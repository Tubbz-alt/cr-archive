<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3 # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
   4 # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   5 # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   6 # Copyright (C) 2006-2020 Apple Inc. All rights reserved.
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10 # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  11 # Copyright (C) 2012 Ericsson AB. All rights reserved.
  12 # Copyright (C) 2007, 2008, 2009, 2012 Google Inc.
  13 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  14 # Copyright (C) 2015, 2016 Canon Inc. All rights reserved.
  15 #
  16 # This library is free software; you can redistribute it and/or
  17 # modify it under the terms of the GNU Library General Public
  18 # License as published by the Free Software Foundation; either
  19 # version 2 of the License, or (at your option) any later version.
  20 #
  21 # This library is distributed in the hope that it will be useful,
  22 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  23 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24 # Library General Public License for more details.
  25 #
  26 # You should have received a copy of the GNU Library General Public License
  27 # along with this library; see the file COPYING.LIB.  If not, write to
  28 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  29 # Boston, MA 02110-1301, USA.
  30 
  31 
  32 package CodeGeneratorJS;
  33 
  34 use strict;
  35 use constant FileNamePrefix =&gt; &quot;JS&quot;;
  36 use Carp qw&lt;longmess&gt;;
  37 use Data::Dumper;
  38 use Hasher;
  39 
  40 my $codeGenerator;
  41 my $writeDependencies;
  42 
  43 my @headerContentHeader = ();
  44 my @headerContent = ();
  45 my %headerIncludes = ();
  46 my %headerTrailingIncludes = ();
  47 
  48 my @implContentHeader = ();
  49 my @implContent = ();
  50 my %implIncludes = ();
  51 my @depsContent = ();
  52 my $numCachedAttributes = 0;
  53 
  54 my $beginAppleCopyrightForHeaderFiles = &lt;&lt;END;
  55 // ------- Begin Apple Copyright -------
  56 /*
  57  * Copyright (C) 2008 Apple Inc. All rights reserved.
  58  *
  59  * Permission is granted by Apple to use this file to the extent
  60  * necessary to relink with LGPL WebKit files.
  61  *
  62  * No license or rights are granted by Apple expressly or by
  63  * implication, estoppel, or otherwise, to Apple patents and
  64  * trademarks. For the sake of clarity, no license or rights are
  65  * granted by Apple expressly or by implication, estoppel, or otherwise,
  66  * under any Apple patents, copyrights and trademarks to underlying
  67  * implementations of any application programming interfaces (APIs)
  68  * or to any functionality that is invoked by calling any API.
  69  */
  70 
  71 END
  72 my $beginAppleCopyrightForSourceFiles = &lt;&lt;END;
  73 // ------- Begin Apple Copyright -------
  74 /*
  75  * Copyright (C) 2008 Apple Inc. All rights reserved.
  76  *
  77  * No license or rights are granted by Apple expressly or by implication,
  78  * estoppel, or otherwise, to Apple copyrights, patents, trademarks, trade
  79  * secrets or other rights.
  80  */
  81 
  82 END
  83 my $endAppleCopyright   = &lt;&lt;END;
  84 // ------- End Apple Copyright   -------
  85 
  86 END
  87 
  88 # Default .h template
  89 my $headerTemplate = &lt;&lt; &quot;EOF&quot;;
  90 /*
  91     This file is part of the WebKit open source project.
  92     This file has been generated by generate-bindings.pl. DO NOT MODIFY!
  93 
  94     This library is free software; you can redistribute it and/or
  95     modify it under the terms of the GNU Library General Public
  96     License as published by the Free Software Foundation; either
  97     version 2 of the License, or (at your option) any later version.
  98 
  99     This library is distributed in the hope that it will be useful,
 100     but WITHOUT ANY WARRANTY; without even the implied warranty of
 101     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 102     Library General Public License for more details.
 103 
 104     You should have received a copy of the GNU Library General Public License
 105     along with this library; see the file COPYING.LIB.  If not, write to
 106     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 107     Boston, MA 02110-1301, USA.
 108 */
 109 EOF
 110 
 111 sub assert
 112 {
 113     my $message = shift;
 114 
 115     my $mess = longmess();
 116     print Dumper($mess);
 117 
 118     die $message;
 119 }
 120 
 121 # Default constructor
 122 sub new
 123 {
 124     my $object = shift;
 125     my $reference = { };
 126 
 127     $codeGenerator = shift;
 128     $writeDependencies = shift;
 129 
 130     bless($reference, $object);
 131     return $reference;
 132 }
 133 
 134 sub GenerateEnumeration
 135 {
 136     my ($object, $enumeration) = @_;
 137 
 138     my $className = GetEnumerationClassName($enumeration-&gt;type);
 139     $object-&gt;GenerateEnumerationHeader($enumeration, $className);
 140     $object-&gt;GenerateEnumerationImplementation($enumeration, $className);
 141 }
 142 
 143 sub GenerateDictionary
 144 {
 145     my ($object, $dictionary, $enumerations, $otherDictionaries) = @_;
 146 
 147     my $className = GetDictionaryClassName($dictionary-&gt;type);
 148     $object-&gt;GenerateDictionaryHeader($dictionary, $className, $enumerations, $otherDictionaries);
 149     $object-&gt;GenerateDictionaryImplementation($dictionary, $className, $enumerations, $otherDictionaries);
 150 }
 151 
 152 sub GenerateCallbackFunction
 153 {
 154     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
 155 
 156     $object-&gt;GenerateCallbackFunctionHeader($callbackFunction, $enumerations, $dictionaries);
 157     $object-&gt;GenerateCallbackFunctionImplementation($callbackFunction, $enumerations, $dictionaries);
 158 }
 159 
 160 sub GenerateInterface
 161 {
 162     my ($object, $interface, $defines, $enumerations, $dictionaries) = @_;
 163 
 164     $codeGenerator-&gt;LinkOverloadedOperations($interface);
 165 
 166     AddStringifierOperationIfNeeded($interface);
 167     AddLegacyCallerOperationIfNeeded($interface);
 168 
 169     if ($interface-&gt;isCallback) {
 170         $object-&gt;GenerateCallbackInterfaceHeader($interface, $enumerations, $dictionaries);
 171         $object-&gt;GenerateCallbackInterfaceImplementation($interface, $enumerations, $dictionaries);
 172     } else {
 173         $object-&gt;GenerateHeader($interface, $enumerations, $dictionaries);
 174         $object-&gt;GenerateImplementation($interface, $enumerations, $dictionaries);
 175     }
 176 }
 177 
 178 sub AddStringifierOperationIfNeeded
 179 {
 180     my $interface = shift;
 181 
 182     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 183         next unless $property-&gt;isStringifier;
 184 
 185         if (ref($property) eq &quot;IDLAttribute&quot;) {
 186             assert(&quot;stringifier can only be used on attributes with type DOMString or USVString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot; || $property-&gt;type-&gt;name eq &quot;USVString&quot;;
 187         }
 188 
 189         if (ref($property) eq &quot;IDLOperation&quot;) {
 190             assert(&quot;stringifier can only be used on operations with a return type of DOMString&quot;) unless $property-&gt;type-&gt;name eq &quot;DOMString&quot;;
 191             assert(&quot;stringifier can only be used on operations with zero arguments&quot;) unless scalar(@{$property-&gt;arguments}) == 0;
 192 
 193             # Don&#39;t duplicate the operation if it was declared with the name &#39;toString&#39;.
 194             return if $property-&gt;name eq &quot;toString&quot;;
 195         }
 196 
 197         my $stringifier = IDLOperation-&gt;new();
 198         $stringifier-&gt;name(&quot;toString&quot;);
 199         $stringifier-&gt;type(IDLParser::cloneType($property-&gt;type));
 200         $stringifier-&gt;isStringifier(1);
 201 
 202         IDLParser::copyExtendedAttributes($stringifier-&gt;extendedAttributes, $property-&gt;extendedAttributes);
 203 
 204         if ($property-&gt;name &amp;&amp; !$stringifier-&gt;extendedAttributes-&gt;{ImplementedAs}) {
 205             $stringifier-&gt;extendedAttributes-&gt;{ImplementedAs} = $property-&gt;name;
 206         }
 207 
 208         # If the stringifier was declared as read-write attribute and had [CEReactions], we need to remove
 209         # it from the operation, as the operation should act like attribute getter, which doesn&#39;t respect
 210         # [CEReactions].
 211         if (ref($property) eq &quot;IDLAttribute&quot; &amp;&amp; !$property-&gt;isReadOnly &amp;&amp; $stringifier-&gt;extendedAttributes-&gt;{CEReactions}) {
 212              delete $stringifier-&gt;extendedAttributes-&gt;{CEReactions};
 213         }
 214 
 215         push(@{$interface-&gt;operations}, $stringifier);
 216         return;
 217     }
 218 }
 219 
 220 sub AddLegacyCallerOperationIfNeeded
 221 {
 222     my $interface = shift;
 223 
 224     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
 225         my $isLegacyCaller = grep { $_ eq &quot;legacycaller&quot; } @{$operation-&gt;specials};
 226         if ($isLegacyCaller) {
 227             $interface-&gt;{LegacyCallers} = [] if !exists $interface-&gt;{LegacyCallers};
 228 
 229             my $clonedOperation = IDLParser::cloneOperation($operation);
 230             push(@{$interface-&gt;{LegacyCallers}}, $clonedOperation);
 231     
 232             $clonedOperation-&gt;{overloads} = $interface-&gt;{LegacyCallers};
 233             $clonedOperation-&gt;{overloadIndex} = @{$interface-&gt;{LegacyCallers}};
 234         }
 235     }
 236 }
 237 
 238 sub EventHandlerAttributeEventName
 239 {
 240     my $attribute = shift;
 241     my $eventType = $attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name;
 242 
 243     # Remove the &quot;on&quot; prefix.
 244     $eventType = substr($eventType, 2);
 245 
 246     return &quot;eventNames().${eventType}Event&quot;;
 247 }
 248 
 249 sub GetParentClassName
 250 {
 251     my $interface = shift;
 252 
 253     return $interface-&gt;extendedAttributes-&gt;{JSLegacyParent} if $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
 254     return &quot;JSDOMObject&quot; unless NeedsImplementationClass($interface);
 255     return &quot;JSDOMWrapper&lt;&quot; . GetImplClassName($interface) . &quot;&gt;&quot; unless $interface-&gt;parentType;
 256     return &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
 257 }
 258 
 259 sub GetCallbackClassName
 260 {
 261     my $className = shift;
 262 
 263     return &quot;JS$className&quot;;
 264 }
 265 
 266 sub GetExportMacroForJSClass
 267 {
 268     my $interface = shift;
 269 
 270     return $interface-&gt;extendedAttributes-&gt;{ExportMacro} . &quot; &quot; if $interface-&gt;extendedAttributes-&gt;{ExportMacro};
 271     return &quot;&quot;;
 272 }
 273 
 274 sub AddIncludesForImplementationTypeInImpl
 275 {
 276     my $implementationType = shift;
 277     
 278     AddIncludesForImplementationType($implementationType, \%implIncludes);
 279 }
 280 
 281 sub AddIncludesForImplementationTypeInHeader
 282 {
 283     my $implementationType = shift;
 284     
 285     AddIncludesForImplementationType($implementationType, \%headerIncludes);
 286 }
 287 
 288 sub AddIncludesForImplementationType
 289 {
 290     my ($implementationType, $includesRef) = @_;
 291 
 292     $includesRef-&gt;{&quot;${implementationType}.h&quot;} = 1;
 293 }
 294 
 295 sub AddToImplIncludesForIDLType
 296 {
 297     my ($type, $conditional) = @_;
 298 
 299     return AddToIncludesForIDLType($type, \%implIncludes, $conditional)
 300 }
 301 
 302 sub AddToIncludesForIDLType
 303 {
 304     my ($type, $includesRef, $conditional) = @_;
 305 
 306     if ($type-&gt;isNullable) {
 307         AddToIncludes(&quot;JSDOMConvertNullable.h&quot;, $includesRef, $conditional);
 308     }
 309 
 310     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
 311         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
 312         if ($overrideTypeName eq &quot;IDLIDBKey&quot;) {
 313             AddToIncludes(&quot;JSDOMConvertIndexedDB.h&quot;, $includesRef, $conditional);
 314             return;
 315         }
 316 
 317         if ($overrideTypeName eq &quot;IDLWebGLAny&quot; || $overrideTypeName eq &quot;IDLWebGLExtension&quot;) {
 318             AddToIncludes(&quot;JSDOMConvertWebGL.h&quot;, $includesRef, $conditional);
 319             return;
 320         }
 321     }
 322 
 323     if ($type-&gt;name eq &quot;any&quot;) {
 324         AddToIncludes(&quot;JSDOMConvertAny.h&quot;, $includesRef, $conditional);
 325         return;
 326     }
 327 
 328     if ($type-&gt;name eq &quot;boolean&quot;) {
 329         AddToIncludes(&quot;JSDOMConvertBoolean.h&quot;, $includesRef, $conditional);
 330         return;
 331     }
 332 
 333     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
 334         AddToIncludes(&quot;JSDOMConvertBufferSource.h&quot;, $includesRef, $conditional);
 335         return;
 336     }
 337 
 338     if ($codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsCallbackInterface($type)) {
 339         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 340         AddToIncludes(&quot;JSDOMConvertCallbacks.h&quot;, $includesRef, $conditional);
 341         return;
 342     }
 343 
 344     if ($type-&gt;name eq &quot;Date&quot;) {
 345         AddToIncludes(&quot;JSDOMConvertDate.h&quot;, $includesRef, $conditional);
 346         return;
 347     }
 348 
 349     if ($codeGenerator-&gt;IsExternalDictionaryType($type)) {
 350         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 351         AddToIncludes(&quot;JSDOMConvertDictionary.h&quot;, $includesRef, $conditional);
 352         return;
 353     }
 354 
 355     if ($codeGenerator-&gt;IsExternalEnumType($type)) {
 356         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 357         AddToIncludes(&quot;JSDOMConvertEnumeration.h&quot;, $includesRef, $conditional);
 358         return;
 359     }
 360 
 361     if ($type-&gt;name eq &quot;EventListener&quot;) {
 362         AddToIncludes(&quot;JSEventListener.h&quot;, $includesRef, $conditional);
 363         AddToIncludes(&quot;JSDOMConvertEventListener.h&quot;, $includesRef, $conditional);
 364         return;
 365     }
 366 
 367     if ($codeGenerator-&gt;IsInterfaceType($type)) {
 368         AddToIncludes(&quot;JS&quot; . $type-&gt;name . &quot;.h&quot;, $includesRef, $conditional);
 369         AddToIncludes(&quot;JSDOMConvertInterface.h&quot;, $includesRef, $conditional);
 370         return;
 371     }
 372 
 373     if ($type-&gt;name eq &quot;JSON&quot;) {
 374         AddToIncludes(&quot;JSDOMConvertJSON.h&quot;, $includesRef, $conditional);
 375         return;
 376     }
 377 
 378     if ($codeGenerator-&gt;IsNumericType($type)) {
 379         AddToIncludes(&quot;JSDOMConvertNumbers.h&quot;, $includesRef, $conditional);
 380         return;
 381     }
 382 
 383     if ($type-&gt;name eq &quot;object&quot;) {
 384         AddToIncludes(&quot;JSDOMConvertObject.h&quot;, $includesRef, $conditional);
 385         return;
 386     }
 387 
 388     if ($codeGenerator-&gt;IsPromiseType($type)) {
 389         AddToIncludes(&quot;DOMPromiseProxy.h&quot;, $includesRef, $conditional);
 390         AddToIncludes(&quot;JSDOMConvertPromise.h&quot;, $includesRef, $conditional);
 391 
 392         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 393         return;
 394     }
 395 
 396     if ($codeGenerator-&gt;IsRecordType($type)) {
 397         AddToIncludes(&quot;&lt;wtf/Vector.h&gt;&quot;, $includesRef, $conditional);
 398         AddToIncludes(&quot;JSDOMConvertRecord.h&quot;, $includesRef, $conditional);
 399 
 400         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 401         AddToIncludesForIDLType(@{$type-&gt;subtypes}[1], $includesRef, $conditional);
 402         return;
 403     }
 404 
 405     if ($codeGenerator-&gt;IsSequenceOrFrozenArrayType($type)) {
 406         AddToIncludes(&quot;&lt;JavaScriptCore/JSArray.h&gt;&quot;, $includesRef, $conditional);
 407         AddToIncludes(&quot;JSDOMConvertSequences.h&quot;, $includesRef, $conditional);
 408 
 409         AddToIncludesForIDLType(@{$type-&gt;subtypes}[0], $includesRef, $conditional);
 410         return;
 411     }
 412 
 413     if ($type-&gt;name eq &quot;ScheduledAction&quot;) {
 414         AddToIncludes(&quot;JSDOMConvertScheduledAction.h&quot;, $includesRef, $conditional);
 415         return;
 416     }
 417 
 418     if ($type-&gt;name eq &quot;SerializedScriptValue&quot;) {
 419         AddToIncludes(&quot;SerializedScriptValue.h&quot;, $includesRef, $conditional);
 420         AddToIncludes(&quot;JSDOMConvertSerializedScriptValue.h&quot;, $includesRef, $conditional);
 421         return;
 422     }
 423 
 424     if ($codeGenerator-&gt;IsStringType($type)) {
 425         AddToIncludes(&quot;JSDOMConvertStrings.h&quot;, $includesRef, $conditional);
 426         return;
 427     }
 428 
 429     if ($type-&gt;isUnion) {
 430         AddToIncludes(&quot;&lt;wtf/Variant.h&gt;&quot;, $includesRef, $conditional);
 431         AddToIncludes(&quot;JSDOMConvertUnion.h&quot;, $includesRef, $conditional);
 432 
 433         foreach my $memberType (@{$type-&gt;subtypes}) {
 434             AddToIncludesForIDLType($memberType, $includesRef, $conditional);
 435         }
 436 
 437         return;
 438     }
 439 
 440     if ($type-&gt;name eq &quot;XPathNSResolver&quot;) {
 441         AddToIncludes(&quot;JSXPathNSResolver.h&quot;, $includesRef, $conditional);
 442         AddToIncludes(&quot;JSDOMConvertXPathNSResolver.h&quot;, $includesRef, $conditional);
 443         return;
 444     }
 445 }
 446 
 447 sub AddToImplIncludes
 448 {
 449     my ($header, $conditional) = @_;
 450 
 451     AddToIncludes($header, \%implIncludes, $conditional);
 452 }
 453 
 454 sub AddToIncludes
 455 {
 456     my ($header, $includesRef, $conditional) = @_;
 457 
 458     if (not $conditional) {
 459         $includesRef-&gt;{$header} = 1;
 460     } elsif (not exists($includesRef-&gt;{$header})) {
 461         $includesRef-&gt;{$header} = $conditional;
 462     } else {
 463         my $oldValue = $includesRef-&gt;{$header};
 464         $includesRef-&gt;{$header} = &quot;$oldValue|$conditional&quot; if $oldValue ne 1;
 465     }
 466 }
 467 
 468 sub IsReadonly
 469 {
 470     my $attribute = shift;
 471     return $attribute-&gt;isReadOnly &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{Replaceable} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{PutForwards};
 472 }
 473 
 474 sub AddClassForwardIfNeeded
 475 {
 476     my $type = shift;
 477 
 478     # SVGAnimatedLength/Number/etc. are not classes so they can&#39;t be forward declared as classes.
 479     return if $codeGenerator-&gt;IsSVGAnimatedType($type);
 480     return if $codeGenerator-&gt;IsBufferSourceType($type);
 481 
 482     push(@headerContent, &quot;class &quot; . $type-&gt;name . &quot;;\n\n&quot;);
 483 }
 484 
 485 sub GetGenerateIsReachable
 486 {
 487     my $interface = shift;
 488     return $interface-&gt;extendedAttributes-&gt;{GenerateIsReachable};
 489 }
 490 
 491 sub GetCustomIsReachable
 492 {
 493     my $interface = shift;
 494     return $interface-&gt;extendedAttributes-&gt;{CustomIsReachable};
 495 }
 496 
 497 sub IsDOMGlobalObject
 498 {
 499     my $interface = shift;
 500     return $interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; || $interface-&gt;type-&gt;name eq &quot;RemoteDOMWindow&quot; || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;) || $interface-&gt;type-&gt;name eq &quot;TestGlobalObject&quot;;
 501 }
 502 
 503 sub ShouldUseGlobalObjectPrototype
 504 {
 505     my $interface = shift;
 506 
 507     # For workers, the global object is a DedicatedWorkerGlobalScope.
 508     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;;
 509     # For worklets, the global object is a PaintWorkletGlobalScope.
 510     return 0 if $interface-&gt;type-&gt;name eq &quot;WorkletGlobalScope&quot;;
 511 
 512     return IsDOMGlobalObject($interface);
 513 }
 514 
 515 sub GenerateIndexedGetter
 516 {
 517     my ($interface, $indexedGetterOperation, $indexExpression) = @_;
 518     
 519     # NOTE: This abstractly implements steps 1.2.1 - 1.2.8 of the LegacyPlatformObjectGetOwnProperty
 520     #       algorithm. Returing the conversion expression and attributes expression for use
 521     #       by the caller.
 522     
 523     # 1.2.1 Let operation be the operation used to declare the indexed property getter.
 524     # 1.2.2 Let value be an uninitialized variable.
 525     # 1.2.3 If operation was defined without an identifier, then set value to the result
 526     #       of performing the steps listed in the interface description to determine the
 527     #       value of an indexed property with index as the index.
 528     # 1.2.4 Otherwise, operation was defined with an identifier. Set value to the result
 529     #       of performing the steps listed in the description of operation with index as
 530     #       the only argument value.
 531     # 1.2.5 Let desc be a newly created Property Descriptor with no fields.
 532     # 1.2.6 Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 533     # 1.2.7 If O implements an interface with an indexed property setter, then set
 534     #       desc.[[Writable]] to true, otherwise set it to false.
 535     # 1.2.8 Return desc.
 536     
 537     my @attributes = ();
 538     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetIndexedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 539     
 540     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 541 
 542     my $indexedGetterFunctionName = $indexedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $indexedGetterOperation-&gt;name || &quot;item&quot;;
 543     my $nativeToJSConversion = NativeToJSValueUsingPointers($indexedGetterOperation, $interface, &quot;thisObject-&gt;wrapped().${indexedGetterFunctionName}(${indexExpression})&quot;, &quot;*thisObject-&gt;globalObject()&quot;);
 544     
 545     return ($nativeToJSConversion, $attributeString);
 546 }
 547 
 548 sub GenerateNamedGetter
 549 {
 550     my ($interface, $namedGetterOperation, $namedPropertyExpression) = @_;
 551     
 552     # NOTE: This abstractly implements steps 2.1 - 2.10 of the LegacyPlatformObjectGetOwnProperty
 553     #       algorithm. Returing the conversion expression and attributes expression for use
 554     #       by the caller.
 555     
 556     # 2.1  Let operation be the operation used to declare the named property getter.
 557     # 2.2  Let value be an uninitialized variable.
 558     # 2.3  If operation was defined without an identifier, then set value to the result
 559     #      of performing the steps listed in the interface description to determine the
 560     #      value of a named property with P as the name.
 561     # 2.4  Otherwise, operation was defined with an identifier. Set value to the result
 562     #      of performing the steps listed in the description of operation with P as the
 563     #      only argument value..
 564     # 2.5  Let desc be a newly created Property Descriptor with no fields.
 565     # 2.6  Set desc.[[Value]] to the result of converting value to an ECMAScript value.
 566     # 2.7  If O implements an interface with a named property setter, then set desc.[[Writable]]
 567     #      to true, otherwise set it to false.
 568     # 2.8  If O implements an interface with the [LegacyUnenumerableNamedProperties]
 569     #      extended attribute, then set desc.[[Enumerable]] to false, otherwise set it
 570     #      to true.
 571     # 2.9  Set desc.[[Configurable]] to true.
 572     # 2.10 Return desc.
 573     
 574     my @attributes = ();
 575     push(@attributes, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if !GetNamedSetterOperation($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin};
 576     push(@attributes, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties};
 577     
 578     my $attributeString = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@attributes &gt; 0) ? join(&quot; | &quot;, @attributes) : &quot;0&quot;) . &quot;)&quot;;
 579     my $nativeToJSConversion = NativeToJSValueUsingPointers($namedGetterOperation, $interface, $namedPropertyExpression, &quot;*thisObject-&gt;globalObject()&quot;);
 580     
 581     return ($nativeToJSConversion, $attributeString);
 582 }
 583 
 584 sub GenerateNamedGetterLambda
 585 {
 586     my ($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, $IDLType) = @_;
 587     
 588     # NOTE: Named getters are little odd. To avoid doing duplicate lookups (once when checking if
 589     #       the property name is a &#39;supported property name&#39; and once to get the value) we signal
 590     #       that a property is supported by whether or not it is &#39;null&#39; (where what null means is
 591     #       dependant on the IDL type). This is based on the assumption that no named getter will
 592     #       ever actually want to return null as an actual return value, which seems like an ok
 593     #       assumption to make (should it turn out this doesn&#39;t hold in the future, we have lots
 594     #       of options; do two lookups, add an extra layer of Optional, etc.).
 595     
 596     my $resultType = &quot;typename ${IDLType}::ImplementationType&quot;;
 597     $resultType = &quot;ExceptionOr&lt;&quot; . $resultType . &quot;&gt;&quot; if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 598     my $returnType = &quot;Optional&lt;&quot; . $resultType . &quot;&gt;&quot;;
 599 
 600     push(@$outputArray, &quot;    auto getterFunctor = [] (auto&amp; thisObject, auto propertyName) -&gt; ${returnType} {\n&quot;);
 601 
 602     my @arguments = GenerateCallWithUsingReferences($namedGetterOperation-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;WTF::nullopt&quot;, &quot;thisObject&quot;, &quot;        &quot;);
 603     push(@arguments, &quot;propertyNameToAtomString(propertyName)&quot;);
 604 
 605     push(@$outputArray, &quot;        auto result = thisObject.wrapped().${namedGetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;);\n&quot;);
 606     
 607     if ($namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) {
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
 624     my ($outputArray, $interface, $className) = @_;
 625     
 626     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 627     
 628     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);
 629     push(@$outputArray, &quot;{\n&quot;);
 630     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 631     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 632     
 633     my $namedGetterOperation = GetNamedGetterOperation($interface);
 634     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 635     
 636     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 637         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
 638     }
 639     
 640     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 641     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 642     
 643     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 644     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 645     
 646     # 1. If O supports indexed properties and P is an array index property name, then:
 647     if ($indexedGetterOperation) {
 648         # 1.1. Let index be the result of calling ToUint32(P).
 649         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 650         
 651         # 1.2. If index is a supported property index, then:
 652         # FIXME: This should support non-contiguous indices.
 653         push(@$outputArray, &quot;        if (index.value() &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 654         
 655         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 656         
 657         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index.value()&quot;);
 658         
 659         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 660         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 661         
 662         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 663         push(@$outputArray, &quot;            return true;\n&quot;);
 664         
 665         push(@$outputArray, &quot;        }\n&quot;);
 666         
 667         # 1.3. Set ignoreNamedProps to true.
 668         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 669         #       rather than going through the paces of having an actual ignoreNamedProps update.
 670         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 671             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);
 672         }
 673         push(@$outputArray, &quot;    }\n&quot;);
 674     }
 675     
 676     # 2. If O supports named properties, the result of running the named property visibility
 677     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 678     if ($namedGetterOperation) {
 679         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 680         #       to true, due to the early return in step 1.3
 681         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 682                 
 683         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 684         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 685         
 686         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 687         
 688         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 689         
 690         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 691         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 692         
 693         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 694         
 695         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 696         
 697         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 698         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 699         
 700         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 701         push(@$outputArray, &quot;        return true;\n&quot;);
 702         push(@$outputArray, &quot;    }\n&quot;);
 703     }
 704 
 705     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 706         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 707         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);
 708         push(@$outputArray, &quot;        return true;\n&quot;);
 709     }
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
 731         $didGeneratePropertyName = 1;
 732     };
 733     
 734     my $namedGetterOperation = GetNamedGetterOperation($interface);
 735     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 736     
 737     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* lexicalGlobalObject, unsigned index, PropertySlot&amp; slot)\n&quot;);
 738     push(@$outputArray, &quot;{\n&quot;);
 739     if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 740         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
 741     }
 742     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 743     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 744     
 745     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 746         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
 747     }
 748     
 749     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 750     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 751     
 752     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 753     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 754     
 755     # 1. If O supports indexed properties and P is an array index property name, then:
 756     if ($indexedGetterOperation) {
 757         # 1.1. Let index be the result of calling ToUint32(P).
 758         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 759         
 760         # 1.2. If index is a supported property index, then:
 761         # FIXME: This should support non-contiguous indices.
 762         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 763         
 764         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 765         
 766         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
 767         
 768         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 769         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 770         
 771         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 772         push(@$outputArray, &quot;            return true;\n&quot;);
 773         
 774         push(@$outputArray, &quot;        }\n&quot;);
 775         
 776         # 1.3. Set ignoreNamedProps to true.
 777         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 778         #       rather than going through the paces of having an actual ignoreNamedProps update.
 779         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
 780             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);
 781         }
 782         push(@$outputArray, &quot;    }\n&quot;);
 783     }
 784     
 785     # 2. If O supports named properties, the result of running the named property visibility
 786     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 787     if ($namedGetterOperation) {
 788         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 789         #       to true, due to the early return in step 1.3
 790         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 791                 
 792         &amp;$propertyNameGeneration();
 793         
 794         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 795         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 796         
 797         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 798         
 799         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 800         
 801         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
 802         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);
 803         
 804         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 805         
 806         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 807 
 808         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 809         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 810         
 811         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 812         push(@$outputArray, &quot;        return true;\n&quot;);
 813         push(@$outputArray, &quot;    }\n&quot;);
 814     }
 815     
 816     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 817         &amp;$propertyNameGeneration();
 818 
 819         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 820         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);
 821         push(@$outputArray, &quot;        return true;\n&quot;);
 822     }
 823 
 824     # 3. Return OrdinaryGetOwnProperty(O, P).
 825     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);
 826     
 827     push(@$outputArray, &quot;}\n\n&quot;);
 828 }
 829 
 830 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 831 sub GenerateGetOwnPropertyNames
 832 {
 833     my ($outputArray, $interface, $className) = @_;
 834     
 835     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 836     
 837     my $namedGetterOperation = GetNamedGetterOperation($interface);
 838     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 839     
 840     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);
 841     push(@$outputArray, &quot;{\n&quot;);
 842     if ($indexedGetterOperation || $namedGetterOperation) {
 843         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
 844     }
 845     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 846     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 847     
 848     # 1. If the object supports indexed properties, then the object’s supported
 849     #    property indices are enumerated first, in numerical order.
 850     # FIXME: This should support non-contiguous indices.
 851     if ($indexedGetterOperation) {
 852         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
 853         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(vm, i));\n&quot;);
 854     }
 855 
 856     # 2. If the object supports named properties and doesn’t implement an interface
 857     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 858     #    object’s supported property names that are visible according to the named
 859     #    property visibility algorithm are enumerated next, in the order given in
 860     #    the definition of the set of supported property names.
 861     if ($namedGetterOperation) {
 862         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 863             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 864             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 865         } else {
 866             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 867             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 868             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 869             push(@$outputArray, &quot;    }\n&quot;);
 870         }
 871     }
 872     
 873     # 3. Finally, any enumerable own properties or properties from the object’s
 874     #    prototype chain are then enumerated, in no defined order.
 875     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, lexicalGlobalObject, propertyNames, mode);\n&quot;);
 876     push(@$outputArray, &quot;}\n\n&quot;);
 877 }
 878 
 879 # https://heycam.github.io/webidl/#invoke-indexed-setter
 880 sub GenerateInvokeIndexedPropertySetter
 881 {
 882     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 883     
 884     # The second argument of the indexed setter operation is the argument being converted.
 885     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
 886     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 887     
 888     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
 889     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 890     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 891     
 892     my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
 893     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 894     my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
 895     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);
 896     
 897     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 898 }
 899 
 900 # https://heycam.github.io/webidl/#invoke-named-setter
 901 sub GenerateInvokeNamedPropertySetter
 902 {
 903     my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
 904     
 905     my $argument = @{$namedSetterOperation-&gt;arguments}[1];
 906     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);
 907     
 908     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
 909     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 910     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 911 
 912     push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 913 
 914     my $namedSetterFunctionName = $namedSetterOperation-&gt;name || &quot;setNamedItem&quot;;
 915     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 916 
 917     my @arguments = ();
 918     push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
 919     push(@arguments, $nativeValuePassExpression);
 920     push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 921 
 922     my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
 923     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);
 924 
 925     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 926 }
 927 
 928 sub GeneratePut
 929 {
 930     my ($outputArray, $interface, $className) = @_;
 931     
 932     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
 933     
 934     my $namedSetterOperation = GetNamedSetterOperation($interface);
 935     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
 936     
 937     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);
 938     push(@$outputArray, &quot;{\n&quot;);
 939     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
 940     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
 941 
 942     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
 943         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
 944     if ($namedSetterOperation) {
 945         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);
 946     }
 947     if ($indexedSetterOperation) {
 948         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);
 949     }
 950     
 951     if ($indexedSetterOperation) {
 952         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 953         
 954         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;value&quot;);
 955         
 956         push(@$outputArray, &quot;        return true;\n&quot;);
 957         push(@$outputArray, &quot;    }\n\n&quot;);
 958     }
 959     
 960     if ($namedSetterOperation) {
 961         # FIMXE: We need a more comprehensive story for Symbols.
 962         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
 963         
 964         my $additionalIndent = &quot;&quot;;
 965         
 966         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
 967         if (!$overrideBuiltins) {
 968             push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
 969             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(JSC::getVM(lexicalGlobalObject));\n&quot;);
 970             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);
 971             $additionalIndent .= &quot;    &quot;;
 972         }
 973 
 974         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
 975         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
 976             push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
 977             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);
 978         }
 979         push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
 980 
 981         if (!$overrideBuiltins) {
 982             push(@$outputArray, &quot;        }\n&quot;);
 983         }
 984         
 985         push(@$outputArray, &quot;    }\n\n&quot;);
 986     }
 987     
 988     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
 989     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 990         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 991 
 992         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
 993         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);
 994         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
 995     }
 996 
 997     push(@$outputArray, &quot;    return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);
 998     push(@$outputArray, &quot;}\n\n&quot;);
 999 }
1000 
1001 sub GeneratePutByIndex
1002 {
1003     my ($outputArray, $interface, $className) = @_;
1004     
1005     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1006 
1007     my $namedSetterOperation = GetNamedSetterOperation($interface);
1008     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1009     
1010     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1011     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1012     
1013     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);
1014     push(@$outputArray, &quot;{\n&quot;);
1015     if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
1016         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
1017     }
1018     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1019     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1020 
1021     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1022         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1023     if ($namedSetterOperation) {
1024         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1025     }
1026     if ($indexedSetterOperation) {
1027         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1028     }
1029     
1030     if ($indexedSetterOperation) {
1031         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1032         
1033         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1034         
1035         push(@$outputArray, &quot;        return true;\n&quot;);
1036         push(@$outputArray, &quot;    }\n\n&quot;);
1037     }
1038     
1039     if ($namedSetterOperation) {
1040         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1041                 
1042         my $additionalIndent = &quot;&quot;;
1043         if (!$overrideBuiltins) {
1044             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1045             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);
1046             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);
1047             $additionalIndent .= &quot;    &quot;;
1048         }
1049         
1050         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1051         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1052             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1053             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);
1054         }
1055         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1056         
1057         if (!$overrideBuiltins) {
1058             push(@$outputArray, &quot;    }\n\n&quot;);
1059         }
1060     }
1061 
1062     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1063     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1064         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
1065         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1066         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1067         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
1068         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);
1069         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1070     }
1071 
1072     if (!$ellidesCallsToBase) {
1073         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);
1074     }
1075     
1076     push(@$outputArray, &quot;}\n\n&quot;);
1077 }
1078 
1079 sub GenerateIsUnforgeablePropertyName
1080 {
1081     my ($outputArray, $interface) = @_;
1082     
1083     my @unforgeablePropertyNames = ();
1084     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1085         next if $property-&gt;isStatic;
1086         
1087         if (IsUnforgeable($interface, $property)) {
1088             push(@unforgeablePropertyNames, $property-&gt;name);
1089         }
1090     }
1091     
1092     return 0 if (scalar(@unforgeablePropertyNames) == 0);
1093     
1094     my $condition = join(&quot; || &quot;, map { &quot;propertyName == \&quot;&quot; . $_ . &quot;\&quot;&quot; } @unforgeablePropertyNames);
1095     
1096     push(@$outputArray, &quot;static bool isUnforgeablePropertyName(PropertyName propertyName)\n&quot;);
1097     push(@$outputArray, &quot;{\n&quot;);
1098     push(@$outputArray, &quot;    return ${condition};\n&quot;);
1099     push(@$outputArray, &quot;}\n\n&quot;);
1100     
1101     return 1;
1102 }
1103 
1104 # https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
1105 sub GenerateDefineOwnProperty
1106 {
1107     my ($outputArray, $interface, $className) = @_;
1108     
1109     return if $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty};
1110     
1111     my $namedSetterOperation = GetNamedSetterOperation($interface);
1112     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1113     
1114     return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
1115     
1116     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);
1117     push(@$outputArray, &quot;{\n&quot;);
1118     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
1119     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1120 
1121     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1122         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1123     if ($namedSetterOperation) {
1124         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1125     }
1126     if ($indexedSetterOperation) {
1127         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);
1128     }
1129     
1130     # 1. If O supports indexed properties and P is an array index property name, then:
1131     if (GetIndexedGetterOperation($interface)) {
1132         # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
1133         # is no indexed property setter.
1134 
1135         if (!$indexedSetterOperation) {
1136             # 2. If O does not implement an interface with an indexed property setter, then return false.
1137             push(@$outputArray, &quot;    if (parseIndex(propertyName))\n&quot;);
1138             push(@$outputArray, &quot;        return false;\n\n&quot;);
1139         } else {
1140             push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
1141 
1142             # 1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1143             push(@$outputArray, &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1144             push(@$outputArray, &quot;            return false;\n&quot;);
1145             
1146             # 3. Invoke the indexed property setter with P and Desc.[[Value]].
1147             GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;propertyDescriptor.value()&quot;);
1148             
1149             # 4. Return true.
1150             push(@$outputArray, &quot;        return true;\n&quot;);
1151             push(@$outputArray, &quot;    }\n\n&quot;);
1152         }
1153     }
1154     
1155     # 2. If O supports named properties, O does not implement an interface with the [Global]
1156     #    extended attribute and P is not an unforgeable property name of O, then:
1157     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalInterface($interface)) {
1158         # FIMXE: We need a more comprehensive story for Symbols.
1159         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
1160         
1161         my $additionalIndent = &quot;&quot;;
1162         
1163         my $hasUnforgableProperties = GenerateIsUnforgeablePropertyName($outputArray, $interface);
1164         if ($hasUnforgableProperties) {
1165             push(@$outputArray, &quot;        if (!isUnforgeablePropertyName(propertyName)) {\n&quot;);
1166             $additionalIndent .= &quot;    &quot;;
1167         }
1168         
1169         # 1. Let creating be true if P is not a supported property name, and false otherwise.
1170         # NOTE: This step is strength reduced into the only use of &#39;creating&#39; in step 2.2.1
1171         
1172         # 2. If O implements an interface with the [OverrideBuiltins] extended attribute or O
1173         #    does not have an own property named P, then:
1174         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1175         if (!$overrideBuiltins) {
1176             # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
1177             #        only look at the actual properties, and not call into our implementation of the
1178             #        [[GetOwnProperty]] hook?
1179             push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1180             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot)) {\n&quot;);
1181             $additionalIndent .= &quot;    &quot;;
1182         }
1183         if (!$namedSetterOperation) {
1184             # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
1185             push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
1186             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1187         } else {
1188             # 2.2. If O implements an interface with a named property setter, then:
1189             
1190             # 2.2.1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1191             push(@$outputArray, $additionalIndent . &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1192             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1193             
1194             # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
1195             GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
1196             if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1197                 push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
1198                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, propertyDescriptor, shouldThrow);\n&quot;);
1199             }
1200             # 2.2.3. Return true.
1201             push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
1202         }
1203         
1204         if (!$overrideBuiltins) {
1205             push(@$outputArray, $additionalIndent . &quot;    }\n&quot;);
1206         }
1207         
1208         if ($hasUnforgableProperties) {
1209             push(@$outputArray, &quot;        }\n&quot;);
1210         }
1211         
1212         # Close the !propertyName.isSymbol() condition.
1213         push(@$outputArray, &quot;    }\n\n&quot;);
1214     }
1215     
1216     push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
1217         
1218     # 3. If O does not implement an interface with the [Global] extended attribute,
1219     #    then set Desc.[[Configurable]] to true.
1220     if (!IsGlobalInterface($interface)) {
1221         push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
1222     }
1223     
1224     # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
1225     # FIXME: Does this do the same thing?
1226     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);
1227     
1228     push(@$outputArray, &quot;}\n\n&quot;);
1229 }
1230 
1231 sub GenerateDeletePropertyCommon
1232 {
1233     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1234     
1235     # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
1236     # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
1237 
1238     # 2. If O supports named properties, O does not implement an interface with the
1239     #    [Global] extended attribute and the result of calling the named
1240     #    property visibility algorithm with property name P and object O is true, then:
1241     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1242     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);
1243 
1244     AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
1245     my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
1246     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, thisObject, propertyName)) {\n&quot;);
1247 
1248     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;);
1249 
1250     # 2.1. If O does not implement an interface with a named property deleter, then return false.
1251     # 2.2. Let operation be the operation used to declare the named property deleter.
1252     # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
1253 
1254     # 2.3. If operation was defined without an identifier, then:
1255     #      1. Perform the steps listed in the interface description to delete an existing named
1256     #         property with P as the name.
1257     #      2. If the steps indicated that the deletion failed, then return false.
1258     # 2.4. Otherwise, operation was defined with an identifier:
1259     #      1. Perform the steps listed in the description of operation with P as the only argument
1260     #         value.
1261     #      2. If operation was declared with a return type of boolean and the steps returned false,
1262     #         then return false.
1263 
1264     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;deleteNamedProperty&quot;;
1265     my $functionCall = &quot;impl.&quot; . $functionImplementationName . &quot;(propertyNameToString(propertyName))&quot;;
1266 
1267     # NOTE: We expect the implementation function of named deleters without an identifier to
1268     #       return either bool or ExceptionOr&lt;bool&gt;. the implementation function of named deleters
1269     #       with an identifier have no restriction, but if the return value of the operation is
1270     #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
1271 
1272     if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
1273         push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
1274         push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
1275         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);
1276         push(@$outputArray, &quot;            propagateException(*lexicalGlobalObject, throwScope, result.releaseException());\n&quot;);
1277         push(@$outputArray, &quot;            return true;\n&quot;);
1278         push(@$outputArray, &quot;        }\n\n&quot;);
1279 
1280         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1281             push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
1282         } else {
1283             push(@$outputArray, &quot;        return true;\n&quot;);
1284         }
1285     } else {
1286         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1287             push(@$outputArray, &quot;        return ${functionCall};\n&quot;);
1288         } else {
1289             push(@$outputArray, &quot;        ${functionCall};\n&quot;);
1290             push(@$outputArray, &quot;        return true;\n&quot;);
1291         }
1292     }
1293 
1294     push(@$outputArray, &quot;    }\n&quot;);
1295 }
1296 
1297 sub GenerateDeleteProperty
1298 {
1299     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1300 
1301     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1302     # for the deleteProperty override hook.
1303 
1304     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)\n&quot;);
1305     push(@$outputArray, &quot;{\n&quot;);
1306 
1307     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1308     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1309 
1310     # 1. If O supports indexed properties and P is an array index property name, then:
1311     #    1. Let index be the result of calling ToUint32(P).
1312     #    2. If index is not a supported property index, then return true.
1313     #    3. Return false.
1314     if (GetIndexedGetterOperation($interface)) {
1315         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName))\n&quot;);
1316         push(@$outputArray, &quot;        return !impl.isSupportedPropertyIndex(index.value());\n&quot;);
1317     }
1318 
1319     # GenerateDeletePropertyCommon implements step 2.
1320     GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1321 
1322     # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
1323     # the remained of the algorithm ourselves.
1324     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, lexicalGlobalObject, propertyName);\n&quot;);
1325     push(@$outputArray, &quot;}\n\n&quot;);
1326 }
1327 
1328 sub GenerateDeletePropertyByIndex
1329 {
1330     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1331 
1332     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1333     # for the deletePropertyByIndex override hook.
1334 
1335     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index)\n&quot;);
1336     push(@$outputArray, &quot;{\n&quot;);
1337 
1338     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1339     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1340 
1341     # 1. If O supports indexed properties and P is an array index property name, then:
1342     #    1. Let index be the result of calling ToUint32(P).
1343     #    2. If index is not a supported property index, then return true.
1344     #    3. Return false.
1345 
1346     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1347     #       is all that needs to be done, no need to generate the .
1348 
1349     if (GetIndexedGetterOperation($interface)) {
1350         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1351     } else {
1352         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
1353         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1354 
1355         # GenerateDeletePropertyCommon implements step 2.
1356         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1357 
1358         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1359         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1360         
1361         # 3. If O has an own property with name P, then:
1362         #    1. If the property is not configurable, then return false.
1363         #    2. Otherwise, remove the property from O.
1364         # 3. Return true.
1365         
1366         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, lexicalGlobalObject, index);\n&quot;);
1367     }
1368 
1369     push(@$outputArray, &quot;}\n\n&quot;);
1370 }
1371 
1372 
1373 sub GenerateNamedDeleterDefinition
1374 {
1375     my ($outputArray, $interface, $className) = @_;
1376     
1377     return if $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty};
1378 
1379     my $namedDeleterOperation = GetNamedDeleterOperation($interface);
1380     
1381     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
1382     # the deleteProperty and deletePropertyByIndex override hooks.
1383 
1384     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
1385     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);
1386 
1387     my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
1388     if ($conditional) {
1389         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1390         push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
1391     }
1392 
1393     GenerateDeleteProperty($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1394     GenerateDeletePropertyByIndex($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1395 
1396     push(@implContent, &quot;#endif\n\n&quot;) if $conditional;
1397 }
1398 
1399 sub GenerateHeaderContentHeader
1400 {
1401     my $interface = shift;
1402     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1403 
1404     my @headerContentHeader;
1405     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1406         @headerContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForHeaderFiles);
1407     } else {
1408         @headerContentHeader = split(&quot;\r&quot;, $headerTemplate);
1409     }
1410 
1411     push(@headerContentHeader, &quot;\n#pragma once\n\n&quot;);
1412 
1413     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1414     push(@headerContentHeader, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
1415     return @headerContentHeader;
1416 }
1417 
1418 sub GenerateImplementationContentHeader
1419 {
1420     my $interface = shift;
1421     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1422 
1423     my @implContentHeader;
1424     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
1425         @implContentHeader = split(&quot;\r&quot;, $beginAppleCopyrightForSourceFiles);
1426     } else {
1427         @implContentHeader = split(&quot;\r&quot;, $headerTemplate);
1428     }
1429 
1430     push(@implContentHeader, &quot;\n#include \&quot;config.h\&quot;\n&quot;);
1431     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
1432     push(@implContentHeader, &quot;\n#if ${conditionalString}\n\n&quot;) if $conditionalString;
1433     push(@implContentHeader, &quot;#include \&quot;$className.h\&quot;\n\n&quot;);
1434     return @implContentHeader;
1435 }
1436 
1437 sub NeedsImplementationClass
1438 {
1439     my ($interface) = @_;
1440 
1441     return 0 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
1442     return 1;
1443 }
1444 
1445 sub ShouldGenerateToWrapped
1446 {
1447     my ($hasParent, $interface) = @_;
1448 
1449     return 0 if not NeedsImplementationClass($interface);
1450     return 1 if !$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
1451     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1452     return 0;
1453 }
1454 
1455 sub ShouldGenerateWrapperOwnerCode
1456 {
1457     my ($hasParent, $interface) = @_;
1458 
1459     return 0 if not NeedsImplementationClass($interface);
1460     return 1 if !$hasParent;
1461     return 1 if GetGenerateIsReachable($interface);
1462     return 1 if GetCustomIsReachable($interface);
1463     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomFinalize};
1464     return 1 if $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;);
1465     return 0;
1466 }
1467 
1468 sub ShouldGenerateToJSDeclaration
1469 {
1470     my ($hasParent, $interface) = @_;
1471 
1472     return 0 if ($interface-&gt;extendedAttributes-&gt;{SuppressToJSObject});
1473     return 0 if not NeedsImplementationClass($interface);
1474     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1475     return 1 if (!$hasParent or $interface-&gt;extendedAttributes-&gt;{JSGenerateToJSObject} or $interface-&gt;extendedAttributes-&gt;{CustomToJSObject});
1476     return 1 if $interface-&gt;parentType &amp;&amp; $interface-&gt;parentType-&gt;name eq &quot;EventTarget&quot;;
1477     return 1 if $interface-&gt;extendedAttributes-&gt;{Constructor} or $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
1478     return 0;
1479 }
1480 
1481 sub ShouldGenerateToJSImplementation
1482 {
1483     my ($hasParent, $interface) = @_;
1484 
1485     return 0 if not ShouldGenerateToJSDeclaration($hasParent, $interface);
1486     return 1 if not $interface-&gt;extendedAttributes-&gt;{CustomToJSObject};
1487     return 0;
1488 }
1489 
1490 sub GetTypeNameForDisplayInException
1491 {
1492     my ($type) = @_;
1493 
1494     # FIXME: Add more type specializations.
1495     return &quot;(&quot; . join(&quot; or &quot;, map { $_-&gt;name } GetFlattenedMemberTypes($type)) . &quot;)&quot; if $type-&gt;isUnion;
1496     return $type-&gt;name;
1497 }
1498 
1499 sub GetArgumentExceptionFunction
1500 {
1501     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1502 
1503     my $name = $argument-&gt;name;
1504     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1505     my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
1506 
1507     if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
1508         # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
1509         return &quot;throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;
1510     }
1511 
1512     if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
1513         return &quot;throwArgumentTypeError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;
1514     }
1515 
1516     if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
1517         my $className = GetEnumerationClassName($argument-&gt;type, $interface);
1518         return &quot;throwArgumentMustBeEnumError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;
1519     }
1520 
1521     return undef;
1522 }
1523 
1524 sub GetArgumentExceptionThrower
1525 {
1526     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1527 
1528     my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
1529     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1530 }
1531 
1532 sub GetAttributeExceptionFunction
1533 {
1534     my ($interface, $attribute) = @_;
1535     
1536     my $name = $attribute-&gt;name;
1537     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1538     my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
1539 
1540     if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
1541         return &quot;throwAttributeTypeError(lexicalGlobalObject, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;
1542     }
1543 }
1544 
1545 sub GetAttributeExceptionThrower
1546 {
1547     my ($interface, $attribute) = @_;
1548 
1549     my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
1550     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;
1551 
1552 }
1553 
1554 sub PassArgumentExpression
1555 {
1556     my ($name, $context) = @_;
1557 
1558     my $type = $context-&gt;type;
1559 
1560     return &quot;WTFMove(${name})&quot; if $type-&gt;isNullable;
1561 
1562     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
1563         return &quot;*${name}&quot; if $type-&gt;name eq &quot;ArrayBuffer&quot;;
1564         return &quot;${name}.releaseNonNull()&quot;;
1565     }
1566 
1567     return &quot;${name}.releaseNonNull()&quot; if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type) || ($codeGenerator-&gt;IsPromiseType($type) &amp;&amp; (ref($context) ne &quot;IDLArgument&quot; || !$context-&gt;isOptional));
1568     return &quot;*${name}&quot; if $codeGenerator-&gt;IsWrapperType($type);
1569     return &quot;WTFMove(${name})&quot;;
1570 }
1571 
1572 sub GetAttributeGetterName
1573 {
1574     my ($interface, $className, $attribute) = @_;
1575 
1576     return $codeGenerator-&gt;WK_lcfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1577     return GetJSBuiltinFunctionName($className, $attribute) if IsJSBuiltin($interface, $attribute);
1578     return &quot;js&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1579 }
1580 
1581 sub GetAttributeSetterName
1582 {
1583     my ($interface, $className, $attribute) = @_;
1584 
1585     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst($className) . &quot;Constructor&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) if $attribute-&gt;isStatic;
1586     return &quot;set&quot; . $codeGenerator-&gt;WK_ucfirst(GetJSBuiltinFunctionName($className, $attribute)) if IsJSBuiltin($interface, $attribute);
1587     return &quot;setJS&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) ? &quot;Constructor&quot; : &quot;&quot;);
1588 }
1589 
1590 sub GetFunctionName
1591 {
1592     my ($interface, $className, $operation) = @_;
1593 
1594     return GetJSBuiltinFunctionName($className, $operation) if IsJSBuiltin($interface, $operation);
1595 
1596     my $functionName = $operation-&gt;name;
1597     $functionName = &quot;SymbolIterator&quot; if $functionName eq &quot;[Symbol.Iterator]&quot;;
1598 
1599     my $kind = $operation-&gt;isStatic ? &quot;Constructor&quot; : (OperationShouldBeOnInstance($interface, $operation) ? &quot;Instance&quot; : &quot;Prototype&quot;);
1600     return $codeGenerator-&gt;WK_lcfirst($className) . $kind . &quot;Function&quot; . $codeGenerator-&gt;WK_ucfirst($functionName);
1601 }
1602 
1603 sub GetFullyQualifiedImplementationCallName
1604 {
1605     my ($interface, $property, $implementationName, $implExpression, $conditional) = @_;
1606     
1607     my $implementedBy = $property-&gt;extendedAttributes-&gt;{ImplementedBy};
1608     if ($implementedBy) {
1609         AddToImplIncludes(&quot;${implementedBy}.h&quot;, $conditional);
1610         return &quot;WebCore::${implementedBy}::${implementationName}&quot;;
1611     }
1612     
1613     if ($property-&gt;isStatic || $property-&gt;extendedAttributes-&gt;{Constructor} || $property-&gt;extendedAttributes-&gt;{NamedConstructor}) {
1614         return $interface-&gt;type-&gt;name . &quot;::${implementationName}&quot;;
1615     }
1616     
1617     if ($property-&gt;isMapLike) {
1618         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
1619     }
1620     
1621     if ($property-&gt;isSetLike) {
1622         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToSetLike&quot;;
1623     }
1624 
1625     return &quot;${implExpression}.${implementationName}&quot;;
1626 }
1627 
1628 sub AddAdditionalArgumentsForImplementationCall
1629 {
1630     my ($arguments, $interface, $property, $implExpression, $globalObject, $callFrame, $thisObjectExpression) = @_;
1631     
1632     if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
1633         unshift(@$arguments, $implExpression);
1634     }
1635     
1636     if ($property-&gt;isMapLike or $property-&gt;isSetLike) {
1637         push(@$arguments, $globalObject);
1638         if (ref($property) eq &quot;IDLOperation&quot;) {
1639             push(@$arguments, $callFrame);
1640         }
1641         push(@$arguments, $thisObjectExpression);
1642     }
1643 }
1644 
1645 sub GetSpecialAccessorOperationForType
1646 {
1647     my ($interface, $special, $firstParameterType, $numberOfParameters) = @_;
1648 
1649     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
1650         my $specials = $operation-&gt;specials;
1651         my $specialExists = grep { $_ eq $special } @$specials;
1652         my $arguments = $operation-&gt;arguments;
1653         if ($specialExists and scalar(@$arguments) == $numberOfParameters and $arguments-&gt;[0]-&gt;type-&gt;name eq $firstParameterType) {
1654             return $operation;
1655         }
1656     }
1657 
1658     return 0;
1659 }
1660 
1661 sub IsGlobalInterface
1662 {
1663     my $interface = shift;
1664 
1665     return $interface-&gt;extendedAttributes-&gt;{Global};
1666 }
1667 
1668 sub AttributeShouldBeOnInstance
1669 {
1670     my $interface = shift;
1671     my $attribute = shift;
1672 
1673     return 1 if IsGlobalInterface($interface);
1674     return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1675 
1676     # [Unforgeable] attributes should be on the instance.
1677     # https://heycam.github.io/webidl/#Unforgeable
1678     return 1 if IsUnforgeable($interface, $attribute);
1679 
1680     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
1681         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity};
1682         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter};
1683         return 1;
1684     }
1685 
1686     return 0;
1687 }
1688 
1689 sub IsAlwaysExposedOnInterface
1690 {
1691     my ($interfaceExposures, $contextExposures) = @_;
1692 
1693     my %contextExposureSet = ();
1694 
1695     if (ref($contextExposures) eq &quot;ARRAY&quot;) {
1696         foreach my $contextExposure (@$contextExposures) {
1697             $contextExposureSet{$contextExposure} = 1;
1698         }
1699     } else {
1700         $contextExposureSet{$contextExposures} = 1;
1701     }
1702 
1703     if (ref($interfaceExposures) ne &quot;ARRAY&quot;) {
1704         $interfaceExposures = [$interfaceExposures];
1705     }
1706 
1707     foreach my $interfaceExposure (@$interfaceExposures) {
1708         return 0 unless exists $contextExposureSet{$interfaceExposure};
1709     }
1710 
1711     return 1;
1712 }
1713 
1714 sub NeedsRuntimeCheck
1715 {
1716     my ($interface, $context) = @_;
1717 
1718     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1719         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1720         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1721     }
1722 
1723     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
1724         || $context-&gt;extendedAttributes-&gt;{EnabledForContext}
1725         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1726         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1727         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1728         || $context-&gt;extendedAttributes-&gt;{SecureContext}
1729         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}
1730         || $context-&gt;extendedAttributes-&gt;{CustomEnabled};
1731 }
1732 
1733 # https://heycam.github.io/webidl/#es-operations
1734 sub OperationShouldBeOnInstance
1735 {
1736     my ($interface, $operation) = @_;
1737 
1738     return 1 if IsGlobalInterface($interface);
1739 
1740     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1741     if (IsUnforgeable($interface, $operation)) {
1742         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1743         return 1;
1744     }
1745 
1746     return 0;
1747 }
1748 
1749 sub OperationHasForcedReturnValue
1750 {
1751     my ($operation) = @_;
1752 
1753     foreach my $argument (@{$operation-&gt;arguments}) {
1754         return 1 if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
1755     }
1756     return 0;
1757 }
1758 
1759 sub IsAcceleratedDOMAttribute
1760 {
1761     my ($interface, $attribute) = @_;
1762 
1763     # If we use CustomGetterSetter in IDL code generator we cannot skip type check.
1764     return 0 if NeedsRuntimeCheck($interface, $attribute) and AttributeShouldBeOnInstance($interface, $attribute);
1765     return 0 if $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and AttributeShouldBeOnInstance($interface, $attribute);
1766 
1767     # If the interface has special logic for casting we cannot hoist type check to JSC.
1768     return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
1769     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1770 
1771     return 0 if $attribute-&gt;isStatic;
1772     return 0 if $attribute-&gt;isMapLike;
1773     return 0 if $attribute-&gt;isSetLike;
1774     return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1775     return 0 if IsJSBuiltin($interface, $attribute);
1776     return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
1777     return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
1778     return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1779     return 1;
1780 }
1781 
1782 sub GetJSCAttributesForAttribute
1783 {
1784     my $interface = shift;
1785     my $attribute = shift;
1786 
1787     my @specials = ();
1788     push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
1789 
1790     # As per Web IDL specification, constructor properties on the ECMAScript global object should not be enumerable.
1791     my $isGlobalConstructor = $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1792     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if ($attribute-&gt;extendedAttributes-&gt;{NotEnumerable} || $isGlobalConstructor);
1793     push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
1794     push(@specials, &quot;JSC::PropertyAttribute::CustomAccessor&quot;) unless $isGlobalConstructor or IsJSBuiltin($interface, $attribute);
1795     push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
1796     push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1797     push(@specials, &quot;JSC::PropertyAttribute::Accessor | JSC::PropertyAttribute::Builtin&quot;) if  IsJSBuiltin($interface, $attribute);
1798     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
1799 }
1800 
1801 sub GetIndexedGetterOperation
1802 {
1803     my $interface = shift;
1804     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;unsigned long&quot;, 1);
1805 }
1806 
1807 sub GetIndexedSetterOperation
1808 {
1809     my $interface = shift;
1810     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;unsigned long&quot;, 2);
1811 }
1812 
1813 sub GetNamedGetterOperation
1814 {
1815     my $interface = shift;
1816     return GetSpecialAccessorOperationForType($interface, &quot;getter&quot;, &quot;DOMString&quot;, 1);
1817 }
1818 
1819 sub GetNamedSetterOperation
1820 {
1821     my $interface = shift;
1822     return GetSpecialAccessorOperationForType($interface, &quot;setter&quot;, &quot;DOMString&quot;, 2);
1823 }
1824 
1825 sub GetNamedDeleterOperation
1826 {
1827     my $interface = shift;
1828     return GetSpecialAccessorOperationForType($interface, &quot;deleter&quot;, &quot;DOMString&quot;, 1);
1829 }
1830 
1831 sub InstanceOperationCount
1832 {
1833     my $interface = shift;
1834     my $count = 0;
1835 
1836     foreach my $operation (@{$interface-&gt;operations}) {
1837         $count++ if OperationShouldBeOnInstance($interface, $operation);
1838     }
1839 
1840     return $count;
1841 }
1842 
1843 sub PrototypeOperationCount
1844 {
1845     my $interface = shift;
1846     my $count = 0;
1847 
1848     foreach my $operation (@{$interface-&gt;operations}) {
1849         $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
1850     }
1851 
1852     $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
1853     $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;
1854     $count += scalar @{$interface-&gt;setLike-&gt;operations} if $interface-&gt;setLike;
1855     $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
1856 
1857     return $count;
1858 }
1859 
1860 sub InstancePropertyCount
1861 {
1862     my $interface = shift;
1863     my $count = 0;
1864     foreach my $attribute (@{$interface-&gt;attributes}) {
1865         $count++ if AttributeShouldBeOnInstance($interface, $attribute);
1866     }
1867     $count += InstanceOperationCount($interface);
1868     return $count;
1869 }
1870 
1871 sub PrototypePropertyCount
1872 {
1873     my $interface = shift;
1874     my $count = 0;
1875     foreach my $attribute (@{$interface-&gt;attributes}) {
1876         $count++ if !AttributeShouldBeOnInstance($interface, $attribute);
1877     }
1878     $count += PrototypeOperationCount($interface);
1879     $count++ if NeedsConstructorProperty($interface);
1880     return $count;
1881 }
1882 
1883 sub InstanceOverridesGetOwnPropertySlot
1884 {
1885     my $interface = shift;
1886     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot}
1887         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1888         || GetIndexedGetterOperation($interface)
1889         || GetNamedGetterOperation($interface);
1890 }
1891 
1892 sub InstanceOverridesGetOwnPropertyNames
1893 {
1894     my $interface = shift;
1895     return $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames}
1896         || GetIndexedGetterOperation($interface)
1897         || GetNamedGetterOperation($interface);
1898 }
1899 
1900 sub InstanceOverridesPut
1901 {
1902     my $interface = shift;
1903     return $interface-&gt;extendedAttributes-&gt;{CustomPut}
1904         || $interface-&gt;extendedAttributes-&gt;{Plugin}
1905         || GetIndexedSetterOperation($interface)
1906         || GetNamedSetterOperation($interface);
1907 }
1908 
1909 sub InstanceOverridesDefineOwnProperty
1910 {
1911     my $interface = shift;
1912 
1913     return 0 if $interface-&gt;extendedAttributes-&gt;{DefaultDefineOwnProperty};
1914 
1915     return $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty}
1916         || GetIndexedSetterOperation($interface)
1917         || GetNamedSetterOperation($interface);
1918 }
1919 
1920 sub InstanceOverridesDeleteProperty
1921 {
1922     my $interface = shift;
1923     return $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty}
1924         || GetNamedDeleterOperation($interface);
1925 }
1926 
1927 sub PrototypeHasStaticPropertyTable
1928 {
1929     my $interface = shift;
1930     my $numConstants = @{$interface-&gt;constants};
1931     return $numConstants &gt; 0 || PrototypePropertyCount($interface) &gt; 0;
1932 }
1933 
1934 sub InstanceNeedsVisitChildren
1935 {
1936     my $interface = shift;
1937     
1938     foreach my $attribute (@{$interface-&gt;attributes}) {
1939         return 1 if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
1940     }
1941 
1942     return 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
1943     return 1 if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1944     return 0;
1945 }
1946 
1947 sub InstanceNeedsEstimatedSize
1948 {
1949     my $interface = shift;
1950     return $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
1951 }
1952 
1953 sub GetImplClassName
1954 {
1955     my $interface = shift;
1956 
1957     return $interface-&gt;type-&gt;name;
1958 }
1959 
1960 sub IsClassNameWordBoundary
1961 {
1962     my ($name, $i) = @_;
1963 
1964     # Interpret negative numbers as distance from end of string, just as the substr function does.
1965     $i += length($name) if $i &lt; 0;
1966 
1967     return 0 if $i &lt; 0;
1968     return 1 if $i == 0;
1969     return 1 if $i == length($name);
1970     return 0 if $i &gt; length($name);
1971 
1972     my $checkString = substr($name, $i - 1);
1973     return $checkString =~ /^[^A-Z][A-Z]/ || $checkString =~ /^[A-Z][A-Z][^A-Z]/;
1974 }
1975 
1976 sub IsPrefixRemovable
1977 {
1978     my ($class, $name, $i) = @_;
1979 
1980     return IsClassNameWordBoundary($name, $i)
1981         &amp;&amp; (IsClassNameWordBoundary($class, $i) &amp;&amp; substr($class, 0, $i) eq substr($name, 0, $i)
1982             || IsClassNameWordBoundary($class, -$i) &amp;&amp; substr($class, -$i) eq substr($name, 0, $i));
1983 }
1984 
1985 sub GetNestedClassName
1986 {
1987     my ($interface, $name) = @_;
1988 
1989     my $class = GetImplClassName($interface);
1990     my $member = $codeGenerator-&gt;WK_ucfirst($name);
1991 
1992     # Since the enumeration name will be nested in the class name&#39;s namespace, remove any words
1993     # that happen to match the start or end of the class name. If an enumeration is named TrackType or
1994     # TextTrackType, and the class is named TextTrack, then we will get a name like TextTrack::Type.
1995     my $memberLength = length($member);
1996     my $longestPrefixLength = 0;
1997     if ($member =~ /^[A-Z]./) {
1998         for (my $i = 2; $i &lt; $memberLength - 1; $i++) {
1999             $longestPrefixLength = $i if IsPrefixRemovable($class, $member, $i);
2000         }
2001     }
2002     $member = substr($member, $longestPrefixLength);
2003 
2004     return &quot;${class}::$member&quot;;
2005 }
2006 
2007 sub GetEnumerationClassName
2008 {
2009     my ($type, $interface) = @_;
2010 
2011     assert(&quot;Not a type&quot;) if ref($type) ne &quot;IDLType&quot;;
2012 
2013     if ($codeGenerator-&gt;HasEnumImplementationNameOverride($type)) {
2014         return $codeGenerator-&gt;GetEnumImplementationNameOverride($type);
2015     }
2016 
2017     my $name = $type-&gt;name;
2018 
2019     return $name if $codeGenerator-&gt;IsExternalEnumType($type);
2020     return $name unless defined($interface);
2021 
2022     return GetNestedClassName($interface, $name);
2023 }
2024 
2025 sub GetEnumerationValueName
2026 {
2027     my ($name) = @_;
2028 
2029     return &quot;EmptyString&quot; if $name eq &quot;&quot;;
2030     $name = join(&quot;&quot;, map { $codeGenerator-&gt;WK_ucfirst($_) } split(&quot;-&quot;, $name));
2031     $name = &quot;_$name&quot; if $name =~ /^\d/;
2032     return $name;
2033 }
2034 
2035 sub GenerateEnumerationHeader
2036 {
2037     my ($object, $enumeration, $className) = @_;
2038  
2039     # - Add default header template and header protection.
2040     push(@headerContentHeader, GenerateHeaderContentHeader($enumeration));
2041 
2042     $headerIncludes{&quot;${className}.h&quot;} = 1;
2043 
2044     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2045     push(@headerContent, GenerateEnumerationHeaderContent($enumeration, $className));
2046     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
2047      
2048     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2049     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2050 }
2051  
2052 sub GenerateEnumerationImplementation
2053 {
2054     my ($object, $enumeration, $className) = @_;
2055  
2056     # - Add default header template
2057     push(@implContentHeader, GenerateImplementationContentHeader($enumeration));
2058 
2059     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
2060     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
2061     push(@implContent, GenerateEnumerationImplementationContent($enumeration, $className));
2062     push(@implContent, &quot;} // namespace WebCore\n&quot;);
2063      
2064     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2065     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
2066 }
2067 
2068 sub GenerateEnumerationImplementationContent
2069 {
2070     my ($enumeration, $className, $interface, $conditionalString) = @_;
2071 
2072     # FIXME: A little ugly to have this be a side effect instead of a return value.
2073     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSString.h&gt;&quot;);
2074     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2075     AddToImplIncludes(&quot;JSDOMConvertEnumeration.h&quot;);
2076 
2077     my $result = &quot;&quot;;
2078     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2079 
2080 
2081     $result .= &quot;String convertEnumerationToString($className enumerationValue)\n&quot;;
2082     $result .= &quot;{\n&quot;;
2083     AddToImplIncludes(&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;);
2084     $result .= &quot;    static const NeverDestroyed&lt;String&gt; values[] = {\n&quot;;
2085     foreach my $value (@{$enumeration-&gt;values}) {
2086         if ($value eq &quot;&quot;) {
2087             $result .= &quot;        emptyString(),\n&quot;;
2088         } else {
2089             $result .= &quot;        MAKE_STATIC_STRING_IMPL(\&quot;$value\&quot;),\n&quot;;
2090         }
2091     }
2092     $result .= &quot;    };\n&quot;;
2093     my $index = 0;
2094     foreach my $value (@{$enumeration-&gt;values}) {
2095         my $enumerationValueName = GetEnumerationValueName($value);
2096         $result .= &quot;    static_assert(static_cast&lt;size_t&gt;(${className}::$enumerationValueName) == $index, \&quot;${className}::$enumerationValueName is not $index as expected\&quot;);\n&quot;;
2097         $index++;
2098     }
2099     $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
2100     $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
2101     $result .= &quot;}\n\n&quot;;
2102 
2103 
2104     # FIXME: Change to take VM&amp; instead of JSGlobalObject*.
2105     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(JSGlobalObject&amp; lexicalGlobalObject, $className enumerationValue)\n&quot;;
2106     $result .= &quot;{\n&quot;;
2107     $result .= &quot;    return jsStringWithCache(&amp;lexicalGlobalObject, convertEnumerationToString(enumerationValue));\n&quot;;
2108     $result .= &quot;}\n\n&quot;;
2109 
2110     # FIXME: Change to take VM&amp; instead of JSGlobalObject&amp;.
2111     # FIXME: Consider using toStringOrNull to make exception checking faster.
2112     # FIXME: Consider finding a more efficient way to match against all the strings quickly.
2113     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;
2114     $result .= &quot;{\n&quot;;
2115     $result .= &quot;    auto stringValue = value.toWTFString(&amp;lexicalGlobalObject);\n&quot;;
2116     foreach my $value (@{$enumeration-&gt;values}) {
2117         my $enumerationValueName = GetEnumerationValueName($value);
2118         if ($value eq &quot;&quot;) {
2119             $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
2120         } else {
2121             $result .= &quot;    if (stringValue == \&quot;$value\&quot;)\n&quot;;
2122         }
2123         $result .= &quot;        return ${className}::${enumerationValueName};\n&quot;;
2124     }
2125     $result .= &quot;    return WTF::nullopt;\n&quot;;
2126     $result .= &quot;}\n\n&quot;;
2127 
2128     $result .= &quot;template&lt;&gt; const char* expectedEnumerationValues&lt;$className&gt;()\n&quot;;
2129     $result .= &quot;{\n&quot;;
2130     $result .= &quot;    return \&quot;\\\&quot;&quot; . join (&quot;\\\&quot;, \\\&quot;&quot;, @{$enumeration-&gt;values}) . &quot;\\\&quot;\&quot;;\n&quot;;
2131     $result .= &quot;}\n\n&quot;;
2132 
2133     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2134 
2135     return $result;
2136 }
2137 
2138 sub GenerateEnumerationsImplementationContent
2139 {
2140     my ($interface, $enumerations) = @_;
2141 
2142     return &quot;&quot; unless @$enumerations;
2143 
2144     my $result = &quot;&quot;;
2145     foreach my $enumeration (@$enumerations) {
2146         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2147         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2148         $result .= GenerateEnumerationImplementationContent($enumeration, $className, $interface, $conditionalString);
2149     }
2150     return $result;
2151 }
2152 
2153 sub GenerateEnumerationHeaderContent
2154 {
2155     my ($enumeration, $className, $conditionalString) = @_;
2156 
2157     $headerIncludes{&quot;JSDOMConvertEnumeration.h&quot;} = 1;
2158 
2159     my $result = &quot;&quot;;
2160     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2161 
2162     my $exportMacro = GetExportMacroForJSClass($enumeration);
2163 
2164     $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
2165     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::JSGlobalObject&amp;, $className);\n\n&quot;;
2166     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;;
2167     $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
2168     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2169     
2170     return $result;
2171 }
2172 
2173 sub GenerateEnumerationsHeaderContent
2174 {
2175     my ($interface, $enumerations) = @_;
2176 
2177     return &quot;&quot; unless @$enumerations;
2178 
2179     # FIXME: Could optimize this to only generate the parts of each enumeration that are actually
2180     # used, which would require iterating over everything in the interface.
2181 
2182     my $result = &quot;&quot;;
2183     foreach my $enumeration (@$enumerations) {
2184         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2185         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2186         $result .= GenerateEnumerationHeaderContent($enumeration, $className, $conditionalString);
2187     }
2188     return $result;
2189 }
2190 
2191 sub GetDictionaryClassName
2192 {
2193     my ($type, $interface) = @_;
2194 
2195     if ($codeGenerator-&gt;HasDictionaryImplementationNameOverride($type)) {
2196         return $codeGenerator-&gt;GetDictionaryImplementationNameOverride($type);
2197     }
2198 
2199     my $name = $type-&gt;name;
2200     return $name if $codeGenerator-&gt;IsExternalDictionaryType($type);
2201     return $name unless defined($interface);
2202     return GetNestedClassName($interface, $name);
2203 }
2204 
2205 sub GenerateDefaultValue
2206 {
2207     my ($typeScope, $context, $type, $defaultValue) = @_;
2208 
2209     if ($codeGenerator-&gt;IsStringType($type)) {
2210         my $useAtomString = $type-&gt;extendedAttributes-&gt;{AtomString};
2211         if ($defaultValue eq &quot;null&quot;) {
2212             return $useAtomString ? &quot;nullAtom()&quot; : &quot;String()&quot;;
2213         } elsif ($defaultValue eq &quot;\&quot;\&quot;&quot;) {
2214             return $useAtomString ? &quot;emptyAtom()&quot; : &quot;emptyString()&quot;;
2215         } else {
2216             return $useAtomString ? &quot;AtomString(${defaultValue}, AtomString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;
2217         }
2218     }
2219 
2220     if ($codeGenerator-&gt;IsEnumType($type)) {
2221         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2222         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2223         if ($defaultValue eq &quot;null&quot;) {
2224             die if !$type-&gt;isNullable;
2225             return &quot;WTF::nullopt&quot;;
2226         }
2227         my $className = GetEnumerationClassName($type, $typeScope);
2228         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2229         return $className . &quot;::&quot; . $enumerationValueName;
2230     }
2231     if ($defaultValue eq &quot;null&quot;) {
2232         if ($type-&gt;isUnion) {
2233             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2234 
2235             my $IDLType = GetIDLType($typeScope, $type);
2236             return &quot;convert&lt;${IDLType}&gt;(lexicalGlobalObject, jsNull());&quot;;
2237         }
2238 
2239         return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
2240         return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
2241         return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
2242         return &quot;WTF::nullopt&quot;;
2243     }
2244 
2245     if ($defaultValue eq &quot;[]&quot;) {
2246         my $IDLType = GetIDLType($typeScope, $type);
2247         return &quot;Converter&lt;${IDLType}&gt;::ReturnType{ }&quot;;
2248     }
2249 
2250     return &quot;jsUndefined()&quot; if $defaultValue eq &quot;undefined&quot;;
2251     return &quot;PNaN&quot; if $defaultValue eq &quot;NaN&quot;;
2252 
2253     return $defaultValue;
2254 }
2255 
2256 sub GenerateDictionaryHeaderContent
2257 {
2258     my ($dictionary, $className, $conditionalString) = @_;
2259 
2260     $headerIncludes{&quot;JSDOMConvertDictionary.h&quot;} = 1;
2261 
2262     my $exportMacro = GetExportMacroForJSClass($dictionary);
2263 
2264     my $result = &quot;&quot;;
2265     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2266     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n\n&quot;;
2267 
2268     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2269         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;
2270     }
2271 
2272     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2273     return $result;
2274 }
2275 
2276 sub GenerateDictionariesHeaderContent
2277 {
2278     my ($typeScope, $allDictionaries) = @_;
2279 
2280     return &quot;&quot; unless @$allDictionaries;
2281 
2282     my $result = &quot;&quot;;
2283     foreach my $dictionary (@$allDictionaries) {
2284         $headerIncludes{$typeScope-&gt;type-&gt;name . &quot;.h&quot;} = 1 if $typeScope;
2285         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2286         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
2287         $result .= GenerateDictionaryHeaderContent($dictionary, $className, $conditionalString);
2288     }
2289     return $result;
2290 }
2291 
2292 sub GenerateDictionaryImplementationContent
2293 {
2294     my ($dictionary, $className, $interface) = @_;
2295 
2296     my $result = &quot;&quot;;
2297 
2298     my $name = $dictionary-&gt;type-&gt;name;
2299     my $typeScope = $interface || $dictionary;
2300 
2301     my $conditional = $dictionary-&gt;extendedAttributes-&gt;{Conditional};
2302     if ($conditional) {
2303         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2304         $result .= &quot;#if ${conditionalString}\n\n&quot;;
2305     }
2306 
2307     # FIXME: A little ugly to have this be a side effect instead of a return value.
2308     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2309     AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
2310 
2311     # https://heycam.github.io/webidl/#es-dictionary
2312     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;
2313     $result .= &quot;{\n&quot;;
2314     $result .= &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;;
2315     $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
2316     $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
2317     $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
2318 
2319     # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
2320     $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
2321     $result .= &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;;
2322     $result .= &quot;        return { };\n&quot;;
2323     $result .= &quot;    }\n&quot;;
2324 
2325     # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
2326 
2327     # 3. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
2328     my @dictionaries;
2329     push(@dictionaries, $dictionary);
2330     my $parentType = $dictionary-&gt;parentType;
2331     while (defined($parentType)) {
2332         my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
2333         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2334         unshift(@dictionaries, $parentDictionary);
2335         $parentType = $parentDictionary-&gt;parentType;
2336     }
2337 
2338     my $arguments = &quot;&quot;;
2339     my $comma = &quot;&quot;;
2340 
2341     $result .= &quot;    $className result;\n&quot;;
2342 
2343     # 4. For each dictionary dictionary in dictionaries, in order:
2344     foreach my $dictionary (@dictionaries) {
2345         # For each dictionary member member declared on dictionary, in lexicographical order:
2346         my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2347         foreach my $member (@sortedMembers) {
2348             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2349 
2350             my $type = $member-&gt;type;
2351             AddToImplIncludesForIDLType($type);
2352 
2353             my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2354             if ($conditional) {
2355                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2356                 $result .= &quot;#if ${conditionalString}\n&quot;;
2357             }
2358 
2359             # 4.1. Let key be the identifier of member.
2360             my $key = $member-&gt;name;
2361             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2362 
2363             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2364             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2365             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2366             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2367             $result .= &quot;    else {\n&quot;;
2368             $result .= &quot;        ${key}Value = object-&gt;get(&amp;lexicalGlobalObject, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;
2369             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2370             $result .= &quot;    }\n&quot;;
2371 
2372             my $IDLType = GetIDLType($typeScope, $type);
2373 
2374             # 4.3. If value is not undefined, then:
2375             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2376 
2377             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;);
2378             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2379             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2380 
2381             # Value is undefined.
2382             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2383             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2384                 $result .= &quot;    } else\n&quot;;
2385                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2386             } elsif ($member-&gt;isRequired) {
2387                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2388                 $result .= &quot;    } else {\n&quot;;
2389                 $result .= &quot;        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;
2390                 $result .= &quot;        return { };\n&quot;;
2391                 $result .= &quot;    }\n&quot;;
2392             } else {
2393                 $result .= &quot;    }\n&quot;;
2394             }
2395 
2396             $result .= &quot;#endif\n&quot; if $conditional;
2397         }
2398     }
2399 
2400     # 5. Return dict.
2401     $result .= &quot;    return result;\n&quot;;
2402     $result .= &quot;}\n\n&quot;;
2403 
2404     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2405         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2406         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2407 
2408         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;
2409         $result .= &quot;{\n&quot;;
2410         $result .= &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n\n&quot;;
2411 
2412         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
2413         $result .= &quot;    auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n\n&quot;;
2414 
2415         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2416         #    in order from least to most derived.
2417         #    NOTE: This was done above.
2418 
2419         # 3. For each dictionary dictionary in dictionaries, in order:
2420         foreach my $dictionary (@dictionaries) {
2421             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2422             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2423             foreach my $member (@sortedMembers) {
2424                 my $key = $member-&gt;name;
2425                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2426                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2427 
2428                 my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2429                 if ($conditional) {
2430                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2431                     $result .= &quot;#if ${conditionalString}\n&quot;;
2432                 }
2433 
2434                 # 1. Let key be the identifier of member.
2435                 # 2. If the dictionary member named key is present in V, then:
2436                     # 1. Let idlValue be the value of member on V.
2437                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2438                     # 3. Perform ! CreateDataProperty(O, key, value).
2439 
2440                 my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);
2441                 my $indent = &quot;&quot;;
2442                 if ($needsRuntimeCheck) {
2443                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;&amp;globalObject&quot;);
2444                     $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;
2445                     $indent = &quot;    &quot;;
2446                 }
2447 
2448                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2449                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2450                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2451 
2452                     $result .= &quot;${indent}    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;
2453                     $result .= &quot;${indent}        auto ${key}Value = ${conversionExpression};\n&quot;;
2454                     $result .= &quot;${indent}        result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2455                     $result .= &quot;${indent}    }\n&quot;;
2456                 } else {
2457                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2458 
2459                     $result .= &quot;${indent}    auto ${key}Value = ${conversionExpression};\n&quot;;
2460                     $result .= &quot;${indent}    result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2461                 }
2462                 if ($needsRuntimeCheck) {
2463                     $result .= &quot;    }\n&quot;;
2464                 }
2465 
2466                 $result .= &quot;#endif\n&quot; if $conditional;
2467             }
2468         }
2469 
2470         $result .= &quot;    return result;\n&quot;;
2471         $result .= &quot;}\n\n&quot;;
2472     }
2473 
2474     $result .= &quot;#endif\n\n&quot; if $conditional;
2475 
2476     return $result;
2477 }
2478 
2479 sub GenerateDictionariesImplementationContent
2480 {
2481     my ($typeScope, $allDictionaries) = @_;
2482 
2483     my $result = &quot;&quot;;
2484     foreach my $dictionary (@$allDictionaries) {
2485         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2486         $result .= GenerateDictionaryImplementationContent($dictionary, $className, $typeScope);
2487     }
2488     return $result;
2489 }
2490 
2491 sub GetJSTypeForNode
2492 {
2493     my ($interface) = @_;
2494 
2495     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Document&quot;)) {
2496         return &quot;JSDocumentWrapperType&quot;;
2497     }
2498     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentFragment&quot;)) {
2499         return &quot;JSDocumentFragmentNodeType&quot;;
2500     }
2501     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;DocumentType&quot;)) {
2502         return &quot;JSDocumentTypeNodeType&quot;;
2503     }
2504     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;ProcessingInstruction&quot;)) {
2505         return &quot;JSProcessingInstructionNodeType&quot;;
2506     }
2507     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;CDATASection&quot;)) {
2508         return &quot;JSCDATASectionNodeType&quot;;
2509     }
2510     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Attr&quot;)) {
2511         return &quot;JSAttrNodeType&quot;;
2512     }
2513     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Comment&quot;)) {
2514         return &quot;JSCommentNodeType&quot;;
2515     }
2516     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Text&quot;)) {
2517         return &quot;JSTextNodeType&quot;;
2518     }
2519     if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Element&quot;)) {
2520         return &quot;JSElementType&quot;;
2521     }
2522     return &quot;JSNodeType&quot;;
2523 }
2524 
2525 sub GenerateHeader
2526 {
2527     my ($object, $interface, $enumerations, $dictionaries) = @_;
2528 
2529     my $interfaceName = $interface-&gt;type-&gt;name;
2530     my $className = &quot;JS$interfaceName&quot;;
2531     my %structureFlags = ();
2532 
2533     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
2534     my $parentClassName = GetParentClassName($interface);
2535     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
2536 
2537     # - Add default header template and header protection
2538     push(@headerContentHeader, GenerateHeaderContentHeader($interface));
2539 
2540     if ($hasParent) {
2541         $headerIncludes{&quot;$parentClassName.h&quot;} = 1;
2542     } else {
2543         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
2544         if ($interface-&gt;isException) {
2545             $headerIncludes{&quot;&lt;JavaScriptCore/ErrorPrototype.h&gt;&quot;} = 1;
2546         }
2547     }
2548 
2549     $headerIncludes{&quot;SVGElement.h&quot;} = 1 if $className =~ /^JSSVG/;
2550 
2551     my $implType = GetImplClassName($interface);
2552 
2553     my $numConstants = @{$interface-&gt;constants};
2554     my $numAttributes = @{$interface-&gt;attributes};
2555     my $numOperations = @{$interface-&gt;operations};
2556 
2557     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
2558 
2559     if ($codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type)) {
2560         $headerIncludes{&quot;SVGAnimatedPropertyImpl.h&quot;} = 1;
2561     } elsif ($codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {
2562         $headerIncludes{&quot;SVGPathSegImpl.h&quot;} = 1;
2563     } else {
2564         $headerIncludes{&quot;$interfaceName.h&quot;} = 1 if $hasParent &amp;&amp; $interface-&gt;extendedAttributes-&gt;{JSGenerateToNativeObject};
2565         # Implementation class forward declaration
2566         if (IsDOMGlobalObject($interface)) {
2567             AddClassForwardIfNeeded($interface-&gt;type);
2568         }
2569     }
2570 
2571     push(@headerContent, &quot;class JSWindowProxy;\n\n&quot;) if $interfaceName eq &quot;DOMWindow&quot; or $interfaceName eq &quot;RemoteDOMWindow&quot;;
2572 
2573     my $exportMacro = GetExportMacroForJSClass($interface);
2574 
2575     # Class declaration
2576     push(@headerContent, &quot;class $exportMacro$className : public $parentClassName {\n&quot;);
2577 
2578     # Static create methods
2579     push(@headerContent, &quot;public:\n&quot;);
2580     push(@headerContent, &quot;    using Base = $parentClassName;\n&quot;);
2581     push(@headerContent, &quot;    using DOMWrapped = $implType;\n&quot;) if $hasParent;
2582 
2583     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2584         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
2585         push(@headerContent, &quot;    {\n&quot;);
2586         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl), proxy);\n&quot;);
2587         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2588         push(@headerContent, &quot;        return ptr;\n&quot;);
2589         push(@headerContent, &quot;    }\n\n&quot;);
2590     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2591         push(@headerContent, &quot;    static $className* create(JSC::VM&amp; vm, JSC::Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSC::JSProxy* proxy)\n&quot;);
2592         push(@headerContent, &quot;    {\n&quot;);
2593         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(vm.heap)) ${className}(vm, structure, WTFMove(impl));\n&quot;);
2594         push(@headerContent, &quot;        ptr-&gt;finishCreation(vm, proxy);\n&quot;);
2595         push(@headerContent, &quot;        return ptr;\n&quot;);
2596         push(@headerContent, &quot;    }\n\n&quot;);
2597     } elsif ($interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined}) {
2598         AddIncludesForImplementationTypeInHeader($implType);
2599         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2600         push(@headerContent, &quot;    {\n&quot;);
2601         push(@headerContent, &quot;        globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(globalObject-&gt;vm(), \&quot;Allocated masquerading object\&quot;);\n&quot;);
2602         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2603         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2604         push(@headerContent, &quot;        return ptr;\n&quot;);
2605         push(@headerContent, &quot;    }\n\n&quot;);
2606     } elsif (!NeedsImplementationClass($interface)) {
2607         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2608         push(@headerContent, &quot;    {\n&quot;);
2609         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2610         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2611         push(@headerContent, &quot;        return ptr;\n&quot;);
2612         push(@headerContent, &quot;    }\n\n&quot;);  
2613     } else {
2614         if (!$codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type) &amp;&amp; !$codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {
2615             AddIncludesForImplementationTypeInHeader($implType);
2616         }
2617         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2618         push(@headerContent, &quot;    {\n&quot;);
2619         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2620         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2621         push(@headerContent, &quot;        return ptr;\n&quot;);
2622         push(@headerContent, &quot;    }\n\n&quot;);
2623     }
2624 
2625     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2626     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2627     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2628     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2629     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2630         
2631     # Prototype
2632     unless (ShouldUseGlobalObjectPrototype($interface)) {
2633         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2634         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2635     }
2636 
2637     # JSValue to implementation type
2638     if (ShouldGenerateToWrapped($hasParent, $interface)) {
2639         # FIXME: Add extended attribute for this.
2640         my @toWrappedArguments = ();
2641         push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
2642         push(@toWrappedArguments, &quot;JSC::JSGlobalObject&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;
2643         push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
2644 
2645         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2646 
2647         my $export = &quot;&quot;;
2648         $export = &quot;WEBCORE_EXPORT &quot; if $interface-&gt;extendedAttributes-&gt;{ExportToWrappedFunction};
2649         push(@headerContent, &quot;    static ${export}${toWrappedType} toWrapped(&quot; . join(&quot;, &quot;, @toWrappedArguments) . &quot;);\n&quot;);
2650     }
2651 
2652     $headerTrailingIncludes{&quot;${className}Custom.h&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomHeader};
2653 
2654     my $namedGetterOperation = GetNamedGetterOperation($interface);
2655     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2656 
2657     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2658     if ($namedGetterOperation) {
2659         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2660             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2661         } else {
2662             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2663         }
2664     }
2665     
2666     # ClassInfo MethodTable declarations.
2667     
2668     if (InstanceOverridesGetOwnPropertySlot($interface)) {
2669         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);
2670         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
2671         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::JSGlobalObject*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);
2672         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2673     }
2674 
2675     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
2676         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);
2677         $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;
2678     }
2679 
2680     if ($interface-&gt;extendedAttributes-&gt;{Plugin} || GetNamedSetterOperation($interface)) {
2681         $structureFlags{&quot;JSC::ProhibitsPropertyCaching&quot;} = 1;
2682     }
2683     
2684     if (InstanceOverridesGetOwnPropertyNames($interface)) {
2685         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);
2686         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2687     }
2688     
2689     if (InstanceOverridesPut($interface)) {
2690         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
2691         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);
2692     }
2693     
2694     if (InstanceOverridesDefineOwnProperty($interface)) {
2695         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
2696     }
2697 
2698     if (InstanceOverridesDeleteProperty($interface)) {
2699         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName);\n&quot;);
2700         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned);\n&quot;);
2701     }
2702 
2703     if (InstanceOverridesGetCallData($interface)) {
2704         push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
2705         $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
2706         $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
2707     }
2708     
2709     if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
2710         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);
2711     }
2712     
2713     if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
2714         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);
2715     }
2716     
2717     if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
2718         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);
2719     }
2720 
2721     if (InstanceNeedsEstimatedSize($interface)) {
2722         push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
2723     }
2724     
2725     if (!$hasParent) {
2726         push(@headerContent, &quot;    static void destroy(JSC::JSCell*);\n&quot;);
2727     }
2728 
2729     # Class info
2730     if ($interfaceName eq &quot;Node&quot;) {
2731         push(@headerContent, &quot;\n&quot;);
2732         push(@headerContent, &quot;protected:\n&quot;);
2733         push(@headerContent, &quot;    static const JSC::ClassInfo s_info;\n&quot;);
2734         push(@headerContent, &quot;public:\n&quot;);
2735         push(@headerContent, &quot;    static constexpr const JSC::ClassInfo* info() { return &amp;s_info; }\n\n&quot;);
2736     } else {
2737         push(@headerContent, &quot;\n&quot;);
2738         push(@headerContent, &quot;    DECLARE_INFO;\n\n&quot;);
2739     }
2740 
2741     # Structure ID
2742     push(@headerContent, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
2743     push(@headerContent, &quot;    {\n&quot;);
2744     my $indexingModeIncludingHistory = InstanceOverridesGetOwnPropertySlot($interface) ? &quot;JSC::MayHaveIndexedAccessors&quot; : &quot;JSC::NonArray&quot;;
2745     if (IsDOMGlobalObject($interface)) {
2746         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info(), $indexingModeIncludingHistory);\n&quot;);
2747     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2748         my $type = GetJSTypeForNode($interface);
2749         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info(), $indexingModeIncludingHistory);\n&quot;);
2750     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Event&quot;)) {
2751         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info(), $indexingModeIncludingHistory);\n&quot;);
2752     } else {
2753         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info(), $indexingModeIncludingHistory);\n&quot;);
2754     }
2755     push(@headerContent, &quot;    }\n\n&quot;);
2756 
2757     # Custom pushEventHandlerScope function
2758     if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
2759         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::JSGlobalObject*, JSC::JSScope*) const;\n\n&quot;);
2760     }
2761     
2762     # Constructor object getter
2763     unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
2764         push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
2765         push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
2766     }
2767 
2768     # Serializer function.
2769     if ($interface-&gt;serializable) {
2770         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::JSGlobalObject&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);
2771     }
2772     
2773     my $numCustomOperations = 0;
2774     my $numCustomAttributes = 0;
2775 
2776     my $hasForwardDeclaringOperations = 0;
2777     my $hasForwardDeclaringAttributes = 0;
2778 
2779     my $hasDOMJITAttributes = 0;
2780 
2781     # Attribute and function enums
2782     if ($numAttributes &gt; 0) {
2783         foreach my $attribute (@{$interface-&gt;attributes}) {
2784             $numCustomAttributes++ if HasCustomGetter($attribute);
2785             $numCustomAttributes++ if HasCustomSetter($attribute);
2786             if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
2787                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2788                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2789                 push(@headerContent, &quot;    mutable JSC::WriteBarrier&lt;JSC::Unknown&gt; m_&quot; . $attribute-&gt;name . &quot;;\n&quot;);
2790                 $numCachedAttributes++;
2791                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2792             }
2793             $hasDOMJITAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2794 
2795             $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2796         }
2797     }
2798 
2799     # FIXME: We put this unconditionally to put all the WebCore JS wrappers in each IsoSubspace.
2800     # https://bugs.webkit.org/show_bug.cgi?id=205107
2801     if (IsDOMGlobalObject($interface)) {
2802         push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::IsoSubspace* subspaceFor(JSC::VM&amp; vm) { return subspaceForImpl(vm); }\n&quot;);
2803         push(@headerContent, &quot;    static JSC::IsoSubspace* subspaceForImpl(JSC::VM&amp; vm);\n&quot;);
2804     }
2805 
2806     # visit function
2807     if ($needsVisitChildren) {
2808         push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2809         push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
2810         push(@headerContent, &quot;\n&quot;);
2811 
2812         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2813             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2814             # concurrent GC or in between eden GCs something may happen that would lead to this
2815             # logic behaving differently. Since this could mark objects or add opaque roots, this
2816             # means that after any increment of mutator resumption in a concurrent GC and at least
2817             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2818             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2819             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2820             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2821             # that the GC calls to ask an object is it would like to mark anything else after the
2822             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2823             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2824             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2825             if (!IsDOMGlobalObject($interface)) {
2826                 push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return outputConstraintSubspaceFor(vm); }\n&quot;);
2827             }
2828         }
2829     }
2830 
2831     if (NeedsImplementationClass($interface)) {
2832         push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);
2833     }
2834     
2835     if ($numCustomAttributes &gt; 0) {
2836         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2837 
2838         foreach my $attribute (@{$interface-&gt;attributes}) {
2839             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2840             if (HasCustomGetter($attribute)) {
2841                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2842                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
2843                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::JSGlobalObject&amp;) const;\n&quot;);
2844                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2845             }
2846             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2847                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2848                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;);
2849                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2850             }
2851         }
2852     }
2853 
2854     foreach my $operation (@{$interface-&gt;operations}) {
2855         $numCustomOperations++ if HasCustomMethod($operation);
2856         $hasForwardDeclaringOperations = 1 if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2857     }
2858 
2859     if ($numCustomOperations &gt; 0) {
2860         my $inAppleCopyright = 0;
2861         push(@headerContent, &quot;\n    // Custom functions\n&quot;);
2862         foreach my $operation (@{$interface-&gt;operations}) {
2863             next unless HasCustomMethod($operation);
2864             next if $operation-&gt;{overloads} &amp;&amp; $operation-&gt;{overloadIndex} != 1;
2865 
2866             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2867                 if (!$inAppleCopyright) {
2868                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2869                     $inAppleCopyright = 1;
2870                 }
2871             } elsif ($inAppleCopyright) {
2872                 push(@headerContent, $endAppleCopyright);
2873                 $inAppleCopyright = 0;
2874             }
2875 
2876             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
2877             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2878 
2879             my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
2880 
2881             my @functionArguments = ();
2882             push(@functionArguments, &quot;JSC::JSGlobalObject&amp;&quot;);
2883             push(@functionArguments, &quot;JSC::CallFrame&amp;&quot;);
2884             push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
2885 
2886             push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
2887 
2888             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2889         }
2890         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2891     }
2892 
2893     if (NeedsImplementationClass($interface)) {
2894         if ($hasParent) {
2895             push(@headerContent, &quot;    $interfaceName&amp; wrapped() const\n&quot;);
2896             push(@headerContent, &quot;    {\n&quot;);
2897             push(@headerContent, &quot;        return static_cast&lt;$interfaceName&amp;&gt;(Base::wrapped());\n&quot;);
2898             push(@headerContent, &quot;    }\n&quot;);
2899         }
2900     }
2901 
2902     # structure flags
2903     if (%structureFlags) {
2904         push(@headerContent, &quot;public:\n&quot;);
2905         push(@headerContent, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);
2906         foreach my $structureFlag (sort (keys %structureFlags)) {
2907             push(@headerContent, &quot; | &quot; . $structureFlag);
2908         }
2909         push(@headerContent, &quot;;\n&quot;);
2910     }
2911 
2912     push(@headerContent, &quot;protected:\n&quot;);
2913 
2914     # Constructor
2915     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2916         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;, JSWindowProxy*);\n&quot;);
2917     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2918         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2919     } elsif (!NeedsImplementationClass($interface)) {
2920         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;);\n\n&quot;);
2921      } else {
2922         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;, Ref&lt;$implType&gt;&amp;&amp;);\n\n&quot;);
2923     }
2924 
2925     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2926         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSWindowProxy*);\n&quot;);
2927     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2928         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;, JSC::JSProxy*);\n&quot;);
2929     } else {
2930         push(@headerContent, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
2931     }
2932 
2933     push(@headerContent, &quot;};\n\n&quot;);
2934 
2935     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface)) {
2936         if ($interfaceName ne &quot;Node&quot; &amp;&amp; $codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2937             $headerIncludes{&quot;JSNode.h&quot;} = 1;
2938             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSNodeOwner {\n&quot;);
2939         } else {
2940             push(@headerContent, &quot;class JS${interfaceName}Owner : public JSC::WeakHandleOwner {\n&quot;);
2941         }
2942         $headerIncludes{&quot;&lt;wtf/NeverDestroyed.h&gt;&quot;} = 1;
2943         push(@headerContent, &quot;public:\n&quot;);
2944         push(@headerContent, &quot;    virtual bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt;, void* context, JSC::SlotVisitor&amp;, const char**);\n&quot;);
2945         push(@headerContent, &quot;    virtual void finalize(JSC::Handle&lt;JSC::Unknown&gt;, void* context);\n&quot;);
2946         push(@headerContent, &quot;};\n&quot;);
2947         push(@headerContent, &quot;\n&quot;);
2948         push(@headerContent, &quot;inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, $implType*)\n&quot;);
2949         push(@headerContent, &quot;{\n&quot;);
2950         push(@headerContent, &quot;    static NeverDestroyed&lt;JS${interfaceName}Owner&gt; owner;\n&quot;);
2951         push(@headerContent, &quot;    return &amp;owner.get();\n&quot;);
2952         push(@headerContent, &quot;}\n&quot;);
2953         push(@headerContent, &quot;\n&quot;);
2954         push(@headerContent, &quot;inline void* wrapperKey($implType* wrappableObject)\n&quot;);
2955         push(@headerContent, &quot;{\n&quot;);
2956         push(@headerContent, &quot;    return wrappableObject;\n&quot;);
2957         push(@headerContent, &quot;}\n&quot;);
2958         push(@headerContent, &quot;\n&quot;);
2959     }
2960     if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
2961         # Node and NodeList have custom inline implementations which thus cannot be exported.
2962         # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
2963         if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
2964             push(@headerContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2965         } else {
2966             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);
2967         }
2968         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(lexicalGlobalObject, globalObject, *impl) : JSC::jsNull(); }\n&quot;);
2969 
2970         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2971         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(lexicalGlobalObject, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);
2972    }
2973 
2974     push(@headerContent, &quot;\n&quot;);
2975 
2976     GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
2977 
2978     if ($hasForwardDeclaringOperations) {
2979         my $inAppleCopyright = 0;
2980         push(@headerContent,&quot;// Functions\n\n&quot;);
2981         foreach my $operation (@{$interface-&gt;operations}) {
2982             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
2983             next unless $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2984 
2985             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2986                 if (!$inAppleCopyright) {
2987                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2988                     $inAppleCopyright = 1;
2989                 }
2990             } elsif ($inAppleCopyright) {
2991                 push(@headerContent, $endAppleCopyright);
2992                 $inAppleCopyright = 0;
2993             }
2994 
2995             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
2996             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
2997             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2998             my $functionName = GetFunctionName($interface, $className, $operation);
2999             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);
3000             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3001         }
3002 
3003         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
3004         push(@headerContent,&quot;\n&quot;);
3005     }
3006 
3007     if ($hasForwardDeclaringAttributes) {
3008         push(@headerContent,&quot;// Attributes\n\n&quot;);
3009         foreach my $attribute (@{$interface-&gt;attributes}) {
3010             next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3011 
3012             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
3013             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3014             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3015             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
3016             if (!IsReadonly($attribute)) {
3017                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
3018                 push(@headerContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
3019             }
3020             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3021         }
3022     }
3023 
3024     # CheckSubClass Snippet function.
3025     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
3026         $headerIncludes{&quot;&lt;JavaScriptCore/Snippet.h&gt;&quot;} = 1;
3027         push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3028         push(@headerContent, &quot;Ref&lt;JSC::Snippet&gt; checkSubClassSnippetFor${className}();\n&quot;);
3029         push(@headerContent, &quot;#endif\n&quot;);
3030     }
3031 
3032     if ($hasDOMJITAttributes) {
3033         $headerIncludes{&quot;&lt;JavaScriptCore/DOMJITGetterSetter.h&gt;&quot;} = 1;
3034         push(@headerContent,&quot;// DOM JIT Attributes\n\n&quot;);
3035         foreach my $attribute (@{$interface-&gt;attributes}) {
3036             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3037             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
3038 
3039             my $interfaceName = $interface-&gt;type-&gt;name;
3040             my $className = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
3041             my $domJITClassName = $className . &quot;Attribute&quot;;
3042 
3043             push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3044             push(@headerContent, &quot;Ref&lt;JSC::DOMJIT::CallDOMGetterSnippet&gt; compile${domJITClassName}();\n&quot;);
3045             push(@headerContent, &quot;#endif\n\n&quot;);
3046         }
3047     }
3048 
3049     if (HasCustomConstructor($interface)) {
3050         push(@headerContent, &quot;// Custom constructor\n&quot;);
3051         push(@headerContent, &quot;JSC::EncodedJSValue construct${className}(JSC::JSGlobalObject*, JSC::CallFrame&amp;);\n\n&quot;);
3052     }
3053 
3054     if (NeedsImplementationClass($interface)) {
3055         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
3056         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
3057 
3058         push(@headerContent, &quot;template&lt;&gt; struct JSDOMWrapperConverterTraits&lt;${implType}&gt; {\n&quot;);
3059         push(@headerContent, &quot;    using WrapperClass = ${className};\n&quot;);
3060         push(@headerContent, &quot;    using ToWrappedReturnType = ${toWrappedType};\n&quot;);
3061         push(@headerContent, &quot;};\n&quot;);
3062     }
3063 
3064     push(@headerContent, GenerateEnumerationsHeaderContent($interface, $enumerations));
3065     push(@headerContent, GenerateDictionariesHeaderContent($interface, $dictionaries));
3066 
3067     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
3068     push(@headerContent, &quot;\n} // namespace WebCore\n&quot;);
3069     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
3070 
3071     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3072         push(@headerContent, &quot;\n&quot;);
3073         push(@headerContent, split(&quot;\r&quot;, $endAppleCopyright));
3074     }
3075 
3076     # - Generate dependencies.
3077     if ($writeDependencies) {
3078         my @ancestors;
3079         $codeGenerator-&gt;ForAllParents($interface, sub {
3080             my $currentInterface = shift;
3081             push(@ancestors, $currentInterface-&gt;type-&gt;name);
3082         }, 0);
3083         for my $dictionary (@$dictionaries) {
3084             my $parentType = $dictionary-&gt;parentType;
3085             while (defined($parentType)) {
3086                 push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
3087                 my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
3088                 assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
3089                 $parentType = $parentDictionary-&gt;parentType;
3090             }
3091         }
3092         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
3093         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
3094     }
3095 }
3096 
3097 sub GeneratePropertiesHashTable
3098 {
3099     my ($object, $interface, $isInstance, $hashKeys, $hashSpecials, $hashValue1, $hashValue2, $conditionals, $readWriteConditionals, $runtimeEnabledOperations, $runtimeEnabledAttributes) = @_;
3100 
3101     # FIXME: These should be functions on $interface.
3102     my $interfaceName = $interface-&gt;type-&gt;name;
3103     my $className = &quot;JS$interfaceName&quot;;
3104     
3105     # - Add all properties in a hashtable definition
3106     my $propertyCount = $isInstance ? InstancePropertyCount($interface) : PrototypePropertyCount($interface);
3107 
3108     if (!$isInstance &amp;&amp; NeedsConstructorProperty($interface)) {
3109         die if !$propertyCount;
3110         push(@$hashKeys, &quot;constructor&quot;);
3111         my $getter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3112         push(@$hashValue1, $getter);
3113 
3114         my $setter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3115         push(@$hashValue2, $setter);
3116         push(@$hashSpecials, &quot;static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum)&quot;);
3117     }
3118 
3119     return 0 if !$propertyCount;
3120 
3121     my @attributes = @{$interface-&gt;attributes};
3122     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3123     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;
3124 
3125     foreach my $attribute (@attributes) {
3126         next if ($attribute-&gt;isStatic);
3127         next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
3128         next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
3129 
3130         # Global objects add RuntimeEnabled attributes after creation so do not add them to the static table.
3131         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $attribute)) {
3132             $propertyCount -= 1;
3133             next;
3134         }
3135 
3136         my $name = $attribute-&gt;name;
3137         push(@$hashKeys, $name);
3138 
3139         my $special = GetJSCAttributesForAttribute($interface, $attribute);
3140         push(@$hashSpecials, $special);
3141 
3142         if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
3143             push(@$hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
3144         } else {
3145             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3146             push(@$hashValue1, $getter);
3147         }
3148 
3149         if (IsReadonly($attribute)) {
3150             push(@$hashValue2, &quot;0&quot;);
3151         } else {
3152             my $setter = GetAttributeSetterName($interface, $className, $attribute);
3153             push(@$hashValue2, $setter);
3154         }
3155 
3156         my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
3157         $conditionals-&gt;{$name} = $conditional if $conditional;
3158         my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3159         $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
3160 
3161         my $needsRuntimeCheck = NeedsRuntimeCheck($interface, $attribute);
3162         my $needsRuntimeReadWriteCheck = $attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite};
3163 
3164         if ($needsRuntimeCheck &amp;&amp; $needsRuntimeReadWriteCheck) {
3165             die &quot;Being both runtime enabled and runtime conditionally read-write is not yet supported (used on the &#39;${name}&#39; attribute of &#39;${interfaceName}&#39;).\n&quot;;
3166         }
3167 
3168         if ($needsRuntimeCheck || $needsRuntimeReadWriteCheck) {
3169             push(@$runtimeEnabledAttributes, $attribute);
3170         }
3171     }
3172 
3173     my @operations = @{$interface-&gt;operations};
3174     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3175     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3176     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;
3177     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3178     foreach my $operation (@operations) {
3179         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
3180         next if ($operation-&gt;isStatic);
3181         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3182         next if OperationShouldBeOnInstance($interface, $operation) != $isInstance;
3183         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
3184 
3185         # Global objects add RuntimeEnabled operations after creation so do not add them to the static table.
3186         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $operation)) {
3187             $propertyCount -= 1;
3188             next;
3189         }
3190 
3191         my $name = $operation-&gt;name;
3192         push(@$hashKeys, $name);
3193 
3194         my $functionName = GetFunctionName($interface, $className, $operation);
3195         push(@$hashValue1, $functionName);
3196 
3197         my $functionLength = GetFunctionLength($operation);
3198 
3199         if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3200             push(@$hashValue2, &quot;&amp;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
3201         } else {
3202             push(@$hashValue2, $functionLength);
3203         }
3204 
3205         push(@$hashSpecials, ComputeFunctionSpecial($interface, $operation));
3206 
3207         my $conditional = GetConditionalForOperationConsideringOverloads($operation);
3208         $conditionals-&gt;{$name} = $conditional if $conditional;
3209 
3210         if (NeedsRuntimeCheck($interface, $operation)) {
3211             push(@$runtimeEnabledOperations, $operation);
3212         }
3213     }
3214 
3215     return $propertyCount;
3216 }
3217 
3218 # This computes an effective overload set for a given operation / constructor,
3219 # which represents the allowable invocations.This set is used as input for
3220 # the Web IDL overload resolution algorithm.
3221 # http://heycam.github.io/webidl/#dfn-effective-overload-set
3222 sub ComputeEffectiveOverloadSet
3223 {
3224     my ($overloads) = @_;
3225 
3226     my %allSets;
3227     my $addTuple = sub {
3228         my $tuple = shift;
3229         # The Web IDL specification uses a flat set of tuples but we use a hash where the key is the
3230         # number of parameters and the value is the set of tuples for the given number of parameters.
3231         my $length = scalar(@{@$tuple[1]});
3232         if (!exists($allSets{$length})) {
3233             $allSets{$length} = [ $tuple ];
3234         } else {
3235             push(@{$allSets{$length}}, $tuple);
3236         }
3237     };
3238 
3239     my $m = LengthOfLongestOperationParameterList($overloads);
3240     foreach my $overload (@{$overloads}) {
3241         my $n = @{$overload-&gt;arguments};
3242         my @t;
3243         my @o;
3244         my $isVariadic = 0;
3245         foreach my $argument (@{$overload-&gt;arguments}) {
3246             push(@t, $argument-&gt;type);
3247             if ($argument-&gt;isOptional) {
3248                 push(@o, &quot;optional&quot;);
3249             } elsif ($argument-&gt;isVariadic) {
3250                 push(@o, &quot;variadic&quot;);
3251                 $isVariadic = 1;
3252             } else {
3253                 push(@o, &quot;required&quot;);
3254             }
3255         }
3256         &amp;$addTuple([$overload, [@t], [@o]]);
3257         if ($isVariadic) {
3258             my @newT = @t;
3259             my @newO = @o;
3260             for (my $i = $n; $i &lt; $m; $i++) {
3261                 push(@newT, $t[-1]);
3262                 push(@newO, &quot;variadic&quot;);
3263                 &amp;$addTuple([$overload, [@newT], [@newO]]);
3264             }
3265         }
3266         for (my $i = $n - 1; $i &gt;= 0; $i--) {
3267             my $argument = @{$overload-&gt;arguments}[$i];
3268             last unless ($argument-&gt;isOptional || $argument-&gt;isVariadic);
3269             pop(@t);
3270             pop(@o);
3271             &amp;$addTuple([$overload, [@t], [@o]]);
3272         }
3273     }
3274     return %allSets;
3275 }
3276 
3277 sub IsIDLTypeDistinguishableWithUnionForOverloadResolution
3278 {
3279     my ($type, $unionSubtypes) = @_;
3280 
3281     assert(&quot;First type should not be a union&quot;) if $type-&gt;isUnion;
3282     for my $unionSubType (@$unionSubtypes) {
3283         return 0 unless AreTypesDistinguishableForOverloadResolution($type, $unionSubType);
3284     }
3285     return 1;
3286 }
3287 
3288 # Determines if two types are distinguishable in the context of overload resolution,
3289 # according to the Web IDL specification:
3290 # http://heycam.github.io/webidl/#dfn-distinguishable
3291 sub AreTypesDistinguishableForOverloadResolution
3292 {
3293     my ($typeA, $typeB) = @_;
3294 
3295     my $isCallbackFunctionOrDictionary = sub {
3296         my $type = shift;
3297         return $codeGenerator-&gt;IsCallbackFunction($type) || $codeGenerator-&gt;IsDictionaryType($type);
3298     };
3299 
3300     # Two types are distinguishable for overload resolution if at most one of the two includes a nullable type.
3301     return 0 if $typeA-&gt;isNullable &amp;&amp; $typeB-&gt;isNullable;
3302 
3303     # Union types: typeA and typeB  are distinguishable if:
3304     # - Both types are either a union type or nullable union type, and each member type of the one is
3305     #   distinguishable with each member type of the other.
3306     # - One type is a union type or nullable union type, the other is neither a union type nor a nullable
3307     #   union type, and each member type of the first is distinguishable with the second.
3308     if ($typeA-&gt;isUnion &amp;&amp; $typeB-&gt;isUnion) {
3309         for my $unionASubType (@{$typeA-&gt;subtypes}) {
3310             return 0 unless IsIDLTypeDistinguishableWithUnionForOverloadResolution($unionASubType, $typeB-&gt;subtypes);
3311         }
3312         return 1;
3313     } elsif ($typeA-&gt;isUnion) {
3314         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeB, $typeA-&gt;subtypes);
3315     } elsif ($typeB-&gt;isUnion) {
3316         return IsIDLTypeDistinguishableWithUnionForOverloadResolution($typeA, $typeB-&gt;subtypes);
3317     }
3318 
3319     return 0 if $typeA-&gt;name eq $typeB-&gt;name;
3320     return 0 if $typeA-&gt;name eq &quot;object&quot; or $typeB-&gt;name eq &quot;object&quot;;
3321     return 0 if $codeGenerator-&gt;IsNumericType($typeA) &amp;&amp; $codeGenerator-&gt;IsNumericType($typeB);
3322     return 0 if $codeGenerator-&gt;IsStringOrEnumType($typeA) &amp;&amp; $codeGenerator-&gt;IsStringOrEnumType($typeB);
3323     return 0 if $codeGenerator-&gt;IsDictionaryType($typeA) &amp;&amp; $codeGenerator-&gt;IsDictionaryType($typeB);
3324     return 0 if $codeGenerator-&gt;IsCallbackInterface($typeA) &amp;&amp; $codeGenerator-&gt;IsCallbackInterface($typeB);
3325     return 0 if &amp;$isCallbackFunctionOrDictionary($typeA) &amp;&amp; &amp;$isCallbackFunctionOrDictionary($typeB);
3326     return 0 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeA) &amp;&amp; $codeGenerator-&gt;IsSequenceOrFrozenArrayType($typeB);
3327     # FIXME: return 0 if $typeA and $typeB are both exception types.
3328     return 1;
3329 }
3330 
3331 # If there is more than one entry in an effective overload set that has a given type list length,
3332 # then for those entries there must be an index i such that for each pair of entries the types
3333 # at index i are distinguishable. The lowest such index is termed the distinguishing argument index.
3334 # http://heycam.github.io/webidl/#dfn-distinguishing-argument-index
3335 sub GetDistinguishingArgumentIndex
3336 {
3337     my ($operation, $S) = @_;
3338 
3339     # FIXME: Consider all the tuples, not just the 2 first ones?
3340     my $firstTupleTypes = @{@{$S}[0]}[1];
3341     my $secondTupleTypes = @{@{$S}[1]}[1];
3342     for (my $index = 0; $index &lt; scalar(@$firstTupleTypes); $index++) {
3343         return $index if AreTypesDistinguishableForOverloadResolution(@{$firstTupleTypes}[$index], @{$secondTupleTypes}[$index]);
3344     }
3345     die &quot;Undistinguishable overloads for operation &quot; . $operation-&gt;name . &quot; with length: &quot; . scalar(@$firstTupleTypes);
3346 }
3347 
3348 sub GetOverloadThatMatches
3349 {
3350     my ($S, $parameterIndex, $matches) = @_;
3351 
3352     for my $tuple (@{$S}) {
3353         my $type = @{@{$tuple}[1]}[$parameterIndex];
3354         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3355         if ($type-&gt;isUnion) {
3356             for my $subtype (GetFlattenedMemberTypes($type)) {
3357                 return @{$tuple}[0] if $matches-&gt;($subtype, $optionality);
3358             }
3359         } else {
3360             return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3361         }
3362     }
3363 }
3364 
3365 sub GetOverloadThatMatchesIgnoringUnionSubtypes
3366 {
3367     my ($S, $parameterIndex, $matches) = @_;
3368 
3369     for my $tuple (@{$S}) {
3370         my $type = @{@{$tuple}[1]}[$parameterIndex];
3371         my $optionality = @{@{$tuple}[2]}[$parameterIndex];
3372         return @{$tuple}[0] if $matches-&gt;($type, $optionality);
3373     }
3374 }
3375 
3376 sub GetConditionalForOperationConsideringOverloads
3377 {
3378     my $operation = shift;
3379 
3380     return $operation-&gt;extendedAttributes-&gt;{Conditional} unless $operation-&gt;{overloads};
3381 
3382     my %conditions;
3383     foreach my $overload (@{$operation-&gt;{overloads}}) {
3384         my $conditional = $overload-&gt;extendedAttributes-&gt;{Conditional};
3385         return unless $conditional;
3386         $conditions{$conditional} = 1;
3387     }
3388     return join(&quot;|&quot;, keys %conditions);
3389 }
3390 
3391 # Implements the overload resolution algorithm, as defined in the Web IDL specification:
3392 # http://heycam.github.io/webidl/#es-overloads
3393 sub GenerateOverloadDispatcher
3394 {
3395     my ($operation, $interface, $overloadFunctionPrefix, $overloadFunctionSuffix, $parametersToForward) = @_;
3396     
3397     my %allSets = ComputeEffectiveOverloadSet($operation-&gt;{overloads});
3398 
3399     my $generateOverloadCallIfNecessary = sub {
3400         my ($overload, $condition, $include) = @_;
3401         return unless $overload;
3402         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($overload);
3403         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3404         push(@implContent, &quot;        if ($condition)\n    &quot;) if $condition;
3405         push(@implContent, &quot;        return &quot; . $overloadFunctionPrefix . $overload-&gt;{overloadIndex} . $overloadFunctionSuffix . &quot;(${parametersToForward});\n&quot;);
3406         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3407         AddToImplIncludes($include, $overload-&gt;extendedAttributes-&gt;{Conditional}) if $include;
3408     };
3409     my $isOptionalParameter = sub {
3410         my ($type, $optionality) = @_;
3411         return $optionality eq &quot;optional&quot;;
3412     };
3413     my $isDictionaryOrRecordParameter = sub {
3414         my ($type, $optionality) = @_;
3415         return $codeGenerator-&gt;IsDictionaryType($type) || $codeGenerator-&gt;IsRecordType($type);
3416     };
3417     my $isNullableOrDictionaryOrRecordOrUnionContainingOne = sub {
3418         my ($type, $optionality) = @_;
3419         return 1 if $type-&gt;isNullable;
3420         if ($type-&gt;isUnion) {
3421             for my $subtype (GetFlattenedMemberTypes($type)) {
3422                 return 1 if $type-&gt;isNullable || &amp;$isDictionaryOrRecordParameter($subtype, $optionality);
3423             }
3424             return 0;
3425         } else {
3426             return &amp;$isDictionaryOrRecordParameter($type, $optionality);
3427         }
3428     };
3429     my $isObjectOrErrorParameter = sub {
3430         my ($type, $optionality) = @_;
3431         return $type-&gt;name eq &quot;object&quot; || $type-&gt;name eq &quot;Error&quot;;
3432     };
3433     my $isObjectOrErrorOrDOMExceptionParameter = sub {
3434         my ($type, $optionality) = @_;
3435         return 1 if &amp;$isObjectOrErrorParameter($type, $optionality);
3436         return $type-&gt;name eq &quot;DOMException&quot;;
3437     };
3438     my $isObjectOrCallbackFunctionParameter = sub {
3439         my ($type, $optionality) = @_;
3440         return $type-&gt;name eq &quot;object&quot; || $codeGenerator-&gt;IsCallbackFunction($type);
3441     };
3442     my $isSequenceOrFrozenArrayParameter = sub {
3443         my ($type, $optionality) = @_;
3444         return $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
3445     };
3446     my $isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter = sub {
3447         my ($type, $optionality) = @_;
3448         return 1 if &amp;$isDictionaryOrRecordParameter($type, $optionality);
3449         return 1 if $type-&gt;name eq &quot;object&quot;;
3450         return 1 if $codeGenerator-&gt;IsCallbackInterface($type) &amp;&amp; !$codeGenerator-&gt;IsCallbackFunction($type);
3451         return 0;
3452     };
3453     my $isBooleanParameter = sub {
3454         my ($type, $optionality) = @_;
3455         return $type-&gt;name eq &quot;boolean&quot;;
3456     };
3457     my $isNumericParameter = sub {
3458         my ($type, $optionality) = @_;
3459         return $codeGenerator-&gt;IsNumericType($type);
3460     };
3461     my $isStringOrEnumParameter = sub {
3462         my ($type, $optionality) = @_;
3463         return $codeGenerator-&gt;IsStringOrEnumType($type);
3464     };
3465     my $isAnyParameter = sub {
3466         my ($type, $optionality) = @_;
3467         return $type-&gt;name eq &quot;any&quot;;
3468     };
3469 
3470     my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
3471 
3472     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, callFrame-&gt;argumentCount());\n&quot;);
3473 
3474     for my $length ( sort keys %allSets ) {
3475         push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
3476 
3477         my $S = $allSets{$length};
3478         if (scalar(@$S) &gt; 1) {
3479             my $d = GetDistinguishingArgumentIndex($operation, $S);
3480             push(@implContent, &quot;        JSValue distinguishingArg = callFrame-&gt;uncheckedArgument($d);\n&quot;);
3481 
3482             my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
3483             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
3484 
3485             $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
3486             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefinedOrNull()&quot;);
3487 
3488             for my $tuple (@{$S}) {
3489                 my $overload = @{$tuple}[0];
3490                 my $type = @{@{$tuple}[1]}[$d];
3491 
3492                 my @subtypes = $type-&gt;isUnion ? GetFlattenedMemberTypes($type) : ( $type );
3493                 for my $subtype (@subtypes) {
3494                     if ($codeGenerator-&gt;IsWrapperType($subtype) || $codeGenerator-&gt;IsBufferSourceType($subtype)) {
3495                         if ($subtype-&gt;name eq &quot;DOMWindow&quot;) {
3496                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3497                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSDOMWindow&gt;(vm))&quot;);
3498                         } elsif ($subtype-&gt;name eq &quot;RemoteDOMWindow&quot;) {
3499                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3500                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSRemoteDOMWindow&gt;(vm))&quot;);
3501                         } else {
3502                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JS&quot; . $subtype-&gt;name . &quot;&gt;(vm)&quot;);
3503                         }
3504                     }
3505                 }
3506             }
3507 
3508             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorOrDOMExceptionParameter);
3509             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JSDOMException&gt;(vm)&quot;);
3510 
3511             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorParameter);
3512             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;type() == ErrorInstanceType&quot;);
3513 
3514             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
3515             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
3516 
3517             # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
3518             $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
3519             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(lexicalGlobalObject, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);
3520 
3521             $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
3522             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
3523 
3524             my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
3525             &amp;$generateOverloadCallIfNecessary($booleanOverload, &quot;distinguishingArg.isBoolean()&quot;);
3526 
3527             my $numericOverload = GetOverloadThatMatches($S, $d, \&amp;$isNumericParameter);
3528             &amp;$generateOverloadCallIfNecessary($numericOverload, &quot;distinguishingArg.isNumber()&quot;);
3529 
3530             # Fallbacks.
3531             $overload = GetOverloadThatMatches($S, $d, \&amp;$isStringOrEnumParameter);
3532             if ($overload) {
3533                 &amp;$generateOverloadCallIfNecessary($overload);
3534             } elsif ($numericOverload) {
3535                 &amp;$generateOverloadCallIfNecessary($numericOverload);
3536             } elsif ($booleanOverload) {
3537                 &amp;$generateOverloadCallIfNecessary($booleanOverload);
3538             } else {
3539                 $overload = GetOverloadThatMatches($S, $d, \&amp;$isAnyParameter);
3540                 &amp;$generateOverloadCallIfNecessary($overload);
3541             }
3542         } else {
3543             # Only 1 overload with this number of parameters.
3544             my $overload = @{@{$S}[0]}[0];
3545             &amp;$generateOverloadCallIfNecessary($overload);
3546         }
3547         push(@implContent, &lt;&lt;END);
3548     }
3549 END
3550     }
3551     my $minArgCount = GetFunctionLength($operation);
3552     if ($minArgCount &gt; 0) {
3553         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)
3554     } else {
3555         push(@implContent, &quot;    return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)
3556     }
3557 }
3558 
3559 # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
3560 sub GetFunctionLength
3561 {
3562     my $operation = shift;
3563 
3564     my $getOverloadLength = sub {
3565         my $operation = shift;
3566 
3567         my $length = 0;
3568         foreach my $argument (@{$operation-&gt;arguments}) {
3569             last if $argument-&gt;isOptional || $argument-&gt;isVariadic;
3570             $length++;
3571         }
3572         return $length;
3573     };
3574 
3575     my $length = &amp;$getOverloadLength($operation);
3576     foreach my $overload (@{$operation-&gt;{overloads}}) {
3577         my $newLength = &amp;$getOverloadLength($overload);
3578         $length = $newLength if $newLength &lt; $length;
3579     }
3580     return $length;
3581 }
3582 
3583 sub LengthOfLongestOperationParameterList
3584 {
3585     my ($overloads) = @_;
3586     my $result = 0;
3587     foreach my $overload (@{$overloads}) {
3588         my @arguments = @{$overload-&gt;arguments};
3589         $result = @arguments if $result &lt; @arguments;
3590     }
3591     return $result;
3592 }
3593 
3594 # See http://refspecs.linux-foundation.org/cxxabi-1.83.html.
3595 sub GetGnuVTableRefForInterface
3596 {
3597     my $interface = shift;
3598     my $vtableName = GetGnuVTableNameForInterface($interface);
3599     if (!$vtableName) {
3600         return &quot;0&quot;;
3601     }
3602     my $typename = $interface-&gt;type-&gt;name;
3603     my $offset = GetGnuVTableOffsetForType($typename);
3604     return &quot;&amp;&quot; . $vtableName . &quot;[&quot; . $offset . &quot;]&quot;;
3605 }
3606 
3607 sub GetGnuVTableNameForInterface
3608 {
3609     my $interface = shift;
3610     my $typename = $interface-&gt;type-&gt;name;
3611     my $templatePosition = index($typename, &quot;&lt;&quot;);
3612     return &quot;&quot; if $templatePosition != -1;
3613     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3614     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3615     return &quot;_ZTV&quot; . GetGnuMangledNameForInterface($interface);
3616 }
3617 
3618 sub GetGnuMangledNameForInterface
3619 {
3620     my $interface = shift;
3621     my $typename = $interface-&gt;type-&gt;name;
3622     my $templatePosition = index($typename, &quot;&lt;&quot;);
3623     if ($templatePosition != -1) {
3624         return &quot;&quot;;
3625     }
3626     my $mangledType = length($typename) . $typename;
3627     my $namespace = &quot;WebCore&quot;;
3628     my $mangledNamespace =  &quot;N&quot; . length($namespace) . $namespace;
3629     return $mangledNamespace . $mangledType . &quot;E&quot;;
3630 }
3631 
3632 sub GetGnuVTableOffsetForType
3633 {
3634     my $typename = shift;
3635     if ($typename eq &quot;ApplePaySession&quot;
3636         || $typename eq &quot;SVGAElement&quot;
3637         || $typename eq &quot;SVGCircleElement&quot;
3638         || $typename eq &quot;SVGClipPathElement&quot;
3639         || $typename eq &quot;SVGDefsElement&quot;
3640         || $typename eq &quot;SVGEllipseElement&quot;
3641         || $typename eq &quot;SVGForeignObjectElement&quot;
3642         || $typename eq &quot;SVGGElement&quot;
3643         || $typename eq &quot;SVGImageElement&quot;
3644         || $typename eq &quot;SVGLineElement&quot;
3645         || $typename eq &quot;SVGPathElement&quot;
3646         || $typename eq &quot;SVGPolyElement&quot;
3647         || $typename eq &quot;SVGPolygonElement&quot;
3648         || $typename eq &quot;SVGPolylineElement&quot;
3649         || $typename eq &quot;SVGRectElement&quot;
3650         || $typename eq &quot;SVGSVGElement&quot;
3651         || $typename eq &quot;SVGGeometryElement&quot;
3652         || $typename eq &quot;SVGGraphicsElement&quot;
3653         || $typename eq &quot;SVGSwitchElement&quot;
3654         || $typename eq &quot;SVGTextElement&quot;
3655         || $typename eq &quot;SVGUseElement&quot;) {
3656         return &quot;3&quot;;
3657     }
3658     return &quot;2&quot;;
3659 }
3660 
3661 # See http://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B_Name_Mangling.
3662 sub GetWinVTableRefForInterface
3663 {
3664     my $interface = shift;
3665     my $vtableName = GetWinVTableNameForInterface($interface);
3666     return 0 if !$vtableName;
3667     return &quot;__identifier(\&quot;&quot; . $vtableName . &quot;\&quot;)&quot;;
3668 }
3669 
3670 sub GetWinVTableNameForInterface
3671 {
3672     my $interface = shift;
3673     my $typename = $interface-&gt;type-&gt;name;
3674     my $templatePosition = index($typename, &quot;&lt;&quot;);
3675     return &quot;&quot; if $templatePosition != -1;
3676     return &quot;&quot; if GetImplementationLacksVTableForInterface($interface);
3677     return &quot;&quot; if GetSkipVTableValidationForInterface($interface);
3678     return &quot;??_7&quot; . GetWinMangledNameForInterface($interface) . &quot;6B@&quot;;
3679 }
3680 
3681 sub GetWinMangledNameForInterface
3682 {
3683     my $interface = shift;
3684     my $typename = $interface-&gt;type-&gt;name;
3685     my $namespace = &quot;WebCore&quot;;
3686     return $typename . &quot;@&quot; . $namespace . &quot;@@&quot;;
3687 }
3688 
3689 sub GetImplementationLacksVTableForInterface
3690 {
3691     my $interface = shift;
3692     return $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
3693 }
3694 
3695 sub GetSkipVTableValidationForInterface
3696 {
3697     my $interface = shift;
3698     return $interface-&gt;extendedAttributes-&gt;{SkipVTableValidation};
3699 }
3700 
3701 # URL becomes url, but SetURL becomes setURL.
3702 sub ToMethodName
3703 {
3704     my $param = shift;
3705     my $ret = lcfirst($param);
3706     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
3707     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
3708     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
3709     $ret =~ s/hDR/hdr/ if $ret =~ /^hDR/;
3710     $ret =~ s/jS/js/ if $ret =~ /^jS/;
3711     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
3712     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
3713     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
3714 
3715     # For HTML5 FileSystem API Flags attributes.
3716     # (create is widely used to instantiate an object and must be avoided.)
3717     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
3718     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
3719 
3720     return $ret;
3721 }
3722 
3723 sub GenerateRuntimeEnableConditionalStringForExposed
3724 {
3725     my ($interface, $context, $conjuncts, $globalObjectIsParam) = @_;
3726 
3727     assert(&quot;Must specify value for Exposed.&quot;) if $context-&gt;extendedAttributes-&gt;{Exposed} eq &quot;VALUE_IS_MISSING&quot;;
3728 
3729     AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3730 
3731     my $exposed = $context-&gt;extendedAttributes-&gt;{Exposed};
3732     if (ref($exposed) eq &#39;ARRAY&#39;) {
3733         if (scalar(@$exposed) &gt; 1) {
3734             return;
3735         }
3736         $exposed = @$exposed[0];
3737     }
3738 
3739     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;
3740 
3741     if ($exposed eq &quot;Window&quot;) {
3742         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isDocument()&quot;);
3743     } elsif ($exposed eq &quot;Worker&quot;) {
3744         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkerGlobalScope()&quot;);
3745     } elsif ($exposed eq &quot;Worklet&quot;) {
3746         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkletGlobalScope()&quot;);
3747     } else {
3748         assert(&quot;Unrecognized value &#39;&quot; . Dumper($context-&gt;extendedAttributes-&gt;{Exposed}) . &quot;&#39; for the Exposed extended attribute on &#39;&quot; . ref($context) . &quot;&#39;.&quot;);
3749     }
3750 }
3751 
3752 # Returns the conditional string that determines whether a method/attribute is enabled at runtime.
3753 # A method/attribute is enabled at runtime if either its RuntimeEnabledFeatures function returns
3754 # true or its EnabledForWorld function returns true (or both).
3755 # NOTE: Parameter passed in must have an &#39;extendedAttributes&#39; property.
3756 # (e.g. IDLInterface, IDLAttribute, IDLOperation, IDLIterable, etc.)
3757 sub GenerateRuntimeEnableConditionalString
3758 {
3759     my ($interface, $context, $globalObjectIsParam) = @_;
3760 
3761     my @conjuncts;
3762     my $globalObjectPtr = $globalObjectIsParam ? $globalObjectIsParam : &quot;globalObject()&quot;;
3763     
3764     if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
3765         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3766 
3767         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3768             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3769                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme())&quot;);
3770         } elsif ($context-&gt;extendedAttributes-&gt;{ContextAllowsMediaDevices}) {
3771             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3772                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;allowsMediaDevices())&quot;);
3773         } else {
3774             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(globalObject())-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;);
3775         }
3776     } else {
3777         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3778             AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3779 
3780             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme()&quot;);
3781         }
3782     }
3783 
3784     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
3785         GenerateRuntimeEnableConditionalStringForExposed($interface, $context, \@conjuncts);
3786     }
3787 
3788     if ($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) {
3789         assert(&quot;Must specify value for EnabledForWorld.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledForWorld} eq &quot;VALUE_IS_MISSING&quot;;
3790 
3791         AddToImplIncludes(&quot;DOMWrapperWorld.h&quot;);
3792 
3793         push(@conjuncts, &quot;worldForDOMObject(*this).&quot; . ToMethodName($context-&gt;extendedAttributes-&gt;{EnabledForWorld}) . &quot;()&quot;);
3794     }
3795 
3796     if ($context-&gt;extendedAttributes-&gt;{EnabledBySetting}) {
3797         assert(&quot;Must specify value for EnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3798 
3799         AddToImplIncludes(&quot;Document.h&quot;);
3800         AddToImplIncludes(&quot;Settings.h&quot;);
3801 
3802         assert(&quot;EnabledBySetting can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3803 
3804         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledBySetting});
3805         foreach my $flag (@flags) {
3806             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3807         }
3808     }
3809 
3810     if ($context-&gt;extendedAttributes-&gt;{CustomEnabled}) {
3811         assert(&quot;CustomEnabled can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3812 
3813         my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
3814         push(@conjuncts, &quot;${className}&quot; . $codeGenerator-&gt;WK_ucfirst($context-&gt;name) . &quot;IsEnabled()&quot;);
3815     }
3816 
3817     if ($context-&gt;extendedAttributes-&gt;{DisabledByQuirk}) {
3818         assert(&quot;Must specify value for DisabledByQuirk.&quot;) if $context-&gt;extendedAttributes-&gt;{DisabledByQuirk} eq &quot;VALUE_IS_MISSING&quot;;
3819 
3820         AddToImplIncludes(&quot;Document.h&quot;);
3821         AddToImplIncludes(&quot;Quirks.h&quot;);
3822 
3823         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3824 
3825         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3826         foreach my $flag (@flags) {
3827             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3828         }
3829     }
3830 
3831     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3832         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3833 
3834         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3835 
3836         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3837         foreach my $flag (@flags) {
3838             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3839         }
3840     }
3841 
3842     if ($context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {
3843         assert(&quot;Must specify value for RuntimeConditionallyReadWrite.&quot;) if $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite} eq &quot;VALUE_IS_MISSING&quot;;
3844 
3845         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3846 
3847         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite});
3848         foreach my $flag (@flags) {
3849             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3850         }
3851     }
3852 
3853     if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {
3854         assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;
3855         assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);
3856 
3857         my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;
3858         my $name = $context-&gt;name;
3859         push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);
3860     }
3861 
3862     if ($context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {
3863         assert(&quot;Must specify value for ConstructorEnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;
3864 
3865         my @settings = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting});
3866         foreach my $setting (@settings) {
3867             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($setting) . &quot;Enabled()&quot;);
3868         }
3869     }
3870 
3871     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3872     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3873     return $result;
3874 }
3875 
3876 sub GetCastingHelperForThisObject
3877 {
3878     my $interface = shift;
3879     my $interfaceName = $interface-&gt;type-&gt;name;
3880     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3881 }
3882 
3883 # http://heycam.github.io/webidl/#Unscopable
3884 sub addUnscopableProperties
3885 {
3886     my $interface = shift;
3887 
3888     my @unscopables;
3889     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3890         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3891     }
3892     return if scalar(@unscopables) == 0;
3893 
3894     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
3895     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;vm(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);
3896     foreach my $unscopable (@unscopables) {
3897         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);
3898     }
3899     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3900 }
3901 
3902 sub GetArgumentTypeForFunctionWithoutTypeCheck
3903 {
3904     my ($interface, $type) = @_;
3905 
3906     my $IDLType = GetIDLType($interface, $type);
3907     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3908 }
3909 
3910 sub GetArgumentTypeFilter
3911 {
3912     my ($interface, $type) = @_;
3913 
3914     my $IDLType = GetIDLType($interface, $type);
3915     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
3916 }
3917 
3918 sub GetResultTypeFilter
3919 {
3920     my ($interface, $type) = @_;
3921 
3922     my $IDLType = GetIDLType($interface, $type);
3923     return &quot;DOMJIT::IDLResultTypeFilter&lt;${IDLType}&gt;::value&quot;;
3924 }
3925 
3926 sub GetAttributeWithName
3927 {
3928     my ($interface, $attributeName) = @_;
3929     
3930     foreach my $attribute (@{$interface-&gt;attributes}) {
3931         return $attribute if $attribute-&gt;name eq $attributeName;
3932     }
3933 }
3934 
3935 # https://heycam.github.io/webidl/#es-iterator
3936 sub InterfaceNeedsIterator
3937 {
3938     my ($interface) = @_;
3939 
3940     return 1 if $interface-&gt;setLike;
3941     return 1 if $interface-&gt;mapLike;
3942     return 1 if $interface-&gt;iterable;
3943 
3944     if (GetIndexedGetterOperation($interface)) {
3945         my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
3946         return 1 if $lengthAttribute and $codeGenerator-&gt;IsIntegerType($lengthAttribute-&gt;type);
3947     }
3948     return 0;
3949 }
3950 
3951 sub GenerateImplementation
3952 {
3953     my ($object, $interface, $enumerations, $dictionaries) = @_;
3954 
3955     my $interfaceName = $interface-&gt;type-&gt;name;
3956     my $className = &quot;JS$interfaceName&quot;;
3957 
3958     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
3959     my $parentClassName = GetParentClassName($interface);
3960     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
3961     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
3962 
3963     my $namedGetterOperation = GetNamedGetterOperation($interface);
3964     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
3965 
3966     # - Add default header template
3967     push(@implContentHeader, GenerateImplementationContentHeader($interface));
3968 
3969     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
3970     AddToImplIncludes(&quot;JSDOMBinding.h&quot;);
3971     AddToImplIncludes(&quot;JSDOMExceptionHandling.h&quot;);
3972     AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
3973     AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
3974     AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
3975     AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
3976     AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;
3977     AddToImplIncludes(&quot;JSDOMSetLike.h&quot;) if $interface-&gt;setLike;
3978     AddJSBuiltinIncludesIfNeeded($interface);
3979 
3980     my $implType = GetImplClassName($interface);
3981 
3982     @implContent = ();
3983 
3984     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
3985     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
3986 
3987     push(@implContent, GenerateEnumerationsImplementationContent($interface, $enumerations));
3988     push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
3989 
3990     my @operations = @{$interface-&gt;operations};
3991     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3992     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
3993     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;
3994     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3995 
3996     my @attributes = @{$interface-&gt;attributes};
3997     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
3998     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;
3999 
4000     my $numConstants = @{$interface-&gt;constants};
4001     my $numOperations = @operations;
4002     my $numAttributes = @attributes;
4003 
4004     if ($numOperations &gt; 0) {
4005         my $inAppleCopyright = 0;
4006         push(@implContent,&quot;// Functions\n\n&quot;);
4007         foreach my $operation (@operations) {
4008             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4009             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4010             next if IsJSBuiltin($interface, $operation);
4011 
4012             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
4013                 if (!$inAppleCopyright) {
4014                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
4015                     $inAppleCopyright = 1;
4016                 }
4017             } elsif ($inAppleCopyright) {
4018                 push(@implContent, $endAppleCopyright);
4019                 $inAppleCopyright = 0;
4020             }
4021 
4022             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
4023             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
4024             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4025             my $functionName = GetFunctionName($interface, $className, $operation);
4026             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);
4027             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4028                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
4029                 my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
4030                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject*, $className*&quot;;
4031                 foreach my $argument (@{$operation-&gt;arguments}) {
4032                     my $type = $argument-&gt;type;
4033                     my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
4034                     $functionSignature .= &quot;, ${argumentType}&quot;;
4035                 }
4036                 push(@implContent, $functionSignature . &quot;);\n&quot;);
4037             }
4038             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4039         }
4040 
4041         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
4042         push(@implContent, &quot;\n&quot;);
4043     }
4044 
4045     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4046         push(@implContent, &quot;// Attributes\n\n&quot;);
4047 
4048         if (NeedsConstructorProperty($interface)) {
4049             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4050             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
4051 
4052             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4053             push(@implContent, &quot;bool ${constructorSetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
4054         }
4055 
4056         foreach my $attribute (@attributes) {
4057             next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4058             next if IsJSBuiltin($interface, $attribute);
4059 
4060             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4061             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4062             my $getter = GetAttributeGetterName($interface, $className, $attribute);
4063             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);
4064             if (!IsReadonly($attribute)) {
4065                 my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4066                 if ($readWriteConditional) {
4067                     my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
4068                     push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
4069                 }
4070                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4071                 push(@implContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);
4072                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
4073             }
4074             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4075         }
4076 
4077         push(@implContent, &quot;\n&quot;);
4078     }
4079 
4080     if ($numOperations &gt; 0) {
4081         foreach my $operation (@operations) {
4082             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
4083             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
4084             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
4085 
4086             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
4087             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
4088             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
4089 
4090             my $interfaceName = $interface-&gt;type-&gt;name;
4091             my $functionName = GetFunctionName($interface, $className, $operation);
4092             my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
4093             my $domJITSignatureName = &quot;DOMJITSignatureFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name);
4094             my $classInfo = &quot;JS&quot; . $interface-&gt;type-&gt;name . &quot;::info()&quot;;
4095             my $resultType = GetResultTypeFilter($interface, $operation-&gt;type);
4096             my $domJITSignatureHeader = &quot;static const JSC::DOMJIT::Signature ${domJITSignatureName}(${nameOfFunctionWithoutTypeCheck},&quot;;
4097             my $domJITSignatureFooter = &quot;$classInfo, JSC::DOMJIT::Effect::forRead(DOMJIT::AbstractHeapRepository::DOM), ${resultType}&quot;;
4098             foreach my $argument (@{$operation-&gt;arguments}) {
4099                 my $type = $argument-&gt;type;
4100                 my $argumentType = GetArgumentTypeFilter($interface, $type);
4101                 $domJITSignatureFooter .= &quot;, ${argumentType}&quot;;
4102             }
4103             $domJITSignatureFooter .= &quot;);&quot;;
4104             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4105             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4106             push(@implContent, &quot;$domJITSignatureHeader $domJITSignatureFooter\n&quot;);
4107             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4108             push(@implContent, &quot;\n&quot;);
4109         }
4110     }
4111 
4112     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4113         foreach my $attribute (@attributes) {
4114             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4115             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
4116 
4117             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4118             push(@implContent, &quot;#if ${conditionalString}\n\n&quot;) if $conditionalString;
4119             AddToImplIncludes(&quot;DOMJITIDLTypeFilter.h&quot;, $conditionalString);
4120             my $interfaceName = $interface-&gt;type-&gt;name;
4121             my $generatorName = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
4122             my $domJITClassName = $generatorName . &quot;Attribute&quot;;
4123             my $getter = GetAttributeGetterName($interface, $generatorName, $attribute);
4124             my $resultType = &quot;JSC::SpecBytecodeTop&quot;;
4125             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4126                 $resultType = GetResultTypeFilter($interface, $attribute-&gt;type);
4127             }
4128             push(@implContent, &quot;static const JSC::DOMJIT::GetterSetter DOMJITAttributeFor${generatorName} {\n&quot;);
4129             push(@implContent, &quot;    $getter,\n&quot;);
4130             push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4131             push(@implContent, &quot;    &amp;compile${domJITClassName},\n&quot;);
4132             push(@implContent, &quot;#else\n&quot;);
4133             push(@implContent, &quot;    nullptr,\n&quot;);
4134             push(@implContent, &quot;#endif\n&quot;);
4135             push(@implContent, &quot;    $resultType\n&quot;);
4136             push(@implContent, &quot;};\n\n&quot;);
4137             push(@implContent, &quot;#endif\n\n&quot;) if $conditionalString;
4138         }
4139     }
4140 
4141     GeneratePrototypeDeclaration(\@implContent, $className, $interface) if !HeaderNeedsPrototypeDeclaration($interface);
4142 
4143     GenerateConstructorDeclaration(\@implContent, $className, $interface) if NeedsConstructorProperty($interface);
4144 
4145     my @hashKeys = ();
4146     my @hashValue1 = ();
4147     my @hashValue2 = ();
4148     my @hashSpecials = ();
4149     my %conditionals = ();
4150     my %readWriteConditionals = ();
4151     my $hashName = $className . &quot;Table&quot;;
4152     my @runtimeEnabledOperations = ();
4153     my @runtimeEnabledAttributes = ();
4154 
4155     # Generate hash table for properties on the instance.
4156     my $numInstanceProperties = GeneratePropertiesHashTable($object, $interface, 1, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4157     $object-&gt;GenerateHashTable($className, $hashName, $numInstanceProperties, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 0) if $numInstanceProperties &gt; 0;
4158 
4159     # - Add all interface object (aka constructor) properties (constants, static attributes, static operations).
4160     if (NeedsConstructorProperty($interface)) {
4161         my $hashSize = 0;
4162         my $hashName = $className . &quot;ConstructorTable&quot;;
4163 
4164         my @hashKeys = ();
4165         my @hashValue1 = ();
4166         my @hashValue2 = ();
4167         my @hashSpecials = ();
4168         my %conditionals = ();
4169         my %readWriteConditionals = ();
4170 
4171         my $needsConstructorTable = 0;
4172 
4173         foreach my $constant (@{$interface-&gt;constants}) {
4174             my $name = $constant-&gt;name;
4175             push(@hashKeys, $name);
4176             push(@hashValue1, $constant-&gt;value);
4177             push(@hashValue2, &quot;0&quot;);
4178             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4179 
4180             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
4181             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
4182 
4183             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4184             $conditionals{$name} = $conditional if $conditional;
4185 
4186             $hashSize++;
4187         }
4188 
4189         foreach my $attribute (@{$interface-&gt;attributes}) {
4190             next unless ($attribute-&gt;isStatic);
4191             my $name = $attribute-&gt;name;
4192             push(@hashKeys, $name);
4193 
4194             my @specials = ();
4195             push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
4196             push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
4197             push(@specials, &quot;JSC::PropertyAttribute::DOMAttribute&quot;) if IsAcceleratedDOMAttribute($interface, $attribute);
4198             push(@specials, &quot;JSC::PropertyAttribute::DOMJITAttribute&quot;) if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
4199             my $special = &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
4200             push(@hashSpecials, $special);
4201 
4202             if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
4203                 push(@hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
4204             } else {
4205                 my $getter = GetAttributeGetterName($interface, $className, $attribute);
4206                 push(@hashValue1, $getter);
4207             }
4208 
4209             if (IsReadonly($attribute)) {
4210                 push(@hashValue2, &quot;0&quot;);
4211             } else {
4212                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
4213                 push(@hashValue2, $setter);
4214             }
4215 
4216             my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4217             $conditionals{$name} = $conditional if $conditional;
4218 
4219             my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4220             $readWriteConditionals{$name} = $readWriteConditional if $readWriteConditional;
4221 
4222             $hashSize++;
4223         }
4224 
4225         foreach my $operation (@{$interface-&gt;operations}) {
4226             next unless ($operation-&gt;isStatic);
4227             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4228             my $name = $operation-&gt;name;
4229             push(@hashKeys, $name);
4230 
4231             my $functionName = GetFunctionName($interface, $className, $operation);
4232             push(@hashValue1, $functionName);
4233 
4234             my $functionLength = GetFunctionLength($operation);
4235             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4236                 push(@hashValue2, &quot;DOMJITFunctionFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($operation-&gt;name));
4237             } else {
4238                 push(@hashValue2, $functionLength);
4239             }
4240 
4241             push(@hashSpecials, ComputeFunctionSpecial($interface, $operation));
4242 
4243             my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
4244             $conditionals{$name} = $conditional if $conditional;
4245 
4246             $hashSize++;
4247         }
4248 
4249         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
4250 
4251         push(@implContent, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interface));
4252 
4253         my $protoClassName = &quot;${className}Prototype&quot;;
4254         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $visibleInterfaceName, $interface);
4255 
4256         my $namedConstructor = $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
4257         GenerateConstructorDefinitions(\@implContent, $className, $protoClassName, $namedConstructor, $interface, &quot;GeneratingNamedConstructor&quot;) if $namedConstructor;
4258     }
4259 
4260     # - Add functions and constants to a hashtable definition
4261 
4262     $hashName = $className . &quot;PrototypeTable&quot;;
4263 
4264     @hashKeys = ();
4265     @hashValue1 = ();
4266     @hashValue2 = ();
4267     @hashSpecials = ();
4268     %conditionals = ();
4269     %readWriteConditionals = ();
4270     @runtimeEnabledOperations = ();
4271     @runtimeEnabledAttributes = ();
4272 
4273     # Generate hash table for properties on the prototype.
4274     my $numPrototypeProperties = GeneratePropertiesHashTable($object, $interface, 0,
4275         \@hashKeys, \@hashSpecials,
4276         \@hashValue1, \@hashValue2,
4277         \%conditionals, \%readWriteConditionals,
4278         \@runtimeEnabledOperations, \@runtimeEnabledAttributes);
4279 
4280     my $hashSize = $numPrototypeProperties;
4281 
4282     foreach my $constant (@{$interface-&gt;constants}) {
4283         my $name = $constant-&gt;name;
4284 
4285         push(@hashKeys, $name);
4286         push(@hashValue1, $constant-&gt;value);
4287         push(@hashValue2, &quot;0&quot;);
4288         push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4289 
4290         my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4291         $conditionals{$name} = $conditional if $conditional;
4292 
4293         $hashSize++;
4294     }
4295 
4296     my $justGenerateValueArray = !IsDOMGlobalObject($interface);
4297 
4298     $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, $justGenerateValueArray);
4299 
4300     if ($justGenerateValueArray) {
4301         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4302     } else {
4303         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4304     }
4305 
4306     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalInterface($interface)) {
4307         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4308         push(@implContent, &quot;{\n&quot;);
4309         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4310         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4311 
4312         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4313         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4314 
4315         if (@runtimeEnabledProperties) {
4316             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4317         }
4318 
4319         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4320             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4321             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4322             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4323             my $name = $operationOrAttribute-&gt;name;
4324             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4325             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
4326             push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
4327             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
4328             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject(), propertyName);\n&quot;);
4329             push(@implContent, &quot;    }\n&quot;);
4330             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4331         }
4332 
4333         foreach my $attribute (@runtimeEnabledAttributes) {
4334             if ($attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {
4335                 AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4336                 my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4337 
4338                 my $attributeName = $attribute-&gt;name;
4339                 my $getter = GetAttributeGetterName($interface, $className, $attribute);
4340                 my $setter = &quot;nullptr&quot;;
4341                 my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4342 
4343                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4344                 push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4345                 push(@implContent, &quot;    // Adding back attribute, but as readonly, after removing the read-write variant above. \n&quot;);
4346                 push(@implContent, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);
4347                 push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4348                 push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4349             }
4350         }
4351 
4352         if (@runtimeEnabledProperties) {
4353             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4354             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4355         }
4356 
4357         foreach my $operation (@{$interface-&gt;operations}) {
4358             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4359             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4360             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4361             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4362             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4363             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4364         }
4365 
4366         if (InterfaceNeedsIterator($interface)) {
4367             AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
4368             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike or $interface-&gt;setLike) {
4369                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4370             } else {
4371                 AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
4372                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4373             }
4374         }
4375         push(@implContent, &quot;    addValueIterableMethods(*globalObject(), *this);\n&quot;) if $interface-&gt;iterable and !IsKeyValueIterableInterface($interface);
4376 
4377         addUnscopableProperties($interface);
4378 
4379         push(@implContent, &quot;}\n\n&quot;);
4380     }
4381 
4382     # - Initialize static ClassInfo object
4383     push(@implContent, &quot;const ClassInfo $className&quot; . &quot;::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, &quot;);
4384 
4385     if ($numInstanceProperties &gt; 0) {
4386         push(@implContent, &quot;&amp;${className}Table&quot;);
4387     } else {
4388         push(@implContent, &quot;nullptr&quot;);
4389     }
4390     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
4391         push(@implContent, &quot;\n&quot;);
4392         push(@implContent, &quot;#if ENABLE(JIT)\n&quot;);
4393         push(@implContent, &quot;, &amp;checkSubClassSnippetFor${className}\n&quot;);
4394         push(@implContent, &quot;#else\n&quot;);
4395         push(@implContent, &quot;, nullptr\n&quot;);
4396         push(@implContent, &quot;#endif\n&quot;);
4397     } else {
4398         push(@implContent, &quot;, nullptr&quot;);
4399     }
4400     push(@implContent, &quot;, CREATE_METHOD_TABLE($className) };\n\n&quot;);
4401 
4402     # Constructor
4403     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4404         AddIncludesForImplementationTypeInImpl(&quot;JSWindowProxy&quot;);
4405         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl, JSWindowProxy* proxy)\n&quot;);
4406         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl), proxy)\n&quot;);
4407         push(@implContent, &quot;{\n&quot;);
4408         push(@implContent, &quot;}\n\n&quot;);
4409     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4410         AddIncludesForImplementationTypeInImpl($interfaceName);
4411         push(@implContent, &quot;${className}::$className(VM&amp; vm, Structure* structure, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4412         push(@implContent, &quot;    : $parentClassName(vm, structure, WTFMove(impl))\n&quot;);
4413         push(@implContent, &quot;{\n&quot;);
4414         push(@implContent, &quot;}\n\n&quot;);
4415     } elsif (!NeedsImplementationClass($interface)) {
4416         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4417         push(@implContent, &quot;    : $parentClassName(structure, globalObject) { }\n\n&quot;);
4418     } else {
4419         push(@implContent, &quot;${className}::$className(Structure* structure, JSDOMGlobalObject&amp; globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4420         push(@implContent, &quot;    : $parentClassName(structure, globalObject, WTFMove(impl))\n&quot;);
4421         push(@implContent, &quot;{\n&quot;);
4422         push(@implContent, &quot;}\n\n&quot;);
4423     }
4424 
4425     # Finish Creation
4426     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4427         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSWindowProxy* proxy)\n&quot;);
4428         push(@implContent, &quot;{\n&quot;);
4429         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4430     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4431         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSProxy* proxy)\n&quot;);
4432         push(@implContent, &quot;{\n&quot;);
4433         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4434     } else {
4435         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm)\n&quot;);
4436         push(@implContent, &quot;{\n&quot;);
4437         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4438         push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
4439     }
4440 
4441     if (!$codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;JSBuiltin&quot;)) {
4442         AddToImplIncludes(&quot;ActiveDOMObject.h&quot;);
4443         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {
4444             push(@implContent, &quot;    static_assert(std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.\&quot;);\n\n&quot;);
4445         } else {
4446             push(@implContent, &quot;    static_assert(!std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.\&quot;);\n\n&quot;);
4447         }
4448     }
4449 
4450     if ($interfaceName eq &quot;Location&quot;) {
4451         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4452         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4453     }
4454 
4455     # Support for RuntimeEnabled attributes on instances.
4456     foreach my $attribute (@{$interface-&gt;attributes}) {
4457         next unless NeedsRuntimeCheck($interface, $attribute);
4458         next unless AttributeShouldBeOnInstance($interface, $attribute);
4459 
4460         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4461         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4462         my $attributeName = $attribute-&gt;name;
4463         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4464         my $setter = IsReadonly($attribute) ? &quot;nullptr&quot; : GetAttributeSetterName($interface, $className, $attribute);
4465         my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4466 
4467         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4468         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4469         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4470         push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4471         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4472     }
4473 
4474     # Support PrivateIdentifier attributes on instances.
4475     foreach my $attribute (@{$interface-&gt;attributes}) {
4476         next unless $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier};
4477         next unless AttributeShouldBeOnInstance($interface, $attribute);
4478 
4479         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4480         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4481         my $attributeName = $attribute-&gt;name;
4482         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4483 
4484         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4485         push(@implContent, &quot;    putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PrivateName(), CustomGetterSetter::create(vm, $getter, nullptr), attributesForStructure(JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly));\n&quot;);
4486         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4487     }
4488 
4489     # Support for RuntimeEnabled operations on instances.
4490     foreach my $operation (@{$interface-&gt;operations}) {
4491         next unless NeedsRuntimeCheck($interface, $operation);
4492         next unless OperationShouldBeOnInstance($interface, $operation);
4493         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4494 
4495         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4496         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation);
4497         my $functionName = $operation-&gt;name;
4498         my $implementationFunction = GetFunctionName($interface, $className, $operation);
4499         my $functionLength = GetFunctionLength($operation);
4500         my $jsAttributes = ComputeFunctionSpecial($interface, $operation);
4501 
4502         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4503         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4504         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4505         my $propertyName = &quot;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $functionName . ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} ? &quot;PrivateName()&quot; : &quot;PublicName()&quot;);
4506         if (IsJSBuiltin($interface, $operation)) {
4507             push(@implContent, &quot;        putDirectBuiltinFunction(vm, this, $propertyName, $implementationFunction(vm), attributesForStructure($jsAttributes));\n&quot;);
4508         } else {
4509             push(@implContent, &quot;        putDirectNativeFunction(vm, this, $propertyName, $functionLength, $implementationFunction, NoIntrinsic, attributesForStructure($jsAttributes));\n&quot;);
4510         }
4511         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4512     }
4513     push(@implContent, &quot;}\n\n&quot;);
4514 
4515     unless (ShouldUseGlobalObjectPrototype($interface)) {
4516         push(@implContent, &quot;JSObject* ${className}::createPrototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4517         push(@implContent, &quot;{\n&quot;);
4518         if ($interface-&gt;parentType) {
4519             my $parentClassNameForPrototype = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
4520             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, ${parentClassNameForPrototype}::prototype(vm, globalObject)));\n&quot;);
4521         } else {
4522             my $prototype = $interface-&gt;isException ? &quot;errorPrototype&quot; : &quot;objectPrototype&quot;;
4523             push(@implContent, &quot;    return ${className}Prototype::create(vm, &amp;globalObject, ${className}Prototype::createStructure(vm, &amp;globalObject, globalObject.${prototype}()));\n&quot;);
4524         }
4525         push(@implContent, &quot;}\n\n&quot;);
4526 
4527         push(@implContent, &quot;JSObject* ${className}::prototype(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
4528         push(@implContent, &quot;{\n&quot;);
4529         push(@implContent, &quot;    return getDOMPrototype&lt;${className}&gt;(vm, globalObject);\n&quot;);
4530         push(@implContent, &quot;}\n\n&quot;);
4531     }
4532 
4533     if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4534         push(@implContent, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
4535         push(@implContent, &quot;{\n&quot;);
4536         push(@implContent, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4537         push(@implContent, &quot;}\n\n&quot;);
4538 
4539         if ($interface-&gt;extendedAttributes-&gt;{NamedConstructor}) {
4540             push(@implContent, &quot;JSValue ${className}::getNamedConstructor(VM&amp; vm, JSGlobalObject* globalObject)\n&quot;);
4541             push(@implContent, &quot;{\n&quot;);
4542             push(@implContent, &quot;    return getDOMConstructor&lt;${className}NamedConstructor&gt;(vm, *jsCast&lt;JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
4543             push(@implContent, &quot;}\n\n&quot;);
4544         }
4545     }
4546 
4547     if (!$hasParent) {
4548         push(@implContent, &quot;void ${className}::destroy(JSC::JSCell* cell)\n&quot;);
4549         push(@implContent, &quot;{\n&quot;);
4550         push(@implContent, &quot;    ${className}* thisObject = static_cast&lt;${className}*&gt;(cell);\n&quot;);
4551         push(@implContent, &quot;    thisObject-&gt;${className}::~${className}();\n&quot;);
4552         push(@implContent, &quot;}\n\n&quot;);
4553     }
4554 
4555     if (InstanceOverridesGetOwnPropertySlot($interface)) {
4556         GenerateGetOwnPropertySlot(\@implContent, $interface, $className);
4557         GenerateGetOwnPropertySlotByIndex(\@implContent, $interface, $className);
4558     }
4559     
4560     if (InstanceOverridesGetOwnPropertyNames($interface)) {
4561         GenerateGetOwnPropertyNames(\@implContent, $interface, $className);
4562     }
4563     
4564     if (InstanceOverridesPut($interface)) {
4565         GeneratePut(\@implContent, $interface, $className);
4566         GeneratePutByIndex(\@implContent, $interface, $className);
4567     }
4568     
4569     if (InstanceOverridesDefineOwnProperty($interface)) {
4570         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4571     }
4572 
4573     if (InstanceOverridesDeleteProperty($interface)) {
4574         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4575     }
4576     
4577     if (InstanceOverridesGetCallData($interface)) {
4578         GenerateGetCallData(\@implContent, $interface, $className);
4579     }
4580     
4581     if ($numAttributes &gt; 0) {
4582         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4583 
4584         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4585         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4586         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
4587             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);
4588             push(@implContent, &quot;{\n&quot;);
4589             push(@implContent, &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);
4590             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4591             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
4592             push(@implContent, &quot;        decodedThisValue = JSValue(&amp;lexicalGlobalObject).toThis(&amp;lexicalGlobalObject, NotStrictMode);\n&quot;);
4593             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);\n&quot;);
4594             push(@implContent, &quot;}\n\n&quot;);
4595         } else {
4596             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);
4597             push(@implContent, &quot;{\n&quot;);
4598             push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), JSValue::decode(thisValue));\n&quot;);
4599             push(@implContent, &quot;}\n\n&quot;);
4600         }
4601     }
4602 
4603     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4604         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4605 
4606         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4607         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4608         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;callFrame.thisValue().toThis(&amp;lexicalGlobalObject, NotStrictMode)&quot; : &quot;callFrame.thisValue()&quot;;
4609         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)\n&quot;);
4610         push(@implContent, &quot;{\n&quot;);
4611         push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), $thisValue);\n&quot;);
4612         push(@implContent, &quot;}\n\n&quot;);
4613     }
4614 
4615     if (NeedsConstructorProperty($interface)) {
4616         my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4617 
4618         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);
4619         push(@implContent, &quot;{\n&quot;);
4620         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
4621         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4622         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4623         push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
4624         push(@implContent, &quot;        return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);
4625 
4626         if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
4627             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(JSC::getVM(lexicalGlobalObject), prototype-&gt;globalObject()));\n&quot;);
4628         } else {
4629             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(JSC::getVM(lexicalGlobalObject), ${className}Constructor::createStructure(JSC::getVM(lexicalGlobalObject), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);
4630             push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
4631             push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4632             push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
4633         }
4634         push(@implContent, &quot;}\n\n&quot;);
4635 
4636         my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4637 
4638         push(@implContent, &quot;bool ${constructorSetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
4639         push(@implContent, &quot;{\n&quot;);
4640         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
4641         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4642         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4643         push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
4644         push(@implContent, &quot;        throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);
4645         push(@implContent, &quot;        return false;\n&quot;);
4646         push(@implContent, &quot;    }\n&quot;);
4647         push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
4648         push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
4649         push(@implContent, &quot;}\n\n&quot;);
4650 
4651     }
4652 
4653     foreach my $attribute (@attributes) {
4654         GenerateAttributeGetterDefinition(\@implContent, $interface, $className, $attribute);
4655         GenerateAttributeSetterDefinition(\@implContent, $interface, $className, $attribute);
4656     }
4657 
4658     foreach my $operation (@operations) {
4659         GenerateOperationDefinition(\@implContent, $interface, $className, $operation);
4660     }
4661     
4662     GenerateIterableDefinition($interface) if $interface-&gt;iterable;
4663     GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
4664 
4665     if (IsDOMGlobalObject($interface)) {
4666         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4667         push(@implContent, &quot;JSC::IsoSubspace* ${className}::subspaceForImpl(JSC::VM&amp; vm)\n&quot;);
4668         push(@implContent, &quot;{\n&quot;);
4669         push(@implContent, &quot;    return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;subspaceFor${className}();\n&quot;);
4670         push(@implContent, &quot;}\n\n&quot;);
4671     }
4672 
4673     if ($needsVisitChildren) {
4674         push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4675         push(@implContent, &quot;{\n&quot;);
4676         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4677         push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4678         push(@implContent, &quot;    Base::visitChildren(thisObject, visitor);\n&quot;);
4679         push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
4680         if ($interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost}) {
4681             push(@implContent, &quot;    visitor.reportExtraMemoryVisited(thisObject-&gt;wrapped().memoryCost());\n&quot;);
4682             if ($interface-&gt;extendedAttributes-&gt;{ReportExternalMemoryCost}) {;
4683                 push(@implContent, &quot;#if ENABLE(RESOURCE_USAGE)\n&quot;);
4684                 push(@implContent, &quot;    visitor.reportExternalMemoryVisited(thisObject-&gt;wrapped().externalMemoryCost());\n&quot;);
4685                 push(@implContent, &quot;#endif\n&quot;);
4686             }
4687         }
4688         if ($numCachedAttributes &gt; 0) {
4689             foreach my $attribute (@{$interface-&gt;attributes}) {
4690                 if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4691                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4692                     push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4693                     push(@implContent, &quot;    visitor.append(thisObject-&gt;m_&quot; . $attribute-&gt;name . &quot;);\n&quot;);
4694                     push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4695                 }
4696             }
4697         }
4698         push(@implContent, &quot;}\n\n&quot;);
4699         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
4700             push(@implContent, &quot;void ${className}::visitOutputConstraints(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4701             push(@implContent, &quot;{\n&quot;);
4702             push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4703             push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4704             push(@implContent, &quot;    Base::visitOutputConstraints(thisObject, visitor);\n&quot;);
4705             push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;);
4706             push(@implContent, &quot;}\n\n&quot;);
4707         }
4708     }
4709 
4710     if (InstanceNeedsEstimatedSize($interface)) {
4711         push(@implContent, &quot;size_t ${className}::estimatedSize(JSCell* cell, VM&amp; vm)\n&quot;);
4712         push(@implContent, &quot;{\n&quot;);
4713         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4714         push(@implContent, &quot;    return Base::estimatedSize(thisObject, vm) + thisObject-&gt;wrapped().memoryCost();\n&quot;);
4715         push(@implContent, &quot;}\n\n&quot;);
4716     }
4717 
4718     if (NeedsImplementationClass($interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{CustomHeapSnapshot}) {
4719         AddToImplIncludes(&quot;&lt;JavaScriptCore/HeapAnalyzer.h&gt;&quot;);
4720         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
4721         AddToImplIncludes(&quot;&lt;wtf/URL.h&gt;&quot;);
4722         push(@implContent, &quot;void ${className}::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)\n&quot;);
4723         push(@implContent, &quot;{\n&quot;);
4724         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4725         push(@implContent, &quot;    analyzer.setWrappedObjectForCell(cell, &amp;thisObject-&gt;wrapped());\n&quot;);
4726         push(@implContent, &quot;    if (thisObject-&gt;scriptExecutionContext())\n&quot;);
4727         push(@implContent, &quot;        analyzer.setLabelForCell(cell, \&quot;url \&quot; + thisObject-&gt;scriptExecutionContext()-&gt;url().string());\n&quot;);
4728         push(@implContent, &quot;    Base::analyzeHeap(cell, analyzer);\n&quot;);
4729         push(@implContent, &quot;}\n\n&quot;);
4730     }
4731 
4732     if ($indexedGetterOperation) {
4733         $implIncludes{&quot;&lt;wtf/URL.h&gt;&quot;} = 1 if $indexedGetterOperation-&gt;type-&gt;name eq &quot;DOMString&quot;;
4734         if ($interfaceName =~ /^HTML\w*Collection$/ or $interfaceName eq &quot;RadioNodeList&quot;) {
4735             $implIncludes{&quot;JSNode.h&quot;} = 1;
4736             $implIncludes{&quot;Node.h&quot;} = 1;
4737         }
4738     }
4739 
4740     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !GetCustomIsReachable($interface)) {
4741         push(@implContent, &quot;bool JS${interfaceName}Owner::isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason)\n&quot;);
4742         push(@implContent, &quot;{\n&quot;);
4743         # All ActiveDOMObjects implement hasPendingActivity(), but not all of them
4744         # increment their C++ reference counts when hasPendingActivity() becomes
4745         # true. As a result, ActiveDOMObjects can be prematurely destroyed before
4746         # their pending activities complete. To wallpaper over this bug, JavaScript
4747         # wrappers unconditionally keep ActiveDOMObjects with pending activity alive.
4748         # FIXME: Fix this lifetime issue in the DOM, and move this hasPendingActivity
4749         # check just above the (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) check below.
4750         my $emittedJSCast = 0;
4751         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {
4752             push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4753             $emittedJSCast = 1;
4754             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().hasPendingActivity()) {\n&quot;);
4755             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4756             push(@implContent, &quot;            *reason = \&quot;ActiveDOMObject with pending activity\&quot;;\n&quot;);
4757             push(@implContent, &quot;        return true;\n&quot;);
4758             push(@implContent, &quot;     }\n&quot;);
4759         }
4760         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;EventTarget&quot;)) {
4761             if (!$emittedJSCast) {
4762                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4763                 $emittedJSCast = 1;
4764             }
4765             push(@implContent, &quot;    if (js${interfaceName}-&gt;wrapped().isFiringEventListeners()) {\n&quot;);
4766             push(@implContent, &quot;        if (UNLIKELY(reason))\n&quot;);
4767             push(@implContent, &quot;            *reason = \&quot;EventTarget firing event listeners\&quot;;\n&quot;);
4768             push(@implContent, &quot;        return true;\n&quot;);
4769             push(@implContent, &quot;    }\n&quot;);
4770         }
4771         if ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
4772             if (!$emittedJSCast) {
4773                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4774                 $emittedJSCast = 1;
4775             }
4776             push(@implContent, &quot;    if (JSNodeOwner::isReachableFromOpaqueRoots(handle, 0, visitor, reason))\n&quot;);
4777             push(@implContent, &quot;        return true;\n&quot;);
4778         }
4779         if (GetGenerateIsReachable($interface)) {
4780             if (!$emittedJSCast) {
4781                 push(@implContent, &quot;    auto* js${interfaceName} = jsCast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4782                 $emittedJSCast = 1;
4783             }
4784 
4785             my $rootString;
4786             if (GetGenerateIsReachable($interface) eq &quot;Impl&quot;) {
4787                 $rootString  = &quot;    ${implType}* root = &amp;js${interfaceName}-&gt;wrapped();\n&quot;;
4788                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4789                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4790             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplWebGLRenderingContext&quot;) {
4791                 $rootString  = &quot;    WebGLRenderingContextBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().context());\n&quot;;
4792                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4793                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}\&quot;;\n&quot;;
4794             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromDOMWindow&quot;) {
4795                 $rootString  = &quot;    auto* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().window());\n&quot;;
4796                 $rootString .= &quot;    if (!root)\n&quot;;
4797                 $rootString .= &quot;        return false;\n&quot;;
4798                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4799                 $rootString .= &quot;        *reason = \&quot;Reachable from Window\&quot;;\n&quot;;
4800             } elsif (GetGenerateIsReachable($interface) eq &quot;ReachableFromNavigator&quot;) {
4801                 $implIncludes{&quot;Navigator.h&quot;} = 1;
4802                 $implIncludes{&quot;WorkerNavigator.h&quot;} = 1;
4803                 $rootString  = &quot;    NavigatorBase* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().navigator());\n&quot;;
4804                 $rootString .= &quot;    if (!root)\n&quot;;
4805                 $rootString .= &quot;        return false;\n&quot;;
4806                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4807                 $rootString .= &quot;        *reason = \&quot;Reachable from Navigator\&quot;;\n&quot;;
4808             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplDocument&quot;) {
4809                 $rootString  = &quot;    Document* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().document());\n&quot;;
4810                 $rootString .= &quot;    if (!root)\n&quot;;
4811                 $rootString .= &quot;        return false;\n&quot;;
4812                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4813                 $rootString .= &quot;        *reason = \&quot;Reachable from Document\&quot;;\n&quot;;
4814             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplElementRoot&quot;) {
4815                 $implIncludes{&quot;Element.h&quot;} = 1;
4816                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4817                 $rootString  = &quot;    Element* element = WTF::getPtr(js${interfaceName}-&gt;wrapped().element());\n&quot;;
4818                 $rootString .= &quot;    if (!element)\n&quot;;
4819                 $rootString .= &quot;        return false;\n&quot;;
4820                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4821                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName}Owner\&quot;;\n&quot;;
4822                 $rootString .= &quot;    void* root = WebCore::root(element);\n&quot;;
4823             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplOwnerNodeRoot&quot;) {
4824                 $implIncludes{&quot;Element.h&quot;} = 1;
4825                 $implIncludes{&quot;JSNodeCustom.h&quot;} = 1;
4826                 $rootString  = &quot;    void* root = WebCore::root(js${interfaceName}-&gt;wrapped().ownerNode());\n&quot;;
4827                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4828                 $rootString .= &quot;        *reason = \&quot;Reachable from ${interfaceName} ownerNode\&quot;;\n&quot;;
4829             } elsif (GetGenerateIsReachable($interface) eq &quot;ImplScriptExecutionContext&quot;) {
4830                 $rootString  = &quot;    ScriptExecutionContext* root = WTF::getPtr(js${interfaceName}-&gt;wrapped().scriptExecutionContext());\n&quot;;
4831                 $rootString .= &quot;    if (!root)\n&quot;;
4832                 $rootString .= &quot;        return false;\n&quot;;
4833                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4834                 $rootString .= &quot;        *reason = \&quot;Reachable from ScriptExecutionContext\&quot;;\n&quot;;
4835             } else {
4836                 $rootString  = &quot;    void* root = WebCore::root(&amp;js${interfaceName}-&gt;wrapped());\n&quot;;
4837                 $rootString .= &quot;    if (UNLIKELY(reason))\n&quot;;
4838                 $rootString .= &quot;        *reason = \&quot;Reachable from js${interfaceName}\&quot;;\n&quot;;
4839             }
4840 
4841             push(@implContent, $rootString);
4842             push(@implContent, &quot;    return visitor.containsOpaqueRoot(root);\n&quot;);
4843         } else {
4844             if (!$emittedJSCast) {
4845                 push(@implContent, &quot;    UNUSED_PARAM(handle);\n&quot;);
4846             }
4847             push(@implContent, &quot;    UNUSED_PARAM(visitor);\n&quot;);
4848             push(@implContent, &quot;    UNUSED_PARAM(reason);\n&quot;);
4849             push(@implContent, &quot;    return false;\n&quot;);
4850         }
4851         push(@implContent, &quot;}\n\n&quot;);
4852     }
4853 
4854     if (ShouldGenerateWrapperOwnerCode($hasParent, $interface) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{JSCustomFinalize}) {
4855         push(@implContent, &quot;void JS${interfaceName}Owner::finalize(JSC::Handle&lt;JSC::Unknown&gt; handle, void* context)\n&quot;);
4856         push(@implContent, &quot;{\n&quot;);
4857         push(@implContent, &quot;    auto* js${interfaceName} = static_cast&lt;JS${interfaceName}*&gt;(handle.slot()-&gt;asCell());\n&quot;);
4858         push(@implContent, &quot;    auto&amp; world = *static_cast&lt;DOMWrapperWorld*&gt;(context);\n&quot;);
4859         push(@implContent, &quot;    uncacheWrapper(world, &amp;js${interfaceName}-&gt;wrapped(), js${interfaceName});\n&quot;);
4860         push(@implContent, &quot;}\n\n&quot;);
4861     }
4862 
4863     if (ShouldGenerateToJSImplementation($hasParent, $interface)) {
4864         my $vtableNameGnu = GetGnuVTableNameForInterface($interface);
4865         my $vtableRefGnu = GetGnuVTableRefForInterface($interface);
4866         my $vtableRefWin = GetWinVTableRefForInterface($interface);
4867 
4868         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4869 #if ENABLE(BINDING_INTEGRITY)
4870 #if PLATFORM(WIN)
4871 #pragma warning(disable: 4483)
4872 extern &quot;C&quot; { extern void (*const ${vtableRefWin}[])(); }
4873 #else
4874 extern &quot;C&quot; { extern void* ${vtableNameGnu}[]; }
4875 #endif
4876 #endif
4877 
4878 END
4879 
4880         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
4881         push(@implContent, &quot;{\n&quot;);
4882         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4883 
4884 #if ENABLE(BINDING_INTEGRITY)
4885     void* actualVTablePointer = getVTablePointer(impl.ptr());
4886 #if PLATFORM(WIN)
4887     void* expectedVTablePointer = ${vtableRefWin};
4888 #else
4889     void* expectedVTablePointer = ${vtableRefGnu};
4890 #endif
4891 
4892     // If this fails ${implType} does not have a vtable, so you need to add the
4893     // ImplementationLacksVTable attribute to the interface definition
4894     static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
4895 
4896     // If you hit this assertion you either have a use after free bug, or
4897     // ${implType} has subclasses. If ${implType} has subclasses that get passed
4898     // to toJS() we currently require $interfaceName you to opt out of binding hardening
4899     // by adding the SkipVTableValidation attribute to the interface IDL definition
4900     RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
4901 #endif
4902 END
4903         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
4904     // If you hit this failure the interface definition has the ImplementationLacksVTable
4905     // attribute. You should remove that attribute. If the class has subclasses
4906     // that may be passed through this toJS() function you should use the SkipVTableValidation
4907     // attribute to $interfaceName.
4908     static_assert(!std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is polymorphic but the IDL claims it is not&quot;);
4909 END
4910         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
4911     globalObject-&gt;vm().heap.reportExtraMemoryAllocated(impl-&gt;memoryCost());
4912 END
4913 
4914         push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
4915         push(@implContent, &quot;}\n\n&quot;);
4916 
4917         push(@implContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);
4918         push(@implContent, &quot;{\n&quot;);
4919         push(@implContent, &quot;    return wrap(lexicalGlobalObject, globalObject, impl);\n&quot;);
4920         push(@implContent, &quot;}\n\n&quot;);
4921     }
4922 
4923     if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
4924         push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
4925         push(@implContent, &quot;{\n&quot;);
4926         push(@implContent, &quot;    if (auto* wrapper = &quot; . GetCastingHelperForThisObject($interface) . &quot;(vm, value))\n&quot;);
4927         push(@implContent, &quot;        return &amp;wrapper-&gt;wrapped();\n&quot;);
4928         push(@implContent, &quot;    return nullptr;\n&quot;);
4929         push(@implContent, &quot;}\n&quot;);
4930     }
4931 
4932     push(@implContent, &quot;\n}\n&quot;);
4933 
4934     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
4935     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
4936 }
4937 
4938 sub GenerateAttributeGetterBodyDefinition
4939 {
4940     my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
4941     
4942     my @signatureArguments = ();
4943     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);
4944     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4945     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4946     
4947     push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4948     push(@$outputArray, &quot;{\n&quot;);
4949     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
4950     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
4951 
4952     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
4953         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
4954         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
4955         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4956         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4957             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
4958         } else {
4959             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
4960         }
4961         push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
4962     }
4963     
4964     if (HasCustomGetter($attribute)) {
4965         my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
4966         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(lexicalGlobalObject);\n&quot;);
4967     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4968         $implIncludes{&quot;EventNames.h&quot;} = 1;
4969         my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
4970             : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
4971             : &quot;eventHandlerAttribute&quot;;
4972         my $eventName = EventHandlerAttributeEventName($attribute);
4973         push(@$outputArray, &quot;    return $getter(thisObject.wrapped(), $eventName, worldForDOMObject(thisObject));\n&quot;);
4974     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4975         my $constructorType = $attribute-&gt;type-&gt;name;
4976         $constructorType =~ s/Constructor$//;
4977         # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
4978         # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
4979         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4980             my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
4981             $constructorType =~ s/Named$//;
4982             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject);\n&quot;);
4983         } else {
4984             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
4985             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(JSC::getVM(&amp;lexicalGlobalObject), thisObject.globalObject());\n&quot;);
4986         }
4987     } else {
4988         if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4989             push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
4990             push(@$outputArray, &quot;        return cachedValue;\n&quot;);
4991         }
4992         
4993         my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
4994         
4995         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
4996         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
4997         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);
4998         
4999         unshift(@arguments, @callWithArgs);
5000 
5001         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;
5002         my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
5003         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike or $attribute-&gt;isSetLike;
5004 
5005         if (!IsReadonly($attribute)) {
5006             my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5007             if ($callTracingCallback) {
5008                 my @callTracerArguments = ();
5009                 GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
5010             }
5011         }
5012 
5013         push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
5014         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};
5015         push(@$outputArray, &quot;    return result;\n&quot;);
5016     }
5017     push(@$outputArray, &quot;}\n\n&quot;);
5018 }
5019 
5020 sub GenerateAttributeGetterTrampolineDefinition
5021 {
5022     my ($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional) = @_;
5023     
5024     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5025     
5026     my $callAttributeGetterName = &quot;get&quot;;
5027     $callAttributeGetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5028     
5029     my @templateParameters = ();
5030     push(@templateParameters, $attributeGetterBodyName);
5031     if ($attribute-&gt;extendedAttributes-&gt;{LenientThis}) {
5032         push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;)
5033     } elsif ($codeGenerator-&gt;IsPromiseType($attribute-&gt;type)) {
5034         push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
5035     } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
5036         push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
5037     }
5038     
5039     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);
5040     push(@$outputArray, &quot;{\n&quot;);
5041     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);
5042     push(@$outputArray, &quot;}\n\n&quot;);
5043 }
5044 
5045 sub GenerateAttributeGetterDefinition
5046 {
5047     my ($outputArray, $interface, $className, $attribute) = @_;
5048 
5049     return if IsJSBuiltin($interface, $attribute);
5050 
5051     my $attributeGetterName = GetAttributeGetterName($interface, $className, $attribute);
5052     my $attributeGetterBodyName = $attributeGetterName . &quot;Getter&quot;;
5053     
5054     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5055     if ($conditional) {
5056         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5057         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5058     }
5059     
5060     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
5061     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
5062     
5063     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5064 }
5065 
5066 sub GenerateAttributeSetterBodyDefinition
5067 {
5068     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
5069 
5070     my @signatureArguments = ();
5071     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);
5072     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
5073     push(@signatureArguments, &quot;JSValue value&quot;);
5074     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
5075     
5076     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5077     push(@$outputArray, &quot;{\n&quot;);
5078     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
5079     if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5080         push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);
5081     } else {
5082         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5083     }
5084 
5085     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;lexicalGlobalObject&quot;);
5086 
5087     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
5088         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5089         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5090             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);
5091         } else {
5092             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);
5093         }
5094         push(@$outputArray, &quot;        return false;\n&quot;);
5095     }
5096     
5097     if (HasCustomSetter($attribute)) {
5098         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
5099         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(lexicalGlobalObject, value);\n&quot;);
5100         push(@$outputArray, &quot;    return true;\n&quot;);
5101     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
5102         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5103         my $eventName = EventHandlerAttributeEventName($attribute);
5104         # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
5105         if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
5106             AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
5107             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(lexicalGlobalObject, value, thisObject), worldForDOMObject(thisObject));\n&quot;);
5108         } else {
5109             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5110             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
5111                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
5112                 : &quot;setEventHandlerAttribute&quot;;
5113             push(@$outputArray, &quot;    $setter(lexicalGlobalObject, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);
5114         }
5115         push(@$outputArray, &quot;    return true;\n&quot;);
5116     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
5117         my $constructorType = $attribute-&gt;type-&gt;name;
5118         $constructorType =~ s/Constructor$//;
5119         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
5120         # We do not generate the header file for NamedConstructor of class XXXX,
5121         # since we generate the NamedConstructor declaration into the header file of class XXXX.
5122         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
5123             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
5124         }
5125         my $id = $attribute-&gt;name;
5126         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
5127         push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5128     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
5129         my $id = $attribute-&gt;name;
5130         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
5131         if (AttributeShouldBeOnInstance($interface, $attribute)) {
5132             push(@$outputArray, &quot;    return replaceStaticPropertySlot(vm, &amp;thisObject, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5133         } else {
5134             push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5135         }
5136     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5137         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
5138         
5139         # 3.5.9.1. Let Q be ? Get(O, id).
5140         my $id = $attribute-&gt;name;
5141         push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);
5142         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;lexicalGlobalObject, id);\n&quot;);
5143         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5144         
5145         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
5146         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
5147         push(@$outputArray, &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;);
5148         push(@$outputArray, &quot;        return false;\n&quot;);
5149         push(@$outputArray, &quot;    }\n&quot;);
5150         
5151         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
5152         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
5153         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);
5154         
5155         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
5156         # FIXME: What should the second value to the PutPropertySlot be?
5157         # (https://github.com/heycam/webidl/issues/368)
5158         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
5159         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;lexicalGlobalObject, forwardId, value, slot);\n&quot;);
5160         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5161         
5162         push(@$outputArray, &quot;    return true;\n&quot;);
5163     } else {
5164         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5165        
5166         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5167             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5168             # the standard conversion, but rather silently fail on invalid enumeration values.
5169             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(lexicalGlobalObject, value);\n&quot;);
5170             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5171             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5172             push(@$outputArray, &quot;        return false;\n&quot;);
5173             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5174         } else {
5175             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;
5176             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5177 
5178             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);
5179             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5180             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5181         }
5182 
5183         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5184 
5185         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5186 
5187         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
5188         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);
5189 
5190         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5191         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5192 
5193         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5194         if ($callTracingCallback) {
5195             my $indent = &quot;    &quot;;
5196             my @callTracerArguments = (&quot;nativeValue&quot;);
5197             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5198         }
5199 
5200         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5201         push(@$outputArray, &quot;    AttributeSetter::call(lexicalGlobalObject, throwScope, [&amp;] {\n&quot;);
5202         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5203         push(@$outputArray, &quot;    });\n&quot;);
5204         push(@$outputArray, &quot;    return true;\n&quot;);
5205     }
5206     push(@$outputArray, &quot;}\n\n&quot;);
5207 }
5208 
5209 sub GenerateAttributeSetterTrampolineDefinition
5210 {
5211     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5212     
5213     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5214     
5215     my $callAttributeSetterName = &quot;set&quot;;
5216     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5217     
5218     my @templateParameters = ();
5219     push(@templateParameters, $attributeSetterBodyName);
5220     push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
5221     
5222     push(@$outputArray, &quot;bool ${attributeSetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);
5223     push(@$outputArray, &quot;{\n&quot;);
5224     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);
5225     push(@$outputArray, &quot;}\n\n&quot;);
5226 }
5227 
5228 sub GenerateAttributeSetterDefinition
5229 {
5230     my ($outputArray, $interface, $className, $attribute) = @_;
5231     
5232     return if IsReadonly($attribute);
5233     return if IsJSBuiltin($interface, $attribute);
5234     
5235     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5236     if ($conditional) {
5237         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5238         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5239     }
5240 
5241     my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
5242     if ($readWriteConditional) {
5243         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
5244         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5245     }
5246 
5247     my $attributeSetterName = GetAttributeSetterName($interface, $className, $attribute);
5248     my $attributeSetterBodyName = $attributeSetterName . &quot;Setter&quot;;
5249     
5250     GenerateAttributeSetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional);
5251     GenerateAttributeSetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional);
5252 
5253     push(@$outputArray, &quot;#endif\n\n&quot;) if $readWriteConditional;
5254     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5255 }
5256 
5257 sub GenerateOperationTrampolineDefinition
5258 {
5259     my ($outputArray, $interface, $className, $operation, $functionName, $functionBodyName) = @_;
5260 
5261     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5262     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5263     my $exposureScope = $interface-&gt;extendedAttributes-&gt;{Exposed} ? &quot;WindowOrWorker&quot; : &quot;WindowOnly&quot;;
5264 
5265     my $callFunctionName = &quot;call&quot;;
5266     $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
5267     $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5268 
5269     my @callFunctionTemplateArguments = ();
5270     push(@callFunctionTemplateArguments, $functionBodyName);
5271     push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
5272 
5273     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5274     push(@$outputArray, &quot;{\n&quot;);
5275     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*lexicalGlobalObject, *callFrame, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);
5276     push(@$outputArray, &quot;}\n\n&quot;);
5277 }
5278 
5279 sub GenerateOperationBodyDefinition
5280 {
5281     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded, $generatingOverloadDispatcher) = @_;
5282 
5283     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5284     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5285     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5286 
5287     my @signatureArguments = ();
5288     push(@signatureArguments, &quot;JSC::JSGlobalObject* lexicalGlobalObject&quot;);
5289     push(@signatureArguments, &quot;JSC::CallFrame* callFrame&quot;);
5290     push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
5291     push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5292     push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
5293 
5294     push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5295     push(@$outputArray, &quot;{\n&quot;);
5296     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
5297     push(@$outputArray, &quot;    UNUSED_PARAM(callFrame);\n&quot;);
5298     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5299 
5300     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;) unless $generatingOverloadDispatcher;
5301 
5302     # For overloads, we generate the security check in the overload dispatcher, instead of the body of each overload, as per specification:
5303     # https://heycam.github.io/webidl/#dfn-create-operation-function
5304     if (!$isOverloaded || $generatingOverloadDispatcher) {
5305         if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
5306             assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
5307             
5308             AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5309             if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
5310                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);
5311                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5312             } else {
5313                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);
5314                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5315             }
5316         }
5317     }
5318 
5319     my $indent = &quot;    &quot;;
5320 
5321     if ($generatingOverloadDispatcher) {
5322         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
5323         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
5324 
5325         my @argumentsToForward = ();
5326         push(@argumentsToForward, &quot;lexicalGlobalObject&quot;);
5327         push(@argumentsToForward, &quot;callFrame&quot;);
5328         push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
5329         push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5330         push(@argumentsToForward, &quot;throwScope&quot;);
5331 
5332         GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
5333     } elsif (HasCustomMethod($operation)) {
5334         GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
5335     } else {
5336         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isSetLike &amp;&amp; !$operation-&gt;isStatic) {
5337             push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5338         }
5339 
5340         GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5341         my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5342 
5343         if ($operation-&gt;extendedAttributes-&gt;{ResultField}) {
5344             my $resultName = $operation-&gt;extendedAttributes-&gt;{ResultField};
5345             push(@$outputArray, &quot;    auto implResult = $functionString;\n&quot;);
5346             GenerateImplementationFunctionCall($outputArray, $operation, $interface, &quot;WTFMove(implResult.$resultName)&quot;, $indent);
5347         } else {
5348             GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5349         }
5350     }
5351 
5352     push(@$outputArray, &quot;}\n\n&quot;);
5353 }
5354 
5355 sub GenerateOperationDefinition
5356 {
5357     my ($outputArray, $interface, $className, $operation) = @_;
5358 
5359     return if IsJSBuiltin($interface, $operation);
5360     return if $operation-&gt;isIterable;
5361     return if $operation-&gt;isSerializer;
5362 
5363     my $isCustom = HasCustomMethod($operation);
5364     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5365 
5366     assert(&quot;[Custom] is not supported for overloaded operations.&quot;) if $isCustom &amp;&amp; $isOverloaded;
5367 
5368     my $inAppleCopyright = 0;
5369 
5370     if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
5371         if (!$inAppleCopyright) {
5372             push(@$outputArray, $beginAppleCopyrightForSourceFiles);
5373             $inAppleCopyright = 1;
5374         }
5375     } elsif ($inAppleCopyright) {
5376         push(@$outputArray, $endAppleCopyright);
5377         $inAppleCopyright = 0;
5378     }
5379 
5380     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5381     if ($conditional) {
5382         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5383         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5384     }
5385 
5386     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5387 
5388     AddToImplIncludesForIDLType($operation-&gt;type, $conditional) unless $isCustom or $hasPromiseReturnType;
5389     AddToImplIncludes(&quot;JSDOMOperation.h&quot;, $conditional) if !$hasPromiseReturnType;
5390     AddToImplIncludes(&quot;JSDOMOperationReturningPromise.h&quot;, $conditional) if $hasPromiseReturnType;
5391 
5392     my $functionName = GetFunctionName($interface, $className, $operation);
5393     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
5394     my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
5395 
5396     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded);
5397 
5398     # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
5399     # that gets generated after the last overload body has been generated.
5400     unless ($isOverloaded) {
5401         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
5402     }
5403 
5404     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5405 
5406     # Generate a function dispatching call to the rest of the overloads.
5407     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5408         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5409         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5410         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5411 
5412         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
5413         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, $isOverloaded, 1);
5414         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5415     
5416         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5417     }
5418 
5419 
5420     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5421         if ($conditional) {
5422             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5423             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5424         }
5425 
5426         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
5427         my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
5428         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject* lexicalGlobalObject, $className* castedThis&quot;);
5429         foreach my $argument (@{$operation-&gt;arguments}) {
5430             my $type = $argument-&gt;type;
5431             my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
5432             my $name = $argument-&gt;name;
5433             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5434             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5435         }
5436         push(@$outputArray, &quot;)\n&quot;);
5437         push(@$outputArray, &quot;{\n&quot;);
5438         push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);
5439         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);
5440         push(@$outputArray, &quot;    IGNORE_WARNINGS_BEGIN(\&quot;frame-address\&quot;)\n&quot;);
5441         push(@$outputArray, &quot;    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);\n&quot;);
5442         push(@$outputArray, &quot;    IGNORE_WARNINGS_END\n&quot;);
5443         push(@$outputArray, &quot;    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);\n&quot;);
5444         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5445         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5446         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5447         
5448         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5449         
5450         my @arguments = ();
5451         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);
5452         
5453         foreach my $argument (@{$operation-&gt;arguments}) {
5454             my $value = &quot;&quot;;
5455             my $type = $argument-&gt;type;
5456             my $name = $argument-&gt;name;
5457             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5458             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5459 
5460             my ($nativeValue, $mayThrowException) = ToNativeForFunctionWithoutTypeCheck($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});
5461             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5462             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5463             $value = &quot;WTFMove($name)&quot;;
5464 
5465             if ($shouldPassByReference) {
5466                 $value = &quot;*$name&quot;;
5467             }
5468             push(@arguments, $value);
5469         }
5470         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5471         $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5472         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5473         push(@$outputArray, &quot;}\n\n&quot;);
5474 
5475         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5476     }
5477 
5478     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5479 }
5480 
5481 sub GenerateSerializerDefinition
5482 {
5483     my ($interface, $className) = @_;
5484 
5485     my $interfaceName = $interface-&gt;type-&gt;name;
5486 
5487     my $parentSerializerInterface = 0;
5488     if ($interface-&gt;serializable-&gt;hasInherit) {
5489         $codeGenerator-&gt;ForAllParents($interface, sub {
5490             my $parentInterface = shift;
5491             if ($parentInterface-&gt;serializable &amp;&amp; !$parentSerializerInterface) {
5492                 $parentSerializerInterface = $parentInterface;
5493             }
5494         }, 0);
5495         die &quot;Failed to find parent interface with \&quot;serializer\&quot; for \&quot;inherit\&quot; serializer in $interfaceName\n&quot; if !$parentSerializerInterface;
5496     }
5497 
5498     my @serializedAttributes = ();
5499 
5500     foreach my $attributeName (@{$interface-&gt;serializable-&gt;attributes}) {
5501         my $foundAttribute = 0;
5502         foreach my $attribute (@{$interface-&gt;attributes}) {
5503             if ($attributeName eq $attribute-&gt;name) {
5504                 $foundAttribute = 1;
5505                 if ($codeGenerator-&gt;IsSerializableAttribute($interface, $attribute)) {
5506                     push(@serializedAttributes, $attribute);                
5507                     last;
5508                 }                    
5509                 die &quot;Explicit \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; is not serializable\n&quot; if !$interface-&gt;serializable-&gt;hasAttribute;
5510                 last;
5511             }
5512         }
5513         die &quot;Failed to find \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; in $interfaceName\n&quot; if !$foundAttribute;
5514     }
5515 
5516     my $serializerFunctionName = &quot;toJSON&quot;;
5517     my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
5518 
5519     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
5520 
5521     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(JSGlobalObject&amp; lexicalGlobalObject, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);
5522     push(@implContent, &quot;{\n&quot;);
5523     push(@implContent, &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);
5524 
5525     if ($interface-&gt;serializable-&gt;hasInherit) {
5526         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
5527         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(lexicalGlobalObject, thisObject, globalObject, throwScope);\n&quot;);
5528     } else {
5529         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n&quot;);
5530     }
5531     push(@implContent, &quot;\n&quot;);
5532 
5533     foreach my $attribute (@serializedAttributes) {
5534         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5535 
5536         my $name = $attribute-&gt;name;
5537         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
5538         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(lexicalGlobalObject, thisObject, throwScope);\n&quot;);
5539         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5540 
5541         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5542             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5543             if ($attribute-&gt;type-&gt;isNullable) {
5544                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
5545                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
5546                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5547                 push(@implContent, &quot;    } else\n&quot;);
5548                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5549             } else {
5550                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);
5551                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5552             }
5553         } else {
5554             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5555         }
5556 
5557         push(@implContent, &quot;\n&quot;);
5558     }
5559 
5560     push(@implContent, &quot;    return result;\n&quot;);
5561     push(@implContent, &quot;}\n&quot;);
5562     push(@implContent, &quot;\n&quot;);
5563 
5564     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(JSGlobalObject* lexicalGlobalObject, CallFrame*, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);
5565     push(@implContent, &quot;{\n&quot;);
5566     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*lexicalGlobalObject, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);
5567     push(@implContent, &quot;}\n&quot;);
5568     push(@implContent, &quot;\n&quot;);
5569     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5570     push(@implContent, &quot;{\n&quot;);
5571     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*lexicalGlobalObject, *callFrame, \&quot;${serializerFunctionName}\&quot;);\n&quot;);
5572     push(@implContent, &quot;}\n&quot;);
5573     push(@implContent, &quot;\n&quot;);
5574 }
5575 
5576 sub GenerateGetCallData
5577 {
5578     my ($outputArray, $interface, $className) = @_;
5579 
5580     return if $interface-&gt;extendedAttributes-&gt;{CustomGetCallData};
5581 
5582     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
5583         GeneratePluginCall($outputArray, $interface, $className);
5584     } else {
5585         GenerateLegacyCallerDefinitions($outputArray, $interface, $className);
5586     }
5587 }
5588 
5589 sub GeneratePluginCall
5590 {
5591     my ($outputArray, $interface, $className) = @_;
5592 
5593     AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
5594 
5595     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell* cell, CallData&amp; callData)\n&quot;);
5596     push(@$outputArray, &quot;{\n&quot;);
5597     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
5598     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
5599 
5600     push(@$outputArray, &quot;    return pluginElementCustomGetCallData(thisObject, callData);\n&quot;);
5601     push(@$outputArray, &quot;}\n&quot;);
5602     push(@$outputArray, &quot;\n&quot;);
5603 }
5604 
5605 sub GenerateLegacyCallerDefinitions
5606 {
5607     my ($outputArray, $interface, $className) = @_;
5608 
5609     my @legacyCallers = @{$interface-&gt;{LegacyCallers}};
5610     if (@legacyCallers &gt; 1) {
5611         foreach my $legacyCaller (@legacyCallers) {
5612             GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
5613         }
5614 
5615         my $overloadFunctionPrefix = &quot;call${className}&quot;;
5616 
5617         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5618         push(@$outputArray, &quot;{\n&quot;);
5619         push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
5620         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5621         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5622 
5623         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);
5624 
5625         push(@$outputArray, &quot;}\n\n&quot;);
5626     } else {
5627         GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
5628     }
5629 
5630     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell*, CallData&amp; callData)\n&quot;);
5631     push(@$outputArray, &quot;{\n&quot;);
5632     push(@$outputArray, &quot;    callData.native.function = call${className};\n&quot;);
5633     push(@$outputArray, &quot;    return CallType::Host;\n&quot;);
5634     push(@$outputArray, &quot;}\n&quot;);
5635     push(@$outputArray, &quot;\n&quot;);
5636 }
5637 
5638 sub GenerateLegacyCallerDefinition
5639 {
5640     my ($outputArray, $interface, $className, $operation) = @_;
5641 
5642     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5643     if ($isOverloaded) {
5644         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5645     } else {
5646         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
5647     }
5648 
5649     push(@$outputArray, &quot;{\n&quot;);
5650     push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
5651     push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5652     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5653 
5654     my $indent = &quot;    &quot;;
5655     GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5656 
5657     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(callFrame-&gt;jsCallee());\n&quot;);
5658     push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
5659     push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5660 
5661     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
5662     my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5663 
5664     GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5665 
5666     push(@$outputArray, &quot;}\n\n&quot;);
5667 }
5668 
5669 sub GenerateCallWithUsingReferences
5670 {
5671     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5672 
5673     my $callFramePointer = &quot;callFrame&quot;;
5674     my $callFrameReference = &quot;*callFrame&quot;;
5675     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;;
5676 
5677     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);
5678 }
5679 
5680 # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
5681 sub GenerateCallWithUsingPointers
5682 {
5683     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5684 
5685     my $callFramePointer = &quot;callFrame&quot;;
5686     my $callFrameReference = &quot;*callFrame&quot;;
5687     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot;;
5688 
5689     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);
5690 }
5691 
5692 sub GenerateConstructorCallWithUsingPointers
5693 {
5694     my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
5695 
5696     my $callFramePointer = &quot;callFrame&quot;;
5697     my $callFrameReference = &quot;*callFrame&quot;;
5698     my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
5699     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*lexicalGlobalObject, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;
5700     my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
5701 
5702     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);
5703 }
5704 
5705 sub GenerateCallWith
5706 {
5707     my ($callWith, $outputArray, $returnValue, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;
5708 
5709     return () unless $callWith;
5710 
5711     $indent ||= &quot;    &quot;;
5712 
5713     my @callWithArgs;
5714     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;)) {
5715         push(@callWithArgs, &quot;*${globalObject}&quot;);
5716         push(@callWithArgs, $callFrameReference);
5717     }
5718     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;)) {
5719         push(@callWithArgs, &quot;*${globalObject}&quot;);
5720     }
5721     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
5722         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5723         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5724         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5725         push(@callWithArgs, &quot;*context&quot;);
5726     }
5727     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;Document&quot;)) {
5728         AddToImplIncludes(&quot;Document.h&quot;);
5729         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5730         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5731         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5732         push(@$outputArray, $indent . &quot;ASSERT(context-&gt;isDocument());\n&quot;);
5733         push(@$outputArray, $indent . &quot;auto&amp; document = downcast&lt;Document&gt;(*context);\n&quot;);
5734         push(@callWithArgs, &quot;document&quot;);
5735     }
5736     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
5737         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5738         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5739         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow(*$globalObject, $callFrameReference).document();\n&quot;);
5740         push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
5741         push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
5742         push(@callWithArgs, &quot;*incumbentDocument&quot;);
5743     }
5744     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
5745         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5746         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5747         push(@callWithArgs, &quot;responsibleDocument(${globalObject}-&gt;vm(), $callFrameReference)&quot;);
5748     }
5749     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
5750         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5751         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5752         push(@callWithArgs, &quot;activeDOMWindow(*$globalObject)&quot;);
5753     }
5754     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
5755         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5756         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5757         push(@callWithArgs, &quot;firstDOMWindow(*$globalObject)&quot;);
5758     }
5759     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
5760         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5761         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
5762         push(@callWithArgs, &quot;incumbentDOMWindow(*$globalObject, $callFrameReference)&quot;);
5763     }
5764     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
5765         push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
5766     }
5767     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
5768         push(@callWithArgs, &quot;worldForDOMObject(${thisReference})&quot;);
5769     }
5770 
5771     return @callWithArgs;
5772 }
5773 
5774 sub GenerateArgumentsCountCheck
5775 {
5776     my ($outputArray, $operation, $interface, $indent) = @_;
5777 
5778     # Overloaded operations don&#39;t need to check the argument count since the 
5779     # dispatch function does for them.
5780     return if $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5781 
5782     my $numMandatoryArguments = @{$operation-&gt;arguments};
5783     foreach my $argument (reverse(@{$operation-&gt;arguments})) {
5784         if ($argument-&gt;isOptional or $argument-&gt;isVariadic) {
5785             $numMandatoryArguments--;
5786         } else {
5787             last;
5788         }
5789     }
5790     if ($numMandatoryArguments &gt;= 1) {
5791         push(@$outputArray, $indent . &quot;if (UNLIKELY(callFrame-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);
5792         push(@$outputArray, $indent . &quot;    return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));\n&quot;);
5793     }
5794 }
5795 
5796 my %automaticallyGeneratedDefaultValues = (
5797     &quot;any&quot; =&gt; &quot;undefined&quot;,
5798 
5799     # toString() will convert undefined to the string &quot;undefined&quot;;
5800     # (note that this optimizes a behavior that is almost never useful)
5801     &quot;DOMString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5802     &quot;USVString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5803 
5804     # JSValue::toBoolean() will convert undefined to false.
5805     &quot;boolean&quot; =&gt; &quot;false&quot;,
5806 
5807     # JSValue::toInt*() / JSValue::toUint*() will convert undefined to 0.
5808     &quot;byte&quot; =&gt; &quot;0&quot;,
5809     &quot;long long&quot; =&gt; &quot;0&quot;,
5810     &quot;long&quot; =&gt; &quot;0&quot;,
5811     &quot;octet&quot; =&gt; &quot;0&quot;,
5812     &quot;short&quot; =&gt; &quot;0&quot;,
5813     &quot;unsigned long long&quot; =&gt; &quot;0&quot;,
5814     &quot;unsigned long&quot; =&gt; &quot;0&quot;,
5815     &quot;unsigned short&quot; =&gt; &quot;0&quot;,
5816 
5817     # toNumber() / toFloat() convert undefined to NaN.
5818     &quot;double&quot; =&gt; &quot;NaN&quot;,
5819     &quot;float&quot; =&gt; &quot;NaN&quot;,
5820     &quot;unrestricted double&quot; =&gt; &quot;NaN&quot;,
5821     &quot;unrestricted float&quot; =&gt; &quot;NaN&quot;,
5822 );
5823 
5824 sub WillConvertUndefinedToDefaultParameterValue
5825 {
5826     my ($parameterType, $defaultValue) = @_;
5827 
5828     my $automaticallyGeneratedDefaultValue = $automaticallyGeneratedDefaultValues{$parameterType-&gt;name};
5829     return 1 if defined $automaticallyGeneratedDefaultValue &amp;&amp; $automaticallyGeneratedDefaultValue eq $defaultValue;
5830 
5831     return 1 if $defaultValue eq &quot;null&quot; &amp;&amp; $codeGenerator-&gt;IsWrapperType($parameterType);
5832     return 1 if $defaultValue eq &quot;[]&quot; &amp;&amp; $codeGenerator-&gt;IsDictionaryType($parameterType);
5833 
5834     return 0;
5835 }
5836 
5837 sub NeedsExplicitPropagateExceptionCall
5838 {
5839     my ($operation) = @_;
5840 
5841     return 0 unless $operation-&gt;extendedAttributes-&gt;{MayThrowException};
5842 
5843     return $operation-&gt;type &amp;&amp; ($operation-&gt;type-&gt;name eq &quot;void&quot; || $codeGenerator-&gt;IsPromiseType($operation-&gt;type) || OperationHasForcedReturnValue($operation));
5844 }
5845 
5846 sub GenerateParametersCheck
5847 {
5848     my ($outputArray, $operation, $interface, $functionImplementationName, $indent) = @_;
5849 
5850     my $interfaceName = $interface-&gt;type-&gt;name;
5851     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
5852     my $numArguments = @{$operation-&gt;arguments};
5853     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5854     my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
5855 
5856     my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5857     
5858     my @arguments = ();
5859     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);
5860     
5861     my $quotedFunctionName;
5862     if (!$isConstructor) {
5863         my $name = $operation-&gt;name;
5864         $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
5865         push(@arguments, GenerateCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{CallWith}, \@$outputArray, &quot;JSValue::encode(jsUndefined())&quot;, &quot;*castedThis&quot;));
5866     } else {
5867         $quotedFunctionName = &quot;nullptr&quot;;
5868         push(@arguments, GenerateConstructorCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{ConstructorCallWith}, \@$outputArray, $visibleInterfaceName, &quot;*castedThis&quot;));
5869     }
5870 
5871     my $argumentIndex = 0;
5872     foreach my $argument (@{$operation-&gt;arguments}) {
5873         my $type = $argument-&gt;type;
5874 
5875         assert &quot;Optional arguments of non-nullable wrapper types are not supported (&quot; . $operation-&gt;name . &quot;)&quot; if $argument-&gt;isOptional &amp;&amp; !$type-&gt;isNullable &amp;&amp; $codeGenerator-&gt;IsWrapperType($type);
5876 
5877         if ($argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default)) {
5878             # As per Web IDL, optional dictionary arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
5879             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsDictionaryType($type);
5880 
5881             # Treat undefined the same as an empty sequence Or frozen array.
5882             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
5883 
5884             # We use undefined as default value for optional arguments of type &#39;any&#39; unless specified otherwise.
5885             $argument-&gt;default(&quot;undefined&quot;) if $type-&gt;name eq &quot;any&quot;;
5886 
5887             # We use the null string as default value for arguments of type DOMString unless specified otherwise.
5888             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsStringType($type);
5889 
5890             # As per Web IDL, passing undefined for a nullable argument is treated as null. Therefore, use null as
5891             # default value for nullable arguments unless otherwise specified.
5892             $argument-&gt;default(&quot;null&quot;) if $type-&gt;isNullable;
5893 
5894             # For callback arguments, the generated bindings treat undefined as null, so use null as implicit default value.
5895             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type);
5896         }
5897 
5898         my $name = $argument-&gt;name;
5899         my $value = $name;
5900 
5901         if ($argument-&gt;isVariadic) {
5902             AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
5903             AddToImplIncludesForIDLType($type, $conditional);
5904         
5905             my $IDLType = GetIDLType($interface, $type);
5906 
5907             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*lexicalGlobalObject, *callFrame, ${argumentIndex});\n&quot;);
5908             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5909 
5910             $value = &quot;WTFMove(${name})&quot;;
5911         } else {
5912             my $argumentLookupForConversion;
5913             my $optionalCheck;
5914             my $nativeValueCastFunction;
5915 
5916             if ($argument-&gt;isOptional) {
5917                 assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
5918 
5919                 if (defined($argument-&gt;default)) {
5920                     if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
5921                         $argumentLookupForConversion = &quot;callFrame-&gt;argument($argumentIndex)&quot;;
5922                     } else {
5923                         my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
5924                         $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5925                         $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;
5926                     }
5927                 } else {
5928                     my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
5929 
5930                     my $defaultValue;
5931                     if ($codeGenerator-&gt;IsPromiseType($argument-&gt;type)) {
5932                         $defaultValue = &quot;nullptr&quot;;
5933                     } else {
5934                         $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
5935                         $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
5936                     }
5937 
5938                     $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;
5939                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;
5940                 }
5941             } else {
5942                 if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
5943                     push(@$outputArray, $indent . &quot;auto returnValue = callFrame-&gt;uncheckedArgument($argumentIndex);\n&quot;);
5944                     $argumentLookupForConversion = &quot;returnValue&quot;;
5945                 } else {
5946                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;
5947                 }
5948             }
5949 
5950             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
5951             my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
5952 
5953             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);
5954 
5955             $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
5956             $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
5957 
5958             push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
5959             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5960 
5961             $value = PassArgumentExpression($name, $argument);
5962         }
5963 
5964         push(@arguments, $value);
5965         $argumentIndex++;
5966     }
5967 
5968     push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
5969 
5970     my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
5971     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);
5972 
5973     return $functionString;
5974 }
5975 
5976 sub GenerateDictionaryHeader
5977 {
5978     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5979 
5980     # - Add default header template and header protection.
5981     push(@headerContentHeader, GenerateHeaderContentHeader($dictionary));
5982 
5983     $headerIncludes{&quot;${className}.h&quot;} = 1;
5984 
5985     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5986     push(@headerContent, GenerateDictionaryHeaderContent($dictionary, $className));
5987     push(@headerContent, GenerateEnumerationsHeaderContent($dictionary, $enumerations));
5988     push(@headerContent, GenerateDictionariesHeaderContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5989     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5990 
5991     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
5992     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
5993     
5994     # - Generate dependencies.
5995     if ($writeDependencies) {
5996         my @ancestors;
5997         my $parentType = $dictionary-&gt;parentType;
5998         while (defined($parentType)) {
5999             push(@ancestors, $parentType-&gt;name) if $codeGenerator-&gt;IsExternalDictionaryType($parentType);
6000             my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
6001             assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless $parentDictionary;
6002             $parentType = $parentDictionary-&gt;parentType;
6003         }
6004         push(@depsContent, &quot;$className.h : &quot;, join(&quot; &quot;, map { &quot;$_.idl&quot; } @ancestors), &quot;\n&quot;);
6005         push(@depsContent, map { &quot;$_.idl :\n&quot; } @ancestors);
6006     }
6007 }
6008 
6009 sub GenerateDictionaryImplementation
6010 {
6011     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
6012 
6013     # - Add default header template
6014     push(@implContentHeader, GenerateImplementationContentHeader($dictionary));
6015 
6016     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6017     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6018     push(@implContent, GenerateDictionaryImplementationContent($dictionary, $className));
6019     push(@implContent, GenerateEnumerationsImplementationContent($dictionary, $enumerations));
6020     push(@implContent, GenerateDictionariesImplementationContent($dictionary, $otherDictionaries)) if $otherDictionaries;
6021     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6022 
6023     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
6024     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6025 }
6026 
6027 sub GenerateCallbackFunctionHeader
6028 {
6029     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
6030 
6031     push(@headerContentHeader, GenerateHeaderContentHeader($callbackFunction));
6032 
6033     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
6034 
6035     my @operations = ();
6036     push(@operations, $callbackFunction-&gt;operation);
6037     my @constants = ();
6038 
6039     $object-&gt;GenerateCallbackHeaderContent($callbackFunction, \@operations, \@constants, \@headerContent, \%headerIncludes);
6040 
6041     push(@headerContent, GenerateEnumerationsHeaderContent($callbackFunction, $enumerations));
6042     push(@headerContent, GenerateDictionariesHeaderContent($callbackFunction, $dictionaries));
6043 
6044     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
6045 
6046     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
6047     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6048 }
6049 
6050 sub GenerateCallbackFunctionImplementation
6051 {
6052     my ($object, $callbackFunction, $enumerations, $dictionaries) = @_;
6053 
6054     push(@implContentHeader, GenerateImplementationContentHeader($callbackFunction));
6055 
6056     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6057     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6058 
6059     push(@implContent, GenerateEnumerationsImplementationContent($callbackFunction, $enumerations));
6060     push(@implContent, GenerateDictionariesImplementationContent($callbackFunction, $dictionaries));
6061 
6062     my @operations = ();
6063     push(@operations, $callbackFunction-&gt;operation);
6064     my @constants = ();
6065 
6066     $object-&gt;GenerateCallbackImplementationContent($callbackFunction, \@operations, \@constants, \@implContent, \%implIncludes);
6067 
6068     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6069 
6070     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackFunction);
6071     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6072 }
6073 
6074 sub GenerateCallbackInterfaceHeader
6075 {
6076     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
6077 
6078     push(@headerContentHeader, GenerateHeaderContentHeader($callbackInterface));
6079 
6080     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
6081     
6082     $object-&gt;GenerateCallbackHeaderContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@headerContent, \%headerIncludes);
6083 
6084     push(@headerContent, GenerateEnumerationsHeaderContent($callbackInterface, $enumerations));
6085     push(@headerContent, GenerateDictionariesHeaderContent($callbackInterface, $dictionaries));
6086 
6087     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
6088 
6089     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
6090     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6091 }
6092 
6093 sub GenerateCallbackInterfaceImplementation
6094 {
6095     my ($object, $callbackInterface, $enumerations, $dictionaries) = @_;
6096 
6097     push(@implContentHeader, GenerateImplementationContentHeader($callbackInterface));
6098 
6099     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
6100     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
6101 
6102     push(@implContent, GenerateEnumerationsImplementationContent($callbackInterface, $enumerations));
6103     push(@implContent, GenerateDictionariesImplementationContent($callbackInterface, $dictionaries));
6104 
6105     $object-&gt;GenerateCallbackImplementationContent($callbackInterface, $callbackInterface-&gt;operations, $callbackInterface-&gt;constants, \@implContent, \%implIncludes);
6106 
6107     push(@implContent, &quot;} // namespace WebCore\n&quot;);
6108 
6109     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($callbackInterface);
6110     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
6111 }
6112 
6113 sub GenerateCallbackHeaderContent
6114 {
6115     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6116 
6117     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6118     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6119     my $className = &quot;JS${name}&quot;;
6120 
6121     $includesRef-&gt;{&quot;IDLTypes.h&quot;} = 1;
6122     $includesRef-&gt;{&quot;JSCallbackData.h&quot;} = 1;
6123     $includesRef-&gt;{&quot;&lt;wtf/Forward.h&gt;&quot;} = 1;
6124     $includesRef-&gt;{&quot;${name}.h&quot;} = 1;
6125 
6126     my $exportMacro = GetExportMacroForJSClass($interfaceOrCallback);
6127 
6128     push(@$contentRef, &quot;class $exportMacro$className final : public ${name} {\n&quot;);
6129     push(@$contentRef, &quot;public:\n&quot;);
6130 
6131     # The static create() method.
6132     push(@$contentRef, &quot;    static Ref&lt;$className&gt; create(JSC::JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6133     push(@$contentRef, &quot;    {\n&quot;);
6134     push(@$contentRef, &quot;        return adoptRef(*new ${className}(callback, globalObject));\n&quot;);
6135     push(@$contentRef, &quot;    }\n\n&quot;);
6136 
6137     push(@$contentRef, &quot;    virtual ScriptExecutionContext* scriptExecutionContext() const { return ContextDestructionObserver::scriptExecutionContext(); }\n\n&quot;);
6138 
6139     push(@$contentRef, &quot;    virtual ~$className();\n&quot;);
6140 
6141     push(@$contentRef, &quot;    ${callbackDataType}* callbackData() { return m_data; }\n&quot;);
6142 
6143     push(@$contentRef, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;) if @{$constants};
6144 
6145     push(@$contentRef, &quot;    virtual bool operator==(const ${name}&amp;) const override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual};
6146 
6147     # Operations
6148     my $numOperations = @{$operations};
6149     if ($numOperations &gt; 0) {
6150         push(@$contentRef, &quot;\n    // Functions\n&quot;);
6151         foreach my $operation (@{$operations}) {
6152             my @arguments = ();
6153 
6154             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6155             if ($callbackThisObject) {
6156                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6157                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6158                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6159             }
6160 
6161             foreach my $argument (@{$operation-&gt;arguments}) {
6162                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6163                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6164             }
6165 
6166             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6167             
6168             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6169             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6170 
6171             push(@$contentRef, &quot;    ${nativeReturnType} ${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;) override;\n&quot;);
6172         }
6173     }
6174 
6175     push(@$contentRef, &quot;\nprivate:\n&quot;);
6176 
6177     push(@$contentRef, &quot;    ${className}(JSC::JSObject*, JSDOMGlobalObject*);\n\n&quot;);
6178 
6179     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6180         push(@$contentRef, &quot;    bool hasCallback() const final { return m_data &amp;&amp; m_data-&gt;callback(); }\n\n&quot;);
6181     }
6182 
6183     push(@$contentRef, &quot;    void visitJSFunction(JSC::SlotVisitor&amp;) override;\n\n&quot;) if $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback};
6184 
6185     push(@$contentRef, &quot;    ${callbackDataType}* m_data;\n&quot;);
6186     push(@$contentRef, &quot;};\n\n&quot;);
6187 
6188     # toJS().
6189     push(@$contentRef, $exportMacro . &quot;JSC::JSValue toJS(${name}&amp;);\n&quot;);
6190     push(@$contentRef, &quot;inline JSC::JSValue toJS(${name}* impl) { return impl ? toJS(*impl) : JSC::jsNull(); }\n\n&quot;);
6191 }
6192 
6193 sub GenerateCallbackImplementationContent
6194 {
6195     my ($object, $interfaceOrCallback, $operations, $constants, $contentRef, $includesRef) = @_;
6196 
6197     my $name = $interfaceOrCallback-&gt;type-&gt;name;
6198     my $callbackDataType = $interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback} ? &quot;JSCallbackDataWeak&quot; : &quot;JSCallbackDataStrong&quot;;
6199     my $visibleName = $codeGenerator-&gt;GetVisibleInterfaceName($interfaceOrCallback);
6200     my $className = &quot;JS${name}&quot;;
6201 
6202     $includesRef-&gt;{&quot;ScriptExecutionContext.h&quot;} = 1;
6203 
6204     # Constructor
6205     push(@$contentRef, &quot;${className}::${className}(JSObject* callback, JSDOMGlobalObject* globalObject)\n&quot;);
6206     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6207         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext(), ${className}Type)\n&quot;);
6208     } else {
6209         push(@$contentRef, &quot;    : ${name}(globalObject-&gt;scriptExecutionContext())\n&quot;);
6210     }
6211     push(@$contentRef, &quot;    , m_data(new ${callbackDataType}(callback, globalObject, this))\n&quot;);
6212     push(@$contentRef, &quot;{\n&quot;);
6213     push(@$contentRef, &quot;}\n\n&quot;);
6214 
6215     # Destructor
6216     push(@$contentRef, &quot;${className}::~${className}()\n&quot;);
6217     push(@$contentRef, &quot;{\n&quot;);
6218     push(@$contentRef, &quot;    ScriptExecutionContext* context = scriptExecutionContext();\n&quot;);
6219     push(@$contentRef, &quot;    // When the context is destroyed, all tasks with a reference to a callback\n&quot;);
6220     push(@$contentRef, &quot;    // should be deleted. So if the context is 0, we are on the context thread.\n&quot;);
6221     push(@$contentRef, &quot;    if (!context || context-&gt;isContextThread())\n&quot;);
6222     push(@$contentRef, &quot;        delete m_data;\n&quot;);
6223     push(@$contentRef, &quot;    else\n&quot;);
6224     push(@$contentRef, &quot;        context-&gt;postTask(DeleteCallbackDataTask(m_data));\n&quot;);
6225     push(@$contentRef, &quot;#ifndef NDEBUG\n&quot;);
6226     push(@$contentRef, &quot;    m_data = nullptr;\n&quot;);
6227     push(@$contentRef, &quot;#endif\n&quot;);
6228     push(@$contentRef, &quot;}\n\n&quot;);
6229 
6230     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{CallbackNeedsOperatorEqual}) {
6231         push(@$contentRef, &quot;bool ${className}::operator==(const ${name}&amp; other) const\n&quot;);
6232         push(@$contentRef, &quot;{\n&quot;);
6233         push(@$contentRef, &quot;    if (other.type() != type())\n&quot;);
6234         push(@$contentRef, &quot;        return false;\n&quot;);
6235         push(@$contentRef, &quot;    return static_cast&lt;const ${className}*&gt;(&amp;other)-&gt;m_data-&gt;callback() == m_data-&gt;callback();\n&quot;);
6236         push(@$contentRef, &quot;}\n\n&quot;);
6237     }
6238 
6239     # Constants.
6240     my $numConstants = @{$constants};
6241     if ($numConstants &gt; 0) {
6242         GenerateConstructorDeclaration($contentRef, $className, $interfaceOrCallback, $name);
6243 
6244         my $hashSize = 0;
6245         my $hashName = $className . &quot;ConstructorTable&quot;;
6246 
6247         my @hashKeys = ();
6248         my @hashValue1 = ();
6249         my @hashValue2 = ();
6250         my @hashSpecials = ();
6251         my %conditionals = ();
6252         my %readWriteConditionals = ();
6253 
6254         foreach my $constant (@{$constants}) {
6255             my $name = $constant-&gt;name;
6256             push(@hashKeys, $name);
6257             push(@hashValue1, $constant-&gt;value);
6258             push(@hashValue2, &quot;0&quot;);
6259             push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
6260 
6261             my $implementedBy = $constant-&gt;extendedAttributes-&gt;{ImplementedBy};
6262             $implIncludes{&quot;${implementedBy}.h&quot;} = 1 if $implementedBy;
6263 
6264             my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
6265             $conditionals{$name} = $conditional if $conditional;
6266 
6267             $hashSize++;
6268         }
6269         $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, 1) if $hashSize &gt; 0;
6270 
6271         push(@$contentRef, $codeGenerator-&gt;GenerateCompileTimeCheckForEnumsIfNeeded($interfaceOrCallback));
6272 
6273         GenerateConstructorDefinitions($contentRef, $className, &quot;&quot;, $visibleName, $interfaceOrCallback);
6274 
6275         push(@$contentRef, &quot;JSValue ${className}::getConstructor(VM&amp; vm, const JSGlobalObject* globalObject)\n&quot;);
6276         push(@$contentRef, &quot;{\n&quot;);
6277         push(@$contentRef, &quot;    return getDOMConstructor&lt;${className}Constructor&gt;(vm, *jsCast&lt;const JSDOMGlobalObject*&gt;(globalObject));\n&quot;);
6278         push(@$contentRef, &quot;}\n\n&quot;);
6279     }
6280 
6281     # Operations
6282     my $numOperations = @{$operations};
6283     if ($numOperations &gt; 0) {
6284         foreach my $operation (@{$operations}) {
6285             next if $operation-&gt;extendedAttributes-&gt;{Custom};
6286         
6287             AddToIncludesForIDLType($operation-&gt;type, $includesRef);
6288 
6289             my $nativeReturnType = &quot;CallbackResult&lt;typename &quot; . GetIDLType($interfaceOrCallback, $operation-&gt;type) . &quot;::ImplementationType&gt;&quot;;
6290             
6291             # FIXME: Change the default name (used for callback functions) to something other than handleEvent. It makes little sense.
6292             my $functionName = $operation-&gt;name || &quot;handleEvent&quot;;
6293 
6294             my @arguments = ();
6295 
6296             my $thisValue = &quot;jsUndefined()&quot;;
6297 
6298             my $callbackThisObject = $operation-&gt;extendedAttributes-&gt;{CallbackThisObject};
6299             if ($callbackThisObject) {
6300                 my $thisObjectType = $codeGenerator-&gt;ParseType($callbackThisObject);
6301 
6302                 AddToIncludesForIDLType($thisObjectType, $includesRef, 1);
6303                 my $IDLType = GetIDLType($interfaceOrCallback, $thisObjectType);
6304                 push(@arguments, &quot;typename ${IDLType}::ParameterType thisObject&quot;);
6305 
6306                 my $thisObjectArgument = IDLArgument-&gt;new();
6307                 $thisObjectArgument-&gt;type($thisObjectType);
6308 
6309                 $thisValue = NativeToJSValueUsingReferences($thisObjectArgument, $interfaceOrCallback, &quot;thisObject&quot;, &quot;globalObject&quot;);
6310             }
6311 
6312             foreach my $argument (@{$operation-&gt;arguments}) {
6313                 AddToIncludesForIDLType($argument-&gt;type, $includesRef, 1);
6314                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6315                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6316             }
6317             
6318             push(@$contentRef, &quot;${nativeReturnType} ${className}::${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)\n&quot;);
6319             push(@$contentRef, &quot;{\n&quot;);
6320 
6321             # FIXME: This is needed for NodeFilter, which works even for disconnected iframes. We should investigate
6322             # if that behavior is needed for other callbacks.
6323             if (!$operation-&gt;extendedAttributes-&gt;{SkipCallbackInvokeCheck}) {
6324                 push(@$contentRef, &quot;    if (!canInvokeCallback())\n&quot;);
6325                 push(@$contentRef, &quot;        return CallbackResultType::UnableToExecute;\n\n&quot;);
6326             }
6327 
6328             push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
6329             push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
6330             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6331             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6332 
6333             push(@$contentRef, &quot;    auto&amp; lexicalGlobalObject = globalObject;\n&quot;);
6334 
6335             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6336             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6337 
6338             foreach my $argument (@{$operation-&gt;arguments}) {
6339                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6340             }
6341             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6342 
6343             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6344 
6345             my $callbackInvocation;
6346             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6347                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6348             } else {
6349                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
6350                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(vm, \&quot;${functionName}\&quot;), returnedException)&quot;;
6351             }
6352 
6353             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6354                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6355             } else {
6356                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6357             }
6358 
6359             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6360             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6361             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6362                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6363                 push(@$contentRef, &quot;        throwException(&amp;lexicalGlobalObject, throwScope, returnedException);\n&quot;);
6364             } else {
6365                 push(@$contentRef, &quot;        reportException(&amp;lexicalGlobalObject, returnedException);\n&quot;);
6366             }
6367             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6368             push(@$contentRef, &quot;     }\n\n&quot;);
6369 
6370             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6371                 push(@$contentRef, &quot;    return { };\n&quot;);
6372             } else {
6373                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;);
6374             
6375                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6376                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6377                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
6378                 push(@$contentRef, &quot;    return returnValue;\n&quot;);
6379             }
6380 
6381             push(@$contentRef, &quot;}\n\n&quot;);
6382         }
6383     }
6384 
6385     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6386         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6387         push(@$contentRef, &quot;{\n&quot;);
6388         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6389         push(@$contentRef, &quot;}\n\n&quot;);
6390     }
6391 
6392     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6393     push(@$contentRef, &quot;{\n&quot;);
6394     push(@$contentRef, &quot;    if (!static_cast&lt;${className}&amp;&gt;(impl).callbackData())\n&quot;);
6395     push(@$contentRef, &quot;        return jsNull();\n\n&quot;);
6396     push(@$contentRef, &quot;    return static_cast&lt;${className}&amp;&gt;(impl).callbackData()-&gt;callback();\n&quot;);
6397     push(@$contentRef, &quot;}\n\n&quot;);
6398 }
6399 
6400 sub GenerateImplementationFunctionCall
6401 {
6402     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6403 
6404     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6405     if ($callTracingCallback) {
6406         my @callTracerArguments = map { $_-&gt;name } @{$operation-&gt;arguments};
6407         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6408     }
6409 
6410     if (OperationHasForcedReturnValue($operation)) {
6411         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6412         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6413     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6414         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6415         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6416     } else {
6417         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;
6418         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6419     }
6420 }
6421 
6422 sub GenerateImplementationCustomFunctionCall
6423 {
6424     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6425 
6426     my @customFunctionArguments = ();
6427     push(@customFunctionArguments, &quot;*lexicalGlobalObject&quot;);
6428     push(@customFunctionArguments, &quot;*callFrame&quot;);
6429     push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
6430 
6431     if ($operation-&gt;isStatic) {
6432         push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6433     } else {
6434         push(@$outputArray, $indent . &quot;return JSValue::encode(castedThis-&gt;&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6435     }
6436 }
6437 
6438 sub IsValueIterableInterface
6439 {
6440     my $interface = shift;
6441     return 0 unless $interface-&gt;iterable;
6442     return 0 if length $interface-&gt;iterable-&gt;keyType;
6443     # FIXME: See https://webkit.org/b/159140, we should die if the next check is false.
6444     return 0 unless GetIndexedGetterOperation($interface);
6445     return 1;
6446 }
6447 
6448 sub IsKeyValueIterableInterface
6449 {
6450     my $interface = shift;
6451     return 0 unless $interface-&gt;iterable;
6452     return 0 if IsValueIterableInterface($interface);
6453     return 1;
6454 }
6455 
6456 sub GenerateIterableDefinition
6457 {
6458     my $interface = shift;
6459 
6460     my $interfaceName = $interface-&gt;type-&gt;name;
6461     my $className = &quot;JS$interfaceName&quot;;
6462     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
6463 
6464     AddToImplIncludes(&quot;JSDOMIterator.h&quot;);
6465 
6466     return unless IsKeyValueIterableInterface($interface);
6467 
6468     my $iteratorName = &quot;${interfaceName}Iterator&quot;;
6469     my $iteratorPrototypeName = &quot;${interfaceName}IteratorPrototype&quot;;
6470 
6471     my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
6472     my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
6473     my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
6474     my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
6475 
6476     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;keyType) if $interface-&gt;iterable-&gt;isKeyValue;
6477     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;valueType);
6478 
6479     push(@implContent,  &lt;&lt;END);
6480 struct ${iteratorTraitsName} {
6481     static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
6482     using KeyType = ${iteratorTraitsKeyType};
6483     using ValueType = ${iteratorTraitsValueType};
6484 };
6485 
6486 using ${iteratorName} = JSDOMIterator&lt;${className}, ${iteratorTraitsName}&gt;;
6487 using ${iteratorPrototypeName} = JSDOMIteratorPrototype&lt;${className}, ${iteratorTraitsName}&gt;;
6488 
6489 template&lt;&gt;
6490 const JSC::ClassInfo ${iteratorName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorName}) };
6491 
6492 template&lt;&gt;
6493 const JSC::ClassInfo ${iteratorPrototypeName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorPrototypeName}) };
6494 
6495 END
6496 
6497     foreach my $operation (@{$interface-&gt;iterable-&gt;operations}) {
6498         my $propertyName = $operation-&gt;name;
6499         my $functionName = GetFunctionName($interface, $className, $operation);
6500 
6501         next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
6502 
6503         if ($propertyName eq &quot;forEach&quot;) {
6504             push(@implContent,  &lt;&lt;END);
6505 static inline EncodedJSValue ${functionName}Caller(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)
6506 {
6507     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*lexicalGlobalObject, *callFrame, *thisObject, throwScope));
6508 }
6509 
6510 END
6511         } else {
6512             my $iterationKind = &quot;Entries&quot;;
6513             $iterationKind = &quot;Keys&quot; if $propertyName eq &quot;keys&quot;;
6514             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;values&quot;;
6515             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;
6516 
6517             push(@implContent,  &lt;&lt;END);
6518 static inline EncodedJSValue ${functionName}Caller(JSGlobalObject*, CallFrame*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)
6519 {
6520     return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
6521 }
6522 
6523 END
6524         }
6525 
6526         push(@implContent,  &lt;&lt;END);
6527 JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)
6528 {
6529     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*lexicalGlobalObject, *callFrame, &quot;${propertyName}&quot;);
6530 }
6531 
6532 END
6533     }
6534 }
6535 
6536 # http://heycam.github.io/webidl/#dfn-flattened-union-member-types
6537 sub GetFlattenedMemberTypes
6538 {
6539     my ($idlUnionType) = @_;
6540 
6541     my @flattenedMemberTypes = ();
6542 
6543     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6544         if ($memberType-&gt;isUnion) {
6545             push(@flattenedMemberTypes, GetFlattenedMemberTypes($memberType));
6546         } else {
6547             push(@flattenedMemberTypes, $memberType);
6548         }
6549     }
6550 
6551     return @flattenedMemberTypes;
6552 }
6553 
6554 # http://heycam.github.io/webidl/#dfn-number-of-nullable-member-types
6555 sub GetNumberOfNullableMemberTypes
6556 {
6557     my ($idlUnionType) = @_;
6558 
6559     my $count = 0;
6560 
6561     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6562         $count++ if $memberType-&gt;isNullable;
6563         $count += GetNumberOfNullableMemberTypes($memberType) if $memberType-&gt;isUnion;
6564     }
6565 
6566     return $count;
6567 }
6568 
6569 sub GetIDLUnionMemberTypes
6570 {
6571     my ($interface, $idlUnionType) = @_;
6572 
6573     my $numberOfNullableMembers = GetNumberOfNullableMemberTypes($idlUnionType);
6574     assert(&quot;Union types must only have 0 or 1 nullable types.&quot;) if $numberOfNullableMembers &gt; 1;
6575 
6576     my @idlUnionMemberTypes = ();
6577 
6578     push(@idlUnionMemberTypes, &quot;IDLNull&quot;) if $numberOfNullableMembers == 1;
6579 
6580     foreach my $memberType (GetFlattenedMemberTypes($idlUnionType)) {
6581         push(@idlUnionMemberTypes, GetIDLTypeExcludingNullability($interface, $memberType));
6582     }
6583 
6584     return @idlUnionMemberTypes;
6585 }
6586 
6587 sub IsAnnotatedType
6588 {
6589     my ($type) = @_;
6590 
6591     return 1 if $type-&gt;extendedAttributes-&gt;{Clamp};
6592     return 1 if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6593     return 1 if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
6594     return 1 if $type-&gt;extendedAttributes-&gt;{AtomString};
6595     return 1 if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};
6596 }
6597 
6598 sub GetAnnotatedIDLType
6599 {
6600     my ($type) = @_;
6601 
6602     return &quot;IDLClampAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{Clamp};
6603     return &quot;IDLEnforceRangeAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{EnforceRange};
6604     return &quot;IDLTreatNullAsEmptyAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{TreatNullAs} &amp;&amp; $type-&gt;extendedAttributes-&gt;{TreatNullAs} eq &quot;EmptyString&quot;;
6605     return &quot;IDLAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{AtomString};
6606     return &quot;IDLRequiresExistingAtomStringAdaptor&quot; if $type-&gt;extendedAttributes-&gt;{RequiresExistingAtomString};
6607 }
6608 
6609 sub GetBaseIDLType
6610 {
6611     my ($interface, $type) = @_;
6612 
6613     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6614         return $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6615     }
6616 
6617     my %IDLTypes = (
6618         &quot;void&quot; =&gt; &quot;IDLVoid&quot;,
6619         &quot;any&quot; =&gt; &quot;IDLAny&quot;,
6620         &quot;boolean&quot; =&gt; &quot;IDLBoolean&quot;,
6621         &quot;byte&quot; =&gt; &quot;IDLByte&quot;,
6622         &quot;octet&quot; =&gt; &quot;IDLOctet&quot;,
6623         &quot;short&quot; =&gt; &quot;IDLShort&quot;,
6624         &quot;unsigned short&quot; =&gt; &quot;IDLUnsignedShort&quot;,
6625         &quot;long&quot; =&gt; &quot;IDLLong&quot;,
6626         &quot;unsigned long&quot; =&gt; &quot;IDLUnsignedLong&quot;,
6627         &quot;long long&quot; =&gt; &quot;IDLLongLong&quot;,
6628         &quot;unsigned long long&quot; =&gt; &quot;IDLUnsignedLongLong&quot;,
6629         &quot;float&quot; =&gt; &quot;IDLFloat&quot;,
6630         &quot;unrestricted float&quot; =&gt; &quot;IDLUnrestrictedFloat&quot;,
6631         &quot;double&quot; =&gt; &quot;IDLDouble&quot;,
6632         &quot;unrestricted double&quot; =&gt; &quot;IDLUnrestrictedDouble&quot;,
6633         &quot;DOMString&quot; =&gt; &quot;IDLDOMString&quot;,
6634         &quot;ByteString&quot; =&gt; &quot;IDLByteString&quot;,
6635         &quot;USVString&quot; =&gt; &quot;IDLUSVString&quot;,
6636         &quot;object&quot; =&gt; &quot;IDLObject&quot;,
6637         &quot;ArrayBuffer&quot; =&gt; &quot;IDLArrayBuffer&quot;,
6638         &quot;ArrayBufferView&quot; =&gt; &quot;IDLArrayBufferView&quot;,
6639         &quot;DataView&quot; =&gt; &quot;IDLDataView&quot;,
6640         &quot;Int8Array&quot; =&gt; &quot;IDLInt8Array&quot;,
6641         &quot;Int16Array&quot; =&gt; &quot;IDLInt16Array&quot;,
6642         &quot;Int32Array&quot; =&gt; &quot;IDLInt32Array&quot;,
6643         &quot;Uint8Array&quot; =&gt; &quot;IDLUint8Array&quot;,
6644         &quot;Uint16Array&quot; =&gt; &quot;IDLUint16Array&quot;,
6645         &quot;Uint32Array&quot; =&gt; &quot;IDLUint32Array&quot;,
6646         &quot;Uint8ClampedArray&quot; =&gt; &quot;IDLUint8ClampedArray&quot;,
6647         &quot;Float32Array&quot; =&gt; &quot;IDLFloat32Array&quot;,
6648         &quot;Float64Array&quot; =&gt; &quot;IDLFloat64Array&quot;,
6649 
6650         # Non-WebIDL extensions
6651         &quot;Date&quot; =&gt; &quot;IDLDate&quot;,
6652         &quot;EventListener&quot; =&gt; &quot;IDLEventListener&lt;JSEventListener&gt;&quot;,
6653         &quot;JSON&quot; =&gt; &quot;IDLJSON&quot;,
6654         &quot;ScheduledAction&quot; =&gt; &quot;IDLScheduledAction&quot;,
6655         &quot;SerializedScriptValue&quot; =&gt; &quot;IDLSerializedScriptValue&lt;SerializedScriptValue&gt;&quot;,
6656         &quot;XPathNSResolver&quot; =&gt; &quot;IDLXPathNSResolver&lt;XPathNSResolver&gt;&quot;,
6657     );
6658 
6659     return $IDLTypes{$type-&gt;name} if exists $IDLTypes{$type-&gt;name};
6660     return &quot;IDLEnumeration&lt;&quot; . GetEnumerationClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsEnumType($type);
6661     return &quot;IDLDictionary&lt;&quot; . GetDictionaryClassName($type, $interface) . &quot;&gt;&quot; if $codeGenerator-&gt;IsDictionaryType($type);
6662     return &quot;IDLSequence&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsSequenceType($type);
6663     return &quot;IDLFrozenArray&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsFrozenArrayType($type);
6664     return &quot;IDLRecord&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;, &quot; . GetIDLType($interface, @{$type-&gt;subtypes}[1]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsRecordType($type);
6665     return &quot;IDLPromise&lt;&quot; . GetIDLType($interface, @{$type-&gt;subtypes}[0]) . &quot;&gt;&quot; if $codeGenerator-&gt;IsPromiseType($type);
6666     return &quot;IDLUnion&lt;&quot; . join(&quot;, &quot;, GetIDLUnionMemberTypes($interface, $type)) . &quot;&gt;&quot; if $type-&gt;isUnion;
6667     return &quot;IDLCallbackFunction&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackFunction($type);
6668     return &quot;IDLCallbackInterface&lt;&quot; . GetCallbackClassName($type-&gt;name) . &quot;&gt;&quot; if $codeGenerator-&gt;IsCallbackInterface($type);
6669 
6670     assert(&quot;Unknown type &#39;&quot; . $type-&gt;name . &quot;&#39;.\n&quot;) unless $codeGenerator-&gt;IsInterfaceType($type);
6671     return &quot;IDLInterface&lt;&quot; . $type-&gt;name . &quot;&gt;&quot;;
6672 }
6673 
6674 sub GetIDLTypeExcludingNullability
6675 {
6676     my ($interface, $type) = @_;
6677 
6678     my $baseIDLType = GetBaseIDLType($interface, $type);
6679     $baseIDLType = GetAnnotatedIDLType($type) . &quot;&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if IsAnnotatedType($type);
6680     return $baseIDLType;
6681 }
6682 
6683 sub GetIDLType
6684 {
6685     my ($interface, $type) = @_;
6686 
6687     my $baseIDLType = GetIDLTypeExcludingNullability($interface, $type);
6688     $baseIDLType = &quot;IDLNullable&lt;&quot; . $baseIDLType . &quot;&gt;&quot; if $type-&gt;isNullable;
6689     return $baseIDLType;
6690 }
6691 
6692 sub ShouldPassArgumentByReference
6693 {
6694     my ($argument) = @_;
6695 
6696     my $type = $argument-&gt;type;
6697 
6698     return 0 if $type-&gt;isNullable;
6699     return 0 if $codeGenerator-&gt;IsCallbackInterface($type);
6700     return 0 if $codeGenerator-&gt;IsCallbackFunction($type);
6701     return 0 if !$codeGenerator-&gt;IsWrapperType($type) &amp;&amp; !$codeGenerator-&gt;IsBufferSourceType($type);
6702 
6703     return 1;
6704 }
6705 
6706 sub JSValueToNativeDOMConvertNeedsThisObject
6707 {
6708     my $type = shift;
6709 
6710     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
6711     return 0;
6712 }
6713 
6714 sub JSValueToNativeDOMConvertNeedsGlobalObject
6715 {
6716     my $type = shift;
6717 
6718     return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
6719     return 1 if $codeGenerator-&gt;IsCallbackFunction($type);
6720     return JSValueToNativeDOMConvertNeedsGlobalObject(@{$type-&gt;subtypes}[1]) if $codeGenerator-&gt;IsRecordType($type);
6721     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
6722     return 0;
6723 }
6724 
6725 sub IsValidContextForJSValueToNative
6726 {
6727     my $context = shift;
6728     return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6729 }
6730 
6731 sub JSValueToNative
6732 {
6733     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;
6734 
6735     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6736 
6737     my $type = $context-&gt;type;
6738 
6739     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6740     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;
6741     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;
6742     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6743 
6744     AddToImplIncludesForIDLType($type, $conditional);
6745     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6746 
6747     my $IDLType = GetIDLType($interface, $type);
6748 
6749     my @conversionArguments = ();
6750     push(@conversionArguments, $lexicalGlobalObjectReference);
6751     push(@conversionArguments, $value);
6752     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6753     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6754     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6755 
6756     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6757 }
6758 
6759 sub ToNativeForFunctionWithoutTypeCheck
6760 {
6761     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference) = @_;
6762 
6763     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6764 
6765     my $type = $context-&gt;type;
6766 
6767     # FIXME: Remove these 3 variables when all JSValueToNative use references.
6768     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;
6769     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;
6770     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6771 
6772     AddToImplIncludesForIDLType($type, $conditional);
6773 
6774     # FIXME: Support more types.
6775 
6776     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6777 
6778     my $IDLType = GetIDLType($interface, $type);
6779 
6780     my @conversionArguments = ();
6781     push(@conversionArguments, &quot;$lexicalGlobalObjectReference&quot;);
6782     push(@conversionArguments, &quot;$value&quot;);
6783 
6784     return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
6785 }
6786 
6787 sub NativeToJSValueDOMConvertNeedsState
6788 {
6789     my ($type) = @_;
6790 
6791     # FIXME: We need a more robust way to specify this requirement so as not
6792     # to require specializing each type. Perhaps just requiring all override
6793     # types to take both lexicalGlobalObject and the global object would work?
6794     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6795         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6796         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6797         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6798         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6799 
6800         return 0;
6801     }
6802 
6803     # FIXME: This should actually check if all the sub-objects of the union need the lexicalGlobalObject.
6804     return 1 if $type-&gt;isUnion;
6805     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6806     return 1 if $codeGenerator-&gt;IsRecordType($type);
6807     return 1 if $codeGenerator-&gt;IsStringType($type);
6808     return 1 if $codeGenerator-&gt;IsEnumType($type);
6809     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6810     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6811     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6812     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6813     return 1 if $type-&gt;name eq &quot;Date&quot;;
6814     return 1 if $type-&gt;name eq &quot;JSON&quot;;
6815     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6816     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6817     
6818     return 0;
6819 }
6820 
6821 sub NativeToJSValueDOMConvertNeedsGlobalObject
6822 {
6823     my ($type) = @_;
6824     
6825     # FIXME: We need a more robust way to specify this requirement so as not
6826     # to require specializing each type. Perhaps just requiring all override
6827     # types to take both lexicalGlobalObject and the global object would work?
6828     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6829         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6830         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6831         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6832         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6833 
6834         return 0;
6835     }
6836 
6837     # FIXME: This should actually check if all the sub-objects of the union need the global object.
6838     return 1 if $type-&gt;isUnion;
6839     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6840     return 1 if $codeGenerator-&gt;IsRecordType($type);
6841     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6842     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6843     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6844     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6845     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6846     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6847 
6848     return 0;
6849 }
6850 
6851 sub NativeToJSValueUsingReferences
6852 {
6853     my ($context, $interface, $value, $globalObjectReference) = @_;
6854 
6855     return NativeToJSValue($context, $interface, $value, &quot;lexicalGlobalObject&quot;, $globalObjectReference);
6856 }
6857 
6858 # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
6859 sub NativeToJSValueUsingPointers
6860 {
6861     my ($context, $interface, $value, $globalObjectReference) = @_;
6862 
6863     return NativeToJSValue($context, $interface, $value, &quot;*lexicalGlobalObject&quot;, $globalObjectReference);
6864 }
6865 
6866 sub IsValidContextForNativeToJSValue
6867 {
6868     my $context = shift;
6869     
6870     return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6871 }
6872 
6873 sub NativeToJSValue
6874 {
6875     my ($context, $interface, $value, $lexicalGlobalObjectReference, $globalObjectReference) = @_;
6876 
6877     assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
6878 
6879     my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
6880     my $type = $context-&gt;type;
6881     my $mayThrowException = ref($context) eq &quot;IDLAttribute&quot; || $context-&gt;extendedAttributes-&gt;{MayThrowException};
6882 
6883     # We could instead overload a function to work with optional as well as non-optional numbers, but this
6884     # is slightly better because it guarantees we will fail to compile if the IDL file doesn&#39;t match the C++.
6885     if ($context-&gt;extendedAttributes-&gt;{Reflect} and ($type-&gt;name eq &quot;unsigned long&quot; or $type-&gt;name eq &quot;unsigned short&quot;)) {
6886         $value =~ s/getUnsignedIntegralAttribute/getIntegralAttribute/g;
6887         $value = &quot;std::max(0, $value)&quot;;
6888     }
6889 
6890     AddToImplIncludesForIDLType($type, $conditional);
6891     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6892 
6893     if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
6894         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
6895         $value = &quot;BindingSecurity::checkSecurityForNode($lexicalGlobalObjectReference, $value)&quot;;
6896     }
6897 
6898     my $IDLType = GetIDLType($interface, $type);
6899 
6900     my @conversionArguments = ();
6901     push(@conversionArguments, $lexicalGlobalObjectReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;
6902     push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6903     push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
6904     push(@conversionArguments, $value);
6905 
6906     my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
6907 
6908     return &quot;${functionName}&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6909 }
6910 
6911 sub ceilingToPowerOf2
6912 {
6913     my ($size) = @_;
6914 
6915     my $powerOf2 = 1;
6916     while ($size &gt; $powerOf2) {
6917         $powerOf2 &lt;&lt;= 1;
6918     }
6919 
6920     return $powerOf2;
6921 }
6922 
6923 # Internal Helper
6924 sub GenerateHashTableValueArray
6925 {
6926     my $keys = shift;
6927     my $specials = shift;
6928     my $value1 = shift;
6929     my $value2 = shift;
6930     my $conditionals = shift;
6931     my $readWriteConditionals = shift;
6932     my $nameEntries = shift;
6933 
6934     my $packedSize = scalar @{$keys};
6935     push(@implContent, &quot;\nstatic const HashTableValue $nameEntries\[\] =\n\{\n&quot;);
6936 
6937     my $hasSetter = &quot;false&quot;;
6938 
6939     my $i = 0;
6940     foreach my $key (@{$keys}) {
6941         my $firstTargetType;
6942         my $secondTargetType = &quot;&quot;;
6943         my $conditional;
6944 
6945         if ($conditionals) {
6946             $conditional = $conditionals-&gt;{$key};
6947         }
6948         if ($conditional) {
6949             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
6950             push(@implContent, &quot;#if ${conditionalString}\n&quot;);
6951         }
6952 
6953         if (&quot;@$specials[$i]&quot; =~ m/DOMJITFunction/) {
6954             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6955             $secondTargetType = &quot;static_cast&lt;const JSC::DOMJIT::Signature*&gt;&quot;;
6956         } elsif (&quot;@$specials[$i]&quot; =~ m/Function/) {
6957             $firstTargetType = &quot;static_cast&lt;RawNativeFunction&gt;&quot;;
6958         } elsif (&quot;@$specials[$i]&quot; =~ m/Builtin/) {
6959             $firstTargetType = &quot;static_cast&lt;BuiltinGenerator&gt;&quot;;
6960         } elsif (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6961             $firstTargetType = &quot;&quot;;
6962         } elsif (&quot;@$specials[$i]&quot; =~ m/DOMJITAttribute/) {
6963             $firstTargetType = &quot;static_cast&lt;const JSC::DOMJIT::GetterSetter*&gt;&quot;;
6964         } else {
6965             $firstTargetType = &quot;static_cast&lt;PropertySlot::GetValueFunc&gt;&quot;;
6966             $secondTargetType = &quot;static_cast&lt;PutPropertySlot::PutValueFunc&gt;&quot;;
6967             $hasSetter = &quot;true&quot;;
6968         }
6969         if (&quot;@$specials[$i]&quot; =~ m/ConstantInteger/) {
6970             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (long long)&quot; . $firstTargetType . &quot;(@$value1[$i]) } },\n&quot;);
6971         } else {
6972             my $readWriteConditional = $readWriteConditionals ? $readWriteConditionals-&gt;{$key} : undef;
6973             if ($readWriteConditional) {
6974                 my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
6975                 push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
6976             }
6977 
6978             push(@implContent, &quot;    { \&quot;$key\&quot;, @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) &quot; . $secondTargetType . &quot;(@$value2[$i]) } },\n&quot;);
6979 
6980             if ($readWriteConditional) {
6981                 push(@implContent, &quot;#else\n&quot;) ;
6982                 push(@implContent, &quot;    { \&quot;$key\&quot;, JSC::PropertyAttribute::ReadOnly | @$specials[$i], NoIntrinsic, { (intptr_t)&quot; . $firstTargetType . &quot;(@$value1[$i]), (intptr_t) static_cast&lt;PutPropertySlot::PutValueFunc&gt;(0) } },\n&quot;);
6983                 push(@implContent, &quot;#endif\n&quot;);
6984             }
6985         }
6986         if ($conditional) {
6987             push(@implContent, &quot;#else\n&quot;);
6988             push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } },\n&quot;);
6989             push(@implContent, &quot;#endif\n&quot;);
6990         }
6991         ++$i;
6992     }
6993 
6994     push(@implContent, &quot;    { 0, 0, NoIntrinsic, { 0, 0 } }\n&quot;) if (!$packedSize);
6995     push(@implContent, &quot;};\n\n&quot;);
6996 
6997     return $hasSetter;
6998 }
6999 
7000 sub GenerateHashTable
7001 {
7002     my $object = shift;
7003 
7004     my $className = shift;
7005     my $name = shift;
7006     my $size = shift;
7007     my $keys = shift;
7008     my $specials = shift;
7009     my $value1 = shift;
7010     my $value2 = shift;
7011     my $conditionals = shift;
7012     my $readWriteConditionals = shift;
7013     my $justGenerateValueArray = shift;
7014 
7015     my $nameEntries = &quot;${name}Values&quot;;
7016     $nameEntries =~ s/:/_/g;
7017     my $nameIndex = &quot;${name}Index&quot;;
7018     $nameIndex =~ s/:/_/g;
7019 
7020     if (($name =~ /Prototype/) or ($name =~ /Constructor/)) {
7021         my $type = $name;
7022         my $implClass;
7023 
7024         if ($name =~ /Prototype/) {
7025             $type =~ s/Prototype.*//;
7026             $implClass = $type; $implClass =~ s/Wrapper$//;
7027             push(@implContent, &quot;/* Hash table for prototype */\n&quot;);
7028         } else {
7029             $type =~ s/Constructor.*//;
7030             $implClass = $type; $implClass =~ s/Constructor$//;
7031             push(@implContent, &quot;/* Hash table for constructor */\n&quot;);
7032         }
7033     } else {
7034         push(@implContent, &quot;/* Hash table */\n&quot;);
7035     }
7036 
7037     if ($justGenerateValueArray) {
7038         GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries) if $size;
7039         return;
7040     }
7041 
7042     # Generate size data for compact&#39; size hash table
7043 
7044     my @table = ();
7045     my @links = ();
7046 
7047     my $compactSize = ceilingToPowerOf2($size * 2);
7048 
7049     my $maxDepth = 0;
7050     my $collisions = 0;
7051     my $numEntries = $compactSize;
7052 
7053     my $i = 0;
7054     foreach (@{$keys}) {
7055         my $depth = 0;
7056         my $h = Hasher::GenerateHashValue($_) % $numEntries;
7057 
7058         while (defined($table[$h])) {
7059             if (defined($links[$h])) {
7060                 $h = $links[$h];
7061                 $depth++;
7062             } else {
7063                 $collisions++;
7064                 $links[$h] = $compactSize;
7065                 $h = $compactSize;
7066                 $compactSize++;
7067             }
7068         }
7069 
7070         $table[$h] = $i;
7071 
7072         $i++;
7073         $maxDepth = $depth if ($depth &gt; $maxDepth);
7074     }
7075 
7076     push(@implContent, &quot;\nstatic const struct CompactHashIndex ${nameIndex}\[$compactSize\] = {\n&quot;);
7077     for (my $i = 0; $i &lt; $compactSize; $i++) {
7078         my $T = -1;
7079         if (defined($table[$i])) { $T = $table[$i]; }
7080         my $L = -1;
7081         if (defined($links[$i])) { $L = $links[$i]; }
7082         push(@implContent, &quot;    { $T, $L },\n&quot;);
7083     }
7084     push(@implContent, &quot;};\n\n&quot;);
7085 
7086     # Dump the hash table
7087     my $hasSetter = GenerateHashTableValueArray($keys, $specials, $value1, $value2, $conditionals, $readWriteConditionals, $nameEntries);
7088     my $packedSize = scalar @{$keys};
7089 
7090     my $compactSizeMask = $numEntries - 1;
7091     push(@implContent, &quot;static const HashTable $name = { $packedSize, $compactSizeMask, $hasSetter, ${className}::info(), $nameEntries, $nameIndex };\n&quot;);
7092 }
7093 
7094 sub WriteData
7095 {
7096     my $object = shift;
7097     my $interface = shift;
7098     my $outputDir = shift;
7099 
7100     my $name = $interface-&gt;type-&gt;name;
7101     my $headerFileName = &quot;$outputDir/JS$name.h&quot;;
7102     my $implFileName = &quot;$outputDir/JS$name.cpp&quot;;
7103     my $depsFileName = &quot;$outputDir/JS$name.dep&quot;;
7104 
7105     # Update a .cpp file if the contents are changed.
7106     my $contents = join &quot;&quot;, @implContentHeader;
7107 
7108     my @includes = ();
7109     my %implIncludeConditions = ();
7110     foreach my $include (keys %implIncludes) {
7111         next if $headerIncludes{$include};
7112         next if $headerTrailingIncludes{$include};
7113 
7114         my $condition = $implIncludes{$include};
7115 
7116         my $checkType = $include;
7117         $checkType =~ s/\.h//;
7118         next if $codeGenerator-&gt;IsSVGAnimatedTypeName($checkType);
7119 
7120         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7121 
7122         if ($condition eq 1) {
7123             push @includes, $include;
7124         } else {
7125             push @{$implIncludeConditions{$codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($condition)}}, $include;
7126         }
7127     }
7128     foreach my $include (sort @includes) {
7129         $contents .= &quot;#include $include\n&quot;;
7130     }
7131     foreach my $condition (sort keys %implIncludeConditions) {
7132         $contents .= &quot;\n#if &quot; . $condition . &quot;\n&quot;;
7133         foreach my $include (sort @{$implIncludeConditions{$condition}}) {
7134             $contents .= &quot;#include $include\n&quot;;
7135         }
7136         $contents .= &quot;#endif\n&quot;;
7137     }
7138 
7139     $contents .= join &quot;&quot;, @implContent;
7140     $codeGenerator-&gt;UpdateFile($implFileName, $contents);
7141 
7142     @implContentHeader = ();
7143     @implContent = ();
7144     %implIncludes = ();
7145 
7146     # Update a .h file if the contents are changed.
7147     $contents = join &quot;&quot;, @headerContentHeader;
7148 
7149     @includes = ();
7150     foreach my $include (keys %headerIncludes) {
7151         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7152         push @includes, $include;
7153     }
7154     foreach my $include (sort @includes) {
7155         # &quot;JSClassName.h&quot; is already included right after config.h.
7156         next if $include eq &quot;\&quot;JS$name.h\&quot;&quot;;
7157         $contents .= &quot;#include $include\n&quot;;
7158     }
7159 
7160     $contents .= join &quot;&quot;, @headerContent;
7161 
7162     @includes = ();
7163     foreach my $include (keys %headerTrailingIncludes) {
7164         $include = &quot;\&quot;$include\&quot;&quot; unless $include =~ /^[&quot;&lt;]/; # &quot;
7165         push @includes, $include;
7166     }
7167     foreach my $include (sort @includes) {
7168         $contents .= &quot;#include $include\n&quot;;
7169     }
7170     $codeGenerator-&gt;UpdateFile($headerFileName, $contents);
7171 
7172     @headerContentHeader = ();
7173     @headerContent = ();
7174     %headerIncludes = ();
7175     %headerTrailingIncludes = ();
7176 
7177     if (@depsContent) {
7178         # Update a .dep file if the contents are changed.
7179         $contents = join &quot;&quot;, @depsContent;
7180         $codeGenerator-&gt;UpdateFile($depsFileName, $contents);
7181 
7182         @depsContent = ();
7183     }
7184 }
7185 
7186 sub GeneratePrototypeDeclaration
7187 {
7188     my ($outputArray, $className, $interface) = @_;
7189 
7190     my $prototypeClassName = &quot;${className}Prototype&quot;;
7191 
7192     my %structureFlags = ();
7193     push(@$outputArray, &quot;class ${prototypeClassName} : public JSC::JSNonFinalObject {\n&quot;);
7194     push(@$outputArray, &quot;public:\n&quot;);
7195     push(@$outputArray, &quot;    using Base = JSC::JSNonFinalObject;\n&quot;);
7196 
7197     push(@$outputArray, &quot;    static ${prototypeClassName}* create(JSC::VM&amp; vm, JSDOMGlobalObject* globalObject, JSC::Structure* structure)\n&quot;);
7198     push(@$outputArray, &quot;    {\n&quot;);
7199     push(@$outputArray, &quot;        ${className}Prototype* ptr = new (NotNull, JSC::allocateCell&lt;${className}Prototype&gt;(vm.heap)) ${className}Prototype(vm, globalObject, structure);\n&quot;);
7200     push(@$outputArray, &quot;        ptr-&gt;finishCreation(vm);\n&quot;);
7201     push(@$outputArray, &quot;        return ptr;\n&quot;);
7202     push(@$outputArray, &quot;    }\n\n&quot;);
7203 
7204     push(@$outputArray, &quot;    DECLARE_INFO;\n&quot;);
7205 
7206     push(@$outputArray, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
7207     push(@$outputArray, &quot;    {\n&quot;);
7208     push(@$outputArray, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
7209     push(@$outputArray, &quot;    }\n&quot;);
7210 
7211     push(@$outputArray, &quot;\nprivate:\n&quot;);
7212     push(@$outputArray, &quot;    ${prototypeClassName}(JSC::VM&amp; vm, JSC::JSGlobalObject*, JSC::Structure* structure)\n&quot;);
7213     push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
7214     push(@$outputArray, &quot;    {\n&quot;);
7215     push(@$outputArray, &quot;    }\n&quot;);
7216 
7217     if (PrototypeHasStaticPropertyTable($interface)) {
7218         if (IsGlobalInterface($interface)) {
7219             $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
7220         } else {
7221             push(@$outputArray, &quot;\n&quot;);
7222             push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
7223         }
7224     }
7225 
7226     # FIXME: Should this override putByIndex as well?
7227     if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
7228         push(@$outputArray, &quot;\n&quot;);
7229         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);
7230     }
7231 
7232     if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
7233         push(@$outputArray, &quot;\n&quot;);
7234         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);
7235     }
7236 
7237     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
7238 
7239     # structure flags
7240     if (%structureFlags) {
7241         push(@$outputArray, &quot;public:\n&quot;);
7242         push(@$outputArray, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);
7243         foreach my $structureFlag (sort (keys %structureFlags)) {
7244             push(@$outputArray, &quot; | &quot; . $structureFlag);
7245         }
7246         push(@$outputArray, &quot;;\n&quot;);
7247     }
7248 
7249     push(@$outputArray, &quot;};\n&quot;);
7250     push(@$outputArray, &quot;STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(${prototypeClassName}, ${prototypeClassName}::Base);\n\n&quot;);
7251 }
7252 
7253 sub GetConstructorTemplateClassName
7254 {
7255     my $interface = shift;
7256     return &quot;JSDOMConstructorNotConstructable&quot; if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7257     return &quot;JSDOMConstructorNotConstructable&quot; unless IsConstructable($interface);
7258     return &quot;JSDOMBuiltinConstructor&quot; if IsJSBuiltinConstructor($interface);
7259     return &quot;JSDOMConstructor&quot;;
7260 }
7261 
7262 sub GenerateConstructorDeclaration
7263 {
7264     my ($outputArray, $className, $interface) = @_;
7265 
7266     my $interfaceName = $interface-&gt;type-&gt;name;
7267     my $constructorClassName = &quot;${className}Constructor&quot;;
7268     my $templateClassName = GetConstructorTemplateClassName($interface);
7269 
7270     AddToImplIncludes(&quot;${templateClassName}.h&quot;);
7271     AddToImplIncludes(&quot;JSDOMNamedConstructor.h&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7272 
7273     push(@$outputArray, &quot;using $constructorClassName = $templateClassName&lt;$className&gt;;\n&quot;);
7274     push(@$outputArray, &quot;using JS${interfaceName}NamedConstructor = JSDOMNamedConstructor&lt;$className&gt;;\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7275     push(@$outputArray, &quot;\n&quot;);
7276 }
7277 
7278 sub GenerateConstructorDefinitions
7279 {
7280     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7281 
7282     if (IsConstructable($interface)) {
7283         my @constructors = @{$interface-&gt;constructors};
7284         if (@constructors &gt; 1) {
7285             foreach my $constructor (@constructors) {
7286                 GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
7287             }
7288 
7289             my $overloadFunctionPrefix = &quot;construct${className}&quot;;
7290 
7291             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
7292             push(@implContent, &quot;{\n&quot;);
7293             push(@implContent, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
7294             push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7295             push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7296 
7297             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);
7298 
7299             push(@implContent, &quot;}\n\n&quot;);
7300         } elsif (@constructors == 1) {
7301             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
7302         } else {
7303             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7304         }
7305     }
7306 
7307     GenerateConstructorHelperMethods($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7308 }
7309 
7310 sub GenerateConstructorDefinition
7311 {
7312     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $operation) = @_;
7313 
7314     return if IsJSBuiltinConstructor($interface);
7315 
7316     my $interfaceName = $interface-&gt;type-&gt;name;
7317     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7318 
7319     if (IsConstructable($interface)) {
7320         if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7321             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)\n&quot;);
7322             push(@$outputArray, &quot;{\n&quot;);
7323             push(@$outputArray, &quot;    ASSERT(callFrame);\n&quot;);
7324             push(@$outputArray, &quot;    return construct${className}(lexicalGlobalObject, *callFrame);\n&quot;);
7325             push(@$outputArray, &quot;}\n\n&quot;);
7326          } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
7327             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
7328             if ($isOverloaded) {
7329                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
7330             } else {
7331                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);
7332             }
7333 
7334             push(@$outputArray, &quot;{\n&quot;);
7335             push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);
7336             push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7337             push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7338             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(callFrame-&gt;jsCallee());\n&quot;);
7339             push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
7340 
7341              if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {
7342                  my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation, &quot;lexicalGlobalObject&quot;);
7343                  push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7344                  push(@$outputArray, &quot;        throwTypeError(lexicalGlobalObject, throwScope, \&quot;Illegal constructor\&quot;_s);\n&quot;);
7345                  push(@$outputArray, &quot;        return JSValue::encode(jsNull());\n&quot;);
7346                  push(@$outputArray, &quot;    }\n&quot;);
7347              }
7348 
7349             GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
7350 
7351             my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
7352             my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
7353 
7354             push(@$outputArray, &quot;    auto object = ${functionString};\n&quot;);
7355             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($interface-&gt;extendedAttributes-&gt;{ConstructorCallWith}, &quot;ExecState&quot;);
7356 
7357             my $IDLType = GetIDLType($interface, $interface-&gt;type);
7358 
7359             AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
7360 
7361             my @constructionConversionArguments = ();
7362             push(@constructionConversionArguments, &quot;*lexicalGlobalObject&quot;);
7363             push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
7364             push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
7365             push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
7366 
7367             push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
7368             push(@$outputArray, &quot;}\n\n&quot;);
7369         }
7370     }
7371 }
7372 
7373 sub ConstructorHasProperties
7374 {
7375     my $interface = shift;
7376 
7377     foreach my $constant (@{$interface-&gt;constants}) {
7378         return 1;
7379     }
7380 
7381     foreach my $attribute (@{$interface-&gt;attributes}) {
7382         next unless ($attribute-&gt;isStatic);
7383         return 1;
7384     }
7385 
7386     foreach my $operation (@{$interface-&gt;operations}) {
7387         next unless ($operation-&gt;isStatic);
7388         return 1;
7389     }
7390 
7391     return 0;
7392 }
7393 
7394 sub GetRuntimeEnabledStaticProperties
7395 {
7396     my ($interface) = @_;
7397 
7398     my @runtimeEnabledProperties = ();
7399 
7400     my @attributes = @{$interface-&gt;attributes};
7401     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
7402     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;
7403 
7404     foreach my $attribute (@attributes) {
7405         next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
7406         next if not $attribute-&gt;isStatic;
7407 
7408         if (NeedsRuntimeCheck($interface, $attribute)) {
7409             push(@runtimeEnabledProperties, $attribute);
7410         }
7411     }
7412 
7413     my @operations = @{$interface-&gt;operations};
7414     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
7415     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
7416     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;
7417     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
7418     foreach my $operation (@operations) {
7419         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
7420         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
7421         next if OperationShouldBeOnInstance($interface, $operation) != 0;
7422         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
7423         next if not $operation-&gt;isStatic;
7424 
7425         if (NeedsRuntimeCheck($interface, $operation)) {
7426             push(@runtimeEnabledProperties, $operation);
7427         }
7428     }
7429 
7430     return @runtimeEnabledProperties;
7431 }
7432 
7433 sub GenerateConstructorHelperMethods
7434 {
7435     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7436 
7437     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7438     my $leastConstructorLength = 0;
7439     if ($interface-&gt;extendedAttributes-&gt;{Constructor} || $interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
7440         my @constructors = @{$interface-&gt;constructors};
7441         my @customConstructors = @{$interface-&gt;customConstructors};
7442         $leastConstructorLength = 255;
7443         foreach my $constructor (@constructors, @customConstructors) {
7444             my $constructorLength = GetFunctionLength($constructor);
7445             $leastConstructorLength = $constructorLength if ($constructorLength &lt; $leastConstructorLength);
7446         }
7447     } else {
7448         $leastConstructorLength = 0;
7449     }
7450 
7451     # If the interface has a parent interface which does not have [NoInterfaceObject], then use its interface object as prototype,
7452     # otherwise use FunctionPrototype: http://heycam.github.io/webidl/#interface-object
7453     push(@$outputArray, &quot;template&lt;&gt; JSValue ${constructorClassName}::prototypeForStructure(JSC::VM&amp; vm, const JSDOMGlobalObject&amp; globalObject)\n&quot;);
7454     push(@$outputArray, &quot;{\n&quot;);
7455 
7456     assert(&quot;An interface cannot inherit from another interface that is marked as [NoInterfaceObject]&quot;) if $interface-&gt;parentType &amp;&amp; $codeGenerator-&gt;GetInterfaceExtendedAttributesFromName($interface-&gt;parentType-&gt;name)-&gt;{NoInterfaceObject};
7457 
7458     if (!$generatingNamedConstructor and $interface-&gt;parentType) {
7459         my $parentClassName = &quot;JS&quot; . $interface-&gt;parentType-&gt;name;
7460         push(@$outputArray, &quot;    return ${parentClassName}::getConstructor(vm, &amp;globalObject);\n&quot;);
7461     } else {
7462         AddToImplIncludes(&quot;&lt;JavaScriptCore/FunctionPrototype.h&gt;&quot;);
7463         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
7464         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7465     }
7466     push(@$outputArray, &quot;}\n\n&quot;);
7467 
7468 
7469     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7470     push(@$outputArray, &quot;{\n&quot;);
7471 
7472     # There must exist an interface prototype object for every non-callback interface defined, regardless
7473     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7474     # https://heycam.github.io/webidl/#interface-prototype-object
7475     if (ShouldUseGlobalObjectPrototype($interface)) {
7476         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7477     } elsif ($interface-&gt;isCallback) {
7478         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7479     } else {
7480         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7481     }
7482 
7483     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7484 
7485     if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {
7486         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $interface, &quot;&amp;globalObject&quot;);
7487         push(@$outputArray, &quot;    int constructorLength = ${leastConstructorLength};\n&quot;);
7488         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);
7489         push(@$outputArray, &quot;        constructorLength = 0;\n&quot;);
7490         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(constructorLength), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7491     } else {
7492         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7493     }
7494 
7495     my $classForThis = &quot;${className}::info()&quot;;
7496     if ($interface-&gt;isCallback) {
7497         $classForThis = &quot;nullptr&quot;;
7498     }
7499     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7500 
7501     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7502 
7503     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7504         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7505         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
7506         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;&amp;globalObject&quot;);
7507         my $name = $operationOrAttribute-&gt;name;
7508         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7509         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
7510         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
7511         push(@$outputArray, &quot;        JSObject::deleteProperty(this, &amp;globalObject, propertyName);\n&quot;);
7512         push(@$outputArray, &quot;    }\n&quot;);
7513         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7514     }
7515 
7516     push(@$outputArray, &quot;}\n\n&quot;);
7517 
7518     if (IsJSBuiltinConstructor($interface)) {
7519         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7520         push(@$outputArray, &quot;{\n&quot;);
7521         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7522         push(@$outputArray, &quot;}\n&quot;);
7523         push(@$outputArray, &quot;\n&quot;);
7524     }
7525     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7526 }
7527 
7528 sub HasCustomConstructor
7529 {
7530     my $interface = shift;
7531     return $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7532 }
7533 
7534 sub HasCustomGetter
7535 {
7536     my $attribute = shift;
7537     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomGetter};
7538 }
7539 
7540 sub HasCustomSetter
7541 {
7542     my $attribute = shift;
7543     return $attribute-&gt;extendedAttributes-&gt;{Custom} || $attribute-&gt;extendedAttributes-&gt;{CustomSetter};
7544 }
7545 
7546 sub HasCustomMethod
7547 {
7548     my $operation = shift;
7549     return $operation-&gt;extendedAttributes-&gt;{Custom};
7550 }
7551 
7552 sub NeedsConstructorProperty
7553 {
7554     my $interface = shift;
7555     
7556     return !$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject};
7557 }
7558 
7559 sub IsConstructable
7560 {
7561     my $interface = shift;
7562     return HasCustomConstructor($interface)
7563         || $interface-&gt;extendedAttributes-&gt;{Constructor}
7564         || $interface-&gt;extendedAttributes-&gt;{NamedConstructor}
7565         || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7566 }
7567 
7568 sub InstanceOverridesGetCallData
7569 {
7570     my $interface = shift;
7571     return $interface-&gt;{LegacyCallers} || $interface-&gt;extendedAttributes-&gt;{CustomGetCallData} || $interface-&gt;extendedAttributes-&gt;{Plugin};
7572 }
7573 
7574 sub HeaderNeedsPrototypeDeclaration
7575 {
7576     my $interface = shift;
7577     return IsDOMGlobalObject($interface)
7578         || $interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}
7579         || $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype};
7580 }
7581 
7582 sub IsUnforgeable
7583 {
7584     my ($interface, $property) = @_;
7585 
7586     return $property-&gt;extendedAttributes-&gt;{Unforgeable} || $interface-&gt;extendedAttributes-&gt;{Unforgeable};
7587 }
7588 
7589 sub ComputeFunctionSpecial
7590 {
7591     my ($interface, $operation) = @_;
7592 
7593     my @specials = ();
7594     push(@specials, (&quot;JSC::PropertyAttribute::DontDelete&quot;, &quot;JSC::PropertyAttribute::ReadOnly&quot;)) if IsUnforgeable($interface, $operation);
7595     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if $operation-&gt;extendedAttributes-&gt;{NotEnumerable};
7596     if (IsJSBuiltin($interface, $operation)) {
7597         push(@specials, &quot;JSC::PropertyAttribute::Builtin&quot;);
7598     } else {
7599         push(@specials, &quot;JSC::PropertyAttribute::Function&quot;);
7600     }
7601     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
7602         push(@specials, &quot;JSC::PropertyAttribute::DOMJITFunction&quot;) if $operation-&gt;extendedAttributes-&gt;{DOMJIT};
7603     }
7604     return &quot;static_cast&lt;unsigned&gt;(&quot; . ((@specials &gt; 0) ? join(&quot; | &quot;, @specials) : &quot;0&quot;) . &quot;)&quot;;
7605 }
7606 
7607 sub IsJSBuiltin
7608 {
7609     my ($interface, $object) = @_;
7610 
7611     return 0 if $object-&gt;extendedAttributes-&gt;{Custom};
7612     return 0 if $object-&gt;extendedAttributes-&gt;{CustomGetter};
7613     return 0 if $object-&gt;extendedAttributes-&gt;{CustomSetter};
7614 
7615     return 1 if $object-&gt;extendedAttributes-&gt;{JSBuiltin};
7616     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7617 
7618     return 0;
7619 }
7620 
7621 sub IsJSBuiltinConstructor
7622 {
7623     my ($interface) = @_;
7624 
7625     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
7626     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltin};
7627     return 1 if $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor};
7628     return 0;
7629 }
7630 
7631 sub GetJSBuiltinFunctionName
7632 {
7633     my ($className, $operation) = @_;
7634 
7635     my $scopeName = $operation-&gt;extendedAttributes-&gt;{ImplementedBy};
7636     $scopeName = substr $className, 2 unless $scopeName;
7637     return GetJSBuiltinFunctionNameFromString($scopeName, $operation-&gt;name);
7638 }
7639 
7640 sub GetJSBuiltinFunctionNameFromString
7641 {
7642     my ($scopeName, $functionName) = @_;
7643 
7644     return $codeGenerator-&gt;WK_lcfirst($scopeName) . $codeGenerator-&gt;WK_ucfirst($functionName) . &quot;CodeGenerator&quot;;
7645 }
7646 
7647 sub GetJSBuiltinScopeName
7648 {
7649     my ($interface, $object) = @_;
7650     return $object-&gt;extendedAttributes-&gt;{ImplementedBy} || $interface-&gt;type-&gt;name;
7651 }
7652 
7653 sub AddJSBuiltinIncludesIfNeeded()
7654 {
7655     my $interface = shift;
7656 
7657     if ($interface-&gt;extendedAttributes-&gt;{JSBuiltin} || $interface-&gt;extendedAttributes-&gt;{JSBuiltinConstructor}) {
7658         AddToImplIncludes($interface-&gt;type-&gt;name . &quot;Builtins.h&quot;);
7659         return;
7660     }
7661 
7662     foreach my $operation (@{$interface-&gt;operations}) {
7663         AddToImplIncludes(GetJSBuiltinScopeName($interface, $operation) . &quot;Builtins.h&quot;, $operation-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $operation);
7664     }
7665 
7666     foreach my $attribute (@{$interface-&gt;attributes}) {
7667         AddToImplIncludes(GetJSBuiltinScopeName($interface, $attribute) . &quot;Builtins.h&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}) if IsJSBuiltin($interface, $attribute);
7668     }
7669 }
7670 
7671 sub GenerateCallTracer()
7672 {
7673     my ($outputArray, $callTracingCallback, $name, $arguments, $indent) = @_;
7674 
7675     AddToImplIncludes(&quot;CallTracer.h&quot;);
7676 
7677     push(@$outputArray, $indent . &quot;if (UNLIKELY(impl.callTracingActive()))\n&quot;);
7678     push(@$outputArray, $indent . &quot;    CallTracer::&quot; . $callTracingCallback . &quot;(impl, \&quot;&quot; . $name . &quot;\&quot;_s&quot;);
7679     if (scalar(@$arguments)) {
7680         push(@$outputArray, &quot;, { &quot; . join(&quot;, &quot;, @$arguments) . &quot; }&quot;);
7681     }
7682     push(@$outputArray, &quot;);\n&quot;);
7683 }
7684 
7685 sub GenerateCustomElementReactionsStackIfNeeded
7686 {
7687     my ($outputArray, $context, $stateVariable) = @_;
7688 
7689     my $CEReactions = $context-&gt;extendedAttributes-&gt;{CEReactions};
7690 
7691     return if !$CEReactions;
7692 
7693     AddToImplIncludes(&quot;CustomElementReactionQueue.h&quot;);
7694 
7695     if ($CEReactions eq &quot;NotNeeded&quot;) {
7696         push(@$outputArray, &quot;    CustomElementReactionDisallowedScope customElementReactionDisallowedScope;\n&quot;);
7697     } else {
7698         push(@$outputArray, &quot;    CustomElementReactionStack customElementReactionStack($stateVariable);\n&quot;);
7699     }
7700 }
7701 
7702 1;
    </pre>
  </body>
</html>
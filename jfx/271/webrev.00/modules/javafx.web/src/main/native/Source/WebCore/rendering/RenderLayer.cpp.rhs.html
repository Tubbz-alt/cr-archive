<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2019 Adobe. All rights reserved.
   4  *
   5  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   6  *
   7  * Other contributors:
   8  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   9  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
  10  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  11  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  12  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  13  *   Josh Soref &lt;timeless@mac.com&gt;
  14  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Lesser General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2.1 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24  * Lesser General Public License for more details.
  25  *
  26  * You should have received a copy of the GNU Lesser General Public
  27  * License along with this library; if not, write to the Free Software
  28  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  29  *
  30  * Alternatively, the contents of this file may be used under the terms
  31  * of either the Mozilla Public License Version 1.1, found at
  32  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  33  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  34  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  35  * applicable instead of those above.  If you wish to allow use of your
  36  * version of this file only under the terms of one of those two
  37  * licenses (the MPL or the GPL) and not to allow others to use your
  38  * version of this file under the LGPL, indicate your decision by
  39  * deletingthe provisions above and replace them with the notice and
  40  * other provisions required by the MPL or the GPL, as the case may be.
  41  * If you do not delete the provisions above, a recipient may use your
  42  * version of this file under any of the LGPL, the MPL or the GPL.
  43  */
  44 
  45 #include &quot;config.h&quot;
  46 #include &quot;RenderLayer.h&quot;
  47 
  48 #include &quot;BoxShape.h&quot;
  49 #include &quot;CSSAnimationController.h&quot;
  50 #include &quot;CSSFilter.h&quot;
  51 #include &quot;CSSPropertyNames.h&quot;
  52 #include &quot;Chrome.h&quot;
  53 #include &quot;DebugPageOverlays.h&quot;
  54 #include &quot;DeprecatedGlobalSettings.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentMarkerController.h&quot;
  57 #include &quot;DocumentTimeline.h&quot;
  58 #include &quot;Editor.h&quot;
  59 #include &quot;Element.h&quot;
  60 #include &quot;EventHandler.h&quot;
  61 #include &quot;FEColorMatrix.h&quot;
  62 #include &quot;FEMerge.h&quot;
  63 #include &quot;FloatConversion.h&quot;
  64 #include &quot;FloatPoint3D.h&quot;
  65 #include &quot;FloatRect.h&quot;
  66 #include &quot;FloatRoundedRect.h&quot;
  67 #include &quot;FocusController.h&quot;
  68 #include &quot;Frame.h&quot;
  69 #include &quot;FrameLoader.h&quot;
  70 #include &quot;FrameLoaderClient.h&quot;
  71 #include &quot;FrameSelection.h&quot;
  72 #include &quot;FrameTree.h&quot;
  73 #include &quot;FrameView.h&quot;
  74 #include &quot;Gradient.h&quot;
  75 #include &quot;GraphicsContext.h&quot;
  76 #include &quot;HTMLFormControlElement.h&quot;
  77 #include &quot;HTMLFrameElement.h&quot;
  78 #include &quot;HTMLFrameOwnerElement.h&quot;
  79 #include &quot;HTMLIFrameElement.h&quot;
  80 #include &quot;HTMLNames.h&quot;
  81 #include &quot;HTMLParserIdioms.h&quot;
  82 #include &quot;HitTestRequest.h&quot;
  83 #include &quot;HitTestResult.h&quot;
  84 #include &quot;HitTestingTransformState.h&quot;
  85 #include &quot;Logging.h&quot;
  86 #include &quot;OverflowEvent.h&quot;
  87 #include &quot;OverlapTestRequestClient.h&quot;
  88 #include &quot;Page.h&quot;
  89 #include &quot;PlatformMouseEvent.h&quot;
  90 #include &quot;RenderFlexibleBox.h&quot;
  91 #include &quot;RenderFragmentContainer.h&quot;
  92 #include &quot;RenderFragmentedFlow.h&quot;
  93 #include &quot;RenderGeometryMap.h&quot;
  94 #include &quot;RenderImage.h&quot;
  95 #include &quot;RenderInline.h&quot;
  96 #include &quot;RenderIterator.h&quot;
  97 #include &quot;RenderLayerBacking.h&quot;
  98 #include &quot;RenderLayerCompositor.h&quot;
  99 #include &quot;RenderLayerFilters.h&quot;
 100 #include &quot;RenderMarquee.h&quot;
 101 #include &quot;RenderMultiColumnFlow.h&quot;
 102 #include &quot;RenderReplica.h&quot;
 103 #include &quot;RenderSVGResourceClipper.h&quot;
 104 #include &quot;RenderSVGRoot.h&quot;
 105 #include &quot;RenderScrollbar.h&quot;
 106 #include &quot;RenderScrollbarPart.h&quot;
 107 #include &quot;RenderTableCell.h&quot;
 108 #include &quot;RenderTableRow.h&quot;
 109 #include &quot;RenderText.h&quot;
 110 #include &quot;RenderTheme.h&quot;
 111 #include &quot;RenderTreeAsText.h&quot;
 112 #include &quot;RenderView.h&quot;
 113 #include &quot;RuntimeEnabledFeatures.h&quot;
 114 #include &quot;SVGNames.h&quot;
 115 #include &quot;ScaleTransformOperation.h&quot;
 116 #include &quot;ScriptDisallowedScope.h&quot;
 117 #include &quot;ScrollAnimator.h&quot;
 118 #include &quot;Scrollbar.h&quot;
 119 #include &quot;ScrollbarTheme.h&quot;
 120 #include &quot;ScrollingCoordinator.h&quot;
 121 #include &quot;Settings.h&quot;
 122 #include &quot;ShadowRoot.h&quot;
 123 #include &quot;SourceGraphic.h&quot;
 124 #include &quot;StyleProperties.h&quot;
 125 #include &quot;StyleResolver.h&quot;
 126 #include &quot;TransformationMatrix.h&quot;
 127 #include &quot;TranslateTransformOperation.h&quot;
 128 #include &quot;WheelEventTestMonitor.h&quot;
 129 #include &lt;stdio.h&gt;
 130 #include &lt;wtf/MonotonicTime.h&gt;
 131 #include &lt;wtf/StdLibExtras.h&gt;
 132 #include &lt;wtf/text/CString.h&gt;
 133 #include &lt;wtf/text/TextStream.h&gt;
 134 
 135 #if ENABLE(CSS_SCROLL_SNAP)
 136 #include &quot;AxisScrollSnapOffsets.h&quot;
 137 #endif
 138 
 139 #define MIN_INTERSECT_FOR_REVEAL 32
 140 
 141 namespace WebCore {
 142 
 143 using namespace HTMLNames;
 144 
 145 class ClipRects : public RefCounted&lt;ClipRects&gt; {
 146     WTF_MAKE_FAST_ALLOCATED;
 147 public:
 148     static Ref&lt;ClipRects&gt; create()
 149     {
 150         return adoptRef(*new ClipRects);
 151     }
 152 
 153     static Ref&lt;ClipRects&gt; create(const ClipRects&amp; other)
 154     {
 155         return adoptRef(*new ClipRects(other));
 156     }
 157 
 158     void reset()
 159     {
 160         m_overflowClipRect.reset();
 161         m_fixedClipRect.reset();
 162         m_posClipRect.reset();
 163         m_fixed = false;
 164     }
 165 
 166     const ClipRect&amp; overflowClipRect() const { return m_overflowClipRect; }
 167     void setOverflowClipRect(const ClipRect&amp; clipRect) { m_overflowClipRect = clipRect; }
 168 
 169     const ClipRect&amp; fixedClipRect() const { return m_fixedClipRect; }
 170     void setFixedClipRect(const ClipRect&amp; clipRect) { m_fixedClipRect = clipRect; }
 171 
 172     const ClipRect&amp; posClipRect() const { return m_posClipRect; }
 173     void setPosClipRect(const ClipRect&amp; clipRect) { m_posClipRect = clipRect; }
 174 
 175     bool fixed() const { return m_fixed; }
 176     void setFixed(bool fixed) { m_fixed = fixed; }
 177 
 178     bool operator==(const ClipRects&amp; other) const
 179     {
 180         return m_overflowClipRect == other.overflowClipRect()
 181             &amp;&amp; m_fixedClipRect == other.fixedClipRect()
 182             &amp;&amp; m_posClipRect == other.posClipRect()
 183             &amp;&amp; m_fixed == other.fixed();
 184     }
 185 
 186     ClipRects&amp; operator=(const ClipRects&amp; other)
 187     {
 188         m_overflowClipRect = other.overflowClipRect();
 189         m_fixedClipRect = other.fixedClipRect();
 190         m_posClipRect = other.posClipRect();
 191         m_fixed = other.fixed();
 192         return *this;
 193     }
 194 
 195 private:
 196     ClipRects() = default;
 197 
 198     ClipRects(const LayoutRect&amp; clipRect)
 199         : m_overflowClipRect(clipRect)
 200         , m_fixedClipRect(clipRect)
 201         , m_posClipRect(clipRect)
 202     {
 203     }
 204 
 205     ClipRects(const ClipRects&amp; other)
 206         : RefCounted()
 207         , m_fixed(other.fixed())
 208         , m_overflowClipRect(other.overflowClipRect())
 209         , m_fixedClipRect(other.fixedClipRect())
 210         , m_posClipRect(other.posClipRect())
 211     {
 212     }
 213 
 214     bool m_fixed { false };
 215     ClipRect m_overflowClipRect;
 216     ClipRect m_fixedClipRect;
 217     ClipRect m_posClipRect;
 218 };
 219 
 220 class ClipRectsCache {
 221     WTF_MAKE_FAST_ALLOCATED;
 222 public:
 223     ClipRectsCache()
 224     {
 225 #if ASSERT_ENABLED
 226         for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
 227             m_clipRectsRoot[i] = 0;
 228             m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
 229         }
 230 #endif
 231     }
 232 
 233     ClipRects* getClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 234     {
 235         return m_clipRects[getIndex(clipRectsType, respectOverflow)].get();
 236     }
 237 
 238     void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
 239     {
 240         m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
 241     }
 242 
 243 #if ASSERT_ENABLED
 244     const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
 245     OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
 246 #endif
 247 
 248 private:
 249     unsigned getIndex(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 250     {
 251         unsigned index = static_cast&lt;unsigned&gt;(clipRectsType);
 252         if (respectOverflow == RespectOverflowClip)
 253             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 254         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 255         return index;
 256     }
 257 
 258     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 259 };
 260 
 261 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 262 {
 263 #if !ENABLE(3D_TRANSFORMS)
 264     UNUSED_PARAM(has3DRendering);
 265     matrix.makeAffine();
 266 #else
 267     if (!has3DRendering)
 268         matrix.makeAffine();
 269 #endif
 270 }
 271 
 272 #if !LOG_DISABLED
 273 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)
 274 {
 275     TextStream::GroupScope scope(ts);
 276     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;
 277     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;
 278     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;
 279     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;
 280 
 281     return ts;
 282 }
 283 
 284 #endif
 285 
 286 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);
 287 
 288 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 289     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 290     , m_forcedStackingContext(rendererLayerModelObject.isMedia())
 291     , m_isNormalFlowOnly(false)
 292     , m_isCSSStackingContext(false)
 293     , m_isOpportunisticStackingContext(false)
 294     , m_zOrderListsDirty(false)
 295     , m_normalFlowListDirty(true)
 296     , m_hadNegativeZOrderList(false)
 297     , m_inResizeMode(false)
 298     , m_scrollDimensionsDirty(true)
 299     , m_hasSelfPaintingLayerDescendant(false)
 300     , m_hasSelfPaintingLayerDescendantDirty(false)
 301     , m_usedTransparency(false)
 302     , m_paintingInsideReflection(false)
 303     , m_inOverflowRelayout(false)
 304     , m_repaintStatus(NeedsNormalRepaint)
 305     , m_visibleContentStatusDirty(true)
 306     , m_hasVisibleContent(false)
 307     , m_visibleDescendantStatusDirty(false)
 308     , m_hasVisibleDescendant(false)
 309     , m_registeredScrollableArea(false)
 310     , m_isFixedIntersectingViewport(false)
 311     , m_behavesAsFixed(false)
 312     , m_3DTransformedDescendantStatusDirty(true)
 313     , m_has3DTransformedDescendant(false)
 314     , m_hasCompositingDescendant(false)
 315     , m_hasCompositedScrollingAncestor(false)
 316     , m_hasCompositedScrollableOverflow(false)
 317     , m_hasTransformedAncestor(false)
 318     , m_has3DTransformedAncestor(false)
 319     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 320     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 321 #if PLATFORM(IOS_FAMILY)
 322 #if ENABLE(IOS_TOUCH_EVENTS)
 323     , m_registeredAsTouchEventListenerForScrolling(false)
 324 #endif
 325     , m_adjustForIOSCaretWhenScrolling(false)
 326 #endif
 327     , m_requiresScrollPositionReconciliation(false)
 328     , m_containsDirtyOverlayScrollbars(false)
 329     , m_updatingMarqueePosition(false)
 330 #if ASSERT_ENABLED
 331     , m_layerListMutationAllowed(true)
 332 #endif
 333 #if ENABLE(CSS_COMPOSITING)
 334     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 335     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 336     , m_hasNotIsolatedBlendingDescendants(false)
 337     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 338 #endif
 339     , m_renderer(rendererLayerModelObject)
 340 {
 341     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
 342     setIsCSSStackingContext(shouldBeCSSStackingContext());
 343 
 344     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 345 
 346     if (!renderer().firstChild()) {
 347         m_visibleContentStatusDirty = false;
 348         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 349     }
 350 
 351     if (Element* element = renderer().element()) {
 352         // We save and restore only the scrollOffset as the other scroll values are recalculated.
 353         m_scrollPosition = element-&gt;savedLayerScrollPosition();
 354         if (!m_scrollPosition.isZero())
 355             scrollAnimator().setCurrentPosition(m_scrollPosition);
 356         element-&gt;setSavedLayerScrollPosition(IntPoint());
 357     }
 358 }
 359 
 360 RenderLayer::~RenderLayer()
 361 {
 362     if (inResizeMode())
 363         renderer().frame().eventHandler().resizeLayerDestroyed();
 364 
 365     ASSERT(m_registeredScrollableArea == renderer().view().frameView().containsScrollableArea(this));
 366 
 367     if (m_registeredScrollableArea)
 368         renderer().view().frameView().removeScrollableArea(this);
 369 
 370 #if ENABLE(IOS_TOUCH_EVENTS)
 371     unregisterAsTouchEventListenerForScrolling();
 372 #endif
 373     if (Element* element = renderer().element())
 374         element-&gt;setSavedLayerScrollPosition(m_scrollPosition);
 375 
 376     destroyScrollbar(HorizontalScrollbar);
 377     destroyScrollbar(VerticalScrollbar);
 378 
 379     if (auto* scrollingCoordinator = renderer().page().scrollingCoordinator())
 380         scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 381 
 382     if (m_reflection)
 383         removeReflection();
 384 
 385     clearScrollCorner();
 386     clearResizer();
 387 
 388     clearLayerFilters();
 389 
 390     if (paintsIntoProvidedBacking()) {
 391         auto* backingProviderLayer = this-&gt;backingProviderLayer();
 392         if (backingProviderLayer-&gt;backing())
 393             backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);
 394     }
 395 
 396     // Child layers will be deleted by their corresponding render objects, so
 397     // we don&#39;t need to delete them ourselves.
 398 
 399     clearBacking(true);
 400 
 401     // Layer and all its children should be removed from the tree before destruction.
 402     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !parent());
 403     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !firstChild());
 404 }
 405 
 406 void RenderLayer::addChild(RenderLayer&amp; child, RenderLayer* beforeChild)
 407 {
 408     RenderLayer* prevSibling = beforeChild ? beforeChild-&gt;previousSibling() : lastChild();
 409     if (prevSibling) {
 410         child.setPreviousSibling(prevSibling);
 411         prevSibling-&gt;setNextSibling(&amp;child);
 412         ASSERT(prevSibling != &amp;child);
 413     } else
 414         setFirstChild(&amp;child);
 415 
 416     if (beforeChild) {
 417         beforeChild-&gt;setPreviousSibling(&amp;child);
 418         child.setNextSibling(beforeChild);
 419         ASSERT(beforeChild != &amp;child);
 420     } else
 421         setLastChild(&amp;child);
 422 
 423     child.setParent(this);
 424 
 425     dirtyPaintOrderListsOnChildChange(child);
 426 
 427     child.updateDescendantDependentFlags();
 428     if (child.m_hasVisibleContent || child.m_hasVisibleDescendant)
 429         setAncestorChainHasVisibleDescendant();
 430 
 431     if (child.isSelfPaintingLayer() || child.hasSelfPaintingLayerDescendant())
 432         setAncestorChainHasSelfPaintingLayerDescendant();
 433 
 434     if (compositor().hasContentCompositingLayers())
 435         setDescendantsNeedCompositingRequirementsTraversal();
 436 
 437     if (child.hasDescendantNeedingCompositingRequirementsTraversal() || child.needsCompositingRequirementsTraversal())
 438         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 439 
 440     if (child.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || child.needsUpdateBackingOrHierarchyTraversal())
 441         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 442 
 443 #if ENABLE(CSS_COMPOSITING)
 444     if (child.hasBlendMode() || (child.hasNotIsolatedBlendingDescendants() &amp;&amp; !child.isolatesBlending()))
 445         updateAncestorChainHasBlendingDescendants(); // Why not just dirty?
 446 #endif
 447 
 448     compositor().layerWasAdded(*this, child);
 449 }
 450 
 451 void RenderLayer::removeChild(RenderLayer&amp; oldChild)
 452 {
 453     if (!renderer().renderTreeBeingDestroyed())
 454         compositor().layerWillBeRemoved(*this, oldChild);
 455 
 456     // remove the child
 457     if (oldChild.previousSibling())
 458         oldChild.previousSibling()-&gt;setNextSibling(oldChild.nextSibling());
 459     if (oldChild.nextSibling())
 460         oldChild.nextSibling()-&gt;setPreviousSibling(oldChild.previousSibling());
 461 
 462     if (m_first == &amp;oldChild)
 463         m_first = oldChild.nextSibling();
 464     if (m_last == &amp;oldChild)
 465         m_last = oldChild.previousSibling();
 466 
 467     dirtyPaintOrderListsOnChildChange(oldChild);
 468 
 469     oldChild.setPreviousSibling(nullptr);
 470     oldChild.setNextSibling(nullptr);
 471     oldChild.setParent(nullptr);
 472 
 473     oldChild.updateDescendantDependentFlags();
 474     if (oldChild.m_hasVisibleContent || oldChild.m_hasVisibleDescendant)
 475         dirtyAncestorChainVisibleDescendantStatus();
 476 
 477     if (oldChild.isSelfPaintingLayer() || oldChild.hasSelfPaintingLayerDescendant())
 478         dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 479 
 480     if (compositor().hasContentCompositingLayers())
 481         setDescendantsNeedCompositingRequirementsTraversal();
 482 
 483 #if ENABLE(CSS_COMPOSITING)
 484     if (oldChild.hasBlendMode() || (oldChild.hasNotIsolatedBlendingDescendants() &amp;&amp; !oldChild.isolatesBlending()))
 485         dirtyAncestorChainHasBlendingDescendants();
 486 #endif
 487 }
 488 
 489 void RenderLayer::dirtyPaintOrderListsOnChildChange(RenderLayer&amp; child)
 490 {
 491     if (child.isNormalFlowOnly())
 492         dirtyNormalFlowList();
 493 
 494     if (!child.isNormalFlowOnly() || child.firstChild()) {
 495         // Dirty the z-order list in which we are contained. The stackingContext() can be null in the
 496         // case where we&#39;re building up generated content layers. This is ok, since the lists will start
 497         // off dirty in that case anyway.
 498         child.dirtyStackingContextZOrderLists();
 499     }
 500 }
 501 
 502 void RenderLayer::insertOnlyThisLayer(LayerChangeTiming timing)
 503 {
 504     if (!m_parent &amp;&amp; renderer().parent()) {
 505         // We need to connect ourselves when our renderer() has a parent.
 506         // Find our enclosingLayer and add ourselves.
 507         RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
 508         ASSERT(parentLayer);
 509         RenderLayer* beforeChild = parentLayer-&gt;reflectionLayer() != this ? renderer().parent()-&gt;findNextLayer(parentLayer, &amp;renderer()) : nullptr;
 510         parentLayer-&gt;addChild(*this, beforeChild);
 511     }
 512 
 513     // Remove all descendant layers from the hierarchy and add them to the new position.
 514     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
 515         child.moveLayers(m_parent, this);
 516 
 517     if (parent()) {
 518         if (timing == LayerChangeTiming::StyleChange)
 519             renderer().view().layerChildrenChangedDuringStyleChange(*parent());
 520     }
 521 
 522     // Clear out all the clip rects.
 523     clearClipRectsIncludingDescendants();
 524 }
 525 
 526 void RenderLayer::removeOnlyThisLayer(LayerChangeTiming timing)
 527 {
 528     if (!m_parent)
 529         return;
 530 
 531     if (timing == LayerChangeTiming::StyleChange)
 532         renderer().view().layerChildrenChangedDuringStyleChange(*parent());
 533 
 534     // Mark that we are about to lose our layer. This makes render tree
 535     // walks ignore this layer while we&#39;re removing it.
 536     renderer().setHasLayer(false);
 537 
 538     compositor().layerWillBeRemoved(*m_parent, *this);
 539 
 540     // Dirty the clip rects.
 541     clearClipRectsIncludingDescendants();
 542 
 543     RenderLayer* nextSib = nextSibling();
 544 
 545     // Remove the child reflection layer before moving other child layers.
 546     // The reflection layer should not be moved to the parent.
 547     if (reflection())
 548         removeChild(*reflectionLayer());
 549 
 550     // Now walk our kids and reattach them to our parent.
 551     RenderLayer* current = m_first;
 552     while (current) {
 553         RenderLayer* next = current-&gt;nextSibling();
 554         removeChild(*current);
 555         m_parent-&gt;addChild(*current, nextSib);
 556         current-&gt;setRepaintStatus(NeedsFullRepaint);
 557         current = next;
 558     }
 559 
 560     // Remove us from the parent.
 561     m_parent-&gt;removeChild(*this);
 562     renderer().destroyLayer();
 563 }
 564 
 565 static bool canCreateStackingContext(const RenderLayer&amp; layer)
 566 {
 567     auto&amp; renderer = layer.renderer();
 568     return renderer.hasTransformRelatedProperty()
 569         || renderer.hasClipPath()
 570         || renderer.hasFilter()
 571         || renderer.hasMask()
 572         || renderer.hasBackdropFilter()
 573 #if ENABLE(CSS_COMPOSITING)
 574         || renderer.hasBlendMode()
 575 #endif
 576         || renderer.isTransparent()
 577         || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
 578         || renderer.hasReflection()
 579         || renderer.style().hasIsolation()
 580         || !renderer.style().hasAutoUsedZIndex()
 581         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 582 }
 583 
 584 bool RenderLayer::shouldBeNormalFlowOnly() const
 585 {
 586     if (canCreateStackingContext(*this))
 587         return false;
 588 
 589     return renderer().hasOverflowClip()
 590         || renderer().isCanvas()
 591         || renderer().isVideo()
 592         || renderer().isEmbeddedObject()
 593         || renderer().isRenderIFrame()
 594         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 595         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 596         || renderer().isInFlowRenderFragmentedFlow();
 597 }
 598 
 599 bool RenderLayer::shouldBeCSSStackingContext() const
 600 {
 601     return !renderer().style().hasAutoUsedZIndex() || isRenderViewLayer();
 602 }
 603 
 604 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 605 {
 606     if (isNormalFlowOnly == m_isNormalFlowOnly)
 607         return false;
 608 
 609     m_isNormalFlowOnly = isNormalFlowOnly;
 610 
 611     if (auto* p = parent())
 612         p-&gt;dirtyNormalFlowList();
 613     dirtyStackingContextZOrderLists();
 614     return true;
 615 }
 616 
 617 void RenderLayer::isStackingContextChanged()
 618 {
 619     dirtyStackingContextZOrderLists();
 620     if (isStackingContext())
 621         dirtyZOrderLists();
 622     else
 623         clearZOrderLists();
 624 }
 625 
 626 bool RenderLayer::setIsOpportunisticStackingContext(bool isStacking)
 627 {
 628     bool wasStacking = isStackingContext();
 629     m_isOpportunisticStackingContext = isStacking;
 630     if (wasStacking == isStackingContext())
 631         return false;
 632 
 633     isStackingContextChanged();
 634     return true;
 635 }
 636 
 637 bool RenderLayer::setIsCSSStackingContext(bool isCSSStackingContext)
 638 {
 639     bool wasStacking = isStackingContext();
 640     m_isCSSStackingContext = isCSSStackingContext;
 641     if (wasStacking == isStackingContext())
 642         return false;
 643 
 644     isStackingContextChanged();
 645     return true;
 646 }
 647 
 648 void RenderLayer::setParent(RenderLayer* parent)
 649 {
 650     if (parent == m_parent)
 651         return;
 652 
 653     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 654         compositor().layerWillBeRemoved(*m_parent, *this);
 655 
 656     m_parent = parent;
 657 
 658     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 659         compositor().layerWasAdded(*m_parent, *this);
 660 }
 661 
 662 RenderLayer* RenderLayer::stackingContext() const
 663 {
 664     auto* layer = parent();
 665     while (layer &amp;&amp; !layer-&gt;isStackingContext())
 666         layer = layer-&gt;parent();
 667 
 668     ASSERT(!layer || layer-&gt;isStackingContext());
 669     return layer;
 670 }
 671 
 672 void RenderLayer::dirtyZOrderLists()
 673 {
 674     ASSERT(layerListMutationAllowed());
 675     ASSERT(isStackingContext());
 676 
 677     if (m_posZOrderList)
 678         m_posZOrderList-&gt;clear();
 679     if (m_negZOrderList)
 680         m_negZOrderList-&gt;clear();
 681     m_zOrderListsDirty = true;
 682 
 683     // FIXME: Ideally, we&#39;d only dirty if the lists changed.
 684     if (hasCompositingDescendant())
 685         setNeedsCompositingPaintOrderChildrenUpdate();
 686 }
 687 
 688 void RenderLayer::dirtyStackingContextZOrderLists()
 689 {
 690     if (auto* sc = stackingContext())
 691         sc-&gt;dirtyZOrderLists();
 692 }
 693 
 694 void RenderLayer::dirtyNormalFlowList()
 695 {
 696     ASSERT(layerListMutationAllowed());
 697 
 698     if (m_normalFlowList)
 699         m_normalFlowList-&gt;clear();
 700     m_normalFlowListDirty = true;
 701 
 702     if (hasCompositingDescendant())
 703         setNeedsCompositingPaintOrderChildrenUpdate();
 704 }
 705 
 706 void RenderLayer::updateNormalFlowList()
 707 {
 708     if (!m_normalFlowListDirty)
 709         return;
 710 
 711     ASSERT(layerListMutationAllowed());
 712 
 713     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 714         // Ignore non-overflow layers and reflections.
 715         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 716             if (!m_normalFlowList)
 717                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 718             m_normalFlowList-&gt;append(child);
 719         }
 720     }
 721 
 722     m_normalFlowListDirty = false;
 723 }
 724 
 725 void RenderLayer::rebuildZOrderLists()
 726 {
 727     ASSERT(layerListMutationAllowed());
 728     ASSERT(isDirtyStackingContext());
 729 
 730     OptionSet&lt;Compositing&gt; childDirtyFlags;
 731     rebuildZOrderLists(m_posZOrderList, m_negZOrderList, childDirtyFlags);
 732     m_zOrderListsDirty = false;
 733 
 734     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 735     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 736     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 737     // lists on dirtying so we don&#39;t know the old state.
 738     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 739         m_hadNegativeZOrderList = hasNegativeZOrderList;
 740         if (isComposited())
 741             setNeedsCompositingConfigurationUpdate();
 742     }
 743 
 744     // Building lists may have added layers with dirty flags, so make sure we propagate dirty bits up the tree.
 745     if (m_compositingDirtyBits.containsAll({ Compositing::DescendantsNeedRequirementsTraversal, Compositing::DescendantsNeedBackingAndHierarchyTraversal }))
 746         return;
 747 
 748     if (childDirtyFlags.containsAny(computeCompositingRequirementsFlags()))
 749         setDescendantsNeedCompositingRequirementsTraversal();
 750 
 751     if (childDirtyFlags.containsAny(updateBackingOrHierarchyFlags()))
 752         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
 753 }
 754 
 755 void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)
 756 {
 757     bool includeHiddenLayers = compositor().usesCompositing();
 758     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 759         if (!isReflectionLayer(*child))
 760             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList, accumulatedDirtyFlags);
 761     }
 762 
 763     auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
 764         return first-&gt;zIndex() &lt; second-&gt;zIndex();
 765     };
 766 
 767     // Sort the two lists.
 768     if (posZOrderList)
 769         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 770 
 771     if (negZOrderList)
 772         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 773 }
 774 
 775 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)
 776 {
 777     updateDescendantDependentFlags();
 778 
 779     bool isStacking = isStackingContext();
 780     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 781     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 782     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 783         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 784         if (!layerList)
 785             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 786         layerList-&gt;append(this);
 787         accumulatedDirtyFlags.add(m_compositingDirtyBits);
 788     }
 789 
 790     // Recur into our children to collect more layers, but only if we don&#39;t establish
 791     // a stacking context/container.
 792     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 793         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 794             // Ignore reflections.
 795             if (!isReflectionLayer(*child))
 796                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList, accumulatedDirtyFlags);
 797         }
 798     }
 799 }
 800 
 801 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 802 {
 803     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 804         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 805             break;
 806         layer-&gt;m_compositingDirtyBits.add(flag);
 807     }
 808 }
 809 
 810 void RenderLayer::updateLayerListsIfNeeded()
 811 {
 812     updateZOrderLists();
 813     updateNormalFlowList();
 814 
 815     if (RenderLayer* reflectionLayer = this-&gt;reflectionLayer()) {
 816         reflectionLayer-&gt;updateZOrderLists();
 817         reflectionLayer-&gt;updateNormalFlowList();
 818     }
 819 }
 820 
 821 String RenderLayer::name() const
 822 {
 823     StringBuilder name;
 824 
 825     if (Element* element = renderer().element()) {
 826         name.append(&quot; &lt;&quot;);
 827         name.append(element-&gt;tagName().convertToLowercaseWithoutLocale());
 828         name.append(&#39;&gt;&#39;);
 829 
 830         if (element-&gt;hasID()) {
 831             name.appendLiteral(&quot; id=\&#39;&quot;);
 832             name.append(element-&gt;getIdAttribute());
 833             name.append(&#39;\&#39;&#39;);
 834         }
 835 
 836         if (element-&gt;hasClass()) {
 837             name.appendLiteral(&quot; class=\&#39;&quot;);
 838             size_t classNamesToDump = element-&gt;classNames().size();
 839             const size_t maxNumClassNames = 7;
 840             bool addEllipsis = false;
 841             if (classNamesToDump &gt; maxNumClassNames) {
 842                 classNamesToDump = maxNumClassNames;
 843                 addEllipsis = true;
 844             }
 845 
 846             for (size_t i = 0; i &lt; classNamesToDump; ++i) {
 847                 if (i &gt; 0)
 848                     name.append(&#39; &#39;);
 849                 name.append(element-&gt;classNames()[i]);
 850             }
 851             if (addEllipsis)
 852                 name.append(&quot;...&quot;);
 853             name.append(&#39;\&#39;&#39;);
 854         }
 855     } else
 856         name.append(renderer().renderName());
 857 
 858     if (isReflection())
 859         name.appendLiteral(&quot; (reflection)&quot;);
 860 
 861     return name.toString();
 862 }
 863 
 864 RenderLayerCompositor&amp; RenderLayer::compositor() const
 865 {
 866     return renderer().view().compositor();
 867 }
 868 
 869 void RenderLayer::contentChanged(ContentChangeType changeType)
 870 {
 871     if (changeType == CanvasChanged || changeType == VideoChanged || changeType == FullScreenChanged || (isComposited() &amp;&amp; changeType == ImageChanged)) {
 872         setNeedsPostLayoutCompositingUpdate();
 873         setNeedsCompositingConfigurationUpdate();
 874     }
 875 
 876     if (auto* backing = this-&gt;backing())
 877         backing-&gt;contentChanged(changeType);
 878 }
 879 
 880 bool RenderLayer::canRender3DTransforms() const
 881 {
 882     return compositor().canRender3DTransforms();
 883 }
 884 
 885 bool RenderLayer::paintsWithFilters() const
 886 {
 887     if (!renderer().hasFilter())
 888         return false;
 889 
 890     if (!isComposited())
 891         return true;
 892 
 893     return !m_backing-&gt;canCompositeFilters();
 894 }
 895 
 896 bool RenderLayer::requiresFullLayerImageForFilters() const
 897 {
 898     if (!paintsWithFilters())
 899         return false;
 900 
 901     return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
 902 }
 903 
 904 OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; RenderLayer::flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer)
 905 {
 906     OptionSet&lt;UpdateLayerPositionsFlag&gt; flags = { CheckForRepaint };
 907 
 908     if (auto* parent = startingLayer.parent()) {
 909         if (parent-&gt;hasTransformedAncestor() || parent-&gt;transform())
 910             flags.add(SeenTransformedLayer);
 911 
 912         if (parent-&gt;has3DTransformedAncestor() || (parent-&gt;transform() &amp;&amp; !parent-&gt;transform()-&gt;isAffine()))
 913             flags.add(Seen3DTransformedLayer);
 914 
 915         if (parent-&gt;behavesAsFixed() || (parent-&gt;renderer().isFixedPositioned() &amp;&amp; !parent-&gt;hasTransformedAncestor()))
 916             flags.add(SeenFixedLayer);
 917 
 918         if (parent-&gt;hasCompositedScrollingAncestor() || parent-&gt;hasCompositedScrollableOverflow())
 919             flags.add(SeenCompositedScrollingLayer);
 920     }
 921 
 922     return flags;
 923 }
 924 
 925 void RenderLayer::updateLayerPositionsAfterStyleChange()
 926 {
 927     updateLayerPositions(nullptr, flagsForUpdateLayerPositions(*this));
 928 }
 929 
 930 void RenderLayer::updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint)
 931 {
 932     auto updateLayerPositionFlags = [&amp;](bool isRelayoutingSubtree, bool didFullRepaint) {
 933         auto flags = flagsForUpdateLayerPositions(*this);
 934         if (didFullRepaint) {
 935             flags.remove(RenderLayer::CheckForRepaint);
 936             flags.add(RenderLayer::NeedsFullRepaintInBacking);
 937         }
 938         if (isRelayoutingSubtree &amp;&amp; enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))
 939             flags.add(RenderLayer::UpdatePagination);
 940         return flags;
 941     };
 942 
 943     LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
 944     RenderGeometryMap geometryMap(UseTransforms);
 945     if (!isRenderViewLayer())
 946         geometryMap.pushMappingsToAncestor(parent(), nullptr);
 947 
 948     updateLayerPositions(&amp;geometryMap, updateLayerPositionFlags(isRelayoutingSubtree, didFullRepaint));
 949 }
 950 
 951 void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 952 {
 953     updateLayerPosition(&amp;flags);
 954     applyPostLayoutScrollPositionIfNeeded();
 955 
 956     if (geometryMap)
 957         geometryMap-&gt;pushMappingsToAncestor(this, parent());
 958 
 959     // Clear our cached clip rect information.
 960     clearClipRects();
 961 
 962     if (hasOverflowControls()) {
 963         LayoutSize offsetFromRoot;
 964         if (geometryMap)
 965             offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
 966         else {
 967             // FIXME: It looks suspicious to call convertToLayerCoords here
 968             // as canUseOffsetFromAncestor may be true for an ancestor layer.
 969             offsetFromRoot = offsetFromAncestor(root());
 970         }
 971         positionOverflowControls(roundedIntSize(offsetFromRoot));
 972     }
 973 
 974     updateDescendantDependentFlags();
 975 
 976     if (flags &amp; UpdatePagination)
 977         updatePagination();
 978     else
 979         m_enclosingPaginationLayer = nullptr;
 980 
 981     if (m_hasVisibleContent) {
 982         // FIXME: Paint offset cache does not work with RenderLayers as there is not a 1-to-1
 983         // mapping between them and the RenderObjects. It would be neat to enable
 984         // LayoutState outside the layout() phase and use it here.
 985         ASSERT(!renderer().view().frameView().layoutContext().isPaintOffsetCacheEnabled());
 986 
 987         RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
 988 
 989         auto hadRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 990         RepaintLayoutRects oldRects = hadRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 991         computeRepaintRects(repaintContainer, geometryMap);
 992 
 993         auto hasRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 994         RepaintLayoutRects newRects = hasRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 995         // FIXME: Should ASSERT that value calculated for m_outlineBox using the cached offset is the same
 996         // as the value not using the cached offset, but we can&#39;t due to https://bugs.webkit.org/show_bug.cgi?id=37048
 997         if ((flags &amp; CheckForRepaint) &amp;&amp; hasRepaintLayoutRects) {
 998             if (!renderer().view().printing()) {
 999                 if (m_repaintStatus &amp; NeedsFullRepaint) {
1000                     if (hadRepaintLayoutRects)
1001                         renderer().repaintUsingContainer(repaintContainer, oldRects.m_repaintRect);
1002                     if (!hadRepaintLayoutRects || newRects.m_repaintRect != oldRects.m_repaintRect)
1003                         renderer().repaintUsingContainer(repaintContainer, newRects.m_repaintRect);
1004                 } else if (shouldRepaintAfterLayout()) {
1005                     // FIXME: We will convert this to just take the old and new RepaintLayoutRects once
1006                     // we change other callers to use RepaintLayoutRects.
1007                     renderer().repaintAfterLayoutIfNeeded(repaintContainer, oldRects.m_repaintRect, oldRects.m_outlineBox, &amp;newRects.m_repaintRect, &amp;newRects.m_outlineBox);
1008                 }
1009             }
1010         }
1011     } else
1012         clearRepaintRects();
1013 
1014     m_repaintStatus = NeedsNormalRepaint;
1015     m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
1016     m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);
1017     m_behavesAsFixed = flags.contains(SeenFixedLayer);
1018     setHasCompositedScrollingAncestor(flags.contains(SeenCompositedScrollingLayer));
1019 
1020     // Update the reflection&#39;s position and size.
1021     if (m_reflection)
1022         m_reflection-&gt;layout();
1023 
1024     if (renderer().isInFlowRenderFragmentedFlow()) {
1025         updatePagination();
1026         flags.add(UpdatePagination);
1027     }
1028 
1029     if (transform()) {
1030         flags.add(SeenTransformedLayer);
1031         if (!transform()-&gt;isAffine())
1032             flags.add(Seen3DTransformedLayer);
1033     }
1034 
1035     // Fixed inside transform behaves like absolute (per spec).
1036     if (renderer().isFixedPositioned() &amp;&amp; !m_hasTransformedAncestor) {
1037         m_behavesAsFixed = true;
1038         flags.add(SeenFixedLayer);
1039     }
1040 
1041     if (hasCompositedScrollableOverflow())
1042         flags.add(SeenCompositedScrollingLayer);
1043 
1044     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1045         child-&gt;updateLayerPositions(geometryMap, flags);
1046 
1047     // With all our children positioned, now update our marquee if we need to.
1048     if (m_marquee) {
1049         // FIXME: would like to use SetForScope&lt;&gt; but it doesn&#39;t work with bitfields.
1050         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1051         m_updatingMarqueePosition = true;
1052         m_marquee-&gt;updateMarqueePosition();
1053         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1054     }
1055 
1056     if (renderer().isFixedPositioned() &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {
1057         bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
1058         if (intersectsViewport != m_isFixedIntersectingViewport) {
1059             m_isFixedIntersectingViewport = intersectsViewport;
1060             setNeedsPostLayoutCompositingUpdate();
1061         }
1062     }
1063 
1064     if (isComposited())
1065         backing()-&gt;updateAfterLayout(flags.contains(ContainingClippingLayerChangedSize), flags.contains(NeedsFullRepaintInBacking));
1066 
1067     if (geometryMap)
1068         geometryMap-&gt;popMappingsToAncestor(parent());
1069 
1070     renderer().document().markers().invalidateRectsForAllMarkers();
1071 }
1072 
1073 LayoutRect RenderLayer::repaintRectIncludingNonCompositingDescendants() const
1074 {
1075     LayoutRect repaintRect = renderer().repaintLayoutRects().m_repaintRect;
1076     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1077         // Don&#39;t include repaint rects for composited child layers; they will paint themselves and have a different origin.
1078         if (child-&gt;isComposited())
1079             continue;
1080 
1081         repaintRect.uniteIfNonZero(child-&gt;repaintRectIncludingNonCompositingDescendants());
1082     }
1083     return repaintRect;
1084 }
1085 
1086 void RenderLayer::setAncestorChainHasSelfPaintingLayerDescendant()
1087 {
1088     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1089         if (!layer-&gt;m_hasSelfPaintingLayerDescendantDirty &amp;&amp; layer-&gt;hasSelfPaintingLayerDescendant())
1090             break;
1091 
1092         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = false;
1093         layer-&gt;m_hasSelfPaintingLayerDescendant = true;
1094     }
1095 }
1096 
1097 void RenderLayer::dirtyAncestorChainHasSelfPaintingLayerDescendantStatus()
1098 {
1099     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1100         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = true;
1101         // If we have reached a self-painting layer, we know our parent should have a self-painting descendant
1102         // in this case, there is no need to dirty our ancestors further.
1103         if (layer-&gt;isSelfPaintingLayer()) {
1104             ASSERT(!parent() || parent()-&gt;m_hasSelfPaintingLayerDescendantDirty || parent()-&gt;hasSelfPaintingLayerDescendant());
1105             break;
1106         }
1107     }
1108 }
1109 
1110 void RenderLayer::computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap)
1111 {
1112     ASSERT(!m_visibleContentStatusDirty);
1113     renderer().computeRepaintLayoutRects(repaintContainer, geometryMap);
1114 }
1115 
1116 void RenderLayer::computeRepaintRectsIncludingDescendants()
1117 {
1118     // FIXME: computeRepaintRects() has to walk up the parent chain for every layer to compute the rects.
1119     // We should make this more efficient.
1120     // FIXME: it&#39;s wrong to call this when layout is not up-to-date, which we do.
1121     computeRepaintRects(renderer().containerForRepaint());
1122 
1123     for (RenderLayer* layer = firstChild(); layer; layer = layer-&gt;nextSibling())
1124         layer-&gt;computeRepaintRectsIncludingDescendants();
1125 }
1126 
1127 void RenderLayer::clearRepaintRects()
1128 {
1129     ASSERT(!m_visibleContentStatusDirty);
1130 
1131     renderer().clearRepaintLayoutRects();
1132 }
1133 
1134 void RenderLayer::updateLayerPositionsAfterDocumentScroll()
1135 {
1136     ASSERT(this == renderer().view().layer());
1137 
1138     LOG(Scrolling, &quot;RenderLayer::updateLayerPositionsAfterDocumentScroll&quot;);
1139 
1140     RenderGeometryMap geometryMap(UseTransforms);
1141     updateLayerPositionsAfterScroll(&amp;geometryMap);
1142 }
1143 
1144 void RenderLayer::updateLayerPositionsAfterOverflowScroll()
1145 {
1146     RenderGeometryMap geometryMap(UseTransforms);
1147     if (this != renderer().view().layer())
1148         geometryMap.pushMappingsToAncestor(parent(), nullptr);
1149 
1150     // FIXME: why is it OK to not check the ancestors of this layer in order to
1151     // initialize the HasSeenViewportConstrainedAncestor and HasSeenAncestorWithOverflowClip flags?
1152     updateLayerPositionsAfterScroll(&amp;geometryMap, IsOverflowScroll);
1153 }
1154 
1155 void RenderLayer::updateLayerPositionsAfterScroll(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; flags)
1156 {
1157     // FIXME: This shouldn&#39;t be needed, but there are some corner cases where
1158     // these flags are still dirty. Update so that the check below is valid.
1159     updateDescendantDependentFlags();
1160 
1161     // If we have no visible content and no visible descendants, there is no point recomputing
1162     // our rectangles as they will be empty. If our visibility changes, we are expected to
1163     // recompute all our positions anyway.
1164     if (!m_hasVisibleDescendant &amp;&amp; !m_hasVisibleContent)
1165         return;
1166 
1167     bool positionChanged = updateLayerPosition();
1168     if (positionChanged)
1169         flags.add(HasChangedAncestor);
1170 
1171     if (flags.containsAny({ HasChangedAncestor, HasSeenViewportConstrainedAncestor, IsOverflowScroll }))
1172         clearClipRects();
1173 
1174     if (renderer().style().hasViewportConstrainedPosition())
1175         flags.add(HasSeenViewportConstrainedAncestor);
1176 
1177     if (renderer().hasOverflowClip())
1178         flags.add(HasSeenAncestorWithOverflowClip);
1179 
1180     bool shouldComputeRepaintRects = (flags.contains(HasSeenViewportConstrainedAncestor) || flags.containsAll({ IsOverflowScroll, HasSeenAncestorWithOverflowClip })) &amp;&amp; isSelfPaintingLayer();
1181     bool isVisuallyEmpty = !isVisuallyNonEmpty();
1182     bool shouldPushAndPopMappings = geometryMap &amp;&amp; ((shouldComputeRepaintRects &amp;&amp; !isVisuallyEmpty) || firstChild());
1183     if (shouldPushAndPopMappings)
1184         geometryMap-&gt;pushMappingsToAncestor(this, parent());
1185 
1186     if (shouldComputeRepaintRects) {
1187         // When scrolling, we don&#39;t compute repaint rects for visually non-empty layers.
1188         if (isVisuallyEmpty)
1189             clearRepaintRects();
1190         else // FIXME: We could track the repaint container as we walk down the tree.
1191             computeRepaintRects(renderer().containerForRepaint(), geometryMap);
1192     } else if (!renderer().view().frameView().platformWidget()) {
1193         // When ScrollView&#39;s m_paintsEntireContents flag flips due to layer backing changes, the repaint area transitions from
1194         // visual to layout overflow. When this happens the cached repaint rects become invalid and they need to be recomputed (see webkit.org/b/188121).
1195         // Check that our cached rects are correct.
1196         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_repaintRect == renderer().clippedOverflowRectForRepaint(renderer().containerForRepaint()));
1197         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_outlineBox == renderer().outlineBoundsForRepaint(renderer().containerForRepaint()));
1198     }
1199 
1200     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1201         child-&gt;updateLayerPositionsAfterScroll(geometryMap, flags);
1202 
1203     // We don&#39;t update our reflection as scrolling is a translation which does not change the size()
1204     // of an object, thus RenderReplica will still repaint itself properly as the layer position was
1205     // updated above.
1206 
1207     if (m_marquee) {
1208         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1209         m_updatingMarqueePosition = true;
1210         m_marquee-&gt;updateMarqueePosition();
1211         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1212     }
1213 
1214     if (shouldPushAndPopMappings)
1215         geometryMap-&gt;popMappingsToAncestor(parent());
1216 
1217     renderer().document().markers().invalidateRectsForAllMarkers();
1218 }
1219 
1220 #if ENABLE(CSS_COMPOSITING)
1221 
1222 void RenderLayer::updateBlendMode()
1223 {
1224     bool hadBlendMode = static_cast&lt;BlendMode&gt;(m_blendMode) != BlendMode::Normal;
1225     if (parent() &amp;&amp; hadBlendMode != hasBlendMode()) {
1226         if (hasBlendMode())
1227             parent()-&gt;updateAncestorChainHasBlendingDescendants();
1228         else
1229             parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1230     }
1231 
1232     BlendMode newBlendMode = renderer().style().blendMode();
1233     if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
1234         m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
1235 }
1236 
1237 void RenderLayer::willRemoveChildWithBlendMode()
1238 {
1239     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1240 }
1241 
1242 void RenderLayer::updateAncestorChainHasBlendingDescendants()
1243 {
1244     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1245         if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
1246             break;
1247         layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
1248         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1249 
1250         layer-&gt;updateSelfPaintingLayer();
1251 
1252         if (layer-&gt;isCSSStackingContext())
1253             break;
1254     }
1255 }
1256 
1257 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1258 {
1259     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1260         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1261             break;
1262 
1263         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1264 
1265         if (layer-&gt;isCSSStackingContext())
1266             break;
1267     }
1268 }
1269 #endif
1270 
1271 static inline LayoutRect computeReferenceRectFromBox(const RenderBox&amp; box, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot)
1272 {
1273     LayoutRect referenceBox;
1274     switch (boxType) {
1275     case CSSBoxType::ContentBox:
1276     case CSSBoxType::FillBox:
1277         referenceBox = box.contentBoxRect();
1278         referenceBox.move(offsetFromRoot);
1279         break;
1280     case CSSBoxType::PaddingBox:
1281         referenceBox = box.paddingBoxRect();
1282         referenceBox.move(offsetFromRoot);
1283         break;
1284     case CSSBoxType::MarginBox:
1285         referenceBox = box.marginBoxRect();
1286         referenceBox.move(offsetFromRoot);
1287         break;
1288     // stroke-box, view-box compute to border-box for HTML elements.
1289     case CSSBoxType::StrokeBox:
1290     case CSSBoxType::ViewBox:
1291     case CSSBoxType::BorderBox:
1292     case CSSBoxType::BoxMissing:
1293         referenceBox = box.borderBoxRect();
1294         referenceBox.move(offsetFromRoot);
1295         break;
1296     }
1297 
1298     return referenceBox;
1299 }
1300 
1301 static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)
1302 {
1303     // FIXME: Support different reference boxes for inline content.
1304     // https://bugs.webkit.org/show_bug.cgi?id=129047
1305     if (!renderer.isBox())
1306         return rootRelativeBounds;
1307 
1308     return computeReferenceRectFromBox(downcast&lt;RenderBox&gt;(renderer), boxType, offsetFromRoot);
1309 }
1310 
1311 static inline CSSBoxType transformBoxToCSSBoxType(TransformBox transformBox)
1312 {
1313     switch (transformBox) {
1314     case TransformBox::StrokeBox:
1315         return CSSBoxType::StrokeBox;
1316     case TransformBox::ContentBox:
1317         return CSSBoxType::ContentBox;
1318     case TransformBox::BorderBox:
1319         return CSSBoxType::BorderBox;
1320     case TransformBox::FillBox:
1321         return CSSBoxType::FillBox;
1322     case TransformBox::ViewBox:
1323         return CSSBoxType::ViewBox;
1324     default:
1325         ASSERT_NOT_REACHED();
1326         return CSSBoxType::BorderBox;
1327     }
1328 }
1329 
1330 void RenderLayer::updateTransform()
1331 {
1332     bool hasTransform = renderer().hasTransform();
1333     bool had3DTransform = has3DTransform();
1334 
1335     bool hadTransform = !!m_transform;
1336     if (hasTransform != hadTransform) {
1337         if (hasTransform)
1338             m_transform = makeUnique&lt;TransformationMatrix&gt;();
1339         else
1340             m_transform = nullptr;
1341 
1342         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1343         clearClipRectsIncludingDescendants();
1344     }
1345 
1346     if (hasTransform) {
1347         RenderBox* box = renderBox();
1348         ASSERT(box);
1349         m_transform-&gt;makeIdentity();
1350         LayoutSize offsetFromRoot;
1351         auto computedReferenceBox = computeReferenceRectFromBox(*box, transformBoxToCSSBoxType(box-&gt;style().transformBox()), offsetFromRoot);
1352         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);
1353         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1354     }
1355 
1356     if (had3DTransform != has3DTransform()) {
1357         dirty3DTransformedDescendantStatus();
1358         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1359         setNeedsPostLayoutCompositingUpdateOnAncestors();
1360     }
1361 }
1362 
1363 TransformationMatrix RenderLayer::currentTransform(RenderStyle::ApplyTransformOrigin applyOrigin) const
1364 {
1365     if (!m_transform)
1366         return TransformationMatrix();
1367 
1368     RenderBox* box = renderBox();
1369 
1370     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1371         if (auto* timeline = renderer().documentTimeline()) {
1372             if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1373                 TransformationMatrix currTransform;
1374                 LayoutSize offsetFromRoot;
1375                 std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
1376                 auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());
1377                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());
1378                 style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1379                 makeMatrixRenderable(currTransform, canRender3DTransforms());
1380                 return currTransform;
1381             }
1382         }
1383     } else {
1384         if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1385             TransformationMatrix currTransform;
1386             std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
1387             LayoutSize offsetFromRoot;
1388             auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());
1389             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());
1390             style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1391             makeMatrixRenderable(currTransform, canRender3DTransforms());
1392             return currTransform;
1393         }
1394     }
1395 
1396 
1397     // m_transform includes transform-origin, so we need to recompute the transform here.
1398     if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
1399         TransformationMatrix currTransform;
1400         LayoutSize offsetFromRoot;
1401         std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
1402         auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());
1403         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());
1404         box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
1405         makeMatrixRenderable(currTransform, canRender3DTransforms());
1406         return currTransform;
1407     }
1408 
1409     return *m_transform;
1410 }
1411 
1412 TransformationMatrix RenderLayer::renderableTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
1413 {
1414     if (!m_transform)
1415         return TransformationMatrix();
1416 
1417     if (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) {
1418         TransformationMatrix matrix = *m_transform;
1419         makeMatrixRenderable(matrix, false /* flatten 3d */);
1420         return matrix;
1421     }
1422 
1423     return *m_transform;
1424 }
1425 
1426 RenderLayer* RenderLayer::enclosingOverflowClipLayer(IncludeSelfOrNot includeSelf) const
1427 {
1428     const RenderLayer* layer = (includeSelf == IncludeSelf) ? this : parent();
1429     while (layer) {
1430         if (layer-&gt;renderer().hasOverflowClip())
1431             return const_cast&lt;RenderLayer*&gt;(layer);
1432 
1433         layer = layer-&gt;parent();
1434     }
1435     return nullptr;
1436 }
1437 
1438 // FIXME: This is terrible. Bring back a cached bit for this someday. This crawl is going to slow down all
1439 // painting of content inside paginated layers.
1440 bool RenderLayer::hasCompositedLayerInEnclosingPaginationChain() const
1441 {
1442     // No enclosing layer means no compositing in the chain.
1443     if (!m_enclosingPaginationLayer)
1444         return false;
1445 
1446     // If the enclosing layer is composited, we don&#39;t have to check anything in between us and that
1447     // layer.
1448     if (m_enclosingPaginationLayer-&gt;isComposited())
1449         return true;
1450 
1451     // If we are the enclosing pagination layer, then we can&#39;t be composited or we&#39;d have passed the
1452     // previous check.
1453     if (m_enclosingPaginationLayer == this)
1454         return false;
1455 
1456     // The enclosing paginated layer is our ancestor and is not composited, so we have to check
1457     // intermediate layers between us and the enclosing pagination layer. Start with our own layer.
1458     if (isComposited())
1459         return true;
1460 
1461     // For normal flow layers, we can recur up the layer tree.
1462     if (isNormalFlowOnly())
1463         return parent()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1464 
1465     // Otherwise we have to go up the containing block chain. Find the first enclosing
1466     // containing block layer ancestor, and check that.
1467     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1468         if (containingBlock-&gt;hasLayer())
1469             return containingBlock-&gt;layer()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1470     }
1471     return false;
1472 }
1473 
1474 void RenderLayer::updatePagination()
1475 {
1476     m_enclosingPaginationLayer = nullptr;
1477 
1478     if (!parent())
1479         return;
1480 
1481     // Each layer that is inside a multicolumn flow thread has to be checked individually and
1482     // genuinely know if it is going to have to split itself up when painting only its contents (and not any other descendant
1483     // layers). We track an enclosingPaginationLayer instead of using a simple bit, since we want to be able to get back
1484     // to that layer easily.
1485     if (renderer().isInFlowRenderFragmentedFlow()) {
1486         m_enclosingPaginationLayer = makeWeakPtr(*this);
1487         return;
1488     }
1489 
1490     if (isNormalFlowOnly()) {
1491         // Content inside a transform is not considered to be paginated, since we simply
1492         // paint the transform multiple times in each column, so we don&#39;t have to use
1493         // fragments for the transformed content.
1494         if (parent()-&gt;hasTransform())
1495             m_enclosingPaginationLayer = nullptr;
1496         else
1497             m_enclosingPaginationLayer = makeWeakPtr(parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1498         return;
1499     }
1500 
1501     // For the new columns code, we want to walk up our containing block chain looking for an enclosing layer. Once
1502     // we find one, then we just check its pagination status.
1503     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1504         if (containingBlock-&gt;hasLayer()) {
1505             // Content inside a transform is not considered to be paginated, since we simply
1506             // paint the transform multiple times in each column, so we don&#39;t have to use
1507             // fragments for the transformed content.
1508             if (containingBlock-&gt;layer()-&gt;hasTransform())
1509                 m_enclosingPaginationLayer = nullptr;
1510             else
1511                 m_enclosingPaginationLayer = makeWeakPtr(containingBlock-&gt;layer()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1512             return;
1513         }
1514     }
1515 }
1516 
1517 void RenderLayer::setHasVisibleContent()
1518 {
1519     if (m_hasVisibleContent &amp;&amp; !m_visibleContentStatusDirty) {
1520         ASSERT(!parent() || parent()-&gt;hasVisibleDescendant());
1521         return;
1522     }
1523 
1524     m_visibleContentStatusDirty = false;
1525     m_hasVisibleContent = true;
1526     computeRepaintRects(renderer().containerForRepaint());
1527     if (!isNormalFlowOnly()) {
1528         // We don&#39;t collect invisible layers in z-order lists if we are not in compositing mode.
1529         // As we became visible, we need to dirty our stacking containers ancestors to be properly
1530         // collected. FIXME: When compositing, we could skip this dirtying phase.
1531         for (RenderLayer* sc = stackingContext(); sc; sc = sc-&gt;stackingContext()) {
1532             sc-&gt;dirtyZOrderLists();
1533             if (sc-&gt;hasVisibleContent())
1534                 break;
1535         }
1536     }
1537 
1538     if (parent())
1539         parent()-&gt;setAncestorChainHasVisibleDescendant();
1540 }
1541 
1542 void RenderLayer::dirtyVisibleContentStatus()
1543 {
1544     m_visibleContentStatusDirty = true;
1545     if (parent())
1546         parent()-&gt;dirtyAncestorChainVisibleDescendantStatus();
1547 }
1548 
1549 void RenderLayer::dirtyAncestorChainVisibleDescendantStatus()
1550 {
1551     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1552         if (layer-&gt;m_visibleDescendantStatusDirty)
1553             break;
1554 
1555         layer-&gt;m_visibleDescendantStatusDirty = true;
1556     }
1557 }
1558 
1559 void RenderLayer::setAncestorChainHasVisibleDescendant()
1560 {
1561     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1562         if (!layer-&gt;m_visibleDescendantStatusDirty &amp;&amp; layer-&gt;hasVisibleDescendant())
1563             break;
1564 
1565         layer-&gt;m_hasVisibleDescendant = true;
1566         layer-&gt;m_visibleDescendantStatusDirty = false;
1567     }
1568 }
1569 
1570 void RenderLayer::updateDescendantDependentFlags()
1571 {
1572     if (m_visibleDescendantStatusDirty || m_hasSelfPaintingLayerDescendantDirty || hasNotIsolatedBlendingDescendantsStatusDirty()) {
1573         bool hasVisibleDescendant = false;
1574         bool hasSelfPaintingLayerDescendant = false;
1575 #if ENABLE(CSS_COMPOSITING)
1576         bool hasNotIsolatedBlendingDescendants = false;
1577 #endif
1578 
1579         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1580             child-&gt;updateDescendantDependentFlags();
1581 
1582             hasVisibleDescendant |= child-&gt;m_hasVisibleContent || child-&gt;m_hasVisibleDescendant;
1583             hasSelfPaintingLayerDescendant |= child-&gt;isSelfPaintingLayer() || child-&gt;hasSelfPaintingLayerDescendant();
1584 #if ENABLE(CSS_COMPOSITING)
1585             hasNotIsolatedBlendingDescendants |= child-&gt;hasBlendMode() || (child-&gt;hasNotIsolatedBlendingDescendants() &amp;&amp; !child-&gt;isolatesBlending());
1586 #endif
1587 
1588             bool allFlagsSet = hasVisibleDescendant &amp;&amp; hasSelfPaintingLayerDescendant;
1589 #if ENABLE(CSS_COMPOSITING)
1590             allFlagsSet &amp;= hasNotIsolatedBlendingDescendants;
1591 #endif
1592             if (allFlagsSet)
1593                 break;
1594         }
1595 
1596         m_hasVisibleDescendant = hasVisibleDescendant;
1597         m_visibleDescendantStatusDirty = false;
1598         m_hasSelfPaintingLayerDescendant = hasSelfPaintingLayerDescendant;
1599         m_hasSelfPaintingLayerDescendantDirty = false;
1600 
1601 #if ENABLE(CSS_COMPOSITING)
1602         m_hasNotIsolatedBlendingDescendants = hasNotIsolatedBlendingDescendants;
1603         if (m_hasNotIsolatedBlendingDescendantsStatusDirty) {
1604             m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1605             updateSelfPaintingLayer();
1606         }
1607 #endif
1608     }
1609 
1610     if (m_visibleContentStatusDirty) {
1611         if (renderer().style().visibility() == Visibility::Visible)
1612             m_hasVisibleContent = true;
1613         else {
1614             // layer may be hidden but still have some visible content, check for this
1615             m_hasVisibleContent = false;
1616             RenderObject* r = renderer().firstChild();
1617             while (r) {
1618                 if (r-&gt;style().visibility() == Visibility::Visible &amp;&amp; !r-&gt;hasLayer()) {
1619                     m_hasVisibleContent = true;
1620                     break;
1621                 }
1622                 RenderObject* child = nullptr;
1623                 if (!r-&gt;hasLayer() &amp;&amp; (child = r-&gt;firstChildSlow()))
1624                     r = child;
1625                 else if (r-&gt;nextSibling())
1626                     r = r-&gt;nextSibling();
1627                 else {
1628                     do {
1629                         r = r-&gt;parent();
1630                         if (r == &amp;renderer())
1631                             r = nullptr;
1632                     } while (r &amp;&amp; !r-&gt;nextSibling());
1633                     if (r)
1634                         r = r-&gt;nextSibling();
1635                 }
1636             }
1637         }
1638         m_visibleContentStatusDirty = false;
1639     }
1640 }
1641 
1642 void RenderLayer::dirty3DTransformedDescendantStatus()
1643 {
1644     RenderLayer* curr = stackingContext();
1645     if (curr)
1646         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1647 
1648     // This propagates up through preserve-3d hierarchies to the enclosing flattening layer.
1649     // Note that preserves3D() creates stacking context, so we can just run up the stacking containers.
1650     while (curr &amp;&amp; curr-&gt;preserves3D()) {
1651         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1652         curr = curr-&gt;stackingContext();
1653     }
1654 }
1655 
1656 // Return true if this layer or any preserve-3d descendants have 3d.
1657 bool RenderLayer::update3DTransformedDescendantStatus()
1658 {
1659     if (m_3DTransformedDescendantStatusDirty) {
1660         m_has3DTransformedDescendant = false;
1661 
1662         updateZOrderLists();
1663 
1664         // Transformed or preserve-3d descendants can only be in the z-order lists, not
1665         // in the normal flow list, so we only need to check those.
1666         for (auto* layer : positiveZOrderLayers())
1667             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1668 
1669         // Now check our negative z-index children.
1670         for (auto* layer : negativeZOrderLayers())
1671             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1672 
1673         m_3DTransformedDescendantStatusDirty = false;
1674     }
1675 
1676     // If we live in a 3d hierarchy, then the layer at the root of that hierarchy needs
1677     // the m_has3DTransformedDescendant set.
1678     if (preserves3D())
1679         return has3DTransform() || m_has3DTransformedDescendant;
1680 
1681     return has3DTransform();
1682 }
1683 
1684 bool RenderLayer::updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* flags)
1685 {
1686     LayoutPoint localPoint;
1687     LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
1688     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
1689         auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1690         IntRect lineBox = inlineFlow.linesBoundingBox();
1691         setSize(lineBox.size());
1692         inlineBoundingBoxOffset = toLayoutSize(lineBox.location());
1693         localPoint += inlineBoundingBoxOffset;
1694     } else if (RenderBox* box = renderBox()) {
1695         // FIXME: Is snapping the size really needed here for the RenderBox case?
1696         auto newSize = snappedIntRect(box-&gt;frameRect()).size();
1697         if (newSize != size()) {
1698             if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
1699                 // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
1700                 setNeedsPostLayoutCompositingUpdate();
1701             }
1702 
1703             if (flags &amp;&amp; renderer().hasOverflowClip())
1704                 flags-&gt;add(ContainingClippingLayerChangedSize);
1705 
1706             setSize(newSize);
1707         }
1708 
1709         box-&gt;applyTopLeftLocationOffset(localPoint);
1710     }
1711 
1712     if (!renderer().isOutOfFlowPositioned()) {
1713         auto* ancestor = renderer().parent();
1714         // We must adjust our position by walking up the render tree looking for the
1715         // nearest enclosing object with a layer.
1716         while (ancestor &amp;&amp; !ancestor-&gt;hasLayer()) {
1717             if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor)) {
1718                 // Rows and cells share the same coordinate space (that of the section).
1719                 // Omit them when computing our xpos/ypos.
1720                 localPoint += downcast&lt;RenderBox&gt;(*ancestor).topLeftLocationOffset();
1721             }
1722             ancestor = ancestor-&gt;parent();
1723         }
1724         if (is&lt;RenderTableRow&gt;(ancestor)) {
1725             // Put ourselves into the row coordinate space.
1726             localPoint -= downcast&lt;RenderTableRow&gt;(*ancestor).topLeftLocationOffset();
1727         }
1728     }
1729 
1730     // Subtract our parent&#39;s scroll offset.
1731     RenderLayer* positionedParent;
1732     if (renderer().isOutOfFlowPositioned() &amp;&amp; (positionedParent = enclosingAncestorForPosition(renderer().style().position()))) {
1733         // For positioned layers, we subtract out the enclosing positioned layer&#39;s scroll offset.
1734         if (positionedParent-&gt;renderer().hasOverflowClip())
1735             localPoint -= toLayoutSize(positionedParent-&gt;scrollPosition());
1736 
1737         if (renderer().isOutOfFlowPositioned() &amp;&amp; positionedParent-&gt;renderer().isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(positionedParent-&gt;renderer())) {
1738             LayoutSize offset = downcast&lt;RenderInline&gt;(positionedParent-&gt;renderer()).offsetForInFlowPositionedInline(&amp;downcast&lt;RenderBox&gt;(renderer()));
1739             localPoint += offset;
1740         }
1741     } else if (parent()) {
1742         if (parent()-&gt;renderer().hasOverflowClip())
1743             localPoint -= toLayoutSize(parent()-&gt;scrollPosition());
1744     }
1745 
1746     bool positionOrOffsetChanged = false;
1747     if (renderer().isInFlowPositioned()) {
1748         LayoutSize newOffset = downcast&lt;RenderBoxModelObject&gt;(renderer()).offsetForInFlowPosition();
1749         positionOrOffsetChanged = newOffset != m_offsetForInFlowPosition;
1750         m_offsetForInFlowPosition = newOffset;
1751         localPoint.move(m_offsetForInFlowPosition);
1752     } else {
1753         m_offsetForInFlowPosition = LayoutSize();
1754     }
1755 
1756     // FIXME: We&#39;d really like to just get rid of the concept of a layer rectangle and rely on the renderers.
1757     localPoint -= inlineBoundingBoxOffset;
1758 
1759     positionOrOffsetChanged |= location() != localPoint;
1760     setLocation(localPoint);
1761 
1762     if (positionOrOffsetChanged &amp;&amp; compositor().hasContentCompositingLayers()) {
1763         if (isComposited())
1764             setNeedsCompositingGeometryUpdate();
1765         // This layer&#39;s position can affect the location of a composited descendant (which may be a sibling in z-order),
1766         // so trigger a descendant walk from the paint-order parent.
1767         if (auto* paintParent = paintOrderParent())
1768             paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1769     }
1770 
1771     return positionOrOffsetChanged;
1772 }
1773 
1774 TransformationMatrix RenderLayer::perspectiveTransform() const
1775 {
1776     RenderBox* box = renderBox();
1777     if (!box)
1778         return TransformationMatrix();
1779 
1780     if (!box-&gt;hasTransformRelatedProperty())
1781         return TransformationMatrix();
1782 
1783     const RenderStyle&amp; style = box-&gt;style();
1784     if (!style.hasPerspective())
1785         return TransformationMatrix();
1786 
1787     // Maybe fetch the perspective from the backing?
1788     const FloatRect borderBox = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1789     float perspectiveOriginX = floatValueForLength(style.perspectiveOriginX(), borderBox.width());
1790     float perspectiveOriginY = floatValueForLength(style.perspectiveOriginY(), borderBox.height());
1791 
1792     // A perspective origin of 0,0 makes the vanishing point in the center of the element.
1793     // We want it to be in the top-left, so subtract half the height and width.
1794     perspectiveOriginX -= borderBox.width() / 2.0f;
1795     perspectiveOriginY -= borderBox.height() / 2.0f;
1796 
1797     TransformationMatrix t;
1798     t.translate(perspectiveOriginX, perspectiveOriginY);
1799     t.applyPerspective(style.perspective());
1800     t.translate(-perspectiveOriginX, -perspectiveOriginY);
1801 
1802     return t;
1803 }
1804 
1805 FloatPoint RenderLayer::perspectiveOrigin() const
1806 {
1807     if (!renderer().hasTransformRelatedProperty())
1808         return FloatPoint();
1809 
1810     const LayoutRect borderBox = downcast&lt;RenderBox&gt;(renderer()).borderBoxRect();
1811     const RenderStyle&amp; style = renderer().style();
1812 
1813     return FloatPoint(floatValueForLength(style.perspectiveOriginX(), borderBox.width()),
1814                       floatValueForLength(style.perspectiveOriginY(), borderBox.height()));
1815 }
1816 
1817 static inline bool isContainerForPositioned(RenderLayer&amp; layer, PositionType position)
1818 {
1819     switch (position) {
1820     case PositionType::Fixed:
1821         return layer.renderer().canContainFixedPositionObjects();
1822 
1823     case PositionType::Absolute:
1824         return layer.renderer().canContainAbsolutelyPositionedObjects();
1825 
1826     default:
1827         ASSERT_NOT_REACHED();
1828         return false;
1829     }
1830 }
1831 
1832 bool RenderLayer::ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit) const
1833 {
1834     if (&amp;ancestor == this)
1835         return true;
1836 
1837     for (const auto* currentBlock = renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {
1838         auto* currLayer = currentBlock-&gt;layer();
1839         if (currLayer == &amp;ancestor)
1840             return true;
1841 
1842         if (currLayer &amp;&amp; currLayer == checkLimit)
1843             return false;
1844     }
1845 
1846     return false;
1847 }
1848 
1849 RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
1850 {
1851     RenderLayer* curr = parent();
1852     while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
1853         curr = curr-&gt;parent();
1854 
1855     return curr;
1856 }
1857 
1858 static RenderLayer* enclosingFrameRenderLayer(const RenderLayer&amp; layer)
1859 {
1860     auto* ownerElement = layer.renderer().document().ownerElement();
1861     if (!ownerElement)
1862         return nullptr;
1863 
1864     auto* ownerRenderer = ownerElement-&gt;renderer();
1865     if (!ownerRenderer)
1866         return nullptr;
1867 
1868     return ownerRenderer-&gt;enclosingLayer();
1869 }
1870 
1871 static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)
1872 {
1873     if (auto* parent = layer.parent())
1874         return parent;
1875 
1876     return enclosingFrameRenderLayer(layer);
1877 }
1878 
1879 RenderLayer* RenderLayer::enclosingScrollableLayer() const
1880 {
1881     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
1882         if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
1883             return nextLayer;
1884     }
1885 
1886     return nullptr;
1887 }
1888 
1889 IntRect RenderLayer::scrollableAreaBoundingBox(bool* isInsideFixed) const
1890 {
1891     return renderer().absoluteBoundingBoxRect(/* useTransforms */ true, isInsideFixed);
1892 }
1893 
1894 bool RenderLayer::isRubberBandInProgress() const
1895 {
1896 #if ENABLE(RUBBER_BANDING)
1897     if (!scrollsOverflow())
1898         return false;
1899 
1900     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
1901         return scrollAnimator-&gt;isRubberBandInProgress();
1902 #endif
1903 
1904     return false;
1905 }
1906 
1907 bool RenderLayer::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
1908 {
1909     return renderer().settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
1910 }
1911 
1912 RenderLayer* RenderLayer::enclosingTransformedAncestor() const
1913 {
1914     RenderLayer* curr = parent();
1915     while (curr &amp;&amp; !curr-&gt;isRenderViewLayer() &amp;&amp; !curr-&gt;transform())
1916         curr = curr-&gt;parent();
1917 
1918     return curr;
1919 }
1920 
1921 inline bool RenderLayer::shouldRepaintAfterLayout() const
1922 {
1923     if (m_repaintStatus == NeedsNormalRepaint)
1924         return true;
1925 
1926     // Composited layers that were moved during a positioned movement only
1927     // layout, don&#39;t need to be repainted. They just need to be recomposited.
1928     ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
1929     return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
1930 }
1931 
1932 void RenderLayer::setBackingProviderLayer(RenderLayer* backingProvider)
1933 {
1934     if (backingProvider == m_backingProviderLayer)
1935         return;
1936 
1937     if (!renderer().renderTreeBeingDestroyed())
1938         clearClipRectsIncludingDescendants();
1939 
1940     m_backingProviderLayer = makeWeakPtr(backingProvider);
1941 }
1942 
1943 void RenderLayer::disconnectFromBackingProviderLayer()
1944 {
1945     if (!m_backingProviderLayer)
1946         return;
1947 
1948     ASSERT(m_backingProviderLayer-&gt;isComposited());
1949     if (m_backingProviderLayer-&gt;isComposited())
1950         m_backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);
1951 }
1952 
1953 bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
1954 {
1955     return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
1956 }
1957 
1958 RenderLayer* RenderLayer::enclosingCompositingLayer(IncludeSelfOrNot includeSelf) const
1959 {
1960     if (includeSelf == IncludeSelf &amp;&amp; isComposited())
1961         return const_cast&lt;RenderLayer*&gt;(this);
1962 
1963     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1964         if (curr-&gt;isComposited())
1965             return const_cast&lt;RenderLayer*&gt;(curr);
1966     }
1967 
1968     return nullptr;
1969 }
1970 
1971 RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
1972 {
1973     auto repaintTargetForLayer = [](const RenderLayer&amp; layer) -&gt; RenderLayer* {
1974         if (compositedWithOwnBackingStore(layer))
1975             return const_cast&lt;RenderLayer*&gt;(&amp;layer);
1976 
1977         if (layer.paintsIntoProvidedBacking())
1978             return layer.backingProviderLayer();
1979 
1980         return nullptr;
1981     };
1982 
1983     RenderLayer* repaintTarget = nullptr;
1984     if (includeSelf == IncludeSelf &amp;&amp; (repaintTarget = repaintTargetForLayer(*this)))
1985         return repaintTarget;
1986 
1987     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1988         if ((repaintTarget = repaintTargetForLayer(*curr)))
1989             return repaintTarget;
1990     }
1991 
1992     return nullptr;
1993 }
1994 
1995 RenderLayer* RenderLayer::enclosingFilterLayer(IncludeSelfOrNot includeSelf) const
1996 {
1997     const RenderLayer* curr = (includeSelf == IncludeSelf) ? this : parent();
1998     for (; curr; curr = curr-&gt;parent()) {
1999         if (curr-&gt;requiresFullLayerImageForFilters())
2000             return const_cast&lt;RenderLayer*&gt;(curr);
2001     }
2002 
2003     return nullptr;
2004 }
2005 
2006 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
2007 {
2008     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
2009         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
2010             return const_cast&lt;RenderLayer*&gt;(curr);
2011     }
2012     return nullptr;
2013 }
2014 
2015 // FIXME: This neeeds a better name.
2016 void RenderLayer::setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp; rect)
2017 {
2018     ASSERT(requiresFullLayerImageForFilters());
2019     ASSERT(m_filters);
2020 
2021     if (rect.isEmpty())
2022         return;
2023 
2024     LayoutRect rectForRepaint = rect;
2025     rectForRepaint += filterOutsets();
2026 
2027     m_filters-&gt;expandDirtySourceRect(rectForRepaint);
2028 
2029     RenderLayer* parentLayer = enclosingFilterRepaintLayer();
2030     ASSERT(parentLayer);
2031     FloatQuad repaintQuad(rectForRepaint);
2032     LayoutRect parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
2033 
2034     if (parentLayer-&gt;isComposited()) {
2035         if (!parentLayer-&gt;backing()-&gt;paintsIntoWindow()) {
2036             parentLayer-&gt;setBackingNeedsRepaintInRect(parentLayerRect);
2037             return;
2038         }
2039         // If the painting goes to window, redirect the painting to the parent RenderView.
2040         parentLayer = renderer().view().layer();
2041         parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
2042     }
2043 
2044     if (parentLayer-&gt;paintsWithFilters()) {
2045         parentLayer-&gt;setFilterBackendNeedsRepaintingInRect(parentLayerRect);
2046         return;
2047     }
2048 
2049     if (parentLayer-&gt;isRenderViewLayer()) {
2050         downcast&lt;RenderView&gt;(parentLayer-&gt;renderer()).repaintViewRectangle(parentLayerRect);
2051         return;
2052     }
2053 
2054     ASSERT_NOT_REACHED();
2055 }
2056 
2057 bool RenderLayer::hasAncestorWithFilterOutsets() const
2058 {
2059     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
2060         if (curr-&gt;hasFilterOutsets())
2061             return true;
2062     }
2063     return false;
2064 }
2065 
2066 RenderLayer* RenderLayer::clippingRootForPainting() const
2067 {
2068     if (isComposited())
2069         return const_cast&lt;RenderLayer*&gt;(this);
2070 
2071     if (paintsIntoProvidedBacking())
2072         return backingProviderLayer();
2073 
2074     const RenderLayer* current = this;
2075     while (current) {
2076         if (current-&gt;isRenderViewLayer())
2077             return const_cast&lt;RenderLayer*&gt;(current);
2078 
2079         current = current-&gt;paintOrderParent();
2080         ASSERT(current);
2081         if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
2082             return const_cast&lt;RenderLayer*&gt;(current);
2083 
2084         if (current-&gt;paintsIntoProvidedBacking())
2085             return current-&gt;backingProviderLayer();
2086     }
2087 
2088     ASSERT_NOT_REACHED();
2089     return nullptr;
2090 }
2091 
2092 LayoutPoint RenderLayer::absoluteToContents(const LayoutPoint&amp; absolutePoint) const
2093 {
2094     // We don&#39;t use convertToLayerCoords because it doesn&#39;t know about transforms
2095     return LayoutPoint(renderer().absoluteToLocal(absolutePoint, UseTransforms));
2096 }
2097 
2098 bool RenderLayer::cannotBlitToWindow() const
2099 {
2100     if (isTransparent() || hasReflection() || hasTransform())
2101         return true;
2102     if (!parent())
2103         return false;
2104     return parent()-&gt;cannotBlitToWindow();
2105 }
2106 
2107 RenderLayer* RenderLayer::transparentPaintingAncestor()
2108 {
2109     if (isComposited())
2110         return nullptr;
2111 
2112     for (RenderLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
2113         if (curr-&gt;isComposited())
2114             return nullptr;
2115         if (curr-&gt;isTransparent())
2116             return curr;
2117     }
2118     return nullptr;
2119 }
2120 
2121 enum TransparencyClipBoxBehavior {
2122     PaintingTransparencyClipBox,
2123     HitTestingTransparencyClipBox
2124 };
2125 
2126 enum TransparencyClipBoxMode {
2127     DescendantsOfTransparencyClipBox,
2128     RootOfTransparencyClipBox
2129 };
2130 
2131 static LayoutRect transparencyClipBox(const RenderLayer&amp;, const RenderLayer* rootLayer, TransparencyClipBoxBehavior, TransparencyClipBoxMode, OptionSet&lt;PaintBehavior&gt; = { });
2132 
2133 static void expandClipRectForDescendantsAndReflection(LayoutRect&amp; clipRect, const RenderLayer&amp; layer, const RenderLayer* rootLayer,
2134     TransparencyClipBoxBehavior transparencyBehavior, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2135 {
2136     // If we have a mask, then the clip is limited to the border box area (and there is
2137     // no need to examine child layers).
2138     if (!layer.renderer().hasMask()) {
2139         // Note: we don&#39;t have to walk z-order lists since transparent elements always establish
2140         // a stacking container. This means we can just walk the layer tree directly.
2141         for (RenderLayer* curr = layer.firstChild(); curr; curr = curr-&gt;nextSibling()) {
2142             if (!layer.isReflectionLayer(*curr))
2143                 clipRect.unite(transparencyClipBox(*curr, rootLayer, transparencyBehavior, DescendantsOfTransparencyClipBox, paintBehavior));
2144         }
2145     }
2146 
2147     // If we have a reflection, then we need to account for that when we push the clip.  Reflect our entire
2148     // current transparencyClipBox to catch all child layers.
2149     // FIXME: Accelerated compositing will eventually want to do something smart here to avoid incorporating this
2150     // size into the parent layer.
2151     if (layer.renderer().hasReflection()) {
2152         LayoutSize delta = layer.offsetFromAncestor(rootLayer);
2153         clipRect.move(-delta);
2154         clipRect.unite(layer.renderBox()-&gt;reflectedRect(clipRect));
2155         clipRect.move(delta);
2156     }
2157 }
2158 
2159 static LayoutRect transparencyClipBox(const RenderLayer&amp; layer, const RenderLayer* rootLayer, TransparencyClipBoxBehavior transparencyBehavior,
2160     TransparencyClipBoxMode transparencyMode, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2161 {
2162     // FIXME: Although this function completely ignores CSS-imposed clipping, we did already intersect with the
2163     // paintDirtyRect, and that should cut down on the amount we have to paint.  Still it
2164     // would be better to respect clips.
2165 
2166     if (rootLayer != &amp;layer &amp;&amp; ((transparencyBehavior == PaintingTransparencyClipBox &amp;&amp; layer.paintsWithTransform(paintBehavior))
2167         || (transparencyBehavior == HitTestingTransparencyClipBox &amp;&amp; layer.hasTransform()))) {
2168         // The best we can do here is to use enclosed bounding boxes to establish a &quot;fuzzy&quot; enough clip to encompass
2169         // the transformed layer and all of its children.
2170         RenderLayer::PaginationInclusionMode mode = transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::IncludeCompositedPaginatedLayers : RenderLayer::ExcludeCompositedPaginatedLayers;
2171         const RenderLayer* paginationLayer = transparencyMode == DescendantsOfTransparencyClipBox ? layer.enclosingPaginationLayer(mode) : nullptr;
2172         const RenderLayer* rootLayerForTransform = paginationLayer ? paginationLayer : rootLayer;
2173         LayoutSize delta = layer.offsetFromAncestor(rootLayerForTransform);
2174 
2175         TransformationMatrix transform;
2176         transform.translate(delta.width(), delta.height());
2177         transform.multiply(*layer.transform());
2178 
2179         // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
2180         // paints unfragmented.
2181         LayoutRect clipRect = layer.boundingBox(&amp;layer);
2182         expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
2183         clipRect += layer.filterOutsets();
2184         LayoutRect result = transform.mapRect(clipRect);
2185         if (!paginationLayer)
2186             return result;
2187 
2188         // We have to break up the transformed extent across our columns.
2189         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
2190         // get our true bounding box.
2191         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
2192         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
2193         result.move(paginationLayer-&gt;offsetFromAncestor(rootLayer));
2194         return result;
2195     }
2196 
2197     LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
2198     expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
2199     clipRect += layer.filterOutsets();
2200 
2201     return clipRect;
2202 }
2203 
2204 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2205 {
2206     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
2207 }
2208 
2209 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
2210 {
2211     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
2212         return;
2213 
2214     RenderLayer* ancestor = transparentPaintingAncestor();
2215     if (ancestor)
2216         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
2217 
2218     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
2219         ASSERT(isCSSStackingContext());
2220         m_usedTransparency = true;
2221         context.save();
2222         LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
2223         adjustedClipRect.move(paintingInfo.subpixelOffset);
2224         FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
2225         context.clip(pixelSnappedClipRect);
2226 
2227 #if ENABLE(CSS_COMPOSITING)
2228         bool usesCompositeOperation = hasBlendMode() &amp;&amp; !(renderer().isSVGRoot() &amp;&amp; parent() &amp;&amp; parent()-&gt;isRenderViewLayer());
2229         if (usesCompositeOperation)
2230             context.setCompositeOperation(context.compositeOperation(), blendMode());
2231 #endif
2232 
2233         context.beginTransparencyLayer(renderer().opacity());
2234 
2235 #if ENABLE(CSS_COMPOSITING)
2236         if (usesCompositeOperation)
2237             context.setCompositeOperation(context.compositeOperation(), BlendMode::Normal);
2238 #endif
2239 
2240 #ifdef REVEAL_TRANSPARENCY_LAYERS
2241         context.setFillColor(Color(0.0f, 0.0f, 0.5f, 0.2f));
2242         context.fillRect(pixelSnappedClipRect);
2243 #endif
2244     }
2245 }
2246 
2247 #if PLATFORM(IOS_FAMILY)
2248 void RenderLayer::willBeDestroyed()
2249 {
2250     if (RenderLayerBacking* layerBacking = backing())
2251         layerBacking-&gt;layerWillBeDestroyed();
2252 }
2253 #endif
2254 
2255 bool RenderLayer::isDescendantOf(const RenderLayer&amp; layer) const
2256 {
2257     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parent()) {
2258         if (&amp;layer == ancestor)
2259             return true;
2260     }
2261     return false;
2262 }
2263 
2264 static RenderLayer* findCommonAncestor(const RenderLayer&amp; firstLayer, const RenderLayer&amp; secondLayer)
2265 {
2266     if (&amp;firstLayer == &amp;secondLayer)
2267         return const_cast&lt;RenderLayer*&gt;(&amp;firstLayer);
2268 
2269     HashSet&lt;const RenderLayer*&gt; ancestorChain;
2270     for (auto* currLayer = &amp;firstLayer; currLayer; currLayer = currLayer-&gt;parent())
2271         ancestorChain.add(currLayer);
2272 
2273     for (auto* currLayer = &amp;secondLayer; currLayer; currLayer = currLayer-&gt;parent()) {
2274         if (ancestorChain.contains(currLayer))
2275             return const_cast&lt;RenderLayer*&gt;(currLayer);
2276     }
2277     return nullptr;
2278 }
2279 
2280 RenderLayer* RenderLayer::commonAncestorWithLayer(const RenderLayer&amp; layer) const
2281 {
2282     return findCommonAncestor(*this, layer);
2283 }
2284 
2285 void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
2286 {
2287     LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
2288     roundedLocation = roundedIntPoint(location);
2289 }
2290 
2291 // Returns the layer reached on the walk up towards the ancestor.
2292 static inline const RenderLayer* accumulateOffsetTowardsAncestor(const RenderLayer* layer, const RenderLayer* ancestorLayer, LayoutPoint&amp; location, RenderLayer::ColumnOffsetAdjustment adjustForColumns)
2293 {
2294     ASSERT(ancestorLayer != layer);
2295 
2296     const RenderLayerModelObject&amp; renderer = layer-&gt;renderer();
2297     auto position = renderer.style().position();
2298 
2299     // FIXME: Special casing RenderFragmentedFlow so much for fixed positioning here is not great.
2300     RenderFragmentedFlow* fixedFragmentedFlowContainer = position == PositionType::Fixed ? renderer.enclosingFragmentedFlow() : nullptr;
2301     if (fixedFragmentedFlowContainer &amp;&amp; !fixedFragmentedFlowContainer-&gt;isOutOfFlowPositioned())
2302         fixedFragmentedFlowContainer = nullptr;
2303 
2304     // FIXME: Positioning of out-of-flow(fixed, absolute) elements collected in a RenderFragmentedFlow
2305     // may need to be revisited in a future patch.
2306     // If the fixed renderer is inside a RenderFragmentedFlow, we should not compute location using localToAbsolute,
2307     // since localToAbsolute maps the coordinates from named flow to regions coordinates and regions can be
2308     // positioned in a completely different place in the viewport (RenderView).
2309     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer &amp;&amp; (!ancestorLayer || ancestorLayer == renderer.view().layer())) {
2310         // If the fixed layer&#39;s container is the root, just add in the offset of the view. We can obtain this by calling
2311         // localToAbsolute() on the RenderView.
2312         FloatPoint absPos = renderer.localToAbsolute(FloatPoint(), IsFixed);
2313         location += LayoutSize(absPos.x(), absPos.y());
2314         return ancestorLayer;
2315     }
2316 
2317     // For the fixed positioned elements inside a render flow thread, we should also skip the code path below
2318     // Otherwise, for the case of ancestorLayer == rootLayer and fixed positioned element child of a transformed
2319     // element in render flow thread, we will hit the fixed positioned container before hitting the ancestor layer.
2320     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer) {
2321         // For a fixed layers, we need to walk up to the root to see if there&#39;s a fixed position container
2322         // (e.g. a transformed layer). It&#39;s an error to call offsetFromAncestor() across a layer with a transform,
2323         // so we should always find the ancestor at or before we find the fixed position container.
2324         RenderLayer* fixedPositionContainerLayer = nullptr;
2325         bool foundAncestor = false;
2326         for (RenderLayer* currLayer = layer-&gt;parent(); currLayer; currLayer = currLayer-&gt;parent()) {
2327             if (currLayer == ancestorLayer)
2328                 foundAncestor = true;
2329 
2330             if (isContainerForPositioned(*currLayer, PositionType::Fixed)) {
2331                 fixedPositionContainerLayer = currLayer;
2332                 ASSERT_UNUSED(foundAncestor, foundAncestor);
2333                 break;
2334             }
2335         }
2336 
2337         ASSERT(fixedPositionContainerLayer); // We should have hit the RenderView&#39;s layer at least.
2338 
2339         if (fixedPositionContainerLayer != ancestorLayer) {
2340             LayoutSize fixedContainerCoords = layer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2341             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2342             location += (fixedContainerCoords - ancestorCoords);
2343             return ancestorLayer;
2344         }
2345     }
2346 
2347     if (position == PositionType::Fixed &amp;&amp; fixedFragmentedFlowContainer) {
2348         ASSERT(ancestorLayer);
2349         if (ancestorLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
2350             location += toLayoutSize(layer-&gt;location());
2351             return ancestorLayer;
2352         }
2353 
2354         if (ancestorLayer == renderer.view().layer()) {
2355             // Add location in flow thread coordinates.
2356             location += toLayoutSize(layer-&gt;location());
2357 
2358             // Add flow thread offset in view coordinates since the view may be scrolled.
2359             FloatPoint absPos = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
2360             location += LayoutSize(absPos.x(), absPos.y());
2361             return ancestorLayer;
2362         }
2363     }
2364 
2365     RenderLayer* parentLayer;
2366     if (position == PositionType::Absolute || position == PositionType::Fixed) {
2367         // Do what enclosingAncestorForPosition() does, but check for ancestorLayer along the way.
2368         parentLayer = layer-&gt;parent();
2369         bool foundAncestorFirst = false;
2370         while (parentLayer) {
2371             // RenderFragmentedFlow is a positioned container, child of RenderView, positioned at (0,0).
2372             // This implies that, for out-of-flow positioned elements inside a RenderFragmentedFlow,
2373             // we are bailing out before reaching root layer.
2374             if (isContainerForPositioned(*parentLayer, position))
2375                 break;
2376 
2377             if (parentLayer == ancestorLayer) {
2378                 foundAncestorFirst = true;
2379                 break;
2380             }
2381 
2382             parentLayer = parentLayer-&gt;parent();
2383         }
2384 
2385         // We should not reach RenderView layer past the RenderFragmentedFlow layer for any
2386         // children of the RenderFragmentedFlow.
2387         if (renderer.enclosingFragmentedFlow() &amp;&amp; !layer-&gt;isOutOfFlowRenderFragmentedFlow())
2388             ASSERT(parentLayer != renderer.view().layer());
2389 
2390         if (foundAncestorFirst) {
2391             // Found ancestorLayer before the abs. positioned container, so compute offset of both relative
2392             // to enclosingAncestorForPosition and subtract.
2393             RenderLayer* positionedAncestor = parentLayer-&gt;enclosingAncestorForPosition(position);
2394             LayoutSize thisCoords = layer-&gt;offsetFromAncestor(positionedAncestor);
2395             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(positionedAncestor);
2396             location += (thisCoords - ancestorCoords);
2397             return ancestorLayer;
2398         }
2399     } else
2400         parentLayer = layer-&gt;parent();
2401 
2402     if (!parentLayer)
2403         return nullptr;
2404 
2405     location += toLayoutSize(layer-&gt;location());
2406 
2407     if (adjustForColumns == RenderLayer::AdjustForColumns) {
2408         if (RenderLayer* parentLayer = layer-&gt;parent()) {
2409             if (is&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer())) {
2410                 RenderFragmentContainer* fragment = downcast&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer()).physicalTranslationFromFlowToFragment(location);
2411                 if (fragment)
2412                     location.moveBy(fragment-&gt;topLeftLocation() + -parentLayer-&gt;renderBox()-&gt;topLeftLocation());
2413             }
2414         }
2415     }
2416 
2417     return parentLayer;
2418 }
2419 
2420 LayoutPoint RenderLayer::convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp; location, ColumnOffsetAdjustment adjustForColumns) const
2421 {
2422     if (ancestorLayer == this)
2423         return location;
2424 
2425     const RenderLayer* currLayer = this;
2426     LayoutPoint locationInLayerCoords = location;
2427     while (currLayer &amp;&amp; currLayer != ancestorLayer)
2428         currLayer = accumulateOffsetTowardsAncestor(currLayer, ancestorLayer, locationInLayerCoords, adjustForColumns);
2429     return locationInLayerCoords;
2430 }
2431 
2432 LayoutSize RenderLayer::offsetFromAncestor(const RenderLayer* ancestorLayer, ColumnOffsetAdjustment adjustForColumns) const
2433 {
2434     return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
2435 }
2436 
2437 bool RenderLayer::canUseCompositedScrolling() const
2438 {
2439     bool isVisible = renderer().style().visibility() == Visibility::Visible;
2440     if (renderer().settings().asyncOverflowScrollingEnabled())
2441         return isVisible &amp;&amp; scrollsOverflow();
2442 
2443 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(OVERFLOW_SCROLLING_TOUCH)
2444     return isVisible &amp;&amp; scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());
2445 #else
2446     return false;
2447 #endif
2448 }
2449 
2450 #if ENABLE(IOS_TOUCH_EVENTS)
2451 bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
2452 {
2453     // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
2454     if (hasCompositedScrollableOverflow())
2455         return false;
2456 
2457     return ScrollableArea::handleTouchEvent(touchEvent);
2458 }
2459 
2460 void RenderLayer::registerAsTouchEventListenerForScrolling()
2461 {
2462     if (!renderer().element() || m_registeredAsTouchEventListenerForScrolling)
2463         return;
2464 
2465     renderer().document().addTouchEventHandler(*renderer().element());
2466     m_registeredAsTouchEventListenerForScrolling = true;
2467 }
2468 
2469 void RenderLayer::unregisterAsTouchEventListenerForScrolling()
2470 {
2471     if (!renderer().element() || !m_registeredAsTouchEventListenerForScrolling)
2472         return;
2473 
2474     renderer().document().removeTouchEventHandler(*renderer().element());
2475     m_registeredAsTouchEventListenerForScrolling = false;
2476 }
2477 #endif // ENABLE(IOS_TOUCH_EVENTS)
2478 
2479 // FIXME: this is only valid after we&#39;ve made layers.
2480 bool RenderLayer::usesCompositedScrolling() const
2481 {
2482     return isComposited() &amp;&amp; backing()-&gt;hasScrollingLayer();
2483 }
2484 
2485 // FIXME: this is only valid after we&#39;ve made layers.
2486 bool RenderLayer::usesAsyncScrolling() const
2487 {
2488     return compositor().useCoordinatedScrollingForLayer(*this);
2489 }
2490 
2491 static inline int adjustedScrollDelta(int beginningDelta)
2492 {
2493     // This implemention matches Firefox&#39;s.
2494     // http://mxr.mozilla.org/firefox/source/toolkit/content/widgets/browser.xml#856.
2495     const int speedReducer = 12;
2496 
2497     int adjustedDelta = beginningDelta / speedReducer;
2498     if (adjustedDelta &gt; 1)
2499         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(adjustedDelta))) - 1;
2500     else if (adjustedDelta &lt; -1)
2501         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(-adjustedDelta))) + 1;
2502 
2503     return adjustedDelta;
2504 }
2505 
2506 static inline IntSize adjustedScrollDelta(const IntSize&amp; delta)
2507 {
2508     return IntSize(adjustedScrollDelta(delta.width()), adjustedScrollDelta(delta.height()));
2509 }
2510 
2511 void RenderLayer::panScrollFromPoint(const IntPoint&amp; sourcePoint)
2512 {
2513     IntPoint lastKnownMousePosition = renderer().frame().eventHandler().lastKnownMousePosition();
2514 
2515     // We need to check if the last known mouse position is out of the window. When the mouse is out of the window, the position is incoherent
2516     static IntPoint previousMousePosition;
2517     if (lastKnownMousePosition.x() &lt; 0 || lastKnownMousePosition.y() &lt; 0)
2518         lastKnownMousePosition = previousMousePosition;
2519     else
2520         previousMousePosition = lastKnownMousePosition;
2521 
2522     IntSize delta = lastKnownMousePosition - sourcePoint;
2523 
2524     if (abs(delta.width()) &lt;= ScrollView::noPanScrollRadius) // at the center we let the space for the icon
2525         delta.setWidth(0);
2526     if (abs(delta.height()) &lt;= ScrollView::noPanScrollRadius)
2527         delta.setHeight(0);
2528 
2529     scrollByRecursively(adjustedScrollDelta(delta));
2530 }
2531 
2532 // FIXME: unify with the scrollRectToVisible() code below.
2533 void RenderLayer::scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea)
2534 {
2535     if (delta.isZero())
2536         return;
2537 
2538     bool restrictedByLineClamp = false;
2539     if (renderer().parent())
2540         restrictedByLineClamp = !renderer().parent()-&gt;style().lineClamp().isNone();
2541 
2542     if (renderer().hasOverflowClip() &amp;&amp; !restrictedByLineClamp) {
2543         ScrollOffset newScrollOffset = scrollOffset() + delta;
2544         scrollToOffset(newScrollOffset);
2545         if (scrolledArea)
2546             *scrolledArea = this;
2547 
2548         // If this layer can&#39;t do the scroll we ask the next layer up that can scroll to try
2549         IntSize remainingScrollOffset = newScrollOffset - scrollOffset();
2550         if (!remainingScrollOffset.isZero() &amp;&amp; renderer().parent()) {
2551             if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
2552                 scrollableLayer-&gt;scrollByRecursively(remainingScrollOffset, scrolledArea);
2553 
2554             renderer().frame().eventHandler().updateAutoscrollRenderer();
2555         }
2556     } else {
2557         // If we are here, we were called on a renderer that can be programmatically scrolled, but doesn&#39;t
2558         // have an overflow clip. Which means that it is a document node that can be scrolled.
2559         renderer().view().frameView().scrollBy(delta);
2560         if (scrolledArea)
2561             *scrolledArea = &amp;renderer().view().frameView();
2562 
2563         // FIXME: If we didn&#39;t scroll the whole way, do we want to try looking at the frames ownerElement?
2564         // https://bugs.webkit.org/show_bug.cgi?id=28237
2565     }
2566 }
2567 
2568 void RenderLayer::setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt; position)
2569 {
2570     m_postLayoutScrollPosition = position;
2571 }
2572 
2573 void RenderLayer::applyPostLayoutScrollPositionIfNeeded()
2574 {
2575     if (!m_postLayoutScrollPosition)
2576         return;
2577 
2578     scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
2579     m_postLayoutScrollPosition = WTF::nullopt;
2580 }
2581 
2582 void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)
2583 {
2584     ScrollPosition position(x, m_scrollPosition.y());
2585     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2586 }
2587 
2588 void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)
2589 {
2590     ScrollPosition position(m_scrollPosition.x(), y);
2591     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2592 }
2593 
2594 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2595 {
2596     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2597 }
2598 
2599 bool RenderLayer::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)
2600 {
2601 #if ENABLE(ASYNC_SCROLLING)
2602     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
2603         return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);
2604 #endif
2605     return false;
2606 }
2607 
2608 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)
2609 {
2610     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
2611     if (clampedScrollOffset == this-&gt;scrollOffset())
2612         return;
2613 
2614     auto previousScrollType = currentScrollType();
2615     setCurrentScrollType(scrollType);
2616 
2617     if (!requestScrollPositionUpdate(scrollPositionFromOffset(clampedScrollOffset), scrollType, clamping))
2618         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);
2619 
2620     setCurrentScrollType(previousScrollType);
2621 }
2622 
2623 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2624 {
2625     RenderBox* box = renderBox();
2626     if (!box)
2627         return;
2628 
2629     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);
2630 
2631     ScrollPosition newPosition = position;
2632     if (!box-&gt;isHTMLMarquee()) {
2633         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2634         if (m_scrollDimensionsDirty)
2635             computeScrollDimensions();
2636 #if PLATFORM(IOS_FAMILY)
2637         if (adjustForIOSCaretWhenScrolling()) {
2638             // FIXME: It&#39;s not clear what this code is trying to do. Behavior seems reasonable with it removed.
2639             int maxOffset = scrollWidth() - roundToInt(box-&gt;clientWidth());
2640             ScrollOffset newOffset = scrollOffsetFromPosition(newPosition);
2641             int scrollXOffset = newOffset.x();
2642             if (scrollXOffset &gt; maxOffset - caretWidth) {
2643                 scrollXOffset += caretWidth;
2644                 if (scrollXOffset &lt;= caretWidth)
2645                     scrollXOffset = 0;
2646             } else if (scrollXOffset &lt; m_scrollPosition.x() - caretWidth)
2647                 scrollXOffset -= caretWidth;
2648 
2649             newOffset.setX(scrollXOffset);
2650             newPosition = scrollPositionFromOffset(newOffset);
2651         }
2652 #endif
2653     }
2654 
2655     if (m_scrollPosition == newPosition) {
2656         // FIXME: Nothing guarantees we get a scrollTo() with an unchanged position at the end of a user gesture.
2657         // The ScrollingCoordinator probably needs to message the main thread when a gesture ends.
2658         if (requiresScrollPositionReconciliation()) {
2659             setNeedsCompositingGeometryUpdate();
2660             updateCompositingLayersAfterScroll();
2661         }
2662         return;
2663     }
2664 
2665     m_scrollPosition = newPosition;
2666 
2667     RenderView&amp; view = renderer().view();
2668 
2669     // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
2670     // We don&#39;t update compositing layers, because we need to do a deep update from the compositing ancestor.
2671     if (!view.frameView().layoutContext().isInRenderTreeLayout()) {
2672         // If we&#39;re in the middle of layout, we&#39;ll just update layers once layout has finished.
2673         updateLayerPositionsAfterOverflowScroll();
2674 
2675         view.frameView().scheduleUpdateWidgetPositions();
2676 
2677         if (!m_updatingMarqueePosition) {
2678             // Avoid updating compositing layers if, higher on the stack, we&#39;re already updating layer
2679             // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
2680             // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
2681             // when that completes.
2682             if (usesCompositedScrolling()) {
2683                 setNeedsCompositingGeometryUpdate();
2684 
2685                 // Scroll position can affect the location of a composited descendant (which may be a sibling in z-order),
2686                 // so trigger a descendant walk from the paint-order parent.
2687                 if (auto* paintParent = paintOrderParent())
2688                     paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2689             }
2690 
2691             updateCompositingLayersAfterScroll();
2692         }
2693 
2694         // Update regions, scrolling may change the clip of a particular region.
2695         renderer().document().invalidateRenderingDependentRegions();
2696         DebugPageOverlays::didLayout(renderer().frame());
2697     }
2698 
2699     Frame&amp; frame = renderer().frame();
2700     RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
2701     // The caret rect needs to be invalidated after scrolling
2702     frame.selection().setCaretRectNeedsUpdate();
2703 
2704     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2705 
2706     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2707     if (repaintContainer)
2708         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2709     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2710 
2711     bool requiresRepaint = true;
2712     if (usesCompositedScrolling()) {
2713         setNeedsCompositingGeometryUpdate();
2714         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2715         requiresRepaint = false;
2716     }
2717 
2718     // Just schedule a full repaint of our object.
2719     if (requiresRepaint)
2720         renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
2721 
2722     // Schedule the scroll and scroll-related DOM events.
2723     if (Element* element = renderer().element())
2724         element-&gt;document().addPendingScrollEventTarget(*element);
2725 
2726     if (scrollsOverflow())
2727         view.frameView().didChangeScrollOffset();
2728 
2729     view.frameView().viewportContentsChanged();
2730     frame.editor().renderLayerDidScroll(*this);
2731 }
2732 
2733 static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
2734 {
2735     // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
2736     if (frameElementBase &amp;&amp; frameElementBase-&gt;scrollingMode() != ScrollbarAlwaysOff)
2737         return true;
2738 
2739     // If scrollbars are forbidden, user initiated scrolls should obviously be ignored.
2740     if (frameView.wasScrolledByUser())
2741         return false;
2742 
2743     // Forbid autoscrolls when scrollbars are off, but permits other programmatic scrolls,
2744     // like navigation to an anchor.
2745     return !frameView.frame().eventHandler().autoscrollInProgress();
2746 }
2747 
2748 bool RenderLayer::allowsCurrentScroll() const
2749 {
2750     if (!renderer().hasOverflowClip())
2751         return false;
2752 
2753     // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2754     // FIXME: Is this still needed? It used to be relevant for Safari RSS.
2755     if (renderer().parent() &amp;&amp; !renderer().parent()-&gt;style().lineClamp().isNone())
2756         return false;
2757 
2758     RenderBox* box = renderBox();
2759     ASSERT(box); // Only boxes can have overflowClip set.
2760 
2761     if (renderer().frame().eventHandler().autoscrollInProgress()) {
2762         // The &quot;programmatically&quot; here is misleading; this asks whether the box has scrollable overflow,
2763         // or is a special case like a form control.
2764         return box-&gt;canBeProgramaticallyScrolled();
2765     }
2766 
2767     // Programmatic scrolls can scroll overflow:hidden.
2768     return box-&gt;hasHorizontalOverflow() || box-&gt;hasVerticalOverflow();
2769 }
2770 
2771 void RenderLayer::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
2772 {
2773     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; this &lt;&lt; &quot; scrollRectToVisible &quot; &lt;&lt; absoluteRect);
2774 
2775     RenderLayer* parentLayer = nullptr;
2776     LayoutRect newRect = absoluteRect;
2777 
2778     // We may end up propagating a scroll event. It is important that we suspend events until
2779     // the end of the function since they could delete the layer or the layer&#39;s renderer().
2780     FrameView&amp; frameView = renderer().view().frameView();
2781 
2782     if (renderer().parent())
2783         parentLayer = renderer().parent()-&gt;enclosingLayer();
2784 
2785     if (allowsCurrentScroll()) {
2786         // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2787         // This will prevent us from revealing text hidden by the slider in Safari RSS.
2788         RenderBox* box = renderBox();
2789         ASSERT(box);
2790         LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());
2791         if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
2792             // For direction: rtl; writing-mode: horizontal-tb box, the scroll bar is on the left side. The visible rect
2793             // starts from the right side of scroll bar. So the x of localExposeRect should start from the same position too.
2794             localExposeRect.moveBy(LayoutPoint(-verticalScrollbarWidth(), 0));
2795         }
2796         LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
2797         LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
2798 
2799         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
2800         if (clampedScrollOffset != scrollOffset()) {
2801             ScrollOffset oldScrollOffset = scrollOffset();
2802             scrollToOffset(clampedScrollOffset);
2803             IntSize scrollOffsetDifference = scrollOffset() - oldScrollOffset;
2804             localExposeRect.move(-scrollOffsetDifference);
2805             newRect = LayoutRect(box-&gt;localToAbsoluteQuad(FloatQuad(FloatRect(localExposeRect)), UseTransforms).boundingBox());
2806         }
2807     } else if (!parentLayer &amp;&amp; renderer().isRenderView()) {
2808         HTMLFrameOwnerElement* ownerElement = renderer().document().ownerElement();
2809 
2810         if (ownerElement &amp;&amp; ownerElement-&gt;renderer()) {
2811             HTMLFrameElementBase* frameElementBase = nullptr;
2812 
2813             if (is&lt;HTMLFrameElementBase&gt;(*ownerElement))
2814                 frameElementBase = downcast&lt;HTMLFrameElementBase&gt;(ownerElement);
2815 
2816             if (frameElementAndViewPermitScroll(frameElementBase, frameView)) {
2817                 // If this assertion fires we need to protect the ownerElement from being destroyed.
2818                 ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2819 
2820                 LayoutRect viewRect = frameView.visibleContentRect(LegacyIOSDocumentVisibleRect);
2821                 LayoutRect exposeRect = getRectToExpose(viewRect, absoluteRect, insideFixed, options.alignX, options.alignY);
2822 
2823                 IntPoint scrollOffset(roundedIntPoint(exposeRect.location()));
2824                 // Adjust offsets if they&#39;re outside of the allowable range.
2825                 scrollOffset = scrollOffset.constrainedBetween(IntPoint(), IntPoint(frameView.contentsSize()));
2826                 frameView.setScrollPosition(scrollOffset);
2827 
2828                 if (options.shouldAllowCrossOriginScrolling == ShouldAllowCrossOriginScrolling::Yes || frameView.safeToPropagateScrollToParent()) {
2829                     parentLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
2830                     // Convert the rect into the coordinate space of the parent frame&#39;s document.
2831                     newRect = frameView.contentsToContainingViewContents(enclosingIntRect(newRect));
2832                     insideFixed = false; // FIXME: ideally need to determine if this &lt;iframe&gt; is inside position:fixed.
2833                 } else
2834                     parentLayer = nullptr;
2835             }
2836         } else {
2837             if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
2838                 return;
2839 
2840             auto minScrollPosition = frameView.minimumScrollPosition();
2841             auto maxScrollPosition = frameView.maximumScrollPosition();
2842 
2843 #if !PLATFORM(IOS_FAMILY)
2844             LayoutRect viewRect = frameView.visibleContentRect();
2845 #else
2846             // FIXME: ContentInsets should be taken care of in UI process side. webkit.org/b/199682
2847             // To do that, getRectToExpose needs to return the additional scrolling to do beyond content rect.
2848             LayoutRect viewRect = frameView.viewRectExpandedByContentInsets();
2849 
2850             // FIXME: webkit.org/b/199683 FrameView::visibleContentRect is wrong when content insets are present
2851             maxScrollPosition = frameView.scrollPositionFromOffset(ScrollPosition(frameView.totalContentsSize() - flooredIntSize(viewRect.size())));
2852 
2853             auto contentInsets = page().contentInsets();
2854             minScrollPosition.move(-contentInsets.left(), -contentInsets.top());
2855             maxScrollPosition.move(contentInsets.right(), contentInsets.bottom());
2856 #endif
2857             // Move the target rect into &quot;scrollView contents&quot; coordinates.
2858             LayoutRect targetRect = absoluteRect;
2859             targetRect.move(0, frameView.headerHeight());
2860 
2861             LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
2862             // Avoid scrolling to the rounded value of revealRect.location() if we don&#39;t actually need to scroll
2863             if (revealRect != viewRect) {
2864                 ScrollOffset clampedScrollPosition = roundedIntPoint(revealRect.location()).constrainedBetween(minScrollPosition, maxScrollPosition);
2865                 frameView.setScrollPosition(clampedScrollPosition);
2866             }
2867 
2868             // This is the outermost view of a web page, so after scrolling this view we
2869             // scroll its container by calling Page::scrollRectIntoView.
2870             // This only has an effect on the Mac platform in applications
2871             // that put web views into scrolling containers, such as Mac OS X Mail.
2872             // The canAutoscroll function in EventHandler also knows about this.
2873             page().chrome().scrollRectIntoView(snappedIntRect(absoluteRect));
2874         }
2875     }
2876 
2877     if (parentLayer)
2878         parentLayer-&gt;scrollRectToVisible(newRect, insideFixed, options);
2879 }
2880 
2881 void RenderLayer::updateCompositingLayersAfterScroll()
2882 {
2883     if (compositor().hasContentCompositingLayers()) {
2884         // Our stacking container is guaranteed to contain all of our descendants that may need
2885         // repositioning, so update compositing layers from there.
2886         if (RenderLayer* compositingAncestor = stackingContext()-&gt;enclosingCompositingLayer()) {
2887             if (usesCompositedScrolling())
2888                 compositor().updateCompositingLayers(CompositingUpdateType::OnCompositedScroll, compositingAncestor);
2889             else {
2890                 // FIXME: would be nice to only dirty layers whose positions were affected by scrolling.
2891                 compositingAncestor-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2892                 compositor().updateCompositingLayers(CompositingUpdateType::OnScroll, compositingAncestor);
2893             }
2894         }
2895     }
2896 }
2897 
2898 LayoutRect RenderLayer::getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const
2899 {
2900     FrameView&amp; frameView = renderer().view().frameView();
2901     if (renderer().isRenderView() &amp;&amp; insideFixed) {
2902         // If the element is inside position:fixed and we&#39;re not scaled, no amount of scrolling is going to move things around.
2903         if (frameView.frameScaleFactor() == 1)
2904             return visibleRect;
2905 
2906         if (renderer().settings().visualViewportEnabled()) {
2907             // exposeRect is in absolute coords, affected by page scale. Unscale it.
2908             LayoutRect unscaledExposeRect = exposeRect;
2909             unscaledExposeRect.scale(1 / frameView.frameScaleFactor());
2910             unscaledExposeRect.move(0, -frameView.headerHeight());
2911 
2912             // These are both in unscaled coordinates.
2913             LayoutRect layoutViewport = frameView.layoutViewportRect();
2914             LayoutRect visualViewport = frameView.visualViewportRect();
2915 
2916             // The rect to expose may be partially offscreen, which we can&#39;t do anything about with position:fixed.
2917             unscaledExposeRect.intersect(layoutViewport);
2918             // Make sure it&#39;s not larger than the visual viewport; if so, we&#39;ll just move to the top left.
2919             unscaledExposeRect.setSize(unscaledExposeRect.size().shrunkTo(visualViewport.size()));
2920 
2921             // Compute how much we have to move the visualViewport to reveal the part of the layoutViewport that contains exposeRect.
2922             LayoutRect requiredVisualViewport = getRectToExpose(visualViewport, unscaledExposeRect, false, alignX, alignY);
2923             // Scale it back up.
2924             requiredVisualViewport.scale(frameView.frameScaleFactor());
2925             requiredVisualViewport.move(0, frameView.headerHeight());
2926             return requiredVisualViewport;
2927         }
2928     }
2929 
2930     // Determine the appropriate X behavior.
2931     ScrollAlignment::Behavior scrollX;
2932     LayoutRect exposeRectX(exposeRect.x(), visibleRect.y(), exposeRect.width(), visibleRect.height());
2933     LayoutUnit intersectWidth = intersection(visibleRect, exposeRectX).width();
2934     if (intersectWidth == exposeRect.width() || intersectWidth &gt;= MIN_INTERSECT_FOR_REVEAL)
2935         // If the rectangle is fully visible, use the specified visible behavior.
2936         // If the rectangle is partially visible, but over a certain threshold,
2937         // then treat it as fully visible to avoid unnecessary horizontal scrolling
2938         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2939     else if (intersectWidth == visibleRect.width()) {
2940         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2941         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2942         if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2943             scrollX = ScrollAlignment::Behavior::NoScroll;
2944     } else if (intersectWidth &gt; 0)
2945         // If the rectangle is partially visible, but not above the minimum threshold, use the specified partial behavior
2946         scrollX = ScrollAlignment::getPartialBehavior(alignX);
2947     else
2948         scrollX = ScrollAlignment::getHiddenBehavior(alignX);
2949     // If we&#39;re trying to align to the closest edge, and the exposeRect is further right
2950     // than the visibleRect, and not bigger than the visible area, then align with the right.
2951     if (scrollX == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxX() &gt; visibleRect.maxX() &amp;&amp; exposeRect.width() &lt; visibleRect.width())
2952         scrollX = ScrollAlignment::Behavior::AlignRight;
2953 
2954     // Given the X behavior, compute the X coordinate.
2955     LayoutUnit x;
2956     if (scrollX == ScrollAlignment::Behavior::NoScroll)
2957         x = visibleRect.x();
2958     else if (scrollX == ScrollAlignment::Behavior::AlignRight)
2959         x = exposeRect.maxX() - visibleRect.width();
2960     else if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2961         x = exposeRect.x() + (exposeRect.width() - visibleRect.width()) / 2;
2962     else
2963         x = exposeRect.x();
2964 
2965     // Determine the appropriate Y behavior.
2966     ScrollAlignment::Behavior scrollY;
2967     LayoutRect exposeRectY(visibleRect.x(), exposeRect.y(), visibleRect.width(), exposeRect.height());
2968     LayoutUnit intersectHeight = intersection(visibleRect, exposeRectY).height();
2969     if (intersectHeight == exposeRect.height())
2970         // If the rectangle is fully visible, use the specified visible behavior.
2971         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2972     else if (intersectHeight == visibleRect.height()) {
2973         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2974         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2975         if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2976             scrollY = ScrollAlignment::Behavior::NoScroll;
2977     } else if (intersectHeight &gt; 0)
2978         // If the rectangle is partially visible, use the specified partial behavior
2979         scrollY = ScrollAlignment::getPartialBehavior(alignY);
2980     else
2981         scrollY = ScrollAlignment::getHiddenBehavior(alignY);
2982     // If we&#39;re trying to align to the closest edge, and the exposeRect is further down
2983     // than the visibleRect, and not bigger than the visible area, then align with the bottom.
2984     if (scrollY == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxY() &gt; visibleRect.maxY() &amp;&amp; exposeRect.height() &lt; visibleRect.height())
2985         scrollY = ScrollAlignment::Behavior::AlignBottom;
2986 
2987     // Given the Y behavior, compute the Y coordinate.
2988     LayoutUnit y;
2989     if (scrollY == ScrollAlignment::Behavior::NoScroll)
2990         y = visibleRect.y();
2991     else if (scrollY == ScrollAlignment::Behavior::AlignBottom)
2992         y = exposeRect.maxY() - visibleRect.height();
2993     else if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2994         y = exposeRect.y() + (exposeRect.height() - visibleRect.height()) / 2;
2995     else
2996         y = exposeRect.y();
2997 
2998     return LayoutRect(LayoutPoint(x, y), visibleRect.size());
2999 }
3000 
3001 void RenderLayer::autoscroll(const IntPoint&amp; positionInWindow)
3002 {
3003     IntPoint currentDocumentPosition = renderer().view().frameView().windowToContents(positionInWindow);
3004     scrollRectToVisible(LayoutRect(currentDocumentPosition, LayoutSize(1, 1)), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::Yes });
3005 }
3006 
3007 bool RenderLayer::canResize() const
3008 {
3009     // We need a special case for &lt;iframe&gt; because they never have
3010     // hasOverflowClip(). However, they do &quot;implicitly&quot; clip their contents, so
3011     // we want to allow resizing them also.
3012     return (renderer().hasOverflowClip() || renderer().isRenderIFrame()) &amp;&amp; renderer().style().resize() != Resize::None;
3013 }
3014 
3015 void RenderLayer::resize(const PlatformMouseEvent&amp; evt, const LayoutSize&amp; oldOffset)
3016 {
3017     // FIXME: This should be possible on generated content but is not right now.
3018     if (!inResizeMode() || !canResize() || !renderer().element())
3019         return;
3020 
3021     // FIXME: The only case where renderer-&gt;element()-&gt;renderer() != renderer is with continuations. Do they matter here?
3022     // If they do it would still be better to deal with them explicitly.
3023     Element* element = renderer().element();
3024     auto* renderer = downcast&lt;RenderBox&gt;(element-&gt;renderer());
3025 
3026     Document&amp; document = element-&gt;document();
3027     if (!document.frame()-&gt;eventHandler().mousePressed())
3028         return;
3029 
3030     float zoomFactor = renderer-&gt;style().effectiveZoom();
3031 
3032     LayoutSize newOffset = offsetFromResizeCorner(document.view()-&gt;windowToContents(evt.position()));
3033     newOffset.setWidth(newOffset.width() / zoomFactor);
3034     newOffset.setHeight(newOffset.height() / zoomFactor);
3035 
3036     LayoutSize currentSize = LayoutSize(renderer-&gt;width() / zoomFactor, renderer-&gt;height() / zoomFactor);
3037     LayoutSize minimumSize = element-&gt;minimumSizeForResizing().shrunkTo(currentSize);
3038     element-&gt;setMinimumSizeForResizing(minimumSize);
3039 
3040     LayoutSize adjustedOldOffset = LayoutSize(oldOffset.width() / zoomFactor, oldOffset.height() / zoomFactor);
3041     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
3042         newOffset.setWidth(-newOffset.width());
3043         adjustedOldOffset.setWidth(-adjustedOldOffset.width());
3044     }
3045 
3046     LayoutSize difference = (currentSize + newOffset - adjustedOldOffset).expandedTo(minimumSize) - currentSize;
3047 
3048     StyledElement* styledElement = downcast&lt;StyledElement&gt;(element);
3049     bool isBoxSizingBorder = renderer-&gt;style().boxSizing() == BoxSizing::BorderBox;
3050 
3051     Resize resize = renderer-&gt;style().resize();
3052     if (resize != Resize::Vertical &amp;&amp; difference.width()) {
3053         if (is&lt;HTMLFormControlElement&gt;(*element)) {
3054             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
3055             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSUnitType::CSS_PX);
3056             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSUnitType::CSS_PX);
3057         }
3058         LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
3059         baseWidth = baseWidth / zoomFactor;
3060         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSUnitType::CSS_PX);
3061     }
3062 
3063     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
3064         if (is&lt;HTMLFormControlElement&gt;(*element)) {
3065             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
3066             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSUnitType::CSS_PX);
3067             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSUnitType::CSS_PX);
3068         }
3069         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
3070         baseHeight = baseHeight / zoomFactor;
3071         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSUnitType::CSS_PX);
3072     }
3073 
3074     document.updateLayout();
3075 
3076     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
3077 }
3078 
3079 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
3080 {
3081     scrollTo(scrollPositionFromOffset(offset));
3082 }
3083 
3084 ScrollingNodeID RenderLayer::scrollingNodeID() const
3085 {
3086     if (!isComposited())
3087         return 0;
3088 
3089     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
3090 }
3091 
3092 IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
3093 {
3094     IntSize scrollbarSpace;
3095     if (showsOverflowControls() &amp;&amp; scrollbarInclusion == IncludeScrollbars)
3096         scrollbarSpace = scrollbarIntrusion();
3097 
3098     auto visibleSize = this-&gt;visibleSize();
3099     return { scrollPosition(), { std::max(0, visibleSize.width() - scrollbarSpace.width()), std::max(0, visibleSize.height() - scrollbarSpace.height()) } };
3100 }
3101 
3102 IntSize RenderLayer::overhangAmount() const
3103 {
3104 #if ENABLE(RUBBER_BANDING)
3105     if (!renderer().settings().rubberBandingForSubScrollableRegionsEnabled())
3106         return IntSize();
3107 
3108     IntSize stretch;
3109 
3110     // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
3111     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
3112     auto reachableSize = reachableTotalContentsSize();
3113     if (scrollOffset.y() &lt; 0)
3114         stretch.setHeight(scrollOffset.y());
3115     else if (reachableSize.height() &amp;&amp; scrollOffset.y() &gt; reachableSize.height() - visibleHeight())
3116         stretch.setHeight(scrollOffset.y() - (reachableSize.height() - visibleHeight()));
3117 
3118     if (scrollOffset.x() &lt; 0)
3119         stretch.setWidth(scrollOffset.x());
3120     else if (reachableSize.width() &amp;&amp; scrollOffset.x() &gt; reachableSize.width() - visibleWidth())
3121         stretch.setWidth(scrollOffset.x() - (reachableSize.width() - visibleWidth()));
3122 
3123     return stretch;
3124 #else
3125     return IntSize();
3126 #endif
3127 }
3128 
3129 bool RenderLayer::isActive() const
3130 {
3131     return page().focusController().isActive();
3132 }
3133 
3134 static int cornerStart(const RenderLayer&amp; layer, int minX, int maxX, int thickness)
3135 {
3136     if (layer.shouldPlaceBlockDirectionScrollbarOnLeft())
3137         return minX + layer.renderer().style().borderLeftWidth();
3138     return maxX - thickness - layer.renderer().style().borderRightWidth();
3139 }
3140 
3141 static LayoutRect cornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
3142 {
3143     int horizontalThickness;
3144     int verticalThickness;
3145     if (!layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
3146         // FIXME: This isn&#39;t right.  We need to know the thickness of custom scrollbars
3147         // even when they don&#39;t exist in order to set the resizer square size properly.
3148         horizontalThickness = ScrollbarTheme::theme().scrollbarThickness();
3149         verticalThickness = horizontalThickness;
3150     } else if (layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
3151         horizontalThickness = layer.verticalScrollbar()-&gt;width();
3152         verticalThickness = horizontalThickness;
3153     } else if (layer.horizontalScrollbar() &amp;&amp; !layer.verticalScrollbar()) {
3154         verticalThickness = layer.horizontalScrollbar()-&gt;height();
3155         horizontalThickness = verticalThickness;
3156     } else {
3157         horizontalThickness = layer.verticalScrollbar()-&gt;width();
3158         verticalThickness = layer.horizontalScrollbar()-&gt;height();
3159     }
3160     return LayoutRect(cornerStart(layer, bounds.x(), bounds.maxX(), horizontalThickness),
3161         bounds.maxY() - verticalThickness - layer.renderer().style().borderBottomWidth(),
3162         horizontalThickness, verticalThickness);
3163 }
3164 
3165 IntRect RenderLayer::scrollCornerRect() const
3166 {
3167     // We have a scrollbar corner when a non overlay scrollbar is visible and not filling the entire length of the box.
3168     // This happens when:
3169     // (a) A resizer is present and at least one non overlay scrollbar is present
3170     // (b) Both non overlay scrollbars are present.
3171     // Overlay scrollbars always fill the entire length of the box so we never have scroll corner in that case.
3172     bool hasHorizontalBar = m_hBar &amp;&amp; !m_hBar-&gt;isOverlayScrollbar();
3173     bool hasVerticalBar = m_vBar &amp;&amp; !m_vBar-&gt;isOverlayScrollbar();
3174     bool hasResizer = renderer().style().resize() != Resize::None;
3175     if ((hasHorizontalBar &amp;&amp; hasVerticalBar) || (hasResizer &amp;&amp; (hasHorizontalBar || hasVerticalBar)))
3176         return snappedIntRect(cornerRect(*this, renderBox()-&gt;borderBoxRect()));
3177     return IntRect();
3178 }
3179 
3180 static LayoutRect resizerCornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
3181 {
3182     ASSERT(layer.renderer().isBox());
3183     if (layer.renderer().style().resize() == Resize::None)
3184         return LayoutRect();
3185     return cornerRect(layer, bounds);
3186 }
3187 
3188 LayoutRect RenderLayer::scrollCornerAndResizerRect() const
3189 {
3190     RenderBox* box = renderBox();
3191     if (!box)
3192         return LayoutRect();
3193     LayoutRect scrollCornerAndResizer = scrollCornerRect();
3194     if (scrollCornerAndResizer.isEmpty())
3195         scrollCornerAndResizer = resizerCornerRect(*this, box-&gt;borderBoxRect());
3196     return scrollCornerAndResizer;
3197 }
3198 
3199 bool RenderLayer::isScrollCornerVisible() const
3200 {
3201     ASSERT(renderer().isBox());
3202     return !scrollCornerRect().isEmpty();
3203 }
3204 
3205 IntRect RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
3206 {
3207     IntRect rect = scrollbarRect;
3208     rect.move(scrollbarOffset(scrollbar));
3209 
3210     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), rect);
3211 }
3212 
3213 IntRect RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
3214 {
3215     IntRect rect = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentRect);
3216     rect.move(-scrollbarOffset(scrollbar));
3217     return rect;
3218 }
3219 
3220 IntPoint RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
3221 {
3222     IntPoint point = scrollbarPoint;
3223     point.move(scrollbarOffset(scrollbar));
3224     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), point);
3225 }
3226 
3227 IntPoint RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
3228 {
3229     IntPoint point = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentPoint);
3230     point.move(-scrollbarOffset(scrollbar));
3231     return point;
3232 }
3233 
3234 IntSize RenderLayer::visibleSize() const
3235 {
3236     RenderBox* box = renderBox();
3237     if (!box)
3238         return IntSize();
3239 
3240     return IntSize(roundToInt(box-&gt;clientWidth()), roundToInt(box-&gt;clientHeight()));
3241 }
3242 
3243 IntSize RenderLayer::contentsSize() const
3244 {
3245     return IntSize(scrollWidth(), scrollHeight());
3246 }
3247 
3248 IntSize RenderLayer::reachableTotalContentsSize() const
3249 {
3250     IntSize contentsSize = this-&gt;contentsSize();
3251 
3252     if (!hasScrollableHorizontalOverflow())
3253         contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
3254 
3255     if (!hasScrollableVerticalOverflow())
3256         contentsSize.setHeight(std::min(contentsSize.height(), visibleSize().height()));
3257 
3258     return contentsSize;
3259 }
3260 
3261 void RenderLayer::availableContentSizeChanged(AvailableSizeChangeReason reason)
3262 {
3263     ScrollableArea::availableContentSizeChanged(reason);
3264 
3265     if (reason == AvailableSizeChangeReason::ScrollbarsChanged) {
3266         if (is&lt;RenderBlock&gt;(renderer()))
3267             downcast&lt;RenderBlock&gt;(renderer()).setShouldForceRelayoutChildren(true);
3268         renderer().setNeedsLayout();
3269     }
3270 }
3271 
3272 bool RenderLayer::shouldSuspendScrollAnimations() const
3273 {
3274     return renderer().view().frameView().shouldSuspendScrollAnimations();
3275 }
3276 
3277 #if PLATFORM(IOS_FAMILY)
3278 void RenderLayer::didStartScroll()
3279 {
3280     page().chrome().client().didStartOverflowScroll();
3281 }
3282 
3283 void RenderLayer::didEndScroll()
3284 {
3285     page().chrome().client().didEndOverflowScroll();
3286 }
3287 
3288 void RenderLayer::didUpdateScroll()
3289 {
3290     // Send this notification when we scroll, since this is how we keep selection updated.
3291     page().chrome().client().didLayout(ChromeClient::Scroll);
3292 }
3293 #endif
3294 
3295 IntPoint RenderLayer::lastKnownMousePosition() const
3296 {
3297     return renderer().frame().eventHandler().lastKnownMousePosition();
3298 }
3299 
3300 bool RenderLayer::isHandlingWheelEvent() const
3301 {
3302     return renderer().frame().eventHandler().isHandlingWheelEvent();
3303 }
3304 
3305 IntRect RenderLayer::rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const
3306 {
3307     if (!m_hBar)
3308         return IntRect();
3309 
3310     const RenderBox* box = renderBox();
3311     const IntRect&amp; scrollCorner = scrollCornerRect();
3312 
3313     return IntRect(horizontalScrollbarStart(borderBoxRect.x()),
3314         borderBoxRect.maxY() - box-&gt;borderBottom() - m_hBar-&gt;height(),
3315         borderBoxRect.width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - scrollCorner.width(),
3316         m_hBar-&gt;height());
3317 }
3318 
3319 IntRect RenderLayer::rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const
3320 {
3321     if (!m_vBar)
3322         return IntRect();
3323 
3324     const RenderBox* box = renderBox();
3325     const IntRect&amp; scrollCorner = scrollCornerRect();
3326 
3327     return IntRect(verticalScrollbarStart(borderBoxRect.x(), borderBoxRect.maxX()),
3328         borderBoxRect.y() + box-&gt;borderTop(),
3329         m_vBar-&gt;width(),
3330         borderBoxRect.height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - scrollCorner.height());
3331 }
3332 
3333 LayoutUnit RenderLayer::verticalScrollbarStart(int minX, int maxX) const
3334 {
3335     const RenderBox* box = renderBox();
3336     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3337         return minX + box-&gt;borderLeft();
3338     return maxX - box-&gt;borderRight() - m_vBar-&gt;width();
3339 }
3340 
3341 LayoutUnit RenderLayer::horizontalScrollbarStart(int minX) const
3342 {
3343     const RenderBox* box = renderBox();
3344     int x = minX + box-&gt;borderLeft();
3345     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3346         x += m_vBar ? m_vBar-&gt;width() : roundToInt(resizerCornerRect(*this, box-&gt;borderBoxRect()).width());
3347     return x;
3348 }
3349 
3350 IntSize RenderLayer::scrollbarOffset(const Scrollbar&amp; scrollbar) const
3351 {
3352     RenderBox* box = renderBox();
3353 
3354     if (&amp;scrollbar == m_vBar.get())
3355         return IntSize(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3356 
3357     if (&amp;scrollbar == m_hBar.get())
3358         return IntSize(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3359 
3360     ASSERT_NOT_REACHED();
3361     return IntSize();
3362 }
3363 
3364 void RenderLayer::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3365 {
3366     if (!showsOverflowControls())
3367         return;
3368 
3369     if (&amp;scrollbar == m_vBar.get()) {
3370         if (GraphicsLayer* layer = layerForVerticalScrollbar()) {
3371             layer-&gt;setNeedsDisplayInRect(rect);
3372             return;
3373         }
3374     } else {
3375         if (GraphicsLayer* layer = layerForHorizontalScrollbar()) {
3376             layer-&gt;setNeedsDisplayInRect(rect);
3377             return;
3378         }
3379     }
3380 
3381     IntRect scrollRect = rect;
3382     RenderBox* box = renderBox();
3383     ASSERT(box);
3384     // If we are not yet inserted into the tree, there is no need to repaint.
3385     if (!box-&gt;parent())
3386         return;
3387 
3388     if (&amp;scrollbar == m_vBar.get())
3389         scrollRect.move(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3390     else
3391         scrollRect.move(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3392     LayoutRect repaintRect = scrollRect;
3393     renderBox()-&gt;flipForWritingMode(repaintRect);
3394     renderer().repaintRectangle(repaintRect);
3395 }
3396 
3397 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3398 {
3399     if (!showsOverflowControls())
3400         return;
3401 
3402     if (GraphicsLayer* layer = layerForScrollCorner()) {
3403         layer-&gt;setNeedsDisplayInRect(rect);
3404         return;
3405     }
3406 
3407     if (m_scrollCorner)
3408         m_scrollCorner-&gt;repaintRectangle(rect);
3409     if (m_resizer)
3410         m_resizer-&gt;repaintRectangle(rect);
3411 }
3412 
3413 static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)
3414 {
3415     return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();
3416 }
3417 
3418 bool RenderLayer::horizontalScrollbarHiddenByStyle() const
3419 {
3420     return scrollbarHiddenByStyle(horizontalScrollbar());
3421 }
3422 
3423 bool RenderLayer::verticalScrollbarHiddenByStyle() const
3424 {
3425     return scrollbarHiddenByStyle(verticalScrollbar());
3426 }
3427 
3428 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3429 {
3430     if (Element* element = renderer.element()) {
3431         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3432             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3433                 return shadowRoot-&gt;host()-&gt;renderer();
3434         }
3435     }
3436 
3437     return &amp;renderer;
3438 }
3439 
3440 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3441 {
3442     RefPtr&lt;Scrollbar&gt; widget;
3443     ASSERT(rendererForScrollbar(renderer()));
3444     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3445     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3446     if (hasCustomScrollbarStyle)
3447         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
3448     else {
3449         widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
3450         didAddScrollbar(widget.get(), orientation);
3451         if (page().isMonitoringWheelEvents())
3452             scrollAnimator().setWheelEventTestMonitor(page().wheelEventTestMonitor());
3453     }
3454     renderer().view().frameView().addChild(*widget);
3455     return widget.releaseNonNull();
3456 }
3457 
3458 void RenderLayer::destroyScrollbar(ScrollbarOrientation orientation)
3459 {
3460     RefPtr&lt;Scrollbar&gt;&amp; scrollbar = orientation == HorizontalScrollbar ? m_hBar : m_vBar;
3461     if (!scrollbar)
3462         return;
3463 
3464     if (!scrollbar-&gt;isCustomScrollbar())
3465         willRemoveScrollbar(scrollbar.get(), orientation);
3466 
3467     scrollbar-&gt;removeFromParent();
3468     scrollbar = nullptr;
3469 }
3470 
3471 bool RenderLayer::scrollsOverflow() const
3472 {
3473     if (!is&lt;RenderBox&gt;(renderer()))
3474         return false;
3475 
3476     return downcast&lt;RenderBox&gt;(renderer()).scrollsOverflow();
3477 }
3478 
3479 void RenderLayer::setHasHorizontalScrollbar(bool hasScrollbar)
3480 {
3481     if (hasScrollbar == hasHorizontalScrollbar())
3482         return;
3483 
3484     if (hasScrollbar) {
3485         m_hBar = createScrollbar(HorizontalScrollbar);
3486 #if ENABLE(RUBBER_BANDING)
3487         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3488         ScrollableArea::setHorizontalScrollElasticity(elasticity);
3489 #endif
3490     } else {
3491         destroyScrollbar(HorizontalScrollbar);
3492 #if ENABLE(RUBBER_BANDING)
3493         ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityNone);
3494 #endif
3495     }
3496 
3497     // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3498     if (m_hBar)
3499         m_hBar-&gt;styleChanged();
3500     if (m_vBar)
3501         m_vBar-&gt;styleChanged();
3502 }
3503 
3504 void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
3505 {
3506     if (hasScrollbar == hasVerticalScrollbar())
3507         return;
3508 
3509     if (hasScrollbar) {
3510         m_vBar = createScrollbar(VerticalScrollbar);
3511 #if ENABLE(RUBBER_BANDING)
3512         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3513         ScrollableArea::setVerticalScrollElasticity(elasticity);
3514 #endif
3515     } else {
3516         destroyScrollbar(VerticalScrollbar);
3517 #if ENABLE(RUBBER_BANDING)
3518         ScrollableArea::setVerticalScrollElasticity(ScrollElasticityNone);
3519 #endif
3520     }
3521 
3522      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3523     if (m_hBar)
3524         m_hBar-&gt;styleChanged();
3525     if (m_vBar)
3526         m_vBar-&gt;styleChanged();
3527 }
3528 
3529 ScrollableArea* RenderLayer::enclosingScrollableArea() const
3530 {
3531     if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
3532         return scrollableLayer;
3533 
3534     // FIXME: We should return the frame view here (or possibly an ancestor frame view,
3535     // if the frame view isn&#39;t scrollable.
3536     return nullptr;
3537 }
3538 
3539 bool RenderLayer::isScrollableOrRubberbandable()
3540 {
3541     return renderer().isScrollableOrRubberbandableBox();
3542 }
3543 
3544 bool RenderLayer::hasScrollableOrRubberbandableAncestor()
3545 {
3546     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
3547         if (nextLayer-&gt;isScrollableOrRubberbandable())
3548             return true;
3549     }
3550 
3551     return false;
3552 }
3553 
3554 bool RenderLayer::useDarkAppearance() const
3555 {
3556     return renderer().useDarkAppearance();
3557 }
3558 
3559 #if ENABLE(CSS_SCROLL_SNAP)
3560 void RenderLayer::updateSnapOffsets()
3561 {
3562     // FIXME: Extend support beyond HTMLElements.
3563     if (!is&lt;HTMLElement&gt;(enclosingElement()) || !enclosingElement()-&gt;renderBox())
3564         return;
3565 
3566     RenderBox* box = enclosingElement()-&gt;renderBox();
3567     updateSnapOffsetsForScrollableArea(*this, *downcast&lt;HTMLElement&gt;(enclosingElement()), *box, box-&gt;style());
3568 }
3569 
3570 bool RenderLayer::isScrollSnapInProgress() const
3571 {
3572     if (!scrollsOverflow())
3573         return false;
3574 
3575     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
3576         return scrollAnimator-&gt;isScrollSnapInProgress();
3577 
3578     return false;
3579 }
3580 #endif
3581 
3582 bool RenderLayer::usesMockScrollAnimator() const
3583 {
3584     return DeprecatedGlobalSettings::usesMockScrollAnimator();
3585 }
3586 
3587 void RenderLayer::logMockScrollAnimatorMessage(const String&amp; message) const
3588 {
3589     renderer().document().addConsoleMessage(MessageSource::Other, MessageLevel::Debug, &quot;RenderLayer: &quot; + message);
3590 }
3591 
3592 int RenderLayer::verticalScrollbarWidth(OverlayScrollbarSizeRelevancy relevancy) const
3593 {
3594     if (!m_vBar
3595         || !showsOverflowControls()
3596         || (m_vBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_vBar-&gt;shouldParticipateInHitTesting())))
3597         return 0;
3598 
3599     return m_vBar-&gt;width();
3600 }
3601 
3602 int RenderLayer::horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy relevancy) const
3603 {
3604     if (!m_hBar
3605         || !showsOverflowControls()
3606         || (m_hBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_hBar-&gt;shouldParticipateInHitTesting())))
3607         return 0;
3608 
3609     return m_hBar-&gt;height();
3610 }
3611 
3612 IntSize RenderLayer::offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const
3613 {
3614     // Currently the resize corner is either the bottom right corner or the bottom left corner.
3615     // FIXME: This assumes the location is 0, 0. Is this guaranteed to always be the case?
3616     IntSize elementSize = size();
3617     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3618         elementSize.setWidth(0);
3619     IntPoint resizerPoint = IntPoint(elementSize);
3620     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
3621     return localPoint - resizerPoint;
3622 }
3623 
3624 bool RenderLayer::hasOverflowControls() const
3625 {
3626     return m_hBar || m_vBar || m_scrollCorner || renderer().style().resize() != Resize::None;
3627 }
3628 
3629 void RenderLayer::positionOverflowControls(const IntSize&amp; offsetFromRoot)
3630 {
3631     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
3632         return;
3633 
3634     RenderBox* box = renderBox();
3635     if (!box)
3636         return;
3637 
3638     const IntRect borderBox = snappedIntRect(box-&gt;borderBoxRect());
3639     const IntRect&amp; scrollCorner = scrollCornerRect();
3640     IntRect absBounds(borderBox.location() + offsetFromRoot, borderBox.size());
3641     if (m_vBar) {
3642         IntRect vBarRect = rectForVerticalScrollbar(borderBox);
3643         vBarRect.move(offsetFromRoot);
3644         m_vBar-&gt;setFrameRect(vBarRect);
3645     }
3646 
3647     if (m_hBar) {
3648         IntRect hBarRect = rectForHorizontalScrollbar(borderBox);
3649         hBarRect.move(offsetFromRoot);
3650         m_hBar-&gt;setFrameRect(hBarRect);
3651     }
3652 
3653     if (m_scrollCorner)
3654         m_scrollCorner-&gt;setFrameRect(scrollCorner);
3655     if (m_resizer)
3656         m_resizer-&gt;setFrameRect(resizerCornerRect(*this, borderBox));
3657 
3658     if (isComposited())
3659         backing()-&gt;positionOverflowControlsLayers();
3660 }
3661 
3662 int RenderLayer::scrollWidth() const
3663 {
3664     ASSERT(renderBox());
3665     if (m_scrollDimensionsDirty)
3666         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3667     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3668     return m_scrollSize.width();
3669 }
3670 
3671 int RenderLayer::scrollHeight() const
3672 {
3673     ASSERT(renderBox());
3674     if (m_scrollDimensionsDirty)
3675         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3676     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3677     return m_scrollSize.height();
3678 }
3679 
3680 LayoutUnit RenderLayer::overflowTop() const
3681 {
3682     RenderBox* box = renderBox();
3683     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3684     box-&gt;flipForWritingMode(overflowRect);
3685     return overflowRect.y();
3686 }
3687 
3688 LayoutUnit RenderLayer::overflowBottom() const
3689 {
3690     RenderBox* box = renderBox();
3691     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3692     box-&gt;flipForWritingMode(overflowRect);
3693     return overflowRect.maxY();
3694 }
3695 
3696 LayoutUnit RenderLayer::overflowLeft() const
3697 {
3698     RenderBox* box = renderBox();
3699     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3700     box-&gt;flipForWritingMode(overflowRect);
3701     return overflowRect.x();
3702 }
3703 
3704 LayoutUnit RenderLayer::overflowRight() const
3705 {
3706     RenderBox* box = renderBox();
3707     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3708     box-&gt;flipForWritingMode(overflowRect);
3709     return overflowRect.maxX();
3710 }
3711 
3712 void RenderLayer::computeScrollDimensions()
3713 {
3714     RenderBox* box = renderBox();
3715     ASSERT(box);
3716 
3717     m_scrollDimensionsDirty = false;
3718 
3719     m_scrollSize.setWidth(roundToInt(overflowRight() - overflowLeft()));
3720     m_scrollSize.setHeight(roundToInt(overflowBottom() - overflowTop()));
3721 
3722     int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
3723     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3724         scrollableLeftOverflow -= verticalScrollbarWidth();
3725     int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
3726     setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
3727 
3728     m_hasCompositedScrollableOverflow = canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
3729 }
3730 
3731 bool RenderLayer::hasScrollableHorizontalOverflow() const
3732 {
3733     return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
3734 }
3735 
3736 bool RenderLayer::hasScrollableVerticalOverflow() const
3737 {
3738     return hasVerticalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowY();
3739 }
3740 
3741 bool RenderLayer::hasHorizontalOverflow() const
3742 {
3743     ASSERT(!m_scrollDimensionsDirty);
3744 
3745     return scrollWidth() &gt; roundToInt(renderBox()-&gt;clientWidth());
3746 }
3747 
3748 bool RenderLayer::hasVerticalOverflow() const
3749 {
3750     ASSERT(!m_scrollDimensionsDirty);
3751 
3752     return scrollHeight() &gt; roundToInt(renderBox()-&gt;clientHeight());
3753 }
3754 
3755 static bool styleRequiresScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3756 {
3757     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3758     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3759     return overflow == Overflow::Scroll &amp;&amp; !overflowScrollActsLikeAuto;
3760 }
3761 
3762 static bool styleDefinesAutomaticScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3763 {
3764     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3765     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3766     return overflow == Overflow::Auto || overflowScrollActsLikeAuto;
3767 }
3768 
3769 void RenderLayer::updateScrollbarsAfterLayout()
3770 {
3771     RenderBox* box = renderBox();
3772     ASSERT(box);
3773 
3774     // List box parts handle the scrollbars by themselves so we have nothing to do.
3775     if (box-&gt;style().appearance() == ListboxPart)
3776         return;
3777 
3778     bool hasHorizontalOverflow = this-&gt;hasHorizontalOverflow();
3779     bool hasVerticalOverflow = this-&gt;hasVerticalOverflow();
3780 
3781     // If overflow requires a scrollbar, then we just need to enable or disable.
3782     if (m_hBar &amp;&amp; styleRequiresScrollbar(renderer().style(), HorizontalScrollbar))
3783         m_hBar-&gt;setEnabled(hasHorizontalOverflow);
3784     if (m_vBar &amp;&amp; styleRequiresScrollbar(renderer().style(), VerticalScrollbar))
3785         m_vBar-&gt;setEnabled(hasVerticalOverflow);
3786 
3787     // Scrollbars with auto behavior may need to lay out again if scrollbars got added or removed.
3788     bool autoHorizontalScrollBarChanged = box-&gt;hasHorizontalScrollbarWithAutoBehavior() &amp;&amp; (hasHorizontalScrollbar() != hasHorizontalOverflow);
3789     bool autoVerticalScrollBarChanged = box-&gt;hasVerticalScrollbarWithAutoBehavior() &amp;&amp; (hasVerticalScrollbar() != hasVerticalOverflow);
3790 
3791     if (autoHorizontalScrollBarChanged || autoVerticalScrollBarChanged) {
3792         if (box-&gt;hasHorizontalScrollbarWithAutoBehavior())
3793             setHasHorizontalScrollbar(hasHorizontalOverflow);
3794         if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
3795             setHasVerticalScrollbar(hasVerticalOverflow);
3796 
3797         updateSelfPaintingLayer();
3798 
3799         renderer().repaint();
3800 
3801         if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
3802             if (!m_inOverflowRelayout) {
3803                 m_inOverflowRelayout = true;
3804                 renderer().setNeedsLayout(MarkOnlyThis);
3805                 if (is&lt;RenderBlock&gt;(renderer())) {
3806                     RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(renderer());
3807                     block.scrollbarsChanged(autoHorizontalScrollBarChanged, autoVerticalScrollBarChanged);
3808                     block.layoutBlock(true);
3809                 } else
3810                     renderer().layout();
3811                 m_inOverflowRelayout = false;
3812             }
3813         }
3814 
3815         RenderObject* parent = renderer().parent();
3816         if (parent &amp;&amp; parent-&gt;isFlexibleBox() &amp;&amp; renderer().isBox())
3817             downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;clearCachedMainSizeForChild(*renderBox());
3818     }
3819 
3820     // Set up the range (and page step/line step).
3821     if (m_hBar) {
3822         int clientWidth = roundToInt(box-&gt;clientWidth());
3823         int pageStep = Scrollbar::pageStep(clientWidth);
3824         m_hBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3825         m_hBar-&gt;setProportion(clientWidth, m_scrollSize.width());
3826     }
3827     if (m_vBar) {
3828         int clientHeight = roundToInt(box-&gt;clientHeight());
3829         int pageStep = Scrollbar::pageStep(clientHeight);
3830         m_vBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3831         m_vBar-&gt;setProportion(clientHeight, m_scrollSize.height());
3832     }
3833 
3834     updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
3835 }
3836 
3837 // This is called from layout code (before updateLayerPositions).
3838 void RenderLayer::updateScrollInfoAfterLayout()
3839 {
3840     RenderBox* box = renderBox();
3841     if (!box)
3842         return;
3843 
3844     m_scrollDimensionsDirty = true;
3845     ScrollOffset originalScrollOffset = scrollOffset();
3846 
3847     computeScrollDimensions();
3848 
3849 #if ENABLE(CSS_SCROLL_SNAP)
3850     // FIXME: Ensure that offsets are also updated in case of programmatic style changes.
3851     // https://bugs.webkit.org/show_bug.cgi?id=135964
3852     updateSnapOffsets();
3853 #endif
3854 
3855     if (!box-&gt;isHTMLMarquee() &amp;&amp; !isRubberBandInProgress()) {
3856         // Layout may cause us to be at an invalid scroll position. In this case we need
3857         // to pull our scroll offsets back to the max (or push them up to the min).
3858         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset());
3859 #if PLATFORM(IOS_FAMILY)
3860         // FIXME: This looks wrong. The caret adjust mode should only be enabled on editing related entry points.
3861         // This code was added to fix an issue where the text insertion point would always be drawn on the right edge
3862         // of a text field whose content overflowed its bounds. See &lt;rdar://problem/15579797&gt; for more details.
3863         setAdjustForIOSCaretWhenScrolling(true);
3864 #endif
3865         if (clampedScrollOffset != scrollOffset())
3866             scrollToOffset(clampedScrollOffset);
3867 
3868 #if PLATFORM(IOS_FAMILY)
3869         setAdjustForIOSCaretWhenScrolling(false);
3870 #endif
3871     }
3872 
3873     updateScrollbarsAfterLayout();
3874 
3875     if (originalScrollOffset != scrollOffset())
3876         scrollToOffsetWithoutAnimation(IntPoint(scrollOffset()));
3877 
3878     if (isComposited()) {
3879         setNeedsCompositingGeometryUpdate();
3880         setNeedsCompositingConfigurationUpdate();
3881     }
3882 
3883     if (canUseCompositedScrolling())
3884         setNeedsPostLayoutCompositingUpdate();
3885 
3886     updateScrollSnapState();
3887 }
3888 
3889 bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
3890 {
3891     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
3892 
3893     if (rectForHorizontalScrollbar(borderBox).intersects(localRect))
3894         return true;
3895 
3896     if (rectForVerticalScrollbar(borderBox).intersects(localRect))
3897         return true;
3898 
3899     if (scrollCornerRect().intersects(localRect))
3900         return true;
3901 
3902     if (resizerCornerRect(*this, borderBox).intersects(localRect))
3903         return true;
3904 
3905     return false;
3906 }
3907 
3908 bool RenderLayer::showsOverflowControls() const
3909 {
3910 #if PLATFORM(IOS_FAMILY)
3911     // On iOS, the scrollbars are made in the UI process.
3912     return !canUseCompositedScrolling();
3913 #endif
3914 
3915     return true;
3916 }
3917 
3918 void RenderLayer::paintOverflowControls(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect, bool paintingOverlayControls)
3919 {
3920     // Don&#39;t do anything if we have no overflow.
3921     if (!renderer().hasOverflowClip())
3922         return;
3923 
3924     if (!showsOverflowControls())
3925         return;
3926 
3927     // Overlay scrollbars paint in a second pass through the layer tree so that they will paint
3928     // on top of everything else. If this is the normal painting pass, paintingOverlayControls
3929     // will be false, and we should just tell the root layer that there are overlay scrollbars
3930     // that need to be painted. That will cause the second pass through the layer tree to run,
3931     // and we&#39;ll paint the scrollbars then. In the meantime, cache tx and ty so that the
3932     // second pass doesn&#39;t need to re-enter the RenderTree to get it right.
3933     if (hasOverlayScrollbars() &amp;&amp; !paintingOverlayControls) {
3934         m_cachedOverlayScrollbarOffset = paintOffset;
3935 
3936         // It&#39;s not necessary to do the second pass if the scrollbars paint into layers.
3937         if ((m_hBar &amp;&amp; layerForHorizontalScrollbar()) || (m_vBar &amp;&amp; layerForVerticalScrollbar()))
3938             return;
3939         IntRect localDamgeRect = damageRect;
3940         localDamgeRect.moveBy(-paintOffset);
3941         if (!overflowControlsIntersectRect(localDamgeRect))
3942             return;
3943 
3944         RenderLayer* paintingRoot = enclosingCompositingLayer();
3945         if (!paintingRoot)
3946             paintingRoot = renderer().view().layer();
3947 
3948         paintingRoot-&gt;setContainsDirtyOverlayScrollbars(true);
3949         return;
3950     }
3951 
3952     // This check is required to avoid painting custom CSS scrollbars twice.
3953     if (paintingOverlayControls &amp;&amp; !hasOverlayScrollbars())
3954         return;
3955 
3956     IntPoint adjustedPaintOffset = paintOffset;
3957     if (paintingOverlayControls)
3958         adjustedPaintOffset = m_cachedOverlayScrollbarOffset;
3959 
3960     // Move the scrollbar widgets if necessary.  We normally move and resize widgets during layout, but sometimes
3961     // widgets can move without layout occurring (most notably when you scroll a document that
3962     // contains fixed positioned elements).
3963     positionOverflowControls(toIntSize(adjustedPaintOffset));
3964 
3965     // Now that we&#39;re sure the scrollbars are in the right place, paint them.
3966     if (m_hBar &amp;&amp; !layerForHorizontalScrollbar())
3967         m_hBar-&gt;paint(context, damageRect);
3968     if (m_vBar &amp;&amp; !layerForVerticalScrollbar())
3969         m_vBar-&gt;paint(context, damageRect);
3970 
3971     if (layerForScrollCorner())
3972         return;
3973 
3974     // We fill our scroll corner with white if we have a scrollbar that doesn&#39;t run all the way up to the
3975     // edge of the box.
3976     paintScrollCorner(context, adjustedPaintOffset, damageRect);
3977 
3978     // Paint our resizer last, since it sits on top of the scroll corner.
3979     paintResizer(context, adjustedPaintOffset, damageRect);
3980 }
3981 
3982 void RenderLayer::paintScrollCorner(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect)
3983 {
3984     IntRect absRect = scrollCornerRect();
3985     absRect.moveBy(paintOffset);
3986     if (!absRect.intersects(damageRect))
3987         return;
3988 
3989     if (context.invalidatingControlTints()) {
3990         updateScrollCornerStyle();
3991         return;
3992     }
3993 
3994     if (m_scrollCorner) {
3995         m_scrollCorner-&gt;paintIntoRect(context, paintOffset, absRect);
3996         return;
3997     }
3998 
3999     // We don&#39;t want to paint a corner if we have overlay scrollbars, since we need
4000     // to see what is behind it.
4001     if (!hasOverlayScrollbars())
4002         ScrollbarTheme::theme().paintScrollCorner(context, absRect);
4003 }
4004 
4005 void RenderLayer::drawPlatformResizerImage(GraphicsContext&amp; context, const LayoutRect&amp; resizerCornerRect)
4006 {
4007     RefPtr&lt;Image&gt; resizeCornerImage;
4008     FloatSize cornerResizerSize;
4009     if (renderer().document().deviceScaleFactor() &gt;= 2) {
4010         static NeverDestroyed&lt;Image*&gt; resizeCornerImageHiRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner@2x&quot;).leakRef());
4011         resizeCornerImage = resizeCornerImageHiRes;
4012         cornerResizerSize = resizeCornerImage-&gt;size();
4013         cornerResizerSize.scale(0.5f);
4014     } else {
4015         static NeverDestroyed&lt;Image*&gt; resizeCornerImageLoRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner&quot;).leakRef());
4016         resizeCornerImage = resizeCornerImageLoRes;
4017         cornerResizerSize = resizeCornerImage-&gt;size();
4018     }
4019 
4020     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
4021         context.save();
4022         context.translate(resizerCornerRect.x() + cornerResizerSize.width(), resizerCornerRect.y() + resizerCornerRect.height() - cornerResizerSize.height());
4023         context.scale(FloatSize(-1.0, 1.0));
4024         if (resizeCornerImage)
4025             context.drawImage(*resizeCornerImage, FloatRect(FloatPoint(), cornerResizerSize));
4026         context.restore();
4027         return;
4028     }
4029 
4030     if (!resizeCornerImage)
4031         return;
4032     FloatRect imageRect = snapRectToDevicePixels(LayoutRect(resizerCornerRect.maxXMaxYCorner() - cornerResizerSize, cornerResizerSize), renderer().document().deviceScaleFactor());
4033     context.drawImage(*resizeCornerImage, imageRect);
4034 }
4035 
4036 void RenderLayer::paintResizer(GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; damageRect)
4037 {
4038     if (renderer().style().resize() == Resize::None)
4039         return;
4040 
4041     RenderBox* box = renderBox();
4042     ASSERT(box);
4043 
4044     LayoutRect absRect = resizerCornerRect(*this, box-&gt;borderBoxRect());
4045     absRect.moveBy(paintOffset);
4046     if (!absRect.intersects(damageRect))
4047         return;
4048 
4049     if (context.invalidatingControlTints()) {
4050         updateResizerStyle();
4051         return;
4052     }
4053 
4054     if (m_resizer) {
4055         m_resizer-&gt;paintIntoRect(context, paintOffset, absRect);
4056         return;
4057     }
4058 
4059     drawPlatformResizerImage(context, absRect);
4060 
4061     // Draw a frame around the resizer (1px grey line) if there are any scrollbars present.
4062     // Clipping will exclude the right and bottom edges of this frame.
4063     if (!hasOverlayScrollbars() &amp;&amp; (m_vBar || m_hBar)) {
4064         GraphicsContextStateSaver stateSaver(context);
4065         context.clip(absRect);
4066         LayoutRect largerCorner = absRect;
4067         largerCorner.setSize(LayoutSize(largerCorner.width() + 1_lu, largerCorner.height() + 1_lu));
4068         context.setStrokeColor(Color(makeRGB(217, 217, 217)));
4069         context.setStrokeThickness(1.0f);
4070         context.setFillColor(Color::transparent);
4071         context.drawRect(snappedIntRect(largerCorner));
4072     }
4073 }
4074 
4075 bool RenderLayer::isPointInResizeControl(const IntPoint&amp; absolutePoint) const
4076 {
4077     if (!canResize())
4078         return false;
4079 
4080     RenderBox* box = renderBox();
4081     ASSERT(box);
4082 
4083     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
4084 
4085     IntRect localBounds(IntPoint(), snappedIntRect(box-&gt;frameRect()).size());
4086     return resizerCornerRect(*this, localBounds).contains(localPoint);
4087 }
4088 
4089 bool RenderLayer::hitTestOverflowControls(HitTestResult&amp; result, const IntPoint&amp; localPoint)
4090 {
4091     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
4092         return false;
4093 
4094     RenderBox* box = renderBox();
4095     ASSERT(box);
4096 
4097     IntRect resizeControlRect;
4098     if (renderer().style().resize() != Resize::None) {
4099         resizeControlRect = snappedIntRect(resizerCornerRect(*this, box-&gt;borderBoxRect()));
4100         if (resizeControlRect.contains(localPoint))
4101             return true;
4102     }
4103 
4104     int resizeControlSize = std::max(resizeControlRect.height(), 0);
4105 
4106     // FIXME: We should hit test the m_scrollCorner and pass it back through the result.
4107 
4108     if (m_vBar &amp;&amp; m_vBar-&gt;shouldParticipateInHitTesting()) {
4109         LayoutRect vBarRect(verticalScrollbarStart(0, box-&gt;width()),
4110                             box-&gt;borderTop(),
4111                             m_vBar-&gt;width(),
4112                             box-&gt;height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - (m_hBar ? m_hBar-&gt;height() : resizeControlSize));
4113         if (vBarRect.contains(localPoint)) {
4114             result.setScrollbar(m_vBar.get());
4115             return true;
4116         }
4117     }
4118 
4119     resizeControlSize = std::max(resizeControlRect.width(), 0);
4120     if (m_hBar &amp;&amp; m_hBar-&gt;shouldParticipateInHitTesting()) {
4121         LayoutRect hBarRect(horizontalScrollbarStart(0),
4122                             box-&gt;height() - box-&gt;borderBottom() - m_hBar-&gt;height(),
4123                             box-&gt;width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - (m_vBar ? m_vBar-&gt;width() : resizeControlSize),
4124                             m_hBar-&gt;height());
4125         if (hBarRect.contains(localPoint)) {
4126             result.setScrollbar(m_hBar.get());
4127             return true;
4128         }
4129     }
4130 
4131     return false;
4132 }
4133 
4134 bool RenderLayer::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier)
4135 {
4136     return ScrollableArea::scroll(direction, granularity, multiplier);
4137 }
4138 
4139 void RenderLayer::paint(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot, OptionSet&lt;PaintLayerFlag&gt; paintFlags, SecurityOriginPaintPolicy paintPolicy)
4140 {
4141     OverlapTestRequestMap overlapTestRequests;
4142 
4143     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, subpixelOffset, subtreePaintRoot, &amp;overlapTestRequests, paintPolicy == SecurityOriginPaintPolicy::AccessibleOriginOnly);
4144     paintLayer(context, paintingInfo, paintFlags);
4145 
4146     for (auto&amp; widget : overlapTestRequests.keys())
4147         widget-&gt;setOverlapTestResult(false);
4148 }
4149 
4150 void RenderLayer::paintOverlayScrollbars(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot)
4151 {
4152     if (!m_containsDirtyOverlayScrollbars)
4153         return;
4154 
4155     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, LayoutSize(), subtreePaintRoot);
4156     paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
4157 
4158     m_containsDirtyOverlayScrollbars = false;
4159 }
4160 
4161 void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
4162 {
4163     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4164     bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
4165     if (needsClipping || clipRect.affectedByRadius())
4166         context.save();
4167 
4168     if (needsClipping) {
4169         LayoutRect adjustedClipRect = clipRect.rect();
4170         adjustedClipRect.move(paintingInfo.subpixelOffset);
4171         auto snappedClipRect = snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor);
4172         context.clip(snappedClipRect);
4173 
4174         if (paintingInfo.eventRegionContext)
4175             paintingInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(snappedClipRect));
4176     }
4177 
4178     if (clipRect.affectedByRadius()) {
4179         // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
4180         // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
4181         // containing block chain so we check that also.
4182         for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
4183             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; ancestorLayerIsInContainingBlockChain(*layer)) {
4184                 LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
4185                 adjustedClipRect.move(paintingInfo.subpixelOffset);
4186                 FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
4187                 if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
4188                     context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
4189                 else
4190                     context.clipRoundedRect(roundedRect);
4191             }
4192 
4193             if (layer == paintingInfo.rootLayer)
4194                 break;
4195         }
4196     }
4197 }
4198 
4199 void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
4200 {
4201     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius()) {
4202         context.restore();
4203 
4204         if (paintingInfo.eventRegionContext)
4205             paintingInfo.eventRegionContext-&gt;popClip();
4206     }
4207 }
4208 
4209 static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
4210 {
4211     if (overlapTestRequests.isEmpty())
4212         return;
4213 
4214     Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
4215     LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
4216     for (auto&amp; request : overlapTestRequests) {
4217         if (!boundingBox.intersects(request.value))
4218             continue;
4219 
4220         request.key-&gt;setOverlapTestResult(true);
4221         overlappedRequestClients.append(request.key);
4222     }
4223     for (auto* client : overlappedRequestClients)
4224         overlapTestRequests.remove(client);
4225 }
4226 
4227 static inline bool shouldDoSoftwarePaint(const RenderLayer* layer, bool paintingReflection)
4228 {
4229     return paintingReflection &amp;&amp; !layer-&gt;has3DTransform();
4230 }
4231 
4232 static inline bool shouldSuppressPaintingLayer(RenderLayer* layer)
4233 {
4234     if (layer-&gt;renderer().style().isNotFinal() &amp;&amp; !layer-&gt;isRenderViewLayer() &amp;&amp; !layer-&gt;renderer().isDocumentElementRenderer())
4235         return true;
4236 
4237     // Avoid painting all layers if the document is in a state where visual updates aren&#39;t allowed.
4238     // A full repaint will occur in Document::setVisualUpdatesAllowed(bool) if painting is suppressed here.
4239     if (!layer-&gt;renderer().document().visualUpdatesAllowed())
4240         return true;
4241 
4242     return false;
4243 }
4244 
4245 static inline bool paintForFixedRootBackground(const RenderLayer* layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags)
4246 {
4247     return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
4248 }
4249 
4250 void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4251 {
4252     auto shouldContinuePaint = [&amp;] () {
4253         return backing()-&gt;paintsIntoWindow()
4254             || backing()-&gt;paintsIntoCompositedAncestor()
4255             || shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))
4256             || paintForFixedRootBackground(this, paintFlags);
4257     };
4258 
4259     auto paintsIntoDifferentCompositedDestination = [&amp;]() {
4260         if (paintsIntoProvidedBacking())
4261             return true;
4262 
4263         if (isComposited() &amp;&amp; !shouldContinuePaint())
4264             return true;
4265 
4266         return false;
4267     };
4268 
4269     if (paintsIntoDifferentCompositedDestination()) {
4270         if (!context.performingPaintInvalidation() &amp;&amp; !(paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
4271             return;
4272 
4273         paintFlags.add(PaintLayerTemporaryClipRects);
4274     }
4275 
4276     if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {
4277         // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
4278         // unless their position or viewport size is changed.
4279         ASSERT(renderer().isFixedPositioned());
4280         return;
4281     }
4282 
4283     paintLayerWithEffects(context, paintingInfo, paintFlags);
4284 }
4285 
4286 void RenderLayer::paintLayerWithEffects(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4287 {
4288     // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
4289     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
4290         return;
4291 
4292     if (shouldSuppressPaintingLayer(this))
4293         return;
4294 
4295     // If this layer is totally invisible then there is nothing to paint.
4296     if (!renderer().opacity())
4297         return;
4298 
4299     if (paintsWithTransparency(paintingInfo.paintBehavior))
4300         paintFlags.add(PaintLayerHaveTransparency);
4301 
4302     // PaintLayerAppliedTransform is used in RenderReplica, to avoid applying the transform twice.
4303     if (paintsWithTransform(paintingInfo.paintBehavior) &amp;&amp; !(paintFlags &amp; PaintLayerAppliedTransform)) {
4304         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
4305         // If the transform can&#39;t be inverted, then don&#39;t paint anything.
4306         if (!layerTransform.isInvertible())
4307             return;
4308 
4309         // If we have a transparency layer enclosing us and we are the root of a transform, then we need to establish the transparency
4310         // layer from the parent now, assuming there is a parent
4311         if (paintFlags &amp; PaintLayerHaveTransparency) {
4312             if (parent())
4313                 parent()-&gt;beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
4314             else
4315                 beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
4316         }
4317 
4318         if (enclosingPaginationLayer(ExcludeCompositedPaginatedLayers)) {
4319             paintTransformedLayerIntoFragments(context, paintingInfo, paintFlags);
4320             return;
4321         }
4322 
4323         // Make sure the parent&#39;s clip rects have been calculated.
4324         ClipRect clipRect = paintingInfo.paintDirtyRect;
4325         if (parent()) {
4326             ClipRectsContext clipRectsContext(paintingInfo.rootLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4327                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4328             clipRect = backgroundClipRect(clipRectsContext);
4329             clipRect.intersect(paintingInfo.paintDirtyRect);
4330 
4331             // Push the parent coordinate space&#39;s clip.
4332             parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4333         }
4334 
4335         paintLayerByApplyingTransform(context, paintingInfo, paintFlags);
4336 
4337         // Restore the clip.
4338         if (parent())
4339             parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4340 
4341         return;
4342     }
4343 
4344     paintLayerContentsAndReflection(context, paintingInfo, paintFlags);
4345 }
4346 
4347 void RenderLayer::paintLayerContentsAndReflection(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4348 {
4349     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4350 
4351     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4352 
4353     // Paint the reflection first if we have one.
4354     if (m_reflection &amp;&amp; !m_paintingInsideReflection) {
4355         // Mark that we are now inside replica painting.
4356         m_paintingInsideReflection = true;
4357         reflectionLayer()-&gt;paintLayer(context, paintingInfo, localPaintFlags | PaintLayerPaintingReflection);
4358         m_paintingInsideReflection = false;
4359     }
4360 
4361     localPaintFlags.add(paintLayerPaintingCompositingAllPhasesFlags());
4362     paintLayerContents(context, paintingInfo, localPaintFlags);
4363 }
4364 
4365 bool RenderLayer::setupFontSubpixelQuantization(GraphicsContext&amp; context, bool&amp; didQuantizeFonts)
4366 {
4367     if (context.paintingDisabled())
4368         return false;
4369 
4370     bool scrollingOnMainThread = true;
4371 #if ENABLE(ASYNC_SCROLLING)
4372     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
4373         scrollingOnMainThread = scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(renderer().view().frameView());
4374 #endif
4375 
4376     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4377     // things on the scrolling thread.
4378     bool contentsScrollByPainting = (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling()) || (renderer().frame().ownerElement());
4379     bool isZooming = !page().chrome().client().hasStablePageScaleFactor();
4380     if (scrollingOnMainThread || contentsScrollByPainting || isZooming) {
4381         didQuantizeFonts = context.shouldSubpixelQuantizeFonts();
4382         context.setShouldSubpixelQuantizeFonts(false);
4383         return true;
4384     }
4385     return false;
4386 }
4387 
4388 Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
4389 {
4390     const RenderStyle&amp; style = renderer().style();
4391     float deviceSaleFactor = renderer().document().deviceScaleFactor();
4392 
4393     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath())) {
4394         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style.clipPath());
4395         FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), clipPath.referenceBox(), offsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4396 
4397         windRule = clipPath.windRule();
4398         return clipPath.pathForReferenceRect(referenceBox);
4399     }
4400 
4401     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4402 
4403         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4404 
4405         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4406         shapeRect.move(offsetFromRoot);
4407 
4408         windRule = WindRule::NonZero;
4409         return clipPath.pathForReferenceRect(shapeRect);
4410     }
4411 
4412     return Path();
4413 }
4414 
4415 bool RenderLayer::setupClipPath(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4416 {
<a name="1" id="anc1"></a><span class="line-modified">4417     if (!renderer().hasClipPath() || context.paintingDisabled() || paintingInfo.paintDirtyRect.isEmpty())</span>
4418         return false;
4419 
4420     if (!rootRelativeBoundsComputed) {
4421         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4422         rootRelativeBoundsComputed = true;
4423     }
4424 
4425     // SVG elements get clipped in SVG code.
4426     if (is&lt;RenderSVGRoot&gt;(renderer()))
4427         return false;
4428 
4429     auto&amp; style = renderer().style();
4430     LayoutSize paintingOffsetFromRoot = LayoutSize(snapSizeToDevicePixel(offsetFromRoot + paintingInfo.subpixelOffset, LayoutPoint(), renderer().document().deviceScaleFactor()));
4431     ASSERT(style.clipPath());
4432     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath()) || (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer()))) {
4433         WindRule windRule;
4434         Path path = computeClipPath(paintingOffsetFromRoot, rootRelativeBounds, windRule);
4435         context.save();
4436         context.clipPath(path, windRule);
4437         return true;
4438     }
4439 
4440     if (style.clipPath()-&gt;type() == ClipPathOperation::Reference) {
4441         ReferenceClipPathOperation* referenceClipPathOperation = static_cast&lt;ReferenceClipPathOperation*&gt;(style.clipPath());
4442         Element* element = renderer().document().getElementById(referenceClipPathOperation-&gt;fragment());
4443         if (element &amp;&amp; element-&gt;renderer() &amp;&amp; is&lt;RenderSVGResourceClipper&gt;(element-&gt;renderer())) {
4444             context.save();
<a name="2" id="anc2"></a><span class="line-modified">4445             auto referenceBox = snapRectToDevicePixels(rootRelativeBounds, renderer().document().deviceScaleFactor());</span>
<span class="line-modified">4446             auto offset = referenceBox.location();</span>

4447             context.translate(offset);
<a name="3" id="anc3"></a><span class="line-modified">4448             FloatRect svgReferenceBox { {}, referenceBox.size() };</span>
<span class="line-modified">4449             downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer()).applyClippingToContext(renderer(), svgReferenceBox, context);</span>
<span class="line-modified">4450             context.translate(-offset);</span>
4451             return true;
4452         }
4453     }
4454 
4455     return false;
4456 }
4457 
4458 RenderLayerFilters* RenderLayer::filtersForPainting(GraphicsContext&amp; context, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
4459 {
4460     if (context.paintingDisabled())
4461         return nullptr;
4462 
4463     if (paintFlags &amp; PaintLayerPaintingOverlayScrollbars)
4464         return nullptr;
4465 
4466     if (!paintsWithFilters())
4467         return nullptr;
4468 
4469     if (m_filters &amp;&amp; m_filters-&gt;filter())
4470         return m_filters.get();
4471 
4472     return nullptr;
4473 }
4474 
4475 GraphicsContext* RenderLayer::setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4476 {
4477     auto* paintingFilters = filtersForPainting(destinationContext, paintFlags);
4478     if (!paintingFilters)
4479         return nullptr;
4480 
4481     LayoutRect filterRepaintRect = paintingFilters-&gt;dirtySourceRect();
4482     filterRepaintRect.move(offsetFromRoot);
4483 
4484     if (!rootRelativeBoundsComputed) {
4485         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4486         rootRelativeBoundsComputed = true;
4487     }
4488 
4489     GraphicsContext* filterContext = paintingFilters-&gt;beginFilterEffect(destinationContext, enclosingIntRect(rootRelativeBounds), enclosingIntRect(paintingInfo.paintDirtyRect), enclosingIntRect(filterRepaintRect));
4490     if (!filterContext)
4491         return nullptr;
4492 
4493     paintingInfo.paintDirtyRect = paintingFilters-&gt;repaintRect();
4494 
4495     // If the filter needs the full source image, we need to avoid using the clip rectangles.
4496     // Otherwise, if for example this layer has overflow:hidden, a drop shadow will not compute correctly.
4497     // Note that we will still apply the clipping on the final rendering of the filter.
4498     paintingInfo.clipToDirtyRect = !paintingFilters-&gt;hasFilterThatMovesPixels();
4499 
4500     paintingInfo.requireSecurityOriginAccessForWidgets = paintingFilters-&gt;hasFilterThatShouldBeRestrictedBySecurityOrigin();
4501 
4502     return filterContext;
4503 }
4504 
4505 void RenderLayer::applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp; paintingInfo, const LayerFragments&amp; layerFragments)
4506 {
4507     // FIXME: Handle more than one fragment.
4508     ClipRect backgroundRect = layerFragments.isEmpty() ? ClipRect() : layerFragments[0].backgroundRect;
4509     clipToRect(originalContext, paintingInfo, backgroundRect);
4510     m_filters-&gt;applyFilterEffect(originalContext);
4511     restoreClip(originalContext, paintingInfo, backgroundRect);
4512 }
4513 
4514 void RenderLayer::paintLayerContents(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4515 {
4516     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4517 
4518     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4519     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4520     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4521     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4522     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4523     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4524     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4525     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
4526     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);
4527     // Outline always needs to be painted even if we have no visible content. Also,
4528     // the outline is painted in the background phase during composited scrolling.
4529     // If it were painted in the foreground phase, it would move with the scrolled
4530     // content. When not composited scrolling, the outline is painted in the
4531     // foreground phase. Since scrolled contents are moved by repainting in this
4532     // case, the outline won&#39;t get &#39;dragged along&#39;.
4533     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion
4534         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())
4535         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4536         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
4537     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;
4538 
4539     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer()) {
4540         // If beginTransparencyLayers was called prior to this, ensure the transparency state is cleaned up before returning.
4541         if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {
4542             context.endTransparencyLayer();
4543             context.restore();
4544             m_usedTransparency = false;
4545         }
4546 
4547         return;
4548     }
4549 
4550     updateLayerListsIfNeeded();
4551 
4552     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4553     LayoutRect rootRelativeBounds;
4554     bool rootRelativeBoundsComputed = false;
4555 
4556     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4557     // things on the scrolling thread.
4558     bool didQuantizeFonts = true;
4559     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4560 
4561     // Apply clip-path to context.
4562     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4563     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4564         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4565 
4566     bool hasClipPath = false;
4567     if (shouldApplyClipPath(paintingInfo.paintBehavior, localPaintFlags))
4568         hasClipPath = setupClipPath(context, paintingInfo, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4569 
4570     bool selectionAndBackgroundsOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);
4571     bool selectionOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);
4572 
4573     SinglePaintFrequencyTracking singlePaintFrequencyTracking(m_paintFrequencyTracker, shouldPaintContent);
4574 
4575     LayerFragments layerFragments;
4576     RenderObject* subtreePaintRootForRenderer = nullptr;
4577 
4578     { // Scope for filter-related state changes.
4579         LayerPaintingInfo localPaintingInfo(paintingInfo);
4580         GraphicsContext* filterContext = setupFilters(context, localPaintingInfo, paintFlags, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4581         if (filterContext &amp;&amp; haveTransparency) {
4582             // If we have a filter and transparency, we have to eagerly start a transparency layer here, rather than risk a child layer lazily starts one with the wrong context.
4583             beginTransparencyLayers(context, localPaintingInfo, paintingInfo.paintDirtyRect);
4584         }
4585         GraphicsContext&amp; currentContext = filterContext ? *filterContext : context;
4586 
4587         // If this layer&#39;s renderer is a child of the subtreePaintRoot, we render unconditionally, which
4588         // is done by passing a nil subtreePaintRoot down to our renderer (as if no subtreePaintRoot was ever set).
4589         // Otherwise, our renderer tree may or may not contain the subtreePaintRoot root, so we pass that root along
4590         // so it will be tested against as we descend through the renderers.
4591         if (localPaintingInfo.subtreePaintRoot &amp;&amp; !renderer().isDescendantOf(localPaintingInfo.subtreePaintRoot))
4592             subtreePaintRootForRenderer = localPaintingInfo.subtreePaintRoot;
4593 
4594         if (localPaintingInfo.overlapTestRequests &amp;&amp; isSelfPaintingLayer)
4595             performOverlapTests(*localPaintingInfo.overlapTestRequests, localPaintingInfo.rootLayer, this);
4596 
4597         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4598         if (localPaintFlags &amp; PaintLayerPaintingSkipRootBackground)
4599             paintBehavior.add(PaintBehavior::SkipRootBackground);
4600         else if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly)
4601             paintBehavior.add(PaintBehavior::RootBackgroundOnly);
4602 
4603         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4604             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4605 
4606         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4607             paintBehavior.add(PaintBehavior::Snapshotting);
4608 
4609         if ((paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint) &amp;&amp; isRenderViewLayer())
4610             paintBehavior.add(PaintBehavior::TileFirstPaint);
4611 
4612         if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4613             paintBehavior.add(PaintBehavior::ExcludeSelection);
4614 
4615         LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
4616         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars || isCollectingEventRegion) {
4617             // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
4618             // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
4619             // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
4620             if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
4621                 // We can turn clipping back by requesting full repaint for the overflow area.
4622                 localPaintingInfo.clipToDirtyRect = true;
4623                 paintDirtyRect = clipRectRelativeToAncestor(localPaintingInfo.rootLayer, offsetFromRoot, LayoutRect::infiniteRect());
4624             }
4625             collectFragments(layerFragments, localPaintingInfo.rootLayer, paintDirtyRect, ExcludeCompositedPaginatedLayers,
4626                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4627                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4628             updatePaintingInfoForFragments(layerFragments, localPaintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4629         }
4630 
4631         if (isPaintingCompositedBackground) {
4632             // Paint only the backgrounds for all of the fragments of the layer.
4633             if (shouldPaintContent &amp;&amp; !selectionOnly) {
4634                 paintBackgroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4635                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4636             }
4637         }
4638 
4639         // Now walk the sorted list of children with negative z-indices.
4640         if ((isPaintingScrollingContent &amp;&amp; isPaintingOverflowContents) || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground))
4641             paintList(negativeZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4642 
4643         if (isPaintingCompositedForeground) {
4644             if (shouldPaintContent) {
4645                 paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4646                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4647             }
4648         }
4649 
4650         if (isCollectingEventRegion)
4651             collectEventRegionForFragments(layerFragments, currentContext, localPaintingInfo);
4652 
4653         if (shouldPaintOutline)
4654             paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4655 
4656         if (isPaintingCompositedForeground) {
4657             // Paint any child layers that have overflow.
4658             paintList(normalFlowLayers(), currentContext, localPaintingInfo, localPaintFlags);
4659 
4660             // Now walk the sorted list of children with positive z-indices.
4661             paintList(positiveZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4662         }
4663 
4664         if (isPaintingOverlayScrollbars &amp;&amp; hasScrollbars())
4665             paintOverflowControlsForFragments(layerFragments, currentContext, localPaintingInfo);
4666 
4667         if (filterContext) {
4668             // When we called collectFragments() last time, paintDirtyRect was reset to represent the filter bounds.
4669             // Now we need to compute the backgroundRect uncontaminated by filters, in order to clip the filtered result.
4670             // Note that we also use paintingInfo here, not localPaintingInfo which filters also contaminated.
4671             LayerFragments layerFragments;
4672             collectFragments(layerFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4673                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4674                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4675             updatePaintingInfoForFragments(layerFragments, paintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4676 
4677             applyFilters(context, paintingInfo, layerFragments);
4678         }
4679     }
4680 
4681     if (shouldPaintContent &amp;&amp; !(selectionOnly || selectionAndBackgroundsOnly)) {
4682         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4683         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4684             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4685 
4686         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4687             paintBehavior.add(PaintBehavior::Snapshotting);
4688 
4689         if (paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4690             paintBehavior.add(PaintBehavior::TileFirstPaint);
4691 
4692         if (shouldPaintMask(paintingInfo.paintBehavior, localPaintFlags)) {
4693             // Paint the mask for the fragments.
4694             paintMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4695         }
4696 
4697         if (!(paintFlags &amp; PaintLayerPaintingCompositingMaskPhase) &amp;&amp; (paintFlags &amp; PaintLayerPaintingCompositingClipPathPhase)) {
4698             // Re-use paintChildClippingMaskForFragments to paint black for the compositing clipping mask.
4699             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4700         }
4701 
4702         if (localPaintFlags &amp; PaintLayerPaintingChildClippingMaskPhase) {
4703             // Paint the border radius mask for the fragments.
4704             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4705         }
4706     }
4707 
4708     // End our transparency layer
4709     if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {
4710         context.endTransparencyLayer();
4711         context.restore();
4712         m_usedTransparency = false;
4713     }
4714 
4715     // Re-set this to whatever it was before we painted the layer.
4716     if (needToAdjustSubpixelQuantization)
4717         context.setShouldSubpixelQuantizeFonts(didQuantizeFonts);
4718 
4719     if (hasClipPath)
4720         context.restore();
4721 }
4722 
4723 void RenderLayer::paintLayerByApplyingTransform(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; translationOffset)
4724 {
4725     // This involves subtracting out the position of the layer in our current coordinate space, but preserving
4726     // the accumulated error for sub-pixel layout.
4727     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4728     LayoutSize offsetFromParent = offsetFromAncestor(paintingInfo.rootLayer);
4729     offsetFromParent += translationOffset;
4730     TransformationMatrix transform(renderableTransform(paintingInfo.paintBehavior));
4731     // Add the subpixel accumulation to the current layer&#39;s offset so that we can always snap the translateRight value to where the renderer() is supposed to be painting.
4732     LayoutSize offsetForThisLayer = offsetFromParent + paintingInfo.subpixelOffset;
4733     FloatSize devicePixelSnappedOffsetForThisLayer = toFloatSize(roundPointToDevicePixels(toLayoutPoint(offsetForThisLayer), deviceScaleFactor));
4734     // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
4735     // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
4736     // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
4737     transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
4738     // Apply the transform.
4739     auto oldTransform = context.getCTM();
4740     auto affineTransform = transform.toAffineTransform();
4741     context.concatCTM(affineTransform);
4742 
4743     if (paintingInfo.eventRegionContext)
4744         paintingInfo.eventRegionContext-&gt;pushTransform(affineTransform);
4745 
4746     // Now do a paint with the root layer shifted to be us.
4747     LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
4748     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4749     transformedPaintingInfo.rootLayer = this;
4750     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4751     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4752     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
4753 
4754     if (paintingInfo.eventRegionContext)
4755         paintingInfo.eventRegionContext-&gt;popTransform();
4756 
4757     context.setCTM(oldTransform);
4758 }
4759 
4760 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4761 {
4762     if (layerIterator.begin() == layerIterator.end())
4763         return;
4764 
4765     if (!hasSelfPaintingLayerDescendant())
4766         return;
4767 
4768 #if ASSERT_ENABLED
4769     LayerListMutationDetector mutationChecker(*this);
4770 #endif
4771 
4772     for (auto* childLayer : layerIterator)
4773         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4774 }
4775 
4776 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4777 {
4778     // If we don&#39;t have an enclosing layer, or if the root layer is the same as the enclosing layer,
4779     // then just return the enclosing pagination layer (it will be 0 in the former case and the rootLayer in the latter case).
4780     RenderLayer* paginationLayer = enclosingPaginationLayer(mode);
4781     if (!paginationLayer || rootLayer == paginationLayer)
4782         return paginationLayer;
4783 
4784     // Walk up the layer tree and see which layer we hit first. If it&#39;s the root, then the enclosing pagination
4785     // layer isn&#39;t in our subtree and we return nullptr. If we hit the enclosing pagination layer first, then
4786     // we can return it.
4787     for (const RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
4788         if (layer == rootLayer)
4789             return nullptr;
4790         if (layer == paginationLayer)
4791             return paginationLayer;
4792     }
4793 
4794     // This should never be reached, since an enclosing layer should always either be the rootLayer or be
4795     // our enclosing pagination layer.
4796     ASSERT_NOT_REACHED();
4797     return nullptr;
4798 }
4799 
4800 void RenderLayer::collectFragments(LayerFragments&amp; fragments, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect, PaginationInclusionMode inclusionMode,
4801     ClipRectsType clipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip respectOverflowClip, const LayoutSize&amp; offsetFromRoot,
4802     const LayoutRect* layerBoundingBox, ShouldApplyRootOffsetToFragments applyRootOffsetToFragments)
4803 {
4804     RenderLayer* paginationLayer = enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4805     if (!paginationLayer || hasTransform()) {
4806         // For unpaginated layers, there is only one fragment.
4807         LayerFragment fragment;
4808         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4809         calculateRects(clipRectsContext, dirtyRect, fragment.layerBounds, fragment.backgroundRect, fragment.foregroundRect, offsetFromRoot);
4810         fragments.append(fragment);
4811         return;
4812     }
4813 
4814     // Compute our offset within the enclosing pagination layer.
4815     LayoutSize offsetWithinPaginatedLayer = offsetFromAncestor(paginationLayer);
4816 
4817     // Calculate clip rects relative to the enclosingPaginationLayer. The purpose of this call is to determine our bounds clipped to intermediate
4818     // layers between us and the pagination context. It&#39;s important to minimize the number of fragments we need to create and this helps with that.
4819     ClipRectsContext paginationClipRectsContext(paginationLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4820     LayoutRect layerBoundsInFragmentedFlow;
4821     ClipRect backgroundRectInFragmentedFlow;
4822     ClipRect foregroundRectInFragmentedFlow;
4823     calculateRects(paginationClipRectsContext, LayoutRect::infiniteRect(), layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow,
4824         offsetWithinPaginatedLayer);
4825 
4826     // Take our bounding box within the flow thread and clip it.
4827     LayoutRect layerBoundingBoxInFragmentedFlow = layerBoundingBox ? *layerBoundingBox : boundingBox(paginationLayer, offsetWithinPaginatedLayer);
4828     layerBoundingBoxInFragmentedFlow.intersect(backgroundRectInFragmentedFlow.rect());
4829 
4830     auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
4831     RenderLayer* parentPaginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4832     LayerFragments ancestorFragments;
4833     if (parentPaginationLayer) {
4834         // Compute a bounding box accounting for fragments.
4835         LayoutRect layerFragmentBoundingBoxInParentPaginationLayer = enclosingFragmentedFlow.fragmentsBoundingBox(layerBoundingBoxInFragmentedFlow);
4836 
4837         // Convert to be in the ancestor pagination context&#39;s coordinate space.
4838         LayoutSize offsetWithinParentPaginatedLayer = paginationLayer-&gt;offsetFromAncestor(parentPaginationLayer);
4839         layerFragmentBoundingBoxInParentPaginationLayer.move(offsetWithinParentPaginatedLayer);
4840 
4841         // Now collect ancestor fragments.
4842         parentPaginationLayer-&gt;collectFragments(ancestorFragments, rootLayer, dirtyRect, inclusionMode, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip,
4843             offsetFromAncestor(rootLayer), &amp;layerFragmentBoundingBoxInParentPaginationLayer, ApplyRootOffsetToFragments);
4844 
4845         if (ancestorFragments.isEmpty())
4846             return;
4847 
4848         for (auto&amp; ancestorFragment : ancestorFragments) {
4849             // Shift the dirty rect into flow thread coordinates.
4850             LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4851             dirtyRectInFragmentedFlow.move(-offsetWithinParentPaginatedLayer - ancestorFragment.paginationOffset);
4852 
4853             size_t oldSize = fragments.size();
4854 
4855             // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4856             // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4857             enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4858 
4859             size_t newSize = fragments.size();
4860 
4861             if (oldSize == newSize)
4862                 continue;
4863 
4864             for (size_t i = oldSize; i &lt; newSize; ++i) {
4865                 LayerFragment&amp; fragment = fragments.at(i);
4866 
4867                 // Set our four rects with all clipping applied that was internal to the flow thread.
4868                 fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4869 
4870                 // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4871                 fragment.moveBy(toLayoutPoint(ancestorFragment.paginationOffset + fragment.paginationOffset + offsetWithinParentPaginatedLayer));
4872 
4873                 // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4874                 // properly clipped by the overflow.
4875                 fragment.intersect(ancestorFragment.paginationClip);
4876 
4877                 // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4878                 // clip, so the column clip ends up being all we apply.
4879                 fragment.intersect(fragment.paginationClip);
4880 
4881                 if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4882                     fragment.paginationOffset = fragment.paginationOffset + offsetWithinParentPaginatedLayer;
4883             }
4884         }
4885 
4886         return;
4887     }
4888 
4889     // Shift the dirty rect into flow thread coordinates.
4890     LayoutSize offsetOfPaginationLayerFromRoot = enclosingPaginationLayer(inclusionMode)-&gt;offsetFromAncestor(rootLayer);
4891     LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4892     dirtyRectInFragmentedFlow.move(-offsetOfPaginationLayerFromRoot);
4893 
4894     // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4895     // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4896     enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4897 
4898     if (fragments.isEmpty())
4899         return;
4900 
4901     // Get the parent clip rects of the pagination layer, since we need to intersect with that when painting column contents.
4902     ClipRect ancestorClipRect = dirtyRect;
4903     if (paginationLayer-&gt;parent()) {
4904         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4905         ancestorClipRect = paginationLayer-&gt;backgroundClipRect(clipRectsContext);
4906         ancestorClipRect.intersect(dirtyRect);
4907     }
4908 
4909     for (auto&amp; fragment : fragments) {
4910         // Set our four rects with all clipping applied that was internal to the flow thread.
4911         fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4912 
4913         // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4914         fragment.moveBy(toLayoutPoint(fragment.paginationOffset + offsetOfPaginationLayerFromRoot));
4915 
4916         // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4917         // properly clipped by the overflow.
4918         fragment.intersect(ancestorClipRect);
4919 
4920         // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4921         // clip, so the column clip ends up being all we apply.
4922         fragment.intersect(fragment.paginationClip);
4923 
4924         if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4925             fragment.paginationOffset = fragment.paginationOffset + offsetOfPaginationLayerFromRoot;
4926     }
4927 }
4928 
4929 void RenderLayer::updatePaintingInfoForFragments(LayerFragments&amp; fragments, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintLayerFlag&gt; localPaintFlags,
4930     bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot)
4931 {
4932     for (auto&amp; fragment : fragments) {
4933         fragment.shouldPaintContent = shouldPaintContent;
4934         if (this != localPaintingInfo.rootLayer || !(localPaintFlags &amp; PaintLayerPaintingOverflowContents)) {
4935             LayoutSize newOffsetFromRoot = offsetFromRoot + fragment.paginationOffset;
4936             fragment.shouldPaintContent &amp;= intersectsDamageRect(fragment.layerBounds, fragment.backgroundRect.rect(), localPaintingInfo.rootLayer, newOffsetFromRoot, fragment.hasBoundingBox ? &amp;fragment.boundingBox : 0);
4937         }
4938     }
4939 }
4940 
4941 void RenderLayer::paintTransformedLayerIntoFragments(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4942 {
4943     LayerFragments enclosingPaginationFragments;
4944     LayoutSize offsetOfPaginationLayerFromRoot;
4945     RenderLayer* paginatedLayer = enclosingPaginationLayer(ExcludeCompositedPaginatedLayers);
4946     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintingInfo.paintBehavior);
4947     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4948         (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4949         (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
4950 
4951     for (const auto&amp; fragment : enclosingPaginationFragments) {
4952         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
4953         // the enclosing pagination layer.
4954         LayoutRect clipRect = fragment.backgroundRect.rect();
4955 
4956         // Now compute the clips within a given fragment
4957         if (parent() != paginatedLayer) {
4958             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(paintingInfo.rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
4959 
4960             ClipRectsContext clipRectsContext(paginatedLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4961                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4962             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
4963             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
4964             clipRect.intersect(parentClipRect);
4965         }
4966 
4967         parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4968         paintLayerByApplyingTransform(context, paintingInfo, paintFlags, fragment.paginationOffset);
4969         parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4970     }
4971 }
4972 
4973 void RenderLayer::paintBackgroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
4974     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
4975     RenderObject* subtreePaintRootForRenderer)
4976 {
4977     for (const auto&amp; fragment : layerFragments) {
4978         if (!fragment.shouldPaintContent)
4979             continue;
4980 
4981         // Begin transparency layers lazily now that we know we have to paint something.
4982         if (haveTransparency)
4983             beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
4984 
4985         if (localPaintingInfo.clipToDirtyRect) {
4986             // Paint our background first, before painting any child layers.
4987             // Establish the clip used to paint our background.
4988             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Background painting will handle clipping to self.
4989         }
4990 
4991         // Paint the background.
4992         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
4993         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::BlockBackground, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4994         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4995 
4996         if (localPaintingInfo.clipToDirtyRect)
4997             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4998     }
4999 }
5000 
5001 void RenderLayer::paintForegroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
5002     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
5003     RenderObject* subtreePaintRootForRenderer)
5004 {
5005     // Begin transparency if we have something to paint.
5006     if (haveTransparency) {
5007         for (const auto&amp; fragment : layerFragments) {
5008             if (fragment.shouldPaintContent &amp;&amp; !fragment.foregroundRect.isEmpty()) {
5009                 beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
5010                 break;
5011             }
5012         }
5013     }
5014 
5015     OptionSet&lt;PaintBehavior&gt; localPaintBehavior;
5016     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceBlackText)
5017         localPaintBehavior = PaintBehavior::ForceBlackText;
5018     else if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceWhiteText)
5019         localPaintBehavior = PaintBehavior::ForceWhiteText;
5020     else
5021         localPaintBehavior = paintBehavior;
5022 
5023     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
5024         localPaintBehavior.add(PaintBehavior::ExcludeSelection);
5025 
5026     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
5027         localPaintBehavior.add(PaintBehavior::Snapshotting);
5028 
5029     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
5030         localPaintBehavior.add(PaintBehavior::TileFirstPaint);
5031 
5032     // Optimize clipping for the single fragment case.
5033     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() == 1 &amp;&amp; layerFragments[0].shouldPaintContent &amp;&amp; !layerFragments[0].foregroundRect.isEmpty();
5034     ClipRect clippedRect;
5035     if (shouldClip) {
5036         clippedRect = layerFragments[0].foregroundRect;
5037         clipToRect(context, localPaintingInfo, clippedRect);
5038     }
5039 
5040     // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
5041     // interleaving of the fragments to work properly.
5042     bool selectionOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);
5043     bool selectionAndBackgroundsOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);
5044 
5045     if (!selectionOnly)
5046         paintForegroundForFragmentsWithPhase(PaintPhase::ChildBlockBackgrounds, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5047 
5048     if (selectionOnly || selectionAndBackgroundsOnly)
5049         paintForegroundForFragmentsWithPhase(PaintPhase::Selection, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5050     else {
5051         paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5052         paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5053         paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5054     }
5055 
5056     if (shouldClip)
5057         restoreClip(context, localPaintingInfo, clippedRect);
5058 }
5059 
5060 void RenderLayer::paintForegroundForFragmentsWithPhase(PaintPhase phase, const LayerFragments&amp; layerFragments, GraphicsContext&amp; context,
5061     const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5062 {
5063     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() &gt; 1;
5064 
5065     for (const auto&amp; fragment : layerFragments) {
5066         if (!fragment.shouldPaintContent || fragment.foregroundRect.isEmpty())
5067             continue;
5068 
5069         if (shouldClip)
5070             clipToRect(context, localPaintingInfo, fragment.foregroundRect);
5071 
5072         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), phase, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this, localPaintingInfo.requireSecurityOriginAccessForWidgets);
5073         if (phase == PaintPhase::Foreground)
5074             paintInfo.overlapTestRequests = localPaintingInfo.overlapTestRequests;
5075         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5076 
5077         if (shouldClip)
5078             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
5079     }
5080 }
5081 
5082 void RenderLayer::paintOutlineForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
5083     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5084 {
5085     for (const auto&amp; fragment : layerFragments) {
5086         if (fragment.backgroundRect.isEmpty())
5087             continue;
5088 
5089         // Paint our own outline
5090         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::SelfOutline, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5091         clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius);
5092         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5093         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5094     }
5095 }
5096 
5097 void RenderLayer::paintMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
5098     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5099 {
5100     for (const auto&amp; fragment : layerFragments) {
5101         if (!fragment.shouldPaintContent)
5102             continue;
5103 
5104         if (localPaintingInfo.clipToDirtyRect)
5105             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Mask painting will handle clipping to self.
5106 
5107         // Paint the mask.
5108         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
5109         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::Mask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5110         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5111 
5112         if (localPaintingInfo.clipToDirtyRect)
5113             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5114     }
5115 }
5116 
5117 void RenderLayer::paintChildClippingMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5118 {
5119     for (const auto&amp; fragment : layerFragments) {
5120         if (!fragment.shouldPaintContent)
5121             continue;
5122 
5123         if (localPaintingInfo.clipToDirtyRect)
5124             clipToRect(context, localPaintingInfo, fragment.foregroundRect, IncludeSelfForBorderRadius); // Child clipping mask painting will handle clipping to self.
5125 
5126         // Paint the clipped mask.
5127         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::ClippingMask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5128         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5129 
5130         if (localPaintingInfo.clipToDirtyRect)
5131             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
5132     }
5133 }
5134 
5135 void RenderLayer::paintOverflowControlsForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
5136 {
5137     for (const auto&amp; fragment : layerFragments) {
5138         if (fragment.backgroundRect.isEmpty())
5139             continue;
5140         clipToRect(context, localPaintingInfo, fragment.backgroundRect);
5141         paintOverflowControls(context, roundedIntPoint(toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset)),
5142             snappedIntRect(fragment.backgroundRect.rect()), true);
5143         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5144     }
5145 }
5146 
5147 void RenderLayer::collectEventRegionForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
5148 {
5149     ASSERT(localPaintingInfo.eventRegionContext);
5150 
5151     for (const auto&amp; fragment : layerFragments) {
5152         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), PaintPhase::EventRegion, { });
5153         paintInfo.eventRegionContext = localPaintingInfo.eventRegionContext;
5154         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5155     }
5156 }
5157 
5158 bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
5159 {
5160     return hitTest(request, result.hitTestLocation(), result);
5161 }
5162 
5163 bool RenderLayer::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; hitTestLocation, HitTestResult&amp; result)
5164 {
5165     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5166     ASSERT(!renderer().view().needsLayout());
5167 
5168     ASSERT(!isRenderFragmentedFlow());
5169     LayoutRect hitTestArea = renderer().view().documentRect();
5170     if (!request.ignoreClipping()) {
5171         const auto&amp; settings = renderer().settings();
5172         if (settings.visualViewportEnabled() &amp;&amp; settings.clientCoordinatesRelativeToLayoutViewport()) {
5173             auto&amp; frameView = renderer().view().frameView();
5174             LayoutRect absoluteLayoutViewportRect = frameView.layoutViewportRect();
5175             auto scaleFactor = frameView.frame().frameScaleFactor();
5176             if (scaleFactor &gt; 1)
5177                 absoluteLayoutViewportRect.scale(scaleFactor);
5178             hitTestArea.intersect(absoluteLayoutViewportRect);
5179         } else
5180             hitTestArea.intersect(renderer().view().frameView().visibleContentRect(LegacyIOSDocumentVisibleRect));
5181     }
5182 
5183     RenderLayer* insideLayer = hitTestLayer(this, nullptr, request, result, hitTestArea, hitTestLocation, false);
5184     if (!insideLayer) {
5185         // We didn&#39;t hit any layer. If we are the root layer and the mouse is -- or just was -- down,
5186         // return ourselves. We do this so mouse events continue getting delivered after a drag has
5187         // exited the WebView, and so hit testing over a scrollbar hits the content document.
5188         if (!request.isChildFrameHitTest() &amp;&amp; (request.active() || request.release()) &amp;&amp; isRenderViewLayer()) {
5189             renderer().updateHitTestResult(result, downcast&lt;RenderView&gt;(renderer()).flipForWritingMode(hitTestLocation.point()));
5190             insideLayer = this;
5191         }
5192     }
5193 
5194     // Now determine if the result is inside an anchor - if the urlElement isn&#39;t already set.
5195     Node* node = result.innerNode();
5196     if (node &amp;&amp; !result.URLElement())
5197         result.setURLElement(node-&gt;enclosingLinkEventParentOrSelf());
5198 
5199     // Now return whether we were inside this layer (this will always be true for the root
5200     // layer).
5201     return insideLayer;
5202 }
5203 
5204 Element* RenderLayer::enclosingElement() const
5205 {
5206     for (RenderElement* r = &amp;renderer(); r; r = r-&gt;parent()) {
5207         if (Element* e = r-&gt;element())
5208             return e;
5209     }
5210     return nullptr;
5211 }
5212 
5213 RenderLayer* RenderLayer::enclosingFragmentedFlowAncestor() const
5214 {
5215     RenderLayer* curr = parent();
5216     for (; curr &amp;&amp; !curr-&gt;isRenderFragmentedFlow(); curr = curr-&gt;parent()) {
5217         if (curr-&gt;isStackingContext() &amp;&amp; curr-&gt;isComposited()) {
5218             // We only adjust the position of the first level of layers.
5219             return nullptr;
5220         }
5221     }
5222     return curr;
5223 }
5224 
5225 // Compute the z-offset of the point in the transformState.
5226 // This is effectively projecting a ray normal to the plane of ancestor, finding where that
5227 // ray intersects target, and computing the z delta between those two points.
5228 static double computeZOffset(const HitTestingTransformState&amp; transformState)
5229 {
5230     // We got an affine transform, so no z-offset
5231     if (transformState.m_accumulatedTransform.isAffine())
5232         return 0;
5233 
5234     // Flatten the point into the target plane
5235     FloatPoint targetPoint = transformState.mappedPoint();
5236 
5237     // Now map the point back through the transform, which computes Z.
5238     FloatPoint3D backmappedPoint = transformState.m_accumulatedTransform.mapPoint(FloatPoint3D(targetPoint));
5239     return backmappedPoint.z();
5240 }
5241 
5242 Ref&lt;HitTestingTransformState&gt; RenderLayer::createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
5243                                         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5244                                         const HitTestingTransformState* containerTransformState,
5245                                         const LayoutSize&amp; translationOffset) const
5246 {
5247     RefPtr&lt;HitTestingTransformState&gt; transformState;
5248     LayoutSize offset;
5249     if (containerTransformState) {
5250         // If we&#39;re already computing transform state, then it&#39;s relative to the container (which we know is non-null).
5251         transformState = HitTestingTransformState::create(*containerTransformState);
5252         offset = offsetFromAncestor(containerLayer);
5253     } else {
5254         // If this is the first time we need to make transform state, then base it off of hitTestLocation,
5255         // which is relative to rootLayer.
5256         transformState = HitTestingTransformState::create(hitTestLocation.transformedPoint(), hitTestLocation.transformedRect(), FloatQuad(hitTestRect));
5257         offset = offsetFromAncestor(rootLayer);
5258     }
5259     offset += translationOffset;
5260 
5261     RenderObject* containerRenderer = containerLayer ? &amp;containerLayer-&gt;renderer() : nullptr;
5262     if (renderer().shouldUseTransformFromContainer(containerRenderer)) {
5263         TransformationMatrix containerTransform;
5264         renderer().getTransformFromContainer(containerRenderer, offset, containerTransform);
5265         transformState-&gt;applyTransform(containerTransform, HitTestingTransformState::AccumulateTransform);
5266     } else {
5267         transformState-&gt;translate(offset.width(), offset.height(), HitTestingTransformState::AccumulateTransform);
5268     }
5269 
5270     return transformState.releaseNonNull();
5271 }
5272 
5273 
5274 static bool isHitCandidate(const RenderLayer* hitLayer, bool canDepthSort, double* zOffset, const HitTestingTransformState* transformState)
5275 {
5276     if (!hitLayer)
5277         return false;
5278 
5279     // The hit layer is depth-sorting with other layers, so just say that it was hit.
5280     if (canDepthSort)
5281         return true;
5282 
5283     // We need to look at z-depth to decide if this layer was hit.
5284     if (zOffset) {
5285         ASSERT(transformState);
5286         // This is actually computing our z, but that&#39;s OK because the hitLayer is coplanar with us.
5287         double childZOffset = computeZOffset(*transformState);
5288         if (childZOffset &gt; *zOffset) {
5289             *zOffset = childZOffset;
5290             return true;
5291         }
5292         return false;
5293     }
5294 
5295     return true;
5296 }
5297 
5298 // hitTestLocation and hitTestRect are relative to rootLayer.
5299 // A &#39;flattening&#39; layer is one preserves3D() == false.
5300 // transformState.m_accumulatedTransform holds the transform from the containing flattening layer.
5301 // transformState.m_lastPlanarPoint is the hitTestLocation in the plane of the containing flattening layer.
5302 // transformState.m_lastPlanarQuad is the hitTestRect as a quad in the plane of the containing flattening layer.
5303 //
5304 // If zOffset is non-null (which indicates that the caller wants z offset information),
5305 //  *zOffset on return is the z offset of the hit point relative to the containing flattening layer.
5306 RenderLayer* RenderLayer::hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5307                                        const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, bool appliedTransform,
5308                                        const HitTestingTransformState* transformState, double* zOffset)
5309 {
5310     updateLayerListsIfNeeded();
5311 
5312     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
5313         return nullptr;
5314 
5315     // The natural thing would be to keep HitTestingTransformState on the stack, but it&#39;s big, so we heap-allocate.
5316 
5317     // Apply a transform if we have one.
5318     if (transform() &amp;&amp; !appliedTransform) {
5319         if (enclosingPaginationLayer(IncludeCompositedPaginatedLayers))
5320             return hitTestTransformedLayerInFragments(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5321 
5322         // Make sure the parent&#39;s clip rects have been calculated.
5323         if (parent()) {
5324             ClipRectsContext clipRectsContext(rootLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5325             ClipRect clipRect = backgroundClipRect(clipRectsContext);
5326             // Test the enclosing clip now.
5327             if (!clipRect.intersects(hitTestLocation))
5328                 return nullptr;
5329         }
5330 
5331         return hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5332     }
5333 
5334     // Ensure our lists and 3d status are up-to-date.
5335     update3DTransformedDescendantStatus();
5336 
5337     RefPtr&lt;HitTestingTransformState&gt; localTransformState;
5338     if (appliedTransform) {
5339         // We computed the correct state in the caller (above code), so just reference it.
5340         ASSERT(transformState);
5341         localTransformState = const_cast&lt;HitTestingTransformState*&gt;(transformState);
5342     } else if (transformState || has3DTransformedDescendant() || preserves3D()) {
5343         // We need transform state for the first time, or to offset the container state, so create it here.
5344         localTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState);
5345     }
5346 
5347     // Check for hit test on backface if backface-visibility is &#39;hidden&#39;
5348     if (localTransformState &amp;&amp; renderer().style().backfaceVisibility() == BackfaceVisibility::Hidden) {
5349         Optional&lt;TransformationMatrix&gt; invertedMatrix = localTransformState-&gt;m_accumulatedTransform.inverse();
5350         // If the z-vector of the matrix is negative, the back is facing towards the viewer.
5351         if (invertedMatrix &amp;&amp; invertedMatrix.value().m33() &lt; 0)
5352             return nullptr;
5353     }
5354 
5355     RefPtr&lt;HitTestingTransformState&gt; unflattenedTransformState = localTransformState;
5356     if (localTransformState &amp;&amp; !preserves3D()) {
5357         // Keep a copy of the pre-flattening state, for computing z-offsets for the container
5358         unflattenedTransformState = HitTestingTransformState::create(*localTransformState);
5359         // This layer is flattening, so flatten the state passed to descendants.
5360         localTransformState-&gt;flatten();
5361     }
5362 
5363     // The following are used for keeping track of the z-depth of the hit point of 3d-transformed
5364     // descendants.
5365     double localZOffset = -std::numeric_limits&lt;double&gt;::infinity();
5366     double* zOffsetForDescendantsPtr = nullptr;
5367     double* zOffsetForContentsPtr = nullptr;
5368 
5369     bool depthSortDescendants = false;
5370     if (preserves3D()) {
5371         depthSortDescendants = true;
5372         // Our layers can depth-test with our container, so share the z depth pointer with the container, if it passed one down.
5373         zOffsetForDescendantsPtr = zOffset ? zOffset : &amp;localZOffset;
5374         zOffsetForContentsPtr = zOffset ? zOffset : &amp;localZOffset;
5375     } else if (zOffset) {
5376         zOffsetForDescendantsPtr = nullptr;
5377         // Container needs us to give back a z offset for the hit layer.
5378         zOffsetForContentsPtr = zOffset;
5379     }
5380 
5381     // This variable tracks which layer the mouse ends up being inside.
5382     RenderLayer* candidateLayer = nullptr;
5383 #if ASSERT_ENABLED
5384     LayerListMutationDetector mutationChecker(*this);
5385 #endif
5386 
5387     // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
5388     auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5389                                         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5390     if (hitLayer) {
5391         if (!depthSortDescendants)
5392             return hitLayer;
5393         candidateLayer = hitLayer;
5394     }
5395 
5396     // Now check our overflow objects.
5397     hitLayer = hitTestList(normalFlowLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5398                            localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5399     if (hitLayer) {
5400         if (!depthSortDescendants)
5401             return hitLayer;
5402         candidateLayer = hitLayer;
5403     }
5404 
5405     // Collect the fragments. This will compute the clip rectangles for each layer fragment.
5406     LayerFragments layerFragments;
5407     collectFragments(layerFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers, RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip,
5408         offsetFromAncestor(rootLayer));
5409 
5410     if (canResize() &amp;&amp; hitTestResizerInFragments(layerFragments, hitTestLocation)) {
5411         renderer().updateHitTestResult(result, hitTestLocation.point());
5412         return this;
5413     }
5414 
5415     // Next we want to see if the mouse pos is inside the child RenderObjects of the layer. Check
5416     // every fragment in reverse order.
5417     if (isSelfPaintingLayer()) {
5418         // Hit test with a temporary HitTestResult, because we only want to commit to &#39;result&#39; if we know we&#39;re frontmost.
5419         HitTestResult tempResult(result.hitTestLocation());
5420         bool insideFragmentForegroundRect = false;
5421         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestDescendants, insideFragmentForegroundRect)
5422             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5423             if (request.resultIsElementList())
5424                 result.append(tempResult, request);
5425             else
5426                 result = tempResult;
5427             if (!depthSortDescendants)
5428                 return this;
5429             // Foreground can depth-sort with descendant layers, so keep this as a candidate.
5430             candidateLayer = this;
5431         } else if (insideFragmentForegroundRect &amp;&amp; request.resultIsElementList())
5432             result.append(tempResult, request);
5433     }
5434 
5435     // Now check our negative z-index children.
5436     hitLayer = hitTestList(negativeZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5437         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5438     if (hitLayer) {
5439         if (!depthSortDescendants)
5440             return hitLayer;
5441         candidateLayer = hitLayer;
5442     }
5443 
5444     // If we found a layer, return. Child layers, and foreground always render in front of background.
5445     if (candidateLayer)
5446         return candidateLayer;
5447 
5448     if (isSelfPaintingLayer()) {
5449         HitTestResult tempResult(result.hitTestLocation());
5450         bool insideFragmentBackgroundRect = false;
5451         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestSelf, insideFragmentBackgroundRect)
5452             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5453             if (request.resultIsElementList())
5454                 result.append(tempResult, request);
5455             else
5456                 result = tempResult;
5457             return this;
5458         }
5459         if (insideFragmentBackgroundRect &amp;&amp; request.resultIsElementList())
5460             result.append(tempResult, request);
5461     }
5462 
5463     return nullptr;
5464 }
5465 
5466 bool RenderLayer::hitTestContentsForFragments(const LayerFragments&amp; layerFragments, const HitTestRequest&amp; request, HitTestResult&amp; result,
5467     const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter, bool&amp; insideClipRect) const
5468 {
5469     if (layerFragments.isEmpty())
5470         return false;
5471 
5472     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5473         const LayerFragment&amp; fragment = layerFragments.at(i);
5474         if ((hitTestFilter == HitTestSelf &amp;&amp; !fragment.backgroundRect.intersects(hitTestLocation))
5475             || (hitTestFilter == HitTestDescendants &amp;&amp; !fragment.foregroundRect.intersects(hitTestLocation)))
5476             continue;
5477         insideClipRect = true;
5478         if (hitTestContents(request, result, fragment.layerBounds, hitTestLocation, hitTestFilter))
5479             return true;
5480     }
5481 
5482     return false;
5483 }
5484 
5485 bool RenderLayer::hitTestResizerInFragments(const LayerFragments&amp; layerFragments, const HitTestLocation&amp; hitTestLocation) const
5486 {
5487     if (layerFragments.isEmpty())
5488         return false;
5489 
5490     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5491         const LayerFragment&amp; fragment = layerFragments.at(i);
5492         if (fragment.backgroundRect.intersects(hitTestLocation) &amp;&amp; resizerCornerRect(*this, snappedIntRect(fragment.layerBounds)).contains(hitTestLocation.roundedPoint()))
5493             return true;
5494     }
5495 
5496     return false;
5497 }
5498 
5499 RenderLayer* RenderLayer::hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5500     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset)
5501 {
5502     LayerFragments enclosingPaginationFragments;
5503     LayoutSize offsetOfPaginationLayerFromRoot;
5504     RenderLayer* paginatedLayer = enclosingPaginationLayer(IncludeCompositedPaginatedLayers);
5505     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, HitTestingTransparencyClipBox, RootOfTransparencyClipBox);
5506     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers,
5507         RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
5508 
5509     for (int i = enclosingPaginationFragments.size() - 1; i &gt;= 0; --i) {
5510         const LayerFragment&amp; fragment = enclosingPaginationFragments.at(i);
5511 
5512         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
5513         // the enclosing pagination layer.
5514         LayoutRect clipRect = fragment.backgroundRect.rect();
5515 
5516         // Now compute the clips within a given fragment
5517         if (parent() != paginatedLayer) {
5518             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
5519 
5520             ClipRectsContext clipRectsContext(paginatedLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5521             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
5522             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
5523             clipRect.intersect(parentClipRect);
5524         }
5525 
5526         if (!hitTestLocation.intersects(clipRect))
5527             continue;
5528 
5529         RenderLayer* hitLayer = hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation,
5530             transformState, zOffset, fragment.paginationOffset);
5531         if (hitLayer)
5532             return hitLayer;
5533     }
5534 
5535     return nullptr;
5536 }
5537 
5538 RenderLayer* RenderLayer::hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5539     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset,
5540     const LayoutSize&amp; translationOffset)
5541 {
5542     // Create a transform state to accumulate this transform.
5543     Ref&lt;HitTestingTransformState&gt; newTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState, translationOffset);
5544 
5545     // If the transform can&#39;t be inverted, then don&#39;t hit test this layer at all.
5546     if (!newTransformState-&gt;m_accumulatedTransform.isInvertible())
5547         return nullptr;
5548 
5549     // Compute the point and the hit test rect in the coords of this layer by using the values
5550     // from the transformState, which store the point and quad in the coords of the last flattened
5551     // layer, and the accumulated transform which lets up map through preserve-3d layers.
5552     //
5553     // We can&#39;t just map hitTestLocation and hitTestRect because they may have been flattened (losing z)
5554     // by our container.
5555     FloatPoint localPoint = newTransformState-&gt;mappedPoint();
5556     FloatQuad localPointQuad = newTransformState-&gt;mappedQuad();
5557     LayoutRect localHitTestRect = newTransformState-&gt;boundsOfMappedArea();
5558     HitTestLocation newHitTestLocation;
5559     if (hitTestLocation.isRectBasedTest())
5560         newHitTestLocation = HitTestLocation(localPoint, localPointQuad);
5561     else
5562         newHitTestLocation = HitTestLocation(localPoint);
5563 
5564     // Now do a hit test with the root layer shifted to be us.
5565     return hitTestLayer(this, containerLayer, request, result, localHitTestRect, newHitTestLocation, true, newTransformState.ptr(), zOffset);
5566 }
5567 
5568 bool RenderLayer::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const LayoutRect&amp; layerBounds, const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter) const
5569 {
5570     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5571 
5572     if (!renderer().hitTest(request, result, hitTestLocation, toLayoutPoint(layerBounds.location() - renderBoxLocation()), hitTestFilter)) {
5573         // It&#39;s wrong to set innerNode, but then claim that you didn&#39;t hit anything, unless it is
5574         // a rect-based test.
5575         ASSERT(!result.innerNode() || (request.resultIsElementList() &amp;&amp; result.listBasedTestResult().size()));
5576         return false;
5577     }
5578 
5579     // For positioned generated content, we might still not have a
5580     // node by the time we get to the layer level, since none of
5581     // the content in the layer has an element. So just walk up
5582     // the tree.
5583     if (!result.innerNode() || !result.innerNonSharedNode()) {
5584         if (isOutOfFlowRenderFragmentedFlow()) {
5585             // The flowthread doesn&#39;t have an enclosing element, so when hitting the layer of the
5586             // flowthread (e.g. the descent area of the RootInlineBox for the image flowed alone
5587             // inside the flow thread) we&#39;re letting the hit testing continue so it will hit the region.
5588             return false;
5589         }
5590 
5591         Element* e = enclosingElement();
5592         if (!result.innerNode())
5593             result.setInnerNode(e);
5594         if (!result.innerNonSharedNode())
5595             result.setInnerNonSharedNode(e);
5596     }
5597 
5598     return true;
5599 }
5600 
5601 RenderLayer* RenderLayer::hitTestList(LayerList layerIterator, RenderLayer* rootLayer,
5602                                       const HitTestRequest&amp; request, HitTestResult&amp; result,
5603                                       const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5604                                       const HitTestingTransformState* transformState,
5605                                       double* zOffsetForDescendants, double* zOffset,
5606                                       const HitTestingTransformState* unflattenedTransformState,
5607                                       bool depthSortDescendants)
5608 {
5609     if (layerIterator.begin() == layerIterator.end())
5610         return nullptr;
5611 
5612     if (!hasSelfPaintingLayerDescendant())
5613         return nullptr;
5614 
5615     RenderLayer* resultLayer = nullptr;
5616 
5617     for (auto iter = layerIterator.rbegin(); iter != layerIterator.rend(); ++iter) {
5618         auto* childLayer = *iter;
5619 
5620         HitTestResult tempResult(result.hitTestLocation());
5621         auto* hitLayer = childLayer-&gt;hitTestLayer(rootLayer, this, request, tempResult, hitTestRect, hitTestLocation, false, transformState, zOffsetForDescendants);
5622 
5623         // If it is a list-based test, we can safely append the temporary result since it might had hit
5624         // nodes but not necesserily had hitLayer set.
5625         ASSERT(!result.isRectBasedTest() || request.resultIsElementList());
5626         if (request.resultIsElementList())
5627             result.append(tempResult, request);
5628 
5629         if (isHitCandidate(hitLayer, depthSortDescendants, zOffset, unflattenedTransformState)) {
5630             resultLayer = hitLayer;
5631             if (!request.resultIsElementList())
5632                 result = tempResult;
5633             if (!depthSortDescendants)
5634                 break;
5635         }
5636     }
5637 
5638     return resultLayer;
5639 }
5640 
5641 Ref&lt;ClipRects&gt; RenderLayer::updateClipRects(const ClipRectsContext&amp; clipRectsContext)
5642 {
5643     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5644     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5645     if (m_clipRectsCache) {
5646         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5647             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5648             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5649 
5650 #ifdef CHECK_CACHED_CLIP_RECTS
5651             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5652             ClipRectsContext tempContext(clipRectsContext);
5653             tempContext.clipRectsType = TemporaryClipRects;
5654             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5655             calculateClipRects(tempContext, tempClipRects);
5656             ASSERT(tempClipRects.get() == *clipRects);
5657 #endif
5658             return *clipRects; // We have the correct cached value.
5659         }
5660     }
5661 
5662     if (!m_clipRectsCache)
5663         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();
5664 #if ASSERT_ENABLED
5665     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5666     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5667 #endif
5668 
5669     RefPtr&lt;ClipRects&gt; parentClipRects;
5670     // For transformed layers, the root layer was shifted to be us, so there is no need to
5671     // examine the parent. We want to cache clip rects with us as the root.
5672     if (clipRectsContext.rootLayer != this &amp;&amp; parent())
5673         parentClipRects = this-&gt;parentClipRects(clipRectsContext);
5674 
5675     auto clipRects = ClipRects::create();
5676     calculateClipRects(clipRectsContext, clipRects);
5677 
5678     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5679         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5680         return parentClipRects.releaseNonNull();
5681     }
5682     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5683     return clipRects;
5684 }
5685 
5686 ClipRects* RenderLayer::clipRects(const ClipRectsContext&amp; context) const
5687 {
5688     ASSERT(context.clipRectsType &lt; NumCachedClipRectsTypes);
5689     if (!m_clipRectsCache)
5690         return nullptr;
5691     return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
5692 }
5693 
5694 bool RenderLayer::clipCrossesPaintingBoundary() const
5695 {
5696     return parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers)
5697         || parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();
5698 }
5699 
5700 void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
5701 {
5702     if (!parent()) {
5703         // The root layer&#39;s clip rect is always infinite.
5704         clipRects.reset();
5705         return;
5706     }
5707 
5708     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5709     bool useCached = clipRectsType != TemporaryClipRects;
5710 
5711     // For transformed layers, the root layer was shifted to be us, so there is no need to
5712     // examine the parent. We want to cache clip rects with us as the root.
5713     RenderLayer* parentLayer = clipRectsContext.rootLayer != this ? parent() : nullptr;
5714 
5715     // Ensure that our parent&#39;s clip has been calculated so that we can examine the values.
5716     if (parentLayer) {
5717         if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
5718             clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
5719         else {
5720             ClipRectsContext parentContext(clipRectsContext);
5721             parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?
5722 
5723             if ((parentContext.clipRectsType != TemporaryClipRects &amp;&amp; parentContext.clipRectsType != AbsoluteClipRects) &amp;&amp; clipCrossesPaintingBoundary())
5724                 parentContext.clipRectsType = TemporaryClipRects;
5725 
5726             parentLayer-&gt;calculateClipRects(parentContext, clipRects);
5727         }
5728     } else
5729         clipRects.reset();
5730 
5731     // A fixed object is essentially the root of its containing block hierarchy, so when
5732     // we encounter such an object, we reset our clip rects to the fixedClipRect.
5733     if (renderer().isFixedPositioned()) {
5734         clipRects.setPosClipRect(clipRects.fixedClipRect());
5735         clipRects.setOverflowClipRect(clipRects.fixedClipRect());
5736         clipRects.setFixed(true);
5737     } else if (renderer().isInFlowPositioned())
5738         clipRects.setPosClipRect(clipRects.overflowClipRect());
5739     else if (renderer().isAbsolutelyPositioned())
5740         clipRects.setOverflowClipRect(clipRects.posClipRect());
5741 
5742     // Update the clip rects that will be passed to child layers.
5743 #if PLATFORM(IOS_FAMILY)
5744     if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
5745 #else
5746     if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
5747 #endif
5748         // This layer establishes a clip of some kind.
5749         LayoutPoint offset;
5750         if (!m_hasTransformedAncestor &amp;&amp; canUseOffsetFromAncestor())
5751             offset = toLayoutPoint(offsetFromAncestor(clipRectsContext.rootLayer, AdjustForColumns));
5752         else
5753             offset = LayoutPoint(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));
5754 
5755         if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
5756             offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
5757 
5758         if (renderer().hasOverflowClip()) {
5759             ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
5760             newOverflowClip.setAffectedByRadius(renderer().style().hasBorderRadius());
5761             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
5762             if (renderer().isPositioned())
5763                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
5764         }
5765         if (renderer().hasClip()) {
5766             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(offset, nullptr);
5767             clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
5768             clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
5769             clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
5770         }
5771     }
5772 
5773     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; calculateClipRects &quot; &lt;&lt; clipRects);
5774 }
5775 
5776 Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
5777 {
5778     ASSERT(parent());
5779 
5780     auto temporaryParentClipRects = [&amp;](const ClipRectsContext&amp; clipContext) {
5781         auto parentClipRects = ClipRects::create();
5782         parent()-&gt;calculateClipRects(clipContext, parentClipRects);
5783         return parentClipRects;
5784     };
5785 
5786     if (clipRectsContext.clipRectsType == TemporaryClipRects)
5787         return temporaryParentClipRects(clipRectsContext);
5788 
5789     if (clipRectsContext.clipRectsType != AbsoluteClipRects &amp;&amp; clipCrossesPaintingBoundary()) {
5790         ClipRectsContext tempClipRectsContext(clipRectsContext);
5791         tempClipRectsContext.clipRectsType = TemporaryClipRects;
5792         return temporaryParentClipRects(tempClipRectsContext);
5793     }
5794 
5795     return parent()-&gt;updateClipRects(clipRectsContext);
5796 }
5797 
5798 static inline ClipRect backgroundClipRectForPosition(const ClipRects&amp; parentRects, PositionType position)
5799 {
5800     if (position == PositionType::Fixed)
5801         return parentRects.fixedClipRect();
5802 
5803     if (position == PositionType::Absolute)
5804         return parentRects.posClipRect();
5805 
5806     return parentRects.overflowClipRect();
5807 }
5808 
5809 ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
5810 {
5811     ASSERT(parent());
5812     auto parentRects = parentClipRects(clipRectsContext);
5813     ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
5814     RenderView&amp; view = renderer().view();
5815     // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
5816     if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
5817         backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
5818 
5819     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; backgroundClipRect with context &quot; &lt;&lt; clipRectsContext &lt;&lt; &quot; returning &quot; &lt;&lt; backgroundClipRect);
5820     return backgroundClipRect;
5821 }
5822 
5823 void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
5824     ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
5825 {
5826     if (clipRectsContext.rootLayer != this &amp;&amp; parent()) {
5827         backgroundRect = backgroundClipRect(clipRectsContext);
5828         backgroundRect.intersect(paintDirtyRect);
5829     } else
5830         backgroundRect = paintDirtyRect;
5831 
5832     LayoutSize offsetFromRootLocal = offsetFromRoot;
5833 
5834     if (clipRectsContext.rootLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
5835         LayoutPoint absPos = LayoutPoint(renderer().view().localToAbsolute(FloatPoint(), IsFixed));
5836         offsetFromRootLocal += toLayoutSize(absPos);
5837     }
5838 
5839     layerBounds = LayoutRect(toLayoutPoint(offsetFromRootLocal), size());
5840 
5841     foregroundRect = backgroundRect;
5842 
5843     // Update the clip rects that will be passed to child layers.
5844     if (renderer().hasClipOrOverflowClip()) {
5845         // This layer establishes a clip of some kind.
5846         if (renderer().hasOverflowClip() &amp;&amp; (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)) {
5847             foregroundRect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(toLayoutPoint(offsetFromRootLocal), nullptr, clipRectsContext.overlayScrollbarSizeRelevancy));
5848             if (renderer().style().hasBorderRadius())
5849                 foregroundRect.setAffectedByRadius(true);
5850         }
5851 
5852         if (renderer().hasClip()) {
5853             // Clip applies to *us* as well, so update the damageRect.
5854             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRootLocal), nullptr);
5855             backgroundRect.intersect(newPosClip);
5856             foregroundRect.intersect(newPosClip);
5857         }
5858 
5859         // If we establish a clip at all, then make sure our background rect is intersected with our layer&#39;s bounds including our visual overflow,
5860         // since any visual overflow like box-shadow or border-outset is not clipped by overflow:auto/hidden.
5861         if (renderBox()-&gt;hasVisualOverflow()) {
5862             // FIXME: Does not do the right thing with CSS regions yet, since we don&#39;t yet factor in the
5863             // individual region boxes as overflow.
5864             LayoutRect layerBoundsWithVisualOverflow = renderBox()-&gt;visualOverflowRect();
5865             renderBox()-&gt;flipForWritingMode(layerBoundsWithVisualOverflow); // Layers are in physical coordinates, so the overflow has to be flipped.
5866             layerBoundsWithVisualOverflow.move(offsetFromRootLocal);
5867             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5868                 backgroundRect.intersect(layerBoundsWithVisualOverflow);
5869         } else {
5870             // Shift the bounds to be for our region only.
5871             LayoutRect bounds = renderBox()-&gt;borderBoxRectInFragment(nullptr);
5872 
5873             bounds.move(offsetFromRootLocal);
5874             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5875                 backgroundRect.intersect(bounds);
5876         }
5877     }
5878 }
5879 
5880 LayoutRect RenderLayer::childrenClipRect() const
5881 {
5882     // FIXME: border-radius not accounted for.
5883     // FIXME: Regions not accounted for.
5884     RenderLayer* clippingRootLayer = clippingRootForPainting();
5885     LayoutRect layerBounds;
5886     ClipRect backgroundRect;
5887     ClipRect foregroundRect;
5888     ClipRectsContext clipRectsContext(clippingRootLayer, TemporaryClipRects);
5889     // Need to use temporary clip rects, because the value of &#39;dontClipToOverflow&#39; may be different from the painting path (&lt;rdar://problem/11844909&gt;).
5890     calculateRects(clipRectsContext, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, offsetFromAncestor(clipRectsContext.rootLayer));
5891     if (foregroundRect.rect().isInfinite())
5892         return renderer().view().unscaledDocumentRect();
5893 
5894     auto absoluteClippingRect = clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(foregroundRect.rect())).enclosingBoundingBox();
5895     return intersection(absoluteClippingRect, renderer().view().unscaledDocumentRect());
5896 }
5897 
5898 LayoutRect RenderLayer::clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const
5899 {
5900     LayoutRect layerBounds;
5901     ClipRect backgroundRect;
5902     ClipRect foregroundRect;
5903     auto clipRectType = !m_enclosingPaginationLayer || m_enclosingPaginationLayer == ancestor ? PaintingClipRects : TemporaryClipRects;
5904     ClipRectsContext clipRectsContext(ancestor, clipRectType);
5905     calculateRects(clipRectsContext, constrainingRect, layerBounds, backgroundRect, foregroundRect, offsetFromAncestor);
5906     return backgroundRect.rect();
5907 }
5908 
5909 LayoutRect RenderLayer::selfClipRect() const
5910 {
5911     // FIXME: border-radius not accounted for.
5912     // FIXME: Regions not accounted for.
5913     RenderLayer* clippingRootLayer = clippingRootForPainting();
5914     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromAncestor(clippingRootLayer), renderer().view().documentRect());
5915     return clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(clipRect)).enclosingBoundingBox();
5916 }
5917 
5918 LayoutRect RenderLayer::localClipRect(bool&amp; clipExceedsBounds) const
5919 {
5920     clipExceedsBounds = false;
5921     // FIXME: border-radius not accounted for.
5922     // FIXME: Regions not accounted for.
5923     RenderLayer* clippingRootLayer = clippingRootForPainting();
5924     LayoutSize offsetFromRoot = offsetFromAncestor(clippingRootLayer);
5925     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromRoot, LayoutRect::infiniteRect());
5926     if (clipRect.isInfinite())
5927         return clipRect;
5928 
5929     if (renderer().hasClip()) {
5930         // CSS clip may be larger than our border box.
5931         LayoutRect cssClipRect = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRoot), nullptr);
5932         clipExceedsBounds = !clipRect.contains(cssClipRect);
5933     }
5934 
5935     clipRect.move(-offsetFromRoot);
5936     return clipRect;
5937 }
5938 
5939 void RenderLayer::addBlockSelectionGapsBounds(const LayoutRect&amp; bounds)
5940 {
5941     m_blockSelectionGapsBounds.unite(enclosingIntRect(bounds));
5942 }
5943 
5944 void RenderLayer::clearBlockSelectionGapsBounds()
5945 {
5946     m_blockSelectionGapsBounds = IntRect();
5947     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5948         child-&gt;clearBlockSelectionGapsBounds();
5949 }
5950 
5951 void RenderLayer::repaintBlockSelectionGaps()
5952 {
5953     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5954         child-&gt;repaintBlockSelectionGaps();
5955 
5956     if (m_blockSelectionGapsBounds.isEmpty())
5957         return;
5958 
5959     LayoutRect rect = m_blockSelectionGapsBounds;
5960     rect.moveBy(-scrollPosition());
5961     if (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling())
5962         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5963     if (renderer().hasClip())
5964         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).clipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5965     if (!rect.isEmpty())
5966         renderer().repaintRectangle(rect);
5967 }
5968 
5969 bool RenderLayer::intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox) const
5970 {
5971     // Always examine the canvas and the root.
5972     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
5973     // paints the root&#39;s background.
5974     if (isRenderViewLayer() || renderer().isDocumentElementRenderer())
5975         return true;
5976 
5977     if (damageRect.isInfinite())
5978         return true;
5979 
5980     if (damageRect.isEmpty())
5981         return false;
5982 
5983     // If we aren&#39;t an inline flow, and our layer bounds do intersect the damage rect, then we can return true.
5984     if (!renderer().isRenderInline() &amp;&amp; layerBounds.intersects(damageRect))
5985         return true;
5986 
5987     // Otherwise we need to compute the bounding box of this single layer and see if it intersects
5988     // the damage rect. It&#39;s possible the fragment computed the bounding box already, in which case we
5989     // can use the cached value.
5990     if (cachedBoundingBox)
5991         return cachedBoundingBox-&gt;intersects(damageRect);
5992 
5993     return boundingBox(rootLayer, offsetFromRoot).intersects(damageRect);
5994 }
5995 
5996 LayoutRect RenderLayer::localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5997 {
5998     // There are three special cases we need to consider.
5999     // (1) Inline Flows.  For inline flows we will create a bounding box that fully encompasses all of the lines occupied by the
6000     // inline.  In other words, if some &lt;span&gt; wraps to three lines, we&#39;ll create a bounding box that fully encloses the
6001     // line boxes of all three lines (including overflow on those lines).
6002     // (2) Left/Top Overflow.  The width/height of layers already includes right/bottom overflow.  However, in the case of left/top
6003     // overflow, we have to create a bounding box that will extend to include this overflow.
6004     // (3) Floats.  When a layer has overhanging floats that it paints, we need to make sure to include these overhanging floats
6005     // as part of our bounding box.  We do this because we are the responsible layer for both hit testing and painting those
6006     // floats.
6007     LayoutRect result;
6008     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer()))
6009         result = downcast&lt;RenderInline&gt;(renderer()).linesVisualOverflowBoundingBox();
6010     else if (is&lt;RenderTableRow&gt;(renderer())) {
6011         auto&amp; tableRow = downcast&lt;RenderTableRow&gt;(renderer());
6012         // Our bounding box is just the union of all of our cells&#39; border/overflow rects.
6013         for (RenderTableCell* cell = tableRow.firstCell(); cell; cell = cell-&gt;nextCell()) {
6014             LayoutRect bbox = cell-&gt;borderBoxRect();
6015             result.unite(bbox);
6016             LayoutRect overflowRect = tableRow.visualOverflowRect();
6017             if (bbox != overflowRect)
6018                 result.unite(overflowRect);
6019         }
6020     } else {
6021         RenderBox* box = renderBox();
6022         ASSERT(box);
6023         if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
6024             result = box-&gt;maskClipRect(LayoutPoint());
6025             box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
6026         } else
6027             result = box-&gt;visualOverflowRect();
6028     }
6029     return result;
6030 }
6031 
6032 LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
6033 {
6034     LayoutRect result = localBoundingBox(flags);
6035     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
6036         if (renderer().isBox())
6037             renderBox()-&gt;flipForWritingMode(result);
6038         else
6039             renderer().containingBlock()-&gt;flipForWritingMode(result);
6040     }
6041 
6042     PaginationInclusionMode inclusionMode = ExcludeCompositedPaginatedLayers;
6043     if (flags &amp; UseFragmentBoxesIncludingCompositing)
6044         inclusionMode = IncludeCompositedPaginatedLayers;
6045 
6046     const RenderLayer* paginationLayer = nullptr;
6047     if (flags.containsAny({ UseFragmentBoxesExcludingCompositing, UseFragmentBoxesIncludingCompositing }))
6048         paginationLayer = enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
6049 
6050     const RenderLayer* childLayer = this;
6051     bool isPaginated = paginationLayer;
6052     while (paginationLayer) {
6053         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
6054         // get our true bounding box.
6055         result.move(childLayer-&gt;offsetFromAncestor(paginationLayer));
6056 
6057         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
6058         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
6059 
6060         childLayer = paginationLayer;
6061         paginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
6062     }
6063 
6064     if (isPaginated) {
6065         result.move(childLayer-&gt;offsetFromAncestor(ancestorLayer));
6066         return result;
6067     }
6068 
6069     result.move(offsetFromRoot);
6070     return result;
6071 }
6072 
6073 bool RenderLayer::getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp; bounds, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags) const
6074 {
6075     // The animation will override the display transform, so don&#39;t include it.
6076     auto boundsFlags = additionalFlags | (defaultCalculateLayerBoundsFlags() - IncludeSelfTransform);
6077 
6078     bounds = calculateLayerBounds(this, LayoutSize(), boundsFlags);
6079 
6080     LayoutRect animatedBounds = bounds;
6081     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
6082         if (auto* timeline = renderer().documentTimeline()) {
6083             if (timeline-&gt;computeExtentOfAnimation(renderer(), animatedBounds)) {
6084                 bounds = animatedBounds;
6085                 return true;
6086             }
6087         }
6088     } else {
6089         if (renderer().animation().computeExtentOfAnimation(renderer(), animatedBounds)) {
6090             bounds = animatedBounds;
6091             return true;
6092         }
6093     }
6094 
6095     return false;
6096 }
6097 
6098 IntRect RenderLayer::absoluteBoundingBox() const
6099 {
6100     const RenderLayer* rootLayer = root();
6101     return snappedIntRect(boundingBox(rootLayer, offsetFromAncestor(rootLayer)));
6102 }
6103 
6104 FloatRect RenderLayer::absoluteBoundingBoxForPainting() const
6105 {
6106     const RenderLayer* rootLayer = root();
6107     return snapRectToDevicePixels(boundingBox(rootLayer, offsetFromAncestor(rootLayer)), renderer().document().deviceScaleFactor());
6108 }
6109 
6110 LayoutRect RenderLayer::overlapBounds() const
6111 {
6112     if (overlapBoundsIncludeChildren())
6113         return calculateLayerBounds(this, { }, defaultCalculateLayerBoundsFlags() | IncludeFilterOutsets);
6114 
6115     return localBoundingBox();
6116 }
6117 
6118 LayoutRect RenderLayer::calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
6119 {
6120     if (!isSelfPaintingLayer())
6121         return LayoutRect();
6122 
6123     // FIXME: This could be improved to do a check like hasVisibleNonCompositingDescendantLayers() (bug 92580).
6124     if ((flags &amp; ExcludeHiddenDescendants) &amp;&amp; this != ancestorLayer &amp;&amp; !hasVisibleContent() &amp;&amp; !hasVisibleDescendant())
6125         return LayoutRect();
6126 
6127     if (isRenderViewLayer()) {
6128         // The root layer is always just the size of the document.
6129         return renderer().view().unscaledDocumentRect();
6130     }
6131 
6132     LayoutRect boundingBoxRect = localBoundingBox(flags);
6133     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
6134         if (is&lt;RenderBox&gt;(renderer()))
6135             downcast&lt;RenderBox&gt;(renderer()).flipForWritingMode(boundingBoxRect);
6136         else
6137             renderer().containingBlock()-&gt;flipForWritingMode(boundingBoxRect);
6138     }
6139 
6140     if (renderer().isDocumentElementRenderer()) {
6141         // If the root layer becomes composited (e.g. because some descendant with negative z-index is composited),
6142         // then it has to be big enough to cover the viewport in order to display the background. This is akin
6143         // to the code in RenderBox::paintRootBoxFillLayers().
6144         const FrameView&amp; frameView = renderer().view().frameView();
6145         boundingBoxRect.setWidth(std::max(boundingBoxRect.width(), frameView.contentsWidth() - boundingBoxRect.x()));
6146         boundingBoxRect.setHeight(std::max(boundingBoxRect.height(), frameView.contentsHeight() - boundingBoxRect.y()));
6147     }
6148 
6149     LayoutRect unionBounds = boundingBoxRect;
6150 
6151     if (flags &amp; UseLocalClipRectIfPossible) {
6152         bool clipExceedsBounds = false;
6153         LayoutRect localClipRect = this-&gt;localClipRect(clipExceedsBounds);
6154         if (!localClipRect.isInfinite() &amp;&amp; !clipExceedsBounds) {
6155             if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal))
6156                 localClipRect = transform()-&gt;mapRect(localClipRect);
6157 
6158             localClipRect.move(offsetFromAncestor(ancestorLayer));
6159             return localClipRect;
6160         }
6161     }
6162 
6163     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
6164     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
6165 
6166     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
6167 
6168     if (RenderLayer* reflection = reflectionLayer()) {
6169         if (!reflection-&gt;isComposited()) {
6170             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
6171             unionBounds.unite(childUnionBounds);
6172         }
6173     }
6174 
6175     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
6176 
6177 #if ASSERT_ENABLED
6178     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
6179 #endif
6180 
6181     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
6182         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))
6183             return;
6184         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
6185         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
6186         // that we hit the max LayoutUnit value.
6187         unionBounds.checkedUnite(childBounds);
6188     };
6189 
6190     for (auto* childLayer : negativeZOrderLayers())
6191         computeLayersUnion(*childLayer);
6192 
6193     for (auto* childLayer : positiveZOrderLayers())
6194         computeLayersUnion(*childLayer);
6195 
6196     for (auto* childLayer : normalFlowLayers())
6197         computeLayersUnion(*childLayer);
6198 
6199     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
6200         unionBounds += filterOutsets();
6201 
6202     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
6203         TransformationMatrix* affineTrans = transform();
6204         boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
6205         unionBounds = affineTrans-&gt;mapRect(unionBounds);
6206     }
6207     unionBounds.move(offsetFromRoot);
6208     return unionBounds;
6209 }
6210 
6211 void RenderLayer::clearClipRectsIncludingDescendants(ClipRectsType typeToClear)
6212 {
6213     // FIXME: it&#39;s not clear how this layer not having clip rects guarantees that no descendants have any.
6214     if (!m_clipRectsCache)
6215         return;
6216 
6217     clearClipRects(typeToClear);
6218 
6219     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
6220         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
6221 }
6222 
6223 void RenderLayer::clearClipRects(ClipRectsType typeToClear)
6224 {
6225     if (typeToClear == AllClipRectTypes)
6226         m_clipRectsCache = nullptr;
6227     else {
6228         ASSERT(typeToClear &lt; NumCachedClipRectsTypes);
6229         m_clipRectsCache-&gt;setClipRects(typeToClear, RespectOverflowClip, nullptr);
6230         m_clipRectsCache-&gt;setClipRects(typeToClear, IgnoreOverflowClip, nullptr);
6231     }
6232 }
6233 
6234 RenderLayerBacking* RenderLayer::ensureBacking()
6235 {
6236     if (!m_backing) {
6237         m_backing = makeUnique&lt;RenderLayerBacking&gt;(*this);
6238         compositor().layerBecameComposited(*this);
6239 
6240         updateFilterPaintingStrategy();
6241     }
6242     return m_backing.get();
6243 }
6244 
6245 void RenderLayer::clearBacking(bool layerBeingDestroyed)
6246 {
6247     if (!m_backing)
6248         return;
6249 
6250     if (!renderer().renderTreeBeingDestroyed())
6251         compositor().layerBecameNonComposited(*this);
6252 
6253     m_backing-&gt;willBeDestroyed();
6254     m_backing = nullptr;
6255 
6256     if (!layerBeingDestroyed)
6257         updateFilterPaintingStrategy();
6258 }
6259 
6260 bool RenderLayer::hasCompositedMask() const
6261 {
6262     return m_backing &amp;&amp; m_backing-&gt;hasMaskLayer();
6263 }
6264 
6265 GraphicsLayer* RenderLayer::layerForHorizontalScrollbar() const
6266 {
6267     return m_backing ? m_backing-&gt;layerForHorizontalScrollbar() : nullptr;
6268 }
6269 
6270 GraphicsLayer* RenderLayer::layerForVerticalScrollbar() const
6271 {
6272     return m_backing ? m_backing-&gt;layerForVerticalScrollbar() : nullptr;
6273 }
6274 
6275 GraphicsLayer* RenderLayer::layerForScrollCorner() const
6276 {
6277     return m_backing ? m_backing-&gt;layerForScrollCorner() : nullptr;
6278 }
6279 
6280 bool RenderLayer::paintsWithTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
6281 {
6282     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6283     return transform() &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || paintsToWindow);
6284 }
6285 
6286 bool RenderLayer::shouldPaintMask(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
6287 {
6288     if (!renderer().hasMask())
6289         return false;
6290 
6291     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6292     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
6293         return true;
6294 
6295     return paintFlags.contains(PaintLayerPaintingCompositingMaskPhase);
6296 }
6297 
6298 bool RenderLayer::shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
6299 {
6300     if (!renderer().hasClipPath())
6301         return false;
6302 
6303     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6304     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
6305         return true;
6306 
6307     return paintFlags.contains(PaintLayerPaintingCompositingClipPathPhase);
6308 }
6309 
6310 bool RenderLayer::scrollingMayRevealBackground() const
6311 {
6312     return scrollsOverflow() || usesCompositedScrolling();
6313 }
6314 
6315 bool RenderLayer::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
6316 {
6317     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
6318         return false;
6319 
6320     if (paintsWithTransparency(PaintBehavior::Normal))
6321         return false;
6322 
6323     if (renderer().isDocumentElementRenderer()) {
6324         // Normally the document element doens&#39;t have a layer.  If it does have a layer, its background propagates to the RenderView
6325         // so this layer doesn&#39;t draw it.
6326         return false;
6327     }
6328 
6329     // We can&#39;t use hasVisibleContent(), because that will be true if our renderer is hidden, but some child
6330     // is visible and that child doesn&#39;t cover the entire rect.
6331     if (renderer().style().visibility() != Visibility::Visible)
6332         return false;
6333 
6334     if (paintsWithFilters() &amp;&amp; renderer().style().filter().hasFilterThatAffectsOpacity())
6335         return false;
6336 
6337     // FIXME: Handle simple transforms.
6338     if (paintsWithTransform(PaintBehavior::Normal))
6339         return false;
6340 
6341     // FIXME: Remove this check.
6342     // This function should not be called when layer-lists are dirty.
6343     // It is somehow getting triggered during style update.
6344     if (zOrderListsDirty() || normalFlowListDirty())
6345         return false;
6346 
6347     // Table painting is special; a table paints its sections.
6348     if (renderer().isTablePart())
6349         return false;
6350 
6351     // FIXME: We currently only check the immediate renderer,
6352     // which will miss many cases.
6353     if (renderer().backgroundIsKnownToBeOpaqueInRect(localRect))
6354         return true;
6355 
6356     // We can&#39;t consult child layers if we clip, since they might cover
6357     // parts of the rect that are clipped out.
6358     if (renderer().hasOverflowClip())
6359         return false;
6360 
6361     return listBackgroundIsKnownToBeOpaqueInRect(positiveZOrderLayers(), localRect)
6362         || listBackgroundIsKnownToBeOpaqueInRect(negativeZOrderLayers(), localRect)
6363         || listBackgroundIsKnownToBeOpaqueInRect(normalFlowLayers(), localRect);
6364 }
6365 
6366 bool RenderLayer::listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp; list, const LayoutRect&amp; localRect) const
6367 {
6368     if (list.begin() == list.end())
6369         return false;
6370 
6371     for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
6372         const auto* childLayer = *iter;
6373         if (childLayer-&gt;isComposited())
6374             continue;
6375 
6376         if (!childLayer-&gt;canUseOffsetFromAncestor())
6377             continue;
6378 
6379         LayoutRect childLocalRect(localRect);
6380         childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
6381 
6382         if (childLayer-&gt;backgroundIsKnownToBeOpaqueInRect(childLocalRect))
6383             return true;
6384     }
6385     return false;
6386 }
6387 
6388 void RenderLayer::repaintIncludingDescendants()
6389 {
6390     renderer().repaint();
6391     for (RenderLayer* current = firstChild(); current; current = current-&gt;nextSibling())
6392         current-&gt;repaintIncludingDescendants();
6393 }
6394 
6395 void RenderLayer::setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer shouldClip)
6396 {
6397     ASSERT(isComposited());
6398     if (backing()-&gt;paintsIntoWindow()) {
6399         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6400         // repaint to the native view system.
6401         renderer().view().repaintViewRectangle(absoluteBoundingBox());
6402     } else
6403         backing()-&gt;setContentsNeedDisplay(shouldClip);
6404 }
6405 
6406 void RenderLayer::setBackingNeedsRepaintInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
6407 {
6408     // https://bugs.webkit.org/show_bug.cgi?id=61159 describes an unreproducible crash here,
6409     // so assert but check that the layer is composited.
6410     ASSERT(isComposited());
6411     if (!isComposited() || backing()-&gt;paintsIntoWindow()) {
6412         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6413         // repaint to the native view system.
6414         LayoutRect absRect(r);
6415         absRect.move(offsetFromAncestor(root()));
6416 
6417         renderer().view().repaintViewRectangle(absRect);
6418     } else
6419         backing()-&gt;setContentsNeedDisplayInRect(r, shouldClip);
6420 }
6421 
6422 // Since we&#39;re only painting non-composited layers, we know that they all share the same repaintContainer.
6423 void RenderLayer::repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer)
6424 {
6425     renderer().repaintUsingContainer(repaintContainer, renderer().clippedOverflowRectForRepaint(repaintContainer));
6426 
6427     for (RenderLayer* curr = firstChild(); curr; curr = curr-&gt;nextSibling()) {
6428         if (!curr-&gt;isComposited())
6429             curr-&gt;repaintIncludingNonCompositingDescendants(repaintContainer);
6430     }
6431 }
6432 
6433 bool RenderLayer::shouldBeSelfPaintingLayer() const
6434 {
6435     if (!isNormalFlowOnly())
6436         return true;
6437 
6438     return hasOverlayScrollbars()
6439         || canUseCompositedScrolling()
6440         || renderer().isTableRow()
6441         || renderer().isCanvas()
6442         || renderer().isVideo()
6443         || renderer().isEmbeddedObject()
6444         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
6445         || renderer().isRenderIFrame()
6446         || renderer().isInFlowRenderFragmentedFlow();
6447 }
6448 
6449 void RenderLayer::updateSelfPaintingLayer()
6450 {
6451     bool isSelfPaintingLayer = shouldBeSelfPaintingLayer();
6452     if (m_isSelfPaintingLayer == isSelfPaintingLayer)
6453         return;
6454 
6455     m_isSelfPaintingLayer = isSelfPaintingLayer;
6456     if (!parent())
6457         return;
6458     if (isSelfPaintingLayer)
6459         parent()-&gt;setAncestorChainHasSelfPaintingLayerDescendant();
6460     else
6461         parent()-&gt;dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
6462 }
6463 
6464 static bool hasVisibleBoxDecorationsOrBackground(const RenderElement&amp; renderer)
6465 {
6466     return renderer.hasVisibleBoxDecorations() || renderer.style().hasOutline();
6467 }
6468 
6469 static bool styleHasSmoothingTextMode(const RenderStyle&amp; style)
6470 {
6471     FontSmoothingMode smoothingMode = style.fontDescription().fontSmoothing();
6472     return smoothingMode == FontSmoothingMode::AutoSmoothing || smoothingMode == FontSmoothingMode::SubpixelAntialiased;
6473 }
6474 
6475 // Constrain the depth and breadth of the search for performance.
6476 static const unsigned maxRendererTraversalCount = 200;
6477 
6478 static void determineNonLayerDescendantsPaintedContent(const RenderElement&amp; renderer, unsigned&amp; renderersTraversed, RenderLayer::PaintedContentRequest&amp; request)
6479 {
6480     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderer)) {
6481         if (++renderersTraversed &gt; maxRendererTraversalCount) {
6482             request.makeStatesUndetermined();
6483             return;
6484         }
6485 
6486         if (is&lt;RenderText&gt;(child)) {
6487             const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
6488             if (!renderText.hasRenderedText())
6489                 continue;
6490 
6491             if (renderer.style().userSelect() != UserSelect::None)
6492                 request.setHasPaintedContent();
6493 
6494             if (!renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()) {
6495                 request.setHasPaintedContent();
6496 
6497                 if (request.needToDetermineSubpixelAntialiasedTextState() &amp;&amp; styleHasSmoothingTextMode(child.style()))
6498                     request.setHasSubpixelAntialiasedText();
6499             }
6500 
6501             if (request.isSatisfied())
6502                 return;
6503         }
6504 
6505         if (!is&lt;RenderElement&gt;(child))
6506             continue;
6507 
6508         const RenderElement&amp; renderElementChild = downcast&lt;RenderElement&gt;(child);
6509 
6510         if (is&lt;RenderLayerModelObject&gt;(renderElementChild) &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(renderElementChild).hasSelfPaintingLayer())
6511             continue;
6512 
6513         if (hasVisibleBoxDecorationsOrBackground(renderElementChild)) {
6514             request.setHasPaintedContent();
6515             if (request.isSatisfied())
6516                 return;
6517         }
6518 
6519         if (is&lt;RenderReplaced&gt;(renderElementChild)) {
6520             request.setHasPaintedContent();
6521 
6522             if (is&lt;RenderImage&gt;(renderElementChild) &amp;&amp; request.needToDetermineSubpixelAntialiasedTextState()) {
6523                 auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderElementChild);
6524                 // May draw text if showing alt text, or image is an SVG image or PDF image.
6525                 if ((imageRenderer.isShowingAltText() || imageRenderer.hasNonBitmapImage()) &amp;&amp; styleHasSmoothingTextMode(child.style()))
6526                     request.setHasSubpixelAntialiasedText();
6527             }
6528 
6529             if (request.isSatisfied())
6530                 return;
6531         }
6532 
6533         determineNonLayerDescendantsPaintedContent(renderElementChild, renderersTraversed, request);
6534         if (request.isSatisfied())
6535             return;
6536     }
6537 }
6538 
6539 bool RenderLayer::hasNonEmptyChildRenderers(PaintedContentRequest&amp; request) const
6540 {
6541     unsigned renderersTraversed = 0;
6542     determineNonLayerDescendantsPaintedContent(renderer(), renderersTraversed, request);
6543     return request.probablyHasPaintedContent();
6544 }
6545 
6546 bool RenderLayer::hasVisibleBoxDecorationsOrBackground() const
6547 {
6548     return WebCore::hasVisibleBoxDecorationsOrBackground(renderer());
6549 }
6550 
6551 bool RenderLayer::hasVisibleBoxDecorations() const
6552 {
6553     if (!hasVisibleContent())
6554         return false;
6555 
6556     return hasVisibleBoxDecorationsOrBackground() || hasOverflowControls();
6557 }
6558 
6559 bool RenderLayer::isVisuallyNonEmpty(PaintedContentRequest* request) const
6560 {
6561     ASSERT(!m_visibleDescendantStatusDirty);
6562 
6563     if (!hasVisibleContent() || !renderer().style().opacity())
6564         return false;
6565 
6566     if (renderer().isRenderReplaced() || hasOverflowControls()) {
6567         if (!request)
6568             return true;
6569 
6570         request-&gt;setHasPaintedContent();
6571         if (request-&gt;isSatisfied())
6572             return true;
6573     }
6574 
6575     if (hasVisibleBoxDecorationsOrBackground()) {
6576         if (!request)
6577             return true;
6578 
6579         request-&gt;setHasPaintedContent();
6580         if (request-&gt;isSatisfied())
6581             return true;
6582     }
6583 
6584     PaintedContentRequest localRequest;
6585     if (!request)
6586         request = &amp;localRequest;
6587 
6588     return hasNonEmptyChildRenderers(*request);
6589 }
6590 
6591 void RenderLayer::updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle)
6592 {
6593     // Overflow are a box concept.
6594     RenderBox* box = renderBox();
6595     if (!box)
6596         return;
6597 
6598     // List box parts handle the scrollbars by themselves so we have nothing to do.
6599     if (box-&gt;style().appearance() == ListboxPart)
6600         return;
6601 
6602     Overflow overflowX = box-&gt;style().overflowX();
6603     Overflow overflowY = box-&gt;style().overflowY();
6604 
6605     // To avoid doing a relayout in updateScrollbarsAfterLayout, we try to keep any automatic scrollbar that was already present.
6606     bool needsHorizontalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasHorizontalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), HorizontalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), HorizontalScrollbar));
6607     bool needsVerticalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasVerticalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), VerticalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), VerticalScrollbar));
6608     setHasHorizontalScrollbar(needsHorizontalScrollbar);
6609     setHasVerticalScrollbar(needsVerticalScrollbar);
6610 
6611     // With non-overlay overflow:scroll, scrollbars are always visible but may be disabled.
6612     // When switching to another value, we need to re-enable them (see bug 11985).
6613     if (m_hBar &amp;&amp; needsHorizontalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowX() == Overflow::Scroll &amp;&amp; overflowX != Overflow::Scroll)
6614         m_hBar-&gt;setEnabled(true);
6615 
6616     if (m_vBar &amp;&amp; needsVerticalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowY() == Overflow::Scroll &amp;&amp; overflowY != Overflow::Scroll)
6617         m_vBar-&gt;setEnabled(true);
6618 
6619     if (!m_scrollDimensionsDirty)
6620         updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
6621 }
6622 
6623 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6624 {
6625     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6626 
6627     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {
6628 #if ENABLE(CSS_COMPOSITING)
6629         if (parent()) {
6630             if (isCSSStackingContext()) {
6631                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6632                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6633             } else {
6634                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6635                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6636                 else if (hasNotIsolatedBlendingDescendants())
6637                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6638             }
6639         }
6640 #endif
6641     }
6642 
6643     // FIXME: RenderLayer already handles visibility changes through our visibility dirty bits. This logic could
6644     // likely be folded along with the rest.
6645     if (oldStyle) {
6646         if (oldStyle-&gt;usedZIndex() != renderer().style().usedZIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {
6647             dirtyStackingContextZOrderLists();
6648             if (isStackingContext())
6649                 dirtyZOrderLists();
6650         }
6651     }
6652 
6653     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6654         if (!m_marquee)
6655             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);
6656         m_marquee-&gt;updateMarqueeStyle();
6657     } else if (m_marquee)
6658         m_marquee = nullptr;
6659 
6660     updateScrollbarsAfterStyleChange(oldStyle);
6661     // Overlay scrollbars can make this layer self-painting so we need
6662     // to recompute the bit once scrollbars have been updated.
6663     updateSelfPaintingLayer();
6664 
6665     if (!hasReflection() &amp;&amp; m_reflection)
6666         removeReflection();
6667     else if (hasReflection()) {
6668         if (!m_reflection)
6669             createReflection();
6670         else
6671             m_reflection-&gt;setStyle(createReflectionStyle());
6672     }
6673 
6674     // FIXME: Need to detect a swap from custom to native scrollbars (and vice versa).
6675     if (m_hBar)
6676         m_hBar-&gt;styleChanged();
6677     if (m_vBar)
6678         m_vBar-&gt;styleChanged();
6679 
6680     updateScrollCornerStyle();
6681     updateResizerStyle();
6682 
6683     updateDescendantDependentFlags();
6684     updateTransform();
6685 #if ENABLE(CSS_COMPOSITING)
6686     updateBlendMode();
6687 #endif
6688     updateFiltersAfterStyleChange();
6689 
6690     compositor().layerStyleChanged(diff, *this, oldStyle);
6691 
6692     updateFilterPaintingStrategy();
6693 
6694 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
6695     if (diff == StyleDifference::RecompositeLayer || diff &gt;= StyleDifference::LayoutPositionedMovementOnly)
6696         renderer().document().invalidateRenderingDependentRegions();
6697 #else
6698     UNUSED_PARAM(diff);
6699 #endif
6700 }
6701 
6702 void RenderLayer::updateScrollableAreaSet(bool hasOverflow)
6703 {
6704     FrameView&amp; frameView = renderer().view().frameView();
6705 
6706     bool isVisibleToHitTest = renderer().visibleToHitTesting();
6707     if (HTMLFrameOwnerElement* owner = frameView.frame().ownerElement())
6708         isVisibleToHitTest &amp;= owner-&gt;renderer() &amp;&amp; owner-&gt;renderer()-&gt;visibleToHitTesting();
6709 
6710     bool isScrollable = hasOverflow &amp;&amp; isVisibleToHitTest;
6711     bool addedOrRemoved = false;
6712 
6713     ASSERT(m_registeredScrollableArea == frameView.containsScrollableArea(this));
6714 
6715     if (isScrollable) {
6716         if (!m_registeredScrollableArea) {
6717             addedOrRemoved = frameView.addScrollableArea(this);
6718             m_registeredScrollableArea = true;
6719         }
6720     } else if (m_registeredScrollableArea) {
6721         addedOrRemoved = frameView.removeScrollableArea(this);
6722         m_registeredScrollableArea = false;
6723     }
6724 
6725 #if ENABLE(IOS_TOUCH_EVENTS)
6726     if (addedOrRemoved) {
6727         if (isScrollable &amp;&amp; !canUseCompositedScrolling())
6728             registerAsTouchEventListenerForScrolling();
6729         else {
6730             // We only need the touch listener for unaccelerated overflow scrolling, so if we became
6731             // accelerated, remove ourselves as a touch event listener.
6732             unregisterAsTouchEventListenerForScrolling();
6733         }
6734     }
6735 #else
6736     UNUSED_VARIABLE(addedOrRemoved);
6737 #endif
6738 }
6739 
6740 void RenderLayer::updateScrollCornerStyle()
6741 {
6742     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6743     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;actualRenderer-&gt;style()) : nullptr;
6744 
6745     if (!corner) {
6746         clearScrollCorner();
6747         return;
6748     }
6749 
6750     if (!m_scrollCorner) {
6751         m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*corner));
6752         // FIXME: A renderer should be a child of its parent!
6753         m_scrollCorner-&gt;setParent(&amp;renderer());
6754         m_scrollCorner-&gt;initializeStyle();
6755     } else
6756         m_scrollCorner-&gt;setStyle(WTFMove(*corner));
6757 }
6758 
6759 void RenderLayer::clearScrollCorner()
6760 {
6761     if (!m_scrollCorner)
6762         return;
6763     m_scrollCorner-&gt;setParent(nullptr);
6764     m_scrollCorner = nullptr;
6765 }
6766 
6767 void RenderLayer::updateResizerStyle()
6768 {
6769     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6770     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::Resizer }, &amp;actualRenderer-&gt;style()) : nullptr;
6771 
6772     if (!resizer) {
6773         clearResizer();
6774         return;
6775     }
6776 
6777     if (!m_resizer) {
6778         m_resizer = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*resizer));
6779         // FIXME: A renderer should be a child of its parent!
6780         m_resizer-&gt;setParent(&amp;renderer());
6781         m_resizer-&gt;initializeStyle();
6782     } else
6783         m_resizer-&gt;setStyle(WTFMove(*resizer));
6784 }
6785 
6786 void RenderLayer::clearResizer()
6787 {
6788     if (!m_resizer)
6789         return;
6790     m_resizer-&gt;setParent(nullptr);
6791     m_resizer = nullptr;
6792 }
6793 
6794 RenderLayer* RenderLayer::reflectionLayer() const
6795 {
6796     return m_reflection ? m_reflection-&gt;layer() : nullptr;
6797 }
6798 
6799 bool RenderLayer::isReflectionLayer(const RenderLayer&amp; layer) const
6800 {
6801     return m_reflection ? &amp;layer == m_reflection-&gt;layer() : false;
6802 }
6803 
6804 void RenderLayer::createReflection()
6805 {
6806     ASSERT(!m_reflection);
6807     m_reflection = createRenderer&lt;RenderReplica&gt;(renderer().document(), createReflectionStyle());
6808     // FIXME: A renderer should be a child of its parent!
6809     m_reflection-&gt;setParent(&amp;renderer()); // We create a 1-way connection.
6810     m_reflection-&gt;initializeStyle();
6811 }
6812 
6813 void RenderLayer::removeReflection()
6814 {
6815     if (!m_reflection-&gt;renderTreeBeingDestroyed())
6816         m_reflection-&gt;removeLayers(this);
6817 
6818     m_reflection-&gt;setParent(nullptr);
6819     m_reflection = nullptr;
6820 }
6821 
6822 RenderStyle RenderLayer::createReflectionStyle()
6823 {
6824     auto newStyle = RenderStyle::create();
6825     newStyle.inheritFrom(renderer().style());
6826 
6827     // Map in our transform.
6828     TransformOperations transform;
6829     switch (renderer().style().boxReflect()-&gt;direction()) {
6830     case ReflectionDirection::Below:
6831         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6832         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6833         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6834         break;
6835     case ReflectionDirection::Above:
6836         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6837         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6838         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6839         break;
6840     case ReflectionDirection::Right:
6841         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6842         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6843         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6844         break;
6845     case ReflectionDirection::Left:
6846         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6847         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6848         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6849         break;
6850     }
6851     newStyle.setTransform(transform);
6852 
6853     // Map in our mask.
6854     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6855 
6856     // Style has transform and mask, so needs to be stacking context.
6857     newStyle.setUsedZIndex(0);
6858 
6859     return newStyle;
6860 }
6861 
6862 void RenderLayer::ensureLayerFilters()
6863 {
6864     if (m_filters)
6865         return;
6866 
6867     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);
6868 }
6869 
6870 void RenderLayer::clearLayerFilters()
6871 {
6872     m_filters = nullptr;
6873 }
6874 
6875 void RenderLayer::updateFiltersAfterStyleChange()
6876 {
6877     if (!hasFilter()) {
6878         clearLayerFilters();
6879         return;
6880     }
6881 
6882     // Add the filter as a client to this renderer, unless we are a RenderLayer accommodating
6883     // an SVG. In that case it takes care of its own resource management for filters.
6884     if (renderer().style().filter().hasReferenceFilter() &amp;&amp; !renderer().isSVGRoot()) {
6885         ensureLayerFilters();
6886         m_filters-&gt;updateReferenceFilterClients(renderer().style().filter());
6887     } else if (m_filters)
6888         m_filters-&gt;removeReferenceFilterClients();
6889 }
6890 
6891 void RenderLayer::updateFilterPaintingStrategy()
6892 {
6893     // RenderLayerFilters is only used to render the filters in software mode,
6894     // so we always need to run updateFilterPaintingStrategy() after the composited
6895     // mode might have changed for this layer.
6896     if (!paintsWithFilters()) {
6897         // Don&#39;t delete the whole filter info here, because we might use it
6898         // for loading SVG reference filter files.
6899         if (m_filters)
6900             m_filters-&gt;setFilter(nullptr);
6901 
6902         // Early-return only if we *don&#39;t* have reference filters.
6903         // For reference filters, we still want the FilterEffect graph built
6904         // for us, even if we&#39;re composited.
6905         if (!renderer().style().filter().hasReferenceFilter())
6906             return;
6907     }
6908 
6909     ensureLayerFilters();
6910     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);
6911 }
6912 
<a name="4" id="anc4"></a>









6913 IntOutsets RenderLayer::filterOutsets() const
6914 {
6915     if (m_filters)
6916         return m_filters-&gt;filter() ? m_filters-&gt;filter()-&gt;outsets() : IntOutsets();
6917     return renderer().style().filterOutsets();
6918 }
6919 
6920 bool RenderLayer::isTransparentRespectingParentFrames() const
6921 {
6922     static const double minimumVisibleOpacity = 0.01;
6923 
6924     float currentOpacity = 1;
6925     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
6926         currentOpacity *= layer-&gt;renderer().style().opacity();
6927         if (currentOpacity &lt; minimumVisibleOpacity)
6928             return true;
6929     }
6930 
6931     return false;
6932 }
6933 
6934 void RenderLayer::invalidateEventRegion()
6935 {
6936 #if PLATFORM(IOS_FAMILY)
6937     auto* compositingLayer = enclosingCompositingLayerForRepaint();
6938     if (!compositingLayer)
6939         return;
6940 
6941     auto maintainsEventRegion = [&amp;] {
6942         // UI side scroll overlap testing.
6943         if (!compositingLayer-&gt;isRenderViewLayer())
6944             return true;
6945 #if ENABLE(POINTER_EVENTS)
6946         // UI side touch-action resolution.
6947         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())
6948             return true;
6949 #endif
6950         return false;
6951     };
6952 
6953     if (!maintainsEventRegion())
6954         return;
6955 
6956     compositingLayer-&gt;setNeedsCompositingConfigurationUpdate();
6957 #endif
6958 }
6959 
6960 TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, ClipRectsType clipRectsType)
6961 {
6962     switch (clipRectsType) {
6963     case PaintingClipRects: ts &lt;&lt; &quot;painting&quot;; break;
6964     case RootRelativeClipRects: ts &lt;&lt; &quot;root-relative&quot;; break;
6965     case AbsoluteClipRects: ts &lt;&lt; &quot;absolute&quot;; break;
6966     case TemporaryClipRects: ts &lt;&lt; &quot;temporary&quot;; break;
6967     case NumCachedClipRectsTypes:
6968     case AllClipRectTypes:
6969         ts &lt;&lt; &quot;?&quot;;
6970         break;
6971     }
6972     return ts;
6973 }
6974 
6975 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
6976 {
6977     ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
6978     if (layer.transform())
6979         ts &lt;&lt; &quot; has transform&quot;;
6980     if (layer.hasFilter())
6981         ts &lt;&lt; &quot; has filter&quot;;
6982     if (layer.hasBackdropFilter())
6983         ts &lt;&lt; &quot; has backdrop filter&quot;;
6984     if (layer.hasBlendMode())
6985         ts &lt;&lt; &quot; has blend mode&quot;;
6986     if (layer.isolatesBlending())
6987         ts &lt;&lt; &quot; isolates blending&quot;;
6988     if (layer.isComposited())
6989         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
6990     return ts;
6991 }
6992 
6993 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)
6994 {
6995     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);
6996     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);
6997     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);
6998 
6999     return ts;
7000 }
7001 
7002 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)
7003 {
7004     switch (reason) {
7005     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;
7006     case IndirectCompositingReason::Clipping: ts &lt;&lt; &quot;clipping&quot;; break;
7007     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;
7008     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;
7009     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;
7010     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;
7011     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;
7012     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;
7013     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;
7014     }
7015 
7016     return ts;
7017 }
7018 
7019 } // namespace WebCore
7020 
7021 #if ENABLE(TREE_DEBUGGING)
7022 
7023 void showLayerTree(const WebCore::RenderLayer* layer)
7024 {
7025     if (!layer)
7026         return;
7027 
7028     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), {
7029         WebCore::RenderAsTextFlag::ShowAllLayers,
7030         WebCore::RenderAsTextFlag::ShowLayerNesting,
7031         WebCore::RenderAsTextFlag::ShowCompositedLayers,
7032         WebCore::RenderAsTextFlag::ShowOverflow,
7033         WebCore::RenderAsTextFlag::ShowSVGGeometry,
7034         WebCore::RenderAsTextFlag::ShowLayerFragments,
7035         WebCore::RenderAsTextFlag::ShowAddresses,
7036         WebCore::RenderAsTextFlag::ShowIDAndClass,
7037         WebCore::RenderAsTextFlag::DontUpdateLayout,
7038         WebCore::RenderAsTextFlag::ShowLayoutState,
7039     });
7040     fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
7041 }
7042 
7043 void showLayerTree(const WebCore::RenderObject* renderer)
7044 {
7045     if (!renderer)
7046         return;
7047     showLayerTree(renderer-&gt;enclosingLayer());
7048 }
7049 
7050 static void outputPaintOrderTreeLegend(TextStream&amp; stream)
7051 {
7052     stream.nextLine();
7053     stream &lt;&lt; &quot;(S)tacking Context/(F)orced SC/O(P)portunistic SC, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, Behaves as fi(x)ed, (C)omposited, (P)rovides backing/uses (p)rovided backing/paints to (a)ncestor, (c)omposited descendant, (s)scrolling ancestor, (t)transformed ancestor\n&quot;
7054         &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
7055         &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
7056         &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
7057     stream.nextLine();
7058 }
7059 
7060 static void outputIdent(TextStream&amp; stream, unsigned depth)
7061 {
7062     unsigned i = 0;
7063     while (++i &lt;= depth * 2)
7064         stream &lt;&lt; &quot; &quot;;
7065 }
7066 
7067 static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
7068 {
7069     stream &lt;&lt; (layer.isCSSStackingContext() ? &quot;S&quot; : (layer.isForcedStackingContext() ? &quot;F&quot; : (layer.isOpportunisticStackingContext() ? &quot;P&quot; : &quot;-&quot;)));
7070     stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
7071     stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
7072     stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
7073     stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
7074     stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
7075     stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
7076     stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
7077     stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
7078     stream &lt;&lt; (layer.behavesAsFixed() ? &quot;x&quot; : &quot;-&quot;);
7079     stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
7080 
7081     auto compositedPaintingDestinationString = [&amp;layer]() {
7082         if (layer.paintsIntoProvidedBacking())
7083             return &quot;p&quot;;
7084 
7085         if (!layer.isComposited())
7086             return &quot;-&quot;;
7087 
7088         if (layer.backing()-&gt;hasBackingSharingLayers())
7089             return &quot;P&quot;;
7090 
7091         if (layer.backing()-&gt;paintsIntoCompositedAncestor())
7092             return &quot;a&quot;;
7093 
7094         return &quot;-&quot;;
7095     };
7096 
7097     stream &lt;&lt; compositedPaintingDestinationString();
7098     stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
7099     stream &lt;&lt; (layer.hasCompositedScrollingAncestor() ? &quot;s&quot; : &quot;-&quot;);
7100     stream &lt;&lt; (layer.hasTransformedAncestor() ? &quot;t&quot; : &quot;-&quot;);
7101 
7102     stream &lt;&lt; &quot; &quot;;
7103 
7104     stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
7105     stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
7106 
7107     stream &lt;&lt; &quot; &quot;;
7108 
7109     stream &lt;&lt; (layer.hasDescendantNeedingCompositingRequirementsTraversal() ? &quot;t&quot; : &quot;-&quot;);
7110     stream &lt;&lt; (layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() ? &quot;b&quot; : &quot;-&quot;);
7111     stream &lt;&lt; (layer.descendantsNeedCompositingRequirementsTraversal() ? &quot;r&quot; : &quot;-&quot;);
7112     stream &lt;&lt; (layer.subsequentLayersNeedCompositingRequirementsTraversal() ? &quot;s&quot; : &quot;-&quot;);
7113     stream &lt;&lt; (layer.descendantsNeedUpdateBackingAndHierarchyTraversal() ? &quot;h&quot; : &quot;-&quot;);
7114     stream &lt;&lt; (layer.needsCompositingPaintOrderChildrenUpdate() ? &quot;o&quot; : &quot;-&quot;);
7115 
7116     stream &lt;&lt; &quot; &quot;;
7117 
7118     stream &lt;&lt; (layer.needsPostLayoutCompositingUpdate() ? &quot;l&quot; : &quot;-&quot;);
7119     stream &lt;&lt; (layer.needsCompositingGeometryUpdate() ? &quot;g&quot; : &quot;-&quot;);
7120     stream &lt;&lt; (layer.childrenNeedCompositingGeometryUpdate() ? &quot;k&quot; : &quot;-&quot;);
7121     stream &lt;&lt; (layer.needsCompositingConfigurationUpdate() ? &quot;c&quot; : &quot;-&quot;);
7122     stream &lt;&lt; (layer.needsCompositingLayerConnection() ? &quot;x&quot; : &quot;-&quot;);
7123     stream &lt;&lt; (layer.needsScrollingTreeUpdate() ? &quot;s&quot; : &quot;-&quot;);
7124 
7125     stream &lt;&lt; &quot; &quot;;
7126 
7127     outputIdent(stream, depth);
7128 
7129     stream &lt;&lt; prefix;
7130 
7131     auto layerRect = layer.rect();
7132 
7133     stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
7134     if (layer.isComposited()) {
7135         auto&amp; backing = *layer.backing();
7136         stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
7137 
7138         if (layer.indirectCompositingReason() != WebCore::IndirectCompositingReason::None)
7139             stream &lt;&lt; &quot; &quot; &lt;&lt; layer.indirectCompositingReason();
7140 
7141         auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
7142         auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
7143         auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
7144         auto positionedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Positioning);
7145 
7146         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID || positionedNodeID) {
7147             stream &lt;&lt; &quot; {&quot;;
7148             bool first = true;
7149             if (scrollingNodeID) {
7150                 stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
7151                 first = false;
7152             }
7153 
7154             if (frameHostingNodeID) {
7155                 if (!first)
7156                     stream &lt;&lt; &quot;, &quot;;
7157                 stream &lt;&lt; &quot;fh &quot; &lt;&lt; frameHostingNodeID;
7158                 first = false;
7159             }
7160 
7161             if (viewportConstrainedNodeID) {
7162                 if (!first)
7163                     stream &lt;&lt; &quot;, &quot;;
7164                 stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;
7165                 first = false;
7166             }
7167 
7168             if (positionedNodeID) {
7169                 if (!first)
7170                     stream &lt;&lt; &quot;, &quot;;
7171                 stream &lt;&lt; &quot;pos &quot; &lt;&lt; positionedNodeID;
7172             }
7173 
7174             stream &lt;&lt; &quot;}&quot;;
7175         }
7176     }
7177     stream &lt;&lt; &quot; &quot; &lt;&lt; layer.name();
7178     stream.nextLine();
7179 
7180     const_cast&lt;WebCore::RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
7181 
7182     for (auto* child : layer.negativeZOrderLayers())
7183         outputPaintOrderTreeRecursive(stream, *child, &quot;- &quot;, depth + 1);
7184 
7185     for (auto* child : layer.normalFlowLayers())
7186         outputPaintOrderTreeRecursive(stream, *child, &quot;n &quot;, depth + 1);
7187 
7188     for (auto* child : layer.positiveZOrderLayers())
7189         outputPaintOrderTreeRecursive(stream, *child, &quot;+ &quot;, depth + 1);
7190 }
7191 
7192 void showPaintOrderTree(const WebCore::RenderLayer* layer)
7193 {
7194     TextStream stream;
7195     outputPaintOrderTreeLegend(stream);
7196     if (layer)
7197         outputPaintOrderTreeRecursive(stream, *layer, &quot;&quot;);
7198 
7199     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
7200 }
7201 
7202 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
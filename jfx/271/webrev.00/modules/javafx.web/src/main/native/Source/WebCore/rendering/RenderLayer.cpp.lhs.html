<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  * Copyright (C) 2019 Adobe. All rights reserved.
   4  *
   5  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   6  *
   7  * Other contributors:
   8  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   9  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
  10  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  11  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  12  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  13  *   Josh Soref &lt;timeless@mac.com&gt;
  14  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Lesser General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2.1 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24  * Lesser General Public License for more details.
  25  *
  26  * You should have received a copy of the GNU Lesser General Public
  27  * License along with this library; if not, write to the Free Software
  28  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  29  *
  30  * Alternatively, the contents of this file may be used under the terms
  31  * of either the Mozilla Public License Version 1.1, found at
  32  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  33  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  34  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  35  * applicable instead of those above.  If you wish to allow use of your
  36  * version of this file only under the terms of one of those two
  37  * licenses (the MPL or the GPL) and not to allow others to use your
  38  * version of this file under the LGPL, indicate your decision by
  39  * deletingthe provisions above and replace them with the notice and
  40  * other provisions required by the MPL or the GPL, as the case may be.
  41  * If you do not delete the provisions above, a recipient may use your
  42  * version of this file under any of the LGPL, the MPL or the GPL.
  43  */
  44 
  45 #include &quot;config.h&quot;
  46 #include &quot;RenderLayer.h&quot;
  47 
  48 #include &quot;BoxShape.h&quot;
  49 #include &quot;CSSAnimationController.h&quot;
  50 #include &quot;CSSFilter.h&quot;
  51 #include &quot;CSSPropertyNames.h&quot;
  52 #include &quot;Chrome.h&quot;
  53 #include &quot;DebugPageOverlays.h&quot;
  54 #include &quot;DeprecatedGlobalSettings.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentMarkerController.h&quot;
  57 #include &quot;DocumentTimeline.h&quot;
  58 #include &quot;Editor.h&quot;
  59 #include &quot;Element.h&quot;
  60 #include &quot;EventHandler.h&quot;
  61 #include &quot;FEColorMatrix.h&quot;
  62 #include &quot;FEMerge.h&quot;
  63 #include &quot;FloatConversion.h&quot;
  64 #include &quot;FloatPoint3D.h&quot;
  65 #include &quot;FloatRect.h&quot;
  66 #include &quot;FloatRoundedRect.h&quot;
  67 #include &quot;FocusController.h&quot;
  68 #include &quot;Frame.h&quot;
  69 #include &quot;FrameLoader.h&quot;
  70 #include &quot;FrameLoaderClient.h&quot;
  71 #include &quot;FrameSelection.h&quot;
  72 #include &quot;FrameTree.h&quot;
  73 #include &quot;FrameView.h&quot;
  74 #include &quot;Gradient.h&quot;
  75 #include &quot;GraphicsContext.h&quot;
  76 #include &quot;HTMLFormControlElement.h&quot;
  77 #include &quot;HTMLFrameElement.h&quot;
  78 #include &quot;HTMLFrameOwnerElement.h&quot;
  79 #include &quot;HTMLIFrameElement.h&quot;
  80 #include &quot;HTMLNames.h&quot;
  81 #include &quot;HTMLParserIdioms.h&quot;
  82 #include &quot;HitTestRequest.h&quot;
  83 #include &quot;HitTestResult.h&quot;
  84 #include &quot;HitTestingTransformState.h&quot;
  85 #include &quot;Logging.h&quot;
  86 #include &quot;OverflowEvent.h&quot;
  87 #include &quot;OverlapTestRequestClient.h&quot;
  88 #include &quot;Page.h&quot;
  89 #include &quot;PlatformMouseEvent.h&quot;
  90 #include &quot;RenderFlexibleBox.h&quot;
  91 #include &quot;RenderFragmentContainer.h&quot;
  92 #include &quot;RenderFragmentedFlow.h&quot;
  93 #include &quot;RenderGeometryMap.h&quot;
  94 #include &quot;RenderImage.h&quot;
  95 #include &quot;RenderInline.h&quot;
  96 #include &quot;RenderIterator.h&quot;
  97 #include &quot;RenderLayerBacking.h&quot;
  98 #include &quot;RenderLayerCompositor.h&quot;
  99 #include &quot;RenderLayerFilters.h&quot;
 100 #include &quot;RenderMarquee.h&quot;
 101 #include &quot;RenderMultiColumnFlow.h&quot;
 102 #include &quot;RenderReplica.h&quot;
 103 #include &quot;RenderSVGResourceClipper.h&quot;
 104 #include &quot;RenderSVGRoot.h&quot;
 105 #include &quot;RenderScrollbar.h&quot;
 106 #include &quot;RenderScrollbarPart.h&quot;
 107 #include &quot;RenderTableCell.h&quot;
 108 #include &quot;RenderTableRow.h&quot;
 109 #include &quot;RenderText.h&quot;
 110 #include &quot;RenderTheme.h&quot;
 111 #include &quot;RenderTreeAsText.h&quot;
 112 #include &quot;RenderView.h&quot;
 113 #include &quot;RuntimeEnabledFeatures.h&quot;
 114 #include &quot;SVGNames.h&quot;
 115 #include &quot;ScaleTransformOperation.h&quot;
 116 #include &quot;ScriptDisallowedScope.h&quot;
 117 #include &quot;ScrollAnimator.h&quot;
 118 #include &quot;Scrollbar.h&quot;
 119 #include &quot;ScrollbarTheme.h&quot;
 120 #include &quot;ScrollingCoordinator.h&quot;
 121 #include &quot;Settings.h&quot;
 122 #include &quot;ShadowRoot.h&quot;
 123 #include &quot;SourceGraphic.h&quot;
 124 #include &quot;StyleProperties.h&quot;
 125 #include &quot;StyleResolver.h&quot;
 126 #include &quot;TransformationMatrix.h&quot;
 127 #include &quot;TranslateTransformOperation.h&quot;
 128 #include &quot;WheelEventTestMonitor.h&quot;
 129 #include &lt;stdio.h&gt;
 130 #include &lt;wtf/MonotonicTime.h&gt;
 131 #include &lt;wtf/StdLibExtras.h&gt;
 132 #include &lt;wtf/text/CString.h&gt;
 133 #include &lt;wtf/text/TextStream.h&gt;
 134 
 135 #if ENABLE(CSS_SCROLL_SNAP)
 136 #include &quot;AxisScrollSnapOffsets.h&quot;
 137 #endif
 138 
 139 #define MIN_INTERSECT_FOR_REVEAL 32
 140 
 141 namespace WebCore {
 142 
 143 using namespace HTMLNames;
 144 
 145 class ClipRects : public RefCounted&lt;ClipRects&gt; {
 146     WTF_MAKE_FAST_ALLOCATED;
 147 public:
 148     static Ref&lt;ClipRects&gt; create()
 149     {
 150         return adoptRef(*new ClipRects);
 151     }
 152 
 153     static Ref&lt;ClipRects&gt; create(const ClipRects&amp; other)
 154     {
 155         return adoptRef(*new ClipRects(other));
 156     }
 157 
 158     void reset()
 159     {
 160         m_overflowClipRect.reset();
 161         m_fixedClipRect.reset();
 162         m_posClipRect.reset();
 163         m_fixed = false;
 164     }
 165 
 166     const ClipRect&amp; overflowClipRect() const { return m_overflowClipRect; }
 167     void setOverflowClipRect(const ClipRect&amp; clipRect) { m_overflowClipRect = clipRect; }
 168 
 169     const ClipRect&amp; fixedClipRect() const { return m_fixedClipRect; }
 170     void setFixedClipRect(const ClipRect&amp; clipRect) { m_fixedClipRect = clipRect; }
 171 
 172     const ClipRect&amp; posClipRect() const { return m_posClipRect; }
 173     void setPosClipRect(const ClipRect&amp; clipRect) { m_posClipRect = clipRect; }
 174 
 175     bool fixed() const { return m_fixed; }
 176     void setFixed(bool fixed) { m_fixed = fixed; }
 177 
 178     bool operator==(const ClipRects&amp; other) const
 179     {
 180         return m_overflowClipRect == other.overflowClipRect()
 181             &amp;&amp; m_fixedClipRect == other.fixedClipRect()
 182             &amp;&amp; m_posClipRect == other.posClipRect()
 183             &amp;&amp; m_fixed == other.fixed();
 184     }
 185 
 186     ClipRects&amp; operator=(const ClipRects&amp; other)
 187     {
 188         m_overflowClipRect = other.overflowClipRect();
 189         m_fixedClipRect = other.fixedClipRect();
 190         m_posClipRect = other.posClipRect();
 191         m_fixed = other.fixed();
 192         return *this;
 193     }
 194 
 195 private:
 196     ClipRects() = default;
 197 
 198     ClipRects(const LayoutRect&amp; clipRect)
 199         : m_overflowClipRect(clipRect)
 200         , m_fixedClipRect(clipRect)
 201         , m_posClipRect(clipRect)
 202     {
 203     }
 204 
 205     ClipRects(const ClipRects&amp; other)
 206         : RefCounted()
 207         , m_fixed(other.fixed())
 208         , m_overflowClipRect(other.overflowClipRect())
 209         , m_fixedClipRect(other.fixedClipRect())
 210         , m_posClipRect(other.posClipRect())
 211     {
 212     }
 213 
 214     bool m_fixed { false };
 215     ClipRect m_overflowClipRect;
 216     ClipRect m_fixedClipRect;
 217     ClipRect m_posClipRect;
 218 };
 219 
 220 class ClipRectsCache {
 221     WTF_MAKE_FAST_ALLOCATED;
 222 public:
 223     ClipRectsCache()
 224     {
 225 #if ASSERT_ENABLED
 226         for (int i = 0; i &lt; NumCachedClipRectsTypes; ++i) {
 227             m_clipRectsRoot[i] = 0;
 228             m_scrollbarRelevancy[i] = IgnoreOverlayScrollbarSize;
 229         }
 230 #endif
 231     }
 232 
 233     ClipRects* getClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 234     {
 235         return m_clipRects[getIndex(clipRectsType, respectOverflow)].get();
 236     }
 237 
 238     void setClipRects(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow, RefPtr&lt;ClipRects&gt;&amp;&amp; clipRects)
 239     {
 240         m_clipRects[getIndex(clipRectsType, respectOverflow)] = WTFMove(clipRects);
 241     }
 242 
 243 #if ASSERT_ENABLED
 244     const RenderLayer* m_clipRectsRoot[NumCachedClipRectsTypes];
 245     OverlayScrollbarSizeRelevancy m_scrollbarRelevancy[NumCachedClipRectsTypes];
 246 #endif
 247 
 248 private:
 249     unsigned getIndex(ClipRectsType clipRectsType, ShouldRespectOverflowClip respectOverflow) const
 250     {
 251         unsigned index = static_cast&lt;unsigned&gt;(clipRectsType);
 252         if (respectOverflow == RespectOverflowClip)
 253             index += static_cast&lt;unsigned&gt;(NumCachedClipRectsTypes);
 254         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; NumCachedClipRectsTypes * 2);
 255         return index;
 256     }
 257 
 258     RefPtr&lt;ClipRects&gt; m_clipRects[NumCachedClipRectsTypes * 2];
 259 };
 260 
 261 void makeMatrixRenderable(TransformationMatrix&amp; matrix, bool has3DRendering)
 262 {
 263 #if !ENABLE(3D_TRANSFORMS)
 264     UNUSED_PARAM(has3DRendering);
 265     matrix.makeAffine();
 266 #else
 267     if (!has3DRendering)
 268         matrix.makeAffine();
 269 #endif
 270 }
 271 
 272 #if !LOG_DISABLED
 273 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipRects&amp; clipRects)
 274 {
 275     TextStream::GroupScope scope(ts);
 276     ts &lt;&lt; indent &lt;&lt; &quot;ClipRects\n&quot;;
 277     ts &lt;&lt; indent &lt;&lt; &quot;  overflow  : &quot; &lt;&lt; clipRects.overflowClipRect() &lt;&lt; &quot;\n&quot;;
 278     ts &lt;&lt; indent &lt;&lt; &quot;  fixed     : &quot; &lt;&lt; clipRects.fixedClipRect() &lt;&lt; &quot;\n&quot;;
 279     ts &lt;&lt; indent &lt;&lt; &quot;  positioned: &quot; &lt;&lt; clipRects.posClipRect() &lt;&lt; &quot;\n&quot;;
 280 
 281     return ts;
 282 }
 283 
 284 #endif
 285 
 286 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);
 287 
 288 RenderLayer::RenderLayer(RenderLayerModelObject&amp; rendererLayerModelObject)
 289     : m_isRenderViewLayer(rendererLayerModelObject.isRenderView())
 290     , m_forcedStackingContext(rendererLayerModelObject.isMedia())
 291     , m_isNormalFlowOnly(false)
 292     , m_isCSSStackingContext(false)
 293     , m_isOpportunisticStackingContext(false)
 294     , m_zOrderListsDirty(false)
 295     , m_normalFlowListDirty(true)
 296     , m_hadNegativeZOrderList(false)
 297     , m_inResizeMode(false)
 298     , m_scrollDimensionsDirty(true)
 299     , m_hasSelfPaintingLayerDescendant(false)
 300     , m_hasSelfPaintingLayerDescendantDirty(false)
 301     , m_usedTransparency(false)
 302     , m_paintingInsideReflection(false)
 303     , m_inOverflowRelayout(false)
 304     , m_repaintStatus(NeedsNormalRepaint)
 305     , m_visibleContentStatusDirty(true)
 306     , m_hasVisibleContent(false)
 307     , m_visibleDescendantStatusDirty(false)
 308     , m_hasVisibleDescendant(false)
 309     , m_registeredScrollableArea(false)
 310     , m_isFixedIntersectingViewport(false)
 311     , m_behavesAsFixed(false)
 312     , m_3DTransformedDescendantStatusDirty(true)
 313     , m_has3DTransformedDescendant(false)
 314     , m_hasCompositingDescendant(false)
 315     , m_hasCompositedScrollingAncestor(false)
 316     , m_hasCompositedScrollableOverflow(false)
 317     , m_hasTransformedAncestor(false)
 318     , m_has3DTransformedAncestor(false)
 319     , m_indirectCompositingReason(static_cast&lt;unsigned&gt;(IndirectCompositingReason::None))
 320     , m_viewportConstrainedNotCompositedReason(NoNotCompositedReason)
 321 #if PLATFORM(IOS_FAMILY)
 322 #if ENABLE(IOS_TOUCH_EVENTS)
 323     , m_registeredAsTouchEventListenerForScrolling(false)
 324 #endif
 325     , m_adjustForIOSCaretWhenScrolling(false)
 326 #endif
 327     , m_requiresScrollPositionReconciliation(false)
 328     , m_containsDirtyOverlayScrollbars(false)
 329     , m_updatingMarqueePosition(false)
 330 #if ASSERT_ENABLED
 331     , m_layerListMutationAllowed(true)
 332 #endif
 333 #if ENABLE(CSS_COMPOSITING)
 334     , m_blendMode(static_cast&lt;unsigned&gt;(BlendMode::Normal))
 335     , m_hasNotIsolatedCompositedBlendingDescendants(false)
 336     , m_hasNotIsolatedBlendingDescendants(false)
 337     , m_hasNotIsolatedBlendingDescendantsStatusDirty(false)
 338 #endif
 339     , m_renderer(rendererLayerModelObject)
 340 {
 341     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
 342     setIsCSSStackingContext(shouldBeCSSStackingContext());
 343 
 344     m_isSelfPaintingLayer = shouldBeSelfPaintingLayer();
 345 
 346     if (!renderer().firstChild()) {
 347         m_visibleContentStatusDirty = false;
 348         m_hasVisibleContent = renderer().style().visibility() == Visibility::Visible;
 349     }
 350 
 351     if (Element* element = renderer().element()) {
 352         // We save and restore only the scrollOffset as the other scroll values are recalculated.
 353         m_scrollPosition = element-&gt;savedLayerScrollPosition();
 354         if (!m_scrollPosition.isZero())
 355             scrollAnimator().setCurrentPosition(m_scrollPosition);
 356         element-&gt;setSavedLayerScrollPosition(IntPoint());
 357     }
 358 }
 359 
 360 RenderLayer::~RenderLayer()
 361 {
 362     if (inResizeMode())
 363         renderer().frame().eventHandler().resizeLayerDestroyed();
 364 
 365     ASSERT(m_registeredScrollableArea == renderer().view().frameView().containsScrollableArea(this));
 366 
 367     if (m_registeredScrollableArea)
 368         renderer().view().frameView().removeScrollableArea(this);
 369 
 370 #if ENABLE(IOS_TOUCH_EVENTS)
 371     unregisterAsTouchEventListenerForScrolling();
 372 #endif
 373     if (Element* element = renderer().element())
 374         element-&gt;setSavedLayerScrollPosition(m_scrollPosition);
 375 
 376     destroyScrollbar(HorizontalScrollbar);
 377     destroyScrollbar(VerticalScrollbar);
 378 
 379     if (auto* scrollingCoordinator = renderer().page().scrollingCoordinator())
 380         scrollingCoordinator-&gt;willDestroyScrollableArea(*this);
 381 
 382     if (m_reflection)
 383         removeReflection();
 384 
 385     clearScrollCorner();
 386     clearResizer();
 387 
 388     clearLayerFilters();
 389 
 390     if (paintsIntoProvidedBacking()) {
 391         auto* backingProviderLayer = this-&gt;backingProviderLayer();
 392         if (backingProviderLayer-&gt;backing())
 393             backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);
 394     }
 395 
 396     // Child layers will be deleted by their corresponding render objects, so
 397     // we don&#39;t need to delete them ourselves.
 398 
 399     clearBacking(true);
 400 
 401     // Layer and all its children should be removed from the tree before destruction.
 402     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !parent());
 403     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(renderer().renderTreeBeingDestroyed() || !firstChild());
 404 }
 405 
 406 void RenderLayer::addChild(RenderLayer&amp; child, RenderLayer* beforeChild)
 407 {
 408     RenderLayer* prevSibling = beforeChild ? beforeChild-&gt;previousSibling() : lastChild();
 409     if (prevSibling) {
 410         child.setPreviousSibling(prevSibling);
 411         prevSibling-&gt;setNextSibling(&amp;child);
 412         ASSERT(prevSibling != &amp;child);
 413     } else
 414         setFirstChild(&amp;child);
 415 
 416     if (beforeChild) {
 417         beforeChild-&gt;setPreviousSibling(&amp;child);
 418         child.setNextSibling(beforeChild);
 419         ASSERT(beforeChild != &amp;child);
 420     } else
 421         setLastChild(&amp;child);
 422 
 423     child.setParent(this);
 424 
 425     dirtyPaintOrderListsOnChildChange(child);
 426 
 427     child.updateDescendantDependentFlags();
 428     if (child.m_hasVisibleContent || child.m_hasVisibleDescendant)
 429         setAncestorChainHasVisibleDescendant();
 430 
 431     if (child.isSelfPaintingLayer() || child.hasSelfPaintingLayerDescendant())
 432         setAncestorChainHasSelfPaintingLayerDescendant();
 433 
 434     if (compositor().hasContentCompositingLayers())
 435         setDescendantsNeedCompositingRequirementsTraversal();
 436 
 437     if (child.hasDescendantNeedingCompositingRequirementsTraversal() || child.needsCompositingRequirementsTraversal())
 438         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 439 
 440     if (child.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || child.needsUpdateBackingOrHierarchyTraversal())
 441         child.setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 442 
 443 #if ENABLE(CSS_COMPOSITING)
 444     if (child.hasBlendMode() || (child.hasNotIsolatedBlendingDescendants() &amp;&amp; !child.isolatesBlending()))
 445         updateAncestorChainHasBlendingDescendants(); // Why not just dirty?
 446 #endif
 447 
 448     compositor().layerWasAdded(*this, child);
 449 }
 450 
 451 void RenderLayer::removeChild(RenderLayer&amp; oldChild)
 452 {
 453     if (!renderer().renderTreeBeingDestroyed())
 454         compositor().layerWillBeRemoved(*this, oldChild);
 455 
 456     // remove the child
 457     if (oldChild.previousSibling())
 458         oldChild.previousSibling()-&gt;setNextSibling(oldChild.nextSibling());
 459     if (oldChild.nextSibling())
 460         oldChild.nextSibling()-&gt;setPreviousSibling(oldChild.previousSibling());
 461 
 462     if (m_first == &amp;oldChild)
 463         m_first = oldChild.nextSibling();
 464     if (m_last == &amp;oldChild)
 465         m_last = oldChild.previousSibling();
 466 
 467     dirtyPaintOrderListsOnChildChange(oldChild);
 468 
 469     oldChild.setPreviousSibling(nullptr);
 470     oldChild.setNextSibling(nullptr);
 471     oldChild.setParent(nullptr);
 472 
 473     oldChild.updateDescendantDependentFlags();
 474     if (oldChild.m_hasVisibleContent || oldChild.m_hasVisibleDescendant)
 475         dirtyAncestorChainVisibleDescendantStatus();
 476 
 477     if (oldChild.isSelfPaintingLayer() || oldChild.hasSelfPaintingLayerDescendant())
 478         dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 479 
 480     if (compositor().hasContentCompositingLayers())
 481         setDescendantsNeedCompositingRequirementsTraversal();
 482 
 483 #if ENABLE(CSS_COMPOSITING)
 484     if (oldChild.hasBlendMode() || (oldChild.hasNotIsolatedBlendingDescendants() &amp;&amp; !oldChild.isolatesBlending()))
 485         dirtyAncestorChainHasBlendingDescendants();
 486 #endif
 487 }
 488 
 489 void RenderLayer::dirtyPaintOrderListsOnChildChange(RenderLayer&amp; child)
 490 {
 491     if (child.isNormalFlowOnly())
 492         dirtyNormalFlowList();
 493 
 494     if (!child.isNormalFlowOnly() || child.firstChild()) {
 495         // Dirty the z-order list in which we are contained. The stackingContext() can be null in the
 496         // case where we&#39;re building up generated content layers. This is ok, since the lists will start
 497         // off dirty in that case anyway.
 498         child.dirtyStackingContextZOrderLists();
 499     }
 500 }
 501 
 502 void RenderLayer::insertOnlyThisLayer(LayerChangeTiming timing)
 503 {
 504     if (!m_parent &amp;&amp; renderer().parent()) {
 505         // We need to connect ourselves when our renderer() has a parent.
 506         // Find our enclosingLayer and add ourselves.
 507         RenderLayer* parentLayer = renderer().parent()-&gt;enclosingLayer();
 508         ASSERT(parentLayer);
 509         RenderLayer* beforeChild = parentLayer-&gt;reflectionLayer() != this ? renderer().parent()-&gt;findNextLayer(parentLayer, &amp;renderer()) : nullptr;
 510         parentLayer-&gt;addChild(*this, beforeChild);
 511     }
 512 
 513     // Remove all descendant layers from the hierarchy and add them to the new position.
 514     for (auto&amp; child : childrenOfType&lt;RenderElement&gt;(renderer()))
 515         child.moveLayers(m_parent, this);
 516 
 517     if (parent()) {
 518         if (timing == LayerChangeTiming::StyleChange)
 519             renderer().view().layerChildrenChangedDuringStyleChange(*parent());
 520     }
 521 
 522     // Clear out all the clip rects.
 523     clearClipRectsIncludingDescendants();
 524 }
 525 
 526 void RenderLayer::removeOnlyThisLayer(LayerChangeTiming timing)
 527 {
 528     if (!m_parent)
 529         return;
 530 
 531     if (timing == LayerChangeTiming::StyleChange)
 532         renderer().view().layerChildrenChangedDuringStyleChange(*parent());
 533 
 534     // Mark that we are about to lose our layer. This makes render tree
 535     // walks ignore this layer while we&#39;re removing it.
 536     renderer().setHasLayer(false);
 537 
 538     compositor().layerWillBeRemoved(*m_parent, *this);
 539 
 540     // Dirty the clip rects.
 541     clearClipRectsIncludingDescendants();
 542 
 543     RenderLayer* nextSib = nextSibling();
 544 
 545     // Remove the child reflection layer before moving other child layers.
 546     // The reflection layer should not be moved to the parent.
 547     if (reflection())
 548         removeChild(*reflectionLayer());
 549 
 550     // Now walk our kids and reattach them to our parent.
 551     RenderLayer* current = m_first;
 552     while (current) {
 553         RenderLayer* next = current-&gt;nextSibling();
 554         removeChild(*current);
 555         m_parent-&gt;addChild(*current, nextSib);
 556         current-&gt;setRepaintStatus(NeedsFullRepaint);
 557         current = next;
 558     }
 559 
 560     // Remove us from the parent.
 561     m_parent-&gt;removeChild(*this);
 562     renderer().destroyLayer();
 563 }
 564 
 565 static bool canCreateStackingContext(const RenderLayer&amp; layer)
 566 {
 567     auto&amp; renderer = layer.renderer();
 568     return renderer.hasTransformRelatedProperty()
 569         || renderer.hasClipPath()
 570         || renderer.hasFilter()
 571         || renderer.hasMask()
 572         || renderer.hasBackdropFilter()
 573 #if ENABLE(CSS_COMPOSITING)
 574         || renderer.hasBlendMode()
 575 #endif
 576         || renderer.isTransparent()
 577         || renderer.isPositioned() // Note that this only creates stacking context in conjunction with explicit z-index.
 578         || renderer.hasReflection()
 579         || renderer.style().hasIsolation()
 580         || !renderer.style().hasAutoUsedZIndex()
 581         || (renderer.style().willChange() &amp;&amp; renderer.style().willChange()-&gt;canCreateStackingContext());
 582 }
 583 
 584 bool RenderLayer::shouldBeNormalFlowOnly() const
 585 {
 586     if (canCreateStackingContext(*this))
 587         return false;
 588 
 589     return renderer().hasOverflowClip()
 590         || renderer().isCanvas()
 591         || renderer().isVideo()
 592         || renderer().isEmbeddedObject()
 593         || renderer().isRenderIFrame()
 594         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
 595         || (renderer().style().specifiesColumns() &amp;&amp; !isRenderViewLayer())
 596         || renderer().isInFlowRenderFragmentedFlow();
 597 }
 598 
 599 bool RenderLayer::shouldBeCSSStackingContext() const
 600 {
 601     return !renderer().style().hasAutoUsedZIndex() || isRenderViewLayer();
 602 }
 603 
 604 bool RenderLayer::setIsNormalFlowOnly(bool isNormalFlowOnly)
 605 {
 606     if (isNormalFlowOnly == m_isNormalFlowOnly)
 607         return false;
 608 
 609     m_isNormalFlowOnly = isNormalFlowOnly;
 610 
 611     if (auto* p = parent())
 612         p-&gt;dirtyNormalFlowList();
 613     dirtyStackingContextZOrderLists();
 614     return true;
 615 }
 616 
 617 void RenderLayer::isStackingContextChanged()
 618 {
 619     dirtyStackingContextZOrderLists();
 620     if (isStackingContext())
 621         dirtyZOrderLists();
 622     else
 623         clearZOrderLists();
 624 }
 625 
 626 bool RenderLayer::setIsOpportunisticStackingContext(bool isStacking)
 627 {
 628     bool wasStacking = isStackingContext();
 629     m_isOpportunisticStackingContext = isStacking;
 630     if (wasStacking == isStackingContext())
 631         return false;
 632 
 633     isStackingContextChanged();
 634     return true;
 635 }
 636 
 637 bool RenderLayer::setIsCSSStackingContext(bool isCSSStackingContext)
 638 {
 639     bool wasStacking = isStackingContext();
 640     m_isCSSStackingContext = isCSSStackingContext;
 641     if (wasStacking == isStackingContext())
 642         return false;
 643 
 644     isStackingContextChanged();
 645     return true;
 646 }
 647 
 648 void RenderLayer::setParent(RenderLayer* parent)
 649 {
 650     if (parent == m_parent)
 651         return;
 652 
 653     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 654         compositor().layerWillBeRemoved(*m_parent, *this);
 655 
 656     m_parent = parent;
 657 
 658     if (m_parent &amp;&amp; !renderer().renderTreeBeingDestroyed())
 659         compositor().layerWasAdded(*m_parent, *this);
 660 }
 661 
 662 RenderLayer* RenderLayer::stackingContext() const
 663 {
 664     auto* layer = parent();
 665     while (layer &amp;&amp; !layer-&gt;isStackingContext())
 666         layer = layer-&gt;parent();
 667 
 668     ASSERT(!layer || layer-&gt;isStackingContext());
 669     return layer;
 670 }
 671 
 672 void RenderLayer::dirtyZOrderLists()
 673 {
 674     ASSERT(layerListMutationAllowed());
 675     ASSERT(isStackingContext());
 676 
 677     if (m_posZOrderList)
 678         m_posZOrderList-&gt;clear();
 679     if (m_negZOrderList)
 680         m_negZOrderList-&gt;clear();
 681     m_zOrderListsDirty = true;
 682 
 683     // FIXME: Ideally, we&#39;d only dirty if the lists changed.
 684     if (hasCompositingDescendant())
 685         setNeedsCompositingPaintOrderChildrenUpdate();
 686 }
 687 
 688 void RenderLayer::dirtyStackingContextZOrderLists()
 689 {
 690     if (auto* sc = stackingContext())
 691         sc-&gt;dirtyZOrderLists();
 692 }
 693 
 694 void RenderLayer::dirtyNormalFlowList()
 695 {
 696     ASSERT(layerListMutationAllowed());
 697 
 698     if (m_normalFlowList)
 699         m_normalFlowList-&gt;clear();
 700     m_normalFlowListDirty = true;
 701 
 702     if (hasCompositingDescendant())
 703         setNeedsCompositingPaintOrderChildrenUpdate();
 704 }
 705 
 706 void RenderLayer::updateNormalFlowList()
 707 {
 708     if (!m_normalFlowListDirty)
 709         return;
 710 
 711     ASSERT(layerListMutationAllowed());
 712 
 713     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 714         // Ignore non-overflow layers and reflections.
 715         if (child-&gt;isNormalFlowOnly() &amp;&amp; !isReflectionLayer(*child)) {
 716             if (!m_normalFlowList)
 717                 m_normalFlowList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 718             m_normalFlowList-&gt;append(child);
 719         }
 720     }
 721 
 722     m_normalFlowListDirty = false;
 723 }
 724 
 725 void RenderLayer::rebuildZOrderLists()
 726 {
 727     ASSERT(layerListMutationAllowed());
 728     ASSERT(isDirtyStackingContext());
 729 
 730     OptionSet&lt;Compositing&gt; childDirtyFlags;
 731     rebuildZOrderLists(m_posZOrderList, m_negZOrderList, childDirtyFlags);
 732     m_zOrderListsDirty = false;
 733 
 734     bool hasNegativeZOrderList = m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 735     // Having negative z-order lists affect whether a compositing layer needs a foreground layer.
 736     // Ideally we&#39;d only trigger this when having z-order children changes, but we blow away the old z-order
 737     // lists on dirtying so we don&#39;t know the old state.
 738     if (hasNegativeZOrderList != m_hadNegativeZOrderList) {
 739         m_hadNegativeZOrderList = hasNegativeZOrderList;
 740         if (isComposited())
 741             setNeedsCompositingConfigurationUpdate();
 742     }
 743 
 744     // Building lists may have added layers with dirty flags, so make sure we propagate dirty bits up the tree.
 745     if (m_compositingDirtyBits.containsAll({ Compositing::DescendantsNeedRequirementsTraversal, Compositing::DescendantsNeedBackingAndHierarchyTraversal }))
 746         return;
 747 
 748     if (childDirtyFlags.containsAny(computeCompositingRequirementsFlags()))
 749         setDescendantsNeedCompositingRequirementsTraversal();
 750 
 751     if (childDirtyFlags.containsAny(updateBackingOrHierarchyFlags()))
 752         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
 753 }
 754 
 755 void RenderLayer::rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; posZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)
 756 {
 757     bool includeHiddenLayers = compositor().usesCompositing();
 758     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 759         if (!isReflectionLayer(*child))
 760             child-&gt;collectLayers(includeHiddenLayers, posZOrderList, negZOrderList, accumulatedDirtyFlags);
 761     }
 762 
 763     auto compareZIndex = [] (const RenderLayer* first, const RenderLayer* second) -&gt; bool {
 764         return first-&gt;zIndex() &lt; second-&gt;zIndex();
 765     };
 766 
 767     // Sort the two lists.
 768     if (posZOrderList)
 769         std::stable_sort(posZOrderList-&gt;begin(), posZOrderList-&gt;end(), compareZIndex);
 770 
 771     if (negZOrderList)
 772         std::stable_sort(negZOrderList-&gt;begin(), negZOrderList-&gt;end(), compareZIndex);
 773 }
 774 
 775 void RenderLayer::collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; positiveZOrderList, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp; negativeZOrderList, OptionSet&lt;Compositing&gt;&amp; accumulatedDirtyFlags)
 776 {
 777     updateDescendantDependentFlags();
 778 
 779     bool isStacking = isStackingContext();
 780     // Overflow layers are just painted by their enclosing layers, so they don&#39;t get put in zorder lists.
 781     bool includeHiddenLayer = includeHiddenLayers || (m_hasVisibleContent || (m_hasVisibleDescendant &amp;&amp; isStacking));
 782     if (includeHiddenLayer &amp;&amp; !isNormalFlowOnly()) {
 783         auto&amp; layerList = (zIndex() &gt;= 0) ? positiveZOrderList : negativeZOrderList;
 784         if (!layerList)
 785             layerList = makeUnique&lt;Vector&lt;RenderLayer*&gt;&gt;();
 786         layerList-&gt;append(this);
 787         accumulatedDirtyFlags.add(m_compositingDirtyBits);
 788     }
 789 
 790     // Recur into our children to collect more layers, but only if we don&#39;t establish
 791     // a stacking context/container.
 792     if ((includeHiddenLayers || m_hasVisibleDescendant) &amp;&amp; !isStacking) {
 793         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
 794             // Ignore reflections.
 795             if (!isReflectionLayer(*child))
 796                 child-&gt;collectLayers(includeHiddenLayers, positiveZOrderList, negativeZOrderList, accumulatedDirtyFlags);
 797         }
 798     }
 799 }
 800 
 801 void RenderLayer::setAncestorsHaveCompositingDirtyFlag(Compositing flag)
 802 {
 803     for (auto* layer = paintOrderParent(); layer; layer = layer-&gt;paintOrderParent()) {
 804         if (layer-&gt;m_compositingDirtyBits.contains(flag))
 805             break;
 806         layer-&gt;m_compositingDirtyBits.add(flag);
 807     }
 808 }
 809 
 810 void RenderLayer::updateLayerListsIfNeeded()
 811 {
 812     updateZOrderLists();
 813     updateNormalFlowList();
 814 
 815     if (RenderLayer* reflectionLayer = this-&gt;reflectionLayer()) {
 816         reflectionLayer-&gt;updateZOrderLists();
 817         reflectionLayer-&gt;updateNormalFlowList();
 818     }
 819 }
 820 
 821 String RenderLayer::name() const
 822 {
 823     StringBuilder name;
 824 
 825     if (Element* element = renderer().element()) {
 826         name.append(&quot; &lt;&quot;);
 827         name.append(element-&gt;tagName().convertToLowercaseWithoutLocale());
 828         name.append(&#39;&gt;&#39;);
 829 
 830         if (element-&gt;hasID()) {
 831             name.appendLiteral(&quot; id=\&#39;&quot;);
 832             name.append(element-&gt;getIdAttribute());
 833             name.append(&#39;\&#39;&#39;);
 834         }
 835 
 836         if (element-&gt;hasClass()) {
 837             name.appendLiteral(&quot; class=\&#39;&quot;);
 838             size_t classNamesToDump = element-&gt;classNames().size();
 839             const size_t maxNumClassNames = 7;
 840             bool addEllipsis = false;
 841             if (classNamesToDump &gt; maxNumClassNames) {
 842                 classNamesToDump = maxNumClassNames;
 843                 addEllipsis = true;
 844             }
 845 
 846             for (size_t i = 0; i &lt; classNamesToDump; ++i) {
 847                 if (i &gt; 0)
 848                     name.append(&#39; &#39;);
 849                 name.append(element-&gt;classNames()[i]);
 850             }
 851             if (addEllipsis)
 852                 name.append(&quot;...&quot;);
 853             name.append(&#39;\&#39;&#39;);
 854         }
 855     } else
 856         name.append(renderer().renderName());
 857 
 858     if (isReflection())
 859         name.appendLiteral(&quot; (reflection)&quot;);
 860 
 861     return name.toString();
 862 }
 863 
 864 RenderLayerCompositor&amp; RenderLayer::compositor() const
 865 {
 866     return renderer().view().compositor();
 867 }
 868 
 869 void RenderLayer::contentChanged(ContentChangeType changeType)
 870 {
 871     if (changeType == CanvasChanged || changeType == VideoChanged || changeType == FullScreenChanged || (isComposited() &amp;&amp; changeType == ImageChanged)) {
 872         setNeedsPostLayoutCompositingUpdate();
 873         setNeedsCompositingConfigurationUpdate();
 874     }
 875 
 876     if (auto* backing = this-&gt;backing())
 877         backing-&gt;contentChanged(changeType);
 878 }
 879 
 880 bool RenderLayer::canRender3DTransforms() const
 881 {
 882     return compositor().canRender3DTransforms();
 883 }
 884 
 885 bool RenderLayer::paintsWithFilters() const
 886 {
 887     if (!renderer().hasFilter())
 888         return false;
 889 
 890     if (!isComposited())
 891         return true;
 892 
 893     return !m_backing-&gt;canCompositeFilters();
 894 }
 895 
 896 bool RenderLayer::requiresFullLayerImageForFilters() const
 897 {
 898     if (!paintsWithFilters())
 899         return false;
 900 
 901     return m_filters &amp;&amp; m_filters-&gt;hasFilterThatMovesPixels();
 902 }
 903 
 904 OptionSet&lt;RenderLayer::UpdateLayerPositionsFlag&gt; RenderLayer::flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer)
 905 {
 906     OptionSet&lt;UpdateLayerPositionsFlag&gt; flags = { CheckForRepaint };
 907 
 908     if (auto* parent = startingLayer.parent()) {
 909         if (parent-&gt;hasTransformedAncestor() || parent-&gt;transform())
 910             flags.add(SeenTransformedLayer);
 911 
 912         if (parent-&gt;has3DTransformedAncestor() || (parent-&gt;transform() &amp;&amp; !parent-&gt;transform()-&gt;isAffine()))
 913             flags.add(Seen3DTransformedLayer);
 914 
 915         if (parent-&gt;behavesAsFixed() || (parent-&gt;renderer().isFixedPositioned() &amp;&amp; !parent-&gt;hasTransformedAncestor()))
 916             flags.add(SeenFixedLayer);
 917 
 918         if (parent-&gt;hasCompositedScrollingAncestor() || parent-&gt;hasCompositedScrollableOverflow())
 919             flags.add(SeenCompositedScrollingLayer);
 920     }
 921 
 922     return flags;
 923 }
 924 
 925 void RenderLayer::updateLayerPositionsAfterStyleChange()
 926 {
 927     updateLayerPositions(nullptr, flagsForUpdateLayerPositions(*this));
 928 }
 929 
 930 void RenderLayer::updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint)
 931 {
 932     auto updateLayerPositionFlags = [&amp;](bool isRelayoutingSubtree, bool didFullRepaint) {
 933         auto flags = flagsForUpdateLayerPositions(*this);
 934         if (didFullRepaint) {
 935             flags.remove(RenderLayer::CheckForRepaint);
 936             flags.add(RenderLayer::NeedsFullRepaintInBacking);
 937         }
 938         if (isRelayoutingSubtree &amp;&amp; enclosingPaginationLayer(RenderLayer::IncludeCompositedPaginatedLayers))
 939             flags.add(RenderLayer::UpdatePagination);
 940         return flags;
 941     };
 942 
 943     LOG(Compositing, &quot;RenderLayer %p updateLayerPositionsAfterLayout&quot;, this);
 944     RenderGeometryMap geometryMap(UseTransforms);
 945     if (!isRenderViewLayer())
 946         geometryMap.pushMappingsToAncestor(parent(), nullptr);
 947 
 948     updateLayerPositions(&amp;geometryMap, updateLayerPositionFlags(isRelayoutingSubtree, didFullRepaint));
 949 }
 950 
 951 void RenderLayer::updateLayerPositions(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsFlag&gt; flags)
 952 {
 953     updateLayerPosition(&amp;flags);
 954     applyPostLayoutScrollPositionIfNeeded();
 955 
 956     if (geometryMap)
 957         geometryMap-&gt;pushMappingsToAncestor(this, parent());
 958 
 959     // Clear our cached clip rect information.
 960     clearClipRects();
 961 
 962     if (hasOverflowControls()) {
 963         LayoutSize offsetFromRoot;
 964         if (geometryMap)
 965             offsetFromRoot = LayoutSize(toFloatSize(geometryMap-&gt;absolutePoint(FloatPoint())));
 966         else {
 967             // FIXME: It looks suspicious to call convertToLayerCoords here
 968             // as canUseOffsetFromAncestor may be true for an ancestor layer.
 969             offsetFromRoot = offsetFromAncestor(root());
 970         }
 971         positionOverflowControls(roundedIntSize(offsetFromRoot));
 972     }
 973 
 974     updateDescendantDependentFlags();
 975 
 976     if (flags &amp; UpdatePagination)
 977         updatePagination();
 978     else
 979         m_enclosingPaginationLayer = nullptr;
 980 
 981     if (m_hasVisibleContent) {
 982         // FIXME: Paint offset cache does not work with RenderLayers as there is not a 1-to-1
 983         // mapping between them and the RenderObjects. It would be neat to enable
 984         // LayoutState outside the layout() phase and use it here.
 985         ASSERT(!renderer().view().frameView().layoutContext().isPaintOffsetCacheEnabled());
 986 
 987         RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
 988 
 989         auto hadRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 990         RepaintLayoutRects oldRects = hadRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 991         computeRepaintRects(repaintContainer, geometryMap);
 992 
 993         auto hasRepaintLayoutRects = renderer().hasRepaintLayoutRects();
 994         RepaintLayoutRects newRects = hasRepaintLayoutRects ? renderer().repaintLayoutRects() : RepaintLayoutRects();
 995         // FIXME: Should ASSERT that value calculated for m_outlineBox using the cached offset is the same
 996         // as the value not using the cached offset, but we can&#39;t due to https://bugs.webkit.org/show_bug.cgi?id=37048
 997         if ((flags &amp; CheckForRepaint) &amp;&amp; hasRepaintLayoutRects) {
 998             if (!renderer().view().printing()) {
 999                 if (m_repaintStatus &amp; NeedsFullRepaint) {
1000                     if (hadRepaintLayoutRects)
1001                         renderer().repaintUsingContainer(repaintContainer, oldRects.m_repaintRect);
1002                     if (!hadRepaintLayoutRects || newRects.m_repaintRect != oldRects.m_repaintRect)
1003                         renderer().repaintUsingContainer(repaintContainer, newRects.m_repaintRect);
1004                 } else if (shouldRepaintAfterLayout()) {
1005                     // FIXME: We will convert this to just take the old and new RepaintLayoutRects once
1006                     // we change other callers to use RepaintLayoutRects.
1007                     renderer().repaintAfterLayoutIfNeeded(repaintContainer, oldRects.m_repaintRect, oldRects.m_outlineBox, &amp;newRects.m_repaintRect, &amp;newRects.m_outlineBox);
1008                 }
1009             }
1010         }
1011     } else
1012         clearRepaintRects();
1013 
1014     m_repaintStatus = NeedsNormalRepaint;
1015     m_hasTransformedAncestor = flags.contains(SeenTransformedLayer);
1016     m_has3DTransformedAncestor = flags.contains(Seen3DTransformedLayer);
1017     m_behavesAsFixed = flags.contains(SeenFixedLayer);
1018     setHasCompositedScrollingAncestor(flags.contains(SeenCompositedScrollingLayer));
1019 
1020     // Update the reflection&#39;s position and size.
1021     if (m_reflection)
1022         m_reflection-&gt;layout();
1023 
1024     if (renderer().isInFlowRenderFragmentedFlow()) {
1025         updatePagination();
1026         flags.add(UpdatePagination);
1027     }
1028 
1029     if (transform()) {
1030         flags.add(SeenTransformedLayer);
1031         if (!transform()-&gt;isAffine())
1032             flags.add(Seen3DTransformedLayer);
1033     }
1034 
1035     // Fixed inside transform behaves like absolute (per spec).
1036     if (renderer().isFixedPositioned() &amp;&amp; !m_hasTransformedAncestor) {
1037         m_behavesAsFixed = true;
1038         flags.add(SeenFixedLayer);
1039     }
1040 
1041     if (hasCompositedScrollableOverflow())
1042         flags.add(SeenCompositedScrollingLayer);
1043 
1044     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1045         child-&gt;updateLayerPositions(geometryMap, flags);
1046 
1047     // With all our children positioned, now update our marquee if we need to.
1048     if (m_marquee) {
1049         // FIXME: would like to use SetForScope&lt;&gt; but it doesn&#39;t work with bitfields.
1050         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1051         m_updatingMarqueePosition = true;
1052         m_marquee-&gt;updateMarqueePosition();
1053         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1054     }
1055 
1056     if (renderer().isFixedPositioned() &amp;&amp; renderer().settings().acceleratedCompositingForFixedPositionEnabled()) {
1057         bool intersectsViewport = compositor().fixedLayerIntersectsViewport(*this);
1058         if (intersectsViewport != m_isFixedIntersectingViewport) {
1059             m_isFixedIntersectingViewport = intersectsViewport;
1060             setNeedsPostLayoutCompositingUpdate();
1061         }
1062     }
1063 
1064     if (isComposited())
1065         backing()-&gt;updateAfterLayout(flags.contains(ContainingClippingLayerChangedSize), flags.contains(NeedsFullRepaintInBacking));
1066 
1067     if (geometryMap)
1068         geometryMap-&gt;popMappingsToAncestor(parent());
1069 
1070     renderer().document().markers().invalidateRectsForAllMarkers();
1071 }
1072 
1073 LayoutRect RenderLayer::repaintRectIncludingNonCompositingDescendants() const
1074 {
1075     LayoutRect repaintRect = renderer().repaintLayoutRects().m_repaintRect;
1076     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1077         // Don&#39;t include repaint rects for composited child layers; they will paint themselves and have a different origin.
1078         if (child-&gt;isComposited())
1079             continue;
1080 
1081         repaintRect.uniteIfNonZero(child-&gt;repaintRectIncludingNonCompositingDescendants());
1082     }
1083     return repaintRect;
1084 }
1085 
1086 void RenderLayer::setAncestorChainHasSelfPaintingLayerDescendant()
1087 {
1088     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1089         if (!layer-&gt;m_hasSelfPaintingLayerDescendantDirty &amp;&amp; layer-&gt;hasSelfPaintingLayerDescendant())
1090             break;
1091 
1092         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = false;
1093         layer-&gt;m_hasSelfPaintingLayerDescendant = true;
1094     }
1095 }
1096 
1097 void RenderLayer::dirtyAncestorChainHasSelfPaintingLayerDescendantStatus()
1098 {
1099     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1100         layer-&gt;m_hasSelfPaintingLayerDescendantDirty = true;
1101         // If we have reached a self-painting layer, we know our parent should have a self-painting descendant
1102         // in this case, there is no need to dirty our ancestors further.
1103         if (layer-&gt;isSelfPaintingLayer()) {
1104             ASSERT(!parent() || parent()-&gt;m_hasSelfPaintingLayerDescendantDirty || parent()-&gt;hasSelfPaintingLayerDescendant());
1105             break;
1106         }
1107     }
1108 }
1109 
1110 void RenderLayer::computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* geometryMap)
1111 {
1112     ASSERT(!m_visibleContentStatusDirty);
1113     renderer().computeRepaintLayoutRects(repaintContainer, geometryMap);
1114 }
1115 
1116 void RenderLayer::computeRepaintRectsIncludingDescendants()
1117 {
1118     // FIXME: computeRepaintRects() has to walk up the parent chain for every layer to compute the rects.
1119     // We should make this more efficient.
1120     // FIXME: it&#39;s wrong to call this when layout is not up-to-date, which we do.
1121     computeRepaintRects(renderer().containerForRepaint());
1122 
1123     for (RenderLayer* layer = firstChild(); layer; layer = layer-&gt;nextSibling())
1124         layer-&gt;computeRepaintRectsIncludingDescendants();
1125 }
1126 
1127 void RenderLayer::clearRepaintRects()
1128 {
1129     ASSERT(!m_visibleContentStatusDirty);
1130 
1131     renderer().clearRepaintLayoutRects();
1132 }
1133 
1134 void RenderLayer::updateLayerPositionsAfterDocumentScroll()
1135 {
1136     ASSERT(this == renderer().view().layer());
1137 
1138     LOG(Scrolling, &quot;RenderLayer::updateLayerPositionsAfterDocumentScroll&quot;);
1139 
1140     RenderGeometryMap geometryMap(UseTransforms);
1141     updateLayerPositionsAfterScroll(&amp;geometryMap);
1142 }
1143 
1144 void RenderLayer::updateLayerPositionsAfterOverflowScroll()
1145 {
1146     RenderGeometryMap geometryMap(UseTransforms);
1147     if (this != renderer().view().layer())
1148         geometryMap.pushMappingsToAncestor(parent(), nullptr);
1149 
1150     // FIXME: why is it OK to not check the ancestors of this layer in order to
1151     // initialize the HasSeenViewportConstrainedAncestor and HasSeenAncestorWithOverflowClip flags?
1152     updateLayerPositionsAfterScroll(&amp;geometryMap, IsOverflowScroll);
1153 }
1154 
1155 void RenderLayer::updateLayerPositionsAfterScroll(RenderGeometryMap* geometryMap, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; flags)
1156 {
1157     // FIXME: This shouldn&#39;t be needed, but there are some corner cases where
1158     // these flags are still dirty. Update so that the check below is valid.
1159     updateDescendantDependentFlags();
1160 
1161     // If we have no visible content and no visible descendants, there is no point recomputing
1162     // our rectangles as they will be empty. If our visibility changes, we are expected to
1163     // recompute all our positions anyway.
1164     if (!m_hasVisibleDescendant &amp;&amp; !m_hasVisibleContent)
1165         return;
1166 
1167     bool positionChanged = updateLayerPosition();
1168     if (positionChanged)
1169         flags.add(HasChangedAncestor);
1170 
1171     if (flags.containsAny({ HasChangedAncestor, HasSeenViewportConstrainedAncestor, IsOverflowScroll }))
1172         clearClipRects();
1173 
1174     if (renderer().style().hasViewportConstrainedPosition())
1175         flags.add(HasSeenViewportConstrainedAncestor);
1176 
1177     if (renderer().hasOverflowClip())
1178         flags.add(HasSeenAncestorWithOverflowClip);
1179 
1180     bool shouldComputeRepaintRects = (flags.contains(HasSeenViewportConstrainedAncestor) || flags.containsAll({ IsOverflowScroll, HasSeenAncestorWithOverflowClip })) &amp;&amp; isSelfPaintingLayer();
1181     bool isVisuallyEmpty = !isVisuallyNonEmpty();
1182     bool shouldPushAndPopMappings = geometryMap &amp;&amp; ((shouldComputeRepaintRects &amp;&amp; !isVisuallyEmpty) || firstChild());
1183     if (shouldPushAndPopMappings)
1184         geometryMap-&gt;pushMappingsToAncestor(this, parent());
1185 
1186     if (shouldComputeRepaintRects) {
1187         // When scrolling, we don&#39;t compute repaint rects for visually non-empty layers.
1188         if (isVisuallyEmpty)
1189             clearRepaintRects();
1190         else // FIXME: We could track the repaint container as we walk down the tree.
1191             computeRepaintRects(renderer().containerForRepaint(), geometryMap);
1192     } else if (!renderer().view().frameView().platformWidget()) {
1193         // When ScrollView&#39;s m_paintsEntireContents flag flips due to layer backing changes, the repaint area transitions from
1194         // visual to layout overflow. When this happens the cached repaint rects become invalid and they need to be recomputed (see webkit.org/b/188121).
1195         // Check that our cached rects are correct.
1196         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_repaintRect == renderer().clippedOverflowRectForRepaint(renderer().containerForRepaint()));
1197         ASSERT(!renderer().hasRepaintLayoutRects() || renderer().repaintLayoutRects().m_outlineBox == renderer().outlineBoundsForRepaint(renderer().containerForRepaint()));
1198     }
1199 
1200     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
1201         child-&gt;updateLayerPositionsAfterScroll(geometryMap, flags);
1202 
1203     // We don&#39;t update our reflection as scrolling is a translation which does not change the size()
1204     // of an object, thus RenderReplica will still repaint itself properly as the layer position was
1205     // updated above.
1206 
1207     if (m_marquee) {
1208         bool oldUpdatingMarqueePosition = m_updatingMarqueePosition;
1209         m_updatingMarqueePosition = true;
1210         m_marquee-&gt;updateMarqueePosition();
1211         m_updatingMarqueePosition = oldUpdatingMarqueePosition;
1212     }
1213 
1214     if (shouldPushAndPopMappings)
1215         geometryMap-&gt;popMappingsToAncestor(parent());
1216 
1217     renderer().document().markers().invalidateRectsForAllMarkers();
1218 }
1219 
1220 #if ENABLE(CSS_COMPOSITING)
1221 
1222 void RenderLayer::updateBlendMode()
1223 {
1224     bool hadBlendMode = static_cast&lt;BlendMode&gt;(m_blendMode) != BlendMode::Normal;
1225     if (parent() &amp;&amp; hadBlendMode != hasBlendMode()) {
1226         if (hasBlendMode())
1227             parent()-&gt;updateAncestorChainHasBlendingDescendants();
1228         else
1229             parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1230     }
1231 
1232     BlendMode newBlendMode = renderer().style().blendMode();
1233     if (newBlendMode != static_cast&lt;BlendMode&gt;(m_blendMode))
1234         m_blendMode = static_cast&lt;unsigned&gt;(newBlendMode);
1235 }
1236 
1237 void RenderLayer::willRemoveChildWithBlendMode()
1238 {
1239     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
1240 }
1241 
1242 void RenderLayer::updateAncestorChainHasBlendingDescendants()
1243 {
1244     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1245         if (!layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; layer-&gt;hasNotIsolatedBlendingDescendants())
1246             break;
1247         layer-&gt;m_hasNotIsolatedBlendingDescendants = true;
1248         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1249 
1250         layer-&gt;updateSelfPaintingLayer();
1251 
1252         if (layer-&gt;isCSSStackingContext())
1253             break;
1254     }
1255 }
1256 
1257 void RenderLayer::dirtyAncestorChainHasBlendingDescendants()
1258 {
1259     for (auto* layer = this; layer; layer = layer-&gt;parent()) {
1260         if (layer-&gt;hasNotIsolatedBlendingDescendantsStatusDirty())
1261             break;
1262 
1263         layer-&gt;m_hasNotIsolatedBlendingDescendantsStatusDirty = true;
1264 
1265         if (layer-&gt;isCSSStackingContext())
1266             break;
1267     }
1268 }
1269 #endif
1270 
1271 static inline LayoutRect computeReferenceRectFromBox(const RenderBox&amp; box, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot)
1272 {
1273     LayoutRect referenceBox;
1274     switch (boxType) {
1275     case CSSBoxType::ContentBox:
1276     case CSSBoxType::FillBox:
1277         referenceBox = box.contentBoxRect();
1278         referenceBox.move(offsetFromRoot);
1279         break;
1280     case CSSBoxType::PaddingBox:
1281         referenceBox = box.paddingBoxRect();
1282         referenceBox.move(offsetFromRoot);
1283         break;
1284     case CSSBoxType::MarginBox:
1285         referenceBox = box.marginBoxRect();
1286         referenceBox.move(offsetFromRoot);
1287         break;
1288     // stroke-box, view-box compute to border-box for HTML elements.
1289     case CSSBoxType::StrokeBox:
1290     case CSSBoxType::ViewBox:
1291     case CSSBoxType::BorderBox:
1292     case CSSBoxType::BoxMissing:
1293         referenceBox = box.borderBoxRect();
1294         referenceBox.move(offsetFromRoot);
1295         break;
1296     }
1297 
1298     return referenceBox;
1299 }
1300 
1301 static inline LayoutRect computeReferenceBox(const RenderObject&amp; renderer, const CSSBoxType&amp; boxType, const LayoutSize&amp; offsetFromRoot, const LayoutRect&amp; rootRelativeBounds)
1302 {
1303     // FIXME: Support different reference boxes for inline content.
1304     // https://bugs.webkit.org/show_bug.cgi?id=129047
1305     if (!renderer.isBox())
1306         return rootRelativeBounds;
1307 
1308     return computeReferenceRectFromBox(downcast&lt;RenderBox&gt;(renderer), boxType, offsetFromRoot);
1309 }
1310 
1311 static inline CSSBoxType transformBoxToCSSBoxType(TransformBox transformBox)
1312 {
1313     switch (transformBox) {
1314     case TransformBox::StrokeBox:
1315         return CSSBoxType::StrokeBox;
1316     case TransformBox::ContentBox:
1317         return CSSBoxType::ContentBox;
1318     case TransformBox::BorderBox:
1319         return CSSBoxType::BorderBox;
1320     case TransformBox::FillBox:
1321         return CSSBoxType::FillBox;
1322     case TransformBox::ViewBox:
1323         return CSSBoxType::ViewBox;
1324     default:
1325         ASSERT_NOT_REACHED();
1326         return CSSBoxType::BorderBox;
1327     }
1328 }
1329 
1330 void RenderLayer::updateTransform()
1331 {
1332     bool hasTransform = renderer().hasTransform();
1333     bool had3DTransform = has3DTransform();
1334 
1335     bool hadTransform = !!m_transform;
1336     if (hasTransform != hadTransform) {
1337         if (hasTransform)
1338             m_transform = makeUnique&lt;TransformationMatrix&gt;();
1339         else
1340             m_transform = nullptr;
1341 
1342         // Layers with transforms act as clip rects roots, so clear the cached clip rects here.
1343         clearClipRectsIncludingDescendants();
1344     }
1345 
1346     if (hasTransform) {
1347         RenderBox* box = renderBox();
1348         ASSERT(box);
1349         m_transform-&gt;makeIdentity();
1350         LayoutSize offsetFromRoot;
1351         auto computedReferenceBox = computeReferenceRectFromBox(*box, transformBoxToCSSBoxType(box-&gt;style().transformBox()), offsetFromRoot);
1352         box-&gt;style().applyTransform(*m_transform, snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor()), RenderStyle::IncludeTransformOrigin);
1353         makeMatrixRenderable(*m_transform, canRender3DTransforms());
1354     }
1355 
1356     if (had3DTransform != has3DTransform()) {
1357         dirty3DTransformedDescendantStatus();
1358         // Having a 3D transform affects whether enclosing perspective and preserve-3d layers composite, so trigger an update.
1359         setNeedsPostLayoutCompositingUpdateOnAncestors();
1360     }
1361 }
1362 
1363 TransformationMatrix RenderLayer::currentTransform(RenderStyle::ApplyTransformOrigin applyOrigin) const
1364 {
1365     if (!m_transform)
1366         return TransformationMatrix();
1367 
1368     RenderBox* box = renderBox();
1369 
1370     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1371         if (auto* timeline = renderer().documentTimeline()) {
1372             if (timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1373                 TransformationMatrix currTransform;
1374                 LayoutSize offsetFromRoot;
1375                 std::unique_ptr&lt;RenderStyle&gt; style = timeline-&gt;animatedStyleForRenderer(renderer());
1376                 auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());
1377                 FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());
1378                 style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1379                 makeMatrixRenderable(currTransform, canRender3DTransforms());
1380                 return currTransform;
1381             }
1382         }
1383     } else {
1384         if (renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform)) {
1385             TransformationMatrix currTransform;
1386             std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
1387             LayoutSize offsetFromRoot;
1388             auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());
1389             FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());
1390             style-&gt;applyTransform(currTransform, pixelSnappedBorderRect, applyOrigin);
1391             makeMatrixRenderable(currTransform, canRender3DTransforms());
1392             return currTransform;
1393         }
1394     }
1395 
1396 
1397     // m_transform includes transform-origin, so we need to recompute the transform here.
1398     if (applyOrigin == RenderStyle::ExcludeTransformOrigin) {
1399         TransformationMatrix currTransform;
1400         LayoutSize offsetFromRoot;
1401         std::unique_ptr&lt;RenderStyle&gt; style = renderer().animation().animatedStyleForRenderer(renderer());
1402         auto computedReferenceBox = computeReferenceBox(renderer(), transformBoxToCSSBoxType(style-&gt;transformBox()), offsetFromRoot, box-&gt;borderBoxRect());
1403         FloatRect pixelSnappedBorderRect = snapRectToDevicePixels(computedReferenceBox, box-&gt;document().deviceScaleFactor());
1404         box-&gt;style().applyTransform(currTransform, pixelSnappedBorderRect, RenderStyle::ExcludeTransformOrigin);
1405         makeMatrixRenderable(currTransform, canRender3DTransforms());
1406         return currTransform;
1407     }
1408 
1409     return *m_transform;
1410 }
1411 
1412 TransformationMatrix RenderLayer::renderableTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
1413 {
1414     if (!m_transform)
1415         return TransformationMatrix();
1416 
1417     if (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) {
1418         TransformationMatrix matrix = *m_transform;
1419         makeMatrixRenderable(matrix, false /* flatten 3d */);
1420         return matrix;
1421     }
1422 
1423     return *m_transform;
1424 }
1425 
1426 RenderLayer* RenderLayer::enclosingOverflowClipLayer(IncludeSelfOrNot includeSelf) const
1427 {
1428     const RenderLayer* layer = (includeSelf == IncludeSelf) ? this : parent();
1429     while (layer) {
1430         if (layer-&gt;renderer().hasOverflowClip())
1431             return const_cast&lt;RenderLayer*&gt;(layer);
1432 
1433         layer = layer-&gt;parent();
1434     }
1435     return nullptr;
1436 }
1437 
1438 // FIXME: This is terrible. Bring back a cached bit for this someday. This crawl is going to slow down all
1439 // painting of content inside paginated layers.
1440 bool RenderLayer::hasCompositedLayerInEnclosingPaginationChain() const
1441 {
1442     // No enclosing layer means no compositing in the chain.
1443     if (!m_enclosingPaginationLayer)
1444         return false;
1445 
1446     // If the enclosing layer is composited, we don&#39;t have to check anything in between us and that
1447     // layer.
1448     if (m_enclosingPaginationLayer-&gt;isComposited())
1449         return true;
1450 
1451     // If we are the enclosing pagination layer, then we can&#39;t be composited or we&#39;d have passed the
1452     // previous check.
1453     if (m_enclosingPaginationLayer == this)
1454         return false;
1455 
1456     // The enclosing paginated layer is our ancestor and is not composited, so we have to check
1457     // intermediate layers between us and the enclosing pagination layer. Start with our own layer.
1458     if (isComposited())
1459         return true;
1460 
1461     // For normal flow layers, we can recur up the layer tree.
1462     if (isNormalFlowOnly())
1463         return parent()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1464 
1465     // Otherwise we have to go up the containing block chain. Find the first enclosing
1466     // containing block layer ancestor, and check that.
1467     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1468         if (containingBlock-&gt;hasLayer())
1469             return containingBlock-&gt;layer()-&gt;hasCompositedLayerInEnclosingPaginationChain();
1470     }
1471     return false;
1472 }
1473 
1474 void RenderLayer::updatePagination()
1475 {
1476     m_enclosingPaginationLayer = nullptr;
1477 
1478     if (!parent())
1479         return;
1480 
1481     // Each layer that is inside a multicolumn flow thread has to be checked individually and
1482     // genuinely know if it is going to have to split itself up when painting only its contents (and not any other descendant
1483     // layers). We track an enclosingPaginationLayer instead of using a simple bit, since we want to be able to get back
1484     // to that layer easily.
1485     if (renderer().isInFlowRenderFragmentedFlow()) {
1486         m_enclosingPaginationLayer = makeWeakPtr(*this);
1487         return;
1488     }
1489 
1490     if (isNormalFlowOnly()) {
1491         // Content inside a transform is not considered to be paginated, since we simply
1492         // paint the transform multiple times in each column, so we don&#39;t have to use
1493         // fragments for the transformed content.
1494         if (parent()-&gt;hasTransform())
1495             m_enclosingPaginationLayer = nullptr;
1496         else
1497             m_enclosingPaginationLayer = makeWeakPtr(parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1498         return;
1499     }
1500 
1501     // For the new columns code, we want to walk up our containing block chain looking for an enclosing layer. Once
1502     // we find one, then we just check its pagination status.
1503     for (const auto* containingBlock = renderer().containingBlock(); containingBlock &amp;&amp; !is&lt;RenderView&gt;(*containingBlock); containingBlock = containingBlock-&gt;containingBlock()) {
1504         if (containingBlock-&gt;hasLayer()) {
1505             // Content inside a transform is not considered to be paginated, since we simply
1506             // paint the transform multiple times in each column, so we don&#39;t have to use
1507             // fragments for the transformed content.
1508             if (containingBlock-&gt;layer()-&gt;hasTransform())
1509                 m_enclosingPaginationLayer = nullptr;
1510             else
1511                 m_enclosingPaginationLayer = makeWeakPtr(containingBlock-&gt;layer()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers));
1512             return;
1513         }
1514     }
1515 }
1516 
1517 void RenderLayer::setHasVisibleContent()
1518 {
1519     if (m_hasVisibleContent &amp;&amp; !m_visibleContentStatusDirty) {
1520         ASSERT(!parent() || parent()-&gt;hasVisibleDescendant());
1521         return;
1522     }
1523 
1524     m_visibleContentStatusDirty = false;
1525     m_hasVisibleContent = true;
1526     computeRepaintRects(renderer().containerForRepaint());
1527     if (!isNormalFlowOnly()) {
1528         // We don&#39;t collect invisible layers in z-order lists if we are not in compositing mode.
1529         // As we became visible, we need to dirty our stacking containers ancestors to be properly
1530         // collected. FIXME: When compositing, we could skip this dirtying phase.
1531         for (RenderLayer* sc = stackingContext(); sc; sc = sc-&gt;stackingContext()) {
1532             sc-&gt;dirtyZOrderLists();
1533             if (sc-&gt;hasVisibleContent())
1534                 break;
1535         }
1536     }
1537 
1538     if (parent())
1539         parent()-&gt;setAncestorChainHasVisibleDescendant();
1540 }
1541 
1542 void RenderLayer::dirtyVisibleContentStatus()
1543 {
1544     m_visibleContentStatusDirty = true;
1545     if (parent())
1546         parent()-&gt;dirtyAncestorChainVisibleDescendantStatus();
1547 }
1548 
1549 void RenderLayer::dirtyAncestorChainVisibleDescendantStatus()
1550 {
1551     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1552         if (layer-&gt;m_visibleDescendantStatusDirty)
1553             break;
1554 
1555         layer-&gt;m_visibleDescendantStatusDirty = true;
1556     }
1557 }
1558 
1559 void RenderLayer::setAncestorChainHasVisibleDescendant()
1560 {
1561     for (RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
1562         if (!layer-&gt;m_visibleDescendantStatusDirty &amp;&amp; layer-&gt;hasVisibleDescendant())
1563             break;
1564 
1565         layer-&gt;m_hasVisibleDescendant = true;
1566         layer-&gt;m_visibleDescendantStatusDirty = false;
1567     }
1568 }
1569 
1570 void RenderLayer::updateDescendantDependentFlags()
1571 {
1572     if (m_visibleDescendantStatusDirty || m_hasSelfPaintingLayerDescendantDirty || hasNotIsolatedBlendingDescendantsStatusDirty()) {
1573         bool hasVisibleDescendant = false;
1574         bool hasSelfPaintingLayerDescendant = false;
1575 #if ENABLE(CSS_COMPOSITING)
1576         bool hasNotIsolatedBlendingDescendants = false;
1577 #endif
1578 
1579         for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling()) {
1580             child-&gt;updateDescendantDependentFlags();
1581 
1582             hasVisibleDescendant |= child-&gt;m_hasVisibleContent || child-&gt;m_hasVisibleDescendant;
1583             hasSelfPaintingLayerDescendant |= child-&gt;isSelfPaintingLayer() || child-&gt;hasSelfPaintingLayerDescendant();
1584 #if ENABLE(CSS_COMPOSITING)
1585             hasNotIsolatedBlendingDescendants |= child-&gt;hasBlendMode() || (child-&gt;hasNotIsolatedBlendingDescendants() &amp;&amp; !child-&gt;isolatesBlending());
1586 #endif
1587 
1588             bool allFlagsSet = hasVisibleDescendant &amp;&amp; hasSelfPaintingLayerDescendant;
1589 #if ENABLE(CSS_COMPOSITING)
1590             allFlagsSet &amp;= hasNotIsolatedBlendingDescendants;
1591 #endif
1592             if (allFlagsSet)
1593                 break;
1594         }
1595 
1596         m_hasVisibleDescendant = hasVisibleDescendant;
1597         m_visibleDescendantStatusDirty = false;
1598         m_hasSelfPaintingLayerDescendant = hasSelfPaintingLayerDescendant;
1599         m_hasSelfPaintingLayerDescendantDirty = false;
1600 
1601 #if ENABLE(CSS_COMPOSITING)
1602         m_hasNotIsolatedBlendingDescendants = hasNotIsolatedBlendingDescendants;
1603         if (m_hasNotIsolatedBlendingDescendantsStatusDirty) {
1604             m_hasNotIsolatedBlendingDescendantsStatusDirty = false;
1605             updateSelfPaintingLayer();
1606         }
1607 #endif
1608     }
1609 
1610     if (m_visibleContentStatusDirty) {
1611         if (renderer().style().visibility() == Visibility::Visible)
1612             m_hasVisibleContent = true;
1613         else {
1614             // layer may be hidden but still have some visible content, check for this
1615             m_hasVisibleContent = false;
1616             RenderObject* r = renderer().firstChild();
1617             while (r) {
1618                 if (r-&gt;style().visibility() == Visibility::Visible &amp;&amp; !r-&gt;hasLayer()) {
1619                     m_hasVisibleContent = true;
1620                     break;
1621                 }
1622                 RenderObject* child = nullptr;
1623                 if (!r-&gt;hasLayer() &amp;&amp; (child = r-&gt;firstChildSlow()))
1624                     r = child;
1625                 else if (r-&gt;nextSibling())
1626                     r = r-&gt;nextSibling();
1627                 else {
1628                     do {
1629                         r = r-&gt;parent();
1630                         if (r == &amp;renderer())
1631                             r = nullptr;
1632                     } while (r &amp;&amp; !r-&gt;nextSibling());
1633                     if (r)
1634                         r = r-&gt;nextSibling();
1635                 }
1636             }
1637         }
1638         m_visibleContentStatusDirty = false;
1639     }
1640 }
1641 
1642 void RenderLayer::dirty3DTransformedDescendantStatus()
1643 {
1644     RenderLayer* curr = stackingContext();
1645     if (curr)
1646         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1647 
1648     // This propagates up through preserve-3d hierarchies to the enclosing flattening layer.
1649     // Note that preserves3D() creates stacking context, so we can just run up the stacking containers.
1650     while (curr &amp;&amp; curr-&gt;preserves3D()) {
1651         curr-&gt;m_3DTransformedDescendantStatusDirty = true;
1652         curr = curr-&gt;stackingContext();
1653     }
1654 }
1655 
1656 // Return true if this layer or any preserve-3d descendants have 3d.
1657 bool RenderLayer::update3DTransformedDescendantStatus()
1658 {
1659     if (m_3DTransformedDescendantStatusDirty) {
1660         m_has3DTransformedDescendant = false;
1661 
1662         updateZOrderLists();
1663 
1664         // Transformed or preserve-3d descendants can only be in the z-order lists, not
1665         // in the normal flow list, so we only need to check those.
1666         for (auto* layer : positiveZOrderLayers())
1667             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1668 
1669         // Now check our negative z-index children.
1670         for (auto* layer : negativeZOrderLayers())
1671             m_has3DTransformedDescendant |= layer-&gt;update3DTransformedDescendantStatus();
1672 
1673         m_3DTransformedDescendantStatusDirty = false;
1674     }
1675 
1676     // If we live in a 3d hierarchy, then the layer at the root of that hierarchy needs
1677     // the m_has3DTransformedDescendant set.
1678     if (preserves3D())
1679         return has3DTransform() || m_has3DTransformedDescendant;
1680 
1681     return has3DTransform();
1682 }
1683 
1684 bool RenderLayer::updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* flags)
1685 {
1686     LayoutPoint localPoint;
1687     LayoutSize inlineBoundingBoxOffset; // We don&#39;t put this into the RenderLayer x/y for inlines, so we need to subtract it out when done.
1688     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer())) {
1689         auto&amp; inlineFlow = downcast&lt;RenderInline&gt;(renderer());
1690         IntRect lineBox = inlineFlow.linesBoundingBox();
1691         setSize(lineBox.size());
1692         inlineBoundingBoxOffset = toLayoutSize(lineBox.location());
1693         localPoint += inlineBoundingBoxOffset;
1694     } else if (RenderBox* box = renderBox()) {
1695         // FIXME: Is snapping the size really needed here for the RenderBox case?
1696         auto newSize = snappedIntRect(box-&gt;frameRect()).size();
1697         if (newSize != size()) {
1698             if (is&lt;RenderWidget&gt;(*box) &amp;&amp; downcast&lt;RenderWidget&gt;(*box).requiresAcceleratedCompositing()) {
1699                 // Trigger RenderLayerCompositor::requiresCompositingForFrame() which depends on the contentBoxRect size.
1700                 setNeedsPostLayoutCompositingUpdate();
1701             }
1702 
1703             if (flags &amp;&amp; renderer().hasOverflowClip())
1704                 flags-&gt;add(ContainingClippingLayerChangedSize);
1705 
1706             setSize(newSize);
1707         }
1708 
1709         box-&gt;applyTopLeftLocationOffset(localPoint);
1710     }
1711 
1712     if (!renderer().isOutOfFlowPositioned()) {
1713         auto* ancestor = renderer().parent();
1714         // We must adjust our position by walking up the render tree looking for the
1715         // nearest enclosing object with a layer.
1716         while (ancestor &amp;&amp; !ancestor-&gt;hasLayer()) {
1717             if (is&lt;RenderBox&gt;(*ancestor) &amp;&amp; !is&lt;RenderTableRow&gt;(*ancestor)) {
1718                 // Rows and cells share the same coordinate space (that of the section).
1719                 // Omit them when computing our xpos/ypos.
1720                 localPoint += downcast&lt;RenderBox&gt;(*ancestor).topLeftLocationOffset();
1721             }
1722             ancestor = ancestor-&gt;parent();
1723         }
1724         if (is&lt;RenderTableRow&gt;(ancestor)) {
1725             // Put ourselves into the row coordinate space.
1726             localPoint -= downcast&lt;RenderTableRow&gt;(*ancestor).topLeftLocationOffset();
1727         }
1728     }
1729 
1730     // Subtract our parent&#39;s scroll offset.
1731     RenderLayer* positionedParent;
1732     if (renderer().isOutOfFlowPositioned() &amp;&amp; (positionedParent = enclosingAncestorForPosition(renderer().style().position()))) {
1733         // For positioned layers, we subtract out the enclosing positioned layer&#39;s scroll offset.
1734         if (positionedParent-&gt;renderer().hasOverflowClip())
1735             localPoint -= toLayoutSize(positionedParent-&gt;scrollPosition());
1736 
1737         if (renderer().isOutOfFlowPositioned() &amp;&amp; positionedParent-&gt;renderer().isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(positionedParent-&gt;renderer())) {
1738             LayoutSize offset = downcast&lt;RenderInline&gt;(positionedParent-&gt;renderer()).offsetForInFlowPositionedInline(&amp;downcast&lt;RenderBox&gt;(renderer()));
1739             localPoint += offset;
1740         }
1741     } else if (parent()) {
1742         if (parent()-&gt;renderer().hasOverflowClip())
1743             localPoint -= toLayoutSize(parent()-&gt;scrollPosition());
1744     }
1745 
1746     bool positionOrOffsetChanged = false;
1747     if (renderer().isInFlowPositioned()) {
1748         LayoutSize newOffset = downcast&lt;RenderBoxModelObject&gt;(renderer()).offsetForInFlowPosition();
1749         positionOrOffsetChanged = newOffset != m_offsetForInFlowPosition;
1750         m_offsetForInFlowPosition = newOffset;
1751         localPoint.move(m_offsetForInFlowPosition);
1752     } else {
1753         m_offsetForInFlowPosition = LayoutSize();
1754     }
1755 
1756     // FIXME: We&#39;d really like to just get rid of the concept of a layer rectangle and rely on the renderers.
1757     localPoint -= inlineBoundingBoxOffset;
1758 
1759     positionOrOffsetChanged |= location() != localPoint;
1760     setLocation(localPoint);
1761 
1762     if (positionOrOffsetChanged &amp;&amp; compositor().hasContentCompositingLayers()) {
1763         if (isComposited())
1764             setNeedsCompositingGeometryUpdate();
1765         // This layer&#39;s position can affect the location of a composited descendant (which may be a sibling in z-order),
1766         // so trigger a descendant walk from the paint-order parent.
1767         if (auto* paintParent = paintOrderParent())
1768             paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
1769     }
1770 
1771     return positionOrOffsetChanged;
1772 }
1773 
1774 TransformationMatrix RenderLayer::perspectiveTransform() const
1775 {
1776     RenderBox* box = renderBox();
1777     if (!box)
1778         return TransformationMatrix();
1779 
1780     if (!box-&gt;hasTransformRelatedProperty())
1781         return TransformationMatrix();
1782 
1783     const RenderStyle&amp; style = box-&gt;style();
1784     if (!style.hasPerspective())
1785         return TransformationMatrix();
1786 
1787     // Maybe fetch the perspective from the backing?
1788     const FloatRect borderBox = snapRectToDevicePixels(box-&gt;borderBoxRect(), box-&gt;document().deviceScaleFactor());
1789     float perspectiveOriginX = floatValueForLength(style.perspectiveOriginX(), borderBox.width());
1790     float perspectiveOriginY = floatValueForLength(style.perspectiveOriginY(), borderBox.height());
1791 
1792     // A perspective origin of 0,0 makes the vanishing point in the center of the element.
1793     // We want it to be in the top-left, so subtract half the height and width.
1794     perspectiveOriginX -= borderBox.width() / 2.0f;
1795     perspectiveOriginY -= borderBox.height() / 2.0f;
1796 
1797     TransformationMatrix t;
1798     t.translate(perspectiveOriginX, perspectiveOriginY);
1799     t.applyPerspective(style.perspective());
1800     t.translate(-perspectiveOriginX, -perspectiveOriginY);
1801 
1802     return t;
1803 }
1804 
1805 FloatPoint RenderLayer::perspectiveOrigin() const
1806 {
1807     if (!renderer().hasTransformRelatedProperty())
1808         return FloatPoint();
1809 
1810     const LayoutRect borderBox = downcast&lt;RenderBox&gt;(renderer()).borderBoxRect();
1811     const RenderStyle&amp; style = renderer().style();
1812 
1813     return FloatPoint(floatValueForLength(style.perspectiveOriginX(), borderBox.width()),
1814                       floatValueForLength(style.perspectiveOriginY(), borderBox.height()));
1815 }
1816 
1817 static inline bool isContainerForPositioned(RenderLayer&amp; layer, PositionType position)
1818 {
1819     switch (position) {
1820     case PositionType::Fixed:
1821         return layer.renderer().canContainFixedPositionObjects();
1822 
1823     case PositionType::Absolute:
1824         return layer.renderer().canContainAbsolutelyPositionedObjects();
1825 
1826     default:
1827         ASSERT_NOT_REACHED();
1828         return false;
1829     }
1830 }
1831 
1832 bool RenderLayer::ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit) const
1833 {
1834     if (&amp;ancestor == this)
1835         return true;
1836 
1837     for (const auto* currentBlock = renderer().containingBlock(); currentBlock &amp;&amp; !is&lt;RenderView&gt;(*currentBlock); currentBlock = currentBlock-&gt;containingBlock()) {
1838         auto* currLayer = currentBlock-&gt;layer();
1839         if (currLayer == &amp;ancestor)
1840             return true;
1841 
1842         if (currLayer &amp;&amp; currLayer == checkLimit)
1843             return false;
1844     }
1845 
1846     return false;
1847 }
1848 
1849 RenderLayer* RenderLayer::enclosingAncestorForPosition(PositionType position) const
1850 {
1851     RenderLayer* curr = parent();
1852     while (curr &amp;&amp; !isContainerForPositioned(*curr, position))
1853         curr = curr-&gt;parent();
1854 
1855     return curr;
1856 }
1857 
1858 static RenderLayer* enclosingFrameRenderLayer(const RenderLayer&amp; layer)
1859 {
1860     auto* ownerElement = layer.renderer().document().ownerElement();
1861     if (!ownerElement)
1862         return nullptr;
1863 
1864     auto* ownerRenderer = ownerElement-&gt;renderer();
1865     if (!ownerRenderer)
1866         return nullptr;
1867 
1868     return ownerRenderer-&gt;enclosingLayer();
1869 }
1870 
1871 static RenderLayer* parentLayerCrossFrame(const RenderLayer&amp; layer)
1872 {
1873     if (auto* parent = layer.parent())
1874         return parent;
1875 
1876     return enclosingFrameRenderLayer(layer);
1877 }
1878 
1879 RenderLayer* RenderLayer::enclosingScrollableLayer() const
1880 {
1881     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
1882         if (is&lt;RenderBox&gt;(nextLayer-&gt;renderer()) &amp;&amp; downcast&lt;RenderBox&gt;(nextLayer-&gt;renderer()).canBeScrolledAndHasScrollableArea())
1883             return nextLayer;
1884     }
1885 
1886     return nullptr;
1887 }
1888 
1889 IntRect RenderLayer::scrollableAreaBoundingBox(bool* isInsideFixed) const
1890 {
1891     return renderer().absoluteBoundingBoxRect(/* useTransforms */ true, isInsideFixed);
1892 }
1893 
1894 bool RenderLayer::isRubberBandInProgress() const
1895 {
1896 #if ENABLE(RUBBER_BANDING)
1897     if (!scrollsOverflow())
1898         return false;
1899 
1900     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
1901         return scrollAnimator-&gt;isRubberBandInProgress();
1902 #endif
1903 
1904     return false;
1905 }
1906 
1907 bool RenderLayer::forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const
1908 {
1909     return renderer().settings().forceUpdateScrollbarsOnMainThreadForPerformanceTesting();
1910 }
1911 
1912 RenderLayer* RenderLayer::enclosingTransformedAncestor() const
1913 {
1914     RenderLayer* curr = parent();
1915     while (curr &amp;&amp; !curr-&gt;isRenderViewLayer() &amp;&amp; !curr-&gt;transform())
1916         curr = curr-&gt;parent();
1917 
1918     return curr;
1919 }
1920 
1921 inline bool RenderLayer::shouldRepaintAfterLayout() const
1922 {
1923     if (m_repaintStatus == NeedsNormalRepaint)
1924         return true;
1925 
1926     // Composited layers that were moved during a positioned movement only
1927     // layout, don&#39;t need to be repainted. They just need to be recomposited.
1928     ASSERT(m_repaintStatus == NeedsFullRepaintForPositionedMovementLayout);
1929     return !isComposited() || backing()-&gt;paintsIntoCompositedAncestor();
1930 }
1931 
1932 void RenderLayer::setBackingProviderLayer(RenderLayer* backingProvider)
1933 {
1934     if (backingProvider == m_backingProviderLayer)
1935         return;
1936 
1937     if (!renderer().renderTreeBeingDestroyed())
1938         clearClipRectsIncludingDescendants();
1939 
1940     m_backingProviderLayer = makeWeakPtr(backingProvider);
1941 }
1942 
1943 void RenderLayer::disconnectFromBackingProviderLayer()
1944 {
1945     if (!m_backingProviderLayer)
1946         return;
1947 
1948     ASSERT(m_backingProviderLayer-&gt;isComposited());
1949     if (m_backingProviderLayer-&gt;isComposited())
1950         m_backingProviderLayer-&gt;backing()-&gt;removeBackingSharingLayer(*this);
1951 }
1952 
1953 bool compositedWithOwnBackingStore(const RenderLayer&amp; layer)
1954 {
1955     return layer.isComposited() &amp;&amp; !layer.backing()-&gt;paintsIntoCompositedAncestor();
1956 }
1957 
1958 RenderLayer* RenderLayer::enclosingCompositingLayer(IncludeSelfOrNot includeSelf) const
1959 {
1960     if (includeSelf == IncludeSelf &amp;&amp; isComposited())
1961         return const_cast&lt;RenderLayer*&gt;(this);
1962 
1963     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1964         if (curr-&gt;isComposited())
1965             return const_cast&lt;RenderLayer*&gt;(curr);
1966     }
1967 
1968     return nullptr;
1969 }
1970 
1971 RenderLayer* RenderLayer::enclosingCompositingLayerForRepaint(IncludeSelfOrNot includeSelf) const
1972 {
1973     auto repaintTargetForLayer = [](const RenderLayer&amp; layer) -&gt; RenderLayer* {
1974         if (compositedWithOwnBackingStore(layer))
1975             return const_cast&lt;RenderLayer*&gt;(&amp;layer);
1976 
1977         if (layer.paintsIntoProvidedBacking())
1978             return layer.backingProviderLayer();
1979 
1980         return nullptr;
1981     };
1982 
1983     RenderLayer* repaintTarget = nullptr;
1984     if (includeSelf == IncludeSelf &amp;&amp; (repaintTarget = repaintTargetForLayer(*this)))
1985         return repaintTarget;
1986 
1987     for (const RenderLayer* curr = paintOrderParent(); curr; curr = curr-&gt;paintOrderParent()) {
1988         if ((repaintTarget = repaintTargetForLayer(*curr)))
1989             return repaintTarget;
1990     }
1991 
1992     return nullptr;
1993 }
1994 
1995 RenderLayer* RenderLayer::enclosingFilterLayer(IncludeSelfOrNot includeSelf) const
1996 {
1997     const RenderLayer* curr = (includeSelf == IncludeSelf) ? this : parent();
1998     for (; curr; curr = curr-&gt;parent()) {
1999         if (curr-&gt;requiresFullLayerImageForFilters())
2000             return const_cast&lt;RenderLayer*&gt;(curr);
2001     }
2002 
2003     return nullptr;
2004 }
2005 
2006 RenderLayer* RenderLayer::enclosingFilterRepaintLayer() const
2007 {
2008     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
2009         if ((curr != this &amp;&amp; curr-&gt;requiresFullLayerImageForFilters()) || compositedWithOwnBackingStore(*curr) || curr-&gt;isRenderViewLayer())
2010             return const_cast&lt;RenderLayer*&gt;(curr);
2011     }
2012     return nullptr;
2013 }
2014 
2015 // FIXME: This neeeds a better name.
2016 void RenderLayer::setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp; rect)
2017 {
2018     ASSERT(requiresFullLayerImageForFilters());
2019     ASSERT(m_filters);
2020 
2021     if (rect.isEmpty())
2022         return;
2023 
2024     LayoutRect rectForRepaint = rect;
2025     rectForRepaint += filterOutsets();
2026 
2027     m_filters-&gt;expandDirtySourceRect(rectForRepaint);
2028 
2029     RenderLayer* parentLayer = enclosingFilterRepaintLayer();
2030     ASSERT(parentLayer);
2031     FloatQuad repaintQuad(rectForRepaint);
2032     LayoutRect parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
2033 
2034     if (parentLayer-&gt;isComposited()) {
2035         if (!parentLayer-&gt;backing()-&gt;paintsIntoWindow()) {
2036             parentLayer-&gt;setBackingNeedsRepaintInRect(parentLayerRect);
2037             return;
2038         }
2039         // If the painting goes to window, redirect the painting to the parent RenderView.
2040         parentLayer = renderer().view().layer();
2041         parentLayerRect = renderer().localToContainerQuad(repaintQuad, &amp;parentLayer-&gt;renderer()).enclosingBoundingBox();
2042     }
2043 
2044     if (parentLayer-&gt;paintsWithFilters()) {
2045         parentLayer-&gt;setFilterBackendNeedsRepaintingInRect(parentLayerRect);
2046         return;
2047     }
2048 
2049     if (parentLayer-&gt;isRenderViewLayer()) {
2050         downcast&lt;RenderView&gt;(parentLayer-&gt;renderer()).repaintViewRectangle(parentLayerRect);
2051         return;
2052     }
2053 
2054     ASSERT_NOT_REACHED();
2055 }
2056 
2057 bool RenderLayer::hasAncestorWithFilterOutsets() const
2058 {
2059     for (const RenderLayer* curr = this; curr; curr = curr-&gt;parent()) {
2060         if (curr-&gt;hasFilterOutsets())
2061             return true;
2062     }
2063     return false;
2064 }
2065 
2066 RenderLayer* RenderLayer::clippingRootForPainting() const
2067 {
2068     if (isComposited())
2069         return const_cast&lt;RenderLayer*&gt;(this);
2070 
2071     if (paintsIntoProvidedBacking())
2072         return backingProviderLayer();
2073 
2074     const RenderLayer* current = this;
2075     while (current) {
2076         if (current-&gt;isRenderViewLayer())
2077             return const_cast&lt;RenderLayer*&gt;(current);
2078 
2079         current = current-&gt;paintOrderParent();
2080         ASSERT(current);
2081         if (current-&gt;transform() || compositedWithOwnBackingStore(*current))
2082             return const_cast&lt;RenderLayer*&gt;(current);
2083 
2084         if (current-&gt;paintsIntoProvidedBacking())
2085             return current-&gt;backingProviderLayer();
2086     }
2087 
2088     ASSERT_NOT_REACHED();
2089     return nullptr;
2090 }
2091 
2092 LayoutPoint RenderLayer::absoluteToContents(const LayoutPoint&amp; absolutePoint) const
2093 {
2094     // We don&#39;t use convertToLayerCoords because it doesn&#39;t know about transforms
2095     return LayoutPoint(renderer().absoluteToLocal(absolutePoint, UseTransforms));
2096 }
2097 
2098 bool RenderLayer::cannotBlitToWindow() const
2099 {
2100     if (isTransparent() || hasReflection() || hasTransform())
2101         return true;
2102     if (!parent())
2103         return false;
2104     return parent()-&gt;cannotBlitToWindow();
2105 }
2106 
2107 RenderLayer* RenderLayer::transparentPaintingAncestor()
2108 {
2109     if (isComposited())
2110         return nullptr;
2111 
2112     for (RenderLayer* curr = parent(); curr; curr = curr-&gt;parent()) {
2113         if (curr-&gt;isComposited())
2114             return nullptr;
2115         if (curr-&gt;isTransparent())
2116             return curr;
2117     }
2118     return nullptr;
2119 }
2120 
2121 enum TransparencyClipBoxBehavior {
2122     PaintingTransparencyClipBox,
2123     HitTestingTransparencyClipBox
2124 };
2125 
2126 enum TransparencyClipBoxMode {
2127     DescendantsOfTransparencyClipBox,
2128     RootOfTransparencyClipBox
2129 };
2130 
2131 static LayoutRect transparencyClipBox(const RenderLayer&amp;, const RenderLayer* rootLayer, TransparencyClipBoxBehavior, TransparencyClipBoxMode, OptionSet&lt;PaintBehavior&gt; = { });
2132 
2133 static void expandClipRectForDescendantsAndReflection(LayoutRect&amp; clipRect, const RenderLayer&amp; layer, const RenderLayer* rootLayer,
2134     TransparencyClipBoxBehavior transparencyBehavior, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2135 {
2136     // If we have a mask, then the clip is limited to the border box area (and there is
2137     // no need to examine child layers).
2138     if (!layer.renderer().hasMask()) {
2139         // Note: we don&#39;t have to walk z-order lists since transparent elements always establish
2140         // a stacking container. This means we can just walk the layer tree directly.
2141         for (RenderLayer* curr = layer.firstChild(); curr; curr = curr-&gt;nextSibling()) {
2142             if (!layer.isReflectionLayer(*curr))
2143                 clipRect.unite(transparencyClipBox(*curr, rootLayer, transparencyBehavior, DescendantsOfTransparencyClipBox, paintBehavior));
2144         }
2145     }
2146 
2147     // If we have a reflection, then we need to account for that when we push the clip.  Reflect our entire
2148     // current transparencyClipBox to catch all child layers.
2149     // FIXME: Accelerated compositing will eventually want to do something smart here to avoid incorporating this
2150     // size into the parent layer.
2151     if (layer.renderer().hasReflection()) {
2152         LayoutSize delta = layer.offsetFromAncestor(rootLayer);
2153         clipRect.move(-delta);
2154         clipRect.unite(layer.renderBox()-&gt;reflectedRect(clipRect));
2155         clipRect.move(delta);
2156     }
2157 }
2158 
2159 static LayoutRect transparencyClipBox(const RenderLayer&amp; layer, const RenderLayer* rootLayer, TransparencyClipBoxBehavior transparencyBehavior,
2160     TransparencyClipBoxMode transparencyMode, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2161 {
2162     // FIXME: Although this function completely ignores CSS-imposed clipping, we did already intersect with the
2163     // paintDirtyRect, and that should cut down on the amount we have to paint.  Still it
2164     // would be better to respect clips.
2165 
2166     if (rootLayer != &amp;layer &amp;&amp; ((transparencyBehavior == PaintingTransparencyClipBox &amp;&amp; layer.paintsWithTransform(paintBehavior))
2167         || (transparencyBehavior == HitTestingTransparencyClipBox &amp;&amp; layer.hasTransform()))) {
2168         // The best we can do here is to use enclosed bounding boxes to establish a &quot;fuzzy&quot; enough clip to encompass
2169         // the transformed layer and all of its children.
2170         RenderLayer::PaginationInclusionMode mode = transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::IncludeCompositedPaginatedLayers : RenderLayer::ExcludeCompositedPaginatedLayers;
2171         const RenderLayer* paginationLayer = transparencyMode == DescendantsOfTransparencyClipBox ? layer.enclosingPaginationLayer(mode) : nullptr;
2172         const RenderLayer* rootLayerForTransform = paginationLayer ? paginationLayer : rootLayer;
2173         LayoutSize delta = layer.offsetFromAncestor(rootLayerForTransform);
2174 
2175         TransformationMatrix transform;
2176         transform.translate(delta.width(), delta.height());
2177         transform.multiply(*layer.transform());
2178 
2179         // We don&#39;t use fragment boxes when collecting a transformed layer&#39;s bounding box, since it always
2180         // paints unfragmented.
2181         LayoutRect clipRect = layer.boundingBox(&amp;layer);
2182         expandClipRectForDescendantsAndReflection(clipRect, layer, &amp;layer, transparencyBehavior, paintBehavior);
2183         clipRect += layer.filterOutsets();
2184         LayoutRect result = transform.mapRect(clipRect);
2185         if (!paginationLayer)
2186             return result;
2187 
2188         // We have to break up the transformed extent across our columns.
2189         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
2190         // get our true bounding box.
2191         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
2192         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
2193         result.move(paginationLayer-&gt;offsetFromAncestor(rootLayer));
2194         return result;
2195     }
2196 
2197     LayoutRect clipRect = layer.boundingBox(rootLayer, layer.offsetFromAncestor(rootLayer), transparencyBehavior == HitTestingTransparencyClipBox ? RenderLayer::UseFragmentBoxesIncludingCompositing : RenderLayer::UseFragmentBoxesExcludingCompositing);
2198     expandClipRectForDescendantsAndReflection(clipRect, layer, rootLayer, transparencyBehavior, paintBehavior);
2199     clipRect += layer.filterOutsets();
2200 
2201     return clipRect;
2202 }
2203 
2204 static LayoutRect paintingExtent(const RenderLayer&amp; currentLayer, const RenderLayer* rootLayer, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt; paintBehavior)
2205 {
2206     return intersection(transparencyClipBox(currentLayer, rootLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintBehavior), paintDirtyRect);
2207 }
2208 
2209 void RenderLayer::beginTransparencyLayers(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutRect&amp; dirtyRect)
2210 {
2211     if (context.paintingDisabled() || (paintsWithTransparency(paintingInfo.paintBehavior) &amp;&amp; m_usedTransparency))
2212         return;
2213 
2214     RenderLayer* ancestor = transparentPaintingAncestor();
2215     if (ancestor)
2216         ancestor-&gt;beginTransparencyLayers(context, paintingInfo, dirtyRect);
2217 
2218     if (paintsWithTransparency(paintingInfo.paintBehavior)) {
2219         ASSERT(isCSSStackingContext());
2220         m_usedTransparency = true;
2221         context.save();
2222         LayoutRect adjustedClipRect = paintingExtent(*this, paintingInfo.rootLayer, dirtyRect, paintingInfo.paintBehavior);
2223         adjustedClipRect.move(paintingInfo.subpixelOffset);
2224         FloatRect pixelSnappedClipRect = snapRectToDevicePixels(adjustedClipRect, renderer().document().deviceScaleFactor());
2225         context.clip(pixelSnappedClipRect);
2226 
2227 #if ENABLE(CSS_COMPOSITING)
2228         bool usesCompositeOperation = hasBlendMode() &amp;&amp; !(renderer().isSVGRoot() &amp;&amp; parent() &amp;&amp; parent()-&gt;isRenderViewLayer());
2229         if (usesCompositeOperation)
2230             context.setCompositeOperation(context.compositeOperation(), blendMode());
2231 #endif
2232 
2233         context.beginTransparencyLayer(renderer().opacity());
2234 
2235 #if ENABLE(CSS_COMPOSITING)
2236         if (usesCompositeOperation)
2237             context.setCompositeOperation(context.compositeOperation(), BlendMode::Normal);
2238 #endif
2239 
2240 #ifdef REVEAL_TRANSPARENCY_LAYERS
2241         context.setFillColor(Color(0.0f, 0.0f, 0.5f, 0.2f));
2242         context.fillRect(pixelSnappedClipRect);
2243 #endif
2244     }
2245 }
2246 
2247 #if PLATFORM(IOS_FAMILY)
2248 void RenderLayer::willBeDestroyed()
2249 {
2250     if (RenderLayerBacking* layerBacking = backing())
2251         layerBacking-&gt;layerWillBeDestroyed();
2252 }
2253 #endif
2254 
2255 bool RenderLayer::isDescendantOf(const RenderLayer&amp; layer) const
2256 {
2257     for (auto* ancestor = this; ancestor; ancestor = ancestor-&gt;parent()) {
2258         if (&amp;layer == ancestor)
2259             return true;
2260     }
2261     return false;
2262 }
2263 
2264 static RenderLayer* findCommonAncestor(const RenderLayer&amp; firstLayer, const RenderLayer&amp; secondLayer)
2265 {
2266     if (&amp;firstLayer == &amp;secondLayer)
2267         return const_cast&lt;RenderLayer*&gt;(&amp;firstLayer);
2268 
2269     HashSet&lt;const RenderLayer*&gt; ancestorChain;
2270     for (auto* currLayer = &amp;firstLayer; currLayer; currLayer = currLayer-&gt;parent())
2271         ancestorChain.add(currLayer);
2272 
2273     for (auto* currLayer = &amp;secondLayer; currLayer; currLayer = currLayer-&gt;parent()) {
2274         if (ancestorChain.contains(currLayer))
2275             return const_cast&lt;RenderLayer*&gt;(currLayer);
2276     }
2277     return nullptr;
2278 }
2279 
2280 RenderLayer* RenderLayer::commonAncestorWithLayer(const RenderLayer&amp; layer) const
2281 {
2282     return findCommonAncestor(*this, layer);
2283 }
2284 
2285 void RenderLayer::convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; roundedLocation, ColumnOffsetAdjustment adjustForColumns) const
2286 {
2287     LayoutPoint location = convertToLayerCoords(ancestorLayer, roundedLocation, adjustForColumns);
2288     roundedLocation = roundedIntPoint(location);
2289 }
2290 
2291 // Returns the layer reached on the walk up towards the ancestor.
2292 static inline const RenderLayer* accumulateOffsetTowardsAncestor(const RenderLayer* layer, const RenderLayer* ancestorLayer, LayoutPoint&amp; location, RenderLayer::ColumnOffsetAdjustment adjustForColumns)
2293 {
2294     ASSERT(ancestorLayer != layer);
2295 
2296     const RenderLayerModelObject&amp; renderer = layer-&gt;renderer();
2297     auto position = renderer.style().position();
2298 
2299     // FIXME: Special casing RenderFragmentedFlow so much for fixed positioning here is not great.
2300     RenderFragmentedFlow* fixedFragmentedFlowContainer = position == PositionType::Fixed ? renderer.enclosingFragmentedFlow() : nullptr;
2301     if (fixedFragmentedFlowContainer &amp;&amp; !fixedFragmentedFlowContainer-&gt;isOutOfFlowPositioned())
2302         fixedFragmentedFlowContainer = nullptr;
2303 
2304     // FIXME: Positioning of out-of-flow(fixed, absolute) elements collected in a RenderFragmentedFlow
2305     // may need to be revisited in a future patch.
2306     // If the fixed renderer is inside a RenderFragmentedFlow, we should not compute location using localToAbsolute,
2307     // since localToAbsolute maps the coordinates from named flow to regions coordinates and regions can be
2308     // positioned in a completely different place in the viewport (RenderView).
2309     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer &amp;&amp; (!ancestorLayer || ancestorLayer == renderer.view().layer())) {
2310         // If the fixed layer&#39;s container is the root, just add in the offset of the view. We can obtain this by calling
2311         // localToAbsolute() on the RenderView.
2312         FloatPoint absPos = renderer.localToAbsolute(FloatPoint(), IsFixed);
2313         location += LayoutSize(absPos.x(), absPos.y());
2314         return ancestorLayer;
2315     }
2316 
2317     // For the fixed positioned elements inside a render flow thread, we should also skip the code path below
2318     // Otherwise, for the case of ancestorLayer == rootLayer and fixed positioned element child of a transformed
2319     // element in render flow thread, we will hit the fixed positioned container before hitting the ancestor layer.
2320     if (position == PositionType::Fixed &amp;&amp; !fixedFragmentedFlowContainer) {
2321         // For a fixed layers, we need to walk up to the root to see if there&#39;s a fixed position container
2322         // (e.g. a transformed layer). It&#39;s an error to call offsetFromAncestor() across a layer with a transform,
2323         // so we should always find the ancestor at or before we find the fixed position container.
2324         RenderLayer* fixedPositionContainerLayer = nullptr;
2325         bool foundAncestor = false;
2326         for (RenderLayer* currLayer = layer-&gt;parent(); currLayer; currLayer = currLayer-&gt;parent()) {
2327             if (currLayer == ancestorLayer)
2328                 foundAncestor = true;
2329 
2330             if (isContainerForPositioned(*currLayer, PositionType::Fixed)) {
2331                 fixedPositionContainerLayer = currLayer;
2332                 ASSERT_UNUSED(foundAncestor, foundAncestor);
2333                 break;
2334             }
2335         }
2336 
2337         ASSERT(fixedPositionContainerLayer); // We should have hit the RenderView&#39;s layer at least.
2338 
2339         if (fixedPositionContainerLayer != ancestorLayer) {
2340             LayoutSize fixedContainerCoords = layer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2341             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(fixedPositionContainerLayer);
2342             location += (fixedContainerCoords - ancestorCoords);
2343             return ancestorLayer;
2344         }
2345     }
2346 
2347     if (position == PositionType::Fixed &amp;&amp; fixedFragmentedFlowContainer) {
2348         ASSERT(ancestorLayer);
2349         if (ancestorLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
2350             location += toLayoutSize(layer-&gt;location());
2351             return ancestorLayer;
2352         }
2353 
2354         if (ancestorLayer == renderer.view().layer()) {
2355             // Add location in flow thread coordinates.
2356             location += toLayoutSize(layer-&gt;location());
2357 
2358             // Add flow thread offset in view coordinates since the view may be scrolled.
2359             FloatPoint absPos = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
2360             location += LayoutSize(absPos.x(), absPos.y());
2361             return ancestorLayer;
2362         }
2363     }
2364 
2365     RenderLayer* parentLayer;
2366     if (position == PositionType::Absolute || position == PositionType::Fixed) {
2367         // Do what enclosingAncestorForPosition() does, but check for ancestorLayer along the way.
2368         parentLayer = layer-&gt;parent();
2369         bool foundAncestorFirst = false;
2370         while (parentLayer) {
2371             // RenderFragmentedFlow is a positioned container, child of RenderView, positioned at (0,0).
2372             // This implies that, for out-of-flow positioned elements inside a RenderFragmentedFlow,
2373             // we are bailing out before reaching root layer.
2374             if (isContainerForPositioned(*parentLayer, position))
2375                 break;
2376 
2377             if (parentLayer == ancestorLayer) {
2378                 foundAncestorFirst = true;
2379                 break;
2380             }
2381 
2382             parentLayer = parentLayer-&gt;parent();
2383         }
2384 
2385         // We should not reach RenderView layer past the RenderFragmentedFlow layer for any
2386         // children of the RenderFragmentedFlow.
2387         if (renderer.enclosingFragmentedFlow() &amp;&amp; !layer-&gt;isOutOfFlowRenderFragmentedFlow())
2388             ASSERT(parentLayer != renderer.view().layer());
2389 
2390         if (foundAncestorFirst) {
2391             // Found ancestorLayer before the abs. positioned container, so compute offset of both relative
2392             // to enclosingAncestorForPosition and subtract.
2393             RenderLayer* positionedAncestor = parentLayer-&gt;enclosingAncestorForPosition(position);
2394             LayoutSize thisCoords = layer-&gt;offsetFromAncestor(positionedAncestor);
2395             LayoutSize ancestorCoords = ancestorLayer-&gt;offsetFromAncestor(positionedAncestor);
2396             location += (thisCoords - ancestorCoords);
2397             return ancestorLayer;
2398         }
2399     } else
2400         parentLayer = layer-&gt;parent();
2401 
2402     if (!parentLayer)
2403         return nullptr;
2404 
2405     location += toLayoutSize(layer-&gt;location());
2406 
2407     if (adjustForColumns == RenderLayer::AdjustForColumns) {
2408         if (RenderLayer* parentLayer = layer-&gt;parent()) {
2409             if (is&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer())) {
2410                 RenderFragmentContainer* fragment = downcast&lt;RenderMultiColumnFlow&gt;(parentLayer-&gt;renderer()).physicalTranslationFromFlowToFragment(location);
2411                 if (fragment)
2412                     location.moveBy(fragment-&gt;topLeftLocation() + -parentLayer-&gt;renderBox()-&gt;topLeftLocation());
2413             }
2414         }
2415     }
2416 
2417     return parentLayer;
2418 }
2419 
2420 LayoutPoint RenderLayer::convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp; location, ColumnOffsetAdjustment adjustForColumns) const
2421 {
2422     if (ancestorLayer == this)
2423         return location;
2424 
2425     const RenderLayer* currLayer = this;
2426     LayoutPoint locationInLayerCoords = location;
2427     while (currLayer &amp;&amp; currLayer != ancestorLayer)
2428         currLayer = accumulateOffsetTowardsAncestor(currLayer, ancestorLayer, locationInLayerCoords, adjustForColumns);
2429     return locationInLayerCoords;
2430 }
2431 
2432 LayoutSize RenderLayer::offsetFromAncestor(const RenderLayer* ancestorLayer, ColumnOffsetAdjustment adjustForColumns) const
2433 {
2434     return toLayoutSize(convertToLayerCoords(ancestorLayer, LayoutPoint(), adjustForColumns));
2435 }
2436 
2437 bool RenderLayer::canUseCompositedScrolling() const
2438 {
2439     bool isVisible = renderer().style().visibility() == Visibility::Visible;
2440     if (renderer().settings().asyncOverflowScrollingEnabled())
2441         return isVisible &amp;&amp; scrollsOverflow();
2442 
2443 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(OVERFLOW_SCROLLING_TOUCH)
2444     return isVisible &amp;&amp; scrollsOverflow() &amp;&amp; (renderer().style().useTouchOverflowScrolling() || renderer().settings().alwaysUseAcceleratedOverflowScroll());
2445 #else
2446     return false;
2447 #endif
2448 }
2449 
2450 #if ENABLE(IOS_TOUCH_EVENTS)
2451 bool RenderLayer::handleTouchEvent(const PlatformTouchEvent&amp; touchEvent)
2452 {
2453     // If we have accelerated scrolling, let the scrolling be handled outside of WebKit.
2454     if (hasCompositedScrollableOverflow())
2455         return false;
2456 
2457     return ScrollableArea::handleTouchEvent(touchEvent);
2458 }
2459 
2460 void RenderLayer::registerAsTouchEventListenerForScrolling()
2461 {
2462     if (!renderer().element() || m_registeredAsTouchEventListenerForScrolling)
2463         return;
2464 
2465     renderer().document().addTouchEventHandler(*renderer().element());
2466     m_registeredAsTouchEventListenerForScrolling = true;
2467 }
2468 
2469 void RenderLayer::unregisterAsTouchEventListenerForScrolling()
2470 {
2471     if (!renderer().element() || !m_registeredAsTouchEventListenerForScrolling)
2472         return;
2473 
2474     renderer().document().removeTouchEventHandler(*renderer().element());
2475     m_registeredAsTouchEventListenerForScrolling = false;
2476 }
2477 #endif // ENABLE(IOS_TOUCH_EVENTS)
2478 
2479 // FIXME: this is only valid after we&#39;ve made layers.
2480 bool RenderLayer::usesCompositedScrolling() const
2481 {
2482     return isComposited() &amp;&amp; backing()-&gt;hasScrollingLayer();
2483 }
2484 
2485 // FIXME: this is only valid after we&#39;ve made layers.
2486 bool RenderLayer::usesAsyncScrolling() const
2487 {
2488     return compositor().useCoordinatedScrollingForLayer(*this);
2489 }
2490 
2491 static inline int adjustedScrollDelta(int beginningDelta)
2492 {
2493     // This implemention matches Firefox&#39;s.
2494     // http://mxr.mozilla.org/firefox/source/toolkit/content/widgets/browser.xml#856.
2495     const int speedReducer = 12;
2496 
2497     int adjustedDelta = beginningDelta / speedReducer;
2498     if (adjustedDelta &gt; 1)
2499         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(adjustedDelta))) - 1;
2500     else if (adjustedDelta &lt; -1)
2501         adjustedDelta = static_cast&lt;int&gt;(adjustedDelta * sqrt(static_cast&lt;double&gt;(-adjustedDelta))) + 1;
2502 
2503     return adjustedDelta;
2504 }
2505 
2506 static inline IntSize adjustedScrollDelta(const IntSize&amp; delta)
2507 {
2508     return IntSize(adjustedScrollDelta(delta.width()), adjustedScrollDelta(delta.height()));
2509 }
2510 
2511 void RenderLayer::panScrollFromPoint(const IntPoint&amp; sourcePoint)
2512 {
2513     IntPoint lastKnownMousePosition = renderer().frame().eventHandler().lastKnownMousePosition();
2514 
2515     // We need to check if the last known mouse position is out of the window. When the mouse is out of the window, the position is incoherent
2516     static IntPoint previousMousePosition;
2517     if (lastKnownMousePosition.x() &lt; 0 || lastKnownMousePosition.y() &lt; 0)
2518         lastKnownMousePosition = previousMousePosition;
2519     else
2520         previousMousePosition = lastKnownMousePosition;
2521 
2522     IntSize delta = lastKnownMousePosition - sourcePoint;
2523 
2524     if (abs(delta.width()) &lt;= ScrollView::noPanScrollRadius) // at the center we let the space for the icon
2525         delta.setWidth(0);
2526     if (abs(delta.height()) &lt;= ScrollView::noPanScrollRadius)
2527         delta.setHeight(0);
2528 
2529     scrollByRecursively(adjustedScrollDelta(delta));
2530 }
2531 
2532 // FIXME: unify with the scrollRectToVisible() code below.
2533 void RenderLayer::scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea)
2534 {
2535     if (delta.isZero())
2536         return;
2537 
2538     bool restrictedByLineClamp = false;
2539     if (renderer().parent())
2540         restrictedByLineClamp = !renderer().parent()-&gt;style().lineClamp().isNone();
2541 
2542     if (renderer().hasOverflowClip() &amp;&amp; !restrictedByLineClamp) {
2543         ScrollOffset newScrollOffset = scrollOffset() + delta;
2544         scrollToOffset(newScrollOffset);
2545         if (scrolledArea)
2546             *scrolledArea = this;
2547 
2548         // If this layer can&#39;t do the scroll we ask the next layer up that can scroll to try
2549         IntSize remainingScrollOffset = newScrollOffset - scrollOffset();
2550         if (!remainingScrollOffset.isZero() &amp;&amp; renderer().parent()) {
2551             if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
2552                 scrollableLayer-&gt;scrollByRecursively(remainingScrollOffset, scrolledArea);
2553 
2554             renderer().frame().eventHandler().updateAutoscrollRenderer();
2555         }
2556     } else {
2557         // If we are here, we were called on a renderer that can be programmatically scrolled, but doesn&#39;t
2558         // have an overflow clip. Which means that it is a document node that can be scrolled.
2559         renderer().view().frameView().scrollBy(delta);
2560         if (scrolledArea)
2561             *scrolledArea = &amp;renderer().view().frameView();
2562 
2563         // FIXME: If we didn&#39;t scroll the whole way, do we want to try looking at the frames ownerElement?
2564         // https://bugs.webkit.org/show_bug.cgi?id=28237
2565     }
2566 }
2567 
2568 void RenderLayer::setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt; position)
2569 {
2570     m_postLayoutScrollPosition = position;
2571 }
2572 
2573 void RenderLayer::applyPostLayoutScrollPositionIfNeeded()
2574 {
2575     if (!m_postLayoutScrollPosition)
2576         return;
2577 
2578     scrollToOffset(scrollOffsetFromPosition(m_postLayoutScrollPosition.value()));
2579     m_postLayoutScrollPosition = WTF::nullopt;
2580 }
2581 
2582 void RenderLayer::scrollToXPosition(int x, ScrollType scrollType, ScrollClamping clamping)
2583 {
2584     ScrollPosition position(x, m_scrollPosition.y());
2585     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2586 }
2587 
2588 void RenderLayer::scrollToYPosition(int y, ScrollType scrollType, ScrollClamping clamping)
2589 {
2590     ScrollPosition position(m_scrollPosition.x(), y);
2591     scrollToOffset(scrollOffsetFromPosition(position), scrollType, clamping);
2592 }
2593 
2594 ScrollOffset RenderLayer::clampScrollOffset(const ScrollOffset&amp; scrollOffset) const
2595 {
2596     return scrollOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
2597 }
2598 
2599 bool RenderLayer::requestScrollPositionUpdate(const ScrollPosition&amp; position, ScrollType scrollType, ScrollClamping clamping)
2600 {
2601 #if ENABLE(ASYNC_SCROLLING)
2602     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
2603         return scrollingCoordinator-&gt;requestScrollPositionUpdate(*this, position, scrollType, clamping);
2604 #endif
2605     return false;
2606 }
2607 
2608 void RenderLayer::scrollToOffset(const ScrollOffset&amp; scrollOffset, ScrollType scrollType, ScrollClamping clamping)
2609 {
2610     ScrollOffset clampedScrollOffset = clamping == ScrollClamping::Clamped ? clampScrollOffset(scrollOffset) : scrollOffset;
2611     if (clampedScrollOffset == this-&gt;scrollOffset())
2612         return;
2613 
2614     auto previousScrollType = currentScrollType();
2615     setCurrentScrollType(scrollType);
2616 
2617     if (!requestScrollPositionUpdate(scrollPositionFromOffset(clampedScrollOffset), scrollType, clamping))
2618         scrollToOffsetWithoutAnimation(clampedScrollOffset, clamping);
2619 
2620     setCurrentScrollType(previousScrollType);
2621 }
2622 
2623 void RenderLayer::scrollTo(const ScrollPosition&amp; position)
2624 {
2625     RenderBox* box = renderBox();
2626     if (!box)
2627         return;
2628 
2629     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;RenderLayer::scrollTo &quot; &lt;&lt; position &lt;&lt; &quot; from &quot; &lt;&lt; m_scrollPosition &lt;&lt; &quot; (is user scroll &quot; &lt;&lt; (currentScrollType() == ScrollType::User) &lt;&lt; &quot;)&quot;);
2630 
2631     ScrollPosition newPosition = position;
2632     if (!box-&gt;isHTMLMarquee()) {
2633         // Ensure that the dimensions will be computed if they need to be (for overflow:hidden blocks).
2634         if (m_scrollDimensionsDirty)
2635             computeScrollDimensions();
2636 #if PLATFORM(IOS_FAMILY)
2637         if (adjustForIOSCaretWhenScrolling()) {
2638             // FIXME: It&#39;s not clear what this code is trying to do. Behavior seems reasonable with it removed.
2639             int maxOffset = scrollWidth() - roundToInt(box-&gt;clientWidth());
2640             ScrollOffset newOffset = scrollOffsetFromPosition(newPosition);
2641             int scrollXOffset = newOffset.x();
2642             if (scrollXOffset &gt; maxOffset - caretWidth) {
2643                 scrollXOffset += caretWidth;
2644                 if (scrollXOffset &lt;= caretWidth)
2645                     scrollXOffset = 0;
2646             } else if (scrollXOffset &lt; m_scrollPosition.x() - caretWidth)
2647                 scrollXOffset -= caretWidth;
2648 
2649             newOffset.setX(scrollXOffset);
2650             newPosition = scrollPositionFromOffset(newOffset);
2651         }
2652 #endif
2653     }
2654 
2655     if (m_scrollPosition == newPosition) {
2656         // FIXME: Nothing guarantees we get a scrollTo() with an unchanged position at the end of a user gesture.
2657         // The ScrollingCoordinator probably needs to message the main thread when a gesture ends.
2658         if (requiresScrollPositionReconciliation()) {
2659             setNeedsCompositingGeometryUpdate();
2660             updateCompositingLayersAfterScroll();
2661         }
2662         return;
2663     }
2664 
2665     m_scrollPosition = newPosition;
2666 
2667     RenderView&amp; view = renderer().view();
2668 
2669     // Update the positions of our child layers (if needed as only fixed layers should be impacted by a scroll).
2670     // We don&#39;t update compositing layers, because we need to do a deep update from the compositing ancestor.
2671     if (!view.frameView().layoutContext().isInRenderTreeLayout()) {
2672         // If we&#39;re in the middle of layout, we&#39;ll just update layers once layout has finished.
2673         updateLayerPositionsAfterOverflowScroll();
2674 
2675         view.frameView().scheduleUpdateWidgetPositions();
2676 
2677         if (!m_updatingMarqueePosition) {
2678             // Avoid updating compositing layers if, higher on the stack, we&#39;re already updating layer
2679             // positions. Updating layer positions requires a full walk of up-to-date RenderLayers, and
2680             // in this case we&#39;re still updating their positions; we&#39;ll update compositing layers later
2681             // when that completes.
2682             if (usesCompositedScrolling()) {
2683                 setNeedsCompositingGeometryUpdate();
2684 
2685                 // Scroll position can affect the location of a composited descendant (which may be a sibling in z-order),
2686                 // so trigger a descendant walk from the paint-order parent.
2687                 if (auto* paintParent = paintOrderParent())
2688                     paintParent-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2689             }
2690 
2691             updateCompositingLayersAfterScroll();
2692         }
2693 
2694         // Update regions, scrolling may change the clip of a particular region.
2695         renderer().document().invalidateRenderingDependentRegions();
2696         DebugPageOverlays::didLayout(renderer().frame());
2697     }
2698 
2699     Frame&amp; frame = renderer().frame();
2700     RenderLayerModelObject* repaintContainer = renderer().containerForRepaint();
2701     // The caret rect needs to be invalidated after scrolling
2702     frame.selection().setCaretRectNeedsUpdate();
2703 
2704     LayoutRect rectForRepaint = renderer().hasRepaintLayoutRects() ? renderer().repaintLayoutRects().m_repaintRect : renderer().clippedOverflowRectForRepaint(repaintContainer);
2705 
2706     FloatQuad quadForFakeMouseMoveEvent = FloatQuad(rectForRepaint);
2707     if (repaintContainer)
2708         quadForFakeMouseMoveEvent = repaintContainer-&gt;localToAbsoluteQuad(quadForFakeMouseMoveEvent);
2709     frame.eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);
2710 
2711     bool requiresRepaint = true;
2712     if (usesCompositedScrolling()) {
2713         setNeedsCompositingGeometryUpdate();
2714         setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2715         requiresRepaint = false;
2716     }
2717 
2718     // Just schedule a full repaint of our object.
2719     if (requiresRepaint)
2720         renderer().repaintUsingContainer(repaintContainer, rectForRepaint);
2721 
2722     // Schedule the scroll and scroll-related DOM events.
2723     if (Element* element = renderer().element())
2724         element-&gt;document().addPendingScrollEventTarget(*element);
2725 
2726     if (scrollsOverflow())
2727         view.frameView().didChangeScrollOffset();
2728 
2729     view.frameView().viewportContentsChanged();
2730     frame.editor().renderLayerDidScroll(*this);
2731 }
2732 
2733 static inline bool frameElementAndViewPermitScroll(HTMLFrameElementBase* frameElementBase, FrameView&amp; frameView)
2734 {
2735     // If scrollbars aren&#39;t explicitly forbidden, permit scrolling.
2736     if (frameElementBase &amp;&amp; frameElementBase-&gt;scrollingMode() != ScrollbarAlwaysOff)
2737         return true;
2738 
2739     // If scrollbars are forbidden, user initiated scrolls should obviously be ignored.
2740     if (frameView.wasScrolledByUser())
2741         return false;
2742 
2743     // Forbid autoscrolls when scrollbars are off, but permits other programmatic scrolls,
2744     // like navigation to an anchor.
2745     return !frameView.frame().eventHandler().autoscrollInProgress();
2746 }
2747 
2748 bool RenderLayer::allowsCurrentScroll() const
2749 {
2750     if (!renderer().hasOverflowClip())
2751         return false;
2752 
2753     // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2754     // FIXME: Is this still needed? It used to be relevant for Safari RSS.
2755     if (renderer().parent() &amp;&amp; !renderer().parent()-&gt;style().lineClamp().isNone())
2756         return false;
2757 
2758     RenderBox* box = renderBox();
2759     ASSERT(box); // Only boxes can have overflowClip set.
2760 
2761     if (renderer().frame().eventHandler().autoscrollInProgress()) {
2762         // The &quot;programmatically&quot; here is misleading; this asks whether the box has scrollable overflow,
2763         // or is a special case like a form control.
2764         return box-&gt;canBeProgramaticallyScrolled();
2765     }
2766 
2767     // Programmatic scrolls can scroll overflow:hidden.
2768     return box-&gt;hasHorizontalOverflow() || box-&gt;hasVerticalOverflow();
2769 }
2770 
2771 void RenderLayer::scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp; options)
2772 {
2773     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;Layer &quot; &lt;&lt; this &lt;&lt; &quot; scrollRectToVisible &quot; &lt;&lt; absoluteRect);
2774 
2775     RenderLayer* parentLayer = nullptr;
2776     LayoutRect newRect = absoluteRect;
2777 
2778     // We may end up propagating a scroll event. It is important that we suspend events until
2779     // the end of the function since they could delete the layer or the layer&#39;s renderer().
2780     FrameView&amp; frameView = renderer().view().frameView();
2781 
2782     if (renderer().parent())
2783         parentLayer = renderer().parent()-&gt;enclosingLayer();
2784 
2785     if (allowsCurrentScroll()) {
2786         // Don&#39;t scroll to reveal an overflow layer that is restricted by the -webkit-line-clamp property.
2787         // This will prevent us from revealing text hidden by the slider in Safari RSS.
2788         RenderBox* box = renderBox();
2789         ASSERT(box);
2790         LayoutRect localExposeRect(box-&gt;absoluteToLocalQuad(FloatQuad(FloatRect(absoluteRect))).boundingBox());
2791         if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
2792             // For direction: rtl; writing-mode: horizontal-tb box, the scroll bar is on the left side. The visible rect
2793             // starts from the right side of scroll bar. So the x of localExposeRect should start from the same position too.
2794             localExposeRect.moveBy(LayoutPoint(-verticalScrollbarWidth(), 0));
2795         }
2796         LayoutRect layerBounds(0_lu, 0_lu, box-&gt;clientWidth(), box-&gt;clientHeight());
2797         LayoutRect revealRect = getRectToExpose(layerBounds, localExposeRect, insideFixed, options.alignX, options.alignY);
2798 
2799         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset() + toIntSize(roundedIntRect(revealRect).location()));
2800         if (clampedScrollOffset != scrollOffset()) {
2801             ScrollOffset oldScrollOffset = scrollOffset();
2802             scrollToOffset(clampedScrollOffset);
2803             IntSize scrollOffsetDifference = scrollOffset() - oldScrollOffset;
2804             localExposeRect.move(-scrollOffsetDifference);
2805             newRect = LayoutRect(box-&gt;localToAbsoluteQuad(FloatQuad(FloatRect(localExposeRect)), UseTransforms).boundingBox());
2806         }
2807     } else if (!parentLayer &amp;&amp; renderer().isRenderView()) {
2808         HTMLFrameOwnerElement* ownerElement = renderer().document().ownerElement();
2809 
2810         if (ownerElement &amp;&amp; ownerElement-&gt;renderer()) {
2811             HTMLFrameElementBase* frameElementBase = nullptr;
2812 
2813             if (is&lt;HTMLFrameElementBase&gt;(*ownerElement))
2814                 frameElementBase = downcast&lt;HTMLFrameElementBase&gt;(ownerElement);
2815 
2816             if (frameElementAndViewPermitScroll(frameElementBase, frameView)) {
2817                 // If this assertion fires we need to protect the ownerElement from being destroyed.
2818                 ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2819 
2820                 LayoutRect viewRect = frameView.visibleContentRect(LegacyIOSDocumentVisibleRect);
2821                 LayoutRect exposeRect = getRectToExpose(viewRect, absoluteRect, insideFixed, options.alignX, options.alignY);
2822 
2823                 IntPoint scrollOffset(roundedIntPoint(exposeRect.location()));
2824                 // Adjust offsets if they&#39;re outside of the allowable range.
2825                 scrollOffset = scrollOffset.constrainedBetween(IntPoint(), IntPoint(frameView.contentsSize()));
2826                 frameView.setScrollPosition(scrollOffset);
2827 
2828                 if (options.shouldAllowCrossOriginScrolling == ShouldAllowCrossOriginScrolling::Yes || frameView.safeToPropagateScrollToParent()) {
2829                     parentLayer = ownerElement-&gt;renderer()-&gt;enclosingLayer();
2830                     // Convert the rect into the coordinate space of the parent frame&#39;s document.
2831                     newRect = frameView.contentsToContainingViewContents(enclosingIntRect(newRect));
2832                     insideFixed = false; // FIXME: ideally need to determine if this &lt;iframe&gt; is inside position:fixed.
2833                 } else
2834                     parentLayer = nullptr;
2835             }
2836         } else {
2837             if (options.revealMode == SelectionRevealMode::RevealUpToMainFrame &amp;&amp; frameView.frame().isMainFrame())
2838                 return;
2839 
2840             auto minScrollPosition = frameView.minimumScrollPosition();
2841             auto maxScrollPosition = frameView.maximumScrollPosition();
2842 
2843 #if !PLATFORM(IOS_FAMILY)
2844             LayoutRect viewRect = frameView.visibleContentRect();
2845 #else
2846             // FIXME: ContentInsets should be taken care of in UI process side. webkit.org/b/199682
2847             // To do that, getRectToExpose needs to return the additional scrolling to do beyond content rect.
2848             LayoutRect viewRect = frameView.viewRectExpandedByContentInsets();
2849 
2850             // FIXME: webkit.org/b/199683 FrameView::visibleContentRect is wrong when content insets are present
2851             maxScrollPosition = frameView.scrollPositionFromOffset(ScrollPosition(frameView.totalContentsSize() - flooredIntSize(viewRect.size())));
2852 
2853             auto contentInsets = page().contentInsets();
2854             minScrollPosition.move(-contentInsets.left(), -contentInsets.top());
2855             maxScrollPosition.move(contentInsets.right(), contentInsets.bottom());
2856 #endif
2857             // Move the target rect into &quot;scrollView contents&quot; coordinates.
2858             LayoutRect targetRect = absoluteRect;
2859             targetRect.move(0, frameView.headerHeight());
2860 
2861             LayoutRect revealRect = getRectToExpose(viewRect, targetRect, insideFixed, options.alignX, options.alignY);
2862             // Avoid scrolling to the rounded value of revealRect.location() if we don&#39;t actually need to scroll
2863             if (revealRect != viewRect) {
2864                 ScrollOffset clampedScrollPosition = roundedIntPoint(revealRect.location()).constrainedBetween(minScrollPosition, maxScrollPosition);
2865                 frameView.setScrollPosition(clampedScrollPosition);
2866             }
2867 
2868             // This is the outermost view of a web page, so after scrolling this view we
2869             // scroll its container by calling Page::scrollRectIntoView.
2870             // This only has an effect on the Mac platform in applications
2871             // that put web views into scrolling containers, such as Mac OS X Mail.
2872             // The canAutoscroll function in EventHandler also knows about this.
2873             page().chrome().scrollRectIntoView(snappedIntRect(absoluteRect));
2874         }
2875     }
2876 
2877     if (parentLayer)
2878         parentLayer-&gt;scrollRectToVisible(newRect, insideFixed, options);
2879 }
2880 
2881 void RenderLayer::updateCompositingLayersAfterScroll()
2882 {
2883     if (compositor().hasContentCompositingLayers()) {
2884         // Our stacking container is guaranteed to contain all of our descendants that may need
2885         // repositioning, so update compositing layers from there.
2886         if (RenderLayer* compositingAncestor = stackingContext()-&gt;enclosingCompositingLayer()) {
2887             if (usesCompositedScrolling())
2888                 compositor().updateCompositingLayers(CompositingUpdateType::OnCompositedScroll, compositingAncestor);
2889             else {
2890                 // FIXME: would be nice to only dirty layers whose positions were affected by scrolling.
2891                 compositingAncestor-&gt;setDescendantsNeedUpdateBackingAndHierarchyTraversal();
2892                 compositor().updateCompositingLayers(CompositingUpdateType::OnScroll, compositingAncestor);
2893             }
2894         }
2895     }
2896 }
2897 
2898 LayoutRect RenderLayer::getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const
2899 {
2900     FrameView&amp; frameView = renderer().view().frameView();
2901     if (renderer().isRenderView() &amp;&amp; insideFixed) {
2902         // If the element is inside position:fixed and we&#39;re not scaled, no amount of scrolling is going to move things around.
2903         if (frameView.frameScaleFactor() == 1)
2904             return visibleRect;
2905 
2906         if (renderer().settings().visualViewportEnabled()) {
2907             // exposeRect is in absolute coords, affected by page scale. Unscale it.
2908             LayoutRect unscaledExposeRect = exposeRect;
2909             unscaledExposeRect.scale(1 / frameView.frameScaleFactor());
2910             unscaledExposeRect.move(0, -frameView.headerHeight());
2911 
2912             // These are both in unscaled coordinates.
2913             LayoutRect layoutViewport = frameView.layoutViewportRect();
2914             LayoutRect visualViewport = frameView.visualViewportRect();
2915 
2916             // The rect to expose may be partially offscreen, which we can&#39;t do anything about with position:fixed.
2917             unscaledExposeRect.intersect(layoutViewport);
2918             // Make sure it&#39;s not larger than the visual viewport; if so, we&#39;ll just move to the top left.
2919             unscaledExposeRect.setSize(unscaledExposeRect.size().shrunkTo(visualViewport.size()));
2920 
2921             // Compute how much we have to move the visualViewport to reveal the part of the layoutViewport that contains exposeRect.
2922             LayoutRect requiredVisualViewport = getRectToExpose(visualViewport, unscaledExposeRect, false, alignX, alignY);
2923             // Scale it back up.
2924             requiredVisualViewport.scale(frameView.frameScaleFactor());
2925             requiredVisualViewport.move(0, frameView.headerHeight());
2926             return requiredVisualViewport;
2927         }
2928     }
2929 
2930     // Determine the appropriate X behavior.
2931     ScrollAlignment::Behavior scrollX;
2932     LayoutRect exposeRectX(exposeRect.x(), visibleRect.y(), exposeRect.width(), visibleRect.height());
2933     LayoutUnit intersectWidth = intersection(visibleRect, exposeRectX).width();
2934     if (intersectWidth == exposeRect.width() || intersectWidth &gt;= MIN_INTERSECT_FOR_REVEAL)
2935         // If the rectangle is fully visible, use the specified visible behavior.
2936         // If the rectangle is partially visible, but over a certain threshold,
2937         // then treat it as fully visible to avoid unnecessary horizontal scrolling
2938         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2939     else if (intersectWidth == visibleRect.width()) {
2940         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2941         scrollX = ScrollAlignment::getVisibleBehavior(alignX);
2942         if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2943             scrollX = ScrollAlignment::Behavior::NoScroll;
2944     } else if (intersectWidth &gt; 0)
2945         // If the rectangle is partially visible, but not above the minimum threshold, use the specified partial behavior
2946         scrollX = ScrollAlignment::getPartialBehavior(alignX);
2947     else
2948         scrollX = ScrollAlignment::getHiddenBehavior(alignX);
2949     // If we&#39;re trying to align to the closest edge, and the exposeRect is further right
2950     // than the visibleRect, and not bigger than the visible area, then align with the right.
2951     if (scrollX == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxX() &gt; visibleRect.maxX() &amp;&amp; exposeRect.width() &lt; visibleRect.width())
2952         scrollX = ScrollAlignment::Behavior::AlignRight;
2953 
2954     // Given the X behavior, compute the X coordinate.
2955     LayoutUnit x;
2956     if (scrollX == ScrollAlignment::Behavior::NoScroll)
2957         x = visibleRect.x();
2958     else if (scrollX == ScrollAlignment::Behavior::AlignRight)
2959         x = exposeRect.maxX() - visibleRect.width();
2960     else if (scrollX == ScrollAlignment::Behavior::AlignCenter)
2961         x = exposeRect.x() + (exposeRect.width() - visibleRect.width()) / 2;
2962     else
2963         x = exposeRect.x();
2964 
2965     // Determine the appropriate Y behavior.
2966     ScrollAlignment::Behavior scrollY;
2967     LayoutRect exposeRectY(visibleRect.x(), exposeRect.y(), visibleRect.width(), exposeRect.height());
2968     LayoutUnit intersectHeight = intersection(visibleRect, exposeRectY).height();
2969     if (intersectHeight == exposeRect.height())
2970         // If the rectangle is fully visible, use the specified visible behavior.
2971         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2972     else if (intersectHeight == visibleRect.height()) {
2973         // If the rect is bigger than the visible area, don&#39;t bother trying to center. Other alignments will work.
2974         scrollY = ScrollAlignment::getVisibleBehavior(alignY);
2975         if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2976             scrollY = ScrollAlignment::Behavior::NoScroll;
2977     } else if (intersectHeight &gt; 0)
2978         // If the rectangle is partially visible, use the specified partial behavior
2979         scrollY = ScrollAlignment::getPartialBehavior(alignY);
2980     else
2981         scrollY = ScrollAlignment::getHiddenBehavior(alignY);
2982     // If we&#39;re trying to align to the closest edge, and the exposeRect is further down
2983     // than the visibleRect, and not bigger than the visible area, then align with the bottom.
2984     if (scrollY == ScrollAlignment::Behavior::AlignToClosestEdge &amp;&amp; exposeRect.maxY() &gt; visibleRect.maxY() &amp;&amp; exposeRect.height() &lt; visibleRect.height())
2985         scrollY = ScrollAlignment::Behavior::AlignBottom;
2986 
2987     // Given the Y behavior, compute the Y coordinate.
2988     LayoutUnit y;
2989     if (scrollY == ScrollAlignment::Behavior::NoScroll)
2990         y = visibleRect.y();
2991     else if (scrollY == ScrollAlignment::Behavior::AlignBottom)
2992         y = exposeRect.maxY() - visibleRect.height();
2993     else if (scrollY == ScrollAlignment::Behavior::AlignCenter)
2994         y = exposeRect.y() + (exposeRect.height() - visibleRect.height()) / 2;
2995     else
2996         y = exposeRect.y();
2997 
2998     return LayoutRect(LayoutPoint(x, y), visibleRect.size());
2999 }
3000 
3001 void RenderLayer::autoscroll(const IntPoint&amp; positionInWindow)
3002 {
3003     IntPoint currentDocumentPosition = renderer().view().frameView().windowToContents(positionInWindow);
3004     scrollRectToVisible(LayoutRect(currentDocumentPosition, LayoutSize(1, 1)), false, { SelectionRevealMode::Reveal, ScrollAlignment::alignToEdgeIfNeeded, ScrollAlignment::alignToEdgeIfNeeded, ShouldAllowCrossOriginScrolling::Yes });
3005 }
3006 
3007 bool RenderLayer::canResize() const
3008 {
3009     // We need a special case for &lt;iframe&gt; because they never have
3010     // hasOverflowClip(). However, they do &quot;implicitly&quot; clip their contents, so
3011     // we want to allow resizing them also.
3012     return (renderer().hasOverflowClip() || renderer().isRenderIFrame()) &amp;&amp; renderer().style().resize() != Resize::None;
3013 }
3014 
3015 void RenderLayer::resize(const PlatformMouseEvent&amp; evt, const LayoutSize&amp; oldOffset)
3016 {
3017     // FIXME: This should be possible on generated content but is not right now.
3018     if (!inResizeMode() || !canResize() || !renderer().element())
3019         return;
3020 
3021     // FIXME: The only case where renderer-&gt;element()-&gt;renderer() != renderer is with continuations. Do they matter here?
3022     // If they do it would still be better to deal with them explicitly.
3023     Element* element = renderer().element();
3024     auto* renderer = downcast&lt;RenderBox&gt;(element-&gt;renderer());
3025 
3026     Document&amp; document = element-&gt;document();
3027     if (!document.frame()-&gt;eventHandler().mousePressed())
3028         return;
3029 
3030     float zoomFactor = renderer-&gt;style().effectiveZoom();
3031 
3032     LayoutSize newOffset = offsetFromResizeCorner(document.view()-&gt;windowToContents(evt.position()));
3033     newOffset.setWidth(newOffset.width() / zoomFactor);
3034     newOffset.setHeight(newOffset.height() / zoomFactor);
3035 
3036     LayoutSize currentSize = LayoutSize(renderer-&gt;width() / zoomFactor, renderer-&gt;height() / zoomFactor);
3037     LayoutSize minimumSize = element-&gt;minimumSizeForResizing().shrunkTo(currentSize);
3038     element-&gt;setMinimumSizeForResizing(minimumSize);
3039 
3040     LayoutSize adjustedOldOffset = LayoutSize(oldOffset.width() / zoomFactor, oldOffset.height() / zoomFactor);
3041     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
3042         newOffset.setWidth(-newOffset.width());
3043         adjustedOldOffset.setWidth(-adjustedOldOffset.width());
3044     }
3045 
3046     LayoutSize difference = (currentSize + newOffset - adjustedOldOffset).expandedTo(minimumSize) - currentSize;
3047 
3048     StyledElement* styledElement = downcast&lt;StyledElement&gt;(element);
3049     bool isBoxSizingBorder = renderer-&gt;style().boxSizing() == BoxSizing::BorderBox;
3050 
3051     Resize resize = renderer-&gt;style().resize();
3052     if (resize != Resize::Vertical &amp;&amp; difference.width()) {
3053         if (is&lt;HTMLFormControlElement&gt;(*element)) {
3054             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
3055             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginLeft, renderer-&gt;marginLeft() / zoomFactor, CSSUnitType::CSS_PX);
3056             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginRight, renderer-&gt;marginRight() / zoomFactor, CSSUnitType::CSS_PX);
3057         }
3058         LayoutUnit baseWidth = renderer-&gt;width() - (isBoxSizingBorder ? 0_lu : renderer-&gt;horizontalBorderAndPaddingExtent());
3059         baseWidth = baseWidth / zoomFactor;
3060         styledElement-&gt;setInlineStyleProperty(CSSPropertyWidth, roundToInt(baseWidth + difference.width()), CSSUnitType::CSS_PX);
3061     }
3062 
3063     if (resize != Resize::Horizontal &amp;&amp; difference.height()) {
3064         if (is&lt;HTMLFormControlElement&gt;(*element)) {
3065             // Make implicit margins from the theme explicit (see &lt;http://bugs.webkit.org/show_bug.cgi?id=9547&gt;).
3066             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginTop, renderer-&gt;marginTop() / zoomFactor, CSSUnitType::CSS_PX);
3067             styledElement-&gt;setInlineStyleProperty(CSSPropertyMarginBottom, renderer-&gt;marginBottom() / zoomFactor, CSSUnitType::CSS_PX);
3068         }
3069         LayoutUnit baseHeight = renderer-&gt;height() - (isBoxSizingBorder ? 0_lu : renderer-&gt;verticalBorderAndPaddingExtent());
3070         baseHeight = baseHeight / zoomFactor;
3071         styledElement-&gt;setInlineStyleProperty(CSSPropertyHeight, roundToInt(baseHeight + difference.height()), CSSUnitType::CSS_PX);
3072     }
3073 
3074     document.updateLayout();
3075 
3076     // FIXME (Radar 4118564): We should also autoscroll the window as necessary to keep the point under the cursor in view.
3077 }
3078 
3079 void RenderLayer::setScrollOffset(const ScrollOffset&amp; offset)
3080 {
3081     scrollTo(scrollPositionFromOffset(offset));
3082 }
3083 
3084 ScrollingNodeID RenderLayer::scrollingNodeID() const
3085 {
3086     if (!isComposited())
3087         return 0;
3088 
3089     return backing()-&gt;scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling);
3090 }
3091 
3092 IntRect RenderLayer::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior) const
3093 {
3094     IntSize scrollbarSpace;
3095     if (showsOverflowControls() &amp;&amp; scrollbarInclusion == IncludeScrollbars)
3096         scrollbarSpace = scrollbarIntrusion();
3097 
3098     auto visibleSize = this-&gt;visibleSize();
3099     return { scrollPosition(), { std::max(0, visibleSize.width() - scrollbarSpace.width()), std::max(0, visibleSize.height() - scrollbarSpace.height()) } };
3100 }
3101 
3102 IntSize RenderLayer::overhangAmount() const
3103 {
3104 #if ENABLE(RUBBER_BANDING)
3105     if (!renderer().settings().rubberBandingForSubScrollableRegionsEnabled())
3106         return IntSize();
3107 
3108     IntSize stretch;
3109 
3110     // FIXME: use maximumScrollOffset(), or just move this to ScrollableArea.
3111     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
3112     auto reachableSize = reachableTotalContentsSize();
3113     if (scrollOffset.y() &lt; 0)
3114         stretch.setHeight(scrollOffset.y());
3115     else if (reachableSize.height() &amp;&amp; scrollOffset.y() &gt; reachableSize.height() - visibleHeight())
3116         stretch.setHeight(scrollOffset.y() - (reachableSize.height() - visibleHeight()));
3117 
3118     if (scrollOffset.x() &lt; 0)
3119         stretch.setWidth(scrollOffset.x());
3120     else if (reachableSize.width() &amp;&amp; scrollOffset.x() &gt; reachableSize.width() - visibleWidth())
3121         stretch.setWidth(scrollOffset.x() - (reachableSize.width() - visibleWidth()));
3122 
3123     return stretch;
3124 #else
3125     return IntSize();
3126 #endif
3127 }
3128 
3129 bool RenderLayer::isActive() const
3130 {
3131     return page().focusController().isActive();
3132 }
3133 
3134 static int cornerStart(const RenderLayer&amp; layer, int minX, int maxX, int thickness)
3135 {
3136     if (layer.shouldPlaceBlockDirectionScrollbarOnLeft())
3137         return minX + layer.renderer().style().borderLeftWidth();
3138     return maxX - thickness - layer.renderer().style().borderRightWidth();
3139 }
3140 
3141 static LayoutRect cornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
3142 {
3143     int horizontalThickness;
3144     int verticalThickness;
3145     if (!layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
3146         // FIXME: This isn&#39;t right.  We need to know the thickness of custom scrollbars
3147         // even when they don&#39;t exist in order to set the resizer square size properly.
3148         horizontalThickness = ScrollbarTheme::theme().scrollbarThickness();
3149         verticalThickness = horizontalThickness;
3150     } else if (layer.verticalScrollbar() &amp;&amp; !layer.horizontalScrollbar()) {
3151         horizontalThickness = layer.verticalScrollbar()-&gt;width();
3152         verticalThickness = horizontalThickness;
3153     } else if (layer.horizontalScrollbar() &amp;&amp; !layer.verticalScrollbar()) {
3154         verticalThickness = layer.horizontalScrollbar()-&gt;height();
3155         horizontalThickness = verticalThickness;
3156     } else {
3157         horizontalThickness = layer.verticalScrollbar()-&gt;width();
3158         verticalThickness = layer.horizontalScrollbar()-&gt;height();
3159     }
3160     return LayoutRect(cornerStart(layer, bounds.x(), bounds.maxX(), horizontalThickness),
3161         bounds.maxY() - verticalThickness - layer.renderer().style().borderBottomWidth(),
3162         horizontalThickness, verticalThickness);
3163 }
3164 
3165 IntRect RenderLayer::scrollCornerRect() const
3166 {
3167     // We have a scrollbar corner when a non overlay scrollbar is visible and not filling the entire length of the box.
3168     // This happens when:
3169     // (a) A resizer is present and at least one non overlay scrollbar is present
3170     // (b) Both non overlay scrollbars are present.
3171     // Overlay scrollbars always fill the entire length of the box so we never have scroll corner in that case.
3172     bool hasHorizontalBar = m_hBar &amp;&amp; !m_hBar-&gt;isOverlayScrollbar();
3173     bool hasVerticalBar = m_vBar &amp;&amp; !m_vBar-&gt;isOverlayScrollbar();
3174     bool hasResizer = renderer().style().resize() != Resize::None;
3175     if ((hasHorizontalBar &amp;&amp; hasVerticalBar) || (hasResizer &amp;&amp; (hasHorizontalBar || hasVerticalBar)))
3176         return snappedIntRect(cornerRect(*this, renderBox()-&gt;borderBoxRect()));
3177     return IntRect();
3178 }
3179 
3180 static LayoutRect resizerCornerRect(const RenderLayer&amp; layer, const LayoutRect&amp; bounds)
3181 {
3182     ASSERT(layer.renderer().isBox());
3183     if (layer.renderer().style().resize() == Resize::None)
3184         return LayoutRect();
3185     return cornerRect(layer, bounds);
3186 }
3187 
3188 LayoutRect RenderLayer::scrollCornerAndResizerRect() const
3189 {
3190     RenderBox* box = renderBox();
3191     if (!box)
3192         return LayoutRect();
3193     LayoutRect scrollCornerAndResizer = scrollCornerRect();
3194     if (scrollCornerAndResizer.isEmpty())
3195         scrollCornerAndResizer = resizerCornerRect(*this, box-&gt;borderBoxRect());
3196     return scrollCornerAndResizer;
3197 }
3198 
3199 bool RenderLayer::isScrollCornerVisible() const
3200 {
3201     ASSERT(renderer().isBox());
3202     return !scrollCornerRect().isEmpty();
3203 }
3204 
3205 IntRect RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
3206 {
3207     IntRect rect = scrollbarRect;
3208     rect.move(scrollbarOffset(scrollbar));
3209 
3210     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), rect);
3211 }
3212 
3213 IntRect RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
3214 {
3215     IntRect rect = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentRect);
3216     rect.move(-scrollbarOffset(scrollbar));
3217     return rect;
3218 }
3219 
3220 IntPoint RenderLayer::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
3221 {
3222     IntPoint point = scrollbarPoint;
3223     point.move(scrollbarOffset(scrollbar));
3224     return renderer().view().frameView().convertFromRendererToContainingView(&amp;renderer(), point);
3225 }
3226 
3227 IntPoint RenderLayer::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
3228 {
3229     IntPoint point = renderer().view().frameView().convertFromContainingViewToRenderer(&amp;renderer(), parentPoint);
3230     point.move(-scrollbarOffset(scrollbar));
3231     return point;
3232 }
3233 
3234 IntSize RenderLayer::visibleSize() const
3235 {
3236     RenderBox* box = renderBox();
3237     if (!box)
3238         return IntSize();
3239 
3240     return IntSize(roundToInt(box-&gt;clientWidth()), roundToInt(box-&gt;clientHeight()));
3241 }
3242 
3243 IntSize RenderLayer::contentsSize() const
3244 {
3245     return IntSize(scrollWidth(), scrollHeight());
3246 }
3247 
3248 IntSize RenderLayer::reachableTotalContentsSize() const
3249 {
3250     IntSize contentsSize = this-&gt;contentsSize();
3251 
3252     if (!hasScrollableHorizontalOverflow())
3253         contentsSize.setWidth(std::min(contentsSize.width(), visibleSize().width()));
3254 
3255     if (!hasScrollableVerticalOverflow())
3256         contentsSize.setHeight(std::min(contentsSize.height(), visibleSize().height()));
3257 
3258     return contentsSize;
3259 }
3260 
3261 void RenderLayer::availableContentSizeChanged(AvailableSizeChangeReason reason)
3262 {
3263     ScrollableArea::availableContentSizeChanged(reason);
3264 
3265     if (reason == AvailableSizeChangeReason::ScrollbarsChanged) {
3266         if (is&lt;RenderBlock&gt;(renderer()))
3267             downcast&lt;RenderBlock&gt;(renderer()).setShouldForceRelayoutChildren(true);
3268         renderer().setNeedsLayout();
3269     }
3270 }
3271 
3272 bool RenderLayer::shouldSuspendScrollAnimations() const
3273 {
3274     return renderer().view().frameView().shouldSuspendScrollAnimations();
3275 }
3276 
3277 #if PLATFORM(IOS_FAMILY)
3278 void RenderLayer::didStartScroll()
3279 {
3280     page().chrome().client().didStartOverflowScroll();
3281 }
3282 
3283 void RenderLayer::didEndScroll()
3284 {
3285     page().chrome().client().didEndOverflowScroll();
3286 }
3287 
3288 void RenderLayer::didUpdateScroll()
3289 {
3290     // Send this notification when we scroll, since this is how we keep selection updated.
3291     page().chrome().client().didLayout(ChromeClient::Scroll);
3292 }
3293 #endif
3294 
3295 IntPoint RenderLayer::lastKnownMousePosition() const
3296 {
3297     return renderer().frame().eventHandler().lastKnownMousePosition();
3298 }
3299 
3300 bool RenderLayer::isHandlingWheelEvent() const
3301 {
3302     return renderer().frame().eventHandler().isHandlingWheelEvent();
3303 }
3304 
3305 IntRect RenderLayer::rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const
3306 {
3307     if (!m_hBar)
3308         return IntRect();
3309 
3310     const RenderBox* box = renderBox();
3311     const IntRect&amp; scrollCorner = scrollCornerRect();
3312 
3313     return IntRect(horizontalScrollbarStart(borderBoxRect.x()),
3314         borderBoxRect.maxY() - box-&gt;borderBottom() - m_hBar-&gt;height(),
3315         borderBoxRect.width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - scrollCorner.width(),
3316         m_hBar-&gt;height());
3317 }
3318 
3319 IntRect RenderLayer::rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const
3320 {
3321     if (!m_vBar)
3322         return IntRect();
3323 
3324     const RenderBox* box = renderBox();
3325     const IntRect&amp; scrollCorner = scrollCornerRect();
3326 
3327     return IntRect(verticalScrollbarStart(borderBoxRect.x(), borderBoxRect.maxX()),
3328         borderBoxRect.y() + box-&gt;borderTop(),
3329         m_vBar-&gt;width(),
3330         borderBoxRect.height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - scrollCorner.height());
3331 }
3332 
3333 LayoutUnit RenderLayer::verticalScrollbarStart(int minX, int maxX) const
3334 {
3335     const RenderBox* box = renderBox();
3336     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3337         return minX + box-&gt;borderLeft();
3338     return maxX - box-&gt;borderRight() - m_vBar-&gt;width();
3339 }
3340 
3341 LayoutUnit RenderLayer::horizontalScrollbarStart(int minX) const
3342 {
3343     const RenderBox* box = renderBox();
3344     int x = minX + box-&gt;borderLeft();
3345     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3346         x += m_vBar ? m_vBar-&gt;width() : roundToInt(resizerCornerRect(*this, box-&gt;borderBoxRect()).width());
3347     return x;
3348 }
3349 
3350 IntSize RenderLayer::scrollbarOffset(const Scrollbar&amp; scrollbar) const
3351 {
3352     RenderBox* box = renderBox();
3353 
3354     if (&amp;scrollbar == m_vBar.get())
3355         return IntSize(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3356 
3357     if (&amp;scrollbar == m_hBar.get())
3358         return IntSize(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3359 
3360     ASSERT_NOT_REACHED();
3361     return IntSize();
3362 }
3363 
3364 void RenderLayer::invalidateScrollbarRect(Scrollbar&amp; scrollbar, const IntRect&amp; rect)
3365 {
3366     if (!showsOverflowControls())
3367         return;
3368 
3369     if (&amp;scrollbar == m_vBar.get()) {
3370         if (GraphicsLayer* layer = layerForVerticalScrollbar()) {
3371             layer-&gt;setNeedsDisplayInRect(rect);
3372             return;
3373         }
3374     } else {
3375         if (GraphicsLayer* layer = layerForHorizontalScrollbar()) {
3376             layer-&gt;setNeedsDisplayInRect(rect);
3377             return;
3378         }
3379     }
3380 
3381     IntRect scrollRect = rect;
3382     RenderBox* box = renderBox();
3383     ASSERT(box);
3384     // If we are not yet inserted into the tree, there is no need to repaint.
3385     if (!box-&gt;parent())
3386         return;
3387 
3388     if (&amp;scrollbar == m_vBar.get())
3389         scrollRect.move(verticalScrollbarStart(0, box-&gt;width()), box-&gt;borderTop());
3390     else
3391         scrollRect.move(horizontalScrollbarStart(0), box-&gt;height() - box-&gt;borderBottom() - scrollbar.height());
3392     LayoutRect repaintRect = scrollRect;
3393     renderBox()-&gt;flipForWritingMode(repaintRect);
3394     renderer().repaintRectangle(repaintRect);
3395 }
3396 
3397 void RenderLayer::invalidateScrollCornerRect(const IntRect&amp; rect)
3398 {
3399     if (!showsOverflowControls())
3400         return;
3401 
3402     if (GraphicsLayer* layer = layerForScrollCorner()) {
3403         layer-&gt;setNeedsDisplayInRect(rect);
3404         return;
3405     }
3406 
3407     if (m_scrollCorner)
3408         m_scrollCorner-&gt;repaintRectangle(rect);
3409     if (m_resizer)
3410         m_resizer-&gt;repaintRectangle(rect);
3411 }
3412 
3413 static bool scrollbarHiddenByStyle(Scrollbar* scrollbar)
3414 {
3415     return scrollbar &amp;&amp; scrollbar-&gt;isHiddenByStyle();
3416 }
3417 
3418 bool RenderLayer::horizontalScrollbarHiddenByStyle() const
3419 {
3420     return scrollbarHiddenByStyle(horizontalScrollbar());
3421 }
3422 
3423 bool RenderLayer::verticalScrollbarHiddenByStyle() const
3424 {
3425     return scrollbarHiddenByStyle(verticalScrollbar());
3426 }
3427 
3428 static inline RenderElement* rendererForScrollbar(RenderLayerModelObject&amp; renderer)
3429 {
3430     if (Element* element = renderer.element()) {
3431         if (ShadowRoot* shadowRoot = element-&gt;containingShadowRoot()) {
3432             if (shadowRoot-&gt;mode() == ShadowRootMode::UserAgent)
3433                 return shadowRoot-&gt;host()-&gt;renderer();
3434         }
3435     }
3436 
3437     return &amp;renderer;
3438 }
3439 
3440 Ref&lt;Scrollbar&gt; RenderLayer::createScrollbar(ScrollbarOrientation orientation)
3441 {
3442     RefPtr&lt;Scrollbar&gt; widget;
3443     ASSERT(rendererForScrollbar(renderer()));
3444     auto&amp; actualRenderer = *rendererForScrollbar(renderer());
3445     bool hasCustomScrollbarStyle = is&lt;RenderBox&gt;(actualRenderer) &amp;&amp; downcast&lt;RenderBox&gt;(actualRenderer).style().hasPseudoStyle(PseudoId::Scrollbar);
3446     if (hasCustomScrollbarStyle)
3447         widget = RenderScrollbar::createCustomScrollbar(*this, orientation, downcast&lt;RenderBox&gt;(actualRenderer).element());
3448     else {
3449         widget = Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
3450         didAddScrollbar(widget.get(), orientation);
3451         if (page().isMonitoringWheelEvents())
3452             scrollAnimator().setWheelEventTestMonitor(page().wheelEventTestMonitor());
3453     }
3454     renderer().view().frameView().addChild(*widget);
3455     return widget.releaseNonNull();
3456 }
3457 
3458 void RenderLayer::destroyScrollbar(ScrollbarOrientation orientation)
3459 {
3460     RefPtr&lt;Scrollbar&gt;&amp; scrollbar = orientation == HorizontalScrollbar ? m_hBar : m_vBar;
3461     if (!scrollbar)
3462         return;
3463 
3464     if (!scrollbar-&gt;isCustomScrollbar())
3465         willRemoveScrollbar(scrollbar.get(), orientation);
3466 
3467     scrollbar-&gt;removeFromParent();
3468     scrollbar = nullptr;
3469 }
3470 
3471 bool RenderLayer::scrollsOverflow() const
3472 {
3473     if (!is&lt;RenderBox&gt;(renderer()))
3474         return false;
3475 
3476     return downcast&lt;RenderBox&gt;(renderer()).scrollsOverflow();
3477 }
3478 
3479 void RenderLayer::setHasHorizontalScrollbar(bool hasScrollbar)
3480 {
3481     if (hasScrollbar == hasHorizontalScrollbar())
3482         return;
3483 
3484     if (hasScrollbar) {
3485         m_hBar = createScrollbar(HorizontalScrollbar);
3486 #if ENABLE(RUBBER_BANDING)
3487         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3488         ScrollableArea::setHorizontalScrollElasticity(elasticity);
3489 #endif
3490     } else {
3491         destroyScrollbar(HorizontalScrollbar);
3492 #if ENABLE(RUBBER_BANDING)
3493         ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityNone);
3494 #endif
3495     }
3496 
3497     // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3498     if (m_hBar)
3499         m_hBar-&gt;styleChanged();
3500     if (m_vBar)
3501         m_vBar-&gt;styleChanged();
3502 }
3503 
3504 void RenderLayer::setHasVerticalScrollbar(bool hasScrollbar)
3505 {
3506     if (hasScrollbar == hasVerticalScrollbar())
3507         return;
3508 
3509     if (hasScrollbar) {
3510         m_vBar = createScrollbar(VerticalScrollbar);
3511 #if ENABLE(RUBBER_BANDING)
3512         ScrollElasticity elasticity = scrollsOverflow() &amp;&amp; renderer().settings().rubberBandingForSubScrollableRegionsEnabled() ? ScrollElasticityAutomatic : ScrollElasticityNone;
3513         ScrollableArea::setVerticalScrollElasticity(elasticity);
3514 #endif
3515     } else {
3516         destroyScrollbar(VerticalScrollbar);
3517 #if ENABLE(RUBBER_BANDING)
3518         ScrollableArea::setVerticalScrollElasticity(ScrollElasticityNone);
3519 #endif
3520     }
3521 
3522      // Destroying or creating one bar can cause our scrollbar corner to come and go.  We need to update the opposite scrollbar&#39;s style.
3523     if (m_hBar)
3524         m_hBar-&gt;styleChanged();
3525     if (m_vBar)
3526         m_vBar-&gt;styleChanged();
3527 }
3528 
3529 ScrollableArea* RenderLayer::enclosingScrollableArea() const
3530 {
3531     if (RenderLayer* scrollableLayer = enclosingScrollableLayer())
3532         return scrollableLayer;
3533 
3534     // FIXME: We should return the frame view here (or possibly an ancestor frame view,
3535     // if the frame view isn&#39;t scrollable.
3536     return nullptr;
3537 }
3538 
3539 bool RenderLayer::isScrollableOrRubberbandable()
3540 {
3541     return renderer().isScrollableOrRubberbandableBox();
3542 }
3543 
3544 bool RenderLayer::hasScrollableOrRubberbandableAncestor()
3545 {
3546     for (RenderLayer* nextLayer = parentLayerCrossFrame(*this); nextLayer; nextLayer = parentLayerCrossFrame(*nextLayer)) {
3547         if (nextLayer-&gt;isScrollableOrRubberbandable())
3548             return true;
3549     }
3550 
3551     return false;
3552 }
3553 
3554 bool RenderLayer::useDarkAppearance() const
3555 {
3556     return renderer().useDarkAppearance();
3557 }
3558 
3559 #if ENABLE(CSS_SCROLL_SNAP)
3560 void RenderLayer::updateSnapOffsets()
3561 {
3562     // FIXME: Extend support beyond HTMLElements.
3563     if (!is&lt;HTMLElement&gt;(enclosingElement()) || !enclosingElement()-&gt;renderBox())
3564         return;
3565 
3566     RenderBox* box = enclosingElement()-&gt;renderBox();
3567     updateSnapOffsetsForScrollableArea(*this, *downcast&lt;HTMLElement&gt;(enclosingElement()), *box, box-&gt;style());
3568 }
3569 
3570 bool RenderLayer::isScrollSnapInProgress() const
3571 {
3572     if (!scrollsOverflow())
3573         return false;
3574 
3575     if (ScrollAnimator* scrollAnimator = existingScrollAnimator())
3576         return scrollAnimator-&gt;isScrollSnapInProgress();
3577 
3578     return false;
3579 }
3580 #endif
3581 
3582 bool RenderLayer::usesMockScrollAnimator() const
3583 {
3584     return DeprecatedGlobalSettings::usesMockScrollAnimator();
3585 }
3586 
3587 void RenderLayer::logMockScrollAnimatorMessage(const String&amp; message) const
3588 {
3589     renderer().document().addConsoleMessage(MessageSource::Other, MessageLevel::Debug, &quot;RenderLayer: &quot; + message);
3590 }
3591 
3592 int RenderLayer::verticalScrollbarWidth(OverlayScrollbarSizeRelevancy relevancy) const
3593 {
3594     if (!m_vBar
3595         || !showsOverflowControls()
3596         || (m_vBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_vBar-&gt;shouldParticipateInHitTesting())))
3597         return 0;
3598 
3599     return m_vBar-&gt;width();
3600 }
3601 
3602 int RenderLayer::horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy relevancy) const
3603 {
3604     if (!m_hBar
3605         || !showsOverflowControls()
3606         || (m_hBar-&gt;isOverlayScrollbar() &amp;&amp; (relevancy == IgnoreOverlayScrollbarSize || !m_hBar-&gt;shouldParticipateInHitTesting())))
3607         return 0;
3608 
3609     return m_hBar-&gt;height();
3610 }
3611 
3612 IntSize RenderLayer::offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const
3613 {
3614     // Currently the resize corner is either the bottom right corner or the bottom left corner.
3615     // FIXME: This assumes the location is 0, 0. Is this guaranteed to always be the case?
3616     IntSize elementSize = size();
3617     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3618         elementSize.setWidth(0);
3619     IntPoint resizerPoint = IntPoint(elementSize);
3620     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
3621     return localPoint - resizerPoint;
3622 }
3623 
3624 bool RenderLayer::hasOverflowControls() const
3625 {
3626     return m_hBar || m_vBar || m_scrollCorner || renderer().style().resize() != Resize::None;
3627 }
3628 
3629 void RenderLayer::positionOverflowControls(const IntSize&amp; offsetFromRoot)
3630 {
3631     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
3632         return;
3633 
3634     RenderBox* box = renderBox();
3635     if (!box)
3636         return;
3637 
3638     const IntRect borderBox = snappedIntRect(box-&gt;borderBoxRect());
3639     const IntRect&amp; scrollCorner = scrollCornerRect();
3640     IntRect absBounds(borderBox.location() + offsetFromRoot, borderBox.size());
3641     if (m_vBar) {
3642         IntRect vBarRect = rectForVerticalScrollbar(borderBox);
3643         vBarRect.move(offsetFromRoot);
3644         m_vBar-&gt;setFrameRect(vBarRect);
3645     }
3646 
3647     if (m_hBar) {
3648         IntRect hBarRect = rectForHorizontalScrollbar(borderBox);
3649         hBarRect.move(offsetFromRoot);
3650         m_hBar-&gt;setFrameRect(hBarRect);
3651     }
3652 
3653     if (m_scrollCorner)
3654         m_scrollCorner-&gt;setFrameRect(scrollCorner);
3655     if (m_resizer)
3656         m_resizer-&gt;setFrameRect(resizerCornerRect(*this, borderBox));
3657 
3658     if (isComposited())
3659         backing()-&gt;positionOverflowControlsLayers();
3660 }
3661 
3662 int RenderLayer::scrollWidth() const
3663 {
3664     ASSERT(renderBox());
3665     if (m_scrollDimensionsDirty)
3666         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3667     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3668     return m_scrollSize.width();
3669 }
3670 
3671 int RenderLayer::scrollHeight() const
3672 {
3673     ASSERT(renderBox());
3674     if (m_scrollDimensionsDirty)
3675         const_cast&lt;RenderLayer*&gt;(this)-&gt;computeScrollDimensions();
3676     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
3677     return m_scrollSize.height();
3678 }
3679 
3680 LayoutUnit RenderLayer::overflowTop() const
3681 {
3682     RenderBox* box = renderBox();
3683     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3684     box-&gt;flipForWritingMode(overflowRect);
3685     return overflowRect.y();
3686 }
3687 
3688 LayoutUnit RenderLayer::overflowBottom() const
3689 {
3690     RenderBox* box = renderBox();
3691     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3692     box-&gt;flipForWritingMode(overflowRect);
3693     return overflowRect.maxY();
3694 }
3695 
3696 LayoutUnit RenderLayer::overflowLeft() const
3697 {
3698     RenderBox* box = renderBox();
3699     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3700     box-&gt;flipForWritingMode(overflowRect);
3701     return overflowRect.x();
3702 }
3703 
3704 LayoutUnit RenderLayer::overflowRight() const
3705 {
3706     RenderBox* box = renderBox();
3707     LayoutRect overflowRect(box-&gt;layoutOverflowRect());
3708     box-&gt;flipForWritingMode(overflowRect);
3709     return overflowRect.maxX();
3710 }
3711 
3712 void RenderLayer::computeScrollDimensions()
3713 {
3714     RenderBox* box = renderBox();
3715     ASSERT(box);
3716 
3717     m_scrollDimensionsDirty = false;
3718 
3719     m_scrollSize.setWidth(roundToInt(overflowRight() - overflowLeft()));
3720     m_scrollSize.setHeight(roundToInt(overflowBottom() - overflowTop()));
3721 
3722     int scrollableLeftOverflow = roundToInt(overflowLeft() - box-&gt;borderLeft());
3723     if (shouldPlaceBlockDirectionScrollbarOnLeft())
3724         scrollableLeftOverflow -= verticalScrollbarWidth();
3725     int scrollableTopOverflow = roundToInt(overflowTop() - box-&gt;borderTop());
3726     setScrollOrigin(IntPoint(-scrollableLeftOverflow, -scrollableTopOverflow));
3727 
3728     m_hasCompositedScrollableOverflow = canUseCompositedScrolling() &amp;&amp; (hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
3729 }
3730 
3731 bool RenderLayer::hasScrollableHorizontalOverflow() const
3732 {
3733     return hasHorizontalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowX();
3734 }
3735 
3736 bool RenderLayer::hasScrollableVerticalOverflow() const
3737 {
3738     return hasVerticalOverflow() &amp;&amp; renderBox()-&gt;scrollsOverflowY();
3739 }
3740 
3741 bool RenderLayer::hasHorizontalOverflow() const
3742 {
3743     ASSERT(!m_scrollDimensionsDirty);
3744 
3745     return scrollWidth() &gt; roundToInt(renderBox()-&gt;clientWidth());
3746 }
3747 
3748 bool RenderLayer::hasVerticalOverflow() const
3749 {
3750     ASSERT(!m_scrollDimensionsDirty);
3751 
3752     return scrollHeight() &gt; roundToInt(renderBox()-&gt;clientHeight());
3753 }
3754 
3755 static bool styleRequiresScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3756 {
3757     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3758     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3759     return overflow == Overflow::Scroll &amp;&amp; !overflowScrollActsLikeAuto;
3760 }
3761 
3762 static bool styleDefinesAutomaticScrollbar(const RenderStyle&amp; style, ScrollbarOrientation axis)
3763 {
3764     Overflow overflow = axis == ScrollbarOrientation::HorizontalScrollbar ? style.overflowX() : style.overflowY();
3765     bool overflowScrollActsLikeAuto = overflow == Overflow::Scroll &amp;&amp; !style.hasPseudoStyle(PseudoId::Scrollbar) &amp;&amp; ScrollbarTheme::theme().usesOverlayScrollbars();
3766     return overflow == Overflow::Auto || overflowScrollActsLikeAuto;
3767 }
3768 
3769 void RenderLayer::updateScrollbarsAfterLayout()
3770 {
3771     RenderBox* box = renderBox();
3772     ASSERT(box);
3773 
3774     // List box parts handle the scrollbars by themselves so we have nothing to do.
3775     if (box-&gt;style().appearance() == ListboxPart)
3776         return;
3777 
3778     bool hasHorizontalOverflow = this-&gt;hasHorizontalOverflow();
3779     bool hasVerticalOverflow = this-&gt;hasVerticalOverflow();
3780 
3781     // If overflow requires a scrollbar, then we just need to enable or disable.
3782     if (m_hBar &amp;&amp; styleRequiresScrollbar(renderer().style(), HorizontalScrollbar))
3783         m_hBar-&gt;setEnabled(hasHorizontalOverflow);
3784     if (m_vBar &amp;&amp; styleRequiresScrollbar(renderer().style(), VerticalScrollbar))
3785         m_vBar-&gt;setEnabled(hasVerticalOverflow);
3786 
3787     // Scrollbars with auto behavior may need to lay out again if scrollbars got added or removed.
3788     bool autoHorizontalScrollBarChanged = box-&gt;hasHorizontalScrollbarWithAutoBehavior() &amp;&amp; (hasHorizontalScrollbar() != hasHorizontalOverflow);
3789     bool autoVerticalScrollBarChanged = box-&gt;hasVerticalScrollbarWithAutoBehavior() &amp;&amp; (hasVerticalScrollbar() != hasVerticalOverflow);
3790 
3791     if (autoHorizontalScrollBarChanged || autoVerticalScrollBarChanged) {
3792         if (box-&gt;hasHorizontalScrollbarWithAutoBehavior())
3793             setHasHorizontalScrollbar(hasHorizontalOverflow);
3794         if (box-&gt;hasVerticalScrollbarWithAutoBehavior())
3795             setHasVerticalScrollbar(hasVerticalOverflow);
3796 
3797         updateSelfPaintingLayer();
3798 
3799         renderer().repaint();
3800 
3801         if (renderer().style().overflowX() == Overflow::Auto || renderer().style().overflowY() == Overflow::Auto) {
3802             if (!m_inOverflowRelayout) {
3803                 m_inOverflowRelayout = true;
3804                 renderer().setNeedsLayout(MarkOnlyThis);
3805                 if (is&lt;RenderBlock&gt;(renderer())) {
3806                     RenderBlock&amp; block = downcast&lt;RenderBlock&gt;(renderer());
3807                     block.scrollbarsChanged(autoHorizontalScrollBarChanged, autoVerticalScrollBarChanged);
3808                     block.layoutBlock(true);
3809                 } else
3810                     renderer().layout();
3811                 m_inOverflowRelayout = false;
3812             }
3813         }
3814 
3815         RenderObject* parent = renderer().parent();
3816         if (parent &amp;&amp; parent-&gt;isFlexibleBox() &amp;&amp; renderer().isBox())
3817             downcast&lt;RenderFlexibleBox&gt;(parent)-&gt;clearCachedMainSizeForChild(*renderBox());
3818     }
3819 
3820     // Set up the range (and page step/line step).
3821     if (m_hBar) {
3822         int clientWidth = roundToInt(box-&gt;clientWidth());
3823         int pageStep = Scrollbar::pageStep(clientWidth);
3824         m_hBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3825         m_hBar-&gt;setProportion(clientWidth, m_scrollSize.width());
3826     }
3827     if (m_vBar) {
3828         int clientHeight = roundToInt(box-&gt;clientHeight());
3829         int pageStep = Scrollbar::pageStep(clientHeight);
3830         m_vBar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
3831         m_vBar-&gt;setProportion(clientHeight, m_scrollSize.height());
3832     }
3833 
3834     updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
3835 }
3836 
3837 // This is called from layout code (before updateLayerPositions).
3838 void RenderLayer::updateScrollInfoAfterLayout()
3839 {
3840     RenderBox* box = renderBox();
3841     if (!box)
3842         return;
3843 
3844     m_scrollDimensionsDirty = true;
3845     ScrollOffset originalScrollOffset = scrollOffset();
3846 
3847     computeScrollDimensions();
3848 
3849 #if ENABLE(CSS_SCROLL_SNAP)
3850     // FIXME: Ensure that offsets are also updated in case of programmatic style changes.
3851     // https://bugs.webkit.org/show_bug.cgi?id=135964
3852     updateSnapOffsets();
3853 #endif
3854 
3855     if (!box-&gt;isHTMLMarquee() &amp;&amp; !isRubberBandInProgress()) {
3856         // Layout may cause us to be at an invalid scroll position. In this case we need
3857         // to pull our scroll offsets back to the max (or push them up to the min).
3858         ScrollOffset clampedScrollOffset = clampScrollOffset(scrollOffset());
3859 #if PLATFORM(IOS_FAMILY)
3860         // FIXME: This looks wrong. The caret adjust mode should only be enabled on editing related entry points.
3861         // This code was added to fix an issue where the text insertion point would always be drawn on the right edge
3862         // of a text field whose content overflowed its bounds. See &lt;rdar://problem/15579797&gt; for more details.
3863         setAdjustForIOSCaretWhenScrolling(true);
3864 #endif
3865         if (clampedScrollOffset != scrollOffset())
3866             scrollToOffset(clampedScrollOffset);
3867 
3868 #if PLATFORM(IOS_FAMILY)
3869         setAdjustForIOSCaretWhenScrolling(false);
3870 #endif
3871     }
3872 
3873     updateScrollbarsAfterLayout();
3874 
3875     if (originalScrollOffset != scrollOffset())
3876         scrollToOffsetWithoutAnimation(IntPoint(scrollOffset()));
3877 
3878     if (isComposited()) {
3879         setNeedsCompositingGeometryUpdate();
3880         setNeedsCompositingConfigurationUpdate();
3881     }
3882 
3883     if (canUseCompositedScrolling())
3884         setNeedsPostLayoutCompositingUpdate();
3885 
3886     updateScrollSnapState();
3887 }
3888 
3889 bool RenderLayer::overflowControlsIntersectRect(const IntRect&amp; localRect) const
3890 {
3891     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
3892 
3893     if (rectForHorizontalScrollbar(borderBox).intersects(localRect))
3894         return true;
3895 
3896     if (rectForVerticalScrollbar(borderBox).intersects(localRect))
3897         return true;
3898 
3899     if (scrollCornerRect().intersects(localRect))
3900         return true;
3901 
3902     if (resizerCornerRect(*this, borderBox).intersects(localRect))
3903         return true;
3904 
3905     return false;
3906 }
3907 
3908 bool RenderLayer::showsOverflowControls() const
3909 {
3910 #if PLATFORM(IOS_FAMILY)
3911     // On iOS, the scrollbars are made in the UI process.
3912     return !canUseCompositedScrolling();
3913 #endif
3914 
3915     return true;
3916 }
3917 
3918 void RenderLayer::paintOverflowControls(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect, bool paintingOverlayControls)
3919 {
3920     // Don&#39;t do anything if we have no overflow.
3921     if (!renderer().hasOverflowClip())
3922         return;
3923 
3924     if (!showsOverflowControls())
3925         return;
3926 
3927     // Overlay scrollbars paint in a second pass through the layer tree so that they will paint
3928     // on top of everything else. If this is the normal painting pass, paintingOverlayControls
3929     // will be false, and we should just tell the root layer that there are overlay scrollbars
3930     // that need to be painted. That will cause the second pass through the layer tree to run,
3931     // and we&#39;ll paint the scrollbars then. In the meantime, cache tx and ty so that the
3932     // second pass doesn&#39;t need to re-enter the RenderTree to get it right.
3933     if (hasOverlayScrollbars() &amp;&amp; !paintingOverlayControls) {
3934         m_cachedOverlayScrollbarOffset = paintOffset;
3935 
3936         // It&#39;s not necessary to do the second pass if the scrollbars paint into layers.
3937         if ((m_hBar &amp;&amp; layerForHorizontalScrollbar()) || (m_vBar &amp;&amp; layerForVerticalScrollbar()))
3938             return;
3939         IntRect localDamgeRect = damageRect;
3940         localDamgeRect.moveBy(-paintOffset);
3941         if (!overflowControlsIntersectRect(localDamgeRect))
3942             return;
3943 
3944         RenderLayer* paintingRoot = enclosingCompositingLayer();
3945         if (!paintingRoot)
3946             paintingRoot = renderer().view().layer();
3947 
3948         paintingRoot-&gt;setContainsDirtyOverlayScrollbars(true);
3949         return;
3950     }
3951 
3952     // This check is required to avoid painting custom CSS scrollbars twice.
3953     if (paintingOverlayControls &amp;&amp; !hasOverlayScrollbars())
3954         return;
3955 
3956     IntPoint adjustedPaintOffset = paintOffset;
3957     if (paintingOverlayControls)
3958         adjustedPaintOffset = m_cachedOverlayScrollbarOffset;
3959 
3960     // Move the scrollbar widgets if necessary.  We normally move and resize widgets during layout, but sometimes
3961     // widgets can move without layout occurring (most notably when you scroll a document that
3962     // contains fixed positioned elements).
3963     positionOverflowControls(toIntSize(adjustedPaintOffset));
3964 
3965     // Now that we&#39;re sure the scrollbars are in the right place, paint them.
3966     if (m_hBar &amp;&amp; !layerForHorizontalScrollbar())
3967         m_hBar-&gt;paint(context, damageRect);
3968     if (m_vBar &amp;&amp; !layerForVerticalScrollbar())
3969         m_vBar-&gt;paint(context, damageRect);
3970 
3971     if (layerForScrollCorner())
3972         return;
3973 
3974     // We fill our scroll corner with white if we have a scrollbar that doesn&#39;t run all the way up to the
3975     // edge of the box.
3976     paintScrollCorner(context, adjustedPaintOffset, damageRect);
3977 
3978     // Paint our resizer last, since it sits on top of the scroll corner.
3979     paintResizer(context, adjustedPaintOffset, damageRect);
3980 }
3981 
3982 void RenderLayer::paintScrollCorner(GraphicsContext&amp; context, const IntPoint&amp; paintOffset, const IntRect&amp; damageRect)
3983 {
3984     IntRect absRect = scrollCornerRect();
3985     absRect.moveBy(paintOffset);
3986     if (!absRect.intersects(damageRect))
3987         return;
3988 
3989     if (context.invalidatingControlTints()) {
3990         updateScrollCornerStyle();
3991         return;
3992     }
3993 
3994     if (m_scrollCorner) {
3995         m_scrollCorner-&gt;paintIntoRect(context, paintOffset, absRect);
3996         return;
3997     }
3998 
3999     // We don&#39;t want to paint a corner if we have overlay scrollbars, since we need
4000     // to see what is behind it.
4001     if (!hasOverlayScrollbars())
4002         ScrollbarTheme::theme().paintScrollCorner(context, absRect);
4003 }
4004 
4005 void RenderLayer::drawPlatformResizerImage(GraphicsContext&amp; context, const LayoutRect&amp; resizerCornerRect)
4006 {
4007     RefPtr&lt;Image&gt; resizeCornerImage;
4008     FloatSize cornerResizerSize;
4009     if (renderer().document().deviceScaleFactor() &gt;= 2) {
4010         static NeverDestroyed&lt;Image*&gt; resizeCornerImageHiRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner@2x&quot;).leakRef());
4011         resizeCornerImage = resizeCornerImageHiRes;
4012         cornerResizerSize = resizeCornerImage-&gt;size();
4013         cornerResizerSize.scale(0.5f);
4014     } else {
4015         static NeverDestroyed&lt;Image*&gt; resizeCornerImageLoRes(&amp;Image::loadPlatformResource(&quot;textAreaResizeCorner&quot;).leakRef());
4016         resizeCornerImage = resizeCornerImageLoRes;
4017         cornerResizerSize = resizeCornerImage-&gt;size();
4018     }
4019 
4020     if (shouldPlaceBlockDirectionScrollbarOnLeft()) {
4021         context.save();
4022         context.translate(resizerCornerRect.x() + cornerResizerSize.width(), resizerCornerRect.y() + resizerCornerRect.height() - cornerResizerSize.height());
4023         context.scale(FloatSize(-1.0, 1.0));
4024         if (resizeCornerImage)
4025             context.drawImage(*resizeCornerImage, FloatRect(FloatPoint(), cornerResizerSize));
4026         context.restore();
4027         return;
4028     }
4029 
4030     if (!resizeCornerImage)
4031         return;
4032     FloatRect imageRect = snapRectToDevicePixels(LayoutRect(resizerCornerRect.maxXMaxYCorner() - cornerResizerSize, cornerResizerSize), renderer().document().deviceScaleFactor());
4033     context.drawImage(*resizeCornerImage, imageRect);
4034 }
4035 
4036 void RenderLayer::paintResizer(GraphicsContext&amp; context, const LayoutPoint&amp; paintOffset, const LayoutRect&amp; damageRect)
4037 {
4038     if (renderer().style().resize() == Resize::None)
4039         return;
4040 
4041     RenderBox* box = renderBox();
4042     ASSERT(box);
4043 
4044     LayoutRect absRect = resizerCornerRect(*this, box-&gt;borderBoxRect());
4045     absRect.moveBy(paintOffset);
4046     if (!absRect.intersects(damageRect))
4047         return;
4048 
4049     if (context.invalidatingControlTints()) {
4050         updateResizerStyle();
4051         return;
4052     }
4053 
4054     if (m_resizer) {
4055         m_resizer-&gt;paintIntoRect(context, paintOffset, absRect);
4056         return;
4057     }
4058 
4059     drawPlatformResizerImage(context, absRect);
4060 
4061     // Draw a frame around the resizer (1px grey line) if there are any scrollbars present.
4062     // Clipping will exclude the right and bottom edges of this frame.
4063     if (!hasOverlayScrollbars() &amp;&amp; (m_vBar || m_hBar)) {
4064         GraphicsContextStateSaver stateSaver(context);
4065         context.clip(absRect);
4066         LayoutRect largerCorner = absRect;
4067         largerCorner.setSize(LayoutSize(largerCorner.width() + 1_lu, largerCorner.height() + 1_lu));
4068         context.setStrokeColor(Color(makeRGB(217, 217, 217)));
4069         context.setStrokeThickness(1.0f);
4070         context.setFillColor(Color::transparent);
4071         context.drawRect(snappedIntRect(largerCorner));
4072     }
4073 }
4074 
4075 bool RenderLayer::isPointInResizeControl(const IntPoint&amp; absolutePoint) const
4076 {
4077     if (!canResize())
4078         return false;
4079 
4080     RenderBox* box = renderBox();
4081     ASSERT(box);
4082 
4083     IntPoint localPoint = roundedIntPoint(absoluteToContents(absolutePoint));
4084 
4085     IntRect localBounds(IntPoint(), snappedIntRect(box-&gt;frameRect()).size());
4086     return resizerCornerRect(*this, localBounds).contains(localPoint);
4087 }
4088 
4089 bool RenderLayer::hitTestOverflowControls(HitTestResult&amp; result, const IntPoint&amp; localPoint)
4090 {
4091     if (!m_hBar &amp;&amp; !m_vBar &amp;&amp; !canResize())
4092         return false;
4093 
4094     RenderBox* box = renderBox();
4095     ASSERT(box);
4096 
4097     IntRect resizeControlRect;
4098     if (renderer().style().resize() != Resize::None) {
4099         resizeControlRect = snappedIntRect(resizerCornerRect(*this, box-&gt;borderBoxRect()));
4100         if (resizeControlRect.contains(localPoint))
4101             return true;
4102     }
4103 
4104     int resizeControlSize = std::max(resizeControlRect.height(), 0);
4105 
4106     // FIXME: We should hit test the m_scrollCorner and pass it back through the result.
4107 
4108     if (m_vBar &amp;&amp; m_vBar-&gt;shouldParticipateInHitTesting()) {
4109         LayoutRect vBarRect(verticalScrollbarStart(0, box-&gt;width()),
4110                             box-&gt;borderTop(),
4111                             m_vBar-&gt;width(),
4112                             box-&gt;height() - (box-&gt;borderTop() + box-&gt;borderBottom()) - (m_hBar ? m_hBar-&gt;height() : resizeControlSize));
4113         if (vBarRect.contains(localPoint)) {
4114             result.setScrollbar(m_vBar.get());
4115             return true;
4116         }
4117     }
4118 
4119     resizeControlSize = std::max(resizeControlRect.width(), 0);
4120     if (m_hBar &amp;&amp; m_hBar-&gt;shouldParticipateInHitTesting()) {
4121         LayoutRect hBarRect(horizontalScrollbarStart(0),
4122                             box-&gt;height() - box-&gt;borderBottom() - m_hBar-&gt;height(),
4123                             box-&gt;width() - (box-&gt;borderLeft() + box-&gt;borderRight()) - (m_vBar ? m_vBar-&gt;width() : resizeControlSize),
4124                             m_hBar-&gt;height());
4125         if (hBarRect.contains(localPoint)) {
4126             result.setScrollbar(m_hBar.get());
4127             return true;
4128         }
4129     }
4130 
4131     return false;
4132 }
4133 
4134 bool RenderLayer::scroll(ScrollDirection direction, ScrollGranularity granularity, float multiplier)
4135 {
4136     return ScrollableArea::scroll(direction, granularity, multiplier);
4137 }
4138 
4139 void RenderLayer::paint(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot, OptionSet&lt;PaintLayerFlag&gt; paintFlags, SecurityOriginPaintPolicy paintPolicy)
4140 {
4141     OverlapTestRequestMap overlapTestRequests;
4142 
4143     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, subpixelOffset, subtreePaintRoot, &amp;overlapTestRequests, paintPolicy == SecurityOriginPaintPolicy::AccessibleOriginOnly);
4144     paintLayer(context, paintingInfo, paintFlags);
4145 
4146     for (auto&amp; widget : overlapTestRequests.keys())
4147         widget-&gt;setOverlapTestResult(false);
4148 }
4149 
4150 void RenderLayer::paintOverlayScrollbars(GraphicsContext&amp; context, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRoot)
4151 {
4152     if (!m_containsDirtyOverlayScrollbars)
4153         return;
4154 
4155     LayerPaintingInfo paintingInfo(this, enclosingIntRect(damageRect), paintBehavior, LayoutSize(), subtreePaintRoot);
4156     paintLayer(context, paintingInfo, PaintLayerPaintingOverlayScrollbars);
4157 
4158     m_containsDirtyOverlayScrollbars = false;
4159 }
4160 
4161 void RenderLayer::clipToRect(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect, BorderRadiusClippingRule rule)
4162 {
4163     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4164     bool needsClipping = !clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect;
4165     if (needsClipping || clipRect.affectedByRadius())
4166         context.save();
4167 
4168     if (needsClipping) {
4169         LayoutRect adjustedClipRect = clipRect.rect();
4170         adjustedClipRect.move(paintingInfo.subpixelOffset);
4171         auto snappedClipRect = snapRectToDevicePixels(adjustedClipRect, deviceScaleFactor);
4172         context.clip(snappedClipRect);
4173 
4174         if (paintingInfo.eventRegionContext)
4175             paintingInfo.eventRegionContext-&gt;pushClip(enclosingIntRect(snappedClipRect));
4176     }
4177 
4178     if (clipRect.affectedByRadius()) {
4179         // If the clip rect has been tainted by a border radius, then we have to walk up our layer chain applying the clips from
4180         // any layers with overflow. The condition for being able to apply these clips is that the overflow object be in our
4181         // containing block chain so we check that also.
4182         for (RenderLayer* layer = rule == IncludeSelfForBorderRadius ? this : parent(); layer; layer = layer-&gt;parent()) {
4183             if (layer-&gt;renderer().hasOverflowClip() &amp;&amp; layer-&gt;renderer().style().hasBorderRadius() &amp;&amp; ancestorLayerIsInContainingBlockChain(*layer)) {
4184                 LayoutRect adjustedClipRect = LayoutRect(toLayoutPoint(layer-&gt;offsetFromAncestor(paintingInfo.rootLayer, AdjustForColumns)), layer-&gt;size());
4185                 adjustedClipRect.move(paintingInfo.subpixelOffset);
4186                 FloatRoundedRect roundedRect = layer-&gt;renderer().style().getRoundedInnerBorderFor(adjustedClipRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor);
4187                 if (roundedRect.intersectionIsRectangular(paintingInfo.paintDirtyRect))
4188                     context.clip(snapRectToDevicePixels(intersection(paintingInfo.paintDirtyRect, adjustedClipRect), deviceScaleFactor));
4189                 else
4190                     context.clipRoundedRect(roundedRect);
4191             }
4192 
4193             if (layer == paintingInfo.rootLayer)
4194                 break;
4195         }
4196     }
4197 }
4198 
4199 void RenderLayer::restoreClip(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const ClipRect&amp; clipRect)
4200 {
4201     if ((!clipRect.isInfinite() &amp;&amp; clipRect.rect() != paintingInfo.paintDirtyRect) || clipRect.affectedByRadius()) {
4202         context.restore();
4203 
4204         if (paintingInfo.eventRegionContext)
4205             paintingInfo.eventRegionContext-&gt;popClip();
4206     }
4207 }
4208 
4209 static void performOverlapTests(OverlapTestRequestMap&amp; overlapTestRequests, const RenderLayer* rootLayer, const RenderLayer* layer)
4210 {
4211     if (overlapTestRequests.isEmpty())
4212         return;
4213 
4214     Vector&lt;OverlapTestRequestClient*&gt; overlappedRequestClients;
4215     LayoutRect boundingBox = layer-&gt;boundingBox(rootLayer, layer-&gt;offsetFromAncestor(rootLayer));
4216     for (auto&amp; request : overlapTestRequests) {
4217         if (!boundingBox.intersects(request.value))
4218             continue;
4219 
4220         request.key-&gt;setOverlapTestResult(true);
4221         overlappedRequestClients.append(request.key);
4222     }
4223     for (auto* client : overlappedRequestClients)
4224         overlapTestRequests.remove(client);
4225 }
4226 
4227 static inline bool shouldDoSoftwarePaint(const RenderLayer* layer, bool paintingReflection)
4228 {
4229     return paintingReflection &amp;&amp; !layer-&gt;has3DTransform();
4230 }
4231 
4232 static inline bool shouldSuppressPaintingLayer(RenderLayer* layer)
4233 {
4234     if (layer-&gt;renderer().style().isNotFinal() &amp;&amp; !layer-&gt;isRenderViewLayer() &amp;&amp; !layer-&gt;renderer().isDocumentElementRenderer())
4235         return true;
4236 
4237     // Avoid painting all layers if the document is in a state where visual updates aren&#39;t allowed.
4238     // A full repaint will occur in Document::setVisualUpdatesAllowed(bool) if painting is suppressed here.
4239     if (!layer-&gt;renderer().document().visualUpdatesAllowed())
4240         return true;
4241 
4242     return false;
4243 }
4244 
4245 static inline bool paintForFixedRootBackground(const RenderLayer* layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags)
4246 {
4247     return layer-&gt;renderer().isDocumentElementRenderer() &amp;&amp; (paintFlags &amp; RenderLayer::PaintLayerPaintingRootBackgroundOnly);
4248 }
4249 
4250 void RenderLayer::paintLayer(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4251 {
4252     auto shouldContinuePaint = [&amp;] () {
4253         return backing()-&gt;paintsIntoWindow()
4254             || backing()-&gt;paintsIntoCompositedAncestor()
4255             || shouldDoSoftwarePaint(this, paintFlags.contains(PaintLayerPaintingReflection))
4256             || paintForFixedRootBackground(this, paintFlags);
4257     };
4258 
4259     auto paintsIntoDifferentCompositedDestination = [&amp;]() {
4260         if (paintsIntoProvidedBacking())
4261             return true;
4262 
4263         if (isComposited() &amp;&amp; !shouldContinuePaint())
4264             return true;
4265 
4266         return false;
4267     };
4268 
4269     if (paintsIntoDifferentCompositedDestination()) {
4270         if (!context.performingPaintInvalidation() &amp;&amp; !(paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
4271             return;
4272 
4273         paintFlags.add(PaintLayerTemporaryClipRects);
4274     }
4275 
4276     if (viewportConstrainedNotCompositedReason() == NotCompositedForBoundsOutOfView) {
4277         // Don&#39;t paint out-of-view viewport constrained layers (when doing prepainting) because they will never be visible
4278         // unless their position or viewport size is changed.
4279         ASSERT(renderer().isFixedPositioned());
4280         return;
4281     }
4282 
4283     paintLayerWithEffects(context, paintingInfo, paintFlags);
4284 }
4285 
4286 void RenderLayer::paintLayerWithEffects(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4287 {
4288     // Non self-painting leaf layers don&#39;t need to be painted as their renderer() should properly paint itself.
4289     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
4290         return;
4291 
4292     if (shouldSuppressPaintingLayer(this))
4293         return;
4294 
4295     // If this layer is totally invisible then there is nothing to paint.
4296     if (!renderer().opacity())
4297         return;
4298 
4299     if (paintsWithTransparency(paintingInfo.paintBehavior))
4300         paintFlags.add(PaintLayerHaveTransparency);
4301 
4302     // PaintLayerAppliedTransform is used in RenderReplica, to avoid applying the transform twice.
4303     if (paintsWithTransform(paintingInfo.paintBehavior) &amp;&amp; !(paintFlags &amp; PaintLayerAppliedTransform)) {
4304         TransformationMatrix layerTransform = renderableTransform(paintingInfo.paintBehavior);
4305         // If the transform can&#39;t be inverted, then don&#39;t paint anything.
4306         if (!layerTransform.isInvertible())
4307             return;
4308 
4309         // If we have a transparency layer enclosing us and we are the root of a transform, then we need to establish the transparency
4310         // layer from the parent now, assuming there is a parent
4311         if (paintFlags &amp; PaintLayerHaveTransparency) {
4312             if (parent())
4313                 parent()-&gt;beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
4314             else
4315                 beginTransparencyLayers(context, paintingInfo, paintingInfo.paintDirtyRect);
4316         }
4317 
4318         if (enclosingPaginationLayer(ExcludeCompositedPaginatedLayers)) {
4319             paintTransformedLayerIntoFragments(context, paintingInfo, paintFlags);
4320             return;
4321         }
4322 
4323         // Make sure the parent&#39;s clip rects have been calculated.
4324         ClipRect clipRect = paintingInfo.paintDirtyRect;
4325         if (parent()) {
4326             ClipRectsContext clipRectsContext(paintingInfo.rootLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4327                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4328             clipRect = backgroundClipRect(clipRectsContext);
4329             clipRect.intersect(paintingInfo.paintDirtyRect);
4330 
4331             // Push the parent coordinate space&#39;s clip.
4332             parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4333         }
4334 
4335         paintLayerByApplyingTransform(context, paintingInfo, paintFlags);
4336 
4337         // Restore the clip.
4338         if (parent())
4339             parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4340 
4341         return;
4342     }
4343 
4344     paintLayerContentsAndReflection(context, paintingInfo, paintFlags);
4345 }
4346 
4347 void RenderLayer::paintLayerContentsAndReflection(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4348 {
4349     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4350 
4351     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4352 
4353     // Paint the reflection first if we have one.
4354     if (m_reflection &amp;&amp; !m_paintingInsideReflection) {
4355         // Mark that we are now inside replica painting.
4356         m_paintingInsideReflection = true;
4357         reflectionLayer()-&gt;paintLayer(context, paintingInfo, localPaintFlags | PaintLayerPaintingReflection);
4358         m_paintingInsideReflection = false;
4359     }
4360 
4361     localPaintFlags.add(paintLayerPaintingCompositingAllPhasesFlags());
4362     paintLayerContents(context, paintingInfo, localPaintFlags);
4363 }
4364 
4365 bool RenderLayer::setupFontSubpixelQuantization(GraphicsContext&amp; context, bool&amp; didQuantizeFonts)
4366 {
4367     if (context.paintingDisabled())
4368         return false;
4369 
4370     bool scrollingOnMainThread = true;
4371 #if ENABLE(ASYNC_SCROLLING)
4372     if (ScrollingCoordinator* scrollingCoordinator = page().scrollingCoordinator())
4373         scrollingOnMainThread = scrollingCoordinator-&gt;shouldUpdateScrollLayerPositionSynchronously(renderer().view().frameView());
4374 #endif
4375 
4376     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4377     // things on the scrolling thread.
4378     bool contentsScrollByPainting = (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling()) || (renderer().frame().ownerElement());
4379     bool isZooming = !page().chrome().client().hasStablePageScaleFactor();
4380     if (scrollingOnMainThread || contentsScrollByPainting || isZooming) {
4381         didQuantizeFonts = context.shouldSubpixelQuantizeFonts();
4382         context.setShouldSubpixelQuantizeFonts(false);
4383         return true;
4384     }
4385     return false;
4386 }
4387 
4388 Path RenderLayer::computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp; windRule) const
4389 {
4390     const RenderStyle&amp; style = renderer().style();
4391     float deviceSaleFactor = renderer().document().deviceScaleFactor();
4392 
4393     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath())) {
4394         auto&amp; clipPath = downcast&lt;ShapeClipPathOperation&gt;(*style.clipPath());
4395         FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), clipPath.referenceBox(), offsetFromRoot, rootRelativeBounds), deviceSaleFactor);
4396 
4397         windRule = clipPath.windRule();
4398         return clipPath.pathForReferenceRect(referenceBox);
4399     }
4400 
4401     if (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer())) {
4402 
4403         auto&amp; clipPath = downcast&lt;BoxClipPathOperation&gt;(*style.clipPath());
4404 
4405         FloatRoundedRect shapeRect = computeRoundedRectForBoxShape(clipPath.referenceBox(), downcast&lt;RenderBox&gt;(renderer())).pixelSnappedRoundedRectForPainting(deviceSaleFactor);
4406         shapeRect.move(offsetFromRoot);
4407 
4408         windRule = WindRule::NonZero;
4409         return clipPath.pathForReferenceRect(shapeRect);
4410     }
4411 
4412     return Path();
4413 }
4414 
4415 bool RenderLayer::setupClipPath(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4416 {
<a name="1" id="anc1"></a><span class="line-modified">4417     if (!renderer().hasClipPath() || context.paintingDisabled())</span>
4418         return false;
4419 
4420     if (!rootRelativeBoundsComputed) {
4421         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4422         rootRelativeBoundsComputed = true;
4423     }
4424 
4425     // SVG elements get clipped in SVG code.
4426     if (is&lt;RenderSVGRoot&gt;(renderer()))
4427         return false;
4428 
4429     auto&amp; style = renderer().style();
4430     LayoutSize paintingOffsetFromRoot = LayoutSize(snapSizeToDevicePixel(offsetFromRoot + paintingInfo.subpixelOffset, LayoutPoint(), renderer().document().deviceScaleFactor()));
4431     ASSERT(style.clipPath());
4432     if (is&lt;ShapeClipPathOperation&gt;(*style.clipPath()) || (is&lt;BoxClipPathOperation&gt;(*style.clipPath()) &amp;&amp; is&lt;RenderBox&gt;(renderer()))) {
4433         WindRule windRule;
4434         Path path = computeClipPath(paintingOffsetFromRoot, rootRelativeBounds, windRule);
4435         context.save();
4436         context.clipPath(path, windRule);
4437         return true;
4438     }
4439 
4440     if (style.clipPath()-&gt;type() == ClipPathOperation::Reference) {
4441         ReferenceClipPathOperation* referenceClipPathOperation = static_cast&lt;ReferenceClipPathOperation*&gt;(style.clipPath());
4442         Element* element = renderer().document().getElementById(referenceClipPathOperation-&gt;fragment());
4443         if (element &amp;&amp; element-&gt;renderer() &amp;&amp; is&lt;RenderSVGResourceClipper&gt;(element-&gt;renderer())) {
4444             context.save();
<a name="2" id="anc2"></a><span class="line-modified">4445             float deviceSaleFactor = renderer().document().deviceScaleFactor();</span>
<span class="line-modified">4446             FloatRect referenceBox = snapRectToDevicePixels(computeReferenceBox(renderer(), CSSBoxType::ContentBox, paintingOffsetFromRoot, rootRelativeBounds), deviceSaleFactor);</span>
<span class="line-removed">4447             FloatPoint offset {referenceBox.location()};</span>
4448             context.translate(offset);
<a name="3" id="anc3"></a><span class="line-modified">4449             FloatRect svgReferenceBox {FloatPoint(), referenceBox.size()};</span>
<span class="line-modified">4450             downcast&lt;RenderSVGResourceClipper&gt;(*element-&gt;renderer()).applyClippingToContext(renderer(), svgReferenceBox, paintingInfo.paintDirtyRect, context);</span>
<span class="line-modified">4451             context.translate(FloatPoint(-offset.x(), -offset.y()));</span>
4452             return true;
4453         }
4454     }
4455 
4456     return false;
4457 }
4458 
4459 RenderLayerFilters* RenderLayer::filtersForPainting(GraphicsContext&amp; context, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
4460 {
4461     if (context.paintingDisabled())
4462         return nullptr;
4463 
4464     if (paintFlags &amp; PaintLayerPaintingOverlayScrollbars)
4465         return nullptr;
4466 
4467     if (!paintsWithFilters())
4468         return nullptr;
4469 
4470     if (m_filters &amp;&amp; m_filters-&gt;filter())
4471         return m_filters.get();
4472 
4473     return nullptr;
4474 }
4475 
4476 GraphicsContext* RenderLayer::setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed)
4477 {
4478     auto* paintingFilters = filtersForPainting(destinationContext, paintFlags);
4479     if (!paintingFilters)
4480         return nullptr;
4481 
4482     LayoutRect filterRepaintRect = paintingFilters-&gt;dirtySourceRect();
4483     filterRepaintRect.move(offsetFromRoot);
4484 
4485     if (!rootRelativeBoundsComputed) {
4486         rootRelativeBounds = calculateLayerBounds(paintingInfo.rootLayer, offsetFromRoot, { });
4487         rootRelativeBoundsComputed = true;
4488     }
4489 
4490     GraphicsContext* filterContext = paintingFilters-&gt;beginFilterEffect(destinationContext, enclosingIntRect(rootRelativeBounds), enclosingIntRect(paintingInfo.paintDirtyRect), enclosingIntRect(filterRepaintRect));
4491     if (!filterContext)
4492         return nullptr;
4493 
4494     paintingInfo.paintDirtyRect = paintingFilters-&gt;repaintRect();
4495 
4496     // If the filter needs the full source image, we need to avoid using the clip rectangles.
4497     // Otherwise, if for example this layer has overflow:hidden, a drop shadow will not compute correctly.
4498     // Note that we will still apply the clipping on the final rendering of the filter.
4499     paintingInfo.clipToDirtyRect = !paintingFilters-&gt;hasFilterThatMovesPixels();
4500 
4501     paintingInfo.requireSecurityOriginAccessForWidgets = paintingFilters-&gt;hasFilterThatShouldBeRestrictedBySecurityOrigin();
4502 
4503     return filterContext;
4504 }
4505 
4506 void RenderLayer::applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp; paintingInfo, const LayerFragments&amp; layerFragments)
4507 {
4508     // FIXME: Handle more than one fragment.
4509     ClipRect backgroundRect = layerFragments.isEmpty() ? ClipRect() : layerFragments[0].backgroundRect;
4510     clipToRect(originalContext, paintingInfo, backgroundRect);
4511     m_filters-&gt;applyFilterEffect(originalContext);
4512     restoreClip(originalContext, paintingInfo, backgroundRect);
4513 }
4514 
4515 void RenderLayer::paintLayerContents(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4516 {
4517     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
4518 
4519     auto localPaintFlags = paintFlags - PaintLayerAppliedTransform;
4520     bool haveTransparency = localPaintFlags.contains(PaintLayerHaveTransparency);
4521     bool isSelfPaintingLayer = this-&gt;isSelfPaintingLayer();
4522     bool isPaintingOverlayScrollbars = paintFlags.contains(PaintLayerPaintingOverlayScrollbars);
4523     bool isPaintingScrollingContent = paintFlags.contains(PaintLayerPaintingCompositingScrollingPhase);
4524     bool isPaintingCompositedForeground = paintFlags.contains(PaintLayerPaintingCompositingForegroundPhase);
4525     bool isPaintingCompositedBackground = paintFlags.contains(PaintLayerPaintingCompositingBackgroundPhase);
4526     bool isPaintingOverflowContents = paintFlags.contains(PaintLayerPaintingOverflowContents);
4527     bool isCollectingEventRegion = paintFlags.contains(PaintLayerCollectingEventRegion);
4528     // Outline always needs to be painted even if we have no visible content. Also,
4529     // the outline is painted in the background phase during composited scrolling.
4530     // If it were painted in the foreground phase, it would move with the scrolled
4531     // content. When not composited scrolling, the outline is painted in the
4532     // foreground phase. Since scrolled contents are moved by repainting in this
4533     // case, the outline won&#39;t get &#39;dragged along&#39;.
4534     bool shouldPaintOutline = isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion
4535         &amp;&amp; (renderer().view().printing() || renderer().view().hasRenderersWithOutline())
4536         &amp;&amp; ((isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground)
4537         || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedForeground));
4538     bool shouldPaintContent = m_hasVisibleContent &amp;&amp; isSelfPaintingLayer &amp;&amp; !isPaintingOverlayScrollbars &amp;&amp; !isCollectingEventRegion;
4539 
4540     if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly &amp;&amp; !renderer().isRenderView() &amp;&amp; !renderer().isDocumentElementRenderer()) {
4541         // If beginTransparencyLayers was called prior to this, ensure the transparency state is cleaned up before returning.
4542         if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {
4543             context.endTransparencyLayer();
4544             context.restore();
4545             m_usedTransparency = false;
4546         }
4547 
4548         return;
4549     }
4550 
4551     updateLayerListsIfNeeded();
4552 
4553     LayoutSize offsetFromRoot = offsetFromAncestor(paintingInfo.rootLayer);
4554     LayoutRect rootRelativeBounds;
4555     bool rootRelativeBoundsComputed = false;
4556 
4557     // FIXME: We shouldn&#39;t have to disable subpixel quantization for overflow clips or subframes once we scroll those
4558     // things on the scrolling thread.
4559     bool didQuantizeFonts = true;
4560     bool needToAdjustSubpixelQuantization = setupFontSubpixelQuantization(context, didQuantizeFonts);
4561 
4562     // Apply clip-path to context.
4563     LayoutSize columnAwareOffsetFromRoot = offsetFromRoot;
4564     if (renderer().enclosingFragmentedFlow() &amp;&amp; (renderer().hasClipPath() || filtersForPainting(context, paintFlags)))
4565         columnAwareOffsetFromRoot = toLayoutSize(convertToLayerCoords(paintingInfo.rootLayer, LayoutPoint(), AdjustForColumns));
4566 
4567     bool hasClipPath = false;
4568     if (shouldApplyClipPath(paintingInfo.paintBehavior, localPaintFlags))
4569         hasClipPath = setupClipPath(context, paintingInfo, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4570 
4571     bool selectionAndBackgroundsOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);
4572     bool selectionOnly = paintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);
4573 
4574     SinglePaintFrequencyTracking singlePaintFrequencyTracking(m_paintFrequencyTracker, shouldPaintContent);
4575 
4576     LayerFragments layerFragments;
4577     RenderObject* subtreePaintRootForRenderer = nullptr;
4578 
4579     { // Scope for filter-related state changes.
4580         LayerPaintingInfo localPaintingInfo(paintingInfo);
4581         GraphicsContext* filterContext = setupFilters(context, localPaintingInfo, paintFlags, columnAwareOffsetFromRoot, rootRelativeBounds, rootRelativeBoundsComputed);
4582         if (filterContext &amp;&amp; haveTransparency) {
4583             // If we have a filter and transparency, we have to eagerly start a transparency layer here, rather than risk a child layer lazily starts one with the wrong context.
4584             beginTransparencyLayers(context, localPaintingInfo, paintingInfo.paintDirtyRect);
4585         }
4586         GraphicsContext&amp; currentContext = filterContext ? *filterContext : context;
4587 
4588         // If this layer&#39;s renderer is a child of the subtreePaintRoot, we render unconditionally, which
4589         // is done by passing a nil subtreePaintRoot down to our renderer (as if no subtreePaintRoot was ever set).
4590         // Otherwise, our renderer tree may or may not contain the subtreePaintRoot root, so we pass that root along
4591         // so it will be tested against as we descend through the renderers.
4592         if (localPaintingInfo.subtreePaintRoot &amp;&amp; !renderer().isDescendantOf(localPaintingInfo.subtreePaintRoot))
4593             subtreePaintRootForRenderer = localPaintingInfo.subtreePaintRoot;
4594 
4595         if (localPaintingInfo.overlapTestRequests &amp;&amp; isSelfPaintingLayer)
4596             performOverlapTests(*localPaintingInfo.overlapTestRequests, localPaintingInfo.rootLayer, this);
4597 
4598         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4599         if (localPaintFlags &amp; PaintLayerPaintingSkipRootBackground)
4600             paintBehavior.add(PaintBehavior::SkipRootBackground);
4601         else if (localPaintFlags &amp; PaintLayerPaintingRootBackgroundOnly)
4602             paintBehavior.add(PaintBehavior::RootBackgroundOnly);
4603 
4604         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4605             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4606 
4607         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4608             paintBehavior.add(PaintBehavior::Snapshotting);
4609 
4610         if ((paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint) &amp;&amp; isRenderViewLayer())
4611             paintBehavior.add(PaintBehavior::TileFirstPaint);
4612 
4613         if (paintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
4614             paintBehavior.add(PaintBehavior::ExcludeSelection);
4615 
4616         LayoutRect paintDirtyRect = localPaintingInfo.paintDirtyRect;
4617         if (shouldPaintContent || shouldPaintOutline || isPaintingOverlayScrollbars || isCollectingEventRegion) {
4618             // Collect the fragments. This will compute the clip rectangles and paint offsets for each layer fragment, as well as whether or not the content of each
4619             // fragment should paint. If the parent&#39;s filter dictates full repaint to ensure proper filter effect,
4620             // use the overflow clip as dirty rect, instead of no clipping. It maintains proper clipping for overflow::scroll.
4621             if (!localPaintingInfo.clipToDirtyRect &amp;&amp; renderer().hasOverflowClip()) {
4622                 // We can turn clipping back by requesting full repaint for the overflow area.
4623                 localPaintingInfo.clipToDirtyRect = true;
4624                 paintDirtyRect = clipRectRelativeToAncestor(localPaintingInfo.rootLayer, offsetFromRoot, LayoutRect::infiniteRect());
4625             }
4626             collectFragments(layerFragments, localPaintingInfo.rootLayer, paintDirtyRect, ExcludeCompositedPaginatedLayers,
4627                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4628                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4629             updatePaintingInfoForFragments(layerFragments, localPaintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4630         }
4631 
4632         if (isPaintingCompositedBackground) {
4633             // Paint only the backgrounds for all of the fragments of the layer.
4634             if (shouldPaintContent &amp;&amp; !selectionOnly) {
4635                 paintBackgroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4636                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4637             }
4638         }
4639 
4640         // Now walk the sorted list of children with negative z-indices.
4641         if ((isPaintingScrollingContent &amp;&amp; isPaintingOverflowContents) || (!isPaintingScrollingContent &amp;&amp; isPaintingCompositedBackground))
4642             paintList(negativeZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4643 
4644         if (isPaintingCompositedForeground) {
4645             if (shouldPaintContent) {
4646                 paintForegroundForFragments(layerFragments, currentContext, context, paintingInfo.paintDirtyRect, haveTransparency,
4647                     localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4648             }
4649         }
4650 
4651         if (isCollectingEventRegion)
4652             collectEventRegionForFragments(layerFragments, currentContext, localPaintingInfo);
4653 
4654         if (shouldPaintOutline)
4655             paintOutlineForFragments(layerFragments, currentContext, localPaintingInfo, paintBehavior, subtreePaintRootForRenderer);
4656 
4657         if (isPaintingCompositedForeground) {
4658             // Paint any child layers that have overflow.
4659             paintList(normalFlowLayers(), currentContext, localPaintingInfo, localPaintFlags);
4660 
4661             // Now walk the sorted list of children with positive z-indices.
4662             paintList(positiveZOrderLayers(), currentContext, localPaintingInfo, localPaintFlags);
4663         }
4664 
4665         if (isPaintingOverlayScrollbars &amp;&amp; hasScrollbars())
4666             paintOverflowControlsForFragments(layerFragments, currentContext, localPaintingInfo);
4667 
4668         if (filterContext) {
4669             // When we called collectFragments() last time, paintDirtyRect was reset to represent the filter bounds.
4670             // Now we need to compute the backgroundRect uncontaminated by filters, in order to clip the filtered result.
4671             // Note that we also use paintingInfo here, not localPaintingInfo which filters also contaminated.
4672             LayerFragments layerFragments;
4673             collectFragments(layerFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4674                 (localPaintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4675                 (isPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetFromRoot);
4676             updatePaintingInfoForFragments(layerFragments, paintingInfo, localPaintFlags, shouldPaintContent, offsetFromRoot);
4677 
4678             applyFilters(context, paintingInfo, layerFragments);
4679         }
4680     }
4681 
4682     if (shouldPaintContent &amp;&amp; !(selectionOnly || selectionAndBackgroundsOnly)) {
4683         OptionSet&lt;PaintBehavior&gt; paintBehavior = PaintBehavior::Normal;
4684         if (paintingInfo.paintBehavior &amp; PaintBehavior::FlattenCompositingLayers)
4685             paintBehavior.add(PaintBehavior::FlattenCompositingLayers);
4686 
4687         if (paintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
4688             paintBehavior.add(PaintBehavior::Snapshotting);
4689 
4690         if (paintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
4691             paintBehavior.add(PaintBehavior::TileFirstPaint);
4692 
4693         if (shouldPaintMask(paintingInfo.paintBehavior, localPaintFlags)) {
4694             // Paint the mask for the fragments.
4695             paintMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4696         }
4697 
4698         if (!(paintFlags &amp; PaintLayerPaintingCompositingMaskPhase) &amp;&amp; (paintFlags &amp; PaintLayerPaintingCompositingClipPathPhase)) {
4699             // Re-use paintChildClippingMaskForFragments to paint black for the compositing clipping mask.
4700             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4701         }
4702 
4703         if (localPaintFlags &amp; PaintLayerPaintingChildClippingMaskPhase) {
4704             // Paint the border radius mask for the fragments.
4705             paintChildClippingMaskForFragments(layerFragments, context, paintingInfo, paintBehavior, subtreePaintRootForRenderer);
4706         }
4707     }
4708 
4709     // End our transparency layer
4710     if (haveTransparency &amp;&amp; m_usedTransparency &amp;&amp; !m_paintingInsideReflection) {
4711         context.endTransparencyLayer();
4712         context.restore();
4713         m_usedTransparency = false;
4714     }
4715 
4716     // Re-set this to whatever it was before we painted the layer.
4717     if (needToAdjustSubpixelQuantization)
4718         context.setShouldSubpixelQuantizeFonts(didQuantizeFonts);
4719 
4720     if (hasClipPath)
4721         context.restore();
4722 }
4723 
4724 void RenderLayer::paintLayerByApplyingTransform(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags, const LayoutSize&amp; translationOffset)
4725 {
4726     // This involves subtracting out the position of the layer in our current coordinate space, but preserving
4727     // the accumulated error for sub-pixel layout.
4728     float deviceScaleFactor = renderer().document().deviceScaleFactor();
4729     LayoutSize offsetFromParent = offsetFromAncestor(paintingInfo.rootLayer);
4730     offsetFromParent += translationOffset;
4731     TransformationMatrix transform(renderableTransform(paintingInfo.paintBehavior));
4732     // Add the subpixel accumulation to the current layer&#39;s offset so that we can always snap the translateRight value to where the renderer() is supposed to be painting.
4733     LayoutSize offsetForThisLayer = offsetFromParent + paintingInfo.subpixelOffset;
4734     FloatSize devicePixelSnappedOffsetForThisLayer = toFloatSize(roundPointToDevicePixels(toLayoutPoint(offsetForThisLayer), deviceScaleFactor));
4735     // We handle accumulated subpixels through nested layers here. Since the context gets translated to device pixels,
4736     // all we need to do is add the delta to the accumulated pixels coming from ancestor layers.
4737     // Translate the graphics context to the snapping position to avoid off-device-pixel positing.
4738     transform.translateRight(devicePixelSnappedOffsetForThisLayer.width(), devicePixelSnappedOffsetForThisLayer.height());
4739     // Apply the transform.
4740     auto oldTransform = context.getCTM();
4741     auto affineTransform = transform.toAffineTransform();
4742     context.concatCTM(affineTransform);
4743 
4744     if (paintingInfo.eventRegionContext)
4745         paintingInfo.eventRegionContext-&gt;pushTransform(affineTransform);
4746 
4747     // Now do a paint with the root layer shifted to be us.
4748     LayoutSize adjustedSubpixelOffset = offsetForThisLayer - LayoutSize(devicePixelSnappedOffsetForThisLayer);
4749     LayerPaintingInfo transformedPaintingInfo(paintingInfo);
4750     transformedPaintingInfo.rootLayer = this;
4751     transformedPaintingInfo.paintDirtyRect = LayoutRect(encloseRectToDevicePixels(transform.inverse().valueOr(AffineTransform()).mapRect(paintingInfo.paintDirtyRect), deviceScaleFactor));
4752     transformedPaintingInfo.subpixelOffset = adjustedSubpixelOffset;
4753     paintLayerContentsAndReflection(context, transformedPaintingInfo, paintFlags);
4754 
4755     if (paintingInfo.eventRegionContext)
4756         paintingInfo.eventRegionContext-&gt;popTransform();
4757 
4758     context.setCTM(oldTransform);
4759 }
4760 
4761 void RenderLayer::paintList(LayerList layerIterator, GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4762 {
4763     if (layerIterator.begin() == layerIterator.end())
4764         return;
4765 
4766     if (!hasSelfPaintingLayerDescendant())
4767         return;
4768 
4769 #if ASSERT_ENABLED
4770     LayerListMutationDetector mutationChecker(*this);
4771 #endif
4772 
4773     for (auto* childLayer : layerIterator)
4774         childLayer-&gt;paintLayer(context, paintingInfo, paintFlags);
4775 }
4776 
4777 RenderLayer* RenderLayer::enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode mode) const
4778 {
4779     // If we don&#39;t have an enclosing layer, or if the root layer is the same as the enclosing layer,
4780     // then just return the enclosing pagination layer (it will be 0 in the former case and the rootLayer in the latter case).
4781     RenderLayer* paginationLayer = enclosingPaginationLayer(mode);
4782     if (!paginationLayer || rootLayer == paginationLayer)
4783         return paginationLayer;
4784 
4785     // Walk up the layer tree and see which layer we hit first. If it&#39;s the root, then the enclosing pagination
4786     // layer isn&#39;t in our subtree and we return nullptr. If we hit the enclosing pagination layer first, then
4787     // we can return it.
4788     for (const RenderLayer* layer = this; layer; layer = layer-&gt;parent()) {
4789         if (layer == rootLayer)
4790             return nullptr;
4791         if (layer == paginationLayer)
4792             return paginationLayer;
4793     }
4794 
4795     // This should never be reached, since an enclosing layer should always either be the rootLayer or be
4796     // our enclosing pagination layer.
4797     ASSERT_NOT_REACHED();
4798     return nullptr;
4799 }
4800 
4801 void RenderLayer::collectFragments(LayerFragments&amp; fragments, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect, PaginationInclusionMode inclusionMode,
4802     ClipRectsType clipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip respectOverflowClip, const LayoutSize&amp; offsetFromRoot,
4803     const LayoutRect* layerBoundingBox, ShouldApplyRootOffsetToFragments applyRootOffsetToFragments)
4804 {
4805     RenderLayer* paginationLayer = enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4806     if (!paginationLayer || hasTransform()) {
4807         // For unpaginated layers, there is only one fragment.
4808         LayerFragment fragment;
4809         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4810         calculateRects(clipRectsContext, dirtyRect, fragment.layerBounds, fragment.backgroundRect, fragment.foregroundRect, offsetFromRoot);
4811         fragments.append(fragment);
4812         return;
4813     }
4814 
4815     // Compute our offset within the enclosing pagination layer.
4816     LayoutSize offsetWithinPaginatedLayer = offsetFromAncestor(paginationLayer);
4817 
4818     // Calculate clip rects relative to the enclosingPaginationLayer. The purpose of this call is to determine our bounds clipped to intermediate
4819     // layers between us and the pagination context. It&#39;s important to minimize the number of fragments we need to create and this helps with that.
4820     ClipRectsContext paginationClipRectsContext(paginationLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4821     LayoutRect layerBoundsInFragmentedFlow;
4822     ClipRect backgroundRectInFragmentedFlow;
4823     ClipRect foregroundRectInFragmentedFlow;
4824     calculateRects(paginationClipRectsContext, LayoutRect::infiniteRect(), layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow,
4825         offsetWithinPaginatedLayer);
4826 
4827     // Take our bounding box within the flow thread and clip it.
4828     LayoutRect layerBoundingBoxInFragmentedFlow = layerBoundingBox ? *layerBoundingBox : boundingBox(paginationLayer, offsetWithinPaginatedLayer);
4829     layerBoundingBoxInFragmentedFlow.intersect(backgroundRectInFragmentedFlow.rect());
4830 
4831     auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
4832     RenderLayer* parentPaginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(rootLayer, inclusionMode);
4833     LayerFragments ancestorFragments;
4834     if (parentPaginationLayer) {
4835         // Compute a bounding box accounting for fragments.
4836         LayoutRect layerFragmentBoundingBoxInParentPaginationLayer = enclosingFragmentedFlow.fragmentsBoundingBox(layerBoundingBoxInFragmentedFlow);
4837 
4838         // Convert to be in the ancestor pagination context&#39;s coordinate space.
4839         LayoutSize offsetWithinParentPaginatedLayer = paginationLayer-&gt;offsetFromAncestor(parentPaginationLayer);
4840         layerFragmentBoundingBoxInParentPaginationLayer.move(offsetWithinParentPaginatedLayer);
4841 
4842         // Now collect ancestor fragments.
4843         parentPaginationLayer-&gt;collectFragments(ancestorFragments, rootLayer, dirtyRect, inclusionMode, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip,
4844             offsetFromAncestor(rootLayer), &amp;layerFragmentBoundingBoxInParentPaginationLayer, ApplyRootOffsetToFragments);
4845 
4846         if (ancestorFragments.isEmpty())
4847             return;
4848 
4849         for (auto&amp; ancestorFragment : ancestorFragments) {
4850             // Shift the dirty rect into flow thread coordinates.
4851             LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4852             dirtyRectInFragmentedFlow.move(-offsetWithinParentPaginatedLayer - ancestorFragment.paginationOffset);
4853 
4854             size_t oldSize = fragments.size();
4855 
4856             // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4857             // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4858             enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4859 
4860             size_t newSize = fragments.size();
4861 
4862             if (oldSize == newSize)
4863                 continue;
4864 
4865             for (size_t i = oldSize; i &lt; newSize; ++i) {
4866                 LayerFragment&amp; fragment = fragments.at(i);
4867 
4868                 // Set our four rects with all clipping applied that was internal to the flow thread.
4869                 fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4870 
4871                 // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4872                 fragment.moveBy(toLayoutPoint(ancestorFragment.paginationOffset + fragment.paginationOffset + offsetWithinParentPaginatedLayer));
4873 
4874                 // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4875                 // properly clipped by the overflow.
4876                 fragment.intersect(ancestorFragment.paginationClip);
4877 
4878                 // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4879                 // clip, so the column clip ends up being all we apply.
4880                 fragment.intersect(fragment.paginationClip);
4881 
4882                 if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4883                     fragment.paginationOffset = fragment.paginationOffset + offsetWithinParentPaginatedLayer;
4884             }
4885         }
4886 
4887         return;
4888     }
4889 
4890     // Shift the dirty rect into flow thread coordinates.
4891     LayoutSize offsetOfPaginationLayerFromRoot = enclosingPaginationLayer(inclusionMode)-&gt;offsetFromAncestor(rootLayer);
4892     LayoutRect dirtyRectInFragmentedFlow(dirtyRect);
4893     dirtyRectInFragmentedFlow.move(-offsetOfPaginationLayerFromRoot);
4894 
4895     // Tell the flow thread to collect the fragments. We pass enough information to create a minimal number of fragments based off the pages/columns
4896     // that intersect the actual dirtyRect as well as the pages/columns that intersect our layer&#39;s bounding box.
4897     enclosingFragmentedFlow.collectLayerFragments(fragments, layerBoundingBoxInFragmentedFlow, dirtyRectInFragmentedFlow);
4898 
4899     if (fragments.isEmpty())
4900         return;
4901 
4902     // Get the parent clip rects of the pagination layer, since we need to intersect with that when painting column contents.
4903     ClipRect ancestorClipRect = dirtyRect;
4904     if (paginationLayer-&gt;parent()) {
4905         ClipRectsContext clipRectsContext(rootLayer, clipRectsType, inOverlayScrollbarSizeRelevancy, respectOverflowClip);
4906         ancestorClipRect = paginationLayer-&gt;backgroundClipRect(clipRectsContext);
4907         ancestorClipRect.intersect(dirtyRect);
4908     }
4909 
4910     for (auto&amp; fragment : fragments) {
4911         // Set our four rects with all clipping applied that was internal to the flow thread.
4912         fragment.setRects(layerBoundsInFragmentedFlow, backgroundRectInFragmentedFlow, foregroundRectInFragmentedFlow, &amp;layerBoundingBoxInFragmentedFlow);
4913 
4914         // Shift to the root-relative physical position used when painting the flow thread in this fragment.
4915         fragment.moveBy(toLayoutPoint(fragment.paginationOffset + offsetOfPaginationLayerFromRoot));
4916 
4917         // Intersect the fragment with our ancestor&#39;s background clip so that e.g., columns in an overflow:hidden block are
4918         // properly clipped by the overflow.
4919         fragment.intersect(ancestorClipRect);
4920 
4921         // Now intersect with our pagination clip. This will typically mean we&#39;re just intersecting the dirty rect with the column
4922         // clip, so the column clip ends up being all we apply.
4923         fragment.intersect(fragment.paginationClip);
4924 
4925         if (applyRootOffsetToFragments == ApplyRootOffsetToFragments)
4926             fragment.paginationOffset = fragment.paginationOffset + offsetOfPaginationLayerFromRoot;
4927     }
4928 }
4929 
4930 void RenderLayer::updatePaintingInfoForFragments(LayerFragments&amp; fragments, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintLayerFlag&gt; localPaintFlags,
4931     bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot)
4932 {
4933     for (auto&amp; fragment : fragments) {
4934         fragment.shouldPaintContent = shouldPaintContent;
4935         if (this != localPaintingInfo.rootLayer || !(localPaintFlags &amp; PaintLayerPaintingOverflowContents)) {
4936             LayoutSize newOffsetFromRoot = offsetFromRoot + fragment.paginationOffset;
4937             fragment.shouldPaintContent &amp;= intersectsDamageRect(fragment.layerBounds, fragment.backgroundRect.rect(), localPaintingInfo.rootLayer, newOffsetFromRoot, fragment.hasBoundingBox ? &amp;fragment.boundingBox : 0);
4938         }
4939     }
4940 }
4941 
4942 void RenderLayer::paintTransformedLayerIntoFragments(GraphicsContext&amp; context, const LayerPaintingInfo&amp; paintingInfo, OptionSet&lt;PaintLayerFlag&gt; paintFlags)
4943 {
4944     LayerFragments enclosingPaginationFragments;
4945     LayoutSize offsetOfPaginationLayerFromRoot;
4946     RenderLayer* paginatedLayer = enclosingPaginationLayer(ExcludeCompositedPaginatedLayers);
4947     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, PaintingTransparencyClipBox, RootOfTransparencyClipBox, paintingInfo.paintBehavior);
4948     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, paintingInfo.rootLayer, paintingInfo.paintDirtyRect, ExcludeCompositedPaginatedLayers,
4949         (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects, IgnoreOverlayScrollbarSize,
4950         (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
4951 
4952     for (const auto&amp; fragment : enclosingPaginationFragments) {
4953         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
4954         // the enclosing pagination layer.
4955         LayoutRect clipRect = fragment.backgroundRect.rect();
4956 
4957         // Now compute the clips within a given fragment
4958         if (parent() != paginatedLayer) {
4959             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(paintingInfo.rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
4960 
4961             ClipRectsContext clipRectsContext(paginatedLayer, (paintFlags &amp; PaintLayerTemporaryClipRects) ? TemporaryClipRects : PaintingClipRects,
4962                 IgnoreOverlayScrollbarSize, (paintFlags &amp; PaintLayerPaintingOverflowContents) ? IgnoreOverflowClip : RespectOverflowClip);
4963             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
4964             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
4965             clipRect.intersect(parentClipRect);
4966         }
4967 
4968         parent()-&gt;clipToRect(context, paintingInfo, clipRect);
4969         paintLayerByApplyingTransform(context, paintingInfo, paintFlags, fragment.paginationOffset);
4970         parent()-&gt;restoreClip(context, paintingInfo, clipRect);
4971     }
4972 }
4973 
4974 void RenderLayer::paintBackgroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
4975     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
4976     RenderObject* subtreePaintRootForRenderer)
4977 {
4978     for (const auto&amp; fragment : layerFragments) {
4979         if (!fragment.shouldPaintContent)
4980             continue;
4981 
4982         // Begin transparency layers lazily now that we know we have to paint something.
4983         if (haveTransparency)
4984             beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
4985 
4986         if (localPaintingInfo.clipToDirtyRect) {
4987             // Paint our background first, before painting any child layers.
4988             // Establish the clip used to paint our background.
4989             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Background painting will handle clipping to self.
4990         }
4991 
4992         // Paint the background.
4993         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
4994         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::BlockBackground, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
4995         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
4996 
4997         if (localPaintingInfo.clipToDirtyRect)
4998             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
4999     }
5000 }
5001 
5002 void RenderLayer::paintForegroundForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, GraphicsContext&amp; contextForTransparencyLayer,
5003     const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior,
5004     RenderObject* subtreePaintRootForRenderer)
5005 {
5006     // Begin transparency if we have something to paint.
5007     if (haveTransparency) {
5008         for (const auto&amp; fragment : layerFragments) {
5009             if (fragment.shouldPaintContent &amp;&amp; !fragment.foregroundRect.isEmpty()) {
5010                 beginTransparencyLayers(contextForTransparencyLayer, localPaintingInfo, transparencyPaintDirtyRect);
5011                 break;
5012             }
5013         }
5014     }
5015 
5016     OptionSet&lt;PaintBehavior&gt; localPaintBehavior;
5017     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceBlackText)
5018         localPaintBehavior = PaintBehavior::ForceBlackText;
5019     else if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ForceWhiteText)
5020         localPaintBehavior = PaintBehavior::ForceWhiteText;
5021     else
5022         localPaintBehavior = paintBehavior;
5023 
5024     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::ExcludeSelection)
5025         localPaintBehavior.add(PaintBehavior::ExcludeSelection);
5026 
5027     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::Snapshotting)
5028         localPaintBehavior.add(PaintBehavior::Snapshotting);
5029 
5030     if (localPaintingInfo.paintBehavior &amp; PaintBehavior::TileFirstPaint)
5031         localPaintBehavior.add(PaintBehavior::TileFirstPaint);
5032 
5033     // Optimize clipping for the single fragment case.
5034     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() == 1 &amp;&amp; layerFragments[0].shouldPaintContent &amp;&amp; !layerFragments[0].foregroundRect.isEmpty();
5035     ClipRect clippedRect;
5036     if (shouldClip) {
5037         clippedRect = layerFragments[0].foregroundRect;
5038         clipToRect(context, localPaintingInfo, clippedRect);
5039     }
5040 
5041     // We have to loop through every fragment multiple times, since we have to repaint in each specific phase in order for
5042     // interleaving of the fragments to work properly.
5043     bool selectionOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionOnly);
5044     bool selectionAndBackgroundsOnly = localPaintingInfo.paintBehavior.contains(PaintBehavior::SelectionAndBackgroundsOnly);
5045 
5046     if (!selectionOnly)
5047         paintForegroundForFragmentsWithPhase(PaintPhase::ChildBlockBackgrounds, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5048 
5049     if (selectionOnly || selectionAndBackgroundsOnly)
5050         paintForegroundForFragmentsWithPhase(PaintPhase::Selection, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5051     else {
5052         paintForegroundForFragmentsWithPhase(PaintPhase::Float, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5053         paintForegroundForFragmentsWithPhase(PaintPhase::Foreground, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5054         paintForegroundForFragmentsWithPhase(PaintPhase::ChildOutlines, layerFragments, context, localPaintingInfo, localPaintBehavior, subtreePaintRootForRenderer);
5055     }
5056 
5057     if (shouldClip)
5058         restoreClip(context, localPaintingInfo, clippedRect);
5059 }
5060 
5061 void RenderLayer::paintForegroundForFragmentsWithPhase(PaintPhase phase, const LayerFragments&amp; layerFragments, GraphicsContext&amp; context,
5062     const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5063 {
5064     bool shouldClip = localPaintingInfo.clipToDirtyRect &amp;&amp; layerFragments.size() &gt; 1;
5065 
5066     for (const auto&amp; fragment : layerFragments) {
5067         if (!fragment.shouldPaintContent || fragment.foregroundRect.isEmpty())
5068             continue;
5069 
5070         if (shouldClip)
5071             clipToRect(context, localPaintingInfo, fragment.foregroundRect);
5072 
5073         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), phase, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this, localPaintingInfo.requireSecurityOriginAccessForWidgets);
5074         if (phase == PaintPhase::Foreground)
5075             paintInfo.overlapTestRequests = localPaintingInfo.overlapTestRequests;
5076         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5077 
5078         if (shouldClip)
5079             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
5080     }
5081 }
5082 
5083 void RenderLayer::paintOutlineForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
5084     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5085 {
5086     for (const auto&amp; fragment : layerFragments) {
5087         if (fragment.backgroundRect.isEmpty())
5088             continue;
5089 
5090         // Paint our own outline
5091         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::SelfOutline, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5092         clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius);
5093         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5094         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5095     }
5096 }
5097 
5098 void RenderLayer::paintMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo,
5099     OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5100 {
5101     for (const auto&amp; fragment : layerFragments) {
5102         if (!fragment.shouldPaintContent)
5103             continue;
5104 
5105         if (localPaintingInfo.clipToDirtyRect)
5106             clipToRect(context, localPaintingInfo, fragment.backgroundRect, DoNotIncludeSelfForBorderRadius); // Mask painting will handle clipping to self.
5107 
5108         // Paint the mask.
5109         // FIXME: Eventually we will collect the region from the fragment itself instead of just from the paint info.
5110         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::Mask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5111         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5112 
5113         if (localPaintingInfo.clipToDirtyRect)
5114             restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5115     }
5116 }
5117 
5118 void RenderLayer::paintChildClippingMaskForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo, OptionSet&lt;PaintBehavior&gt; paintBehavior, RenderObject* subtreePaintRootForRenderer)
5119 {
5120     for (const auto&amp; fragment : layerFragments) {
5121         if (!fragment.shouldPaintContent)
5122             continue;
5123 
5124         if (localPaintingInfo.clipToDirtyRect)
5125             clipToRect(context, localPaintingInfo, fragment.foregroundRect, IncludeSelfForBorderRadius); // Child clipping mask painting will handle clipping to self.
5126 
5127         // Paint the clipped mask.
5128         PaintInfo paintInfo(context, fragment.backgroundRect.rect(), PaintPhase::ClippingMask, paintBehavior, subtreePaintRootForRenderer, nullptr, nullptr, &amp;localPaintingInfo.rootLayer-&gt;renderer(), this);
5129         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5130 
5131         if (localPaintingInfo.clipToDirtyRect)
5132             restoreClip(context, localPaintingInfo, fragment.foregroundRect);
5133     }
5134 }
5135 
5136 void RenderLayer::paintOverflowControlsForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
5137 {
5138     for (const auto&amp; fragment : layerFragments) {
5139         if (fragment.backgroundRect.isEmpty())
5140             continue;
5141         clipToRect(context, localPaintingInfo, fragment.backgroundRect);
5142         paintOverflowControls(context, roundedIntPoint(toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset)),
5143             snappedIntRect(fragment.backgroundRect.rect()), true);
5144         restoreClip(context, localPaintingInfo, fragment.backgroundRect);
5145     }
5146 }
5147 
5148 void RenderLayer::collectEventRegionForFragments(const LayerFragments&amp; layerFragments, GraphicsContext&amp; context, const LayerPaintingInfo&amp; localPaintingInfo)
5149 {
5150     ASSERT(localPaintingInfo.eventRegionContext);
5151 
5152     for (const auto&amp; fragment : layerFragments) {
5153         PaintInfo paintInfo(context, fragment.foregroundRect.rect(), PaintPhase::EventRegion, { });
5154         paintInfo.eventRegionContext = localPaintingInfo.eventRegionContext;
5155         renderer().paint(paintInfo, toLayoutPoint(fragment.layerBounds.location() - renderBoxLocation() + localPaintingInfo.subpixelOffset));
5156     }
5157 }
5158 
5159 bool RenderLayer::hitTest(const HitTestRequest&amp; request, HitTestResult&amp; result)
5160 {
5161     return hitTest(request, result.hitTestLocation(), result);
5162 }
5163 
5164 bool RenderLayer::hitTest(const HitTestRequest&amp; request, const HitTestLocation&amp; hitTestLocation, HitTestResult&amp; result)
5165 {
5166     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5167     ASSERT(!renderer().view().needsLayout());
5168 
5169     ASSERT(!isRenderFragmentedFlow());
5170     LayoutRect hitTestArea = renderer().view().documentRect();
5171     if (!request.ignoreClipping()) {
5172         const auto&amp; settings = renderer().settings();
5173         if (settings.visualViewportEnabled() &amp;&amp; settings.clientCoordinatesRelativeToLayoutViewport()) {
5174             auto&amp; frameView = renderer().view().frameView();
5175             LayoutRect absoluteLayoutViewportRect = frameView.layoutViewportRect();
5176             auto scaleFactor = frameView.frame().frameScaleFactor();
5177             if (scaleFactor &gt; 1)
5178                 absoluteLayoutViewportRect.scale(scaleFactor);
5179             hitTestArea.intersect(absoluteLayoutViewportRect);
5180         } else
5181             hitTestArea.intersect(renderer().view().frameView().visibleContentRect(LegacyIOSDocumentVisibleRect));
5182     }
5183 
5184     RenderLayer* insideLayer = hitTestLayer(this, nullptr, request, result, hitTestArea, hitTestLocation, false);
5185     if (!insideLayer) {
5186         // We didn&#39;t hit any layer. If we are the root layer and the mouse is -- or just was -- down,
5187         // return ourselves. We do this so mouse events continue getting delivered after a drag has
5188         // exited the WebView, and so hit testing over a scrollbar hits the content document.
5189         if (!request.isChildFrameHitTest() &amp;&amp; (request.active() || request.release()) &amp;&amp; isRenderViewLayer()) {
5190             renderer().updateHitTestResult(result, downcast&lt;RenderView&gt;(renderer()).flipForWritingMode(hitTestLocation.point()));
5191             insideLayer = this;
5192         }
5193     }
5194 
5195     // Now determine if the result is inside an anchor - if the urlElement isn&#39;t already set.
5196     Node* node = result.innerNode();
5197     if (node &amp;&amp; !result.URLElement())
5198         result.setURLElement(node-&gt;enclosingLinkEventParentOrSelf());
5199 
5200     // Now return whether we were inside this layer (this will always be true for the root
5201     // layer).
5202     return insideLayer;
5203 }
5204 
5205 Element* RenderLayer::enclosingElement() const
5206 {
5207     for (RenderElement* r = &amp;renderer(); r; r = r-&gt;parent()) {
5208         if (Element* e = r-&gt;element())
5209             return e;
5210     }
5211     return nullptr;
5212 }
5213 
5214 RenderLayer* RenderLayer::enclosingFragmentedFlowAncestor() const
5215 {
5216     RenderLayer* curr = parent();
5217     for (; curr &amp;&amp; !curr-&gt;isRenderFragmentedFlow(); curr = curr-&gt;parent()) {
5218         if (curr-&gt;isStackingContext() &amp;&amp; curr-&gt;isComposited()) {
5219             // We only adjust the position of the first level of layers.
5220             return nullptr;
5221         }
5222     }
5223     return curr;
5224 }
5225 
5226 // Compute the z-offset of the point in the transformState.
5227 // This is effectively projecting a ray normal to the plane of ancestor, finding where that
5228 // ray intersects target, and computing the z delta between those two points.
5229 static double computeZOffset(const HitTestingTransformState&amp; transformState)
5230 {
5231     // We got an affine transform, so no z-offset
5232     if (transformState.m_accumulatedTransform.isAffine())
5233         return 0;
5234 
5235     // Flatten the point into the target plane
5236     FloatPoint targetPoint = transformState.mappedPoint();
5237 
5238     // Now map the point back through the transform, which computes Z.
5239     FloatPoint3D backmappedPoint = transformState.m_accumulatedTransform.mapPoint(FloatPoint3D(targetPoint));
5240     return backmappedPoint.z();
5241 }
5242 
5243 Ref&lt;HitTestingTransformState&gt; RenderLayer::createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
5244                                         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5245                                         const HitTestingTransformState* containerTransformState,
5246                                         const LayoutSize&amp; translationOffset) const
5247 {
5248     RefPtr&lt;HitTestingTransformState&gt; transformState;
5249     LayoutSize offset;
5250     if (containerTransformState) {
5251         // If we&#39;re already computing transform state, then it&#39;s relative to the container (which we know is non-null).
5252         transformState = HitTestingTransformState::create(*containerTransformState);
5253         offset = offsetFromAncestor(containerLayer);
5254     } else {
5255         // If this is the first time we need to make transform state, then base it off of hitTestLocation,
5256         // which is relative to rootLayer.
5257         transformState = HitTestingTransformState::create(hitTestLocation.transformedPoint(), hitTestLocation.transformedRect(), FloatQuad(hitTestRect));
5258         offset = offsetFromAncestor(rootLayer);
5259     }
5260     offset += translationOffset;
5261 
5262     RenderObject* containerRenderer = containerLayer ? &amp;containerLayer-&gt;renderer() : nullptr;
5263     if (renderer().shouldUseTransformFromContainer(containerRenderer)) {
5264         TransformationMatrix containerTransform;
5265         renderer().getTransformFromContainer(containerRenderer, offset, containerTransform);
5266         transformState-&gt;applyTransform(containerTransform, HitTestingTransformState::AccumulateTransform);
5267     } else {
5268         transformState-&gt;translate(offset.width(), offset.height(), HitTestingTransformState::AccumulateTransform);
5269     }
5270 
5271     return transformState.releaseNonNull();
5272 }
5273 
5274 
5275 static bool isHitCandidate(const RenderLayer* hitLayer, bool canDepthSort, double* zOffset, const HitTestingTransformState* transformState)
5276 {
5277     if (!hitLayer)
5278         return false;
5279 
5280     // The hit layer is depth-sorting with other layers, so just say that it was hit.
5281     if (canDepthSort)
5282         return true;
5283 
5284     // We need to look at z-depth to decide if this layer was hit.
5285     if (zOffset) {
5286         ASSERT(transformState);
5287         // This is actually computing our z, but that&#39;s OK because the hitLayer is coplanar with us.
5288         double childZOffset = computeZOffset(*transformState);
5289         if (childZOffset &gt; *zOffset) {
5290             *zOffset = childZOffset;
5291             return true;
5292         }
5293         return false;
5294     }
5295 
5296     return true;
5297 }
5298 
5299 // hitTestLocation and hitTestRect are relative to rootLayer.
5300 // A &#39;flattening&#39; layer is one preserves3D() == false.
5301 // transformState.m_accumulatedTransform holds the transform from the containing flattening layer.
5302 // transformState.m_lastPlanarPoint is the hitTestLocation in the plane of the containing flattening layer.
5303 // transformState.m_lastPlanarQuad is the hitTestRect as a quad in the plane of the containing flattening layer.
5304 //
5305 // If zOffset is non-null (which indicates that the caller wants z offset information),
5306 //  *zOffset on return is the z offset of the hit point relative to the containing flattening layer.
5307 RenderLayer* RenderLayer::hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5308                                        const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, bool appliedTransform,
5309                                        const HitTestingTransformState* transformState, double* zOffset)
5310 {
5311     updateLayerListsIfNeeded();
5312 
5313     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
5314         return nullptr;
5315 
5316     // The natural thing would be to keep HitTestingTransformState on the stack, but it&#39;s big, so we heap-allocate.
5317 
5318     // Apply a transform if we have one.
5319     if (transform() &amp;&amp; !appliedTransform) {
5320         if (enclosingPaginationLayer(IncludeCompositedPaginatedLayers))
5321             return hitTestTransformedLayerInFragments(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5322 
5323         // Make sure the parent&#39;s clip rects have been calculated.
5324         if (parent()) {
5325             ClipRectsContext clipRectsContext(rootLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5326             ClipRect clipRect = backgroundClipRect(clipRectsContext);
5327             // Test the enclosing clip now.
5328             if (!clipRect.intersects(hitTestLocation))
5329                 return nullptr;
5330         }
5331 
5332         return hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation, transformState, zOffset);
5333     }
5334 
5335     // Ensure our lists and 3d status are up-to-date.
5336     update3DTransformedDescendantStatus();
5337 
5338     RefPtr&lt;HitTestingTransformState&gt; localTransformState;
5339     if (appliedTransform) {
5340         // We computed the correct state in the caller (above code), so just reference it.
5341         ASSERT(transformState);
5342         localTransformState = const_cast&lt;HitTestingTransformState*&gt;(transformState);
5343     } else if (transformState || has3DTransformedDescendant() || preserves3D()) {
5344         // We need transform state for the first time, or to offset the container state, so create it here.
5345         localTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState);
5346     }
5347 
5348     // Check for hit test on backface if backface-visibility is &#39;hidden&#39;
5349     if (localTransformState &amp;&amp; renderer().style().backfaceVisibility() == BackfaceVisibility::Hidden) {
5350         Optional&lt;TransformationMatrix&gt; invertedMatrix = localTransformState-&gt;m_accumulatedTransform.inverse();
5351         // If the z-vector of the matrix is negative, the back is facing towards the viewer.
5352         if (invertedMatrix &amp;&amp; invertedMatrix.value().m33() &lt; 0)
5353             return nullptr;
5354     }
5355 
5356     RefPtr&lt;HitTestingTransformState&gt; unflattenedTransformState = localTransformState;
5357     if (localTransformState &amp;&amp; !preserves3D()) {
5358         // Keep a copy of the pre-flattening state, for computing z-offsets for the container
5359         unflattenedTransformState = HitTestingTransformState::create(*localTransformState);
5360         // This layer is flattening, so flatten the state passed to descendants.
5361         localTransformState-&gt;flatten();
5362     }
5363 
5364     // The following are used for keeping track of the z-depth of the hit point of 3d-transformed
5365     // descendants.
5366     double localZOffset = -std::numeric_limits&lt;double&gt;::infinity();
5367     double* zOffsetForDescendantsPtr = nullptr;
5368     double* zOffsetForContentsPtr = nullptr;
5369 
5370     bool depthSortDescendants = false;
5371     if (preserves3D()) {
5372         depthSortDescendants = true;
5373         // Our layers can depth-test with our container, so share the z depth pointer with the container, if it passed one down.
5374         zOffsetForDescendantsPtr = zOffset ? zOffset : &amp;localZOffset;
5375         zOffsetForContentsPtr = zOffset ? zOffset : &amp;localZOffset;
5376     } else if (zOffset) {
5377         zOffsetForDescendantsPtr = nullptr;
5378         // Container needs us to give back a z offset for the hit layer.
5379         zOffsetForContentsPtr = zOffset;
5380     }
5381 
5382     // This variable tracks which layer the mouse ends up being inside.
5383     RenderLayer* candidateLayer = nullptr;
5384 #if ASSERT_ENABLED
5385     LayerListMutationDetector mutationChecker(*this);
5386 #endif
5387 
5388     // Begin by walking our list of positive layers from highest z-index down to the lowest z-index.
5389     auto* hitLayer = hitTestList(positiveZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5390                                         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5391     if (hitLayer) {
5392         if (!depthSortDescendants)
5393             return hitLayer;
5394         candidateLayer = hitLayer;
5395     }
5396 
5397     // Now check our overflow objects.
5398     hitLayer = hitTestList(normalFlowLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5399                            localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5400     if (hitLayer) {
5401         if (!depthSortDescendants)
5402             return hitLayer;
5403         candidateLayer = hitLayer;
5404     }
5405 
5406     // Collect the fragments. This will compute the clip rectangles for each layer fragment.
5407     LayerFragments layerFragments;
5408     collectFragments(layerFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers, RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip,
5409         offsetFromAncestor(rootLayer));
5410 
5411     if (canResize() &amp;&amp; hitTestResizerInFragments(layerFragments, hitTestLocation)) {
5412         renderer().updateHitTestResult(result, hitTestLocation.point());
5413         return this;
5414     }
5415 
5416     // Next we want to see if the mouse pos is inside the child RenderObjects of the layer. Check
5417     // every fragment in reverse order.
5418     if (isSelfPaintingLayer()) {
5419         // Hit test with a temporary HitTestResult, because we only want to commit to &#39;result&#39; if we know we&#39;re frontmost.
5420         HitTestResult tempResult(result.hitTestLocation());
5421         bool insideFragmentForegroundRect = false;
5422         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestDescendants, insideFragmentForegroundRect)
5423             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5424             if (request.resultIsElementList())
5425                 result.append(tempResult, request);
5426             else
5427                 result = tempResult;
5428             if (!depthSortDescendants)
5429                 return this;
5430             // Foreground can depth-sort with descendant layers, so keep this as a candidate.
5431             candidateLayer = this;
5432         } else if (insideFragmentForegroundRect &amp;&amp; request.resultIsElementList())
5433             result.append(tempResult, request);
5434     }
5435 
5436     // Now check our negative z-index children.
5437     hitLayer = hitTestList(negativeZOrderLayers(), rootLayer, request, result, hitTestRect, hitTestLocation,
5438         localTransformState.get(), zOffsetForDescendantsPtr, zOffset, unflattenedTransformState.get(), depthSortDescendants);
5439     if (hitLayer) {
5440         if (!depthSortDescendants)
5441             return hitLayer;
5442         candidateLayer = hitLayer;
5443     }
5444 
5445     // If we found a layer, return. Child layers, and foreground always render in front of background.
5446     if (candidateLayer)
5447         return candidateLayer;
5448 
5449     if (isSelfPaintingLayer()) {
5450         HitTestResult tempResult(result.hitTestLocation());
5451         bool insideFragmentBackgroundRect = false;
5452         if (hitTestContentsForFragments(layerFragments, request, tempResult, hitTestLocation, HitTestSelf, insideFragmentBackgroundRect)
5453             &amp;&amp; isHitCandidate(this, false, zOffsetForContentsPtr, unflattenedTransformState.get())) {
5454             if (request.resultIsElementList())
5455                 result.append(tempResult, request);
5456             else
5457                 result = tempResult;
5458             return this;
5459         }
5460         if (insideFragmentBackgroundRect &amp;&amp; request.resultIsElementList())
5461             result.append(tempResult, request);
5462     }
5463 
5464     return nullptr;
5465 }
5466 
5467 bool RenderLayer::hitTestContentsForFragments(const LayerFragments&amp; layerFragments, const HitTestRequest&amp; request, HitTestResult&amp; result,
5468     const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter, bool&amp; insideClipRect) const
5469 {
5470     if (layerFragments.isEmpty())
5471         return false;
5472 
5473     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5474         const LayerFragment&amp; fragment = layerFragments.at(i);
5475         if ((hitTestFilter == HitTestSelf &amp;&amp; !fragment.backgroundRect.intersects(hitTestLocation))
5476             || (hitTestFilter == HitTestDescendants &amp;&amp; !fragment.foregroundRect.intersects(hitTestLocation)))
5477             continue;
5478         insideClipRect = true;
5479         if (hitTestContents(request, result, fragment.layerBounds, hitTestLocation, hitTestFilter))
5480             return true;
5481     }
5482 
5483     return false;
5484 }
5485 
5486 bool RenderLayer::hitTestResizerInFragments(const LayerFragments&amp; layerFragments, const HitTestLocation&amp; hitTestLocation) const
5487 {
5488     if (layerFragments.isEmpty())
5489         return false;
5490 
5491     for (int i = layerFragments.size() - 1; i &gt;= 0; --i) {
5492         const LayerFragment&amp; fragment = layerFragments.at(i);
5493         if (fragment.backgroundRect.intersects(hitTestLocation) &amp;&amp; resizerCornerRect(*this, snappedIntRect(fragment.layerBounds)).contains(hitTestLocation.roundedPoint()))
5494             return true;
5495     }
5496 
5497     return false;
5498 }
5499 
5500 RenderLayer* RenderLayer::hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5501     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset)
5502 {
5503     LayerFragments enclosingPaginationFragments;
5504     LayoutSize offsetOfPaginationLayerFromRoot;
5505     RenderLayer* paginatedLayer = enclosingPaginationLayer(IncludeCompositedPaginatedLayers);
5506     LayoutRect transformedExtent = transparencyClipBox(*this, paginatedLayer, HitTestingTransparencyClipBox, RootOfTransparencyClipBox);
5507     paginatedLayer-&gt;collectFragments(enclosingPaginationFragments, rootLayer, hitTestRect, IncludeCompositedPaginatedLayers,
5508         RootRelativeClipRects, IncludeOverlayScrollbarSize, RespectOverflowClip, offsetOfPaginationLayerFromRoot, &amp;transformedExtent);
5509 
5510     for (int i = enclosingPaginationFragments.size() - 1; i &gt;= 0; --i) {
5511         const LayerFragment&amp; fragment = enclosingPaginationFragments.at(i);
5512 
5513         // Apply the page/column clip for this fragment, as well as any clips established by layers in between us and
5514         // the enclosing pagination layer.
5515         LayoutRect clipRect = fragment.backgroundRect.rect();
5516 
5517         // Now compute the clips within a given fragment
5518         if (parent() != paginatedLayer) {
5519             offsetOfPaginationLayerFromRoot = toLayoutSize(paginatedLayer-&gt;convertToLayerCoords(rootLayer, toLayoutPoint(offsetOfPaginationLayerFromRoot)));
5520 
5521             ClipRectsContext clipRectsContext(paginatedLayer, RootRelativeClipRects, IncludeOverlayScrollbarSize);
5522             LayoutRect parentClipRect = backgroundClipRect(clipRectsContext).rect();
5523             parentClipRect.move(fragment.paginationOffset + offsetOfPaginationLayerFromRoot);
5524             clipRect.intersect(parentClipRect);
5525         }
5526 
5527         if (!hitTestLocation.intersects(clipRect))
5528             continue;
5529 
5530         RenderLayer* hitLayer = hitTestLayerByApplyingTransform(rootLayer, containerLayer, request, result, hitTestRect, hitTestLocation,
5531             transformState, zOffset, fragment.paginationOffset);
5532         if (hitLayer)
5533             return hitLayer;
5534     }
5535 
5536     return nullptr;
5537 }
5538 
5539 RenderLayer* RenderLayer::hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp; request, HitTestResult&amp; result,
5540     const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation, const HitTestingTransformState* transformState, double* zOffset,
5541     const LayoutSize&amp; translationOffset)
5542 {
5543     // Create a transform state to accumulate this transform.
5544     Ref&lt;HitTestingTransformState&gt; newTransformState = createLocalTransformState(rootLayer, containerLayer, hitTestRect, hitTestLocation, transformState, translationOffset);
5545 
5546     // If the transform can&#39;t be inverted, then don&#39;t hit test this layer at all.
5547     if (!newTransformState-&gt;m_accumulatedTransform.isInvertible())
5548         return nullptr;
5549 
5550     // Compute the point and the hit test rect in the coords of this layer by using the values
5551     // from the transformState, which store the point and quad in the coords of the last flattened
5552     // layer, and the accumulated transform which lets up map through preserve-3d layers.
5553     //
5554     // We can&#39;t just map hitTestLocation and hitTestRect because they may have been flattened (losing z)
5555     // by our container.
5556     FloatPoint localPoint = newTransformState-&gt;mappedPoint();
5557     FloatQuad localPointQuad = newTransformState-&gt;mappedQuad();
5558     LayoutRect localHitTestRect = newTransformState-&gt;boundsOfMappedArea();
5559     HitTestLocation newHitTestLocation;
5560     if (hitTestLocation.isRectBasedTest())
5561         newHitTestLocation = HitTestLocation(localPoint, localPointQuad);
5562     else
5563         newHitTestLocation = HitTestLocation(localPoint);
5564 
5565     // Now do a hit test with the root layer shifted to be us.
5566     return hitTestLayer(this, containerLayer, request, result, localHitTestRect, newHitTestLocation, true, newTransformState.ptr(), zOffset);
5567 }
5568 
5569 bool RenderLayer::hitTestContents(const HitTestRequest&amp; request, HitTestResult&amp; result, const LayoutRect&amp; layerBounds, const HitTestLocation&amp; hitTestLocation, HitTestFilter hitTestFilter) const
5570 {
5571     ASSERT(isSelfPaintingLayer() || hasSelfPaintingLayerDescendant());
5572 
5573     if (!renderer().hitTest(request, result, hitTestLocation, toLayoutPoint(layerBounds.location() - renderBoxLocation()), hitTestFilter)) {
5574         // It&#39;s wrong to set innerNode, but then claim that you didn&#39;t hit anything, unless it is
5575         // a rect-based test.
5576         ASSERT(!result.innerNode() || (request.resultIsElementList() &amp;&amp; result.listBasedTestResult().size()));
5577         return false;
5578     }
5579 
5580     // For positioned generated content, we might still not have a
5581     // node by the time we get to the layer level, since none of
5582     // the content in the layer has an element. So just walk up
5583     // the tree.
5584     if (!result.innerNode() || !result.innerNonSharedNode()) {
5585         if (isOutOfFlowRenderFragmentedFlow()) {
5586             // The flowthread doesn&#39;t have an enclosing element, so when hitting the layer of the
5587             // flowthread (e.g. the descent area of the RootInlineBox for the image flowed alone
5588             // inside the flow thread) we&#39;re letting the hit testing continue so it will hit the region.
5589             return false;
5590         }
5591 
5592         Element* e = enclosingElement();
5593         if (!result.innerNode())
5594             result.setInnerNode(e);
5595         if (!result.innerNonSharedNode())
5596             result.setInnerNonSharedNode(e);
5597     }
5598 
5599     return true;
5600 }
5601 
5602 RenderLayer* RenderLayer::hitTestList(LayerList layerIterator, RenderLayer* rootLayer,
5603                                       const HitTestRequest&amp; request, HitTestResult&amp; result,
5604                                       const LayoutRect&amp; hitTestRect, const HitTestLocation&amp; hitTestLocation,
5605                                       const HitTestingTransformState* transformState,
5606                                       double* zOffsetForDescendants, double* zOffset,
5607                                       const HitTestingTransformState* unflattenedTransformState,
5608                                       bool depthSortDescendants)
5609 {
5610     if (layerIterator.begin() == layerIterator.end())
5611         return nullptr;
5612 
5613     if (!hasSelfPaintingLayerDescendant())
5614         return nullptr;
5615 
5616     RenderLayer* resultLayer = nullptr;
5617 
5618     for (auto iter = layerIterator.rbegin(); iter != layerIterator.rend(); ++iter) {
5619         auto* childLayer = *iter;
5620 
5621         HitTestResult tempResult(result.hitTestLocation());
5622         auto* hitLayer = childLayer-&gt;hitTestLayer(rootLayer, this, request, tempResult, hitTestRect, hitTestLocation, false, transformState, zOffsetForDescendants);
5623 
5624         // If it is a list-based test, we can safely append the temporary result since it might had hit
5625         // nodes but not necesserily had hitLayer set.
5626         ASSERT(!result.isRectBasedTest() || request.resultIsElementList());
5627         if (request.resultIsElementList())
5628             result.append(tempResult, request);
5629 
5630         if (isHitCandidate(hitLayer, depthSortDescendants, zOffset, unflattenedTransformState)) {
5631             resultLayer = hitLayer;
5632             if (!request.resultIsElementList())
5633                 result = tempResult;
5634             if (!depthSortDescendants)
5635                 break;
5636         }
5637     }
5638 
5639     return resultLayer;
5640 }
5641 
5642 Ref&lt;ClipRects&gt; RenderLayer::updateClipRects(const ClipRectsContext&amp; clipRectsContext)
5643 {
5644     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5645     ASSERT(clipRectsType &lt; NumCachedClipRectsTypes);
5646     if (m_clipRectsCache) {
5647         if (auto* clipRects = m_clipRectsCache-&gt;getClipRects(clipRectsType, clipRectsContext.respectOverflowClip)) {
5648             ASSERT(clipRectsContext.rootLayer == m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType]);
5649             ASSERT(m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] == clipRectsContext.overlayScrollbarSizeRelevancy);
5650 
5651 #ifdef CHECK_CACHED_CLIP_RECTS
5652             // This code is useful to check cached clip rects, but is too expensive to leave enabled in debug builds by default.
5653             ClipRectsContext tempContext(clipRectsContext);
5654             tempContext.clipRectsType = TemporaryClipRects;
5655             Ref&lt;ClipRects&gt; tempClipRects = ClipRects::create();
5656             calculateClipRects(tempContext, tempClipRects);
5657             ASSERT(tempClipRects.get() == *clipRects);
5658 #endif
5659             return *clipRects; // We have the correct cached value.
5660         }
5661     }
5662 
5663     if (!m_clipRectsCache)
5664         m_clipRectsCache = makeUnique&lt;ClipRectsCache&gt;();
5665 #if ASSERT_ENABLED
5666     m_clipRectsCache-&gt;m_clipRectsRoot[clipRectsType] = clipRectsContext.rootLayer;
5667     m_clipRectsCache-&gt;m_scrollbarRelevancy[clipRectsType] = clipRectsContext.overlayScrollbarSizeRelevancy;
5668 #endif
5669 
5670     RefPtr&lt;ClipRects&gt; parentClipRects;
5671     // For transformed layers, the root layer was shifted to be us, so there is no need to
5672     // examine the parent. We want to cache clip rects with us as the root.
5673     if (clipRectsContext.rootLayer != this &amp;&amp; parent())
5674         parentClipRects = this-&gt;parentClipRects(clipRectsContext);
5675 
5676     auto clipRects = ClipRects::create();
5677     calculateClipRects(clipRectsContext, clipRects);
5678 
5679     if (parentClipRects &amp;&amp; *parentClipRects == clipRects) {
5680         m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, parentClipRects.copyRef());
5681         return parentClipRects.releaseNonNull();
5682     }
5683     m_clipRectsCache-&gt;setClipRects(clipRectsType, clipRectsContext.respectOverflowClip, clipRects.copyRef());
5684     return clipRects;
5685 }
5686 
5687 ClipRects* RenderLayer::clipRects(const ClipRectsContext&amp; context) const
5688 {
5689     ASSERT(context.clipRectsType &lt; NumCachedClipRectsTypes);
5690     if (!m_clipRectsCache)
5691         return nullptr;
5692     return m_clipRectsCache-&gt;getClipRects(context.clipRectsType, context.respectOverflowClip);
5693 }
5694 
5695 bool RenderLayer::clipCrossesPaintingBoundary() const
5696 {
5697     return parent()-&gt;enclosingPaginationLayer(IncludeCompositedPaginatedLayers) != enclosingPaginationLayer(IncludeCompositedPaginatedLayers)
5698         || parent()-&gt;enclosingCompositingLayerForRepaint() != enclosingCompositingLayerForRepaint();
5699 }
5700 
5701 void RenderLayer::calculateClipRects(const ClipRectsContext&amp; clipRectsContext, ClipRects&amp; clipRects) const
5702 {
5703     if (!parent()) {
5704         // The root layer&#39;s clip rect is always infinite.
5705         clipRects.reset();
5706         return;
5707     }
5708 
5709     ClipRectsType clipRectsType = clipRectsContext.clipRectsType;
5710     bool useCached = clipRectsType != TemporaryClipRects;
5711 
5712     // For transformed layers, the root layer was shifted to be us, so there is no need to
5713     // examine the parent. We want to cache clip rects with us as the root.
5714     RenderLayer* parentLayer = clipRectsContext.rootLayer != this ? parent() : nullptr;
5715 
5716     // Ensure that our parent&#39;s clip has been calculated so that we can examine the values.
5717     if (parentLayer) {
5718         if (useCached &amp;&amp; parentLayer-&gt;clipRects(clipRectsContext))
5719             clipRects = *parentLayer-&gt;clipRects(clipRectsContext);
5720         else {
5721             ClipRectsContext parentContext(clipRectsContext);
5722             parentContext.overlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize; // FIXME: why?
5723 
5724             if ((parentContext.clipRectsType != TemporaryClipRects &amp;&amp; parentContext.clipRectsType != AbsoluteClipRects) &amp;&amp; clipCrossesPaintingBoundary())
5725                 parentContext.clipRectsType = TemporaryClipRects;
5726 
5727             parentLayer-&gt;calculateClipRects(parentContext, clipRects);
5728         }
5729     } else
5730         clipRects.reset();
5731 
5732     // A fixed object is essentially the root of its containing block hierarchy, so when
5733     // we encounter such an object, we reset our clip rects to the fixedClipRect.
5734     if (renderer().isFixedPositioned()) {
5735         clipRects.setPosClipRect(clipRects.fixedClipRect());
5736         clipRects.setOverflowClipRect(clipRects.fixedClipRect());
5737         clipRects.setFixed(true);
5738     } else if (renderer().isInFlowPositioned())
5739         clipRects.setPosClipRect(clipRects.overflowClipRect());
5740     else if (renderer().isAbsolutelyPositioned())
5741         clipRects.setOverflowClipRect(clipRects.posClipRect());
5742 
5743     // Update the clip rects that will be passed to child layers.
5744 #if PLATFORM(IOS_FAMILY)
5745     if (renderer().hasClipOrOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) {
5746 #else
5747     if ((renderer().hasOverflowClip() &amp;&amp; (clipRectsContext.respectOverflowClip == RespectOverflowClip || this != clipRectsContext.rootLayer)) || renderer().hasClip()) {
5748 #endif
5749         // This layer establishes a clip of some kind.
5750         LayoutPoint offset;
5751         if (!m_hasTransformedAncestor &amp;&amp; canUseOffsetFromAncestor())
5752             offset = toLayoutPoint(offsetFromAncestor(clipRectsContext.rootLayer, AdjustForColumns));
5753         else
5754             offset = LayoutPoint(renderer().localToContainerPoint(FloatPoint(), &amp;clipRectsContext.rootLayer-&gt;renderer()));
5755 
5756         if (clipRects.fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;renderer().view())
5757             offset -= toLayoutSize(renderer().view().frameView().scrollPositionForFixedPosition());
5758 
5759         if (renderer().hasOverflowClip()) {
5760             ClipRect newOverflowClip = downcast&lt;RenderBox&gt;(renderer()).overflowClipRectForChildLayers(offset, nullptr, clipRectsContext.overlayScrollbarSizeRelevancy);
5761             newOverflowClip.setAffectedByRadius(renderer().style().hasBorderRadius());
5762             clipRects.setOverflowClipRect(intersection(newOverflowClip, clipRects.overflowClipRect()));
5763             if (renderer().isPositioned())
5764                 clipRects.setPosClipRect(intersection(newOverflowClip, clipRects.posClipRect()));
5765         }
5766         if (renderer().hasClip()) {
5767             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(offset, nullptr);
5768             clipRects.setPosClipRect(intersection(newPosClip, clipRects.posClipRect()));
5769             clipRects.setOverflowClipRect(intersection(newPosClip, clipRects.overflowClipRect()));
5770             clipRects.setFixedClipRect(intersection(newPosClip, clipRects.fixedClipRect()));
5771         }
5772     }
5773 
5774     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; calculateClipRects &quot; &lt;&lt; clipRects);
5775 }
5776 
5777 Ref&lt;ClipRects&gt; RenderLayer::parentClipRects(const ClipRectsContext&amp; clipRectsContext) const
5778 {
5779     ASSERT(parent());
5780 
5781     auto temporaryParentClipRects = [&amp;](const ClipRectsContext&amp; clipContext) {
5782         auto parentClipRects = ClipRects::create();
5783         parent()-&gt;calculateClipRects(clipContext, parentClipRects);
5784         return parentClipRects;
5785     };
5786 
5787     if (clipRectsContext.clipRectsType == TemporaryClipRects)
5788         return temporaryParentClipRects(clipRectsContext);
5789 
5790     if (clipRectsContext.clipRectsType != AbsoluteClipRects &amp;&amp; clipCrossesPaintingBoundary()) {
5791         ClipRectsContext tempClipRectsContext(clipRectsContext);
5792         tempClipRectsContext.clipRectsType = TemporaryClipRects;
5793         return temporaryParentClipRects(tempClipRectsContext);
5794     }
5795 
5796     return parent()-&gt;updateClipRects(clipRectsContext);
5797 }
5798 
5799 static inline ClipRect backgroundClipRectForPosition(const ClipRects&amp; parentRects, PositionType position)
5800 {
5801     if (position == PositionType::Fixed)
5802         return parentRects.fixedClipRect();
5803 
5804     if (position == PositionType::Absolute)
5805         return parentRects.posClipRect();
5806 
5807     return parentRects.overflowClipRect();
5808 }
5809 
5810 ClipRect RenderLayer::backgroundClipRect(const ClipRectsContext&amp; clipRectsContext) const
5811 {
5812     ASSERT(parent());
5813     auto parentRects = parentClipRects(clipRectsContext);
5814     ClipRect backgroundClipRect = backgroundClipRectForPosition(parentRects, renderer().style().position());
5815     RenderView&amp; view = renderer().view();
5816     // Note: infinite clipRects should not be scrolled here, otherwise they will accidentally no longer be considered infinite.
5817     if (parentRects-&gt;fixed() &amp;&amp; &amp;clipRectsContext.rootLayer-&gt;renderer() == &amp;view &amp;&amp; !backgroundClipRect.isInfinite())
5818         backgroundClipRect.moveBy(view.frameView().scrollPositionForFixedPosition());
5819 
5820     LOG_WITH_STREAM(ClipRects, stream &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; this &lt;&lt; &quot; backgroundClipRect with context &quot; &lt;&lt; clipRectsContext &lt;&lt; &quot; returning &quot; &lt;&lt; backgroundClipRect);
5821     return backgroundClipRect;
5822 }
5823 
5824 void RenderLayer::calculateRects(const ClipRectsContext&amp; clipRectsContext, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
5825     ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const
5826 {
5827     if (clipRectsContext.rootLayer != this &amp;&amp; parent()) {
5828         backgroundRect = backgroundClipRect(clipRectsContext);
5829         backgroundRect.intersect(paintDirtyRect);
5830     } else
5831         backgroundRect = paintDirtyRect;
5832 
5833     LayoutSize offsetFromRootLocal = offsetFromRoot;
5834 
5835     if (clipRectsContext.rootLayer-&gt;isOutOfFlowRenderFragmentedFlow()) {
5836         LayoutPoint absPos = LayoutPoint(renderer().view().localToAbsolute(FloatPoint(), IsFixed));
5837         offsetFromRootLocal += toLayoutSize(absPos);
5838     }
5839 
5840     layerBounds = LayoutRect(toLayoutPoint(offsetFromRootLocal), size());
5841 
5842     foregroundRect = backgroundRect;
5843 
5844     // Update the clip rects that will be passed to child layers.
5845     if (renderer().hasClipOrOverflowClip()) {
5846         // This layer establishes a clip of some kind.
5847         if (renderer().hasOverflowClip() &amp;&amp; (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)) {
5848             foregroundRect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(toLayoutPoint(offsetFromRootLocal), nullptr, clipRectsContext.overlayScrollbarSizeRelevancy));
5849             if (renderer().style().hasBorderRadius())
5850                 foregroundRect.setAffectedByRadius(true);
5851         }
5852 
5853         if (renderer().hasClip()) {
5854             // Clip applies to *us* as well, so update the damageRect.
5855             LayoutRect newPosClip = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRootLocal), nullptr);
5856             backgroundRect.intersect(newPosClip);
5857             foregroundRect.intersect(newPosClip);
5858         }
5859 
5860         // If we establish a clip at all, then make sure our background rect is intersected with our layer&#39;s bounds including our visual overflow,
5861         // since any visual overflow like box-shadow or border-outset is not clipped by overflow:auto/hidden.
5862         if (renderBox()-&gt;hasVisualOverflow()) {
5863             // FIXME: Does not do the right thing with CSS regions yet, since we don&#39;t yet factor in the
5864             // individual region boxes as overflow.
5865             LayoutRect layerBoundsWithVisualOverflow = renderBox()-&gt;visualOverflowRect();
5866             renderBox()-&gt;flipForWritingMode(layerBoundsWithVisualOverflow); // Layers are in physical coordinates, so the overflow has to be flipped.
5867             layerBoundsWithVisualOverflow.move(offsetFromRootLocal);
5868             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5869                 backgroundRect.intersect(layerBoundsWithVisualOverflow);
5870         } else {
5871             // Shift the bounds to be for our region only.
5872             LayoutRect bounds = renderBox()-&gt;borderBoxRectInFragment(nullptr);
5873 
5874             bounds.move(offsetFromRootLocal);
5875             if (this != clipRectsContext.rootLayer || clipRectsContext.respectOverflowClip == RespectOverflowClip)
5876                 backgroundRect.intersect(bounds);
5877         }
5878     }
5879 }
5880 
5881 LayoutRect RenderLayer::childrenClipRect() const
5882 {
5883     // FIXME: border-radius not accounted for.
5884     // FIXME: Regions not accounted for.
5885     RenderLayer* clippingRootLayer = clippingRootForPainting();
5886     LayoutRect layerBounds;
5887     ClipRect backgroundRect;
5888     ClipRect foregroundRect;
5889     ClipRectsContext clipRectsContext(clippingRootLayer, TemporaryClipRects);
5890     // Need to use temporary clip rects, because the value of &#39;dontClipToOverflow&#39; may be different from the painting path (&lt;rdar://problem/11844909&gt;).
5891     calculateRects(clipRectsContext, LayoutRect::infiniteRect(), layerBounds, backgroundRect, foregroundRect, offsetFromAncestor(clipRectsContext.rootLayer));
5892     if (foregroundRect.rect().isInfinite())
5893         return renderer().view().unscaledDocumentRect();
5894 
5895     auto absoluteClippingRect = clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(foregroundRect.rect())).enclosingBoundingBox();
5896     return intersection(absoluteClippingRect, renderer().view().unscaledDocumentRect());
5897 }
5898 
5899 LayoutRect RenderLayer::clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const
5900 {
5901     LayoutRect layerBounds;
5902     ClipRect backgroundRect;
5903     ClipRect foregroundRect;
5904     auto clipRectType = !m_enclosingPaginationLayer || m_enclosingPaginationLayer == ancestor ? PaintingClipRects : TemporaryClipRects;
5905     ClipRectsContext clipRectsContext(ancestor, clipRectType);
5906     calculateRects(clipRectsContext, constrainingRect, layerBounds, backgroundRect, foregroundRect, offsetFromAncestor);
5907     return backgroundRect.rect();
5908 }
5909 
5910 LayoutRect RenderLayer::selfClipRect() const
5911 {
5912     // FIXME: border-radius not accounted for.
5913     // FIXME: Regions not accounted for.
5914     RenderLayer* clippingRootLayer = clippingRootForPainting();
5915     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromAncestor(clippingRootLayer), renderer().view().documentRect());
5916     return clippingRootLayer-&gt;renderer().localToAbsoluteQuad(FloatQuad(clipRect)).enclosingBoundingBox();
5917 }
5918 
5919 LayoutRect RenderLayer::localClipRect(bool&amp; clipExceedsBounds) const
5920 {
5921     clipExceedsBounds = false;
5922     // FIXME: border-radius not accounted for.
5923     // FIXME: Regions not accounted for.
5924     RenderLayer* clippingRootLayer = clippingRootForPainting();
5925     LayoutSize offsetFromRoot = offsetFromAncestor(clippingRootLayer);
5926     LayoutRect clipRect = clipRectRelativeToAncestor(clippingRootLayer, offsetFromRoot, LayoutRect::infiniteRect());
5927     if (clipRect.isInfinite())
5928         return clipRect;
5929 
5930     if (renderer().hasClip()) {
5931         // CSS clip may be larger than our border box.
5932         LayoutRect cssClipRect = downcast&lt;RenderBox&gt;(renderer()).clipRect(toLayoutPoint(offsetFromRoot), nullptr);
5933         clipExceedsBounds = !clipRect.contains(cssClipRect);
5934     }
5935 
5936     clipRect.move(-offsetFromRoot);
5937     return clipRect;
5938 }
5939 
5940 void RenderLayer::addBlockSelectionGapsBounds(const LayoutRect&amp; bounds)
5941 {
5942     m_blockSelectionGapsBounds.unite(enclosingIntRect(bounds));
5943 }
5944 
5945 void RenderLayer::clearBlockSelectionGapsBounds()
5946 {
5947     m_blockSelectionGapsBounds = IntRect();
5948     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5949         child-&gt;clearBlockSelectionGapsBounds();
5950 }
5951 
5952 void RenderLayer::repaintBlockSelectionGaps()
5953 {
5954     for (RenderLayer* child = firstChild(); child; child = child-&gt;nextSibling())
5955         child-&gt;repaintBlockSelectionGaps();
5956 
5957     if (m_blockSelectionGapsBounds.isEmpty())
5958         return;
5959 
5960     LayoutRect rect = m_blockSelectionGapsBounds;
5961     rect.moveBy(-scrollPosition());
5962     if (renderer().hasOverflowClip() &amp;&amp; !usesCompositedScrolling())
5963         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).overflowClipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5964     if (renderer().hasClip())
5965         rect.intersect(downcast&lt;RenderBox&gt;(renderer()).clipRect(LayoutPoint(), nullptr)); // FIXME: Regions not accounted for.
5966     if (!rect.isEmpty())
5967         renderer().repaintRectangle(rect);
5968 }
5969 
5970 bool RenderLayer::intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox) const
5971 {
5972     // Always examine the canvas and the root.
5973     // FIXME: Could eliminate the isDocumentElementRenderer() check if we fix background painting so that the RenderView
5974     // paints the root&#39;s background.
5975     if (isRenderViewLayer() || renderer().isDocumentElementRenderer())
5976         return true;
5977 
5978     if (damageRect.isInfinite())
5979         return true;
5980 
5981     if (damageRect.isEmpty())
5982         return false;
5983 
5984     // If we aren&#39;t an inline flow, and our layer bounds do intersect the damage rect, then we can return true.
5985     if (!renderer().isRenderInline() &amp;&amp; layerBounds.intersects(damageRect))
5986         return true;
5987 
5988     // Otherwise we need to compute the bounding box of this single layer and see if it intersects
5989     // the damage rect. It&#39;s possible the fragment computed the bounding box already, in which case we
5990     // can use the cached value.
5991     if (cachedBoundingBox)
5992         return cachedBoundingBox-&gt;intersects(damageRect);
5993 
5994     return boundingBox(rootLayer, offsetFromRoot).intersects(damageRect);
5995 }
5996 
5997 LayoutRect RenderLayer::localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
5998 {
5999     // There are three special cases we need to consider.
6000     // (1) Inline Flows.  For inline flows we will create a bounding box that fully encompasses all of the lines occupied by the
6001     // inline.  In other words, if some &lt;span&gt; wraps to three lines, we&#39;ll create a bounding box that fully encloses the
6002     // line boxes of all three lines (including overflow on those lines).
6003     // (2) Left/Top Overflow.  The width/height of layers already includes right/bottom overflow.  However, in the case of left/top
6004     // overflow, we have to create a bounding box that will extend to include this overflow.
6005     // (3) Floats.  When a layer has overhanging floats that it paints, we need to make sure to include these overhanging floats
6006     // as part of our bounding box.  We do this because we are the responsible layer for both hit testing and painting those
6007     // floats.
6008     LayoutRect result;
6009     if (renderer().isInline() &amp;&amp; is&lt;RenderInline&gt;(renderer()))
6010         result = downcast&lt;RenderInline&gt;(renderer()).linesVisualOverflowBoundingBox();
6011     else if (is&lt;RenderTableRow&gt;(renderer())) {
6012         auto&amp; tableRow = downcast&lt;RenderTableRow&gt;(renderer());
6013         // Our bounding box is just the union of all of our cells&#39; border/overflow rects.
6014         for (RenderTableCell* cell = tableRow.firstCell(); cell; cell = cell-&gt;nextCell()) {
6015             LayoutRect bbox = cell-&gt;borderBoxRect();
6016             result.unite(bbox);
6017             LayoutRect overflowRect = tableRow.visualOverflowRect();
6018             if (bbox != overflowRect)
6019                 result.unite(overflowRect);
6020         }
6021     } else {
6022         RenderBox* box = renderBox();
6023         ASSERT(box);
6024         if (!(flags &amp; DontConstrainForMask) &amp;&amp; box-&gt;hasMask()) {
6025             result = box-&gt;maskClipRect(LayoutPoint());
6026             box-&gt;flipForWritingMode(result); // The mask clip rect is in physical coordinates, so we have to flip, since localBoundingBox is not.
6027         } else
6028             result = box-&gt;visualOverflowRect();
6029     }
6030     return result;
6031 }
6032 
6033 LayoutRect RenderLayer::boundingBox(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
6034 {
6035     LayoutRect result = localBoundingBox(flags);
6036     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
6037         if (renderer().isBox())
6038             renderBox()-&gt;flipForWritingMode(result);
6039         else
6040             renderer().containingBlock()-&gt;flipForWritingMode(result);
6041     }
6042 
6043     PaginationInclusionMode inclusionMode = ExcludeCompositedPaginatedLayers;
6044     if (flags &amp; UseFragmentBoxesIncludingCompositing)
6045         inclusionMode = IncludeCompositedPaginatedLayers;
6046 
6047     const RenderLayer* paginationLayer = nullptr;
6048     if (flags.containsAny({ UseFragmentBoxesExcludingCompositing, UseFragmentBoxesIncludingCompositing }))
6049         paginationLayer = enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
6050 
6051     const RenderLayer* childLayer = this;
6052     bool isPaginated = paginationLayer;
6053     while (paginationLayer) {
6054         // Split our box up into the actual fragment boxes that render in the columns/pages and unite those together to
6055         // get our true bounding box.
6056         result.move(childLayer-&gt;offsetFromAncestor(paginationLayer));
6057 
6058         auto&amp; enclosingFragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(paginationLayer-&gt;renderer());
6059         result = enclosingFragmentedFlow.fragmentsBoundingBox(result);
6060 
6061         childLayer = paginationLayer;
6062         paginationLayer = paginationLayer-&gt;parent()-&gt;enclosingPaginationLayerInSubtree(ancestorLayer, inclusionMode);
6063     }
6064 
6065     if (isPaginated) {
6066         result.move(childLayer-&gt;offsetFromAncestor(ancestorLayer));
6067         return result;
6068     }
6069 
6070     result.move(offsetFromRoot);
6071     return result;
6072 }
6073 
6074 bool RenderLayer::getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp; bounds, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags) const
6075 {
6076     // The animation will override the display transform, so don&#39;t include it.
6077     auto boundsFlags = additionalFlags | (defaultCalculateLayerBoundsFlags() - IncludeSelfTransform);
6078 
6079     bounds = calculateLayerBounds(this, LayoutSize(), boundsFlags);
6080 
6081     LayoutRect animatedBounds = bounds;
6082     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
6083         if (auto* timeline = renderer().documentTimeline()) {
6084             if (timeline-&gt;computeExtentOfAnimation(renderer(), animatedBounds)) {
6085                 bounds = animatedBounds;
6086                 return true;
6087             }
6088         }
6089     } else {
6090         if (renderer().animation().computeExtentOfAnimation(renderer(), animatedBounds)) {
6091             bounds = animatedBounds;
6092             return true;
6093         }
6094     }
6095 
6096     return false;
6097 }
6098 
6099 IntRect RenderLayer::absoluteBoundingBox() const
6100 {
6101     const RenderLayer* rootLayer = root();
6102     return snappedIntRect(boundingBox(rootLayer, offsetFromAncestor(rootLayer)));
6103 }
6104 
6105 FloatRect RenderLayer::absoluteBoundingBoxForPainting() const
6106 {
6107     const RenderLayer* rootLayer = root();
6108     return snapRectToDevicePixels(boundingBox(rootLayer, offsetFromAncestor(rootLayer)), renderer().document().deviceScaleFactor());
6109 }
6110 
6111 LayoutRect RenderLayer::overlapBounds() const
6112 {
6113     if (overlapBoundsIncludeChildren())
6114         return calculateLayerBounds(this, { }, defaultCalculateLayerBoundsFlags() | IncludeFilterOutsets);
6115 
6116     return localBoundingBox();
6117 }
6118 
6119 LayoutRect RenderLayer::calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; flags) const
6120 {
6121     if (!isSelfPaintingLayer())
6122         return LayoutRect();
6123 
6124     // FIXME: This could be improved to do a check like hasVisibleNonCompositingDescendantLayers() (bug 92580).
6125     if ((flags &amp; ExcludeHiddenDescendants) &amp;&amp; this != ancestorLayer &amp;&amp; !hasVisibleContent() &amp;&amp; !hasVisibleDescendant())
6126         return LayoutRect();
6127 
6128     if (isRenderViewLayer()) {
6129         // The root layer is always just the size of the document.
6130         return renderer().view().unscaledDocumentRect();
6131     }
6132 
6133     LayoutRect boundingBoxRect = localBoundingBox(flags);
6134     if (renderer().view().frameView().hasFlippedBlockRenderers()) {
6135         if (is&lt;RenderBox&gt;(renderer()))
6136             downcast&lt;RenderBox&gt;(renderer()).flipForWritingMode(boundingBoxRect);
6137         else
6138             renderer().containingBlock()-&gt;flipForWritingMode(boundingBoxRect);
6139     }
6140 
6141     if (renderer().isDocumentElementRenderer()) {
6142         // If the root layer becomes composited (e.g. because some descendant with negative z-index is composited),
6143         // then it has to be big enough to cover the viewport in order to display the background. This is akin
6144         // to the code in RenderBox::paintRootBoxFillLayers().
6145         const FrameView&amp; frameView = renderer().view().frameView();
6146         boundingBoxRect.setWidth(std::max(boundingBoxRect.width(), frameView.contentsWidth() - boundingBoxRect.x()));
6147         boundingBoxRect.setHeight(std::max(boundingBoxRect.height(), frameView.contentsHeight() - boundingBoxRect.y()));
6148     }
6149 
6150     LayoutRect unionBounds = boundingBoxRect;
6151 
6152     if (flags &amp; UseLocalClipRectIfPossible) {
6153         bool clipExceedsBounds = false;
6154         LayoutRect localClipRect = this-&gt;localClipRect(clipExceedsBounds);
6155         if (!localClipRect.isInfinite() &amp;&amp; !clipExceedsBounds) {
6156             if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal))
6157                 localClipRect = transform()-&gt;mapRect(localClipRect);
6158 
6159             localClipRect.move(offsetFromAncestor(ancestorLayer));
6160             return localClipRect;
6161         }
6162     }
6163 
6164     // FIXME: should probably just pass &#39;flags&#39; down to descendants.
6165     auto descendantFlags = defaultCalculateLayerBoundsFlags() | (flags &amp; ExcludeHiddenDescendants) | (flags &amp; IncludeCompositedDescendants);
6166 
6167     const_cast&lt;RenderLayer*&gt;(this)-&gt;updateLayerListsIfNeeded();
6168 
6169     if (RenderLayer* reflection = reflectionLayer()) {
6170         if (!reflection-&gt;isComposited()) {
6171             LayoutRect childUnionBounds = reflection-&gt;calculateLayerBounds(this, reflection-&gt;offsetFromAncestor(this), descendantFlags);
6172             unionBounds.unite(childUnionBounds);
6173         }
6174     }
6175 
6176     ASSERT(isStackingContext() || !positiveZOrderLayers().size());
6177 
6178 #if ASSERT_ENABLED
6179     LayerListMutationDetector mutationChecker(const_cast&lt;RenderLayer&amp;&gt;(*this));
6180 #endif
6181 
6182     auto computeLayersUnion = [this, &amp;unionBounds, flags, descendantFlags] (const RenderLayer&amp; childLayer) {
6183         if (!(flags &amp; IncludeCompositedDescendants) &amp;&amp; (childLayer.isComposited() || childLayer.paintsIntoProvidedBacking()))
6184             return;
6185         LayoutRect childBounds = childLayer.calculateLayerBounds(this, childLayer.offsetFromAncestor(this), descendantFlags);
6186         // Ignore child layer (and behave as if we had overflow: hidden) when it is positioned off the parent layer so much
6187         // that we hit the max LayoutUnit value.
6188         unionBounds.checkedUnite(childBounds);
6189     };
6190 
6191     for (auto* childLayer : negativeZOrderLayers())
6192         computeLayersUnion(*childLayer);
6193 
6194     for (auto* childLayer : positiveZOrderLayers())
6195         computeLayersUnion(*childLayer);
6196 
6197     for (auto* childLayer : normalFlowLayers())
6198         computeLayersUnion(*childLayer);
6199 
6200     if (flags.contains(IncludeFilterOutsets) || (flags.contains(IncludePaintedFilterOutsets) &amp;&amp; paintsWithFilters()))
6201         unionBounds += filterOutsets();
6202 
6203     if ((flags &amp; IncludeSelfTransform) &amp;&amp; paintsWithTransform(PaintBehavior::Normal)) {
6204         TransformationMatrix* affineTrans = transform();
6205         boundingBoxRect = affineTrans-&gt;mapRect(boundingBoxRect);
6206         unionBounds = affineTrans-&gt;mapRect(unionBounds);
6207     }
6208     unionBounds.move(offsetFromRoot);
6209     return unionBounds;
6210 }
6211 
6212 void RenderLayer::clearClipRectsIncludingDescendants(ClipRectsType typeToClear)
6213 {
6214     // FIXME: it&#39;s not clear how this layer not having clip rects guarantees that no descendants have any.
6215     if (!m_clipRectsCache)
6216         return;
6217 
6218     clearClipRects(typeToClear);
6219 
6220     for (RenderLayer* l = firstChild(); l; l = l-&gt;nextSibling())
6221         l-&gt;clearClipRectsIncludingDescendants(typeToClear);
6222 }
6223 
6224 void RenderLayer::clearClipRects(ClipRectsType typeToClear)
6225 {
6226     if (typeToClear == AllClipRectTypes)
6227         m_clipRectsCache = nullptr;
6228     else {
6229         ASSERT(typeToClear &lt; NumCachedClipRectsTypes);
6230         m_clipRectsCache-&gt;setClipRects(typeToClear, RespectOverflowClip, nullptr);
6231         m_clipRectsCache-&gt;setClipRects(typeToClear, IgnoreOverflowClip, nullptr);
6232     }
6233 }
6234 
6235 RenderLayerBacking* RenderLayer::ensureBacking()
6236 {
6237     if (!m_backing) {
6238         m_backing = makeUnique&lt;RenderLayerBacking&gt;(*this);
6239         compositor().layerBecameComposited(*this);
6240 
6241         updateFilterPaintingStrategy();
6242     }
6243     return m_backing.get();
6244 }
6245 
6246 void RenderLayer::clearBacking(bool layerBeingDestroyed)
6247 {
6248     if (!m_backing)
6249         return;
6250 
6251     if (!renderer().renderTreeBeingDestroyed())
6252         compositor().layerBecameNonComposited(*this);
6253 
6254     m_backing-&gt;willBeDestroyed();
6255     m_backing = nullptr;
6256 
6257     if (!layerBeingDestroyed)
6258         updateFilterPaintingStrategy();
6259 }
6260 
6261 bool RenderLayer::hasCompositedMask() const
6262 {
6263     return m_backing &amp;&amp; m_backing-&gt;hasMaskLayer();
6264 }
6265 
6266 GraphicsLayer* RenderLayer::layerForHorizontalScrollbar() const
6267 {
6268     return m_backing ? m_backing-&gt;layerForHorizontalScrollbar() : nullptr;
6269 }
6270 
6271 GraphicsLayer* RenderLayer::layerForVerticalScrollbar() const
6272 {
6273     return m_backing ? m_backing-&gt;layerForVerticalScrollbar() : nullptr;
6274 }
6275 
6276 GraphicsLayer* RenderLayer::layerForScrollCorner() const
6277 {
6278     return m_backing ? m_backing-&gt;layerForScrollCorner() : nullptr;
6279 }
6280 
6281 bool RenderLayer::paintsWithTransform(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
6282 {
6283     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6284     return transform() &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || paintsToWindow);
6285 }
6286 
6287 bool RenderLayer::shouldPaintMask(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
6288 {
6289     if (!renderer().hasMask())
6290         return false;
6291 
6292     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6293     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
6294         return true;
6295 
6296     return paintFlags.contains(PaintLayerPaintingCompositingMaskPhase);
6297 }
6298 
6299 bool RenderLayer::shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt; paintBehavior, OptionSet&lt;PaintLayerFlag&gt; paintFlags) const
6300 {
6301     if (!renderer().hasClipPath())
6302         return false;
6303 
6304     bool paintsToWindow = !isComposited() || backing()-&gt;paintsIntoWindow();
6305     if (paintsToWindow || (paintBehavior &amp; PaintBehavior::FlattenCompositingLayers))
6306         return true;
6307 
6308     return paintFlags.contains(PaintLayerPaintingCompositingClipPathPhase);
6309 }
6310 
6311 bool RenderLayer::scrollingMayRevealBackground() const
6312 {
6313     return scrollsOverflow() || usesCompositedScrolling();
6314 }
6315 
6316 bool RenderLayer::backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const
6317 {
6318     if (!isSelfPaintingLayer() &amp;&amp; !hasSelfPaintingLayerDescendant())
6319         return false;
6320 
6321     if (paintsWithTransparency(PaintBehavior::Normal))
6322         return false;
6323 
6324     if (renderer().isDocumentElementRenderer()) {
6325         // Normally the document element doens&#39;t have a layer.  If it does have a layer, its background propagates to the RenderView
6326         // so this layer doesn&#39;t draw it.
6327         return false;
6328     }
6329 
6330     // We can&#39;t use hasVisibleContent(), because that will be true if our renderer is hidden, but some child
6331     // is visible and that child doesn&#39;t cover the entire rect.
6332     if (renderer().style().visibility() != Visibility::Visible)
6333         return false;
6334 
6335     if (paintsWithFilters() &amp;&amp; renderer().style().filter().hasFilterThatAffectsOpacity())
6336         return false;
6337 
6338     // FIXME: Handle simple transforms.
6339     if (paintsWithTransform(PaintBehavior::Normal))
6340         return false;
6341 
6342     // FIXME: Remove this check.
6343     // This function should not be called when layer-lists are dirty.
6344     // It is somehow getting triggered during style update.
6345     if (zOrderListsDirty() || normalFlowListDirty())
6346         return false;
6347 
6348     // Table painting is special; a table paints its sections.
6349     if (renderer().isTablePart())
6350         return false;
6351 
6352     // FIXME: We currently only check the immediate renderer,
6353     // which will miss many cases.
6354     if (renderer().backgroundIsKnownToBeOpaqueInRect(localRect))
6355         return true;
6356 
6357     // We can&#39;t consult child layers if we clip, since they might cover
6358     // parts of the rect that are clipped out.
6359     if (renderer().hasOverflowClip())
6360         return false;
6361 
6362     return listBackgroundIsKnownToBeOpaqueInRect(positiveZOrderLayers(), localRect)
6363         || listBackgroundIsKnownToBeOpaqueInRect(negativeZOrderLayers(), localRect)
6364         || listBackgroundIsKnownToBeOpaqueInRect(normalFlowLayers(), localRect);
6365 }
6366 
6367 bool RenderLayer::listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp; list, const LayoutRect&amp; localRect) const
6368 {
6369     if (list.begin() == list.end())
6370         return false;
6371 
6372     for (auto iter = list.rbegin(); iter != list.rend(); ++iter) {
6373         const auto* childLayer = *iter;
6374         if (childLayer-&gt;isComposited())
6375             continue;
6376 
6377         if (!childLayer-&gt;canUseOffsetFromAncestor())
6378             continue;
6379 
6380         LayoutRect childLocalRect(localRect);
6381         childLocalRect.move(-childLayer-&gt;offsetFromAncestor(this));
6382 
6383         if (childLayer-&gt;backgroundIsKnownToBeOpaqueInRect(childLocalRect))
6384             return true;
6385     }
6386     return false;
6387 }
6388 
6389 void RenderLayer::repaintIncludingDescendants()
6390 {
6391     renderer().repaint();
6392     for (RenderLayer* current = firstChild(); current; current = current-&gt;nextSibling())
6393         current-&gt;repaintIncludingDescendants();
6394 }
6395 
6396 void RenderLayer::setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer shouldClip)
6397 {
6398     ASSERT(isComposited());
6399     if (backing()-&gt;paintsIntoWindow()) {
6400         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6401         // repaint to the native view system.
6402         renderer().view().repaintViewRectangle(absoluteBoundingBox());
6403     } else
6404         backing()-&gt;setContentsNeedDisplay(shouldClip);
6405 }
6406 
6407 void RenderLayer::setBackingNeedsRepaintInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
6408 {
6409     // https://bugs.webkit.org/show_bug.cgi?id=61159 describes an unreproducible crash here,
6410     // so assert but check that the layer is composited.
6411     ASSERT(isComposited());
6412     if (!isComposited() || backing()-&gt;paintsIntoWindow()) {
6413         // If we&#39;re trying to repaint the placeholder document layer, propagate the
6414         // repaint to the native view system.
6415         LayoutRect absRect(r);
6416         absRect.move(offsetFromAncestor(root()));
6417 
6418         renderer().view().repaintViewRectangle(absRect);
6419     } else
6420         backing()-&gt;setContentsNeedDisplayInRect(r, shouldClip);
6421 }
6422 
6423 // Since we&#39;re only painting non-composited layers, we know that they all share the same repaintContainer.
6424 void RenderLayer::repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer)
6425 {
6426     renderer().repaintUsingContainer(repaintContainer, renderer().clippedOverflowRectForRepaint(repaintContainer));
6427 
6428     for (RenderLayer* curr = firstChild(); curr; curr = curr-&gt;nextSibling()) {
6429         if (!curr-&gt;isComposited())
6430             curr-&gt;repaintIncludingNonCompositingDescendants(repaintContainer);
6431     }
6432 }
6433 
6434 bool RenderLayer::shouldBeSelfPaintingLayer() const
6435 {
6436     if (!isNormalFlowOnly())
6437         return true;
6438 
6439     return hasOverlayScrollbars()
6440         || canUseCompositedScrolling()
6441         || renderer().isTableRow()
6442         || renderer().isCanvas()
6443         || renderer().isVideo()
6444         || renderer().isEmbeddedObject()
6445         || (renderer().isRenderImage() &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage())
6446         || renderer().isRenderIFrame()
6447         || renderer().isInFlowRenderFragmentedFlow();
6448 }
6449 
6450 void RenderLayer::updateSelfPaintingLayer()
6451 {
6452     bool isSelfPaintingLayer = shouldBeSelfPaintingLayer();
6453     if (m_isSelfPaintingLayer == isSelfPaintingLayer)
6454         return;
6455 
6456     m_isSelfPaintingLayer = isSelfPaintingLayer;
6457     if (!parent())
6458         return;
6459     if (isSelfPaintingLayer)
6460         parent()-&gt;setAncestorChainHasSelfPaintingLayerDescendant();
6461     else
6462         parent()-&gt;dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
6463 }
6464 
6465 static bool hasVisibleBoxDecorationsOrBackground(const RenderElement&amp; renderer)
6466 {
6467     return renderer.hasVisibleBoxDecorations() || renderer.style().hasOutline();
6468 }
6469 
6470 static bool styleHasSmoothingTextMode(const RenderStyle&amp; style)
6471 {
6472     FontSmoothingMode smoothingMode = style.fontDescription().fontSmoothing();
6473     return smoothingMode == FontSmoothingMode::AutoSmoothing || smoothingMode == FontSmoothingMode::SubpixelAntialiased;
6474 }
6475 
6476 // Constrain the depth and breadth of the search for performance.
6477 static const unsigned maxRendererTraversalCount = 200;
6478 
6479 static void determineNonLayerDescendantsPaintedContent(const RenderElement&amp; renderer, unsigned&amp; renderersTraversed, RenderLayer::PaintedContentRequest&amp; request)
6480 {
6481     for (const auto&amp; child : childrenOfType&lt;RenderObject&gt;(renderer)) {
6482         if (++renderersTraversed &gt; maxRendererTraversalCount) {
6483             request.makeStatesUndetermined();
6484             return;
6485         }
6486 
6487         if (is&lt;RenderText&gt;(child)) {
6488             const auto&amp; renderText = downcast&lt;RenderText&gt;(child);
6489             if (!renderText.hasRenderedText())
6490                 continue;
6491 
6492             if (renderer.style().userSelect() != UserSelect::None)
6493                 request.setHasPaintedContent();
6494 
6495             if (!renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()) {
6496                 request.setHasPaintedContent();
6497 
6498                 if (request.needToDetermineSubpixelAntialiasedTextState() &amp;&amp; styleHasSmoothingTextMode(child.style()))
6499                     request.setHasSubpixelAntialiasedText();
6500             }
6501 
6502             if (request.isSatisfied())
6503                 return;
6504         }
6505 
6506         if (!is&lt;RenderElement&gt;(child))
6507             continue;
6508 
6509         const RenderElement&amp; renderElementChild = downcast&lt;RenderElement&gt;(child);
6510 
6511         if (is&lt;RenderLayerModelObject&gt;(renderElementChild) &amp;&amp; downcast&lt;RenderLayerModelObject&gt;(renderElementChild).hasSelfPaintingLayer())
6512             continue;
6513 
6514         if (hasVisibleBoxDecorationsOrBackground(renderElementChild)) {
6515             request.setHasPaintedContent();
6516             if (request.isSatisfied())
6517                 return;
6518         }
6519 
6520         if (is&lt;RenderReplaced&gt;(renderElementChild)) {
6521             request.setHasPaintedContent();
6522 
6523             if (is&lt;RenderImage&gt;(renderElementChild) &amp;&amp; request.needToDetermineSubpixelAntialiasedTextState()) {
6524                 auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderElementChild);
6525                 // May draw text if showing alt text, or image is an SVG image or PDF image.
6526                 if ((imageRenderer.isShowingAltText() || imageRenderer.hasNonBitmapImage()) &amp;&amp; styleHasSmoothingTextMode(child.style()))
6527                     request.setHasSubpixelAntialiasedText();
6528             }
6529 
6530             if (request.isSatisfied())
6531                 return;
6532         }
6533 
6534         determineNonLayerDescendantsPaintedContent(renderElementChild, renderersTraversed, request);
6535         if (request.isSatisfied())
6536             return;
6537     }
6538 }
6539 
6540 bool RenderLayer::hasNonEmptyChildRenderers(PaintedContentRequest&amp; request) const
6541 {
6542     unsigned renderersTraversed = 0;
6543     determineNonLayerDescendantsPaintedContent(renderer(), renderersTraversed, request);
6544     return request.probablyHasPaintedContent();
6545 }
6546 
6547 bool RenderLayer::hasVisibleBoxDecorationsOrBackground() const
6548 {
6549     return WebCore::hasVisibleBoxDecorationsOrBackground(renderer());
6550 }
6551 
6552 bool RenderLayer::hasVisibleBoxDecorations() const
6553 {
6554     if (!hasVisibleContent())
6555         return false;
6556 
6557     return hasVisibleBoxDecorationsOrBackground() || hasOverflowControls();
6558 }
6559 
6560 bool RenderLayer::isVisuallyNonEmpty(PaintedContentRequest* request) const
6561 {
6562     ASSERT(!m_visibleDescendantStatusDirty);
6563 
6564     if (!hasVisibleContent() || !renderer().style().opacity())
6565         return false;
6566 
6567     if (renderer().isRenderReplaced() || hasOverflowControls()) {
6568         if (!request)
6569             return true;
6570 
6571         request-&gt;setHasPaintedContent();
6572         if (request-&gt;isSatisfied())
6573             return true;
6574     }
6575 
6576     if (hasVisibleBoxDecorationsOrBackground()) {
6577         if (!request)
6578             return true;
6579 
6580         request-&gt;setHasPaintedContent();
6581         if (request-&gt;isSatisfied())
6582             return true;
6583     }
6584 
6585     PaintedContentRequest localRequest;
6586     if (!request)
6587         request = &amp;localRequest;
6588 
6589     return hasNonEmptyChildRenderers(*request);
6590 }
6591 
6592 void RenderLayer::updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle)
6593 {
6594     // Overflow are a box concept.
6595     RenderBox* box = renderBox();
6596     if (!box)
6597         return;
6598 
6599     // List box parts handle the scrollbars by themselves so we have nothing to do.
6600     if (box-&gt;style().appearance() == ListboxPart)
6601         return;
6602 
6603     Overflow overflowX = box-&gt;style().overflowX();
6604     Overflow overflowY = box-&gt;style().overflowY();
6605 
6606     // To avoid doing a relayout in updateScrollbarsAfterLayout, we try to keep any automatic scrollbar that was already present.
6607     bool needsHorizontalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasHorizontalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), HorizontalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), HorizontalScrollbar));
6608     bool needsVerticalScrollbar = box-&gt;hasOverflowClip() &amp;&amp; ((hasVerticalScrollbar() &amp;&amp; styleDefinesAutomaticScrollbar(box-&gt;style(), VerticalScrollbar)) || styleRequiresScrollbar(box-&gt;style(), VerticalScrollbar));
6609     setHasHorizontalScrollbar(needsHorizontalScrollbar);
6610     setHasVerticalScrollbar(needsVerticalScrollbar);
6611 
6612     // With non-overlay overflow:scroll, scrollbars are always visible but may be disabled.
6613     // When switching to another value, we need to re-enable them (see bug 11985).
6614     if (m_hBar &amp;&amp; needsHorizontalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowX() == Overflow::Scroll &amp;&amp; overflowX != Overflow::Scroll)
6615         m_hBar-&gt;setEnabled(true);
6616 
6617     if (m_vBar &amp;&amp; needsVerticalScrollbar &amp;&amp; oldStyle &amp;&amp; oldStyle-&gt;overflowY() == Overflow::Scroll &amp;&amp; overflowY != Overflow::Scroll)
6618         m_vBar-&gt;setEnabled(true);
6619 
6620     if (!m_scrollDimensionsDirty)
6621         updateScrollableAreaSet(hasScrollableHorizontalOverflow() || hasScrollableVerticalOverflow());
6622 }
6623 
6624 void RenderLayer::styleChanged(StyleDifference diff, const RenderStyle* oldStyle)
6625 {
6626     setIsNormalFlowOnly(shouldBeNormalFlowOnly());
6627 
6628     if (setIsCSSStackingContext(shouldBeCSSStackingContext())) {
6629 #if ENABLE(CSS_COMPOSITING)
6630         if (parent()) {
6631             if (isCSSStackingContext()) {
6632                 if (!hasNotIsolatedBlendingDescendantsStatusDirty() &amp;&amp; hasNotIsolatedBlendingDescendants())
6633                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6634             } else {
6635                 if (hasNotIsolatedBlendingDescendantsStatusDirty())
6636                     parent()-&gt;dirtyAncestorChainHasBlendingDescendants();
6637                 else if (hasNotIsolatedBlendingDescendants())
6638                     parent()-&gt;updateAncestorChainHasBlendingDescendants();
6639             }
6640         }
6641 #endif
6642     }
6643 
6644     // FIXME: RenderLayer already handles visibility changes through our visibility dirty bits. This logic could
6645     // likely be folded along with the rest.
6646     if (oldStyle) {
6647         if (oldStyle-&gt;usedZIndex() != renderer().style().usedZIndex() || oldStyle-&gt;visibility() != renderer().style().visibility()) {
6648             dirtyStackingContextZOrderLists();
6649             if (isStackingContext())
6650                 dirtyZOrderLists();
6651         }
6652     }
6653 
6654     if (renderer().isHTMLMarquee() &amp;&amp; renderer().style().marqueeBehavior() != MarqueeBehavior::None &amp;&amp; renderer().isBox()) {
6655         if (!m_marquee)
6656             m_marquee = makeUnique&lt;RenderMarquee&gt;(this);
6657         m_marquee-&gt;updateMarqueeStyle();
6658     } else if (m_marquee)
6659         m_marquee = nullptr;
6660 
6661     updateScrollbarsAfterStyleChange(oldStyle);
6662     // Overlay scrollbars can make this layer self-painting so we need
6663     // to recompute the bit once scrollbars have been updated.
6664     updateSelfPaintingLayer();
6665 
6666     if (!hasReflection() &amp;&amp; m_reflection)
6667         removeReflection();
6668     else if (hasReflection()) {
6669         if (!m_reflection)
6670             createReflection();
6671         else
6672             m_reflection-&gt;setStyle(createReflectionStyle());
6673     }
6674 
6675     // FIXME: Need to detect a swap from custom to native scrollbars (and vice versa).
6676     if (m_hBar)
6677         m_hBar-&gt;styleChanged();
6678     if (m_vBar)
6679         m_vBar-&gt;styleChanged();
6680 
6681     updateScrollCornerStyle();
6682     updateResizerStyle();
6683 
6684     updateDescendantDependentFlags();
6685     updateTransform();
6686 #if ENABLE(CSS_COMPOSITING)
6687     updateBlendMode();
6688 #endif
6689     updateFiltersAfterStyleChange();
6690 
6691     compositor().layerStyleChanged(diff, *this, oldStyle);
6692 
6693     updateFilterPaintingStrategy();
6694 
6695 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(TOUCH_EVENTS)
6696     if (diff == StyleDifference::RecompositeLayer || diff &gt;= StyleDifference::LayoutPositionedMovementOnly)
6697         renderer().document().invalidateRenderingDependentRegions();
6698 #else
6699     UNUSED_PARAM(diff);
6700 #endif
6701 }
6702 
6703 void RenderLayer::updateScrollableAreaSet(bool hasOverflow)
6704 {
6705     FrameView&amp; frameView = renderer().view().frameView();
6706 
6707     bool isVisibleToHitTest = renderer().visibleToHitTesting();
6708     if (HTMLFrameOwnerElement* owner = frameView.frame().ownerElement())
6709         isVisibleToHitTest &amp;= owner-&gt;renderer() &amp;&amp; owner-&gt;renderer()-&gt;visibleToHitTesting();
6710 
6711     bool isScrollable = hasOverflow &amp;&amp; isVisibleToHitTest;
6712     bool addedOrRemoved = false;
6713 
6714     ASSERT(m_registeredScrollableArea == frameView.containsScrollableArea(this));
6715 
6716     if (isScrollable) {
6717         if (!m_registeredScrollableArea) {
6718             addedOrRemoved = frameView.addScrollableArea(this);
6719             m_registeredScrollableArea = true;
6720         }
6721     } else if (m_registeredScrollableArea) {
6722         addedOrRemoved = frameView.removeScrollableArea(this);
6723         m_registeredScrollableArea = false;
6724     }
6725 
6726 #if ENABLE(IOS_TOUCH_EVENTS)
6727     if (addedOrRemoved) {
6728         if (isScrollable &amp;&amp; !canUseCompositedScrolling())
6729             registerAsTouchEventListenerForScrolling();
6730         else {
6731             // We only need the touch listener for unaccelerated overflow scrolling, so if we became
6732             // accelerated, remove ourselves as a touch event listener.
6733             unregisterAsTouchEventListenerForScrolling();
6734         }
6735     }
6736 #else
6737     UNUSED_VARIABLE(addedOrRemoved);
6738 #endif
6739 }
6740 
6741 void RenderLayer::updateScrollCornerStyle()
6742 {
6743     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6744     auto corner = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::ScrollbarCorner }, &amp;actualRenderer-&gt;style()) : nullptr;
6745 
6746     if (!corner) {
6747         clearScrollCorner();
6748         return;
6749     }
6750 
6751     if (!m_scrollCorner) {
6752         m_scrollCorner = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*corner));
6753         // FIXME: A renderer should be a child of its parent!
6754         m_scrollCorner-&gt;setParent(&amp;renderer());
6755         m_scrollCorner-&gt;initializeStyle();
6756     } else
6757         m_scrollCorner-&gt;setStyle(WTFMove(*corner));
6758 }
6759 
6760 void RenderLayer::clearScrollCorner()
6761 {
6762     if (!m_scrollCorner)
6763         return;
6764     m_scrollCorner-&gt;setParent(nullptr);
6765     m_scrollCorner = nullptr;
6766 }
6767 
6768 void RenderLayer::updateResizerStyle()
6769 {
6770     RenderElement* actualRenderer = rendererForScrollbar(renderer());
6771     auto resizer = renderer().hasOverflowClip() ? actualRenderer-&gt;getUncachedPseudoStyle({ PseudoId::Resizer }, &amp;actualRenderer-&gt;style()) : nullptr;
6772 
6773     if (!resizer) {
6774         clearResizer();
6775         return;
6776     }
6777 
6778     if (!m_resizer) {
6779         m_resizer = createRenderer&lt;RenderScrollbarPart&gt;(renderer().document(), WTFMove(*resizer));
6780         // FIXME: A renderer should be a child of its parent!
6781         m_resizer-&gt;setParent(&amp;renderer());
6782         m_resizer-&gt;initializeStyle();
6783     } else
6784         m_resizer-&gt;setStyle(WTFMove(*resizer));
6785 }
6786 
6787 void RenderLayer::clearResizer()
6788 {
6789     if (!m_resizer)
6790         return;
6791     m_resizer-&gt;setParent(nullptr);
6792     m_resizer = nullptr;
6793 }
6794 
6795 RenderLayer* RenderLayer::reflectionLayer() const
6796 {
6797     return m_reflection ? m_reflection-&gt;layer() : nullptr;
6798 }
6799 
6800 bool RenderLayer::isReflectionLayer(const RenderLayer&amp; layer) const
6801 {
6802     return m_reflection ? &amp;layer == m_reflection-&gt;layer() : false;
6803 }
6804 
6805 void RenderLayer::createReflection()
6806 {
6807     ASSERT(!m_reflection);
6808     m_reflection = createRenderer&lt;RenderReplica&gt;(renderer().document(), createReflectionStyle());
6809     // FIXME: A renderer should be a child of its parent!
6810     m_reflection-&gt;setParent(&amp;renderer()); // We create a 1-way connection.
6811     m_reflection-&gt;initializeStyle();
6812 }
6813 
6814 void RenderLayer::removeReflection()
6815 {
6816     if (!m_reflection-&gt;renderTreeBeingDestroyed())
6817         m_reflection-&gt;removeLayers(this);
6818 
6819     m_reflection-&gt;setParent(nullptr);
6820     m_reflection = nullptr;
6821 }
6822 
6823 RenderStyle RenderLayer::createReflectionStyle()
6824 {
6825     auto newStyle = RenderStyle::create();
6826     newStyle.inheritFrom(renderer().style());
6827 
6828     // Map in our transform.
6829     TransformOperations transform;
6830     switch (renderer().style().boxReflect()-&gt;direction()) {
6831     case ReflectionDirection::Below:
6832         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6833         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6834         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6835         break;
6836     case ReflectionDirection::Above:
6837         transform.operations().append(ScaleTransformOperation::create(1.0, -1.0, ScaleTransformOperation::SCALE));
6838         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), Length(100., Percent), TransformOperation::TRANSLATE));
6839         transform.operations().append(TranslateTransformOperation::create(Length(0, Fixed), renderer().style().boxReflect()-&gt;offset(), TransformOperation::TRANSLATE));
6840         break;
6841     case ReflectionDirection::Right:
6842         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6843         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6844         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6845         break;
6846     case ReflectionDirection::Left:
6847         transform.operations().append(ScaleTransformOperation::create(-1.0, 1.0, ScaleTransformOperation::SCALE));
6848         transform.operations().append(TranslateTransformOperation::create(Length(100., Percent), Length(0, Fixed), TransformOperation::TRANSLATE));
6849         transform.operations().append(TranslateTransformOperation::create(renderer().style().boxReflect()-&gt;offset(), Length(0, Fixed), TransformOperation::TRANSLATE));
6850         break;
6851     }
6852     newStyle.setTransform(transform);
6853 
6854     // Map in our mask.
6855     newStyle.setMaskBoxImage(renderer().style().boxReflect()-&gt;mask());
6856 
6857     // Style has transform and mask, so needs to be stacking context.
6858     newStyle.setUsedZIndex(0);
6859 
6860     return newStyle;
6861 }
6862 
6863 void RenderLayer::ensureLayerFilters()
6864 {
6865     if (m_filters)
6866         return;
6867 
6868     m_filters = makeUnique&lt;RenderLayerFilters&gt;(*this);
6869 }
6870 
6871 void RenderLayer::clearLayerFilters()
6872 {
6873     m_filters = nullptr;
6874 }
6875 
6876 void RenderLayer::updateFiltersAfterStyleChange()
6877 {
6878     if (!hasFilter()) {
6879         clearLayerFilters();
6880         return;
6881     }
6882 
6883     // Add the filter as a client to this renderer, unless we are a RenderLayer accommodating
6884     // an SVG. In that case it takes care of its own resource management for filters.
6885     if (renderer().style().filter().hasReferenceFilter() &amp;&amp; !renderer().isSVGRoot()) {
6886         ensureLayerFilters();
6887         m_filters-&gt;updateReferenceFilterClients(renderer().style().filter());
6888     } else if (m_filters)
6889         m_filters-&gt;removeReferenceFilterClients();
6890 }
6891 
6892 void RenderLayer::updateFilterPaintingStrategy()
6893 {
6894     // RenderLayerFilters is only used to render the filters in software mode,
6895     // so we always need to run updateFilterPaintingStrategy() after the composited
6896     // mode might have changed for this layer.
6897     if (!paintsWithFilters()) {
6898         // Don&#39;t delete the whole filter info here, because we might use it
6899         // for loading SVG reference filter files.
6900         if (m_filters)
6901             m_filters-&gt;setFilter(nullptr);
6902 
6903         // Early-return only if we *don&#39;t* have reference filters.
6904         // For reference filters, we still want the FilterEffect graph built
6905         // for us, even if we&#39;re composited.
6906         if (!renderer().style().filter().hasReferenceFilter())
6907             return;
6908     }
6909 
6910     ensureLayerFilters();
6911     m_filters-&gt;buildFilter(renderer(), page().deviceScaleFactor(), renderer().settings().acceleratedFiltersEnabled() ? RenderingMode::Accelerated : RenderingMode::Unaccelerated);
6912 }
6913 
<a name="4" id="anc4"></a><span class="line-removed">6914 void RenderLayer::filterNeedsRepaint()</span>
<span class="line-removed">6915 {</span>
<span class="line-removed">6916     // We use the enclosing element so that we recalculate style for the ancestor of an anonymous object.</span>
<span class="line-removed">6917     if (Element* element = enclosingElement()) {</span>
<span class="line-removed">6918         // FIXME: This really shouldn&#39;t have to invalidate layer composition, but tests like css3/filters/effect-reference-delete.html fail if that doesn&#39;t happen.</span>
<span class="line-removed">6919         element-&gt;invalidateStyleAndLayerComposition();</span>
<span class="line-removed">6920     }</span>
<span class="line-removed">6921     renderer().repaint();</span>
<span class="line-removed">6922 }</span>
<span class="line-removed">6923 </span>
6924 IntOutsets RenderLayer::filterOutsets() const
6925 {
6926     if (m_filters)
6927         return m_filters-&gt;filter() ? m_filters-&gt;filter()-&gt;outsets() : IntOutsets();
6928     return renderer().style().filterOutsets();
6929 }
6930 
6931 bool RenderLayer::isTransparentRespectingParentFrames() const
6932 {
6933     static const double minimumVisibleOpacity = 0.01;
6934 
6935     float currentOpacity = 1;
6936     for (auto* layer = this; layer; layer = parentLayerCrossFrame(*layer)) {
6937         currentOpacity *= layer-&gt;renderer().style().opacity();
6938         if (currentOpacity &lt; minimumVisibleOpacity)
6939             return true;
6940     }
6941 
6942     return false;
6943 }
6944 
6945 void RenderLayer::invalidateEventRegion()
6946 {
6947 #if PLATFORM(IOS_FAMILY)
6948     auto* compositingLayer = enclosingCompositingLayerForRepaint();
6949     if (!compositingLayer)
6950         return;
6951 
6952     auto maintainsEventRegion = [&amp;] {
6953         // UI side scroll overlap testing.
6954         if (!compositingLayer-&gt;isRenderViewLayer())
6955             return true;
6956 #if ENABLE(POINTER_EVENTS)
6957         // UI side touch-action resolution.
6958         if (renderer().document().mayHaveElementsWithNonAutoTouchAction())
6959             return true;
6960 #endif
6961         return false;
6962     };
6963 
6964     if (!maintainsEventRegion())
6965         return;
6966 
6967     compositingLayer-&gt;setNeedsCompositingConfigurationUpdate();
6968 #endif
6969 }
6970 
6971 TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp; ts, ClipRectsType clipRectsType)
6972 {
6973     switch (clipRectsType) {
6974     case PaintingClipRects: ts &lt;&lt; &quot;painting&quot;; break;
6975     case RootRelativeClipRects: ts &lt;&lt; &quot;root-relative&quot;; break;
6976     case AbsoluteClipRects: ts &lt;&lt; &quot;absolute&quot;; break;
6977     case TemporaryClipRects: ts &lt;&lt; &quot;temporary&quot;; break;
6978     case NumCachedClipRectsTypes:
6979     case AllClipRectTypes:
6980         ts &lt;&lt; &quot;?&quot;;
6981         break;
6982     }
6983     return ts;
6984 }
6985 
6986 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer&amp; layer)
6987 {
6988     ts &lt;&lt; &quot;RenderLayer &quot; &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layer.size();
6989     if (layer.transform())
6990         ts &lt;&lt; &quot; has transform&quot;;
6991     if (layer.hasFilter())
6992         ts &lt;&lt; &quot; has filter&quot;;
6993     if (layer.hasBackdropFilter())
6994         ts &lt;&lt; &quot; has backdrop filter&quot;;
6995     if (layer.hasBlendMode())
6996         ts &lt;&lt; &quot; has blend mode&quot;;
6997     if (layer.isolatesBlending())
6998         ts &lt;&lt; &quot; isolates blending&quot;;
6999     if (layer.isComposited())
7000         ts &lt;&lt; &quot; &quot; &lt;&lt; *layer.backing();
7001     return ts;
7002 }
7003 
7004 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayer::ClipRectsContext&amp; context)
7005 {
7006     ts.dumpProperty(&quot;root layer:&quot;, context.rootLayer);
7007     ts.dumpProperty(&quot;type:&quot;, context.clipRectsType);
7008     ts.dumpProperty(&quot;overflow-clip:&quot;, context.respectOverflowClip == IgnoreOverflowClip ? &quot;ignore&quot; : &quot;respect&quot;);
7009 
7010     return ts;
7011 }
7012 
7013 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, IndirectCompositingReason reason)
7014 {
7015     switch (reason) {
7016     case IndirectCompositingReason::None: ts &lt;&lt; &quot;none&quot;; break;
7017     case IndirectCompositingReason::Clipping: ts &lt;&lt; &quot;clipping&quot;; break;
7018     case IndirectCompositingReason::Stacking: ts &lt;&lt; &quot;stacking&quot;; break;
7019     case IndirectCompositingReason::OverflowScrollPositioning: ts &lt;&lt; &quot;overflow positioning&quot;; break;
7020     case IndirectCompositingReason::Overlap: ts &lt;&lt; &quot;overlap&quot;; break;
7021     case IndirectCompositingReason::BackgroundLayer: ts &lt;&lt; &quot;background layer&quot;; break;
7022     case IndirectCompositingReason::GraphicalEffect: ts &lt;&lt; &quot;graphical effect&quot;; break;
7023     case IndirectCompositingReason::Perspective: ts &lt;&lt; &quot;perspective&quot;; break;
7024     case IndirectCompositingReason::Preserve3D: ts &lt;&lt; &quot;preserve-3d&quot;; break;
7025     }
7026 
7027     return ts;
7028 }
7029 
7030 } // namespace WebCore
7031 
7032 #if ENABLE(TREE_DEBUGGING)
7033 
7034 void showLayerTree(const WebCore::RenderLayer* layer)
7035 {
7036     if (!layer)
7037         return;
7038 
7039     WTF::String output = externalRepresentation(&amp;layer-&gt;renderer().frame(), {
7040         WebCore::RenderAsTextFlag::ShowAllLayers,
7041         WebCore::RenderAsTextFlag::ShowLayerNesting,
7042         WebCore::RenderAsTextFlag::ShowCompositedLayers,
7043         WebCore::RenderAsTextFlag::ShowOverflow,
7044         WebCore::RenderAsTextFlag::ShowSVGGeometry,
7045         WebCore::RenderAsTextFlag::ShowLayerFragments,
7046         WebCore::RenderAsTextFlag::ShowAddresses,
7047         WebCore::RenderAsTextFlag::ShowIDAndClass,
7048         WebCore::RenderAsTextFlag::DontUpdateLayout,
7049         WebCore::RenderAsTextFlag::ShowLayoutState,
7050     });
7051     fprintf(stderr, &quot;\n%s\n&quot;, output.utf8().data());
7052 }
7053 
7054 void showLayerTree(const WebCore::RenderObject* renderer)
7055 {
7056     if (!renderer)
7057         return;
7058     showLayerTree(renderer-&gt;enclosingLayer());
7059 }
7060 
7061 static void outputPaintOrderTreeLegend(TextStream&amp; stream)
7062 {
7063     stream.nextLine();
7064     stream &lt;&lt; &quot;(S)tacking Context/(F)orced SC/O(P)portunistic SC, (N)ormal flow only, (O)verflow clip, (A)lpha (opacity or mask), has (B)lend mode, (I)solates blending, (T)ransform-ish, (F)ilter, Fi(X)ed position, Behaves as fi(x)ed, (C)omposited, (P)rovides backing/uses (p)rovided backing/paints to (a)ncestor, (c)omposited descendant, (s)scrolling ancestor, (t)transformed ancestor\n&quot;
7065         &quot;Dirty (z)-lists, Dirty (n)ormal flow lists\n&quot;
7066         &quot;Traversal needs: requirements (t)raversal on descendants, (b)acking or hierarchy traversal on descendants, (r)equirements traversal on all descendants, requirements traversal on all (s)ubsequent layers, (h)ierarchy traversal on all descendants, update of paint (o)rder children\n&quot;
7067         &quot;Update needs:    post-(l)ayout requirements, (g)eometry, (k)ids geometry, (c)onfig, layer conne(x)ion, (s)crolling tree\n&quot;;
7068     stream.nextLine();
7069 }
7070 
7071 static void outputIdent(TextStream&amp; stream, unsigned depth)
7072 {
7073     unsigned i = 0;
7074     while (++i &lt;= depth * 2)
7075         stream &lt;&lt; &quot; &quot;;
7076 }
7077 
7078 static void outputPaintOrderTreeRecursive(TextStream&amp; stream, const WebCore::RenderLayer&amp; layer, const char* prefix, unsigned depth = 0)
7079 {
7080     stream &lt;&lt; (layer.isCSSStackingContext() ? &quot;S&quot; : (layer.isForcedStackingContext() ? &quot;F&quot; : (layer.isOpportunisticStackingContext() ? &quot;P&quot; : &quot;-&quot;)));
7081     stream &lt;&lt; (layer.isNormalFlowOnly() ? &quot;N&quot; : &quot;-&quot;);
7082     stream &lt;&lt; (layer.renderer().hasOverflowClip() ? &quot;O&quot; : &quot;-&quot;);
7083     stream &lt;&lt; (layer.isTransparent() ? &quot;A&quot; : &quot;-&quot;);
7084     stream &lt;&lt; (layer.hasBlendMode() ? &quot;B&quot; : &quot;-&quot;);
7085     stream &lt;&lt; (layer.isolatesBlending() ? &quot;I&quot; : &quot;-&quot;);
7086     stream &lt;&lt; (layer.renderer().hasTransformRelatedProperty() ? &quot;T&quot; : &quot;-&quot;);
7087     stream &lt;&lt; (layer.hasFilter() ? &quot;F&quot; : &quot;-&quot;);
7088     stream &lt;&lt; (layer.renderer().isFixedPositioned() ? &quot;X&quot; : &quot;-&quot;);
7089     stream &lt;&lt; (layer.behavesAsFixed() ? &quot;x&quot; : &quot;-&quot;);
7090     stream &lt;&lt; (layer.isComposited() ? &quot;C&quot; : &quot;-&quot;);
7091 
7092     auto compositedPaintingDestinationString = [&amp;layer]() {
7093         if (layer.paintsIntoProvidedBacking())
7094             return &quot;p&quot;;
7095 
7096         if (!layer.isComposited())
7097             return &quot;-&quot;;
7098 
7099         if (layer.backing()-&gt;hasBackingSharingLayers())
7100             return &quot;P&quot;;
7101 
7102         if (layer.backing()-&gt;paintsIntoCompositedAncestor())
7103             return &quot;a&quot;;
7104 
7105         return &quot;-&quot;;
7106     };
7107 
7108     stream &lt;&lt; compositedPaintingDestinationString();
7109     stream &lt;&lt; (layer.hasCompositingDescendant() ? &quot;c&quot; : &quot;-&quot;);
7110     stream &lt;&lt; (layer.hasCompositedScrollingAncestor() ? &quot;s&quot; : &quot;-&quot;);
7111     stream &lt;&lt; (layer.hasTransformedAncestor() ? &quot;t&quot; : &quot;-&quot;);
7112 
7113     stream &lt;&lt; &quot; &quot;;
7114 
7115     stream &lt;&lt; (layer.zOrderListsDirty() ? &quot;z&quot; : &quot;-&quot;);
7116     stream &lt;&lt; (layer.normalFlowListDirty() ? &quot;n&quot; : &quot;-&quot;);
7117 
7118     stream &lt;&lt; &quot; &quot;;
7119 
7120     stream &lt;&lt; (layer.hasDescendantNeedingCompositingRequirementsTraversal() ? &quot;t&quot; : &quot;-&quot;);
7121     stream &lt;&lt; (layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal() ? &quot;b&quot; : &quot;-&quot;);
7122     stream &lt;&lt; (layer.descendantsNeedCompositingRequirementsTraversal() ? &quot;r&quot; : &quot;-&quot;);
7123     stream &lt;&lt; (layer.subsequentLayersNeedCompositingRequirementsTraversal() ? &quot;s&quot; : &quot;-&quot;);
7124     stream &lt;&lt; (layer.descendantsNeedUpdateBackingAndHierarchyTraversal() ? &quot;h&quot; : &quot;-&quot;);
7125     stream &lt;&lt; (layer.needsCompositingPaintOrderChildrenUpdate() ? &quot;o&quot; : &quot;-&quot;);
7126 
7127     stream &lt;&lt; &quot; &quot;;
7128 
7129     stream &lt;&lt; (layer.needsPostLayoutCompositingUpdate() ? &quot;l&quot; : &quot;-&quot;);
7130     stream &lt;&lt; (layer.needsCompositingGeometryUpdate() ? &quot;g&quot; : &quot;-&quot;);
7131     stream &lt;&lt; (layer.childrenNeedCompositingGeometryUpdate() ? &quot;k&quot; : &quot;-&quot;);
7132     stream &lt;&lt; (layer.needsCompositingConfigurationUpdate() ? &quot;c&quot; : &quot;-&quot;);
7133     stream &lt;&lt; (layer.needsCompositingLayerConnection() ? &quot;x&quot; : &quot;-&quot;);
7134     stream &lt;&lt; (layer.needsScrollingTreeUpdate() ? &quot;s&quot; : &quot;-&quot;);
7135 
7136     stream &lt;&lt; &quot; &quot;;
7137 
7138     outputIdent(stream, depth);
7139 
7140     stream &lt;&lt; prefix;
7141 
7142     auto layerRect = layer.rect();
7143 
7144     stream &lt;&lt; &amp;layer &lt;&lt; &quot; &quot; &lt;&lt; layerRect;
7145     if (layer.isComposited()) {
7146         auto&amp; backing = *layer.backing();
7147         stream &lt;&lt; &quot; (layerID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID() &lt;&lt; &quot;)&quot;;
7148 
7149         if (layer.indirectCompositingReason() != WebCore::IndirectCompositingReason::None)
7150             stream &lt;&lt; &quot; &quot; &lt;&lt; layer.indirectCompositingReason();
7151 
7152         auto scrollingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Scrolling);
7153         auto frameHostingNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::FrameHosting);
7154         auto viewportConstrainedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::ViewportConstrained);
7155         auto positionedNodeID = backing.scrollingNodeIDForRole(WebCore::ScrollCoordinationRole::Positioning);
7156 
7157         if (scrollingNodeID || frameHostingNodeID || viewportConstrainedNodeID || positionedNodeID) {
7158             stream &lt;&lt; &quot; {&quot;;
7159             bool first = true;
7160             if (scrollingNodeID) {
7161                 stream &lt;&lt; &quot;sc &quot; &lt;&lt; scrollingNodeID;
7162                 first = false;
7163             }
7164 
7165             if (frameHostingNodeID) {
7166                 if (!first)
7167                     stream &lt;&lt; &quot;, &quot;;
7168                 stream &lt;&lt; &quot;fh &quot; &lt;&lt; frameHostingNodeID;
7169                 first = false;
7170             }
7171 
7172             if (viewportConstrainedNodeID) {
7173                 if (!first)
7174                     stream &lt;&lt; &quot;, &quot;;
7175                 stream &lt;&lt; &quot;vc &quot; &lt;&lt; viewportConstrainedNodeID;
7176                 first = false;
7177             }
7178 
7179             if (positionedNodeID) {
7180                 if (!first)
7181                     stream &lt;&lt; &quot;, &quot;;
7182                 stream &lt;&lt; &quot;pos &quot; &lt;&lt; positionedNodeID;
7183             }
7184 
7185             stream &lt;&lt; &quot;}&quot;;
7186         }
7187     }
7188     stream &lt;&lt; &quot; &quot; &lt;&lt; layer.name();
7189     stream.nextLine();
7190 
7191     const_cast&lt;WebCore::RenderLayer&amp;&gt;(layer).updateLayerListsIfNeeded();
7192 
7193     for (auto* child : layer.negativeZOrderLayers())
7194         outputPaintOrderTreeRecursive(stream, *child, &quot;- &quot;, depth + 1);
7195 
7196     for (auto* child : layer.normalFlowLayers())
7197         outputPaintOrderTreeRecursive(stream, *child, &quot;n &quot;, depth + 1);
7198 
7199     for (auto* child : layer.positiveZOrderLayers())
7200         outputPaintOrderTreeRecursive(stream, *child, &quot;+ &quot;, depth + 1);
7201 }
7202 
7203 void showPaintOrderTree(const WebCore::RenderLayer* layer)
7204 {
7205     TextStream stream;
7206     outputPaintOrderTreeLegend(stream);
7207     if (layer)
7208         outputPaintOrderTreeRecursive(stream, *layer, &quot;&quot;);
7209 
7210     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
7211 }
7212 
7213 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
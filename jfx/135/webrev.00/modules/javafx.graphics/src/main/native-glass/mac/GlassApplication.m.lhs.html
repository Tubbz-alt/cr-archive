<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-glass/mac/GlassApplication.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &quot;common.h&quot;
  27 #import &quot;com_sun_glass_ui_mac_MacApplication.h&quot;
  28 #import &quot;com_sun_glass_events_KeyEvent.h&quot;
  29 
  30 
  31 #import &quot;GlassMacros.h&quot;
  32 #import &quot;GlassApplication.h&quot;
  33 #import &quot;GlassHelper.h&quot;
  34 #import &quot;GlassKey.h&quot;
  35 #import &quot;GlassScreen.h&quot;
  36 #import &quot;GlassWindow.h&quot;
  37 #import &quot;GlassTouches.h&quot;
  38 #import &quot;RemoteLayerSupport.h&quot;
  39 
  40 #import &quot;ProcessInfo.h&quot;
  41 #import &lt;Security/SecRequirement.h&gt;
  42 
  43 //#define VERBOSE
  44 #ifndef VERBOSE
  45     #define LOG(MSG, ...)
  46 #else
  47     #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  48 #endif
  49 
  50 //#define VERBOSE_LOAD
  51 
  52 static BOOL shouldKeepRunningNestedLoop = YES;
  53 static jobject nestedLoopReturnValue = NULL;
  54 static BOOL isFullScreenExitingLoop = NO;
  55 static NSMutableDictionary * keyCodeForCharMap = nil;
  56 static BOOL isEmbedded = NO;
  57 static BOOL disableSyncRendering = NO;
  58 
  59 #ifdef STATIC_BUILD
  60 jint JNICALL JNI_OnLoad_glass(JavaVM *vm, void *reserved)
  61 #else
  62 jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved)
  63 #endif
  64 {
  65     pthread_key_create(&amp;GlassThreadDataKey, NULL);
  66 
  67     memset(&amp;javaIDs, 0, sizeof(javaIDs));
  68     MAIN_JVM = vm;
  69     return JNI_VERSION_1_4;
  70 }
  71 
  72 #pragma mark --- GlassRunnable
  73 
  74 @interface GlassRunnable : NSObject
  75 {
  76     jobject jRunnable;
  77 }
  78 
  79 - (id)initWithRunnable:(jobject)runnable;
  80 - (void)run;
  81 
  82 @end
  83 
  84 @implementation GlassRunnable
  85 
  86 - (id)initWithRunnable:(jobject)runnable
  87 {
  88     self-&gt;jRunnable = runnable;
  89     return self;
  90 }
  91 
  92 - (void)run
  93 {
  94     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  95     {
  96         assert(pthread_main_np() == 1);
  97         JNIEnv *env = jEnv;
  98         if (env != NULL)
  99         {
 100             (*env)-&gt;CallVoidMethod(env, self-&gt;jRunnable, jRunnableRun);
 101             GLASS_CHECK_EXCEPTION(env);
 102         }
 103 
 104         [self release];
 105     }
 106     [pool drain];
 107 }
 108 
 109 - (void)dealloc
 110 {
 111     assert(pthread_main_np() == 1);
 112     JNIEnv *env = jEnv;
 113     if (env != NULL)
 114     {
 115         (*env)-&gt;DeleteGlobalRef(env, self-&gt;jRunnable);
 116     }
 117     self-&gt;jRunnable = NULL;
 118 
 119     [super dealloc];
 120 }
 121 
 122 @end
 123 
 124 #pragma mark --- GlassApplication
 125 
 126 @implementation GlassApplication
 127 
 128 - (id)initWithEnv:(JNIEnv*)env application:(jobject)application launchable:(jobject)launchable taskbarApplication:(jboolean)isTaskbarApplication classLoader:(jobject)classLoader
 129 {
 130     self = [super init];
 131     if (self != nil)
 132     {
 133         self-&gt;started = NO;
 134         self-&gt;jTaskBarApp = isTaskbarApplication;
 135 
 136         self-&gt;jApplication = (*env)-&gt;NewGlobalRef(env, application);
 137         if (launchable != NULL)
 138         {
 139             self-&gt;jLaunchable = (*env)-&gt;NewGlobalRef(env, launchable);
 140         }
 141 
 142         if (classLoader != NULL)
 143         {
 144             [GlassHelper SetGlassClassLoader:classLoader withEnv:env];
 145         }
 146     }
 147     return self;
 148 }
 149 
 150 #pragma mark --- delegate methods
 151 
 152 - (void)GlassApplicationDidChangeScreenParameters
 153 {
 154     LOG(&quot;GlassApplicationDidChangeScreenParameters&quot;);
 155 
 156     assert(pthread_main_np() == 1);
 157     JNIEnv *env = jEnv;
 158     if (env != NULL)
 159     {
 160         GlassScreenDidChangeScreenParameters(env);
 161     }
 162 }
 163 
 164 - (void)applicationWillFinishLaunching:(NSNotification *)aNotification
 165 {
 166     LOG(&quot;GlassApplication:applicationWillFinishLaunching&quot;);
 167 
 168     GET_MAIN_JENV;
 169     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 170     {
 171         // unblock main thread. Glass is started at this point.
 172         self-&gt;started = YES;
 173 
 174         if (self-&gt;jLaunchable != NULL)
 175         {
 176             jclass runnableClass = [GlassHelper ClassForName:&quot;java.lang.Runnable&quot; withEnv:jEnv];
 177             if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE)
 178             {
 179                 (*env)-&gt;ExceptionDescribe(env);
 180                 (*env)-&gt;ExceptionClear(env);
 181             }
 182             if (runnableClass) {
 183                 jmethodID runMethod = (*env)-&gt;GetMethodID(env, runnableClass, &quot;run&quot;, &quot;()V&quot;);
 184                 if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE)
 185                 {
 186                     (*env)-&gt;ExceptionDescribe(env);
 187                     (*env)-&gt;ExceptionClear(env);
 188                 }
 189                 if (runMethod) {
 190                     (*env)-&gt;CallVoidMethod(env, self-&gt;jLaunchable, runMethod);
 191                     if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE)
 192                     {
 193                         (*env)-&gt;ExceptionDescribe(env);
 194                         (*env)-&gt;ExceptionClear(env);
 195                     }
 196                     else
 197                     {
 198                         [[NSNotificationCenter defaultCenter] addObserver:self
 199                                                                  selector:@selector(GlassApplicationDidChangeScreenParameters)
 200                                                                      name:NSApplicationDidChangeScreenParametersNotification
 201                                                                    object:nil];
 202 
 203                         // localMonitor = [NSEvent addLocalMonitorForEventsMatchingMask: NSRightMouseDownMask
 204                         //                                                      handler:^(NSEvent *incomingEvent) {
 205                         //                                                          NSEvent *result = incomingEvent;
 206                         //                                                          NSWindow *targetWindowForEvent = [incomingEvent window];
 207                         //                                                          LOG(&quot;NSRightMouseDownMask local&quot;);
 208                         //                                                          return result;
 209                         //                                                      }];
 210                         //
 211                         // globalMonitor = [NSEvent addGlobalMonitorForEventsMatchingMask: NSRightMouseDownMask
 212                         //                                                      handler:^(NSEvent *incomingEvent) {
 213                         //                                                          NSEvent *result = incomingEvent;
 214                         //                                                          NSWindow *targetWindowForEvent = [incomingEvent window];
 215                         //                                                          NSWindow *window = [[NSApplication sharedApplication]
 216                         //                                                                       windowWithWindowNumber:[incomingEvent windowNumber]];
 217                         //                                                          NSWindow *appWindow = [[NSApplication sharedApplication] mainWindow];
 218                         //                                                          LOG(&quot;NSRightMouseDownMask global: %p num %d win %p appwin %p&quot;,
 219                         //                                                              targetWindowForEvent, [incomingEvent windowNumber], window,
 220                         //                                                              [[NSApplication sharedApplication] mainWindow]);
 221                         //                                                     }];
 222                     }
 223                 } else {
 224                     NSLog(@&quot;ERROR: Glass could not find run() method\n&quot;);
 225                 }
 226             } else {
 227                 NSLog(@&quot;ERROR: Glass could not find Runnable class\n&quot;);
 228             }
 229         }
 230 
 231         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillFinishLaunchingMethod]);
 232     }
 233     [pool drain];
 234     GLASS_CHECK_EXCEPTION(env);
 235 }
 236 
 237 - (void)applicationDidFinishLaunching:(NSNotification *)aNotification
 238 {
 239     LOG(&quot;GlassApplication:applicationDidFinishLaunching&quot;);
 240 
 241     GET_MAIN_JENV;
 242     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 243     {
 244         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidFinishLaunchingMethod]);
 245     }
 246     [pool drain];
 247     GLASS_CHECK_EXCEPTION(env);
 248 }
 249 
 250 - (void)applicationWillBecomeActive:(NSNotification *)aNotification
 251 {
 252     LOG(&quot;GlassApplication:applicationWillBecomeActive&quot;);
 253 
 254     GET_MAIN_JENV;
 255     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 256     {
 257         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillBecomeActiveMethod]);
 258     }
 259     [pool drain];
 260     GLASS_CHECK_EXCEPTION(env);
 261 }
 262 
 263 - (void)applicationDidBecomeActive:(NSNotification *)aNotification
 264 {
 265     LOG(&quot;GlassApplication:applicationDidBecomeActive&quot;);
 266 
 267     GET_MAIN_JENV;
 268     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 269     {
 270         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidBecomeActiveMethod]);
 271     }
 272     [pool drain];
 273     GLASS_CHECK_EXCEPTION(env);
 274 }
 275 
 276 - (void)applicationWillResignActive:(NSNotification *)aNotification
 277 {
 278     LOG(&quot;GlassApplication:applicationWillResignActive&quot;);
 279 
 280     GET_MAIN_JENV;
 281     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 282     {
 283         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillResignActiveMethod]);
 284     }
 285     [pool drain];
 286     GLASS_CHECK_EXCEPTION(env);
 287 }
 288 
 289 - (void)applicationDidResignActive:(NSNotification *)aNotification
 290 {
 291     LOG(&quot;GlassApplication:applicationDidResignActive&quot;);
 292 
 293     GET_MAIN_JENV;
 294     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 295     {
 296         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidResignActiveMethod]);
 297     }
 298     [pool drain];
 299     GLASS_CHECK_EXCEPTION(env);
 300 }
 301 
 302 - (void)applicationWillHide:(NSNotification *)aNotification
 303 {
 304     LOG(&quot;GlassApplication:applicationWillHide&quot;);
 305 
 306     GET_MAIN_JENV;
 307     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 308     {
 309         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillHideMethod]);
 310     }
 311     [pool drain];
 312     GLASS_CHECK_EXCEPTION(env);
 313 }
 314 
 315 - (void)applicationDidHide:(NSNotification *)aNotification
 316 {
 317     LOG(&quot;GlassApplication:applicationDidHide&quot;);
 318 
 319     GET_MAIN_JENV;
 320     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 321     {
 322         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidHideMethod]);
 323     }
 324     [pool drain];
 325     GLASS_CHECK_EXCEPTION(env);
 326 }
 327 
 328 - (void)applicationWillUnhide:(NSNotification *)aNotification
 329 {
 330     LOG(&quot;GlassApplication:applicationWillUnhide&quot;);
 331 
 332     GET_MAIN_JENV;
 333     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 334     {
 335         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillUnhideMethod]);
 336     }
 337     [pool drain];
 338     GLASS_CHECK_EXCEPTION(env);
 339 }
 340 
 341 - (void)applicationDidUnhide:(NSNotification *)aNotification
 342 {
 343     LOG(&quot;GlassApplication:applicationDidUnhide&quot;);
 344 
 345     GET_MAIN_JENV;
 346     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 347     {
 348         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyDidUnhideMethod]);
 349     }
 350     [pool drain];
 351     GLASS_CHECK_EXCEPTION(env);
 352 }
 353 
 354 - (void)application:(NSApplication *)theApplication openFiles:(NSArray *)filenames
 355 {
 356     LOG(&quot;GlassApplication:application:openFiles&quot;);
 357 
 358     GET_MAIN_JENV;
 359     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 360     {
 361         NSUInteger count = [filenames count];
 362         jclass stringClass = [GlassHelper ClassForName:&quot;java.lang.String&quot; withEnv:env];
 363         if (!stringClass) {
 364             return;
 365         }
 366         jobjectArray files = (*env)-&gt;NewObjectArray(env, (jsize)count, stringClass, NULL);
 367         GLASS_CHECK_EXCEPTION(env);
 368         for (NSUInteger i=0; i&lt;count; i++)
 369         {
 370             NSString *file = [filenames objectAtIndex:i];
 371             if (file != nil)
 372             {
 373                 (*env)-&gt;SetObjectArrayElement(env, files, (jsize)i, (*env)-&gt;NewStringUTF(env, [file UTF8String]));
 374                 GLASS_CHECK_EXCEPTION(env);
 375             }
 376         }
 377         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyOpenFilesMethod], files);
 378     }
 379     [pool drain];
 380     GLASS_CHECK_EXCEPTION(env);
 381 
 382     [theApplication replyToOpenOrPrint:NSApplicationDelegateReplySuccess];
 383 }
 384 
 385 - (BOOL)application:(NSApplication *)theApplication openFile:(NSString *)filename
 386 {
 387     LOG(&quot;GlassApplication:application:openFile&quot;);
 388 
 389     // controlled by Info.plist -NSOpenfileName
 390     // http://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html
 391     [self application:theApplication openFiles:[NSArray arrayWithObject:filename]];
 392 
 393     return YES;
 394 }
 395 
 396 - (BOOL)application:(id)theApplication openFileWithoutUI:(NSString *)filename
 397 {
 398     LOG(&quot;GlassApplication:application:openFileWithoutUI&quot;);
 399 
 400     // programmaticaly called by the client (even though GlassApplication does not currently call it, let&#39;s wire it in just in case)
 401     [self application:theApplication openFiles:[NSArray arrayWithObject:filename]];
 402 
 403     return YES;
 404 }
 405 
 406 - (BOOL)application:(NSApplication *)theApplication openTempFile:(NSString *)filename
 407 {
 408     LOG(&quot;GlassApplication:application:openTempFile&quot;);
 409 
 410     // controlled by Info.plist -NSOpenTempfileName
 411     // http://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html
 412     // NOP
 413 
 414     return YES;
 415 }
 416 
 417 - (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender
 418 {
 419     LOG(&quot;GlassApplication:applicationShouldOpenUntitledFile&quot;);
 420 
 421     // don&#39;t want
 422 
 423     return NO;
 424 }
 425 
 426 - (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication *)sender
 427 {
 428     LOG(&quot;GlassApplication:applicationShouldTerminate&quot;);
 429 
 430     GET_MAIN_JENV;
 431     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 432     {
 433         (*env)-&gt;CallVoidMethod(env, self-&gt;jApplication, [GlassHelper ApplicationNotifyWillQuitMethod]);
 434     }
 435     [pool drain];
 436     GLASS_CHECK_EXCEPTION(env);
 437 
 438     return NSTerminateCancel;
 439 }
 440 
 441 
 442 - (BOOL)applicationOpenUntitledFile:(NSApplication *)theApplication
 443 {
 444     LOG(&quot;GlassApplication:applicationOpenUntitledFile&quot;);
 445 
 446     // NOP (should never be called because applicationShouldOpenUntitledFile returns NO)
 447 
 448     return YES;
 449 }
 450 
 451 #pragma mark --- Glass support
 452 
 453 - (void)runLoop:(id)selector
 454 {
 455     LOG(&quot;GlassApplication:runLoop ENTER&quot;);
 456 
 457     NSAutoreleasePool *pool1 = [[NSAutoreleasePool alloc] init];
 458 
 459     jint error = (*jVM)-&gt;AttachCurrentThread(jVM, (void **)&amp;jEnv, NULL);
 460     //jint error = (*jVM)-&gt;AttachCurrentThreadAsDaemon(jVM, (void **)&amp;jEnv, NULL);
 461     if (error == 0)
 462     {
 463         NSAutoreleasePool *pool2 = [[NSAutoreleasePool alloc] init];
 464 
 465         if ([[NSThread currentThread] name] == nil)
 466         {
 467             [[NSThread currentThread] setName:@&quot;Main Cocoa (UI) Thread&quot;];
 468         }
 469 
 470         GlassApplication *glassApp = (GlassApplication *)selector;
 471 
 472         // Load MacApplication class using the glass classloader
 473         jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacApplication&quot; withEnv:jEnv];
 474         if (!cls)
 475         {
 476             NSLog(@&quot;ERROR: can&#39;t find the MacApplication class&quot;);
 477         }
 478         else
 479         {
 480             jmethodID setEventThreadMID = (*jEnv)-&gt;GetMethodID(jEnv, cls, &quot;setEventThread&quot;, &quot;()V&quot;);
 481             if (!setEventThreadMID)
 482             {
 483                 NSLog(@&quot;ERROR: can&#39;t get MacApplication.setEventThread() method ID&quot;);
 484             }
 485             else
 486             {
 487                 (*jEnv)-&gt;CallVoidMethod(jEnv, glassApp-&gt;jApplication, setEventThreadMID);
 488             }
 489         }
 490         GLASS_CHECK_EXCEPTION(jEnv);
 491 
 492         NSBundle *mainBundle = [NSBundle mainBundle];
 493         {
 494             NSString *appName = [mainBundle objectForInfoDictionaryKey:@&quot;CFBundleDisplayName&quot;];
 495 
 496             if (appName == nil) {
 497                 appName = [mainBundle objectForInfoDictionaryKey:@&quot;CFBundleName&quot;];
 498             }
 499 
 500             if (appName) {
 501                 // make the name available to Java side, before Launchable.fnishLaunching callback
 502                 jstring jname = (*jEnv)-&gt;NewStringUTF(jEnv, [appName UTF8String]);
 503                 jmethodID setNameMethod = (*jEnv)-&gt;GetMethodID(jEnv, cls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);
 504                 GLASS_CHECK_EXCEPTION(jEnv);
 505                 if (setNameMethod != NULL) {
 506                     (*jEnv)-&gt;CallVoidMethod(jEnv, glassApp-&gt;jApplication, setNameMethod, jname);
 507                 }
 508                 GLASS_CHECK_EXCEPTION(jEnv);
 509             }
 510         }
 511 
 512         // Determine if we&#39;re running embedded (in AWT, SWT, elsewhere)
 513         NSApplication *app = [NSApplication sharedApplication];
 514         isEmbedded = [app isRunning];
 515 
 516         if (!isEmbedded)
 517         {
 518             if (self-&gt;jTaskBarApp == JNI_TRUE)
 519             {
 520                 // move process from background only to full on app with visible Dock icon
 521                 ProcessSerialNumber psn;
 522                 if (GetCurrentProcess(&amp;psn) == noErr)
 523                 {
 524                     TransformProcessType(&amp;psn, kProcessTransformToForegroundApplication);
 525                 }
 526 
 527                 NSString *CFBundleIconFile = [mainBundle objectForInfoDictionaryKey:@&quot;CFBundleIconFile&quot;];
 528                 NSString *iconPath = nil;
 529                 if (CFBundleIconFile != nil)
 530                 {
 531                     iconPath = [mainBundle pathForResource:[CFBundleIconFile stringByDeletingPathExtension] ofType:[CFBundleIconFile pathExtension]];
 532                 }
 533 
 534                 // -Xdock:icon can override CFBundleIconFile (but only if it actually points to a valid icon)
 535                 NSString *property = [NSString stringWithFormat:@&quot;APP_ICON_%d&quot;, [[NSProcessInfo processInfo] processIdentifier]];
 536                 char *path = getenv([property UTF8String]);
 537                 if (path != NULL)
 538                 {
 539                     NSString *overridenPath = [NSString stringWithFormat:@&quot;%s&quot;, path];
 540                     if ([[NSFileManager defaultManager] fileExistsAtPath:overridenPath isDirectory:NO] == YES)
 541                     {
 542                         iconPath = overridenPath;
 543                     }
 544                 }
 545                 if ([[NSFileManager defaultManager] fileExistsAtPath:iconPath isDirectory:NO] == NO)
 546                 {
 547                     // try again using Java generic icon (this icon might go away eventually ?)
 548                     iconPath = [NSString stringWithFormat:@&quot;%s&quot;, &quot;/System/Library/Frameworks/JavaVM.framework/Resources/GenericApp.icns&quot;];
 549                 }
 550 
 551                 NSImage *image = nil;
 552                 {
 553                     if ([[NSFileManager defaultManager] fileExistsAtPath:iconPath isDirectory:NO] == YES)
 554                     {
 555                         image = [[NSImage alloc] initWithContentsOfFile:iconPath];
 556                     }
 557                     if (image == nil)
 558                     {
 559                         // last resort - if still no icon, then ask for an empty standard app icon, which is guranteed to exist
 560                         image = [[NSImage imageNamed:@&quot;NSApplicationIcon&quot;] retain];
 561                     }
 562                 }
 563                 [app setApplicationIconImage:image];
 564                 [image release];
 565 
 566                 // Install a hidden Window menu. This allows the dock icon
 567                 // menu to show the list of open windows (NSWindow instances)
 568                 NSMenu *myMenu = [[NSMenu alloc] initWithTitle:@&quot;Window&quot;];
 569                 [app setWindowsMenu:myMenu];
 570                 [myMenu release];
 571 
 572                 [app setDelegate:self];
 573 
 574                 // [app activateIgnoringOtherApps:YES] won&#39;t activate the menu bar on OS X 10.9, so instead we do this:
 575                 [[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateIgnoringOtherApps | NSApplicationActivateAllWindows)];
 576             }
 577             else
 578             {
 579                 // allow background processes to change the cursor (10.8 only API so we&#39;ll have to dynamically call it if available)
 580                 {
 581                     BOOL yes = YES;
 582                     [GlassHelper InvokeSelectorIfAvailable:@selector(javaSetAllowsCursorSetInBackground:) forClass:[NSCursor class] withArgument:&amp;yes withReturnValue:NULL];
 583                 }
 584 
 585                 // http://developer.apple.com/library/ios/#documentation/DeveloperTools/Conceptual/cross_development/Using/using.html
 586                 if (floor(NSAppKitVersionNumber) &gt;= 1138) // NSAppKitVersionNumber10_7
 587                 {
 588                     // 10.7 or later: move process from background only process to a limited app with active windows,
 589                     // but no Dock icon
 590                     ProcessSerialNumber psn;
 591                     if (GetCurrentProcess(&amp;psn) == noErr)
 592                     {
 593                         TransformProcessType(&amp;psn, 4); // kProcessTransformToUIElementApplication
 594                     }
 595                 }
 596                 else
 597                 {
 598                     // 10.6 or earlier: applets are not officially supported on 10.6 and earlier
 599                     // so they will have limited applet functionality (no active windows)
 600                 }
 601                 [app setDelegate:self];
 602             }
 603 
 604 #if defined(VERBOSE_LOAD)
 605             jclass BooleanClass = [GlassHelper ClassForName:&quot;java.lang.Boolean&quot; withEnv:jEnv];
 606             if (BooleanClass != 0)
 607             {
 608                 jmethodID getBooleanMethod = (*jEnv)-&gt;GetStaticMethodID(jEnv, BooleanClass, &quot;getBoolean&quot;, &quot;(Ljava/lang/String;)Z&quot;);
 609                 if (getBooleanMethod != 0)
 610                 {
 611                     jstring flag = (*jEnv)-&gt;NewStringUTF(jEnv, &quot;glassload.verbose&quot;);
 612                     jboolean verbose = (*jEnv)-&gt;CallStaticBooleanMethod(jEnv, BooleanClass, getBooleanMethod, flag);
 613                     if (verbose == JNI_TRUE)
 614                     {
 615                         printLoadedLibraries(stderr);
 616                         printLoadedFiles(stderr);
 617                     }
 618                 }
 619             }
 620 #endif
 621 
 622             // drain the pool before entering runloop
 623             [pool2 drain];
 624 
 625             // enter runloop, this will not return until terminated
 626             [NSApp run];
 627 
 628             // Abort listerning to global touch input events
 629             [GlassTouches terminate];
 630 
 631             GLASS_CHECK_EXCEPTION(jEnv);
 632 
 633             (*jEnv)-&gt;CallVoidMethod(jEnv, self-&gt;jApplication, javaIDs.MacApplication.notifyApplicationDidTerminate);
 634             GLASS_CHECK_EXCEPTION(jEnv);
 635 
 636             jint err = (*jVM)-&gt;DetachCurrentThread(jVM);
 637             if (err &lt; 0)
 638             {
 639                 NSLog(@&quot;Unable to detach from JVM. Error code: %d\n&quot;, (int)err);
 640             }
 641 
 642             jEnv = NULL;
 643         }
 644         else // event loop is not started
 645         {
 646             if ([NSThread isMainThread] == YES) {
 647                 [glassApp applicationWillFinishLaunching: NULL];
 648             } else {
 649                 [glassApp performSelectorOnMainThread:@selector(applicationWillFinishLaunching:) withObject:NULL waitUntilDone:NO];
 650             }
 651             GLASS_CHECK_EXCEPTION(jEnv);
 652 
 653             [pool2 drain];
 654         }
 655     }
 656     else // attaching to JVM failed
 657     {
 658         NSLog(@&quot;ERROR: Glass could not attach to VM, result:%d\n&quot;, (int)error);
 659     }
 660 
 661     [pool1 drain];
 662 
 663     LOG(&quot;GlassApplication:runLoop EXIT&quot;);
 664 }
 665 
 666 - (BOOL)started
 667 {
 668     return self-&gt;started;
 669 }
 670 
 671 + (jobject)enterNestedEventLoopWithEnv:(JNIEnv*)env
 672 {
 673     jobject ret = NULL;
 674 
 675     NSRunLoop *theRL = [NSRunLoop currentRunLoop];
 676     NSApplication * app = [NSApplication sharedApplication];
 677     shouldKeepRunningNestedLoop = YES;
 678     // Cannot use [NSDate distantFuture] because the period is big the app could hang in a runloop
 679     // if the event came before entering the RL
 680     while (shouldKeepRunningNestedLoop &amp;&amp; [theRL runMode:NSDefaultRunLoopMode
 681                                               beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.010]])
 682     {
 683         NSEvent * event = [app nextEventMatchingMask: 0xFFFFFFFF untilDate:nil inMode:NSDefaultRunLoopMode dequeue:YES];
 684 
 685         if (event != nil) {
 686             [app sendEvent: event];
 687         }
 688     }
 689 
 690     if (nestedLoopReturnValue != NULL) {
 691         ret = (*env)-&gt;NewLocalRef(env, nestedLoopReturnValue);
 692         (*env)-&gt;DeleteGlobalRef(env, nestedLoopReturnValue);
 693         nestedLoopReturnValue = NULL;
 694     }
 695 
 696     shouldKeepRunningNestedLoop = YES;
 697 
 698     return ret;
 699 }
 700 
 701 + (void)leaveNestedEventLoopWithEnv:(JNIEnv*)env retValue:(jobject)retValue
 702 {
 703     if (retValue != NULL) {
 704         nestedLoopReturnValue = (*env)-&gt;NewGlobalRef(env, retValue);
 705     }
 706     shouldKeepRunningNestedLoop = NO;
 707 }
 708 
 709 + (void)enterFullScreenExitingLoop
 710 {
 711     if (isFullScreenExitingLoop) {
 712         return;
 713     }
 714     isFullScreenExitingLoop = YES;
 715     GET_MAIN_JENV;
 716     (*env)-&gt;CallStaticObjectMethod(env, jApplicationClass,
 717             javaIDs.Application.enterNestedEventLoop);
 718     if ((*env)-&gt;ExceptionCheck(env) == JNI_TRUE) {
 719         (*env)-&gt;ExceptionDescribe(env);
 720         (*env)-&gt;ExceptionClear(env);
 721     }
 722     isFullScreenExitingLoop = NO;
 723 }
 724 
 725 + (void)leaveFullScreenExitingLoopIfNeeded
 726 {
 727     if (!isFullScreenExitingLoop) {
 728         return;
 729     }
 730     GET_MAIN_JENV;
 731     (*env)-&gt;CallStaticVoidMethod(env, jApplicationClass,
 732             javaIDs.Application.leaveNestedEventLoop, (jobject)NULL);
 733 }
 734 
 735 + (void)registerKeyEvent:(NSEvent*)event
 736 {
 737     if (!keyCodeForCharMap) {
 738         keyCodeForCharMap = [[NSMutableDictionary alloc] initWithCapacity:100];
 739         // Note: it&#39;s never released, just like, say, the jApplication reference...
 740     }
 741     [keyCodeForCharMap setObject:[NSNumber numberWithUnsignedShort:[event keyCode]] forKey:[event characters]];
 742 }
 743 
 744 + (jint)getKeyCodeForChar:(jchar)c;
 745 {
 746     id v = [keyCodeForCharMap objectForKey:[NSString stringWithCharacters: (UniChar *)&amp;c length:1]];
 747     if (!v) {
 748         return com_sun_glass_events_KeyEvent_VK_UNDEFINED;
 749     } else {
 750         return GetJavaKeyCodeFor([v unsignedShortValue]);
 751     }
 752 }
 753 
 754 + (BOOL)syncRenderingDisabled {
 755     return disableSyncRendering;
 756 }
 757 
<a name="1" id="anc1"></a><span class="line-removed"> 758 + (BOOL)isSandboxed</span>
<span class="line-removed"> 759 {</span>
<span class="line-removed"> 760     static int isSandboxed = -1;</span>
<span class="line-removed"> 761 </span>
<span class="line-removed"> 762     if (isSandboxed == -1) {</span>
<span class="line-removed"> 763         isSandboxed = 0;</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765         NSBundle *mainBundle = [NSBundle mainBundle];</span>
<span class="line-removed"> 766         NSURL *url = [mainBundle bundleURL];</span>
<span class="line-removed"> 767         SecStaticCodeRef staticCodeRef = NULL;</span>
<span class="line-removed"> 768         SecStaticCodeCreateWithPath((CFURLRef)url, kSecCSDefaultFlags, &amp;staticCodeRef);</span>
<span class="line-removed"> 769 </span>
<span class="line-removed"> 770         if (staticCodeRef) {</span>
<span class="line-removed"> 771             // Check if the app is signed</span>
<span class="line-removed"> 772             OSStatus res_signed = SecStaticCodeCheckValidityWithErrors(staticCodeRef, kSecCSBasicValidateOnly, NULL, NULL);</span>
<span class="line-removed"> 773             if (res_signed == errSecSuccess) {</span>
<span class="line-removed"> 774                 // It is signed, now check if it&#39;s sandboxed</span>
<span class="line-removed"> 775                 SecRequirementRef sandboxRequirementRef = NULL;</span>
<span class="line-removed"> 776                 SecRequirementCreateWithString(CFSTR(&quot;entitlement[\&quot;com.apple.security.app-sandbox\&quot;] exists&quot;), kSecCSDefaultFlags, &amp;sandboxRequirementRef);</span>
<span class="line-removed"> 777 </span>
<span class="line-removed"> 778                 if (sandboxRequirementRef) {</span>
<span class="line-removed"> 779                     OSStatus res_sandboxed = SecStaticCodeCheckValidityWithErrors(staticCodeRef, kSecCSBasicValidateOnly, sandboxRequirementRef, NULL);</span>
<span class="line-removed"> 780                     if (res_sandboxed == errSecSuccess) {</span>
<span class="line-removed"> 781                         // Yep, sandboxed</span>
<span class="line-removed"> 782                         isSandboxed = 1;</span>
<span class="line-removed"> 783                     }</span>
<span class="line-removed"> 784 </span>
<span class="line-removed"> 785                     CFRelease(sandboxRequirementRef);</span>
<span class="line-removed"> 786                 }</span>
<span class="line-removed"> 787             }</span>
<span class="line-removed"> 788 </span>
<span class="line-removed"> 789             CFRelease(staticCodeRef);</span>
<span class="line-removed"> 790         }</span>
<span class="line-removed"> 791     }</span>
<span class="line-removed"> 792 </span>
<span class="line-removed"> 793     return isSandboxed == 1 ? YES : NO;</span>
<span class="line-removed"> 794 }</span>
<span class="line-removed"> 795 </span>
 796 @end
 797 
 798 #pragma mark --- JNI
 799 
 800 /*
 801  * Class:     com_sun_glass_ui_mac_MacApplication
 802  * Method:    _initIDs
 803  * Signature: ()V
 804  */
 805 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1initIDs
 806 (JNIEnv *env, jclass jClass, jboolean jDisableSyncRendering)
 807 {
 808     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1initIDs&quot;);
 809 
 810     disableSyncRendering = jDisableSyncRendering ? YES : NO;
 811 
 812     jApplicationClass = (*env)-&gt;NewGlobalRef(env, jClass);
 813 
 814     javaIDs.Application.createPixels = (*env)-&gt;GetStaticMethodID(
 815             env, jClass, &quot;createPixels&quot;, &quot;(II[IFF)Lcom/sun/glass/ui/Pixels;&quot;);
 816     if ((*env)-&gt;ExceptionCheck(env)) return;
 817 
 818     javaIDs.Application.getScaleFactor = (*env)-&gt;GetStaticMethodID(
 819             env, jClass, &quot;getScaleFactor&quot;, &quot;(IIII)F&quot;);
 820     if ((*env)-&gt;ExceptionCheck(env)) return;
 821 
 822     javaIDs.Application.reportException = (*env)-&gt;GetStaticMethodID(
 823             env, jClass, &quot;reportException&quot;, &quot;(Ljava/lang/Throwable;)V&quot;);
 824     if ((*env)-&gt;ExceptionCheck(env)) return;
 825 
 826     javaIDs.Application.enterNestedEventLoop = (*env)-&gt;GetStaticMethodID(
 827             env, jClass, &quot;enterNestedEventLoop&quot;, &quot;()Ljava/lang/Object;&quot;);
 828     if ((*env)-&gt;ExceptionCheck(env)) return;
 829 
 830     javaIDs.Application.leaveNestedEventLoop = (*env)-&gt;GetStaticMethodID(
 831             env, jClass, &quot;leaveNestedEventLoop&quot;, &quot;(Ljava/lang/Object;)V&quot;);
 832     if ((*env)-&gt;ExceptionCheck(env)) return;
 833 
 834     javaIDs.MacApplication.notifyApplicationDidTerminate = (*env)-&gt;GetMethodID(
 835             env, jClass, &quot;notifyApplicationDidTerminate&quot;, &quot;()V&quot;);
 836     if ((*env)-&gt;ExceptionCheck(env)) return;
 837 
 838     if (jRunnableRun == NULL)
 839     {
 840         jclass jcls = (*env)-&gt;FindClass(env, &quot;java/lang/Runnable&quot;);
 841         if ((*env)-&gt;ExceptionCheck(env)) return;
 842         jRunnableRun = (*env)-&gt;GetMethodID(env, jcls, &quot;run&quot;, &quot;()V&quot;);
 843         if ((*env)-&gt;ExceptionCheck(env)) return;
 844     }
 845 }
 846 
 847 /*
 848  * Class:     com_sun_glass_ui_mac_MacApplication
 849  * Method:    _runLoop
 850  * Signature: (Ljava/lang/ClassLoader;Ljava/lang/Runnable;Z)V
 851  */
 852 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1runLoop
 853 (JNIEnv *env, jobject japplication, jobject classLoader,
 854  jobject jlaunchable, jboolean isTaskbarApplication)
 855 {
 856     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1runLoop&quot;);
 857 
 858     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 859     {
 860         if ([NSThread isMainThread] == YES)
 861         {
 862             //            fprintf(stderr, &quot;\nWARNING: Glass was started on 1st thread and will block this thread.\nYou most likely do not want to do this - please remove \&quot;-XstartOnFirstThread\&quot; from VM arguments.\n\n&quot;);
 863         }
 864         else
 865         {
 866             if ([[NSThread currentThread] name] == nil)
 867             {
 868                 [[NSThread currentThread] setName:@&quot;Main Java Thread&quot;];
 869             }
 870         }
 871 
 872         GlassApplication *glass = [[GlassApplication alloc] initWithEnv:env application:japplication launchable:jlaunchable taskbarApplication:isTaskbarApplication classLoader:classLoader];
 873         if ([NSThread isMainThread] == YES) {
 874             [glass runLoop: glass];
 875         } else {
 876             [glass performSelectorOnMainThread:@selector(runLoop:) withObject:glass waitUntilDone:[NSThread isMainThread]];
 877 
 878             // wait for Cocoa to enter its UI runloop
 879             while ([glass started] == NO)
 880             {
 881                 LOG(&quot;        waiting for [glass started]&quot;);
 882                 usleep(10000);
 883             }
 884         }
 885 
 886         // at this point Java main thread is allowed to proceed, but Cocoa&#39;s UI thread entered its runloop, so the VM will not quit
 887     }
 888     [glasspool drain]; glasspool=nil;
 889     GLASS_CHECK_EXCEPTION(env);
 890 }
 891 
 892 /*
 893  * Class:     com_sun_glass_ui_mac_MacApplication
 894  * Method:    _finishTerminating
 895  * Signature: ()V
 896  */
 897 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1finishTerminating
 898 (JNIEnv *env, jobject japplication)
 899 {
 900     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1finishTerminating&quot;);
 901 
 902     if (isEmbedded) {
 903         return;
 904     }
 905 
 906     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 907     {
 908         [NSApp stop:nil];
 909         [NSApp hide:nil];
 910 
 911         // wake up the runloop one last time so that it can process the stop:
 912         // request, even if the app is inactive currently
 913         NSTimeInterval dummyEventTimestamp = [NSProcessInfo processInfo].systemUptime;
 914         NSEvent* event = [NSEvent otherEventWithType: NSApplicationDefined
 915                                             location: NSMakePoint(0,0)
 916                                        modifierFlags: 0
 917                                            timestamp: dummyEventTimestamp
 918                                         windowNumber: 0
 919                                              context: nil
 920                                              subtype: 0
 921                                                data1: 0
 922                                                data2: 0];
 923         [NSApp postEvent: event atStart: NO];
 924     }
 925     [glasspool drain]; glasspool=nil;
 926     GLASS_CHECK_EXCEPTION(env);
 927 }
 928 
 929 /*
 930  * Class:     com_sun_glass_ui_mac_MacApplication
 931  * Method:    _enterNestedEventLoopImpl
 932  * Signature: ()Ljava/lang/Object;
 933  */
 934 JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_mac_MacApplication__1enterNestedEventLoopImpl
 935 (JNIEnv *env, jobject japplication)
 936 {
 937     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1enterNestedEventLoopImpl&quot;);
 938 
 939     jobject ret;
 940 
 941     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 942     {
 943         ret = [GlassApplication enterNestedEventLoopWithEnv:env];
 944     }
 945     [glasspool drain]; glasspool=nil;
 946     GLASS_CHECK_EXCEPTION(env);
 947 
 948     return ret;
 949 }
 950 
 951 /*
 952  * Class:     com_sun_glass_ui_mac_MacApplication
 953  * Method:    _leaveNestedEventLoopImpl
 954  * Signature: (Ljava/lang/Object;)V
 955  */
 956 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1leaveNestedEventLoopImpl
 957 (JNIEnv *env, jobject japplication, jobject retValue)
 958 {
 959     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1leaveNestedEventLoopImpl&quot;);
 960 
 961     NSAutoreleasePool *glasspool = [[NSAutoreleasePool alloc] init];
 962     {
 963         [GlassApplication leaveNestedEventLoopWithEnv:env retValue:retValue];
 964     }
 965     [glasspool drain]; glasspool=nil;
 966     GLASS_CHECK_EXCEPTION(env);
 967 }
 968 
 969 /*
 970  * Class:     com_sun_glass_ui_Application
 971  * Method:    _submitForLaterInvocation
 972  * Signature: (Ljava/lang/Runnable;)V
 973  */
 974 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1submitForLaterInvocation
 975 (JNIEnv *env, jobject japplication, jobject jRunnable)
 976 {
 977     //LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication_submitForLaterInvocation&quot;);
 978 
 979     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 980     if (jEnv != NULL)
 981     {
 982         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
 983         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:NO];
 984     }
 985 }
 986 
 987 /*
 988  * Class:     com_sun_glass_ui_Application
 989  * Method:    _invokeAndWait
 990  * Signature: (Ljava/lang/Runnable;)V
 991  */
 992 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1invokeAndWait
 993 (JNIEnv *env, jobject japplication, jobject jRunnable)
 994 {
 995     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1invokeAndWait&quot;);
 996 
 997     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 998     if (jEnv != NULL)
 999     {
1000         GlassRunnable *runnable = [[GlassRunnable alloc] initWithRunnable:(*env)-&gt;NewGlobalRef(env, jRunnable)];
1001         [runnable performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];
1002     }
1003 }
1004 
1005 /*
1006  * Class:     com_sun_glass_ui_mac_MacApplication
1007  * Method:    _getRemoteLayerServerName
1008  * Signature: ()Ljava/lang/String;
1009  */
1010 JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getRemoteLayerServerName
1011 (JNIEnv *env, jobject japplication)
1012 {
1013     LOG(&quot;Java_com_sun_glass_ui_mac_MacPasteboard__1getName&quot;);
1014 
1015     jstring name = NULL;
1016 
1017     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1018     GLASS_POOL_ENTER;
1019     {
1020         static mach_port_t remoteLayerServerPort = MACH_PORT_NULL;
1021         if (remoteLayerServerPort == MACH_PORT_NULL)
1022         {
1023             remoteLayerServerPort = RemoteLayerStartServer();
1024         }
1025         NSString *remoteLayerServerName = RemoteLayerGetServerName(remoteLayerServerPort);
1026         name = (*env)-&gt;NewStringUTF(env, [remoteLayerServerName UTF8String]);
1027     }
1028     GLASS_POOL_EXIT;
1029     GLASS_CHECK_EXCEPTION(env);
1030 
1031     return name;
1032 }
1033 
1034 /*
1035  * Class:     com_sun_glass_ui_mac_MacApplication
1036  * Method:    staticScreen_getVideoRefreshPeriod
1037  * Signature: ()D
1038  */
1039 JNIEXPORT jdouble JNICALL
1040 Java_com_sun_glass_ui_mac_MacApplication_staticScreen_1getVideoRefreshPeriod
1041 (JNIEnv *env, jobject jApplication)
1042 {
1043     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1getVideoRefreshPeriod&quot;);
1044 
1045     if (GlassDisplayLink != NULL)
1046     {
1047         double outRefresh = CVDisplayLinkGetActualOutputVideoRefreshPeriod(GlassDisplayLink);
1048         LOG(&quot;CVDisplayLinkGetActualOutputVideoRefreshPeriod: %f&quot;, outRefresh);
1049         return (outRefresh * 1000.0); // to millis
1050     }
1051     else
1052     {
1053         return 0.0;
1054     }
1055 }
1056 
1057 /*
1058  * Class:     com_sun_glass_ui_mac_MacApplication
1059  * Method:    staticScreen_getScreens
1060  * Signature: ()[Lcom/sun/glass/ui/Screen;
1061  */
1062 JNIEXPORT jobjectArray JNICALL Java_com_sun_glass_ui_mac_MacApplication_staticScreen_1getScreens
1063 (JNIEnv *env, jobject jApplication)
1064 {
1065     LOG(&quot;Java_com_sun_glass_ui_mac_MacApplication__1getScreens&quot;);
1066 
1067     jobjectArray screenArray = nil;
1068 
1069     GLASS_POOL_ENTER;
1070     {
1071         screenArray = createJavaScreens(env);
1072     }
1073     GLASS_POOL_EXIT;
1074     GLASS_CHECK_EXCEPTION(env);
1075 
1076     return screenArray;
1077 }
1078 
1079 
1080 /*
1081  * Class:     com_sun_glass_ui_mac_MacApplication
1082  * Method:    _supportsSystemMenu
1083  * Signature: ()Z;
1084  */
1085 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacApplication__1supportsSystemMenu
1086 (JNIEnv *env, jobject japplication)
1087 {
1088     return !isEmbedded;
1089 }
1090 
1091 /*
1092  * Class:     com_sun_glass_ui_mac_MacApplication
1093  * Method:    _hide
1094  * Signature: ()V;
1095  */
1096 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1hide
1097 (JNIEnv *env, jobject japplication)
1098 {
1099     [NSApp hide:NSApp];
1100 }
1101 
1102 /*
1103  * Class:     com_sun_glass_ui_mac_MacApplication
1104  * Method:    _hideOtherApplications
1105  * Signature: ()V;
1106  */
1107 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1hideOtherApplications
1108 (JNIEnv *env, jobject japplication)
1109 {
1110     [NSApp hideOtherApplications:NSApp];
1111 }
1112 
1113 /*
1114  * Class:     com_sun_glass_ui_mac_MacApplication
1115  * Method:    _unhideAllApplications
1116  * Signature: ()V;
1117  */
1118 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacApplication__1unhideAllApplications
1119 (JNIEnv *env, jobject japplication)
1120 {
1121     [NSApp unhideAllApplications:NSApp];
1122 }
1123 
1124 /*
1125  * Class:     com_sun_glass_ui_mac_MacApplication
1126  * Method:    _getDataDirectory
1127  * Signature: ()Ljava/lang/String;
1128  */
1129 JNIEXPORT jstring JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getDataDirectory
1130 (JNIEnv * env, jobject japplication)
1131 {
1132     jstring string = nil;
1133 
1134     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1135     GLASS_POOL_ENTER;
1136     {
1137     NSArray *paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
1138     if (paths &amp;&amp; [paths count] &gt; 0) {
1139         string = (*env)-&gt;NewStringUTF(jEnv, [[paths lastObject] UTF8String]);
1140     }
1141     }
1142     GLASS_POOL_EXIT;
1143     GLASS_CHECK_EXCEPTION(env);
1144 
1145     return string;
1146 }
1147 
1148 /*
1149  * Class:     com_sun_glass_ui_mac_MacApplication
1150  * Method:    _getMacKey
1151  * Signature: (I)I
1152  */
1153 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacApplication__1getMacKey
1154 (JNIEnv *env, jclass jClass, jint code)
1155 {
1156     unsigned short macCode = 0;
1157     GetMacKey(code, &amp;macCode);
1158     return (macCode &amp; 0xFFFF);
1159 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
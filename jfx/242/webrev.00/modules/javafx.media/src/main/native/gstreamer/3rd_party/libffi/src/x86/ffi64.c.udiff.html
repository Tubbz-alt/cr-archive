<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi64.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ffi.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="win64.S.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi64.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /* -----------------------------------------------------------------------
<span class="udiff-line-modified-removed">-    ffi64.c - Copyright (c) 2013  The Written Word, Inc.</span>
<span class="udiff-line-modified-removed">-              Copyright (c) 2011  Anthony Green</span>
<span class="udiff-line-modified-added">+    ffi64.c - Copyright (c) 2011, 2018  Anthony Green</span>
<span class="udiff-line-modified-added">+              Copyright (c) 2013  The Written Word, Inc.</span>
               Copyright (c) 2008, 2010  Red Hat, Inc.
               Copyright (c) 2002, 2007  Bo Thorsen &lt;bo@suse.de&gt;
  
     x86-64 Foreign Function Interface
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,12 @@</span>
  #include &lt;ffi.h&gt;
  #include &lt;ffi_common.h&gt;
  
  #include &lt;stdlib.h&gt;
  #include &lt;stdarg.h&gt;
<span class="udiff-line-added">+ #include &lt;stdint.h&gt;</span>
<span class="udiff-line-added">+ #include &quot;internal64.h&quot;</span>
  
  #ifdef __x86_64__
  
  #define MAX_GPR_REGS 6
  #define MAX_SSE_REGS 8
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60,14 +62,16 @@</span>
  struct register_args
  {
    /* Registers for argument passing.  */
    UINT64 gpr[MAX_GPR_REGS];
    union big_int_union sse[MAX_SSE_REGS];
<span class="udiff-line-added">+   UINT64 rax;   /* ssecount */</span>
<span class="udiff-line-added">+   UINT64 r10;   /* static chain */</span>
  };
  
  extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
<span class="udiff-line-modified-removed">-                  void *raddr, void (*fnaddr)(void), unsigned ssecount);</span>
<span class="udiff-line-modified-added">+                  void *raddr, void (*fnaddr)(void)) FFI_HIDDEN;</span>
  
  /* All reference to register classes here is identical to the code in
     gcc/config/i386/i386.c. Do *not* change one without the other.  */
  
  /* Register class used for passing given 64bit part of the argument.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -165,10 +169,11 @@</span>
      case FFI_TYPE_UINT32:
      case FFI_TYPE_SINT32:
      case FFI_TYPE_UINT64:
      case FFI_TYPE_SINT64:
      case FFI_TYPE_POINTER:
<span class="udiff-line-added">+     do_integer:</span>
        {
      size_t size = byte_offset + type-&gt;size;
  
      if (size &lt;= 4)
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -186,11 +191,11 @@</span>
          classes[1] = X86_64_INTEGERSI_CLASS;
          return 2;
        }
      else if (size &lt;= 16)
        {
<span class="udiff-line-modified-removed">-         classes[0] = classes[1] = X86_64_INTEGERSI_CLASS;</span>
<span class="udiff-line-modified-added">+         classes[0] = classes[1] = X86_64_INTEGER_CLASS;</span>
          return 2;
        }
      else
        FFI_ASSERT (0);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -212,11 +217,11 @@</span>
      case FFI_TYPE_STRUCT:
        {
      const size_t UNITS_PER_WORD = 8;
      size_t words = (type-&gt;size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
      ffi_type **ptr;
<span class="udiff-line-modified-removed">-     int i;</span>
<span class="udiff-line-modified-added">+     unsigned int i;</span>
      enum x86_64_reg_class subclasses[MAX_CLASSES];
  
      /* If the struct is larger than 32 bytes, pass it on the stack.  */
      if (type-&gt;size &gt; 32)
        return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -226,20 +231,21 @@</span>
  
      /* Zero sized arrays or structures are NO_CLASS.  We return 0 to
         signalize memory class, so handle it as special case.  */
      if (!words)
        {
<span class="udiff-line-added">+     case FFI_TYPE_VOID:</span>
          classes[0] = X86_64_NO_CLASS;
          return 1;
        }
  
      /* Merge the fields of structure.  */
      for (ptr = type-&gt;elements; *ptr != NULL; ptr++)
        {
          size_t num;
  
<span class="udiff-line-modified-removed">-         byte_offset = ALIGN (byte_offset, (*ptr)-&gt;alignment);</span>
<span class="udiff-line-modified-added">+         byte_offset = FFI_ALIGN (byte_offset, (*ptr)-&gt;alignment);</span>
  
          num = classify_argument (*ptr, subclasses, byte_offset % 8);
          if (num == 0)
            return 0;
          for (i = 0; i &lt; num; i++)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -274,36 +280,67 @@</span>
          if (classes[i] == X86_64_MEMORY_CLASS)
            return 0;
  
          /* The X86_64_SSEUP_CLASS should be always preceded by
             X86_64_SSE_CLASS or X86_64_SSEUP_CLASS.  */
<span class="udiff-line-modified-removed">-         if (classes[i] == X86_64_SSEUP_CLASS</span>
<span class="udiff-line-modified-added">+         if (i &gt; 1 &amp;&amp; classes[i] == X86_64_SSEUP_CLASS</span>
          &amp;&amp; classes[i - 1] != X86_64_SSE_CLASS
          &amp;&amp; classes[i - 1] != X86_64_SSEUP_CLASS)
            {
          /* The first one should never be X86_64_SSEUP_CLASS.  */
          FFI_ASSERT (i != 0);
          classes[i] = X86_64_SSE_CLASS;
            }
  
          /*  If X86_64_X87UP_CLASS isn&#39;t preceded by X86_64_X87_CLASS,
          everything should be passed in memory.  */
<span class="udiff-line-modified-removed">-         if (classes[i] == X86_64_X87UP_CLASS</span>
<span class="udiff-line-modified-added">+         if (i &gt; 1 &amp;&amp; classes[i] == X86_64_X87UP_CLASS</span>
          &amp;&amp; (classes[i - 1] != X86_64_X87_CLASS))
            {
          /* The first one should never be X86_64_X87UP_CLASS.  */
          FFI_ASSERT (i != 0);
          return 0;
            }
        }
      return words;
        }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     default:</span>
<span class="udiff-line-modified-removed">-       FFI_ASSERT(0);</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_COMPLEX:</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+     ffi_type *inner = type-&gt;elements[0];</span>
<span class="udiff-line-added">+     switch (inner-&gt;type)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+       case FFI_TYPE_INT:</span>
<span class="udiff-line-added">+       case FFI_TYPE_UINT8:</span>
<span class="udiff-line-added">+       case FFI_TYPE_SINT8:</span>
<span class="udiff-line-added">+       case FFI_TYPE_UINT16:</span>
<span class="udiff-line-added">+       case FFI_TYPE_SINT16:</span>
<span class="udiff-line-added">+       case FFI_TYPE_UINT32:</span>
<span class="udiff-line-added">+       case FFI_TYPE_SINT32:</span>
<span class="udiff-line-added">+       case FFI_TYPE_UINT64:</span>
<span class="udiff-line-added">+       case FFI_TYPE_SINT64:</span>
<span class="udiff-line-added">+         goto do_integer;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-added">+         classes[0] = X86_64_SSE_CLASS;</span>
<span class="udiff-line-added">+         if (byte_offset % 8)</span>
<span class="udiff-line-added">+           {</span>
<span class="udiff-line-added">+         classes[1] = X86_64_SSESF_CLASS;</span>
<span class="udiff-line-added">+         return 2;</span>
      }
<span class="udiff-line-modified-removed">-   return 0; /* Never reached.  */</span>
<span class="udiff-line-modified-added">+         return 1;</span>
<span class="udiff-line-added">+       case FFI_TYPE_DOUBLE:</span>
<span class="udiff-line-added">+         classes[0] = classes[1] = X86_64_SSEDF_CLASS;</span>
<span class="udiff-line-added">+         return 2;</span>
<span class="udiff-line-added">+ #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="udiff-line-added">+       case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-added">+         classes[0] = X86_64_COMPLEX_X87_CLASS;</span>
<span class="udiff-line-added">+         return 1;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   abort();</span>
  }
  
  /* Examine the argument and return set number of register required in each
     class.  Return zero iff parameter should be passed in memory, otherwise
     the number of registers.  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -311,11 +348,12 @@</span>
  static size_t
  examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
            _Bool in_return, int *pngpr, int *pnsse)
  {
    size_t n;
<span class="udiff-line-modified-removed">-   int i, ngpr, nsse;</span>
<span class="udiff-line-modified-added">+   unsigned int i;</span>
<span class="udiff-line-added">+   int ngpr, nsse;</span>
  
    n = classify_argument (type, classes, 0);
    if (n == 0)
      return 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -349,46 +387,142 @@</span>
    return n;
  }
  
  /* Perform machine dependent cif processing.  */
  
<span class="udiff-line-modified-removed">- ffi_status</span>
<span class="udiff-line-modified-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+ extern ffi_status</span>
<span class="udiff-line-added">+ ffi_prep_cif_machdep_efi64(ffi_cif *cif);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ffi_status FFI_HIDDEN</span>
  ffi_prep_cif_machdep (ffi_cif *cif)
  {
<span class="udiff-line-modified-removed">-   int gprcount, ssecount, i, avn, ngpr, nsse, flags;</span>
<span class="udiff-line-modified-added">+   int gprcount, ssecount, i, avn, ngpr, nsse;</span>
<span class="udiff-line-added">+   unsigned flags;</span>
    enum x86_64_reg_class classes[MAX_CLASSES];
<span class="udiff-line-modified-removed">-   size_t bytes, n;</span>
<span class="udiff-line-modified-added">+   size_t bytes, n, rtype_size;</span>
<span class="udiff-line-added">+   ffi_type *rtype;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="udiff-line-added">+     return ffi_prep_cif_machdep_efi64(cif);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   if (cif-&gt;abi != FFI_UNIX64)</span>
<span class="udiff-line-added">+     return FFI_BAD_ABI;</span>
  
    gprcount = ssecount = 0;
  
<span class="udiff-line-modified-removed">-   flags = cif-&gt;rtype-&gt;type;</span>
<span class="udiff-line-modified-removed">-   if (flags != FFI_TYPE_VOID)</span>
<span class="udiff-line-modified-added">+   rtype = cif-&gt;rtype;</span>
<span class="udiff-line-modified-added">+   rtype_size = rtype-&gt;size;</span>
<span class="udiff-line-added">+   switch (rtype-&gt;type)</span>
      {
<span class="udiff-line-added">+     case FFI_TYPE_VOID:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_VOID;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT8:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_UINT8;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT8:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_SINT8;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT16:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_UINT16;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT16:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_SINT16;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT32:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_UINT32;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_INT:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT32:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_SINT32;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT64:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT64:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_INT64;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_POINTER:</span>
<span class="udiff-line-added">+       flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_XMM32;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_DOUBLE:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_XMM64;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="udiff-line-added">+     case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_X87;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     case FFI_TYPE_STRUCT:</span>
        n = examine_argument (cif-&gt;rtype, classes, 1, &amp;ngpr, &amp;nsse);
        if (n == 0)
      {
        /* The return value is passed in memory.  A pointer to that
           memory is the first argument.  Allocate a register for it.  */
        gprcount++;
        /* We don&#39;t have to do anything in asm for the return.  */
<span class="udiff-line-modified-removed">-       flags = FFI_TYPE_VOID;</span>
<span class="udiff-line-modified-added">+       flags = UNIX64_RET_VOID | UNIX64_FLAG_RET_IN_MEM;</span>
      }
<span class="udiff-line-modified-removed">-       else if (flags == FFI_TYPE_STRUCT)</span>
<span class="udiff-line-modified-added">+       else</span>
      {
<span class="udiff-line-removed">-       /* Mark which registers the result appears in.  */</span>
        _Bool sse0 = SSE_CLASS_P (classes[0]);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (rtype_size == 4 &amp;&amp; sse0)</span>
<span class="udiff-line-added">+         flags = UNIX64_RET_XMM32;</span>
<span class="udiff-line-added">+       else if (rtype_size == 8)</span>
<span class="udiff-line-added">+         flags = sse0 ? UNIX64_RET_XMM64 : UNIX64_RET_INT64;</span>
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+         {</span>
        _Bool sse1 = n == 2 &amp;&amp; SSE_CLASS_P (classes[1]);
<span class="udiff-line-modified-removed">-       if (sse0 &amp;&amp; !sse1)</span>
<span class="udiff-line-modified-removed">-         flags |= 1 &lt;&lt; 8;</span>
<span class="udiff-line-modified-removed">-       else if (!sse0 &amp;&amp; sse1)</span>
<span class="udiff-line-modified-removed">-         flags |= 1 &lt;&lt; 9;</span>
<span class="udiff-line-modified-removed">-       else if (sse0 &amp;&amp; sse1)</span>
<span class="udiff-line-modified-removed">-         flags |= 1 &lt;&lt; 10;</span>
<span class="udiff-line-modified-removed">-       /* Mark the true size of the structure.  */</span>
<span class="udiff-line-modified-removed">-       flags |= cif-&gt;rtype-&gt;size &lt;&lt; 12;</span>
<span class="udiff-line-modified-added">+           if (sse0 &amp;&amp; sse1)</span>
<span class="udiff-line-modified-added">+         flags = UNIX64_RET_ST_XMM0_XMM1;</span>
<span class="udiff-line-modified-added">+           else if (sse0)</span>
<span class="udiff-line-modified-added">+         flags = UNIX64_RET_ST_XMM0_RAX;</span>
<span class="udiff-line-modified-added">+           else if (sse1)</span>
<span class="udiff-line-modified-added">+         flags = UNIX64_RET_ST_RAX_XMM0;</span>
<span class="udiff-line-modified-added">+           else</span>
<span class="udiff-line-modified-added">+         flags = UNIX64_RET_ST_RAX_RDX;</span>
<span class="udiff-line-added">+           flags |= rtype_size &lt;&lt; UNIX64_SIZE_SHIFT;</span>
      }
      }
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_COMPLEX:</span>
<span class="udiff-line-added">+       switch (rtype-&gt;elements[0]-&gt;type)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT8:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT8:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT16:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT16:</span>
<span class="udiff-line-added">+     case FFI_TYPE_INT:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT32:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT32:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT64:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT64:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_ST_RAX_RDX | ((unsigned) rtype_size &lt;&lt; UNIX64_SIZE_SHIFT);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_XMM64;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_DOUBLE:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_ST_XMM0_XMM1 | (16 &lt;&lt; UNIX64_SIZE_SHIFT);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="udiff-line-added">+     case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-added">+       flags = UNIX64_RET_X87_2;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_TYPEDEF;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_TYPEDEF;</span>
<span class="udiff-line-added">+     }</span>
  
    /* Go over all arguments and determine the way they should be passed.
       If it&#39;s in a register and there is space for it, let that be so. If
       not, add it&#39;s size to the stack byte count.  */
    for (bytes = 0, i = 0, avn = cif-&gt;nargs; i &lt; avn; i++)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -400,58 +534,64 @@</span>
        long align = cif-&gt;arg_types[i]-&gt;alignment;
  
        if (align &lt; 8)
          align = 8;
  
<span class="udiff-line-modified-removed">-       bytes = ALIGN (bytes, align);</span>
<span class="udiff-line-modified-added">+       bytes = FFI_ALIGN (bytes, align);</span>
        bytes += cif-&gt;arg_types[i]-&gt;size;
      }
        else
      {
        gprcount += ngpr;
        ssecount += nsse;
      }
      }
    if (ssecount)
<span class="udiff-line-modified-removed">-     flags |= 1 &lt;&lt; 11;</span>
<span class="udiff-line-modified-added">+     flags |= UNIX64_FLAG_XMM_ARGS;</span>
<span class="udiff-line-added">+ </span>
    cif-&gt;flags = flags;
<span class="udiff-line-modified-removed">-   cif-&gt;bytes = (unsigned)ALIGN (bytes, 8);</span>
<span class="udiff-line-modified-added">+   cif-&gt;bytes = (unsigned) FFI_ALIGN (bytes, 8);</span>
  
    return FFI_OK;
  }
  
<span class="udiff-line-modified-removed">- void</span>
<span class="udiff-line-modified-removed">- ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
<span class="udiff-line-modified-added">+ static void</span>
<span class="udiff-line-modified-added">+ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="udiff-line-added">+           void **avalue, void *closure)</span>
  {
    enum x86_64_reg_class classes[MAX_CLASSES];
    char *stack, *argp;
    ffi_type **arg_types;
<span class="udiff-line-modified-removed">-   int gprcount, ssecount, ngpr, nsse, i, avn;</span>
<span class="udiff-line-removed">-   _Bool ret_in_memory;</span>
<span class="udiff-line-modified-added">+   int gprcount, ssecount, ngpr, nsse, i, avn, flags;</span>
    struct register_args *reg_args;
  
    /* Can&#39;t call 32-bit mode from 64-bit mode.  */
    FFI_ASSERT (cif-&gt;abi == FFI_UNIX64);
  
    /* If the return value is a struct and we don&#39;t have a return value
<span class="udiff-line-modified-removed">-      address then we need to make one.  Note the setting of flags to</span>
<span class="udiff-line-modified-removed">-      VOID above in ffi_prep_cif_machdep.  */</span>
<span class="udiff-line-modified-removed">-   ret_in_memory = (cif-&gt;rtype-&gt;type == FFI_TYPE_STRUCT</span>
<span class="udiff-line-modified-removed">-            &amp;&amp; (cif-&gt;flags &amp; 0xff) == FFI_TYPE_VOID);</span>
<span class="udiff-line-modified-removed">-   if (rvalue == NULL &amp;&amp; ret_in_memory)</span>
<span class="udiff-line-modified-added">+      address then we need to make one.  Otherwise we can ignore it.  */</span>
<span class="udiff-line-modified-added">+   flags = cif-&gt;flags;</span>
<span class="udiff-line-modified-added">+   if (rvalue == NULL)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
      rvalue = alloca (cif-&gt;rtype-&gt;size);
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+     flags = UNIX64_RET_VOID;</span>
<span class="udiff-line-added">+     }</span>
  
    /* Allocate the space for the arguments, plus 4 words of temp space.  */
    stack = alloca (sizeof (struct register_args) + cif-&gt;bytes + 4*8);
    reg_args = (struct register_args *) stack;
    argp = stack + sizeof (struct register_args);
  
<span class="udiff-line-added">+   reg_args-&gt;r10 = (uintptr_t) closure;</span>
<span class="udiff-line-added">+ </span>
    gprcount = ssecount = 0;
  
    /* If the return value is passed in memory, add the pointer as the
       first integer argument.  */
<span class="udiff-line-modified-removed">-   if (ret_in_memory)</span>
<span class="udiff-line-modified-added">+   if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
      reg_args-&gt;gpr[gprcount++] = (unsigned long) rvalue;
  
    avn = cif-&gt;nargs;
    arg_types = cif-&gt;arg_types;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,149 +609,190 @@</span>
        /* Stack arguments are *always* at least 8 byte aligned.  */
        if (align &lt; 8)
          align = 8;
  
        /* Pass this argument in memory.  */
<span class="udiff-line-modified-removed">-       argp = (void *) ALIGN (argp, align);</span>
<span class="udiff-line-modified-added">+       argp = (void *) FFI_ALIGN (argp, align);</span>
        memcpy (argp, avalue[i], size);
        argp += size;
      }
        else
      {
        /* The argument is passed entirely in registers.  */
        char *a = (char *) avalue[i];
<span class="udiff-line-modified-removed">-       int j;</span>
<span class="udiff-line-modified-added">+       unsigned int j;</span>
  
        for (j = 0; j &lt; n; j++, a += 8, size -= 8)
          {
            switch (classes[j])
          {
<span class="udiff-line-added">+         case X86_64_NO_CLASS:</span>
<span class="udiff-line-added">+         case X86_64_SSEUP_CLASS:</span>
<span class="udiff-line-added">+           break;</span>
          case X86_64_INTEGER_CLASS:
          case X86_64_INTEGERSI_CLASS:
            /* Sign-extend integer arguments passed in general
               purpose registers, to cope with the fact that
               LLVM incorrectly assumes that this will be done
               (the x86-64 PS ABI does not specify this). */
            switch (arg_types[i]-&gt;type)
              {
              case FFI_TYPE_SINT8:
<span class="udiff-line-modified-removed">-               *(SINT64 *)&amp;reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT8 *) a);</span>
<span class="udiff-line-modified-added">+               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT8 *) a);</span>
                break;
              case FFI_TYPE_SINT16:
<span class="udiff-line-modified-removed">-               *(SINT64 *)&amp;reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT16 *) a);</span>
<span class="udiff-line-modified-added">+               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT16 *) a);</span>
                break;
              case FFI_TYPE_SINT32:
<span class="udiff-line-modified-removed">-               *(SINT64 *)&amp;reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT32 *) a);</span>
<span class="udiff-line-modified-added">+               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT32 *) a);</span>
                break;
              default:
                reg_args-&gt;gpr[gprcount] = 0;
<span class="udiff-line-modified-removed">-               memcpy (&amp;reg_args-&gt;gpr[gprcount], a, size &lt; 8 ? size : 8);</span>
<span class="udiff-line-modified-added">+               memcpy (&amp;reg_args-&gt;gpr[gprcount], a, size);</span>
              }
            gprcount++;
            break;
          case X86_64_SSE_CLASS:
          case X86_64_SSEDF_CLASS:
<span class="udiff-line-modified-removed">-           reg_args-&gt;sse[ssecount++].i64 = *(UINT64 *) a;</span>
<span class="udiff-line-modified-added">+           memcpy (&amp;reg_args-&gt;sse[ssecount++].i64, a, sizeof(UINT64));</span>
            break;
          case X86_64_SSESF_CLASS:
<span class="udiff-line-modified-removed">-           reg_args-&gt;sse[ssecount++].i32 = *(UINT32 *) a;</span>
<span class="udiff-line-modified-added">+           memcpy (&amp;reg_args-&gt;sse[ssecount++].i32, a, sizeof(UINT32));</span>
            break;
          default:
            abort();
          }
          }
      }
      }
<span class="udiff-line-added">+   reg_args-&gt;rax = ssecount;</span>
  
    ffi_call_unix64 (stack, cif-&gt;bytes + sizeof (struct register_args),
<span class="udiff-line-modified-removed">-            cif-&gt;flags, rvalue, fn, ssecount);</span>
<span class="udiff-line-modified-added">+            flags, rvalue, fn);</span>
  }
  
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+ extern void</span>
<span class="udiff-line-added">+ ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);</span>
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">- extern void ffi_closure_unix64(void);</span>
<span class="udiff-line-modified-added">+ void</span>
<span class="udiff-line-added">+ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       ffi_call_efi64(cif, fn, rvalue, avalue);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   ffi_call_int (cif, fn, rvalue, avalue, NULL);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+ extern void</span>
<span class="udiff-line-added">+ ffi_call_go_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="udiff-line-added">+           void **avalue, void *closure);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void</span>
<span class="udiff-line-added">+ ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="udiff-line-added">+          void **avalue, void *closure)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       ffi_call_go_efi64(cif, fn, rvalue, avalue, closure);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   ffi_call_int (cif, fn, rvalue, avalue, closure);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ extern void ffi_closure_unix64(void) FFI_HIDDEN;</span>
<span class="udiff-line-added">+ extern void ffi_closure_unix64_sse(void) FFI_HIDDEN;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+ extern ffi_status</span>
<span class="udiff-line-added">+ ffi_prep_closure_loc_efi64(ffi_closure* closure,</span>
<span class="udiff-line-added">+                ffi_cif* cif,</span>
<span class="udiff-line-added">+                void (*fun)(ffi_cif*, void*, void**, void*),</span>
<span class="udiff-line-added">+                void *user_data,</span>
<span class="udiff-line-added">+                void *codeloc);</span>
<span class="udiff-line-added">+ #endif</span>
  
  ffi_status
  ffi_prep_closure_loc (ffi_closure* closure,
                ffi_cif* cif,
                void (*fun)(ffi_cif*, void*, void**, void*),
                void *user_data,
                void *codeloc)
  {
<span class="udiff-line-modified-removed">-   volatile unsigned short *tramp;</span>
<span class="udiff-line-modified-added">+   static const unsigned char trampoline[16] = {</span>
<span class="udiff-line-added">+     /* leaq  -0x7(%rip),%r10   # 0x0  */</span>
<span class="udiff-line-added">+     0x4c, 0x8d, 0x15, 0xf9, 0xff, 0xff, 0xff,</span>
<span class="udiff-line-added">+     /* jmpq  *0x3(%rip)        # 0x10 */</span>
<span class="udiff-line-added">+     0xff, 0x25, 0x03, 0x00, 0x00, 0x00,</span>
<span class="udiff-line-added">+     /* nopl  (%rax) */</span>
<span class="udiff-line-added">+     0x0f, 0x1f, 0x00</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+   void (*dest)(void);</span>
<span class="udiff-line-added">+   char *tramp = closure-&gt;tramp;</span>
  
<span class="udiff-line-modified-removed">-   /* Sanity check on the cif ABI.  */</span>
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-removed">-     int abi = cif-&gt;abi;</span>
<span class="udiff-line-modified-removed">-     if (UNLIKELY (! (abi &gt; FFI_FIRST_ABI &amp;&amp; abi &lt; FFI_LAST_ABI)))</span>
<span class="udiff-line-modified-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-modified-added">+   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="udiff-line-modified-added">+     return ffi_prep_closure_loc_efi64(closure, cif, fun, user_data, codeloc);</span>
<span class="udiff-line-modified-added">+ #endif</span>
<span class="udiff-line-added">+   if (cif-&gt;abi != FFI_UNIX64)</span>
        return FFI_BAD_ABI;
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   tramp = (volatile unsigned short *) &amp;closure-&gt;tramp[0];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   tramp[0] = 0xbb49;        /* mov &lt;code&gt;, %r11 */</span>
<span class="udiff-line-removed">-   *((unsigned long long * volatile) &amp;tramp[1])</span>
<span class="udiff-line-removed">-     = (unsigned long) ffi_closure_unix64;</span>
<span class="udiff-line-removed">-   tramp[5] = 0xba49;        /* mov &lt;data&gt;, %r10 */</span>
<span class="udiff-line-removed">-   *((unsigned long long * volatile) &amp;tramp[6])</span>
<span class="udiff-line-removed">-     = (unsigned long) codeloc;</span>
  
<span class="udiff-line-modified-removed">-   /* Set the carry bit iff the function uses any sse registers.</span>
<span class="udiff-line-modified-removed">-      This is clc or stc, together with the first byte of the jmp.  */</span>
<span class="udiff-line-modified-removed">-   tramp[10] = cif-&gt;flags &amp; (1 &lt;&lt; 11) ? 0x49f9 : 0x49f8;</span>
<span class="udiff-line-modified-added">+   if (cif-&gt;flags &amp; UNIX64_FLAG_XMM_ARGS)</span>
<span class="udiff-line-modified-added">+     dest = ffi_closure_unix64_sse;</span>
<span class="udiff-line-modified-added">+   else</span>
<span class="udiff-line-added">+     dest = ffi_closure_unix64;</span>
  
<span class="udiff-line-modified-removed">-   tramp[11] = 0xe3ff;           /* jmp *%r11    */</span>
<span class="udiff-line-modified-added">+   memcpy (tramp, trampoline, sizeof(trampoline));</span>
<span class="udiff-line-added">+   *(UINT64 *)(tramp + 16) = (uintptr_t)dest;</span>
  
    closure-&gt;cif = cif;
    closure-&gt;fun = fun;
    closure-&gt;user_data = user_data;
  
    return FFI_OK;
  }
  
<span class="udiff-line-modified-removed">- int</span>
<span class="udiff-line-modified-removed">- ffi_closure_unix64_inner(ffi_closure *closure, void *rvalue,</span>
<span class="udiff-line-modified-removed">-              struct register_args *reg_args, char *argp)</span>
<span class="udiff-line-modified-added">+ int FFI_HIDDEN</span>
<span class="udiff-line-modified-added">+ ffi_closure_unix64_inner(ffi_cif *cif,</span>
<span class="udiff-line-modified-added">+              void (*fun)(ffi_cif*, void*, void**, void*),</span>
<span class="udiff-line-added">+              void *user_data,</span>
<span class="udiff-line-added">+              void *rvalue,</span>
<span class="udiff-line-added">+              struct register_args *reg_args,</span>
<span class="udiff-line-added">+              char *argp)</span>
  {
<span class="udiff-line-removed">-   ffi_cif *cif;</span>
    void **avalue;
    ffi_type **arg_types;
    long i, avn;
    int gprcount, ssecount, ngpr, nsse;
<span class="udiff-line-modified-removed">-   int ret;</span>
<span class="udiff-line-modified-added">+   int flags;</span>
  
<span class="udiff-line-modified-removed">-   cif = closure-&gt;cif;</span>
<span class="udiff-line-modified-removed">-   avalue = alloca(cif-&gt;nargs * sizeof(void *));</span>
<span class="udiff-line-modified-added">+   avn = cif-&gt;nargs;</span>
<span class="udiff-line-modified-added">+   flags = cif-&gt;flags;</span>
<span class="udiff-line-added">+   avalue = alloca(avn * sizeof(void *));</span>
    gprcount = ssecount = 0;
  
<span class="udiff-line-modified-removed">-   ret = cif-&gt;rtype-&gt;type;</span>
<span class="udiff-line-removed">-   if (ret != FFI_TYPE_VOID)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       enum x86_64_reg_class classes[MAX_CLASSES];</span>
<span class="udiff-line-removed">-       size_t n = examine_argument (cif-&gt;rtype, classes, 1, &amp;ngpr, &amp;nsse);</span>
<span class="udiff-line-removed">-       if (n == 0)</span>
<span class="udiff-line-modified-added">+   if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
      {
<span class="udiff-line-modified-removed">-       /* The return value goes in memory.  Arrange for the closure</span>
<span class="udiff-line-modified-removed">-          return value to go directly back to the original caller.  */</span>
<span class="udiff-line-modified-removed">-       rvalue = (void *) (unsigned long) reg_args-&gt;gpr[gprcount++];</span>
<span class="udiff-line-modified-removed">-       /* We don&#39;t have to do anything in asm for the return.  */</span>
<span class="udiff-line-modified-removed">-       ret = FFI_TYPE_VOID;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">-       else if (ret == FFI_TYPE_STRUCT &amp;&amp; n == 2)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       /* Mark which register the second word of the structure goes in.  */</span>
<span class="udiff-line-removed">-       _Bool sse0 = SSE_CLASS_P (classes[0]);</span>
<span class="udiff-line-removed">-       _Bool sse1 = SSE_CLASS_P (classes[1]);</span>
<span class="udiff-line-removed">-       if (!sse0 &amp;&amp; sse1)</span>
<span class="udiff-line-removed">-         ret |= 1 &lt;&lt; 8;</span>
<span class="udiff-line-removed">-       else if (sse0 &amp;&amp; !sse1)</span>
<span class="udiff-line-removed">-         ret |= 1 &lt;&lt; 9;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+       /* On return, %rax will contain the address that was passed</span>
<span class="udiff-line-modified-added">+      by the caller in %rdi.  */</span>
<span class="udiff-line-modified-added">+       void *r = (void *)(uintptr_t)reg_args-&gt;gpr[gprcount++];</span>
<span class="udiff-line-modified-added">+       *(void **)rvalue = r;</span>
<span class="udiff-line-modified-added">+       rvalue = r;</span>
<span class="udiff-line-modified-added">+       flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);</span>
      }
  
<span class="udiff-line-removed">-   avn = cif-&gt;nargs;</span>
    arg_types = cif-&gt;arg_types;
<span class="udiff-line-removed">- </span>
    for (i = 0; i &lt; avn; ++i)
      {
        enum x86_64_reg_class classes[MAX_CLASSES];
        size_t n;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -625,11 +806,11 @@</span>
        /* Stack arguments are *always* at least 8 byte aligned.  */
        if (align &lt; 8)
          align = 8;
  
        /* Pass this argument in memory.  */
<span class="udiff-line-modified-removed">-       argp = (void *) ALIGN (argp, align);</span>
<span class="udiff-line-modified-added">+       argp = (void *) FFI_ALIGN (argp, align);</span>
        avalue[i] = argp;
        argp += arg_types[i]-&gt;size;
      }
        /* If the argument is in a single register, or two consecutive
       integer registers, then we can use that address directly.  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -651,11 +832,11 @@</span>
      }
        /* Otherwise, allocate space to make them consecutive.  */
        else
      {
        char *a = alloca (16);
<span class="udiff-line-modified-removed">-       int j;</span>
<span class="udiff-line-modified-added">+       unsigned int j;</span>
  
        avalue[i] = a;
        for (j = 0; j &lt; n; j++, a += 8)
          {
            if (SSE_CLASS_P (classes[j]))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -665,12 +846,41 @@</span>
          }
      }
      }
  
    /* Invoke the closure.  */
<span class="udiff-line-modified-removed">-   closure-&gt;fun (cif, rvalue, avalue, closure-&gt;user_data);</span>
<span class="udiff-line-modified-added">+   fun (cif, rvalue, avalue, user_data);</span>
  
    /* Tell assembly how to perform return type promotions.  */
<span class="udiff-line-modified-removed">-   return ret;</span>
<span class="udiff-line-modified-added">+   return flags;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ extern void ffi_go_closure_unix64(void) FFI_HIDDEN;</span>
<span class="udiff-line-added">+ extern void ffi_go_closure_unix64_sse(void) FFI_HIDDEN;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+ extern ffi_status</span>
<span class="udiff-line-added">+ ffi_prep_go_closure_efi64(ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="udiff-line-added">+               void (*fun)(ffi_cif*, void*, void**, void*));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ffi_status</span>
<span class="udiff-line-added">+ ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="udiff-line-added">+              void (*fun)(ffi_cif*, void*, void**, void*))</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ #ifndef __ILP32__</span>
<span class="udiff-line-added">+   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="udiff-line-added">+     return ffi_prep_go_closure_efi64(closure, cif, fun);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+   if (cif-&gt;abi != FFI_UNIX64)</span>
<span class="udiff-line-added">+     return FFI_BAD_ABI;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   closure-&gt;tramp = (cif-&gt;flags &amp; UNIX64_FLAG_XMM_ARGS</span>
<span class="udiff-line-added">+             ? ffi_go_closure_unix64_sse</span>
<span class="udiff-line-added">+             : ffi_go_closure_unix64);</span>
<span class="udiff-line-added">+   closure-&gt;cif = cif;</span>
<span class="udiff-line-added">+   closure-&gt;fun = fun;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return FFI_OK;</span>
  }
  
  #endif /* __x86_64__ */
</pre>
<center><a href="ffi.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="win64.S.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi64.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* -----------------------------------------------------------------------
<a name="1" id="anc1"></a><span class="line-modified">  2    ffi64.c - Copyright (c) 2011, 2018  Anthony Green</span>
<span class="line-modified">  3              Copyright (c) 2013  The Written Word, Inc.</span>
  4              Copyright (c) 2008, 2010  Red Hat, Inc.
  5              Copyright (c) 2002, 2007  Bo Thorsen &lt;bo@suse.de&gt;
  6 
  7    x86-64 Foreign Function Interface
  8 
  9    Permission is hereby granted, free of charge, to any person obtaining
 10    a copy of this software and associated documentation files (the
 11    ``Software&#39;&#39;), to deal in the Software without restriction, including
 12    without limitation the rights to use, copy, modify, merge, publish,
 13    distribute, sublicense, and/or sell copies of the Software, and to
 14    permit persons to whom the Software is furnished to do so, subject to
 15    the following conditions:
 16 
 17    The above copyright notice and this permission notice shall be included
 18    in all copies or substantial portions of the Software.
 19 
 20    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 21    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 22    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 23    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 24    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 25    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 26    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 27    DEALINGS IN THE SOFTWARE.
 28    ----------------------------------------------------------------------- */
 29 
 30 #include &lt;ffi.h&gt;
 31 #include &lt;ffi_common.h&gt;
 32 
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;stdarg.h&gt;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &lt;stdint.h&gt;</span>
<span class="line-added"> 36 #include &quot;internal64.h&quot;</span>
 37 
 38 #ifdef __x86_64__
 39 
 40 #define MAX_GPR_REGS 6
 41 #define MAX_SSE_REGS 8
 42 
 43 #if defined(__INTEL_COMPILER)
 44 #include &quot;xmmintrin.h&quot;
 45 #define UINT128 __m128
 46 #else
 47 #if defined(__SUNPRO_C)
 48 #include &lt;sunmedia_types.h&gt;
 49 #define UINT128 __m128i
 50 #else
 51 #define UINT128 __int128_t
 52 #endif
 53 #endif
 54 
 55 union big_int_union
 56 {
 57   UINT32 i32;
 58   UINT64 i64;
 59   UINT128 i128;
 60 };
 61 
 62 struct register_args
 63 {
 64   /* Registers for argument passing.  */
 65   UINT64 gpr[MAX_GPR_REGS];
 66   union big_int_union sse[MAX_SSE_REGS];
<a name="3" id="anc3"></a><span class="line-added"> 67   UINT64 rax;   /* ssecount */</span>
<span class="line-added"> 68   UINT64 r10;   /* static chain */</span>
 69 };
 70 
 71 extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
<a name="4" id="anc4"></a><span class="line-modified"> 72                  void *raddr, void (*fnaddr)(void)) FFI_HIDDEN;</span>
 73 
 74 /* All reference to register classes here is identical to the code in
 75    gcc/config/i386/i386.c. Do *not* change one without the other.  */
 76 
 77 /* Register class used for passing given 64bit part of the argument.
 78    These represent classes as documented by the PS ABI, with the
 79    exception of SSESF, SSEDF classes, that are basically SSE class,
 80    just gcc will use SF or DFmode move instead of DImode to avoid
 81    reformatting penalties.
 82 
 83    Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
 84    whenever possible (upper half does contain padding).  */
 85 enum x86_64_reg_class
 86   {
 87     X86_64_NO_CLASS,
 88     X86_64_INTEGER_CLASS,
 89     X86_64_INTEGERSI_CLASS,
 90     X86_64_SSE_CLASS,
 91     X86_64_SSESF_CLASS,
 92     X86_64_SSEDF_CLASS,
 93     X86_64_SSEUP_CLASS,
 94     X86_64_X87_CLASS,
 95     X86_64_X87UP_CLASS,
 96     X86_64_COMPLEX_X87_CLASS,
 97     X86_64_MEMORY_CLASS
 98   };
 99 
100 #define MAX_CLASSES 4
101 
102 #define SSE_CLASS_P(X)  ((X) &gt;= X86_64_SSE_CLASS &amp;&amp; X &lt;= X86_64_SSEUP_CLASS)
103 
104 /* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal
105    of this code is to classify each 8bytes of incoming argument by the register
106    class and assign registers accordingly.  */
107 
108 /* Return the union class of CLASS1 and CLASS2.
109    See the x86-64 PS ABI for details.  */
110 
111 static enum x86_64_reg_class
112 merge_classes (enum x86_64_reg_class class1, enum x86_64_reg_class class2)
113 {
114   /* Rule #1: If both classes are equal, this is the resulting class.  */
115   if (class1 == class2)
116     return class1;
117 
118   /* Rule #2: If one of the classes is NO_CLASS, the resulting class is
119      the other class.  */
120   if (class1 == X86_64_NO_CLASS)
121     return class2;
122   if (class2 == X86_64_NO_CLASS)
123     return class1;
124 
125   /* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
126   if (class1 == X86_64_MEMORY_CLASS || class2 == X86_64_MEMORY_CLASS)
127     return X86_64_MEMORY_CLASS;
128 
129   /* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
130   if ((class1 == X86_64_INTEGERSI_CLASS &amp;&amp; class2 == X86_64_SSESF_CLASS)
131       || (class2 == X86_64_INTEGERSI_CLASS &amp;&amp; class1 == X86_64_SSESF_CLASS))
132     return X86_64_INTEGERSI_CLASS;
133   if (class1 == X86_64_INTEGER_CLASS || class1 == X86_64_INTEGERSI_CLASS
134       || class2 == X86_64_INTEGER_CLASS || class2 == X86_64_INTEGERSI_CLASS)
135     return X86_64_INTEGER_CLASS;
136 
137   /* Rule #5: If one of the classes is X87, X87UP, or COMPLEX_X87 class,
138      MEMORY is used.  */
139   if (class1 == X86_64_X87_CLASS
140       || class1 == X86_64_X87UP_CLASS
141       || class1 == X86_64_COMPLEX_X87_CLASS
142       || class2 == X86_64_X87_CLASS
143       || class2 == X86_64_X87UP_CLASS
144       || class2 == X86_64_COMPLEX_X87_CLASS)
145     return X86_64_MEMORY_CLASS;
146 
147   /* Rule #6: Otherwise class SSE is used.  */
148   return X86_64_SSE_CLASS;
149 }
150 
151 /* Classify the argument of type TYPE and mode MODE.
152    CLASSES will be filled by the register class used to pass each word
153    of the operand.  The number of words is returned.  In case the parameter
154    should be passed in memory, 0 is returned. As a special case for zero
155    sized containers, classes[0] will be NO_CLASS and 1 is returned.
156 
157    See the x86-64 PS ABI for details.
158 */
159 static size_t
160 classify_argument (ffi_type *type, enum x86_64_reg_class classes[],
161            size_t byte_offset)
162 {
163   switch (type-&gt;type)
164     {
165     case FFI_TYPE_UINT8:
166     case FFI_TYPE_SINT8:
167     case FFI_TYPE_UINT16:
168     case FFI_TYPE_SINT16:
169     case FFI_TYPE_UINT32:
170     case FFI_TYPE_SINT32:
171     case FFI_TYPE_UINT64:
172     case FFI_TYPE_SINT64:
173     case FFI_TYPE_POINTER:
<a name="5" id="anc5"></a><span class="line-added">174     do_integer:</span>
175       {
176     size_t size = byte_offset + type-&gt;size;
177 
178     if (size &lt;= 4)
179       {
180         classes[0] = X86_64_INTEGERSI_CLASS;
181         return 1;
182       }
183     else if (size &lt;= 8)
184       {
185         classes[0] = X86_64_INTEGER_CLASS;
186         return 1;
187       }
188     else if (size &lt;= 12)
189       {
190         classes[0] = X86_64_INTEGER_CLASS;
191         classes[1] = X86_64_INTEGERSI_CLASS;
192         return 2;
193       }
194     else if (size &lt;= 16)
195       {
<a name="6" id="anc6"></a><span class="line-modified">196         classes[0] = classes[1] = X86_64_INTEGER_CLASS;</span>
197         return 2;
198       }
199     else
200       FFI_ASSERT (0);
201       }
202     case FFI_TYPE_FLOAT:
203       if (!(byte_offset % 8))
204     classes[0] = X86_64_SSESF_CLASS;
205       else
206     classes[0] = X86_64_SSE_CLASS;
207       return 1;
208     case FFI_TYPE_DOUBLE:
209       classes[0] = X86_64_SSEDF_CLASS;
210       return 1;
211 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
212     case FFI_TYPE_LONGDOUBLE:
213       classes[0] = X86_64_X87_CLASS;
214       classes[1] = X86_64_X87UP_CLASS;
215       return 2;
216 #endif
217     case FFI_TYPE_STRUCT:
218       {
219     const size_t UNITS_PER_WORD = 8;
220     size_t words = (type-&gt;size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
221     ffi_type **ptr;
<a name="7" id="anc7"></a><span class="line-modified">222     unsigned int i;</span>
223     enum x86_64_reg_class subclasses[MAX_CLASSES];
224 
225     /* If the struct is larger than 32 bytes, pass it on the stack.  */
226     if (type-&gt;size &gt; 32)
227       return 0;
228 
229     for (i = 0; i &lt; words; i++)
230       classes[i] = X86_64_NO_CLASS;
231 
232     /* Zero sized arrays or structures are NO_CLASS.  We return 0 to
233        signalize memory class, so handle it as special case.  */
234     if (!words)
235       {
<a name="8" id="anc8"></a><span class="line-added">236     case FFI_TYPE_VOID:</span>
237         classes[0] = X86_64_NO_CLASS;
238         return 1;
239       }
240 
241     /* Merge the fields of structure.  */
242     for (ptr = type-&gt;elements; *ptr != NULL; ptr++)
243       {
244         size_t num;
245 
<a name="9" id="anc9"></a><span class="line-modified">246         byte_offset = FFI_ALIGN (byte_offset, (*ptr)-&gt;alignment);</span>
247 
248         num = classify_argument (*ptr, subclasses, byte_offset % 8);
249         if (num == 0)
250           return 0;
251         for (i = 0; i &lt; num; i++)
252           {
253         size_t pos = byte_offset / 8;
254         classes[i + pos] =
255           merge_classes (subclasses[i], classes[i + pos]);
256           }
257 
258         byte_offset += (*ptr)-&gt;size;
259       }
260 
261     if (words &gt; 2)
262       {
263         /* When size &gt; 16 bytes, if the first one isn&#39;t
264            X86_64_SSE_CLASS or any other ones aren&#39;t
265            X86_64_SSEUP_CLASS, everything should be passed in
266            memory.  */
267         if (classes[0] != X86_64_SSE_CLASS)
268           return 0;
269 
270         for (i = 1; i &lt; words; i++)
271           if (classes[i] != X86_64_SSEUP_CLASS)
272         return 0;
273       }
274 
275     /* Final merger cleanup.  */
276     for (i = 0; i &lt; words; i++)
277       {
278         /* If one class is MEMORY, everything should be passed in
279            memory.  */
280         if (classes[i] == X86_64_MEMORY_CLASS)
281           return 0;
282 
283         /* The X86_64_SSEUP_CLASS should be always preceded by
284            X86_64_SSE_CLASS or X86_64_SSEUP_CLASS.  */
<a name="10" id="anc10"></a><span class="line-modified">285         if (i &gt; 1 &amp;&amp; classes[i] == X86_64_SSEUP_CLASS</span>
286         &amp;&amp; classes[i - 1] != X86_64_SSE_CLASS
287         &amp;&amp; classes[i - 1] != X86_64_SSEUP_CLASS)
288           {
289         /* The first one should never be X86_64_SSEUP_CLASS.  */
290         FFI_ASSERT (i != 0);
291         classes[i] = X86_64_SSE_CLASS;
292           }
293 
294         /*  If X86_64_X87UP_CLASS isn&#39;t preceded by X86_64_X87_CLASS,
295         everything should be passed in memory.  */
<a name="11" id="anc11"></a><span class="line-modified">296         if (i &gt; 1 &amp;&amp; classes[i] == X86_64_X87UP_CLASS</span>
297         &amp;&amp; (classes[i - 1] != X86_64_X87_CLASS))
298           {
299         /* The first one should never be X86_64_X87UP_CLASS.  */
300         FFI_ASSERT (i != 0);
301         return 0;
302           }
303       }
304     return words;
305       }
<a name="12" id="anc12"></a><span class="line-modified">306     case FFI_TYPE_COMPLEX:</span>
<span class="line-modified">307       {</span>
<span class="line-modified">308     ffi_type *inner = type-&gt;elements[0];</span>
<span class="line-added">309     switch (inner-&gt;type)</span>
<span class="line-added">310       {</span>
<span class="line-added">311       case FFI_TYPE_INT:</span>
<span class="line-added">312       case FFI_TYPE_UINT8:</span>
<span class="line-added">313       case FFI_TYPE_SINT8:</span>
<span class="line-added">314       case FFI_TYPE_UINT16:</span>
<span class="line-added">315       case FFI_TYPE_SINT16:</span>
<span class="line-added">316       case FFI_TYPE_UINT32:</span>
<span class="line-added">317       case FFI_TYPE_SINT32:</span>
<span class="line-added">318       case FFI_TYPE_UINT64:</span>
<span class="line-added">319       case FFI_TYPE_SINT64:</span>
<span class="line-added">320         goto do_integer;</span>
<span class="line-added">321 </span>
<span class="line-added">322       case FFI_TYPE_FLOAT:</span>
<span class="line-added">323         classes[0] = X86_64_SSE_CLASS;</span>
<span class="line-added">324         if (byte_offset % 8)</span>
<span class="line-added">325           {</span>
<span class="line-added">326         classes[1] = X86_64_SSESF_CLASS;</span>
<span class="line-added">327         return 2;</span>
328     }
<a name="13" id="anc13"></a><span class="line-modified">329         return 1;</span>
<span class="line-added">330       case FFI_TYPE_DOUBLE:</span>
<span class="line-added">331         classes[0] = classes[1] = X86_64_SSEDF_CLASS;</span>
<span class="line-added">332         return 2;</span>
<span class="line-added">333 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-added">334       case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">335         classes[0] = X86_64_COMPLEX_X87_CLASS;</span>
<span class="line-added">336         return 1;</span>
<span class="line-added">337 #endif</span>
<span class="line-added">338 }</span>
<span class="line-added">339       }</span>
<span class="line-added">340     }</span>
<span class="line-added">341   abort();</span>
342 }
343 
344 /* Examine the argument and return set number of register required in each
345    class.  Return zero iff parameter should be passed in memory, otherwise
346    the number of registers.  */
347 
348 static size_t
349 examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
350           _Bool in_return, int *pngpr, int *pnsse)
351 {
352   size_t n;
<a name="14" id="anc14"></a><span class="line-modified">353   unsigned int i;</span>
<span class="line-added">354   int ngpr, nsse;</span>
355 
356   n = classify_argument (type, classes, 0);
357   if (n == 0)
358     return 0;
359 
360   ngpr = nsse = 0;
361   for (i = 0; i &lt; n; ++i)
362     switch (classes[i])
363       {
364       case X86_64_INTEGER_CLASS:
365       case X86_64_INTEGERSI_CLASS:
366     ngpr++;
367     break;
368       case X86_64_SSE_CLASS:
369       case X86_64_SSESF_CLASS:
370       case X86_64_SSEDF_CLASS:
371     nsse++;
372     break;
373       case X86_64_NO_CLASS:
374       case X86_64_SSEUP_CLASS:
375     break;
376       case X86_64_X87_CLASS:
377       case X86_64_X87UP_CLASS:
378       case X86_64_COMPLEX_X87_CLASS:
379     return in_return != 0;
380       default:
381     abort ();
382       }
383 
384   *pngpr = ngpr;
385   *pnsse = nsse;
386 
387   return n;
388 }
389 
390 /* Perform machine dependent cif processing.  */
391 
<a name="15" id="anc15"></a><span class="line-modified">392 #ifndef __ILP32__</span>
<span class="line-added">393 extern ffi_status</span>
<span class="line-added">394 ffi_prep_cif_machdep_efi64(ffi_cif *cif);</span>
<span class="line-added">395 #endif</span>
<span class="line-added">396 </span>
<span class="line-added">397 ffi_status FFI_HIDDEN</span>
398 ffi_prep_cif_machdep (ffi_cif *cif)
399 {
<a name="16" id="anc16"></a><span class="line-modified">400   int gprcount, ssecount, i, avn, ngpr, nsse;</span>
<span class="line-added">401   unsigned flags;</span>
402   enum x86_64_reg_class classes[MAX_CLASSES];
<a name="17" id="anc17"></a><span class="line-modified">403   size_t bytes, n, rtype_size;</span>
<span class="line-added">404   ffi_type *rtype;</span>
<span class="line-added">405 </span>
<span class="line-added">406 #ifndef __ILP32__</span>
<span class="line-added">407   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">408     return ffi_prep_cif_machdep_efi64(cif);</span>
<span class="line-added">409 #endif</span>
<span class="line-added">410   if (cif-&gt;abi != FFI_UNIX64)</span>
<span class="line-added">411     return FFI_BAD_ABI;</span>
412 
413   gprcount = ssecount = 0;
414 
<a name="18" id="anc18"></a><span class="line-modified">415   rtype = cif-&gt;rtype;</span>
<span class="line-modified">416   rtype_size = rtype-&gt;size;</span>
<span class="line-added">417   switch (rtype-&gt;type)</span>
418     {
<a name="19" id="anc19"></a><span class="line-added">419     case FFI_TYPE_VOID:</span>
<span class="line-added">420       flags = UNIX64_RET_VOID;</span>
<span class="line-added">421       break;</span>
<span class="line-added">422     case FFI_TYPE_UINT8:</span>
<span class="line-added">423       flags = UNIX64_RET_UINT8;</span>
<span class="line-added">424       break;</span>
<span class="line-added">425     case FFI_TYPE_SINT8:</span>
<span class="line-added">426       flags = UNIX64_RET_SINT8;</span>
<span class="line-added">427       break;</span>
<span class="line-added">428     case FFI_TYPE_UINT16:</span>
<span class="line-added">429       flags = UNIX64_RET_UINT16;</span>
<span class="line-added">430       break;</span>
<span class="line-added">431     case FFI_TYPE_SINT16:</span>
<span class="line-added">432       flags = UNIX64_RET_SINT16;</span>
<span class="line-added">433       break;</span>
<span class="line-added">434     case FFI_TYPE_UINT32:</span>
<span class="line-added">435       flags = UNIX64_RET_UINT32;</span>
<span class="line-added">436       break;</span>
<span class="line-added">437     case FFI_TYPE_INT:</span>
<span class="line-added">438     case FFI_TYPE_SINT32:</span>
<span class="line-added">439       flags = UNIX64_RET_SINT32;</span>
<span class="line-added">440       break;</span>
<span class="line-added">441     case FFI_TYPE_UINT64:</span>
<span class="line-added">442     case FFI_TYPE_SINT64:</span>
<span class="line-added">443       flags = UNIX64_RET_INT64;</span>
<span class="line-added">444       break;</span>
<span class="line-added">445     case FFI_TYPE_POINTER:</span>
<span class="line-added">446       flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);</span>
<span class="line-added">447       break;</span>
<span class="line-added">448     case FFI_TYPE_FLOAT:</span>
<span class="line-added">449       flags = UNIX64_RET_XMM32;</span>
<span class="line-added">450       break;</span>
<span class="line-added">451     case FFI_TYPE_DOUBLE:</span>
<span class="line-added">452       flags = UNIX64_RET_XMM64;</span>
<span class="line-added">453       break;</span>
<span class="line-added">454 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-added">455     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">456       flags = UNIX64_RET_X87;</span>
<span class="line-added">457       break;</span>
<span class="line-added">458 #endif</span>
<span class="line-added">459     case FFI_TYPE_STRUCT:</span>
460       n = examine_argument (cif-&gt;rtype, classes, 1, &amp;ngpr, &amp;nsse);
461       if (n == 0)
462     {
463       /* The return value is passed in memory.  A pointer to that
464          memory is the first argument.  Allocate a register for it.  */
465       gprcount++;
466       /* We don&#39;t have to do anything in asm for the return.  */
<a name="20" id="anc20"></a><span class="line-modified">467       flags = UNIX64_RET_VOID | UNIX64_FLAG_RET_IN_MEM;</span>
468     }
<a name="21" id="anc21"></a><span class="line-modified">469       else</span>
470     {
<a name="22" id="anc22"></a>
471       _Bool sse0 = SSE_CLASS_P (classes[0]);
<a name="23" id="anc23"></a><span class="line-added">472 </span>
<span class="line-added">473       if (rtype_size == 4 &amp;&amp; sse0)</span>
<span class="line-added">474         flags = UNIX64_RET_XMM32;</span>
<span class="line-added">475       else if (rtype_size == 8)</span>
<span class="line-added">476         flags = sse0 ? UNIX64_RET_XMM64 : UNIX64_RET_INT64;</span>
<span class="line-added">477       else</span>
<span class="line-added">478         {</span>
479       _Bool sse1 = n == 2 &amp;&amp; SSE_CLASS_P (classes[1]);
<a name="24" id="anc24"></a><span class="line-modified">480           if (sse0 &amp;&amp; sse1)</span>
<span class="line-modified">481         flags = UNIX64_RET_ST_XMM0_XMM1;</span>
<span class="line-modified">482           else if (sse0)</span>
<span class="line-modified">483         flags = UNIX64_RET_ST_XMM0_RAX;</span>
<span class="line-modified">484           else if (sse1)</span>
<span class="line-modified">485         flags = UNIX64_RET_ST_RAX_XMM0;</span>
<span class="line-modified">486           else</span>
<span class="line-modified">487         flags = UNIX64_RET_ST_RAX_RDX;</span>
<span class="line-added">488           flags |= rtype_size &lt;&lt; UNIX64_SIZE_SHIFT;</span>
489     }
490     }
<a name="25" id="anc25"></a><span class="line-added">491       break;</span>
<span class="line-added">492     case FFI_TYPE_COMPLEX:</span>
<span class="line-added">493       switch (rtype-&gt;elements[0]-&gt;type)</span>
<span class="line-added">494     {</span>
<span class="line-added">495     case FFI_TYPE_UINT8:</span>
<span class="line-added">496     case FFI_TYPE_SINT8:</span>
<span class="line-added">497     case FFI_TYPE_UINT16:</span>
<span class="line-added">498     case FFI_TYPE_SINT16:</span>
<span class="line-added">499     case FFI_TYPE_INT:</span>
<span class="line-added">500     case FFI_TYPE_UINT32:</span>
<span class="line-added">501     case FFI_TYPE_SINT32:</span>
<span class="line-added">502     case FFI_TYPE_UINT64:</span>
<span class="line-added">503     case FFI_TYPE_SINT64:</span>
<span class="line-added">504       flags = UNIX64_RET_ST_RAX_RDX | ((unsigned) rtype_size &lt;&lt; UNIX64_SIZE_SHIFT);</span>
<span class="line-added">505       break;</span>
<span class="line-added">506     case FFI_TYPE_FLOAT:</span>
<span class="line-added">507       flags = UNIX64_RET_XMM64;</span>
<span class="line-added">508       break;</span>
<span class="line-added">509     case FFI_TYPE_DOUBLE:</span>
<span class="line-added">510       flags = UNIX64_RET_ST_XMM0_XMM1 | (16 &lt;&lt; UNIX64_SIZE_SHIFT);</span>
<span class="line-added">511       break;</span>
<span class="line-added">512 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-added">513     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">514       flags = UNIX64_RET_X87_2;</span>
<span class="line-added">515       break;</span>
<span class="line-added">516 #endif</span>
<span class="line-added">517     default:</span>
<span class="line-added">518       return FFI_BAD_TYPEDEF;</span>
<span class="line-added">519     }</span>
<span class="line-added">520       break;</span>
<span class="line-added">521     default:</span>
<span class="line-added">522       return FFI_BAD_TYPEDEF;</span>
<span class="line-added">523     }</span>
524 
525   /* Go over all arguments and determine the way they should be passed.
526      If it&#39;s in a register and there is space for it, let that be so. If
527      not, add it&#39;s size to the stack byte count.  */
528   for (bytes = 0, i = 0, avn = cif-&gt;nargs; i &lt; avn; i++)
529     {
530       if (examine_argument (cif-&gt;arg_types[i], classes, 0, &amp;ngpr, &amp;nsse) == 0
531       || gprcount + ngpr &gt; MAX_GPR_REGS
532       || ssecount + nsse &gt; MAX_SSE_REGS)
533     {
534       long align = cif-&gt;arg_types[i]-&gt;alignment;
535 
536       if (align &lt; 8)
537         align = 8;
538 
<a name="26" id="anc26"></a><span class="line-modified">539       bytes = FFI_ALIGN (bytes, align);</span>
540       bytes += cif-&gt;arg_types[i]-&gt;size;
541     }
542       else
543     {
544       gprcount += ngpr;
545       ssecount += nsse;
546     }
547     }
548   if (ssecount)
<a name="27" id="anc27"></a><span class="line-modified">549     flags |= UNIX64_FLAG_XMM_ARGS;</span>
<span class="line-added">550 </span>
551   cif-&gt;flags = flags;
<a name="28" id="anc28"></a><span class="line-modified">552   cif-&gt;bytes = (unsigned) FFI_ALIGN (bytes, 8);</span>
553 
554   return FFI_OK;
555 }
556 
<a name="29" id="anc29"></a><span class="line-modified">557 static void</span>
<span class="line-modified">558 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">559           void **avalue, void *closure)</span>
560 {
561   enum x86_64_reg_class classes[MAX_CLASSES];
562   char *stack, *argp;
563   ffi_type **arg_types;
<a name="30" id="anc30"></a><span class="line-modified">564   int gprcount, ssecount, ngpr, nsse, i, avn, flags;</span>

565   struct register_args *reg_args;
566 
567   /* Can&#39;t call 32-bit mode from 64-bit mode.  */
568   FFI_ASSERT (cif-&gt;abi == FFI_UNIX64);
569 
570   /* If the return value is a struct and we don&#39;t have a return value
<a name="31" id="anc31"></a><span class="line-modified">571      address then we need to make one.  Otherwise we can ignore it.  */</span>
<span class="line-modified">572   flags = cif-&gt;flags;</span>
<span class="line-modified">573   if (rvalue == NULL)</span>
<span class="line-modified">574     {</span>
<span class="line-modified">575       if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
576     rvalue = alloca (cif-&gt;rtype-&gt;size);
<a name="32" id="anc32"></a><span class="line-added">577       else</span>
<span class="line-added">578     flags = UNIX64_RET_VOID;</span>
<span class="line-added">579     }</span>
580 
581   /* Allocate the space for the arguments, plus 4 words of temp space.  */
582   stack = alloca (sizeof (struct register_args) + cif-&gt;bytes + 4*8);
583   reg_args = (struct register_args *) stack;
584   argp = stack + sizeof (struct register_args);
585 
<a name="33" id="anc33"></a><span class="line-added">586   reg_args-&gt;r10 = (uintptr_t) closure;</span>
<span class="line-added">587 </span>
588   gprcount = ssecount = 0;
589 
590   /* If the return value is passed in memory, add the pointer as the
591      first integer argument.  */
<a name="34" id="anc34"></a><span class="line-modified">592   if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
593     reg_args-&gt;gpr[gprcount++] = (unsigned long) rvalue;
594 
595   avn = cif-&gt;nargs;
596   arg_types = cif-&gt;arg_types;
597 
598   for (i = 0; i &lt; avn; ++i)
599     {
600       size_t n, size = arg_types[i]-&gt;size;
601 
602       n = examine_argument (arg_types[i], classes, 0, &amp;ngpr, &amp;nsse);
603       if (n == 0
604       || gprcount + ngpr &gt; MAX_GPR_REGS
605       || ssecount + nsse &gt; MAX_SSE_REGS)
606     {
607       long align = arg_types[i]-&gt;alignment;
608 
609       /* Stack arguments are *always* at least 8 byte aligned.  */
610       if (align &lt; 8)
611         align = 8;
612 
613       /* Pass this argument in memory.  */
<a name="35" id="anc35"></a><span class="line-modified">614       argp = (void *) FFI_ALIGN (argp, align);</span>
615       memcpy (argp, avalue[i], size);
616       argp += size;
617     }
618       else
619     {
620       /* The argument is passed entirely in registers.  */
621       char *a = (char *) avalue[i];
<a name="36" id="anc36"></a><span class="line-modified">622       unsigned int j;</span>
623 
624       for (j = 0; j &lt; n; j++, a += 8, size -= 8)
625         {
626           switch (classes[j])
627         {
<a name="37" id="anc37"></a><span class="line-added">628         case X86_64_NO_CLASS:</span>
<span class="line-added">629         case X86_64_SSEUP_CLASS:</span>
<span class="line-added">630           break;</span>
631         case X86_64_INTEGER_CLASS:
632         case X86_64_INTEGERSI_CLASS:
633           /* Sign-extend integer arguments passed in general
634              purpose registers, to cope with the fact that
635              LLVM incorrectly assumes that this will be done
636              (the x86-64 PS ABI does not specify this). */
637           switch (arg_types[i]-&gt;type)
638             {
639             case FFI_TYPE_SINT8:
<a name="38" id="anc38"></a><span class="line-modified">640               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT8 *) a);</span>
641               break;
642             case FFI_TYPE_SINT16:
<a name="39" id="anc39"></a><span class="line-modified">643               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT16 *) a);</span>
644               break;
645             case FFI_TYPE_SINT32:
<a name="40" id="anc40"></a><span class="line-modified">646               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT32 *) a);</span>
647               break;
648             default:
649               reg_args-&gt;gpr[gprcount] = 0;
<a name="41" id="anc41"></a><span class="line-modified">650               memcpy (&amp;reg_args-&gt;gpr[gprcount], a, size);</span>
651             }
652           gprcount++;
653           break;
654         case X86_64_SSE_CLASS:
655         case X86_64_SSEDF_CLASS:
<a name="42" id="anc42"></a><span class="line-modified">656           memcpy (&amp;reg_args-&gt;sse[ssecount++].i64, a, sizeof(UINT64));</span>
657           break;
658         case X86_64_SSESF_CLASS:
<a name="43" id="anc43"></a><span class="line-modified">659           memcpy (&amp;reg_args-&gt;sse[ssecount++].i32, a, sizeof(UINT32));</span>
660           break;
661         default:
662           abort();
663         }
664         }
665     }
666     }
<a name="44" id="anc44"></a><span class="line-added">667   reg_args-&gt;rax = ssecount;</span>
668 
669   ffi_call_unix64 (stack, cif-&gt;bytes + sizeof (struct register_args),
<a name="45" id="anc45"></a><span class="line-modified">670            flags, rvalue, fn);</span>
671 }
672 
<a name="46" id="anc46"></a><span class="line-added">673 #ifndef __ILP32__</span>
<span class="line-added">674 extern void</span>
<span class="line-added">675 ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);</span>
<span class="line-added">676 #endif</span>
677 
<a name="47" id="anc47"></a><span class="line-modified">678 void</span>
<span class="line-added">679 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
<span class="line-added">680 {</span>
<span class="line-added">681 #ifndef __ILP32__</span>
<span class="line-added">682   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">683     {</span>
<span class="line-added">684       ffi_call_efi64(cif, fn, rvalue, avalue);</span>
<span class="line-added">685       return;</span>
<span class="line-added">686     }</span>
<span class="line-added">687 #endif</span>
<span class="line-added">688   ffi_call_int (cif, fn, rvalue, avalue, NULL);</span>
<span class="line-added">689 }</span>
<span class="line-added">690 </span>
<span class="line-added">691 #ifndef __ILP32__</span>
<span class="line-added">692 extern void</span>
<span class="line-added">693 ffi_call_go_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">694           void **avalue, void *closure);</span>
<span class="line-added">695 #endif</span>
<span class="line-added">696 </span>
<span class="line-added">697 void</span>
<span class="line-added">698 ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">699          void **avalue, void *closure)</span>
<span class="line-added">700 {</span>
<span class="line-added">701 #ifndef __ILP32__</span>
<span class="line-added">702   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">703     {</span>
<span class="line-added">704       ffi_call_go_efi64(cif, fn, rvalue, avalue, closure);</span>
<span class="line-added">705       return;</span>
<span class="line-added">706     }</span>
<span class="line-added">707 #endif</span>
<span class="line-added">708   ffi_call_int (cif, fn, rvalue, avalue, closure);</span>
<span class="line-added">709 }</span>
<span class="line-added">710 </span>
<span class="line-added">711 </span>
<span class="line-added">712 extern void ffi_closure_unix64(void) FFI_HIDDEN;</span>
<span class="line-added">713 extern void ffi_closure_unix64_sse(void) FFI_HIDDEN;</span>
<span class="line-added">714 </span>
<span class="line-added">715 #ifndef __ILP32__</span>
<span class="line-added">716 extern ffi_status</span>
<span class="line-added">717 ffi_prep_closure_loc_efi64(ffi_closure* closure,</span>
<span class="line-added">718                ffi_cif* cif,</span>
<span class="line-added">719                void (*fun)(ffi_cif*, void*, void**, void*),</span>
<span class="line-added">720                void *user_data,</span>
<span class="line-added">721                void *codeloc);</span>
<span class="line-added">722 #endif</span>
723 
724 ffi_status
725 ffi_prep_closure_loc (ffi_closure* closure,
726               ffi_cif* cif,
727               void (*fun)(ffi_cif*, void*, void**, void*),
728               void *user_data,
729               void *codeloc)
730 {
<a name="48" id="anc48"></a><span class="line-modified">731   static const unsigned char trampoline[16] = {</span>
<span class="line-added">732     /* leaq  -0x7(%rip),%r10   # 0x0  */</span>
<span class="line-added">733     0x4c, 0x8d, 0x15, 0xf9, 0xff, 0xff, 0xff,</span>
<span class="line-added">734     /* jmpq  *0x3(%rip)        # 0x10 */</span>
<span class="line-added">735     0xff, 0x25, 0x03, 0x00, 0x00, 0x00,</span>
<span class="line-added">736     /* nopl  (%rax) */</span>
<span class="line-added">737     0x0f, 0x1f, 0x00</span>
<span class="line-added">738   };</span>
<span class="line-added">739   void (*dest)(void);</span>
<span class="line-added">740   char *tramp = closure-&gt;tramp;</span>
741 
<a name="49" id="anc49"></a><span class="line-modified">742 #ifndef __ILP32__</span>
<span class="line-modified">743   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-modified">744     return ffi_prep_closure_loc_efi64(closure, cif, fun, user_data, codeloc);</span>
<span class="line-modified">745 #endif</span>
<span class="line-added">746   if (cif-&gt;abi != FFI_UNIX64)</span>
747       return FFI_BAD_ABI;
<a name="50" id="anc50"></a>









748 
<a name="51" id="anc51"></a><span class="line-modified">749   if (cif-&gt;flags &amp; UNIX64_FLAG_XMM_ARGS)</span>
<span class="line-modified">750     dest = ffi_closure_unix64_sse;</span>
<span class="line-modified">751   else</span>
<span class="line-added">752     dest = ffi_closure_unix64;</span>
753 
<a name="52" id="anc52"></a><span class="line-modified">754   memcpy (tramp, trampoline, sizeof(trampoline));</span>
<span class="line-added">755   *(UINT64 *)(tramp + 16) = (uintptr_t)dest;</span>
756 
757   closure-&gt;cif = cif;
758   closure-&gt;fun = fun;
759   closure-&gt;user_data = user_data;
760 
761   return FFI_OK;
762 }
763 
<a name="53" id="anc53"></a><span class="line-modified">764 int FFI_HIDDEN</span>
<span class="line-modified">765 ffi_closure_unix64_inner(ffi_cif *cif,</span>
<span class="line-modified">766              void (*fun)(ffi_cif*, void*, void**, void*),</span>
<span class="line-added">767              void *user_data,</span>
<span class="line-added">768              void *rvalue,</span>
<span class="line-added">769              struct register_args *reg_args,</span>
<span class="line-added">770              char *argp)</span>
771 {
<a name="54" id="anc54"></a>
772   void **avalue;
773   ffi_type **arg_types;
774   long i, avn;
775   int gprcount, ssecount, ngpr, nsse;
<a name="55" id="anc55"></a><span class="line-modified">776   int flags;</span>
777 
<a name="56" id="anc56"></a><span class="line-modified">778   avn = cif-&gt;nargs;</span>
<span class="line-modified">779   flags = cif-&gt;flags;</span>
<span class="line-added">780   avalue = alloca(avn * sizeof(void *));</span>
781   gprcount = ssecount = 0;
782 
<a name="57" id="anc57"></a><span class="line-modified">783   if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>





784     {
<a name="58" id="anc58"></a><span class="line-modified">785       /* On return, %rax will contain the address that was passed</span>
<span class="line-modified">786      by the caller in %rdi.  */</span>
<span class="line-modified">787       void *r = (void *)(uintptr_t)reg_args-&gt;gpr[gprcount++];</span>
<span class="line-modified">788       *(void **)rvalue = r;</span>
<span class="line-modified">789       rvalue = r;</span>
<span class="line-modified">790       flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);</span>










791     }
792 
<a name="59" id="anc59"></a>
793   arg_types = cif-&gt;arg_types;
<a name="60" id="anc60"></a>
794   for (i = 0; i &lt; avn; ++i)
795     {
796       enum x86_64_reg_class classes[MAX_CLASSES];
797       size_t n;
798 
799       n = examine_argument (arg_types[i], classes, 0, &amp;ngpr, &amp;nsse);
800       if (n == 0
801       || gprcount + ngpr &gt; MAX_GPR_REGS
802       || ssecount + nsse &gt; MAX_SSE_REGS)
803     {
804       long align = arg_types[i]-&gt;alignment;
805 
806       /* Stack arguments are *always* at least 8 byte aligned.  */
807       if (align &lt; 8)
808         align = 8;
809 
810       /* Pass this argument in memory.  */
<a name="61" id="anc61"></a><span class="line-modified">811       argp = (void *) FFI_ALIGN (argp, align);</span>
812       avalue[i] = argp;
813       argp += arg_types[i]-&gt;size;
814     }
815       /* If the argument is in a single register, or two consecutive
816      integer registers, then we can use that address directly.  */
817       else if (n == 1
818            || (n == 2 &amp;&amp; !(SSE_CLASS_P (classes[0])
819                    || SSE_CLASS_P (classes[1]))))
820     {
821       /* The argument is in a single register.  */
822       if (SSE_CLASS_P (classes[0]))
823         {
824           avalue[i] = &amp;reg_args-&gt;sse[ssecount];
825           ssecount += n;
826         }
827       else
828         {
829           avalue[i] = &amp;reg_args-&gt;gpr[gprcount];
830           gprcount += n;
831         }
832     }
833       /* Otherwise, allocate space to make them consecutive.  */
834       else
835     {
836       char *a = alloca (16);
<a name="62" id="anc62"></a><span class="line-modified">837       unsigned int j;</span>
838 
839       avalue[i] = a;
840       for (j = 0; j &lt; n; j++, a += 8)
841         {
842           if (SSE_CLASS_P (classes[j]))
843         memcpy (a, &amp;reg_args-&gt;sse[ssecount++], 8);
844           else
845         memcpy (a, &amp;reg_args-&gt;gpr[gprcount++], 8);
846         }
847     }
848     }
849 
850   /* Invoke the closure.  */
<a name="63" id="anc63"></a><span class="line-modified">851   fun (cif, rvalue, avalue, user_data);</span>
852 
853   /* Tell assembly how to perform return type promotions.  */
<a name="64" id="anc64"></a><span class="line-modified">854   return flags;</span>
<span class="line-added">855 }</span>
<span class="line-added">856 </span>
<span class="line-added">857 extern void ffi_go_closure_unix64(void) FFI_HIDDEN;</span>
<span class="line-added">858 extern void ffi_go_closure_unix64_sse(void) FFI_HIDDEN;</span>
<span class="line-added">859 </span>
<span class="line-added">860 #ifndef __ILP32__</span>
<span class="line-added">861 extern ffi_status</span>
<span class="line-added">862 ffi_prep_go_closure_efi64(ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="line-added">863               void (*fun)(ffi_cif*, void*, void**, void*));</span>
<span class="line-added">864 #endif</span>
<span class="line-added">865 </span>
<span class="line-added">866 ffi_status</span>
<span class="line-added">867 ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="line-added">868              void (*fun)(ffi_cif*, void*, void**, void*))</span>
<span class="line-added">869 {</span>
<span class="line-added">870 #ifndef __ILP32__</span>
<span class="line-added">871   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">872     return ffi_prep_go_closure_efi64(closure, cif, fun);</span>
<span class="line-added">873 #endif</span>
<span class="line-added">874   if (cif-&gt;abi != FFI_UNIX64)</span>
<span class="line-added">875     return FFI_BAD_ABI;</span>
<span class="line-added">876 </span>
<span class="line-added">877   closure-&gt;tramp = (cif-&gt;flags &amp; UNIX64_FLAG_XMM_ARGS</span>
<span class="line-added">878             ? ffi_go_closure_unix64_sse</span>
<span class="line-added">879             : ffi_go_closure_unix64);</span>
<span class="line-added">880   closure-&gt;cif = cif;</span>
<span class="line-added">881   closure-&gt;fun = fun;</span>
<span class="line-added">882 </span>
<span class="line-added">883   return FFI_OK;</span>
884 }
885 
886 #endif /* __x86_64__ */
<a name="65" id="anc65"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="65" type="hidden" />
</body>
</html>
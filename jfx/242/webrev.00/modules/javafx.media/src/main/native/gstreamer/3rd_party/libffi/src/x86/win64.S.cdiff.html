<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/win64.S</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ffi64.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../projects/mac/glib-lite/Makefile.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/win64.S</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,528 ***</span>
  #define LIBFFI_ASM
  #include &lt;fficonfig.h&gt;
  #include &lt;ffi.h&gt;
  
<span class="line-modified">! /* Constants for ffi_call_win64 */</span>
<span class="line-modified">! #define STACK 0</span>
<span class="line-modified">! #define PREP_ARGS_FN 32</span>
<span class="line-removed">- #define ECIF 40</span>
<span class="line-removed">- #define CIF_BYTES 48</span>
<span class="line-removed">- #define CIF_FLAGS 56</span>
<span class="line-removed">- #define RVALUE 64</span>
<span class="line-removed">- #define FN 72</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* ffi_call_win64 (void (*prep_args_fn)(char *, extended_cif *),</span>
<span class="line-removed">- 		   extended_cif *ecif, unsigned bytes, unsigned flags,</span>
<span class="line-removed">- 		   unsigned *rvalue, void (*fn)());</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _MSC_VER</span>
<span class="line-removed">- PUBLIC	ffi_call_win64</span>
<span class="line-removed">- </span>
<span class="line-removed">- EXTRN	__chkstk:NEAR</span>
<span class="line-removed">- EXTRN	ffi_closure_win64_inner:NEAR</span>
<span class="line-removed">- </span>
<span class="line-removed">- _TEXT	SEGMENT</span>
<span class="line-removed">- </span>
<span class="line-removed">- ;;; ffi_closure_win64 will be called with these registers set:</span>
<span class="line-removed">- ;;;    rax points to &#39;closure&#39;</span>
<span class="line-removed">- ;;;    r11 contains a bit mask that specifies which of the</span>
<span class="line-removed">- ;;;    first four parameters are float or double</span>
<span class="line-removed">- ;;;</span>
<span class="line-removed">- ;;; It must move the parameters passed in registers to their stack location,</span>
<span class="line-removed">- ;;; call ffi_closure_win64_inner for the actual work, then return the result.</span>
<span class="line-removed">- ;;;</span>
<span class="line-removed">- ffi_closure_win64 PROC FRAME</span>
<span class="line-removed">- 	;; copy register arguments onto stack</span>
<span class="line-removed">- 	test	r11, 1</span>
<span class="line-removed">- 	jne	first_is_float</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+8], rcx</span>
<span class="line-removed">- 	jmp	second</span>
<span class="line-removed">- first_is_float:</span>
<span class="line-removed">- 	movlpd	QWORD PTR [rsp+8], xmm0</span>
<span class="line-removed">- </span>
<span class="line-removed">- second:</span>
<span class="line-removed">- 	test	r11, 2</span>
<span class="line-removed">- 	jne	second_is_float</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+16], rdx</span>
<span class="line-removed">- 	jmp	third</span>
<span class="line-removed">- second_is_float:</span>
<span class="line-removed">- 	movlpd	QWORD PTR [rsp+16], xmm1</span>
<span class="line-removed">- </span>
<span class="line-removed">- third:</span>
<span class="line-removed">- 	test	r11, 4</span>
<span class="line-removed">- 	jne	third_is_float</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+24], r8</span>
<span class="line-removed">- 	jmp	fourth</span>
<span class="line-removed">- third_is_float:</span>
<span class="line-removed">- 	movlpd	QWORD PTR [rsp+24], xmm2</span>
<span class="line-removed">- </span>
<span class="line-removed">- fourth:</span>
<span class="line-removed">- 	test	r11, 8</span>
<span class="line-removed">- 	jne	fourth_is_float</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+32], r9</span>
<span class="line-removed">- 	jmp	done</span>
<span class="line-removed">- fourth_is_float:</span>
<span class="line-removed">- 	movlpd	QWORD PTR [rsp+32], xmm3</span>
<span class="line-removed">- </span>
<span class="line-removed">- done:</span>
<span class="line-removed">- 	.ALLOCSTACK 40</span>
<span class="line-removed">- 	sub	rsp, 40</span>
<span class="line-removed">- 	.ENDPROLOG</span>
<span class="line-removed">- 	mov	rcx, rax	; context is first parameter</span>
<span class="line-removed">- 	mov	rdx, rsp	; stack is second parameter</span>
<span class="line-removed">- 	add	rdx, 48		; point to start of arguments</span>
<span class="line-removed">- 	mov	rax, ffi_closure_win64_inner</span>
<span class="line-removed">- 	call	rax		; call the real closure function</span>
<span class="line-removed">- 	add	rsp, 40</span>
<span class="line-removed">- 	movd	xmm0, rax	; If the closure returned a float,</span>
<span class="line-removed">- 				; ffi_closure_win64_inner wrote it to rax</span>
<span class="line-removed">- 	ret	0</span>
<span class="line-removed">- ffi_closure_win64 ENDP</span>
<span class="line-removed">- </span>
<span class="line-removed">- ffi_call_win64 PROC FRAME</span>
<span class="line-removed">- 	;; copy registers onto stack</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+32], r9</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+24], r8</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+16], rdx</span>
<span class="line-removed">- 	mov	QWORD PTR [rsp+8], rcx</span>
<span class="line-removed">- 	.PUSHREG rbp</span>
<span class="line-removed">- 	push	rbp</span>
<span class="line-removed">- 	.ALLOCSTACK 48</span>
<span class="line-removed">- 	sub	rsp, 48					; 00000030H</span>
<span class="line-removed">- 	.SETFRAME rbp, 32</span>
<span class="line-removed">- 	lea	rbp, QWORD PTR [rsp+32]</span>
<span class="line-removed">- 	.ENDPROLOG</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	eax, DWORD PTR CIF_BYTES[rbp]</span>
<span class="line-removed">- 	add	rax, 15</span>
<span class="line-removed">- 	and	rax, -16</span>
<span class="line-removed">- 	call	__chkstk</span>
<span class="line-removed">- 	sub	rsp, rax</span>
<span class="line-removed">- 	lea	rax, QWORD PTR [rsp+32]</span>
<span class="line-removed">- 	mov	QWORD PTR STACK[rbp], rax</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rdx, QWORD PTR ECIF[rbp]</span>
<span class="line-removed">- 	mov	rcx, QWORD PTR STACK[rbp]</span>
<span class="line-removed">- 	call	QWORD PTR PREP_ARGS_FN[rbp]</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rsp, QWORD PTR STACK[rbp]</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	movlpd	xmm3, QWORD PTR [rsp+24]</span>
<span class="line-removed">- 	movd	r9, xmm3</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	movlpd	xmm2, QWORD PTR [rsp+16]</span>
<span class="line-removed">- 	movd	r8, xmm2</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	movlpd	xmm1, QWORD PTR [rsp+8]</span>
<span class="line-removed">- 	movd	rdx, xmm1</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	movlpd	xmm0, QWORD PTR [rsp]</span>
<span class="line-removed">- 	movd	rcx, xmm0</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	call	QWORD PTR FN[rbp]</span>
<span class="line-removed">- ret_struct4b$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_4B</span>
<span class="line-removed">-  	jne	ret_struct2b$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	mov	DWORD PTR [rcx], eax</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_struct2b$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_2B</span>
<span class="line-removed">-  	jne	ret_struct1b$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	mov	WORD PTR [rcx], ax</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_struct1b$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SMALL_STRUCT_1B</span>
<span class="line-removed">-  	jne	ret_uint8$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	mov	BYTE PTR [rcx], al</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_uint8$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT8</span>
<span class="line-removed">-  	jne	ret_sint8$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	movzx   rax, al</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_sint8$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT8</span>
<span class="line-removed">-  	jne	ret_uint16$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	movsx   rax, al</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_uint16$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT16</span>
<span class="line-removed">-  	jne	ret_sint16$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	movzx   rax, ax</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">- #ifndef GSTREAMER_LITE</span>
<span class="line-removed">- 	jmp	SHORT ret_void$</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- #endif // GSTREAMER_LITE</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_sint16$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT16</span>
<span class="line-removed">-  	jne	ret_uint32$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	movsx   rax, ax</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">- #ifndef GSTREAMER_LITE</span>
<span class="line-removed">- 	jmp	SHORT ret_void$</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- 	jmp	ret_void$</span>
<span class="line-removed">- #endif // GSTREAMER_LITE</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_uint32$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT32</span>
<span class="line-removed">-  	jne	ret_sint32$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	mov     eax, eax</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">- 	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_sint32$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT32</span>
<span class="line-removed">-  	jne	ret_float$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	cdqe</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">- 	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_float$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_FLOAT</span>
<span class="line-removed">-  	jne	SHORT ret_double$</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	rax, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">-  	movss	DWORD PTR [rax], xmm0</span>
<span class="line-removed">-  	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_double$:</span>
<span class="line-removed">-  	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_DOUBLE</span>
<span class="line-removed">-  	jne	SHORT ret_uint64$</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	rax, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">-  	movlpd	QWORD PTR [rax], xmm0</span>
<span class="line-removed">-  	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_uint64$:</span>
<span class="line-removed">-   	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_UINT64</span>
<span class="line-removed">-   	jne	SHORT ret_sint64$</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">-  	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">-  	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_sint64$:</span>
<span class="line-removed">-   	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_SINT64</span>
<span class="line-removed">-   	jne	SHORT ret_pointer$</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">-  	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">-  	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_pointer$:</span>
<span class="line-removed">-   	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_POINTER</span>
<span class="line-removed">-   	jne	SHORT ret_int$</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">-  	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">-  	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_int$:</span>
<span class="line-removed">-   	cmp	DWORD PTR CIF_FLAGS[rbp], FFI_TYPE_INT</span>
<span class="line-removed">-   	jne	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	rcx, QWORD PTR RVALUE[rbp]</span>
<span class="line-removed">- 	cdqe</span>
<span class="line-removed">- 	mov	QWORD PTR [rcx], rax</span>
<span class="line-removed">-  	jmp	SHORT ret_void$</span>
<span class="line-removed">- </span>
<span class="line-removed">- ret_void$:</span>
<span class="line-removed">- 	xor	rax, rax</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	lea	rsp, QWORD PTR [rbp+16]</span>
<span class="line-removed">- 	pop	rbp</span>
<span class="line-removed">- 	ret	0</span>
<span class="line-removed">- ffi_call_win64 ENDP</span>
<span class="line-removed">- _TEXT	ENDS</span>
<span class="line-removed">- END</span>
  
  #else
  
<span class="line-modified">! #ifdef SYMBOL_UNDERSCORE</span>
<span class="line-modified">! #define SYMBOL_NAME(name) _##name</span>
  #else
<span class="line-modified">! #define SYMBOL_NAME(name) name</span>
  #endif
  
<span class="line-modified">! .text</span>
<span class="line-modified">! </span>
<span class="line-modified">! .extern SYMBOL_NAME(ffi_closure_win64_inner)</span>
<span class="line-modified">! </span>
<span class="line-modified">! # ffi_closure_win64 will be called with these registers set:</span>
<span class="line-modified">! #    rax points to &#39;closure&#39;</span>
<span class="line-modified">! #    r11 contains a bit mask that specifies which of the</span>
<span class="line-modified">! #    first four parameters are float or double</span>
<span class="line-modified">! #</span>
<span class="line-modified">! # It must move the parameters passed in registers to their stack location,</span>
<span class="line-modified">! # call ffi_closure_win64_inner for the actual work, then return the result.</span>
<span class="line-modified">! #</span>
<span class="line-modified">! 	.balign 16</span>
<span class="line-modified">! 	.globl SYMBOL_NAME(ffi_closure_win64)</span>
<span class="line-modified">! 	.seh_proc SYMBOL_NAME(ffi_closure_win64)</span>
<span class="line-modified">! SYMBOL_NAME(ffi_closure_win64):</span>
<span class="line-modified">! 	# copy register arguments onto stack</span>
<span class="line-modified">! 	test	$1,%r11</span>
<span class="line-modified">! 	jne	.Lfirst_is_float</span>
<span class="line-modified">! 	mov	%rcx, 8(%rsp)</span>
<span class="line-modified">! 	jmp	.Lsecond</span>
<span class="line-modified">! .Lfirst_is_float:</span>
<span class="line-modified">! 	movlpd	%xmm0, 8(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lsecond:</span>
<span class="line-modified">! 	test	$2, %r11</span>
<span class="line-modified">! 	jne	.Lsecond_is_float</span>
<span class="line-modified">! 	mov	%rdx, 16(%rsp)</span>
<span class="line-modified">! 	jmp	.Lthird</span>
<span class="line-modified">! .Lsecond_is_float:</span>
<span class="line-modified">! 	movlpd	%xmm1, 16(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lthird:</span>
<span class="line-modified">! 	test	$4, %r11</span>
<span class="line-modified">! 	jne	.Lthird_is_float</span>
<span class="line-modified">! 	mov	%r8,24(%rsp)</span>
<span class="line-modified">! 	jmp	.Lfourth</span>
<span class="line-modified">! .Lthird_is_float:</span>
<span class="line-modified">! 	movlpd	%xmm2, 24(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lfourth:</span>
<span class="line-modified">! 	test	$8, %r11</span>
<span class="line-modified">! 	jne	.Lfourth_is_float</span>
<span class="line-modified">! 	mov	%r9, 32(%rsp)</span>
<span class="line-modified">! 	jmp	.Ldone</span>
<span class="line-modified">! .Lfourth_is_float:</span>
<span class="line-modified">! 	movlpd	%xmm3, 32(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Ldone:</span>
<span class="line-modified">! 	.seh_stackalloc 40</span>
<span class="line-modified">! 	sub	$40, %rsp</span>
<span class="line-modified">! 	.seh_endprologue</span>
<span class="line-modified">! 	mov	%rax, %rcx	# context is first parameter</span>
<span class="line-modified">! 	mov	%rsp, %rdx	# stack is second parameter</span>
<span class="line-modified">! 	add	$48, %rdx	# point to start of arguments</span>
<span class="line-modified">! 	leaq	SYMBOL_NAME(ffi_closure_win64_inner)(%rip), %rax</span>
<span class="line-modified">! 	callq	*%rax		# call the real closure function</span>
<span class="line-modified">! 	add	$40, %rsp</span>
<span class="line-modified">! 	movq	%rax, %xmm0	# If the closure returned a float,</span>
<span class="line-modified">! 				# ffi_closure_win64_inner wrote it to rax</span>
<span class="line-modified">! 	retq</span>
<span class="line-modified">! 	.seh_endproc</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	.balign 16</span>
<span class="line-modified">! 	.globl	SYMBOL_NAME(ffi_call_win64)</span>
<span class="line-modified">! 	.seh_proc SYMBOL_NAME(ffi_call_win64)</span>
<span class="line-modified">! SYMBOL_NAME(ffi_call_win64):</span>
<span class="line-modified">! 	# copy registers onto stack</span>
<span class="line-modified">! 	mov	%r9,32(%rsp)</span>
<span class="line-modified">! 	mov	%r8,24(%rsp)</span>
<span class="line-modified">! 	mov	%rdx,16(%rsp)</span>
<span class="line-modified">! 	mov	%rcx,8(%rsp)</span>
<span class="line-modified">! 	.seh_pushreg rbp</span>
<span class="line-modified">! 	push	%rbp</span>
<span class="line-modified">! 	.seh_stackalloc 48</span>
<span class="line-modified">! 	sub	$48,%rsp</span>
<span class="line-modified">! 	.seh_setframe rbp, 32</span>
<span class="line-modified">! 	lea	32(%rsp),%rbp</span>
<span class="line-modified">! 	.seh_endprologue</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	CIF_BYTES(%rbp),%eax</span>
<span class="line-modified">! 	add	$15, %rax</span>
<span class="line-modified">! 	and	$-16, %rax</span>
<span class="line-modified">! 	cmpq	$0x1000, %rax</span>
<span class="line-modified">! 	jb	Lch_done</span>
<span class="line-modified">! Lch_probe:</span>
<span class="line-modified">! 	subq	$0x1000,%rsp</span>
<span class="line-modified">! 	orl	$0x0, (%rsp)</span>
<span class="line-modified">! 	subq	$0x1000,%rax</span>
<span class="line-modified">! 	cmpq	$0x1000,%rax</span>
<span class="line-modified">! 	ja	Lch_probe</span>
<span class="line-modified">! Lch_done:</span>
<span class="line-modified">! 	subq	%rax, %rsp</span>
<span class="line-modified">! 	orl	$0x0, (%rsp)</span>
<span class="line-modified">! 	lea	32(%rsp), %rax</span>
<span class="line-modified">! 	mov	%rax, STACK(%rbp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	ECIF(%rbp), %rdx</span>
<span class="line-modified">! 	mov	STACK(%rbp), %rcx</span>
<span class="line-modified">! 	callq	*PREP_ARGS_FN(%rbp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	STACK(%rbp), %rsp</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movlpd	24(%rsp), %xmm3</span>
<span class="line-modified">! 	movd	%xmm3, %r9</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movlpd	16(%rsp), %xmm2</span>
<span class="line-modified">! 	movd	%xmm2, %r8</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movlpd	8(%rsp), %xmm1</span>
<span class="line-modified">! 	movd	%xmm1, %rdx</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movlpd	(%rsp), %xmm0</span>
<span class="line-modified">! 	movd	%xmm0, %rcx</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	callq	*FN(%rbp)</span>
<span class="line-modified">! .Lret_struct4b:</span>
<span class="line-modified">!  	cmpl	$FFI_TYPE_SMALL_STRUCT_4B, CIF_FLAGS(%rbp)</span>
<span class="line-modified">!  	jne .Lret_struct2b</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	mov	%eax, (%rcx)</span>
<span class="line-modified">! 	jmp	.Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_struct2b:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_SMALL_STRUCT_2B, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_struct1b</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	mov	%ax, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_struct1b:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_SMALL_STRUCT_1B, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_uint8</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	mov	%al, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_uint8:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_UINT8, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_sint8</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov     RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	movzbq  %al, %rax</span>
<span class="line-modified">! 	movq    %rax, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_sint8:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_SINT8, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_uint16</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov     RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	movsbq  %al, %rax</span>
<span class="line-modified">! 	movq    %rax, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_uint16:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_UINT16, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_sint16</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov     RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	movzwq  %ax, %rax</span>
<span class="line-modified">! 	movq    %rax, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_sint16:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_SINT16, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_uint32</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov     RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	movswq  %ax, %rax</span>
<span class="line-modified">! 	movq    %rax, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_uint32:</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_UINT32, CIF_FLAGS(%rbp)</span>
<span class="line-modified">! 	jne .Lret_sint32</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov     RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	movl    %eax, %eax</span>
<span class="line-modified">! 	movq    %rax, (%rcx)</span>
<span class="line-modified">! 	jmp .Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_sint32:</span>
<span class="line-modified">!  	cmpl	$FFI_TYPE_SINT32, CIF_FLAGS(%rbp)</span>
<span class="line-modified">!  	jne	.Lret_float</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	mov	RVALUE(%rbp), %rcx</span>
<span class="line-modified">! 	cltq</span>
<span class="line-modified">! 	movq	%rax, (%rcx)</span>
<span class="line-modified">! 	jmp	.Lret_void</span>
<span class="line-modified">! </span>
<span class="line-modified">! .Lret_float:</span>
<span class="line-modified">!  	cmpl	$FFI_TYPE_FLOAT, CIF_FLAGS(%rbp)</span>
<span class="line-modified">!  	jne	.Lret_double</span>
<span class="line-modified">! </span>
<span class="line-modified">!  	mov	RVALUE(%rbp), %rax</span>
<span class="line-modified">!  	movss	%xmm0, (%rax)</span>
<span class="line-modified">!  	jmp	.Lret_void</span>
<span class="line-modified">! </span>
<span class="line-removed">- .Lret_double:</span>
<span class="line-removed">-  	cmpl	$FFI_TYPE_DOUBLE, CIF_FLAGS(%rbp)</span>
<span class="line-removed">-  	jne	.Lret_uint64</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	RVALUE(%rbp), %rax</span>
<span class="line-removed">-  	movlpd	%xmm0, (%rax)</span>
<span class="line-removed">-  	jmp	.Lret_void</span>
<span class="line-removed">- </span>
<span class="line-removed">- .Lret_uint64:</span>
<span class="line-removed">-   	cmpl	$FFI_TYPE_UINT64, CIF_FLAGS(%rbp)</span>
<span class="line-removed">-  	jne	.Lret_sint64</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	RVALUE(%rbp), %rcx</span>
<span class="line-removed">-  	mov	%rax, (%rcx)</span>
<span class="line-removed">-  	jmp	.Lret_void</span>
<span class="line-removed">- </span>
<span class="line-removed">- .Lret_sint64:</span>
<span class="line-removed">-   	cmpl	$FFI_TYPE_SINT64, CIF_FLAGS(%rbp)</span>
<span class="line-removed">-   	jne	.Lret_pointer</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	RVALUE(%rbp), %rcx</span>
<span class="line-removed">-  	mov	%rax, (%rcx)</span>
<span class="line-removed">-  	jmp	.Lret_void</span>
<span class="line-removed">- </span>
<span class="line-removed">- .Lret_pointer:</span>
<span class="line-removed">-   	cmpl	$FFI_TYPE_POINTER, CIF_FLAGS(%rbp)</span>
<span class="line-removed">-   	jne	.Lret_int</span>
<span class="line-removed">- </span>
<span class="line-removed">-  	mov	RVALUE(%rbp), %rcx</span>
<span class="line-removed">-  	mov	%rax, (%rcx)</span>
<span class="line-removed">-  	jmp	.Lret_void</span>
<span class="line-removed">- </span>
<span class="line-removed">- .Lret_int:</span>
<span class="line-removed">-   	cmpl	$FFI_TYPE_INT, CIF_FLAGS(%rbp)</span>
<span class="line-removed">-   	jne	.Lret_void</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	mov	RVALUE(%rbp), %rcx</span>
<span class="line-removed">- 	cltq</span>
<span class="line-removed">- 	movq	%rax, (%rcx)</span>
<span class="line-removed">- 	jmp	.Lret_void</span>
<span class="line-removed">- </span>
<span class="line-removed">- .Lret_void:</span>
<span class="line-removed">- 	xor	%rax, %rax</span>
<span class="line-removed">- </span>
<span class="line-removed">- 	lea	16(%rbp), %rsp</span>
<span class="line-removed">- 	pop	%rbp</span>
<span class="line-removed">- 	retq</span>
<span class="line-removed">- 	.seh_endproc</span>
<span class="line-removed">- #endif /* !_MSC_VER */</span>
<span class="line-removed">- </span>
<span class="line-new-header">--- 1,237 ---</span>
<span class="line-added">+ #ifdef __x86_64__</span>
  #define LIBFFI_ASM
  #include &lt;fficonfig.h&gt;
  #include &lt;ffi.h&gt;
<span class="line-added">+ #include &lt;ffi_cfi.h&gt;</span>
<span class="line-added">+ #include &quot;asmnames.h&quot;</span>
  
<span class="line-modified">! #if defined(HAVE_AS_CFI_PSEUDO_OP)</span>
<span class="line-modified">!         .cfi_sections   .debug_frame</span>
<span class="line-modified">! #endif</span>
  
<span class="line-added">+ #ifdef X86_WIN64</span>
<span class="line-added">+ #define SEH(...) __VA_ARGS__</span>
<span class="line-added">+ #define arg0	%rcx</span>
<span class="line-added">+ #define arg1	%rdx</span>
<span class="line-added">+ #define arg2	%r8</span>
<span class="line-added">+ #define arg3	%r9</span>
  #else
<span class="line-added">+ #define SEH(...)</span>
<span class="line-added">+ #define arg0	%rdi</span>
<span class="line-added">+ #define arg1	%rsi</span>
<span class="line-added">+ #define arg2	%rdx</span>
<span class="line-added">+ #define arg3	%rcx</span>
<span class="line-added">+ #endif</span>
  
<span class="line-modified">! /* This macro allows the safe creation of jump tables without an</span>
<span class="line-modified">!    actual table.  The entry points into the table are all 8 bytes.</span>
<span class="line-added">+    The use of ORG asserts that we&#39;re at the correct location.  */</span>
<span class="line-added">+ /* ??? The clang assembler doesn&#39;t handle .org with symbolic expressions.  */</span>
<span class="line-added">+ #if defined(__clang__) || defined(__APPLE__) || (defined (__sun__) &amp;&amp; defined(__svr4__))</span>
<span class="line-added">+ # define E(BASE, X)	.balign 8</span>
  #else
<span class="line-modified">! # define E(BASE, X)	.balign 8; .org BASE + X * 8</span>
  #endif
  
<span class="line-modified">! 	.text</span>
<span class="line-modified">! </span>
<span class="line-modified">! /* ffi_call_win64 (void *stack, struct win64_call_frame *frame, void *r10)</span>
<span class="line-modified">! </span>
<span class="line-modified">!    Bit o trickiness here -- FRAME is the base of the stack frame</span>
<span class="line-modified">!    for this function.  This has been allocated by ffi_call.  We also</span>
<span class="line-modified">!    deallocate some of the stack that has been alloca&#39;d.  */</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	.align	8</span>
<span class="line-modified">! 	.globl	C(ffi_call_win64)</span>
<span class="line-modified">! 	FFI_HIDDEN(C(ffi_call_win64))</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	SEH(.seh_proc ffi_call_win64)</span>
<span class="line-modified">! C(ffi_call_win64):</span>
<span class="line-modified">! 	cfi_startproc</span>
<span class="line-modified">! 	/* Set up the local stack frame and install it in rbp/rsp.  */</span>
<span class="line-modified">! 	movq	(%rsp), %rax</span>
<span class="line-modified">! 	movq	%rbp, (arg1)</span>
<span class="line-modified">! 	movq	%rax, 8(arg1)</span>
<span class="line-modified">! 	movq	arg1, %rbp</span>
<span class="line-modified">! 	cfi_def_cfa(%rbp, 16)</span>
<span class="line-modified">! 	cfi_rel_offset(%rbp, 0)</span>
<span class="line-modified">! 	SEH(.seh_pushreg %rbp)</span>
<span class="line-modified">! 	SEH(.seh_setframe %rbp, 0)</span>
<span class="line-modified">! 	SEH(.seh_endprologue)</span>
<span class="line-modified">! 	movq	arg0, %rsp</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movq	arg2, %r10</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	/* Load all slots into both general and xmm registers.  */</span>
<span class="line-modified">! 	movq	(%rsp), %rcx</span>
<span class="line-modified">! 	movsd	(%rsp), %xmm0</span>
<span class="line-modified">! 	movq	8(%rsp), %rdx</span>
<span class="line-modified">! 	movsd	8(%rsp), %xmm1</span>
<span class="line-modified">! 	movq	16(%rsp), %r8</span>
<span class="line-modified">! 	movsd	16(%rsp), %xmm2</span>
<span class="line-modified">! 	movq	24(%rsp), %r9</span>
<span class="line-modified">! 	movsd	24(%rsp), %xmm3</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	call	*16(%rbp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movl	24(%rbp), %ecx</span>
<span class="line-modified">! 	movq	32(%rbp), %r8</span>
<span class="line-modified">! 	leaq	0f(%rip), %r10</span>
<span class="line-modified">! 	cmpl	$FFI_TYPE_SMALL_STRUCT_4B, %ecx</span>
<span class="line-modified">! 	leaq	(%r10, %rcx, 8), %r10</span>
<span class="line-modified">! 	ja	99f</span>
<span class="line-modified">! 	jmp	*%r10</span>
<span class="line-modified">! </span>
<span class="line-modified">! /* Below, we&#39;re space constrained most of the time.  Thus we eschew the</span>
<span class="line-modified">!    modern &quot;mov, pop, ret&quot; sequence (5 bytes) for &quot;leave, ret&quot; (2 bytes).  */</span>
<span class="line-modified">! .macro epilogue</span>
<span class="line-modified">! 	leaveq</span>
<span class="line-modified">! 	cfi_remember_state</span>
<span class="line-modified">! 	cfi_def_cfa(%rsp, 8)</span>
<span class="line-modified">! 	cfi_restore(%rbp)</span>
<span class="line-modified">! 	ret</span>
<span class="line-modified">! 	cfi_restore_state</span>
<span class="line-modified">! .endm</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	.align	8</span>
<span class="line-modified">! 0:</span>
<span class="line-modified">! E(0b, FFI_TYPE_VOID)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_INT)</span>
<span class="line-modified">! 	movslq	%eax, %rax</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_FLOAT)</span>
<span class="line-modified">! 	movss	%xmm0, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_DOUBLE)</span>
<span class="line-modified">! 	movsd	%xmm0, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_LONGDOUBLE)</span>
<span class="line-modified">! 	call	PLT(C(abort))</span>
<span class="line-modified">! E(0b, FFI_TYPE_UINT8)</span>
<span class="line-modified">! 	movzbl	%al, %eax</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_SINT8)</span>
<span class="line-modified">! 	movsbq	%al, %rax</span>
<span class="line-modified">! 	jmp	98f</span>
<span class="line-modified">! E(0b, FFI_TYPE_UINT16)</span>
<span class="line-modified">! 	movzwl	%ax, %eax</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_SINT16)</span>
<span class="line-modified">! 	movswq	%ax, %rax</span>
<span class="line-modified">! 	jmp	98f</span>
<span class="line-modified">! E(0b, FFI_TYPE_UINT32)</span>
<span class="line-modified">! 	movl	%eax, %eax</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_SINT32)</span>
<span class="line-modified">! 	movslq	%eax, %rax</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_UINT64)</span>
<span class="line-modified">! 98:	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_SINT64)</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_STRUCT)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_POINTER)</span>
<span class="line-modified">! 	movq	%rax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_COMPLEX)</span>
<span class="line-modified">! 	call	PLT(C(abort))</span>
<span class="line-modified">! E(0b, FFI_TYPE_SMALL_STRUCT_1B)</span>
<span class="line-modified">! 	movb	%al, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_SMALL_STRUCT_2B)</span>
<span class="line-modified">! 	movw	%ax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! E(0b, FFI_TYPE_SMALL_STRUCT_4B)</span>
<span class="line-modified">! 	movl	%eax, (%r8)</span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	.align	8</span>
<span class="line-modified">! 99:	call	PLT(C(abort))</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	epilogue</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	cfi_endproc</span>
<span class="line-modified">! 	SEH(.seh_endproc)</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! /* 32 bytes of outgoing register stack space, 8 bytes of alignment,</span>
<span class="line-modified">!    16 bytes of result, 32 bytes of xmm registers.  */</span>
<span class="line-modified">! #define ffi_clo_FS	(32+8+16+32)</span>
<span class="line-modified">! #define ffi_clo_OFF_R	(32+8)</span>
<span class="line-modified">! #define ffi_clo_OFF_X	(32+8+16)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	.align	8</span>
<span class="line-modified">! 	.globl	C(ffi_go_closure_win64)</span>
<span class="line-modified">! 	FFI_HIDDEN(C(ffi_go_closure_win64))</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	SEH(.seh_proc ffi_go_closure_win64)</span>
<span class="line-modified">! C(ffi_go_closure_win64):</span>
<span class="line-modified">! 	cfi_startproc</span>
<span class="line-modified">! 	/* Save all integer arguments into the incoming reg stack space.  */</span>
<span class="line-modified">! 	movq	%rcx, 8(%rsp)</span>
<span class="line-modified">! 	movq	%rdx, 16(%rsp)</span>
<span class="line-modified">! 	movq	%r8, 24(%rsp)</span>
<span class="line-modified">! 	movq	%r9, 32(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movq	8(%r10), %rcx			/* load cif */</span>
<span class="line-modified">! 	movq	16(%r10), %rdx			/* load fun */</span>
<span class="line-modified">! 	movq	%r10, %r8			/* closure is user_data */</span>
<span class="line-modified">! 	jmp	0f</span>
<span class="line-modified">! 	cfi_endproc</span>
<span class="line-modified">! 	SEH(.seh_endproc)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	.align	8</span>
<span class="line-modified">! 	.globl	C(ffi_closure_win64)</span>
<span class="line-modified">! 	FFI_HIDDEN(C(ffi_closure_win64))</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	SEH(.seh_proc ffi_closure_win64)</span>
<span class="line-modified">! C(ffi_closure_win64):</span>
<span class="line-modified">! 	cfi_startproc</span>
<span class="line-modified">! 	/* Save all integer arguments into the incoming reg stack space.  */</span>
<span class="line-modified">! 	movq	%rcx, 8(%rsp)</span>
<span class="line-modified">! 	movq	%rdx, 16(%rsp)</span>
<span class="line-modified">! 	movq	%r8, 24(%rsp)</span>
<span class="line-modified">! 	movq	%r9, 32(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	movq	FFI_TRAMPOLINE_SIZE(%r10), %rcx		/* load cif */</span>
<span class="line-modified">! 	movq	FFI_TRAMPOLINE_SIZE+8(%r10), %rdx	/* load fun */</span>
<span class="line-modified">! 	movq	FFI_TRAMPOLINE_SIZE+16(%r10), %r8	/* load user_data */</span>
<span class="line-modified">! 0:</span>
<span class="line-modified">! 	subq	$ffi_clo_FS, %rsp</span>
<span class="line-modified">! 	cfi_adjust_cfa_offset(ffi_clo_FS)</span>
<span class="line-modified">! 	SEH(.seh_stackalloc ffi_clo_FS)</span>
<span class="line-modified">! 	SEH(.seh_endprologue)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	/* Save all sse arguments into the stack frame.  */</span>
<span class="line-modified">! 	movsd	%xmm0, ffi_clo_OFF_X(%rsp)</span>
<span class="line-modified">! 	movsd	%xmm1, ffi_clo_OFF_X+8(%rsp)</span>
<span class="line-modified">! 	movsd	%xmm2, ffi_clo_OFF_X+16(%rsp)</span>
<span class="line-modified">! 	movsd	%xmm3, ffi_clo_OFF_X+24(%rsp)</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	leaq	ffi_clo_OFF_R(%rsp), %r9</span>
<span class="line-modified">! 	call	PLT(C(ffi_closure_win64_inner))</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	/* Load the result into both possible result registers.  */</span>
<span class="line-modified">! 	movq    ffi_clo_OFF_R(%rsp), %rax</span>
<span class="line-modified">! 	movsd   ffi_clo_OFF_R(%rsp), %xmm0</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	addq	$ffi_clo_FS, %rsp</span>
<span class="line-modified">! 	cfi_adjust_cfa_offset(-ffi_clo_FS)</span>
<span class="line-modified">! 	ret</span>
<span class="line-modified">! </span>
<span class="line-modified">! 	cfi_endproc</span>
<span class="line-modified">! 	SEH(.seh_endproc)</span>
<span class="line-modified">! #endif /* __x86_64__ */</span>
<span class="line-modified">! </span>
<span class="line-modified">! #if defined __ELF__ &amp;&amp; defined __linux__</span>
<span class="line-modified">! 	.section	.note.GNU-stack,&quot;&quot;,@progbits</span>
<span class="line-modified">! #endif</span>
</pre>
<center><a href="ffi64.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../projects/mac/glib-lite/Makefile.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
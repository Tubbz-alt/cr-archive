<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/java/javafx/scene/web/HTMLEditorSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import java.util.ResourceBundle;
  29 
  30 import com.sun.javafx.application.PlatformImpl;
  31 import com.sun.javafx.scene.ParentHelper;
  32 import com.sun.javafx.scene.traversal.Algorithm;
  33 import com.sun.javafx.scene.traversal.Direction;
  34 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  35 import com.sun.javafx.scene.traversal.TraversalContext;
  36 import javafx.css.PseudoClass;
  37 import javafx.geometry.Orientation;
  38 import org.w3c.dom.html.HTMLDocument;
  39 import org.w3c.dom.html.HTMLElement;
  40 
  41 import javafx.application.ConditionalFeature;
  42 import javafx.application.Platform;
  43 import javafx.collections.FXCollections;
  44 import javafx.collections.ObservableList;
  45 import javafx.css.StyleableProperty;
  46 import javafx.geometry.NodeOrientation;
  47 import javafx.scene.Node;
  48 import javafx.scene.control.Button;
  49 import javafx.scene.control.ComboBox;
  50 import javafx.scene.control.ListCell;
  51 import javafx.scene.control.ListView;
  52 import javafx.scene.control.Separator;
  53 import javafx.scene.control.TextInputControl;
  54 import javafx.scene.control.ToggleButton;
  55 import javafx.scene.control.ToggleGroup;
  56 import javafx.scene.control.ToolBar;
  57 import javafx.scene.control.Tooltip;
  58 import javafx.scene.image.Image;
  59 import javafx.scene.image.ImageView;
  60 import javafx.scene.input.KeyCode;
  61 import javafx.scene.input.KeyEvent;
  62 import javafx.scene.input.MouseEvent;
  63 import javafx.scene.layout.ColumnConstraints;
  64 import javafx.scene.layout.GridPane;
  65 import javafx.scene.layout.Priority;
  66 import javafx.scene.paint.Color;
  67 import javafx.scene.text.Font;
  68 import javafx.util.Callback;
  69 
  70 import com.sun.javafx.scene.control.skin.FXVK;
  71 import com.sun.javafx.scene.web.behavior.HTMLEditorBehavior;
  72 import com.sun.webkit.WebPage;
  73 import com.sun.javafx.webkit.Accessor;
  74 
  75 import java.security.AccessController;
  76 import java.security.PrivilegedAction;
  77 
  78 import java.util.HashMap;
  79 import java.util.Locale;
  80 import java.util.Map;
  81 import javafx.scene.Scene;
  82 import javafx.scene.control.*;
  83 import javafx.scene.layout.*;
  84 import javafx.collections.ListChangeListener;
  85 
  86 import static javafx.geometry.NodeOrientation.*;
  87 import javafx.print.PrinterJob;
  88 
  89 import static javafx.scene.web.HTMLEditorSkin.Command.*;
  90 
  91 /**
  92  * HTML editor skin.
  93  *
  94  * @see HTMLEditor
  95  * @since 9
  96  */
  97 public class HTMLEditorSkin extends SkinBase&lt;HTMLEditor&gt; {
  98 
  99     /***************************************************************************
 100      *                                                                         *
 101      * Private fields                                                          *
 102      *                                                                         *
 103      **************************************************************************/
 104 
 105     private GridPane gridPane;
 106 
 107     private ToolBar toolbar1;
 108     private ToolBar toolbar2;
 109 
 110     private Button cutButton;
 111     private Button copyButton;
 112     private Button pasteButton;
 113 
 114 //    private Button undoButton;
 115 //    private Button redoButton;
 116 
 117     private Button insertHorizontalRuleButton;
 118 
 119     private ToggleGroup alignmentToggleGroup;
 120     private ToggleButton alignLeftButton;
 121     private ToggleButton alignCenterButton;
 122     private ToggleButton alignRightButton;
 123     private ToggleButton alignJustifyButton;
 124 
 125     private ToggleButton bulletsButton;
 126     private ToggleButton numbersButton;
 127 
 128     private Button indentButton;
 129     private Button outdentButton;
 130 
 131     private ComboBox&lt;String&gt; formatComboBox;
 132     private Map&lt;String, String&gt; formatStyleMap;
 133     private Map&lt;String, String&gt; styleFormatMap;
 134 
 135     private ComboBox&lt;String&gt; fontFamilyComboBox;
 136 
 137     private ComboBox&lt;String&gt; fontSizeComboBox;
 138     private Map&lt;String, String&gt; fontSizeMap;
 139     private Map&lt;String, String&gt; sizeFontMap;
 140 
 141     private ToggleButton boldButton;
 142     private ToggleButton italicButton;
 143     private ToggleButton underlineButton;
 144     private ToggleButton strikethroughButton;
 145 
 146     private ColorPicker fgColorButton;
 147     private ColorPicker bgColorButton;
 148 
 149     private WebView webView;
 150     private WebPage webPage;
 151 
 152     private ParentTraversalEngine engine;
 153 
 154     private boolean resetToolbarState = false;
 155     private String cachedHTMLText = &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body contenteditable=\&quot;true\&quot;&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 156     private ResourceBundle resources;
 157 
 158     private boolean enableAtomicityCheck = false;
 159     private int atomicityCount = 0;
 160     private boolean isFirstRun = true;
 161 
 162     private static final int FONT_FAMILY_MENUBUTTON_WIDTH = 150;
 163     private static final int FONT_FAMILY_MENU_WIDTH = 100;
 164     private static final int FONT_SIZE_MENUBUTTON_WIDTH = 80;
 165 
 166 
 167 
 168     /***************************************************************************
 169      *                                                                         *
 170      * Static fields                                                           *
 171      *                                                                         *
 172      **************************************************************************/
 173 
 174     private static final Color DEFAULT_BG_COLOR = Color.WHITE;
 175     private static final Color DEFAULT_FG_COLOR = Color.BLACK;
 176 
 177     private static final String FORMAT_PARAGRAPH = &quot;&lt;p&gt;&quot;;
 178     private static final String FORMAT_HEADING_1 = &quot;&lt;h1&gt;&quot;;
 179     private static final String FORMAT_HEADING_2 = &quot;&lt;h2&gt;&quot;;
 180     private static final String FORMAT_HEADING_3 = &quot;&lt;h3&gt;&quot;;
 181     private static final String FORMAT_HEADING_4 = &quot;&lt;h4&gt;&quot;;
 182     private static final String FORMAT_HEADING_5 = &quot;&lt;h5&gt;&quot;;
 183     private static final String FORMAT_HEADING_6 = &quot;&lt;h6&gt;&quot;;
 184 
 185     private static final String SIZE_XX_SMALL = &quot;1&quot;;
 186     private static final String SIZE_X_SMALL = &quot;2&quot;;
 187     private static final String SIZE_SMALL = &quot;3&quot;;
 188     private static final String SIZE_MEDIUM = &quot;4&quot;;
 189     private static final String SIZE_LARGE = &quot;5&quot;;
 190     private static final String SIZE_X_LARGE = &quot;6&quot;;
 191     private static final String SIZE_XX_LARGE = &quot;7&quot;;
 192 
 193     // As per RT-16330: default format -&gt; bold/size mappings are as follows:
 194     private static final String[][] DEFAULT_FORMAT_MAPPINGS = {
 195         { FORMAT_PARAGRAPH,   &quot;&quot;,                  SIZE_SMALL     },
 196         { FORMAT_HEADING_1,   BOLD.getCommand(),   SIZE_X_LARGE   },
 197         { FORMAT_HEADING_2,   BOLD.getCommand(),   SIZE_LARGE     },
 198         { FORMAT_HEADING_3,   BOLD.getCommand(),   SIZE_MEDIUM    },
 199         { FORMAT_HEADING_4,   BOLD.getCommand(),   SIZE_SMALL     },
 200         { FORMAT_HEADING_5,   BOLD.getCommand(),   SIZE_X_SMALL   },
 201         { FORMAT_HEADING_6,   BOLD.getCommand(),   SIZE_XX_SMALL  },
 202     };
 203 
 204     private static PseudoClass CONTAINS_FOCUS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;contains-focus&quot;);
 205 
 206 
 207 
 208     /***************************************************************************
 209      *                                                                         *
 210      * Static Methods                                                          *
 211      *                                                                         *
 212      **************************************************************************/
 213 
 214 
 215 
 216     /***************************************************************************
 217      *                                                                         *
 218      * Listeners                                                               *
 219      *                                                                         *
 220      **************************************************************************/
 221 
 222     private ListChangeListener&lt;Node&gt; itemsListener = c -&gt; {
 223         while (c.next()) {
 224             if (c.getRemovedSize() &gt; 0) {
 225                 for (Node n : c.getList()) {
 226                     if (n instanceof WebView) {
 227                         // RT-28611 webView removed - set associated webPage to null
 228                         webPage.dispose();
 229                     }
 230                 }
 231             }
 232         }
 233     };
 234 
 235 
 236 
 237     /***************************************************************************
 238      *                                                                         *
 239      * Constructors                                                            *
 240      *                                                                         *
 241      **************************************************************************/
 242 
 243     /**
 244      * Creates a new HTMLEditorSkin instance, installing the necessary child
 245      * nodes into the Control {@link Control#getChildren() children} list, as
 246      * well as the necessary input mappings for handling key, mouse, etc events.
 247      *
 248      * @param control The control that this skin should be installed onto.
 249      */
 250     public HTMLEditorSkin(HTMLEditor control) {
 251         super(control);
 252 
 253         // install default input map for the HTMLEditor control
 254         HTMLEditorBehavior behavior = new HTMLEditorBehavior(control);
 255 //        htmlEditor.setInputMap(behavior.getInputMap());
 256 
 257         getChildren().clear();
 258 
 259         gridPane = new GridPane();
 260         gridPane.getStyleClass().add(&quot;grid&quot;);
 261         getChildren().addAll(gridPane);
 262 
 263         toolbar1 = new ToolBar();
 264         toolbar1.getStyleClass().add(&quot;top-toolbar&quot;);
 265         gridPane.add(toolbar1, 0, 0);
 266 
 267         toolbar2 = new ToolBar();
 268         toolbar2.getStyleClass().add(&quot;bottom-toolbar&quot;);
 269         gridPane.add(toolbar2, 0, 1);
 270 
 271 //        populateToolbars();
 272 
 273         webView = new WebView();
 274         gridPane.add(webView, 0, 2);
 275 
 276         ColumnConstraints column = new ColumnConstraints();
 277         column.setHgrow(Priority.ALWAYS);
 278         gridPane.getColumnConstraints().add(column);
 279 
 280         webPage = Accessor.getPageFor(webView.getEngine());
 281 
 282         webView.addEventHandler(MouseEvent.MOUSE_RELEASED, event2 -&gt; {
 283             Platform.runLater(new Runnable() {
 284                 @Override public void run() {
 285                     enableAtomicityCheck = true;
 286                     updateToolbarState(true);
 287                     enableAtomicityCheck = false;
 288                 }
 289             });
 290         });
 291 
 292 
 293         webView.addEventHandler(KeyEvent.KEY_PRESSED, event -&gt; {
 294             applyTextFormatting();
 295             if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
 296                 return;
 297             }
 298             if (event.getCode() == KeyCode.TAB &amp;&amp; !event.isControlDown()) {
 299                 if (!event.isShiftDown()) {
 300                     /*
 301                     ** if we are in either Bullet or Numbers mode then the
 302                     ** TAB key tells us to indent again.
 303                     */
 304                     if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
 305                         executeCommand(INDENT.getCommand(), null);
 306                     }
 307                     else {
 308                         executeCommand(INSERT_TAB.getCommand(), null);
 309                     }
 310                 }
 311                 else {
 312                     /*
 313                     ** if we are in either Bullet or Numbers mode then the
 314                     ** Shift-TAB key tells us to outdent.
 315                     */
 316                     if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
 317                         executeCommand(OUTDENT.getCommand(), null);
 318                     }
 319                 }
 320                 return;
 321             }
 322             // Work around for bug that sends events from ColorPicker to this Scene
 323             if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
 324                 (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
 325                 return;
 326             }
 327             Platform.runLater(() -&gt; {
 328                 if (webPage.getClientSelectedText().isEmpty()) {
 329                     if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 330                             event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 331                             event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
 332                         updateToolbarState(true);
 333                     } else if (event.isControlDown() || event.isMetaDown()) {
 334                         if (event.getCode() == KeyCode.B) {
 335                             performCommand(BOLD);
 336                         } else if (event.getCode() == KeyCode.I) {
 337                             performCommand(ITALIC);
 338                         } else if (event.getCode() == KeyCode.U) {
 339                             performCommand(UNDERLINE);
 340                         }
 341                         updateToolbarState(true);
 342                     } else {
 343                         resetToolbarState = event.getCode() == KeyCode.ENTER;
 344                         if (resetToolbarState) {
 345                             if (getCommandState(BOLD.getCommand()) != boldButton.selectedProperty().getValue()) {
 346                                 executeCommand(BOLD.getCommand(), boldButton.selectedProperty().getValue().toString());
 347                             }
 348                         }
 349                         updateToolbarState(false);
 350                     }
 351                     resetToolbarState = false;
 352                 } else if (event.isShiftDown() &amp;&amp;
 353                         (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 354                          event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 355                          event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END)) {
 356                     enableAtomicityCheck = true;
 357                     updateToolbarState(true);
 358                     enableAtomicityCheck = false;
 359                 } else if ((event.isControlDown() || event.isMetaDown()) &amp;&amp;
 360                             event.getCode() == KeyCode.A) {
 361                     enableAtomicityCheck = true;
 362                     updateToolbarState(true);
 363                     enableAtomicityCheck = false;
 364                 }
 365             });
 366         });
 367 
 368         webView.addEventHandler(KeyEvent.KEY_RELEASED, event -&gt; {
 369             if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
 370                 return;
 371             }
 372             // Work around for bug that sends events from ColorPicker to this Scene
 373             if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
 374                 (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
 375                 return;
 376             }
 377             Platform.runLater(() -&gt; {
 378                 if (webPage.getClientSelectedText().isEmpty()) {
 379                     if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 380                             event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 381                             event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
 382                         updateToolbarState(true);
 383                     } else if (event.isControlDown() || event.isMetaDown()) {
 384                         if (event.getCode() == KeyCode.B) {
 385                             performCommand(BOLD);
 386                         } else if (event.getCode() == KeyCode.I) {
 387                             performCommand(ITALIC);
 388                         } else if (event.getCode() == KeyCode.U) {
 389                             performCommand(UNDERLINE);
 390                         }
 391                         updateToolbarState(true);
 392                     } else {
 393                         resetToolbarState = event.getCode() == KeyCode.ENTER;
 394                         if (!resetToolbarState) {
 395                             updateToolbarState(false);
 396                         }
 397                     }
 398                     resetToolbarState = false;
 399                 }
 400             });
 401         });
 402 
 403         getSkinnable().focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
 404             Platform.runLater(new Runnable() {
 405                 @Override public void run() {
 406                     if (newValue) {
 407                         webView.requestFocus();
 408                     }
 409                 }
 410             });
 411         });
 412 
 413         webView.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
 414             // disabling as a fix for RT-30081
 415 //                if (newValue) {
 416 //                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_GAINED, WCFocusEvent.FORWARD));
 417 //                    enableToolbar(true);
 418 //                } else {
 419 //                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_LOST, WCFocusEvent.FORWARD));
 420 //                    enableToolbar(false);
 421 //                }
 422 
 423             pseudoClassStateChanged(CONTAINS_FOCUS_PSEUDOCLASS_STATE, newValue);
 424 
 425             Platform.runLater(new Runnable() {
 426                 @Override public void run() {
 427                     updateToolbarState(true);
 428 
 429                     if (PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
 430                         Scene scene = getSkinnable().getScene();
 431                         if (newValue) {
 432                             FXVK.attach(webView);
 433                         } else if (scene == null ||
 434                                    scene.getWindow() == null ||
 435                                    !scene.getWindow().isFocused() ||
 436                                    !(scene.getFocusOwner() instanceof TextInputControl /*||
 437                                      getScene().getFocusOwner() instanceof WebView*/)) {
 438                             FXVK.detach();
 439                         }
 440                     }
 441                 }
 442             });
 443         });
 444 
 445         webView.getEngine().getLoadWorker().workDoneProperty().addListener((observable, oldValue, newValue) -&gt; {
 446             Platform.runLater(() -&gt; {
 447                 webView.requestLayout();
 448             });
 449 
 450             double totalWork = webView.getEngine().getLoadWorker().getTotalWork();
 451             if (newValue.doubleValue() == totalWork) {
 452                 cachedHTMLText = null;
 453                 Platform.runLater(() -&gt; {
 454                     setContentEditable(true);
 455                     updateToolbarState(true);
 456                     updateNodeOrientation();
 457                     executeCommand(STYLEWITHCSS.getCommand(), &quot;true&quot;);
 458                 });
 459             }
 460         });
 461 
 462         enableToolbar(true);
 463         setHTMLText(cachedHTMLText);
 464 
 465         engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
 466             @Override
 467             public Node select(Node owner, Direction dir, TraversalContext context) {
 468                 return cutButton;
 469             }
 470 
 471             @Override
 472             public Node selectFirst(TraversalContext context) {
 473                 return cutButton;
 474             }
 475 
 476             @Override
 477             public Node selectLast(TraversalContext context) {
 478                 return cutButton;
 479             }
 480         });
 481         ParentHelper.setTraversalEngine(getSkinnable(), engine);
 482         webView.setFocusTraversable(true);
 483         gridPane.getChildren().addListener(itemsListener);
 484     }
 485 
 486 
 487 
 488     /***************************************************************************
 489      *                                                                         *
 490      * Public API                                                              *
 491      *                                                                         *
 492      **************************************************************************/
 493 
 494     /**
 495      * Special-case handling for certain commands. Over time this may be extended
 496      * to handle additional commands. The current list of supported commands is:
 497      *
 498      * &lt;ul&gt;
 499      *     &lt;li&gt;BOLD&lt;/li&gt;
 500      *     &lt;li&gt;ITALIC&lt;/li&gt;
 501      *     &lt;li&gt;UNDERLINE&lt;/li&gt;
 502      * &lt;/ul&gt;
 503      * @param command the command
 504      */
 505     public void performCommand(final Command command) {
 506         switch (command) {
 507             case BOLD: boldButton.fire(); break;
 508             case ITALIC: italicButton.setSelected(!italicButton.isSelected()); break;
 509             case UNDERLINE: underlineButton.setSelected(!underlineButton.isSelected()); break;
 510         }
 511     }
 512 
 513     /** {@inheritDoc} */
 514     @Override protected void layoutChildren(final double x, final double y,
 515                                   final double w, final double h) {
 516 
 517         if (isFirstRun) {
 518             populateToolbars();
 519             isFirstRun = false;
 520         }
 521         super.layoutChildren(x,y,w,h);
 522         double toolbarWidth = Math.max(toolbar1.prefWidth(-1), toolbar2.prefWidth(-1));
 523         toolbar1.setMinWidth(toolbarWidth);
 524         toolbar1.setPrefWidth(toolbarWidth);
 525         toolbar2.setMinWidth(toolbarWidth);
 526         toolbar2.setPrefWidth(toolbarWidth);
 527     }
 528 
 529 
 530 
 531     /***************************************************************************
 532      *                                                                         *
 533      * Private Implementation                                                  *
 534      *                                                                         *
 535      **************************************************************************/
 536 
 537     final String getHTMLText() {
 538         // RT17203 setHTMLText is asynchronous.  We use the cached version of
 539         // the html text until the page finishes loading.
 540         return cachedHTMLText != null ? cachedHTMLText : webPage.getHtml(webPage.getMainFrame());
 541     }
 542 
 543     final void setHTMLText(String htmlText) {
 544         cachedHTMLText = htmlText;
 545         webPage.load(webPage.getMainFrame(), htmlText, &quot;text/html&quot;);
 546 
 547         Platform.runLater(() -&gt; {
 548             updateToolbarState(true);
 549         });
 550     }
 551 
 552     private void populateToolbars() {
 553         resources = ResourceBundle.getBundle(HTMLEditorSkin.class.getName());
 554 
 555         // Toolbar 1
 556         cutButton = addButton(toolbar1, resources.getString(&quot;cutIcon&quot;), resources.getString(&quot;cut&quot;), CUT.getCommand(), &quot;html-editor-cut&quot;);
 557         copyButton = addButton(toolbar1, resources.getString(&quot;copyIcon&quot;), resources.getString(&quot;copy&quot;), COPY.getCommand(), &quot;html-editor-copy&quot;);
 558         pasteButton = addButton(toolbar1, resources.getString(&quot;pasteIcon&quot;), resources.getString(&quot;paste&quot;), PASTE.getCommand(), &quot;html-editor-paste&quot;);
 559 
 560         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 561 
 562 //        undoButton = addButton(toolbar1, &quot;undoIcon&quot;, resources.getString(&quot;undo&quot;), UNDO.getCommand());
 563 //        redoButton = addButton(toolbar1, &quot;redoIcon&quot;, resources.getString(&quot;redo&quot;), REDO.getCommand());//
 564 //        toolbar1.getItems().add(new Separator());
 565 
 566          alignmentToggleGroup = new ToggleGroup();
 567          alignLeftButton = addToggleButton(toolbar1, alignmentToggleGroup,
 568             resources.getString(&quot;alignLeftIcon&quot;), resources.getString(&quot;alignLeft&quot;), ALIGN_LEFT.getCommand(), &quot;html-editor-align-left&quot;);
 569          alignCenterButton = addToggleButton(toolbar1, alignmentToggleGroup,
 570             resources.getString(&quot;alignCenterIcon&quot;), resources.getString(&quot;alignCenter&quot;), ALIGN_CENTER.getCommand(), &quot;html-editor-align-center&quot;);
 571          alignRightButton = addToggleButton(toolbar1, alignmentToggleGroup,
 572             resources.getString(&quot;alignRightIcon&quot;), resources.getString(&quot;alignRight&quot;), ALIGN_RIGHT.getCommand(), &quot;html-editor-align-right&quot;);
 573          alignJustifyButton = addToggleButton(toolbar1, alignmentToggleGroup,
 574             resources.getString(&quot;alignJustifyIcon&quot;), resources.getString(&quot;alignJustify&quot;), ALIGN_JUSTIFY.getCommand(), &quot;html-editor-align-justify&quot;);
 575 
 576         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 577 
 578         outdentButton = addButton(toolbar1, resources.getString(&quot;outdentIcon&quot;), resources.getString(&quot;outdent&quot;), OUTDENT.getCommand(), &quot;html-editor-outdent&quot;);
 579         if (outdentButton.getGraphic() != null) outdentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 580         indentButton = addButton(toolbar1, resources.getString(&quot;indentIcon&quot;), resources.getString(&quot;indent&quot;), INDENT.getCommand(), &quot;html-editor-indent&quot;);
 581         if (indentButton.getGraphic() != null) indentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 582 
 583         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 584 
 585          ToggleGroup listStyleToggleGroup = new ToggleGroup();
 586          bulletsButton = addToggleButton(toolbar1, listStyleToggleGroup,
 587             resources.getString(&quot;bulletsIcon&quot;), resources.getString(&quot;bullets&quot;), BULLETS.getCommand(), &quot;html-editor-bullets&quot;);
 588          if (bulletsButton.getGraphic() != null) bulletsButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 589          numbersButton = addToggleButton(toolbar1, listStyleToggleGroup,
 590             resources.getString(&quot;numbersIcon&quot;), resources.getString(&quot;numbers&quot;), NUMBERS.getCommand(), &quot;html-editor-numbers&quot;);
 591 
 592         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 593 
 594         //toolbar1.getItems().add(new Separator());
 595 
 596         // Toolbar 2
 597         formatComboBox = new ComboBox&lt;String&gt;();
 598         formatComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 599         formatComboBox.setFocusTraversable(false);
 600         formatComboBox.setMinWidth(Region.USE_PREF_SIZE);
 601         toolbar2.getItems().add(formatComboBox);
 602 
 603         formatStyleMap = new HashMap&lt;String, String&gt;();
 604         styleFormatMap = new HashMap&lt;String, String&gt;();
 605 
 606         createFormatMenuItem(FORMAT_PARAGRAPH, resources.getString(&quot;paragraph&quot;));
 607         Platform.runLater(() -&gt; {
 608             formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
 609         });
 610         createFormatMenuItem(FORMAT_HEADING_1, resources.getString(&quot;heading1&quot;));
 611         createFormatMenuItem(FORMAT_HEADING_2, resources.getString(&quot;heading2&quot;));
 612         createFormatMenuItem(FORMAT_HEADING_3, resources.getString(&quot;heading3&quot;));
 613         createFormatMenuItem(FORMAT_HEADING_4, resources.getString(&quot;heading4&quot;));
 614         createFormatMenuItem(FORMAT_HEADING_5, resources.getString(&quot;heading5&quot;));
 615         createFormatMenuItem(FORMAT_HEADING_6, resources.getString(&quot;heading6&quot;));
 616 
 617 //        formatComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 618 //            @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 619 //                final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 620 //                    @Override public void updateItem(String item, boolean empty) {
 621 //                        super.updateItem(item, empty);
 622 //                        if (item != null) {
 623 //                            setText(item);
 624 //                        }
 625 //                    }
 626 //                };
 627 //                return cell;
 628 //            }
 629 //        });
 630 
 631         formatComboBox.setTooltip(new Tooltip(resources.getString(&quot;format&quot;)));
 632 
 633         formatComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
 634             if (newValue == null) {
 635                 formatComboBox.setValue(null);
 636             } else {
 637                 String formatValue = formatStyleMap.get(newValue);
 638                 executeCommand(FORMAT.getCommand(), formatValue);
 639                 updateToolbarState(false);
 640 
 641                 // RT-16330 match the new font format with the required weight and size
 642                 for (int i = 0; i &lt; DEFAULT_FORMAT_MAPPINGS.length; i++) {
 643                     String[] mapping = DEFAULT_FORMAT_MAPPINGS[i];
 644                     if (mapping[0].equalsIgnoreCase(formatValue)) {
 645                         executeCommand(FONT_SIZE.getCommand(), mapping[2]);
 646                         updateToolbarState(false);
 647                         break;
 648                     }
 649                 }
 650             }
 651         });
 652 
 653         fontFamilyComboBox = new ComboBox&lt;String&gt;();
 654         fontFamilyComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 655         fontFamilyComboBox.setMinWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 656         fontFamilyComboBox.setPrefWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 657         fontFamilyComboBox.setMaxWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 658         fontFamilyComboBox.setFocusTraversable(false);
 659         fontFamilyComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontFamily&quot;)));
 660         toolbar2.getItems().add(fontFamilyComboBox);
 661 
 662         // Fix for RT-32906, where all rows were being put through the cell factory
 663         // so that they could be measured. Because we have a fixed width for the
 664         // button this is unnecessary and so we tell the ComboBox to not measure
 665         // any rows.
 666         fontFamilyComboBox.getProperties().put(&quot;comboBoxRowsToMeasureWidth&quot;, 0);
 667 
 668         fontFamilyComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 669             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 670                 final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 671                     @Override public void updateItem(String item, boolean empty) {
 672                         super.updateItem(item, empty);
 673                         if (item != null) {
 674                             setText(item);
 675                             setFont(new Font(item, 12));
 676                         }
 677                     }
 678                 };
 679                 cell.setMinWidth(FONT_FAMILY_MENU_WIDTH);
 680                 cell.setPrefWidth(FONT_FAMILY_MENU_WIDTH);
 681                 cell.setMaxWidth(FONT_FAMILY_MENU_WIDTH);
 682                 return cell;
 683             }
 684         });
 685 
 686         Platform.runLater(() -&gt; {
 687             final ObservableList&lt;String&gt; fonts = FXCollections.observableArrayList(Font.getFamilies());
 688             fonts.add(0, &quot;&quot;);
 689             for (String fontFamily : fonts) {
 690                 fontFamilyComboBox.setValue(&quot;&quot;);
 691                 fontFamilyComboBox.setItems(fonts);
 692             }
 693         });
 694 
 695         fontFamilyComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
 696             executeCommand(FONT_FAMILY.getCommand(), &quot;&#39;&quot; + newValue + &quot;&#39;&quot;);
 697         });
 698 
 699         fontSizeComboBox = new ComboBox&lt;String&gt;();
 700         fontSizeComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 701         fontSizeComboBox.setFocusTraversable(false);
 702         toolbar2.getItems().add(fontSizeComboBox);
 703 
 704         fontSizeMap = new HashMap&lt;String, String&gt;();
 705         sizeFontMap = new HashMap&lt;String, String&gt;();
 706 
 707         createFontSizeMenuItem(SIZE_XX_SMALL, resources.getString(&quot;extraExtraSmall&quot;));
 708         createFontSizeMenuItem(SIZE_X_SMALL, resources.getString(&quot;extraSmall&quot;));
 709         createFontSizeMenuItem(SIZE_SMALL, resources.getString(&quot;small&quot;));
 710         Platform.runLater(() -&gt; {
 711             fontSizeComboBox.setValue(resources.getString(&quot;small&quot;));
 712         });
 713         createFontSizeMenuItem(SIZE_MEDIUM, resources.getString(&quot;medium&quot;));
 714         createFontSizeMenuItem(SIZE_LARGE, resources.getString(&quot;large&quot;));
 715         createFontSizeMenuItem(SIZE_X_LARGE, resources.getString(&quot;extraLarge&quot;));
 716         createFontSizeMenuItem(SIZE_XX_LARGE, resources.getString(&quot;extraExtraLarge&quot;));
 717         fontSizeComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontSize&quot;)));
 718 
 719         fontSizeComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 720             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 721                 final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 722                     @Override public void updateItem(String item, boolean empty) {
 723                         super.updateItem(item, empty);
 724                         if (item != null) {
 725                             setText(item);
 726                             // Remove trailing non-digits to get the size (don&#39;t assume there&#39;s a space).
 727                             String size = item.replaceFirst(&quot;[^0-9.].*$&quot;, &quot;&quot;);
 728                             setFont(new Font((String)fontFamilyComboBox.getValue(), Double.valueOf(size)));
 729                         }
 730                     }
 731                 };
 732                 return cell;
 733             }
 734         });
 735 
 736 
 737         fontSizeComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
 738             Object fontSizeValue = getCommandValue(FONT_SIZE.getCommand());
 739             if (!newValue.equals(fontSizeValue)) {
 740                 executeCommand(FONT_SIZE.getCommand(), fontSizeMap.get(newValue));
 741             }
 742         });
 743 
 744         toolbar2.getItems().add(new Separator(Orientation.VERTICAL));
 745 
 746         boldButton = addToggleButton(toolbar2, null,
 747             resources.getString(&quot;boldIcon&quot;), resources.getString(&quot;bold&quot;), BOLD.getCommand(), &quot;html-editor-bold&quot;);
 748         boldButton.setOnAction(event1 -&gt; {
 749             // Only use the bold button for paragraphs.  We don&#39;t
 750             // want to turn bold off for headings.
 751 
 752             if (&quot;&lt;p&gt;&quot;.equals(formatStyleMap.get(formatComboBox.getValue())))  {
 753                 executeCommand(BOLD.getCommand(), boldButton.selectedProperty().getValue().toString());
 754             }
 755         });
 756         italicButton = addToggleButton(toolbar2, null,
 757             resources.getString(&quot;italicIcon&quot;), resources.getString(&quot;italic&quot;), ITALIC.getCommand(), &quot;html-editor-italic&quot;);
 758         underlineButton = addToggleButton(toolbar2, null,
 759             resources.getString(&quot;underlineIcon&quot;), resources.getString(&quot;underline&quot;), UNDERLINE.getCommand(), &quot;html-editor-underline&quot;);
 760         strikethroughButton = addToggleButton(toolbar2, null,
 761             resources.getString(&quot;strikethroughIcon&quot;), resources.getString(&quot;strikethrough&quot;), STRIKETHROUGH.getCommand(), &quot;html-editor-strike&quot;);
 762 
 763         toolbar2.getItems().add(new Separator(Orientation.VERTICAL));
 764 
 765         insertHorizontalRuleButton = addButton(toolbar2, resources.getString(&quot;insertHorizontalRuleIcon&quot;),
 766             resources.getString(&quot;insertHorizontalRule&quot;), INSERT_HORIZONTAL_RULE.getCommand(), &quot;html-editor-hr&quot;);
 767         // We override setOnAction to insert a new line.  This fixes RT-16453
 768         insertHorizontalRuleButton.setOnAction(event -&gt; {
 769             executeCommand(INSERT_NEW_LINE.getCommand(), null);
 770             executeCommand(INSERT_HORIZONTAL_RULE.getCommand(), null);
 771             updateToolbarState(false);
 772         });
 773 
 774         fgColorButton = new ColorPicker();
 775         fgColorButton.getStyleClass().add(&quot;html-editor-foreground&quot;);
 776         fgColorButton.setFocusTraversable(false);
 777         toolbar1.getItems().add(fgColorButton);
 778 
 779         // JDK-8115747: Icon URLs are now specified in CSS.
 780         // fgColorButton.applyCss();
 781         // ColorPickerSkin fgColorPickerSkin = (ColorPickerSkin) fgColorButton.getSkin();
 782         // String fgIcon = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; HTMLEditorSkin.class.getResource(resources.getString(&quot;foregroundColorIcon&quot;)).toString());
 783         // ((StyleableProperty)fgColorPickerSkin.imageUrlProperty()).applyStyle(null,fgIcon);
 784 
 785         fgColorButton.setValue(DEFAULT_FG_COLOR);
 786         fgColorButton.setTooltip(new Tooltip(resources.getString(&quot;foregroundColor&quot;)));
 787         fgColorButton.setOnAction(ev1 -&gt; {
 788             Color newValue = fgColorButton.getValue();
 789             if (newValue != null) {
 790                 executeCommand(FOREGROUND_COLOR.getCommand(), colorValueToRGBA(newValue));
 791                 fgColorButton.hide();
 792             }
 793         });
 794 
 795         bgColorButton = new ColorPicker();
 796         bgColorButton.getStyleClass().add(&quot;html-editor-background&quot;);
 797         bgColorButton.setFocusTraversable(false);
 798         toolbar1.getItems().add(bgColorButton);
 799 
 800         // JDK-8115747: Icon URLs are now specified in CSS.
 801         // bgColorButton.applyCss();
 802         // ColorPickerSkin  bgColorPickerSkin = (ColorPickerSkin) bgColorButton.getSkin();
 803         // String bgIcon = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; HTMLEditorSkin.class.getResource(resources.getString(&quot;backgroundColorIcon&quot;)).toString());
 804         // ((StyleableProperty)bgColorPickerSkin.imageUrlProperty()).applyStyle(null,bgIcon);
 805 
 806         bgColorButton.setValue(DEFAULT_BG_COLOR);
 807         bgColorButton.setTooltip(new Tooltip(resources.getString(&quot;backgroundColor&quot;)));
 808 
 809         bgColorButton.setOnAction(ev -&gt; {
 810             Color newValue = bgColorButton.getValue();
 811             if (newValue != null) {
 812                 executeCommand(BACKGROUND_COLOR.getCommand(), colorValueToRGBA(newValue));
 813                 bgColorButton.hide();
 814             }
 815         });
 816     }
 817 
 818     private String colorValueToRGBA(Color c) {
 819         return String.format((Locale)null, &quot;rgba(%d, %d, %d, %.5f)&quot;,
 820                              Math.round(c.getRed() * 255),
 821                              Math.round(c.getGreen() * 255),
 822                              Math.round(c.getBlue() * 255),
 823                              c.getOpacity());
 824     }
 825 
 826     private Button addButton(ToolBar toolbar, final String iconName, String tooltipText,
 827             final String command, final String styleClass) {
 828         Button button = new Button();
 829         button.setFocusTraversable(false);
 830         button.getStyleClass().add(styleClass);
 831         toolbar.getItems().add(button);
 832 
 833         Image icon = AccessController.doPrivileged((PrivilegedAction&lt;Image&gt;) () -&gt; new Image(HTMLEditorSkin.class.getResource(iconName).toString()));
 834 //        button.setGraphic(new ImageView(icon));
 835         ((StyleableProperty)button.graphicProperty()).applyStyle(null, new ImageView(icon));
 836         button.setTooltip(new Tooltip(tooltipText));
 837 
 838         button.setOnAction(event -&gt; {
 839             executeCommand(command, null);
 840             updateToolbarState(false);
 841         });
 842 
 843         return button;
 844     }
 845 
 846     private ToggleButton addToggleButton(ToolBar toolbar, ToggleGroup toggleGroup,
 847             final String iconName, String tooltipText, final String command, final String styleClass) {
 848         ToggleButton toggleButton = new ToggleButton();
 849         toggleButton.setUserData(command);
 850         toggleButton.setFocusTraversable(false);
 851         toggleButton.getStyleClass().add(styleClass);
 852         toolbar.getItems().add(toggleButton);
 853         if (toggleGroup != null) {
 854             toggleButton.setToggleGroup(toggleGroup);
 855         }
 856 
 857         Image icon = AccessController.doPrivileged((PrivilegedAction&lt;Image&gt;) () -&gt; new Image(HTMLEditorSkin.class.getResource(iconName).toString()));
 858         ((StyleableProperty)toggleButton.graphicProperty()).applyStyle(null, new ImageView(icon));
 859 //        toggleButton.setGraphic(new ImageView(icon));
 860 
 861         toggleButton.setTooltip(new Tooltip(tooltipText));
 862 
 863         if (!BOLD.getCommand().equals(command)) {
 864             toggleButton.selectedProperty().addListener((observable, oldValue, newValue) -&gt; {
 865                 if (getCommandState(command) != newValue.booleanValue()) {
 866                     executeCommand(command, null);
 867                 }
 868             });
 869         }
 870         return toggleButton;
 871     }
 872 
 873     private void createFormatMenuItem(String formatValue, String label) {
 874         formatComboBox.getItems().add(label);
 875         formatStyleMap.put(label, formatValue);
 876         styleFormatMap.put(formatValue, label);
 877     }
 878 
 879     private void createFontSizeMenuItem(String fontSizeValue, String label) {
 880         fontSizeComboBox.getItems().add(label);
 881         fontSizeMap.put(label, fontSizeValue);
 882         sizeFontMap.put(fontSizeValue, label);
 883     }
 884 
 885     private void updateNodeOrientation() {
 886         NodeOrientation orientation = getSkinnable().getEffectiveNodeOrientation();
 887 
 888         HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
 889         HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
 890         if (htmlDocumentElement.getAttribute(&quot;dir&quot;) == null) {
 891             htmlDocumentElement.setAttribute(&quot;dir&quot;, (orientation == RIGHT_TO_LEFT) ? &quot;rtl&quot; : &quot;ltr&quot;);
 892         }
 893 
 894     }
 895 
 896     private void updateToolbarState(final boolean updateAlignment) {
 897         if (!webView.isFocused()) {
 898             return;
 899         }
 900 
 901         atomicityCount++;
 902 
 903         // These command aways return true.
 904         copyButton.setDisable(!isCommandEnabled(CUT.getCommand()));
 905         cutButton.setDisable(!isCommandEnabled(COPY.getCommand()));
 906         pasteButton.setDisable(!isCommandEnabled(PASTE.getCommand()));
 907 
 908         // undoButton.setDisable(!isCommandEnabled(UNDO.getCommand()));
 909         // redoButton.setDisable(!isCommandEnabled(REDO.getCommand()));
 910 
 911 //        undoButton.setDisable(!isCommandEnabled(FORMAT.getCommand()));
 912 //        redoButton.setDisable(!isCommandEnabled(FORMAT.getCommand()));
 913 
 914         insertHorizontalRuleButton.setDisable(!isCommandEnabled(INSERT_HORIZONTAL_RULE.getCommand()));
 915 
 916         if (updateAlignment) {
 917             alignLeftButton.setDisable(!isCommandEnabled(ALIGN_LEFT.getCommand()));
 918             alignLeftButton.setSelected(getCommandState(ALIGN_LEFT.getCommand()));
 919             alignCenterButton.setDisable(!isCommandEnabled(ALIGN_CENTER.getCommand()));
 920             alignCenterButton.setSelected(getCommandState(ALIGN_CENTER.getCommand()));
 921             alignRightButton.setDisable(!isCommandEnabled(ALIGN_RIGHT.getCommand()));
 922             alignRightButton.setSelected(getCommandState(ALIGN_RIGHT.getCommand()));
 923             alignJustifyButton.setDisable(!isCommandEnabled(ALIGN_JUSTIFY.getCommand()));
 924             alignJustifyButton.setSelected(getCommandState(ALIGN_JUSTIFY.getCommand()));
 925         } else {
 926             if (alignmentToggleGroup.getSelectedToggle() != null) {
 927                 String command = alignmentToggleGroup.getSelectedToggle().getUserData().toString();
 928                 if (isCommandEnabled(command) &amp;&amp; !getCommandState(command) ) {
 929                     executeCommand(command, null);
 930                 }
 931             }
 932         }
 933 
 934         if (alignmentToggleGroup.getSelectedToggle() == null
 935                 &amp;&amp; webPage.getClientSelectedText().isEmpty()) {
 936             alignmentToggleGroup.selectToggle(alignLeftButton);
 937         }
 938 
 939         bulletsButton.setDisable(!isCommandEnabled(BULLETS.getCommand()));
 940         bulletsButton.setSelected(getCommandState(BULLETS.getCommand()));
 941         numbersButton.setDisable(!isCommandEnabled(NUMBERS.getCommand()));
 942         numbersButton.setSelected(getCommandState(NUMBERS.getCommand()));
 943 
 944         indentButton.setDisable(!isCommandEnabled(INDENT.getCommand()));
 945         outdentButton.setDisable(!isCommandEnabled(OUTDENT.getCommand()));
 946 
 947         formatComboBox.setDisable(!isCommandEnabled(FORMAT.getCommand()));
 948 
 949 
 950         String formatValue = getCommandValue(FORMAT.getCommand());
 951         if (formatValue != null) {
 952             String htmlTag = &quot;&lt;&quot; + formatValue + &quot;&gt;&quot;;
 953             String comboFormatValue = styleFormatMap.get(htmlTag);
 954             String format = formatComboBox.getValue();
 955 
 956             // if the format value is then we assume that we&#39;re dealing with a paragraph,
 957             // which seems to correspond with the HTML output we receive.
 958             if ((resetToolbarState || htmlTag.equals(&quot;&lt;&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;div&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;blockquote&gt;&quot;))) {
 959                 formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
 960             } else if (format != null &amp;&amp; ! format.equalsIgnoreCase(comboFormatValue)) {
 961                 formatComboBox.setValue(comboFormatValue);
 962             }
 963         }
 964 
 965         fontFamilyComboBox.setDisable(!isCommandEnabled(FONT_FAMILY.getCommand()));
 966         final String fontFamilyValue = getCommandValue(FONT_FAMILY.getCommand());
 967         if (fontFamilyValue != null) {
 968             String fontFamilyStr = fontFamilyValue;
 969 
 970             // stripping out apostrophe characters, which are appended to either
 971             // end of the font face name when the font face has one or more spaces.
 972             if (fontFamilyStr.startsWith(&quot;&#39;&quot;)) {
 973                 fontFamilyStr = fontFamilyStr.substring(1);
 974             }
 975             if (fontFamilyStr.endsWith(&quot;&#39;&quot;)) {
 976                 fontFamilyStr = fontFamilyStr.substring(0,fontFamilyStr.length() - 1);
 977             }
 978 
 979             Object selectedFont = fontFamilyComboBox.getValue();
 980             if (selectedFont instanceof String) {
 981                 if (!selectedFont.equals(fontFamilyStr)) {
 982 
 983                     ObservableList&lt;String&gt; fontFamilyItems = fontFamilyComboBox.getItems();
 984                     String selectedComboFont = null;
 985                     for (String comboFontFamilyValue : fontFamilyItems) {
 986 
 987                         if (comboFontFamilyValue.equals(fontFamilyStr)) {
 988                             selectedComboFont = comboFontFamilyValue;
 989                             break;
 990                         }
 991                         // Note: By default, &#39;Dialog&#39; is the font returned from webview.
 992                         // For presidio, we&#39;re just mapping to the default font.
 993                         if (comboFontFamilyValue.equals(&quot;&quot;) &amp;&amp; fontFamilyStr.equals(&quot;Dialog&quot;)) {
 994                             selectedComboFont = comboFontFamilyValue;
 995                             break;
 996                         }
 997                     }
 998 
 999                     if (selectedComboFont != null) {
1000                         fontFamilyComboBox.setValue(selectedComboFont);
1001                     }
1002                 }
1003             }
1004         }
1005 
1006         fontSizeComboBox.setDisable(!isCommandEnabled(FONT_SIZE.getCommand()));
1007         String fontSizeValue = getCommandValue(FONT_SIZE.getCommand());
1008 
1009         // added test for fontSizeValue == null to combat RT-28847
1010         if (resetToolbarState &amp;&amp; fontSizeValue == null) {
1011             fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
1012         } else {
1013             if (fontSizeValue != null) {
1014                 if (!fontSizeComboBox.getValue().equals(sizeFontMap.get(fontSizeValue))) {
1015                     fontSizeComboBox.setValue(sizeFontMap.get(fontSizeValue));
1016                 }
1017             }
1018             else {
1019                 /*
1020                 ** these is no font size set in webview,
1021                 ** let&#39;s just use the default....
1022                 */
1023                 if ((fontSizeComboBox.getValue() == null) || !fontSizeComboBox.getValue().equals(sizeFontMap.get(SIZE_SMALL))) {
1024                     fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
1025                 }
1026             }
1027         }
1028 
1029         boldButton.setDisable(!isCommandEnabled(BOLD.getCommand()));
1030         boldButton.setSelected(getCommandState(BOLD.getCommand()));
1031         italicButton.setDisable(!isCommandEnabled(ITALIC.getCommand()));
1032         italicButton.setSelected(getCommandState(ITALIC.getCommand()));
1033         underlineButton.setDisable(!isCommandEnabled(UNDERLINE.getCommand()));
1034         underlineButton.setSelected(getCommandState(UNDERLINE.getCommand()));
1035         strikethroughButton.setDisable(!isCommandEnabled(STRIKETHROUGH.getCommand()));
1036         strikethroughButton.setSelected(getCommandState(STRIKETHROUGH.getCommand()));
1037 
1038         fgColorButton.setDisable(!isCommandEnabled(FOREGROUND_COLOR.getCommand()));
1039         String foregroundColorValue = getCommandValue(FOREGROUND_COLOR.getCommand());
1040         if (foregroundColorValue != null) {
1041             fgColorButton.setValue(getColor(foregroundColorValue));
1042         }
1043 
1044         bgColorButton.setDisable(!isCommandEnabled(BACKGROUND_COLOR.getCommand()));
1045         String backgroundColorValue = getCommandValue(BACKGROUND_COLOR.getCommand());
1046         if (backgroundColorValue != null) {
1047             bgColorButton.setValue(getColor(backgroundColorValue));
1048         }
1049 
1050         atomicityCount = atomicityCount == 0 ? 0 : --atomicityCount;
1051     }
1052 
1053     private void enableToolbar(final boolean enable) {
1054         Platform.runLater(() -&gt; {
1055 
1056             // Make sure buttons have been created to avoid NPE
1057             if (copyButton == null) return;
1058 
1059             /*
1060             ** if we&#39;re to enable, we still only enable
1061             ** the cut/copy/paste buttons that make sense
1062             */
1063             if (enable) {
1064                 copyButton.setDisable(!isCommandEnabled(COPY.getCommand()));
1065                 cutButton.setDisable(!isCommandEnabled(CUT.getCommand()));
1066                 pasteButton.setDisable(!isCommandEnabled(PASTE.getCommand()));
1067             } else {
1068                 copyButton.setDisable(true);
1069                 cutButton.setDisable(true);
1070                 pasteButton.setDisable(true);
1071             }
1072 
1073 //                undoButton.setDisable(!enable);
1074 //                redoButton.setDisable(!enable);
1075             insertHorizontalRuleButton.setDisable(!enable);
1076             alignLeftButton.setDisable(!enable);
1077             alignCenterButton.setDisable(!enable);
1078             alignRightButton.setDisable(!enable);
1079             alignJustifyButton.setDisable(!enable);
1080             bulletsButton.setDisable(!enable);
1081             numbersButton.setDisable(!enable);
1082             indentButton.setDisable(!enable);
1083             outdentButton.setDisable(!enable);
1084             formatComboBox.setDisable(!enable);
1085             fontFamilyComboBox.setDisable(!enable);
1086             fontSizeComboBox.setDisable(!enable);
1087             boldButton.setDisable(!enable);
1088             italicButton.setDisable(!enable);
1089             underlineButton.setDisable(!enable);
1090             strikethroughButton.setDisable(!enable);
1091             fgColorButton.setDisable(!enable);
1092             bgColorButton.setDisable(!enable);
1093         });
1094     }
1095 
1096     private boolean executeCommand(String command, String value) {
1097         // The mentions of atomicity throughout this class relate back to RT-39941,
1098         // refer to that jira issue for more context.
1099         if (!enableAtomicityCheck || (enableAtomicityCheck &amp;&amp; atomicityCount == 0)) {
1100             return webPage.executeCommand(command, value);
1101         }
1102         return false;
1103     }
1104 
1105     private boolean isCommandEnabled(String command) {
1106         return webPage.queryCommandEnabled(command);
1107     }
1108 
1109     private void setContentEditable(boolean b) {
1110         HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
1111         HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
1112         HTMLElement htmlBodyElement = (HTMLElement)htmlDocumentElement.getElementsByTagName(&quot;body&quot;).item(0);
1113         htmlBodyElement.setAttribute(&quot;contenteditable&quot;, Boolean.toString(b));
1114     }
1115 
1116     private boolean getCommandState(String command) {
1117         return webPage.queryCommandState(command);
1118     }
1119 
1120     private String getCommandValue(String command) {
1121         return webPage.queryCommandValue(command);
1122     }
1123 
1124     private Color getColor(String value) {
1125         Color color = Color.web(value);
1126         /* The default background color for WebView, according to the HTML
1127          * standard is rgba=#00000000 (transparent). The canvas background is expected
1128          * to be white.
1129          */
1130         if (color.equals(Color.TRANSPARENT)) {
1131             color = Color.WHITE;
1132         }
1133         return color;
1134     }
1135 
1136     private void applyTextFormatting() {
1137         if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
1138             return;
1139         }
1140 
1141         if (webPage.getClientCommittedTextLength() == 0) {
1142             String format = formatStyleMap.get(formatComboBox.getValue());
1143             String font   = fontFamilyComboBox.getValue().toString();
1144 
1145             executeCommand(FORMAT.getCommand(), format);
1146             executeCommand(FONT_FAMILY.getCommand(), &quot;&#39;&quot; + font + &quot;&#39;&quot;);
1147         }
1148     }
1149 
1150     void print(PrinterJob job) {
1151         webView.getEngine().print(job);
1152     }
1153 
1154 
1155 
1156     /***************************************************************************
1157      *                                                                         *
1158      * Support Classes                                                         *
1159      *                                                                         *
1160      **************************************************************************/
1161 
1162     /**
1163      * Represents commands that can be passed into the HTMLEditor web engine.
1164      */
1165     public enum Command {
1166         CUT(&quot;cut&quot;),
1167         COPY(&quot;copy&quot;),
1168         PASTE(&quot;paste&quot;),
1169 
1170         UNDO(&quot;undo&quot;),
1171         REDO(&quot;redo&quot;),
1172 
1173         INSERT_HORIZONTAL_RULE(&quot;inserthorizontalrule&quot;),
1174 
1175         ALIGN_LEFT(&quot;justifyleft&quot;),
1176         ALIGN_CENTER(&quot;justifycenter&quot;),
1177         ALIGN_RIGHT(&quot;justifyright&quot;),
1178         ALIGN_JUSTIFY(&quot;justifyfull&quot;),
1179 
1180         BULLETS(&quot;insertUnorderedList&quot;),
1181         NUMBERS(&quot;insertOrderedList&quot;),
1182 
1183         INDENT(&quot;indent&quot;),
1184         OUTDENT(&quot;outdent&quot;),
1185 
1186         FORMAT(&quot;formatblock&quot;),
1187         FONT_FAMILY(&quot;fontname&quot;),
1188         FONT_SIZE(&quot;fontsize&quot;),
1189 
1190         BOLD(&quot;bold&quot;),
1191         ITALIC(&quot;italic&quot;),
1192         UNDERLINE(&quot;underline&quot;),
1193         STRIKETHROUGH(&quot;strikethrough&quot;),
1194 
1195         FOREGROUND_COLOR(&quot;forecolor&quot;),
1196         BACKGROUND_COLOR(&quot;backcolor&quot;),
1197         STYLEWITHCSS(&quot;styleWithCSS&quot;),
1198 
1199         INSERT_NEW_LINE(&quot;insertnewline&quot;),
1200         INSERT_TAB(&quot;inserttab&quot;);
1201 
1202         private final String command;
1203 
1204         Command(String command) {
1205             this.command = command;
1206         }
1207 
1208         public String getCommand() {
1209             return command;
1210         }
1211     }
1212 }
    </pre>
  </body>
</html>
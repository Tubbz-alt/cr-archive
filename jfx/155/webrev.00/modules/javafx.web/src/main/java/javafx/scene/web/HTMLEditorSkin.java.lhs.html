<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/javafx/scene/web/HTMLEditorSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.web;
  27 
  28 import java.util.ResourceBundle;
  29 
  30 import com.sun.javafx.application.PlatformImpl;
  31 import com.sun.javafx.scene.ParentHelper;
  32 import com.sun.javafx.scene.traversal.Algorithm;
  33 import com.sun.javafx.scene.traversal.Direction;
  34 import com.sun.javafx.scene.traversal.ParentTraversalEngine;
  35 import com.sun.javafx.scene.traversal.TraversalContext;
  36 import javafx.css.PseudoClass;
  37 import javafx.geometry.Orientation;
  38 import org.w3c.dom.html.HTMLDocument;
  39 import org.w3c.dom.html.HTMLElement;
  40 
  41 import javafx.application.ConditionalFeature;
  42 import javafx.application.Platform;
  43 import javafx.collections.FXCollections;
  44 import javafx.collections.ObservableList;
  45 import javafx.css.StyleableProperty;
  46 import javafx.geometry.NodeOrientation;
  47 import javafx.scene.Node;
  48 import javafx.scene.control.Button;
  49 import javafx.scene.control.ComboBox;
  50 import javafx.scene.control.ListCell;
  51 import javafx.scene.control.ListView;
  52 import javafx.scene.control.Separator;
  53 import javafx.scene.control.TextInputControl;
  54 import javafx.scene.control.ToggleButton;
  55 import javafx.scene.control.ToggleGroup;
  56 import javafx.scene.control.ToolBar;
  57 import javafx.scene.control.Tooltip;
  58 import javafx.scene.image.Image;
  59 import javafx.scene.image.ImageView;
  60 import javafx.scene.input.KeyCode;
  61 import javafx.scene.input.KeyEvent;
  62 import javafx.scene.input.MouseEvent;
  63 import javafx.scene.layout.ColumnConstraints;
  64 import javafx.scene.layout.GridPane;
  65 import javafx.scene.layout.Priority;
  66 import javafx.scene.paint.Color;
  67 import javafx.scene.text.Font;
  68 import javafx.util.Callback;
  69 
  70 import com.sun.javafx.scene.control.skin.FXVK;
  71 import com.sun.javafx.scene.web.behavior.HTMLEditorBehavior;
  72 import com.sun.webkit.WebPage;
  73 import com.sun.javafx.webkit.Accessor;
  74 
  75 import java.security.AccessController;
  76 import java.security.PrivilegedAction;
  77 
  78 import java.util.HashMap;
  79 import java.util.Locale;
  80 import java.util.Map;
  81 import javafx.scene.Scene;
  82 import javafx.scene.control.*;
  83 import javafx.scene.layout.*;
  84 import javafx.collections.ListChangeListener;
  85 
  86 import static javafx.geometry.NodeOrientation.*;
  87 import javafx.print.PrinterJob;
  88 
  89 import static javafx.scene.web.HTMLEditorSkin.Command.*;
  90 
  91 /**
  92  * HTML editor skin.
  93  *
  94  * @see HTMLEditor
  95  * @since 9
  96  */
  97 public class HTMLEditorSkin extends SkinBase&lt;HTMLEditor&gt; {
  98 
  99     /***************************************************************************
 100      *                                                                         *
 101      * Private fields                                                          *
 102      *                                                                         *
 103      **************************************************************************/
 104 
 105     private GridPane gridPane;
 106 
 107     private ToolBar toolbar1;
 108     private ToolBar toolbar2;
 109 
 110     private Button cutButton;
 111     private Button copyButton;
 112     private Button pasteButton;
 113 
 114 //    private Button undoButton;
 115 //    private Button redoButton;
 116 
 117     private Button insertHorizontalRuleButton;
 118 
 119     private ToggleGroup alignmentToggleGroup;
 120     private ToggleButton alignLeftButton;
 121     private ToggleButton alignCenterButton;
 122     private ToggleButton alignRightButton;
 123     private ToggleButton alignJustifyButton;
 124 
 125     private ToggleButton bulletsButton;
 126     private ToggleButton numbersButton;
 127 
 128     private Button indentButton;
 129     private Button outdentButton;
 130 
 131     private ComboBox&lt;String&gt; formatComboBox;
 132     private Map&lt;String, String&gt; formatStyleMap;
 133     private Map&lt;String, String&gt; styleFormatMap;
 134 
 135     private ComboBox&lt;String&gt; fontFamilyComboBox;
 136 
 137     private ComboBox&lt;String&gt; fontSizeComboBox;
 138     private Map&lt;String, String&gt; fontSizeMap;
 139     private Map&lt;String, String&gt; sizeFontMap;
 140 
 141     private ToggleButton boldButton;
 142     private ToggleButton italicButton;
 143     private ToggleButton underlineButton;
 144     private ToggleButton strikethroughButton;
 145 
 146     private ColorPicker fgColorButton;
 147     private ColorPicker bgColorButton;
 148 
 149     private WebView webView;
 150     private WebPage webPage;
 151 
 152     private ParentTraversalEngine engine;
 153 
 154     private boolean resetToolbarState = false;
 155     private String cachedHTMLText = &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body contenteditable=\&quot;true\&quot;&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 156     private ResourceBundle resources;
 157 
 158     private boolean enableAtomicityCheck = false;
 159     private int atomicityCount = 0;
 160     private boolean isFirstRun = true;
 161 
 162     private static final int FONT_FAMILY_MENUBUTTON_WIDTH = 150;
 163     private static final int FONT_FAMILY_MENU_WIDTH = 100;
 164     private static final int FONT_SIZE_MENUBUTTON_WIDTH = 80;
 165 
 166 
 167 
 168     /***************************************************************************
 169      *                                                                         *
 170      * Static fields                                                           *
 171      *                                                                         *
 172      **************************************************************************/
 173 
 174     private static final Color DEFAULT_BG_COLOR = Color.WHITE;
 175     private static final Color DEFAULT_FG_COLOR = Color.BLACK;
 176 
 177     private static final String FORMAT_PARAGRAPH = &quot;&lt;p&gt;&quot;;
 178     private static final String FORMAT_HEADING_1 = &quot;&lt;h1&gt;&quot;;
 179     private static final String FORMAT_HEADING_2 = &quot;&lt;h2&gt;&quot;;
 180     private static final String FORMAT_HEADING_3 = &quot;&lt;h3&gt;&quot;;
 181     private static final String FORMAT_HEADING_4 = &quot;&lt;h4&gt;&quot;;
 182     private static final String FORMAT_HEADING_5 = &quot;&lt;h5&gt;&quot;;
 183     private static final String FORMAT_HEADING_6 = &quot;&lt;h6&gt;&quot;;
 184 
 185     private static final String SIZE_XX_SMALL = &quot;1&quot;;
 186     private static final String SIZE_X_SMALL = &quot;2&quot;;
 187     private static final String SIZE_SMALL = &quot;3&quot;;
 188     private static final String SIZE_MEDIUM = &quot;4&quot;;
 189     private static final String SIZE_LARGE = &quot;5&quot;;
 190     private static final String SIZE_X_LARGE = &quot;6&quot;;
 191     private static final String SIZE_XX_LARGE = &quot;7&quot;;
 192 
 193     // As per RT-16330: default format -&gt; bold/size mappings are as follows:
 194     private static final String[][] DEFAULT_FORMAT_MAPPINGS = {
 195         { FORMAT_PARAGRAPH,   &quot;&quot;,                  SIZE_SMALL     },
 196         { FORMAT_HEADING_1,   BOLD.getCommand(),   SIZE_X_LARGE   },
 197         { FORMAT_HEADING_2,   BOLD.getCommand(),   SIZE_LARGE     },
 198         { FORMAT_HEADING_3,   BOLD.getCommand(),   SIZE_MEDIUM    },
 199         { FORMAT_HEADING_4,   BOLD.getCommand(),   SIZE_SMALL     },
 200         { FORMAT_HEADING_5,   BOLD.getCommand(),   SIZE_X_SMALL   },
 201         { FORMAT_HEADING_6,   BOLD.getCommand(),   SIZE_XX_SMALL  },
 202     };
 203 
 204     private static PseudoClass CONTAINS_FOCUS_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(&quot;contains-focus&quot;);
 205 
 206 
 207 
 208     /***************************************************************************
 209      *                                                                         *
 210      * Static Methods                                                          *
 211      *                                                                         *
 212      **************************************************************************/
 213 
 214 
 215 
 216     /***************************************************************************
 217      *                                                                         *
 218      * Listeners                                                               *
 219      *                                                                         *
 220      **************************************************************************/
 221 
 222     private ListChangeListener&lt;Node&gt; itemsListener = c -&gt; {
 223         while (c.next()) {
 224             if (c.getRemovedSize() &gt; 0) {
 225                 for (Node n : c.getList()) {
 226                     if (n instanceof WebView) {
 227                         // RT-28611 webView removed - set associated webPage to null
 228                         webPage.dispose();
 229                     }
 230                 }
 231             }
 232         }
 233     };
 234 
 235 
 236 
 237     /***************************************************************************
 238      *                                                                         *
 239      * Constructors                                                            *
 240      *                                                                         *
 241      **************************************************************************/
 242 
 243     /**
 244      * Creates a new HTMLEditorSkin instance, installing the necessary child
 245      * nodes into the Control {@link Control#getChildren() children} list, as
 246      * well as the necessary input mappings for handling key, mouse, etc events.
 247      *
 248      * @param control The control that this skin should be installed onto.
 249      */
 250     public HTMLEditorSkin(HTMLEditor control) {
 251         super(control);
 252 
 253         // install default input map for the HTMLEditor control
 254         HTMLEditorBehavior behavior = new HTMLEditorBehavior(control);
 255 //        htmlEditor.setInputMap(behavior.getInputMap());
 256 
 257         getChildren().clear();
 258 
 259         gridPane = new GridPane();
 260         gridPane.getStyleClass().add(&quot;grid&quot;);
 261         getChildren().addAll(gridPane);
 262 
 263         toolbar1 = new ToolBar();
 264         toolbar1.getStyleClass().add(&quot;top-toolbar&quot;);
 265         gridPane.add(toolbar1, 0, 0);
 266 
 267         toolbar2 = new ToolBar();
 268         toolbar2.getStyleClass().add(&quot;bottom-toolbar&quot;);
 269         gridPane.add(toolbar2, 0, 1);
 270 
 271 //        populateToolbars();
 272 
 273         webView = new WebView();
 274         gridPane.add(webView, 0, 2);
 275 
 276         ColumnConstraints column = new ColumnConstraints();
 277         column.setHgrow(Priority.ALWAYS);
 278         gridPane.getColumnConstraints().add(column);
 279 
 280         webPage = Accessor.getPageFor(webView.getEngine());
 281 
 282         webView.addEventHandler(MouseEvent.MOUSE_RELEASED, event2 -&gt; {
 283             Platform.runLater(new Runnable() {
 284                 @Override public void run() {
 285                     enableAtomicityCheck = true;
 286                     updateToolbarState(true);
 287                     enableAtomicityCheck = false;
 288                 }
 289             });
 290         });
 291 
 292 
 293         webView.addEventHandler(KeyEvent.KEY_PRESSED, event -&gt; {
 294             applyTextFormatting();
 295             if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
 296                 return;
 297             }
 298             if (event.getCode() == KeyCode.TAB &amp;&amp; !event.isControlDown()) {
 299                 if (!event.isShiftDown()) {
 300                     /*
 301                     ** if we are in either Bullet or Numbers mode then the
 302                     ** TAB key tells us to indent again.
 303                     */
 304                     if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
 305                         executeCommand(INDENT.getCommand(), null);
 306                     }
 307                     else {
 308                         executeCommand(INSERT_TAB.getCommand(), null);
 309                     }
 310                 }
 311                 else {
 312                     /*
 313                     ** if we are in either Bullet or Numbers mode then the
 314                     ** Shift-TAB key tells us to outdent.
 315                     */
 316                     if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
 317                         executeCommand(OUTDENT.getCommand(), null);
 318                     }
 319                 }
 320                 return;
 321             }
 322             // Work around for bug that sends events from ColorPicker to this Scene
 323             if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
 324                 (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
 325                 return;
 326             }
 327             Platform.runLater(() -&gt; {
 328                 if (webPage.getClientSelectedText().isEmpty()) {
 329                     if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 330                             event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 331                             event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
 332                         updateToolbarState(true);
 333                     } else if (event.isControlDown() || event.isMetaDown()) {
 334                         if (event.getCode() == KeyCode.B) {
 335                             performCommand(BOLD);
 336                         } else if (event.getCode() == KeyCode.I) {
 337                             performCommand(ITALIC);
 338                         } else if (event.getCode() == KeyCode.U) {
 339                             performCommand(UNDERLINE);
 340                         }
 341                         updateToolbarState(true);
 342                     } else {
 343                         resetToolbarState = event.getCode() == KeyCode.ENTER;
 344                         if (resetToolbarState) {
 345                             if (getCommandState(BOLD.getCommand()) != boldButton.selectedProperty().getValue()) {
 346                                 executeCommand(BOLD.getCommand(), boldButton.selectedProperty().getValue().toString());
 347                             }
 348                         }
 349                         updateToolbarState(false);
 350                     }
 351                     resetToolbarState = false;
 352                 } else if (event.isShiftDown() &amp;&amp;
 353                         (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 354                          event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 355                          event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END)) {
<a name="2" id="anc2"></a>
 356                     updateToolbarState(true);
<a name="3" id="anc3"></a>
 357                 } else if ((event.isControlDown() || event.isMetaDown()) &amp;&amp;
 358                             event.getCode() == KeyCode.A) {
<a name="4" id="anc4"></a>
 359                     updateToolbarState(true);
<a name="5" id="anc5"></a>
 360                 }
 361             });
 362         });
 363 
 364         webView.addEventHandler(KeyEvent.KEY_RELEASED, event -&gt; {
 365             if (event.getCode() == KeyCode.CONTROL || event.getCode() == KeyCode.META) {
 366                 return;
 367             }
 368             // Work around for bug that sends events from ColorPicker to this Scene
 369             if ((fgColorButton != null &amp;&amp; fgColorButton.isShowing()) ||
 370                 (bgColorButton != null &amp;&amp; bgColorButton.isShowing())) {
 371                 return;
 372             }
 373             Platform.runLater(() -&gt; {
 374                 if (webPage.getClientSelectedText().isEmpty()) {
 375                     if (event.getCode() == KeyCode.UP || event.getCode() == KeyCode.DOWN ||
 376                             event.getCode() == KeyCode.LEFT || event.getCode() == KeyCode.RIGHT ||
 377                             event.getCode() == KeyCode.HOME || event.getCode() == KeyCode.END) {
 378                         updateToolbarState(true);
 379                     } else if (event.isControlDown() || event.isMetaDown()) {
 380                         if (event.getCode() == KeyCode.B) {
 381                             performCommand(BOLD);
 382                         } else if (event.getCode() == KeyCode.I) {
 383                             performCommand(ITALIC);
 384                         } else if (event.getCode() == KeyCode.U) {
 385                             performCommand(UNDERLINE);
 386                         }
 387                         updateToolbarState(true);
 388                     } else {
 389                         resetToolbarState = event.getCode() == KeyCode.ENTER;
 390                         if (!resetToolbarState) {
 391                             updateToolbarState(false);
 392                         }
 393                     }
 394                     resetToolbarState = false;
 395                 }
 396             });
 397         });
 398 
 399         getSkinnable().focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
 400             Platform.runLater(new Runnable() {
 401                 @Override public void run() {
 402                     if (newValue) {
 403                         webView.requestFocus();
 404                     }
 405                 }
 406             });
 407         });
 408 
 409         webView.focusedProperty().addListener((observable, oldValue, newValue) -&gt; {
 410             // disabling as a fix for RT-30081
 411 //                if (newValue) {
 412 //                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_GAINED, WCFocusEvent.FORWARD));
 413 //                    enableToolbar(true);
 414 //                } else {
 415 //                    webPage.dispatchFocusEvent(new WCFocusEvent(WCFocusEvent.FOCUS_LOST, WCFocusEvent.FORWARD));
 416 //                    enableToolbar(false);
 417 //                }
 418 
 419             pseudoClassStateChanged(CONTAINS_FOCUS_PSEUDOCLASS_STATE, newValue);
 420 
 421             Platform.runLater(new Runnable() {
 422                 @Override public void run() {
 423                     updateToolbarState(true);
 424 
 425                     if (PlatformImpl.isSupported(ConditionalFeature.VIRTUAL_KEYBOARD)) {
 426                         Scene scene = getSkinnable().getScene();
 427                         if (newValue) {
 428                             FXVK.attach(webView);
 429                         } else if (scene == null ||
 430                                    scene.getWindow() == null ||
 431                                    !scene.getWindow().isFocused() ||
 432                                    !(scene.getFocusOwner() instanceof TextInputControl /*||
 433                                      getScene().getFocusOwner() instanceof WebView*/)) {
 434                             FXVK.detach();
 435                         }
 436                     }
 437                 }
 438             });
 439         });
 440 
 441         webView.getEngine().getLoadWorker().workDoneProperty().addListener((observable, oldValue, newValue) -&gt; {
 442             Platform.runLater(() -&gt; {
 443                 webView.requestLayout();
 444             });
 445 
 446             double totalWork = webView.getEngine().getLoadWorker().getTotalWork();
 447             if (newValue.doubleValue() == totalWork) {
 448                 cachedHTMLText = null;
 449                 Platform.runLater(() -&gt; {
 450                     setContentEditable(true);
 451                     updateToolbarState(true);
 452                     updateNodeOrientation();
 453                     executeCommand(STYLEWITHCSS.getCommand(), &quot;true&quot;);
 454                 });
 455             }
 456         });
 457 
 458         enableToolbar(true);
 459         setHTMLText(cachedHTMLText);
 460 
 461         engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {
 462             @Override
 463             public Node select(Node owner, Direction dir, TraversalContext context) {
 464                 return cutButton;
 465             }
 466 
 467             @Override
 468             public Node selectFirst(TraversalContext context) {
 469                 return cutButton;
 470             }
 471 
 472             @Override
 473             public Node selectLast(TraversalContext context) {
 474                 return cutButton;
 475             }
 476         });
 477         ParentHelper.setTraversalEngine(getSkinnable(), engine);
 478         webView.setFocusTraversable(true);
 479         gridPane.getChildren().addListener(itemsListener);
 480     }
 481 
 482 
 483 
 484     /***************************************************************************
 485      *                                                                         *
 486      * Public API                                                              *
 487      *                                                                         *
 488      **************************************************************************/
 489 
 490     /**
 491      * Special-case handling for certain commands. Over time this may be extended
 492      * to handle additional commands. The current list of supported commands is:
 493      *
 494      * &lt;ul&gt;
 495      *     &lt;li&gt;BOLD&lt;/li&gt;
 496      *     &lt;li&gt;ITALIC&lt;/li&gt;
 497      *     &lt;li&gt;UNDERLINE&lt;/li&gt;
 498      * &lt;/ul&gt;
 499      * @param command the command
 500      */
 501     public void performCommand(final Command command) {
 502         switch (command) {
 503             case BOLD: boldButton.fire(); break;
 504             case ITALIC: italicButton.setSelected(!italicButton.isSelected()); break;
 505             case UNDERLINE: underlineButton.setSelected(!underlineButton.isSelected()); break;
 506         }
 507     }
 508 
 509     /** {@inheritDoc} */
 510     @Override protected void layoutChildren(final double x, final double y,
 511                                   final double w, final double h) {
 512 
 513         if (isFirstRun) {
 514             populateToolbars();
 515             isFirstRun = false;
 516         }
 517         super.layoutChildren(x,y,w,h);
 518         double toolbarWidth = Math.max(toolbar1.prefWidth(-1), toolbar2.prefWidth(-1));
 519         toolbar1.setMinWidth(toolbarWidth);
 520         toolbar1.setPrefWidth(toolbarWidth);
 521         toolbar2.setMinWidth(toolbarWidth);
 522         toolbar2.setPrefWidth(toolbarWidth);
 523     }
 524 
 525 
 526 
 527     /***************************************************************************
 528      *                                                                         *
 529      * Private Implementation                                                  *
 530      *                                                                         *
 531      **************************************************************************/
 532 
 533     final String getHTMLText() {
 534         // RT17203 setHTMLText is asynchronous.  We use the cached version of
 535         // the html text until the page finishes loading.
 536         return cachedHTMLText != null ? cachedHTMLText : webPage.getHtml(webPage.getMainFrame());
 537     }
 538 
 539     final void setHTMLText(String htmlText) {
 540         cachedHTMLText = htmlText;
 541         webPage.load(webPage.getMainFrame(), htmlText, &quot;text/html&quot;);
 542 
 543         Platform.runLater(() -&gt; {
 544             updateToolbarState(true);
 545         });
 546     }
 547 
 548     private void populateToolbars() {
 549         resources = ResourceBundle.getBundle(HTMLEditorSkin.class.getName());
 550 
 551         // Toolbar 1
 552         cutButton = addButton(toolbar1, resources.getString(&quot;cutIcon&quot;), resources.getString(&quot;cut&quot;), CUT.getCommand(), &quot;html-editor-cut&quot;);
 553         copyButton = addButton(toolbar1, resources.getString(&quot;copyIcon&quot;), resources.getString(&quot;copy&quot;), COPY.getCommand(), &quot;html-editor-copy&quot;);
 554         pasteButton = addButton(toolbar1, resources.getString(&quot;pasteIcon&quot;), resources.getString(&quot;paste&quot;), PASTE.getCommand(), &quot;html-editor-paste&quot;);
 555 
 556         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 557 
 558 //        undoButton = addButton(toolbar1, &quot;undoIcon&quot;, resources.getString(&quot;undo&quot;), UNDO.getCommand());
 559 //        redoButton = addButton(toolbar1, &quot;redoIcon&quot;, resources.getString(&quot;redo&quot;), REDO.getCommand());//
 560 //        toolbar1.getItems().add(new Separator());
 561 
 562          alignmentToggleGroup = new ToggleGroup();
 563          alignLeftButton = addToggleButton(toolbar1, alignmentToggleGroup,
 564             resources.getString(&quot;alignLeftIcon&quot;), resources.getString(&quot;alignLeft&quot;), ALIGN_LEFT.getCommand(), &quot;html-editor-align-left&quot;);
 565          alignCenterButton = addToggleButton(toolbar1, alignmentToggleGroup,
 566             resources.getString(&quot;alignCenterIcon&quot;), resources.getString(&quot;alignCenter&quot;), ALIGN_CENTER.getCommand(), &quot;html-editor-align-center&quot;);
 567          alignRightButton = addToggleButton(toolbar1, alignmentToggleGroup,
 568             resources.getString(&quot;alignRightIcon&quot;), resources.getString(&quot;alignRight&quot;), ALIGN_RIGHT.getCommand(), &quot;html-editor-align-right&quot;);
 569          alignJustifyButton = addToggleButton(toolbar1, alignmentToggleGroup,
 570             resources.getString(&quot;alignJustifyIcon&quot;), resources.getString(&quot;alignJustify&quot;), ALIGN_JUSTIFY.getCommand(), &quot;html-editor-align-justify&quot;);
 571 
 572         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 573 
 574         outdentButton = addButton(toolbar1, resources.getString(&quot;outdentIcon&quot;), resources.getString(&quot;outdent&quot;), OUTDENT.getCommand(), &quot;html-editor-outdent&quot;);
 575         if (outdentButton.getGraphic() != null) outdentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 576         indentButton = addButton(toolbar1, resources.getString(&quot;indentIcon&quot;), resources.getString(&quot;indent&quot;), INDENT.getCommand(), &quot;html-editor-indent&quot;);
 577         if (indentButton.getGraphic() != null) indentButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 578 
 579         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 580 
 581          ToggleGroup listStyleToggleGroup = new ToggleGroup();
 582          bulletsButton = addToggleButton(toolbar1, listStyleToggleGroup,
 583             resources.getString(&quot;bulletsIcon&quot;), resources.getString(&quot;bullets&quot;), BULLETS.getCommand(), &quot;html-editor-bullets&quot;);
 584          if (bulletsButton.getGraphic() != null) bulletsButton.getGraphic().setNodeOrientation(NodeOrientation.INHERIT);
 585          numbersButton = addToggleButton(toolbar1, listStyleToggleGroup,
 586             resources.getString(&quot;numbersIcon&quot;), resources.getString(&quot;numbers&quot;), NUMBERS.getCommand(), &quot;html-editor-numbers&quot;);
 587 
 588         toolbar1.getItems().add(new Separator(Orientation.VERTICAL));
 589 
 590         //toolbar1.getItems().add(new Separator());
 591 
 592         // Toolbar 2
 593         formatComboBox = new ComboBox&lt;String&gt;();
 594         formatComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 595         formatComboBox.setFocusTraversable(false);
 596         formatComboBox.setMinWidth(Region.USE_PREF_SIZE);
 597         toolbar2.getItems().add(formatComboBox);
 598 
 599         formatStyleMap = new HashMap&lt;String, String&gt;();
 600         styleFormatMap = new HashMap&lt;String, String&gt;();
 601 
 602         createFormatMenuItem(FORMAT_PARAGRAPH, resources.getString(&quot;paragraph&quot;));
 603         Platform.runLater(() -&gt; {
 604             formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
 605         });
 606         createFormatMenuItem(FORMAT_HEADING_1, resources.getString(&quot;heading1&quot;));
 607         createFormatMenuItem(FORMAT_HEADING_2, resources.getString(&quot;heading2&quot;));
 608         createFormatMenuItem(FORMAT_HEADING_3, resources.getString(&quot;heading3&quot;));
 609         createFormatMenuItem(FORMAT_HEADING_4, resources.getString(&quot;heading4&quot;));
 610         createFormatMenuItem(FORMAT_HEADING_5, resources.getString(&quot;heading5&quot;));
 611         createFormatMenuItem(FORMAT_HEADING_6, resources.getString(&quot;heading6&quot;));
 612 
 613 //        formatComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 614 //            @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 615 //                final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 616 //                    @Override public void updateItem(String item, boolean empty) {
 617 //                        super.updateItem(item, empty);
 618 //                        if (item != null) {
 619 //                            setText(item);
 620 //                        }
 621 //                    }
 622 //                };
 623 //                return cell;
 624 //            }
 625 //        });
 626 
 627         formatComboBox.setTooltip(new Tooltip(resources.getString(&quot;format&quot;)));
 628 
 629         formatComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
 630             if (newValue == null) {
 631                 formatComboBox.setValue(null);
 632             } else {
 633                 String formatValue = formatStyleMap.get(newValue);
 634                 executeCommand(FORMAT.getCommand(), formatValue);
 635                 updateToolbarState(false);
 636 
 637                 // RT-16330 match the new font format with the required weight and size
 638                 for (int i = 0; i &lt; DEFAULT_FORMAT_MAPPINGS.length; i++) {
 639                     String[] mapping = DEFAULT_FORMAT_MAPPINGS[i];
 640                     if (mapping[0].equalsIgnoreCase(formatValue)) {
 641                         executeCommand(FONT_SIZE.getCommand(), mapping[2]);
 642                         updateToolbarState(false);
 643                         break;
 644                     }
 645                 }
 646             }
 647         });
 648 
 649         fontFamilyComboBox = new ComboBox&lt;String&gt;();
 650         fontFamilyComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 651         fontFamilyComboBox.setMinWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 652         fontFamilyComboBox.setPrefWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 653         fontFamilyComboBox.setMaxWidth(FONT_FAMILY_MENUBUTTON_WIDTH);
 654         fontFamilyComboBox.setFocusTraversable(false);
 655         fontFamilyComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontFamily&quot;)));
 656         toolbar2.getItems().add(fontFamilyComboBox);
 657 
 658         // Fix for RT-32906, where all rows were being put through the cell factory
 659         // so that they could be measured. Because we have a fixed width for the
 660         // button this is unnecessary and so we tell the ComboBox to not measure
 661         // any rows.
 662         fontFamilyComboBox.getProperties().put(&quot;comboBoxRowsToMeasureWidth&quot;, 0);
 663 
 664         fontFamilyComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 665             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 666                 final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 667                     @Override public void updateItem(String item, boolean empty) {
 668                         super.updateItem(item, empty);
 669                         if (item != null) {
 670                             setText(item);
 671                             setFont(new Font(item, 12));
 672                         }
 673                     }
 674                 };
 675                 cell.setMinWidth(FONT_FAMILY_MENU_WIDTH);
 676                 cell.setPrefWidth(FONT_FAMILY_MENU_WIDTH);
 677                 cell.setMaxWidth(FONT_FAMILY_MENU_WIDTH);
 678                 return cell;
 679             }
 680         });
 681 
 682         Platform.runLater(() -&gt; {
 683             final ObservableList&lt;String&gt; fonts = FXCollections.observableArrayList(Font.getFamilies());
 684             fonts.add(0, &quot;&quot;);
 685             for (String fontFamily : fonts) {
 686                 fontFamilyComboBox.setValue(&quot;&quot;);
 687                 fontFamilyComboBox.setItems(fonts);
 688             }
 689         });
 690 
 691         fontFamilyComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
 692             executeCommand(FONT_FAMILY.getCommand(), &quot;&#39;&quot; + newValue + &quot;&#39;&quot;);
 693         });
 694 
 695         fontSizeComboBox = new ComboBox&lt;String&gt;();
 696         fontSizeComboBox.getStyleClass().add(&quot;font-menu-button&quot;);
 697         fontSizeComboBox.setFocusTraversable(false);
 698         toolbar2.getItems().add(fontSizeComboBox);
 699 
 700         fontSizeMap = new HashMap&lt;String, String&gt;();
 701         sizeFontMap = new HashMap&lt;String, String&gt;();
 702 
 703         createFontSizeMenuItem(SIZE_XX_SMALL, resources.getString(&quot;extraExtraSmall&quot;));
 704         createFontSizeMenuItem(SIZE_X_SMALL, resources.getString(&quot;extraSmall&quot;));
 705         createFontSizeMenuItem(SIZE_SMALL, resources.getString(&quot;small&quot;));
 706         Platform.runLater(() -&gt; {
 707             fontSizeComboBox.setValue(resources.getString(&quot;small&quot;));
 708         });
 709         createFontSizeMenuItem(SIZE_MEDIUM, resources.getString(&quot;medium&quot;));
 710         createFontSizeMenuItem(SIZE_LARGE, resources.getString(&quot;large&quot;));
 711         createFontSizeMenuItem(SIZE_X_LARGE, resources.getString(&quot;extraLarge&quot;));
 712         createFontSizeMenuItem(SIZE_XX_LARGE, resources.getString(&quot;extraExtraLarge&quot;));
 713         fontSizeComboBox.setTooltip(new Tooltip(resources.getString(&quot;fontSize&quot;)));
 714 
 715         fontSizeComboBox.setCellFactory(new Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() {
 716             @Override public ListCell&lt;String&gt; call(ListView&lt;String&gt; param) {
 717                 final ListCell&lt;String&gt; cell = new ListCell&lt;String&gt;() {
 718                     @Override public void updateItem(String item, boolean empty) {
 719                         super.updateItem(item, empty);
 720                         if (item != null) {
 721                             setText(item);
 722                             // Remove trailing non-digits to get the size (don&#39;t assume there&#39;s a space).
 723                             String size = item.replaceFirst(&quot;[^0-9.].*$&quot;, &quot;&quot;);
 724                             setFont(new Font((String)fontFamilyComboBox.getValue(), Double.valueOf(size)));
 725                         }
 726                     }
 727                 };
 728                 return cell;
 729             }
 730         });
 731 
 732 
 733         fontSizeComboBox.valueProperty().addListener((observable, oldValue, newValue) -&gt; {
 734             Object fontSizeValue = getCommandValue(FONT_SIZE.getCommand());
 735             if (!newValue.equals(fontSizeValue)) {
 736                 executeCommand(FONT_SIZE.getCommand(), fontSizeMap.get(newValue));
 737             }
 738         });
 739 
 740         toolbar2.getItems().add(new Separator(Orientation.VERTICAL));
 741 
 742         boldButton = addToggleButton(toolbar2, null,
 743             resources.getString(&quot;boldIcon&quot;), resources.getString(&quot;bold&quot;), BOLD.getCommand(), &quot;html-editor-bold&quot;);
 744         boldButton.setOnAction(event1 -&gt; {
 745             // Only use the bold button for paragraphs.  We don&#39;t
 746             // want to turn bold off for headings.
 747 
 748             if (&quot;&lt;p&gt;&quot;.equals(formatStyleMap.get(formatComboBox.getValue())))  {
 749                 executeCommand(BOLD.getCommand(), boldButton.selectedProperty().getValue().toString());
 750             }
 751         });
 752         italicButton = addToggleButton(toolbar2, null,
 753             resources.getString(&quot;italicIcon&quot;), resources.getString(&quot;italic&quot;), ITALIC.getCommand(), &quot;html-editor-italic&quot;);
 754         underlineButton = addToggleButton(toolbar2, null,
 755             resources.getString(&quot;underlineIcon&quot;), resources.getString(&quot;underline&quot;), UNDERLINE.getCommand(), &quot;html-editor-underline&quot;);
 756         strikethroughButton = addToggleButton(toolbar2, null,
 757             resources.getString(&quot;strikethroughIcon&quot;), resources.getString(&quot;strikethrough&quot;), STRIKETHROUGH.getCommand(), &quot;html-editor-strike&quot;);
 758 
 759         toolbar2.getItems().add(new Separator(Orientation.VERTICAL));
 760 
 761         insertHorizontalRuleButton = addButton(toolbar2, resources.getString(&quot;insertHorizontalRuleIcon&quot;),
 762             resources.getString(&quot;insertHorizontalRule&quot;), INSERT_HORIZONTAL_RULE.getCommand(), &quot;html-editor-hr&quot;);
 763         // We override setOnAction to insert a new line.  This fixes RT-16453
 764         insertHorizontalRuleButton.setOnAction(event -&gt; {
 765             executeCommand(INSERT_NEW_LINE.getCommand(), null);
 766             executeCommand(INSERT_HORIZONTAL_RULE.getCommand(), null);
 767             updateToolbarState(false);
 768         });
 769 
 770         fgColorButton = new ColorPicker();
 771         fgColorButton.getStyleClass().add(&quot;html-editor-foreground&quot;);
 772         fgColorButton.setFocusTraversable(false);
 773         toolbar1.getItems().add(fgColorButton);
 774 
 775         // JDK-8115747: Icon URLs are now specified in CSS.
 776         // fgColorButton.applyCss();
 777         // ColorPickerSkin fgColorPickerSkin = (ColorPickerSkin) fgColorButton.getSkin();
 778         // String fgIcon = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; HTMLEditorSkin.class.getResource(resources.getString(&quot;foregroundColorIcon&quot;)).toString());
 779         // ((StyleableProperty)fgColorPickerSkin.imageUrlProperty()).applyStyle(null,fgIcon);
 780 
 781         fgColorButton.setValue(DEFAULT_FG_COLOR);
 782         fgColorButton.setTooltip(new Tooltip(resources.getString(&quot;foregroundColor&quot;)));
 783         fgColorButton.setOnAction(ev1 -&gt; {
 784             Color newValue = fgColorButton.getValue();
 785             if (newValue != null) {
 786                 executeCommand(FOREGROUND_COLOR.getCommand(), colorValueToRGBA(newValue));
 787                 fgColorButton.hide();
 788             }
 789         });
 790 
 791         bgColorButton = new ColorPicker();
 792         bgColorButton.getStyleClass().add(&quot;html-editor-background&quot;);
 793         bgColorButton.setFocusTraversable(false);
 794         toolbar1.getItems().add(bgColorButton);
 795 
 796         // JDK-8115747: Icon URLs are now specified in CSS.
 797         // bgColorButton.applyCss();
 798         // ColorPickerSkin  bgColorPickerSkin = (ColorPickerSkin) bgColorButton.getSkin();
 799         // String bgIcon = AccessController.doPrivileged((PrivilegedAction&lt;String&gt;) () -&gt; HTMLEditorSkin.class.getResource(resources.getString(&quot;backgroundColorIcon&quot;)).toString());
 800         // ((StyleableProperty)bgColorPickerSkin.imageUrlProperty()).applyStyle(null,bgIcon);
 801 
 802         bgColorButton.setValue(DEFAULT_BG_COLOR);
 803         bgColorButton.setTooltip(new Tooltip(resources.getString(&quot;backgroundColor&quot;)));
 804 
 805         bgColorButton.setOnAction(ev -&gt; {
 806             Color newValue = bgColorButton.getValue();
 807             if (newValue != null) {
 808                 executeCommand(BACKGROUND_COLOR.getCommand(), colorValueToRGBA(newValue));
 809                 bgColorButton.hide();
 810             }
 811         });
 812     }
 813 
 814     private String colorValueToRGBA(Color c) {
 815         return String.format((Locale)null, &quot;rgba(%d, %d, %d, %.5f)&quot;,
 816                              Math.round(c.getRed() * 255),
 817                              Math.round(c.getGreen() * 255),
 818                              Math.round(c.getBlue() * 255),
 819                              c.getOpacity());
 820     }
 821 
 822     private Button addButton(ToolBar toolbar, final String iconName, String tooltipText,
 823             final String command, final String styleClass) {
 824         Button button = new Button();
 825         button.setFocusTraversable(false);
 826         button.getStyleClass().add(styleClass);
 827         toolbar.getItems().add(button);
 828 
 829         Image icon = AccessController.doPrivileged((PrivilegedAction&lt;Image&gt;) () -&gt; new Image(HTMLEditorSkin.class.getResource(iconName).toString()));
 830 //        button.setGraphic(new ImageView(icon));
 831         ((StyleableProperty)button.graphicProperty()).applyStyle(null, new ImageView(icon));
 832         button.setTooltip(new Tooltip(tooltipText));
 833 
 834         button.setOnAction(event -&gt; {
 835             executeCommand(command, null);
 836             updateToolbarState(false);
 837         });
 838 
 839         return button;
 840     }
 841 
 842     private ToggleButton addToggleButton(ToolBar toolbar, ToggleGroup toggleGroup,
 843             final String iconName, String tooltipText, final String command, final String styleClass) {
 844         ToggleButton toggleButton = new ToggleButton();
 845         toggleButton.setUserData(command);
 846         toggleButton.setFocusTraversable(false);
 847         toggleButton.getStyleClass().add(styleClass);
 848         toolbar.getItems().add(toggleButton);
 849         if (toggleGroup != null) {
 850             toggleButton.setToggleGroup(toggleGroup);
 851         }
 852 
 853         Image icon = AccessController.doPrivileged((PrivilegedAction&lt;Image&gt;) () -&gt; new Image(HTMLEditorSkin.class.getResource(iconName).toString()));
 854         ((StyleableProperty)toggleButton.graphicProperty()).applyStyle(null, new ImageView(icon));
 855 //        toggleButton.setGraphic(new ImageView(icon));
 856 
 857         toggleButton.setTooltip(new Tooltip(tooltipText));
 858 
 859         if (!BOLD.getCommand().equals(command)) {
 860             toggleButton.selectedProperty().addListener((observable, oldValue, newValue) -&gt; {
 861                 if (getCommandState(command) != newValue.booleanValue()) {
 862                     executeCommand(command, null);
 863                 }
 864             });
 865         }
 866         return toggleButton;
 867     }
 868 
 869     private void createFormatMenuItem(String formatValue, String label) {
 870         formatComboBox.getItems().add(label);
 871         formatStyleMap.put(label, formatValue);
 872         styleFormatMap.put(formatValue, label);
 873     }
 874 
 875     private void createFontSizeMenuItem(String fontSizeValue, String label) {
 876         fontSizeComboBox.getItems().add(label);
 877         fontSizeMap.put(label, fontSizeValue);
 878         sizeFontMap.put(fontSizeValue, label);
 879     }
 880 
 881     private void updateNodeOrientation() {
 882         NodeOrientation orientation = getSkinnable().getEffectiveNodeOrientation();
 883 
 884         HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
 885         HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
 886         if (htmlDocumentElement.getAttribute(&quot;dir&quot;) == null) {
 887             htmlDocumentElement.setAttribute(&quot;dir&quot;, (orientation == RIGHT_TO_LEFT) ? &quot;rtl&quot; : &quot;ltr&quot;);
 888         }
 889 
 890     }
 891 
 892     private void updateToolbarState(final boolean updateAlignment) {
 893         if (!webView.isFocused()) {
 894             return;
 895         }
 896 
 897         atomicityCount++;
 898 
 899         // These command aways return true.
 900         copyButton.setDisable(!isCommandEnabled(CUT.getCommand()));
 901         cutButton.setDisable(!isCommandEnabled(COPY.getCommand()));
 902         pasteButton.setDisable(!isCommandEnabled(PASTE.getCommand()));
 903 
 904         // undoButton.setDisable(!isCommandEnabled(UNDO.getCommand()));
 905         // redoButton.setDisable(!isCommandEnabled(REDO.getCommand()));
 906 
 907 //        undoButton.setDisable(!isCommandEnabled(FORMAT.getCommand()));
 908 //        redoButton.setDisable(!isCommandEnabled(FORMAT.getCommand()));
 909 
 910         insertHorizontalRuleButton.setDisable(!isCommandEnabled(INSERT_HORIZONTAL_RULE.getCommand()));
 911 
 912         if (updateAlignment) {
 913             alignLeftButton.setDisable(!isCommandEnabled(ALIGN_LEFT.getCommand()));
 914             alignLeftButton.setSelected(getCommandState(ALIGN_LEFT.getCommand()));
 915             alignCenterButton.setDisable(!isCommandEnabled(ALIGN_CENTER.getCommand()));
 916             alignCenterButton.setSelected(getCommandState(ALIGN_CENTER.getCommand()));
 917             alignRightButton.setDisable(!isCommandEnabled(ALIGN_RIGHT.getCommand()));
 918             alignRightButton.setSelected(getCommandState(ALIGN_RIGHT.getCommand()));
 919             alignJustifyButton.setDisable(!isCommandEnabled(ALIGN_JUSTIFY.getCommand()));
 920             alignJustifyButton.setSelected(getCommandState(ALIGN_JUSTIFY.getCommand()));
 921         } else {
 922             if (alignmentToggleGroup.getSelectedToggle() != null) {
 923                 String command = alignmentToggleGroup.getSelectedToggle().getUserData().toString();
 924                 if (isCommandEnabled(command) &amp;&amp; !getCommandState(command) ) {
 925                     executeCommand(command, null);
 926                 }
 927             }
 928         }
 929 
 930         if (alignmentToggleGroup.getSelectedToggle() == null
 931                 &amp;&amp; webPage.getClientSelectedText().isEmpty()) {
 932             alignmentToggleGroup.selectToggle(alignLeftButton);
 933         }
 934 
 935         bulletsButton.setDisable(!isCommandEnabled(BULLETS.getCommand()));
 936         bulletsButton.setSelected(getCommandState(BULLETS.getCommand()));
 937         numbersButton.setDisable(!isCommandEnabled(NUMBERS.getCommand()));
 938         numbersButton.setSelected(getCommandState(NUMBERS.getCommand()));
 939 
 940         indentButton.setDisable(!isCommandEnabled(INDENT.getCommand()));
 941         outdentButton.setDisable(!isCommandEnabled(OUTDENT.getCommand()));
 942 
 943         formatComboBox.setDisable(!isCommandEnabled(FORMAT.getCommand()));
 944 
 945 
 946         String formatValue = getCommandValue(FORMAT.getCommand());
 947         if (formatValue != null) {
 948             String htmlTag = &quot;&lt;&quot; + formatValue + &quot;&gt;&quot;;
 949             String comboFormatValue = styleFormatMap.get(htmlTag);
 950             String format = formatComboBox.getValue();
 951 
 952             // if the format value is then we assume that we&#39;re dealing with a paragraph,
 953             // which seems to correspond with the HTML output we receive.
 954             if ((resetToolbarState || htmlTag.equals(&quot;&lt;&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;div&gt;&quot;) || htmlTag.equalsIgnoreCase(&quot;&lt;blockquote&gt;&quot;))) {
 955                 formatComboBox.setValue(resources.getString(&quot;paragraph&quot;));
 956             } else if (format != null &amp;&amp; ! format.equalsIgnoreCase(comboFormatValue)) {
 957                 formatComboBox.setValue(comboFormatValue);
 958             }
 959         }
 960 
 961         fontFamilyComboBox.setDisable(!isCommandEnabled(FONT_FAMILY.getCommand()));
 962         final String fontFamilyValue = getCommandValue(FONT_FAMILY.getCommand());
 963         if (fontFamilyValue != null) {
 964             String fontFamilyStr = fontFamilyValue;
 965 
 966             // stripping out apostrophe characters, which are appended to either
 967             // end of the font face name when the font face has one or more spaces.
 968             if (fontFamilyStr.startsWith(&quot;&#39;&quot;)) {
 969                 fontFamilyStr = fontFamilyStr.substring(1);
 970             }
 971             if (fontFamilyStr.endsWith(&quot;&#39;&quot;)) {
 972                 fontFamilyStr = fontFamilyStr.substring(0,fontFamilyStr.length() - 1);
 973             }
 974 
 975             Object selectedFont = fontFamilyComboBox.getValue();
 976             if (selectedFont instanceof String) {
 977                 if (!selectedFont.equals(fontFamilyStr)) {
 978 
 979                     ObservableList&lt;String&gt; fontFamilyItems = fontFamilyComboBox.getItems();
 980                     String selectedComboFont = null;
 981                     for (String comboFontFamilyValue : fontFamilyItems) {
 982 
 983                         if (comboFontFamilyValue.equals(fontFamilyStr)) {
 984                             selectedComboFont = comboFontFamilyValue;
 985                             break;
 986                         }
 987                         // Note: By default, &#39;Dialog&#39; is the font returned from webview.
 988                         // For presidio, we&#39;re just mapping to the default font.
 989                         if (comboFontFamilyValue.equals(&quot;&quot;) &amp;&amp; fontFamilyStr.equals(&quot;Dialog&quot;)) {
 990                             selectedComboFont = comboFontFamilyValue;
 991                             break;
 992                         }
 993                     }
 994 
 995                     if (selectedComboFont != null) {
 996                         fontFamilyComboBox.setValue(selectedComboFont);
 997                     }
 998                 }
 999             }
1000         }
1001 
1002         fontSizeComboBox.setDisable(!isCommandEnabled(FONT_SIZE.getCommand()));
1003         String fontSizeValue = getCommandValue(FONT_SIZE.getCommand());
1004 
1005         // added test for fontSizeValue == null to combat RT-28847
1006         if (resetToolbarState &amp;&amp; fontSizeValue == null) {
1007             fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
1008         } else {
1009             if (fontSizeValue != null) {
1010                 if (!fontSizeComboBox.getValue().equals(sizeFontMap.get(fontSizeValue))) {
1011                     fontSizeComboBox.setValue(sizeFontMap.get(fontSizeValue));
1012                 }
1013             }
1014             else {
1015                 /*
1016                 ** these is no font size set in webview,
1017                 ** let&#39;s just use the default....
1018                 */
1019                 if ((fontSizeComboBox.getValue() == null) || !fontSizeComboBox.getValue().equals(sizeFontMap.get(SIZE_SMALL))) {
1020                     fontSizeComboBox.setValue(sizeFontMap.get(SIZE_SMALL));
1021                 }
1022             }
1023         }
1024 
1025         boldButton.setDisable(!isCommandEnabled(BOLD.getCommand()));
1026         boldButton.setSelected(getCommandState(BOLD.getCommand()));
1027         italicButton.setDisable(!isCommandEnabled(ITALIC.getCommand()));
1028         italicButton.setSelected(getCommandState(ITALIC.getCommand()));
1029         underlineButton.setDisable(!isCommandEnabled(UNDERLINE.getCommand()));
1030         underlineButton.setSelected(getCommandState(UNDERLINE.getCommand()));
1031         strikethroughButton.setDisable(!isCommandEnabled(STRIKETHROUGH.getCommand()));
1032         strikethroughButton.setSelected(getCommandState(STRIKETHROUGH.getCommand()));
1033 
1034         fgColorButton.setDisable(!isCommandEnabled(FOREGROUND_COLOR.getCommand()));
1035         String foregroundColorValue = getCommandValue(FOREGROUND_COLOR.getCommand());
1036         if (foregroundColorValue != null) {
1037             fgColorButton.setValue(getColor(foregroundColorValue));
1038         }
1039 
1040         bgColorButton.setDisable(!isCommandEnabled(BACKGROUND_COLOR.getCommand()));
1041         String backgroundColorValue = getCommandValue(BACKGROUND_COLOR.getCommand());
1042         if (backgroundColorValue != null) {
1043             bgColorButton.setValue(getColor(backgroundColorValue));
1044         }
1045 
1046         atomicityCount = atomicityCount == 0 ? 0 : --atomicityCount;
1047     }
1048 
1049     private void enableToolbar(final boolean enable) {
1050         Platform.runLater(() -&gt; {
1051 
1052             // Make sure buttons have been created to avoid NPE
1053             if (copyButton == null) return;
1054 
1055             /*
1056             ** if we&#39;re to enable, we still only enable
1057             ** the cut/copy/paste buttons that make sense
1058             */
1059             if (enable) {
1060                 copyButton.setDisable(!isCommandEnabled(COPY.getCommand()));
1061                 cutButton.setDisable(!isCommandEnabled(CUT.getCommand()));
1062                 pasteButton.setDisable(!isCommandEnabled(PASTE.getCommand()));
1063             } else {
1064                 copyButton.setDisable(true);
1065                 cutButton.setDisable(true);
1066                 pasteButton.setDisable(true);
1067             }
1068 
1069 //                undoButton.setDisable(!enable);
1070 //                redoButton.setDisable(!enable);
1071             insertHorizontalRuleButton.setDisable(!enable);
1072             alignLeftButton.setDisable(!enable);
1073             alignCenterButton.setDisable(!enable);
1074             alignRightButton.setDisable(!enable);
1075             alignJustifyButton.setDisable(!enable);
1076             bulletsButton.setDisable(!enable);
1077             numbersButton.setDisable(!enable);
1078             indentButton.setDisable(!enable);
1079             outdentButton.setDisable(!enable);
1080             formatComboBox.setDisable(!enable);
1081             fontFamilyComboBox.setDisable(!enable);
1082             fontSizeComboBox.setDisable(!enable);
1083             boldButton.setDisable(!enable);
1084             italicButton.setDisable(!enable);
1085             underlineButton.setDisable(!enable);
1086             strikethroughButton.setDisable(!enable);
1087             fgColorButton.setDisable(!enable);
1088             bgColorButton.setDisable(!enable);
1089         });
1090     }
1091 
1092     private boolean executeCommand(String command, String value) {
1093         // The mentions of atomicity throughout this class relate back to RT-39941,
1094         // refer to that jira issue for more context.
1095         if (!enableAtomicityCheck || (enableAtomicityCheck &amp;&amp; atomicityCount == 0)) {
1096             return webPage.executeCommand(command, value);
1097         }
1098         return false;
1099     }
1100 
1101     private boolean isCommandEnabled(String command) {
1102         return webPage.queryCommandEnabled(command);
1103     }
1104 
1105     private void setContentEditable(boolean b) {
1106         HTMLDocument htmlDocument = (HTMLDocument)webPage.getDocument(webPage.getMainFrame());
1107         HTMLElement htmlDocumentElement = (HTMLElement)htmlDocument.getDocumentElement();
1108         HTMLElement htmlBodyElement = (HTMLElement)htmlDocumentElement.getElementsByTagName(&quot;body&quot;).item(0);
1109         htmlBodyElement.setAttribute(&quot;contenteditable&quot;, Boolean.toString(b));
1110     }
1111 
1112     private boolean getCommandState(String command) {
1113         return webPage.queryCommandState(command);
1114     }
1115 
1116     private String getCommandValue(String command) {
1117         return webPage.queryCommandValue(command);
1118     }
1119 
1120     private Color getColor(String value) {
1121         Color color = Color.web(value);
1122         /* The default background color for WebView, according to the HTML
1123          * standard is rgba=#00000000 (transparent). The canvas background is expected
1124          * to be white.
1125          */
1126         if (color.equals(Color.TRANSPARENT)) {
1127             color = Color.WHITE;
1128         }
1129         return color;
1130     }
1131 
1132     private void applyTextFormatting() {
1133         if (getCommandState(BULLETS.getCommand()) || getCommandState(NUMBERS.getCommand())) {
1134             return;
1135         }
1136 
1137         if (webPage.getClientCommittedTextLength() == 0) {
1138             String format = formatStyleMap.get(formatComboBox.getValue());
1139             String font   = fontFamilyComboBox.getValue().toString();
1140 
1141             executeCommand(FORMAT.getCommand(), format);
1142             executeCommand(FONT_FAMILY.getCommand(), &quot;&#39;&quot; + font + &quot;&#39;&quot;);
1143         }
1144     }
1145 
1146     void print(PrinterJob job) {
1147         webView.getEngine().print(job);
1148     }
1149 
1150 
1151 
1152     /***************************************************************************
1153      *                                                                         *
1154      * Support Classes                                                         *
1155      *                                                                         *
1156      **************************************************************************/
1157 
1158     /**
1159      * Represents commands that can be passed into the HTMLEditor web engine.
1160      */
1161     public enum Command {
1162         CUT(&quot;cut&quot;),
1163         COPY(&quot;copy&quot;),
1164         PASTE(&quot;paste&quot;),
1165 
1166         UNDO(&quot;undo&quot;),
1167         REDO(&quot;redo&quot;),
1168 
1169         INSERT_HORIZONTAL_RULE(&quot;inserthorizontalrule&quot;),
1170 
1171         ALIGN_LEFT(&quot;justifyleft&quot;),
1172         ALIGN_CENTER(&quot;justifycenter&quot;),
1173         ALIGN_RIGHT(&quot;justifyright&quot;),
1174         ALIGN_JUSTIFY(&quot;justifyfull&quot;),
1175 
1176         BULLETS(&quot;insertUnorderedList&quot;),
1177         NUMBERS(&quot;insertOrderedList&quot;),
1178 
1179         INDENT(&quot;indent&quot;),
1180         OUTDENT(&quot;outdent&quot;),
1181 
1182         FORMAT(&quot;formatblock&quot;),
1183         FONT_FAMILY(&quot;fontname&quot;),
1184         FONT_SIZE(&quot;fontsize&quot;),
1185 
1186         BOLD(&quot;bold&quot;),
1187         ITALIC(&quot;italic&quot;),
1188         UNDERLINE(&quot;underline&quot;),
1189         STRIKETHROUGH(&quot;strikethrough&quot;),
1190 
1191         FOREGROUND_COLOR(&quot;forecolor&quot;),
1192         BACKGROUND_COLOR(&quot;backcolor&quot;),
1193         STYLEWITHCSS(&quot;styleWithCSS&quot;),
1194 
1195         INSERT_NEW_LINE(&quot;insertnewline&quot;),
1196         INSERT_TAB(&quot;inserttab&quot;);
1197 
1198         private final String command;
1199 
1200         Command(String command) {
1201             this.command = command;
1202         }
1203 
1204         public String getCommand() {
1205             return command;
1206         }
1207     }
1208 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
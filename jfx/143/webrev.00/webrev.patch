diff a/modules/javafx.graphics/src/main/legal/jpeg_fx.md b/modules/javafx.graphics/src/main/legal/jpeg_fx.md
--- a/modules/javafx.graphics/src/main/legal/jpeg_fx.md
+++ b/modules/javafx.graphics/src/main/legal/jpeg_fx.md
@@ -1,6 +1,6 @@
-## Independent JPEG Group (IJG) JPEG v9c
+## Independent JPEG Group (IJG) JPEG v9d
 
 ### IJG License
 ```
 
 /*
@@ -16,11 +16,11 @@
 The authors make NO WARRANTY or representation, either express or implied,
 with respect to this software, its quality, accuracy, merchantability, or
 fitness for a particular purpose.  This software is provided "AS IS", and you,
 its user, assume the entire risk as to its quality and accuracy.
 
-This software is copyright (C) 1991-2018, Thomas G. Lane, Guido Vollbeding.
+This software is copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.
 All Rights Reserved except as specified below.
 
 Permission is hereby granted to use, copy, modify, and distribute this
 software (or portions thereof) for any purpose, without fee, subject to these
 conditions:
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/README b/modules/javafx.graphics/src/main/native-iio/libjpeg/README
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/README
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/README
@@ -1,19 +1,19 @@
 The Independent JPEG Group's JPEG software
 ==========================================
 
-README for release 9c of 14-Jan-2018
+README for release 9d of 12-Jan-2020
 ====================================
 
 This distribution contains the ninth public release of the Independent JPEG
 Group's free JPEG software.  You are welcome to redistribute this software and
 to use it for any purpose, subject to the conditions under LEGAL ISSUES, below.
 
 This software is the work of Tom Lane, Guido Vollbeding, Philip Gladstone,
 Bill Allombert, Jim Boucher, Lee Crocker, Bob Friesenhahn, Ben Jackson,
-Julian Minguillon, Luis Ortiz, George Phillips, Davide Rossi, Ge' Weijers,
-and other members of the Independent JPEG Group.
+John Korejwa, Julian Minguillon, Luis Ortiz, George Phillips, Davide Rossi,
+Ge' Weijers, and other members of the Independent JPEG Group.
 
 IJG is not affiliated with the ISO/IEC JTC1/SC29/WG1 standards committee
 (previously known as JPEG, together with ITU-T SG16).
 
 
@@ -113,11 +113,11 @@
 The authors make NO WARRANTY or representation, either express or implied,
 with respect to this software, its quality, accuracy, merchantability, or
 fitness for a particular purpose.  This software is provided "AS IS", and you,
 its user, assume the entire risk as to its quality and accuracy.
 
-This software is copyright (C) 1991-2018, Thomas G. Lane, Guido Vollbeding.
+This software is copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.
 All Rights Reserved except as specified below.
 
 Permission is hereby granted to use, copy, modify, and distribute this
 software (or portions thereof) for any purpose, without fee, subject to these
 conditions:
@@ -150,17 +150,10 @@
 It is copyright by the Free Software Foundation but is freely distributable.
 The same holds for its supporting scripts (config.guess, config.sub,
 ltmain.sh).  Another support script, install-sh, is copyright by X Consortium
 but is also freely distributable.
 
-The IJG distribution formerly included code to read and write GIF files.
-To avoid entanglement with the Unisys LZW patent (now expired), GIF reading
-support has been removed altogether, and the GIF writer has been simplified
-to produce "uncompressed GIFs".  This technique does not use the LZW
-algorithm; the resulting GIF files are larger than usual, but are readable
-by all standard GIF decoders.
-
 
 REFERENCES
 ==========
 
 We recommend reading one or more of these references before trying to
@@ -244,12 +237,12 @@
 =================
 
 The "official" archive site for this software is www.ijg.org.
 The most recent released version can always be found there in
 directory "files".  This particular version will be archived as
-http://www.ijg.org/files/jpegsrc.v9c.tar.gz, and in Windows-compatible
-"zip" archive format as http://www.ijg.org/files/jpegsr9c.zip.
+http://www.ijg.org/files/jpegsrc.v9d.tar.gz, and in Windows-compatible
+"zip" archive format as http://www.ijg.org/files/jpegsr9d.zip.
 
 The JPEG FAQ (Frequently Asked Questions) article is a source of some
 general information about JPEG.
 It is available on the World Wide Web at http://www.faqs.org/faqs/jpeg-faq/
 and other news.answers archive sites, including the official news.answers
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/UPDATING.txt b/modules/javafx.graphics/src/main/native-iio/libjpeg/UPDATING.txt
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/UPDATING.txt
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/UPDATING.txt
@@ -20,10 +20,11 @@
 * jdhuff.c
 * jdmaster.c
 * jdtrans.c
 * jerror.h
 * jmorecfg.h
+* jmemmgr.c
 
 ** The modifications are,
 4.1) Remove arithmetic encoding/decoding.
 Files: jcinit.c, jctrans.c, jdmaster.c, jdtrans.c, jerror.h, jmorecfg.h
 
@@ -38,8 +39,11 @@
 Pointer to these functions is used while initializing decompressor.
 
 4.4) Improve image filling.
 Files: jdhuff.c
 
+4.5) Improve JPEG processing
+Files: jmemmgr.c
+
 5) Expand tabs and remove trailing white spaces from source files.
 
 6) Verification: FX sdk build and all test run, on all supported platforms.
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jccolor.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jccolor.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jccolor.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jccolor.c
@@ -1,10 +1,10 @@
 /*
  * jccolor.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
- * Modified 2011-2013 by Guido Vollbeding.
+ * Modified 2011-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains input colorspace conversion routines.
  */
@@ -103,52 +103,52 @@
   INT32 i;
 
   /* Allocate and fill in the conversion tables. */
   cconvert->rgb_ycc_tab = rgb_ycc_tab = (INT32 *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (TABLE_SIZE * SIZEOF(INT32)));
+                TABLE_SIZE * SIZEOF(INT32));
 
   for (i = 0; i <= MAXJSAMPLE; i++) {
     rgb_ycc_tab[i+R_Y_OFF] = FIX(0.299) * i;
     rgb_ycc_tab[i+G_Y_OFF] = FIX(0.587) * i;
     rgb_ycc_tab[i+B_Y_OFF] = FIX(0.114) * i   + ONE_HALF;
-    rgb_ycc_tab[i+R_CB_OFF] = (-FIX(0.168735892)) * i;
-    rgb_ycc_tab[i+G_CB_OFF] = (-FIX(0.331264108)) * i;
+    rgb_ycc_tab[i+R_CB_OFF] = (- FIX(0.168735892)) * i;
+    rgb_ycc_tab[i+G_CB_OFF] = (- FIX(0.331264108)) * i;
     /* We use a rounding fudge-factor of 0.5-epsilon for Cb and Cr.
      * This ensures that the maximum output will round to MAXJSAMPLE
      * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
      */
     rgb_ycc_tab[i+B_CB_OFF] = FIX(0.5) * i    + CBCR_OFFSET + ONE_HALF-1;
 /*  B=>Cb and R=>Cr tables are the same
     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.5) * i    + CBCR_OFFSET + ONE_HALF-1;
 */
-    rgb_ycc_tab[i+G_CR_OFF] = (-FIX(0.418687589)) * i;
-    rgb_ycc_tab[i+B_CR_OFF] = (-FIX(0.081312411)) * i;
+    rgb_ycc_tab[i+G_CR_OFF] = (- FIX(0.418687589)) * i;
+    rgb_ycc_tab[i+B_CR_OFF] = (- FIX(0.081312411)) * i;
   }
 }
 
 
 /*
  * Convert some rows of samples to the JPEG colorspace.
  *
  * Note that we change from the application's interleaved-pixel format
- * to our internal noninterleaved, one-plane-per-component format.
- * The input buffer is therefore three times as wide as the output buffer.
+ * to our internal noninterleaved, one-plane-per-component format.  The
+ * input buffer is therefore three times as wide as the output buffer.
  *
- * A starting row offset is provided only for the output buffer.  The caller
- * can easily adjust the passed input_buf value to accommodate any row
- * offset required on that side.
+ * A starting row offset is provided only for the output buffer.  The
+ * caller can easily adjust the passed input_buf value to accommodate
+ * any row offset required on that side.
  */
 
 METHODDEF(void)
 rgb_ycc_convert (j_compress_ptr cinfo,
          JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
          JDIMENSION output_row, int num_rows)
 {
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register INT32 * ctab = cconvert->rgb_ycc_tab;
   register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_ycc_tab;
   register JSAMPROW inptr;
   register JSAMPROW outptr0, outptr1, outptr2;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
 
@@ -160,10 +160,11 @@
     output_row++;
     for (col = 0; col < num_cols; col++) {
       r = GETJSAMPLE(inptr[RGB_RED]);
       g = GETJSAMPLE(inptr[RGB_GREEN]);
       b = GETJSAMPLE(inptr[RGB_BLUE]);
+      inptr += RGB_PIXELSIZE;
       /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
        * must be too; we do not need an explicit range-limiting operation.
        * Hence the value being shifted is never negative, and we don't
        * need the general RIGHT_SHIFT macro.
        */
@@ -177,11 +178,10 @@
          >> SCALEBITS);
       /* Cr */
       outptr2[col] = (JSAMPLE)
         ((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
          >> SCALEBITS);
-      inptr += RGB_PIXELSIZE;
     }
   }
 }
 
 
@@ -199,12 +199,12 @@
 rgb_gray_convert (j_compress_ptr cinfo,
           JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
           JDIMENSION output_row, int num_rows)
 {
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register INT32 * ctab = cconvert->rgb_ycc_tab;
   register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_ycc_tab;
   register JSAMPROW inptr;
   register JSAMPROW outptr;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
 
@@ -213,36 +213,36 @@
     outptr = output_buf[0][output_row++];
     for (col = 0; col < num_cols; col++) {
       r = GETJSAMPLE(inptr[RGB_RED]);
       g = GETJSAMPLE(inptr[RGB_GREEN]);
       b = GETJSAMPLE(inptr[RGB_BLUE]);
+      inptr += RGB_PIXELSIZE;
       /* Y */
       outptr[col] = (JSAMPLE)
         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
          >> SCALEBITS);
-      inptr += RGB_PIXELSIZE;
     }
   }
 }
 
 
 /*
  * Convert some rows of samples to the JPEG colorspace.
  * This version handles Adobe-style CMYK->YCCK conversion,
- * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
- * conversion as above, while passing K (black) unchanged.
+ * where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the
+ * same conversion as above, while passing K (black) unchanged.
  * We assume rgb_ycc_start has been called.
  */
 
 METHODDEF(void)
 cmyk_ycck_convert (j_compress_ptr cinfo,
            JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
            JDIMENSION output_row, int num_rows)
 {
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register INT32 * ctab = cconvert->rgb_ycc_tab;
   register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_ycc_tab;
   register JSAMPROW inptr;
   register JSAMPROW outptr0, outptr1, outptr2, outptr3;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
 
@@ -257,10 +257,11 @@
       r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
       g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
       b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
       /* K passes through as-is */
       outptr3[col] = inptr[3];    /* don't need GETJSAMPLE here */
+      inptr += 4;
       /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
        * must be too; we do not need an explicit range-limiting operation.
        * Hence the value being shifted is never negative, and we don't
        * need the general RIGHT_SHIFT macro.
        */
@@ -274,11 +275,10 @@
          >> SCALEBITS);
       /* Cr */
       outptr2[col] = (JSAMPLE)
         ((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
          >> SCALEBITS);
-      inptr += 4;
     }
   }
 }
 
 
@@ -310,17 +310,17 @@
     output_row++;
     for (col = 0; col < num_cols; col++) {
       r = GETJSAMPLE(inptr[RGB_RED]);
       g = GETJSAMPLE(inptr[RGB_GREEN]);
       b = GETJSAMPLE(inptr[RGB_BLUE]);
+      inptr += RGB_PIXELSIZE;
       /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD
        * (modulo) operator is equivalent to the bitmask operator AND.
        */
       outptr0[col] = (JSAMPLE) ((r - g + CENTERJSAMPLE) & MAXJSAMPLE);
       outptr1[col] = (JSAMPLE) g;
       outptr2[col] = (JSAMPLE) ((b - g + CENTERJSAMPLE) & MAXJSAMPLE);
-      inptr += RGB_PIXELSIZE;
     }
   }
 }
 
 
@@ -333,21 +333,21 @@
 METHODDEF(void)
 grayscale_convert (j_compress_ptr cinfo,
            JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
            JDIMENSION output_row, int num_rows)
 {
-  int instride = cinfo->input_components;
   register JSAMPROW inptr;
   register JSAMPROW outptr;
-  register JDIMENSION col;
+  register JDIMENSION count;
+  register int instride = cinfo->input_components;
   JDIMENSION num_cols = cinfo->image_width;
 
   while (--num_rows >= 0) {
     inptr = *input_buf++;
     outptr = output_buf[0][output_row++];
-    for (col = 0; col < num_cols; col++) {
-      outptr[col] = inptr[0];    /* don't need GETJSAMPLE() here */
+    for (count = num_cols; count > 0; count--) {
+      *outptr++ = *inptr;    /* don't need GETJSAMPLE() here */
       inptr += instride;
     }
   }
 }
 
@@ -394,25 +394,25 @@
 METHODDEF(void)
 null_convert (j_compress_ptr cinfo,
           JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
           JDIMENSION output_row, int num_rows)
 {
-  int ci;
-  register int nc = cinfo->num_components;
   register JSAMPROW inptr;
   register JSAMPROW outptr;
-  register JDIMENSION col;
+  register JDIMENSION count;
+  register int num_comps = cinfo->num_components;
   JDIMENSION num_cols = cinfo->image_width;
+  int ci;
 
   while (--num_rows >= 0) {
     /* It seems fastest to make a separate pass for each component. */
-    for (ci = 0; ci < nc; ci++) {
+    for (ci = 0; ci < num_comps; ci++) {
       inptr = input_buf[0] + ci;
       outptr = output_buf[ci][output_row];
-      for (col = 0; col < num_cols; col++) {
+      for (count = num_cols; count > 0; count--) {
     *outptr++ = *inptr;    /* don't need GETJSAMPLE() here */
-    inptr += nc;
+    inptr += num_comps;
       }
     }
     input_buf++;
     output_row++;
   }
@@ -437,13 +437,12 @@
 GLOBAL(void)
 jinit_color_converter (j_compress_ptr cinfo)
 {
   my_cconvert_ptr cconvert;
 
-  cconvert = (my_cconvert_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(my_color_converter));
+  cconvert = (my_cconvert_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_color_converter));
   cinfo->cconvert = &cconvert->pub;
   /* set start_pass to null method until we find out differently */
   cconvert->pub.start_pass = null_method;
 
   /* Make sure input_components agrees with in_color_space */
@@ -453,13 +452,15 @@
       ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     break;
 
   case JCS_RGB:
   case JCS_BG_RGB:
+#if RGB_PIXELSIZE != 3
     if (cinfo->input_components != RGB_PIXELSIZE)
       ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
     break;
+#endif /* else share code with YCbCr */
 
   case JCS_YCbCr:
   case JCS_BG_YCC:
     if (cinfo->input_components != 3)
       ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
@@ -472,11 +473,10 @@
     break;
 
   default:            /* JCS_UNKNOWN can be anything */
     if (cinfo->input_components < 1)
       ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
-    break;
   }
 
   /* Support color transform only for RGB colorspaces */
   if (cinfo->color_transform &&
       cinfo->jpeg_color_space != JCS_RGB &&
@@ -505,23 +505,22 @@
 
   case JCS_RGB:
   case JCS_BG_RGB:
     if (cinfo->num_components != 3)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
-    if (cinfo->in_color_space == cinfo->jpeg_color_space) {
-      switch (cinfo->color_transform) {
-      case JCT_NONE:
-    cconvert->pub.color_convert = rgb_convert;
-    break;
-      case JCT_SUBTRACT_GREEN:
-    cconvert->pub.color_convert = rgb_rgb1_convert;
-    break;
-      default:
-    ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
-      }
-    } else
+    if (cinfo->in_color_space != cinfo->jpeg_color_space)
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
+    switch (cinfo->color_transform) {
+    case JCT_NONE:
+      cconvert->pub.color_convert = rgb_convert;
+      break;
+    case JCT_SUBTRACT_GREEN:
+      cconvert->pub.color_convert = rgb_rgb1_convert;
+      break;
+    default:
+      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
+    }
     break;
 
   case JCS_YCbCr:
     if (cinfo->num_components != 3)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
@@ -570,14 +569,13 @@
     break;
 
   case JCS_CMYK:
     if (cinfo->num_components != 4)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
-    if (cinfo->in_color_space == JCS_CMYK)
-      cconvert->pub.color_convert = null_convert;
-    else
+    if (cinfo->in_color_space != JCS_CMYK)
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
+    cconvert->pub.color_convert = null_convert;
     break;
 
   case JCS_YCCK:
     if (cinfo->num_components != 4)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
@@ -597,8 +595,7 @@
   default:            /* allow null conversion of JCS_UNKNOWN */
     if (cinfo->jpeg_color_space != cinfo->in_color_space ||
     cinfo->num_components != cinfo->input_components)
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     cconvert->pub.color_convert = null_convert;
-    break;
   }
 }
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jchuff.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jchuff.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jchuff.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jchuff.c
@@ -1,10 +1,10 @@
 /*
  * jchuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2006-2013 by Guido Vollbeding.
+ * Modified 2006-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains Huffman entropy encoding routines.
  * Both sequential and progressive modes are supported in this single module.
@@ -178,17 +178,16 @@
   if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   htbl =
     isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   if (htbl == NULL)
-    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+    htbl = jpeg_std_huff_table((j_common_ptr) cinfo, isDC, tblno);
 
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl == NULL)
-    *pdtbl = (c_derived_tbl *)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  SIZEOF(c_derived_tbl));
+    *pdtbl = (c_derived_tbl *) (*cinfo->mem->alloc_small)
+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(c_derived_tbl));
   dtbl = *pdtbl;
 
   /* Figure C.1: make table of Huffman code length for each symbol */
 
   p = 0;
@@ -1258,27 +1257,93 @@
 {
 #define MAX_CLEN 32        /* assumed maximum initial code length */
   UINT8 bits[MAX_CLEN+1];    /* bits[k] = # of symbols with code length k */
   int codesize[257];        /* codesize[k] = code length of symbol k */
   int others[257];        /* next symbol in current branch of tree */
-  int c1, c2;
-  int p, i, j;
+  int c1, c2, i, j;
+  UINT8 *p;
   long v;
 
+  freq[256] = 1;        /* make sure 256 has a nonzero count */
+  /* Including the pseudo-symbol 256 in the Huffman procedure guarantees
+   * that no real symbol is given code-value of all ones, because 256
+   * will be placed last in the largest codeword category.
+   * In the symbol list build procedure this element serves as sentinel
+   * for the zero run loop.
+   */
+
+#ifndef DONT_USE_FANCY_HUFF_OPT
+
+  /* Build list of symbols sorted in order of descending frequency */
+  /* This approach has several benefits (thank to John Korejwa for the idea):
+   *     1.
+   * If a codelength category is split during the length limiting procedure
+   * below, the feature that more frequent symbols are assigned shorter
+   * codewords remains valid for the adjusted code.
+   *     2.
+   * To reduce consecutive ones in a Huffman data stream (thus reducing the
+   * number of stuff bytes in JPEG) it is preferable to follow 0 branches
+   * (and avoid 1 branches) as much as possible.  This is easily done by
+   * assigning symbols to leaves of the Huffman tree in order of decreasing
+   * frequency, with no secondary sort based on codelengths.
+   *     3.
+   * The symbol list can be built independently from the assignment of code
+   * lengths by the Huffman procedure below.
+   * Note: The symbol list build procedure must be performed first, because
+   * the Huffman procedure assigning the codelengths clobbers the frequency
+   * counts!
+   */
+
+  /* Here we use the others array as a linked list of nonzero frequencies
+   * to be sorted.  Already sorted elements are removed from the list.
+   */
+
+  /* Building list */
+
+  /* This item does not correspond to a valid symbol frequency and is used
+   * as starting index.
+   */
+  j = 256;
+
+  for (i = 0;; i++) {
+    if (freq[i] == 0)        /* skip zero frequencies */
+      continue;
+    if (i > 255)
+      break;
+    others[j] = i;        /* this symbol value */
+    j = i;            /* previous symbol value */
+  }
+  others[j] = -1;        /* mark end of list */
+
+  /* Sorting list */
+
+  p = htbl->huffval;
+  while ((c1 = others[256]) >= 0) {
+    v = freq[c1];
+    i = c1;            /* first symbol value */
+    j = 256;            /* pseudo symbol value for starting index */
+    while ((c2 = others[c1]) >= 0) {
+      if (freq[c2] > v) {
+    v = freq[c2];
+    i = c2;            /* this symbol value */
+    j = c1;            /* previous symbol value */
+      }
+      c1 = c2;
+    }
+    others[j] = others[i];    /* remove this symbol i from list */
+    *p++ = (UINT8) i;
+  }
+
+#endif /* DONT_USE_FANCY_HUFF_OPT */
+
   /* This algorithm is explained in section K.2 of the JPEG standard */
 
   MEMZERO(bits, SIZEOF(bits));
   MEMZERO(codesize, SIZEOF(codesize));
   for (i = 0; i < 257; i++)
     others[i] = -1;        /* init links to empty */
 
-  freq[256] = 1;        /* make sure 256 has a nonzero count */
-  /* Including the pseudo-symbol 256 in the Huffman procedure guarantees
-   * that no real symbol is given code-value of all ones, because 256
-   * will be placed last in the largest codeword category.
-   */
-
   /* Huffman's basic algorithm to assign optimal code lengths to symbols */
 
   for (;;) {
     /* Find the smallest nonzero frequency, set c1 = its symbol */
     /* In case of ties, take the larger symbol number */
@@ -1331,11 +1396,11 @@
   for (i = 0; i <= 256; i++) {
     if (codesize[i]) {
       /* The JPEG standard seems to think that this can't happen, */
       /* but I'm paranoid... */
       if (codesize[i] > MAX_CLEN)
-    ERREXIT(cinfo, JERR_HUFF_CLEN_OVERFLOW);
+    ERREXIT(cinfo, JERR_HUFF_CLEN_OUTOFBOUNDS);
 
       bits[codesize[i]]++;
     }
   }
 
@@ -1351,12 +1416,15 @@
    */
 
   for (i = MAX_CLEN; i > 16; i--) {
     while (bits[i] > 0) {
       j = i - 2;        /* find length of new prefix to be used */
-      while (bits[j] == 0)
+      while (bits[j] == 0) {
+    if (j == 0)
+      ERREXIT(cinfo, JERR_HUFF_CLEN_OUTOFBOUNDS);
     j--;
+      }
 
       bits[i] -= 2;        /* remove two symbols */
       bits[i-1]++;        /* one goes in this length */
       bits[j+1] += 2;        /* two new symbols in this length */
       bits[j]--;        /* symbol of this length is now a prefix */
@@ -1369,24 +1437,27 @@
   bits[i]--;
 
   /* Return final symbol counts (only for lengths 0..16) */
   MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
 
+#ifdef DONT_USE_FANCY_HUFF_OPT
+
   /* Return a list of the symbols sorted by code length */
-  /* It's not real clear to me why we don't need to consider the codelength
-   * changes made above, but the JPEG spec seems to think this works.
+  /* Note: Due to the codelength changes made above, it can happen
+   * that more frequent symbols are assigned longer codewords.
    */
-  p = 0;
+  p = htbl->huffval;
   for (i = 1; i <= MAX_CLEN; i++) {
     for (j = 0; j <= 255; j++) {
       if (codesize[j] == i) {
-    htbl->huffval[p] = (UINT8) j;
-    p++;
+    *p++ = (UINT8) j;
       }
     }
   }
 
+#endif /* DONT_USE_FANCY_HUFF_OPT */
+
   /* Set sent_table FALSE so updated table will be written to JPEG file. */
   htbl->sent_table = FALSE;
 }
 
 
@@ -1402,17 +1473,17 @@
   jpeg_component_info * compptr;
   JHUFF_TBL **htblptr;
   boolean did_dc[NUM_HUFF_TBLS];
   boolean did_ac[NUM_HUFF_TBLS];
 
-  /* It's important not to apply jpeg_gen_optimal_table more than once
-   * per table, because it clobbers the input frequency counts!
-   */
   if (cinfo->progressive_mode)
     /* Flush out buffered data (all we care about is counting the EOB symbol) */
     emit_eobrun(entropy);
 
+  /* It's important not to apply jpeg_gen_optimal_table more than once
+   * per table, because it clobbers the input frequency counts!
+   */
   MEMZERO(did_dc, SIZEOF(did_dc));
   MEMZERO(did_ac, SIZEOF(did_ac));
 
   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
     compptr = cinfo->cur_comp_info[ci];
@@ -1477,13 +1548,12 @@
     entropy->pub.encode_mcu = encode_mcu_DC_refine;
       else {
     entropy->pub.encode_mcu = encode_mcu_AC_refine;
     /* AC refinement needs a correction bit buffer */
     if (entropy->bit_buffer == NULL)
-      entropy->bit_buffer = (char *)
-        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                    MAX_CORR_BITS * SIZEOF(char));
+      entropy->bit_buffer = (char *) (*cinfo->mem->alloc_small)
+        ((j_common_ptr) cinfo, JPOOL_IMAGE, MAX_CORR_BITS * SIZEOF(char));
       }
     }
 
     /* Initialize AC stuff */
     entropy->ac_tbl_no = cinfo->cur_comp_info[0]->ac_tbl_no;
@@ -1507,13 +1577,12 @@
     if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
     /* Allocate and zero the statistics tables */
     /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
     if (entropy->dc_count_ptrs[tbl] == NULL)
-      entropy->dc_count_ptrs[tbl] = (long *)
-        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                    257 * SIZEOF(long));
+      entropy->dc_count_ptrs[tbl] = (long *) (*cinfo->mem->alloc_small)
+        ((j_common_ptr) cinfo, JPOOL_IMAGE, 257 * SIZEOF(long));
     MEMZERO(entropy->dc_count_ptrs[tbl], 257 * SIZEOF(long));
       } else {
     /* Compute derived values for Huffman tables */
     /* We may do this more than once for a table, but it's not expensive */
     jpeg_make_c_derived_tbl(cinfo, TRUE, tbl,
@@ -1527,13 +1596,12 @@
       tbl = compptr->ac_tbl_no;
       if (gather_statistics) {
     if (tbl < 0 || tbl >= NUM_HUFF_TBLS)
       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
     if (entropy->ac_count_ptrs[tbl] == NULL)
-      entropy->ac_count_ptrs[tbl] = (long *)
-        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                    257 * SIZEOF(long));
+      entropy->ac_count_ptrs[tbl] = (long *) (*cinfo->mem->alloc_small)
+        ((j_common_ptr) cinfo, JPOOL_IMAGE, 257 * SIZEOF(long));
     MEMZERO(entropy->ac_count_ptrs[tbl], 257 * SIZEOF(long));
       } else {
     jpeg_make_c_derived_tbl(cinfo, FALSE, tbl,
                 & entropy->ac_derived_tbls[tbl]);
       }
@@ -1558,13 +1626,12 @@
 jinit_huff_encoder (j_compress_ptr cinfo)
 {
   huff_entropy_ptr entropy;
   int i;
 
-  entropy = (huff_entropy_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(huff_entropy_encoder));
+  entropy = (huff_entropy_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(huff_entropy_encoder));
   cinfo->entropy = &entropy->pub;
   entropy->pub.start_pass = start_pass_huff;
 
   /* Mark tables unallocated */
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcinit.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcinit.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcinit.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcinit.c
@@ -223,13 +223,13 @@
     jinit_c_prep_controller(cinfo, FALSE /* never need full buffer here */);
   }
   /* Forward DCT */
   jinit_forward_dct(cinfo);
   /* Entropy encoding: either Huffman or arithmetic coding. */
-  if (cinfo->arith_code)
+  if (cinfo->arith_code) {
     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
-  else {
+  } else {
     jinit_huff_encoder(cinfo);
   }
 
   /* Need a full-image coefficient buffer in any multi-pass mode. */
   jinit_c_coef_controller(cinfo,
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmarker.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmarker.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmarker.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmarker.c
@@ -1,10 +1,10 @@
 /*
  * jcmarker.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
- * Modified 2003-2013 by Guido Vollbeding.
+ * Modified 2003-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains routines to write JPEG datastream markers.
  */
@@ -469,11 +469,10 @@
   case JCS_YCCK:
     emit_byte(cinfo, 2);    /* Color transform = 2 */
     break;
   default:
     emit_byte(cinfo, 0);    /* Color transform = 0 */
-    break;
   }
 }
 
 
 /*
@@ -700,13 +699,12 @@
 jinit_marker_writer (j_compress_ptr cinfo)
 {
   my_marker_ptr marker;
 
   /* Create the subobject */
-  marker = (my_marker_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(my_marker_writer));
+  marker = (my_marker_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_marker_writer));
   cinfo->marker = &marker->pub;
   /* Initialize method pointers */
   marker->pub.write_file_header = write_file_header;
   marker->pub.write_frame_header = write_frame_header;
   marker->pub.write_scan_header = write_scan_header;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c
@@ -1,10 +1,10 @@
 /*
  * jcmaster.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2003-2017 by Guido Vollbeding.
+ * Modified 2003-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains master control logic for the JPEG compressor.
  * These routines are concerned with parameter validation, initial setup,
@@ -60,11 +60,11 @@
   case 3: cinfo->natural_order = jpeg_natural_order3; break;
   case 4: cinfo->natural_order = jpeg_natural_order4; break;
   case 5: cinfo->natural_order = jpeg_natural_order5; break;
   case 6: cinfo->natural_order = jpeg_natural_order6; break;
   case 7: cinfo->natural_order = jpeg_natural_order7; break;
-  default: cinfo->natural_order = jpeg_natural_order; break;
+  default: cinfo->natural_order = jpeg_natural_order;
   }
 
   /* Derive lim_Se from block_size */
   cinfo->lim_Se = cinfo->block_size < DCTSIZE ?
     cinfo->block_size * cinfo->block_size - 1 : DCTSIZE2-1;
@@ -112,24 +112,28 @@
      * This saves time if the downsampler gets to use 1:1 scaling.
      * Note this code adapts subsampling ratios which are powers of 2.
      */
     ssize = 1;
 #ifdef DCT_SCALING_SUPPORTED
-    while (cinfo->min_DCT_h_scaled_size * ssize <=
-       (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
-       (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
-      ssize = ssize * 2;
-    }
+    if (! cinfo->raw_data_in)
+      while (cinfo->min_DCT_h_scaled_size * ssize <=
+         (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
+         (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) ==
+         0) {
+    ssize = ssize * 2;
+      }
 #endif
     compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;
     ssize = 1;
 #ifdef DCT_SCALING_SUPPORTED
-    while (cinfo->min_DCT_v_scaled_size * ssize <=
-       (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
-       (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
-      ssize = ssize * 2;
-    }
+    if (! cinfo->raw_data_in)
+      while (cinfo->min_DCT_v_scaled_size * ssize <=
+         (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
+         (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) ==
+         0) {
+    ssize = ssize * 2;
+      }
 #endif
     compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;
 
     /* We don't support DCT ratios larger than 2. */
     if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)
@@ -621,13 +625,12 @@
 GLOBAL(void)
 jinit_c_master_control (j_compress_ptr cinfo, boolean transcode_only)
 {
   my_master_ptr master;
 
-  master = (my_master_ptr)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  SIZEOF(my_comp_master));
+  master = (my_master_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_comp_master));
   cinfo->master = &master->pub;
   master->pub.prepare_for_pass = prepare_for_pass;
   master->pub.pass_startup = pass_startup;
   master->pub.finish_pass = finish_pass_master;
   master->pub.is_last_pass = FALSE;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcomapi.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcomapi.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcomapi.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcomapi.c
@@ -1,9 +1,10 @@
 /*
  * jcomapi.c
  *
  * Copyright (C) 1994-1997, Thomas G. Lane.
+ * Modified 2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains application interface routines that are used for both
  * compression and decompression.
@@ -102,5 +103,142 @@
   tbl = (JHUFF_TBL *)
     (*cinfo->mem->alloc_small) (cinfo, JPOOL_PERMANENT, SIZEOF(JHUFF_TBL));
   tbl->sent_table = FALSE;    /* make sure this is false in any new table */
   return tbl;
 }
+
+
+/*
+ * Set up the standard Huffman tables (cf. JPEG standard section K.3).
+ * IMPORTANT: these are only valid for 8-bit data precision!
+ * (Would jutils.c be a more reasonable place to put this?)
+ */
+
+GLOBAL(JHUFF_TBL *)
+jpeg_std_huff_table (j_common_ptr cinfo, boolean isDC, int tblno)
+{
+  JHUFF_TBL **htblptr, *htbl;
+  const UINT8 *bits, *val;
+  int nsymbols, len;
+
+  static const UINT8 bits_dc_luminance[17] =
+    { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
+  static const UINT8 val_dc_luminance[] =
+    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
+
+  static const UINT8 bits_dc_chrominance[17] =
+    { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
+  static const UINT8 val_dc_chrominance[] =
+    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
+
+  static const UINT8 bits_ac_luminance[17] =
+    { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
+  static const UINT8 val_ac_luminance[] =
+    { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
+      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
+      0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
+      0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
+      0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
+      0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
+      0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
+      0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
+      0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
+      0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+      0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+      0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
+      0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
+      0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
+      0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
+      0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
+      0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
+      0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
+      0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
+      0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
+      0xf9, 0xfa };
+
+  static const UINT8 bits_ac_chrominance[17] =
+    { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
+  static const UINT8 val_ac_chrominance[] =
+    { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
+      0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
+      0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
+      0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
+      0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
+      0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
+      0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
+      0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
+      0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
+      0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+      0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
+      0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
+      0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
+      0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
+      0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
+      0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
+      0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
+      0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
+      0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
+      0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
+      0xf9, 0xfa };
+
+  if (cinfo->is_decompressor) {
+    if (isDC)
+      htblptr = ((j_decompress_ptr) cinfo)->dc_huff_tbl_ptrs;
+    else
+      htblptr = ((j_decompress_ptr) cinfo)->ac_huff_tbl_ptrs;
+  } else {
+    if (isDC)
+      htblptr = ((j_compress_ptr) cinfo)->dc_huff_tbl_ptrs;
+    else
+      htblptr = ((j_compress_ptr) cinfo)->ac_huff_tbl_ptrs;
+  }
+
+  switch (tblno) {
+  case 0:
+    if (isDC) {
+      bits = bits_dc_luminance;
+      val = val_dc_luminance;
+    } else {
+      bits = bits_ac_luminance;
+      val = val_ac_luminance;
+    }
+    break;
+  case 1:
+    if (isDC) {
+      bits = bits_dc_chrominance;
+      val = val_dc_chrominance;
+    } else {
+      bits = bits_ac_chrominance;
+      val = val_ac_chrominance;
+    }
+    break;
+  default:
+    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+    return NULL; /* avoid compiler warnings for uninitialized variables */
+  }
+
+  if (htblptr[tblno] == NULL)
+    htblptr[tblno] = jpeg_alloc_huff_table(cinfo);
+
+  htbl = htblptr[tblno];
+
+  /* Copy the number-of-symbols-of-each-code-length counts */
+  MEMCOPY(htbl->bits, bits, SIZEOF(htbl->bits));
+
+  /* Validate the counts.  We do this here mainly so we can copy the right
+   * number of symbols from the val[] array, without risking marching off
+   * the end of memory.  jxhuff.c will do a more thorough test later.
+   */
+  nsymbols = 0;
+  for (len = 1; len <= 16; len++)
+    nsymbols += bits[len];
+  if (nsymbols > 256)
+    ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+
+  if (nsymbols > 0)
+    MEMCOPY(htbl->huffval, val, nsymbols * SIZEOF(UINT8));
+
+  /* Initialize sent_table FALSE so table will be written to JPEG file. */
+  htbl->sent_table = FALSE;
+
+  return htbl;
+}
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcparam.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcparam.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcparam.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcparam.c
@@ -1,10 +1,10 @@
 /*
  * jcparam.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
- * Modified 2003-2013 by Guido Vollbeding.
+ * Modified 2003-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains optional default-setting code for the JPEG compressor.
  * Applications do not have to use this file, but those that don't use it
@@ -160,116 +160,27 @@
   jpeg_set_linear_quality(cinfo, quality, force_baseline);
 }
 
 
 /*
- * Huffman table setup routines
+ * Reset standard Huffman tables
  */
 
 LOCAL(void)
-add_huff_table (j_compress_ptr cinfo,
-        JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
-/* Define a Huffman table */
+std_huff_tables (j_compress_ptr cinfo)
 {
-  int nsymbols, len;
-
-  if (*htblptr == NULL)
-    *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
-
-  /* Copy the number-of-symbols-of-each-code-length counts */
-  MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
+  if (cinfo->dc_huff_tbl_ptrs[0] != NULL)
+    (void) jpeg_std_huff_table((j_common_ptr) cinfo, TRUE, 0);
 
-  /* Validate the counts.  We do this here mainly so we can copy the right
-   * number of symbols from the val[] array, without risking marching off
-   * the end of memory.  jchuff.c will do a more thorough test later.
-   */
-  nsymbols = 0;
-  for (len = 1; len <= 16; len++)
-    nsymbols += bits[len];
-  if (nsymbols < 1 || nsymbols > 256)
-    ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
+  if (cinfo->ac_huff_tbl_ptrs[0] != NULL)
+    (void) jpeg_std_huff_table((j_common_ptr) cinfo, FALSE, 0);
 
-  MEMCOPY((*htblptr)->huffval, val, nsymbols * SIZEOF(UINT8));
+  if (cinfo->dc_huff_tbl_ptrs[1] != NULL)
+    (void) jpeg_std_huff_table((j_common_ptr) cinfo, TRUE, 1);
 
-  /* Initialize sent_table FALSE so table will be written to JPEG file. */
-  (*htblptr)->sent_table = FALSE;
-}
-
-
-LOCAL(void)
-std_huff_tables (j_compress_ptr cinfo)
-/* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
-/* IMPORTANT: these are only valid for 8-bit data precision! */
-{
-  static const UINT8 bits_dc_luminance[17] =
-    { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
-  static const UINT8 val_dc_luminance[] =
-    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
-
-  static const UINT8 bits_dc_chrominance[17] =
-    { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
-  static const UINT8 val_dc_chrominance[] =
-    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
-
-  static const UINT8 bits_ac_luminance[17] =
-    { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
-  static const UINT8 val_ac_luminance[] =
-    { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
-      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
-      0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
-      0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
-      0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
-      0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
-      0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
-      0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
-      0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
-      0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
-      0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
-      0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
-      0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
-      0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
-      0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
-      0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
-      0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
-      0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
-      0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
-      0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
-      0xf9, 0xfa };
-
-  static const UINT8 bits_ac_chrominance[17] =
-    { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
-  static const UINT8 val_ac_chrominance[] =
-    { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
-      0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
-      0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
-      0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
-      0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
-      0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
-      0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
-      0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
-      0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
-      0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
-      0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
-      0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
-      0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
-      0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
-      0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
-      0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
-      0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
-      0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
-      0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
-      0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
-      0xf9, 0xfa };
-
-  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[0],
-         bits_dc_luminance, val_dc_luminance);
-  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[0],
-         bits_ac_luminance, val_ac_luminance);
-  add_huff_table(cinfo, &cinfo->dc_huff_tbl_ptrs[1],
-         bits_dc_chrominance, val_dc_chrominance);
-  add_huff_table(cinfo, &cinfo->ac_huff_tbl_ptrs[1],
-         bits_ac_chrominance, val_ac_chrominance);
+  if (cinfo->ac_huff_tbl_ptrs[1] != NULL)
+    (void) jpeg_std_huff_table((j_common_ptr) cinfo, FALSE, 1);
 }
 
 
 /*
  * Default parameter setup for compression.
@@ -304,11 +215,11 @@
   cinfo->scale_num = 1;        /* 1:1 scaling */
   cinfo->scale_denom = 1;
   cinfo->data_precision = BITS_IN_JSAMPLE;
   /* Set up two quantization tables using default quality of 75 */
   jpeg_set_quality(cinfo, 75, TRUE);
-  /* Set up two Huffman tables */
+  /* Reset standard Huffman tables */
   std_huff_tables(cinfo);
 
   /* Initialize default arithmetic coding conditioning */
   for (i = 0; i < NUM_ARITH_TBLS; i++) {
     cinfo->arith_dc_L[i] = 0;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c
@@ -1,10 +1,10 @@
 /*
  * jdcolor.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2011-2017 by Guido Vollbeding.
+ * Modified 2011-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains output colorspace conversion routines.
  */
@@ -122,32 +122,26 @@
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   int i;
   INT32 x;
   SHIFT_TEMPS
 
-  cconvert->Cr_r_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  cconvert->Cb_b_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  cconvert->Cr_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
-  cconvert->Cb_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
+  cconvert->Cr_r_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  cconvert->Cb_b_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  cconvert->Cr_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
+  cconvert->Cb_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
 
   for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     /* Cr=>R value is nearest int to 1.402 * x */
-    cconvert->Cr_r_tab[i] = (int)
-            RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);
+    cconvert->Cr_r_tab[i] = (int) DESCALE(FIX(1.402) * x, SCALEBITS);
     /* Cb=>B value is nearest int to 1.772 * x */
-    cconvert->Cb_b_tab[i] = (int)
-            RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);
+    cconvert->Cb_b_tab[i] = (int) DESCALE(FIX(1.772) * x, SCALEBITS);
     /* Cr=>G value is scaled-up -0.714136286 * x */
     cconvert->Cr_g_tab[i] = (- FIX(0.714136286)) * x;
     /* Cb=>G value is scaled-up -0.344136286 * x */
     /* We also add in ONE_HALF so that need not do it in inner loop */
     cconvert->Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
@@ -162,32 +156,26 @@
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   int i;
   INT32 x;
   SHIFT_TEMPS
 
-  cconvert->Cr_r_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  cconvert->Cb_b_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  cconvert->Cr_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
-  cconvert->Cb_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
+  cconvert->Cr_r_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  cconvert->Cb_b_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  cconvert->Cr_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
+  cconvert->Cb_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
 
   for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     /* Cr=>R value is nearest int to 2.804 * x */
-    cconvert->Cr_r_tab[i] = (int)
-            RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);
+    cconvert->Cr_r_tab[i] = (int) DESCALE(FIX(2.804) * x, SCALEBITS);
     /* Cb=>B value is nearest int to 3.544 * x */
-    cconvert->Cb_b_tab[i] = (int)
-            RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);
+    cconvert->Cb_b_tab[i] = (int) DESCALE(FIX(3.544) * x, SCALEBITS);
     /* Cr=>G value is scaled-up -1.428272572 * x */
     cconvert->Cr_g_tab[i] = (- FIX(1.428272572)) * x;
     /* Cb=>G value is scaled-up -0.688272572 * x */
     /* We also add in ONE_HALF so that need not do it in inner loop */
     cconvert->Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
@@ -199,10 +187,11 @@
  * Convert some rows of samples to the output colorspace.
  *
  * Note that we change from noninterleaved, one-plane-per-component format
  * to interleaved-pixel format.  The output buffer is therefore three times
  * as wide as the input buffer.
+ *
  * A starting row offset is provided only for the input buffer.  The caller
  * can easily adjust the passed output_buf value to accommodate any row
  * offset required on that side.
  */
 
@@ -262,13 +251,12 @@
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
   INT32 * rgb_y_tab;
   INT32 i;
 
   /* Allocate and fill in the conversion tables. */
-  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (TABLE_SIZE * SIZEOF(INT32)));
+  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, TABLE_SIZE * SIZEOF(INT32));
 
   for (i = 0; i <= MAXJSAMPLE; i++) {
     rgb_y_tab[i+R_Y_OFF] = FIX(0.299) * i;
     rgb_y_tab[i+G_Y_OFF] = FIX(0.587) * i;
     rgb_y_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;
@@ -284,12 +272,12 @@
 rgb_gray_convert (j_decompress_ptr cinfo,
           JSAMPIMAGE input_buf, JDIMENSION input_row,
           JSAMPARRAY output_buf, int num_rows)
 {
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register INT32 * ctab = cconvert->rgb_y_tab;
   register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_y_tab;
   register JSAMPROW outptr;
   register JSAMPROW inptr0, inptr1, inptr2;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->output_width;
 
@@ -311,10 +299,11 @@
   }
 }
 
 
 /*
+ * Convert some rows of samples to the output colorspace.
  * [R-G,G,B-G] to [R,G,B] conversion with modulo calculation
  * (inverse color transform).
  * This can be seen as an adaption of the general YCbCr->RGB
  * conversion equation with Kr = Kb = 0, while replacing the
  * normalization by modulo calculation.
@@ -362,12 +351,12 @@
 rgb1_gray_convert (j_decompress_ptr cinfo,
            JSAMPIMAGE input_buf, JDIMENSION input_row,
            JSAMPARRAY output_buf, int num_rows)
 {
   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
-  register INT32 * ctab = cconvert->rgb_y_tab;
   register int r, g, b;
+  register INT32 * ctab = cconvert->rgb_y_tab;
   register JSAMPROW outptr;
   register JSAMPROW inptr0, inptr1, inptr2;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->output_width;
 
@@ -394,10 +383,11 @@
   }
 }
 
 
 /*
+ * Convert some rows of samples to the output colorspace.
  * No colorspace change, but conversion from separate-planes
  * to interleaved representation.
  */
 
 METHODDEF(void)
@@ -428,31 +418,33 @@
 
 
 /*
  * Color conversion for no colorspace change: just copy the data,
  * converting from separate-planes to interleaved representation.
+ * We assume out_color_components == num_components.
  */
 
 METHODDEF(void)
 null_convert (j_decompress_ptr cinfo,
           JSAMPIMAGE input_buf, JDIMENSION input_row,
           JSAMPARRAY output_buf, int num_rows)
 {
-  int ci;
-  register int nc = cinfo->num_components;
   register JSAMPROW outptr;
   register JSAMPROW inptr;
-  register JDIMENSION col;
+  register JDIMENSION count;
+  register int num_comps = cinfo->num_components;
   JDIMENSION num_cols = cinfo->output_width;
+  int ci;
 
   while (--num_rows >= 0) {
-    for (ci = 0; ci < nc; ci++) {
+    /* It seems fastest to make a separate pass for each component. */
+    for (ci = 0; ci < num_comps; ci++) {
       inptr = input_buf[ci][input_row];
       outptr = output_buf[0] + ci;
-      for (col = 0; col < num_cols; col++) {
-    *outptr = *inptr++;    /* needn't bother with GETJSAMPLE() here */
-    outptr += nc;
+      for (count = num_cols; count > 0; count--) {
+    *outptr = *inptr++;    /* don't need GETJSAMPLE() here */
+    outptr += num_comps;
       }
     }
     input_row++;
     output_buf++;
   }
@@ -614,13 +606,14 @@
   }
 }
 
 
 /*
- * Adobe-style YCCK->CMYK conversion.
- * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
- * conversion as above, while passing K (black) unchanged.
+ * Convert some rows of samples to the output colorspace.
+ * This version handles Adobe-style YCCK->CMYK conversion,
+ * where we convert YCbCr to R=1-C, G=1-M, and B=1-Y using the
+ * same conversion as above, while passing K (black) unchanged.
  * We assume build_ycc_rgb_table has been called.
  */
 
 METHODDEF(void)
 ycck_cmyk_convert (j_decompress_ptr cinfo,
@@ -687,13 +680,12 @@
 jinit_color_deconverter (j_decompress_ptr cinfo)
 {
   my_cconvert_ptr cconvert;
   int ci;
 
-  cconvert = (my_cconvert_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(my_color_deconverter));
+  cconvert = (my_cconvert_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_color_deconverter));
   cinfo->cconvert = &cconvert->pub;
   cconvert->pub.start_pass = start_pass_dcolor;
 
   /* Make sure num_components agrees with jpeg_color_space */
   switch (cinfo->jpeg_color_space) {
@@ -717,11 +709,10 @@
     break;
 
   default:            /* JCS_UNKNOWN can be anything */
     if (cinfo->num_components < 1)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
-    break;
   }
 
   /* Support color transform only for RGB colorspaces */
   if (cinfo->color_transform &&
       cinfo->jpeg_color_space != JCS_RGB &&
@@ -778,17 +769,17 @@
       build_bg_ycc_rgb_table(cinfo);
       break;
     case JCS_RGB:
       switch (cinfo->color_transform) {
       case JCT_NONE:
-        cconvert->pub.color_convert = rgb_convert;
-        break;
+    cconvert->pub.color_convert = rgb_convert;
+    break;
       case JCT_SUBTRACT_GREEN:
-        cconvert->pub.color_convert = rgb1_rgb_convert;
-        break;
+    cconvert->pub.color_convert = rgb1_rgb_convert;
+    break;
       default:
-        ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
+    ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
       }
       break;
     case JCS_YCCK:
       cconvert->pub.color_convert = ycck_rgb_convert;
       build_ycc_rgb_table(cinfo);
@@ -801,23 +792,22 @@
     }
     break;
 
   case JCS_BG_RGB:
     cinfo->out_color_components = RGB_PIXELSIZE;
-    if (cinfo->jpeg_color_space == JCS_BG_RGB) {
-      switch (cinfo->color_transform) {
-      case JCT_NONE:
-    cconvert->pub.color_convert = rgb_convert;
-    break;
-      case JCT_SUBTRACT_GREEN:
-    cconvert->pub.color_convert = rgb1_rgb_convert;
-    break;
-      default:
-    ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
-      }
-    } else
+    if (cinfo->jpeg_color_space != JCS_BG_RGB)
+      ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
+    switch (cinfo->color_transform) {
+    case JCT_NONE:
+      cconvert->pub.color_convert = rgb_convert;
+      break;
+    case JCT_SUBTRACT_GREEN:
+      cconvert->pub.color_convert = rgb1_rgb_convert;
+      break;
+    default:
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
+    }
     break;
 
   case JCS_CMYK:
     cinfo->out_color_components = 4;
     switch (cinfo->jpeg_color_space) {
@@ -831,18 +821,16 @@
     default:
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     }
     break;
 
-  default:
-    /* Permit null conversion to same output space */
-    if (cinfo->out_color_space == cinfo->jpeg_color_space) {
-      cinfo->out_color_components = cinfo->num_components;
-      cconvert->pub.color_convert = null_convert;
-    } else            /* unsupported non-null conversion */
+  default:        /* permit null conversion to same output space */
+    if (cinfo->out_color_space != cinfo->jpeg_color_space)
+      /* unsupported non-null conversion */
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
-    break;
+    cinfo->out_color_components = cinfo->num_components;
+    cconvert->pub.color_convert = null_convert;
   }
 
   if (cinfo->quantize_colors)
     cinfo->output_components = 1; /* single colormapped output component */
   else
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdct.h b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdct.h
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdct.h
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdct.h
@@ -1,10 +1,10 @@
 /*
  * jdct.h
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
- * Modified 2002-2017 by Guido Vollbeding.
+ * Modified 2002-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This include file contains common declarations for the forward and
  * inverse DCT modules.  These declarations are private to the DCT managers
@@ -356,17 +356,10 @@
  * thus causing a lot of useless floating-point operations at run time.
  */
 
 #define FIX(x)    ((INT32) ((x) * CONST_SCALE + 0.5))
 
-/* Descale and correctly round an INT32 value that's scaled by N bits.
- * We assume RIGHT_SHIFT rounds towards minus infinity, so adding
- * the fudge factor is correct for either sign of X.
- */
-
-#define DESCALE(x,n)  RIGHT_SHIFT((x) + (ONE << ((n)-1)), n)
-
 /* Multiply an INT32 variable by an INT32 constant to yield an INT32 result.
  * This macro is used only when the two inputs will actually be no more than
  * 16 bits wide, so that a 16x16->32 bit multiply can be used instead of a
  * full 32x32 multiply.  This provides a useful speedup on many machines.
  * Unfortunately there is no way to specify a 16x16->32 multiply portably
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c
@@ -1,10 +1,10 @@
 /*
  * jdhuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2006-2016 by Guido Vollbeding.
+ * Modified 2006-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains Huffman entropy decoding routines.
  * Both sequential and progressive modes are supported in this single module.
@@ -341,17 +341,16 @@
   if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   htbl =
     isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   if (htbl == NULL)
-    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+    htbl = jpeg_std_huff_table((j_common_ptr) cinfo, isDC, tblno);
 
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl == NULL)
-    *pdtbl = (d_derived_tbl *)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  SIZEOF(d_derived_tbl));
+    *pdtbl = (d_derived_tbl *) (*cinfo->mem->alloc_small)
+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(d_derived_tbl));
   dtbl = *pdtbl;
   dtbl->pub = htbl;        /* fill in back link */
 
   /* Figure C.1: make table of Huffman code length for each symbol */
 
@@ -732,11 +731,11 @@
    * This way, we return uniform gray for the remainder of the segment.
    */
   if (! entropy->insufficient_data) {
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(state, entropy->saved);
 
     /* Outer loop handles each block in the MCU */
 
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
@@ -761,16 +760,17 @@
       /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
       (*block)[0] = (JCOEF) (s << Al);
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(entropy->saved, state);
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -811,11 +811,11 @@
     /* There is always only one block per MCU */
 
     if (EOBRUN)            /* if it's a band of zeroes... */
       EOBRUN--;            /* ...process it now (we do nothing) */
     else {
-      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+      BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
       Se = cinfo->Se;
       Al = cinfo->Al;
       natural_order = cinfo->natural_order;
       block = MCU_data[0];
       tbl = entropy->ac_derived_tbl;
@@ -844,19 +844,20 @@
       }
       k += 15;        /* ZRL: skip 15 zeroes in band */
     }
       }
 
-      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+      BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     }
 
     /* Completed MCU, so update state */
     entropy->saved.EOBRUN = EOBRUN;    /* only part of saved state we need */
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -868,11 +869,12 @@
 
 METHODDEF(boolean)
 decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-  int p1, blkn;
+  JCOEF p1;
+  int blkn;
   BITREAD_STATE_VARS;
 
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
@@ -883,11 +885,11 @@
   /* Not worth the cycles to check insufficient_data here,
    * since we will not change the data anyway if we read zeroes.
    */
 
   /* Load up working state */
-  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
 
   p1 = 1 << cinfo->Al;        /* 1 in the bit position being coded */
 
   /* Outer loop handles each block in the MCU */
 
@@ -898,14 +900,15 @@
       MCU_data[blkn][0][0] |= p1;
     /* Note: since we use |=, repeating the assignment later is safe */
   }
 
   /* Completed MCU, so update state */
-  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -917,11 +920,12 @@
 decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   register int s, k, r;
   unsigned int EOBRUN;
-  int Se, p1, m1;
+  int Se;
+  JCOEF p1, m1;
   const int * natural_order;
   JBLOCKROW block;
   JCOEFPTR thiscoef;
   BITREAD_STATE_VARS;
   d_derived_tbl * tbl;
@@ -939,15 +943,15 @@
    */
   if (! entropy->insufficient_data) {
 
     Se = cinfo->Se;
     p1 = 1 << cinfo->Al;    /* 1 in the bit position being coded */
-    m1 = (-1) << cinfo->Al;    /* -1 in the bit position being coded */
+    m1 = -p1;            /* -1 in the bit position being coded */
     natural_order = cinfo->natural_order;
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
 
     /* There is always only one block per MCU */
     block = MCU_data[0];
     tbl = entropy->ac_derived_tbl;
@@ -1045,16 +1049,17 @@
       /* Count one block completed in EOB run */
       EOBRUN--;
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 
 undoit:
   /* Re-zero any output coefficients that we made newly nonzero */
@@ -1093,11 +1098,11 @@
 
     natural_order = cinfo->natural_order;
     Se = cinfo->lim_Se;
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(state, entropy->saved);
 
     /* Outer loop handles each block in the MCU */
 
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
@@ -1180,16 +1185,17 @@
 
       EndOfBlock: ;
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(entropy->saved, state);
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -1217,11 +1223,11 @@
    * This way, we return uniform gray for the remainder of the segment.
    */
   if (! entropy->insufficient_data) {
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(state, entropy->saved);
 
     /* Outer loop handles each block in the MCU */
 
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
@@ -1304,16 +1310,17 @@
 
       EndOfBlock: ;
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(entropy->saved, state);
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -1345,15 +1352,15 @@
       /* Successive approximation refinement scan: must have Al = Ah-1. */
       if (cinfo->Ah-1 != cinfo->Al)
     goto bad;
     }
     if (cinfo->Al > 13) {    /* need not check for < 0 */
-      /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
-       * but the spec doesn't say so, and we try to be liberal about what we
-       * accept.  Note: large Al values could result in out-of-range DC
-       * coefficients during early scans, leading to bizarre displays due to
-       * overflows in the IDCT math.  But we won't crash.
+      /* Arguably the maximum Al value should be less than 13 for 8-bit
+       * precision, but the spec doesn't say so, and we try to be liberal
+       * about what we accept.  Note: large Al values could result in
+       * out-of-range DC coefficients during early scans, leading to bizarre
+       * displays due to overflows in the IDCT math.  But we won't crash.
        */
       bad:
       ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
            cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
     }
@@ -1453,11 +1460,12 @@
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
       ci = cinfo->MCU_membership[blkn];
       compptr = cinfo->cur_comp_info[ci];
       /* Precalculate which table to use for each block */
       entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
-      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
+      entropy->ac_cur_tbls[blkn] =    /* AC needs no table when not present */
+    cinfo->lim_Se ? entropy->ac_derived_tbls[compptr->ac_tbl_no] : NULL;
       /* Decide whether we really care about the coefficient values */
       if (compptr->component_needed) {
     ci = compptr->DCT_v_scaled_size;
     i = compptr->DCT_h_scaled_size;
     switch (cinfo->lim_Se) {
@@ -1496,11 +1504,10 @@
       break;
     default:
       if (ci <= 0 || ci > 8) ci = 8;
       if (i <= 0 || i > 8) i = 8;
       entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
-      break;
     }
       } else {
     entropy->coef_limit[blkn] = 0;
       }
     }
@@ -1524,34 +1531,33 @@
 jinit_huff_decoder (j_decompress_ptr cinfo)
 {
   huff_entropy_ptr entropy;
   int i;
 
-  entropy = (huff_entropy_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(huff_entropy_decoder));
+  entropy = (huff_entropy_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(huff_entropy_decoder));
   cinfo->entropy = &entropy->pub;
   entropy->pub.start_pass = start_pass_huff_decoder;
   entropy->pub.finish_pass = finish_pass_huff;
 
   if (cinfo->progressive_mode) {
     /* Create progression status table */
     int *coef_bit_ptr, ci;
-    cinfo->coef_bits = (int (*)[DCTSIZE2])
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  cinfo->num_components*DCTSIZE2*SIZEOF(int));
+    cinfo->coef_bits = (int (*)[DCTSIZE2]) (*cinfo->mem->alloc_small)
+      ((j_common_ptr) cinfo, JPOOL_IMAGE,
+       cinfo->num_components * DCTSIZE2 * SIZEOF(int));
     coef_bit_ptr = & cinfo->coef_bits[0][0];
     for (ci = 0; ci < cinfo->num_components; ci++)
       for (i = 0; i < DCTSIZE2; i++)
     *coef_bit_ptr++ = -1;
 
     /* Mark derived tables unallocated */
     for (i = 0; i < NUM_HUFF_TBLS; i++) {
       entropy->derived_tbls[i] = NULL;
     }
   } else {
-    /* Mark tables unallocated */
+    /* Mark derived tables unallocated */
     for (i = 0; i < NUM_HUFF_TBLS; i++) {
       entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
     }
   }
 }
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmarker.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmarker.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmarker.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmarker.c
@@ -1,10 +1,10 @@
 /*
  * jdmarker.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
- * Modified 2009-2013 by Guido Vollbeding.
+ * Modified 2009-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains routines to decode JPEG datastream markers.
  * Most of the complexity arises from our desire to support input
@@ -494,12 +494,10 @@
      * off the end of our table space.  jdhuff.c will check more carefully.
      */
     if (count > 256 || ((INT32) count) > length)
       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 
-    MEMZERO(huffval, SIZEOF(huffval)); /* pre-zero array for later copy */
-
     for (i = 0; i < count; i++)
       INPUT_BYTE(cinfo, huffval[i], return FALSE);
 
     length -= count;
 
@@ -515,11 +513,12 @@
 
     if (*htblptr == NULL)
       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
 
     MEMCOPY((*htblptr)->bits, bits, SIZEOF((*htblptr)->bits));
-    MEMCOPY((*htblptr)->huffval, huffval, SIZEOF((*htblptr)->huffval));
+    if (count > 0)
+      MEMCOPY((*htblptr)->huffval, huffval, count * SIZEOF(UINT8));
   }
 
   if (length != 0)
     ERREXIT(cinfo, JERR_BAD_LENGTH);
 
@@ -575,18 +574,18 @@
     count = length;
       } else
     count = DCTSIZE2;
     }
 
-    switch (count) {
+    switch ((int) count) {
     case (2*2): natural_order = jpeg_natural_order2; break;
     case (3*3): natural_order = jpeg_natural_order3; break;
     case (4*4): natural_order = jpeg_natural_order4; break;
     case (5*5): natural_order = jpeg_natural_order5; break;
     case (6*6): natural_order = jpeg_natural_order6; break;
     case (7*7): natural_order = jpeg_natural_order7; break;
-    default:    natural_order = jpeg_natural_order;  break;
+    default:    natural_order = jpeg_natural_order;
     }
 
     for (i = 0; i < count; i++) {
       if (prec)
     INPUT_2BYTES(cinfo, tmp, return FALSE);
@@ -782,11 +781,10 @@
       TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
       break;
     default:
       TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
            GETJOCTET(data[5]), (int) totallen);
-      break;
     }
   } else {
     /* Start of APP0 does not match "JFIF" or "JFXX", or too short */
     TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
   }
@@ -856,11 +854,10 @@
     examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
     break;
   default:
     /* can't get here unless jpeg_save_markers chooses wrong processor */
     ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
-    break;
   }
 
   /* skip any remaining data -- could be lots */
   INPUT_SYNC(cinfo);
   if (length > 0)
@@ -962,11 +959,10 @@
     examine_app14(cinfo, data, data_length, length);
     break;
   default:
     TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,
          (int) (data_length + length));
-    break;
   }
 
   /* skip any remaining data -- could be lots */
   INPUT_SYNC(cinfo);        /* do before skip_input_data */
   if (length > 0)
@@ -1238,11 +1234,10 @@
        * likely to be used to signal incompatible JPEG Part 3 extensions.
        * Once the JPEG 3 version-number marker is well defined, this code
        * ought to change!
        */
       ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo->unread_marker);
-      break;
     }
     /* Successfully processed marker, so reset state variable */
     cinfo->unread_marker = 0;
   } /* end loop */
 }
@@ -1414,13 +1409,12 @@
 {
   my_marker_ptr marker;
   int i;
 
   /* Create subobject in permanent pool */
-  marker = (my_marker_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
-                SIZEOF(my_marker_reader));
+  marker = (my_marker_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_PERMANENT, SIZEOF(my_marker_reader));
   cinfo->marker = &marker->pub;
   /* Initialize public method pointers */
   marker->pub.reset_marker_reader = reset_marker_reader;
   marker->pub.read_markers = read_markers;
   marker->pub.read_restart_marker = read_restart_marker;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmaster.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmaster.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmaster.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmaster.c
@@ -1,10 +1,10 @@
 /*
  * jdmaster.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2002-2017 by Guido Vollbeding.
+ * Modified 2002-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains master control logic for the JPEG decompressor.
  * These routines are concerned with selecting the modules to be executed
@@ -102,11 +102,11 @@
 /* Do computations that are needed before master selection phase.
  * This function is used for full decompression.
  */
 {
 #ifdef IDCT_SCALING_SUPPORTED
-  int ci;
+  int ci, ssize;
   jpeg_component_info *compptr;
 #endif
 
   /* Prevent application from calling me at wrong times */
   if (cinfo->global_state != DSTATE_READY)
@@ -122,37 +122,38 @@
    * This saves time if the upsampler gets to use 1:1 scaling.
    * Note this code adapts subsampling ratios which are powers of 2.
    */
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
-    int ssize = 1;
-    while (cinfo->min_DCT_h_scaled_size * ssize <=
-       (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
-       (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
-      ssize = ssize * 2;
-    }
+    ssize = 1;
+    if (! cinfo->raw_data_out)
+      while (cinfo->min_DCT_h_scaled_size * ssize <=
+         (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
+         (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) ==
+         0) {
+    ssize = ssize * 2;
+      }
     compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;
     ssize = 1;
-    while (cinfo->min_DCT_v_scaled_size * ssize <=
-       (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
-       (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
-      ssize = ssize * 2;
-    }
+    if (! cinfo->raw_data_out)
+      while (cinfo->min_DCT_v_scaled_size * ssize <=
+         (cinfo->do_fancy_upsampling ? DCTSIZE : DCTSIZE / 2) &&
+         (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) ==
+         0) {
+    ssize = ssize * 2;
+      }
     compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;
 
     /* We don't support IDCT ratios larger than 2. */
     if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)
     compptr->DCT_h_scaled_size = compptr->DCT_v_scaled_size * 2;
     else if (compptr->DCT_v_scaled_size > compptr->DCT_h_scaled_size * 2)
     compptr->DCT_v_scaled_size = compptr->DCT_h_scaled_size * 2;
-  }
 
-  /* Recompute downsampled dimensions of components;
-   * application needs to know these if using raw downsampled data.
-   */
-  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
-       ci++, compptr++) {
+    /* Recompute downsampled dimensions of components;
+     * application needs to know these if using raw downsampled data.
+     */
     /* Size in samples, after IDCT scaling */
     compptr->downsampled_width = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_width *
             (long) (compptr->h_samp_factor * compptr->DCT_h_scaled_size),
             (long) (cinfo->max_h_samp_factor * cinfo->block_size));
@@ -170,23 +171,24 @@
   case JCS_GRAYSCALE:
     cinfo->out_color_components = 1;
     break;
   case JCS_RGB:
   case JCS_BG_RGB:
+#if RGB_PIXELSIZE != 3
     cinfo->out_color_components = RGB_PIXELSIZE;
     break;
+#endif /* else share code with YCbCr */
   case JCS_YCbCr:
   case JCS_BG_YCC:
     cinfo->out_color_components = 3;
     break;
   case JCS_CMYK:
   case JCS_YCCK:
     cinfo->out_color_components = 4;
     break;
   default:            /* else must be same colorspace as in file */
     cinfo->out_color_components = cinfo->num_components;
-    break;
   }
   cinfo->output_components = (cinfo->quantize_colors ? 1 :
                   cinfo->out_color_components);
 
   /* See if upsampler will want to emit more than one row at a time */
@@ -523,13 +525,12 @@
 GLOBAL(void)
 jinit_master_decompress (j_decompress_ptr cinfo)
 {
   my_master_ptr master;
 
-  master = (my_master_ptr)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  SIZEOF(my_decomp_master));
+  master = (my_master_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_decomp_master));
   cinfo->master = &master->pub;
   master->pub.prepare_for_output_pass = prepare_for_output_pass;
   master->pub.finish_output_pass = finish_output_pass;
 
   master->pub.is_dummy_pass = FALSE;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmerge.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmerge.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmerge.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdmerge.c
@@ -1,10 +1,10 @@
 /*
  * jdmerge.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
- * Modified 2013-2017 by Guido Vollbeding.
+ * Modified 2013-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains code for merged upsampling/color conversion.
  *
@@ -93,32 +93,26 @@
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   int i;
   INT32 x;
   SHIFT_TEMPS
 
-  upsample->Cr_r_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  upsample->Cb_b_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  upsample->Cr_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
-  upsample->Cb_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
+  upsample->Cr_r_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  upsample->Cb_b_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  upsample->Cr_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
+  upsample->Cb_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
 
   for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     /* Cr=>R value is nearest int to 1.402 * x */
-    upsample->Cr_r_tab[i] = (int)
-            RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);
+    upsample->Cr_r_tab[i] = (int) DESCALE(FIX(1.402) * x, SCALEBITS);
     /* Cb=>B value is nearest int to 1.772 * x */
-    upsample->Cb_b_tab[i] = (int)
-            RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);
+    upsample->Cb_b_tab[i] = (int) DESCALE(FIX(1.772) * x, SCALEBITS);
     /* Cr=>G value is scaled-up -0.714136286 * x */
     upsample->Cr_g_tab[i] = (- FIX(0.714136286)) * x;
     /* Cb=>G value is scaled-up -0.344136286 * x */
     /* We also add in ONE_HALF so that need not do it in inner loop */
     upsample->Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
@@ -133,32 +127,26 @@
   my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
   int i;
   INT32 x;
   SHIFT_TEMPS
 
-  upsample->Cr_r_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  upsample->Cb_b_tab = (int *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(int));
-  upsample->Cr_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
-  upsample->Cb_g_tab = (INT32 *)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                (MAXJSAMPLE+1) * SIZEOF(INT32));
+  upsample->Cr_r_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  upsample->Cb_b_tab = (int *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));
+  upsample->Cr_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
+  upsample->Cb_g_tab = (INT32 *) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));
 
   for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     /* Cr=>R value is nearest int to 2.804 * x */
-    upsample->Cr_r_tab[i] = (int)
-            RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);
+    upsample->Cr_r_tab[i] = (int) DESCALE(FIX(2.804) * x, SCALEBITS);
     /* Cb=>B value is nearest int to 3.544 * x */
-    upsample->Cb_b_tab[i] = (int)
-            RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);
+    upsample->Cb_b_tab[i] = (int) DESCALE(FIX(3.544) * x, SCALEBITS);
     /* Cr=>G value is scaled-up -1.428272572 * x */
     upsample->Cr_g_tab[i] = (- FIX(1.428272572)) * x;
     /* Cb=>G value is scaled-up -0.688272572 * x */
     /* We also add in ONE_HALF so that need not do it in inner loop */
     upsample->Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
@@ -417,26 +405,25 @@
 GLOBAL(void)
 jinit_merged_upsampler (j_decompress_ptr cinfo)
 {
   my_upsample_ptr upsample;
 
-  upsample = (my_upsample_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(my_upsampler));
+  upsample = (my_upsample_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_upsampler));
   cinfo->upsample = &upsample->pub;
   upsample->pub.start_pass = start_pass_merged_upsample;
   upsample->pub.need_context_rows = FALSE;
 
   upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
 
   if (cinfo->max_v_samp_factor == 2) {
     upsample->pub.upsample = merged_2v_upsample;
     upsample->upmethod = h2v2_merged_upsample;
     /* Allocate a spare row buffer */
-    upsample->spare_row = (JSAMPROW)
-      (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-        (size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
+    upsample->spare_row = (JSAMPROW) (*cinfo->mem->alloc_large)
+      ((j_common_ptr) cinfo, JPOOL_IMAGE,
+       (size_t) upsample->out_row_width * SIZEOF(JSAMPLE));
   } else {
     upsample->pub.upsample = merged_1v_upsample;
     upsample->upmethod = h2v1_merged_upsample;
     /* No spare row needed */
     upsample->spare_row = NULL;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdtrans.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdtrans.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdtrans.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdtrans.c
@@ -102,13 +102,13 @@
 
   /* Compute output image dimensions and related values. */
   jpeg_core_output_dimensions(cinfo);
 
   /* Entropy decoding: either Huffman or arithmetic coding. */
-  if (cinfo->arith_code)
+  if (cinfo->arith_code) {
     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
-  else {
+  } else {
     jinit_huff_decoder(cinfo);
   }
 
   /* Always get a full-image coefficient buffer. */
   jinit_d_coef_controller(cinfo, TRUE);
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jerror.h b/modules/javafx.graphics/src/main/native-iio/libjpeg/jerror.h
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jerror.h
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jerror.h
@@ -1,10 +1,10 @@
 /*
  * jerror.h
  *
  * Copyright (C) 1994-1997, Thomas G. Lane.
- * Modified 1997-2012 by Guido Vollbeding.
+ * Modified 1997-2018 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file defines the error and message codes for the JPEG library.
  * Edit this file to add new codes, or to translate the message strings to
@@ -84,11 +84,11 @@
 JMESSAGE(JERR_EMS_WRITE, "Write to EMS failed")
 JMESSAGE(JERR_EOI_EXPECTED, "Didn't expect more than one scan")
 JMESSAGE(JERR_FILE_READ, "Input file read error")
 JMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
 JMESSAGE(JERR_FRACT_SAMPLE_NOTIMPL, "Fractional sampling not implemented yet")
-JMESSAGE(JERR_HUFF_CLEN_OVERFLOW, "Huffman code size table overflow")
+JMESSAGE(JERR_HUFF_CLEN_OUTOFBOUNDS, "Huffman code size table out of bounds")
 JMESSAGE(JERR_HUFF_MISSING_CODE, "Missing Huffman code table entry")
 JMESSAGE(JERR_IMAGE_TOO_BIG, "Maximum supported image dimension is %u pixels")
 JMESSAGE(JERR_INPUT_EMPTY, "Empty input file")
 JMESSAGE(JERR_INPUT_EOF, "Premature end of input file")
 JMESSAGE(JERR_MISMATCHED_QUANT_TABLE,
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jfdctint.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jfdctint.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jfdctint.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jfdctint.c
@@ -1,10 +1,10 @@
 /*
  * jfdctint.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
- * Modification developed 2003-2015 by Guido Vollbeding.
+ * Modification developed 2003-2018 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains a slow-but-accurate integer implementation of the
  * forward DCT (Discrete Cosine Transform).
@@ -3259,82 +3259,88 @@
  */
 
 GLOBAL(void)
 jpeg_fdct_4x2 (DCTELEM * data, JSAMPARRAY sample_data, JDIMENSION start_col)
 {
-  INT32 tmp0, tmp1;
-  INT32 tmp10, tmp11;
-  DCTELEM *dataptr;
+  DCTELEM tmp0, tmp2, tmp10, tmp12, tmp4, tmp5;
+  INT32 tmp1, tmp3, tmp11, tmp13;
+  INT32 z1, z2, z3;
   JSAMPROW elemptr;
-  int ctr;
   SHIFT_TEMPS
 
   /* Pre-zero output coefficient block. */
   MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);
 
   /* Pass 1: process rows.
-   * Note results are scaled up by sqrt(8) compared to a true DCT;
-   * furthermore, we scale the results by 2**PASS1_BITS.
-   * We must also scale the output by (8/4)*(8/2) = 2**3, which we add here.
+   * Note results are scaled up by sqrt(8) compared to a true DCT.
    * 4-point FDCT kernel,
    * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point FDCT].
    */
 
-  dataptr = data;
-  for (ctr = 0; ctr < 2; ctr++) {
-    elemptr = sample_data[ctr] + start_col;
+  /* Row 0 */
+  elemptr = sample_data[0] + start_col;
 
-    /* Even part */
+  /* Even part */
 
-    tmp0 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[3]);
-    tmp1 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[2]);
+  tmp4 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[3]);
+  tmp5 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[2]);
 
-    tmp10 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[3]);
-    tmp11 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[2]);
+  tmp0 = tmp4 + tmp5;
+  tmp2 = tmp4 - tmp5;
 
-    /* Apply unsigned->signed conversion. */
-    dataptr[0] = (DCTELEM)
-      ((tmp0 + tmp1 - 4 * CENTERJSAMPLE) << (PASS1_BITS+3));
-    dataptr[2] = (DCTELEM) ((tmp0 - tmp1) << (PASS1_BITS+3));
+  /* Odd part */
 
-    /* Odd part */
+  z2 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[3]);
+  z3 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[2]);
 
-    tmp0 = MULTIPLY(tmp10 + tmp11, FIX_0_541196100);       /* c6 */
-    /* Add fudge factor here for final descale. */
-    tmp0 += ONE << (CONST_BITS-PASS1_BITS-4);
+  z1 = MULTIPLY(z2 + z3, FIX_0_541196100);    /* c6 */
+  /* Add fudge factor here for final descale. */
+  z1 += ONE << (CONST_BITS-3-1);
+  tmp1 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
+  tmp3 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 
-    dataptr[1] = (DCTELEM)
-      RIGHT_SHIFT(tmp0 + MULTIPLY(tmp10, FIX_0_765366865), /* c2-c6 */
-          CONST_BITS-PASS1_BITS-3);
-    dataptr[3] = (DCTELEM)
-      RIGHT_SHIFT(tmp0 - MULTIPLY(tmp11, FIX_1_847759065), /* c2+c6 */
-          CONST_BITS-PASS1_BITS-3);
+  /* Row 1 */
+  elemptr = sample_data[1] + start_col;
 
-    dataptr += DCTSIZE;        /* advance pointer to next row */
-  }
+  /* Even part */
 
-  /* Pass 2: process columns.
-   * We remove the PASS1_BITS scaling, but leave the results scaled up
-   * by an overall factor of 8.
-   */
+  tmp4 = GETJSAMPLE(elemptr[0]) + GETJSAMPLE(elemptr[3]);
+  tmp5 = GETJSAMPLE(elemptr[1]) + GETJSAMPLE(elemptr[2]);
 
-  dataptr = data;
-  for (ctr = 0; ctr < 4; ctr++) {
-    /* Even part */
+  tmp10 = tmp4 + tmp5;
+  tmp12 = tmp4 - tmp5;
 
-    /* Add fudge factor here for final descale. */
-    tmp0 = dataptr[DCTSIZE*0] + (ONE << (PASS1_BITS-1));
-    tmp1 = dataptr[DCTSIZE*1];
+  /* Odd part */
 
-    dataptr[DCTSIZE*0] = (DCTELEM) RIGHT_SHIFT(tmp0 + tmp1, PASS1_BITS);
+  z2 = GETJSAMPLE(elemptr[0]) - GETJSAMPLE(elemptr[3]);
+  z3 = GETJSAMPLE(elemptr[1]) - GETJSAMPLE(elemptr[2]);
 
-    /* Odd part */
+  z1 = MULTIPLY(z2 + z3, FIX_0_541196100);    /* c6 */
+  tmp11 = z1 + MULTIPLY(z2, FIX_0_765366865); /* c2-c6 */
+  tmp13 = z1 - MULTIPLY(z3, FIX_1_847759065); /* c2+c6 */
 
-    dataptr[DCTSIZE*1] = (DCTELEM) RIGHT_SHIFT(tmp0 - tmp1, PASS1_BITS);
+  /* Pass 2: process columns.
+   * We leave the results scaled up by an overall factor of 8.
+   * We must also scale the output by (8/4)*(8/2) = 2**3.
+   */
 
-    dataptr++;            /* advance pointer to next column */
-  }
+  /* Column 0 */
+  /* Apply unsigned->signed conversion. */
+  data[DCTSIZE*0] = (tmp0 + tmp10 - 8 * CENTERJSAMPLE) << 3;
+  data[DCTSIZE*1] = (tmp0 - tmp10) << 3;
+
+  /* Column 1 */
+  data[DCTSIZE*0+1] = (DCTELEM) RIGHT_SHIFT(tmp1 + tmp11, CONST_BITS-3);
+  data[DCTSIZE*1+1] = (DCTELEM) RIGHT_SHIFT(tmp1 - tmp11, CONST_BITS-3);
+
+  /* Column 2 */
+  data[DCTSIZE*0+2] = (tmp2 + tmp12) << 3;
+  data[DCTSIZE*1+2] = (tmp2 - tmp12) << 3;
+
+  /* Column 3 */
+  data[DCTSIZE*0+3] = (DCTELEM) RIGHT_SHIFT(tmp3 + tmp13, CONST_BITS-3);
+  data[DCTSIZE*1+3] = (DCTELEM) RIGHT_SHIFT(tmp3 - tmp13, CONST_BITS-3);
 }
 
 
 /*
  * Perform the forward DCT on a 2x1 sample block.
@@ -4310,11 +4316,10 @@
   /* Pre-zero output coefficient block. */
   MEMZERO(data, SIZEOF(DCTELEM) * DCTSIZE2);
 
   /* Pass 1: process rows.
    * Note results are scaled up by sqrt(8) compared to a true DCT.
-   * We must also scale the output by (8/2)*(8/4) = 2**3, which we add here.
    */
 
   dataptr = data;
   for (ctr = 0; ctr < 4; ctr++) {
     elemptr = sample_data[ctr] + start_col;
@@ -4323,21 +4328,22 @@
 
     tmp0 = GETJSAMPLE(elemptr[0]);
     tmp1 = GETJSAMPLE(elemptr[1]);
 
     /* Apply unsigned->signed conversion. */
-    dataptr[0] = (DCTELEM) ((tmp0 + tmp1 - 2 * CENTERJSAMPLE) << 3);
+    dataptr[0] = (DCTELEM) (tmp0 + tmp1 - 2 * CENTERJSAMPLE);
 
     /* Odd part */
 
-    dataptr[1] = (DCTELEM) ((tmp0 - tmp1) << 3);
+    dataptr[1] = (DCTELEM) (tmp0 - tmp1);
 
     dataptr += DCTSIZE;        /* advance pointer to next row */
   }
 
   /* Pass 2: process columns.
    * We leave the results scaled up by an overall factor of 8.
+   * We must also scale the output by (8/2)*(8/4) = 2**3.
    * 4-point FDCT kernel,
    * cK represents sqrt(2) * cos(K*pi/16) [refers to 8-point FDCT].
    */
 
   dataptr = data;
@@ -4348,25 +4354,25 @@
     tmp1 = dataptr[DCTSIZE*1] + dataptr[DCTSIZE*2];
 
     tmp10 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*3];
     tmp11 = dataptr[DCTSIZE*1] - dataptr[DCTSIZE*2];
 
-    dataptr[DCTSIZE*0] = (DCTELEM) (tmp0 + tmp1);
-    dataptr[DCTSIZE*2] = (DCTELEM) (tmp0 - tmp1);
+    dataptr[DCTSIZE*0] = (DCTELEM) ((tmp0 + tmp1) << 3);
+    dataptr[DCTSIZE*2] = (DCTELEM) ((tmp0 - tmp1) << 3);
 
     /* Odd part */
 
     tmp0 = MULTIPLY(tmp10 + tmp11, FIX_0_541196100);       /* c6 */
     /* Add fudge factor here for final descale. */
-    tmp0 += ONE << (CONST_BITS-1);
+    tmp0 += ONE << (CONST_BITS-3-1);
 
     dataptr[DCTSIZE*1] = (DCTELEM)
       RIGHT_SHIFT(tmp0 + MULTIPLY(tmp10, FIX_0_765366865), /* c2-c6 */
-          CONST_BITS);
+          CONST_BITS-3);
     dataptr[DCTSIZE*3] = (DCTELEM)
       RIGHT_SHIFT(tmp0 - MULTIPLY(tmp11, FIX_1_847759065), /* c2+c6 */
-          CONST_BITS);
+          CONST_BITS-3);
 
     dataptr++;            /* advance pointer to next column */
   }
 }
 
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jidctint.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jidctint.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jidctint.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jidctint.c
@@ -1,10 +1,10 @@
 /*
  * jidctint.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
- * Modification developed 2002-2016 by Guido Vollbeding.
+ * Modification developed 2002-2018 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains a slow-but-accurate integer implementation of the
  * inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
@@ -1472,11 +1472,11 @@
 }
 
 
 /*
  * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a 11x11 output block.
+ * producing an 11x11 output block.
  *
  * Optimized algorithm with 24 multiplications in the 1-D kernel.
  * cK represents sqrt(2) * cos(K*pi/22).
  */
 
@@ -3673,11 +3673,11 @@
 }
 
 
 /*
  * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a 8x4 output block.
+ * producing an 8x4 output block.
  *
  * 4-point IDCT in pass 1 (columns), 8-point in pass 2 (rows).
  */
 
 GLOBAL(void)
@@ -3833,11 +3833,11 @@
 }
 
 
 /*
  * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a reduced-size 6x3 output block.
+ * producing a 6x3 output block.
  *
  * 3-point IDCT in pass 1 (columns), 6-point in pass 2 (rows).
  */
 
 GLOBAL(void)
@@ -4080,11 +4080,11 @@
 }
 
 
 /*
  * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a 8x16 output block.
+ * producing an 8x16 output block.
  *
  * 16-point IDCT in pass 1 (columns), 8-point in pass 2 (rows).
  */
 
 GLOBAL(void)
@@ -5002,11 +5002,11 @@
 }
 
 
 /*
  * Perform dequantization and inverse DCT on one block of coefficients,
- * producing a reduced-size 3x6 output block.
+ * producing a 3x6 output block.
  *
  * 6-point IDCT in pass 1 (columns), 3-point in pass 2 (rows).
  */
 
 GLOBAL(void)
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c
@@ -1,10 +1,10 @@
 /*
  * jmemmgr.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2011-2012 by Guido Vollbeding.
+ * Modified 2011-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains the JPEG system-independent memory management
  * routines.  This code is usable across a wide variety of machines; most
@@ -128,11 +128,11 @@
    */
   jvirt_sarray_ptr virt_sarray_list;
   jvirt_barray_ptr virt_barray_list;
 
   /* This counts total space obtained from jpeg_get_small/large */
-  long total_space_allocated;
+  size_t total_space_allocated;
 
   /* alloc_sarray and alloc_barray set this value for use by virtual
    * array routines.
    */
   JDIMENSION last_rowsperchunk;    /* from most recent alloc_sarray/barray */
@@ -193,11 +193,11 @@
   /* Since this is only a debugging stub, we can cheat a little by using
    * fprintf directly rather than going through the trace message code.
    * This is helpful because message parm array can't handle longs.
    */
   fprintf(stderr, "Freeing pool %d, total space = %ld\n",
-      pool_id, mem->total_space_allocated);
+      pool_id, (long) mem->total_space_allocated);
 
   for (lhdr_ptr = mem->large_list[pool_id]; lhdr_ptr != NULL;
        lhdr_ptr = lhdr_ptr->hdr.next) {
     fprintf(stderr, "  Large chunk used %ld\n",
         (long) lhdr_ptr->hdr.bytes_used);
@@ -258,15 +258,15 @@
 alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 /* Allocate a "small" object */
 {
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   small_pool_ptr hdr_ptr, prev_hdr_ptr;
-  char * data_ptr;
   size_t odd_bytes, min_request, slop;
+  char * data_ptr;
 
   /* Check for unsatisfiable request (do now to ensure no overflow below) */
-  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
+  if (sizeofobject > (size_t) MAX_ALLOC_CHUNK - SIZEOF(small_pool_hdr))
     out_of_memory(cinfo, 1);    /* request exceeds malloc's ability */
 
   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
   if (odd_bytes > 0)
@@ -291,12 +291,12 @@
     if (prev_hdr_ptr == NULL)    /* first pool in class? */
       slop = first_pool_slop[pool_id];
     else
       slop = extra_pool_slop[pool_id];
     /* Don't ask for more than MAX_ALLOC_CHUNK */
-    if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
-      slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
+    if (slop > (size_t) MAX_ALLOC_CHUNK - min_request)
+      slop = (size_t) MAX_ALLOC_CHUNK - min_request;
     /* Try to get space, if fail reduce slop and try again */
     for (;;) {
       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
       if (hdr_ptr != NULL)
     break;
@@ -346,11 +346,11 @@
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
   large_pool_ptr hdr_ptr;
   size_t odd_bytes;
 
   /* Check for unsatisfiable request (do now to ensure no overflow below) */
-  if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
+  if (sizeofobject > (size_t) MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr))
     out_of_memory(cinfo, 3);    /* request exceeds malloc's ability */
 
   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
   if (odd_bytes > 0)
@@ -406,11 +406,11 @@
   if (samplesperrow == 0) {
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   }
 
   /* Calculate max # of rows allowed in one allocation chunk */
-  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
+  ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /
       ((long) samplesperrow * SIZEOF(JSAMPLE));
   if (ltemp <= 0)
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   if (ltemp < (long) numrows)
     rowsperchunk = (JDIMENSION) ltemp;
@@ -418,19 +418,18 @@
     rowsperchunk = numrows;
   mem->last_rowsperchunk = rowsperchunk;
 
   /* Get space for row pointers (small object) */
   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
-                    (size_t) (numrows * SIZEOF(JSAMPROW)));
+                    (size_t) numrows * SIZEOF(JSAMPROW));
 
   /* Get the rows themselves (large objects) */
   currow = 0;
   while (currow < numrows) {
     rowsperchunk = MIN(rowsperchunk, numrows - currow);
     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
-    (size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
-          * SIZEOF(JSAMPLE)));
+      (size_t) rowsperchunk * (size_t) samplesperrow * SIZEOF(JSAMPLE));
     for (i = rowsperchunk; i > 0; i--) {
       result[currow++] = workspace;
       workspace += samplesperrow;
     }
   }
@@ -458,11 +457,11 @@
   if (blocksperrow == 0) {
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   }
 
   /* Calculate max # of rows allowed in one allocation chunk */
-  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
+  ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /
       ((long) blocksperrow * SIZEOF(JBLOCK));
   if (ltemp <= 0)
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   if (ltemp < (long) numrows)
     rowsperchunk = (JDIMENSION) ltemp;
@@ -470,19 +469,18 @@
     rowsperchunk = numrows;
   mem->last_rowsperchunk = rowsperchunk;
 
   /* Get space for row pointers (small object) */
   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
-                     (size_t) (numrows * SIZEOF(JBLOCKROW)));
+                     (size_t) numrows * SIZEOF(JBLOCKROW));
 
   /* Get the rows themselves (large objects) */
   currow = 0;
   while (currow < numrows) {
     rowsperchunk = MIN(rowsperchunk, numrows - currow);
     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
-    (size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
-          * SIZEOF(JBLOCK)));
+      (size_t) rowsperchunk * (size_t) blocksperrow * SIZEOF(JBLOCK));
     for (i = rowsperchunk; i > 0; i--) {
       result[currow++] = workspace;
       workspace += blocksperrow;
     }
   }
@@ -591,12 +589,12 @@
 METHODDEF(void)
 realize_virt_arrays (j_common_ptr cinfo)
 /* Allocate the in-memory buffers for any unrealized virtual arrays */
 {
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
-  long space_per_minheight, maximum_space, avail_mem;
-  long minheights, max_minheights;
+  long bytesperrow, space_per_minheight, maximum_space;
+  long avail_mem, minheights, max_minheights;
   jvirt_sarray_ptr sptr;
   jvirt_barray_ptr bptr;
 
   /* Compute the minimum space needed (maxaccess rows in each buffer)
    * and the maximum space needed (full image height in each buffer).
@@ -604,31 +602,29 @@
    */
   space_per_minheight = 0;
   maximum_space = 0;
   for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
     if (sptr->mem_buffer == NULL) { /* if not realized yet */
-      space_per_minheight += (long) sptr->maxaccess *
-                 (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
-      maximum_space += (long) sptr->rows_in_array *
-               (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
+      bytesperrow = (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
+      space_per_minheight += (long) sptr->maxaccess * bytesperrow;
+      maximum_space += (long) sptr->rows_in_array * bytesperrow;
     }
   }
   for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
     if (bptr->mem_buffer == NULL) { /* if not realized yet */
-      space_per_minheight += (long) bptr->maxaccess *
-                 (long) bptr->blocksperrow * SIZEOF(JBLOCK);
-      maximum_space += (long) bptr->rows_in_array *
-               (long) bptr->blocksperrow * SIZEOF(JBLOCK);
+      bytesperrow = (long) bptr->blocksperrow * SIZEOF(JBLOCK);
+      space_per_minheight += (long) bptr->maxaccess * bytesperrow;
+      maximum_space += (long) bptr->rows_in_array * bytesperrow;
     }
   }
 
   if (space_per_minheight <= 0)
     return;            /* no unrealized arrays, no work */
 
   /* Determine amount of memory to actually use; this is system-dependent. */
   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
-                 mem->total_space_allocated);
+                 (long) mem->total_space_allocated);
 
   /* If the maximum space needed is available, make all the buffers full
    * height; otherwise parcel it out with the same number of minheights
    * in each buffer.
    */
@@ -700,11 +696,11 @@
 /* Do backing store read or write of a virtual sample array */
 {
   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 
   bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
-  file_offset = ptr->cur_start_row * bytesperrow;
+  file_offset = (long) ptr->cur_start_row * bytesperrow;
   /* Loop to read or write each allocation chunk in mem_buffer */
   for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
     /* One chunk, but check for short chunk at end of buffer */
     rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
     /* Transfer no more than is currently defined */
@@ -733,11 +729,11 @@
 /* Do backing store read or write of a virtual coefficient-block array */
 {
   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 
   bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
-  file_offset = ptr->cur_start_row * bytesperrow;
+  file_offset = (long) ptr->cur_start_row * bytesperrow;
   /* Loop to read or write each allocation chunk in mem_buffer */
   for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
     /* One chunk, but check for short chunk at end of buffer */
     rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
     /* Transfer no more than is currently defined */
@@ -777,11 +773,11 @@
       ptr->mem_buffer == NULL)
     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 
   /* Make the desired part of the virtual array accessible */
   if (start_row < ptr->cur_start_row ||
-      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
+      end_row > ptr->cur_start_row + ptr->rows_in_mem) {
     if (! ptr->b_s_open)
       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
     /* Flush old buffer contents if necessary */
     if (ptr->dirty) {
       do_sarray_io(cinfo, ptr, TRUE);
@@ -862,11 +858,11 @@
       ptr->mem_buffer == NULL)
     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 
   /* Make the desired part of the virtual array accessible */
   if (start_row < ptr->cur_start_row ||
-      end_row > ptr->cur_start_row+ptr->rows_in_mem) {
+      end_row > ptr->cur_start_row + ptr->rows_in_mem) {
     if (! ptr->b_s_open)
       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
     /* Flush old buffer contents if necessary */
     if (ptr->dirty) {
       do_barray_io(cinfo, ptr, TRUE);
@@ -1099,11 +1095,11 @@
   mem->virt_barray_list = NULL;
 
   mem->total_space_allocated = SIZEOF(my_memory_mgr);
 
   /* Declare ourselves open for business */
-  cinfo->mem = & mem->pub;
+  cinfo->mem = &mem->pub;
 
   /* Check for an environment variable JPEGMEM; if found, override the
    * default max_memory setting from jpeg_mem_init.  Note that the
    * surrounding application may again override this value.
    * If your system doesn't support getenv(), define NO_GETENV to disable
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemnobs.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemnobs.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemnobs.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jmemnobs.c
@@ -1,20 +1,21 @@
 /*
  * jmemnobs.c
  *
  * Copyright (C) 1992-1996, Thomas G. Lane.
+ * Modified 2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file provides a really simple implementation of the system-
  * dependent portion of the JPEG memory manager.  This implementation
  * assumes that no backing-store files are needed: all required space
  * can be obtained from malloc().
  * This is very portable in the sense that it'll compile on almost anything,
  * but you'd better have lots of main memory (or virtual memory) if you want
  * to process big images.
- * Note that the max_memory_to_use option is ignored by this implementation.
+ * Note that the max_memory_to_use option is respected by this implementation.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
@@ -64,17 +65,20 @@
 }
 
 
 /*
  * This routine computes the total memory space available for allocation.
- * Here we always say, "we got all you want bud!"
  */
 
 GLOBAL(long)
 jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
             long max_bytes_needed, long already_allocated)
 {
+  if (cinfo->mem->max_memory_to_use)
+    return cinfo->mem->max_memory_to_use - already_allocated;
+
+  /* Here we say, "we got all you want bud!" */
   return max_bytes_needed;
 }
 
 
 /*
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jpegint.h b/modules/javafx.graphics/src/main/native-iio/libjpeg/jpegint.h
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jpegint.h
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jpegint.h
@@ -1,10 +1,10 @@
 /*
  * jpegint.h
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 1997-2017 by Guido Vollbeding.
+ * Modified 1997-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file provides common declarations for the various JPEG modules.
  * These declarations are considered internal to the JPEG library; most
@@ -300,10 +300,17 @@
 #else
 #define SHIFT_TEMPS
 #define RIGHT_SHIFT(x,shft)    ((x) >> (shft))
 #endif
 
+/* Descale and correctly round an INT32 value that's scaled by N bits.
+ * We assume RIGHT_SHIFT rounds towards minus infinity, so adding
+ * the fudge factor is correct for either sign of X.
+ */
+
+#define DESCALE(x,n)    RIGHT_SHIFT((x) + ((INT32) 1 << ((n)-1)), n)
+
 
 /* Short forms of external names for systems with brain-damaged linkers. */
 
 #ifdef NEED_SHORT_EXTERNAL_NAMES
 #define jinit_compress_master    jICompress
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jpeglib.h b/modules/javafx.graphics/src/main/native-iio/libjpeg/jpeglib.h
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jpeglib.h
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jpeglib.h
@@ -1,10 +1,10 @@
 /*
  * jpeglib.h
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
- * Modified 2002-2017 by Guido Vollbeding.
+ * Modified 2002-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file defines the application interface for the JPEG library.
  * Most applications using the library need only include this file,
@@ -37,11 +37,11 @@
  * Might be useful for tests like "#if JPEG_LIB_VERSION >= 90".
  */
 
 #define JPEG_LIB_VERSION        90    /* Compatibility version 9.0 */
 #define JPEG_LIB_VERSION_MAJOR  9
-#define JPEG_LIB_VERSION_MINOR  3
+#define JPEG_LIB_VERSION_MINOR  4
 
 
 /* Various constants determining the sizes of things.
  * All of these are specified by the JPEG standard,
  * so don't change them if you want to be compatible.
@@ -907,10 +907,11 @@
 #define jpeg_quality_scaling    jQualityScaling
 #define jpeg_simple_progression    jSimProgress
 #define jpeg_suppress_tables    jSuppressTables
 #define jpeg_alloc_quant_table    jAlcQTable
 #define jpeg_alloc_huff_table    jAlcHTable
+#define jpeg_std_huff_table    jStdHTable
 #define jpeg_start_compress    jStrtCompress
 #define jpeg_write_scanlines    jWrtScanlines
 #define jpeg_finish_compress    jFinCompress
 #define jpeg_calc_jpeg_dimensions    jCjpegDimensions
 #define jpeg_write_raw_data    jWrtRawData
@@ -975,14 +976,14 @@
 EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));
 
 /* Data source and destination managers: memory buffers. */
 EXTERN(void) jpeg_mem_dest JPP((j_compress_ptr cinfo,
                    unsigned char ** outbuffer,
-                   unsigned long * outsize));
+                   size_t * outsize));
 EXTERN(void) jpeg_mem_src JPP((j_decompress_ptr cinfo,
                   const unsigned char * inbuffer,
-                  unsigned long insize));
+                  size_t insize));
 
 /* Default parameter setup for compression */
 EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
 /* Compression parameter setup aids */
 EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
@@ -1003,10 +1004,12 @@
 EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
 EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
                        boolean suppress));
 EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
 EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
+EXTERN(JHUFF_TBL *) jpeg_std_huff_table JPP((j_common_ptr cinfo,
+                         boolean isDC, int tblno));
 
 /* Main entry points for compression */
 EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
                       boolean write_all_tables));
 EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jutils.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jutils.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jutils.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jutils.c
@@ -1,10 +1,10 @@
 /*
  * jutils.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
- * Modified 2009-2011 by Guido Vollbeding.
+ * Modified 2009-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains tables and miscellaneous utility routines needed
  * for both compression and decompression.
@@ -183,11 +183,11 @@
  * The source and destination arrays must be at least as wide as num_cols.
  */
 {
   register JSAMPROW inptr, outptr;
 #ifdef FMEMCOPY
-  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
+  register size_t count = (size_t) num_cols * SIZEOF(JSAMPLE);
 #else
   register JDIMENSION count;
 #endif
   register int row;
 
@@ -211,11 +211,11 @@
 jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
          JDIMENSION num_blocks)
 /* Copy a row of coefficient blocks from one place to another. */
 {
 #ifdef FMEMCOPY
-  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
+  FMEMCOPY(output_row, input_row, (size_t) num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
 #else
   register JCOEFPTR inptr, outptr;
   register long count;
 
   inptr = (JCOEFPTR) input_row;
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jversion.h b/modules/javafx.graphics/src/main/native-iio/libjpeg/jversion.h
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jversion.h
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jversion.h
@@ -1,14 +1,14 @@
 /*
  * jversion.h
  *
- * Copyright (C) 1991-2018, Thomas G. Lane, Guido Vollbeding.
+ * Copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains software version identification.
  */
 
 
-#define JVERSION    "9c  14-Jan-2018"
+#define JVERSION    "9d  12-Jan-2020"
 
-#define JCOPYRIGHT    "Copyright (C) 2018, Thomas G. Lane, Guido Vollbeding"
+#define JCOPYRIGHT    "Copyright (C) 2020, Thomas G. Lane, Guido Vollbeding"

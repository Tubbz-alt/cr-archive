<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jdct.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdmarker.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * jdhuff.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="line-modified">   5  * Modified 2006-2016 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains Huffman entropy decoding routines.
  10  * Both sequential and progressive modes are supported in this single module.
  11  *
  12  * Much of the complexity here has to do with supporting input suspension.
  13  * If the data source module demands suspension, we want to be able to back
  14  * up to the start of the current MCU.  To do this, we copy state variables
  15  * into local working storage, and update them back to the permanent
  16  * storage only upon successful completion of an MCU.
  17  */
  18 
  19 #define JPEG_INTERNALS
  20 #include &quot;jinclude.h&quot;
  21 #include &quot;jpeglib.h&quot;
  22 
  23 
  24 /* Derived data constructed for each Huffman table */
  25 
</pre>
<hr />
<pre>
 326   JHUFF_TBL *htbl;
 327   d_derived_tbl *dtbl;
 328   int p, i, l, si, numsymbols;
 329   int lookbits, ctr;
 330   char huffsize[257];
 331   unsigned int huffcode[257];
 332   unsigned int code;
 333 
 334   MEMZERO(huffsize, SIZEOF(huffsize));
 335   MEMZERO(huffcode, SIZEOF(huffcode));
 336   /* Note that huffsize[] and huffcode[] are filled in code-length order,
 337    * paralleling the order of the symbols themselves in htbl-&gt;huffval[].
 338    */
 339 
 340   /* Find the input Huffman table */
 341   if (tblno &lt; 0 || tblno &gt;= NUM_HUFF_TBLS)
 342     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 343   htbl =
 344     isDC ? cinfo-&gt;dc_huff_tbl_ptrs[tblno] : cinfo-&gt;ac_huff_tbl_ptrs[tblno];
 345   if (htbl == NULL)
<span class="line-modified"> 346     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);</span>
 347 
 348   /* Allocate a workspace if we haven&#39;t already done so. */
 349   if (*pdtbl == NULL)
<span class="line-modified"> 350     *pdtbl = (d_derived_tbl *)</span>
<span class="line-modified"> 351       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed"> 352                   SIZEOF(d_derived_tbl));</span>
 353   dtbl = *pdtbl;
 354   dtbl-&gt;pub = htbl;        /* fill in back link */
 355 
 356   /* Figure C.1: make table of Huffman code length for each symbol */
 357 
 358   p = 0;
 359   for (l = 1; l &lt;= 16; l++) {
 360     i = (int) htbl-&gt;bits[l];
 361     if (i &lt; 0 || p + i &gt; 256)    /* protect against table overrun */
 362       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 363     while (i--)
 364       huffsize[p++] = (char) l;
 365   }
 366   huffsize[p] = 0;
 367   numsymbols = p;
 368 
 369   /* Figure C.2: generate the codes themselves */
 370   /* We also validate that the counts represent a legal Huffman code tree. */
 371 
 372   code = 0;
</pre>
<hr />
<pre>
 717   int blkn, ci;
 718   JBLOCKROW block;
 719   BITREAD_STATE_VARS;
 720   savable_state state;
 721   d_derived_tbl * tbl;
 722   jpeg_component_info * compptr;
 723 
 724   /* Process restart marker if needed; may have to suspend */
 725   if (cinfo-&gt;restart_interval) {
 726     if (entropy-&gt;restarts_to_go == 0)
 727       if (! process_restart(cinfo))
 728     return FALSE;
 729   }
 730 
 731   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
 732    * This way, we return uniform gray for the remainder of the segment.
 733    */
 734   if (! entropy-&gt;insufficient_data) {
 735 
 736     /* Load up working state */
<span class="line-modified"> 737     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 738     ASSIGN_STATE(state, entropy-&gt;saved);
 739 
 740     /* Outer loop handles each block in the MCU */
 741 
 742     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 743       block = MCU_data[blkn];
 744       ci = cinfo-&gt;MCU_membership[blkn];
 745       compptr = cinfo-&gt;cur_comp_info[ci];
 746       tbl = entropy-&gt;derived_tbls[compptr-&gt;dc_tbl_no];
 747 
 748       /* Decode a single block&#39;s worth of coefficients */
 749 
 750       /* Section F.2.2.1: decode the DC coefficient difference */
 751       HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
 752       if (s) {
 753     CHECK_BIT_BUFFER(br_state, s, return FALSE);
 754     r = GET_BITS(s);
 755     s = HUFF_EXTEND(r, s);
 756       }
 757 
 758       /* Convert DC difference to actual value, update last_dc_val */
 759       s += state.last_dc_val[ci];
 760       state.last_dc_val[ci] = s;
 761       /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
 762       (*block)[0] = (JCOEF) (s &lt;&lt; Al);
 763     }
 764 
 765     /* Completed MCU, so update state */
<span class="line-modified"> 766     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
 767     ASSIGN_STATE(entropy-&gt;saved, state);
 768   }
 769 
<span class="line-modified"> 770   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified"> 771   entropy-&gt;restarts_to_go--;</span>

 772 
 773   return TRUE;
 774 }
 775 
 776 
 777 /*
 778  * MCU decoding for AC initial scan (either spectral selection,
 779  * or first pass of successive approximation).
 780  */
 781 
 782 METHODDEF(boolean)
 783 decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 784 {
 785   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 786   register int s, k, r;
 787   unsigned int EOBRUN;
 788   int Se, Al;
 789   const int * natural_order;
 790   JBLOCKROW block;
 791   BITREAD_STATE_VARS;
</pre>
<hr />
<pre>
 796     if (entropy-&gt;restarts_to_go == 0)
 797       if (! process_restart(cinfo))
 798     return FALSE;
 799   }
 800 
 801   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
 802    * This way, we return uniform gray for the remainder of the segment.
 803    */
 804   if (! entropy-&gt;insufficient_data) {
 805 
 806     /* Load up working state.
 807      * We can avoid loading/saving bitread state if in an EOB run.
 808      */
 809     EOBRUN = entropy-&gt;saved.EOBRUN;    /* only part of saved state we need */
 810 
 811     /* There is always only one block per MCU */
 812 
 813     if (EOBRUN)            /* if it&#39;s a band of zeroes... */
 814       EOBRUN--;            /* ...process it now (we do nothing) */
 815     else {
<span class="line-modified"> 816       BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 817       Se = cinfo-&gt;Se;
 818       Al = cinfo-&gt;Al;
 819       natural_order = cinfo-&gt;natural_order;
 820       block = MCU_data[0];
 821       tbl = entropy-&gt;ac_derived_tbl;
 822 
 823       for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 824     HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
 825     r = s &gt;&gt; 4;
 826     s &amp;= 15;
 827     if (s) {
 828       k += r;
 829       CHECK_BIT_BUFFER(br_state, s, return FALSE);
 830       r = GET_BITS(s);
 831       s = HUFF_EXTEND(r, s);
 832       /* Scale and output coefficient in natural (dezigzagged) order */
 833       (*block)[natural_order[k]] = (JCOEF) (s &lt;&lt; Al);
 834     } else {
 835       if (r != 15) {    /* EOBr, run length is 2^r + appended bits */
 836         if (r) {        /* EOBr, r &gt; 0 */
 837           EOBRUN = 1 &lt;&lt; r;
 838           CHECK_BIT_BUFFER(br_state, r, return FALSE);
 839           r = GET_BITS(r);
 840           EOBRUN += r;
 841           EOBRUN--;        /* this band is processed at this moment */
 842         }
 843         break;        /* force end-of-band */
 844       }
 845       k += 15;        /* ZRL: skip 15 zeroes in band */
 846     }
 847       }
 848 
<span class="line-modified"> 849       BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
 850     }
 851 
 852     /* Completed MCU, so update state */
 853     entropy-&gt;saved.EOBRUN = EOBRUN;    /* only part of saved state we need */
 854   }
 855 
<span class="line-modified"> 856   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified"> 857   entropy-&gt;restarts_to_go--;</span>

 858 
 859   return TRUE;
 860 }
 861 
 862 
 863 /*
 864  * MCU decoding for DC successive approximation refinement scan.
 865  * Note: we assume such scans can be multi-component,
 866  * although the spec is not very clear on the point.
 867  */
 868 
 869 METHODDEF(boolean)
 870 decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 871 {
 872   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
<span class="line-modified"> 873   int p1, blkn;</span>

 874   BITREAD_STATE_VARS;
 875 
 876   /* Process restart marker if needed; may have to suspend */
 877   if (cinfo-&gt;restart_interval) {
 878     if (entropy-&gt;restarts_to_go == 0)
 879       if (! process_restart(cinfo))
 880     return FALSE;
 881   }
 882 
 883   /* Not worth the cycles to check insufficient_data here,
 884    * since we will not change the data anyway if we read zeroes.
 885    */
 886 
 887   /* Load up working state */
<span class="line-modified"> 888   BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 889 
 890   p1 = 1 &lt;&lt; cinfo-&gt;Al;        /* 1 in the bit position being coded */
 891 
 892   /* Outer loop handles each block in the MCU */
 893 
 894   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 895     /* Encoded data is simply the next bit of the two&#39;s-complement DC value */
 896     CHECK_BIT_BUFFER(br_state, 1, return FALSE);
 897     if (GET_BITS(1))
 898       MCU_data[blkn][0][0] |= p1;
 899     /* Note: since we use |=, repeating the assignment later is safe */
 900   }
 901 
 902   /* Completed MCU, so update state */
<span class="line-modified"> 903   BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
 904 
<span class="line-modified"> 905   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified"> 906   entropy-&gt;restarts_to_go--;</span>

 907 
 908   return TRUE;
 909 }
 910 
 911 
 912 /*
 913  * MCU decoding for AC successive approximation refinement scan.
 914  */
 915 
 916 METHODDEF(boolean)
 917 decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 918 {
 919   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 920   register int s, k, r;
 921   unsigned int EOBRUN;
<span class="line-modified"> 922   int Se, p1, m1;</span>

 923   const int * natural_order;
 924   JBLOCKROW block;
 925   JCOEFPTR thiscoef;
 926   BITREAD_STATE_VARS;
 927   d_derived_tbl * tbl;
 928   int num_newnz;
 929   int newnz_pos[DCTSIZE2];
 930 
 931   /* Process restart marker if needed; may have to suspend */
 932   if (cinfo-&gt;restart_interval) {
 933     if (entropy-&gt;restarts_to_go == 0)
 934       if (! process_restart(cinfo))
 935     return FALSE;
 936   }
 937 
 938   /* If we&#39;ve run out of data, don&#39;t modify the MCU.
 939    */
 940   if (! entropy-&gt;insufficient_data) {
 941 
 942     Se = cinfo-&gt;Se;
 943     p1 = 1 &lt;&lt; cinfo-&gt;Al;    /* 1 in the bit position being coded */
<span class="line-modified"> 944     m1 = (-1) &lt;&lt; cinfo-&gt;Al;    /* -1 in the bit position being coded */</span>
 945     natural_order = cinfo-&gt;natural_order;
 946 
 947     /* Load up working state */
<span class="line-modified"> 948     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 949     EOBRUN = entropy-&gt;saved.EOBRUN; /* only part of saved state we need */
 950 
 951     /* There is always only one block per MCU */
 952     block = MCU_data[0];
 953     tbl = entropy-&gt;ac_derived_tbl;
 954 
 955     /* If we are forced to suspend, we must undo the assignments to any newly
 956      * nonzero coefficients in the block, because otherwise we&#39;d get confused
 957      * next time about which coefficients were already nonzero.
 958      * But we need not undo addition of bits to already-nonzero coefficients;
 959      * instead, we can test the current bit to see if we already did it.
 960      */
 961     num_newnz = 0;
 962 
 963     /* initialize coefficient loop counter to start of band */
 964     k = cinfo-&gt;Ss;
 965 
 966     if (EOBRUN == 0) {
 967       do {
 968     HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
</pre>
<hr />
<pre>
1030       do {
1031     thiscoef = *block + natural_order[k];
1032     if (*thiscoef) {
1033       CHECK_BIT_BUFFER(br_state, 1, goto undoit);
1034       if (GET_BITS(1)) {
1035         if ((*thiscoef &amp; p1) == 0) { /* do nothing if already changed it */
1036           if (*thiscoef &gt;= 0)
1037         *thiscoef += p1;
1038           else
1039         *thiscoef += m1;
1040         }
1041       }
1042     }
1043     k++;
1044       } while (k &lt;= Se);
1045       /* Count one block completed in EOB run */
1046       EOBRUN--;
1047     }
1048 
1049     /* Completed MCU, so update state */
<span class="line-modified">1050     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
1051     entropy-&gt;saved.EOBRUN = EOBRUN; /* only part of saved state we need */
1052   }
1053 
<span class="line-modified">1054   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified">1055   entropy-&gt;restarts_to_go--;</span>

1056 
1057   return TRUE;
1058 
1059 undoit:
1060   /* Re-zero any output coefficients that we made newly nonzero */
1061   while (num_newnz)
1062     (*block)[newnz_pos[--num_newnz]] = 0;
1063 
1064   return FALSE;
1065 }
1066 
1067 
1068 /*
1069  * Decode one MCU&#39;s worth of Huffman-compressed coefficients,
1070  * partial blocks.
1071  */
1072 
1073 METHODDEF(boolean)
1074 decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
1075 {
</pre>
<hr />
<pre>
1078   int Se, blkn;
1079   BITREAD_STATE_VARS;
1080   savable_state state;
1081 
1082   /* Process restart marker if needed; may have to suspend */
1083   if (cinfo-&gt;restart_interval) {
1084     if (entropy-&gt;restarts_to_go == 0)
1085       if (! process_restart(cinfo))
1086     return FALSE;
1087   }
1088 
1089   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
1090    * This way, we return uniform gray for the remainder of the segment.
1091    */
1092   if (! entropy-&gt;insufficient_data) {
1093 
1094     natural_order = cinfo-&gt;natural_order;
1095     Se = cinfo-&gt;lim_Se;
1096 
1097     /* Load up working state */
<span class="line-modified">1098     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
1099     ASSIGN_STATE(state, entropy-&gt;saved);
1100 
1101     /* Outer loop handles each block in the MCU */
1102 
1103     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1104       JBLOCKROW block = MCU_data[blkn];
1105       d_derived_tbl * htbl;
1106       register int s, k, r;
1107       int coef_limit, ci;
1108 
1109       /* Decode a single block&#39;s worth of coefficients */
1110 
1111       /* Section F.2.2.1: decode the DC coefficient difference */
1112       htbl = entropy-&gt;dc_cur_tbls[blkn];
1113       HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
1114 
1115       htbl = entropy-&gt;ac_cur_tbls[blkn];
1116       k = 1;
1117       coef_limit = entropy-&gt;coef_limit[blkn];
1118       if (coef_limit) {
</pre>
<hr />
<pre>
1165     HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
1166 
1167     r = s &gt;&gt; 4;
1168     s &amp;= 15;
1169 
1170     if (s) {
1171       k += r;
1172       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1173       DROP_BITS(s);
1174     } else {
1175       if (r != 15)
1176         break;
1177       k += 15;
1178     }
1179       }
1180 
1181       EndOfBlock: ;
1182     }
1183 
1184     /* Completed MCU, so update state */
<span class="line-modified">1185     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
1186     ASSIGN_STATE(entropy-&gt;saved, state);
1187   }
1188 
<span class="line-modified">1189   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified">1190   entropy-&gt;restarts_to_go--;</span>

1191 
1192   return TRUE;
1193 }
1194 
1195 
1196 /*
1197  * Decode one MCU&#39;s worth of Huffman-compressed coefficients,
1198  * full-size blocks.
1199  */
1200 
1201 METHODDEF(boolean)
1202 decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
1203 {
1204   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1205   int blkn;
1206   BITREAD_STATE_VARS;
1207   savable_state state;
1208 
1209   /* Process restart marker if needed; may have to suspend */
1210   if (cinfo-&gt;restart_interval) {
1211     if (entropy-&gt;restarts_to_go == 0)
1212       if (! process_restart(cinfo))
1213     return FALSE;
1214   }
1215 
1216   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
1217    * This way, we return uniform gray for the remainder of the segment.
1218    */
1219   if (! entropy-&gt;insufficient_data) {
1220 
1221     /* Load up working state */
<span class="line-modified">1222     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
1223     ASSIGN_STATE(state, entropy-&gt;saved);
1224 
1225     /* Outer loop handles each block in the MCU */
1226 
1227     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1228       JBLOCKROW block = MCU_data[blkn];
1229       d_derived_tbl * htbl;
1230       register int s, k, r;
1231       int coef_limit, ci;
1232 
1233       /* Decode a single block&#39;s worth of coefficients */
1234 
1235       /* Section F.2.2.1: decode the DC coefficient difference */
1236       htbl = entropy-&gt;dc_cur_tbls[blkn];
1237       HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
1238 
1239       htbl = entropy-&gt;ac_cur_tbls[blkn];
1240       k = 1;
1241       coef_limit = entropy-&gt;coef_limit[blkn];
1242       if (coef_limit) {
</pre>
<hr />
<pre>
1289     HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
1290 
1291     r = s &gt;&gt; 4;
1292     s &amp;= 15;
1293 
1294     if (s) {
1295       k += r;
1296       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1297       DROP_BITS(s);
1298     } else {
1299       if (r != 15)
1300         break;
1301       k += 15;
1302     }
1303       }
1304 
1305       EndOfBlock: ;
1306     }
1307 
1308     /* Completed MCU, so update state */
<span class="line-modified">1309     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
1310     ASSIGN_STATE(entropy-&gt;saved, state);
1311   }
1312 
<span class="line-modified">1313   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified">1314   entropy-&gt;restarts_to_go--;</span>

1315 
1316   return TRUE;
1317 }
1318 
1319 
1320 /*
1321  * Initialize for a Huffman-compressed scan.
1322  */
1323 
1324 METHODDEF(void)
1325 start_pass_huff_decoder (j_decompress_ptr cinfo)
1326 {
1327   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1328   int ci, blkn, tbl, i;
1329   jpeg_component_info * compptr;
1330 
1331   if (cinfo-&gt;progressive_mode) {
1332     /* Validate progressive scan parameters */
1333     if (cinfo-&gt;Ss == 0) {
1334       if (cinfo-&gt;Se != 0)
1335     goto bad;
1336     } else {
1337       /* need not check Ss/Se &lt; 0 since they came from unsigned bytes */
1338       if (cinfo-&gt;Se &lt; cinfo-&gt;Ss || cinfo-&gt;Se &gt; cinfo-&gt;lim_Se)
1339     goto bad;
1340       /* AC scans may have only one component */
1341       if (cinfo-&gt;comps_in_scan != 1)
1342     goto bad;
1343     }
1344     if (cinfo-&gt;Ah != 0) {
1345       /* Successive approximation refinement scan: must have Al = Ah-1. */
1346       if (cinfo-&gt;Ah-1 != cinfo-&gt;Al)
1347     goto bad;
1348     }
1349     if (cinfo-&gt;Al &gt; 13) {    /* need not check for &lt; 0 */
<span class="line-modified">1350       /* Arguably the maximum Al value should be less than 13 for 8-bit precision,</span>
<span class="line-modified">1351        * but the spec doesn&#39;t say so, and we try to be liberal about what we</span>
<span class="line-modified">1352        * accept.  Note: large Al values could result in out-of-range DC</span>
<span class="line-modified">1353        * coefficients during early scans, leading to bizarre displays due to</span>
<span class="line-modified">1354        * overflows in the IDCT math.  But we won&#39;t crash.</span>
1355        */
1356       bad:
1357       ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
1358            cinfo-&gt;Ss, cinfo-&gt;Se, cinfo-&gt;Ah, cinfo-&gt;Al);
1359     }
1360     /* Update progression status, and verify that scan order is legal.
1361      * Note that inter-scan inconsistencies are treated as warnings
1362      * not fatal errors ... not clear if this is right way to behave.
1363      */
1364     for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1365       int coefi, cindex = cinfo-&gt;cur_comp_info[ci]-&gt;component_index;
1366       int *coef_bit_ptr = &amp; cinfo-&gt;coef_bits[cindex][0];
1367       if (cinfo-&gt;Ss &amp;&amp; coef_bit_ptr[0] &lt; 0) /* AC without prior DC scan */
1368     WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
1369       for (coefi = cinfo-&gt;Ss; coefi &lt;= cinfo-&gt;Se; coefi++) {
1370     int expected = (coef_bit_ptr[coefi] &lt; 0) ? 0 : coef_bit_ptr[coefi];
1371     if (cinfo-&gt;Ah != expected)
1372       WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
1373     coef_bit_ptr[coefi] = cinfo-&gt;Al;
1374       }
</pre>
<hr />
<pre>
1438       /* Compute derived values for Huffman tables */
1439       /* We may do this more than once for a table, but it&#39;s not expensive */
1440       tbl = compptr-&gt;dc_tbl_no;
1441       jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
1442                   &amp; entropy-&gt;dc_derived_tbls[tbl]);
1443       if (cinfo-&gt;lim_Se) {    /* AC needs no table when not present */
1444     tbl = compptr-&gt;ac_tbl_no;
1445     jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
1446                 &amp; entropy-&gt;ac_derived_tbls[tbl]);
1447       }
1448       /* Initialize DC predictions to 0 */
1449       entropy-&gt;saved.last_dc_val[ci] = 0;
1450     }
1451 
1452     /* Precalculate decoding info for each block in an MCU of this scan */
1453     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1454       ci = cinfo-&gt;MCU_membership[blkn];
1455       compptr = cinfo-&gt;cur_comp_info[ci];
1456       /* Precalculate which table to use for each block */
1457       entropy-&gt;dc_cur_tbls[blkn] = entropy-&gt;dc_derived_tbls[compptr-&gt;dc_tbl_no];
<span class="line-modified">1458       entropy-&gt;ac_cur_tbls[blkn] = entropy-&gt;ac_derived_tbls[compptr-&gt;ac_tbl_no];</span>

1459       /* Decide whether we really care about the coefficient values */
1460       if (compptr-&gt;component_needed) {
1461     ci = compptr-&gt;DCT_v_scaled_size;
1462     i = compptr-&gt;DCT_h_scaled_size;
1463     switch (cinfo-&gt;lim_Se) {
1464     case (1*1-1):
1465       entropy-&gt;coef_limit[blkn] = 1;
1466       break;
1467     case (2*2-1):
1468       if (ci &lt;= 0 || ci &gt; 2) ci = 2;
1469       if (i &lt;= 0 || i &gt; 2) i = 2;
1470       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
1471       break;
1472     case (3*3-1):
1473       if (ci &lt;= 0 || ci &gt; 3) ci = 3;
1474       if (i &lt;= 0 || i &gt; 3) i = 3;
1475       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
1476       break;
1477     case (4*4-1):
1478       if (ci &lt;= 0 || ci &gt; 4) ci = 4;
</pre>
<hr />
<pre>
1481       break;
1482     case (5*5-1):
1483       if (ci &lt;= 0 || ci &gt; 5) ci = 5;
1484       if (i &lt;= 0 || i &gt; 5) i = 5;
1485       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
1486       break;
1487     case (6*6-1):
1488       if (ci &lt;= 0 || ci &gt; 6) ci = 6;
1489       if (i &lt;= 0 || i &gt; 6) i = 6;
1490       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
1491       break;
1492     case (7*7-1):
1493       if (ci &lt;= 0 || ci &gt; 7) ci = 7;
1494       if (i &lt;= 0 || i &gt; 7) i = 7;
1495       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
1496       break;
1497     default:
1498       if (ci &lt;= 0 || ci &gt; 8) ci = 8;
1499       if (i &lt;= 0 || i &gt; 8) i = 8;
1500       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
<span class="line-removed">1501       break;</span>
1502     }
1503       } else {
1504     entropy-&gt;coef_limit[blkn] = 0;
1505       }
1506     }
1507   }
1508 
1509   /* Initialize bitread state variables */
1510   entropy-&gt;bitstate.bits_left = 0;
1511   entropy-&gt;bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
1512   entropy-&gt;insufficient_data = FALSE;
1513 
1514   /* Initialize restart counter */
1515   entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1516 }
1517 
1518 
1519 /*
1520  * Module initialization routine for Huffman entropy decoding.
1521  */
1522 
1523 GLOBAL(void)
1524 jinit_huff_decoder (j_decompress_ptr cinfo)
1525 {
1526   huff_entropy_ptr entropy;
1527   int i;
1528 
<span class="line-modified">1529   entropy = (huff_entropy_ptr)</span>
<span class="line-modified">1530     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">1531                 SIZEOF(huff_entropy_decoder));</span>
1532   cinfo-&gt;entropy = &amp;entropy-&gt;pub;
1533   entropy-&gt;pub.start_pass = start_pass_huff_decoder;
1534   entropy-&gt;pub.finish_pass = finish_pass_huff;
1535 
1536   if (cinfo-&gt;progressive_mode) {
1537     /* Create progression status table */
1538     int *coef_bit_ptr, ci;
<span class="line-modified">1539     cinfo-&gt;coef_bits = (int (*)[DCTSIZE2])</span>
<span class="line-modified">1540       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">1541                   cinfo-&gt;num_components*DCTSIZE2*SIZEOF(int));</span>
1542     coef_bit_ptr = &amp; cinfo-&gt;coef_bits[0][0];
1543     for (ci = 0; ci &lt; cinfo-&gt;num_components; ci++)
1544       for (i = 0; i &lt; DCTSIZE2; i++)
1545     *coef_bit_ptr++ = -1;
1546 
1547     /* Mark derived tables unallocated */
1548     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1549       entropy-&gt;derived_tbls[i] = NULL;
1550     }
1551   } else {
<span class="line-modified">1552     /* Mark tables unallocated */</span>
1553     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1554       entropy-&gt;dc_derived_tbls[i] = entropy-&gt;ac_derived_tbls[i] = NULL;
1555     }
1556   }
1557 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * jdhuff.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="line-modified">   5  * Modified 2006-2019 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains Huffman entropy decoding routines.
  10  * Both sequential and progressive modes are supported in this single module.
  11  *
  12  * Much of the complexity here has to do with supporting input suspension.
  13  * If the data source module demands suspension, we want to be able to back
  14  * up to the start of the current MCU.  To do this, we copy state variables
  15  * into local working storage, and update them back to the permanent
  16  * storage only upon successful completion of an MCU.
  17  */
  18 
  19 #define JPEG_INTERNALS
  20 #include &quot;jinclude.h&quot;
  21 #include &quot;jpeglib.h&quot;
  22 
  23 
  24 /* Derived data constructed for each Huffman table */
  25 
</pre>
<hr />
<pre>
 326   JHUFF_TBL *htbl;
 327   d_derived_tbl *dtbl;
 328   int p, i, l, si, numsymbols;
 329   int lookbits, ctr;
 330   char huffsize[257];
 331   unsigned int huffcode[257];
 332   unsigned int code;
 333 
 334   MEMZERO(huffsize, SIZEOF(huffsize));
 335   MEMZERO(huffcode, SIZEOF(huffcode));
 336   /* Note that huffsize[] and huffcode[] are filled in code-length order,
 337    * paralleling the order of the symbols themselves in htbl-&gt;huffval[].
 338    */
 339 
 340   /* Find the input Huffman table */
 341   if (tblno &lt; 0 || tblno &gt;= NUM_HUFF_TBLS)
 342     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 343   htbl =
 344     isDC ? cinfo-&gt;dc_huff_tbl_ptrs[tblno] : cinfo-&gt;ac_huff_tbl_ptrs[tblno];
 345   if (htbl == NULL)
<span class="line-modified"> 346     htbl = jpeg_std_huff_table((j_common_ptr) cinfo, isDC, tblno);</span>
 347 
 348   /* Allocate a workspace if we haven&#39;t already done so. */
 349   if (*pdtbl == NULL)
<span class="line-modified"> 350     *pdtbl = (d_derived_tbl *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified"> 351       ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(d_derived_tbl));</span>

 352   dtbl = *pdtbl;
 353   dtbl-&gt;pub = htbl;        /* fill in back link */
 354 
 355   /* Figure C.1: make table of Huffman code length for each symbol */
 356 
 357   p = 0;
 358   for (l = 1; l &lt;= 16; l++) {
 359     i = (int) htbl-&gt;bits[l];
 360     if (i &lt; 0 || p + i &gt; 256)    /* protect against table overrun */
 361       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 362     while (i--)
 363       huffsize[p++] = (char) l;
 364   }
 365   huffsize[p] = 0;
 366   numsymbols = p;
 367 
 368   /* Figure C.2: generate the codes themselves */
 369   /* We also validate that the counts represent a legal Huffman code tree. */
 370 
 371   code = 0;
</pre>
<hr />
<pre>
 716   int blkn, ci;
 717   JBLOCKROW block;
 718   BITREAD_STATE_VARS;
 719   savable_state state;
 720   d_derived_tbl * tbl;
 721   jpeg_component_info * compptr;
 722 
 723   /* Process restart marker if needed; may have to suspend */
 724   if (cinfo-&gt;restart_interval) {
 725     if (entropy-&gt;restarts_to_go == 0)
 726       if (! process_restart(cinfo))
 727     return FALSE;
 728   }
 729 
 730   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
 731    * This way, we return uniform gray for the remainder of the segment.
 732    */
 733   if (! entropy-&gt;insufficient_data) {
 734 
 735     /* Load up working state */
<span class="line-modified"> 736     BITREAD_LOAD_STATE(cinfo, entropy-&gt;bitstate);</span>
 737     ASSIGN_STATE(state, entropy-&gt;saved);
 738 
 739     /* Outer loop handles each block in the MCU */
 740 
 741     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 742       block = MCU_data[blkn];
 743       ci = cinfo-&gt;MCU_membership[blkn];
 744       compptr = cinfo-&gt;cur_comp_info[ci];
 745       tbl = entropy-&gt;derived_tbls[compptr-&gt;dc_tbl_no];
 746 
 747       /* Decode a single block&#39;s worth of coefficients */
 748 
 749       /* Section F.2.2.1: decode the DC coefficient difference */
 750       HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
 751       if (s) {
 752     CHECK_BIT_BUFFER(br_state, s, return FALSE);
 753     r = GET_BITS(s);
 754     s = HUFF_EXTEND(r, s);
 755       }
 756 
 757       /* Convert DC difference to actual value, update last_dc_val */
 758       s += state.last_dc_val[ci];
 759       state.last_dc_val[ci] = s;
 760       /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
 761       (*block)[0] = (JCOEF) (s &lt;&lt; Al);
 762     }
 763 
 764     /* Completed MCU, so update state */
<span class="line-modified"> 765     BITREAD_SAVE_STATE(cinfo, entropy-&gt;bitstate);</span>
 766     ASSIGN_STATE(entropy-&gt;saved, state);
 767   }
 768 
<span class="line-modified"> 769   /* Account for restart interval if using restarts */</span>
<span class="line-modified"> 770   if (cinfo-&gt;restart_interval)</span>
<span class="line-added"> 771     entropy-&gt;restarts_to_go--;</span>
 772 
 773   return TRUE;
 774 }
 775 
 776 
 777 /*
 778  * MCU decoding for AC initial scan (either spectral selection,
 779  * or first pass of successive approximation).
 780  */
 781 
 782 METHODDEF(boolean)
 783 decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 784 {
 785   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 786   register int s, k, r;
 787   unsigned int EOBRUN;
 788   int Se, Al;
 789   const int * natural_order;
 790   JBLOCKROW block;
 791   BITREAD_STATE_VARS;
</pre>
<hr />
<pre>
 796     if (entropy-&gt;restarts_to_go == 0)
 797       if (! process_restart(cinfo))
 798     return FALSE;
 799   }
 800 
 801   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
 802    * This way, we return uniform gray for the remainder of the segment.
 803    */
 804   if (! entropy-&gt;insufficient_data) {
 805 
 806     /* Load up working state.
 807      * We can avoid loading/saving bitread state if in an EOB run.
 808      */
 809     EOBRUN = entropy-&gt;saved.EOBRUN;    /* only part of saved state we need */
 810 
 811     /* There is always only one block per MCU */
 812 
 813     if (EOBRUN)            /* if it&#39;s a band of zeroes... */
 814       EOBRUN--;            /* ...process it now (we do nothing) */
 815     else {
<span class="line-modified"> 816       BITREAD_LOAD_STATE(cinfo, entropy-&gt;bitstate);</span>
 817       Se = cinfo-&gt;Se;
 818       Al = cinfo-&gt;Al;
 819       natural_order = cinfo-&gt;natural_order;
 820       block = MCU_data[0];
 821       tbl = entropy-&gt;ac_derived_tbl;
 822 
 823       for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 824     HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
 825     r = s &gt;&gt; 4;
 826     s &amp;= 15;
 827     if (s) {
 828       k += r;
 829       CHECK_BIT_BUFFER(br_state, s, return FALSE);
 830       r = GET_BITS(s);
 831       s = HUFF_EXTEND(r, s);
 832       /* Scale and output coefficient in natural (dezigzagged) order */
 833       (*block)[natural_order[k]] = (JCOEF) (s &lt;&lt; Al);
 834     } else {
 835       if (r != 15) {    /* EOBr, run length is 2^r + appended bits */
 836         if (r) {        /* EOBr, r &gt; 0 */
 837           EOBRUN = 1 &lt;&lt; r;
 838           CHECK_BIT_BUFFER(br_state, r, return FALSE);
 839           r = GET_BITS(r);
 840           EOBRUN += r;
 841           EOBRUN--;        /* this band is processed at this moment */
 842         }
 843         break;        /* force end-of-band */
 844       }
 845       k += 15;        /* ZRL: skip 15 zeroes in band */
 846     }
 847       }
 848 
<span class="line-modified"> 849       BITREAD_SAVE_STATE(cinfo, entropy-&gt;bitstate);</span>
 850     }
 851 
 852     /* Completed MCU, so update state */
 853     entropy-&gt;saved.EOBRUN = EOBRUN;    /* only part of saved state we need */
 854   }
 855 
<span class="line-modified"> 856   /* Account for restart interval if using restarts */</span>
<span class="line-modified"> 857   if (cinfo-&gt;restart_interval)</span>
<span class="line-added"> 858     entropy-&gt;restarts_to_go--;</span>
 859 
 860   return TRUE;
 861 }
 862 
 863 
 864 /*
 865  * MCU decoding for DC successive approximation refinement scan.
 866  * Note: we assume such scans can be multi-component,
 867  * although the spec is not very clear on the point.
 868  */
 869 
 870 METHODDEF(boolean)
 871 decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 872 {
 873   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
<span class="line-modified"> 874   JCOEF p1;</span>
<span class="line-added"> 875   int blkn;</span>
 876   BITREAD_STATE_VARS;
 877 
 878   /* Process restart marker if needed; may have to suspend */
 879   if (cinfo-&gt;restart_interval) {
 880     if (entropy-&gt;restarts_to_go == 0)
 881       if (! process_restart(cinfo))
 882     return FALSE;
 883   }
 884 
 885   /* Not worth the cycles to check insufficient_data here,
 886    * since we will not change the data anyway if we read zeroes.
 887    */
 888 
 889   /* Load up working state */
<span class="line-modified"> 890   BITREAD_LOAD_STATE(cinfo, entropy-&gt;bitstate);</span>
 891 
 892   p1 = 1 &lt;&lt; cinfo-&gt;Al;        /* 1 in the bit position being coded */
 893 
 894   /* Outer loop handles each block in the MCU */
 895 
 896   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 897     /* Encoded data is simply the next bit of the two&#39;s-complement DC value */
 898     CHECK_BIT_BUFFER(br_state, 1, return FALSE);
 899     if (GET_BITS(1))
 900       MCU_data[blkn][0][0] |= p1;
 901     /* Note: since we use |=, repeating the assignment later is safe */
 902   }
 903 
 904   /* Completed MCU, so update state */
<span class="line-modified"> 905   BITREAD_SAVE_STATE(cinfo, entropy-&gt;bitstate);</span>
 906 
<span class="line-modified"> 907   /* Account for restart interval if using restarts */</span>
<span class="line-modified"> 908   if (cinfo-&gt;restart_interval)</span>
<span class="line-added"> 909     entropy-&gt;restarts_to_go--;</span>
 910 
 911   return TRUE;
 912 }
 913 
 914 
 915 /*
 916  * MCU decoding for AC successive approximation refinement scan.
 917  */
 918 
 919 METHODDEF(boolean)
 920 decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 921 {
 922   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 923   register int s, k, r;
 924   unsigned int EOBRUN;
<span class="line-modified"> 925   int Se;</span>
<span class="line-added"> 926   JCOEF p1, m1;</span>
 927   const int * natural_order;
 928   JBLOCKROW block;
 929   JCOEFPTR thiscoef;
 930   BITREAD_STATE_VARS;
 931   d_derived_tbl * tbl;
 932   int num_newnz;
 933   int newnz_pos[DCTSIZE2];
 934 
 935   /* Process restart marker if needed; may have to suspend */
 936   if (cinfo-&gt;restart_interval) {
 937     if (entropy-&gt;restarts_to_go == 0)
 938       if (! process_restart(cinfo))
 939     return FALSE;
 940   }
 941 
 942   /* If we&#39;ve run out of data, don&#39;t modify the MCU.
 943    */
 944   if (! entropy-&gt;insufficient_data) {
 945 
 946     Se = cinfo-&gt;Se;
 947     p1 = 1 &lt;&lt; cinfo-&gt;Al;    /* 1 in the bit position being coded */
<span class="line-modified"> 948     m1 = -p1;            /* -1 in the bit position being coded */</span>
 949     natural_order = cinfo-&gt;natural_order;
 950 
 951     /* Load up working state */
<span class="line-modified"> 952     BITREAD_LOAD_STATE(cinfo, entropy-&gt;bitstate);</span>
 953     EOBRUN = entropy-&gt;saved.EOBRUN; /* only part of saved state we need */
 954 
 955     /* There is always only one block per MCU */
 956     block = MCU_data[0];
 957     tbl = entropy-&gt;ac_derived_tbl;
 958 
 959     /* If we are forced to suspend, we must undo the assignments to any newly
 960      * nonzero coefficients in the block, because otherwise we&#39;d get confused
 961      * next time about which coefficients were already nonzero.
 962      * But we need not undo addition of bits to already-nonzero coefficients;
 963      * instead, we can test the current bit to see if we already did it.
 964      */
 965     num_newnz = 0;
 966 
 967     /* initialize coefficient loop counter to start of band */
 968     k = cinfo-&gt;Ss;
 969 
 970     if (EOBRUN == 0) {
 971       do {
 972     HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
</pre>
<hr />
<pre>
1034       do {
1035     thiscoef = *block + natural_order[k];
1036     if (*thiscoef) {
1037       CHECK_BIT_BUFFER(br_state, 1, goto undoit);
1038       if (GET_BITS(1)) {
1039         if ((*thiscoef &amp; p1) == 0) { /* do nothing if already changed it */
1040           if (*thiscoef &gt;= 0)
1041         *thiscoef += p1;
1042           else
1043         *thiscoef += m1;
1044         }
1045       }
1046     }
1047     k++;
1048       } while (k &lt;= Se);
1049       /* Count one block completed in EOB run */
1050       EOBRUN--;
1051     }
1052 
1053     /* Completed MCU, so update state */
<span class="line-modified">1054     BITREAD_SAVE_STATE(cinfo, entropy-&gt;bitstate);</span>
1055     entropy-&gt;saved.EOBRUN = EOBRUN; /* only part of saved state we need */
1056   }
1057 
<span class="line-modified">1058   /* Account for restart interval if using restarts */</span>
<span class="line-modified">1059   if (cinfo-&gt;restart_interval)</span>
<span class="line-added">1060     entropy-&gt;restarts_to_go--;</span>
1061 
1062   return TRUE;
1063 
1064 undoit:
1065   /* Re-zero any output coefficients that we made newly nonzero */
1066   while (num_newnz)
1067     (*block)[newnz_pos[--num_newnz]] = 0;
1068 
1069   return FALSE;
1070 }
1071 
1072 
1073 /*
1074  * Decode one MCU&#39;s worth of Huffman-compressed coefficients,
1075  * partial blocks.
1076  */
1077 
1078 METHODDEF(boolean)
1079 decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
1080 {
</pre>
<hr />
<pre>
1083   int Se, blkn;
1084   BITREAD_STATE_VARS;
1085   savable_state state;
1086 
1087   /* Process restart marker if needed; may have to suspend */
1088   if (cinfo-&gt;restart_interval) {
1089     if (entropy-&gt;restarts_to_go == 0)
1090       if (! process_restart(cinfo))
1091     return FALSE;
1092   }
1093 
1094   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
1095    * This way, we return uniform gray for the remainder of the segment.
1096    */
1097   if (! entropy-&gt;insufficient_data) {
1098 
1099     natural_order = cinfo-&gt;natural_order;
1100     Se = cinfo-&gt;lim_Se;
1101 
1102     /* Load up working state */
<span class="line-modified">1103     BITREAD_LOAD_STATE(cinfo, entropy-&gt;bitstate);</span>
1104     ASSIGN_STATE(state, entropy-&gt;saved);
1105 
1106     /* Outer loop handles each block in the MCU */
1107 
1108     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1109       JBLOCKROW block = MCU_data[blkn];
1110       d_derived_tbl * htbl;
1111       register int s, k, r;
1112       int coef_limit, ci;
1113 
1114       /* Decode a single block&#39;s worth of coefficients */
1115 
1116       /* Section F.2.2.1: decode the DC coefficient difference */
1117       htbl = entropy-&gt;dc_cur_tbls[blkn];
1118       HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
1119 
1120       htbl = entropy-&gt;ac_cur_tbls[blkn];
1121       k = 1;
1122       coef_limit = entropy-&gt;coef_limit[blkn];
1123       if (coef_limit) {
</pre>
<hr />
<pre>
1170     HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
1171 
1172     r = s &gt;&gt; 4;
1173     s &amp;= 15;
1174 
1175     if (s) {
1176       k += r;
1177       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1178       DROP_BITS(s);
1179     } else {
1180       if (r != 15)
1181         break;
1182       k += 15;
1183     }
1184       }
1185 
1186       EndOfBlock: ;
1187     }
1188 
1189     /* Completed MCU, so update state */
<span class="line-modified">1190     BITREAD_SAVE_STATE(cinfo, entropy-&gt;bitstate);</span>
1191     ASSIGN_STATE(entropy-&gt;saved, state);
1192   }
1193 
<span class="line-modified">1194   /* Account for restart interval if using restarts */</span>
<span class="line-modified">1195   if (cinfo-&gt;restart_interval)</span>
<span class="line-added">1196     entropy-&gt;restarts_to_go--;</span>
1197 
1198   return TRUE;
1199 }
1200 
1201 
1202 /*
1203  * Decode one MCU&#39;s worth of Huffman-compressed coefficients,
1204  * full-size blocks.
1205  */
1206 
1207 METHODDEF(boolean)
1208 decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
1209 {
1210   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1211   int blkn;
1212   BITREAD_STATE_VARS;
1213   savable_state state;
1214 
1215   /* Process restart marker if needed; may have to suspend */
1216   if (cinfo-&gt;restart_interval) {
1217     if (entropy-&gt;restarts_to_go == 0)
1218       if (! process_restart(cinfo))
1219     return FALSE;
1220   }
1221 
1222   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
1223    * This way, we return uniform gray for the remainder of the segment.
1224    */
1225   if (! entropy-&gt;insufficient_data) {
1226 
1227     /* Load up working state */
<span class="line-modified">1228     BITREAD_LOAD_STATE(cinfo, entropy-&gt;bitstate);</span>
1229     ASSIGN_STATE(state, entropy-&gt;saved);
1230 
1231     /* Outer loop handles each block in the MCU */
1232 
1233     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1234       JBLOCKROW block = MCU_data[blkn];
1235       d_derived_tbl * htbl;
1236       register int s, k, r;
1237       int coef_limit, ci;
1238 
1239       /* Decode a single block&#39;s worth of coefficients */
1240 
1241       /* Section F.2.2.1: decode the DC coefficient difference */
1242       htbl = entropy-&gt;dc_cur_tbls[blkn];
1243       HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
1244 
1245       htbl = entropy-&gt;ac_cur_tbls[blkn];
1246       k = 1;
1247       coef_limit = entropy-&gt;coef_limit[blkn];
1248       if (coef_limit) {
</pre>
<hr />
<pre>
1295     HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
1296 
1297     r = s &gt;&gt; 4;
1298     s &amp;= 15;
1299 
1300     if (s) {
1301       k += r;
1302       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1303       DROP_BITS(s);
1304     } else {
1305       if (r != 15)
1306         break;
1307       k += 15;
1308     }
1309       }
1310 
1311       EndOfBlock: ;
1312     }
1313 
1314     /* Completed MCU, so update state */
<span class="line-modified">1315     BITREAD_SAVE_STATE(cinfo, entropy-&gt;bitstate);</span>
1316     ASSIGN_STATE(entropy-&gt;saved, state);
1317   }
1318 
<span class="line-modified">1319   /* Account for restart interval if using restarts */</span>
<span class="line-modified">1320   if (cinfo-&gt;restart_interval)</span>
<span class="line-added">1321     entropy-&gt;restarts_to_go--;</span>
1322 
1323   return TRUE;
1324 }
1325 
1326 
1327 /*
1328  * Initialize for a Huffman-compressed scan.
1329  */
1330 
1331 METHODDEF(void)
1332 start_pass_huff_decoder (j_decompress_ptr cinfo)
1333 {
1334   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1335   int ci, blkn, tbl, i;
1336   jpeg_component_info * compptr;
1337 
1338   if (cinfo-&gt;progressive_mode) {
1339     /* Validate progressive scan parameters */
1340     if (cinfo-&gt;Ss == 0) {
1341       if (cinfo-&gt;Se != 0)
1342     goto bad;
1343     } else {
1344       /* need not check Ss/Se &lt; 0 since they came from unsigned bytes */
1345       if (cinfo-&gt;Se &lt; cinfo-&gt;Ss || cinfo-&gt;Se &gt; cinfo-&gt;lim_Se)
1346     goto bad;
1347       /* AC scans may have only one component */
1348       if (cinfo-&gt;comps_in_scan != 1)
1349     goto bad;
1350     }
1351     if (cinfo-&gt;Ah != 0) {
1352       /* Successive approximation refinement scan: must have Al = Ah-1. */
1353       if (cinfo-&gt;Ah-1 != cinfo-&gt;Al)
1354     goto bad;
1355     }
1356     if (cinfo-&gt;Al &gt; 13) {    /* need not check for &lt; 0 */
<span class="line-modified">1357       /* Arguably the maximum Al value should be less than 13 for 8-bit</span>
<span class="line-modified">1358        * precision, but the spec doesn&#39;t say so, and we try to be liberal</span>
<span class="line-modified">1359        * about what we accept.  Note: large Al values could result in</span>
<span class="line-modified">1360        * out-of-range DC coefficients during early scans, leading to bizarre</span>
<span class="line-modified">1361        * displays due to overflows in the IDCT math.  But we won&#39;t crash.</span>
1362        */
1363       bad:
1364       ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
1365            cinfo-&gt;Ss, cinfo-&gt;Se, cinfo-&gt;Ah, cinfo-&gt;Al);
1366     }
1367     /* Update progression status, and verify that scan order is legal.
1368      * Note that inter-scan inconsistencies are treated as warnings
1369      * not fatal errors ... not clear if this is right way to behave.
1370      */
1371     for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1372       int coefi, cindex = cinfo-&gt;cur_comp_info[ci]-&gt;component_index;
1373       int *coef_bit_ptr = &amp; cinfo-&gt;coef_bits[cindex][0];
1374       if (cinfo-&gt;Ss &amp;&amp; coef_bit_ptr[0] &lt; 0) /* AC without prior DC scan */
1375     WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
1376       for (coefi = cinfo-&gt;Ss; coefi &lt;= cinfo-&gt;Se; coefi++) {
1377     int expected = (coef_bit_ptr[coefi] &lt; 0) ? 0 : coef_bit_ptr[coefi];
1378     if (cinfo-&gt;Ah != expected)
1379       WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
1380     coef_bit_ptr[coefi] = cinfo-&gt;Al;
1381       }
</pre>
<hr />
<pre>
1445       /* Compute derived values for Huffman tables */
1446       /* We may do this more than once for a table, but it&#39;s not expensive */
1447       tbl = compptr-&gt;dc_tbl_no;
1448       jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
1449                   &amp; entropy-&gt;dc_derived_tbls[tbl]);
1450       if (cinfo-&gt;lim_Se) {    /* AC needs no table when not present */
1451     tbl = compptr-&gt;ac_tbl_no;
1452     jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
1453                 &amp; entropy-&gt;ac_derived_tbls[tbl]);
1454       }
1455       /* Initialize DC predictions to 0 */
1456       entropy-&gt;saved.last_dc_val[ci] = 0;
1457     }
1458 
1459     /* Precalculate decoding info for each block in an MCU of this scan */
1460     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1461       ci = cinfo-&gt;MCU_membership[blkn];
1462       compptr = cinfo-&gt;cur_comp_info[ci];
1463       /* Precalculate which table to use for each block */
1464       entropy-&gt;dc_cur_tbls[blkn] = entropy-&gt;dc_derived_tbls[compptr-&gt;dc_tbl_no];
<span class="line-modified">1465       entropy-&gt;ac_cur_tbls[blkn] =    /* AC needs no table when not present */</span>
<span class="line-added">1466     cinfo-&gt;lim_Se ? entropy-&gt;ac_derived_tbls[compptr-&gt;ac_tbl_no] : NULL;</span>
1467       /* Decide whether we really care about the coefficient values */
1468       if (compptr-&gt;component_needed) {
1469     ci = compptr-&gt;DCT_v_scaled_size;
1470     i = compptr-&gt;DCT_h_scaled_size;
1471     switch (cinfo-&gt;lim_Se) {
1472     case (1*1-1):
1473       entropy-&gt;coef_limit[blkn] = 1;
1474       break;
1475     case (2*2-1):
1476       if (ci &lt;= 0 || ci &gt; 2) ci = 2;
1477       if (i &lt;= 0 || i &gt; 2) i = 2;
1478       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
1479       break;
1480     case (3*3-1):
1481       if (ci &lt;= 0 || ci &gt; 3) ci = 3;
1482       if (i &lt;= 0 || i &gt; 3) i = 3;
1483       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
1484       break;
1485     case (4*4-1):
1486       if (ci &lt;= 0 || ci &gt; 4) ci = 4;
</pre>
<hr />
<pre>
1489       break;
1490     case (5*5-1):
1491       if (ci &lt;= 0 || ci &gt; 5) ci = 5;
1492       if (i &lt;= 0 || i &gt; 5) i = 5;
1493       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
1494       break;
1495     case (6*6-1):
1496       if (ci &lt;= 0 || ci &gt; 6) ci = 6;
1497       if (i &lt;= 0 || i &gt; 6) i = 6;
1498       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
1499       break;
1500     case (7*7-1):
1501       if (ci &lt;= 0 || ci &gt; 7) ci = 7;
1502       if (i &lt;= 0 || i &gt; 7) i = 7;
1503       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
1504       break;
1505     default:
1506       if (ci &lt;= 0 || ci &gt; 8) ci = 8;
1507       if (i &lt;= 0 || i &gt; 8) i = 8;
1508       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];

1509     }
1510       } else {
1511     entropy-&gt;coef_limit[blkn] = 0;
1512       }
1513     }
1514   }
1515 
1516   /* Initialize bitread state variables */
1517   entropy-&gt;bitstate.bits_left = 0;
1518   entropy-&gt;bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
1519   entropy-&gt;insufficient_data = FALSE;
1520 
1521   /* Initialize restart counter */
1522   entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1523 }
1524 
1525 
1526 /*
1527  * Module initialization routine for Huffman entropy decoding.
1528  */
1529 
1530 GLOBAL(void)
1531 jinit_huff_decoder (j_decompress_ptr cinfo)
1532 {
1533   huff_entropy_ptr entropy;
1534   int i;
1535 
<span class="line-modified">1536   entropy = (huff_entropy_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1537     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(huff_entropy_decoder));</span>

1538   cinfo-&gt;entropy = &amp;entropy-&gt;pub;
1539   entropy-&gt;pub.start_pass = start_pass_huff_decoder;
1540   entropy-&gt;pub.finish_pass = finish_pass_huff;
1541 
1542   if (cinfo-&gt;progressive_mode) {
1543     /* Create progression status table */
1544     int *coef_bit_ptr, ci;
<span class="line-modified">1545     cinfo-&gt;coef_bits = (int (*)[DCTSIZE2]) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1546       ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">1547        cinfo-&gt;num_components * DCTSIZE2 * SIZEOF(int));</span>
1548     coef_bit_ptr = &amp; cinfo-&gt;coef_bits[0][0];
1549     for (ci = 0; ci &lt; cinfo-&gt;num_components; ci++)
1550       for (i = 0; i &lt; DCTSIZE2; i++)
1551     *coef_bit_ptr++ = -1;
1552 
1553     /* Mark derived tables unallocated */
1554     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1555       entropy-&gt;derived_tbls[i] = NULL;
1556     }
1557   } else {
<span class="line-modified">1558     /* Mark derived tables unallocated */</span>
1559     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1560       entropy-&gt;dc_derived_tbls[i] = entropy-&gt;ac_derived_tbls[i] = NULL;
1561     }
1562   }
1563 }
</pre>
</td>
</tr>
</table>
<center><a href="jdct.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdmarker.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
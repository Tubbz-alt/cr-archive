diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jcmaster.c
@@ -1,10 +1,10 @@
 /*
  * jcmaster.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2003-2017 by Guido Vollbeding.
+ * Modified 2003-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains master control logic for the JPEG compressor.
  * These routines are concerned with parameter validation, initial setup,
@@ -60,11 +60,11 @@
   case 3: cinfo->natural_order = jpeg_natural_order3; break;
   case 4: cinfo->natural_order = jpeg_natural_order4; break;
   case 5: cinfo->natural_order = jpeg_natural_order5; break;
   case 6: cinfo->natural_order = jpeg_natural_order6; break;
   case 7: cinfo->natural_order = jpeg_natural_order7; break;
-  default: cinfo->natural_order = jpeg_natural_order; break;
+  default: cinfo->natural_order = jpeg_natural_order;
   }
 
   /* Derive lim_Se from block_size */
   cinfo->lim_Se = cinfo->block_size < DCTSIZE ?
     cinfo->block_size * cinfo->block_size - 1 : DCTSIZE2-1;
@@ -112,24 +112,28 @@
      * This saves time if the downsampler gets to use 1:1 scaling.
      * Note this code adapts subsampling ratios which are powers of 2.
      */
     ssize = 1;
 #ifdef DCT_SCALING_SUPPORTED
-    while (cinfo->min_DCT_h_scaled_size * ssize <=
-       (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
-       (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) == 0) {
-      ssize = ssize * 2;
-    }
+    if (! cinfo->raw_data_in)
+      while (cinfo->min_DCT_h_scaled_size * ssize <=
+         (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
+         (cinfo->max_h_samp_factor % (compptr->h_samp_factor * ssize * 2)) ==
+         0) {
+    ssize = ssize * 2;
+      }
 #endif
     compptr->DCT_h_scaled_size = cinfo->min_DCT_h_scaled_size * ssize;
     ssize = 1;
 #ifdef DCT_SCALING_SUPPORTED
-    while (cinfo->min_DCT_v_scaled_size * ssize <=
-       (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
-       (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) == 0) {
-      ssize = ssize * 2;
-    }
+    if (! cinfo->raw_data_in)
+      while (cinfo->min_DCT_v_scaled_size * ssize <=
+         (cinfo->do_fancy_downsampling ? DCTSIZE : DCTSIZE / 2) &&
+         (cinfo->max_v_samp_factor % (compptr->v_samp_factor * ssize * 2)) ==
+         0) {
+    ssize = ssize * 2;
+      }
 #endif
     compptr->DCT_v_scaled_size = cinfo->min_DCT_v_scaled_size * ssize;
 
     /* We don't support DCT ratios larger than 2. */
     if (compptr->DCT_h_scaled_size > compptr->DCT_v_scaled_size * 2)
@@ -621,13 +625,12 @@
 GLOBAL(void)
 jinit_c_master_control (j_compress_ptr cinfo, boolean transcode_only)
 {
   my_master_ptr master;
 
-  master = (my_master_ptr)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  SIZEOF(my_comp_master));
+  master = (my_master_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_comp_master));
   cinfo->master = &master->pub;
   master->pub.prepare_for_pass = prepare_for_pass;
   master->pub.pass_startup = pass_startup;
   master->pub.finish_pass = finish_pass_master;
   master->pub.is_last_pass = FALSE;

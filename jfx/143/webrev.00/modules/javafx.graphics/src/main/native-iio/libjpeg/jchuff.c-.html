<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-iio/libjpeg/jchuff.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * jchuff.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
   5  * Modified 2006-2013 by Guido Vollbeding.
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains Huffman entropy encoding routines.
  10  * Both sequential and progressive modes are supported in this single module.
  11  *
  12  * Much of the complexity here has to do with supporting output suspension.
  13  * If the data destination module demands suspension, we want to be able to
  14  * back up to the start of the current MCU.  To do this, we copy state
  15  * variables into local working storage, and update them back to the
  16  * permanent JPEG objects only upon successful completion of an MCU.
  17  *
  18  * We do not support output suspension for the progressive JPEG mode, since
  19  * the library currently does not allow multiple-scan files to be written
  20  * with output suspension.
  21  */
  22 
  23 #define JPEG_INTERNALS
  24 #include &quot;jinclude.h&quot;
  25 #include &quot;jpeglib.h&quot;
  26 
  27 
  28 /* The legal range of a DCT coefficient is
  29  *  -1024 .. +1023  for 8-bit data;
  30  * -16384 .. +16383 for 12-bit data.
  31  * Hence the magnitude should always fit in 10 or 14 bits respectively.
  32  */
  33 
  34 #if BITS_IN_JSAMPLE == 8
  35 #define MAX_COEF_BITS 10
  36 #else
  37 #define MAX_COEF_BITS 14
  38 #endif
  39 
  40 /* Derived data constructed for each Huffman table */
  41 
  42 typedef struct {
  43   unsigned int ehufco[256];    /* code for each symbol */
  44   char ehufsi[256];        /* length of code for each symbol */
  45   /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
  46 } c_derived_tbl;
  47 
  48 
  49 /* Expanded entropy encoder object for Huffman encoding.
  50  *
  51  * The savable_state subrecord contains fields that change within an MCU,
  52  * but must not be updated permanently until we complete the MCU.
  53  */
  54 
  55 typedef struct {
  56   INT32 put_buffer;        /* current bit-accumulation buffer */
  57   int put_bits;            /* # of bits now in it */
  58   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
  59 } savable_state;
  60 
  61 /* This macro is to work around compilers with missing or broken
  62  * structure assignment.  You&#39;ll need to fix this code if you have
  63  * such a compiler and you change MAX_COMPS_IN_SCAN.
  64  */
  65 
  66 #ifndef NO_STRUCT_ASSIGN
  67 #define ASSIGN_STATE(dest,src)  ((dest) = (src))
  68 #else
  69 #if MAX_COMPS_IN_SCAN == 4
  70 #define ASSIGN_STATE(dest,src)  \
  71     ((dest).put_buffer = (src).put_buffer, \
  72      (dest).put_bits = (src).put_bits, \
  73      (dest).last_dc_val[0] = (src).last_dc_val[0], \
  74      (dest).last_dc_val[1] = (src).last_dc_val[1], \
  75      (dest).last_dc_val[2] = (src).last_dc_val[2], \
  76      (dest).last_dc_val[3] = (src).last_dc_val[3])
  77 #endif
  78 #endif
  79 
  80 
  81 typedef struct {
  82   struct jpeg_entropy_encoder pub; /* public fields */
  83 
  84   savable_state saved;        /* Bit buffer &amp; DC state at start of MCU */
  85 
  86   /* These fields are NOT loaded into local working state. */
  87   unsigned int restarts_to_go;    /* MCUs left in this restart interval */
  88   int next_restart_num;        /* next restart number to write (0-7) */
  89 
  90   /* Pointers to derived tables (these workspaces have image lifespan) */
  91   c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  92   c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
  93 
  94   /* Statistics tables for optimization */
  95   long * dc_count_ptrs[NUM_HUFF_TBLS];
  96   long * ac_count_ptrs[NUM_HUFF_TBLS];
  97 
  98   /* Following fields used only in progressive mode */
  99 
 100   /* Mode flag: TRUE for optimization, FALSE for actual data output */
 101   boolean gather_statistics;
 102 
 103   /* next_output_byte/free_in_buffer are local copies of cinfo-&gt;dest fields.
 104    */
 105   JOCTET * next_output_byte;    /* =&gt; next byte to write in buffer */
 106   size_t free_in_buffer;    /* # of byte spaces remaining in buffer */
 107   j_compress_ptr cinfo;        /* link to cinfo (needed for dump_buffer) */
 108 
 109   /* Coding status for AC components */
 110   int ac_tbl_no;        /* the table number of the single component */
 111   unsigned int EOBRUN;        /* run length of EOBs */
 112   unsigned int BE;        /* # of buffered correction bits before MCU */
 113   char * bit_buffer;        /* buffer for correction bits (1 per char) */
 114   /* packing correction bits tightly would save some space but cost time... */
 115 } huff_entropy_encoder;
 116 
 117 typedef huff_entropy_encoder * huff_entropy_ptr;
 118 
 119 /* Working state while writing an MCU (sequential mode).
 120  * This struct contains all the fields that are needed by subroutines.
 121  */
 122 
 123 typedef struct {
 124   JOCTET * next_output_byte;    /* =&gt; next byte to write in buffer */
 125   size_t free_in_buffer;    /* # of byte spaces remaining in buffer */
 126   savable_state cur;        /* Current bit buffer &amp; DC state */
 127   j_compress_ptr cinfo;        /* dump_buffer needs access to this */
 128 } working_state;
 129 
 130 /* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
 131  * buffer can hold.  Larger sizes may slightly improve compression, but
 132  * 1000 is already well into the realm of overkill.
 133  * The minimum safe size is 64 bits.
 134  */
 135 
 136 #define MAX_CORR_BITS  1000    /* Max # of correction bits I can buffer */
 137 
 138 /* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
 139  * We assume that int right shift is unsigned if INT32 right shift is,
 140  * which should be safe.
 141  */
 142 
 143 #ifdef RIGHT_SHIFT_IS_UNSIGNED
 144 #define ISHIFT_TEMPS    int ishift_temp;
 145 #define IRIGHT_SHIFT(x,shft)  \
 146     ((ishift_temp = (x)) &lt; 0 ? \
 147      (ishift_temp &gt;&gt; (shft)) | ((~0) &lt;&lt; (16-(shft))) : \
 148      (ishift_temp &gt;&gt; (shft)))
 149 #else
 150 #define ISHIFT_TEMPS
 151 #define IRIGHT_SHIFT(x,shft)    ((x) &gt;&gt; (shft))
 152 #endif
 153 
 154 
 155 /*
 156  * Compute the derived values for a Huffman table.
 157  * This routine also performs some validation checks on the table.
 158  */
 159 
 160 LOCAL(void)
 161 jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
 162              c_derived_tbl ** pdtbl)
 163 {
 164   JHUFF_TBL *htbl;
 165   c_derived_tbl *dtbl;
 166   int p, i, l, lastp, si, maxsymbol;
 167   char huffsize[257];
 168   unsigned int huffcode[257];
 169   unsigned int code;
 170 
 171   MEMZERO(huffsize, SIZEOF(huffsize));
 172   MEMZERO(huffcode, SIZEOF(huffcode));
 173   /* Note that huffsize[] and huffcode[] are filled in code-length order,
 174    * paralleling the order of the symbols themselves in htbl-&gt;huffval[].
 175    */
 176 
 177   /* Find the input Huffman table */
 178   if (tblno &lt; 0 || tblno &gt;= NUM_HUFF_TBLS)
 179     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 180   htbl =
 181     isDC ? cinfo-&gt;dc_huff_tbl_ptrs[tblno] : cinfo-&gt;ac_huff_tbl_ptrs[tblno];
 182   if (htbl == NULL)
 183     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 184 
 185   /* Allocate a workspace if we haven&#39;t already done so. */
 186   if (*pdtbl == NULL)
 187     *pdtbl = (c_derived_tbl *)
 188       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 189                   SIZEOF(c_derived_tbl));
 190   dtbl = *pdtbl;
 191 
 192   /* Figure C.1: make table of Huffman code length for each symbol */
 193 
 194   p = 0;
 195   for (l = 1; l &lt;= 16; l++) {
 196     i = (int) htbl-&gt;bits[l];
 197     if (i &lt; 0 || p + i &gt; 256)    /* protect against table overrun */
 198       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 199     while (i--)
 200       huffsize[p++] = (char) l;
 201   }
 202   huffsize[p] = 0;
 203   lastp = p;
 204 
 205   /* Figure C.2: generate the codes themselves */
 206   /* We also validate that the counts represent a legal Huffman code tree. */
 207 
 208   code = 0;
 209   si = huffsize[0];
 210   p = 0;
 211   while (huffsize[p]) {
 212     while (((int) huffsize[p]) == si) {
 213       huffcode[p++] = code;
 214       code++;
 215     }
 216     /* code is now 1 more than the last code used for codelength si; but
 217      * it must still fit in si bits, since no code is allowed to be all ones.
 218      */
 219     if (((INT32) code) &gt;= (((INT32) 1) &lt;&lt; si))
 220       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 221     code &lt;&lt;= 1;
 222     si++;
 223   }
 224 
 225   /* Figure C.3: generate encoding tables */
 226   /* These are code and size indexed by symbol value */
 227 
 228   /* Set all codeless symbols to have code length 0;
 229    * this lets us detect duplicate VAL entries here, and later
 230    * allows emit_bits to detect any attempt to emit such symbols.
 231    */
 232   MEMZERO(dtbl-&gt;ehufsi, SIZEOF(dtbl-&gt;ehufsi));
 233 
 234   /* This is also a convenient place to check for out-of-range
 235    * and duplicated VAL entries.  We allow 0..255 for AC symbols
 236    * but only 0..15 for DC.  (We could constrain them further
 237    * based on data depth and mode, but this seems enough.)
 238    */
 239   maxsymbol = isDC ? 15 : 255;
 240 
 241   for (p = 0; p &lt; lastp; p++) {
 242     i = htbl-&gt;huffval[p];
 243     if (i &lt; 0 || i &gt; maxsymbol || dtbl-&gt;ehufsi[i])
 244       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 245     dtbl-&gt;ehufco[i] = huffcode[p];
 246     dtbl-&gt;ehufsi[i] = huffsize[p];
 247   }
 248 }
 249 
 250 
 251 /* Outputting bytes to the file.
 252  * NB: these must be called only when actually outputting,
 253  * that is, entropy-&gt;gather_statistics == FALSE.
 254  */
 255 
 256 /* Emit a byte, taking &#39;action&#39; if must suspend. */
 257 #define emit_byte_s(state,val,action)  \
 258     { *(state)-&gt;next_output_byte++ = (JOCTET) (val);  \
 259       if (--(state)-&gt;free_in_buffer == 0)  \
 260         if (! dump_buffer_s(state))  \
 261           { action; } }
 262 
 263 /* Emit a byte */
 264 #define emit_byte_e(entropy,val)  \
 265     { *(entropy)-&gt;next_output_byte++ = (JOCTET) (val);  \
 266       if (--(entropy)-&gt;free_in_buffer == 0)  \
 267         dump_buffer_e(entropy); }
 268 
 269 
 270 LOCAL(boolean)
 271 dump_buffer_s (working_state * state)
 272 /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
 273 {
 274   struct jpeg_destination_mgr * dest = state-&gt;cinfo-&gt;dest;
 275 
 276   if (! (*dest-&gt;empty_output_buffer) (state-&gt;cinfo))
 277     return FALSE;
 278   /* After a successful buffer dump, must reset buffer pointers */
 279   state-&gt;next_output_byte = dest-&gt;next_output_byte;
 280   state-&gt;free_in_buffer = dest-&gt;free_in_buffer;
 281   return TRUE;
 282 }
 283 
 284 
 285 LOCAL(void)
 286 dump_buffer_e (huff_entropy_ptr entropy)
 287 /* Empty the output buffer; we do not support suspension in this case. */
 288 {
 289   struct jpeg_destination_mgr * dest = entropy-&gt;cinfo-&gt;dest;
 290 
 291   if (! (*dest-&gt;empty_output_buffer) (entropy-&gt;cinfo))
 292     ERREXIT(entropy-&gt;cinfo, JERR_CANT_SUSPEND);
 293   /* After a successful buffer dump, must reset buffer pointers */
 294   entropy-&gt;next_output_byte = dest-&gt;next_output_byte;
 295   entropy-&gt;free_in_buffer = dest-&gt;free_in_buffer;
 296 }
 297 
 298 
 299 /* Outputting bits to the file */
 300 
 301 /* Only the right 24 bits of put_buffer are used; the valid bits are
 302  * left-justified in this part.  At most 16 bits can be passed to emit_bits
 303  * in one call, and we never retain more than 7 bits in put_buffer
 304  * between calls, so 24 bits are sufficient.
 305  */
 306 
 307 INLINE
 308 LOCAL(boolean)
 309 emit_bits_s (working_state * state, unsigned int code, int size)
 310 /* Emit some bits; return TRUE if successful, FALSE if must suspend */
 311 {
 312   /* This routine is heavily used, so it&#39;s worth coding tightly. */
 313   register INT32 put_buffer;
 314   register int put_bits;
 315 
 316   /* if size is 0, caller used an invalid Huffman table entry */
 317   if (size == 0)
 318     ERREXIT(state-&gt;cinfo, JERR_HUFF_MISSING_CODE);
 319 
 320   /* mask off any extra bits in code */
 321   put_buffer = ((INT32) code) &amp; ((((INT32) 1) &lt;&lt; size) - 1);
 322 
 323   /* new number of bits in buffer */
 324   put_bits = size + state-&gt;cur.put_bits;
 325 
 326   put_buffer &lt;&lt;= 24 - put_bits; /* align incoming bits */
 327 
 328   /* and merge with old buffer contents */
 329   put_buffer |= state-&gt;cur.put_buffer;
 330 
 331   while (put_bits &gt;= 8) {
 332     int c = (int) ((put_buffer &gt;&gt; 16) &amp; 0xFF);
 333 
 334     emit_byte_s(state, c, return FALSE);
 335     if (c == 0xFF) {        /* need to stuff a zero byte? */
 336       emit_byte_s(state, 0, return FALSE);
 337     }
 338     put_buffer &lt;&lt;= 8;
 339     put_bits -= 8;
 340   }
 341 
 342   state-&gt;cur.put_buffer = put_buffer; /* update state variables */
 343   state-&gt;cur.put_bits = put_bits;
 344 
 345   return TRUE;
 346 }
 347 
 348 
 349 INLINE
 350 LOCAL(void)
 351 emit_bits_e (huff_entropy_ptr entropy, unsigned int code, int size)
 352 /* Emit some bits, unless we are in gather mode */
 353 {
 354   /* This routine is heavily used, so it&#39;s worth coding tightly. */
 355   register INT32 put_buffer;
 356   register int put_bits;
 357 
 358   /* if size is 0, caller used an invalid Huffman table entry */
 359   if (size == 0)
 360     ERREXIT(entropy-&gt;cinfo, JERR_HUFF_MISSING_CODE);
 361 
 362   if (entropy-&gt;gather_statistics)
 363     return;            /* do nothing if we&#39;re only getting stats */
 364 
 365   /* mask off any extra bits in code */
 366   put_buffer = ((INT32) code) &amp; ((((INT32) 1) &lt;&lt; size) - 1);
 367 
 368   /* new number of bits in buffer */
 369   put_bits = size + entropy-&gt;saved.put_bits;
 370 
 371   put_buffer &lt;&lt;= 24 - put_bits; /* align incoming bits */
 372 
 373   /* and merge with old buffer contents */
 374   put_buffer |= entropy-&gt;saved.put_buffer;
 375 
 376   while (put_bits &gt;= 8) {
 377     int c = (int) ((put_buffer &gt;&gt; 16) &amp; 0xFF);
 378 
 379     emit_byte_e(entropy, c);
 380     if (c == 0xFF) {        /* need to stuff a zero byte? */
 381       emit_byte_e(entropy, 0);
 382     }
 383     put_buffer &lt;&lt;= 8;
 384     put_bits -= 8;
 385   }
 386 
 387   entropy-&gt;saved.put_buffer = put_buffer; /* update variables */
 388   entropy-&gt;saved.put_bits = put_bits;
 389 }
 390 
 391 
 392 LOCAL(boolean)
 393 flush_bits_s (working_state * state)
 394 {
 395   if (! emit_bits_s(state, 0x7F, 7)) /* fill any partial byte with ones */
 396     return FALSE;
 397   state-&gt;cur.put_buffer = 0;         /* and reset bit-buffer to empty */
 398   state-&gt;cur.put_bits = 0;
 399   return TRUE;
 400 }
 401 
 402 
 403 LOCAL(void)
 404 flush_bits_e (huff_entropy_ptr entropy)
 405 {
 406   emit_bits_e(entropy, 0x7F, 7); /* fill any partial byte with ones */
 407   entropy-&gt;saved.put_buffer = 0; /* and reset bit-buffer to empty */
 408   entropy-&gt;saved.put_bits = 0;
 409 }
 410 
 411 
 412 /*
 413  * Emit (or just count) a Huffman symbol.
 414  */
 415 
 416 INLINE
 417 LOCAL(void)
 418 emit_dc_symbol (huff_entropy_ptr entropy, int tbl_no, int symbol)
 419 {
 420   if (entropy-&gt;gather_statistics)
 421     entropy-&gt;dc_count_ptrs[tbl_no][symbol]++;
 422   else {
 423     c_derived_tbl * tbl = entropy-&gt;dc_derived_tbls[tbl_no];
 424     emit_bits_e(entropy, tbl-&gt;ehufco[symbol], tbl-&gt;ehufsi[symbol]);
 425   }
 426 }
 427 
 428 
 429 INLINE
 430 LOCAL(void)
 431 emit_ac_symbol (huff_entropy_ptr entropy, int tbl_no, int symbol)
 432 {
 433   if (entropy-&gt;gather_statistics)
 434     entropy-&gt;ac_count_ptrs[tbl_no][symbol]++;
 435   else {
 436     c_derived_tbl * tbl = entropy-&gt;ac_derived_tbls[tbl_no];
 437     emit_bits_e(entropy, tbl-&gt;ehufco[symbol], tbl-&gt;ehufsi[symbol]);
 438   }
 439 }
 440 
 441 
 442 /*
 443  * Emit bits from a correction bit buffer.
 444  */
 445 
 446 LOCAL(void)
 447 emit_buffered_bits (huff_entropy_ptr entropy, char * bufstart,
 448             unsigned int nbits)
 449 {
 450   if (entropy-&gt;gather_statistics)
 451     return;            /* no real work */
 452 
 453   while (nbits &gt; 0) {
 454     emit_bits_e(entropy, (unsigned int) (*bufstart), 1);
 455     bufstart++;
 456     nbits--;
 457   }
 458 }
 459 
 460 
 461 /*
 462  * Emit any pending EOBRUN symbol.
 463  */
 464 
 465 LOCAL(void)
 466 emit_eobrun (huff_entropy_ptr entropy)
 467 {
 468   register int temp, nbits;
 469 
 470   if (entropy-&gt;EOBRUN &gt; 0) {    /* if there is any pending EOBRUN */
 471     temp = entropy-&gt;EOBRUN;
 472     nbits = 0;
 473     while ((temp &gt;&gt;= 1))
 474       nbits++;
 475     /* safety check: shouldn&#39;t happen given limited correction-bit buffer */
 476     if (nbits &gt; 14)
 477       ERREXIT(entropy-&gt;cinfo, JERR_HUFF_MISSING_CODE);
 478 
 479     emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, nbits &lt;&lt; 4);
 480     if (nbits)
 481       emit_bits_e(entropy, entropy-&gt;EOBRUN, nbits);
 482 
 483     entropy-&gt;EOBRUN = 0;
 484 
 485     /* Emit any buffered correction bits */
 486     emit_buffered_bits(entropy, entropy-&gt;bit_buffer, entropy-&gt;BE);
 487     entropy-&gt;BE = 0;
 488   }
 489 }
 490 
 491 
 492 /*
 493  * Emit a restart marker &amp; resynchronize predictions.
 494  */
 495 
 496 LOCAL(boolean)
 497 emit_restart_s (working_state * state, int restart_num)
 498 {
 499   int ci;
 500 
 501   if (! flush_bits_s(state))
 502     return FALSE;
 503 
 504   emit_byte_s(state, 0xFF, return FALSE);
 505   emit_byte_s(state, JPEG_RST0 + restart_num, return FALSE);
 506 
 507   /* Re-initialize DC predictions to 0 */
 508   for (ci = 0; ci &lt; state-&gt;cinfo-&gt;comps_in_scan; ci++)
 509     state-&gt;cur.last_dc_val[ci] = 0;
 510 
 511   /* The restart counter is not updated until we successfully write the MCU. */
 512 
 513   return TRUE;
 514 }
 515 
 516 
 517 LOCAL(void)
 518 emit_restart_e (huff_entropy_ptr entropy, int restart_num)
 519 {
 520   int ci;
 521 
 522   emit_eobrun(entropy);
 523 
 524   if (! entropy-&gt;gather_statistics) {
 525     flush_bits_e(entropy);
 526     emit_byte_e(entropy, 0xFF);
 527     emit_byte_e(entropy, JPEG_RST0 + restart_num);
 528   }
 529 
 530   if (entropy-&gt;cinfo-&gt;Ss == 0) {
 531     /* Re-initialize DC predictions to 0 */
 532     for (ci = 0; ci &lt; entropy-&gt;cinfo-&gt;comps_in_scan; ci++)
 533       entropy-&gt;saved.last_dc_val[ci] = 0;
 534   } else {
 535     /* Re-initialize all AC-related fields to 0 */
 536     entropy-&gt;EOBRUN = 0;
 537     entropy-&gt;BE = 0;
 538   }
 539 }
 540 
 541 
 542 /*
 543  * MCU encoding for DC initial scan (either spectral selection,
 544  * or first pass of successive approximation).
 545  */
 546 
 547 METHODDEF(boolean)
 548 encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 549 {
 550   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 551   register int temp, temp2;
 552   register int nbits;
 553   int blkn, ci, tbl;
 554   ISHIFT_TEMPS
 555 
 556   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 557   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 558 
 559   /* Emit restart marker if needed */
 560   if (cinfo-&gt;restart_interval)
 561     if (entropy-&gt;restarts_to_go == 0)
 562       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 563 
 564   /* Encode the MCU data blocks */
 565   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 566     ci = cinfo-&gt;MCU_membership[blkn];
 567     tbl = cinfo-&gt;cur_comp_info[ci]-&gt;dc_tbl_no;
 568 
 569     /* Compute the DC value after the required point transform by Al.
 570      * This is simply an arithmetic right shift.
 571      */
 572     temp = IRIGHT_SHIFT((int) (MCU_data[blkn][0][0]), cinfo-&gt;Al);
 573 
 574     /* DC differences are figured on the point-transformed values. */
 575     temp2 = temp - entropy-&gt;saved.last_dc_val[ci];
 576     entropy-&gt;saved.last_dc_val[ci] = temp;
 577 
 578     /* Encode the DC coefficient difference per section G.1.2.1 */
 579     temp = temp2;
 580     if (temp &lt; 0) {
 581       temp = -temp;        /* temp is abs value of input */
 582       /* For a negative input, want temp2 = bitwise complement of abs(input) */
 583       /* This code assumes we are on a two&#39;s complement machine */
 584       temp2--;
 585     }
 586 
 587     /* Find the number of bits needed for the magnitude of the coefficient */
 588     nbits = 0;
 589     while (temp) {
 590       nbits++;
 591       temp &gt;&gt;= 1;
 592     }
 593     /* Check for out-of-range coefficient values.
 594      * Since we&#39;re encoding a difference, the range limit is twice as much.
 595      */
 596     if (nbits &gt; MAX_COEF_BITS+1)
 597       ERREXIT(cinfo, JERR_BAD_DCT_COEF);
 598 
 599     /* Count/emit the Huffman-coded symbol for the number of bits */
 600     emit_dc_symbol(entropy, tbl, nbits);
 601 
 602     /* Emit that number of bits of the value, if positive, */
 603     /* or the complement of its magnitude, if negative. */
 604     if (nbits)            /* emit_bits rejects calls with size 0 */
 605       emit_bits_e(entropy, (unsigned int) temp2, nbits);
 606   }
 607 
 608   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 609   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 610 
 611   /* Update restart-interval state too */
 612   if (cinfo-&gt;restart_interval) {
 613     if (entropy-&gt;restarts_to_go == 0) {
 614       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 615       entropy-&gt;next_restart_num++;
 616       entropy-&gt;next_restart_num &amp;= 7;
 617     }
 618     entropy-&gt;restarts_to_go--;
 619   }
 620 
 621   return TRUE;
 622 }
 623 
 624 
 625 /*
 626  * MCU encoding for AC initial scan (either spectral selection,
 627  * or first pass of successive approximation).
 628  */
 629 
 630 METHODDEF(boolean)
 631 encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 632 {
 633   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 634   const int * natural_order;
 635   JBLOCKROW block;
 636   register int temp, temp2;
 637   register int nbits;
 638   register int r, k;
 639   int Se, Al;
 640 
 641   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 642   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 643 
 644   /* Emit restart marker if needed */
 645   if (cinfo-&gt;restart_interval)
 646     if (entropy-&gt;restarts_to_go == 0)
 647       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 648 
 649   Se = cinfo-&gt;Se;
 650   Al = cinfo-&gt;Al;
 651   natural_order = cinfo-&gt;natural_order;
 652 
 653   /* Encode the MCU data block */
 654   block = MCU_data[0];
 655 
 656   /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
 657 
 658   r = 0;            /* r = run length of zeros */
 659 
 660   for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 661     if ((temp = (*block)[natural_order[k]]) == 0) {
 662       r++;
 663       continue;
 664     }
 665     /* We must apply the point transform by Al.  For AC coefficients this
 666      * is an integer division with rounding towards 0.  To do this portably
 667      * in C, we shift after obtaining the absolute value; so the code is
 668      * interwoven with finding the abs value (temp) and output bits (temp2).
 669      */
 670     if (temp &lt; 0) {
 671       temp = -temp;        /* temp is abs value of input */
 672       temp &gt;&gt;= Al;        /* apply the point transform */
 673       /* For a negative coef, want temp2 = bitwise complement of abs(coef) */
 674       temp2 = ~temp;
 675     } else {
 676       temp &gt;&gt;= Al;        /* apply the point transform */
 677       temp2 = temp;
 678     }
 679     /* Watch out for case that nonzero coef is zero after point transform */
 680     if (temp == 0) {
 681       r++;
 682       continue;
 683     }
 684 
 685     /* Emit any pending EOBRUN */
 686     if (entropy-&gt;EOBRUN &gt; 0)
 687       emit_eobrun(entropy);
 688     /* if run length &gt; 15, must emit special run-length-16 codes (0xF0) */
 689     while (r &gt; 15) {
 690       emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, 0xF0);
 691       r -= 16;
 692     }
 693 
 694     /* Find the number of bits needed for the magnitude of the coefficient */
 695     nbits = 1;            /* there must be at least one 1 bit */
 696     while ((temp &gt;&gt;= 1))
 697       nbits++;
 698     /* Check for out-of-range coefficient values */
 699     if (nbits &gt; MAX_COEF_BITS)
 700       ERREXIT(cinfo, JERR_BAD_DCT_COEF);
 701 
 702     /* Count/emit Huffman symbol for run length / number of bits */
 703     emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, (r &lt;&lt; 4) + nbits);
 704 
 705     /* Emit that number of bits of the value, if positive, */
 706     /* or the complement of its magnitude, if negative. */
 707     emit_bits_e(entropy, (unsigned int) temp2, nbits);
 708 
 709     r = 0;            /* reset zero run length */
 710   }
 711 
 712   if (r &gt; 0) {            /* If there are trailing zeroes, */
 713     entropy-&gt;EOBRUN++;        /* count an EOB */
 714     if (entropy-&gt;EOBRUN == 0x7FFF)
 715       emit_eobrun(entropy);    /* force it out to avoid overflow */
 716   }
 717 
 718   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 719   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 720 
 721   /* Update restart-interval state too */
 722   if (cinfo-&gt;restart_interval) {
 723     if (entropy-&gt;restarts_to_go == 0) {
 724       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 725       entropy-&gt;next_restart_num++;
 726       entropy-&gt;next_restart_num &amp;= 7;
 727     }
 728     entropy-&gt;restarts_to_go--;
 729   }
 730 
 731   return TRUE;
 732 }
 733 
 734 
 735 /*
 736  * MCU encoding for DC successive approximation refinement scan.
 737  * Note: we assume such scans can be multi-component,
 738  * although the spec is not very clear on the point.
 739  */
 740 
 741 METHODDEF(boolean)
 742 encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 743 {
 744   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 745   int Al, blkn;
 746 
 747   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 748   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 749 
 750   /* Emit restart marker if needed */
 751   if (cinfo-&gt;restart_interval)
 752     if (entropy-&gt;restarts_to_go == 0)
 753       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 754 
 755   Al = cinfo-&gt;Al;
 756 
 757   /* Encode the MCU data blocks */
 758   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 759     /* We simply emit the Al&#39;th bit of the DC coefficient value. */
 760     emit_bits_e(entropy, (unsigned int) (MCU_data[blkn][0][0] &gt;&gt; Al), 1);
 761   }
 762 
 763   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 764   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 765 
 766   /* Update restart-interval state too */
 767   if (cinfo-&gt;restart_interval) {
 768     if (entropy-&gt;restarts_to_go == 0) {
 769       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 770       entropy-&gt;next_restart_num++;
 771       entropy-&gt;next_restart_num &amp;= 7;
 772     }
 773     entropy-&gt;restarts_to_go--;
 774   }
 775 
 776   return TRUE;
 777 }
 778 
 779 
 780 /*
 781  * MCU encoding for AC successive approximation refinement scan.
 782  */
 783 
 784 METHODDEF(boolean)
 785 encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 786 {
 787   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 788   const int * natural_order;
 789   JBLOCKROW block;
 790   register int temp;
 791   register int r, k;
 792   int Se, Al;
 793   int EOB;
 794   char *BR_buffer;
 795   unsigned int BR;
 796   int absvalues[DCTSIZE2];
 797 
 798   MEMZERO(absvalues, SIZEOF(absvalues));
 799 
 800   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 801   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 802 
 803   /* Emit restart marker if needed */
 804   if (cinfo-&gt;restart_interval)
 805     if (entropy-&gt;restarts_to_go == 0)
 806       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 807 
 808   Se = cinfo-&gt;Se;
 809   Al = cinfo-&gt;Al;
 810   natural_order = cinfo-&gt;natural_order;
 811 
 812   /* Encode the MCU data block */
 813   block = MCU_data[0];
 814 
 815   /* It is convenient to make a pre-pass to determine the transformed
 816    * coefficients&#39; absolute values and the EOB position.
 817    */
 818   EOB = 0;
 819   for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 820     temp = (*block)[natural_order[k]];
 821     /* We must apply the point transform by Al.  For AC coefficients this
 822      * is an integer division with rounding towards 0.  To do this portably
 823      * in C, we shift after obtaining the absolute value.
 824      */
 825     if (temp &lt; 0)
 826       temp = -temp;        /* temp is abs value of input */
 827     temp &gt;&gt;= Al;        /* apply the point transform */
 828     absvalues[k] = temp;    /* save abs value for main pass */
 829     if (temp == 1)
 830       EOB = k;            /* EOB = index of last newly-nonzero coef */
 831   }
 832 
 833   /* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
 834 
 835   r = 0;            /* r = run length of zeros */
 836   BR = 0;            /* BR = count of buffered bits added now */
 837   BR_buffer = entropy-&gt;bit_buffer + entropy-&gt;BE; /* Append bits to buffer */
 838 
 839   for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 840     if ((temp = absvalues[k]) == 0) {
 841       r++;
 842       continue;
 843     }
 844 
 845     /* Emit any required ZRLs, but not if they can be folded into EOB */
 846     while (r &gt; 15 &amp;&amp; k &lt;= EOB) {
 847       /* emit any pending EOBRUN and the BE correction bits */
 848       emit_eobrun(entropy);
 849       /* Emit ZRL */
 850       emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, 0xF0);
 851       r -= 16;
 852       /* Emit buffered correction bits that must be associated with ZRL */
 853       emit_buffered_bits(entropy, BR_buffer, BR);
 854       BR_buffer = entropy-&gt;bit_buffer; /* BE bits are gone now */
 855       BR = 0;
 856     }
 857 
 858     /* If the coef was previously nonzero, it only needs a correction bit.
 859      * NOTE: a straight translation of the spec&#39;s figure G.7 would suggest
 860      * that we also need to test r &gt; 15.  But if r &gt; 15, we can only get here
 861      * if k &gt; EOB, which implies that this coefficient is not 1.
 862      */
 863     if (temp &gt; 1) {
 864       /* The correction bit is the next bit of the absolute value. */
 865       BR_buffer[BR++] = (char) (temp &amp; 1);
 866       continue;
 867     }
 868 
 869     /* Emit any pending EOBRUN and the BE correction bits */
 870     emit_eobrun(entropy);
 871 
 872     /* Count/emit Huffman symbol for run length / number of bits */
 873     emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, (r &lt;&lt; 4) + 1);
 874 
 875     /* Emit output bit for newly-nonzero coef */
 876     temp = ((*block)[natural_order[k]] &lt; 0) ? 0 : 1;
 877     emit_bits_e(entropy, (unsigned int) temp, 1);
 878 
 879     /* Emit buffered correction bits that must be associated with this code */
 880     emit_buffered_bits(entropy, BR_buffer, BR);
 881     BR_buffer = entropy-&gt;bit_buffer; /* BE bits are gone now */
 882     BR = 0;
 883     r = 0;            /* reset zero run length */
 884   }
 885 
 886   if (r &gt; 0 || BR &gt; 0) {    /* If there are trailing zeroes, */
 887     entropy-&gt;EOBRUN++;        /* count an EOB */
 888     entropy-&gt;BE += BR;        /* concat my correction bits to older ones */
 889     /* We force out the EOB if we risk either:
 890      * 1. overflow of the EOB counter;
 891      * 2. overflow of the correction bit buffer during the next MCU.
 892      */
 893     if (entropy-&gt;EOBRUN == 0x7FFF || entropy-&gt;BE &gt; (MAX_CORR_BITS-DCTSIZE2+1))
 894       emit_eobrun(entropy);
 895   }
 896 
 897   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 898   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 899 
 900   /* Update restart-interval state too */
 901   if (cinfo-&gt;restart_interval) {
 902     if (entropy-&gt;restarts_to_go == 0) {
 903       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 904       entropy-&gt;next_restart_num++;
 905       entropy-&gt;next_restart_num &amp;= 7;
 906     }
 907     entropy-&gt;restarts_to_go--;
 908   }
 909 
 910   return TRUE;
 911 }
 912 
 913 
 914 /* Encode a single block&#39;s worth of coefficients */
 915 
 916 LOCAL(boolean)
 917 encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
 918           c_derived_tbl *dctbl, c_derived_tbl *actbl)
 919 {
 920   register int temp, temp2;
 921   register int nbits;
 922   register int r, k;
 923   int Se = state-&gt;cinfo-&gt;lim_Se;
 924   const int * natural_order = state-&gt;cinfo-&gt;natural_order;
 925 
 926   /* Encode the DC coefficient difference per section F.1.2.1 */
 927 
 928   temp = temp2 = block[0] - last_dc_val;
 929 
 930   if (temp &lt; 0) {
 931     temp = -temp;        /* temp is abs value of input */
 932     /* For a negative input, want temp2 = bitwise complement of abs(input) */
 933     /* This code assumes we are on a two&#39;s complement machine */
 934     temp2--;
 935   }
 936 
 937   /* Find the number of bits needed for the magnitude of the coefficient */
 938   nbits = 0;
 939   while (temp) {
 940     nbits++;
 941     temp &gt;&gt;= 1;
 942   }
 943   /* Check for out-of-range coefficient values.
 944    * Since we&#39;re encoding a difference, the range limit is twice as much.
 945    */
 946   if (nbits &gt; MAX_COEF_BITS+1)
 947     ERREXIT(state-&gt;cinfo, JERR_BAD_DCT_COEF);
 948 
 949   /* Emit the Huffman-coded symbol for the number of bits */
 950   if (! emit_bits_s(state, dctbl-&gt;ehufco[nbits], dctbl-&gt;ehufsi[nbits]))
 951     return FALSE;
 952 
 953   /* Emit that number of bits of the value, if positive, */
 954   /* or the complement of its magnitude, if negative. */
 955   if (nbits)            /* emit_bits rejects calls with size 0 */
 956     if (! emit_bits_s(state, (unsigned int) temp2, nbits))
 957       return FALSE;
 958 
 959   /* Encode the AC coefficients per section F.1.2.2 */
 960 
 961   r = 0;            /* r = run length of zeros */
 962 
 963   for (k = 1; k &lt;= Se; k++) {
 964     if ((temp2 = block[natural_order[k]]) == 0) {
 965       r++;
 966     } else {
 967       /* if run length &gt; 15, must emit special run-length-16 codes (0xF0) */
 968       while (r &gt; 15) {
 969     if (! emit_bits_s(state, actbl-&gt;ehufco[0xF0], actbl-&gt;ehufsi[0xF0]))
 970       return FALSE;
 971     r -= 16;
 972       }
 973 
 974       temp = temp2;
 975       if (temp &lt; 0) {
 976     temp = -temp;        /* temp is abs value of input */
 977     /* This code assumes we are on a two&#39;s complement machine */
 978     temp2--;
 979       }
 980 
 981       /* Find the number of bits needed for the magnitude of the coefficient */
 982       nbits = 1;        /* there must be at least one 1 bit */
 983       while ((temp &gt;&gt;= 1))
 984     nbits++;
 985       /* Check for out-of-range coefficient values */
 986       if (nbits &gt; MAX_COEF_BITS)
 987     ERREXIT(state-&gt;cinfo, JERR_BAD_DCT_COEF);
 988 
 989       /* Emit Huffman symbol for run length / number of bits */
 990       temp = (r &lt;&lt; 4) + nbits;
 991       if (! emit_bits_s(state, actbl-&gt;ehufco[temp], actbl-&gt;ehufsi[temp]))
 992     return FALSE;
 993 
 994       /* Emit that number of bits of the value, if positive, */
 995       /* or the complement of its magnitude, if negative. */
 996       if (! emit_bits_s(state, (unsigned int) temp2, nbits))
 997     return FALSE;
 998 
 999       r = 0;
1000     }
1001   }
1002 
1003   /* If the last coef(s) were zero, emit an end-of-block code */
1004   if (r &gt; 0)
1005     if (! emit_bits_s(state, actbl-&gt;ehufco[0], actbl-&gt;ehufsi[0]))
1006       return FALSE;
1007 
1008   return TRUE;
1009 }
1010 
1011 
1012 /*
1013  * Encode and output one MCU&#39;s worth of Huffman-compressed coefficients.
1014  */
1015 
1016 METHODDEF(boolean)
1017 encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
1018 {
1019   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1020   working_state state;
1021   int blkn, ci;
1022   jpeg_component_info * compptr;
1023 
1024   /* Load up working state */
1025   state.next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
1026   state.free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
1027   ASSIGN_STATE(state.cur, entropy-&gt;saved);
1028   state.cinfo = cinfo;
1029 
1030   /* Emit restart marker if needed */
1031   if (cinfo-&gt;restart_interval) {
1032     if (entropy-&gt;restarts_to_go == 0)
1033       if (! emit_restart_s(&amp;state, entropy-&gt;next_restart_num))
1034     return FALSE;
1035   }
1036 
1037   /* Encode the MCU data blocks */
1038   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1039     ci = cinfo-&gt;MCU_membership[blkn];
1040     compptr = cinfo-&gt;cur_comp_info[ci];
1041     if (! encode_one_block(&amp;state,
1042                MCU_data[blkn][0], state.cur.last_dc_val[ci],
1043                entropy-&gt;dc_derived_tbls[compptr-&gt;dc_tbl_no],
1044                entropy-&gt;ac_derived_tbls[compptr-&gt;ac_tbl_no]))
1045       return FALSE;
1046     /* Update last_dc_val */
1047     state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
1048   }
1049 
1050   /* Completed MCU, so update state */
1051   cinfo-&gt;dest-&gt;next_output_byte = state.next_output_byte;
1052   cinfo-&gt;dest-&gt;free_in_buffer = state.free_in_buffer;
1053   ASSIGN_STATE(entropy-&gt;saved, state.cur);
1054 
1055   /* Update restart-interval state too */
1056   if (cinfo-&gt;restart_interval) {
1057     if (entropy-&gt;restarts_to_go == 0) {
1058       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1059       entropy-&gt;next_restart_num++;
1060       entropy-&gt;next_restart_num &amp;= 7;
1061     }
1062     entropy-&gt;restarts_to_go--;
1063   }
1064 
1065   return TRUE;
1066 }
1067 
1068 
1069 /*
1070  * Finish up at the end of a Huffman-compressed scan.
1071  */
1072 
1073 METHODDEF(void)
1074 finish_pass_huff (j_compress_ptr cinfo)
1075 {
1076   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1077   working_state state;
1078 
1079   if (cinfo-&gt;progressive_mode) {
1080     entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
1081     entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
1082 
1083     /* Flush out any buffered data */
1084     emit_eobrun(entropy);
1085     flush_bits_e(entropy);
1086 
1087     cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
1088     cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
1089   } else {
1090     /* Load up working state ... flush_bits needs it */
1091     state.next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
1092     state.free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
1093     ASSIGN_STATE(state.cur, entropy-&gt;saved);
1094     state.cinfo = cinfo;
1095 
1096     /* Flush out the last data */
1097     if (! flush_bits_s(&amp;state))
1098       ERREXIT(cinfo, JERR_CANT_SUSPEND);
1099 
1100     /* Update state */
1101     cinfo-&gt;dest-&gt;next_output_byte = state.next_output_byte;
1102     cinfo-&gt;dest-&gt;free_in_buffer = state.free_in_buffer;
1103     ASSIGN_STATE(entropy-&gt;saved, state.cur);
1104   }
1105 }
1106 
1107 
1108 /*
1109  * Huffman coding optimization.
1110  *
1111  * We first scan the supplied data and count the number of uses of each symbol
1112  * that is to be Huffman-coded. (This process MUST agree with the code above.)
1113  * Then we build a Huffman coding tree for the observed counts.
1114  * Symbols which are not needed at all for the particular image are not
1115  * assigned any code, which saves space in the DHT marker as well as in
1116  * the compressed data.
1117  */
1118 
1119 
1120 /* Process a single block&#39;s worth of coefficients */
1121 
1122 LOCAL(void)
1123 htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
1124          long dc_counts[], long ac_counts[])
1125 {
1126   register int temp;
1127   register int nbits;
1128   register int r, k;
1129   int Se = cinfo-&gt;lim_Se;
1130   const int * natural_order = cinfo-&gt;natural_order;
1131 
1132   /* Encode the DC coefficient difference per section F.1.2.1 */
1133 
1134   temp = block[0] - last_dc_val;
1135   if (temp &lt; 0)
1136     temp = -temp;
1137 
1138   /* Find the number of bits needed for the magnitude of the coefficient */
1139   nbits = 0;
1140   while (temp) {
1141     nbits++;
1142     temp &gt;&gt;= 1;
1143   }
1144   /* Check for out-of-range coefficient values.
1145    * Since we&#39;re encoding a difference, the range limit is twice as much.
1146    */
1147   if (nbits &gt; MAX_COEF_BITS+1)
1148     ERREXIT(cinfo, JERR_BAD_DCT_COEF);
1149 
1150   /* Count the Huffman symbol for the number of bits */
1151   dc_counts[nbits]++;
1152 
1153   /* Encode the AC coefficients per section F.1.2.2 */
1154 
1155   r = 0;            /* r = run length of zeros */
1156 
1157   for (k = 1; k &lt;= Se; k++) {
1158     if ((temp = block[natural_order[k]]) == 0) {
1159       r++;
1160     } else {
1161       /* if run length &gt; 15, must emit special run-length-16 codes (0xF0) */
1162       while (r &gt; 15) {
1163     ac_counts[0xF0]++;
1164     r -= 16;
1165       }
1166 
1167       /* Find the number of bits needed for the magnitude of the coefficient */
1168       if (temp &lt; 0)
1169     temp = -temp;
1170 
1171       /* Find the number of bits needed for the magnitude of the coefficient */
1172       nbits = 1;        /* there must be at least one 1 bit */
1173       while ((temp &gt;&gt;= 1))
1174     nbits++;
1175       /* Check for out-of-range coefficient values */
1176       if (nbits &gt; MAX_COEF_BITS)
1177     ERREXIT(cinfo, JERR_BAD_DCT_COEF);
1178 
1179       /* Count Huffman symbol for run length / number of bits */
1180       ac_counts[(r &lt;&lt; 4) + nbits]++;
1181 
1182       r = 0;
1183     }
1184   }
1185 
1186   /* If the last coef(s) were zero, emit an end-of-block code */
1187   if (r &gt; 0)
1188     ac_counts[0]++;
1189 }
1190 
1191 
1192 /*
1193  * Trial-encode one MCU&#39;s worth of Huffman-compressed coefficients.
1194  * No data is actually output, so no suspension return is possible.
1195  */
1196 
1197 METHODDEF(boolean)
1198 encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
1199 {
1200   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1201   int blkn, ci;
1202   jpeg_component_info * compptr;
1203 
1204   /* Take care of restart intervals if needed */
1205   if (cinfo-&gt;restart_interval) {
1206     if (entropy-&gt;restarts_to_go == 0) {
1207       /* Re-initialize DC predictions to 0 */
1208       for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++)
1209     entropy-&gt;saved.last_dc_val[ci] = 0;
1210       /* Update restart state */
1211       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1212     }
1213     entropy-&gt;restarts_to_go--;
1214   }
1215 
1216   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1217     ci = cinfo-&gt;MCU_membership[blkn];
1218     compptr = cinfo-&gt;cur_comp_info[ci];
1219     htest_one_block(cinfo, MCU_data[blkn][0], entropy-&gt;saved.last_dc_val[ci],
1220             entropy-&gt;dc_count_ptrs[compptr-&gt;dc_tbl_no],
1221             entropy-&gt;ac_count_ptrs[compptr-&gt;ac_tbl_no]);
1222     entropy-&gt;saved.last_dc_val[ci] = MCU_data[blkn][0][0];
1223   }
1224 
1225   return TRUE;
1226 }
1227 
1228 
1229 /*
1230  * Generate the best Huffman code table for the given counts, fill htbl.
1231  *
1232  * The JPEG standard requires that no symbol be assigned a codeword of all
1233  * one bits (so that padding bits added at the end of a compressed segment
1234  * can&#39;t look like a valid code).  Because of the canonical ordering of
1235  * codewords, this just means that there must be an unused slot in the
1236  * longest codeword length category.  Section K.2 of the JPEG spec suggests
1237  * reserving such a slot by pretending that symbol 256 is a valid symbol
1238  * with count 1.  In theory that&#39;s not optimal; giving it count zero but
1239  * including it in the symbol set anyway should give a better Huffman code.
1240  * But the theoretically better code actually seems to come out worse in
1241  * practice, because it produces more all-ones bytes (which incur stuffed
1242  * zero bytes in the final file).  In any case the difference is tiny.
1243  *
1244  * The JPEG standard requires Huffman codes to be no more than 16 bits long.
1245  * If some symbols have a very small but nonzero probability, the Huffman tree
1246  * must be adjusted to meet the code length restriction.  We currently use
1247  * the adjustment method suggested in JPEG section K.2.  This method is *not*
1248  * optimal; it may not choose the best possible limited-length code.  But
1249  * typically only very-low-frequency symbols will be given less-than-optimal
1250  * lengths, so the code is almost optimal.  Experimental comparisons against
1251  * an optimal limited-length-code algorithm indicate that the difference is
1252  * microscopic --- usually less than a hundredth of a percent of total size.
1253  * So the extra complexity of an optimal algorithm doesn&#39;t seem worthwhile.
1254  */
1255 
1256 LOCAL(void)
1257 jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
1258 {
1259 #define MAX_CLEN 32        /* assumed maximum initial code length */
1260   UINT8 bits[MAX_CLEN+1];    /* bits[k] = # of symbols with code length k */
1261   int codesize[257];        /* codesize[k] = code length of symbol k */
1262   int others[257];        /* next symbol in current branch of tree */
1263   int c1, c2;
1264   int p, i, j;
1265   long v;
1266 
1267   /* This algorithm is explained in section K.2 of the JPEG standard */
1268 
1269   MEMZERO(bits, SIZEOF(bits));
1270   MEMZERO(codesize, SIZEOF(codesize));
1271   for (i = 0; i &lt; 257; i++)
1272     others[i] = -1;        /* init links to empty */
1273 
1274   freq[256] = 1;        /* make sure 256 has a nonzero count */
1275   /* Including the pseudo-symbol 256 in the Huffman procedure guarantees
1276    * that no real symbol is given code-value of all ones, because 256
1277    * will be placed last in the largest codeword category.
1278    */
1279 
1280   /* Huffman&#39;s basic algorithm to assign optimal code lengths to symbols */
1281 
1282   for (;;) {
1283     /* Find the smallest nonzero frequency, set c1 = its symbol */
1284     /* In case of ties, take the larger symbol number */
1285     c1 = -1;
1286     v = 1000000000L;
1287     for (i = 0; i &lt;= 256; i++) {
1288       if (freq[i] &amp;&amp; freq[i] &lt;= v) {
1289     v = freq[i];
1290     c1 = i;
1291       }
1292     }
1293 
1294     /* Find the next smallest nonzero frequency, set c2 = its symbol */
1295     /* In case of ties, take the larger symbol number */
1296     c2 = -1;
1297     v = 1000000000L;
1298     for (i = 0; i &lt;= 256; i++) {
1299       if (freq[i] &amp;&amp; freq[i] &lt;= v &amp;&amp; i != c1) {
1300     v = freq[i];
1301     c2 = i;
1302       }
1303     }
1304 
1305     /* Done if we&#39;ve merged everything into one frequency */
1306     if (c2 &lt; 0)
1307       break;
1308 
1309     /* Else merge the two counts/trees */
1310     freq[c1] += freq[c2];
1311     freq[c2] = 0;
1312 
1313     /* Increment the codesize of everything in c1&#39;s tree branch */
1314     codesize[c1]++;
1315     while (others[c1] &gt;= 0) {
1316       c1 = others[c1];
1317       codesize[c1]++;
1318     }
1319 
1320     others[c1] = c2;        /* chain c2 onto c1&#39;s tree branch */
1321 
1322     /* Increment the codesize of everything in c2&#39;s tree branch */
1323     codesize[c2]++;
1324     while (others[c2] &gt;= 0) {
1325       c2 = others[c2];
1326       codesize[c2]++;
1327     }
1328   }
1329 
1330   /* Now count the number of symbols of each code length */
1331   for (i = 0; i &lt;= 256; i++) {
1332     if (codesize[i]) {
1333       /* The JPEG standard seems to think that this can&#39;t happen, */
1334       /* but I&#39;m paranoid... */
1335       if (codesize[i] &gt; MAX_CLEN)
1336     ERREXIT(cinfo, JERR_HUFF_CLEN_OVERFLOW);
1337 
1338       bits[codesize[i]]++;
1339     }
1340   }
1341 
1342   /* JPEG doesn&#39;t allow symbols with code lengths over 16 bits, so if the pure
1343    * Huffman procedure assigned any such lengths, we must adjust the coding.
1344    * Here is what the JPEG spec says about how this next bit works:
1345    * Since symbols are paired for the longest Huffman code, the symbols are
1346    * removed from this length category two at a time.  The prefix for the pair
1347    * (which is one bit shorter) is allocated to one of the pair; then,
1348    * skipping the BITS entry for that prefix length, a code word from the next
1349    * shortest nonzero BITS entry is converted into a prefix for two code words
1350    * one bit longer.
1351    */
1352 
1353   for (i = MAX_CLEN; i &gt; 16; i--) {
1354     while (bits[i] &gt; 0) {
1355       j = i - 2;        /* find length of new prefix to be used */
1356       while (bits[j] == 0)
1357     j--;
1358 
1359       bits[i] -= 2;        /* remove two symbols */
1360       bits[i-1]++;        /* one goes in this length */
1361       bits[j+1] += 2;        /* two new symbols in this length */
1362       bits[j]--;        /* symbol of this length is now a prefix */
1363     }
1364   }
1365 
1366   /* Remove the count for the pseudo-symbol 256 from the largest codelength */
1367   while (bits[i] == 0)        /* find largest codelength still in use */
1368     i--;
1369   bits[i]--;
1370 
1371   /* Return final symbol counts (only for lengths 0..16) */
1372   MEMCOPY(htbl-&gt;bits, bits, SIZEOF(htbl-&gt;bits));
1373 
1374   /* Return a list of the symbols sorted by code length */
1375   /* It&#39;s not real clear to me why we don&#39;t need to consider the codelength
1376    * changes made above, but the JPEG spec seems to think this works.
1377    */
1378   p = 0;
1379   for (i = 1; i &lt;= MAX_CLEN; i++) {
1380     for (j = 0; j &lt;= 255; j++) {
1381       if (codesize[j] == i) {
1382     htbl-&gt;huffval[p] = (UINT8) j;
1383     p++;
1384       }
1385     }
1386   }
1387 
1388   /* Set sent_table FALSE so updated table will be written to JPEG file. */
1389   htbl-&gt;sent_table = FALSE;
1390 }
1391 
1392 
1393 /*
1394  * Finish up a statistics-gathering pass and create the new Huffman tables.
1395  */
1396 
1397 METHODDEF(void)
1398 finish_pass_gather (j_compress_ptr cinfo)
1399 {
1400   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1401   int ci, tbl;
1402   jpeg_component_info * compptr;
1403   JHUFF_TBL **htblptr;
1404   boolean did_dc[NUM_HUFF_TBLS];
1405   boolean did_ac[NUM_HUFF_TBLS];
1406 
1407   /* It&#39;s important not to apply jpeg_gen_optimal_table more than once
1408    * per table, because it clobbers the input frequency counts!
1409    */
1410   if (cinfo-&gt;progressive_mode)
1411     /* Flush out buffered data (all we care about is counting the EOB symbol) */
1412     emit_eobrun(entropy);
1413 
1414   MEMZERO(did_dc, SIZEOF(did_dc));
1415   MEMZERO(did_ac, SIZEOF(did_ac));
1416 
1417   for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1418     compptr = cinfo-&gt;cur_comp_info[ci];
1419     /* DC needs no table for refinement scan */
1420     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0) {
1421       tbl = compptr-&gt;dc_tbl_no;
1422       if (! did_dc[tbl]) {
1423     htblptr = &amp; cinfo-&gt;dc_huff_tbl_ptrs[tbl];
1424     if (*htblptr == NULL)
1425       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
1426     jpeg_gen_optimal_table(cinfo, *htblptr, entropy-&gt;dc_count_ptrs[tbl]);
1427     did_dc[tbl] = TRUE;
1428       }
1429     }
1430     /* AC needs no table when not present */
1431     if (cinfo-&gt;Se) {
1432       tbl = compptr-&gt;ac_tbl_no;
1433       if (! did_ac[tbl]) {
1434     htblptr = &amp; cinfo-&gt;ac_huff_tbl_ptrs[tbl];
1435     if (*htblptr == NULL)
1436       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
1437     jpeg_gen_optimal_table(cinfo, *htblptr, entropy-&gt;ac_count_ptrs[tbl]);
1438     did_ac[tbl] = TRUE;
1439       }
1440     }
1441   }
1442 }
1443 
1444 
1445 /*
1446  * Initialize for a Huffman-compressed scan.
1447  * If gather_statistics is TRUE, we do not output anything during the scan,
1448  * just count the Huffman symbols used and generate Huffman code tables.
1449  */
1450 
1451 METHODDEF(void)
1452 start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
1453 {
1454   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1455   int ci, tbl;
1456   jpeg_component_info * compptr;
1457 
1458   if (gather_statistics)
1459     entropy-&gt;pub.finish_pass = finish_pass_gather;
1460   else
1461     entropy-&gt;pub.finish_pass = finish_pass_huff;
1462 
1463   if (cinfo-&gt;progressive_mode) {
1464     entropy-&gt;cinfo = cinfo;
1465     entropy-&gt;gather_statistics = gather_statistics;
1466 
1467     /* We assume jcmaster.c already validated the scan parameters. */
1468 
1469     /* Select execution routine */
1470     if (cinfo-&gt;Ah == 0) {
1471       if (cinfo-&gt;Ss == 0)
1472     entropy-&gt;pub.encode_mcu = encode_mcu_DC_first;
1473       else
1474     entropy-&gt;pub.encode_mcu = encode_mcu_AC_first;
1475     } else {
1476       if (cinfo-&gt;Ss == 0)
1477     entropy-&gt;pub.encode_mcu = encode_mcu_DC_refine;
1478       else {
1479     entropy-&gt;pub.encode_mcu = encode_mcu_AC_refine;
1480     /* AC refinement needs a correction bit buffer */
1481     if (entropy-&gt;bit_buffer == NULL)
1482       entropy-&gt;bit_buffer = (char *)
1483         (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
1484                     MAX_CORR_BITS * SIZEOF(char));
1485       }
1486     }
1487 
1488     /* Initialize AC stuff */
1489     entropy-&gt;ac_tbl_no = cinfo-&gt;cur_comp_info[0]-&gt;ac_tbl_no;
1490     entropy-&gt;EOBRUN = 0;
1491     entropy-&gt;BE = 0;
1492   } else {
1493     if (gather_statistics)
1494       entropy-&gt;pub.encode_mcu = encode_mcu_gather;
1495     else
1496       entropy-&gt;pub.encode_mcu = encode_mcu_huff;
1497   }
1498 
1499   for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1500     compptr = cinfo-&gt;cur_comp_info[ci];
1501     /* DC needs no table for refinement scan */
1502     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0) {
1503       tbl = compptr-&gt;dc_tbl_no;
1504       if (gather_statistics) {
1505     /* Check for invalid table index */
1506     /* (make_c_derived_tbl does this in the other path) */
1507     if (tbl &lt; 0 || tbl &gt;= NUM_HUFF_TBLS)
1508       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
1509     /* Allocate and zero the statistics tables */
1510     /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
1511     if (entropy-&gt;dc_count_ptrs[tbl] == NULL)
1512       entropy-&gt;dc_count_ptrs[tbl] = (long *)
1513         (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
1514                     257 * SIZEOF(long));
1515     MEMZERO(entropy-&gt;dc_count_ptrs[tbl], 257 * SIZEOF(long));
1516       } else {
1517     /* Compute derived values for Huffman tables */
1518     /* We may do this more than once for a table, but it&#39;s not expensive */
1519     jpeg_make_c_derived_tbl(cinfo, TRUE, tbl,
1520                 &amp; entropy-&gt;dc_derived_tbls[tbl]);
1521       }
1522       /* Initialize DC predictions to 0 */
1523       entropy-&gt;saved.last_dc_val[ci] = 0;
1524     }
1525     /* AC needs no table when not present */
1526     if (cinfo-&gt;Se) {
1527       tbl = compptr-&gt;ac_tbl_no;
1528       if (gather_statistics) {
1529     if (tbl &lt; 0 || tbl &gt;= NUM_HUFF_TBLS)
1530       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
1531     if (entropy-&gt;ac_count_ptrs[tbl] == NULL)
1532       entropy-&gt;ac_count_ptrs[tbl] = (long *)
1533         (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
1534                     257 * SIZEOF(long));
1535     MEMZERO(entropy-&gt;ac_count_ptrs[tbl], 257 * SIZEOF(long));
1536       } else {
1537     jpeg_make_c_derived_tbl(cinfo, FALSE, tbl,
1538                 &amp; entropy-&gt;ac_derived_tbls[tbl]);
1539       }
1540     }
1541   }
1542 
1543   /* Initialize bit buffer to empty */
1544   entropy-&gt;saved.put_buffer = 0;
1545   entropy-&gt;saved.put_bits = 0;
1546 
1547   /* Initialize restart stuff */
1548   entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1549   entropy-&gt;next_restart_num = 0;
1550 }
1551 
1552 
1553 /*
1554  * Module initialization routine for Huffman entropy encoding.
1555  */
1556 
1557 GLOBAL(void)
1558 jinit_huff_encoder (j_compress_ptr cinfo)
1559 {
1560   huff_entropy_ptr entropy;
1561   int i;
1562 
1563   entropy = (huff_entropy_ptr)
1564     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
1565                 SIZEOF(huff_entropy_encoder));
1566   cinfo-&gt;entropy = &amp;entropy-&gt;pub;
1567   entropy-&gt;pub.start_pass = start_pass_huff;
1568 
1569   /* Mark tables unallocated */
1570   for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1571     entropy-&gt;dc_derived_tbls[i] = entropy-&gt;ac_derived_tbls[i] = NULL;
1572     entropy-&gt;dc_count_ptrs[i] = entropy-&gt;ac_count_ptrs[i] = NULL;
1573   }
1574 
1575   if (cinfo-&gt;progressive_mode)
1576     entropy-&gt;bit_buffer = NULL;    /* needed only in AC refinement scan */
1577 }
    </pre>
  </body>
</html>
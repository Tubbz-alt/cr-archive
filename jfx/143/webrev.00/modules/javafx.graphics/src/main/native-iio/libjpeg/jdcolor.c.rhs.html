<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * jdcolor.c
  3  *
  4  * Copyright (C) 1991-1997, Thomas G. Lane.
<a name="1" id="anc1"></a><span class="line-modified">  5  * Modified 2011-2019 by Guido Vollbeding.</span>
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains output colorspace conversion routines.
 10  */
 11 
 12 #define JPEG_INTERNALS
 13 #include &quot;jinclude.h&quot;
 14 #include &quot;jpeglib.h&quot;
 15 
 16 
 17 #if RANGE_BITS &lt; 2
 18   /* Deliberate syntax err */
 19   Sorry, this code requires 2 or more range extension bits.
 20 #endif
 21 
 22 
 23 /* Private subobject */
 24 
 25 typedef struct {
 26   struct jpeg_color_deconverter pub; /* public fields */
 27 
 28   /* Private state for YCbCr-&gt;RGB and BG_YCC-&gt;RGB conversion */
 29   int * Cr_r_tab;        /* =&gt; table for Cr to R conversion */
 30   int * Cb_b_tab;        /* =&gt; table for Cb to B conversion */
 31   INT32 * Cr_g_tab;        /* =&gt; table for Cr to G conversion */
 32   INT32 * Cb_g_tab;        /* =&gt; table for Cb to G conversion */
 33 
 34   /* Private state for RGB-&gt;Y conversion */
 35   INT32 * rgb_y_tab;        /* =&gt; table for RGB to Y conversion */
 36 } my_color_deconverter;
 37 
 38 typedef my_color_deconverter * my_cconvert_ptr;
 39 
 40 
 41 /***************  YCbCr -&gt; RGB conversion: most common case **************/
 42 /*************** BG_YCC -&gt; RGB conversion: less common case **************/
 43 /***************    RGB -&gt; Y   conversion: less common case **************/
 44 
 45 /*
 46  * YCbCr is defined per Recommendation ITU-R BT.601-7 (03/2011),
 47  * previously known as Recommendation CCIR 601-1, except that Cb and Cr
 48  * are normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
 49  * sRGB (standard RGB color space) is defined per IEC 61966-2-1:1999.
 50  * sYCC (standard luma-chroma-chroma color space with extended gamut)
 51  * is defined per IEC 61966-2-1:1999 Amendment A1:2003 Annex F.
 52  * bg-sRGB and bg-sYCC (big gamut standard color spaces)
 53  * are defined per IEC 61966-2-1:1999 Amendment A1:2003 Annex G.
 54  * Note that the derived conversion coefficients given in some of these
 55  * documents are imprecise.  The general conversion equations are
 56  *
 57  *    R = Y + K * (1 - Kr) * Cr
 58  *    G = Y - K * (Kb * (1 - Kb) * Cb + Kr * (1 - Kr) * Cr) / (1 - Kr - Kb)
 59  *    B = Y + K * (1 - Kb) * Cb
 60  *
 61  *    Y = Kr * R + (1 - Kr - Kb) * G + Kb * B
 62  *
 63  * With Kr = 0.299 and Kb = 0.114 (derived according to SMPTE RP 177-1993
 64  * from the 1953 FCC NTSC primaries and CIE Illuminant C), K = 2 for sYCC,
 65  * the conversion equations to be implemented are therefore
 66  *
 67  *    R = Y + 1.402 * Cr
 68  *    G = Y - 0.344136286 * Cb - 0.714136286 * Cr
 69  *    B = Y + 1.772 * Cb
 70  *
 71  *    Y = 0.299 * R + 0.587 * G + 0.114 * B
 72  *
 73  * where Cb and Cr represent the incoming values less CENTERJSAMPLE.
 74  * For bg-sYCC, with K = 4, the equations are
 75  *
 76  *    R = Y + 2.804 * Cr
 77  *    G = Y - 0.688272572 * Cb - 1.428272572 * Cr
 78  *    B = Y + 3.544 * Cb
 79  *
 80  * To avoid floating-point arithmetic, we represent the fractional constants
 81  * as integers scaled up by 2^16 (about 4 digits precision); we have to divide
 82  * the products by 2^16, with appropriate rounding, to get the correct answer.
 83  * Notice that Y, being an integral input, does not contribute any fraction
 84  * so it need not participate in the rounding.
 85  *
 86  * For even more speed, we avoid doing any multiplications in the inner loop
 87  * by precalculating the constants times Cb and Cr for all possible values.
 88  * For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
 89  * for 9-bit to 12-bit samples it is still acceptable.  It&#39;s not very
 90  * reasonable for 16-bit samples, but if you want lossless storage you
 91  * shouldn&#39;t be changing colorspace anyway.
 92  * The Cr=&gt;R and Cb=&gt;B values can be rounded to integers in advance; the
 93  * values for the G calculation are left scaled up, since we must add them
 94  * together before rounding.
 95  */
 96 
 97 #define SCALEBITS    16    /* speediest right-shift on some machines */
 98 #define ONE_HALF    ((INT32) 1 &lt;&lt; (SCALEBITS-1))
 99 #define FIX(x)        ((INT32) ((x) * (1L&lt;&lt;SCALEBITS) + 0.5))
100 
101 /* We allocate one big table for RGB-&gt;Y conversion and divide it up into
102  * three parts, instead of doing three alloc_small requests.  This lets us
103  * use a single table base address, which can be held in a register in the
104  * inner loops on many machines (more than can hold all three addresses,
105  * anyway).
106  */
107 
108 #define R_Y_OFF        0            /* offset to R =&gt; Y section */
109 #define G_Y_OFF        (1*(MAXJSAMPLE+1))    /* offset to G =&gt; Y section */
110 #define B_Y_OFF        (2*(MAXJSAMPLE+1))    /* etc. */
111 #define TABLE_SIZE    (3*(MAXJSAMPLE+1))
112 
113 
114 /*
115  * Initialize tables for YCbCr-&gt;RGB and BG_YCC-&gt;RGB colorspace conversion.
116  */
117 
118 LOCAL(void)
119 build_ycc_rgb_table (j_decompress_ptr cinfo)
120 /* Normal case, sYCC */
121 {
122   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
123   int i;
124   INT32 x;
125   SHIFT_TEMPS
126 
<a name="2" id="anc2"></a><span class="line-modified">127   cconvert-&gt;Cr_r_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">128     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">129   cconvert-&gt;Cb_b_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">130     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">131   cconvert-&gt;Cr_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">132     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-modified">133   cconvert-&gt;Cb_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">134     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>




135 
136   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
137     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
138     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
139     /* Cr=&gt;R value is nearest int to 1.402 * x */
<a name="3" id="anc3"></a><span class="line-modified">140     cconvert-&gt;Cr_r_tab[i] = (int) DESCALE(FIX(1.402) * x, SCALEBITS);</span>

141     /* Cb=&gt;B value is nearest int to 1.772 * x */
<a name="4" id="anc4"></a><span class="line-modified">142     cconvert-&gt;Cb_b_tab[i] = (int) DESCALE(FIX(1.772) * x, SCALEBITS);</span>

143     /* Cr=&gt;G value is scaled-up -0.714136286 * x */
144     cconvert-&gt;Cr_g_tab[i] = (- FIX(0.714136286)) * x;
145     /* Cb=&gt;G value is scaled-up -0.344136286 * x */
146     /* We also add in ONE_HALF so that need not do it in inner loop */
147     cconvert-&gt;Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
148   }
149 }
150 
151 
152 LOCAL(void)
153 build_bg_ycc_rgb_table (j_decompress_ptr cinfo)
154 /* Wide gamut case, bg-sYCC */
155 {
156   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
157   int i;
158   INT32 x;
159   SHIFT_TEMPS
160 
<a name="5" id="anc5"></a><span class="line-modified">161   cconvert-&gt;Cr_r_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">162     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">163   cconvert-&gt;Cb_b_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">164     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">165   cconvert-&gt;Cr_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">166     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-modified">167   cconvert-&gt;Cb_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">168     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>




169 
170   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
171     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
172     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
173     /* Cr=&gt;R value is nearest int to 2.804 * x */
<a name="6" id="anc6"></a><span class="line-modified">174     cconvert-&gt;Cr_r_tab[i] = (int) DESCALE(FIX(2.804) * x, SCALEBITS);</span>

175     /* Cb=&gt;B value is nearest int to 3.544 * x */
<a name="7" id="anc7"></a><span class="line-modified">176     cconvert-&gt;Cb_b_tab[i] = (int) DESCALE(FIX(3.544) * x, SCALEBITS);</span>

177     /* Cr=&gt;G value is scaled-up -1.428272572 * x */
178     cconvert-&gt;Cr_g_tab[i] = (- FIX(1.428272572)) * x;
179     /* Cb=&gt;G value is scaled-up -0.688272572 * x */
180     /* We also add in ONE_HALF so that need not do it in inner loop */
181     cconvert-&gt;Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
182   }
183 }
184 
185 
186 /*
187  * Convert some rows of samples to the output colorspace.
188  *
189  * Note that we change from noninterleaved, one-plane-per-component format
190  * to interleaved-pixel format.  The output buffer is therefore three times
191  * as wide as the input buffer.
<a name="8" id="anc8"></a><span class="line-added">192  *</span>
193  * A starting row offset is provided only for the input buffer.  The caller
194  * can easily adjust the passed output_buf value to accommodate any row
195  * offset required on that side.
196  */
197 
198 METHODDEF(void)
199 ycc_rgb_convert (j_decompress_ptr cinfo,
200          JSAMPIMAGE input_buf, JDIMENSION input_row,
201          JSAMPARRAY output_buf, int num_rows)
202 {
203   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
204   register int y, cb, cr;
205   register JSAMPROW outptr;
206   register JSAMPROW inptr0, inptr1, inptr2;
207   register JDIMENSION col;
208   JDIMENSION num_cols = cinfo-&gt;output_width;
209   /* copy these pointers into registers if possible */
210   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
211   register int * Crrtab = cconvert-&gt;Cr_r_tab;
212   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
213   register INT32 * Crgtab = cconvert-&gt;Cr_g_tab;
214   register INT32 * Cbgtab = cconvert-&gt;Cb_g_tab;
215   SHIFT_TEMPS
216 
217   while (--num_rows &gt;= 0) {
218     inptr0 = input_buf[0][input_row];
219     inptr1 = input_buf[1][input_row];
220     inptr2 = input_buf[2][input_row];
221     input_row++;
222     outptr = *output_buf++;
223     for (col = 0; col &lt; num_cols; col++) {
224       y  = GETJSAMPLE(inptr0[col]);
225       cb = GETJSAMPLE(inptr1[col]);
226       cr = GETJSAMPLE(inptr2[col]);
227       /* Range-limiting is essential due to noise introduced by DCT losses,
228        * for extended gamut (sYCC) and wide gamut (bg-sYCC) encodings.
229        */
230       outptr[RGB_RED]   = range_limit[y + Crrtab[cr]];
231       outptr[RGB_GREEN] = range_limit[y +
232                   ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
233                          SCALEBITS))];
234       outptr[RGB_BLUE]  = range_limit[y + Cbbtab[cb]];
235       outptr += RGB_PIXELSIZE;
236     }
237   }
238 }
239 
240 
241 /**************** Cases other than YCC -&gt; RGB ****************/
242 
243 
244 /*
245  * Initialize for RGB-&gt;grayscale colorspace conversion.
246  */
247 
248 LOCAL(void)
249 build_rgb_y_table (j_decompress_ptr cinfo)
250 {
251   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
252   INT32 * rgb_y_tab;
253   INT32 i;
254 
255   /* Allocate and fill in the conversion tables. */
<a name="9" id="anc9"></a><span class="line-modified">256   cconvert-&gt;rgb_y_tab = rgb_y_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">257     ((j_common_ptr) cinfo, JPOOL_IMAGE, TABLE_SIZE * SIZEOF(INT32));</span>

258 
259   for (i = 0; i &lt;= MAXJSAMPLE; i++) {
260     rgb_y_tab[i+R_Y_OFF] = FIX(0.299) * i;
261     rgb_y_tab[i+G_Y_OFF] = FIX(0.587) * i;
262     rgb_y_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;
263   }
264 }
265 
266 
267 /*
268  * Convert RGB to grayscale.
269  */
270 
271 METHODDEF(void)
272 rgb_gray_convert (j_decompress_ptr cinfo,
273           JSAMPIMAGE input_buf, JDIMENSION input_row,
274           JSAMPARRAY output_buf, int num_rows)
275 {
276   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
<a name="10" id="anc10"></a>
277   register int r, g, b;
<a name="11" id="anc11"></a><span class="line-added">278   register INT32 * ctab = cconvert-&gt;rgb_y_tab;</span>
279   register JSAMPROW outptr;
280   register JSAMPROW inptr0, inptr1, inptr2;
281   register JDIMENSION col;
282   JDIMENSION num_cols = cinfo-&gt;output_width;
283 
284   while (--num_rows &gt;= 0) {
285     inptr0 = input_buf[0][input_row];
286     inptr1 = input_buf[1][input_row];
287     inptr2 = input_buf[2][input_row];
288     input_row++;
289     outptr = *output_buf++;
290     for (col = 0; col &lt; num_cols; col++) {
291       r = GETJSAMPLE(inptr0[col]);
292       g = GETJSAMPLE(inptr1[col]);
293       b = GETJSAMPLE(inptr2[col]);
294       /* Y */
295       outptr[col] = (JSAMPLE)
296         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
297          &gt;&gt; SCALEBITS);
298     }
299   }
300 }
301 
302 
303 /*
<a name="12" id="anc12"></a><span class="line-added">304  * Convert some rows of samples to the output colorspace.</span>
305  * [R-G,G,B-G] to [R,G,B] conversion with modulo calculation
306  * (inverse color transform).
307  * This can be seen as an adaption of the general YCbCr-&gt;RGB
308  * conversion equation with Kr = Kb = 0, while replacing the
309  * normalization by modulo calculation.
310  */
311 
312 METHODDEF(void)
313 rgb1_rgb_convert (j_decompress_ptr cinfo,
314           JSAMPIMAGE input_buf, JDIMENSION input_row,
315           JSAMPARRAY output_buf, int num_rows)
316 {
317   register int r, g, b;
318   register JSAMPROW outptr;
319   register JSAMPROW inptr0, inptr1, inptr2;
320   register JDIMENSION col;
321   JDIMENSION num_cols = cinfo-&gt;output_width;
322 
323   while (--num_rows &gt;= 0) {
324     inptr0 = input_buf[0][input_row];
325     inptr1 = input_buf[1][input_row];
326     inptr2 = input_buf[2][input_row];
327     input_row++;
328     outptr = *output_buf++;
329     for (col = 0; col &lt; num_cols; col++) {
330       r = GETJSAMPLE(inptr0[col]);
331       g = GETJSAMPLE(inptr1[col]);
332       b = GETJSAMPLE(inptr2[col]);
333       /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD
334        * (modulo) operator is equivalent to the bitmask operator AND.
335        */
336       outptr[RGB_RED]   = (JSAMPLE) ((r + g - CENTERJSAMPLE) &amp; MAXJSAMPLE);
337       outptr[RGB_GREEN] = (JSAMPLE) g;
338       outptr[RGB_BLUE]  = (JSAMPLE) ((b + g - CENTERJSAMPLE) &amp; MAXJSAMPLE);
339       outptr += RGB_PIXELSIZE;
340     }
341   }
342 }
343 
344 
345 /*
346  * [R-G,G,B-G] to grayscale conversion with modulo calculation
347  * (inverse color transform).
348  */
349 
350 METHODDEF(void)
351 rgb1_gray_convert (j_decompress_ptr cinfo,
352            JSAMPIMAGE input_buf, JDIMENSION input_row,
353            JSAMPARRAY output_buf, int num_rows)
354 {
355   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
<a name="13" id="anc13"></a>
356   register int r, g, b;
<a name="14" id="anc14"></a><span class="line-added">357   register INT32 * ctab = cconvert-&gt;rgb_y_tab;</span>
358   register JSAMPROW outptr;
359   register JSAMPROW inptr0, inptr1, inptr2;
360   register JDIMENSION col;
361   JDIMENSION num_cols = cinfo-&gt;output_width;
362 
363   while (--num_rows &gt;= 0) {
364     inptr0 = input_buf[0][input_row];
365     inptr1 = input_buf[1][input_row];
366     inptr2 = input_buf[2][input_row];
367     input_row++;
368     outptr = *output_buf++;
369     for (col = 0; col &lt; num_cols; col++) {
370       r = GETJSAMPLE(inptr0[col]);
371       g = GETJSAMPLE(inptr1[col]);
372       b = GETJSAMPLE(inptr2[col]);
373       /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD
374        * (modulo) operator is equivalent to the bitmask operator AND.
375        */
376       r = (r + g - CENTERJSAMPLE) &amp; MAXJSAMPLE;
377       b = (b + g - CENTERJSAMPLE) &amp; MAXJSAMPLE;
378       /* Y */
379       outptr[col] = (JSAMPLE)
380         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
381          &gt;&gt; SCALEBITS);
382     }
383   }
384 }
385 
386 
387 /*
<a name="15" id="anc15"></a><span class="line-added">388  * Convert some rows of samples to the output colorspace.</span>
389  * No colorspace change, but conversion from separate-planes
390  * to interleaved representation.
391  */
392 
393 METHODDEF(void)
394 rgb_convert (j_decompress_ptr cinfo,
395          JSAMPIMAGE input_buf, JDIMENSION input_row,
396          JSAMPARRAY output_buf, int num_rows)
397 {
398   register JSAMPROW outptr;
399   register JSAMPROW inptr0, inptr1, inptr2;
400   register JDIMENSION col;
401   JDIMENSION num_cols = cinfo-&gt;output_width;
402 
403   while (--num_rows &gt;= 0) {
404     inptr0 = input_buf[0][input_row];
405     inptr1 = input_buf[1][input_row];
406     inptr2 = input_buf[2][input_row];
407     input_row++;
408     outptr = *output_buf++;
409     for (col = 0; col &lt; num_cols; col++) {
410       /* We can dispense with GETJSAMPLE() here */
411       outptr[RGB_RED]   = inptr0[col];
412       outptr[RGB_GREEN] = inptr1[col];
413       outptr[RGB_BLUE]  = inptr2[col];
414       outptr += RGB_PIXELSIZE;
415     }
416   }
417 }
418 
419 
420 /*
421  * Color conversion for no colorspace change: just copy the data,
422  * converting from separate-planes to interleaved representation.
<a name="16" id="anc16"></a><span class="line-added">423  * We assume out_color_components == num_components.</span>
424  */
425 
426 METHODDEF(void)
427 null_convert (j_decompress_ptr cinfo,
428           JSAMPIMAGE input_buf, JDIMENSION input_row,
429           JSAMPARRAY output_buf, int num_rows)
430 {
<a name="17" id="anc17"></a>

431   register JSAMPROW outptr;
432   register JSAMPROW inptr;
<a name="18" id="anc18"></a><span class="line-modified">433   register JDIMENSION count;</span>
<span class="line-added">434   register int num_comps = cinfo-&gt;num_components;</span>
435   JDIMENSION num_cols = cinfo-&gt;output_width;
<a name="19" id="anc19"></a><span class="line-added">436   int ci;</span>
437 
438   while (--num_rows &gt;= 0) {
<a name="20" id="anc20"></a><span class="line-modified">439     /* It seems fastest to make a separate pass for each component. */</span>
<span class="line-added">440     for (ci = 0; ci &lt; num_comps; ci++) {</span>
441       inptr = input_buf[ci][input_row];
442       outptr = output_buf[0] + ci;
<a name="21" id="anc21"></a><span class="line-modified">443       for (count = num_cols; count &gt; 0; count--) {</span>
<span class="line-modified">444     *outptr = *inptr++;    /* don&#39;t need GETJSAMPLE() here */</span>
<span class="line-modified">445     outptr += num_comps;</span>
446       }
447     }
448     input_row++;
449     output_buf++;
450   }
451 }
452 
453 
454 /*
455  * Color conversion for grayscale: just copy the data.
456  * This also works for YCC -&gt; grayscale conversion, in which
457  * we just copy the Y (luminance) component and ignore chrominance.
458  */
459 
460 METHODDEF(void)
461 grayscale_convert (j_decompress_ptr cinfo,
462            JSAMPIMAGE input_buf, JDIMENSION input_row,
463            JSAMPARRAY output_buf, int num_rows)
464 {
465   jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
466             num_rows, cinfo-&gt;output_width);
467 }
468 
469 
470 /*
471  * Convert grayscale to RGB: just duplicate the graylevel three times.
472  * This is provided to support applications that don&#39;t want to cope
473  * with grayscale as a separate case.
474  */
475 
476 METHODDEF(void)
477 gray_rgb_convert (j_decompress_ptr cinfo,
478           JSAMPIMAGE input_buf, JDIMENSION input_row,
479           JSAMPARRAY output_buf, int num_rows)
480 {
481   register JSAMPROW outptr;
482   register JSAMPROW inptr;
483   register JDIMENSION col;
484   JDIMENSION num_cols = cinfo-&gt;output_width;
485 
486   while (--num_rows &gt;= 0) {
487     inptr = input_buf[0][input_row++];
488     outptr = *output_buf++;
489     for (col = 0; col &lt; num_cols; col++) {
490       /* We can dispense with GETJSAMPLE() here */
491       outptr[RGB_RED] = outptr[RGB_GREEN] = outptr[RGB_BLUE] = inptr[col];
492       outptr += RGB_PIXELSIZE;
493     }
494   }
495 }
496 
497 
498 /*
499  * YCCK-&gt;CMYK-&gt;CMY-&gt;RGB conversion.
500  *
501  * NB: this color conversion is introduced in jfx libjpeg snapshot as
502  *     a part of the fix for JDK-8096615. In case of library upgrade, please
503  *     check whether this convertor needs to be moved into upgraded version
504  *     of the library.
505  */
506 METHODDEF(void)
507 ycck_rgb_convert (j_decompress_ptr cinfo,
508                    JSAMPIMAGE input_buf, JDIMENSION input_row,
509                    JSAMPARRAY output_buf, int num_rows)
510 {
511   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
512   register int y, cb, cr, k;
513   register int C, M, Y;
514   register int r, g, b;
515   register JSAMPROW outptr;
516   register JSAMPROW inptr0, inptr1, inptr2, inptr3;
517   register JDIMENSION col;
518   JDIMENSION num_cols = cinfo-&gt;output_width;
519   /* copy these pointers into registers if possible */
520   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
521   register int * Crrtab = cconvert-&gt;Cr_r_tab;
522   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
523   register INT32 * Crgtab = cconvert-&gt;Cr_g_tab;
524   register INT32 * Cbgtab = cconvert-&gt;Cb_g_tab;
525   SHIFT_TEMPS
526 
527   while (--num_rows &gt;= 0) {
528     inptr0 = input_buf[0][input_row];
529     inptr1 = input_buf[1][input_row];
530     inptr2 = input_buf[2][input_row];
531     inptr3 = input_buf[3][input_row];
532     input_row++;
533     outptr = *output_buf++;
534     for (col = 0; col &lt; num_cols; col++) {
535       y  = GETJSAMPLE(inptr0[col]);
536       cb = GETJSAMPLE(inptr1[col]);
537       cr = GETJSAMPLE(inptr2[col]);
538       k  = GETJSAMPLE(inptr3[col]);
539 
540       C = MAXJSAMPLE - (y + Crrtab[cr]);
541       M = MAXJSAMPLE - (y + ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS)));
542       Y = MAXJSAMPLE - (y + Cbbtab[cb]);
543 
544       r = C * k / MAXJSAMPLE;
545       g = M * k / MAXJSAMPLE;
546       b = Y * k / MAXJSAMPLE;
547 
548       /* Range-limiting is essential due to noise introduced by DCT losses. */
549       outptr[RGB_RED] = range_limit[r];
550       outptr[RGB_GREEN] = range_limit[g];
551       outptr[RGB_BLUE] = range_limit[b];
552 
553       outptr += RGB_PIXELSIZE;
554     }
555   }
556 }
557 
558 /*
559  * CMYK-&gt;CMY-&gt;RGB conversion.
560  *
561  * NB: this color conversion is introduced in jfx libjpeg snapshot as
562  *     a part of the fix for JDK-8096615. In case of library upgrade, please
563  *     check whether this convertor needs to be moved into upgraded version
564  *     of the library.
565  */
566 METHODDEF(void)
567 cmyk_rgb_convert (j_decompress_ptr cinfo,
568                    JSAMPIMAGE input_buf, JDIMENSION input_row,
569                    JSAMPARRAY output_buf, int num_rows)
570 {
571   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
572   register int c, m, y, k;
573   register int r, g, b;
574   register JSAMPROW outptr;
575   register JSAMPROW inptr0, inptr1, inptr2, inptr3;
576   register JDIMENSION col;
577   JDIMENSION num_cols = cinfo-&gt;output_width;
578   /* copy these pointers into registers if possible */
579   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
580   SHIFT_TEMPS
581 
582   while (--num_rows &gt;= 0) {
583     inptr0 = input_buf[0][input_row];
584     inptr1 = input_buf[1][input_row];
585     inptr2 = input_buf[2][input_row];
586     inptr3 = input_buf[3][input_row];
587     input_row++;
588     outptr = *output_buf++;
589     for (col = 0; col &lt; num_cols; col++) {
590       c = GETJSAMPLE(inptr0[col]);
591       m = GETJSAMPLE(inptr1[col]);
592       y = GETJSAMPLE(inptr2[col]);
593       k = GETJSAMPLE(inptr3[col]);
594 
595       r = c * k / MAXJSAMPLE;
596       g = m * k / MAXJSAMPLE;
597       b = y * k / MAXJSAMPLE;
598 
599       /* Range-limiting is essential due to noise introduced by DCT losses. */
600       outptr[RGB_RED] = range_limit[r];
601       outptr[RGB_GREEN] = range_limit[g];
602       outptr[RGB_BLUE] = range_limit[b];
603 
604       outptr += RGB_PIXELSIZE;
605     }
606   }
607 }
608 
609 
610 /*
<a name="22" id="anc22"></a><span class="line-modified">611  * Convert some rows of samples to the output colorspace.</span>
<span class="line-modified">612  * This version handles Adobe-style YCCK-&gt;CMYK conversion,</span>
<span class="line-modified">613  * where we convert YCbCr to R=1-C, G=1-M, and B=1-Y using the</span>
<span class="line-added">614  * same conversion as above, while passing K (black) unchanged.</span>
615  * We assume build_ycc_rgb_table has been called.
616  */
617 
618 METHODDEF(void)
619 ycck_cmyk_convert (j_decompress_ptr cinfo,
620            JSAMPIMAGE input_buf, JDIMENSION input_row,
621            JSAMPARRAY output_buf, int num_rows)
622 {
623   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
624   register int y, cb, cr;
625   register JSAMPROW outptr;
626   register JSAMPROW inptr0, inptr1, inptr2, inptr3;
627   register JDIMENSION col;
628   JDIMENSION num_cols = cinfo-&gt;output_width;
629   /* copy these pointers into registers if possible */
630   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
631   register int * Crrtab = cconvert-&gt;Cr_r_tab;
632   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
633   register INT32 * Crgtab = cconvert-&gt;Cr_g_tab;
634   register INT32 * Cbgtab = cconvert-&gt;Cb_g_tab;
635   SHIFT_TEMPS
636 
637   while (--num_rows &gt;= 0) {
638     inptr0 = input_buf[0][input_row];
639     inptr1 = input_buf[1][input_row];
640     inptr2 = input_buf[2][input_row];
641     inptr3 = input_buf[3][input_row];
642     input_row++;
643     outptr = *output_buf++;
644     for (col = 0; col &lt; num_cols; col++) {
645       y  = GETJSAMPLE(inptr0[col]);
646       cb = GETJSAMPLE(inptr1[col]);
647       cr = GETJSAMPLE(inptr2[col]);
648       /* Range-limiting is essential due to noise introduced by DCT losses,
649        * and for extended gamut encodings (sYCC).
650        */
651       outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];    /* red */
652       outptr[1] = range_limit[MAXJSAMPLE - (y +            /* green */
653                   ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
654                          SCALEBITS)))];
655       outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];    /* blue */
656       /* K passes through unchanged */
657       outptr[3] = inptr3[col];    /* don&#39;t need GETJSAMPLE here */
658       outptr += 4;
659     }
660   }
661 }
662 
663 
664 /*
665  * Empty method for start_pass.
666  */
667 
668 METHODDEF(void)
669 start_pass_dcolor (j_decompress_ptr cinfo)
670 {
671   /* no work needed */
672 }
673 
674 
675 /*
676  * Module initialization routine for output colorspace conversion.
677  */
678 
679 GLOBAL(void)
680 jinit_color_deconverter (j_decompress_ptr cinfo)
681 {
682   my_cconvert_ptr cconvert;
683   int ci;
684 
<a name="23" id="anc23"></a><span class="line-modified">685   cconvert = (my_cconvert_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">686     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_color_deconverter));</span>

687   cinfo-&gt;cconvert = &amp;cconvert-&gt;pub;
688   cconvert-&gt;pub.start_pass = start_pass_dcolor;
689 
690   /* Make sure num_components agrees with jpeg_color_space */
691   switch (cinfo-&gt;jpeg_color_space) {
692   case JCS_GRAYSCALE:
693     if (cinfo-&gt;num_components != 1)
694       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
695     break;
696 
697   case JCS_RGB:
698   case JCS_YCbCr:
699   case JCS_BG_RGB:
700   case JCS_BG_YCC:
701     if (cinfo-&gt;num_components != 3)
702       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
703     break;
704 
705   case JCS_CMYK:
706   case JCS_YCCK:
707     if (cinfo-&gt;num_components != 4)
708       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
709     break;
710 
711   default:            /* JCS_UNKNOWN can be anything */
712     if (cinfo-&gt;num_components &lt; 1)
713       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
<a name="24" id="anc24"></a>
714   }
715 
716   /* Support color transform only for RGB colorspaces */
717   if (cinfo-&gt;color_transform &amp;&amp;
718       cinfo-&gt;jpeg_color_space != JCS_RGB &amp;&amp;
719       cinfo-&gt;jpeg_color_space != JCS_BG_RGB)
720     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
721 
722   /* Set out_color_components and conversion method based on requested space.
723    * Also clear the component_needed flags for any unused components,
724    * so that earlier pipeline stages can avoid useless computation.
725    */
726 
727   switch (cinfo-&gt;out_color_space) {
728   case JCS_GRAYSCALE:
729     cinfo-&gt;out_color_components = 1;
730     switch (cinfo-&gt;jpeg_color_space) {
731     case JCS_GRAYSCALE:
732     case JCS_YCbCr:
733     case JCS_BG_YCC:
734       cconvert-&gt;pub.color_convert = grayscale_convert;
735       /* For color-&gt;grayscale conversion, only the Y (0) component is needed */
736       for (ci = 1; ci &lt; cinfo-&gt;num_components; ci++)
737     cinfo-&gt;comp_info[ci].component_needed = FALSE;
738       break;
739     case JCS_RGB:
740       switch (cinfo-&gt;color_transform) {
741       case JCT_NONE:
742     cconvert-&gt;pub.color_convert = rgb_gray_convert;
743     break;
744       case JCT_SUBTRACT_GREEN:
745     cconvert-&gt;pub.color_convert = rgb1_gray_convert;
746     break;
747       default:
748     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
749       }
750       build_rgb_y_table(cinfo);
751       break;
752     default:
753       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
754     }
755     break;
756 
757   case JCS_RGB:
758     cinfo-&gt;out_color_components = RGB_PIXELSIZE;
759     switch (cinfo-&gt;jpeg_color_space) {
760     case JCS_GRAYSCALE:
761       cconvert-&gt;pub.color_convert = gray_rgb_convert;
762       break;
763     case JCS_YCbCr:
764       cconvert-&gt;pub.color_convert = ycc_rgb_convert;
765       build_ycc_rgb_table(cinfo);
766       break;
767     case JCS_BG_YCC:
768       cconvert-&gt;pub.color_convert = ycc_rgb_convert;
769       build_bg_ycc_rgb_table(cinfo);
770       break;
771     case JCS_RGB:
772       switch (cinfo-&gt;color_transform) {
773       case JCT_NONE:
<a name="25" id="anc25"></a><span class="line-modified">774     cconvert-&gt;pub.color_convert = rgb_convert;</span>
<span class="line-modified">775     break;</span>
776       case JCT_SUBTRACT_GREEN:
<a name="26" id="anc26"></a><span class="line-modified">777     cconvert-&gt;pub.color_convert = rgb1_rgb_convert;</span>
<span class="line-modified">778     break;</span>
779       default:
<a name="27" id="anc27"></a><span class="line-modified">780     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
781       }
782       break;
783     case JCS_YCCK:
784       cconvert-&gt;pub.color_convert = ycck_rgb_convert;
785       build_ycc_rgb_table(cinfo);
786       break;
787     case JCS_CMYK:
788       cconvert-&gt;pub.color_convert = cmyk_rgb_convert;
789       break;
790     default:
791       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
792     }
793     break;
794 
795   case JCS_BG_RGB:
796     cinfo-&gt;out_color_components = RGB_PIXELSIZE;
<a name="28" id="anc28"></a><span class="line-modified">797     if (cinfo-&gt;jpeg_color_space != JCS_BG_RGB)</span>
<span class="line-modified">798       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
<span class="line-modified">799     switch (cinfo-&gt;color_transform) {</span>
<span class="line-modified">800     case JCT_NONE:</span>
<span class="line-modified">801       cconvert-&gt;pub.color_convert = rgb_convert;</span>
<span class="line-modified">802       break;</span>
<span class="line-modified">803     case JCT_SUBTRACT_GREEN:</span>
<span class="line-modified">804       cconvert-&gt;pub.color_convert = rgb1_rgb_convert;</span>
<span class="line-modified">805       break;</span>
<span class="line-modified">806     default:</span>


807       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
<a name="29" id="anc29"></a><span class="line-added">808     }</span>
809     break;
810 
811   case JCS_CMYK:
812     cinfo-&gt;out_color_components = 4;
813     switch (cinfo-&gt;jpeg_color_space) {
814     case JCS_YCCK:
815       cconvert-&gt;pub.color_convert = ycck_cmyk_convert;
816       build_ycc_rgb_table(cinfo);
817       break;
818     case JCS_CMYK:
819       cconvert-&gt;pub.color_convert = null_convert;
820       break;
821     default:
822       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
823     }
824     break;
825 
<a name="30" id="anc30"></a><span class="line-modified">826   default:        /* permit null conversion to same output space */</span>
<span class="line-modified">827     if (cinfo-&gt;out_color_space != cinfo-&gt;jpeg_color_space)</span>
<span class="line-modified">828       /* unsupported non-null conversion */</span>



829       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
<a name="31" id="anc31"></a><span class="line-modified">830     cinfo-&gt;out_color_components = cinfo-&gt;num_components;</span>
<span class="line-added">831     cconvert-&gt;pub.color_convert = null_convert;</span>
832   }
833 
834   if (cinfo-&gt;quantize_colors)
835     cinfo-&gt;output_components = 1; /* single colormapped output component */
836   else
837     cinfo-&gt;output_components = cinfo-&gt;out_color_components;
838 }
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-iio/libjpeg/jdmerge.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jdmaster.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdtrans.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-iio/libjpeg/jdmerge.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * jdmerge.c
  3  *
  4  * Copyright (C) 1994-1996, Thomas G. Lane.
<span class="line-modified">  5  * Modified 2013-2017 by Guido Vollbeding.</span>
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains code for merged upsampling/color conversion.
 10  *
 11  * This file combines functions from jdsample.c and jdcolor.c;
 12  * read those files first to understand what&#39;s going on.
 13  *
 14  * When the chroma components are to be upsampled by simple replication
 15  * (ie, box filtering), we can save some work in color conversion by
 16  * calculating all the output pixels corresponding to a pair of chroma
 17  * samples at one time.  In the conversion equations
 18  *    R = Y           + K1 * Cr
 19  *    G = Y + K2 * Cb + K3 * Cr
 20  *    B = Y + K4 * Cb
 21  * only the Y term varies among the group of pixels corresponding to a pair
 22  * of chroma samples, so the rest of the terms can be calculated just once.
 23  * At typical sampling ratios, this eliminates half or three-quarters of the
 24  * multiplications needed for color conversion.
 25  *
</pre>
<hr />
<pre>
 78 
 79 #define SCALEBITS    16    /* speediest right-shift on some machines */
 80 #define ONE_HALF    ((INT32) 1 &lt;&lt; (SCALEBITS-1))
 81 #define FIX(x)        ((INT32) ((x) * (1L&lt;&lt;SCALEBITS) + 0.5))
 82 
 83 
 84 /*
 85  * Initialize tables for YCbCr-&gt;RGB and BG_YCC-&gt;RGB colorspace conversion.
 86  * This is taken directly from jdcolor.c; see that file for more info.
 87  */
 88 
 89 LOCAL(void)
 90 build_ycc_rgb_table (j_decompress_ptr cinfo)
 91 /* Normal case, sYCC */
 92 {
 93   my_upsample_ptr upsample = (my_upsample_ptr) cinfo-&gt;upsample;
 94   int i;
 95   INT32 x;
 96   SHIFT_TEMPS
 97 
<span class="line-modified"> 98   upsample-&gt;Cr_r_tab = (int *)</span>
<span class="line-modified"> 99     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">100                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">101   upsample-&gt;Cb_b_tab = (int *)</span>
<span class="line-modified">102     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">103                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">104   upsample-&gt;Cr_g_tab = (INT32 *)</span>
<span class="line-modified">105     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">106                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-removed">107   upsample-&gt;Cb_g_tab = (INT32 *)</span>
<span class="line-removed">108     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">109                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
110 
111   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
112     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
113     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
114     /* Cr=&gt;R value is nearest int to 1.402 * x */
<span class="line-modified">115     upsample-&gt;Cr_r_tab[i] = (int)</span>
<span class="line-removed">116             RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);</span>
117     /* Cb=&gt;B value is nearest int to 1.772 * x */
<span class="line-modified">118     upsample-&gt;Cb_b_tab[i] = (int)</span>
<span class="line-removed">119             RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);</span>
120     /* Cr=&gt;G value is scaled-up -0.714136286 * x */
121     upsample-&gt;Cr_g_tab[i] = (- FIX(0.714136286)) * x;
122     /* Cb=&gt;G value is scaled-up -0.344136286 * x */
123     /* We also add in ONE_HALF so that need not do it in inner loop */
124     upsample-&gt;Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
125   }
126 }
127 
128 
129 LOCAL(void)
130 build_bg_ycc_rgb_table (j_decompress_ptr cinfo)
131 /* Wide gamut case, bg-sYCC */
132 {
133   my_upsample_ptr upsample = (my_upsample_ptr) cinfo-&gt;upsample;
134   int i;
135   INT32 x;
136   SHIFT_TEMPS
137 
<span class="line-modified">138   upsample-&gt;Cr_r_tab = (int *)</span>
<span class="line-modified">139     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">140                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">141   upsample-&gt;Cb_b_tab = (int *)</span>
<span class="line-modified">142     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">143                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">144   upsample-&gt;Cr_g_tab = (INT32 *)</span>
<span class="line-modified">145     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">146                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-removed">147   upsample-&gt;Cb_g_tab = (INT32 *)</span>
<span class="line-removed">148     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">149                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
150 
151   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
152     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
153     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
154     /* Cr=&gt;R value is nearest int to 2.804 * x */
<span class="line-modified">155     upsample-&gt;Cr_r_tab[i] = (int)</span>
<span class="line-removed">156             RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);</span>
157     /* Cb=&gt;B value is nearest int to 3.544 * x */
<span class="line-modified">158     upsample-&gt;Cb_b_tab[i] = (int)</span>
<span class="line-removed">159             RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);</span>
160     /* Cr=&gt;G value is scaled-up -1.428272572 * x */
161     upsample-&gt;Cr_g_tab[i] = (- FIX(1.428272572)) * x;
162     /* Cb=&gt;G value is scaled-up -0.688272572 * x */
163     /* We also add in ONE_HALF so that need not do it in inner loop */
164     upsample-&gt;Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
165   }
166 }
167 
168 
169 /*
170  * Initialize for an upsampling pass.
171  */
172 
173 METHODDEF(void)
174 start_pass_merged_upsample (j_decompress_ptr cinfo)
175 {
176   my_upsample_ptr upsample = (my_upsample_ptr) cinfo-&gt;upsample;
177 
178   /* Mark the spare buffer empty */
179   upsample-&gt;spare_full = FALSE;
</pre>
<hr />
<pre>
402     outptr1[RGB_RED]   = range_limit[y + cred];
403     outptr1[RGB_GREEN] = range_limit[y + cgreen];
404     outptr1[RGB_BLUE]  = range_limit[y + cblue];
405   }
406 }
407 
408 
409 /*
410  * Module initialization routine for merged upsampling/color conversion.
411  *
412  * NB: this is called under the conditions determined by use_merged_upsample()
413  * in jdmaster.c.  That routine MUST correspond to the actual capabilities
414  * of this module; no safety checks are made here.
415  */
416 
417 GLOBAL(void)
418 jinit_merged_upsampler (j_decompress_ptr cinfo)
419 {
420   my_upsample_ptr upsample;
421 
<span class="line-modified">422   upsample = (my_upsample_ptr)</span>
<span class="line-modified">423     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">424                 SIZEOF(my_upsampler));</span>
425   cinfo-&gt;upsample = &amp;upsample-&gt;pub;
426   upsample-&gt;pub.start_pass = start_pass_merged_upsample;
427   upsample-&gt;pub.need_context_rows = FALSE;
428 
429   upsample-&gt;out_row_width = cinfo-&gt;output_width * cinfo-&gt;out_color_components;
430 
431   if (cinfo-&gt;max_v_samp_factor == 2) {
432     upsample-&gt;pub.upsample = merged_2v_upsample;
433     upsample-&gt;upmethod = h2v2_merged_upsample;
434     /* Allocate a spare row buffer */
<span class="line-modified">435     upsample-&gt;spare_row = (JSAMPROW)</span>
<span class="line-modified">436       (*cinfo-&gt;mem-&gt;alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">437         (size_t) (upsample-&gt;out_row_width * SIZEOF(JSAMPLE)));</span>
438   } else {
439     upsample-&gt;pub.upsample = merged_1v_upsample;
440     upsample-&gt;upmethod = h2v1_merged_upsample;
441     /* No spare row needed */
442     upsample-&gt;spare_row = NULL;
443   }
444 
445   if (cinfo-&gt;jpeg_color_space == JCS_BG_YCC)
446     build_bg_ycc_rgb_table(cinfo);
447   else
448     build_ycc_rgb_table(cinfo);
449 }
450 
451 #endif /* UPSAMPLE_MERGING_SUPPORTED */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * jdmerge.c
  3  *
  4  * Copyright (C) 1994-1996, Thomas G. Lane.
<span class="line-modified">  5  * Modified 2013-2019 by Guido Vollbeding.</span>
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains code for merged upsampling/color conversion.
 10  *
 11  * This file combines functions from jdsample.c and jdcolor.c;
 12  * read those files first to understand what&#39;s going on.
 13  *
 14  * When the chroma components are to be upsampled by simple replication
 15  * (ie, box filtering), we can save some work in color conversion by
 16  * calculating all the output pixels corresponding to a pair of chroma
 17  * samples at one time.  In the conversion equations
 18  *    R = Y           + K1 * Cr
 19  *    G = Y + K2 * Cb + K3 * Cr
 20  *    B = Y + K4 * Cb
 21  * only the Y term varies among the group of pixels corresponding to a pair
 22  * of chroma samples, so the rest of the terms can be calculated just once.
 23  * At typical sampling ratios, this eliminates half or three-quarters of the
 24  * multiplications needed for color conversion.
 25  *
</pre>
<hr />
<pre>
 78 
 79 #define SCALEBITS    16    /* speediest right-shift on some machines */
 80 #define ONE_HALF    ((INT32) 1 &lt;&lt; (SCALEBITS-1))
 81 #define FIX(x)        ((INT32) ((x) * (1L&lt;&lt;SCALEBITS) + 0.5))
 82 
 83 
 84 /*
 85  * Initialize tables for YCbCr-&gt;RGB and BG_YCC-&gt;RGB colorspace conversion.
 86  * This is taken directly from jdcolor.c; see that file for more info.
 87  */
 88 
 89 LOCAL(void)
 90 build_ycc_rgb_table (j_decompress_ptr cinfo)
 91 /* Normal case, sYCC */
 92 {
 93   my_upsample_ptr upsample = (my_upsample_ptr) cinfo-&gt;upsample;
 94   int i;
 95   INT32 x;
 96   SHIFT_TEMPS
 97 
<span class="line-modified"> 98   upsample-&gt;Cr_r_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified"> 99     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">100   upsample-&gt;Cb_b_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">101     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">102   upsample-&gt;Cr_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">103     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-modified">104   upsample-&gt;Cb_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">105     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>




106 
107   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
108     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
109     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
110     /* Cr=&gt;R value is nearest int to 1.402 * x */
<span class="line-modified">111     upsample-&gt;Cr_r_tab[i] = (int) DESCALE(FIX(1.402) * x, SCALEBITS);</span>

112     /* Cb=&gt;B value is nearest int to 1.772 * x */
<span class="line-modified">113     upsample-&gt;Cb_b_tab[i] = (int) DESCALE(FIX(1.772) * x, SCALEBITS);</span>

114     /* Cr=&gt;G value is scaled-up -0.714136286 * x */
115     upsample-&gt;Cr_g_tab[i] = (- FIX(0.714136286)) * x;
116     /* Cb=&gt;G value is scaled-up -0.344136286 * x */
117     /* We also add in ONE_HALF so that need not do it in inner loop */
118     upsample-&gt;Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
119   }
120 }
121 
122 
123 LOCAL(void)
124 build_bg_ycc_rgb_table (j_decompress_ptr cinfo)
125 /* Wide gamut case, bg-sYCC */
126 {
127   my_upsample_ptr upsample = (my_upsample_ptr) cinfo-&gt;upsample;
128   int i;
129   INT32 x;
130   SHIFT_TEMPS
131 
<span class="line-modified">132   upsample-&gt;Cr_r_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">133     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">134   upsample-&gt;Cb_b_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">135     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">136   upsample-&gt;Cr_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">137     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-modified">138   upsample-&gt;Cb_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">139     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>




140 
141   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
142     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
143     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
144     /* Cr=&gt;R value is nearest int to 2.804 * x */
<span class="line-modified">145     upsample-&gt;Cr_r_tab[i] = (int) DESCALE(FIX(2.804) * x, SCALEBITS);</span>

146     /* Cb=&gt;B value is nearest int to 3.544 * x */
<span class="line-modified">147     upsample-&gt;Cb_b_tab[i] = (int) DESCALE(FIX(3.544) * x, SCALEBITS);</span>

148     /* Cr=&gt;G value is scaled-up -1.428272572 * x */
149     upsample-&gt;Cr_g_tab[i] = (- FIX(1.428272572)) * x;
150     /* Cb=&gt;G value is scaled-up -0.688272572 * x */
151     /* We also add in ONE_HALF so that need not do it in inner loop */
152     upsample-&gt;Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
153   }
154 }
155 
156 
157 /*
158  * Initialize for an upsampling pass.
159  */
160 
161 METHODDEF(void)
162 start_pass_merged_upsample (j_decompress_ptr cinfo)
163 {
164   my_upsample_ptr upsample = (my_upsample_ptr) cinfo-&gt;upsample;
165 
166   /* Mark the spare buffer empty */
167   upsample-&gt;spare_full = FALSE;
</pre>
<hr />
<pre>
390     outptr1[RGB_RED]   = range_limit[y + cred];
391     outptr1[RGB_GREEN] = range_limit[y + cgreen];
392     outptr1[RGB_BLUE]  = range_limit[y + cblue];
393   }
394 }
395 
396 
397 /*
398  * Module initialization routine for merged upsampling/color conversion.
399  *
400  * NB: this is called under the conditions determined by use_merged_upsample()
401  * in jdmaster.c.  That routine MUST correspond to the actual capabilities
402  * of this module; no safety checks are made here.
403  */
404 
405 GLOBAL(void)
406 jinit_merged_upsampler (j_decompress_ptr cinfo)
407 {
408   my_upsample_ptr upsample;
409 
<span class="line-modified">410   upsample = (my_upsample_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">411     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_upsampler));</span>

412   cinfo-&gt;upsample = &amp;upsample-&gt;pub;
413   upsample-&gt;pub.start_pass = start_pass_merged_upsample;
414   upsample-&gt;pub.need_context_rows = FALSE;
415 
416   upsample-&gt;out_row_width = cinfo-&gt;output_width * cinfo-&gt;out_color_components;
417 
418   if (cinfo-&gt;max_v_samp_factor == 2) {
419     upsample-&gt;pub.upsample = merged_2v_upsample;
420     upsample-&gt;upmethod = h2v2_merged_upsample;
421     /* Allocate a spare row buffer */
<span class="line-modified">422     upsample-&gt;spare_row = (JSAMPROW) (*cinfo-&gt;mem-&gt;alloc_large)</span>
<span class="line-modified">423       ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">424        (size_t) upsample-&gt;out_row_width * SIZEOF(JSAMPLE));</span>
425   } else {
426     upsample-&gt;pub.upsample = merged_1v_upsample;
427     upsample-&gt;upmethod = h2v1_merged_upsample;
428     /* No spare row needed */
429     upsample-&gt;spare_row = NULL;
430   }
431 
432   if (cinfo-&gt;jpeg_color_space == JCS_BG_YCC)
433     build_bg_ycc_rgb_table(cinfo);
434   else
435     build_ycc_rgb_table(cinfo);
436 }
437 
438 #endif /* UPSAMPLE_MERGING_SUPPORTED */
</pre>
</td>
</tr>
</table>
<center><a href="jdmaster.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdtrans.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
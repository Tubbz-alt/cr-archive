<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-iio/libjpeg/jcmarker.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * jcmarker.c
  3  *
  4  * Copyright (C) 1991-1998, Thomas G. Lane.
  5  * Modified 2003-2013 by Guido Vollbeding.
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains routines to write JPEG datastream markers.
 10  */
 11 
 12 #define JPEG_INTERNALS
 13 #include &quot;jinclude.h&quot;
 14 #include &quot;jpeglib.h&quot;
 15 
 16 
 17 typedef enum {            /* JPEG marker codes */
 18   M_SOF0  = 0xc0,
 19   M_SOF1  = 0xc1,
 20   M_SOF2  = 0xc2,
 21   M_SOF3  = 0xc3,
 22 
 23   M_SOF5  = 0xc5,
 24   M_SOF6  = 0xc6,
 25   M_SOF7  = 0xc7,
 26 
 27   M_JPG   = 0xc8,
 28   M_SOF9  = 0xc9,
 29   M_SOF10 = 0xca,
 30   M_SOF11 = 0xcb,
 31 
 32   M_SOF13 = 0xcd,
 33   M_SOF14 = 0xce,
 34   M_SOF15 = 0xcf,
 35 
 36   M_DHT   = 0xc4,
 37 
 38   M_DAC   = 0xcc,
 39 
 40   M_RST0  = 0xd0,
 41   M_RST1  = 0xd1,
 42   M_RST2  = 0xd2,
 43   M_RST3  = 0xd3,
 44   M_RST4  = 0xd4,
 45   M_RST5  = 0xd5,
 46   M_RST6  = 0xd6,
 47   M_RST7  = 0xd7,
 48 
 49   M_SOI   = 0xd8,
 50   M_EOI   = 0xd9,
 51   M_SOS   = 0xda,
 52   M_DQT   = 0xdb,
 53   M_DNL   = 0xdc,
 54   M_DRI   = 0xdd,
 55   M_DHP   = 0xde,
 56   M_EXP   = 0xdf,
 57 
 58   M_APP0  = 0xe0,
 59   M_APP1  = 0xe1,
 60   M_APP2  = 0xe2,
 61   M_APP3  = 0xe3,
 62   M_APP4  = 0xe4,
 63   M_APP5  = 0xe5,
 64   M_APP6  = 0xe6,
 65   M_APP7  = 0xe7,
 66   M_APP8  = 0xe8,
 67   M_APP9  = 0xe9,
 68   M_APP10 = 0xea,
 69   M_APP11 = 0xeb,
 70   M_APP12 = 0xec,
 71   M_APP13 = 0xed,
 72   M_APP14 = 0xee,
 73   M_APP15 = 0xef,
 74 
 75   M_JPG0  = 0xf0,
 76   M_JPG8  = 0xf8,
 77   M_JPG13 = 0xfd,
 78   M_COM   = 0xfe,
 79 
 80   M_TEM   = 0x01,
 81 
 82   M_ERROR = 0x100
 83 } JPEG_MARKER;
 84 
 85 
 86 /* Private state */
 87 
 88 typedef struct {
 89   struct jpeg_marker_writer pub; /* public fields */
 90 
 91   unsigned int last_restart_interval; /* last DRI value emitted; 0 after SOI */
 92 } my_marker_writer;
 93 
 94 typedef my_marker_writer * my_marker_ptr;
 95 
 96 
 97 /*
 98  * Basic output routines.
 99  *
100  * Note that we do not support suspension while writing a marker.
101  * Therefore, an application using suspension must ensure that there is
102  * enough buffer space for the initial markers (typ. 600-700 bytes) before
103  * calling jpeg_start_compress, and enough space to write the trailing EOI
104  * (a few bytes) before calling jpeg_finish_compress.  Multipass compression
105  * modes are not supported at all with suspension, so those two are the only
106  * points where markers will be written.
107  */
108 
109 LOCAL(void)
110 emit_byte (j_compress_ptr cinfo, int val)
111 /* Emit a byte */
112 {
113   struct jpeg_destination_mgr * dest = cinfo-&gt;dest;
114 
115   *(dest-&gt;next_output_byte)++ = (JOCTET) val;
116   if (--dest-&gt;free_in_buffer == 0) {
117     if (! (*dest-&gt;empty_output_buffer) (cinfo))
118       ERREXIT(cinfo, JERR_CANT_SUSPEND);
119   }
120 }
121 
122 
123 LOCAL(void)
124 emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)
125 /* Emit a marker code */
126 {
127   emit_byte(cinfo, 0xFF);
128   emit_byte(cinfo, (int) mark);
129 }
130 
131 
132 LOCAL(void)
133 emit_2bytes (j_compress_ptr cinfo, int value)
134 /* Emit a 2-byte integer; these are always MSB first in JPEG files */
135 {
136   emit_byte(cinfo, (value &gt;&gt; 8) &amp; 0xFF);
137   emit_byte(cinfo, value &amp; 0xFF);
138 }
139 
140 
141 /*
142  * Routines to write specific marker types.
143  */
144 
145 LOCAL(int)
146 emit_dqt (j_compress_ptr cinfo, int index)
147 /* Emit a DQT marker */
148 /* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
149 {
150   JQUANT_TBL * qtbl = cinfo-&gt;quant_tbl_ptrs[index];
151   int prec;
152   int i;
153 
154   if (qtbl == NULL)
155     ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, index);
156 
157   prec = 0;
158   for (i = 0; i &lt;= cinfo-&gt;lim_Se; i++) {
159     if (qtbl-&gt;quantval[cinfo-&gt;natural_order[i]] &gt; 255)
160       prec = 1;
161   }
162 
163   if (! qtbl-&gt;sent_table) {
164     emit_marker(cinfo, M_DQT);
165 
166     emit_2bytes(cinfo,
167       prec ? cinfo-&gt;lim_Se * 2 + 2 + 1 + 2 : cinfo-&gt;lim_Se + 1 + 1 + 2);
168 
169     emit_byte(cinfo, index + (prec&lt;&lt;4));
170 
171     for (i = 0; i &lt;= cinfo-&gt;lim_Se; i++) {
172       /* The table entries must be emitted in zigzag order. */
173       unsigned int qval = qtbl-&gt;quantval[cinfo-&gt;natural_order[i]];
174       if (prec)
175     emit_byte(cinfo, (int) (qval &gt;&gt; 8));
176       emit_byte(cinfo, (int) (qval &amp; 0xFF));
177     }
178 
179     qtbl-&gt;sent_table = TRUE;
180   }
181 
182   return prec;
183 }
184 
185 
186 LOCAL(void)
187 emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
188 /* Emit a DHT marker */
189 {
190   JHUFF_TBL * htbl;
191   int length, i;
192 
193   if (is_ac) {
194     htbl = cinfo-&gt;ac_huff_tbl_ptrs[index];
195     index += 0x10;        /* output index has AC bit set */
196   } else {
197     htbl = cinfo-&gt;dc_huff_tbl_ptrs[index];
198   }
199 
200   if (htbl == NULL)
201     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);
202 
203   if (! htbl-&gt;sent_table) {
204     emit_marker(cinfo, M_DHT);
205 
206     length = 0;
207     for (i = 1; i &lt;= 16; i++)
208       length += htbl-&gt;bits[i];
209 
210     emit_2bytes(cinfo, length + 2 + 1 + 16);
211     emit_byte(cinfo, index);
212 
213     for (i = 1; i &lt;= 16; i++)
214       emit_byte(cinfo, htbl-&gt;bits[i]);
215 
216     for (i = 0; i &lt; length; i++)
217       emit_byte(cinfo, htbl-&gt;huffval[i]);
218 
219     htbl-&gt;sent_table = TRUE;
220   }
221 }
222 
223 
224 LOCAL(void)
225 emit_dac (j_compress_ptr cinfo)
226 /* Emit a DAC marker */
227 /* Since the useful info is so small, we want to emit all the tables in */
228 /* one DAC marker.  Therefore this routine does its own scan of the table. */
229 {
230 #ifdef C_ARITH_CODING_SUPPORTED
231   char dc_in_use[NUM_ARITH_TBLS];
232   char ac_in_use[NUM_ARITH_TBLS];
233   int length, i;
234   jpeg_component_info *compptr;
235 
236   for (i = 0; i &lt; NUM_ARITH_TBLS; i++)
237     dc_in_use[i] = ac_in_use[i] = 0;
238 
239   for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {
240     compptr = cinfo-&gt;cur_comp_info[i];
241     /* DC needs no table for refinement scan */
242     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0)
243       dc_in_use[compptr-&gt;dc_tbl_no] = 1;
244     /* AC needs no table when not present */
245     if (cinfo-&gt;Se)
246       ac_in_use[compptr-&gt;ac_tbl_no] = 1;
247   }
248 
249   length = 0;
250   for (i = 0; i &lt; NUM_ARITH_TBLS; i++)
251     length += dc_in_use[i] + ac_in_use[i];
252 
253   if (length) {
254     emit_marker(cinfo, M_DAC);
255 
256     emit_2bytes(cinfo, length*2 + 2);
257 
258     for (i = 0; i &lt; NUM_ARITH_TBLS; i++) {
259       if (dc_in_use[i]) {
260     emit_byte(cinfo, i);
261     emit_byte(cinfo, cinfo-&gt;arith_dc_L[i] + (cinfo-&gt;arith_dc_U[i]&lt;&lt;4));
262       }
263       if (ac_in_use[i]) {
264     emit_byte(cinfo, i + 0x10);
265     emit_byte(cinfo, cinfo-&gt;arith_ac_K[i]);
266       }
267     }
268   }
269 #endif /* C_ARITH_CODING_SUPPORTED */
270 }
271 
272 
273 LOCAL(void)
274 emit_dri (j_compress_ptr cinfo)
275 /* Emit a DRI marker */
276 {
277   emit_marker(cinfo, M_DRI);
278 
279   emit_2bytes(cinfo, 4);    /* fixed length */
280 
281   emit_2bytes(cinfo, (int) cinfo-&gt;restart_interval);
282 }
283 
284 
285 LOCAL(void)
286 emit_lse_ict (j_compress_ptr cinfo)
287 /* Emit an LSE inverse color transform specification marker */
288 {
289   /* Support only 1 transform */
290   if (cinfo-&gt;color_transform != JCT_SUBTRACT_GREEN ||
291       cinfo-&gt;num_components &lt; 3)
292     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
293 
294   emit_marker(cinfo, M_JPG8);
295 
296   emit_2bytes(cinfo, 24);    /* fixed length */
297 
298   emit_byte(cinfo, 0x0D);    /* ID inverse transform specification */
299   emit_2bytes(cinfo, MAXJSAMPLE);    /* MAXTRANS */
300   emit_byte(cinfo, 3);        /* Nt=3 */
301   emit_byte(cinfo, cinfo-&gt;comp_info[1].component_id);
302   emit_byte(cinfo, cinfo-&gt;comp_info[0].component_id);
303   emit_byte(cinfo, cinfo-&gt;comp_info[2].component_id);
304   emit_byte(cinfo, 0x80);    /* F1: CENTER1=1, NORM1=0 */
305   emit_2bytes(cinfo, 0);    /* A(1,1)=0 */
306   emit_2bytes(cinfo, 0);    /* A(1,2)=0 */
307   emit_byte(cinfo, 0);        /* F2: CENTER2=0, NORM2=0 */
308   emit_2bytes(cinfo, 1);    /* A(2,1)=1 */
309   emit_2bytes(cinfo, 0);    /* A(2,2)=0 */
310   emit_byte(cinfo, 0);        /* F3: CENTER3=0, NORM3=0 */
311   emit_2bytes(cinfo, 1);    /* A(3,1)=1 */
312   emit_2bytes(cinfo, 0);    /* A(3,2)=0 */
313 }
314 
315 
316 LOCAL(void)
317 emit_sof (j_compress_ptr cinfo, JPEG_MARKER code)
318 /* Emit a SOF marker */
319 {
320   int ci;
321   jpeg_component_info *compptr;
322 
323   emit_marker(cinfo, code);
324 
325   emit_2bytes(cinfo, 3 * cinfo-&gt;num_components + 2 + 5 + 1); /* length */
326 
327   /* Make sure image isn&#39;t bigger than SOF field can handle */
328   if ((long) cinfo-&gt;jpeg_height &gt; 65535L ||
329       (long) cinfo-&gt;jpeg_width &gt; 65535L)
330     ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) 65535);
331 
332   emit_byte(cinfo, cinfo-&gt;data_precision);
333   emit_2bytes(cinfo, (int) cinfo-&gt;jpeg_height);
334   emit_2bytes(cinfo, (int) cinfo-&gt;jpeg_width);
335 
336   emit_byte(cinfo, cinfo-&gt;num_components);
337 
338   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
339        ci++, compptr++) {
340     emit_byte(cinfo, compptr-&gt;component_id);
341     emit_byte(cinfo, (compptr-&gt;h_samp_factor &lt;&lt; 4) + compptr-&gt;v_samp_factor);
342     emit_byte(cinfo, compptr-&gt;quant_tbl_no);
343   }
344 }
345 
346 
347 LOCAL(void)
348 emit_sos (j_compress_ptr cinfo)
349 /* Emit a SOS marker */
350 {
351   int i, td, ta;
352   jpeg_component_info *compptr;
353 
354   emit_marker(cinfo, M_SOS);
355 
356   emit_2bytes(cinfo, 2 * cinfo-&gt;comps_in_scan + 2 + 1 + 3); /* length */
357 
358   emit_byte(cinfo, cinfo-&gt;comps_in_scan);
359 
360   for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {
361     compptr = cinfo-&gt;cur_comp_info[i];
362     emit_byte(cinfo, compptr-&gt;component_id);
363 
364     /* We emit 0 for unused field(s); this is recommended by the P&amp;M text
365      * but does not seem to be specified in the standard.
366      */
367 
368     /* DC needs no table for refinement scan */
369     td = cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0 ? compptr-&gt;dc_tbl_no : 0;
370     /* AC needs no table when not present */
371     ta = cinfo-&gt;Se ? compptr-&gt;ac_tbl_no : 0;
372 
373     emit_byte(cinfo, (td &lt;&lt; 4) + ta);
374   }
375 
376   emit_byte(cinfo, cinfo-&gt;Ss);
377   emit_byte(cinfo, cinfo-&gt;Se);
378   emit_byte(cinfo, (cinfo-&gt;Ah &lt;&lt; 4) + cinfo-&gt;Al);
379 }
380 
381 
382 LOCAL(void)
383 emit_pseudo_sos (j_compress_ptr cinfo)
384 /* Emit a pseudo SOS marker */
385 {
386   emit_marker(cinfo, M_SOS);
387 
388   emit_2bytes(cinfo, 2 + 1 + 3); /* length */
389 
390   emit_byte(cinfo, 0); /* Ns */
391 
392   emit_byte(cinfo, 0); /* Ss */
393   emit_byte(cinfo, cinfo-&gt;block_size * cinfo-&gt;block_size - 1); /* Se */
394   emit_byte(cinfo, 0); /* Ah/Al */
395 }
396 
397 
398 LOCAL(void)
399 emit_jfif_app0 (j_compress_ptr cinfo)
400 /* Emit a JFIF-compliant APP0 marker */
401 {
402   /*
403    * Length of APP0 block    (2 bytes)
404    * Block ID            (4 bytes - ASCII &quot;JFIF&quot;)
405    * Zero byte            (1 byte to terminate the ID string)
406    * Version Major, Minor    (2 bytes - major first)
407    * Units            (1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
408    * Xdpu            (2 bytes - dots per unit horizontal)
409    * Ydpu            (2 bytes - dots per unit vertical)
410    * Thumbnail X size        (1 byte)
411    * Thumbnail Y size        (1 byte)
412    */
413 
414   emit_marker(cinfo, M_APP0);
415 
416   emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */
417 
418   emit_byte(cinfo, 0x4A);    /* Identifier: ASCII &quot;JFIF&quot; */
419   emit_byte(cinfo, 0x46);
420   emit_byte(cinfo, 0x49);
421   emit_byte(cinfo, 0x46);
422   emit_byte(cinfo, 0);
423   emit_byte(cinfo, cinfo-&gt;JFIF_major_version); /* Version fields */
424   emit_byte(cinfo, cinfo-&gt;JFIF_minor_version);
425   emit_byte(cinfo, cinfo-&gt;density_unit); /* Pixel size information */
426   emit_2bytes(cinfo, (int) cinfo-&gt;X_density);
427   emit_2bytes(cinfo, (int) cinfo-&gt;Y_density);
428   emit_byte(cinfo, 0);        /* No thumbnail image */
429   emit_byte(cinfo, 0);
430 }
431 
432 
433 LOCAL(void)
434 emit_adobe_app14 (j_compress_ptr cinfo)
435 /* Emit an Adobe APP14 marker */
436 {
437   /*
438    * Length of APP14 block    (2 bytes)
439    * Block ID            (5 bytes - ASCII &quot;Adobe&quot;)
440    * Version Number        (2 bytes - currently 100)
441    * Flags0            (2 bytes - currently 0)
442    * Flags1            (2 bytes - currently 0)
443    * Color transform        (1 byte)
444    *
445    * Although Adobe TN 5116 mentions Version = 101, all the Adobe files
446    * now in circulation seem to use Version = 100, so that&#39;s what we write.
447    *
448    * We write the color transform byte as 1 if the JPEG color space is
449    * YCbCr, 2 if it&#39;s YCCK, 0 otherwise.  Adobe&#39;s definition has to do with
450    * whether the encoder performed a transformation, which is pretty useless.
451    */
452 
453   emit_marker(cinfo, M_APP14);
454 
455   emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */
456 
457   emit_byte(cinfo, 0x41);    /* Identifier: ASCII &quot;Adobe&quot; */
458   emit_byte(cinfo, 0x64);
459   emit_byte(cinfo, 0x6F);
460   emit_byte(cinfo, 0x62);
461   emit_byte(cinfo, 0x65);
462   emit_2bytes(cinfo, 100);    /* Version */
463   emit_2bytes(cinfo, 0);    /* Flags0 */
464   emit_2bytes(cinfo, 0);    /* Flags1 */
465   switch (cinfo-&gt;jpeg_color_space) {
466   case JCS_YCbCr:
467     emit_byte(cinfo, 1);    /* Color transform = 1 */
468     break;
469   case JCS_YCCK:
470     emit_byte(cinfo, 2);    /* Color transform = 2 */
471     break;
472   default:
473     emit_byte(cinfo, 0);    /* Color transform = 0 */
474     break;
475   }
476 }
477 
478 
479 /*
480  * These routines allow writing an arbitrary marker with parameters.
481  * The only intended use is to emit COM or APPn markers after calling
482  * write_file_header and before calling write_frame_header.
483  * Other uses are not guaranteed to produce desirable results.
484  * Counting the parameter bytes properly is the caller&#39;s responsibility.
485  */
486 
487 METHODDEF(void)
488 write_marker_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
489 /* Emit an arbitrary marker header */
490 {
491   if (datalen &gt; (unsigned int) 65533)        /* safety check */
492     ERREXIT(cinfo, JERR_BAD_LENGTH);
493 
494   emit_marker(cinfo, (JPEG_MARKER) marker);
495 
496   emit_2bytes(cinfo, (int) (datalen + 2));    /* total length */
497 }
498 
499 METHODDEF(void)
500 write_marker_byte (j_compress_ptr cinfo, int val)
501 /* Emit one byte of marker parameters following write_marker_header */
502 {
503   emit_byte(cinfo, val);
504 }
505 
506 
507 /*
508  * Write datastream header.
509  * This consists of an SOI and optional APPn markers.
510  * We recommend use of the JFIF marker, but not the Adobe marker,
511  * when using YCbCr or grayscale data.  The JFIF marker is also used
512  * for other standard JPEG colorspaces.  The Adobe marker is helpful
513  * to distinguish RGB, CMYK, and YCCK colorspaces.
514  * Note that an application can write additional header markers after
515  * jpeg_start_compress returns.
516  */
517 
518 METHODDEF(void)
519 write_file_header (j_compress_ptr cinfo)
520 {
521   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;
522 
523   emit_marker(cinfo, M_SOI);    /* first the SOI */
524 
525   /* SOI is defined to reset restart interval to 0 */
526   marker-&gt;last_restart_interval = 0;
527 
528   if (cinfo-&gt;write_JFIF_header)    /* next an optional JFIF APP0 */
529     emit_jfif_app0(cinfo);
530   if (cinfo-&gt;write_Adobe_marker) /* next an optional Adobe APP14 */
531     emit_adobe_app14(cinfo);
532 }
533 
534 
535 /*
536  * Write frame header.
537  * This consists of DQT and SOFn markers,
538  * a conditional LSE marker and a conditional pseudo SOS marker.
539  * Note that we do not emit the SOF until we have emitted the DQT(s).
540  * This avoids compatibility problems with incorrect implementations that
541  * try to error-check the quant table numbers as soon as they see the SOF.
542  */
543 
544 METHODDEF(void)
545 write_frame_header (j_compress_ptr cinfo)
546 {
547   int ci, prec;
548   boolean is_baseline;
549   jpeg_component_info *compptr;
550 
551   /* Emit DQT for each quantization table.
552    * Note that emit_dqt() suppresses any duplicate tables.
553    */
554   prec = 0;
555   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
556        ci++, compptr++) {
557     prec += emit_dqt(cinfo, compptr-&gt;quant_tbl_no);
558   }
559   /* now prec is nonzero iff there are any 16-bit quant tables. */
560 
561   /* Check for a non-baseline specification.
562    * Note we assume that Huffman table numbers won&#39;t be changed later.
563    */
564   if (cinfo-&gt;arith_code || cinfo-&gt;progressive_mode ||
565       cinfo-&gt;data_precision != 8 || cinfo-&gt;block_size != DCTSIZE) {
566     is_baseline = FALSE;
567   } else {
568     is_baseline = TRUE;
569     for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
570      ci++, compptr++) {
571       if (compptr-&gt;dc_tbl_no &gt; 1 || compptr-&gt;ac_tbl_no &gt; 1)
572     is_baseline = FALSE;
573     }
574     if (prec &amp;&amp; is_baseline) {
575       is_baseline = FALSE;
576       /* If it&#39;s baseline except for quantizer size, warn the user */
577       TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);
578     }
579   }
580 
581   /* Emit the proper SOF marker */
582   if (cinfo-&gt;arith_code) {
583     if (cinfo-&gt;progressive_mode)
584       emit_sof(cinfo, M_SOF10); /* SOF code for progressive arithmetic */
585     else
586       emit_sof(cinfo, M_SOF9);  /* SOF code for sequential arithmetic */
587   } else {
588     if (cinfo-&gt;progressive_mode)
589       emit_sof(cinfo, M_SOF2);    /* SOF code for progressive Huffman */
590     else if (is_baseline)
591       emit_sof(cinfo, M_SOF0);    /* SOF code for baseline implementation */
592     else
593       emit_sof(cinfo, M_SOF1);    /* SOF code for non-baseline Huffman file */
594   }
595 
596   /* Check to emit LSE inverse color transform specification marker */
597   if (cinfo-&gt;color_transform)
598     emit_lse_ict(cinfo);
599 
600   /* Check to emit pseudo SOS marker */
601   if (cinfo-&gt;progressive_mode &amp;&amp; cinfo-&gt;block_size != DCTSIZE)
602     emit_pseudo_sos(cinfo);
603 }
604 
605 
606 /*
607  * Write scan header.
608  * This consists of DHT or DAC markers, optional DRI, and SOS.
609  * Compressed data will be written following the SOS.
610  */
611 
612 METHODDEF(void)
613 write_scan_header (j_compress_ptr cinfo)
614 {
615   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;
616   int i;
617   jpeg_component_info *compptr;
618 
619   if (cinfo-&gt;arith_code) {
620     /* Emit arith conditioning info.  We may have some duplication
621      * if the file has multiple scans, but it&#39;s so small it&#39;s hardly
622      * worth worrying about.
623      */
624     emit_dac(cinfo);
625   } else {
626     /* Emit Huffman tables.
627      * Note that emit_dht() suppresses any duplicate tables.
628      */
629     for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {
630       compptr = cinfo-&gt;cur_comp_info[i];
631       /* DC needs no table for refinement scan */
632       if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0)
633     emit_dht(cinfo, compptr-&gt;dc_tbl_no, FALSE);
634       /* AC needs no table when not present */
635       if (cinfo-&gt;Se)
636     emit_dht(cinfo, compptr-&gt;ac_tbl_no, TRUE);
637     }
638   }
639 
640   /* Emit DRI if required --- note that DRI value could change for each scan.
641    * We avoid wasting space with unnecessary DRIs, however.
642    */
643   if (cinfo-&gt;restart_interval != marker-&gt;last_restart_interval) {
644     emit_dri(cinfo);
645     marker-&gt;last_restart_interval = cinfo-&gt;restart_interval;
646   }
647 
648   emit_sos(cinfo);
649 }
650 
651 
652 /*
653  * Write datastream trailer.
654  */
655 
656 METHODDEF(void)
657 write_file_trailer (j_compress_ptr cinfo)
658 {
659   emit_marker(cinfo, M_EOI);
660 }
661 
662 
663 /*
664  * Write an abbreviated table-specification datastream.
665  * This consists of SOI, DQT and DHT tables, and EOI.
666  * Any table that is defined and not marked sent_table = TRUE will be
667  * emitted.  Note that all tables will be marked sent_table = TRUE at exit.
668  */
669 
670 METHODDEF(void)
671 write_tables_only (j_compress_ptr cinfo)
672 {
673   int i;
674 
675   emit_marker(cinfo, M_SOI);
676 
677   for (i = 0; i &lt; NUM_QUANT_TBLS; i++) {
678     if (cinfo-&gt;quant_tbl_ptrs[i] != NULL)
679       (void) emit_dqt(cinfo, i);
680   }
681 
682   if (! cinfo-&gt;arith_code) {
683     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
684       if (cinfo-&gt;dc_huff_tbl_ptrs[i] != NULL)
685     emit_dht(cinfo, i, FALSE);
686       if (cinfo-&gt;ac_huff_tbl_ptrs[i] != NULL)
687     emit_dht(cinfo, i, TRUE);
688     }
689   }
690 
691   emit_marker(cinfo, M_EOI);
692 }
693 
694 
695 /*
696  * Initialize the marker writer module.
697  */
698 
699 GLOBAL(void)
700 jinit_marker_writer (j_compress_ptr cinfo)
701 {
702   my_marker_ptr marker;
703 
704   /* Create the subobject */
705   marker = (my_marker_ptr)
706     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
707                 SIZEOF(my_marker_writer));
708   cinfo-&gt;marker = &amp;marker-&gt;pub;
709   /* Initialize method pointers */
710   marker-&gt;pub.write_file_header = write_file_header;
711   marker-&gt;pub.write_frame_header = write_frame_header;
712   marker-&gt;pub.write_scan_header = write_scan_header;
713   marker-&gt;pub.write_file_trailer = write_file_trailer;
714   marker-&gt;pub.write_tables_only = write_tables_only;
715   marker-&gt;pub.write_marker_header = write_marker_header;
716   marker-&gt;pub.write_marker_byte = write_marker_byte;
717   /* Initialize private state */
718   marker-&gt;last_restart_interval = 0;
719 }
    </pre>
  </body>
</html>
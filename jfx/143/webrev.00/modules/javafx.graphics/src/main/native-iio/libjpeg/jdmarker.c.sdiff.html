<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-iio/libjpeg/jdmarker.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jdhuff.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdmaster.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-iio/libjpeg/jdmarker.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * jdmarker.c
   3  *
   4  * Copyright (C) 1991-1998, Thomas G. Lane.
<span class="line-modified">   5  * Modified 2009-2013 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains routines to decode JPEG datastream markers.
  10  * Most of the complexity arises from our desire to support input
  11  * suspension: if not all of the data for a marker is available,
  12  * we must exit back to the application.  On resumption, we reprocess
  13  * the marker.
  14  */
  15 
  16 #define JPEG_INTERNALS
  17 #include &quot;jinclude.h&quot;
  18 #include &quot;jpeglib.h&quot;
  19 
  20 
  21 typedef enum {            /* JPEG marker codes */
  22   M_SOF0  = 0xc0,
  23   M_SOF1  = 0xc1,
  24   M_SOF2  = 0xc2,
  25   M_SOF3  = 0xc3,
</pre>
<hr />
<pre>
 479     for (i = 1; i &lt;= 16; i++) {
 480       INPUT_BYTE(cinfo, bits[i], return FALSE);
 481       count += bits[i];
 482     }
 483 
 484     length -= 1 + 16;
 485 
 486     TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 487          bits[1], bits[2], bits[3], bits[4],
 488          bits[5], bits[6], bits[7], bits[8]);
 489     TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 490          bits[9], bits[10], bits[11], bits[12],
 491          bits[13], bits[14], bits[15], bits[16]);
 492 
 493     /* Here we just do minimal validation of the counts to avoid walking
 494      * off the end of our table space.  jdhuff.c will check more carefully.
 495      */
 496     if (count &gt; 256 || ((INT32) count) &gt; length)
 497       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 498 
<span class="line-removed"> 499     MEMZERO(huffval, SIZEOF(huffval)); /* pre-zero array for later copy */</span>
<span class="line-removed"> 500 </span>
 501     for (i = 0; i &lt; count; i++)
 502       INPUT_BYTE(cinfo, huffval[i], return FALSE);
 503 
 504     length -= count;
 505 
 506     if (index &amp; 0x10) {        /* AC table definition */
 507       index -= 0x10;
 508       htblptr = &amp;cinfo-&gt;ac_huff_tbl_ptrs[index];
 509     } else {            /* DC table definition */
 510       htblptr = &amp;cinfo-&gt;dc_huff_tbl_ptrs[index];
 511     }
 512 
 513     if (index &lt; 0 || index &gt;= NUM_HUFF_TBLS)
 514       ERREXIT1(cinfo, JERR_DHT_INDEX, index);
 515 
 516     if (*htblptr == NULL)
 517       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
 518 
 519     MEMCOPY((*htblptr)-&gt;bits, bits, SIZEOF((*htblptr)-&gt;bits));
<span class="line-modified"> 520     MEMCOPY((*htblptr)-&gt;huffval, huffval, SIZEOF((*htblptr)-&gt;huffval));</span>

 521   }
 522 
 523   if (length != 0)
 524     ERREXIT(cinfo, JERR_BAD_LENGTH);
 525 
 526   INPUT_SYNC(cinfo);
 527   return TRUE;
 528 }
 529 
 530 
 531 LOCAL(boolean)
 532 get_dqt (j_decompress_ptr cinfo)
 533 /* Process a DQT marker */
 534 {
 535   INT32 length, count, i;
 536   int n, prec;
 537   unsigned int tmp;
 538   JQUANT_TBL *quant_ptr;
 539   const int *natural_order;
 540   INPUT_VARS(cinfo);
</pre>
<hr />
<pre>
 560     if (prec) {
 561       if (length &lt; DCTSIZE2 * 2) {
 562     /* Initialize full table for safety. */
 563     for (i = 0; i &lt; DCTSIZE2; i++) {
 564       quant_ptr-&gt;quantval[i] = 1;
 565     }
 566     count = length &gt;&gt; 1;
 567       } else
 568     count = DCTSIZE2;
 569     } else {
 570       if (length &lt; DCTSIZE2) {
 571     /* Initialize full table for safety. */
 572     for (i = 0; i &lt; DCTSIZE2; i++) {
 573       quant_ptr-&gt;quantval[i] = 1;
 574     }
 575     count = length;
 576       } else
 577     count = DCTSIZE2;
 578     }
 579 
<span class="line-modified"> 580     switch (count) {</span>
 581     case (2*2): natural_order = jpeg_natural_order2; break;
 582     case (3*3): natural_order = jpeg_natural_order3; break;
 583     case (4*4): natural_order = jpeg_natural_order4; break;
 584     case (5*5): natural_order = jpeg_natural_order5; break;
 585     case (6*6): natural_order = jpeg_natural_order6; break;
 586     case (7*7): natural_order = jpeg_natural_order7; break;
<span class="line-modified"> 587     default:    natural_order = jpeg_natural_order;  break;</span>
 588     }
 589 
 590     for (i = 0; i &lt; count; i++) {
 591       if (prec)
 592     INPUT_2BYTES(cinfo, tmp, return FALSE);
 593       else
 594     INPUT_BYTE(cinfo, tmp, return FALSE);
 595       /* We convert the zigzag-order table to natural array order. */
 596       quant_ptr-&gt;quantval[natural_order[i]] = (UINT16) tmp;
 597     }
 598 
 599     if (cinfo-&gt;err-&gt;trace_level &gt;= 2) {
 600       for (i = 0; i &lt; DCTSIZE2; i += 8) {
 601     TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
 602          quant_ptr-&gt;quantval[i],   quant_ptr-&gt;quantval[i+1],
 603          quant_ptr-&gt;quantval[i+2], quant_ptr-&gt;quantval[i+3],
 604          quant_ptr-&gt;quantval[i+4], quant_ptr-&gt;quantval[i+5],
 605          quant_ptr-&gt;quantval[i+6], quant_ptr-&gt;quantval[i+7]);
 606       }
 607     }
</pre>
<hr />
<pre>
 767       GETJOCTET(data[2]) == 0x58 &amp;&amp;
 768       GETJOCTET(data[3]) == 0x58 &amp;&amp;
 769       GETJOCTET(data[4]) == 0) {
 770     /* Found JFIF &quot;JFXX&quot; extension APP0 marker */
 771     /* The library doesn&#39;t actually do anything with these,
 772      * but we try to produce a helpful trace message.
 773      */
 774     switch (GETJOCTET(data[5])) {
 775     case 0x10:
 776       TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
 777       break;
 778     case 0x11:
 779       TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
 780       break;
 781     case 0x13:
 782       TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
 783       break;
 784     default:
 785       TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
 786            GETJOCTET(data[5]), (int) totallen);
<span class="line-removed"> 787       break;</span>
 788     }
 789   } else {
 790     /* Start of APP0 does not match &quot;JFIF&quot; or &quot;JFXX&quot;, or too short */
 791     TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
 792   }
 793 }
 794 
 795 
 796 LOCAL(void)
 797 examine_app14 (j_decompress_ptr cinfo, JOCTET FAR * data,
 798            unsigned int datalen, INT32 remaining)
 799 /* Examine first few bytes from an APP14.
 800  * Take appropriate action if it is an Adobe marker.
 801  * datalen is # of bytes at data[], remaining is length of rest of marker data.
 802  */
 803 {
 804   unsigned int version, flags0, flags1, transform;
 805 
 806   if (datalen &gt;= APP14_DATA_LEN &amp;&amp;
 807       GETJOCTET(data[0]) == 0x41 &amp;&amp;
</pre>
<hr />
<pre>
 841     numtoread = APPN_DATA_LEN;
 842   else if (length &gt; 0)
 843     numtoread = (unsigned int) length;
 844   else
 845     numtoread = 0;
 846   for (i = 0; i &lt; numtoread; i++)
 847     INPUT_BYTE(cinfo, b[i], return FALSE);
 848   length -= numtoread;
 849 
 850   /* process it */
 851   switch (cinfo-&gt;unread_marker) {
 852   case M_APP0:
 853     examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
 854     break;
 855   case M_APP14:
 856     examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
 857     break;
 858   default:
 859     /* can&#39;t get here unless jpeg_save_markers chooses wrong processor */
 860     ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo-&gt;unread_marker);
<span class="line-removed"> 861     break;</span>
 862   }
 863 
 864   /* skip any remaining data -- could be lots */
 865   INPUT_SYNC(cinfo);
 866   if (length &gt; 0)
 867     (*cinfo-&gt;src-&gt;skip_input_data) (cinfo, (long) length);
 868 
 869   return TRUE;
 870 }
 871 
 872 
 873 #ifdef SAVE_MARKERS_SUPPORTED
 874 
 875 METHODDEF(boolean)
 876 save_marker (j_decompress_ptr cinfo)
 877 /* Save an APPn or COM marker into the marker list */
 878 {
 879   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;
 880   jpeg_saved_marker_ptr cur_marker = marker-&gt;cur_marker;
 881   unsigned int bytes_read, data_length;
</pre>
<hr />
<pre>
 947       prev-&gt;next = cur_marker;
 948     }
 949     /* Reset pointer &amp; calc remaining data length */
 950     data = cur_marker-&gt;data;
 951     length = cur_marker-&gt;original_length - data_length;
 952   }
 953   /* Reset to initial state for next marker */
 954   marker-&gt;cur_marker = NULL;
 955 
 956   /* Process the marker if interesting; else just make a generic trace msg */
 957   switch (cinfo-&gt;unread_marker) {
 958   case M_APP0:
 959     examine_app0(cinfo, data, data_length, length);
 960     break;
 961   case M_APP14:
 962     examine_app14(cinfo, data, data_length, length);
 963     break;
 964   default:
 965     TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo-&gt;unread_marker,
 966          (int) (data_length + length));
<span class="line-removed"> 967     break;</span>
 968   }
 969 
 970   /* skip any remaining data -- could be lots */
 971   INPUT_SYNC(cinfo);        /* do before skip_input_data */
 972   if (length &gt; 0)
 973     (*cinfo-&gt;src-&gt;skip_input_data) (cinfo, (long) length);
 974 
 975   return TRUE;
 976 }
 977 
 978 #endif /* SAVE_MARKERS_SUPPORTED */
 979 
 980 
 981 METHODDEF(boolean)
 982 skip_variable (j_decompress_ptr cinfo)
 983 /* Skip over an unknown or uninteresting variable-length marker */
 984 {
 985   INT32 length;
 986   INPUT_VARS(cinfo);
 987 
</pre>
<hr />
<pre>
1223     case M_RST4:
1224     case M_RST5:
1225     case M_RST6:
1226     case M_RST7:
1227     case M_TEM:
1228       TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo-&gt;unread_marker);
1229       break;
1230 
1231     case M_DNL:            /* Ignore DNL ... perhaps the wrong thing */
1232       if (! skip_variable(cinfo))
1233     return JPEG_SUSPENDED;
1234       break;
1235 
1236     default:            /* must be DHP, EXP, JPGn, or RESn */
1237       /* For now, we treat the reserved markers as fatal errors since they are
1238        * likely to be used to signal incompatible JPEG Part 3 extensions.
1239        * Once the JPEG 3 version-number marker is well defined, this code
1240        * ought to change!
1241        */
1242       ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo-&gt;unread_marker);
<span class="line-removed">1243       break;</span>
1244     }
1245     /* Successfully processed marker, so reset state variable */
1246     cinfo-&gt;unread_marker = 0;
1247   } /* end loop */
1248 }
1249 
1250 
1251 /*
1252  * Read a restart marker, which is expected to appear next in the datastream;
1253  * if the marker is not there, take appropriate recovery action.
1254  * Returns FALSE if suspension is required.
1255  *
1256  * This is called by the entropy decoder after it has read an appropriate
1257  * number of MCUs.  cinfo-&gt;unread_marker may be nonzero if the entropy decoder
1258  * has already read a marker from the data source.  Under normal conditions
1259  * cinfo-&gt;unread_marker will be reset to 0 before returning; if not reset,
1260  * it holds a marker which the decoder will be unable to read past.
1261  */
1262 
1263 METHODDEF(boolean)
</pre>
<hr />
<pre>
1399   cinfo-&gt;unread_marker = 0;        /* no pending marker */
1400   marker-&gt;pub.saw_SOI = FALSE;        /* set internal state too */
1401   marker-&gt;pub.saw_SOF = FALSE;
1402   marker-&gt;pub.discarded_bytes = 0;
1403   marker-&gt;cur_marker = NULL;
1404 }
1405 
1406 
1407 /*
1408  * Initialize the marker reader module.
1409  * This is called only once, when the decompression object is created.
1410  */
1411 
1412 GLOBAL(void)
1413 jinit_marker_reader (j_decompress_ptr cinfo)
1414 {
1415   my_marker_ptr marker;
1416   int i;
1417 
1418   /* Create subobject in permanent pool */
<span class="line-modified">1419   marker = (my_marker_ptr)</span>
<span class="line-modified">1420     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,</span>
<span class="line-removed">1421                 SIZEOF(my_marker_reader));</span>
1422   cinfo-&gt;marker = &amp;marker-&gt;pub;
1423   /* Initialize public method pointers */
1424   marker-&gt;pub.reset_marker_reader = reset_marker_reader;
1425   marker-&gt;pub.read_markers = read_markers;
1426   marker-&gt;pub.read_restart_marker = read_restart_marker;
1427   /* Initialize COM/APPn processing.
1428    * By default, we examine and then discard APP0 and APP14,
1429    * but simply discard COM and all other APPn.
1430    */
1431   marker-&gt;process_COM = skip_variable;
1432   marker-&gt;length_limit_COM = 0;
1433   for (i = 0; i &lt; 16; i++) {
1434     marker-&gt;process_APPn[i] = skip_variable;
1435     marker-&gt;length_limit_APPn[i] = 0;
1436   }
1437   marker-&gt;process_APPn[0] = get_interesting_appn;
1438   marker-&gt;process_APPn[14] = get_interesting_appn;
1439   /* Reset marker processing state */
1440   reset_marker_reader(cinfo);
1441 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * jdmarker.c
   3  *
   4  * Copyright (C) 1991-1998, Thomas G. Lane.
<span class="line-modified">   5  * Modified 2009-2019 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains routines to decode JPEG datastream markers.
  10  * Most of the complexity arises from our desire to support input
  11  * suspension: if not all of the data for a marker is available,
  12  * we must exit back to the application.  On resumption, we reprocess
  13  * the marker.
  14  */
  15 
  16 #define JPEG_INTERNALS
  17 #include &quot;jinclude.h&quot;
  18 #include &quot;jpeglib.h&quot;
  19 
  20 
  21 typedef enum {            /* JPEG marker codes */
  22   M_SOF0  = 0xc0,
  23   M_SOF1  = 0xc1,
  24   M_SOF2  = 0xc2,
  25   M_SOF3  = 0xc3,
</pre>
<hr />
<pre>
 479     for (i = 1; i &lt;= 16; i++) {
 480       INPUT_BYTE(cinfo, bits[i], return FALSE);
 481       count += bits[i];
 482     }
 483 
 484     length -= 1 + 16;
 485 
 486     TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 487          bits[1], bits[2], bits[3], bits[4],
 488          bits[5], bits[6], bits[7], bits[8]);
 489     TRACEMS8(cinfo, 2, JTRC_HUFFBITS,
 490          bits[9], bits[10], bits[11], bits[12],
 491          bits[13], bits[14], bits[15], bits[16]);
 492 
 493     /* Here we just do minimal validation of the counts to avoid walking
 494      * off the end of our table space.  jdhuff.c will check more carefully.
 495      */
 496     if (count &gt; 256 || ((INT32) count) &gt; length)
 497       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 498 


 499     for (i = 0; i &lt; count; i++)
 500       INPUT_BYTE(cinfo, huffval[i], return FALSE);
 501 
 502     length -= count;
 503 
 504     if (index &amp; 0x10) {        /* AC table definition */
 505       index -= 0x10;
 506       htblptr = &amp;cinfo-&gt;ac_huff_tbl_ptrs[index];
 507     } else {            /* DC table definition */
 508       htblptr = &amp;cinfo-&gt;dc_huff_tbl_ptrs[index];
 509     }
 510 
 511     if (index &lt; 0 || index &gt;= NUM_HUFF_TBLS)
 512       ERREXIT1(cinfo, JERR_DHT_INDEX, index);
 513 
 514     if (*htblptr == NULL)
 515       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
 516 
 517     MEMCOPY((*htblptr)-&gt;bits, bits, SIZEOF((*htblptr)-&gt;bits));
<span class="line-modified"> 518     if (count &gt; 0)</span>
<span class="line-added"> 519       MEMCOPY((*htblptr)-&gt;huffval, huffval, count * SIZEOF(UINT8));</span>
 520   }
 521 
 522   if (length != 0)
 523     ERREXIT(cinfo, JERR_BAD_LENGTH);
 524 
 525   INPUT_SYNC(cinfo);
 526   return TRUE;
 527 }
 528 
 529 
 530 LOCAL(boolean)
 531 get_dqt (j_decompress_ptr cinfo)
 532 /* Process a DQT marker */
 533 {
 534   INT32 length, count, i;
 535   int n, prec;
 536   unsigned int tmp;
 537   JQUANT_TBL *quant_ptr;
 538   const int *natural_order;
 539   INPUT_VARS(cinfo);
</pre>
<hr />
<pre>
 559     if (prec) {
 560       if (length &lt; DCTSIZE2 * 2) {
 561     /* Initialize full table for safety. */
 562     for (i = 0; i &lt; DCTSIZE2; i++) {
 563       quant_ptr-&gt;quantval[i] = 1;
 564     }
 565     count = length &gt;&gt; 1;
 566       } else
 567     count = DCTSIZE2;
 568     } else {
 569       if (length &lt; DCTSIZE2) {
 570     /* Initialize full table for safety. */
 571     for (i = 0; i &lt; DCTSIZE2; i++) {
 572       quant_ptr-&gt;quantval[i] = 1;
 573     }
 574     count = length;
 575       } else
 576     count = DCTSIZE2;
 577     }
 578 
<span class="line-modified"> 579     switch ((int) count) {</span>
 580     case (2*2): natural_order = jpeg_natural_order2; break;
 581     case (3*3): natural_order = jpeg_natural_order3; break;
 582     case (4*4): natural_order = jpeg_natural_order4; break;
 583     case (5*5): natural_order = jpeg_natural_order5; break;
 584     case (6*6): natural_order = jpeg_natural_order6; break;
 585     case (7*7): natural_order = jpeg_natural_order7; break;
<span class="line-modified"> 586     default:    natural_order = jpeg_natural_order;</span>
 587     }
 588 
 589     for (i = 0; i &lt; count; i++) {
 590       if (prec)
 591     INPUT_2BYTES(cinfo, tmp, return FALSE);
 592       else
 593     INPUT_BYTE(cinfo, tmp, return FALSE);
 594       /* We convert the zigzag-order table to natural array order. */
 595       quant_ptr-&gt;quantval[natural_order[i]] = (UINT16) tmp;
 596     }
 597 
 598     if (cinfo-&gt;err-&gt;trace_level &gt;= 2) {
 599       for (i = 0; i &lt; DCTSIZE2; i += 8) {
 600     TRACEMS8(cinfo, 2, JTRC_QUANTVALS,
 601          quant_ptr-&gt;quantval[i],   quant_ptr-&gt;quantval[i+1],
 602          quant_ptr-&gt;quantval[i+2], quant_ptr-&gt;quantval[i+3],
 603          quant_ptr-&gt;quantval[i+4], quant_ptr-&gt;quantval[i+5],
 604          quant_ptr-&gt;quantval[i+6], quant_ptr-&gt;quantval[i+7]);
 605       }
 606     }
</pre>
<hr />
<pre>
 766       GETJOCTET(data[2]) == 0x58 &amp;&amp;
 767       GETJOCTET(data[3]) == 0x58 &amp;&amp;
 768       GETJOCTET(data[4]) == 0) {
 769     /* Found JFIF &quot;JFXX&quot; extension APP0 marker */
 770     /* The library doesn&#39;t actually do anything with these,
 771      * but we try to produce a helpful trace message.
 772      */
 773     switch (GETJOCTET(data[5])) {
 774     case 0x10:
 775       TRACEMS1(cinfo, 1, JTRC_THUMB_JPEG, (int) totallen);
 776       break;
 777     case 0x11:
 778       TRACEMS1(cinfo, 1, JTRC_THUMB_PALETTE, (int) totallen);
 779       break;
 780     case 0x13:
 781       TRACEMS1(cinfo, 1, JTRC_THUMB_RGB, (int) totallen);
 782       break;
 783     default:
 784       TRACEMS2(cinfo, 1, JTRC_JFIF_EXTENSION,
 785            GETJOCTET(data[5]), (int) totallen);

 786     }
 787   } else {
 788     /* Start of APP0 does not match &quot;JFIF&quot; or &quot;JFXX&quot;, or too short */
 789     TRACEMS1(cinfo, 1, JTRC_APP0, (int) totallen);
 790   }
 791 }
 792 
 793 
 794 LOCAL(void)
 795 examine_app14 (j_decompress_ptr cinfo, JOCTET FAR * data,
 796            unsigned int datalen, INT32 remaining)
 797 /* Examine first few bytes from an APP14.
 798  * Take appropriate action if it is an Adobe marker.
 799  * datalen is # of bytes at data[], remaining is length of rest of marker data.
 800  */
 801 {
 802   unsigned int version, flags0, flags1, transform;
 803 
 804   if (datalen &gt;= APP14_DATA_LEN &amp;&amp;
 805       GETJOCTET(data[0]) == 0x41 &amp;&amp;
</pre>
<hr />
<pre>
 839     numtoread = APPN_DATA_LEN;
 840   else if (length &gt; 0)
 841     numtoread = (unsigned int) length;
 842   else
 843     numtoread = 0;
 844   for (i = 0; i &lt; numtoread; i++)
 845     INPUT_BYTE(cinfo, b[i], return FALSE);
 846   length -= numtoread;
 847 
 848   /* process it */
 849   switch (cinfo-&gt;unread_marker) {
 850   case M_APP0:
 851     examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
 852     break;
 853   case M_APP14:
 854     examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
 855     break;
 856   default:
 857     /* can&#39;t get here unless jpeg_save_markers chooses wrong processor */
 858     ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo-&gt;unread_marker);

 859   }
 860 
 861   /* skip any remaining data -- could be lots */
 862   INPUT_SYNC(cinfo);
 863   if (length &gt; 0)
 864     (*cinfo-&gt;src-&gt;skip_input_data) (cinfo, (long) length);
 865 
 866   return TRUE;
 867 }
 868 
 869 
 870 #ifdef SAVE_MARKERS_SUPPORTED
 871 
 872 METHODDEF(boolean)
 873 save_marker (j_decompress_ptr cinfo)
 874 /* Save an APPn or COM marker into the marker list */
 875 {
 876   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;
 877   jpeg_saved_marker_ptr cur_marker = marker-&gt;cur_marker;
 878   unsigned int bytes_read, data_length;
</pre>
<hr />
<pre>
 944       prev-&gt;next = cur_marker;
 945     }
 946     /* Reset pointer &amp; calc remaining data length */
 947     data = cur_marker-&gt;data;
 948     length = cur_marker-&gt;original_length - data_length;
 949   }
 950   /* Reset to initial state for next marker */
 951   marker-&gt;cur_marker = NULL;
 952 
 953   /* Process the marker if interesting; else just make a generic trace msg */
 954   switch (cinfo-&gt;unread_marker) {
 955   case M_APP0:
 956     examine_app0(cinfo, data, data_length, length);
 957     break;
 958   case M_APP14:
 959     examine_app14(cinfo, data, data_length, length);
 960     break;
 961   default:
 962     TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo-&gt;unread_marker,
 963          (int) (data_length + length));

 964   }
 965 
 966   /* skip any remaining data -- could be lots */
 967   INPUT_SYNC(cinfo);        /* do before skip_input_data */
 968   if (length &gt; 0)
 969     (*cinfo-&gt;src-&gt;skip_input_data) (cinfo, (long) length);
 970 
 971   return TRUE;
 972 }
 973 
 974 #endif /* SAVE_MARKERS_SUPPORTED */
 975 
 976 
 977 METHODDEF(boolean)
 978 skip_variable (j_decompress_ptr cinfo)
 979 /* Skip over an unknown or uninteresting variable-length marker */
 980 {
 981   INT32 length;
 982   INPUT_VARS(cinfo);
 983 
</pre>
<hr />
<pre>
1219     case M_RST4:
1220     case M_RST5:
1221     case M_RST6:
1222     case M_RST7:
1223     case M_TEM:
1224       TRACEMS1(cinfo, 1, JTRC_PARMLESS_MARKER, cinfo-&gt;unread_marker);
1225       break;
1226 
1227     case M_DNL:            /* Ignore DNL ... perhaps the wrong thing */
1228       if (! skip_variable(cinfo))
1229     return JPEG_SUSPENDED;
1230       break;
1231 
1232     default:            /* must be DHP, EXP, JPGn, or RESn */
1233       /* For now, we treat the reserved markers as fatal errors since they are
1234        * likely to be used to signal incompatible JPEG Part 3 extensions.
1235        * Once the JPEG 3 version-number marker is well defined, this code
1236        * ought to change!
1237        */
1238       ERREXIT1(cinfo, JERR_UNKNOWN_MARKER, cinfo-&gt;unread_marker);

1239     }
1240     /* Successfully processed marker, so reset state variable */
1241     cinfo-&gt;unread_marker = 0;
1242   } /* end loop */
1243 }
1244 
1245 
1246 /*
1247  * Read a restart marker, which is expected to appear next in the datastream;
1248  * if the marker is not there, take appropriate recovery action.
1249  * Returns FALSE if suspension is required.
1250  *
1251  * This is called by the entropy decoder after it has read an appropriate
1252  * number of MCUs.  cinfo-&gt;unread_marker may be nonzero if the entropy decoder
1253  * has already read a marker from the data source.  Under normal conditions
1254  * cinfo-&gt;unread_marker will be reset to 0 before returning; if not reset,
1255  * it holds a marker which the decoder will be unable to read past.
1256  */
1257 
1258 METHODDEF(boolean)
</pre>
<hr />
<pre>
1394   cinfo-&gt;unread_marker = 0;        /* no pending marker */
1395   marker-&gt;pub.saw_SOI = FALSE;        /* set internal state too */
1396   marker-&gt;pub.saw_SOF = FALSE;
1397   marker-&gt;pub.discarded_bytes = 0;
1398   marker-&gt;cur_marker = NULL;
1399 }
1400 
1401 
1402 /*
1403  * Initialize the marker reader module.
1404  * This is called only once, when the decompression object is created.
1405  */
1406 
1407 GLOBAL(void)
1408 jinit_marker_reader (j_decompress_ptr cinfo)
1409 {
1410   my_marker_ptr marker;
1411   int i;
1412 
1413   /* Create subobject in permanent pool */
<span class="line-modified">1414   marker = (my_marker_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1415     ((j_common_ptr) cinfo, JPOOL_PERMANENT, SIZEOF(my_marker_reader));</span>

1416   cinfo-&gt;marker = &amp;marker-&gt;pub;
1417   /* Initialize public method pointers */
1418   marker-&gt;pub.reset_marker_reader = reset_marker_reader;
1419   marker-&gt;pub.read_markers = read_markers;
1420   marker-&gt;pub.read_restart_marker = read_restart_marker;
1421   /* Initialize COM/APPn processing.
1422    * By default, we examine and then discard APP0 and APP14,
1423    * but simply discard COM and all other APPn.
1424    */
1425   marker-&gt;process_COM = skip_variable;
1426   marker-&gt;length_limit_COM = 0;
1427   for (i = 0; i &lt; 16; i++) {
1428     marker-&gt;process_APPn[i] = skip_variable;
1429     marker-&gt;length_limit_APPn[i] = 0;
1430   }
1431   marker-&gt;process_APPn[0] = get_interesting_appn;
1432   marker-&gt;process_APPn[14] = get_interesting_appn;
1433   /* Reset marker processing state */
1434   reset_marker_reader(cinfo);
1435 }
</pre>
</td>
</tr>
</table>
<center><a href="jdhuff.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdmaster.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c
--- a/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c
+++ b/modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c
@@ -1,10 +1,10 @@
 /*
  * jdhuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
- * Modified 2006-2016 by Guido Vollbeding.
+ * Modified 2006-2019 by Guido Vollbeding.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
  * This file contains Huffman entropy decoding routines.
  * Both sequential and progressive modes are supported in this single module.
@@ -341,17 +341,16 @@
   if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
   htbl =
     isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
   if (htbl == NULL)
-    ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
+    htbl = jpeg_std_huff_table((j_common_ptr) cinfo, isDC, tblno);
 
   /* Allocate a workspace if we haven't already done so. */
   if (*pdtbl == NULL)
-    *pdtbl = (d_derived_tbl *)
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  SIZEOF(d_derived_tbl));
+    *pdtbl = (d_derived_tbl *) (*cinfo->mem->alloc_small)
+      ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(d_derived_tbl));
   dtbl = *pdtbl;
   dtbl->pub = htbl;        /* fill in back link */
 
   /* Figure C.1: make table of Huffman code length for each symbol */
 
@@ -732,11 +731,11 @@
    * This way, we return uniform gray for the remainder of the segment.
    */
   if (! entropy->insufficient_data) {
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(state, entropy->saved);
 
     /* Outer loop handles each block in the MCU */
 
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
@@ -761,16 +760,17 @@
       /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
       (*block)[0] = (JCOEF) (s << Al);
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(entropy->saved, state);
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -811,11 +811,11 @@
     /* There is always only one block per MCU */
 
     if (EOBRUN)            /* if it's a band of zeroes... */
       EOBRUN--;            /* ...process it now (we do nothing) */
     else {
-      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+      BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
       Se = cinfo->Se;
       Al = cinfo->Al;
       natural_order = cinfo->natural_order;
       block = MCU_data[0];
       tbl = entropy->ac_derived_tbl;
@@ -844,19 +844,20 @@
       }
       k += 15;        /* ZRL: skip 15 zeroes in band */
     }
       }
 
-      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+      BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     }
 
     /* Completed MCU, so update state */
     entropy->saved.EOBRUN = EOBRUN;    /* only part of saved state we need */
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -868,11 +869,12 @@
 
 METHODDEF(boolean)
 decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-  int p1, blkn;
+  JCOEF p1;
+  int blkn;
   BITREAD_STATE_VARS;
 
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
@@ -883,11 +885,11 @@
   /* Not worth the cycles to check insufficient_data here,
    * since we will not change the data anyway if we read zeroes.
    */
 
   /* Load up working state */
-  BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+  BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
 
   p1 = 1 << cinfo->Al;        /* 1 in the bit position being coded */
 
   /* Outer loop handles each block in the MCU */
 
@@ -898,14 +900,15 @@
       MCU_data[blkn][0][0] |= p1;
     /* Note: since we use |=, repeating the assignment later is safe */
   }
 
   /* Completed MCU, so update state */
-  BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+  BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -917,11 +920,12 @@
 decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
   register int s, k, r;
   unsigned int EOBRUN;
-  int Se, p1, m1;
+  int Se;
+  JCOEF p1, m1;
   const int * natural_order;
   JBLOCKROW block;
   JCOEFPTR thiscoef;
   BITREAD_STATE_VARS;
   d_derived_tbl * tbl;
@@ -939,15 +943,15 @@
    */
   if (! entropy->insufficient_data) {
 
     Se = cinfo->Se;
     p1 = 1 << cinfo->Al;    /* 1 in the bit position being coded */
-    m1 = (-1) << cinfo->Al;    /* -1 in the bit position being coded */
+    m1 = -p1;            /* -1 in the bit position being coded */
     natural_order = cinfo->natural_order;
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
 
     /* There is always only one block per MCU */
     block = MCU_data[0];
     tbl = entropy->ac_derived_tbl;
@@ -1045,16 +1049,17 @@
       /* Count one block completed in EOB run */
       EOBRUN--;
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 
 undoit:
   /* Re-zero any output coefficients that we made newly nonzero */
@@ -1093,11 +1098,11 @@
 
     natural_order = cinfo->natural_order;
     Se = cinfo->lim_Se;
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(state, entropy->saved);
 
     /* Outer loop handles each block in the MCU */
 
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
@@ -1180,16 +1185,17 @@
 
       EndOfBlock: ;
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(entropy->saved, state);
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -1217,11 +1223,11 @@
    * This way, we return uniform gray for the remainder of the segment.
    */
   if (! entropy->insufficient_data) {
 
     /* Load up working state */
-    BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
+    BITREAD_LOAD_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(state, entropy->saved);
 
     /* Outer loop handles each block in the MCU */
 
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
@@ -1304,16 +1310,17 @@
 
       EndOfBlock: ;
     }
 
     /* Completed MCU, so update state */
-    BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
+    BITREAD_SAVE_STATE(cinfo, entropy->bitstate);
     ASSIGN_STATE(entropy->saved, state);
   }
 
-  /* Account for restart interval (no-op if not using restarts) */
-  entropy->restarts_to_go--;
+  /* Account for restart interval if using restarts */
+  if (cinfo->restart_interval)
+    entropy->restarts_to_go--;
 
   return TRUE;
 }
 
 
@@ -1345,15 +1352,15 @@
       /* Successive approximation refinement scan: must have Al = Ah-1. */
       if (cinfo->Ah-1 != cinfo->Al)
     goto bad;
     }
     if (cinfo->Al > 13) {    /* need not check for < 0 */
-      /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
-       * but the spec doesn't say so, and we try to be liberal about what we
-       * accept.  Note: large Al values could result in out-of-range DC
-       * coefficients during early scans, leading to bizarre displays due to
-       * overflows in the IDCT math.  But we won't crash.
+      /* Arguably the maximum Al value should be less than 13 for 8-bit
+       * precision, but the spec doesn't say so, and we try to be liberal
+       * about what we accept.  Note: large Al values could result in
+       * out-of-range DC coefficients during early scans, leading to bizarre
+       * displays due to overflows in the IDCT math.  But we won't crash.
        */
       bad:
       ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
            cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
     }
@@ -1453,11 +1460,12 @@
     for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
       ci = cinfo->MCU_membership[blkn];
       compptr = cinfo->cur_comp_info[ci];
       /* Precalculate which table to use for each block */
       entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
-      entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
+      entropy->ac_cur_tbls[blkn] =    /* AC needs no table when not present */
+    cinfo->lim_Se ? entropy->ac_derived_tbls[compptr->ac_tbl_no] : NULL;
       /* Decide whether we really care about the coefficient values */
       if (compptr->component_needed) {
     ci = compptr->DCT_v_scaled_size;
     i = compptr->DCT_h_scaled_size;
     switch (cinfo->lim_Se) {
@@ -1496,11 +1504,10 @@
       break;
     default:
       if (ci <= 0 || ci > 8) ci = 8;
       if (i <= 0 || i > 8) i = 8;
       entropy->coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
-      break;
     }
       } else {
     entropy->coef_limit[blkn] = 0;
       }
     }
@@ -1524,34 +1531,33 @@
 jinit_huff_decoder (j_decompress_ptr cinfo)
 {
   huff_entropy_ptr entropy;
   int i;
 
-  entropy = (huff_entropy_ptr)
-    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                SIZEOF(huff_entropy_decoder));
+  entropy = (huff_entropy_ptr) (*cinfo->mem->alloc_small)
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(huff_entropy_decoder));
   cinfo->entropy = &entropy->pub;
   entropy->pub.start_pass = start_pass_huff_decoder;
   entropy->pub.finish_pass = finish_pass_huff;
 
   if (cinfo->progressive_mode) {
     /* Create progression status table */
     int *coef_bit_ptr, ci;
-    cinfo->coef_bits = (int (*)[DCTSIZE2])
-      (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-                  cinfo->num_components*DCTSIZE2*SIZEOF(int));
+    cinfo->coef_bits = (int (*)[DCTSIZE2]) (*cinfo->mem->alloc_small)
+      ((j_common_ptr) cinfo, JPOOL_IMAGE,
+       cinfo->num_components * DCTSIZE2 * SIZEOF(int));
     coef_bit_ptr = & cinfo->coef_bits[0][0];
     for (ci = 0; ci < cinfo->num_components; ci++)
       for (i = 0; i < DCTSIZE2; i++)
     *coef_bit_ptr++ = -1;
 
     /* Mark derived tables unallocated */
     for (i = 0; i < NUM_HUFF_TBLS; i++) {
       entropy->derived_tbls[i] = NULL;
     }
   } else {
-    /* Mark tables unallocated */
+    /* Mark derived tables unallocated */
     for (i = 0; i < NUM_HUFF_TBLS; i++) {
       entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
     }
   }
 }

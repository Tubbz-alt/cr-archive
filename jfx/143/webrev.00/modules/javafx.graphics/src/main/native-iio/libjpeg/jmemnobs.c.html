<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-iio/libjpeg/jmemnobs.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * jmemnobs.c
  3  *
  4  * Copyright (C) 1992-1996, Thomas G. Lane.
  5  * Modified 2019 by Guido Vollbeding.
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file provides a really simple implementation of the system-
 10  * dependent portion of the JPEG memory manager.  This implementation
 11  * assumes that no backing-store files are needed: all required space
 12  * can be obtained from malloc().
 13  * This is very portable in the sense that it&#39;ll compile on almost anything,
 14  * but you&#39;d better have lots of main memory (or virtual memory) if you want
 15  * to process big images.
 16  * Note that the max_memory_to_use option is respected by this implementation.
 17  */
 18 
 19 #define JPEG_INTERNALS
 20 #include &quot;jinclude.h&quot;
 21 #include &quot;jpeglib.h&quot;
 22 #include &quot;jmemsys.h&quot;        /* import the system-dependent declarations */
 23 
 24 #ifndef HAVE_STDLIB_H        /* &lt;stdlib.h&gt; should declare malloc(),free() */
 25 extern void * malloc JPP((size_t size));
 26 extern void free JPP((void *ptr));
 27 #endif
 28 
 29 
 30 /*
 31  * Memory allocation and freeing are controlled by the regular library
 32  * routines malloc() and free().
 33  */
 34 
 35 GLOBAL(void *)
 36 jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
 37 {
 38   return (void *) malloc(sizeofobject);
 39 }
 40 
 41 GLOBAL(void)
 42 jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
 43 {
 44   free(object);
 45 }
 46 
 47 
 48 /*
 49  * &quot;Large&quot; objects are treated the same as &quot;small&quot; ones.
 50  * NB: although we include FAR keywords in the routine declarations,
 51  * this file won&#39;t actually work in 80x86 small/medium model; at least,
 52  * you probably won&#39;t be able to process useful-size images in only 64KB.
 53  */
 54 
 55 GLOBAL(void FAR *)
 56 jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
 57 {
 58   return (void FAR *) malloc(sizeofobject);
 59 }
 60 
 61 GLOBAL(void)
 62 jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
 63 {
 64   free(object);
 65 }
 66 
 67 
 68 /*
 69  * This routine computes the total memory space available for allocation.
 70  */
 71 
 72 GLOBAL(long)
 73 jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
 74             long max_bytes_needed, long already_allocated)
 75 {
 76   if (cinfo-&gt;mem-&gt;max_memory_to_use)
 77     return cinfo-&gt;mem-&gt;max_memory_to_use - already_allocated;
 78 
 79   /* Here we say, &quot;we got all you want bud!&quot; */
 80   return max_bytes_needed;
 81 }
 82 
 83 
 84 /*
 85  * Backing store (temporary file) management.
 86  * Since jpeg_mem_available always promised the moon,
 87  * this should never be called and we can just error out.
 88  */
 89 
 90 GLOBAL(void)
 91 jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
 92              long total_bytes_needed)
 93 {
 94   ERREXIT(cinfo, JERR_NO_BACKING_STORE);
 95 }
 96 
 97 
 98 /*
 99  * These routines take care of any system-dependent initialization and
100  * cleanup required.  Here, there isn&#39;t any.
101  */
102 
103 GLOBAL(long)
104 jpeg_mem_init (j_common_ptr cinfo)
105 {
106   return 0;            /* just set max_memory_to_use to 0 */
107 }
108 
109 GLOBAL(void)
110 jpeg_mem_term (j_common_ptr cinfo)
111 {
112   /* no work */
113 }
    </pre>
  </body>
</html>
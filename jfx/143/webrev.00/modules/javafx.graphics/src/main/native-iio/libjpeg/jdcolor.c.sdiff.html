<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jcparam.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdct.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-iio/libjpeg/jdcolor.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * jdcolor.c
  3  *
  4  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="line-modified">  5  * Modified 2011-2017 by Guido Vollbeding.</span>
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains output colorspace conversion routines.
 10  */
 11 
 12 #define JPEG_INTERNALS
 13 #include &quot;jinclude.h&quot;
 14 #include &quot;jpeglib.h&quot;
 15 
 16 
 17 #if RANGE_BITS &lt; 2
 18   /* Deliberate syntax err */
 19   Sorry, this code requires 2 or more range extension bits.
 20 #endif
 21 
 22 
 23 /* Private subobject */
 24 
 25 typedef struct {
</pre>
<hr />
<pre>
107 
108 #define R_Y_OFF        0            /* offset to R =&gt; Y section */
109 #define G_Y_OFF        (1*(MAXJSAMPLE+1))    /* offset to G =&gt; Y section */
110 #define B_Y_OFF        (2*(MAXJSAMPLE+1))    /* etc. */
111 #define TABLE_SIZE    (3*(MAXJSAMPLE+1))
112 
113 
114 /*
115  * Initialize tables for YCbCr-&gt;RGB and BG_YCC-&gt;RGB colorspace conversion.
116  */
117 
118 LOCAL(void)
119 build_ycc_rgb_table (j_decompress_ptr cinfo)
120 /* Normal case, sYCC */
121 {
122   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
123   int i;
124   INT32 x;
125   SHIFT_TEMPS
126 
<span class="line-modified">127   cconvert-&gt;Cr_r_tab = (int *)</span>
<span class="line-modified">128     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">129                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">130   cconvert-&gt;Cb_b_tab = (int *)</span>
<span class="line-modified">131     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">132                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">133   cconvert-&gt;Cr_g_tab = (INT32 *)</span>
<span class="line-modified">134     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">135                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-removed">136   cconvert-&gt;Cb_g_tab = (INT32 *)</span>
<span class="line-removed">137     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">138                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
139 
140   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
141     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
142     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
143     /* Cr=&gt;R value is nearest int to 1.402 * x */
<span class="line-modified">144     cconvert-&gt;Cr_r_tab[i] = (int)</span>
<span class="line-removed">145             RIGHT_SHIFT(FIX(1.402) * x + ONE_HALF, SCALEBITS);</span>
146     /* Cb=&gt;B value is nearest int to 1.772 * x */
<span class="line-modified">147     cconvert-&gt;Cb_b_tab[i] = (int)</span>
<span class="line-removed">148             RIGHT_SHIFT(FIX(1.772) * x + ONE_HALF, SCALEBITS);</span>
149     /* Cr=&gt;G value is scaled-up -0.714136286 * x */
150     cconvert-&gt;Cr_g_tab[i] = (- FIX(0.714136286)) * x;
151     /* Cb=&gt;G value is scaled-up -0.344136286 * x */
152     /* We also add in ONE_HALF so that need not do it in inner loop */
153     cconvert-&gt;Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
154   }
155 }
156 
157 
158 LOCAL(void)
159 build_bg_ycc_rgb_table (j_decompress_ptr cinfo)
160 /* Wide gamut case, bg-sYCC */
161 {
162   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
163   int i;
164   INT32 x;
165   SHIFT_TEMPS
166 
<span class="line-modified">167   cconvert-&gt;Cr_r_tab = (int *)</span>
<span class="line-modified">168     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">169                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">170   cconvert-&gt;Cb_b_tab = (int *)</span>
<span class="line-modified">171     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">172                 (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">173   cconvert-&gt;Cr_g_tab = (INT32 *)</span>
<span class="line-modified">174     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">175                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-removed">176   cconvert-&gt;Cb_g_tab = (INT32 *)</span>
<span class="line-removed">177     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">178                 (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
179 
180   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
181     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
182     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
183     /* Cr=&gt;R value is nearest int to 2.804 * x */
<span class="line-modified">184     cconvert-&gt;Cr_r_tab[i] = (int)</span>
<span class="line-removed">185             RIGHT_SHIFT(FIX(2.804) * x + ONE_HALF, SCALEBITS);</span>
186     /* Cb=&gt;B value is nearest int to 3.544 * x */
<span class="line-modified">187     cconvert-&gt;Cb_b_tab[i] = (int)</span>
<span class="line-removed">188             RIGHT_SHIFT(FIX(3.544) * x + ONE_HALF, SCALEBITS);</span>
189     /* Cr=&gt;G value is scaled-up -1.428272572 * x */
190     cconvert-&gt;Cr_g_tab[i] = (- FIX(1.428272572)) * x;
191     /* Cb=&gt;G value is scaled-up -0.688272572 * x */
192     /* We also add in ONE_HALF so that need not do it in inner loop */
193     cconvert-&gt;Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
194   }
195 }
196 
197 
198 /*
199  * Convert some rows of samples to the output colorspace.
200  *
201  * Note that we change from noninterleaved, one-plane-per-component format
202  * to interleaved-pixel format.  The output buffer is therefore three times
203  * as wide as the input buffer.

204  * A starting row offset is provided only for the input buffer.  The caller
205  * can easily adjust the passed output_buf value to accommodate any row
206  * offset required on that side.
207  */
208 
209 METHODDEF(void)
210 ycc_rgb_convert (j_decompress_ptr cinfo,
211          JSAMPIMAGE input_buf, JDIMENSION input_row,
212          JSAMPARRAY output_buf, int num_rows)
213 {
214   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
215   register int y, cb, cr;
216   register JSAMPROW outptr;
217   register JSAMPROW inptr0, inptr1, inptr2;
218   register JDIMENSION col;
219   JDIMENSION num_cols = cinfo-&gt;output_width;
220   /* copy these pointers into registers if possible */
221   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
222   register int * Crrtab = cconvert-&gt;Cr_r_tab;
223   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
</pre>
<hr />
<pre>
247     }
248   }
249 }
250 
251 
252 /**************** Cases other than YCC -&gt; RGB ****************/
253 
254 
255 /*
256  * Initialize for RGB-&gt;grayscale colorspace conversion.
257  */
258 
259 LOCAL(void)
260 build_rgb_y_table (j_decompress_ptr cinfo)
261 {
262   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
263   INT32 * rgb_y_tab;
264   INT32 i;
265 
266   /* Allocate and fill in the conversion tables. */
<span class="line-modified">267   cconvert-&gt;rgb_y_tab = rgb_y_tab = (INT32 *)</span>
<span class="line-modified">268     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">269                 (TABLE_SIZE * SIZEOF(INT32)));</span>
270 
271   for (i = 0; i &lt;= MAXJSAMPLE; i++) {
272     rgb_y_tab[i+R_Y_OFF] = FIX(0.299) * i;
273     rgb_y_tab[i+G_Y_OFF] = FIX(0.587) * i;
274     rgb_y_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;
275   }
276 }
277 
278 
279 /*
280  * Convert RGB to grayscale.
281  */
282 
283 METHODDEF(void)
284 rgb_gray_convert (j_decompress_ptr cinfo,
285           JSAMPIMAGE input_buf, JDIMENSION input_row,
286           JSAMPARRAY output_buf, int num_rows)
287 {
288   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
<span class="line-removed">289   register INT32 * ctab = cconvert-&gt;rgb_y_tab;</span>
290   register int r, g, b;

291   register JSAMPROW outptr;
292   register JSAMPROW inptr0, inptr1, inptr2;
293   register JDIMENSION col;
294   JDIMENSION num_cols = cinfo-&gt;output_width;
295 
296   while (--num_rows &gt;= 0) {
297     inptr0 = input_buf[0][input_row];
298     inptr1 = input_buf[1][input_row];
299     inptr2 = input_buf[2][input_row];
300     input_row++;
301     outptr = *output_buf++;
302     for (col = 0; col &lt; num_cols; col++) {
303       r = GETJSAMPLE(inptr0[col]);
304       g = GETJSAMPLE(inptr1[col]);
305       b = GETJSAMPLE(inptr2[col]);
306       /* Y */
307       outptr[col] = (JSAMPLE)
308         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
309          &gt;&gt; SCALEBITS);
310     }
311   }
312 }
313 
314 
315 /*

316  * [R-G,G,B-G] to [R,G,B] conversion with modulo calculation
317  * (inverse color transform).
318  * This can be seen as an adaption of the general YCbCr-&gt;RGB
319  * conversion equation with Kr = Kb = 0, while replacing the
320  * normalization by modulo calculation.
321  */
322 
323 METHODDEF(void)
324 rgb1_rgb_convert (j_decompress_ptr cinfo,
325           JSAMPIMAGE input_buf, JDIMENSION input_row,
326           JSAMPARRAY output_buf, int num_rows)
327 {
328   register int r, g, b;
329   register JSAMPROW outptr;
330   register JSAMPROW inptr0, inptr1, inptr2;
331   register JDIMENSION col;
332   JDIMENSION num_cols = cinfo-&gt;output_width;
333 
334   while (--num_rows &gt;= 0) {
335     inptr0 = input_buf[0][input_row];
</pre>
<hr />
<pre>
347       outptr[RGB_RED]   = (JSAMPLE) ((r + g - CENTERJSAMPLE) &amp; MAXJSAMPLE);
348       outptr[RGB_GREEN] = (JSAMPLE) g;
349       outptr[RGB_BLUE]  = (JSAMPLE) ((b + g - CENTERJSAMPLE) &amp; MAXJSAMPLE);
350       outptr += RGB_PIXELSIZE;
351     }
352   }
353 }
354 
355 
356 /*
357  * [R-G,G,B-G] to grayscale conversion with modulo calculation
358  * (inverse color transform).
359  */
360 
361 METHODDEF(void)
362 rgb1_gray_convert (j_decompress_ptr cinfo,
363            JSAMPIMAGE input_buf, JDIMENSION input_row,
364            JSAMPARRAY output_buf, int num_rows)
365 {
366   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
<span class="line-removed">367   register INT32 * ctab = cconvert-&gt;rgb_y_tab;</span>
368   register int r, g, b;

369   register JSAMPROW outptr;
370   register JSAMPROW inptr0, inptr1, inptr2;
371   register JDIMENSION col;
372   JDIMENSION num_cols = cinfo-&gt;output_width;
373 
374   while (--num_rows &gt;= 0) {
375     inptr0 = input_buf[0][input_row];
376     inptr1 = input_buf[1][input_row];
377     inptr2 = input_buf[2][input_row];
378     input_row++;
379     outptr = *output_buf++;
380     for (col = 0; col &lt; num_cols; col++) {
381       r = GETJSAMPLE(inptr0[col]);
382       g = GETJSAMPLE(inptr1[col]);
383       b = GETJSAMPLE(inptr2[col]);
384       /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD
385        * (modulo) operator is equivalent to the bitmask operator AND.
386        */
387       r = (r + g - CENTERJSAMPLE) &amp; MAXJSAMPLE;
388       b = (b + g - CENTERJSAMPLE) &amp; MAXJSAMPLE;
389       /* Y */
390       outptr[col] = (JSAMPLE)
391         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
392          &gt;&gt; SCALEBITS);
393     }
394   }
395 }
396 
397 
398 /*

399  * No colorspace change, but conversion from separate-planes
400  * to interleaved representation.
401  */
402 
403 METHODDEF(void)
404 rgb_convert (j_decompress_ptr cinfo,
405          JSAMPIMAGE input_buf, JDIMENSION input_row,
406          JSAMPARRAY output_buf, int num_rows)
407 {
408   register JSAMPROW outptr;
409   register JSAMPROW inptr0, inptr1, inptr2;
410   register JDIMENSION col;
411   JDIMENSION num_cols = cinfo-&gt;output_width;
412 
413   while (--num_rows &gt;= 0) {
414     inptr0 = input_buf[0][input_row];
415     inptr1 = input_buf[1][input_row];
416     inptr2 = input_buf[2][input_row];
417     input_row++;
418     outptr = *output_buf++;
419     for (col = 0; col &lt; num_cols; col++) {
420       /* We can dispense with GETJSAMPLE() here */
421       outptr[RGB_RED]   = inptr0[col];
422       outptr[RGB_GREEN] = inptr1[col];
423       outptr[RGB_BLUE]  = inptr2[col];
424       outptr += RGB_PIXELSIZE;
425     }
426   }
427 }
428 
429 
430 /*
431  * Color conversion for no colorspace change: just copy the data,
432  * converting from separate-planes to interleaved representation.

433  */
434 
435 METHODDEF(void)
436 null_convert (j_decompress_ptr cinfo,
437           JSAMPIMAGE input_buf, JDIMENSION input_row,
438           JSAMPARRAY output_buf, int num_rows)
439 {
<span class="line-removed">440   int ci;</span>
<span class="line-removed">441   register int nc = cinfo-&gt;num_components;</span>
442   register JSAMPROW outptr;
443   register JSAMPROW inptr;
<span class="line-modified">444   register JDIMENSION col;</span>

445   JDIMENSION num_cols = cinfo-&gt;output_width;

446 
447   while (--num_rows &gt;= 0) {
<span class="line-modified">448     for (ci = 0; ci &lt; nc; ci++) {</span>

449       inptr = input_buf[ci][input_row];
450       outptr = output_buf[0] + ci;
<span class="line-modified">451       for (col = 0; col &lt; num_cols; col++) {</span>
<span class="line-modified">452     *outptr = *inptr++;    /* needn&#39;t bother with GETJSAMPLE() here */</span>
<span class="line-modified">453     outptr += nc;</span>
454       }
455     }
456     input_row++;
457     output_buf++;
458   }
459 }
460 
461 
462 /*
463  * Color conversion for grayscale: just copy the data.
464  * This also works for YCC -&gt; grayscale conversion, in which
465  * we just copy the Y (luminance) component and ignore chrominance.
466  */
467 
468 METHODDEF(void)
469 grayscale_convert (j_decompress_ptr cinfo,
470            JSAMPIMAGE input_buf, JDIMENSION input_row,
471            JSAMPARRAY output_buf, int num_rows)
472 {
473   jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
</pre>
<hr />
<pre>
599       m = GETJSAMPLE(inptr1[col]);
600       y = GETJSAMPLE(inptr2[col]);
601       k = GETJSAMPLE(inptr3[col]);
602 
603       r = c * k / MAXJSAMPLE;
604       g = m * k / MAXJSAMPLE;
605       b = y * k / MAXJSAMPLE;
606 
607       /* Range-limiting is essential due to noise introduced by DCT losses. */
608       outptr[RGB_RED] = range_limit[r];
609       outptr[RGB_GREEN] = range_limit[g];
610       outptr[RGB_BLUE] = range_limit[b];
611 
612       outptr += RGB_PIXELSIZE;
613     }
614   }
615 }
616 
617 
618 /*
<span class="line-modified">619  * Adobe-style YCCK-&gt;CMYK conversion.</span>
<span class="line-modified">620  * We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same</span>
<span class="line-modified">621  * conversion as above, while passing K (black) unchanged.</span>

622  * We assume build_ycc_rgb_table has been called.
623  */
624 
625 METHODDEF(void)
626 ycck_cmyk_convert (j_decompress_ptr cinfo,
627            JSAMPIMAGE input_buf, JDIMENSION input_row,
628            JSAMPARRAY output_buf, int num_rows)
629 {
630   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
631   register int y, cb, cr;
632   register JSAMPROW outptr;
633   register JSAMPROW inptr0, inptr1, inptr2, inptr3;
634   register JDIMENSION col;
635   JDIMENSION num_cols = cinfo-&gt;output_width;
636   /* copy these pointers into registers if possible */
637   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
638   register int * Crrtab = cconvert-&gt;Cr_r_tab;
639   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
640   register INT32 * Crgtab = cconvert-&gt;Cr_g_tab;
641   register INT32 * Cbgtab = cconvert-&gt;Cb_g_tab;
</pre>
<hr />
<pre>
672  * Empty method for start_pass.
673  */
674 
675 METHODDEF(void)
676 start_pass_dcolor (j_decompress_ptr cinfo)
677 {
678   /* no work needed */
679 }
680 
681 
682 /*
683  * Module initialization routine for output colorspace conversion.
684  */
685 
686 GLOBAL(void)
687 jinit_color_deconverter (j_decompress_ptr cinfo)
688 {
689   my_cconvert_ptr cconvert;
690   int ci;
691 
<span class="line-modified">692   cconvert = (my_cconvert_ptr)</span>
<span class="line-modified">693     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">694                 SIZEOF(my_color_deconverter));</span>
695   cinfo-&gt;cconvert = &amp;cconvert-&gt;pub;
696   cconvert-&gt;pub.start_pass = start_pass_dcolor;
697 
698   /* Make sure num_components agrees with jpeg_color_space */
699   switch (cinfo-&gt;jpeg_color_space) {
700   case JCS_GRAYSCALE:
701     if (cinfo-&gt;num_components != 1)
702       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
703     break;
704 
705   case JCS_RGB:
706   case JCS_YCbCr:
707   case JCS_BG_RGB:
708   case JCS_BG_YCC:
709     if (cinfo-&gt;num_components != 3)
710       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
711     break;
712 
713   case JCS_CMYK:
714   case JCS_YCCK:
715     if (cinfo-&gt;num_components != 4)
716       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
717     break;
718 
719   default:            /* JCS_UNKNOWN can be anything */
720     if (cinfo-&gt;num_components &lt; 1)
721       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
<span class="line-removed">722     break;</span>
723   }
724 
725   /* Support color transform only for RGB colorspaces */
726   if (cinfo-&gt;color_transform &amp;&amp;
727       cinfo-&gt;jpeg_color_space != JCS_RGB &amp;&amp;
728       cinfo-&gt;jpeg_color_space != JCS_BG_RGB)
729     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
730 
731   /* Set out_color_components and conversion method based on requested space.
732    * Also clear the component_needed flags for any unused components,
733    * so that earlier pipeline stages can avoid useless computation.
734    */
735 
736   switch (cinfo-&gt;out_color_space) {
737   case JCS_GRAYSCALE:
738     cinfo-&gt;out_color_components = 1;
739     switch (cinfo-&gt;jpeg_color_space) {
740     case JCS_GRAYSCALE:
741     case JCS_YCbCr:
742     case JCS_BG_YCC:
</pre>
<hr />
<pre>
763     }
764     break;
765 
766   case JCS_RGB:
767     cinfo-&gt;out_color_components = RGB_PIXELSIZE;
768     switch (cinfo-&gt;jpeg_color_space) {
769     case JCS_GRAYSCALE:
770       cconvert-&gt;pub.color_convert = gray_rgb_convert;
771       break;
772     case JCS_YCbCr:
773       cconvert-&gt;pub.color_convert = ycc_rgb_convert;
774       build_ycc_rgb_table(cinfo);
775       break;
776     case JCS_BG_YCC:
777       cconvert-&gt;pub.color_convert = ycc_rgb_convert;
778       build_bg_ycc_rgb_table(cinfo);
779       break;
780     case JCS_RGB:
781       switch (cinfo-&gt;color_transform) {
782       case JCT_NONE:
<span class="line-modified">783         cconvert-&gt;pub.color_convert = rgb_convert;</span>
<span class="line-modified">784         break;</span>
785       case JCT_SUBTRACT_GREEN:
<span class="line-modified">786         cconvert-&gt;pub.color_convert = rgb1_rgb_convert;</span>
<span class="line-modified">787         break;</span>
788       default:
<span class="line-modified">789         ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
790       }
791       break;
792     case JCS_YCCK:
793       cconvert-&gt;pub.color_convert = ycck_rgb_convert;
794       build_ycc_rgb_table(cinfo);
795       break;
796     case JCS_CMYK:
797       cconvert-&gt;pub.color_convert = cmyk_rgb_convert;
798       break;
799     default:
800       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
801     }
802     break;
803 
804   case JCS_BG_RGB:
805     cinfo-&gt;out_color_components = RGB_PIXELSIZE;
<span class="line-modified">806     if (cinfo-&gt;jpeg_color_space == JCS_BG_RGB) {</span>
<span class="line-modified">807       switch (cinfo-&gt;color_transform) {</span>
<span class="line-modified">808       case JCT_NONE:</span>
<span class="line-modified">809     cconvert-&gt;pub.color_convert = rgb_convert;</span>
<span class="line-modified">810     break;</span>
<span class="line-modified">811       case JCT_SUBTRACT_GREEN:</span>
<span class="line-modified">812     cconvert-&gt;pub.color_convert = rgb1_rgb_convert;</span>
<span class="line-modified">813     break;</span>
<span class="line-modified">814       default:</span>
<span class="line-modified">815     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
<span class="line-removed">816       }</span>
<span class="line-removed">817     } else</span>
818       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);

819     break;
820 
821   case JCS_CMYK:
822     cinfo-&gt;out_color_components = 4;
823     switch (cinfo-&gt;jpeg_color_space) {
824     case JCS_YCCK:
825       cconvert-&gt;pub.color_convert = ycck_cmyk_convert;
826       build_ycc_rgb_table(cinfo);
827       break;
828     case JCS_CMYK:
829       cconvert-&gt;pub.color_convert = null_convert;
830       break;
831     default:
832       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
833     }
834     break;
835 
<span class="line-modified">836   default:</span>
<span class="line-modified">837     /* Permit null conversion to same output space */</span>
<span class="line-modified">838     if (cinfo-&gt;out_color_space == cinfo-&gt;jpeg_color_space) {</span>
<span class="line-removed">839       cinfo-&gt;out_color_components = cinfo-&gt;num_components;</span>
<span class="line-removed">840       cconvert-&gt;pub.color_convert = null_convert;</span>
<span class="line-removed">841     } else            /* unsupported non-null conversion */</span>
842       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
<span class="line-modified">843     break;</span>

844   }
845 
846   if (cinfo-&gt;quantize_colors)
847     cinfo-&gt;output_components = 1; /* single colormapped output component */
848   else
849     cinfo-&gt;output_components = cinfo-&gt;out_color_components;
850 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * jdcolor.c
  3  *
  4  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="line-modified">  5  * Modified 2011-2019 by Guido Vollbeding.</span>
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains output colorspace conversion routines.
 10  */
 11 
 12 #define JPEG_INTERNALS
 13 #include &quot;jinclude.h&quot;
 14 #include &quot;jpeglib.h&quot;
 15 
 16 
 17 #if RANGE_BITS &lt; 2
 18   /* Deliberate syntax err */
 19   Sorry, this code requires 2 or more range extension bits.
 20 #endif
 21 
 22 
 23 /* Private subobject */
 24 
 25 typedef struct {
</pre>
<hr />
<pre>
107 
108 #define R_Y_OFF        0            /* offset to R =&gt; Y section */
109 #define G_Y_OFF        (1*(MAXJSAMPLE+1))    /* offset to G =&gt; Y section */
110 #define B_Y_OFF        (2*(MAXJSAMPLE+1))    /* etc. */
111 #define TABLE_SIZE    (3*(MAXJSAMPLE+1))
112 
113 
114 /*
115  * Initialize tables for YCbCr-&gt;RGB and BG_YCC-&gt;RGB colorspace conversion.
116  */
117 
118 LOCAL(void)
119 build_ycc_rgb_table (j_decompress_ptr cinfo)
120 /* Normal case, sYCC */
121 {
122   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
123   int i;
124   INT32 x;
125   SHIFT_TEMPS
126 
<span class="line-modified">127   cconvert-&gt;Cr_r_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">128     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">129   cconvert-&gt;Cb_b_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">130     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">131   cconvert-&gt;Cr_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">132     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-modified">133   cconvert-&gt;Cb_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">134     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>




135 
136   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
137     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
138     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
139     /* Cr=&gt;R value is nearest int to 1.402 * x */
<span class="line-modified">140     cconvert-&gt;Cr_r_tab[i] = (int) DESCALE(FIX(1.402) * x, SCALEBITS);</span>

141     /* Cb=&gt;B value is nearest int to 1.772 * x */
<span class="line-modified">142     cconvert-&gt;Cb_b_tab[i] = (int) DESCALE(FIX(1.772) * x, SCALEBITS);</span>

143     /* Cr=&gt;G value is scaled-up -0.714136286 * x */
144     cconvert-&gt;Cr_g_tab[i] = (- FIX(0.714136286)) * x;
145     /* Cb=&gt;G value is scaled-up -0.344136286 * x */
146     /* We also add in ONE_HALF so that need not do it in inner loop */
147     cconvert-&gt;Cb_g_tab[i] = (- FIX(0.344136286)) * x + ONE_HALF;
148   }
149 }
150 
151 
152 LOCAL(void)
153 build_bg_ycc_rgb_table (j_decompress_ptr cinfo)
154 /* Wide gamut case, bg-sYCC */
155 {
156   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
157   int i;
158   INT32 x;
159   SHIFT_TEMPS
160 
<span class="line-modified">161   cconvert-&gt;Cr_r_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">162     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">163   cconvert-&gt;Cb_b_tab = (int *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">164     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(int));</span>
<span class="line-modified">165   cconvert-&gt;Cr_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">166     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>
<span class="line-modified">167   cconvert-&gt;Cb_g_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">168     ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));</span>




169 
170   for (i = 0, x = -CENTERJSAMPLE; i &lt;= MAXJSAMPLE; i++, x++) {
171     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
172     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
173     /* Cr=&gt;R value is nearest int to 2.804 * x */
<span class="line-modified">174     cconvert-&gt;Cr_r_tab[i] = (int) DESCALE(FIX(2.804) * x, SCALEBITS);</span>

175     /* Cb=&gt;B value is nearest int to 3.544 * x */
<span class="line-modified">176     cconvert-&gt;Cb_b_tab[i] = (int) DESCALE(FIX(3.544) * x, SCALEBITS);</span>

177     /* Cr=&gt;G value is scaled-up -1.428272572 * x */
178     cconvert-&gt;Cr_g_tab[i] = (- FIX(1.428272572)) * x;
179     /* Cb=&gt;G value is scaled-up -0.688272572 * x */
180     /* We also add in ONE_HALF so that need not do it in inner loop */
181     cconvert-&gt;Cb_g_tab[i] = (- FIX(0.688272572)) * x + ONE_HALF;
182   }
183 }
184 
185 
186 /*
187  * Convert some rows of samples to the output colorspace.
188  *
189  * Note that we change from noninterleaved, one-plane-per-component format
190  * to interleaved-pixel format.  The output buffer is therefore three times
191  * as wide as the input buffer.
<span class="line-added">192  *</span>
193  * A starting row offset is provided only for the input buffer.  The caller
194  * can easily adjust the passed output_buf value to accommodate any row
195  * offset required on that side.
196  */
197 
198 METHODDEF(void)
199 ycc_rgb_convert (j_decompress_ptr cinfo,
200          JSAMPIMAGE input_buf, JDIMENSION input_row,
201          JSAMPARRAY output_buf, int num_rows)
202 {
203   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
204   register int y, cb, cr;
205   register JSAMPROW outptr;
206   register JSAMPROW inptr0, inptr1, inptr2;
207   register JDIMENSION col;
208   JDIMENSION num_cols = cinfo-&gt;output_width;
209   /* copy these pointers into registers if possible */
210   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
211   register int * Crrtab = cconvert-&gt;Cr_r_tab;
212   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
</pre>
<hr />
<pre>
236     }
237   }
238 }
239 
240 
241 /**************** Cases other than YCC -&gt; RGB ****************/
242 
243 
244 /*
245  * Initialize for RGB-&gt;grayscale colorspace conversion.
246  */
247 
248 LOCAL(void)
249 build_rgb_y_table (j_decompress_ptr cinfo)
250 {
251   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
252   INT32 * rgb_y_tab;
253   INT32 i;
254 
255   /* Allocate and fill in the conversion tables. */
<span class="line-modified">256   cconvert-&gt;rgb_y_tab = rgb_y_tab = (INT32 *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">257     ((j_common_ptr) cinfo, JPOOL_IMAGE, TABLE_SIZE * SIZEOF(INT32));</span>

258 
259   for (i = 0; i &lt;= MAXJSAMPLE; i++) {
260     rgb_y_tab[i+R_Y_OFF] = FIX(0.299) * i;
261     rgb_y_tab[i+G_Y_OFF] = FIX(0.587) * i;
262     rgb_y_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;
263   }
264 }
265 
266 
267 /*
268  * Convert RGB to grayscale.
269  */
270 
271 METHODDEF(void)
272 rgb_gray_convert (j_decompress_ptr cinfo,
273           JSAMPIMAGE input_buf, JDIMENSION input_row,
274           JSAMPARRAY output_buf, int num_rows)
275 {
276   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;

277   register int r, g, b;
<span class="line-added">278   register INT32 * ctab = cconvert-&gt;rgb_y_tab;</span>
279   register JSAMPROW outptr;
280   register JSAMPROW inptr0, inptr1, inptr2;
281   register JDIMENSION col;
282   JDIMENSION num_cols = cinfo-&gt;output_width;
283 
284   while (--num_rows &gt;= 0) {
285     inptr0 = input_buf[0][input_row];
286     inptr1 = input_buf[1][input_row];
287     inptr2 = input_buf[2][input_row];
288     input_row++;
289     outptr = *output_buf++;
290     for (col = 0; col &lt; num_cols; col++) {
291       r = GETJSAMPLE(inptr0[col]);
292       g = GETJSAMPLE(inptr1[col]);
293       b = GETJSAMPLE(inptr2[col]);
294       /* Y */
295       outptr[col] = (JSAMPLE)
296         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
297          &gt;&gt; SCALEBITS);
298     }
299   }
300 }
301 
302 
303 /*
<span class="line-added">304  * Convert some rows of samples to the output colorspace.</span>
305  * [R-G,G,B-G] to [R,G,B] conversion with modulo calculation
306  * (inverse color transform).
307  * This can be seen as an adaption of the general YCbCr-&gt;RGB
308  * conversion equation with Kr = Kb = 0, while replacing the
309  * normalization by modulo calculation.
310  */
311 
312 METHODDEF(void)
313 rgb1_rgb_convert (j_decompress_ptr cinfo,
314           JSAMPIMAGE input_buf, JDIMENSION input_row,
315           JSAMPARRAY output_buf, int num_rows)
316 {
317   register int r, g, b;
318   register JSAMPROW outptr;
319   register JSAMPROW inptr0, inptr1, inptr2;
320   register JDIMENSION col;
321   JDIMENSION num_cols = cinfo-&gt;output_width;
322 
323   while (--num_rows &gt;= 0) {
324     inptr0 = input_buf[0][input_row];
</pre>
<hr />
<pre>
336       outptr[RGB_RED]   = (JSAMPLE) ((r + g - CENTERJSAMPLE) &amp; MAXJSAMPLE);
337       outptr[RGB_GREEN] = (JSAMPLE) g;
338       outptr[RGB_BLUE]  = (JSAMPLE) ((b + g - CENTERJSAMPLE) &amp; MAXJSAMPLE);
339       outptr += RGB_PIXELSIZE;
340     }
341   }
342 }
343 
344 
345 /*
346  * [R-G,G,B-G] to grayscale conversion with modulo calculation
347  * (inverse color transform).
348  */
349 
350 METHODDEF(void)
351 rgb1_gray_convert (j_decompress_ptr cinfo,
352            JSAMPIMAGE input_buf, JDIMENSION input_row,
353            JSAMPARRAY output_buf, int num_rows)
354 {
355   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;

356   register int r, g, b;
<span class="line-added">357   register INT32 * ctab = cconvert-&gt;rgb_y_tab;</span>
358   register JSAMPROW outptr;
359   register JSAMPROW inptr0, inptr1, inptr2;
360   register JDIMENSION col;
361   JDIMENSION num_cols = cinfo-&gt;output_width;
362 
363   while (--num_rows &gt;= 0) {
364     inptr0 = input_buf[0][input_row];
365     inptr1 = input_buf[1][input_row];
366     inptr2 = input_buf[2][input_row];
367     input_row++;
368     outptr = *output_buf++;
369     for (col = 0; col &lt; num_cols; col++) {
370       r = GETJSAMPLE(inptr0[col]);
371       g = GETJSAMPLE(inptr1[col]);
372       b = GETJSAMPLE(inptr2[col]);
373       /* Assume that MAXJSAMPLE+1 is a power of 2, so that the MOD
374        * (modulo) operator is equivalent to the bitmask operator AND.
375        */
376       r = (r + g - CENTERJSAMPLE) &amp; MAXJSAMPLE;
377       b = (b + g - CENTERJSAMPLE) &amp; MAXJSAMPLE;
378       /* Y */
379       outptr[col] = (JSAMPLE)
380         ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
381          &gt;&gt; SCALEBITS);
382     }
383   }
384 }
385 
386 
387 /*
<span class="line-added">388  * Convert some rows of samples to the output colorspace.</span>
389  * No colorspace change, but conversion from separate-planes
390  * to interleaved representation.
391  */
392 
393 METHODDEF(void)
394 rgb_convert (j_decompress_ptr cinfo,
395          JSAMPIMAGE input_buf, JDIMENSION input_row,
396          JSAMPARRAY output_buf, int num_rows)
397 {
398   register JSAMPROW outptr;
399   register JSAMPROW inptr0, inptr1, inptr2;
400   register JDIMENSION col;
401   JDIMENSION num_cols = cinfo-&gt;output_width;
402 
403   while (--num_rows &gt;= 0) {
404     inptr0 = input_buf[0][input_row];
405     inptr1 = input_buf[1][input_row];
406     inptr2 = input_buf[2][input_row];
407     input_row++;
408     outptr = *output_buf++;
409     for (col = 0; col &lt; num_cols; col++) {
410       /* We can dispense with GETJSAMPLE() here */
411       outptr[RGB_RED]   = inptr0[col];
412       outptr[RGB_GREEN] = inptr1[col];
413       outptr[RGB_BLUE]  = inptr2[col];
414       outptr += RGB_PIXELSIZE;
415     }
416   }
417 }
418 
419 
420 /*
421  * Color conversion for no colorspace change: just copy the data,
422  * converting from separate-planes to interleaved representation.
<span class="line-added">423  * We assume out_color_components == num_components.</span>
424  */
425 
426 METHODDEF(void)
427 null_convert (j_decompress_ptr cinfo,
428           JSAMPIMAGE input_buf, JDIMENSION input_row,
429           JSAMPARRAY output_buf, int num_rows)
430 {


431   register JSAMPROW outptr;
432   register JSAMPROW inptr;
<span class="line-modified">433   register JDIMENSION count;</span>
<span class="line-added">434   register int num_comps = cinfo-&gt;num_components;</span>
435   JDIMENSION num_cols = cinfo-&gt;output_width;
<span class="line-added">436   int ci;</span>
437 
438   while (--num_rows &gt;= 0) {
<span class="line-modified">439     /* It seems fastest to make a separate pass for each component. */</span>
<span class="line-added">440     for (ci = 0; ci &lt; num_comps; ci++) {</span>
441       inptr = input_buf[ci][input_row];
442       outptr = output_buf[0] + ci;
<span class="line-modified">443       for (count = num_cols; count &gt; 0; count--) {</span>
<span class="line-modified">444     *outptr = *inptr++;    /* don&#39;t need GETJSAMPLE() here */</span>
<span class="line-modified">445     outptr += num_comps;</span>
446       }
447     }
448     input_row++;
449     output_buf++;
450   }
451 }
452 
453 
454 /*
455  * Color conversion for grayscale: just copy the data.
456  * This also works for YCC -&gt; grayscale conversion, in which
457  * we just copy the Y (luminance) component and ignore chrominance.
458  */
459 
460 METHODDEF(void)
461 grayscale_convert (j_decompress_ptr cinfo,
462            JSAMPIMAGE input_buf, JDIMENSION input_row,
463            JSAMPARRAY output_buf, int num_rows)
464 {
465   jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
</pre>
<hr />
<pre>
591       m = GETJSAMPLE(inptr1[col]);
592       y = GETJSAMPLE(inptr2[col]);
593       k = GETJSAMPLE(inptr3[col]);
594 
595       r = c * k / MAXJSAMPLE;
596       g = m * k / MAXJSAMPLE;
597       b = y * k / MAXJSAMPLE;
598 
599       /* Range-limiting is essential due to noise introduced by DCT losses. */
600       outptr[RGB_RED] = range_limit[r];
601       outptr[RGB_GREEN] = range_limit[g];
602       outptr[RGB_BLUE] = range_limit[b];
603 
604       outptr += RGB_PIXELSIZE;
605     }
606   }
607 }
608 
609 
610 /*
<span class="line-modified">611  * Convert some rows of samples to the output colorspace.</span>
<span class="line-modified">612  * This version handles Adobe-style YCCK-&gt;CMYK conversion,</span>
<span class="line-modified">613  * where we convert YCbCr to R=1-C, G=1-M, and B=1-Y using the</span>
<span class="line-added">614  * same conversion as above, while passing K (black) unchanged.</span>
615  * We assume build_ycc_rgb_table has been called.
616  */
617 
618 METHODDEF(void)
619 ycck_cmyk_convert (j_decompress_ptr cinfo,
620            JSAMPIMAGE input_buf, JDIMENSION input_row,
621            JSAMPARRAY output_buf, int num_rows)
622 {
623   my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo-&gt;cconvert;
624   register int y, cb, cr;
625   register JSAMPROW outptr;
626   register JSAMPROW inptr0, inptr1, inptr2, inptr3;
627   register JDIMENSION col;
628   JDIMENSION num_cols = cinfo-&gt;output_width;
629   /* copy these pointers into registers if possible */
630   register JSAMPLE * range_limit = cinfo-&gt;sample_range_limit;
631   register int * Crrtab = cconvert-&gt;Cr_r_tab;
632   register int * Cbbtab = cconvert-&gt;Cb_b_tab;
633   register INT32 * Crgtab = cconvert-&gt;Cr_g_tab;
634   register INT32 * Cbgtab = cconvert-&gt;Cb_g_tab;
</pre>
<hr />
<pre>
665  * Empty method for start_pass.
666  */
667 
668 METHODDEF(void)
669 start_pass_dcolor (j_decompress_ptr cinfo)
670 {
671   /* no work needed */
672 }
673 
674 
675 /*
676  * Module initialization routine for output colorspace conversion.
677  */
678 
679 GLOBAL(void)
680 jinit_color_deconverter (j_decompress_ptr cinfo)
681 {
682   my_cconvert_ptr cconvert;
683   int ci;
684 
<span class="line-modified">685   cconvert = (my_cconvert_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">686     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_color_deconverter));</span>

687   cinfo-&gt;cconvert = &amp;cconvert-&gt;pub;
688   cconvert-&gt;pub.start_pass = start_pass_dcolor;
689 
690   /* Make sure num_components agrees with jpeg_color_space */
691   switch (cinfo-&gt;jpeg_color_space) {
692   case JCS_GRAYSCALE:
693     if (cinfo-&gt;num_components != 1)
694       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
695     break;
696 
697   case JCS_RGB:
698   case JCS_YCbCr:
699   case JCS_BG_RGB:
700   case JCS_BG_YCC:
701     if (cinfo-&gt;num_components != 3)
702       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
703     break;
704 
705   case JCS_CMYK:
706   case JCS_YCCK:
707     if (cinfo-&gt;num_components != 4)
708       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
709     break;
710 
711   default:            /* JCS_UNKNOWN can be anything */
712     if (cinfo-&gt;num_components &lt; 1)
713       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);

714   }
715 
716   /* Support color transform only for RGB colorspaces */
717   if (cinfo-&gt;color_transform &amp;&amp;
718       cinfo-&gt;jpeg_color_space != JCS_RGB &amp;&amp;
719       cinfo-&gt;jpeg_color_space != JCS_BG_RGB)
720     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
721 
722   /* Set out_color_components and conversion method based on requested space.
723    * Also clear the component_needed flags for any unused components,
724    * so that earlier pipeline stages can avoid useless computation.
725    */
726 
727   switch (cinfo-&gt;out_color_space) {
728   case JCS_GRAYSCALE:
729     cinfo-&gt;out_color_components = 1;
730     switch (cinfo-&gt;jpeg_color_space) {
731     case JCS_GRAYSCALE:
732     case JCS_YCbCr:
733     case JCS_BG_YCC:
</pre>
<hr />
<pre>
754     }
755     break;
756 
757   case JCS_RGB:
758     cinfo-&gt;out_color_components = RGB_PIXELSIZE;
759     switch (cinfo-&gt;jpeg_color_space) {
760     case JCS_GRAYSCALE:
761       cconvert-&gt;pub.color_convert = gray_rgb_convert;
762       break;
763     case JCS_YCbCr:
764       cconvert-&gt;pub.color_convert = ycc_rgb_convert;
765       build_ycc_rgb_table(cinfo);
766       break;
767     case JCS_BG_YCC:
768       cconvert-&gt;pub.color_convert = ycc_rgb_convert;
769       build_bg_ycc_rgb_table(cinfo);
770       break;
771     case JCS_RGB:
772       switch (cinfo-&gt;color_transform) {
773       case JCT_NONE:
<span class="line-modified">774     cconvert-&gt;pub.color_convert = rgb_convert;</span>
<span class="line-modified">775     break;</span>
776       case JCT_SUBTRACT_GREEN:
<span class="line-modified">777     cconvert-&gt;pub.color_convert = rgb1_rgb_convert;</span>
<span class="line-modified">778     break;</span>
779       default:
<span class="line-modified">780     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
781       }
782       break;
783     case JCS_YCCK:
784       cconvert-&gt;pub.color_convert = ycck_rgb_convert;
785       build_ycc_rgb_table(cinfo);
786       break;
787     case JCS_CMYK:
788       cconvert-&gt;pub.color_convert = cmyk_rgb_convert;
789       break;
790     default:
791       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
792     }
793     break;
794 
795   case JCS_BG_RGB:
796     cinfo-&gt;out_color_components = RGB_PIXELSIZE;
<span class="line-modified">797     if (cinfo-&gt;jpeg_color_space != JCS_BG_RGB)</span>
<span class="line-modified">798       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);</span>
<span class="line-modified">799     switch (cinfo-&gt;color_transform) {</span>
<span class="line-modified">800     case JCT_NONE:</span>
<span class="line-modified">801       cconvert-&gt;pub.color_convert = rgb_convert;</span>
<span class="line-modified">802       break;</span>
<span class="line-modified">803     case JCT_SUBTRACT_GREEN:</span>
<span class="line-modified">804       cconvert-&gt;pub.color_convert = rgb1_rgb_convert;</span>
<span class="line-modified">805       break;</span>
<span class="line-modified">806     default:</span>


807       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
<span class="line-added">808     }</span>
809     break;
810 
811   case JCS_CMYK:
812     cinfo-&gt;out_color_components = 4;
813     switch (cinfo-&gt;jpeg_color_space) {
814     case JCS_YCCK:
815       cconvert-&gt;pub.color_convert = ycck_cmyk_convert;
816       build_ycc_rgb_table(cinfo);
817       break;
818     case JCS_CMYK:
819       cconvert-&gt;pub.color_convert = null_convert;
820       break;
821     default:
822       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
823     }
824     break;
825 
<span class="line-modified">826   default:        /* permit null conversion to same output space */</span>
<span class="line-modified">827     if (cinfo-&gt;out_color_space != cinfo-&gt;jpeg_color_space)</span>
<span class="line-modified">828       /* unsupported non-null conversion */</span>



829       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
<span class="line-modified">830     cinfo-&gt;out_color_components = cinfo-&gt;num_components;</span>
<span class="line-added">831     cconvert-&gt;pub.color_convert = null_convert;</span>
832   }
833 
834   if (cinfo-&gt;quantize_colors)
835     cinfo-&gt;output_components = 1; /* single colormapped output component */
836   else
837     cinfo-&gt;output_components = cinfo-&gt;out_color_components;
838 }
</pre>
</td>
</tr>
</table>
<center><a href="jcparam.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jdct.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-iio/libjpeg/jcmarker.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * jcmarker.c
  3  *
  4  * Copyright (C) 1991-1998, Thomas G. Lane.
<a name="1" id="anc1"></a><span class="line-modified">  5  * Modified 2003-2019 by Guido Vollbeding.</span>
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains routines to write JPEG datastream markers.
 10  */
 11 
 12 #define JPEG_INTERNALS
 13 #include &quot;jinclude.h&quot;
 14 #include &quot;jpeglib.h&quot;
 15 
 16 
 17 typedef enum {            /* JPEG marker codes */
 18   M_SOF0  = 0xc0,
 19   M_SOF1  = 0xc1,
 20   M_SOF2  = 0xc2,
 21   M_SOF3  = 0xc3,
 22 
 23   M_SOF5  = 0xc5,
 24   M_SOF6  = 0xc6,
 25   M_SOF7  = 0xc7,
 26 
 27   M_JPG   = 0xc8,
 28   M_SOF9  = 0xc9,
 29   M_SOF10 = 0xca,
 30   M_SOF11 = 0xcb,
 31 
 32   M_SOF13 = 0xcd,
 33   M_SOF14 = 0xce,
 34   M_SOF15 = 0xcf,
 35 
 36   M_DHT   = 0xc4,
 37 
 38   M_DAC   = 0xcc,
 39 
 40   M_RST0  = 0xd0,
 41   M_RST1  = 0xd1,
 42   M_RST2  = 0xd2,
 43   M_RST3  = 0xd3,
 44   M_RST4  = 0xd4,
 45   M_RST5  = 0xd5,
 46   M_RST6  = 0xd6,
 47   M_RST7  = 0xd7,
 48 
 49   M_SOI   = 0xd8,
 50   M_EOI   = 0xd9,
 51   M_SOS   = 0xda,
 52   M_DQT   = 0xdb,
 53   M_DNL   = 0xdc,
 54   M_DRI   = 0xdd,
 55   M_DHP   = 0xde,
 56   M_EXP   = 0xdf,
 57 
 58   M_APP0  = 0xe0,
 59   M_APP1  = 0xe1,
 60   M_APP2  = 0xe2,
 61   M_APP3  = 0xe3,
 62   M_APP4  = 0xe4,
 63   M_APP5  = 0xe5,
 64   M_APP6  = 0xe6,
 65   M_APP7  = 0xe7,
 66   M_APP8  = 0xe8,
 67   M_APP9  = 0xe9,
 68   M_APP10 = 0xea,
 69   M_APP11 = 0xeb,
 70   M_APP12 = 0xec,
 71   M_APP13 = 0xed,
 72   M_APP14 = 0xee,
 73   M_APP15 = 0xef,
 74 
 75   M_JPG0  = 0xf0,
 76   M_JPG8  = 0xf8,
 77   M_JPG13 = 0xfd,
 78   M_COM   = 0xfe,
 79 
 80   M_TEM   = 0x01,
 81 
 82   M_ERROR = 0x100
 83 } JPEG_MARKER;
 84 
 85 
 86 /* Private state */
 87 
 88 typedef struct {
 89   struct jpeg_marker_writer pub; /* public fields */
 90 
 91   unsigned int last_restart_interval; /* last DRI value emitted; 0 after SOI */
 92 } my_marker_writer;
 93 
 94 typedef my_marker_writer * my_marker_ptr;
 95 
 96 
 97 /*
 98  * Basic output routines.
 99  *
100  * Note that we do not support suspension while writing a marker.
101  * Therefore, an application using suspension must ensure that there is
102  * enough buffer space for the initial markers (typ. 600-700 bytes) before
103  * calling jpeg_start_compress, and enough space to write the trailing EOI
104  * (a few bytes) before calling jpeg_finish_compress.  Multipass compression
105  * modes are not supported at all with suspension, so those two are the only
106  * points where markers will be written.
107  */
108 
109 LOCAL(void)
110 emit_byte (j_compress_ptr cinfo, int val)
111 /* Emit a byte */
112 {
113   struct jpeg_destination_mgr * dest = cinfo-&gt;dest;
114 
115   *(dest-&gt;next_output_byte)++ = (JOCTET) val;
116   if (--dest-&gt;free_in_buffer == 0) {
117     if (! (*dest-&gt;empty_output_buffer) (cinfo))
118       ERREXIT(cinfo, JERR_CANT_SUSPEND);
119   }
120 }
121 
122 
123 LOCAL(void)
124 emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)
125 /* Emit a marker code */
126 {
127   emit_byte(cinfo, 0xFF);
128   emit_byte(cinfo, (int) mark);
129 }
130 
131 
132 LOCAL(void)
133 emit_2bytes (j_compress_ptr cinfo, int value)
134 /* Emit a 2-byte integer; these are always MSB first in JPEG files */
135 {
136   emit_byte(cinfo, (value &gt;&gt; 8) &amp; 0xFF);
137   emit_byte(cinfo, value &amp; 0xFF);
138 }
139 
140 
141 /*
142  * Routines to write specific marker types.
143  */
144 
145 LOCAL(int)
146 emit_dqt (j_compress_ptr cinfo, int index)
147 /* Emit a DQT marker */
148 /* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
149 {
150   JQUANT_TBL * qtbl = cinfo-&gt;quant_tbl_ptrs[index];
151   int prec;
152   int i;
153 
154   if (qtbl == NULL)
155     ERREXIT1(cinfo, JERR_NO_QUANT_TABLE, index);
156 
157   prec = 0;
158   for (i = 0; i &lt;= cinfo-&gt;lim_Se; i++) {
159     if (qtbl-&gt;quantval[cinfo-&gt;natural_order[i]] &gt; 255)
160       prec = 1;
161   }
162 
163   if (! qtbl-&gt;sent_table) {
164     emit_marker(cinfo, M_DQT);
165 
166     emit_2bytes(cinfo,
167       prec ? cinfo-&gt;lim_Se * 2 + 2 + 1 + 2 : cinfo-&gt;lim_Se + 1 + 1 + 2);
168 
169     emit_byte(cinfo, index + (prec&lt;&lt;4));
170 
171     for (i = 0; i &lt;= cinfo-&gt;lim_Se; i++) {
172       /* The table entries must be emitted in zigzag order. */
173       unsigned int qval = qtbl-&gt;quantval[cinfo-&gt;natural_order[i]];
174       if (prec)
175     emit_byte(cinfo, (int) (qval &gt;&gt; 8));
176       emit_byte(cinfo, (int) (qval &amp; 0xFF));
177     }
178 
179     qtbl-&gt;sent_table = TRUE;
180   }
181 
182   return prec;
183 }
184 
185 
186 LOCAL(void)
187 emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
188 /* Emit a DHT marker */
189 {
190   JHUFF_TBL * htbl;
191   int length, i;
192 
193   if (is_ac) {
194     htbl = cinfo-&gt;ac_huff_tbl_ptrs[index];
195     index += 0x10;        /* output index has AC bit set */
196   } else {
197     htbl = cinfo-&gt;dc_huff_tbl_ptrs[index];
198   }
199 
200   if (htbl == NULL)
201     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);
202 
203   if (! htbl-&gt;sent_table) {
204     emit_marker(cinfo, M_DHT);
205 
206     length = 0;
207     for (i = 1; i &lt;= 16; i++)
208       length += htbl-&gt;bits[i];
209 
210     emit_2bytes(cinfo, length + 2 + 1 + 16);
211     emit_byte(cinfo, index);
212 
213     for (i = 1; i &lt;= 16; i++)
214       emit_byte(cinfo, htbl-&gt;bits[i]);
215 
216     for (i = 0; i &lt; length; i++)
217       emit_byte(cinfo, htbl-&gt;huffval[i]);
218 
219     htbl-&gt;sent_table = TRUE;
220   }
221 }
222 
223 
224 LOCAL(void)
225 emit_dac (j_compress_ptr cinfo)
226 /* Emit a DAC marker */
227 /* Since the useful info is so small, we want to emit all the tables in */
228 /* one DAC marker.  Therefore this routine does its own scan of the table. */
229 {
230 #ifdef C_ARITH_CODING_SUPPORTED
231   char dc_in_use[NUM_ARITH_TBLS];
232   char ac_in_use[NUM_ARITH_TBLS];
233   int length, i;
234   jpeg_component_info *compptr;
235 
236   for (i = 0; i &lt; NUM_ARITH_TBLS; i++)
237     dc_in_use[i] = ac_in_use[i] = 0;
238 
239   for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {
240     compptr = cinfo-&gt;cur_comp_info[i];
241     /* DC needs no table for refinement scan */
242     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0)
243       dc_in_use[compptr-&gt;dc_tbl_no] = 1;
244     /* AC needs no table when not present */
245     if (cinfo-&gt;Se)
246       ac_in_use[compptr-&gt;ac_tbl_no] = 1;
247   }
248 
249   length = 0;
250   for (i = 0; i &lt; NUM_ARITH_TBLS; i++)
251     length += dc_in_use[i] + ac_in_use[i];
252 
253   if (length) {
254     emit_marker(cinfo, M_DAC);
255 
256     emit_2bytes(cinfo, length*2 + 2);
257 
258     for (i = 0; i &lt; NUM_ARITH_TBLS; i++) {
259       if (dc_in_use[i]) {
260     emit_byte(cinfo, i);
261     emit_byte(cinfo, cinfo-&gt;arith_dc_L[i] + (cinfo-&gt;arith_dc_U[i]&lt;&lt;4));
262       }
263       if (ac_in_use[i]) {
264     emit_byte(cinfo, i + 0x10);
265     emit_byte(cinfo, cinfo-&gt;arith_ac_K[i]);
266       }
267     }
268   }
269 #endif /* C_ARITH_CODING_SUPPORTED */
270 }
271 
272 
273 LOCAL(void)
274 emit_dri (j_compress_ptr cinfo)
275 /* Emit a DRI marker */
276 {
277   emit_marker(cinfo, M_DRI);
278 
279   emit_2bytes(cinfo, 4);    /* fixed length */
280 
281   emit_2bytes(cinfo, (int) cinfo-&gt;restart_interval);
282 }
283 
284 
285 LOCAL(void)
286 emit_lse_ict (j_compress_ptr cinfo)
287 /* Emit an LSE inverse color transform specification marker */
288 {
289   /* Support only 1 transform */
290   if (cinfo-&gt;color_transform != JCT_SUBTRACT_GREEN ||
291       cinfo-&gt;num_components &lt; 3)
292     ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
293 
294   emit_marker(cinfo, M_JPG8);
295 
296   emit_2bytes(cinfo, 24);    /* fixed length */
297 
298   emit_byte(cinfo, 0x0D);    /* ID inverse transform specification */
299   emit_2bytes(cinfo, MAXJSAMPLE);    /* MAXTRANS */
300   emit_byte(cinfo, 3);        /* Nt=3 */
301   emit_byte(cinfo, cinfo-&gt;comp_info[1].component_id);
302   emit_byte(cinfo, cinfo-&gt;comp_info[0].component_id);
303   emit_byte(cinfo, cinfo-&gt;comp_info[2].component_id);
304   emit_byte(cinfo, 0x80);    /* F1: CENTER1=1, NORM1=0 */
305   emit_2bytes(cinfo, 0);    /* A(1,1)=0 */
306   emit_2bytes(cinfo, 0);    /* A(1,2)=0 */
307   emit_byte(cinfo, 0);        /* F2: CENTER2=0, NORM2=0 */
308   emit_2bytes(cinfo, 1);    /* A(2,1)=1 */
309   emit_2bytes(cinfo, 0);    /* A(2,2)=0 */
310   emit_byte(cinfo, 0);        /* F3: CENTER3=0, NORM3=0 */
311   emit_2bytes(cinfo, 1);    /* A(3,1)=1 */
312   emit_2bytes(cinfo, 0);    /* A(3,2)=0 */
313 }
314 
315 
316 LOCAL(void)
317 emit_sof (j_compress_ptr cinfo, JPEG_MARKER code)
318 /* Emit a SOF marker */
319 {
320   int ci;
321   jpeg_component_info *compptr;
322 
323   emit_marker(cinfo, code);
324 
325   emit_2bytes(cinfo, 3 * cinfo-&gt;num_components + 2 + 5 + 1); /* length */
326 
327   /* Make sure image isn&#39;t bigger than SOF field can handle */
328   if ((long) cinfo-&gt;jpeg_height &gt; 65535L ||
329       (long) cinfo-&gt;jpeg_width &gt; 65535L)
330     ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) 65535);
331 
332   emit_byte(cinfo, cinfo-&gt;data_precision);
333   emit_2bytes(cinfo, (int) cinfo-&gt;jpeg_height);
334   emit_2bytes(cinfo, (int) cinfo-&gt;jpeg_width);
335 
336   emit_byte(cinfo, cinfo-&gt;num_components);
337 
338   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
339        ci++, compptr++) {
340     emit_byte(cinfo, compptr-&gt;component_id);
341     emit_byte(cinfo, (compptr-&gt;h_samp_factor &lt;&lt; 4) + compptr-&gt;v_samp_factor);
342     emit_byte(cinfo, compptr-&gt;quant_tbl_no);
343   }
344 }
345 
346 
347 LOCAL(void)
348 emit_sos (j_compress_ptr cinfo)
349 /* Emit a SOS marker */
350 {
351   int i, td, ta;
352   jpeg_component_info *compptr;
353 
354   emit_marker(cinfo, M_SOS);
355 
356   emit_2bytes(cinfo, 2 * cinfo-&gt;comps_in_scan + 2 + 1 + 3); /* length */
357 
358   emit_byte(cinfo, cinfo-&gt;comps_in_scan);
359 
360   for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {
361     compptr = cinfo-&gt;cur_comp_info[i];
362     emit_byte(cinfo, compptr-&gt;component_id);
363 
364     /* We emit 0 for unused field(s); this is recommended by the P&amp;M text
365      * but does not seem to be specified in the standard.
366      */
367 
368     /* DC needs no table for refinement scan */
369     td = cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0 ? compptr-&gt;dc_tbl_no : 0;
370     /* AC needs no table when not present */
371     ta = cinfo-&gt;Se ? compptr-&gt;ac_tbl_no : 0;
372 
373     emit_byte(cinfo, (td &lt;&lt; 4) + ta);
374   }
375 
376   emit_byte(cinfo, cinfo-&gt;Ss);
377   emit_byte(cinfo, cinfo-&gt;Se);
378   emit_byte(cinfo, (cinfo-&gt;Ah &lt;&lt; 4) + cinfo-&gt;Al);
379 }
380 
381 
382 LOCAL(void)
383 emit_pseudo_sos (j_compress_ptr cinfo)
384 /* Emit a pseudo SOS marker */
385 {
386   emit_marker(cinfo, M_SOS);
387 
388   emit_2bytes(cinfo, 2 + 1 + 3); /* length */
389 
390   emit_byte(cinfo, 0); /* Ns */
391 
392   emit_byte(cinfo, 0); /* Ss */
393   emit_byte(cinfo, cinfo-&gt;block_size * cinfo-&gt;block_size - 1); /* Se */
394   emit_byte(cinfo, 0); /* Ah/Al */
395 }
396 
397 
398 LOCAL(void)
399 emit_jfif_app0 (j_compress_ptr cinfo)
400 /* Emit a JFIF-compliant APP0 marker */
401 {
402   /*
403    * Length of APP0 block    (2 bytes)
404    * Block ID            (4 bytes - ASCII &quot;JFIF&quot;)
405    * Zero byte            (1 byte to terminate the ID string)
406    * Version Major, Minor    (2 bytes - major first)
407    * Units            (1 byte - 0x00 = none, 0x01 = inch, 0x02 = cm)
408    * Xdpu            (2 bytes - dots per unit horizontal)
409    * Ydpu            (2 bytes - dots per unit vertical)
410    * Thumbnail X size        (1 byte)
411    * Thumbnail Y size        (1 byte)
412    */
413 
414   emit_marker(cinfo, M_APP0);
415 
416   emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */
417 
418   emit_byte(cinfo, 0x4A);    /* Identifier: ASCII &quot;JFIF&quot; */
419   emit_byte(cinfo, 0x46);
420   emit_byte(cinfo, 0x49);
421   emit_byte(cinfo, 0x46);
422   emit_byte(cinfo, 0);
423   emit_byte(cinfo, cinfo-&gt;JFIF_major_version); /* Version fields */
424   emit_byte(cinfo, cinfo-&gt;JFIF_minor_version);
425   emit_byte(cinfo, cinfo-&gt;density_unit); /* Pixel size information */
426   emit_2bytes(cinfo, (int) cinfo-&gt;X_density);
427   emit_2bytes(cinfo, (int) cinfo-&gt;Y_density);
428   emit_byte(cinfo, 0);        /* No thumbnail image */
429   emit_byte(cinfo, 0);
430 }
431 
432 
433 LOCAL(void)
434 emit_adobe_app14 (j_compress_ptr cinfo)
435 /* Emit an Adobe APP14 marker */
436 {
437   /*
438    * Length of APP14 block    (2 bytes)
439    * Block ID            (5 bytes - ASCII &quot;Adobe&quot;)
440    * Version Number        (2 bytes - currently 100)
441    * Flags0            (2 bytes - currently 0)
442    * Flags1            (2 bytes - currently 0)
443    * Color transform        (1 byte)
444    *
445    * Although Adobe TN 5116 mentions Version = 101, all the Adobe files
446    * now in circulation seem to use Version = 100, so that&#39;s what we write.
447    *
448    * We write the color transform byte as 1 if the JPEG color space is
449    * YCbCr, 2 if it&#39;s YCCK, 0 otherwise.  Adobe&#39;s definition has to do with
450    * whether the encoder performed a transformation, which is pretty useless.
451    */
452 
453   emit_marker(cinfo, M_APP14);
454 
455   emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */
456 
457   emit_byte(cinfo, 0x41);    /* Identifier: ASCII &quot;Adobe&quot; */
458   emit_byte(cinfo, 0x64);
459   emit_byte(cinfo, 0x6F);
460   emit_byte(cinfo, 0x62);
461   emit_byte(cinfo, 0x65);
462   emit_2bytes(cinfo, 100);    /* Version */
463   emit_2bytes(cinfo, 0);    /* Flags0 */
464   emit_2bytes(cinfo, 0);    /* Flags1 */
465   switch (cinfo-&gt;jpeg_color_space) {
466   case JCS_YCbCr:
467     emit_byte(cinfo, 1);    /* Color transform = 1 */
468     break;
469   case JCS_YCCK:
470     emit_byte(cinfo, 2);    /* Color transform = 2 */
471     break;
472   default:
473     emit_byte(cinfo, 0);    /* Color transform = 0 */
<a name="2" id="anc2"></a>
474   }
475 }
476 
477 
478 /*
479  * These routines allow writing an arbitrary marker with parameters.
480  * The only intended use is to emit COM or APPn markers after calling
481  * write_file_header and before calling write_frame_header.
482  * Other uses are not guaranteed to produce desirable results.
483  * Counting the parameter bytes properly is the caller&#39;s responsibility.
484  */
485 
486 METHODDEF(void)
487 write_marker_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
488 /* Emit an arbitrary marker header */
489 {
490   if (datalen &gt; (unsigned int) 65533)        /* safety check */
491     ERREXIT(cinfo, JERR_BAD_LENGTH);
492 
493   emit_marker(cinfo, (JPEG_MARKER) marker);
494 
495   emit_2bytes(cinfo, (int) (datalen + 2));    /* total length */
496 }
497 
498 METHODDEF(void)
499 write_marker_byte (j_compress_ptr cinfo, int val)
500 /* Emit one byte of marker parameters following write_marker_header */
501 {
502   emit_byte(cinfo, val);
503 }
504 
505 
506 /*
507  * Write datastream header.
508  * This consists of an SOI and optional APPn markers.
509  * We recommend use of the JFIF marker, but not the Adobe marker,
510  * when using YCbCr or grayscale data.  The JFIF marker is also used
511  * for other standard JPEG colorspaces.  The Adobe marker is helpful
512  * to distinguish RGB, CMYK, and YCCK colorspaces.
513  * Note that an application can write additional header markers after
514  * jpeg_start_compress returns.
515  */
516 
517 METHODDEF(void)
518 write_file_header (j_compress_ptr cinfo)
519 {
520   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;
521 
522   emit_marker(cinfo, M_SOI);    /* first the SOI */
523 
524   /* SOI is defined to reset restart interval to 0 */
525   marker-&gt;last_restart_interval = 0;
526 
527   if (cinfo-&gt;write_JFIF_header)    /* next an optional JFIF APP0 */
528     emit_jfif_app0(cinfo);
529   if (cinfo-&gt;write_Adobe_marker) /* next an optional Adobe APP14 */
530     emit_adobe_app14(cinfo);
531 }
532 
533 
534 /*
535  * Write frame header.
536  * This consists of DQT and SOFn markers,
537  * a conditional LSE marker and a conditional pseudo SOS marker.
538  * Note that we do not emit the SOF until we have emitted the DQT(s).
539  * This avoids compatibility problems with incorrect implementations that
540  * try to error-check the quant table numbers as soon as they see the SOF.
541  */
542 
543 METHODDEF(void)
544 write_frame_header (j_compress_ptr cinfo)
545 {
546   int ci, prec;
547   boolean is_baseline;
548   jpeg_component_info *compptr;
549 
550   /* Emit DQT for each quantization table.
551    * Note that emit_dqt() suppresses any duplicate tables.
552    */
553   prec = 0;
554   for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
555        ci++, compptr++) {
556     prec += emit_dqt(cinfo, compptr-&gt;quant_tbl_no);
557   }
558   /* now prec is nonzero iff there are any 16-bit quant tables. */
559 
560   /* Check for a non-baseline specification.
561    * Note we assume that Huffman table numbers won&#39;t be changed later.
562    */
563   if (cinfo-&gt;arith_code || cinfo-&gt;progressive_mode ||
564       cinfo-&gt;data_precision != 8 || cinfo-&gt;block_size != DCTSIZE) {
565     is_baseline = FALSE;
566   } else {
567     is_baseline = TRUE;
568     for (ci = 0, compptr = cinfo-&gt;comp_info; ci &lt; cinfo-&gt;num_components;
569      ci++, compptr++) {
570       if (compptr-&gt;dc_tbl_no &gt; 1 || compptr-&gt;ac_tbl_no &gt; 1)
571     is_baseline = FALSE;
572     }
573     if (prec &amp;&amp; is_baseline) {
574       is_baseline = FALSE;
575       /* If it&#39;s baseline except for quantizer size, warn the user */
576       TRACEMS(cinfo, 0, JTRC_16BIT_TABLES);
577     }
578   }
579 
580   /* Emit the proper SOF marker */
581   if (cinfo-&gt;arith_code) {
582     if (cinfo-&gt;progressive_mode)
583       emit_sof(cinfo, M_SOF10); /* SOF code for progressive arithmetic */
584     else
585       emit_sof(cinfo, M_SOF9);  /* SOF code for sequential arithmetic */
586   } else {
587     if (cinfo-&gt;progressive_mode)
588       emit_sof(cinfo, M_SOF2);    /* SOF code for progressive Huffman */
589     else if (is_baseline)
590       emit_sof(cinfo, M_SOF0);    /* SOF code for baseline implementation */
591     else
592       emit_sof(cinfo, M_SOF1);    /* SOF code for non-baseline Huffman file */
593   }
594 
595   /* Check to emit LSE inverse color transform specification marker */
596   if (cinfo-&gt;color_transform)
597     emit_lse_ict(cinfo);
598 
599   /* Check to emit pseudo SOS marker */
600   if (cinfo-&gt;progressive_mode &amp;&amp; cinfo-&gt;block_size != DCTSIZE)
601     emit_pseudo_sos(cinfo);
602 }
603 
604 
605 /*
606  * Write scan header.
607  * This consists of DHT or DAC markers, optional DRI, and SOS.
608  * Compressed data will be written following the SOS.
609  */
610 
611 METHODDEF(void)
612 write_scan_header (j_compress_ptr cinfo)
613 {
614   my_marker_ptr marker = (my_marker_ptr) cinfo-&gt;marker;
615   int i;
616   jpeg_component_info *compptr;
617 
618   if (cinfo-&gt;arith_code) {
619     /* Emit arith conditioning info.  We may have some duplication
620      * if the file has multiple scans, but it&#39;s so small it&#39;s hardly
621      * worth worrying about.
622      */
623     emit_dac(cinfo);
624   } else {
625     /* Emit Huffman tables.
626      * Note that emit_dht() suppresses any duplicate tables.
627      */
628     for (i = 0; i &lt; cinfo-&gt;comps_in_scan; i++) {
629       compptr = cinfo-&gt;cur_comp_info[i];
630       /* DC needs no table for refinement scan */
631       if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0)
632     emit_dht(cinfo, compptr-&gt;dc_tbl_no, FALSE);
633       /* AC needs no table when not present */
634       if (cinfo-&gt;Se)
635     emit_dht(cinfo, compptr-&gt;ac_tbl_no, TRUE);
636     }
637   }
638 
639   /* Emit DRI if required --- note that DRI value could change for each scan.
640    * We avoid wasting space with unnecessary DRIs, however.
641    */
642   if (cinfo-&gt;restart_interval != marker-&gt;last_restart_interval) {
643     emit_dri(cinfo);
644     marker-&gt;last_restart_interval = cinfo-&gt;restart_interval;
645   }
646 
647   emit_sos(cinfo);
648 }
649 
650 
651 /*
652  * Write datastream trailer.
653  */
654 
655 METHODDEF(void)
656 write_file_trailer (j_compress_ptr cinfo)
657 {
658   emit_marker(cinfo, M_EOI);
659 }
660 
661 
662 /*
663  * Write an abbreviated table-specification datastream.
664  * This consists of SOI, DQT and DHT tables, and EOI.
665  * Any table that is defined and not marked sent_table = TRUE will be
666  * emitted.  Note that all tables will be marked sent_table = TRUE at exit.
667  */
668 
669 METHODDEF(void)
670 write_tables_only (j_compress_ptr cinfo)
671 {
672   int i;
673 
674   emit_marker(cinfo, M_SOI);
675 
676   for (i = 0; i &lt; NUM_QUANT_TBLS; i++) {
677     if (cinfo-&gt;quant_tbl_ptrs[i] != NULL)
678       (void) emit_dqt(cinfo, i);
679   }
680 
681   if (! cinfo-&gt;arith_code) {
682     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
683       if (cinfo-&gt;dc_huff_tbl_ptrs[i] != NULL)
684     emit_dht(cinfo, i, FALSE);
685       if (cinfo-&gt;ac_huff_tbl_ptrs[i] != NULL)
686     emit_dht(cinfo, i, TRUE);
687     }
688   }
689 
690   emit_marker(cinfo, M_EOI);
691 }
692 
693 
694 /*
695  * Initialize the marker writer module.
696  */
697 
698 GLOBAL(void)
699 jinit_marker_writer (j_compress_ptr cinfo)
700 {
701   my_marker_ptr marker;
702 
703   /* Create the subobject */
<a name="3" id="anc3"></a><span class="line-modified">704   marker = (my_marker_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">705     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(my_marker_writer));</span>

706   cinfo-&gt;marker = &amp;marker-&gt;pub;
707   /* Initialize method pointers */
708   marker-&gt;pub.write_file_header = write_file_header;
709   marker-&gt;pub.write_frame_header = write_frame_header;
710   marker-&gt;pub.write_scan_header = write_scan_header;
711   marker-&gt;pub.write_file_trailer = write_file_trailer;
712   marker-&gt;pub.write_tables_only = write_tables_only;
713   marker-&gt;pub.write_marker_header = write_marker_header;
714   marker-&gt;pub.write_marker_byte = write_marker_byte;
715   /* Initialize private state */
716   marker-&gt;last_restart_interval = 0;
717 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
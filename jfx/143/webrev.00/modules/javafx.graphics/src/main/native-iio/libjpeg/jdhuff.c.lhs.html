<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-iio/libjpeg/jdhuff.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * jdhuff.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<a name="1" id="anc1"></a><span class="line-modified">   5  * Modified 2006-2016 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains Huffman entropy decoding routines.
  10  * Both sequential and progressive modes are supported in this single module.
  11  *
  12  * Much of the complexity here has to do with supporting input suspension.
  13  * If the data source module demands suspension, we want to be able to back
  14  * up to the start of the current MCU.  To do this, we copy state variables
  15  * into local working storage, and update them back to the permanent
  16  * storage only upon successful completion of an MCU.
  17  */
  18 
  19 #define JPEG_INTERNALS
  20 #include &quot;jinclude.h&quot;
  21 #include &quot;jpeglib.h&quot;
  22 
  23 
  24 /* Derived data constructed for each Huffman table */
  25 
  26 #define HUFF_LOOKAHEAD    8    /* # of bits of lookahead */
  27 
  28 typedef struct {
  29   /* Basic tables: (element [0] of each array is unused) */
  30   INT32 maxcode[18];        /* largest code of length k (-1 if none) */
  31   /* (maxcode[17] is a sentinel to ensure jpeg_huff_decode terminates) */
  32   INT32 valoffset[17];        /* huffval[] offset for codes of length k */
  33   /* valoffset[k] = huffval[] index of 1st symbol of code length k, less
  34    * the smallest code of length k; so given a code of length k, the
  35    * corresponding symbol is huffval[code + valoffset[k]]
  36    */
  37 
  38   /* Link to public Huffman table (needed only in jpeg_huff_decode) */
  39   JHUFF_TBL *pub;
  40 
  41   /* Lookahead tables: indexed by the next HUFF_LOOKAHEAD bits of
  42    * the input data stream.  If the next Huffman code is no more
  43    * than HUFF_LOOKAHEAD bits long, we can obtain its length and
  44    * the corresponding symbol directly from these tables.
  45    */
  46   int look_nbits[1&lt;&lt;HUFF_LOOKAHEAD]; /* # bits, or 0 if too long */
  47   UINT8 look_sym[1&lt;&lt;HUFF_LOOKAHEAD]; /* symbol, or unused */
  48 } d_derived_tbl;
  49 
  50 
  51 /*
  52  * Fetching the next N bits from the input stream is a time-critical operation
  53  * for the Huffman decoders.  We implement it with a combination of inline
  54  * macros and out-of-line subroutines.  Note that N (the number of bits
  55  * demanded at one time) never exceeds 15 for JPEG use.
  56  *
  57  * We read source bytes into get_buffer and dole out bits as needed.
  58  * If get_buffer already contains enough bits, they are fetched in-line
  59  * by the macros CHECK_BIT_BUFFER and GET_BITS.  When there aren&#39;t enough
  60  * bits, jpeg_fill_bit_buffer is called; it will attempt to fill get_buffer
  61  * as full as possible (not just to the number of bits needed; this
  62  * prefetching reduces the overhead cost of calling jpeg_fill_bit_buffer).
  63  * Note that jpeg_fill_bit_buffer may return FALSE to indicate suspension.
  64  * On TRUE return, jpeg_fill_bit_buffer guarantees that get_buffer contains
  65  * at least the requested number of bits --- dummy zeroes are inserted if
  66  * necessary.
  67  */
  68 
  69 typedef INT32 bit_buf_type;    /* type of bit-extraction buffer */
  70 #define BIT_BUF_SIZE  32    /* size of buffer in bits */
  71 
  72 /* If long is &gt; 32 bits on your machine, and shifting/masking longs is
  73  * reasonably fast, making bit_buf_type be long and setting BIT_BUF_SIZE
  74  * appropriately should be a win.  Unfortunately we can&#39;t define the size
  75  * with something like  #define BIT_BUF_SIZE (sizeof(bit_buf_type)*8)
  76  * because not all machines measure sizeof in 8-bit bytes.
  77  */
  78 
  79 typedef struct {        /* Bitreading state saved across MCUs */
  80   bit_buf_type get_buffer;    /* current bit-extraction buffer */
  81   int bits_left;        /* # of unused bits in it */
  82 } bitread_perm_state;
  83 
  84 typedef struct {        /* Bitreading working state within an MCU */
  85   /* Current data source location */
  86   /* We need a copy, rather than munging the original, in case of suspension */
  87   const JOCTET * next_input_byte; /* =&gt; next byte to read from source */
  88   size_t bytes_in_buffer;    /* # of bytes remaining in source buffer */
  89   /* Bit input buffer --- note these values are kept in register variables,
  90    * not in this struct, inside the inner loops.
  91    */
  92   bit_buf_type get_buffer;    /* current bit-extraction buffer */
  93   int bits_left;        /* # of unused bits in it */
  94   /* Pointer needed by jpeg_fill_bit_buffer. */
  95   j_decompress_ptr cinfo;    /* back link to decompress master record */
  96 } bitread_working_state;
  97 
  98 /* Macros to declare and load/save bitread local variables. */
  99 #define BITREAD_STATE_VARS  \
 100     register bit_buf_type get_buffer;  \
 101     register int bits_left;  \
 102     bitread_working_state br_state
 103 
 104 #define BITREAD_LOAD_STATE(cinfop,permstate)  \
 105     br_state.cinfo = cinfop; \
 106     br_state.next_input_byte = cinfop-&gt;src-&gt;next_input_byte; \
 107     br_state.bytes_in_buffer = cinfop-&gt;src-&gt;bytes_in_buffer; \
 108     get_buffer = permstate.get_buffer; \
 109     bits_left = permstate.bits_left;
 110 
 111 #define BITREAD_SAVE_STATE(cinfop,permstate)  \
 112     cinfop-&gt;src-&gt;next_input_byte = br_state.next_input_byte; \
 113     cinfop-&gt;src-&gt;bytes_in_buffer = br_state.bytes_in_buffer; \
 114     permstate.get_buffer = get_buffer; \
 115     permstate.bits_left = bits_left
 116 
 117 /*
 118  * These macros provide the in-line portion of bit fetching.
 119  * Use CHECK_BIT_BUFFER to ensure there are N bits in get_buffer
 120  * before using GET_BITS, PEEK_BITS, or DROP_BITS.
 121  * The variables get_buffer and bits_left are assumed to be locals,
 122  * but the state struct might not be (jpeg_huff_decode needs this).
 123  *    CHECK_BIT_BUFFER(state,n,action);
 124  *        Ensure there are N bits in get_buffer; if suspend, take action.
 125  *      val = GET_BITS(n);
 126  *        Fetch next N bits.
 127  *      val = PEEK_BITS(n);
 128  *        Fetch next N bits without removing them from the buffer.
 129  *    DROP_BITS(n);
 130  *        Discard next N bits.
 131  * The value N should be a simple variable, not an expression, because it
 132  * is evaluated multiple times.
 133  */
 134 
 135 #define CHECK_BIT_BUFFER(state,nbits,action) \
 136     { if (bits_left &lt; (nbits)) {  \
 137         if (! jpeg_fill_bit_buffer(&amp;(state),get_buffer,bits_left,nbits))  \
 138           { action; }  \
 139         get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }
 140 
 141 #define GET_BITS(nbits) \
 142     (((int) (get_buffer &gt;&gt; (bits_left -= (nbits)))) &amp; BIT_MASK(nbits))
 143 
 144 #define PEEK_BITS(nbits) \
 145     (((int) (get_buffer &gt;&gt; (bits_left -  (nbits)))) &amp; BIT_MASK(nbits))
 146 
 147 #define DROP_BITS(nbits) \
 148     (bits_left -= (nbits))
 149 
 150 
 151 /*
 152  * Code for extracting next Huffman-coded symbol from input bit stream.
 153  * Again, this is time-critical and we make the main paths be macros.
 154  *
 155  * We use a lookahead table to process codes of up to HUFF_LOOKAHEAD bits
 156  * without looping.  Usually, more than 95% of the Huffman codes will be 8
 157  * or fewer bits long.  The few overlength codes are handled with a loop,
 158  * which need not be inline code.
 159  *
 160  * Notes about the HUFF_DECODE macro:
 161  * 1. Near the end of the data segment, we may fail to get enough bits
 162  *    for a lookahead.  In that case, we do it the hard way.
 163  * 2. If the lookahead table contains no entry, the next code must be
 164  *    more than HUFF_LOOKAHEAD bits long.
 165  * 3. jpeg_huff_decode returns -1 if forced to suspend.
 166  */
 167 
 168 #define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
 169 { register int nb, look; \
 170   if (bits_left &lt; HUFF_LOOKAHEAD) { \
 171     if (! jpeg_fill_bit_buffer(&amp;state,get_buffer,bits_left, 0)) {failaction;} \
 172     get_buffer = state.get_buffer; bits_left = state.bits_left; \
 173     if (bits_left &lt; HUFF_LOOKAHEAD) { \
 174       nb = 1; goto slowlabel; \
 175     } \
 176   } \
 177   look = PEEK_BITS(HUFF_LOOKAHEAD); \
 178   if ((nb = htbl-&gt;look_nbits[look]) != 0) { \
 179     DROP_BITS(nb); \
 180     result = htbl-&gt;look_sym[look]; \
 181   } else { \
 182     nb = HUFF_LOOKAHEAD+1; \
 183 slowlabel: \
 184     if ((result=jpeg_huff_decode(&amp;state,get_buffer,bits_left,htbl,nb)) &lt; 0) \
 185     { failaction; } \
 186     get_buffer = state.get_buffer; bits_left = state.bits_left; \
 187   } \
 188 }
 189 
 190 
 191 /*
 192  * Expanded entropy decoder object for Huffman decoding.
 193  *
 194  * The savable_state subrecord contains fields that change within an MCU,
 195  * but must not be updated permanently until we complete the MCU.
 196  */
 197 
 198 typedef struct {
 199   unsigned int EOBRUN;            /* remaining EOBs in EOBRUN */
 200   int last_dc_val[MAX_COMPS_IN_SCAN];    /* last DC coef for each component */
 201 } savable_state;
 202 
 203 /* This macro is to work around compilers with missing or broken
 204  * structure assignment.  You&#39;ll need to fix this code if you have
 205  * such a compiler and you change MAX_COMPS_IN_SCAN.
 206  */
 207 
 208 #ifndef NO_STRUCT_ASSIGN
 209 #define ASSIGN_STATE(dest,src)  ((dest) = (src))
 210 #else
 211 #if MAX_COMPS_IN_SCAN == 4
 212 #define ASSIGN_STATE(dest,src)  \
 213     ((dest).EOBRUN = (src).EOBRUN, \
 214      (dest).last_dc_val[0] = (src).last_dc_val[0], \
 215      (dest).last_dc_val[1] = (src).last_dc_val[1], \
 216      (dest).last_dc_val[2] = (src).last_dc_val[2], \
 217      (dest).last_dc_val[3] = (src).last_dc_val[3])
 218 #endif
 219 #endif
 220 
 221 
 222 typedef struct {
 223   struct jpeg_entropy_decoder pub; /* public fields */
 224 
 225   /* These fields are loaded into local variables at start of each MCU.
 226    * In case of suspension, we exit WITHOUT updating them.
 227    */
 228   bitread_perm_state bitstate;    /* Bit buffer at start of MCU */
 229   savable_state saved;        /* Other state at start of MCU */
 230 
 231   /* These fields are NOT loaded into local working state. */
 232   boolean insufficient_data;    /* set TRUE after emitting warning */
 233   unsigned int restarts_to_go;    /* MCUs left in this restart interval */
 234 
 235   /* Following two fields used only in progressive mode */
 236 
 237   /* Pointers to derived tables (these workspaces have image lifespan) */
 238   d_derived_tbl * derived_tbls[NUM_HUFF_TBLS];
 239 
 240   d_derived_tbl * ac_derived_tbl; /* active table during an AC scan */
 241 
 242   /* Following fields used only in sequential mode */
 243 
 244   /* Pointers to derived tables (these workspaces have image lifespan) */
 245   d_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
 246   d_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
 247 
 248   /* Precalculated info set up by start_pass for use in decode_mcu: */
 249 
 250   /* Pointers to derived tables to be used for each block within an MCU */
 251   d_derived_tbl * dc_cur_tbls[D_MAX_BLOCKS_IN_MCU];
 252   d_derived_tbl * ac_cur_tbls[D_MAX_BLOCKS_IN_MCU];
 253   /* Whether we care about the DC and AC coefficient values for each block */
 254   int coef_limit[D_MAX_BLOCKS_IN_MCU];
 255 } huff_entropy_decoder;
 256 
 257 typedef huff_entropy_decoder * huff_entropy_ptr;
 258 
 259 
 260 static const int jpeg_zigzag_order[8][8] = {
 261   {  0,  1,  5,  6, 14, 15, 27, 28 },
 262   {  2,  4,  7, 13, 16, 26, 29, 42 },
 263   {  3,  8, 12, 17, 25, 30, 41, 43 },
 264   {  9, 11, 18, 24, 31, 40, 44, 53 },
 265   { 10, 19, 23, 32, 39, 45, 52, 54 },
 266   { 20, 22, 33, 38, 46, 51, 55, 60 },
 267   { 21, 34, 37, 47, 50, 56, 59, 61 },
 268   { 35, 36, 48, 49, 57, 58, 62, 63 }
 269 };
 270 
 271 static const int jpeg_zigzag_order7[7][7] = {
 272   {  0,  1,  5,  6, 14, 15, 27 },
 273   {  2,  4,  7, 13, 16, 26, 28 },
 274   {  3,  8, 12, 17, 25, 29, 38 },
 275   {  9, 11, 18, 24, 30, 37, 39 },
 276   { 10, 19, 23, 31, 36, 40, 45 },
 277   { 20, 22, 32, 35, 41, 44, 46 },
 278   { 21, 33, 34, 42, 43, 47, 48 }
 279 };
 280 
 281 static const int jpeg_zigzag_order6[6][6] = {
 282   {  0,  1,  5,  6, 14, 15 },
 283   {  2,  4,  7, 13, 16, 25 },
 284   {  3,  8, 12, 17, 24, 26 },
 285   {  9, 11, 18, 23, 27, 32 },
 286   { 10, 19, 22, 28, 31, 33 },
 287   { 20, 21, 29, 30, 34, 35 }
 288 };
 289 
 290 static const int jpeg_zigzag_order5[5][5] = {
 291   {  0,  1,  5,  6, 14 },
 292   {  2,  4,  7, 13, 15 },
 293   {  3,  8, 12, 16, 21 },
 294   {  9, 11, 17, 20, 22 },
 295   { 10, 18, 19, 23, 24 }
 296 };
 297 
 298 static const int jpeg_zigzag_order4[4][4] = {
 299   { 0,  1,  5,  6 },
 300   { 2,  4,  7, 12 },
 301   { 3,  8, 11, 13 },
 302   { 9, 10, 14, 15 }
 303 };
 304 
 305 static const int jpeg_zigzag_order3[3][3] = {
 306   { 0, 1, 5 },
 307   { 2, 4, 6 },
 308   { 3, 7, 8 }
 309 };
 310 
 311 static const int jpeg_zigzag_order2[2][2] = {
 312   { 0, 1 },
 313   { 2, 3 }
 314 };
 315 
 316 
 317 /*
 318  * Compute the derived values for a Huffman table.
 319  * This routine also performs some validation checks on the table.
 320  */
 321 
 322 LOCAL(void)
 323 jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
 324              d_derived_tbl ** pdtbl)
 325 {
 326   JHUFF_TBL *htbl;
 327   d_derived_tbl *dtbl;
 328   int p, i, l, si, numsymbols;
 329   int lookbits, ctr;
 330   char huffsize[257];
 331   unsigned int huffcode[257];
 332   unsigned int code;
 333 
 334   MEMZERO(huffsize, SIZEOF(huffsize));
 335   MEMZERO(huffcode, SIZEOF(huffcode));
 336   /* Note that huffsize[] and huffcode[] are filled in code-length order,
 337    * paralleling the order of the symbols themselves in htbl-&gt;huffval[].
 338    */
 339 
 340   /* Find the input Huffman table */
 341   if (tblno &lt; 0 || tblno &gt;= NUM_HUFF_TBLS)
 342     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 343   htbl =
 344     isDC ? cinfo-&gt;dc_huff_tbl_ptrs[tblno] : cinfo-&gt;ac_huff_tbl_ptrs[tblno];
 345   if (htbl == NULL)
<a name="2" id="anc2"></a><span class="line-modified"> 346     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);</span>
 347 
 348   /* Allocate a workspace if we haven&#39;t already done so. */
 349   if (*pdtbl == NULL)
<a name="3" id="anc3"></a><span class="line-modified"> 350     *pdtbl = (d_derived_tbl *)</span>
<span class="line-modified"> 351       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed"> 352                   SIZEOF(d_derived_tbl));</span>
 353   dtbl = *pdtbl;
 354   dtbl-&gt;pub = htbl;        /* fill in back link */
 355 
 356   /* Figure C.1: make table of Huffman code length for each symbol */
 357 
 358   p = 0;
 359   for (l = 1; l &lt;= 16; l++) {
 360     i = (int) htbl-&gt;bits[l];
 361     if (i &lt; 0 || p + i &gt; 256)    /* protect against table overrun */
 362       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 363     while (i--)
 364       huffsize[p++] = (char) l;
 365   }
 366   huffsize[p] = 0;
 367   numsymbols = p;
 368 
 369   /* Figure C.2: generate the codes themselves */
 370   /* We also validate that the counts represent a legal Huffman code tree. */
 371 
 372   code = 0;
 373   si = huffsize[0];
 374   p = 0;
 375   while (huffsize[p]) {
 376     while (((int) huffsize[p]) == si) {
 377       huffcode[p++] = code;
 378       code++;
 379     }
 380     /* code is now 1 more than the last code used for codelength si; but
 381      * it must still fit in si bits, since no code is allowed to be all ones.
 382      */
 383     if (((INT32) code) &gt;= (((INT32) 1) &lt;&lt; si))
 384       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 385     code &lt;&lt;= 1;
 386     si++;
 387   }
 388 
 389   /* Figure F.15: generate decoding tables for bit-sequential decoding */
 390 
 391   p = 0;
 392   for (l = 1; l &lt;= 16; l++) {
 393     if (htbl-&gt;bits[l]) {
 394       /* valoffset[l] = huffval[] index of 1st symbol of code length l,
 395        * minus the minimum code of length l
 396        */
 397       dtbl-&gt;valoffset[l] = (INT32) p - (INT32) huffcode[p];
 398       p += htbl-&gt;bits[l];
 399       dtbl-&gt;maxcode[l] = huffcode[p-1]; /* maximum code of length l */
 400     } else {
 401       dtbl-&gt;maxcode[l] = -1;    /* -1 if no codes of this length */
 402     }
 403   }
 404   dtbl-&gt;maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
 405 
 406   /* Compute lookahead tables to speed up decoding.
 407    * First we set all the table entries to 0, indicating &quot;too long&quot;;
 408    * then we iterate through the Huffman codes that are short enough and
 409    * fill in all the entries that correspond to bit sequences starting
 410    * with that code.
 411    */
 412 
 413   MEMZERO(dtbl-&gt;look_nbits, SIZEOF(dtbl-&gt;look_nbits));
 414 
 415   p = 0;
 416   for (l = 1; l &lt;= HUFF_LOOKAHEAD; l++) {
 417     for (i = 1; i &lt;= (int) htbl-&gt;bits[l]; i++, p++) {
 418       /* l = current code&#39;s length, p = its index in huffcode[] &amp; huffval[]. */
 419       /* Generate left-justified code followed by all possible bit sequences */
 420       lookbits = huffcode[p] &lt;&lt; (HUFF_LOOKAHEAD-l);
 421       for (ctr = 1 &lt;&lt; (HUFF_LOOKAHEAD-l); ctr &gt; 0; ctr--) {
 422     dtbl-&gt;look_nbits[lookbits] = l;
 423     dtbl-&gt;look_sym[lookbits] = htbl-&gt;huffval[p];
 424     lookbits++;
 425       }
 426     }
 427   }
 428 
 429   /* Validate symbols as being reasonable.
 430    * For AC tables, we make no check, but accept all byte values 0..255.
 431    * For DC tables, we require the symbols to be in range 0..15.
 432    * (Tighter bounds could be applied depending on the data depth and mode,
 433    * but this is sufficient to ensure safe decoding.)
 434    */
 435   if (isDC) {
 436     for (i = 0; i &lt; numsymbols; i++) {
 437       int sym = htbl-&gt;huffval[i];
 438       if (sym &lt; 0 || sym &gt; 15)
 439     ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 440     }
 441   }
 442 }
 443 
 444 
 445 /*
 446  * Out-of-line code for bit fetching.
 447  * Note: current values of get_buffer and bits_left are passed as parameters,
 448  * but are returned in the corresponding fields of the state struct.
 449  *
 450  * On most machines MIN_GET_BITS should be 25 to allow the full 32-bit width
 451  * of get_buffer to be used.  (On machines with wider words, an even larger
 452  * buffer could be used.)  However, on some machines 32-bit shifts are
 453  * quite slow and take time proportional to the number of places shifted.
 454  * (This is true with most PC compilers, for instance.)  In this case it may
 455  * be a win to set MIN_GET_BITS to the minimum value of 15.  This reduces the
 456  * average shift distance at the cost of more calls to jpeg_fill_bit_buffer.
 457  */
 458 
 459 #ifdef SLOW_SHIFT_32
 460 #define MIN_GET_BITS  15    /* minimum allowable value */
 461 #else
 462 #define MIN_GET_BITS  (BIT_BUF_SIZE-7)
 463 #endif
 464 
 465 
 466 LOCAL(boolean)
 467 jpeg_fill_bit_buffer (bitread_working_state * state,
 468               register bit_buf_type get_buffer, register int bits_left,
 469               int nbits)
 470 /* Load up the bit buffer to a depth of at least nbits */
 471 {
 472   /* Copy heavily used state fields into locals (hopefully registers) */
 473   register const JOCTET * next_input_byte = state-&gt;next_input_byte;
 474   register size_t bytes_in_buffer = state-&gt;bytes_in_buffer;
 475   j_decompress_ptr cinfo = state-&gt;cinfo;
 476 
 477   /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
 478   /* (It is assumed that no request will be for more than that many bits.) */
 479   /* We fail to do so only if we hit a marker or are forced to suspend. */
 480 
 481   if (cinfo-&gt;unread_marker == 0) {    /* cannot advance past a marker */
 482     while (bits_left &lt; MIN_GET_BITS) {
 483       register int c;
 484 
 485       /* Attempt to read a byte */
 486       if (bytes_in_buffer == 0) {
 487     if (! (*cinfo-&gt;src-&gt;fill_input_buffer) (cinfo))
 488       return FALSE;
 489     next_input_byte = cinfo-&gt;src-&gt;next_input_byte;
 490     bytes_in_buffer = cinfo-&gt;src-&gt;bytes_in_buffer;
 491       }
 492       bytes_in_buffer--;
 493       c = GETJOCTET(*next_input_byte++);
 494 
 495       /* If it&#39;s 0xFF, check and discard stuffed zero byte */
 496       if (c == 0xFF) {
 497     /* Loop here to discard any padding FF&#39;s on terminating marker,
 498      * so that we can save a valid unread_marker value.  NOTE: we will
 499      * accept multiple FF&#39;s followed by a 0 as meaning a single FF data
 500      * byte.  This data pattern is not valid according to the standard.
 501      */
 502     do {
 503       if (bytes_in_buffer == 0) {
 504         if (! (*cinfo-&gt;src-&gt;fill_input_buffer) (cinfo))
 505           return FALSE;
 506         next_input_byte = cinfo-&gt;src-&gt;next_input_byte;
 507         bytes_in_buffer = cinfo-&gt;src-&gt;bytes_in_buffer;
 508       }
 509       bytes_in_buffer--;
 510       c = GETJOCTET(*next_input_byte++);
 511     } while (c == 0xFF);
 512 
 513     if (c == 0) {
 514       /* Found FF/00, which represents an FF data byte */
 515       c = 0xFF;
 516     } else {
 517       /* Oops, it&#39;s actually a marker indicating end of compressed data.
 518        * Save the marker code for later use.
 519        * Fine point: it might appear that we should save the marker into
 520        * bitread working state, not straight into permanent state.  But
 521        * once we have hit a marker, we cannot need to suspend within the
 522        * current MCU, because we will read no more bytes from the data
 523        * source.  So it is OK to update permanent state right away.
 524        */
 525       cinfo-&gt;unread_marker = c;
 526       /* See if we need to insert some fake zero bits. */
 527       goto no_more_bytes;
 528     }
 529       }
 530 
 531       /* OK, load c into get_buffer */
 532       get_buffer = (get_buffer &lt;&lt; 8) | c;
 533       bits_left += 8;
 534     } /* end while */
 535   } else {
 536   no_more_bytes:
 537     /* We get here if we&#39;ve read the marker that terminates the compressed
 538      * data segment.  There should be enough bits in the buffer register
 539      * to satisfy the request; if so, no problem.
 540      */
 541     if (nbits &gt; bits_left) {
 542       /* Uh-oh.  Report corrupted data to user and stuff zeroes into
 543        * the data stream, so that we can produce some kind of image.
 544        * We use a nonvolatile flag to ensure that only one warning message
 545        * appears per data segment.
 546        */
 547       if (! ((huff_entropy_ptr) cinfo-&gt;entropy)-&gt;insufficient_data) {
 548     WARNMS(cinfo, JWRN_HIT_MARKER);
 549     ((huff_entropy_ptr) cinfo-&gt;entropy)-&gt;insufficient_data = TRUE;
 550       }
 551       /* Fill the buffer with zero bits */
 552       get_buffer &lt;&lt;= MIN_GET_BITS - bits_left;
 553       bits_left = MIN_GET_BITS;
 554     }
 555   }
 556 
 557   /* Unload the local registers */
 558   state-&gt;next_input_byte = next_input_byte;
 559   state-&gt;bytes_in_buffer = bytes_in_buffer;
 560   state-&gt;get_buffer = get_buffer;
 561   state-&gt;bits_left = bits_left;
 562 
 563   return TRUE;
 564 }
 565 
 566 
 567 /*
 568  * Figure F.12: extend sign bit.
 569  * On some machines, a shift and sub will be faster than a table lookup.
 570  */
 571 
 572 #ifdef AVOID_TABLES
 573 
 574 #define BIT_MASK(nbits)   ((1&lt;&lt;(nbits))-1)
 575 #define HUFF_EXTEND(x,s)  ((x) &lt; (1&lt;&lt;((s)-1)) ? (x) - ((1&lt;&lt;(s))-1) : (x))
 576 
 577 #else
 578 
 579 #define BIT_MASK(nbits)   bmask[nbits]
 580 #define HUFF_EXTEND(x,s)  ((x) &lt;= bmask[(s) - 1] ? (x) - bmask[s] : (x))
 581 
 582 static const int bmask[16] =    /* bmask[n] is mask for n rightmost bits */
 583   { 0, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF,
 584     0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF };
 585 
 586 #endif /* AVOID_TABLES */
 587 
 588 
 589 /*
 590  * Out-of-line code for Huffman code decoding.
 591  */
 592 
 593 LOCAL(int)
 594 jpeg_huff_decode (bitread_working_state * state,
 595           register bit_buf_type get_buffer, register int bits_left,
 596           d_derived_tbl * htbl, int min_bits)
 597 {
 598   register int l = min_bits;
 599   register INT32 code;
 600 
 601   /* HUFF_DECODE has determined that the code is at least min_bits */
 602   /* bits long, so fetch that many bits in one swoop. */
 603 
 604   CHECK_BIT_BUFFER(*state, l, return -1);
 605   code = GET_BITS(l);
 606 
 607   /* Collect the rest of the Huffman code one bit at a time. */
 608   /* This is per Figure F.16 in the JPEG spec. */
 609 
 610   while (code &gt; htbl-&gt;maxcode[l]) {
 611     code &lt;&lt;= 1;
 612     CHECK_BIT_BUFFER(*state, 1, return -1);
 613     code |= GET_BITS(1);
 614     l++;
 615   }
 616 
 617   /* Unload the local registers */
 618   state-&gt;get_buffer = get_buffer;
 619   state-&gt;bits_left = bits_left;
 620 
 621   /* With garbage input we may reach the sentinel value l = 17. */
 622 
 623   if (l &gt; 16) {
 624     int br_offset = state-&gt;next_input_byte - state-&gt;cinfo-&gt;src-&gt;next_input_byte;
 625     WARNMS(state-&gt;cinfo, JWRN_HUFF_BAD_CODE);
 626     state-&gt;next_input_byte = state-&gt;cinfo-&gt;src-&gt;next_input_byte + br_offset;
 627     return 0;            /* fake a zero as the safest result */
 628   }
 629 
 630   return htbl-&gt;pub-&gt;huffval[ (int) (code + htbl-&gt;valoffset[l]) ];
 631 }
 632 
 633 
 634 /*
 635  * Finish up at the end of a Huffman-compressed scan.
 636  */
 637 
 638 METHODDEF(void)
 639 finish_pass_huff (j_decompress_ptr cinfo)
 640 {
 641   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 642 
 643   /* Throw away any unused bits remaining in bit buffer; */
 644   /* include any full bytes in next_marker&#39;s count of discarded bytes */
 645   cinfo-&gt;marker-&gt;discarded_bytes += entropy-&gt;bitstate.bits_left / 8;
 646   entropy-&gt;bitstate.bits_left = 0;
 647 }
 648 
 649 
 650 /*
 651  * Check for a restart marker &amp; resynchronize decoder.
 652  * Returns FALSE if must suspend.
 653  */
 654 
 655 LOCAL(boolean)
 656 process_restart (j_decompress_ptr cinfo)
 657 {
 658   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 659   int ci;
 660 
 661   finish_pass_huff(cinfo);
 662 
 663   /* Advance past the RSTn marker */
 664   if (! (*cinfo-&gt;marker-&gt;read_restart_marker) (cinfo))
 665     return FALSE;
 666 
 667   /* Re-initialize DC predictions to 0 */
 668   for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++)
 669     entropy-&gt;saved.last_dc_val[ci] = 0;
 670   /* Re-init EOB run count, too */
 671   entropy-&gt;saved.EOBRUN = 0;
 672 
 673   /* Reset restart counter */
 674   entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 675 
 676   /* Reset out-of-data flag, unless read_restart_marker left us smack up
 677    * against a marker.  In that case we will end up treating the next data
 678    * segment as empty, and we can avoid producing bogus output pixels by
 679    * leaving the flag set.
 680    */
 681   if (cinfo-&gt;unread_marker == 0)
 682     entropy-&gt;insufficient_data = FALSE;
 683 
 684   return TRUE;
 685 }
 686 
 687 
 688 /*
 689  * Huffman MCU decoding.
 690  * Each of these routines decodes and returns one MCU&#39;s worth of
 691  * Huffman-compressed coefficients.
 692  * The coefficients are reordered from zigzag order into natural array order,
 693  * but are not dequantized.
 694  *
 695  * The i&#39;th block of the MCU is stored into the block pointed to by
 696  * MCU_data[i].  WE ASSUME THIS AREA IS INITIALLY ZEROED BY THE CALLER.
 697  * (Wholesale zeroing is usually a little faster than retail...)
 698  *
 699  * We return FALSE if data source requested suspension.  In that case no
 700  * changes have been made to permanent state.  (Exception: some output
 701  * coefficients may already have been assigned.  This is harmless for
 702  * spectral selection, since we&#39;ll just re-assign them on the next call.
 703  * Successive approximation AC refinement has to be more careful, however.)
 704  */
 705 
 706 /*
 707  * MCU decoding for DC initial scan (either spectral selection,
 708  * or first pass of successive approximation).
 709  */
 710 
 711 METHODDEF(boolean)
 712 decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 713 {
 714   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 715   int Al = cinfo-&gt;Al;
 716   register int s, r;
 717   int blkn, ci;
 718   JBLOCKROW block;
 719   BITREAD_STATE_VARS;
 720   savable_state state;
 721   d_derived_tbl * tbl;
 722   jpeg_component_info * compptr;
 723 
 724   /* Process restart marker if needed; may have to suspend */
 725   if (cinfo-&gt;restart_interval) {
 726     if (entropy-&gt;restarts_to_go == 0)
 727       if (! process_restart(cinfo))
 728     return FALSE;
 729   }
 730 
 731   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
 732    * This way, we return uniform gray for the remainder of the segment.
 733    */
 734   if (! entropy-&gt;insufficient_data) {
 735 
 736     /* Load up working state */
<a name="4" id="anc4"></a><span class="line-modified"> 737     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 738     ASSIGN_STATE(state, entropy-&gt;saved);
 739 
 740     /* Outer loop handles each block in the MCU */
 741 
 742     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 743       block = MCU_data[blkn];
 744       ci = cinfo-&gt;MCU_membership[blkn];
 745       compptr = cinfo-&gt;cur_comp_info[ci];
 746       tbl = entropy-&gt;derived_tbls[compptr-&gt;dc_tbl_no];
 747 
 748       /* Decode a single block&#39;s worth of coefficients */
 749 
 750       /* Section F.2.2.1: decode the DC coefficient difference */
 751       HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
 752       if (s) {
 753     CHECK_BIT_BUFFER(br_state, s, return FALSE);
 754     r = GET_BITS(s);
 755     s = HUFF_EXTEND(r, s);
 756       }
 757 
 758       /* Convert DC difference to actual value, update last_dc_val */
 759       s += state.last_dc_val[ci];
 760       state.last_dc_val[ci] = s;
 761       /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
 762       (*block)[0] = (JCOEF) (s &lt;&lt; Al);
 763     }
 764 
 765     /* Completed MCU, so update state */
<a name="5" id="anc5"></a><span class="line-modified"> 766     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
 767     ASSIGN_STATE(entropy-&gt;saved, state);
 768   }
 769 
<a name="6" id="anc6"></a><span class="line-modified"> 770   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified"> 771   entropy-&gt;restarts_to_go--;</span>

 772 
 773   return TRUE;
 774 }
 775 
 776 
 777 /*
 778  * MCU decoding for AC initial scan (either spectral selection,
 779  * or first pass of successive approximation).
 780  */
 781 
 782 METHODDEF(boolean)
 783 decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 784 {
 785   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 786   register int s, k, r;
 787   unsigned int EOBRUN;
 788   int Se, Al;
 789   const int * natural_order;
 790   JBLOCKROW block;
 791   BITREAD_STATE_VARS;
 792   d_derived_tbl * tbl;
 793 
 794   /* Process restart marker if needed; may have to suspend */
 795   if (cinfo-&gt;restart_interval) {
 796     if (entropy-&gt;restarts_to_go == 0)
 797       if (! process_restart(cinfo))
 798     return FALSE;
 799   }
 800 
 801   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
 802    * This way, we return uniform gray for the remainder of the segment.
 803    */
 804   if (! entropy-&gt;insufficient_data) {
 805 
 806     /* Load up working state.
 807      * We can avoid loading/saving bitread state if in an EOB run.
 808      */
 809     EOBRUN = entropy-&gt;saved.EOBRUN;    /* only part of saved state we need */
 810 
 811     /* There is always only one block per MCU */
 812 
 813     if (EOBRUN)            /* if it&#39;s a band of zeroes... */
 814       EOBRUN--;            /* ...process it now (we do nothing) */
 815     else {
<a name="7" id="anc7"></a><span class="line-modified"> 816       BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 817       Se = cinfo-&gt;Se;
 818       Al = cinfo-&gt;Al;
 819       natural_order = cinfo-&gt;natural_order;
 820       block = MCU_data[0];
 821       tbl = entropy-&gt;ac_derived_tbl;
 822 
 823       for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 824     HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
 825     r = s &gt;&gt; 4;
 826     s &amp;= 15;
 827     if (s) {
 828       k += r;
 829       CHECK_BIT_BUFFER(br_state, s, return FALSE);
 830       r = GET_BITS(s);
 831       s = HUFF_EXTEND(r, s);
 832       /* Scale and output coefficient in natural (dezigzagged) order */
 833       (*block)[natural_order[k]] = (JCOEF) (s &lt;&lt; Al);
 834     } else {
 835       if (r != 15) {    /* EOBr, run length is 2^r + appended bits */
 836         if (r) {        /* EOBr, r &gt; 0 */
 837           EOBRUN = 1 &lt;&lt; r;
 838           CHECK_BIT_BUFFER(br_state, r, return FALSE);
 839           r = GET_BITS(r);
 840           EOBRUN += r;
 841           EOBRUN--;        /* this band is processed at this moment */
 842         }
 843         break;        /* force end-of-band */
 844       }
 845       k += 15;        /* ZRL: skip 15 zeroes in band */
 846     }
 847       }
 848 
<a name="8" id="anc8"></a><span class="line-modified"> 849       BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
 850     }
 851 
 852     /* Completed MCU, so update state */
 853     entropy-&gt;saved.EOBRUN = EOBRUN;    /* only part of saved state we need */
 854   }
 855 
<a name="9" id="anc9"></a><span class="line-modified"> 856   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified"> 857   entropy-&gt;restarts_to_go--;</span>

 858 
 859   return TRUE;
 860 }
 861 
 862 
 863 /*
 864  * MCU decoding for DC successive approximation refinement scan.
 865  * Note: we assume such scans can be multi-component,
 866  * although the spec is not very clear on the point.
 867  */
 868 
 869 METHODDEF(boolean)
 870 decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 871 {
 872   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
<a name="10" id="anc10"></a><span class="line-modified"> 873   int p1, blkn;</span>

 874   BITREAD_STATE_VARS;
 875 
 876   /* Process restart marker if needed; may have to suspend */
 877   if (cinfo-&gt;restart_interval) {
 878     if (entropy-&gt;restarts_to_go == 0)
 879       if (! process_restart(cinfo))
 880     return FALSE;
 881   }
 882 
 883   /* Not worth the cycles to check insufficient_data here,
 884    * since we will not change the data anyway if we read zeroes.
 885    */
 886 
 887   /* Load up working state */
<a name="11" id="anc11"></a><span class="line-modified"> 888   BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 889 
 890   p1 = 1 &lt;&lt; cinfo-&gt;Al;        /* 1 in the bit position being coded */
 891 
 892   /* Outer loop handles each block in the MCU */
 893 
 894   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 895     /* Encoded data is simply the next bit of the two&#39;s-complement DC value */
 896     CHECK_BIT_BUFFER(br_state, 1, return FALSE);
 897     if (GET_BITS(1))
 898       MCU_data[blkn][0][0] |= p1;
 899     /* Note: since we use |=, repeating the assignment later is safe */
 900   }
 901 
 902   /* Completed MCU, so update state */
<a name="12" id="anc12"></a><span class="line-modified"> 903   BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
 904 
<a name="13" id="anc13"></a><span class="line-modified"> 905   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified"> 906   entropy-&gt;restarts_to_go--;</span>

 907 
 908   return TRUE;
 909 }
 910 
 911 
 912 /*
 913  * MCU decoding for AC successive approximation refinement scan.
 914  */
 915 
 916 METHODDEF(boolean)
 917 decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 918 {
 919   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 920   register int s, k, r;
 921   unsigned int EOBRUN;
<a name="14" id="anc14"></a><span class="line-modified"> 922   int Se, p1, m1;</span>

 923   const int * natural_order;
 924   JBLOCKROW block;
 925   JCOEFPTR thiscoef;
 926   BITREAD_STATE_VARS;
 927   d_derived_tbl * tbl;
 928   int num_newnz;
 929   int newnz_pos[DCTSIZE2];
 930 
 931   /* Process restart marker if needed; may have to suspend */
 932   if (cinfo-&gt;restart_interval) {
 933     if (entropy-&gt;restarts_to_go == 0)
 934       if (! process_restart(cinfo))
 935     return FALSE;
 936   }
 937 
 938   /* If we&#39;ve run out of data, don&#39;t modify the MCU.
 939    */
 940   if (! entropy-&gt;insufficient_data) {
 941 
 942     Se = cinfo-&gt;Se;
 943     p1 = 1 &lt;&lt; cinfo-&gt;Al;    /* 1 in the bit position being coded */
<a name="15" id="anc15"></a><span class="line-modified"> 944     m1 = (-1) &lt;&lt; cinfo-&gt;Al;    /* -1 in the bit position being coded */</span>
 945     natural_order = cinfo-&gt;natural_order;
 946 
 947     /* Load up working state */
<a name="16" id="anc16"></a><span class="line-modified"> 948     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
 949     EOBRUN = entropy-&gt;saved.EOBRUN; /* only part of saved state we need */
 950 
 951     /* There is always only one block per MCU */
 952     block = MCU_data[0];
 953     tbl = entropy-&gt;ac_derived_tbl;
 954 
 955     /* If we are forced to suspend, we must undo the assignments to any newly
 956      * nonzero coefficients in the block, because otherwise we&#39;d get confused
 957      * next time about which coefficients were already nonzero.
 958      * But we need not undo addition of bits to already-nonzero coefficients;
 959      * instead, we can test the current bit to see if we already did it.
 960      */
 961     num_newnz = 0;
 962 
 963     /* initialize coefficient loop counter to start of band */
 964     k = cinfo-&gt;Ss;
 965 
 966     if (EOBRUN == 0) {
 967       do {
 968     HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
 969     r = s &gt;&gt; 4;
 970     s &amp;= 15;
 971     if (s) {
 972       if (s != 1)        /* size of new coef should always be 1 */
 973         WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
 974       CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 975       if (GET_BITS(1))
 976         s = p1;        /* newly nonzero coef is positive */
 977       else
 978         s = m1;        /* newly nonzero coef is negative */
 979     } else {
 980       if (r != 15) {
 981         EOBRUN = 1 &lt;&lt; r;    /* EOBr, run length is 2^r + appended bits */
 982         if (r) {
 983           CHECK_BIT_BUFFER(br_state, r, goto undoit);
 984           r = GET_BITS(r);
 985           EOBRUN += r;
 986         }
 987         break;        /* rest of block is handled by EOB logic */
 988       }
 989       /* note s = 0 for processing ZRL */
 990     }
 991     /* Advance over already-nonzero coefs and r still-zero coefs,
 992      * appending correction bits to the nonzeroes.  A correction bit is 1
 993      * if the absolute value of the coefficient must be increased.
 994      */
 995     do {
 996       thiscoef = *block + natural_order[k];
 997       if (*thiscoef) {
 998         CHECK_BIT_BUFFER(br_state, 1, goto undoit);
 999         if (GET_BITS(1)) {
1000           if ((*thiscoef &amp; p1) == 0) { /* do nothing if already set it */
1001         if (*thiscoef &gt;= 0)
1002           *thiscoef += p1;
1003         else
1004           *thiscoef += m1;
1005           }
1006         }
1007       } else {
1008         if (--r &lt; 0)
1009           break;        /* reached target zero coefficient */
1010       }
1011       k++;
1012     } while (k &lt;= Se);
1013     if (s) {
1014       int pos = natural_order[k];
1015       /* Output newly nonzero coefficient */
1016       (*block)[pos] = (JCOEF) s;
1017       /* Remember its position in case we have to suspend */
1018       newnz_pos[num_newnz++] = pos;
1019     }
1020     k++;
1021       } while (k &lt;= Se);
1022     }
1023 
1024     if (EOBRUN) {
1025       /* Scan any remaining coefficient positions after the end-of-band
1026        * (the last newly nonzero coefficient, if any).  Append a correction
1027        * bit to each already-nonzero coefficient.  A correction bit is 1
1028        * if the absolute value of the coefficient must be increased.
1029        */
1030       do {
1031     thiscoef = *block + natural_order[k];
1032     if (*thiscoef) {
1033       CHECK_BIT_BUFFER(br_state, 1, goto undoit);
1034       if (GET_BITS(1)) {
1035         if ((*thiscoef &amp; p1) == 0) { /* do nothing if already changed it */
1036           if (*thiscoef &gt;= 0)
1037         *thiscoef += p1;
1038           else
1039         *thiscoef += m1;
1040         }
1041       }
1042     }
1043     k++;
1044       } while (k &lt;= Se);
1045       /* Count one block completed in EOB run */
1046       EOBRUN--;
1047     }
1048 
1049     /* Completed MCU, so update state */
<a name="17" id="anc17"></a><span class="line-modified">1050     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
1051     entropy-&gt;saved.EOBRUN = EOBRUN; /* only part of saved state we need */
1052   }
1053 
<a name="18" id="anc18"></a><span class="line-modified">1054   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified">1055   entropy-&gt;restarts_to_go--;</span>

1056 
1057   return TRUE;
1058 
1059 undoit:
1060   /* Re-zero any output coefficients that we made newly nonzero */
1061   while (num_newnz)
1062     (*block)[newnz_pos[--num_newnz]] = 0;
1063 
1064   return FALSE;
1065 }
1066 
1067 
1068 /*
1069  * Decode one MCU&#39;s worth of Huffman-compressed coefficients,
1070  * partial blocks.
1071  */
1072 
1073 METHODDEF(boolean)
1074 decode_mcu_sub (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
1075 {
1076   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1077   const int * natural_order;
1078   int Se, blkn;
1079   BITREAD_STATE_VARS;
1080   savable_state state;
1081 
1082   /* Process restart marker if needed; may have to suspend */
1083   if (cinfo-&gt;restart_interval) {
1084     if (entropy-&gt;restarts_to_go == 0)
1085       if (! process_restart(cinfo))
1086     return FALSE;
1087   }
1088 
1089   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
1090    * This way, we return uniform gray for the remainder of the segment.
1091    */
1092   if (! entropy-&gt;insufficient_data) {
1093 
1094     natural_order = cinfo-&gt;natural_order;
1095     Se = cinfo-&gt;lim_Se;
1096 
1097     /* Load up working state */
<a name="19" id="anc19"></a><span class="line-modified">1098     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
1099     ASSIGN_STATE(state, entropy-&gt;saved);
1100 
1101     /* Outer loop handles each block in the MCU */
1102 
1103     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1104       JBLOCKROW block = MCU_data[blkn];
1105       d_derived_tbl * htbl;
1106       register int s, k, r;
1107       int coef_limit, ci;
1108 
1109       /* Decode a single block&#39;s worth of coefficients */
1110 
1111       /* Section F.2.2.1: decode the DC coefficient difference */
1112       htbl = entropy-&gt;dc_cur_tbls[blkn];
1113       HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
1114 
1115       htbl = entropy-&gt;ac_cur_tbls[blkn];
1116       k = 1;
1117       coef_limit = entropy-&gt;coef_limit[blkn];
1118       if (coef_limit) {
1119     /* Convert DC difference to actual value, update last_dc_val */
1120     if (s) {
1121       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1122       r = GET_BITS(s);
1123       s = HUFF_EXTEND(r, s);
1124     }
1125     ci = cinfo-&gt;MCU_membership[blkn];
1126     s += state.last_dc_val[ci];
1127     state.last_dc_val[ci] = s;
1128     /* Output the DC coefficient */
1129     (*block)[0] = (JCOEF) s;
1130 
1131     /* Section F.2.2.2: decode the AC coefficients */
1132     /* Since zeroes are skipped, output area must be cleared beforehand */
1133     for (; k &lt; coef_limit; k++) {
1134       HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
1135 
1136       r = s &gt;&gt; 4;
1137       s &amp;= 15;
1138 
1139       if (s) {
1140         k += r;
1141         CHECK_BIT_BUFFER(br_state, s, return FALSE);
1142         r = GET_BITS(s);
1143         s = HUFF_EXTEND(r, s);
1144         /* Output coefficient in natural (dezigzagged) order.
1145          * Note: the extra entries in natural_order[] will save us
1146          * if k &gt; Se, which could happen if the data is corrupted.
1147          */
1148         (*block)[natural_order[k]] = (JCOEF) s;
1149       } else {
1150         if (r != 15)
1151           goto EndOfBlock;
1152         k += 15;
1153       }
1154     }
1155       } else {
1156     if (s) {
1157       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1158       DROP_BITS(s);
1159     }
1160       }
1161 
1162       /* Section F.2.2.2: decode the AC coefficients */
1163       /* In this path we just discard the values */
1164       for (; k &lt;= Se; k++) {
1165     HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
1166 
1167     r = s &gt;&gt; 4;
1168     s &amp;= 15;
1169 
1170     if (s) {
1171       k += r;
1172       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1173       DROP_BITS(s);
1174     } else {
1175       if (r != 15)
1176         break;
1177       k += 15;
1178     }
1179       }
1180 
1181       EndOfBlock: ;
1182     }
1183 
1184     /* Completed MCU, so update state */
<a name="20" id="anc20"></a><span class="line-modified">1185     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
1186     ASSIGN_STATE(entropy-&gt;saved, state);
1187   }
1188 
<a name="21" id="anc21"></a><span class="line-modified">1189   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified">1190   entropy-&gt;restarts_to_go--;</span>

1191 
1192   return TRUE;
1193 }
1194 
1195 
1196 /*
1197  * Decode one MCU&#39;s worth of Huffman-compressed coefficients,
1198  * full-size blocks.
1199  */
1200 
1201 METHODDEF(boolean)
1202 decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
1203 {
1204   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1205   int blkn;
1206   BITREAD_STATE_VARS;
1207   savable_state state;
1208 
1209   /* Process restart marker if needed; may have to suspend */
1210   if (cinfo-&gt;restart_interval) {
1211     if (entropy-&gt;restarts_to_go == 0)
1212       if (! process_restart(cinfo))
1213     return FALSE;
1214   }
1215 
1216   /* If we&#39;ve run out of data, just leave the MCU set to zeroes.
1217    * This way, we return uniform gray for the remainder of the segment.
1218    */
1219   if (! entropy-&gt;insufficient_data) {
1220 
1221     /* Load up working state */
<a name="22" id="anc22"></a><span class="line-modified">1222     BITREAD_LOAD_STATE(cinfo,entropy-&gt;bitstate);</span>
1223     ASSIGN_STATE(state, entropy-&gt;saved);
1224 
1225     /* Outer loop handles each block in the MCU */
1226 
1227     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1228       JBLOCKROW block = MCU_data[blkn];
1229       d_derived_tbl * htbl;
1230       register int s, k, r;
1231       int coef_limit, ci;
1232 
1233       /* Decode a single block&#39;s worth of coefficients */
1234 
1235       /* Section F.2.2.1: decode the DC coefficient difference */
1236       htbl = entropy-&gt;dc_cur_tbls[blkn];
1237       HUFF_DECODE(s, br_state, htbl, return FALSE, label1);
1238 
1239       htbl = entropy-&gt;ac_cur_tbls[blkn];
1240       k = 1;
1241       coef_limit = entropy-&gt;coef_limit[blkn];
1242       if (coef_limit) {
1243     /* Convert DC difference to actual value, update last_dc_val */
1244     if (s) {
1245       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1246       r = GET_BITS(s);
1247       s = HUFF_EXTEND(r, s);
1248     }
1249     ci = cinfo-&gt;MCU_membership[blkn];
1250     s += state.last_dc_val[ci];
1251     state.last_dc_val[ci] = s;
1252     /* Output the DC coefficient */
1253     (*block)[0] = (JCOEF) s;
1254 
1255     /* Section F.2.2.2: decode the AC coefficients */
1256     /* Since zeroes are skipped, output area must be cleared beforehand */
1257     for (; k &lt; coef_limit; k++) {
1258       HUFF_DECODE(s, br_state, htbl, return FALSE, label2);
1259 
1260       r = s &gt;&gt; 4;
1261       s &amp;= 15;
1262 
1263       if (s) {
1264         k += r;
1265         CHECK_BIT_BUFFER(br_state, s, return FALSE);
1266         r = GET_BITS(s);
1267         s = HUFF_EXTEND(r, s);
1268         /* Output coefficient in natural (dezigzagged) order.
1269          * Note: the extra entries in jpeg_natural_order[] will save us
1270          * if k &gt;= DCTSIZE2, which could happen if the data is corrupted.
1271          */
1272         (*block)[jpeg_natural_order[k]] = (JCOEF) s;
1273       } else {
1274         if (r != 15)
1275           goto EndOfBlock;
1276         k += 15;
1277       }
1278     }
1279       } else {
1280     if (s) {
1281       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1282       DROP_BITS(s);
1283     }
1284       }
1285 
1286       /* Section F.2.2.2: decode the AC coefficients */
1287       /* In this path we just discard the values */
1288       for (; k &lt; DCTSIZE2; k++) {
1289     HUFF_DECODE(s, br_state, htbl, return FALSE, label3);
1290 
1291     r = s &gt;&gt; 4;
1292     s &amp;= 15;
1293 
1294     if (s) {
1295       k += r;
1296       CHECK_BIT_BUFFER(br_state, s, return FALSE);
1297       DROP_BITS(s);
1298     } else {
1299       if (r != 15)
1300         break;
1301       k += 15;
1302     }
1303       }
1304 
1305       EndOfBlock: ;
1306     }
1307 
1308     /* Completed MCU, so update state */
<a name="23" id="anc23"></a><span class="line-modified">1309     BITREAD_SAVE_STATE(cinfo,entropy-&gt;bitstate);</span>
1310     ASSIGN_STATE(entropy-&gt;saved, state);
1311   }
1312 
<a name="24" id="anc24"></a><span class="line-modified">1313   /* Account for restart interval (no-op if not using restarts) */</span>
<span class="line-modified">1314   entropy-&gt;restarts_to_go--;</span>

1315 
1316   return TRUE;
1317 }
1318 
1319 
1320 /*
1321  * Initialize for a Huffman-compressed scan.
1322  */
1323 
1324 METHODDEF(void)
1325 start_pass_huff_decoder (j_decompress_ptr cinfo)
1326 {
1327   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1328   int ci, blkn, tbl, i;
1329   jpeg_component_info * compptr;
1330 
1331   if (cinfo-&gt;progressive_mode) {
1332     /* Validate progressive scan parameters */
1333     if (cinfo-&gt;Ss == 0) {
1334       if (cinfo-&gt;Se != 0)
1335     goto bad;
1336     } else {
1337       /* need not check Ss/Se &lt; 0 since they came from unsigned bytes */
1338       if (cinfo-&gt;Se &lt; cinfo-&gt;Ss || cinfo-&gt;Se &gt; cinfo-&gt;lim_Se)
1339     goto bad;
1340       /* AC scans may have only one component */
1341       if (cinfo-&gt;comps_in_scan != 1)
1342     goto bad;
1343     }
1344     if (cinfo-&gt;Ah != 0) {
1345       /* Successive approximation refinement scan: must have Al = Ah-1. */
1346       if (cinfo-&gt;Ah-1 != cinfo-&gt;Al)
1347     goto bad;
1348     }
1349     if (cinfo-&gt;Al &gt; 13) {    /* need not check for &lt; 0 */
<a name="25" id="anc25"></a><span class="line-modified">1350       /* Arguably the maximum Al value should be less than 13 for 8-bit precision,</span>
<span class="line-modified">1351        * but the spec doesn&#39;t say so, and we try to be liberal about what we</span>
<span class="line-modified">1352        * accept.  Note: large Al values could result in out-of-range DC</span>
<span class="line-modified">1353        * coefficients during early scans, leading to bizarre displays due to</span>
<span class="line-modified">1354        * overflows in the IDCT math.  But we won&#39;t crash.</span>
1355        */
1356       bad:
1357       ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
1358            cinfo-&gt;Ss, cinfo-&gt;Se, cinfo-&gt;Ah, cinfo-&gt;Al);
1359     }
1360     /* Update progression status, and verify that scan order is legal.
1361      * Note that inter-scan inconsistencies are treated as warnings
1362      * not fatal errors ... not clear if this is right way to behave.
1363      */
1364     for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1365       int coefi, cindex = cinfo-&gt;cur_comp_info[ci]-&gt;component_index;
1366       int *coef_bit_ptr = &amp; cinfo-&gt;coef_bits[cindex][0];
1367       if (cinfo-&gt;Ss &amp;&amp; coef_bit_ptr[0] &lt; 0) /* AC without prior DC scan */
1368     WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
1369       for (coefi = cinfo-&gt;Ss; coefi &lt;= cinfo-&gt;Se; coefi++) {
1370     int expected = (coef_bit_ptr[coefi] &lt; 0) ? 0 : coef_bit_ptr[coefi];
1371     if (cinfo-&gt;Ah != expected)
1372       WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
1373     coef_bit_ptr[coefi] = cinfo-&gt;Al;
1374       }
1375     }
1376 
1377     /* Select MCU decoding routine */
1378     if (cinfo-&gt;Ah == 0) {
1379       if (cinfo-&gt;Ss == 0)
1380     entropy-&gt;pub.decode_mcu = decode_mcu_DC_first;
1381       else
1382     entropy-&gt;pub.decode_mcu = decode_mcu_AC_first;
1383     } else {
1384       if (cinfo-&gt;Ss == 0)
1385     entropy-&gt;pub.decode_mcu = decode_mcu_DC_refine;
1386       else
1387     entropy-&gt;pub.decode_mcu = decode_mcu_AC_refine;
1388     }
1389 
1390     for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1391       compptr = cinfo-&gt;cur_comp_info[ci];
1392       /* Make sure requested tables are present, and compute derived tables.
1393        * We may build same derived table more than once, but it&#39;s not expensive.
1394        */
1395       if (cinfo-&gt;Ss == 0) {
1396     if (cinfo-&gt;Ah == 0) {    /* DC refinement needs no table */
1397       tbl = compptr-&gt;dc_tbl_no;
1398       jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
1399                   &amp; entropy-&gt;derived_tbls[tbl]);
1400     }
1401       } else {
1402     tbl = compptr-&gt;ac_tbl_no;
1403     jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
1404                 &amp; entropy-&gt;derived_tbls[tbl]);
1405     /* remember the single active table */
1406     entropy-&gt;ac_derived_tbl = entropy-&gt;derived_tbls[tbl];
1407       }
1408       /* Initialize DC predictions to 0 */
1409       entropy-&gt;saved.last_dc_val[ci] = 0;
1410     }
1411 
1412     /* Initialize private state variables */
1413     entropy-&gt;saved.EOBRUN = 0;
1414   } else {
1415     /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
1416      * This ought to be an error condition, but we make it a warning because
1417      * there are some baseline files out there with all zeroes in these bytes.
1418      */
1419     if (cinfo-&gt;Ss != 0 || cinfo-&gt;Ah != 0 || cinfo-&gt;Al != 0 ||
1420     ((cinfo-&gt;is_baseline || cinfo-&gt;Se &lt; DCTSIZE2) &amp;&amp;
1421     cinfo-&gt;Se != cinfo-&gt;lim_Se))
1422       WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
1423 
1424     /* Select MCU decoding routine */
1425     /* We retain the hard-coded case for full-size blocks.
1426      * This is not necessary, but it appears that this version is slightly
1427      * more performant in the given implementation.
1428      * With an improved implementation we would prefer a single optimized
1429      * function.
1430      */
1431     if (cinfo-&gt;lim_Se != DCTSIZE2-1)
1432       entropy-&gt;pub.decode_mcu = decode_mcu_sub;
1433     else
1434       entropy-&gt;pub.decode_mcu = decode_mcu;
1435 
1436     for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1437       compptr = cinfo-&gt;cur_comp_info[ci];
1438       /* Compute derived values for Huffman tables */
1439       /* We may do this more than once for a table, but it&#39;s not expensive */
1440       tbl = compptr-&gt;dc_tbl_no;
1441       jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
1442                   &amp; entropy-&gt;dc_derived_tbls[tbl]);
1443       if (cinfo-&gt;lim_Se) {    /* AC needs no table when not present */
1444     tbl = compptr-&gt;ac_tbl_no;
1445     jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
1446                 &amp; entropy-&gt;ac_derived_tbls[tbl]);
1447       }
1448       /* Initialize DC predictions to 0 */
1449       entropy-&gt;saved.last_dc_val[ci] = 0;
1450     }
1451 
1452     /* Precalculate decoding info for each block in an MCU of this scan */
1453     for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1454       ci = cinfo-&gt;MCU_membership[blkn];
1455       compptr = cinfo-&gt;cur_comp_info[ci];
1456       /* Precalculate which table to use for each block */
1457       entropy-&gt;dc_cur_tbls[blkn] = entropy-&gt;dc_derived_tbls[compptr-&gt;dc_tbl_no];
<a name="26" id="anc26"></a><span class="line-modified">1458       entropy-&gt;ac_cur_tbls[blkn] = entropy-&gt;ac_derived_tbls[compptr-&gt;ac_tbl_no];</span>

1459       /* Decide whether we really care about the coefficient values */
1460       if (compptr-&gt;component_needed) {
1461     ci = compptr-&gt;DCT_v_scaled_size;
1462     i = compptr-&gt;DCT_h_scaled_size;
1463     switch (cinfo-&gt;lim_Se) {
1464     case (1*1-1):
1465       entropy-&gt;coef_limit[blkn] = 1;
1466       break;
1467     case (2*2-1):
1468       if (ci &lt;= 0 || ci &gt; 2) ci = 2;
1469       if (i &lt;= 0 || i &gt; 2) i = 2;
1470       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order2[ci - 1][i - 1];
1471       break;
1472     case (3*3-1):
1473       if (ci &lt;= 0 || ci &gt; 3) ci = 3;
1474       if (i &lt;= 0 || i &gt; 3) i = 3;
1475       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order3[ci - 1][i - 1];
1476       break;
1477     case (4*4-1):
1478       if (ci &lt;= 0 || ci &gt; 4) ci = 4;
1479       if (i &lt;= 0 || i &gt; 4) i = 4;
1480       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order4[ci - 1][i - 1];
1481       break;
1482     case (5*5-1):
1483       if (ci &lt;= 0 || ci &gt; 5) ci = 5;
1484       if (i &lt;= 0 || i &gt; 5) i = 5;
1485       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order5[ci - 1][i - 1];
1486       break;
1487     case (6*6-1):
1488       if (ci &lt;= 0 || ci &gt; 6) ci = 6;
1489       if (i &lt;= 0 || i &gt; 6) i = 6;
1490       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order6[ci - 1][i - 1];
1491       break;
1492     case (7*7-1):
1493       if (ci &lt;= 0 || ci &gt; 7) ci = 7;
1494       if (i &lt;= 0 || i &gt; 7) i = 7;
1495       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order7[ci - 1][i - 1];
1496       break;
1497     default:
1498       if (ci &lt;= 0 || ci &gt; 8) ci = 8;
1499       if (i &lt;= 0 || i &gt; 8) i = 8;
1500       entropy-&gt;coef_limit[blkn] = 1 + jpeg_zigzag_order[ci - 1][i - 1];
<a name="27" id="anc27"></a><span class="line-removed">1501       break;</span>
1502     }
1503       } else {
1504     entropy-&gt;coef_limit[blkn] = 0;
1505       }
1506     }
1507   }
1508 
1509   /* Initialize bitread state variables */
1510   entropy-&gt;bitstate.bits_left = 0;
1511   entropy-&gt;bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
1512   entropy-&gt;insufficient_data = FALSE;
1513 
1514   /* Initialize restart counter */
1515   entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1516 }
1517 
1518 
1519 /*
1520  * Module initialization routine for Huffman entropy decoding.
1521  */
1522 
1523 GLOBAL(void)
1524 jinit_huff_decoder (j_decompress_ptr cinfo)
1525 {
1526   huff_entropy_ptr entropy;
1527   int i;
1528 
<a name="28" id="anc28"></a><span class="line-modified">1529   entropy = (huff_entropy_ptr)</span>
<span class="line-modified">1530     (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-removed">1531                 SIZEOF(huff_entropy_decoder));</span>
1532   cinfo-&gt;entropy = &amp;entropy-&gt;pub;
1533   entropy-&gt;pub.start_pass = start_pass_huff_decoder;
1534   entropy-&gt;pub.finish_pass = finish_pass_huff;
1535 
1536   if (cinfo-&gt;progressive_mode) {
1537     /* Create progression status table */
1538     int *coef_bit_ptr, ci;
<a name="29" id="anc29"></a><span class="line-modified">1539     cinfo-&gt;coef_bits = (int (*)[DCTSIZE2])</span>
<span class="line-modified">1540       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,</span>
<span class="line-modified">1541                   cinfo-&gt;num_components*DCTSIZE2*SIZEOF(int));</span>
1542     coef_bit_ptr = &amp; cinfo-&gt;coef_bits[0][0];
1543     for (ci = 0; ci &lt; cinfo-&gt;num_components; ci++)
1544       for (i = 0; i &lt; DCTSIZE2; i++)
1545     *coef_bit_ptr++ = -1;
1546 
1547     /* Mark derived tables unallocated */
1548     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1549       entropy-&gt;derived_tbls[i] = NULL;
1550     }
1551   } else {
<a name="30" id="anc30"></a><span class="line-modified">1552     /* Mark tables unallocated */</span>
1553     for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1554       entropy-&gt;dc_derived_tbls[i] = entropy-&gt;ac_derived_tbls[i] = NULL;
1555     }
1556   }
1557 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
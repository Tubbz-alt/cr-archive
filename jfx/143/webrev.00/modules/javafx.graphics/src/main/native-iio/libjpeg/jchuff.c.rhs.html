<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-iio/libjpeg/jchuff.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * jchuff.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<a name="1" id="anc1"></a><span class="line-modified">   5  * Modified 2006-2019 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains Huffman entropy encoding routines.
  10  * Both sequential and progressive modes are supported in this single module.
  11  *
  12  * Much of the complexity here has to do with supporting output suspension.
  13  * If the data destination module demands suspension, we want to be able to
  14  * back up to the start of the current MCU.  To do this, we copy state
  15  * variables into local working storage, and update them back to the
  16  * permanent JPEG objects only upon successful completion of an MCU.
  17  *
  18  * We do not support output suspension for the progressive JPEG mode, since
  19  * the library currently does not allow multiple-scan files to be written
  20  * with output suspension.
  21  */
  22 
  23 #define JPEG_INTERNALS
  24 #include &quot;jinclude.h&quot;
  25 #include &quot;jpeglib.h&quot;
  26 
  27 
  28 /* The legal range of a DCT coefficient is
  29  *  -1024 .. +1023  for 8-bit data;
  30  * -16384 .. +16383 for 12-bit data.
  31  * Hence the magnitude should always fit in 10 or 14 bits respectively.
  32  */
  33 
  34 #if BITS_IN_JSAMPLE == 8
  35 #define MAX_COEF_BITS 10
  36 #else
  37 #define MAX_COEF_BITS 14
  38 #endif
  39 
  40 /* Derived data constructed for each Huffman table */
  41 
  42 typedef struct {
  43   unsigned int ehufco[256];    /* code for each symbol */
  44   char ehufsi[256];        /* length of code for each symbol */
  45   /* If no code has been allocated for a symbol S, ehufsi[S] contains 0 */
  46 } c_derived_tbl;
  47 
  48 
  49 /* Expanded entropy encoder object for Huffman encoding.
  50  *
  51  * The savable_state subrecord contains fields that change within an MCU,
  52  * but must not be updated permanently until we complete the MCU.
  53  */
  54 
  55 typedef struct {
  56   INT32 put_buffer;        /* current bit-accumulation buffer */
  57   int put_bits;            /* # of bits now in it */
  58   int last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each component */
  59 } savable_state;
  60 
  61 /* This macro is to work around compilers with missing or broken
  62  * structure assignment.  You&#39;ll need to fix this code if you have
  63  * such a compiler and you change MAX_COMPS_IN_SCAN.
  64  */
  65 
  66 #ifndef NO_STRUCT_ASSIGN
  67 #define ASSIGN_STATE(dest,src)  ((dest) = (src))
  68 #else
  69 #if MAX_COMPS_IN_SCAN == 4
  70 #define ASSIGN_STATE(dest,src)  \
  71     ((dest).put_buffer = (src).put_buffer, \
  72      (dest).put_bits = (src).put_bits, \
  73      (dest).last_dc_val[0] = (src).last_dc_val[0], \
  74      (dest).last_dc_val[1] = (src).last_dc_val[1], \
  75      (dest).last_dc_val[2] = (src).last_dc_val[2], \
  76      (dest).last_dc_val[3] = (src).last_dc_val[3])
  77 #endif
  78 #endif
  79 
  80 
  81 typedef struct {
  82   struct jpeg_entropy_encoder pub; /* public fields */
  83 
  84   savable_state saved;        /* Bit buffer &amp; DC state at start of MCU */
  85 
  86   /* These fields are NOT loaded into local working state. */
  87   unsigned int restarts_to_go;    /* MCUs left in this restart interval */
  88   int next_restart_num;        /* next restart number to write (0-7) */
  89 
  90   /* Pointers to derived tables (these workspaces have image lifespan) */
  91   c_derived_tbl * dc_derived_tbls[NUM_HUFF_TBLS];
  92   c_derived_tbl * ac_derived_tbls[NUM_HUFF_TBLS];
  93 
  94   /* Statistics tables for optimization */
  95   long * dc_count_ptrs[NUM_HUFF_TBLS];
  96   long * ac_count_ptrs[NUM_HUFF_TBLS];
  97 
  98   /* Following fields used only in progressive mode */
  99 
 100   /* Mode flag: TRUE for optimization, FALSE for actual data output */
 101   boolean gather_statistics;
 102 
 103   /* next_output_byte/free_in_buffer are local copies of cinfo-&gt;dest fields.
 104    */
 105   JOCTET * next_output_byte;    /* =&gt; next byte to write in buffer */
 106   size_t free_in_buffer;    /* # of byte spaces remaining in buffer */
 107   j_compress_ptr cinfo;        /* link to cinfo (needed for dump_buffer) */
 108 
 109   /* Coding status for AC components */
 110   int ac_tbl_no;        /* the table number of the single component */
 111   unsigned int EOBRUN;        /* run length of EOBs */
 112   unsigned int BE;        /* # of buffered correction bits before MCU */
 113   char * bit_buffer;        /* buffer for correction bits (1 per char) */
 114   /* packing correction bits tightly would save some space but cost time... */
 115 } huff_entropy_encoder;
 116 
 117 typedef huff_entropy_encoder * huff_entropy_ptr;
 118 
 119 /* Working state while writing an MCU (sequential mode).
 120  * This struct contains all the fields that are needed by subroutines.
 121  */
 122 
 123 typedef struct {
 124   JOCTET * next_output_byte;    /* =&gt; next byte to write in buffer */
 125   size_t free_in_buffer;    /* # of byte spaces remaining in buffer */
 126   savable_state cur;        /* Current bit buffer &amp; DC state */
 127   j_compress_ptr cinfo;        /* dump_buffer needs access to this */
 128 } working_state;
 129 
 130 /* MAX_CORR_BITS is the number of bits the AC refinement correction-bit
 131  * buffer can hold.  Larger sizes may slightly improve compression, but
 132  * 1000 is already well into the realm of overkill.
 133  * The minimum safe size is 64 bits.
 134  */
 135 
 136 #define MAX_CORR_BITS  1000    /* Max # of correction bits I can buffer */
 137 
 138 /* IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than INT32.
 139  * We assume that int right shift is unsigned if INT32 right shift is,
 140  * which should be safe.
 141  */
 142 
 143 #ifdef RIGHT_SHIFT_IS_UNSIGNED
 144 #define ISHIFT_TEMPS    int ishift_temp;
 145 #define IRIGHT_SHIFT(x,shft)  \
 146     ((ishift_temp = (x)) &lt; 0 ? \
 147      (ishift_temp &gt;&gt; (shft)) | ((~0) &lt;&lt; (16-(shft))) : \
 148      (ishift_temp &gt;&gt; (shft)))
 149 #else
 150 #define ISHIFT_TEMPS
 151 #define IRIGHT_SHIFT(x,shft)    ((x) &gt;&gt; (shft))
 152 #endif
 153 
 154 
 155 /*
 156  * Compute the derived values for a Huffman table.
 157  * This routine also performs some validation checks on the table.
 158  */
 159 
 160 LOCAL(void)
 161 jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
 162              c_derived_tbl ** pdtbl)
 163 {
 164   JHUFF_TBL *htbl;
 165   c_derived_tbl *dtbl;
 166   int p, i, l, lastp, si, maxsymbol;
 167   char huffsize[257];
 168   unsigned int huffcode[257];
 169   unsigned int code;
 170 
 171   MEMZERO(huffsize, SIZEOF(huffsize));
 172   MEMZERO(huffcode, SIZEOF(huffcode));
 173   /* Note that huffsize[] and huffcode[] are filled in code-length order,
 174    * paralleling the order of the symbols themselves in htbl-&gt;huffval[].
 175    */
 176 
 177   /* Find the input Huffman table */
 178   if (tblno &lt; 0 || tblno &gt;= NUM_HUFF_TBLS)
 179     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
 180   htbl =
 181     isDC ? cinfo-&gt;dc_huff_tbl_ptrs[tblno] : cinfo-&gt;ac_huff_tbl_ptrs[tblno];
 182   if (htbl == NULL)
<a name="2" id="anc2"></a><span class="line-modified"> 183     htbl = jpeg_std_huff_table((j_common_ptr) cinfo, isDC, tblno);</span>
 184 
 185   /* Allocate a workspace if we haven&#39;t already done so. */
 186   if (*pdtbl == NULL)
<a name="3" id="anc3"></a><span class="line-modified"> 187     *pdtbl = (c_derived_tbl *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified"> 188       ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(c_derived_tbl));</span>

 189   dtbl = *pdtbl;
 190 
 191   /* Figure C.1: make table of Huffman code length for each symbol */
 192 
 193   p = 0;
 194   for (l = 1; l &lt;= 16; l++) {
 195     i = (int) htbl-&gt;bits[l];
 196     if (i &lt; 0 || p + i &gt; 256)    /* protect against table overrun */
 197       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 198     while (i--)
 199       huffsize[p++] = (char) l;
 200   }
 201   huffsize[p] = 0;
 202   lastp = p;
 203 
 204   /* Figure C.2: generate the codes themselves */
 205   /* We also validate that the counts represent a legal Huffman code tree. */
 206 
 207   code = 0;
 208   si = huffsize[0];
 209   p = 0;
 210   while (huffsize[p]) {
 211     while (((int) huffsize[p]) == si) {
 212       huffcode[p++] = code;
 213       code++;
 214     }
 215     /* code is now 1 more than the last code used for codelength si; but
 216      * it must still fit in si bits, since no code is allowed to be all ones.
 217      */
 218     if (((INT32) code) &gt;= (((INT32) 1) &lt;&lt; si))
 219       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 220     code &lt;&lt;= 1;
 221     si++;
 222   }
 223 
 224   /* Figure C.3: generate encoding tables */
 225   /* These are code and size indexed by symbol value */
 226 
 227   /* Set all codeless symbols to have code length 0;
 228    * this lets us detect duplicate VAL entries here, and later
 229    * allows emit_bits to detect any attempt to emit such symbols.
 230    */
 231   MEMZERO(dtbl-&gt;ehufsi, SIZEOF(dtbl-&gt;ehufsi));
 232 
 233   /* This is also a convenient place to check for out-of-range
 234    * and duplicated VAL entries.  We allow 0..255 for AC symbols
 235    * but only 0..15 for DC.  (We could constrain them further
 236    * based on data depth and mode, but this seems enough.)
 237    */
 238   maxsymbol = isDC ? 15 : 255;
 239 
 240   for (p = 0; p &lt; lastp; p++) {
 241     i = htbl-&gt;huffval[p];
 242     if (i &lt; 0 || i &gt; maxsymbol || dtbl-&gt;ehufsi[i])
 243       ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
 244     dtbl-&gt;ehufco[i] = huffcode[p];
 245     dtbl-&gt;ehufsi[i] = huffsize[p];
 246   }
 247 }
 248 
 249 
 250 /* Outputting bytes to the file.
 251  * NB: these must be called only when actually outputting,
 252  * that is, entropy-&gt;gather_statistics == FALSE.
 253  */
 254 
 255 /* Emit a byte, taking &#39;action&#39; if must suspend. */
 256 #define emit_byte_s(state,val,action)  \
 257     { *(state)-&gt;next_output_byte++ = (JOCTET) (val);  \
 258       if (--(state)-&gt;free_in_buffer == 0)  \
 259         if (! dump_buffer_s(state))  \
 260           { action; } }
 261 
 262 /* Emit a byte */
 263 #define emit_byte_e(entropy,val)  \
 264     { *(entropy)-&gt;next_output_byte++ = (JOCTET) (val);  \
 265       if (--(entropy)-&gt;free_in_buffer == 0)  \
 266         dump_buffer_e(entropy); }
 267 
 268 
 269 LOCAL(boolean)
 270 dump_buffer_s (working_state * state)
 271 /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
 272 {
 273   struct jpeg_destination_mgr * dest = state-&gt;cinfo-&gt;dest;
 274 
 275   if (! (*dest-&gt;empty_output_buffer) (state-&gt;cinfo))
 276     return FALSE;
 277   /* After a successful buffer dump, must reset buffer pointers */
 278   state-&gt;next_output_byte = dest-&gt;next_output_byte;
 279   state-&gt;free_in_buffer = dest-&gt;free_in_buffer;
 280   return TRUE;
 281 }
 282 
 283 
 284 LOCAL(void)
 285 dump_buffer_e (huff_entropy_ptr entropy)
 286 /* Empty the output buffer; we do not support suspension in this case. */
 287 {
 288   struct jpeg_destination_mgr * dest = entropy-&gt;cinfo-&gt;dest;
 289 
 290   if (! (*dest-&gt;empty_output_buffer) (entropy-&gt;cinfo))
 291     ERREXIT(entropy-&gt;cinfo, JERR_CANT_SUSPEND);
 292   /* After a successful buffer dump, must reset buffer pointers */
 293   entropy-&gt;next_output_byte = dest-&gt;next_output_byte;
 294   entropy-&gt;free_in_buffer = dest-&gt;free_in_buffer;
 295 }
 296 
 297 
 298 /* Outputting bits to the file */
 299 
 300 /* Only the right 24 bits of put_buffer are used; the valid bits are
 301  * left-justified in this part.  At most 16 bits can be passed to emit_bits
 302  * in one call, and we never retain more than 7 bits in put_buffer
 303  * between calls, so 24 bits are sufficient.
 304  */
 305 
 306 INLINE
 307 LOCAL(boolean)
 308 emit_bits_s (working_state * state, unsigned int code, int size)
 309 /* Emit some bits; return TRUE if successful, FALSE if must suspend */
 310 {
 311   /* This routine is heavily used, so it&#39;s worth coding tightly. */
 312   register INT32 put_buffer;
 313   register int put_bits;
 314 
 315   /* if size is 0, caller used an invalid Huffman table entry */
 316   if (size == 0)
 317     ERREXIT(state-&gt;cinfo, JERR_HUFF_MISSING_CODE);
 318 
 319   /* mask off any extra bits in code */
 320   put_buffer = ((INT32) code) &amp; ((((INT32) 1) &lt;&lt; size) - 1);
 321 
 322   /* new number of bits in buffer */
 323   put_bits = size + state-&gt;cur.put_bits;
 324 
 325   put_buffer &lt;&lt;= 24 - put_bits; /* align incoming bits */
 326 
 327   /* and merge with old buffer contents */
 328   put_buffer |= state-&gt;cur.put_buffer;
 329 
 330   while (put_bits &gt;= 8) {
 331     int c = (int) ((put_buffer &gt;&gt; 16) &amp; 0xFF);
 332 
 333     emit_byte_s(state, c, return FALSE);
 334     if (c == 0xFF) {        /* need to stuff a zero byte? */
 335       emit_byte_s(state, 0, return FALSE);
 336     }
 337     put_buffer &lt;&lt;= 8;
 338     put_bits -= 8;
 339   }
 340 
 341   state-&gt;cur.put_buffer = put_buffer; /* update state variables */
 342   state-&gt;cur.put_bits = put_bits;
 343 
 344   return TRUE;
 345 }
 346 
 347 
 348 INLINE
 349 LOCAL(void)
 350 emit_bits_e (huff_entropy_ptr entropy, unsigned int code, int size)
 351 /* Emit some bits, unless we are in gather mode */
 352 {
 353   /* This routine is heavily used, so it&#39;s worth coding tightly. */
 354   register INT32 put_buffer;
 355   register int put_bits;
 356 
 357   /* if size is 0, caller used an invalid Huffman table entry */
 358   if (size == 0)
 359     ERREXIT(entropy-&gt;cinfo, JERR_HUFF_MISSING_CODE);
 360 
 361   if (entropy-&gt;gather_statistics)
 362     return;            /* do nothing if we&#39;re only getting stats */
 363 
 364   /* mask off any extra bits in code */
 365   put_buffer = ((INT32) code) &amp; ((((INT32) 1) &lt;&lt; size) - 1);
 366 
 367   /* new number of bits in buffer */
 368   put_bits = size + entropy-&gt;saved.put_bits;
 369 
 370   put_buffer &lt;&lt;= 24 - put_bits; /* align incoming bits */
 371 
 372   /* and merge with old buffer contents */
 373   put_buffer |= entropy-&gt;saved.put_buffer;
 374 
 375   while (put_bits &gt;= 8) {
 376     int c = (int) ((put_buffer &gt;&gt; 16) &amp; 0xFF);
 377 
 378     emit_byte_e(entropy, c);
 379     if (c == 0xFF) {        /* need to stuff a zero byte? */
 380       emit_byte_e(entropy, 0);
 381     }
 382     put_buffer &lt;&lt;= 8;
 383     put_bits -= 8;
 384   }
 385 
 386   entropy-&gt;saved.put_buffer = put_buffer; /* update variables */
 387   entropy-&gt;saved.put_bits = put_bits;
 388 }
 389 
 390 
 391 LOCAL(boolean)
 392 flush_bits_s (working_state * state)
 393 {
 394   if (! emit_bits_s(state, 0x7F, 7)) /* fill any partial byte with ones */
 395     return FALSE;
 396   state-&gt;cur.put_buffer = 0;         /* and reset bit-buffer to empty */
 397   state-&gt;cur.put_bits = 0;
 398   return TRUE;
 399 }
 400 
 401 
 402 LOCAL(void)
 403 flush_bits_e (huff_entropy_ptr entropy)
 404 {
 405   emit_bits_e(entropy, 0x7F, 7); /* fill any partial byte with ones */
 406   entropy-&gt;saved.put_buffer = 0; /* and reset bit-buffer to empty */
 407   entropy-&gt;saved.put_bits = 0;
 408 }
 409 
 410 
 411 /*
 412  * Emit (or just count) a Huffman symbol.
 413  */
 414 
 415 INLINE
 416 LOCAL(void)
 417 emit_dc_symbol (huff_entropy_ptr entropy, int tbl_no, int symbol)
 418 {
 419   if (entropy-&gt;gather_statistics)
 420     entropy-&gt;dc_count_ptrs[tbl_no][symbol]++;
 421   else {
 422     c_derived_tbl * tbl = entropy-&gt;dc_derived_tbls[tbl_no];
 423     emit_bits_e(entropy, tbl-&gt;ehufco[symbol], tbl-&gt;ehufsi[symbol]);
 424   }
 425 }
 426 
 427 
 428 INLINE
 429 LOCAL(void)
 430 emit_ac_symbol (huff_entropy_ptr entropy, int tbl_no, int symbol)
 431 {
 432   if (entropy-&gt;gather_statistics)
 433     entropy-&gt;ac_count_ptrs[tbl_no][symbol]++;
 434   else {
 435     c_derived_tbl * tbl = entropy-&gt;ac_derived_tbls[tbl_no];
 436     emit_bits_e(entropy, tbl-&gt;ehufco[symbol], tbl-&gt;ehufsi[symbol]);
 437   }
 438 }
 439 
 440 
 441 /*
 442  * Emit bits from a correction bit buffer.
 443  */
 444 
 445 LOCAL(void)
 446 emit_buffered_bits (huff_entropy_ptr entropy, char * bufstart,
 447             unsigned int nbits)
 448 {
 449   if (entropy-&gt;gather_statistics)
 450     return;            /* no real work */
 451 
 452   while (nbits &gt; 0) {
 453     emit_bits_e(entropy, (unsigned int) (*bufstart), 1);
 454     bufstart++;
 455     nbits--;
 456   }
 457 }
 458 
 459 
 460 /*
 461  * Emit any pending EOBRUN symbol.
 462  */
 463 
 464 LOCAL(void)
 465 emit_eobrun (huff_entropy_ptr entropy)
 466 {
 467   register int temp, nbits;
 468 
 469   if (entropy-&gt;EOBRUN &gt; 0) {    /* if there is any pending EOBRUN */
 470     temp = entropy-&gt;EOBRUN;
 471     nbits = 0;
 472     while ((temp &gt;&gt;= 1))
 473       nbits++;
 474     /* safety check: shouldn&#39;t happen given limited correction-bit buffer */
 475     if (nbits &gt; 14)
 476       ERREXIT(entropy-&gt;cinfo, JERR_HUFF_MISSING_CODE);
 477 
 478     emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, nbits &lt;&lt; 4);
 479     if (nbits)
 480       emit_bits_e(entropy, entropy-&gt;EOBRUN, nbits);
 481 
 482     entropy-&gt;EOBRUN = 0;
 483 
 484     /* Emit any buffered correction bits */
 485     emit_buffered_bits(entropy, entropy-&gt;bit_buffer, entropy-&gt;BE);
 486     entropy-&gt;BE = 0;
 487   }
 488 }
 489 
 490 
 491 /*
 492  * Emit a restart marker &amp; resynchronize predictions.
 493  */
 494 
 495 LOCAL(boolean)
 496 emit_restart_s (working_state * state, int restart_num)
 497 {
 498   int ci;
 499 
 500   if (! flush_bits_s(state))
 501     return FALSE;
 502 
 503   emit_byte_s(state, 0xFF, return FALSE);
 504   emit_byte_s(state, JPEG_RST0 + restart_num, return FALSE);
 505 
 506   /* Re-initialize DC predictions to 0 */
 507   for (ci = 0; ci &lt; state-&gt;cinfo-&gt;comps_in_scan; ci++)
 508     state-&gt;cur.last_dc_val[ci] = 0;
 509 
 510   /* The restart counter is not updated until we successfully write the MCU. */
 511 
 512   return TRUE;
 513 }
 514 
 515 
 516 LOCAL(void)
 517 emit_restart_e (huff_entropy_ptr entropy, int restart_num)
 518 {
 519   int ci;
 520 
 521   emit_eobrun(entropy);
 522 
 523   if (! entropy-&gt;gather_statistics) {
 524     flush_bits_e(entropy);
 525     emit_byte_e(entropy, 0xFF);
 526     emit_byte_e(entropy, JPEG_RST0 + restart_num);
 527   }
 528 
 529   if (entropy-&gt;cinfo-&gt;Ss == 0) {
 530     /* Re-initialize DC predictions to 0 */
 531     for (ci = 0; ci &lt; entropy-&gt;cinfo-&gt;comps_in_scan; ci++)
 532       entropy-&gt;saved.last_dc_val[ci] = 0;
 533   } else {
 534     /* Re-initialize all AC-related fields to 0 */
 535     entropy-&gt;EOBRUN = 0;
 536     entropy-&gt;BE = 0;
 537   }
 538 }
 539 
 540 
 541 /*
 542  * MCU encoding for DC initial scan (either spectral selection,
 543  * or first pass of successive approximation).
 544  */
 545 
 546 METHODDEF(boolean)
 547 encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 548 {
 549   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 550   register int temp, temp2;
 551   register int nbits;
 552   int blkn, ci, tbl;
 553   ISHIFT_TEMPS
 554 
 555   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 556   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 557 
 558   /* Emit restart marker if needed */
 559   if (cinfo-&gt;restart_interval)
 560     if (entropy-&gt;restarts_to_go == 0)
 561       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 562 
 563   /* Encode the MCU data blocks */
 564   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 565     ci = cinfo-&gt;MCU_membership[blkn];
 566     tbl = cinfo-&gt;cur_comp_info[ci]-&gt;dc_tbl_no;
 567 
 568     /* Compute the DC value after the required point transform by Al.
 569      * This is simply an arithmetic right shift.
 570      */
 571     temp = IRIGHT_SHIFT((int) (MCU_data[blkn][0][0]), cinfo-&gt;Al);
 572 
 573     /* DC differences are figured on the point-transformed values. */
 574     temp2 = temp - entropy-&gt;saved.last_dc_val[ci];
 575     entropy-&gt;saved.last_dc_val[ci] = temp;
 576 
 577     /* Encode the DC coefficient difference per section G.1.2.1 */
 578     temp = temp2;
 579     if (temp &lt; 0) {
 580       temp = -temp;        /* temp is abs value of input */
 581       /* For a negative input, want temp2 = bitwise complement of abs(input) */
 582       /* This code assumes we are on a two&#39;s complement machine */
 583       temp2--;
 584     }
 585 
 586     /* Find the number of bits needed for the magnitude of the coefficient */
 587     nbits = 0;
 588     while (temp) {
 589       nbits++;
 590       temp &gt;&gt;= 1;
 591     }
 592     /* Check for out-of-range coefficient values.
 593      * Since we&#39;re encoding a difference, the range limit is twice as much.
 594      */
 595     if (nbits &gt; MAX_COEF_BITS+1)
 596       ERREXIT(cinfo, JERR_BAD_DCT_COEF);
 597 
 598     /* Count/emit the Huffman-coded symbol for the number of bits */
 599     emit_dc_symbol(entropy, tbl, nbits);
 600 
 601     /* Emit that number of bits of the value, if positive, */
 602     /* or the complement of its magnitude, if negative. */
 603     if (nbits)            /* emit_bits rejects calls with size 0 */
 604       emit_bits_e(entropy, (unsigned int) temp2, nbits);
 605   }
 606 
 607   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 608   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 609 
 610   /* Update restart-interval state too */
 611   if (cinfo-&gt;restart_interval) {
 612     if (entropy-&gt;restarts_to_go == 0) {
 613       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 614       entropy-&gt;next_restart_num++;
 615       entropy-&gt;next_restart_num &amp;= 7;
 616     }
 617     entropy-&gt;restarts_to_go--;
 618   }
 619 
 620   return TRUE;
 621 }
 622 
 623 
 624 /*
 625  * MCU encoding for AC initial scan (either spectral selection,
 626  * or first pass of successive approximation).
 627  */
 628 
 629 METHODDEF(boolean)
 630 encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 631 {
 632   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 633   const int * natural_order;
 634   JBLOCKROW block;
 635   register int temp, temp2;
 636   register int nbits;
 637   register int r, k;
 638   int Se, Al;
 639 
 640   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 641   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 642 
 643   /* Emit restart marker if needed */
 644   if (cinfo-&gt;restart_interval)
 645     if (entropy-&gt;restarts_to_go == 0)
 646       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 647 
 648   Se = cinfo-&gt;Se;
 649   Al = cinfo-&gt;Al;
 650   natural_order = cinfo-&gt;natural_order;
 651 
 652   /* Encode the MCU data block */
 653   block = MCU_data[0];
 654 
 655   /* Encode the AC coefficients per section G.1.2.2, fig. G.3 */
 656 
 657   r = 0;            /* r = run length of zeros */
 658 
 659   for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 660     if ((temp = (*block)[natural_order[k]]) == 0) {
 661       r++;
 662       continue;
 663     }
 664     /* We must apply the point transform by Al.  For AC coefficients this
 665      * is an integer division with rounding towards 0.  To do this portably
 666      * in C, we shift after obtaining the absolute value; so the code is
 667      * interwoven with finding the abs value (temp) and output bits (temp2).
 668      */
 669     if (temp &lt; 0) {
 670       temp = -temp;        /* temp is abs value of input */
 671       temp &gt;&gt;= Al;        /* apply the point transform */
 672       /* For a negative coef, want temp2 = bitwise complement of abs(coef) */
 673       temp2 = ~temp;
 674     } else {
 675       temp &gt;&gt;= Al;        /* apply the point transform */
 676       temp2 = temp;
 677     }
 678     /* Watch out for case that nonzero coef is zero after point transform */
 679     if (temp == 0) {
 680       r++;
 681       continue;
 682     }
 683 
 684     /* Emit any pending EOBRUN */
 685     if (entropy-&gt;EOBRUN &gt; 0)
 686       emit_eobrun(entropy);
 687     /* if run length &gt; 15, must emit special run-length-16 codes (0xF0) */
 688     while (r &gt; 15) {
 689       emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, 0xF0);
 690       r -= 16;
 691     }
 692 
 693     /* Find the number of bits needed for the magnitude of the coefficient */
 694     nbits = 1;            /* there must be at least one 1 bit */
 695     while ((temp &gt;&gt;= 1))
 696       nbits++;
 697     /* Check for out-of-range coefficient values */
 698     if (nbits &gt; MAX_COEF_BITS)
 699       ERREXIT(cinfo, JERR_BAD_DCT_COEF);
 700 
 701     /* Count/emit Huffman symbol for run length / number of bits */
 702     emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, (r &lt;&lt; 4) + nbits);
 703 
 704     /* Emit that number of bits of the value, if positive, */
 705     /* or the complement of its magnitude, if negative. */
 706     emit_bits_e(entropy, (unsigned int) temp2, nbits);
 707 
 708     r = 0;            /* reset zero run length */
 709   }
 710 
 711   if (r &gt; 0) {            /* If there are trailing zeroes, */
 712     entropy-&gt;EOBRUN++;        /* count an EOB */
 713     if (entropy-&gt;EOBRUN == 0x7FFF)
 714       emit_eobrun(entropy);    /* force it out to avoid overflow */
 715   }
 716 
 717   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 718   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 719 
 720   /* Update restart-interval state too */
 721   if (cinfo-&gt;restart_interval) {
 722     if (entropy-&gt;restarts_to_go == 0) {
 723       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 724       entropy-&gt;next_restart_num++;
 725       entropy-&gt;next_restart_num &amp;= 7;
 726     }
 727     entropy-&gt;restarts_to_go--;
 728   }
 729 
 730   return TRUE;
 731 }
 732 
 733 
 734 /*
 735  * MCU encoding for DC successive approximation refinement scan.
 736  * Note: we assume such scans can be multi-component,
 737  * although the spec is not very clear on the point.
 738  */
 739 
 740 METHODDEF(boolean)
 741 encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 742 {
 743   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 744   int Al, blkn;
 745 
 746   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 747   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 748 
 749   /* Emit restart marker if needed */
 750   if (cinfo-&gt;restart_interval)
 751     if (entropy-&gt;restarts_to_go == 0)
 752       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 753 
 754   Al = cinfo-&gt;Al;
 755 
 756   /* Encode the MCU data blocks */
 757   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
 758     /* We simply emit the Al&#39;th bit of the DC coefficient value. */
 759     emit_bits_e(entropy, (unsigned int) (MCU_data[blkn][0][0] &gt;&gt; Al), 1);
 760   }
 761 
 762   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 763   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 764 
 765   /* Update restart-interval state too */
 766   if (cinfo-&gt;restart_interval) {
 767     if (entropy-&gt;restarts_to_go == 0) {
 768       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 769       entropy-&gt;next_restart_num++;
 770       entropy-&gt;next_restart_num &amp;= 7;
 771     }
 772     entropy-&gt;restarts_to_go--;
 773   }
 774 
 775   return TRUE;
 776 }
 777 
 778 
 779 /*
 780  * MCU encoding for AC successive approximation refinement scan.
 781  */
 782 
 783 METHODDEF(boolean)
 784 encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 785 {
 786   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
 787   const int * natural_order;
 788   JBLOCKROW block;
 789   register int temp;
 790   register int r, k;
 791   int Se, Al;
 792   int EOB;
 793   char *BR_buffer;
 794   unsigned int BR;
 795   int absvalues[DCTSIZE2];
 796 
 797   MEMZERO(absvalues, SIZEOF(absvalues));
 798 
 799   entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
 800   entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
 801 
 802   /* Emit restart marker if needed */
 803   if (cinfo-&gt;restart_interval)
 804     if (entropy-&gt;restarts_to_go == 0)
 805       emit_restart_e(entropy, entropy-&gt;next_restart_num);
 806 
 807   Se = cinfo-&gt;Se;
 808   Al = cinfo-&gt;Al;
 809   natural_order = cinfo-&gt;natural_order;
 810 
 811   /* Encode the MCU data block */
 812   block = MCU_data[0];
 813 
 814   /* It is convenient to make a pre-pass to determine the transformed
 815    * coefficients&#39; absolute values and the EOB position.
 816    */
 817   EOB = 0;
 818   for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 819     temp = (*block)[natural_order[k]];
 820     /* We must apply the point transform by Al.  For AC coefficients this
 821      * is an integer division with rounding towards 0.  To do this portably
 822      * in C, we shift after obtaining the absolute value.
 823      */
 824     if (temp &lt; 0)
 825       temp = -temp;        /* temp is abs value of input */
 826     temp &gt;&gt;= Al;        /* apply the point transform */
 827     absvalues[k] = temp;    /* save abs value for main pass */
 828     if (temp == 1)
 829       EOB = k;            /* EOB = index of last newly-nonzero coef */
 830   }
 831 
 832   /* Encode the AC coefficients per section G.1.2.3, fig. G.7 */
 833 
 834   r = 0;            /* r = run length of zeros */
 835   BR = 0;            /* BR = count of buffered bits added now */
 836   BR_buffer = entropy-&gt;bit_buffer + entropy-&gt;BE; /* Append bits to buffer */
 837 
 838   for (k = cinfo-&gt;Ss; k &lt;= Se; k++) {
 839     if ((temp = absvalues[k]) == 0) {
 840       r++;
 841       continue;
 842     }
 843 
 844     /* Emit any required ZRLs, but not if they can be folded into EOB */
 845     while (r &gt; 15 &amp;&amp; k &lt;= EOB) {
 846       /* emit any pending EOBRUN and the BE correction bits */
 847       emit_eobrun(entropy);
 848       /* Emit ZRL */
 849       emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, 0xF0);
 850       r -= 16;
 851       /* Emit buffered correction bits that must be associated with ZRL */
 852       emit_buffered_bits(entropy, BR_buffer, BR);
 853       BR_buffer = entropy-&gt;bit_buffer; /* BE bits are gone now */
 854       BR = 0;
 855     }
 856 
 857     /* If the coef was previously nonzero, it only needs a correction bit.
 858      * NOTE: a straight translation of the spec&#39;s figure G.7 would suggest
 859      * that we also need to test r &gt; 15.  But if r &gt; 15, we can only get here
 860      * if k &gt; EOB, which implies that this coefficient is not 1.
 861      */
 862     if (temp &gt; 1) {
 863       /* The correction bit is the next bit of the absolute value. */
 864       BR_buffer[BR++] = (char) (temp &amp; 1);
 865       continue;
 866     }
 867 
 868     /* Emit any pending EOBRUN and the BE correction bits */
 869     emit_eobrun(entropy);
 870 
 871     /* Count/emit Huffman symbol for run length / number of bits */
 872     emit_ac_symbol(entropy, entropy-&gt;ac_tbl_no, (r &lt;&lt; 4) + 1);
 873 
 874     /* Emit output bit for newly-nonzero coef */
 875     temp = ((*block)[natural_order[k]] &lt; 0) ? 0 : 1;
 876     emit_bits_e(entropy, (unsigned int) temp, 1);
 877 
 878     /* Emit buffered correction bits that must be associated with this code */
 879     emit_buffered_bits(entropy, BR_buffer, BR);
 880     BR_buffer = entropy-&gt;bit_buffer; /* BE bits are gone now */
 881     BR = 0;
 882     r = 0;            /* reset zero run length */
 883   }
 884 
 885   if (r &gt; 0 || BR &gt; 0) {    /* If there are trailing zeroes, */
 886     entropy-&gt;EOBRUN++;        /* count an EOB */
 887     entropy-&gt;BE += BR;        /* concat my correction bits to older ones */
 888     /* We force out the EOB if we risk either:
 889      * 1. overflow of the EOB counter;
 890      * 2. overflow of the correction bit buffer during the next MCU.
 891      */
 892     if (entropy-&gt;EOBRUN == 0x7FFF || entropy-&gt;BE &gt; (MAX_CORR_BITS-DCTSIZE2+1))
 893       emit_eobrun(entropy);
 894   }
 895 
 896   cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
 897   cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
 898 
 899   /* Update restart-interval state too */
 900   if (cinfo-&gt;restart_interval) {
 901     if (entropy-&gt;restarts_to_go == 0) {
 902       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
 903       entropy-&gt;next_restart_num++;
 904       entropy-&gt;next_restart_num &amp;= 7;
 905     }
 906     entropy-&gt;restarts_to_go--;
 907   }
 908 
 909   return TRUE;
 910 }
 911 
 912 
 913 /* Encode a single block&#39;s worth of coefficients */
 914 
 915 LOCAL(boolean)
 916 encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
 917           c_derived_tbl *dctbl, c_derived_tbl *actbl)
 918 {
 919   register int temp, temp2;
 920   register int nbits;
 921   register int r, k;
 922   int Se = state-&gt;cinfo-&gt;lim_Se;
 923   const int * natural_order = state-&gt;cinfo-&gt;natural_order;
 924 
 925   /* Encode the DC coefficient difference per section F.1.2.1 */
 926 
 927   temp = temp2 = block[0] - last_dc_val;
 928 
 929   if (temp &lt; 0) {
 930     temp = -temp;        /* temp is abs value of input */
 931     /* For a negative input, want temp2 = bitwise complement of abs(input) */
 932     /* This code assumes we are on a two&#39;s complement machine */
 933     temp2--;
 934   }
 935 
 936   /* Find the number of bits needed for the magnitude of the coefficient */
 937   nbits = 0;
 938   while (temp) {
 939     nbits++;
 940     temp &gt;&gt;= 1;
 941   }
 942   /* Check for out-of-range coefficient values.
 943    * Since we&#39;re encoding a difference, the range limit is twice as much.
 944    */
 945   if (nbits &gt; MAX_COEF_BITS+1)
 946     ERREXIT(state-&gt;cinfo, JERR_BAD_DCT_COEF);
 947 
 948   /* Emit the Huffman-coded symbol for the number of bits */
 949   if (! emit_bits_s(state, dctbl-&gt;ehufco[nbits], dctbl-&gt;ehufsi[nbits]))
 950     return FALSE;
 951 
 952   /* Emit that number of bits of the value, if positive, */
 953   /* or the complement of its magnitude, if negative. */
 954   if (nbits)            /* emit_bits rejects calls with size 0 */
 955     if (! emit_bits_s(state, (unsigned int) temp2, nbits))
 956       return FALSE;
 957 
 958   /* Encode the AC coefficients per section F.1.2.2 */
 959 
 960   r = 0;            /* r = run length of zeros */
 961 
 962   for (k = 1; k &lt;= Se; k++) {
 963     if ((temp2 = block[natural_order[k]]) == 0) {
 964       r++;
 965     } else {
 966       /* if run length &gt; 15, must emit special run-length-16 codes (0xF0) */
 967       while (r &gt; 15) {
 968     if (! emit_bits_s(state, actbl-&gt;ehufco[0xF0], actbl-&gt;ehufsi[0xF0]))
 969       return FALSE;
 970     r -= 16;
 971       }
 972 
 973       temp = temp2;
 974       if (temp &lt; 0) {
 975     temp = -temp;        /* temp is abs value of input */
 976     /* This code assumes we are on a two&#39;s complement machine */
 977     temp2--;
 978       }
 979 
 980       /* Find the number of bits needed for the magnitude of the coefficient */
 981       nbits = 1;        /* there must be at least one 1 bit */
 982       while ((temp &gt;&gt;= 1))
 983     nbits++;
 984       /* Check for out-of-range coefficient values */
 985       if (nbits &gt; MAX_COEF_BITS)
 986     ERREXIT(state-&gt;cinfo, JERR_BAD_DCT_COEF);
 987 
 988       /* Emit Huffman symbol for run length / number of bits */
 989       temp = (r &lt;&lt; 4) + nbits;
 990       if (! emit_bits_s(state, actbl-&gt;ehufco[temp], actbl-&gt;ehufsi[temp]))
 991     return FALSE;
 992 
 993       /* Emit that number of bits of the value, if positive, */
 994       /* or the complement of its magnitude, if negative. */
 995       if (! emit_bits_s(state, (unsigned int) temp2, nbits))
 996     return FALSE;
 997 
 998       r = 0;
 999     }
1000   }
1001 
1002   /* If the last coef(s) were zero, emit an end-of-block code */
1003   if (r &gt; 0)
1004     if (! emit_bits_s(state, actbl-&gt;ehufco[0], actbl-&gt;ehufsi[0]))
1005       return FALSE;
1006 
1007   return TRUE;
1008 }
1009 
1010 
1011 /*
1012  * Encode and output one MCU&#39;s worth of Huffman-compressed coefficients.
1013  */
1014 
1015 METHODDEF(boolean)
1016 encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
1017 {
1018   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1019   working_state state;
1020   int blkn, ci;
1021   jpeg_component_info * compptr;
1022 
1023   /* Load up working state */
1024   state.next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
1025   state.free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
1026   ASSIGN_STATE(state.cur, entropy-&gt;saved);
1027   state.cinfo = cinfo;
1028 
1029   /* Emit restart marker if needed */
1030   if (cinfo-&gt;restart_interval) {
1031     if (entropy-&gt;restarts_to_go == 0)
1032       if (! emit_restart_s(&amp;state, entropy-&gt;next_restart_num))
1033     return FALSE;
1034   }
1035 
1036   /* Encode the MCU data blocks */
1037   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1038     ci = cinfo-&gt;MCU_membership[blkn];
1039     compptr = cinfo-&gt;cur_comp_info[ci];
1040     if (! encode_one_block(&amp;state,
1041                MCU_data[blkn][0], state.cur.last_dc_val[ci],
1042                entropy-&gt;dc_derived_tbls[compptr-&gt;dc_tbl_no],
1043                entropy-&gt;ac_derived_tbls[compptr-&gt;ac_tbl_no]))
1044       return FALSE;
1045     /* Update last_dc_val */
1046     state.cur.last_dc_val[ci] = MCU_data[blkn][0][0];
1047   }
1048 
1049   /* Completed MCU, so update state */
1050   cinfo-&gt;dest-&gt;next_output_byte = state.next_output_byte;
1051   cinfo-&gt;dest-&gt;free_in_buffer = state.free_in_buffer;
1052   ASSIGN_STATE(entropy-&gt;saved, state.cur);
1053 
1054   /* Update restart-interval state too */
1055   if (cinfo-&gt;restart_interval) {
1056     if (entropy-&gt;restarts_to_go == 0) {
1057       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1058       entropy-&gt;next_restart_num++;
1059       entropy-&gt;next_restart_num &amp;= 7;
1060     }
1061     entropy-&gt;restarts_to_go--;
1062   }
1063 
1064   return TRUE;
1065 }
1066 
1067 
1068 /*
1069  * Finish up at the end of a Huffman-compressed scan.
1070  */
1071 
1072 METHODDEF(void)
1073 finish_pass_huff (j_compress_ptr cinfo)
1074 {
1075   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1076   working_state state;
1077 
1078   if (cinfo-&gt;progressive_mode) {
1079     entropy-&gt;next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
1080     entropy-&gt;free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
1081 
1082     /* Flush out any buffered data */
1083     emit_eobrun(entropy);
1084     flush_bits_e(entropy);
1085 
1086     cinfo-&gt;dest-&gt;next_output_byte = entropy-&gt;next_output_byte;
1087     cinfo-&gt;dest-&gt;free_in_buffer = entropy-&gt;free_in_buffer;
1088   } else {
1089     /* Load up working state ... flush_bits needs it */
1090     state.next_output_byte = cinfo-&gt;dest-&gt;next_output_byte;
1091     state.free_in_buffer = cinfo-&gt;dest-&gt;free_in_buffer;
1092     ASSIGN_STATE(state.cur, entropy-&gt;saved);
1093     state.cinfo = cinfo;
1094 
1095     /* Flush out the last data */
1096     if (! flush_bits_s(&amp;state))
1097       ERREXIT(cinfo, JERR_CANT_SUSPEND);
1098 
1099     /* Update state */
1100     cinfo-&gt;dest-&gt;next_output_byte = state.next_output_byte;
1101     cinfo-&gt;dest-&gt;free_in_buffer = state.free_in_buffer;
1102     ASSIGN_STATE(entropy-&gt;saved, state.cur);
1103   }
1104 }
1105 
1106 
1107 /*
1108  * Huffman coding optimization.
1109  *
1110  * We first scan the supplied data and count the number of uses of each symbol
1111  * that is to be Huffman-coded. (This process MUST agree with the code above.)
1112  * Then we build a Huffman coding tree for the observed counts.
1113  * Symbols which are not needed at all for the particular image are not
1114  * assigned any code, which saves space in the DHT marker as well as in
1115  * the compressed data.
1116  */
1117 
1118 
1119 /* Process a single block&#39;s worth of coefficients */
1120 
1121 LOCAL(void)
1122 htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
1123          long dc_counts[], long ac_counts[])
1124 {
1125   register int temp;
1126   register int nbits;
1127   register int r, k;
1128   int Se = cinfo-&gt;lim_Se;
1129   const int * natural_order = cinfo-&gt;natural_order;
1130 
1131   /* Encode the DC coefficient difference per section F.1.2.1 */
1132 
1133   temp = block[0] - last_dc_val;
1134   if (temp &lt; 0)
1135     temp = -temp;
1136 
1137   /* Find the number of bits needed for the magnitude of the coefficient */
1138   nbits = 0;
1139   while (temp) {
1140     nbits++;
1141     temp &gt;&gt;= 1;
1142   }
1143   /* Check for out-of-range coefficient values.
1144    * Since we&#39;re encoding a difference, the range limit is twice as much.
1145    */
1146   if (nbits &gt; MAX_COEF_BITS+1)
1147     ERREXIT(cinfo, JERR_BAD_DCT_COEF);
1148 
1149   /* Count the Huffman symbol for the number of bits */
1150   dc_counts[nbits]++;
1151 
1152   /* Encode the AC coefficients per section F.1.2.2 */
1153 
1154   r = 0;            /* r = run length of zeros */
1155 
1156   for (k = 1; k &lt;= Se; k++) {
1157     if ((temp = block[natural_order[k]]) == 0) {
1158       r++;
1159     } else {
1160       /* if run length &gt; 15, must emit special run-length-16 codes (0xF0) */
1161       while (r &gt; 15) {
1162     ac_counts[0xF0]++;
1163     r -= 16;
1164       }
1165 
1166       /* Find the number of bits needed for the magnitude of the coefficient */
1167       if (temp &lt; 0)
1168     temp = -temp;
1169 
1170       /* Find the number of bits needed for the magnitude of the coefficient */
1171       nbits = 1;        /* there must be at least one 1 bit */
1172       while ((temp &gt;&gt;= 1))
1173     nbits++;
1174       /* Check for out-of-range coefficient values */
1175       if (nbits &gt; MAX_COEF_BITS)
1176     ERREXIT(cinfo, JERR_BAD_DCT_COEF);
1177 
1178       /* Count Huffman symbol for run length / number of bits */
1179       ac_counts[(r &lt;&lt; 4) + nbits]++;
1180 
1181       r = 0;
1182     }
1183   }
1184 
1185   /* If the last coef(s) were zero, emit an end-of-block code */
1186   if (r &gt; 0)
1187     ac_counts[0]++;
1188 }
1189 
1190 
1191 /*
1192  * Trial-encode one MCU&#39;s worth of Huffman-compressed coefficients.
1193  * No data is actually output, so no suspension return is possible.
1194  */
1195 
1196 METHODDEF(boolean)
1197 encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
1198 {
1199   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1200   int blkn, ci;
1201   jpeg_component_info * compptr;
1202 
1203   /* Take care of restart intervals if needed */
1204   if (cinfo-&gt;restart_interval) {
1205     if (entropy-&gt;restarts_to_go == 0) {
1206       /* Re-initialize DC predictions to 0 */
1207       for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++)
1208     entropy-&gt;saved.last_dc_val[ci] = 0;
1209       /* Update restart state */
1210       entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1211     }
1212     entropy-&gt;restarts_to_go--;
1213   }
1214 
1215   for (blkn = 0; blkn &lt; cinfo-&gt;blocks_in_MCU; blkn++) {
1216     ci = cinfo-&gt;MCU_membership[blkn];
1217     compptr = cinfo-&gt;cur_comp_info[ci];
1218     htest_one_block(cinfo, MCU_data[blkn][0], entropy-&gt;saved.last_dc_val[ci],
1219             entropy-&gt;dc_count_ptrs[compptr-&gt;dc_tbl_no],
1220             entropy-&gt;ac_count_ptrs[compptr-&gt;ac_tbl_no]);
1221     entropy-&gt;saved.last_dc_val[ci] = MCU_data[blkn][0][0];
1222   }
1223 
1224   return TRUE;
1225 }
1226 
1227 
1228 /*
1229  * Generate the best Huffman code table for the given counts, fill htbl.
1230  *
1231  * The JPEG standard requires that no symbol be assigned a codeword of all
1232  * one bits (so that padding bits added at the end of a compressed segment
1233  * can&#39;t look like a valid code).  Because of the canonical ordering of
1234  * codewords, this just means that there must be an unused slot in the
1235  * longest codeword length category.  Section K.2 of the JPEG spec suggests
1236  * reserving such a slot by pretending that symbol 256 is a valid symbol
1237  * with count 1.  In theory that&#39;s not optimal; giving it count zero but
1238  * including it in the symbol set anyway should give a better Huffman code.
1239  * But the theoretically better code actually seems to come out worse in
1240  * practice, because it produces more all-ones bytes (which incur stuffed
1241  * zero bytes in the final file).  In any case the difference is tiny.
1242  *
1243  * The JPEG standard requires Huffman codes to be no more than 16 bits long.
1244  * If some symbols have a very small but nonzero probability, the Huffman tree
1245  * must be adjusted to meet the code length restriction.  We currently use
1246  * the adjustment method suggested in JPEG section K.2.  This method is *not*
1247  * optimal; it may not choose the best possible limited-length code.  But
1248  * typically only very-low-frequency symbols will be given less-than-optimal
1249  * lengths, so the code is almost optimal.  Experimental comparisons against
1250  * an optimal limited-length-code algorithm indicate that the difference is
1251  * microscopic --- usually less than a hundredth of a percent of total size.
1252  * So the extra complexity of an optimal algorithm doesn&#39;t seem worthwhile.
1253  */
1254 
1255 LOCAL(void)
1256 jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
1257 {
1258 #define MAX_CLEN 32        /* assumed maximum initial code length */
1259   UINT8 bits[MAX_CLEN+1];    /* bits[k] = # of symbols with code length k */
1260   int codesize[257];        /* codesize[k] = code length of symbol k */
1261   int others[257];        /* next symbol in current branch of tree */
<a name="4" id="anc4"></a><span class="line-modified">1262   int c1, c2, i, j;</span>
<span class="line-modified">1263   UINT8 *p;</span>
1264   long v;
1265 
<a name="5" id="anc5"></a><span class="line-added">1266   freq[256] = 1;        /* make sure 256 has a nonzero count */</span>
<span class="line-added">1267   /* Including the pseudo-symbol 256 in the Huffman procedure guarantees</span>
<span class="line-added">1268    * that no real symbol is given code-value of all ones, because 256</span>
<span class="line-added">1269    * will be placed last in the largest codeword category.</span>
<span class="line-added">1270    * In the symbol list build procedure this element serves as sentinel</span>
<span class="line-added">1271    * for the zero run loop.</span>
<span class="line-added">1272    */</span>
<span class="line-added">1273 </span>
<span class="line-added">1274 #ifndef DONT_USE_FANCY_HUFF_OPT</span>
<span class="line-added">1275 </span>
<span class="line-added">1276   /* Build list of symbols sorted in order of descending frequency */</span>
<span class="line-added">1277   /* This approach has several benefits (thank to John Korejwa for the idea):</span>
<span class="line-added">1278    *     1.</span>
<span class="line-added">1279    * If a codelength category is split during the length limiting procedure</span>
<span class="line-added">1280    * below, the feature that more frequent symbols are assigned shorter</span>
<span class="line-added">1281    * codewords remains valid for the adjusted code.</span>
<span class="line-added">1282    *     2.</span>
<span class="line-added">1283    * To reduce consecutive ones in a Huffman data stream (thus reducing the</span>
<span class="line-added">1284    * number of stuff bytes in JPEG) it is preferable to follow 0 branches</span>
<span class="line-added">1285    * (and avoid 1 branches) as much as possible.  This is easily done by</span>
<span class="line-added">1286    * assigning symbols to leaves of the Huffman tree in order of decreasing</span>
<span class="line-added">1287    * frequency, with no secondary sort based on codelengths.</span>
<span class="line-added">1288    *     3.</span>
<span class="line-added">1289    * The symbol list can be built independently from the assignment of code</span>
<span class="line-added">1290    * lengths by the Huffman procedure below.</span>
<span class="line-added">1291    * Note: The symbol list build procedure must be performed first, because</span>
<span class="line-added">1292    * the Huffman procedure assigning the codelengths clobbers the frequency</span>
<span class="line-added">1293    * counts!</span>
<span class="line-added">1294    */</span>
<span class="line-added">1295 </span>
<span class="line-added">1296   /* Here we use the others array as a linked list of nonzero frequencies</span>
<span class="line-added">1297    * to be sorted.  Already sorted elements are removed from the list.</span>
<span class="line-added">1298    */</span>
<span class="line-added">1299 </span>
<span class="line-added">1300   /* Building list */</span>
<span class="line-added">1301 </span>
<span class="line-added">1302   /* This item does not correspond to a valid symbol frequency and is used</span>
<span class="line-added">1303    * as starting index.</span>
<span class="line-added">1304    */</span>
<span class="line-added">1305   j = 256;</span>
<span class="line-added">1306 </span>
<span class="line-added">1307   for (i = 0;; i++) {</span>
<span class="line-added">1308     if (freq[i] == 0)        /* skip zero frequencies */</span>
<span class="line-added">1309       continue;</span>
<span class="line-added">1310     if (i &gt; 255)</span>
<span class="line-added">1311       break;</span>
<span class="line-added">1312     others[j] = i;        /* this symbol value */</span>
<span class="line-added">1313     j = i;            /* previous symbol value */</span>
<span class="line-added">1314   }</span>
<span class="line-added">1315   others[j] = -1;        /* mark end of list */</span>
<span class="line-added">1316 </span>
<span class="line-added">1317   /* Sorting list */</span>
<span class="line-added">1318 </span>
<span class="line-added">1319   p = htbl-&gt;huffval;</span>
<span class="line-added">1320   while ((c1 = others[256]) &gt;= 0) {</span>
<span class="line-added">1321     v = freq[c1];</span>
<span class="line-added">1322     i = c1;            /* first symbol value */</span>
<span class="line-added">1323     j = 256;            /* pseudo symbol value for starting index */</span>
<span class="line-added">1324     while ((c2 = others[c1]) &gt;= 0) {</span>
<span class="line-added">1325       if (freq[c2] &gt; v) {</span>
<span class="line-added">1326     v = freq[c2];</span>
<span class="line-added">1327     i = c2;            /* this symbol value */</span>
<span class="line-added">1328     j = c1;            /* previous symbol value */</span>
<span class="line-added">1329       }</span>
<span class="line-added">1330       c1 = c2;</span>
<span class="line-added">1331     }</span>
<span class="line-added">1332     others[j] = others[i];    /* remove this symbol i from list */</span>
<span class="line-added">1333     *p++ = (UINT8) i;</span>
<span class="line-added">1334   }</span>
<span class="line-added">1335 </span>
<span class="line-added">1336 #endif /* DONT_USE_FANCY_HUFF_OPT */</span>
<span class="line-added">1337 </span>
1338   /* This algorithm is explained in section K.2 of the JPEG standard */
1339 
1340   MEMZERO(bits, SIZEOF(bits));
1341   MEMZERO(codesize, SIZEOF(codesize));
1342   for (i = 0; i &lt; 257; i++)
1343     others[i] = -1;        /* init links to empty */
1344 
<a name="6" id="anc6"></a>





1345   /* Huffman&#39;s basic algorithm to assign optimal code lengths to symbols */
1346 
1347   for (;;) {
1348     /* Find the smallest nonzero frequency, set c1 = its symbol */
1349     /* In case of ties, take the larger symbol number */
1350     c1 = -1;
1351     v = 1000000000L;
1352     for (i = 0; i &lt;= 256; i++) {
1353       if (freq[i] &amp;&amp; freq[i] &lt;= v) {
1354     v = freq[i];
1355     c1 = i;
1356       }
1357     }
1358 
1359     /* Find the next smallest nonzero frequency, set c2 = its symbol */
1360     /* In case of ties, take the larger symbol number */
1361     c2 = -1;
1362     v = 1000000000L;
1363     for (i = 0; i &lt;= 256; i++) {
1364       if (freq[i] &amp;&amp; freq[i] &lt;= v &amp;&amp; i != c1) {
1365     v = freq[i];
1366     c2 = i;
1367       }
1368     }
1369 
1370     /* Done if we&#39;ve merged everything into one frequency */
1371     if (c2 &lt; 0)
1372       break;
1373 
1374     /* Else merge the two counts/trees */
1375     freq[c1] += freq[c2];
1376     freq[c2] = 0;
1377 
1378     /* Increment the codesize of everything in c1&#39;s tree branch */
1379     codesize[c1]++;
1380     while (others[c1] &gt;= 0) {
1381       c1 = others[c1];
1382       codesize[c1]++;
1383     }
1384 
1385     others[c1] = c2;        /* chain c2 onto c1&#39;s tree branch */
1386 
1387     /* Increment the codesize of everything in c2&#39;s tree branch */
1388     codesize[c2]++;
1389     while (others[c2] &gt;= 0) {
1390       c2 = others[c2];
1391       codesize[c2]++;
1392     }
1393   }
1394 
1395   /* Now count the number of symbols of each code length */
1396   for (i = 0; i &lt;= 256; i++) {
1397     if (codesize[i]) {
1398       /* The JPEG standard seems to think that this can&#39;t happen, */
1399       /* but I&#39;m paranoid... */
1400       if (codesize[i] &gt; MAX_CLEN)
<a name="7" id="anc7"></a><span class="line-modified">1401     ERREXIT(cinfo, JERR_HUFF_CLEN_OUTOFBOUNDS);</span>
1402 
1403       bits[codesize[i]]++;
1404     }
1405   }
1406 
1407   /* JPEG doesn&#39;t allow symbols with code lengths over 16 bits, so if the pure
1408    * Huffman procedure assigned any such lengths, we must adjust the coding.
1409    * Here is what the JPEG spec says about how this next bit works:
1410    * Since symbols are paired for the longest Huffman code, the symbols are
1411    * removed from this length category two at a time.  The prefix for the pair
1412    * (which is one bit shorter) is allocated to one of the pair; then,
1413    * skipping the BITS entry for that prefix length, a code word from the next
1414    * shortest nonzero BITS entry is converted into a prefix for two code words
1415    * one bit longer.
1416    */
1417 
1418   for (i = MAX_CLEN; i &gt; 16; i--) {
1419     while (bits[i] &gt; 0) {
1420       j = i - 2;        /* find length of new prefix to be used */
<a name="8" id="anc8"></a><span class="line-modified">1421       while (bits[j] == 0) {</span>
<span class="line-added">1422     if (j == 0)</span>
<span class="line-added">1423       ERREXIT(cinfo, JERR_HUFF_CLEN_OUTOFBOUNDS);</span>
1424     j--;
<a name="9" id="anc9"></a><span class="line-added">1425       }</span>
1426 
1427       bits[i] -= 2;        /* remove two symbols */
1428       bits[i-1]++;        /* one goes in this length */
1429       bits[j+1] += 2;        /* two new symbols in this length */
1430       bits[j]--;        /* symbol of this length is now a prefix */
1431     }
1432   }
1433 
1434   /* Remove the count for the pseudo-symbol 256 from the largest codelength */
1435   while (bits[i] == 0)        /* find largest codelength still in use */
1436     i--;
1437   bits[i]--;
1438 
1439   /* Return final symbol counts (only for lengths 0..16) */
1440   MEMCOPY(htbl-&gt;bits, bits, SIZEOF(htbl-&gt;bits));
1441 
<a name="10" id="anc10"></a><span class="line-added">1442 #ifdef DONT_USE_FANCY_HUFF_OPT</span>
<span class="line-added">1443 </span>
1444   /* Return a list of the symbols sorted by code length */
<a name="11" id="anc11"></a><span class="line-modified">1445   /* Note: Due to the codelength changes made above, it can happen</span>
<span class="line-modified">1446    * that more frequent symbols are assigned longer codewords.</span>
1447    */
<a name="12" id="anc12"></a><span class="line-modified">1448   p = htbl-&gt;huffval;</span>
1449   for (i = 1; i &lt;= MAX_CLEN; i++) {
1450     for (j = 0; j &lt;= 255; j++) {
1451       if (codesize[j] == i) {
<a name="13" id="anc13"></a><span class="line-modified">1452     *p++ = (UINT8) j;</span>

1453       }
1454     }
1455   }
1456 
<a name="14" id="anc14"></a><span class="line-added">1457 #endif /* DONT_USE_FANCY_HUFF_OPT */</span>
<span class="line-added">1458 </span>
1459   /* Set sent_table FALSE so updated table will be written to JPEG file. */
1460   htbl-&gt;sent_table = FALSE;
1461 }
1462 
1463 
1464 /*
1465  * Finish up a statistics-gathering pass and create the new Huffman tables.
1466  */
1467 
1468 METHODDEF(void)
1469 finish_pass_gather (j_compress_ptr cinfo)
1470 {
1471   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1472   int ci, tbl;
1473   jpeg_component_info * compptr;
1474   JHUFF_TBL **htblptr;
1475   boolean did_dc[NUM_HUFF_TBLS];
1476   boolean did_ac[NUM_HUFF_TBLS];
1477 
<a name="15" id="anc15"></a>


1478   if (cinfo-&gt;progressive_mode)
1479     /* Flush out buffered data (all we care about is counting the EOB symbol) */
1480     emit_eobrun(entropy);
1481 
<a name="16" id="anc16"></a><span class="line-added">1482   /* It&#39;s important not to apply jpeg_gen_optimal_table more than once</span>
<span class="line-added">1483    * per table, because it clobbers the input frequency counts!</span>
<span class="line-added">1484    */</span>
1485   MEMZERO(did_dc, SIZEOF(did_dc));
1486   MEMZERO(did_ac, SIZEOF(did_ac));
1487 
1488   for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1489     compptr = cinfo-&gt;cur_comp_info[ci];
1490     /* DC needs no table for refinement scan */
1491     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0) {
1492       tbl = compptr-&gt;dc_tbl_no;
1493       if (! did_dc[tbl]) {
1494     htblptr = &amp; cinfo-&gt;dc_huff_tbl_ptrs[tbl];
1495     if (*htblptr == NULL)
1496       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
1497     jpeg_gen_optimal_table(cinfo, *htblptr, entropy-&gt;dc_count_ptrs[tbl]);
1498     did_dc[tbl] = TRUE;
1499       }
1500     }
1501     /* AC needs no table when not present */
1502     if (cinfo-&gt;Se) {
1503       tbl = compptr-&gt;ac_tbl_no;
1504       if (! did_ac[tbl]) {
1505     htblptr = &amp; cinfo-&gt;ac_huff_tbl_ptrs[tbl];
1506     if (*htblptr == NULL)
1507       *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
1508     jpeg_gen_optimal_table(cinfo, *htblptr, entropy-&gt;ac_count_ptrs[tbl]);
1509     did_ac[tbl] = TRUE;
1510       }
1511     }
1512   }
1513 }
1514 
1515 
1516 /*
1517  * Initialize for a Huffman-compressed scan.
1518  * If gather_statistics is TRUE, we do not output anything during the scan,
1519  * just count the Huffman symbols used and generate Huffman code tables.
1520  */
1521 
1522 METHODDEF(void)
1523 start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
1524 {
1525   huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo-&gt;entropy;
1526   int ci, tbl;
1527   jpeg_component_info * compptr;
1528 
1529   if (gather_statistics)
1530     entropy-&gt;pub.finish_pass = finish_pass_gather;
1531   else
1532     entropy-&gt;pub.finish_pass = finish_pass_huff;
1533 
1534   if (cinfo-&gt;progressive_mode) {
1535     entropy-&gt;cinfo = cinfo;
1536     entropy-&gt;gather_statistics = gather_statistics;
1537 
1538     /* We assume jcmaster.c already validated the scan parameters. */
1539 
1540     /* Select execution routine */
1541     if (cinfo-&gt;Ah == 0) {
1542       if (cinfo-&gt;Ss == 0)
1543     entropy-&gt;pub.encode_mcu = encode_mcu_DC_first;
1544       else
1545     entropy-&gt;pub.encode_mcu = encode_mcu_AC_first;
1546     } else {
1547       if (cinfo-&gt;Ss == 0)
1548     entropy-&gt;pub.encode_mcu = encode_mcu_DC_refine;
1549       else {
1550     entropy-&gt;pub.encode_mcu = encode_mcu_AC_refine;
1551     /* AC refinement needs a correction bit buffer */
1552     if (entropy-&gt;bit_buffer == NULL)
<a name="17" id="anc17"></a><span class="line-modified">1553       entropy-&gt;bit_buffer = (char *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1554         ((j_common_ptr) cinfo, JPOOL_IMAGE, MAX_CORR_BITS * SIZEOF(char));</span>

1555       }
1556     }
1557 
1558     /* Initialize AC stuff */
1559     entropy-&gt;ac_tbl_no = cinfo-&gt;cur_comp_info[0]-&gt;ac_tbl_no;
1560     entropy-&gt;EOBRUN = 0;
1561     entropy-&gt;BE = 0;
1562   } else {
1563     if (gather_statistics)
1564       entropy-&gt;pub.encode_mcu = encode_mcu_gather;
1565     else
1566       entropy-&gt;pub.encode_mcu = encode_mcu_huff;
1567   }
1568 
1569   for (ci = 0; ci &lt; cinfo-&gt;comps_in_scan; ci++) {
1570     compptr = cinfo-&gt;cur_comp_info[ci];
1571     /* DC needs no table for refinement scan */
1572     if (cinfo-&gt;Ss == 0 &amp;&amp; cinfo-&gt;Ah == 0) {
1573       tbl = compptr-&gt;dc_tbl_no;
1574       if (gather_statistics) {
1575     /* Check for invalid table index */
1576     /* (make_c_derived_tbl does this in the other path) */
1577     if (tbl &lt; 0 || tbl &gt;= NUM_HUFF_TBLS)
1578       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
1579     /* Allocate and zero the statistics tables */
1580     /* Note that jpeg_gen_optimal_table expects 257 entries in each table! */
1581     if (entropy-&gt;dc_count_ptrs[tbl] == NULL)
<a name="18" id="anc18"></a><span class="line-modified">1582       entropy-&gt;dc_count_ptrs[tbl] = (long *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1583         ((j_common_ptr) cinfo, JPOOL_IMAGE, 257 * SIZEOF(long));</span>

1584     MEMZERO(entropy-&gt;dc_count_ptrs[tbl], 257 * SIZEOF(long));
1585       } else {
1586     /* Compute derived values for Huffman tables */
1587     /* We may do this more than once for a table, but it&#39;s not expensive */
1588     jpeg_make_c_derived_tbl(cinfo, TRUE, tbl,
1589                 &amp; entropy-&gt;dc_derived_tbls[tbl]);
1590       }
1591       /* Initialize DC predictions to 0 */
1592       entropy-&gt;saved.last_dc_val[ci] = 0;
1593     }
1594     /* AC needs no table when not present */
1595     if (cinfo-&gt;Se) {
1596       tbl = compptr-&gt;ac_tbl_no;
1597       if (gather_statistics) {
1598     if (tbl &lt; 0 || tbl &gt;= NUM_HUFF_TBLS)
1599       ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tbl);
1600     if (entropy-&gt;ac_count_ptrs[tbl] == NULL)
<a name="19" id="anc19"></a><span class="line-modified">1601       entropy-&gt;ac_count_ptrs[tbl] = (long *) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1602         ((j_common_ptr) cinfo, JPOOL_IMAGE, 257 * SIZEOF(long));</span>

1603     MEMZERO(entropy-&gt;ac_count_ptrs[tbl], 257 * SIZEOF(long));
1604       } else {
1605     jpeg_make_c_derived_tbl(cinfo, FALSE, tbl,
1606                 &amp; entropy-&gt;ac_derived_tbls[tbl]);
1607       }
1608     }
1609   }
1610 
1611   /* Initialize bit buffer to empty */
1612   entropy-&gt;saved.put_buffer = 0;
1613   entropy-&gt;saved.put_bits = 0;
1614 
1615   /* Initialize restart stuff */
1616   entropy-&gt;restarts_to_go = cinfo-&gt;restart_interval;
1617   entropy-&gt;next_restart_num = 0;
1618 }
1619 
1620 
1621 /*
1622  * Module initialization routine for Huffman entropy encoding.
1623  */
1624 
1625 GLOBAL(void)
1626 jinit_huff_encoder (j_compress_ptr cinfo)
1627 {
1628   huff_entropy_ptr entropy;
1629   int i;
1630 
<a name="20" id="anc20"></a><span class="line-modified">1631   entropy = (huff_entropy_ptr) (*cinfo-&gt;mem-&gt;alloc_small)</span>
<span class="line-modified">1632     ((j_common_ptr) cinfo, JPOOL_IMAGE, SIZEOF(huff_entropy_encoder));</span>

1633   cinfo-&gt;entropy = &amp;entropy-&gt;pub;
1634   entropy-&gt;pub.start_pass = start_pass_huff;
1635 
1636   /* Mark tables unallocated */
1637   for (i = 0; i &lt; NUM_HUFF_TBLS; i++) {
1638     entropy-&gt;dc_derived_tbls[i] = entropy-&gt;ac_derived_tbls[i] = NULL;
1639     entropy-&gt;dc_count_ptrs[i] = entropy-&gt;ac_count_ptrs[i] = NULL;
1640   }
1641 
1642   if (cinfo-&gt;progressive_mode)
1643     entropy-&gt;bit_buffer = NULL;    /* needed only in AC refinement scan */
1644 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
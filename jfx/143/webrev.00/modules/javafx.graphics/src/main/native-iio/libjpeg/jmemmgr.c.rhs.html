<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * jmemmgr.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<a name="1" id="anc1"></a><span class="line-modified">   5  * Modified 2011-2019 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains the JPEG system-independent memory management
  10  * routines.  This code is usable across a wide variety of machines; most
  11  * of the system dependencies have been isolated in a separate file.
  12  * The major functions provided here are:
  13  *   * pool-based allocation and freeing of memory;
  14  *   * policy decisions about how to divide available memory among the
  15  *     virtual arrays;
  16  *   * control logic for swapping virtual arrays between main memory and
  17  *     backing storage.
  18  * The separate system-dependent file provides the actual backing-storage
  19  * access code, and it contains the policy decision about how much total
  20  * main memory to use.
  21  * This file is system-dependent in the sense that some of its functions
  22  * are unnecessary in some systems.  For example, if there is enough virtual
  23  * memory so that backing storage will never be used, much of the virtual
  24  * array control logic could be removed.  (Of course, if you have that much
  25  * memory then you shouldn&#39;t care about a little bit of unused code...)
  26  */
  27 
  28 #define JPEG_INTERNALS
  29 #define AM_MEMORY_MANAGER    /* we define jvirt_Xarray_control structs */
  30 #include &quot;jinclude.h&quot;
  31 #include &quot;jpeglib.h&quot;
  32 #include &quot;jmemsys.h&quot;        /* import the system-dependent declarations */
  33 
  34 #ifndef NO_GETENV
  35 #ifndef HAVE_STDLIB_H        /* &lt;stdlib.h&gt; should declare getenv() */
  36 extern char * getenv JPP((const char * name));
  37 #endif
  38 #endif
  39 
  40 
  41 /*
  42  * Some important notes:
  43  *   The allocation routines provided here must never return NULL.
  44  *   They should exit to error_exit if unsuccessful.
  45  *
  46  *   It&#39;s not a good idea to try to merge the sarray and barray routines,
  47  *   even though they are textually almost the same, because samples are
  48  *   usually stored as bytes while coefficients are shorts or ints.  Thus,
  49  *   in machines where byte pointers have a different representation from
  50  *   word pointers, the resulting machine code could not be the same.
  51  */
  52 
  53 
  54 /*
  55  * Many machines require storage alignment: longs must start on 4-byte
  56  * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
  57  * always returns pointers that are multiples of the worst-case alignment
  58  * requirement, and we had better do so too.
  59  * There isn&#39;t any really portable way to determine the worst-case alignment
  60  * requirement.  This module assumes that the alignment requirement is
  61  * multiples of sizeof(ALIGN_TYPE).
  62  * By default, we define ALIGN_TYPE as double.  This is necessary on some
  63  * workstations (where doubles really do need 8-byte alignment) and will work
  64  * fine on nearly everything.  If your machine has lesser alignment needs,
  65  * you can save a few bytes by making ALIGN_TYPE smaller.
  66  * The only place I know of where this will NOT work is certain Macintosh
  67  * 680x0 compilers that define double as a 10-byte IEEE extended float.
  68  * Doing 10-byte alignment is counterproductive because longwords won&#39;t be
  69  * aligned well.  Put &quot;#define ALIGN_TYPE long&quot; in jconfig.h if you have
  70  * such a compiler.
  71  */
  72 
  73 #ifndef ALIGN_TYPE        /* so can override from jconfig.h */
  74 #define ALIGN_TYPE  double
  75 #endif
  76 
  77 
  78 /*
  79  * We allocate objects from &quot;pools&quot;, where each pool is gotten with a single
  80  * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
  81  * overhead within a pool, except for alignment padding.  Each pool has a
  82  * header with a link to the next pool of the same class.
  83  * Small and large pool headers are identical except that the latter&#39;s
  84  * link pointer must be FAR on 80x86 machines.
  85  * Notice that the &quot;real&quot; header fields are union&#39;ed with a dummy ALIGN_TYPE
  86  * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
  87  * of the alignment requirement of ALIGN_TYPE.
  88  */
  89 
  90 typedef union small_pool_struct * small_pool_ptr;
  91 
  92 typedef union small_pool_struct {
  93   struct {
  94     small_pool_ptr next;    /* next in list of pools */
  95     size_t bytes_used;        /* how many bytes already used within pool */
  96     size_t bytes_left;        /* bytes still available in this pool */
  97   } hdr;
  98   ALIGN_TYPE dummy;        /* included in union to ensure alignment */
  99 } small_pool_hdr;
 100 
 101 typedef union large_pool_struct FAR * large_pool_ptr;
 102 
 103 typedef union large_pool_struct {
 104   struct {
 105     large_pool_ptr next;    /* next in list of pools */
 106     size_t bytes_used;        /* how many bytes already used within pool */
 107     size_t bytes_left;        /* bytes still available in this pool */
 108   } hdr;
 109   ALIGN_TYPE dummy;        /* included in union to ensure alignment */
 110 } large_pool_hdr;
 111 
 112 
 113 /*
 114  * Here is the full definition of a memory manager object.
 115  */
 116 
 117 typedef struct {
 118   struct jpeg_memory_mgr pub;    /* public fields */
 119 
 120   /* Each pool identifier (lifetime class) names a linked list of pools. */
 121   small_pool_ptr small_list[JPOOL_NUMPOOLS];
 122   large_pool_ptr large_list[JPOOL_NUMPOOLS];
 123 
 124   /* Since we only have one lifetime class of virtual arrays, only one
 125    * linked list is necessary (for each datatype).  Note that the virtual
 126    * array control blocks being linked together are actually stored somewhere
 127    * in the small-pool list.
 128    */
 129   jvirt_sarray_ptr virt_sarray_list;
 130   jvirt_barray_ptr virt_barray_list;
 131 
 132   /* This counts total space obtained from jpeg_get_small/large */
<a name="2" id="anc2"></a><span class="line-modified"> 133   size_t total_space_allocated;</span>
 134 
 135   /* alloc_sarray and alloc_barray set this value for use by virtual
 136    * array routines.
 137    */
 138   JDIMENSION last_rowsperchunk;    /* from most recent alloc_sarray/barray */
 139 } my_memory_mgr;
 140 
 141 typedef my_memory_mgr * my_mem_ptr;
 142 
 143 
 144 /*
 145  * The control blocks for virtual arrays.
 146  * Note that these blocks are allocated in the &quot;small&quot; pool area.
 147  * System-dependent info for the associated backing store (if any) is hidden
 148  * inside the backing_store_info struct.
 149  */
 150 
 151 struct jvirt_sarray_control {
 152   JSAMPARRAY mem_buffer;    /* =&gt; the in-memory buffer */
 153   JDIMENSION rows_in_array;    /* total virtual array height */
 154   JDIMENSION samplesperrow;    /* width of array (and of memory buffer) */
 155   JDIMENSION maxaccess;        /* max rows accessed by access_virt_sarray */
 156   JDIMENSION rows_in_mem;    /* height of memory buffer */
 157   JDIMENSION rowsperchunk;    /* allocation chunk size in mem_buffer */
 158   JDIMENSION cur_start_row;    /* first logical row # in the buffer */
 159   JDIMENSION first_undef_row;    /* row # of first uninitialized row */
 160   boolean pre_zero;        /* pre-zero mode requested? */
 161   boolean dirty;        /* do current buffer contents need written? */
 162   boolean b_s_open;        /* is backing-store data valid? */
 163   jvirt_sarray_ptr next;    /* link to next virtual sarray control block */
 164   backing_store_info b_s_info;    /* System-dependent control info */
 165 };
 166 
 167 struct jvirt_barray_control {
 168   JBLOCKARRAY mem_buffer;    /* =&gt; the in-memory buffer */
 169   JDIMENSION rows_in_array;    /* total virtual array height */
 170   JDIMENSION blocksperrow;    /* width of array (and of memory buffer) */
 171   JDIMENSION maxaccess;        /* max rows accessed by access_virt_barray */
 172   JDIMENSION rows_in_mem;    /* height of memory buffer */
 173   JDIMENSION rowsperchunk;    /* allocation chunk size in mem_buffer */
 174   JDIMENSION cur_start_row;    /* first logical row # in the buffer */
 175   JDIMENSION first_undef_row;    /* row # of first uninitialized row */
 176   boolean pre_zero;        /* pre-zero mode requested? */
 177   boolean dirty;        /* do current buffer contents need written? */
 178   boolean b_s_open;        /* is backing-store data valid? */
 179   jvirt_barray_ptr next;    /* link to next virtual barray control block */
 180   backing_store_info b_s_info;    /* System-dependent control info */
 181 };
 182 
 183 
 184 #ifdef MEM_STATS        /* optional extra stuff for statistics */
 185 
 186 LOCAL(void)
 187 print_mem_stats (j_common_ptr cinfo, int pool_id)
 188 {
 189   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 190   small_pool_ptr shdr_ptr;
 191   large_pool_ptr lhdr_ptr;
 192 
 193   /* Since this is only a debugging stub, we can cheat a little by using
 194    * fprintf directly rather than going through the trace message code.
 195    * This is helpful because message parm array can&#39;t handle longs.
 196    */
 197   fprintf(stderr, &quot;Freeing pool %d, total space = %ld\n&quot;,
<a name="3" id="anc3"></a><span class="line-modified"> 198       pool_id, (long) mem-&gt;total_space_allocated);</span>
 199 
 200   for (lhdr_ptr = mem-&gt;large_list[pool_id]; lhdr_ptr != NULL;
 201        lhdr_ptr = lhdr_ptr-&gt;hdr.next) {
 202     fprintf(stderr, &quot;  Large chunk used %ld\n&quot;,
 203         (long) lhdr_ptr-&gt;hdr.bytes_used);
 204   }
 205 
 206   for (shdr_ptr = mem-&gt;small_list[pool_id]; shdr_ptr != NULL;
 207        shdr_ptr = shdr_ptr-&gt;hdr.next) {
 208     fprintf(stderr, &quot;  Small chunk used %ld free %ld\n&quot;,
 209         (long) shdr_ptr-&gt;hdr.bytes_used,
 210         (long) shdr_ptr-&gt;hdr.bytes_left);
 211   }
 212 }
 213 
 214 #endif /* MEM_STATS */
 215 
 216 
 217 LOCAL(noreturn_t)
 218 out_of_memory (j_common_ptr cinfo, int which)
 219 /* Report an out-of-memory error and stop execution */
 220 /* If we compiled MEM_STATS support, report alloc requests before dying */
 221 {
 222 #ifdef MEM_STATS
 223   cinfo-&gt;err-&gt;trace_level = 2;    /* force self_destruct to report stats */
 224 #endif
 225   ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
 226 }
 227 
 228 
 229 /*
 230  * Allocation of &quot;small&quot; objects.
 231  *
 232  * For these, we use pooled storage.  When a new pool must be created,
 233  * we try to get enough space for the current request plus a &quot;slop&quot; factor,
 234  * where the slop will be the amount of leftover space in the new pool.
 235  * The speed vs. space tradeoff is largely determined by the slop values.
 236  * A different slop value is provided for each pool class (lifetime),
 237  * and we also distinguish the first pool of a class from later ones.
 238  * NOTE: the values given work fairly well on both 16- and 32-bit-int
 239  * machines, but may be too small if longs are 64 bits or more.
 240  */
 241 
 242 static const size_t first_pool_slop[JPOOL_NUMPOOLS] =
 243 {
 244     1600,            /* first PERMANENT pool */
 245     16000            /* first IMAGE pool */
 246 };
 247 
 248 static const size_t extra_pool_slop[JPOOL_NUMPOOLS] =
 249 {
 250     0,            /* additional PERMANENT pools */
 251     5000            /* additional IMAGE pools */
 252 };
 253 
 254 #define MIN_SLOP  50        /* greater than 0 to avoid futile looping */
 255 
 256 
 257 METHODDEF(void *)
 258 alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 259 /* Allocate a &quot;small&quot; object */
 260 {
 261   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 262   small_pool_ptr hdr_ptr, prev_hdr_ptr;
<a name="4" id="anc4"></a>
 263   size_t odd_bytes, min_request, slop;
<a name="5" id="anc5"></a><span class="line-added"> 264   char * data_ptr;</span>
 265 
 266   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<a name="6" id="anc6"></a><span class="line-modified"> 267   if (sizeofobject &gt; (size_t) MAX_ALLOC_CHUNK - SIZEOF(small_pool_hdr))</span>
 268     out_of_memory(cinfo, 1);    /* request exceeds malloc&#39;s ability */
 269 
 270   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 271   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 272   if (odd_bytes &gt; 0)
 273     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 274 
 275   /* See if space is available in any existing pool */
 276   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 277     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 278   prev_hdr_ptr = NULL;
 279   hdr_ptr = mem-&gt;small_list[pool_id];
 280   while (hdr_ptr != NULL) {
 281     if (hdr_ptr-&gt;hdr.bytes_left &gt;= sizeofobject)
 282       break;            /* found pool with enough space */
 283     prev_hdr_ptr = hdr_ptr;
 284     hdr_ptr = hdr_ptr-&gt;hdr.next;
 285   }
 286 
 287   /* Time to make a new pool? */
 288   if (hdr_ptr == NULL) {
 289     /* min_request is what we need now, slop is what will be leftover */
 290     min_request = sizeofobject + SIZEOF(small_pool_hdr);
 291     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 292       slop = first_pool_slop[pool_id];
 293     else
 294       slop = extra_pool_slop[pool_id];
 295     /* Don&#39;t ask for more than MAX_ALLOC_CHUNK */
<a name="7" id="anc7"></a><span class="line-modified"> 296     if (slop &gt; (size_t) MAX_ALLOC_CHUNK - min_request)</span>
<span class="line-modified"> 297       slop = (size_t) MAX_ALLOC_CHUNK - min_request;</span>
 298     /* Try to get space, if fail reduce slop and try again */
 299     for (;;) {
 300       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 301       if (hdr_ptr != NULL)
 302     break;
 303       slop /= 2;
 304       if (slop &lt; MIN_SLOP)    /* give up when it gets real small */
 305     out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 306     }
 307     mem-&gt;total_space_allocated += min_request + slop;
 308     /* Success, initialize the new pool header and add to end of list */
 309     hdr_ptr-&gt;hdr.next = NULL;
 310     hdr_ptr-&gt;hdr.bytes_used = 0;
 311     hdr_ptr-&gt;hdr.bytes_left = sizeofobject + slop;
 312     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 313       mem-&gt;small_list[pool_id] = hdr_ptr;
 314     else
 315       prev_hdr_ptr-&gt;hdr.next = hdr_ptr;
 316   }
 317 
 318   /* OK, allocate the object from the current pool */
 319   data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
 320   data_ptr += hdr_ptr-&gt;hdr.bytes_used; /* point to place for object */
 321   hdr_ptr-&gt;hdr.bytes_used += sizeofobject;
 322   hdr_ptr-&gt;hdr.bytes_left -= sizeofobject;
 323 
 324   return (void *) data_ptr;
 325 }
 326 
 327 
 328 /*
 329  * Allocation of &quot;large&quot; objects.
 330  *
 331  * The external semantics of these are the same as &quot;small&quot; objects,
 332  * except that FAR pointers are used on 80x86.  However the pool
 333  * management heuristics are quite different.  We assume that each
 334  * request is large enough that it may as well be passed directly to
 335  * jpeg_get_large; the pool management just links everything together
 336  * so that we can free it all on demand.
 337  * Note: the major use of &quot;large&quot; objects is in JSAMPARRAY and JBLOCKARRAY
 338  * structures.  The routines that create these structures (see below)
 339  * deliberately bunch rows together to ensure a large request size.
 340  */
 341 
 342 METHODDEF(void FAR *)
 343 alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 344 /* Allocate a &quot;large&quot; object */
 345 {
 346   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 347   large_pool_ptr hdr_ptr;
 348   size_t odd_bytes;
 349 
 350   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<a name="8" id="anc8"></a><span class="line-modified"> 351   if (sizeofobject &gt; (size_t) MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr))</span>
 352     out_of_memory(cinfo, 3);    /* request exceeds malloc&#39;s ability */
 353 
 354   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 355   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 356   if (odd_bytes &gt; 0)
 357     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 358 
 359   /* Always make a new pool */
 360   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 361     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 362 
 363   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 364                         SIZEOF(large_pool_hdr));
 365   if (hdr_ptr == NULL)
 366     out_of_memory(cinfo, 4);    /* jpeg_get_large failed */
 367   mem-&gt;total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 368 
 369   /* Success, initialize the new pool header and add to list */
 370   hdr_ptr-&gt;hdr.next = mem-&gt;large_list[pool_id];
 371   /* We maintain space counts in each pool header for statistical purposes,
 372    * even though they are not needed for allocation.
 373    */
 374   hdr_ptr-&gt;hdr.bytes_used = sizeofobject;
 375   hdr_ptr-&gt;hdr.bytes_left = 0;
 376   mem-&gt;large_list[pool_id] = hdr_ptr;
 377 
 378   return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
 379 }
 380 
 381 
 382 /*
 383  * Creation of 2-D sample arrays.
 384  * The pointers are in near heap, the samples themselves in FAR heap.
 385  *
 386  * To minimize allocation overhead and to allow I/O of large contiguous
 387  * blocks, we allocate the sample rows in groups of as many rows as possible
 388  * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
 389  * NB: the virtual array control routines, later in this file, know about
 390  * this chunking of rows.  The rowsperchunk value is left in the mem manager
 391  * object so that it can be saved away if this sarray is the workspace for
 392  * a virtual array.
 393  */
 394 
 395 METHODDEF(JSAMPARRAY)
 396 alloc_sarray (j_common_ptr cinfo, int pool_id,
 397           JDIMENSION samplesperrow, JDIMENSION numrows)
 398 /* Allocate a 2-D sample array */
 399 {
 400   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 401   JSAMPARRAY result;
 402   JSAMPROW workspace;
 403   JDIMENSION rowsperchunk, currow, i;
 404   long ltemp;
 405 
 406   if (samplesperrow == 0) {
 407     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 408   }
 409 
 410   /* Calculate max # of rows allowed in one allocation chunk */
<a name="9" id="anc9"></a><span class="line-modified"> 411   ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /</span>
 412       ((long) samplesperrow * SIZEOF(JSAMPLE));
 413   if (ltemp &lt;= 0)
 414     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 415   if (ltemp &lt; (long) numrows)
 416     rowsperchunk = (JDIMENSION) ltemp;
 417   else
 418     rowsperchunk = numrows;
 419   mem-&gt;last_rowsperchunk = rowsperchunk;
 420 
 421   /* Get space for row pointers (small object) */
 422   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
<a name="10" id="anc10"></a><span class="line-modified"> 423                     (size_t) numrows * SIZEOF(JSAMPROW));</span>
 424 
 425   /* Get the rows themselves (large objects) */
 426   currow = 0;
 427   while (currow &lt; numrows) {
 428     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 429     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
<a name="11" id="anc11"></a><span class="line-modified"> 430       (size_t) rowsperchunk * (size_t) samplesperrow * SIZEOF(JSAMPLE));</span>

 431     for (i = rowsperchunk; i &gt; 0; i--) {
 432       result[currow++] = workspace;
 433       workspace += samplesperrow;
 434     }
 435   }
 436 
 437   return result;
 438 }
 439 
 440 
 441 /*
 442  * Creation of 2-D coefficient-block arrays.
 443  * This is essentially the same as the code for sample arrays, above.
 444  */
 445 
 446 METHODDEF(JBLOCKARRAY)
 447 alloc_barray (j_common_ptr cinfo, int pool_id,
 448           JDIMENSION blocksperrow, JDIMENSION numrows)
 449 /* Allocate a 2-D coefficient-block array */
 450 {
 451   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 452   JBLOCKARRAY result;
 453   JBLOCKROW workspace;
 454   JDIMENSION rowsperchunk, currow, i;
 455   long ltemp;
 456 
 457   if (blocksperrow == 0) {
 458     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 459   }
 460 
 461   /* Calculate max # of rows allowed in one allocation chunk */
<a name="12" id="anc12"></a><span class="line-modified"> 462   ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /</span>
 463       ((long) blocksperrow * SIZEOF(JBLOCK));
 464   if (ltemp &lt;= 0)
 465     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 466   if (ltemp &lt; (long) numrows)
 467     rowsperchunk = (JDIMENSION) ltemp;
 468   else
 469     rowsperchunk = numrows;
 470   mem-&gt;last_rowsperchunk = rowsperchunk;
 471 
 472   /* Get space for row pointers (small object) */
 473   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
<a name="13" id="anc13"></a><span class="line-modified"> 474                      (size_t) numrows * SIZEOF(JBLOCKROW));</span>
 475 
 476   /* Get the rows themselves (large objects) */
 477   currow = 0;
 478   while (currow &lt; numrows) {
 479     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 480     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
<a name="14" id="anc14"></a><span class="line-modified"> 481       (size_t) rowsperchunk * (size_t) blocksperrow * SIZEOF(JBLOCK));</span>

 482     for (i = rowsperchunk; i &gt; 0; i--) {
 483       result[currow++] = workspace;
 484       workspace += blocksperrow;
 485     }
 486   }
 487 
 488   return result;
 489 }
 490 
 491 
 492 /*
 493  * About virtual array management:
 494  *
 495  * The above &quot;normal&quot; array routines are only used to allocate strip buffers
 496  * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 497  * are handled as &quot;virtual&quot; arrays.  The array is still accessed a strip at a
 498  * time, but the memory manager must save the whole array for repeated
 499  * accesses.  The intended implementation is that there is a strip buffer in
 500  * memory (as high as is possible given the desired memory limit), plus a
 501  * backing file that holds the rest of the array.
 502  *
 503  * The request_virt_array routines are told the total size of the image and
 504  * the maximum number of rows that will be accessed at once.  The in-memory
 505  * buffer must be at least as large as the maxaccess value.
 506  *
 507  * The request routines create control blocks but not the in-memory buffers.
 508  * That is postponed until realize_virt_arrays is called.  At that time the
 509  * total amount of space needed is known (approximately, anyway), so free
 510  * memory can be divided up fairly.
 511  *
 512  * The access_virt_array routines are responsible for making a specific strip
 513  * area accessible (after reading or writing the backing file, if necessary).
 514  * Note that the access routines are told whether the caller intends to modify
 515  * the accessed strip; during a read-only pass this saves having to rewrite
 516  * data to disk.  The access routines are also responsible for pre-zeroing
 517  * any newly accessed rows, if pre-zeroing was requested.
 518  *
 519  * In current usage, the access requests are usually for nonoverlapping
 520  * strips; that is, successive access start_row numbers differ by exactly
 521  * num_rows = maxaccess.  This means we can get good performance with simple
 522  * buffer dump/reload logic, by making the in-memory buffer be a multiple
 523  * of the access height; then there will never be accesses across bufferload
 524  * boundaries.  The code will still work with overlapping access requests,
 525  * but it doesn&#39;t handle bufferload overlaps very efficiently.
 526  */
 527 
 528 
 529 METHODDEF(jvirt_sarray_ptr)
 530 request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 531              JDIMENSION samplesperrow, JDIMENSION numrows,
 532              JDIMENSION maxaccess)
 533 /* Request a virtual 2-D sample array */
 534 {
 535   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 536   jvirt_sarray_ptr result;
 537 
 538   /* Only IMAGE-lifetime virtual arrays are currently supported */
 539   if (pool_id != JPOOL_IMAGE)
 540     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 541 
 542   /* get control block */
 543   result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
 544                       SIZEOF(struct jvirt_sarray_control));
 545 
 546   result-&gt;mem_buffer = NULL;    /* marks array not yet realized */
 547   result-&gt;rows_in_array = numrows;
 548   result-&gt;samplesperrow = samplesperrow;
 549   result-&gt;maxaccess = maxaccess;
 550   result-&gt;pre_zero = pre_zero;
 551   result-&gt;b_s_open = FALSE;    /* no associated backing-store object */
 552   result-&gt;next = mem-&gt;virt_sarray_list; /* add to list of virtual arrays */
 553   mem-&gt;virt_sarray_list = result;
 554 
 555   return result;
 556 }
 557 
 558 
 559 METHODDEF(jvirt_barray_ptr)
 560 request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 561              JDIMENSION blocksperrow, JDIMENSION numrows,
 562              JDIMENSION maxaccess)
 563 /* Request a virtual 2-D coefficient-block array */
 564 {
 565   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 566   jvirt_barray_ptr result;
 567 
 568   /* Only IMAGE-lifetime virtual arrays are currently supported */
 569   if (pool_id != JPOOL_IMAGE)
 570     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 571 
 572   /* get control block */
 573   result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
 574                       SIZEOF(struct jvirt_barray_control));
 575 
 576   result-&gt;mem_buffer = NULL;    /* marks array not yet realized */
 577   result-&gt;rows_in_array = numrows;
 578   result-&gt;blocksperrow = blocksperrow;
 579   result-&gt;maxaccess = maxaccess;
 580   result-&gt;pre_zero = pre_zero;
 581   result-&gt;b_s_open = FALSE;    /* no associated backing-store object */
 582   result-&gt;next = mem-&gt;virt_barray_list; /* add to list of virtual arrays */
 583   mem-&gt;virt_barray_list = result;
 584 
 585   return result;
 586 }
 587 
 588 
 589 METHODDEF(void)
 590 realize_virt_arrays (j_common_ptr cinfo)
 591 /* Allocate the in-memory buffers for any unrealized virtual arrays */
 592 {
 593   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
<a name="15" id="anc15"></a><span class="line-modified"> 594   long bytesperrow, space_per_minheight, maximum_space;</span>
<span class="line-modified"> 595   long avail_mem, minheights, max_minheights;</span>
 596   jvirt_sarray_ptr sptr;
 597   jvirt_barray_ptr bptr;
 598 
 599   /* Compute the minimum space needed (maxaccess rows in each buffer)
 600    * and the maximum space needed (full image height in each buffer).
 601    * These may be of use to the system-dependent jpeg_mem_available routine.
 602    */
 603   space_per_minheight = 0;
 604   maximum_space = 0;
 605   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 606     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
<a name="16" id="anc16"></a><span class="line-modified"> 607       bytesperrow = (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
<span class="line-modified"> 608       space_per_minheight += (long) sptr-&gt;maxaccess * bytesperrow;</span>
<span class="line-modified"> 609       maximum_space += (long) sptr-&gt;rows_in_array * bytesperrow;</span>

 610     }
 611   }
 612   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 613     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */
<a name="17" id="anc17"></a><span class="line-modified"> 614       bytesperrow = (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
<span class="line-modified"> 615       space_per_minheight += (long) bptr-&gt;maxaccess * bytesperrow;</span>
<span class="line-modified"> 616       maximum_space += (long) bptr-&gt;rows_in_array * bytesperrow;</span>

 617     }
 618   }
 619 
 620   if (space_per_minheight &lt;= 0)
 621     return;            /* no unrealized arrays, no work */
 622 
 623   /* Determine amount of memory to actually use; this is system-dependent. */
 624   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
<a name="18" id="anc18"></a><span class="line-modified"> 625                  (long) mem-&gt;total_space_allocated);</span>
 626 
 627   /* If the maximum space needed is available, make all the buffers full
 628    * height; otherwise parcel it out with the same number of minheights
 629    * in each buffer.
 630    */
 631   if (avail_mem &gt;= maximum_space)
 632     max_minheights = 1000000000L;
 633   else {
 634     max_minheights = avail_mem / space_per_minheight;
 635     /* If there doesn&#39;t seem to be enough space, try to get the minimum
 636      * anyway.  This allows a &quot;stub&quot; implementation of jpeg_mem_available().
 637      */
 638     if (max_minheights &lt;= 0)
 639       max_minheights = 1;
 640   }
 641 
 642   /* Allocate the in-memory buffers and initialize backing store as needed. */
 643 
 644   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 645     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
 646       minheights = ((long) sptr-&gt;rows_in_array - 1L) / sptr-&gt;maxaccess + 1L;
 647       if (minheights &lt;= max_minheights) {
 648     /* This buffer fits in memory */
 649     sptr-&gt;rows_in_mem = sptr-&gt;rows_in_array;
 650       } else {
 651     /* It doesn&#39;t fit in memory, create backing store. */
 652     sptr-&gt;rows_in_mem = (JDIMENSION) (max_minheights * sptr-&gt;maxaccess);
 653     jpeg_open_backing_store(cinfo, &amp; sptr-&gt;b_s_info,
 654                 (long) sptr-&gt;rows_in_array *
 655                 (long) sptr-&gt;samplesperrow *
 656                 (long) SIZEOF(JSAMPLE));
 657     sptr-&gt;b_s_open = TRUE;
 658       }
 659       sptr-&gt;mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
 660                       sptr-&gt;samplesperrow, sptr-&gt;rows_in_mem);
 661       sptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;
 662       sptr-&gt;cur_start_row = 0;
 663       sptr-&gt;first_undef_row = 0;
 664       sptr-&gt;dirty = FALSE;
 665     }
 666   }
 667 
 668   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 669     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */
 670       minheights = ((long) bptr-&gt;rows_in_array - 1L) / bptr-&gt;maxaccess + 1L;
 671       if (minheights &lt;= max_minheights) {
 672     /* This buffer fits in memory */
 673     bptr-&gt;rows_in_mem = bptr-&gt;rows_in_array;
 674       } else {
 675     /* It doesn&#39;t fit in memory, create backing store. */
 676     bptr-&gt;rows_in_mem = (JDIMENSION) (max_minheights * bptr-&gt;maxaccess);
 677     jpeg_open_backing_store(cinfo, &amp; bptr-&gt;b_s_info,
 678                 (long) bptr-&gt;rows_in_array *
 679                 (long) bptr-&gt;blocksperrow *
 680                 (long) SIZEOF(JBLOCK));
 681     bptr-&gt;b_s_open = TRUE;
 682       }
 683       bptr-&gt;mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 684                       bptr-&gt;blocksperrow, bptr-&gt;rows_in_mem);
 685       bptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;
 686       bptr-&gt;cur_start_row = 0;
 687       bptr-&gt;first_undef_row = 0;
 688       bptr-&gt;dirty = FALSE;
 689     }
 690   }
 691 }
 692 
 693 
 694 LOCAL(void)
 695 do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
 696 /* Do backing store read or write of a virtual sample array */
 697 {
 698   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 699 
 700   bytesperrow = (long) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
<a name="19" id="anc19"></a><span class="line-modified"> 701   file_offset = (long) ptr-&gt;cur_start_row * bytesperrow;</span>
 702   /* Loop to read or write each allocation chunk in mem_buffer */
 703   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 704     /* One chunk, but check for short chunk at end of buffer */
 705     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 706     /* Transfer no more than is currently defined */
 707     thisrow = (long) ptr-&gt;cur_start_row + i;
 708     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 709     /* Transfer no more than fits in file */
 710     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 711     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 712       break;
 713     byte_count = rows * bytesperrow;
 714     if (writing)
 715       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 716                         (void FAR *) ptr-&gt;mem_buffer[i],
 717                         file_offset, byte_count);
 718     else
 719       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 720                        (void FAR *) ptr-&gt;mem_buffer[i],
 721                        file_offset, byte_count);
 722     file_offset += byte_count;
 723   }
 724 }
 725 
 726 
 727 LOCAL(void)
 728 do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
 729 /* Do backing store read or write of a virtual coefficient-block array */
 730 {
 731   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 732 
 733   bytesperrow = (long) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);
<a name="20" id="anc20"></a><span class="line-modified"> 734   file_offset = (long) ptr-&gt;cur_start_row * bytesperrow;</span>
 735   /* Loop to read or write each allocation chunk in mem_buffer */
 736   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 737     /* One chunk, but check for short chunk at end of buffer */
 738     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 739     /* Transfer no more than is currently defined */
 740     thisrow = (long) ptr-&gt;cur_start_row + i;
 741     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 742     /* Transfer no more than fits in file */
 743     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 744     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 745       break;
 746     byte_count = rows * bytesperrow;
 747     if (writing)
 748       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 749                         (void FAR *) ptr-&gt;mem_buffer[i],
 750                         file_offset, byte_count);
 751     else
 752       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 753                        (void FAR *) ptr-&gt;mem_buffer[i],
 754                        file_offset, byte_count);
 755     file_offset += byte_count;
 756   }
 757 }
 758 
 759 
 760 METHODDEF(JSAMPARRAY)
 761 access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 762             JDIMENSION start_row, JDIMENSION num_rows,
 763             boolean writable)
 764 /* Access the part of a virtual sample array starting at start_row */
 765 /* and extending for num_rows rows.  writable is true if  */
 766 /* caller intends to modify the accessed area. */
 767 {
 768   JDIMENSION end_row = start_row + num_rows;
 769   JDIMENSION undef_row;
 770 
 771   /* debugging check */
 772   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 773       ptr-&gt;mem_buffer == NULL)
 774     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 775 
 776   /* Make the desired part of the virtual array accessible */
 777   if (start_row &lt; ptr-&gt;cur_start_row ||
<a name="21" id="anc21"></a><span class="line-modified"> 778       end_row &gt; ptr-&gt;cur_start_row + ptr-&gt;rows_in_mem) {</span>
 779     if (! ptr-&gt;b_s_open)
 780       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 781     /* Flush old buffer contents if necessary */
 782     if (ptr-&gt;dirty) {
 783       do_sarray_io(cinfo, ptr, TRUE);
 784       ptr-&gt;dirty = FALSE;
 785     }
 786     /* Decide what part of virtual array to access.
 787      * Algorithm: if target address &gt; current window, assume forward scan,
 788      * load starting at target address.  If target address &lt; current window,
 789      * assume backward scan, load so that target area is top of window.
 790      * Note that when switching from forward write to forward read, will have
 791      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 792      */
 793     if (start_row &gt; ptr-&gt;cur_start_row) {
 794       ptr-&gt;cur_start_row = start_row;
 795     } else {
 796       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 797       long ltemp;
 798 
 799       ltemp = (long) end_row - (long) ptr-&gt;rows_in_mem;
 800       if (ltemp &lt; 0)
 801     ltemp = 0;        /* don&#39;t fall off front end of file */
 802       ptr-&gt;cur_start_row = (JDIMENSION) ltemp;
 803     }
 804     /* Read in the selected part of the array.
 805      * During the initial write pass, we will do no actual read
 806      * because the selected part is all undefined.
 807      */
 808     do_sarray_io(cinfo, ptr, FALSE);
 809   }
 810   /* Ensure the accessed part of the array is defined; prezero if needed.
 811    * To improve locality of access, we only prezero the part of the array
 812    * that the caller is about to access, not the entire in-memory array.
 813    */
 814   if (ptr-&gt;first_undef_row &lt; end_row) {
 815     if (ptr-&gt;first_undef_row &lt; start_row) {
 816       if (writable)        /* writer skipped over a section of array */
 817     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 818       undef_row = start_row;    /* but reader is allowed to read ahead */
 819     } else {
 820       undef_row = ptr-&gt;first_undef_row;
 821     }
 822     if (writable)
 823       ptr-&gt;first_undef_row = end_row;
 824     if (ptr-&gt;pre_zero) {
 825       size_t bytesperrow = (size_t) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
 826       undef_row -= ptr-&gt;cur_start_row; /* make indexes relative to buffer */
 827       end_row -= ptr-&gt;cur_start_row;
 828       while (undef_row &lt; end_row) {
 829     FMEMZERO((void FAR *) ptr-&gt;mem_buffer[undef_row], bytesperrow);
 830     undef_row++;
 831       }
 832     } else {
 833       if (! writable)        /* reader looking at undefined data */
 834     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 835     }
 836   }
 837   /* Flag the buffer dirty if caller will write in it */
 838   if (writable)
 839     ptr-&gt;dirty = TRUE;
 840   /* Return address of proper part of the buffer */
 841   return ptr-&gt;mem_buffer + (start_row - ptr-&gt;cur_start_row);
 842 }
 843 
 844 
 845 METHODDEF(JBLOCKARRAY)
 846 access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
 847             JDIMENSION start_row, JDIMENSION num_rows,
 848             boolean writable)
 849 /* Access the part of a virtual block array starting at start_row */
 850 /* and extending for num_rows rows.  writable is true if  */
 851 /* caller intends to modify the accessed area. */
 852 {
 853   JDIMENSION end_row = start_row + num_rows;
 854   JDIMENSION undef_row;
 855 
 856   /* debugging check */
 857   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 858       ptr-&gt;mem_buffer == NULL)
 859     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 860 
 861   /* Make the desired part of the virtual array accessible */
 862   if (start_row &lt; ptr-&gt;cur_start_row ||
<a name="22" id="anc22"></a><span class="line-modified"> 863       end_row &gt; ptr-&gt;cur_start_row + ptr-&gt;rows_in_mem) {</span>
 864     if (! ptr-&gt;b_s_open)
 865       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 866     /* Flush old buffer contents if necessary */
 867     if (ptr-&gt;dirty) {
 868       do_barray_io(cinfo, ptr, TRUE);
 869       ptr-&gt;dirty = FALSE;
 870     }
 871     /* Decide what part of virtual array to access.
 872      * Algorithm: if target address &gt; current window, assume forward scan,
 873      * load starting at target address.  If target address &lt; current window,
 874      * assume backward scan, load so that target area is top of window.
 875      * Note that when switching from forward write to forward read, will have
 876      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 877      */
 878     if (start_row &gt; ptr-&gt;cur_start_row) {
 879       ptr-&gt;cur_start_row = start_row;
 880     } else {
 881       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 882       long ltemp;
 883 
 884       ltemp = (long) end_row - (long) ptr-&gt;rows_in_mem;
 885       if (ltemp &lt; 0)
 886     ltemp = 0;        /* don&#39;t fall off front end of file */
 887       ptr-&gt;cur_start_row = (JDIMENSION) ltemp;
 888     }
 889     /* Read in the selected part of the array.
 890      * During the initial write pass, we will do no actual read
 891      * because the selected part is all undefined.
 892      */
 893     do_barray_io(cinfo, ptr, FALSE);
 894   }
 895   /* Ensure the accessed part of the array is defined; prezero if needed.
 896    * To improve locality of access, we only prezero the part of the array
 897    * that the caller is about to access, not the entire in-memory array.
 898    */
 899   if (ptr-&gt;first_undef_row &lt; end_row) {
 900     if (ptr-&gt;first_undef_row &lt; start_row) {
 901       if (writable)        /* writer skipped over a section of array */
 902     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 903       undef_row = start_row;    /* but reader is allowed to read ahead */
 904     } else {
 905       undef_row = ptr-&gt;first_undef_row;
 906     }
 907     if (writable)
 908       ptr-&gt;first_undef_row = end_row;
 909     if (ptr-&gt;pre_zero) {
 910       size_t bytesperrow = (size_t) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);
 911       undef_row -= ptr-&gt;cur_start_row; /* make indexes relative to buffer */
 912       end_row -= ptr-&gt;cur_start_row;
 913       while (undef_row &lt; end_row) {
 914     FMEMZERO((void FAR *) ptr-&gt;mem_buffer[undef_row], bytesperrow);
 915     undef_row++;
 916       }
 917     } else {
 918       if (! writable)        /* reader looking at undefined data */
 919     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 920     }
 921   }
 922   /* Flag the buffer dirty if caller will write in it */
 923   if (writable)
 924     ptr-&gt;dirty = TRUE;
 925   /* Return address of proper part of the buffer */
 926   return ptr-&gt;mem_buffer + (start_row - ptr-&gt;cur_start_row);
 927 }
 928 
 929 
 930 /*
 931  * Release all objects belonging to a specified pool.
 932  */
 933 
 934 METHODDEF(void)
 935 free_pool (j_common_ptr cinfo, int pool_id)
 936 {
 937   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 938   small_pool_ptr shdr_ptr;
 939   large_pool_ptr lhdr_ptr;
 940   size_t space_freed;
 941 
 942   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 943     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 944 
 945 #ifdef MEM_STATS
 946   if (cinfo-&gt;err-&gt;trace_level &gt; 1)
 947     print_mem_stats(cinfo, pool_id); /* print pool&#39;s memory usage statistics */
 948 #endif
 949 
 950   /* If freeing IMAGE pool, close any virtual arrays first */
 951   if (pool_id == JPOOL_IMAGE) {
 952     jvirt_sarray_ptr sptr;
 953     jvirt_barray_ptr bptr;
 954 
 955     for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 956       if (sptr-&gt;b_s_open) {    /* there may be no backing store */
 957     sptr-&gt;b_s_open = FALSE;    /* prevent recursive close if error */
 958     (*sptr-&gt;b_s_info.close_backing_store) (cinfo, &amp; sptr-&gt;b_s_info);
 959       }
 960     }
 961     mem-&gt;virt_sarray_list = NULL;
 962     for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 963       if (bptr-&gt;b_s_open) {    /* there may be no backing store */
 964     bptr-&gt;b_s_open = FALSE;    /* prevent recursive close if error */
 965     (*bptr-&gt;b_s_info.close_backing_store) (cinfo, &amp; bptr-&gt;b_s_info);
 966       }
 967     }
 968     mem-&gt;virt_barray_list = NULL;
 969   }
 970 
 971   /* Release large objects */
 972   lhdr_ptr = mem-&gt;large_list[pool_id];
 973   mem-&gt;large_list[pool_id] = NULL;
 974 
 975   while (lhdr_ptr != NULL) {
 976     large_pool_ptr next_lhdr_ptr = lhdr_ptr-&gt;hdr.next;
 977     space_freed = lhdr_ptr-&gt;hdr.bytes_used +
 978           lhdr_ptr-&gt;hdr.bytes_left +
 979           SIZEOF(large_pool_hdr);
 980     jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
 981     mem-&gt;total_space_allocated -= space_freed;
 982     lhdr_ptr = next_lhdr_ptr;
 983   }
 984 
 985   /* Release small objects */
 986   shdr_ptr = mem-&gt;small_list[pool_id];
 987   mem-&gt;small_list[pool_id] = NULL;
 988 
 989   while (shdr_ptr != NULL) {
 990     small_pool_ptr next_shdr_ptr = shdr_ptr-&gt;hdr.next;
 991     space_freed = shdr_ptr-&gt;hdr.bytes_used +
 992           shdr_ptr-&gt;hdr.bytes_left +
 993           SIZEOF(small_pool_hdr);
 994     jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
 995     mem-&gt;total_space_allocated -= space_freed;
 996     shdr_ptr = next_shdr_ptr;
 997   }
 998 }
 999 
1000 
1001 /*
1002  * Close up shop entirely.
1003  * Note that this cannot be called unless cinfo-&gt;mem is non-NULL.
1004  */
1005 
1006 METHODDEF(void)
1007 self_destruct (j_common_ptr cinfo)
1008 {
1009   int pool;
1010 
1011   /* Close all backing store, release all memory.
1012    * Releasing pools in reverse order might help avoid fragmentation
1013    * with some (brain-damaged) malloc libraries.
1014    */
1015   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {
1016     free_pool(cinfo, pool);
1017   }
1018 
1019   /* Release the memory manager control block too. */
1020   jpeg_free_small(cinfo, (void *) cinfo-&gt;mem, SIZEOF(my_memory_mgr));
1021   cinfo-&gt;mem = NULL;        /* ensures I will be called only once */
1022 
1023   jpeg_mem_term(cinfo);        /* system-dependent cleanup */
1024 }
1025 
1026 
1027 /*
1028  * Memory manager initialization.
1029  * When this is called, only the error manager pointer is valid in cinfo!
1030  */
1031 
1032 GLOBAL(void)
1033 jinit_memory_mgr (j_common_ptr cinfo)
1034 {
1035   my_mem_ptr mem;
1036   long max_to_use;
1037   int pool;
1038   size_t test_mac;
1039 
1040   cinfo-&gt;mem = NULL;        /* for safety if init fails */
1041 
1042   /* Check for configuration errors.
1043    * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
1044    * doesn&#39;t reflect any real hardware alignment requirement.
1045    * The test is a little tricky: for X&gt;0, X and X-1 have no one-bits
1046    * in common if and only if X is a power of 2, ie has only one one-bit.
1047    * Some compilers may give an &quot;unreachable code&quot; warning here; ignore it.
1048    */
1049   if ((SIZEOF(ALIGN_TYPE) &amp; (SIZEOF(ALIGN_TYPE)-1)) != 0)
1050     ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
1051   /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
1052    * a multiple of SIZEOF(ALIGN_TYPE).
1053    * Again, an &quot;unreachable code&quot; warning may be ignored here.
1054    * But a &quot;constant too large&quot; warning means you need to fix MAX_ALLOC_CHUNK.
1055    */
1056   test_mac = (size_t) MAX_ALLOC_CHUNK;
1057   if ((long) test_mac != MAX_ALLOC_CHUNK ||
1058       (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
1059     ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
1060 
1061   max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
1062 
1063   /* Attempt to allocate memory manager&#39;s control block */
1064   mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
1065 
1066   if (mem == NULL) {
1067     jpeg_mem_term(cinfo);    /* system-dependent cleanup */
1068     ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
1069   }
1070 
1071   /* OK, fill in the method pointers */
1072   mem-&gt;pub.alloc_small = alloc_small;
1073   mem-&gt;pub.alloc_large = alloc_large;
1074   mem-&gt;pub.alloc_sarray = alloc_sarray;
1075   mem-&gt;pub.alloc_barray = alloc_barray;
1076   mem-&gt;pub.request_virt_sarray = request_virt_sarray;
1077   mem-&gt;pub.request_virt_barray = request_virt_barray;
1078   mem-&gt;pub.realize_virt_arrays = realize_virt_arrays;
1079   mem-&gt;pub.access_virt_sarray = access_virt_sarray;
1080   mem-&gt;pub.access_virt_barray = access_virt_barray;
1081   mem-&gt;pub.free_pool = free_pool;
1082   mem-&gt;pub.self_destruct = self_destruct;
1083 
1084   /* Make MAX_ALLOC_CHUNK accessible to other modules */
1085   mem-&gt;pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
1086 
1087   /* Initialize working state */
1088   mem-&gt;pub.max_memory_to_use = max_to_use;
1089 
1090   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {
1091     mem-&gt;small_list[pool] = NULL;
1092     mem-&gt;large_list[pool] = NULL;
1093   }
1094   mem-&gt;virt_sarray_list = NULL;
1095   mem-&gt;virt_barray_list = NULL;
1096 
1097   mem-&gt;total_space_allocated = SIZEOF(my_memory_mgr);
1098 
1099   /* Declare ourselves open for business */
<a name="23" id="anc23"></a><span class="line-modified">1100   cinfo-&gt;mem = &amp;mem-&gt;pub;</span>
1101 
1102   /* Check for an environment variable JPEGMEM; if found, override the
1103    * default max_memory setting from jpeg_mem_init.  Note that the
1104    * surrounding application may again override this value.
1105    * If your system doesn&#39;t support getenv(), define NO_GETENV to disable
1106    * this feature.
1107    */
1108 #ifndef NO_GETENV
1109   { char * memenv;
1110 
1111     if ((memenv = getenv(&quot;JPEGMEM&quot;)) != NULL) {
1112       char ch = &#39;x&#39;;
1113 
1114       if (sscanf(memenv, &quot;%ld%c&quot;, &amp;max_to_use, &amp;ch) &gt; 0) {
1115     if (ch == &#39;m&#39; || ch == &#39;M&#39;)
1116       max_to_use *= 1000L;
1117     mem-&gt;pub.max_memory_to_use = max_to_use * 1000L;
1118       }
1119     }
1120   }
1121 #endif
1122 
1123 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
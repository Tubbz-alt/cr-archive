<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="jidctint.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jmemnobs.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * jmemmgr.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="line-modified">   5  * Modified 2011-2012 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains the JPEG system-independent memory management
  10  * routines.  This code is usable across a wide variety of machines; most
  11  * of the system dependencies have been isolated in a separate file.
  12  * The major functions provided here are:
  13  *   * pool-based allocation and freeing of memory;
  14  *   * policy decisions about how to divide available memory among the
  15  *     virtual arrays;
  16  *   * control logic for swapping virtual arrays between main memory and
  17  *     backing storage.
  18  * The separate system-dependent file provides the actual backing-storage
  19  * access code, and it contains the policy decision about how much total
  20  * main memory to use.
  21  * This file is system-dependent in the sense that some of its functions
  22  * are unnecessary in some systems.  For example, if there is enough virtual
  23  * memory so that backing storage will never be used, much of the virtual
  24  * array control logic could be removed.  (Of course, if you have that much
  25  * memory then you shouldn&#39;t care about a little bit of unused code...)
</pre>
<hr />
<pre>
 113 /*
 114  * Here is the full definition of a memory manager object.
 115  */
 116 
 117 typedef struct {
 118   struct jpeg_memory_mgr pub;    /* public fields */
 119 
 120   /* Each pool identifier (lifetime class) names a linked list of pools. */
 121   small_pool_ptr small_list[JPOOL_NUMPOOLS];
 122   large_pool_ptr large_list[JPOOL_NUMPOOLS];
 123 
 124   /* Since we only have one lifetime class of virtual arrays, only one
 125    * linked list is necessary (for each datatype).  Note that the virtual
 126    * array control blocks being linked together are actually stored somewhere
 127    * in the small-pool list.
 128    */
 129   jvirt_sarray_ptr virt_sarray_list;
 130   jvirt_barray_ptr virt_barray_list;
 131 
 132   /* This counts total space obtained from jpeg_get_small/large */
<span class="line-modified"> 133   long total_space_allocated;</span>
 134 
 135   /* alloc_sarray and alloc_barray set this value for use by virtual
 136    * array routines.
 137    */
 138   JDIMENSION last_rowsperchunk;    /* from most recent alloc_sarray/barray */
 139 } my_memory_mgr;
 140 
 141 typedef my_memory_mgr * my_mem_ptr;
 142 
 143 
 144 /*
 145  * The control blocks for virtual arrays.
 146  * Note that these blocks are allocated in the &quot;small&quot; pool area.
 147  * System-dependent info for the associated backing store (if any) is hidden
 148  * inside the backing_store_info struct.
 149  */
 150 
 151 struct jvirt_sarray_control {
 152   JSAMPARRAY mem_buffer;    /* =&gt; the in-memory buffer */
 153   JDIMENSION rows_in_array;    /* total virtual array height */
</pre>
<hr />
<pre>
 178   boolean b_s_open;        /* is backing-store data valid? */
 179   jvirt_barray_ptr next;    /* link to next virtual barray control block */
 180   backing_store_info b_s_info;    /* System-dependent control info */
 181 };
 182 
 183 
 184 #ifdef MEM_STATS        /* optional extra stuff for statistics */
 185 
 186 LOCAL(void)
 187 print_mem_stats (j_common_ptr cinfo, int pool_id)
 188 {
 189   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 190   small_pool_ptr shdr_ptr;
 191   large_pool_ptr lhdr_ptr;
 192 
 193   /* Since this is only a debugging stub, we can cheat a little by using
 194    * fprintf directly rather than going through the trace message code.
 195    * This is helpful because message parm array can&#39;t handle longs.
 196    */
 197   fprintf(stderr, &quot;Freeing pool %d, total space = %ld\n&quot;,
<span class="line-modified"> 198       pool_id, mem-&gt;total_space_allocated);</span>
 199 
 200   for (lhdr_ptr = mem-&gt;large_list[pool_id]; lhdr_ptr != NULL;
 201        lhdr_ptr = lhdr_ptr-&gt;hdr.next) {
 202     fprintf(stderr, &quot;  Large chunk used %ld\n&quot;,
 203         (long) lhdr_ptr-&gt;hdr.bytes_used);
 204   }
 205 
 206   for (shdr_ptr = mem-&gt;small_list[pool_id]; shdr_ptr != NULL;
 207        shdr_ptr = shdr_ptr-&gt;hdr.next) {
 208     fprintf(stderr, &quot;  Small chunk used %ld free %ld\n&quot;,
 209         (long) shdr_ptr-&gt;hdr.bytes_used,
 210         (long) shdr_ptr-&gt;hdr.bytes_left);
 211   }
 212 }
 213 
 214 #endif /* MEM_STATS */
 215 
 216 
 217 LOCAL(noreturn_t)
 218 out_of_memory (j_common_ptr cinfo, int which)
</pre>
<hr />
<pre>
 243 {
 244     1600,            /* first PERMANENT pool */
 245     16000            /* first IMAGE pool */
 246 };
 247 
 248 static const size_t extra_pool_slop[JPOOL_NUMPOOLS] =
 249 {
 250     0,            /* additional PERMANENT pools */
 251     5000            /* additional IMAGE pools */
 252 };
 253 
 254 #define MIN_SLOP  50        /* greater than 0 to avoid futile looping */
 255 
 256 
 257 METHODDEF(void *)
 258 alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 259 /* Allocate a &quot;small&quot; object */
 260 {
 261   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 262   small_pool_ptr hdr_ptr, prev_hdr_ptr;
<span class="line-removed"> 263   char * data_ptr;</span>
 264   size_t odd_bytes, min_request, slop;

 265 
 266   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<span class="line-modified"> 267   if (sizeofobject &gt; (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))</span>
 268     out_of_memory(cinfo, 1);    /* request exceeds malloc&#39;s ability */
 269 
 270   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 271   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 272   if (odd_bytes &gt; 0)
 273     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 274 
 275   /* See if space is available in any existing pool */
 276   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 277     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 278   prev_hdr_ptr = NULL;
 279   hdr_ptr = mem-&gt;small_list[pool_id];
 280   while (hdr_ptr != NULL) {
 281     if (hdr_ptr-&gt;hdr.bytes_left &gt;= sizeofobject)
 282       break;            /* found pool with enough space */
 283     prev_hdr_ptr = hdr_ptr;
 284     hdr_ptr = hdr_ptr-&gt;hdr.next;
 285   }
 286 
 287   /* Time to make a new pool? */
 288   if (hdr_ptr == NULL) {
 289     /* min_request is what we need now, slop is what will be leftover */
 290     min_request = sizeofobject + SIZEOF(small_pool_hdr);
 291     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 292       slop = first_pool_slop[pool_id];
 293     else
 294       slop = extra_pool_slop[pool_id];
 295     /* Don&#39;t ask for more than MAX_ALLOC_CHUNK */
<span class="line-modified"> 296     if (slop &gt; (size_t) (MAX_ALLOC_CHUNK-min_request))</span>
<span class="line-modified"> 297       slop = (size_t) (MAX_ALLOC_CHUNK-min_request);</span>
 298     /* Try to get space, if fail reduce slop and try again */
 299     for (;;) {
 300       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 301       if (hdr_ptr != NULL)
 302     break;
 303       slop /= 2;
 304       if (slop &lt; MIN_SLOP)    /* give up when it gets real small */
 305     out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 306     }
 307     mem-&gt;total_space_allocated += min_request + slop;
 308     /* Success, initialize the new pool header and add to end of list */
 309     hdr_ptr-&gt;hdr.next = NULL;
 310     hdr_ptr-&gt;hdr.bytes_used = 0;
 311     hdr_ptr-&gt;hdr.bytes_left = sizeofobject + slop;
 312     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 313       mem-&gt;small_list[pool_id] = hdr_ptr;
 314     else
 315       prev_hdr_ptr-&gt;hdr.next = hdr_ptr;
 316   }
 317 
</pre>
<hr />
<pre>
 331  * The external semantics of these are the same as &quot;small&quot; objects,
 332  * except that FAR pointers are used on 80x86.  However the pool
 333  * management heuristics are quite different.  We assume that each
 334  * request is large enough that it may as well be passed directly to
 335  * jpeg_get_large; the pool management just links everything together
 336  * so that we can free it all on demand.
 337  * Note: the major use of &quot;large&quot; objects is in JSAMPARRAY and JBLOCKARRAY
 338  * structures.  The routines that create these structures (see below)
 339  * deliberately bunch rows together to ensure a large request size.
 340  */
 341 
 342 METHODDEF(void FAR *)
 343 alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 344 /* Allocate a &quot;large&quot; object */
 345 {
 346   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 347   large_pool_ptr hdr_ptr;
 348   size_t odd_bytes;
 349 
 350   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<span class="line-modified"> 351   if (sizeofobject &gt; (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))</span>
 352     out_of_memory(cinfo, 3);    /* request exceeds malloc&#39;s ability */
 353 
 354   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 355   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 356   if (odd_bytes &gt; 0)
 357     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 358 
 359   /* Always make a new pool */
 360   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 361     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 362 
 363   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 364                         SIZEOF(large_pool_hdr));
 365   if (hdr_ptr == NULL)
 366     out_of_memory(cinfo, 4);    /* jpeg_get_large failed */
 367   mem-&gt;total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 368 
 369   /* Success, initialize the new pool header and add to list */
 370   hdr_ptr-&gt;hdr.next = mem-&gt;large_list[pool_id];
 371   /* We maintain space counts in each pool header for statistical purposes,
</pre>
<hr />
<pre>
 391  * object so that it can be saved away if this sarray is the workspace for
 392  * a virtual array.
 393  */
 394 
 395 METHODDEF(JSAMPARRAY)
 396 alloc_sarray (j_common_ptr cinfo, int pool_id,
 397           JDIMENSION samplesperrow, JDIMENSION numrows)
 398 /* Allocate a 2-D sample array */
 399 {
 400   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 401   JSAMPARRAY result;
 402   JSAMPROW workspace;
 403   JDIMENSION rowsperchunk, currow, i;
 404   long ltemp;
 405 
 406   if (samplesperrow == 0) {
 407     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 408   }
 409 
 410   /* Calculate max # of rows allowed in one allocation chunk */
<span class="line-modified"> 411   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /</span>
 412       ((long) samplesperrow * SIZEOF(JSAMPLE));
 413   if (ltemp &lt;= 0)
 414     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 415   if (ltemp &lt; (long) numrows)
 416     rowsperchunk = (JDIMENSION) ltemp;
 417   else
 418     rowsperchunk = numrows;
 419   mem-&gt;last_rowsperchunk = rowsperchunk;
 420 
 421   /* Get space for row pointers (small object) */
 422   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
<span class="line-modified"> 423                     (size_t) (numrows * SIZEOF(JSAMPROW)));</span>
 424 
 425   /* Get the rows themselves (large objects) */
 426   currow = 0;
 427   while (currow &lt; numrows) {
 428     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 429     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
<span class="line-modified"> 430     (size_t) ((size_t) rowsperchunk * (size_t) samplesperrow</span>
<span class="line-removed"> 431           * SIZEOF(JSAMPLE)));</span>
 432     for (i = rowsperchunk; i &gt; 0; i--) {
 433       result[currow++] = workspace;
 434       workspace += samplesperrow;
 435     }
 436   }
 437 
 438   return result;
 439 }
 440 
 441 
 442 /*
 443  * Creation of 2-D coefficient-block arrays.
 444  * This is essentially the same as the code for sample arrays, above.
 445  */
 446 
 447 METHODDEF(JBLOCKARRAY)
 448 alloc_barray (j_common_ptr cinfo, int pool_id,
 449           JDIMENSION blocksperrow, JDIMENSION numrows)
 450 /* Allocate a 2-D coefficient-block array */
 451 {
 452   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 453   JBLOCKARRAY result;
 454   JBLOCKROW workspace;
 455   JDIMENSION rowsperchunk, currow, i;
 456   long ltemp;
 457 
 458   if (blocksperrow == 0) {
 459     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 460   }
 461 
 462   /* Calculate max # of rows allowed in one allocation chunk */
<span class="line-modified"> 463   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /</span>
 464       ((long) blocksperrow * SIZEOF(JBLOCK));
 465   if (ltemp &lt;= 0)
 466     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 467   if (ltemp &lt; (long) numrows)
 468     rowsperchunk = (JDIMENSION) ltemp;
 469   else
 470     rowsperchunk = numrows;
 471   mem-&gt;last_rowsperchunk = rowsperchunk;
 472 
 473   /* Get space for row pointers (small object) */
 474   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
<span class="line-modified"> 475                      (size_t) (numrows * SIZEOF(JBLOCKROW)));</span>
 476 
 477   /* Get the rows themselves (large objects) */
 478   currow = 0;
 479   while (currow &lt; numrows) {
 480     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 481     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
<span class="line-modified"> 482     (size_t) ((size_t) rowsperchunk * (size_t) blocksperrow</span>
<span class="line-removed"> 483           * SIZEOF(JBLOCK)));</span>
 484     for (i = rowsperchunk; i &gt; 0; i--) {
 485       result[currow++] = workspace;
 486       workspace += blocksperrow;
 487     }
 488   }
 489 
 490   return result;
 491 }
 492 
 493 
 494 /*
 495  * About virtual array management:
 496  *
 497  * The above &quot;normal&quot; array routines are only used to allocate strip buffers
 498  * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 499  * are handled as &quot;virtual&quot; arrays.  The array is still accessed a strip at a
 500  * time, but the memory manager must save the whole array for repeated
 501  * accesses.  The intended implementation is that there is a strip buffer in
 502  * memory (as high as is possible given the desired memory limit), plus a
 503  * backing file that holds the rest of the array.
</pre>
<hr />
<pre>
 576                       SIZEOF(struct jvirt_barray_control));
 577 
 578   result-&gt;mem_buffer = NULL;    /* marks array not yet realized */
 579   result-&gt;rows_in_array = numrows;
 580   result-&gt;blocksperrow = blocksperrow;
 581   result-&gt;maxaccess = maxaccess;
 582   result-&gt;pre_zero = pre_zero;
 583   result-&gt;b_s_open = FALSE;    /* no associated backing-store object */
 584   result-&gt;next = mem-&gt;virt_barray_list; /* add to list of virtual arrays */
 585   mem-&gt;virt_barray_list = result;
 586 
 587   return result;
 588 }
 589 
 590 
 591 METHODDEF(void)
 592 realize_virt_arrays (j_common_ptr cinfo)
 593 /* Allocate the in-memory buffers for any unrealized virtual arrays */
 594 {
 595   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
<span class="line-modified"> 596   long space_per_minheight, maximum_space, avail_mem;</span>
<span class="line-modified"> 597   long minheights, max_minheights;</span>
 598   jvirt_sarray_ptr sptr;
 599   jvirt_barray_ptr bptr;
 600 
 601   /* Compute the minimum space needed (maxaccess rows in each buffer)
 602    * and the maximum space needed (full image height in each buffer).
 603    * These may be of use to the system-dependent jpeg_mem_available routine.
 604    */
 605   space_per_minheight = 0;
 606   maximum_space = 0;
 607   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 608     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
<span class="line-modified"> 609       space_per_minheight += (long) sptr-&gt;maxaccess *</span>
<span class="line-modified"> 610                  (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
<span class="line-modified"> 611       maximum_space += (long) sptr-&gt;rows_in_array *</span>
<span class="line-removed"> 612                (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
 613     }
 614   }
 615   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 616     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */
<span class="line-modified"> 617       space_per_minheight += (long) bptr-&gt;maxaccess *</span>
<span class="line-modified"> 618                  (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
<span class="line-modified"> 619       maximum_space += (long) bptr-&gt;rows_in_array *</span>
<span class="line-removed"> 620                (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
 621     }
 622   }
 623 
 624   if (space_per_minheight &lt;= 0)
 625     return;            /* no unrealized arrays, no work */
 626 
 627   /* Determine amount of memory to actually use; this is system-dependent. */
 628   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
<span class="line-modified"> 629                  mem-&gt;total_space_allocated);</span>
 630 
 631   /* If the maximum space needed is available, make all the buffers full
 632    * height; otherwise parcel it out with the same number of minheights
 633    * in each buffer.
 634    */
 635   if (avail_mem &gt;= maximum_space)
 636     max_minheights = 1000000000L;
 637   else {
 638     max_minheights = avail_mem / space_per_minheight;
 639     /* If there doesn&#39;t seem to be enough space, try to get the minimum
 640      * anyway.  This allows a &quot;stub&quot; implementation of jpeg_mem_available().
 641      */
 642     if (max_minheights &lt;= 0)
 643       max_minheights = 1;
 644   }
 645 
 646   /* Allocate the in-memory buffers and initialize backing store as needed. */
 647 
 648   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 649     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
</pre>
<hr />
<pre>
 685     bptr-&gt;b_s_open = TRUE;
 686       }
 687       bptr-&gt;mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 688                       bptr-&gt;blocksperrow, bptr-&gt;rows_in_mem);
 689       bptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;
 690       bptr-&gt;cur_start_row = 0;
 691       bptr-&gt;first_undef_row = 0;
 692       bptr-&gt;dirty = FALSE;
 693     }
 694   }
 695 }
 696 
 697 
 698 LOCAL(void)
 699 do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
 700 /* Do backing store read or write of a virtual sample array */
 701 {
 702   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 703 
 704   bytesperrow = (long) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
<span class="line-modified"> 705   file_offset = ptr-&gt;cur_start_row * bytesperrow;</span>
 706   /* Loop to read or write each allocation chunk in mem_buffer */
 707   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 708     /* One chunk, but check for short chunk at end of buffer */
 709     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 710     /* Transfer no more than is currently defined */
 711     thisrow = (long) ptr-&gt;cur_start_row + i;
 712     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 713     /* Transfer no more than fits in file */
 714     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 715     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 716       break;
 717     byte_count = rows * bytesperrow;
 718     if (writing)
 719       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 720                         (void FAR *) ptr-&gt;mem_buffer[i],
 721                         file_offset, byte_count);
 722     else
 723       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 724                        (void FAR *) ptr-&gt;mem_buffer[i],
 725                        file_offset, byte_count);
 726     file_offset += byte_count;
 727   }
 728 }
 729 
 730 
 731 LOCAL(void)
 732 do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
 733 /* Do backing store read or write of a virtual coefficient-block array */
 734 {
 735   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 736 
 737   bytesperrow = (long) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);
<span class="line-modified"> 738   file_offset = ptr-&gt;cur_start_row * bytesperrow;</span>
 739   /* Loop to read or write each allocation chunk in mem_buffer */
 740   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 741     /* One chunk, but check for short chunk at end of buffer */
 742     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 743     /* Transfer no more than is currently defined */
 744     thisrow = (long) ptr-&gt;cur_start_row + i;
 745     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 746     /* Transfer no more than fits in file */
 747     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 748     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 749       break;
 750     byte_count = rows * bytesperrow;
 751     if (writing)
 752       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 753                         (void FAR *) ptr-&gt;mem_buffer[i],
 754                         file_offset, byte_count);
 755     else
 756       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 757                        (void FAR *) ptr-&gt;mem_buffer[i],
 758                        file_offset, byte_count);
</pre>
<hr />
<pre>
 762 
 763 
 764 METHODDEF(JSAMPARRAY)
 765 access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 766             JDIMENSION start_row, JDIMENSION num_rows,
 767             boolean writable)
 768 /* Access the part of a virtual sample array starting at start_row */
 769 /* and extending for num_rows rows.  writable is true if  */
 770 /* caller intends to modify the accessed area. */
 771 {
 772   JDIMENSION end_row = start_row + num_rows;
 773   JDIMENSION undef_row;
 774 
 775   /* debugging check */
 776   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 777       ptr-&gt;mem_buffer == NULL)
 778     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 779 
 780   /* Make the desired part of the virtual array accessible */
 781   if (start_row &lt; ptr-&gt;cur_start_row ||
<span class="line-modified"> 782       end_row &gt; ptr-&gt;cur_start_row+ptr-&gt;rows_in_mem) {</span>
 783     if (! ptr-&gt;b_s_open)
 784       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 785     /* Flush old buffer contents if necessary */
 786     if (ptr-&gt;dirty) {
 787       do_sarray_io(cinfo, ptr, TRUE);
 788       ptr-&gt;dirty = FALSE;
 789     }
 790     /* Decide what part of virtual array to access.
 791      * Algorithm: if target address &gt; current window, assume forward scan,
 792      * load starting at target address.  If target address &lt; current window,
 793      * assume backward scan, load so that target area is top of window.
 794      * Note that when switching from forward write to forward read, will have
 795      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 796      */
 797     if (start_row &gt; ptr-&gt;cur_start_row) {
 798       ptr-&gt;cur_start_row = start_row;
 799     } else {
 800       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 801       long ltemp;
 802 
</pre>
<hr />
<pre>
 847 
 848 
 849 METHODDEF(JBLOCKARRAY)
 850 access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
 851             JDIMENSION start_row, JDIMENSION num_rows,
 852             boolean writable)
 853 /* Access the part of a virtual block array starting at start_row */
 854 /* and extending for num_rows rows.  writable is true if  */
 855 /* caller intends to modify the accessed area. */
 856 {
 857   JDIMENSION end_row = start_row + num_rows;
 858   JDIMENSION undef_row;
 859 
 860   /* debugging check */
 861   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 862       ptr-&gt;mem_buffer == NULL)
 863     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 864 
 865   /* Make the desired part of the virtual array accessible */
 866   if (start_row &lt; ptr-&gt;cur_start_row ||
<span class="line-modified"> 867       end_row &gt; ptr-&gt;cur_start_row+ptr-&gt;rows_in_mem) {</span>
 868     if (! ptr-&gt;b_s_open)
 869       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 870     /* Flush old buffer contents if necessary */
 871     if (ptr-&gt;dirty) {
 872       do_barray_io(cinfo, ptr, TRUE);
 873       ptr-&gt;dirty = FALSE;
 874     }
 875     /* Decide what part of virtual array to access.
 876      * Algorithm: if target address &gt; current window, assume forward scan,
 877      * load starting at target address.  If target address &lt; current window,
 878      * assume backward scan, load so that target area is top of window.
 879      * Note that when switching from forward write to forward read, will have
 880      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 881      */
 882     if (start_row &gt; ptr-&gt;cur_start_row) {
 883       ptr-&gt;cur_start_row = start_row;
 884     } else {
 885       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 886       long ltemp;
 887 
</pre>
<hr />
<pre>
1084   mem-&gt;pub.access_virt_barray = access_virt_barray;
1085   mem-&gt;pub.free_pool = free_pool;
1086   mem-&gt;pub.self_destruct = self_destruct;
1087 
1088   /* Make MAX_ALLOC_CHUNK accessible to other modules */
1089   mem-&gt;pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
1090 
1091   /* Initialize working state */
1092   mem-&gt;pub.max_memory_to_use = max_to_use;
1093 
1094   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {
1095     mem-&gt;small_list[pool] = NULL;
1096     mem-&gt;large_list[pool] = NULL;
1097   }
1098   mem-&gt;virt_sarray_list = NULL;
1099   mem-&gt;virt_barray_list = NULL;
1100 
1101   mem-&gt;total_space_allocated = SIZEOF(my_memory_mgr);
1102 
1103   /* Declare ourselves open for business */
<span class="line-modified">1104   cinfo-&gt;mem = &amp; mem-&gt;pub;</span>
1105 
1106   /* Check for an environment variable JPEGMEM; if found, override the
1107    * default max_memory setting from jpeg_mem_init.  Note that the
1108    * surrounding application may again override this value.
1109    * If your system doesn&#39;t support getenv(), define NO_GETENV to disable
1110    * this feature.
1111    */
1112 #ifndef NO_GETENV
1113   { char * memenv;
1114 
1115     if ((memenv = getenv(&quot;JPEGMEM&quot;)) != NULL) {
1116       char ch = &#39;x&#39;;
1117 
1118       if (sscanf(memenv, &quot;%ld%c&quot;, &amp;max_to_use, &amp;ch) &gt; 0) {
1119     if (ch == &#39;m&#39; || ch == &#39;M&#39;)
1120       max_to_use *= 1000L;
1121     mem-&gt;pub.max_memory_to_use = max_to_use * 1000L;
1122       }
1123     }
1124   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * jmemmgr.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
<span class="line-modified">   5  * Modified 2011-2019 by Guido Vollbeding.</span>
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains the JPEG system-independent memory management
  10  * routines.  This code is usable across a wide variety of machines; most
  11  * of the system dependencies have been isolated in a separate file.
  12  * The major functions provided here are:
  13  *   * pool-based allocation and freeing of memory;
  14  *   * policy decisions about how to divide available memory among the
  15  *     virtual arrays;
  16  *   * control logic for swapping virtual arrays between main memory and
  17  *     backing storage.
  18  * The separate system-dependent file provides the actual backing-storage
  19  * access code, and it contains the policy decision about how much total
  20  * main memory to use.
  21  * This file is system-dependent in the sense that some of its functions
  22  * are unnecessary in some systems.  For example, if there is enough virtual
  23  * memory so that backing storage will never be used, much of the virtual
  24  * array control logic could be removed.  (Of course, if you have that much
  25  * memory then you shouldn&#39;t care about a little bit of unused code...)
</pre>
<hr />
<pre>
 113 /*
 114  * Here is the full definition of a memory manager object.
 115  */
 116 
 117 typedef struct {
 118   struct jpeg_memory_mgr pub;    /* public fields */
 119 
 120   /* Each pool identifier (lifetime class) names a linked list of pools. */
 121   small_pool_ptr small_list[JPOOL_NUMPOOLS];
 122   large_pool_ptr large_list[JPOOL_NUMPOOLS];
 123 
 124   /* Since we only have one lifetime class of virtual arrays, only one
 125    * linked list is necessary (for each datatype).  Note that the virtual
 126    * array control blocks being linked together are actually stored somewhere
 127    * in the small-pool list.
 128    */
 129   jvirt_sarray_ptr virt_sarray_list;
 130   jvirt_barray_ptr virt_barray_list;
 131 
 132   /* This counts total space obtained from jpeg_get_small/large */
<span class="line-modified"> 133   size_t total_space_allocated;</span>
 134 
 135   /* alloc_sarray and alloc_barray set this value for use by virtual
 136    * array routines.
 137    */
 138   JDIMENSION last_rowsperchunk;    /* from most recent alloc_sarray/barray */
 139 } my_memory_mgr;
 140 
 141 typedef my_memory_mgr * my_mem_ptr;
 142 
 143 
 144 /*
 145  * The control blocks for virtual arrays.
 146  * Note that these blocks are allocated in the &quot;small&quot; pool area.
 147  * System-dependent info for the associated backing store (if any) is hidden
 148  * inside the backing_store_info struct.
 149  */
 150 
 151 struct jvirt_sarray_control {
 152   JSAMPARRAY mem_buffer;    /* =&gt; the in-memory buffer */
 153   JDIMENSION rows_in_array;    /* total virtual array height */
</pre>
<hr />
<pre>
 178   boolean b_s_open;        /* is backing-store data valid? */
 179   jvirt_barray_ptr next;    /* link to next virtual barray control block */
 180   backing_store_info b_s_info;    /* System-dependent control info */
 181 };
 182 
 183 
 184 #ifdef MEM_STATS        /* optional extra stuff for statistics */
 185 
 186 LOCAL(void)
 187 print_mem_stats (j_common_ptr cinfo, int pool_id)
 188 {
 189   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 190   small_pool_ptr shdr_ptr;
 191   large_pool_ptr lhdr_ptr;
 192 
 193   /* Since this is only a debugging stub, we can cheat a little by using
 194    * fprintf directly rather than going through the trace message code.
 195    * This is helpful because message parm array can&#39;t handle longs.
 196    */
 197   fprintf(stderr, &quot;Freeing pool %d, total space = %ld\n&quot;,
<span class="line-modified"> 198       pool_id, (long) mem-&gt;total_space_allocated);</span>
 199 
 200   for (lhdr_ptr = mem-&gt;large_list[pool_id]; lhdr_ptr != NULL;
 201        lhdr_ptr = lhdr_ptr-&gt;hdr.next) {
 202     fprintf(stderr, &quot;  Large chunk used %ld\n&quot;,
 203         (long) lhdr_ptr-&gt;hdr.bytes_used);
 204   }
 205 
 206   for (shdr_ptr = mem-&gt;small_list[pool_id]; shdr_ptr != NULL;
 207        shdr_ptr = shdr_ptr-&gt;hdr.next) {
 208     fprintf(stderr, &quot;  Small chunk used %ld free %ld\n&quot;,
 209         (long) shdr_ptr-&gt;hdr.bytes_used,
 210         (long) shdr_ptr-&gt;hdr.bytes_left);
 211   }
 212 }
 213 
 214 #endif /* MEM_STATS */
 215 
 216 
 217 LOCAL(noreturn_t)
 218 out_of_memory (j_common_ptr cinfo, int which)
</pre>
<hr />
<pre>
 243 {
 244     1600,            /* first PERMANENT pool */
 245     16000            /* first IMAGE pool */
 246 };
 247 
 248 static const size_t extra_pool_slop[JPOOL_NUMPOOLS] =
 249 {
 250     0,            /* additional PERMANENT pools */
 251     5000            /* additional IMAGE pools */
 252 };
 253 
 254 #define MIN_SLOP  50        /* greater than 0 to avoid futile looping */
 255 
 256 
 257 METHODDEF(void *)
 258 alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 259 /* Allocate a &quot;small&quot; object */
 260 {
 261   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 262   small_pool_ptr hdr_ptr, prev_hdr_ptr;

 263   size_t odd_bytes, min_request, slop;
<span class="line-added"> 264   char * data_ptr;</span>
 265 
 266   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<span class="line-modified"> 267   if (sizeofobject &gt; (size_t) MAX_ALLOC_CHUNK - SIZEOF(small_pool_hdr))</span>
 268     out_of_memory(cinfo, 1);    /* request exceeds malloc&#39;s ability */
 269 
 270   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 271   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 272   if (odd_bytes &gt; 0)
 273     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 274 
 275   /* See if space is available in any existing pool */
 276   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 277     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 278   prev_hdr_ptr = NULL;
 279   hdr_ptr = mem-&gt;small_list[pool_id];
 280   while (hdr_ptr != NULL) {
 281     if (hdr_ptr-&gt;hdr.bytes_left &gt;= sizeofobject)
 282       break;            /* found pool with enough space */
 283     prev_hdr_ptr = hdr_ptr;
 284     hdr_ptr = hdr_ptr-&gt;hdr.next;
 285   }
 286 
 287   /* Time to make a new pool? */
 288   if (hdr_ptr == NULL) {
 289     /* min_request is what we need now, slop is what will be leftover */
 290     min_request = sizeofobject + SIZEOF(small_pool_hdr);
 291     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 292       slop = first_pool_slop[pool_id];
 293     else
 294       slop = extra_pool_slop[pool_id];
 295     /* Don&#39;t ask for more than MAX_ALLOC_CHUNK */
<span class="line-modified"> 296     if (slop &gt; (size_t) MAX_ALLOC_CHUNK - min_request)</span>
<span class="line-modified"> 297       slop = (size_t) MAX_ALLOC_CHUNK - min_request;</span>
 298     /* Try to get space, if fail reduce slop and try again */
 299     for (;;) {
 300       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 301       if (hdr_ptr != NULL)
 302     break;
 303       slop /= 2;
 304       if (slop &lt; MIN_SLOP)    /* give up when it gets real small */
 305     out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 306     }
 307     mem-&gt;total_space_allocated += min_request + slop;
 308     /* Success, initialize the new pool header and add to end of list */
 309     hdr_ptr-&gt;hdr.next = NULL;
 310     hdr_ptr-&gt;hdr.bytes_used = 0;
 311     hdr_ptr-&gt;hdr.bytes_left = sizeofobject + slop;
 312     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 313       mem-&gt;small_list[pool_id] = hdr_ptr;
 314     else
 315       prev_hdr_ptr-&gt;hdr.next = hdr_ptr;
 316   }
 317 
</pre>
<hr />
<pre>
 331  * The external semantics of these are the same as &quot;small&quot; objects,
 332  * except that FAR pointers are used on 80x86.  However the pool
 333  * management heuristics are quite different.  We assume that each
 334  * request is large enough that it may as well be passed directly to
 335  * jpeg_get_large; the pool management just links everything together
 336  * so that we can free it all on demand.
 337  * Note: the major use of &quot;large&quot; objects is in JSAMPARRAY and JBLOCKARRAY
 338  * structures.  The routines that create these structures (see below)
 339  * deliberately bunch rows together to ensure a large request size.
 340  */
 341 
 342 METHODDEF(void FAR *)
 343 alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 344 /* Allocate a &quot;large&quot; object */
 345 {
 346   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 347   large_pool_ptr hdr_ptr;
 348   size_t odd_bytes;
 349 
 350   /* Check for unsatisfiable request (do now to ensure no overflow below) */
<span class="line-modified"> 351   if (sizeofobject &gt; (size_t) MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr))</span>
 352     out_of_memory(cinfo, 3);    /* request exceeds malloc&#39;s ability */
 353 
 354   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 355   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 356   if (odd_bytes &gt; 0)
 357     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 358 
 359   /* Always make a new pool */
 360   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 361     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 362 
 363   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 364                         SIZEOF(large_pool_hdr));
 365   if (hdr_ptr == NULL)
 366     out_of_memory(cinfo, 4);    /* jpeg_get_large failed */
 367   mem-&gt;total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 368 
 369   /* Success, initialize the new pool header and add to list */
 370   hdr_ptr-&gt;hdr.next = mem-&gt;large_list[pool_id];
 371   /* We maintain space counts in each pool header for statistical purposes,
</pre>
<hr />
<pre>
 391  * object so that it can be saved away if this sarray is the workspace for
 392  * a virtual array.
 393  */
 394 
 395 METHODDEF(JSAMPARRAY)
 396 alloc_sarray (j_common_ptr cinfo, int pool_id,
 397           JDIMENSION samplesperrow, JDIMENSION numrows)
 398 /* Allocate a 2-D sample array */
 399 {
 400   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 401   JSAMPARRAY result;
 402   JSAMPROW workspace;
 403   JDIMENSION rowsperchunk, currow, i;
 404   long ltemp;
 405 
 406   if (samplesperrow == 0) {
 407     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 408   }
 409 
 410   /* Calculate max # of rows allowed in one allocation chunk */
<span class="line-modified"> 411   ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /</span>
 412       ((long) samplesperrow * SIZEOF(JSAMPLE));
 413   if (ltemp &lt;= 0)
 414     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 415   if (ltemp &lt; (long) numrows)
 416     rowsperchunk = (JDIMENSION) ltemp;
 417   else
 418     rowsperchunk = numrows;
 419   mem-&gt;last_rowsperchunk = rowsperchunk;
 420 
 421   /* Get space for row pointers (small object) */
 422   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
<span class="line-modified"> 423                     (size_t) numrows * SIZEOF(JSAMPROW));</span>
 424 
 425   /* Get the rows themselves (large objects) */
 426   currow = 0;
 427   while (currow &lt; numrows) {
 428     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 429     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
<span class="line-modified"> 430       (size_t) rowsperchunk * (size_t) samplesperrow * SIZEOF(JSAMPLE));</span>

 431     for (i = rowsperchunk; i &gt; 0; i--) {
 432       result[currow++] = workspace;
 433       workspace += samplesperrow;
 434     }
 435   }
 436 
 437   return result;
 438 }
 439 
 440 
 441 /*
 442  * Creation of 2-D coefficient-block arrays.
 443  * This is essentially the same as the code for sample arrays, above.
 444  */
 445 
 446 METHODDEF(JBLOCKARRAY)
 447 alloc_barray (j_common_ptr cinfo, int pool_id,
 448           JDIMENSION blocksperrow, JDIMENSION numrows)
 449 /* Allocate a 2-D coefficient-block array */
 450 {
 451   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 452   JBLOCKARRAY result;
 453   JBLOCKROW workspace;
 454   JDIMENSION rowsperchunk, currow, i;
 455   long ltemp;
 456 
 457   if (blocksperrow == 0) {
 458     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 459   }
 460 
 461   /* Calculate max # of rows allowed in one allocation chunk */
<span class="line-modified"> 462   ltemp = (MAX_ALLOC_CHUNK - SIZEOF(large_pool_hdr)) /</span>
 463       ((long) blocksperrow * SIZEOF(JBLOCK));
 464   if (ltemp &lt;= 0)
 465     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 466   if (ltemp &lt; (long) numrows)
 467     rowsperchunk = (JDIMENSION) ltemp;
 468   else
 469     rowsperchunk = numrows;
 470   mem-&gt;last_rowsperchunk = rowsperchunk;
 471 
 472   /* Get space for row pointers (small object) */
 473   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
<span class="line-modified"> 474                      (size_t) numrows * SIZEOF(JBLOCKROW));</span>
 475 
 476   /* Get the rows themselves (large objects) */
 477   currow = 0;
 478   while (currow &lt; numrows) {
 479     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 480     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
<span class="line-modified"> 481       (size_t) rowsperchunk * (size_t) blocksperrow * SIZEOF(JBLOCK));</span>

 482     for (i = rowsperchunk; i &gt; 0; i--) {
 483       result[currow++] = workspace;
 484       workspace += blocksperrow;
 485     }
 486   }
 487 
 488   return result;
 489 }
 490 
 491 
 492 /*
 493  * About virtual array management:
 494  *
 495  * The above &quot;normal&quot; array routines are only used to allocate strip buffers
 496  * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 497  * are handled as &quot;virtual&quot; arrays.  The array is still accessed a strip at a
 498  * time, but the memory manager must save the whole array for repeated
 499  * accesses.  The intended implementation is that there is a strip buffer in
 500  * memory (as high as is possible given the desired memory limit), plus a
 501  * backing file that holds the rest of the array.
</pre>
<hr />
<pre>
 574                       SIZEOF(struct jvirt_barray_control));
 575 
 576   result-&gt;mem_buffer = NULL;    /* marks array not yet realized */
 577   result-&gt;rows_in_array = numrows;
 578   result-&gt;blocksperrow = blocksperrow;
 579   result-&gt;maxaccess = maxaccess;
 580   result-&gt;pre_zero = pre_zero;
 581   result-&gt;b_s_open = FALSE;    /* no associated backing-store object */
 582   result-&gt;next = mem-&gt;virt_barray_list; /* add to list of virtual arrays */
 583   mem-&gt;virt_barray_list = result;
 584 
 585   return result;
 586 }
 587 
 588 
 589 METHODDEF(void)
 590 realize_virt_arrays (j_common_ptr cinfo)
 591 /* Allocate the in-memory buffers for any unrealized virtual arrays */
 592 {
 593   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
<span class="line-modified"> 594   long bytesperrow, space_per_minheight, maximum_space;</span>
<span class="line-modified"> 595   long avail_mem, minheights, max_minheights;</span>
 596   jvirt_sarray_ptr sptr;
 597   jvirt_barray_ptr bptr;
 598 
 599   /* Compute the minimum space needed (maxaccess rows in each buffer)
 600    * and the maximum space needed (full image height in each buffer).
 601    * These may be of use to the system-dependent jpeg_mem_available routine.
 602    */
 603   space_per_minheight = 0;
 604   maximum_space = 0;
 605   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 606     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
<span class="line-modified"> 607       bytesperrow = (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);</span>
<span class="line-modified"> 608       space_per_minheight += (long) sptr-&gt;maxaccess * bytesperrow;</span>
<span class="line-modified"> 609       maximum_space += (long) sptr-&gt;rows_in_array * bytesperrow;</span>

 610     }
 611   }
 612   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 613     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */
<span class="line-modified"> 614       bytesperrow = (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);</span>
<span class="line-modified"> 615       space_per_minheight += (long) bptr-&gt;maxaccess * bytesperrow;</span>
<span class="line-modified"> 616       maximum_space += (long) bptr-&gt;rows_in_array * bytesperrow;</span>

 617     }
 618   }
 619 
 620   if (space_per_minheight &lt;= 0)
 621     return;            /* no unrealized arrays, no work */
 622 
 623   /* Determine amount of memory to actually use; this is system-dependent. */
 624   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
<span class="line-modified"> 625                  (long) mem-&gt;total_space_allocated);</span>
 626 
 627   /* If the maximum space needed is available, make all the buffers full
 628    * height; otherwise parcel it out with the same number of minheights
 629    * in each buffer.
 630    */
 631   if (avail_mem &gt;= maximum_space)
 632     max_minheights = 1000000000L;
 633   else {
 634     max_minheights = avail_mem / space_per_minheight;
 635     /* If there doesn&#39;t seem to be enough space, try to get the minimum
 636      * anyway.  This allows a &quot;stub&quot; implementation of jpeg_mem_available().
 637      */
 638     if (max_minheights &lt;= 0)
 639       max_minheights = 1;
 640   }
 641 
 642   /* Allocate the in-memory buffers and initialize backing store as needed. */
 643 
 644   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 645     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
</pre>
<hr />
<pre>
 681     bptr-&gt;b_s_open = TRUE;
 682       }
 683       bptr-&gt;mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 684                       bptr-&gt;blocksperrow, bptr-&gt;rows_in_mem);
 685       bptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;
 686       bptr-&gt;cur_start_row = 0;
 687       bptr-&gt;first_undef_row = 0;
 688       bptr-&gt;dirty = FALSE;
 689     }
 690   }
 691 }
 692 
 693 
 694 LOCAL(void)
 695 do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
 696 /* Do backing store read or write of a virtual sample array */
 697 {
 698   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 699 
 700   bytesperrow = (long) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
<span class="line-modified"> 701   file_offset = (long) ptr-&gt;cur_start_row * bytesperrow;</span>
 702   /* Loop to read or write each allocation chunk in mem_buffer */
 703   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 704     /* One chunk, but check for short chunk at end of buffer */
 705     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 706     /* Transfer no more than is currently defined */
 707     thisrow = (long) ptr-&gt;cur_start_row + i;
 708     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 709     /* Transfer no more than fits in file */
 710     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 711     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 712       break;
 713     byte_count = rows * bytesperrow;
 714     if (writing)
 715       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 716                         (void FAR *) ptr-&gt;mem_buffer[i],
 717                         file_offset, byte_count);
 718     else
 719       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 720                        (void FAR *) ptr-&gt;mem_buffer[i],
 721                        file_offset, byte_count);
 722     file_offset += byte_count;
 723   }
 724 }
 725 
 726 
 727 LOCAL(void)
 728 do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
 729 /* Do backing store read or write of a virtual coefficient-block array */
 730 {
 731   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 732 
 733   bytesperrow = (long) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);
<span class="line-modified"> 734   file_offset = (long) ptr-&gt;cur_start_row * bytesperrow;</span>
 735   /* Loop to read or write each allocation chunk in mem_buffer */
 736   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 737     /* One chunk, but check for short chunk at end of buffer */
 738     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 739     /* Transfer no more than is currently defined */
 740     thisrow = (long) ptr-&gt;cur_start_row + i;
 741     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 742     /* Transfer no more than fits in file */
 743     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 744     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 745       break;
 746     byte_count = rows * bytesperrow;
 747     if (writing)
 748       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 749                         (void FAR *) ptr-&gt;mem_buffer[i],
 750                         file_offset, byte_count);
 751     else
 752       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 753                        (void FAR *) ptr-&gt;mem_buffer[i],
 754                        file_offset, byte_count);
</pre>
<hr />
<pre>
 758 
 759 
 760 METHODDEF(JSAMPARRAY)
 761 access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 762             JDIMENSION start_row, JDIMENSION num_rows,
 763             boolean writable)
 764 /* Access the part of a virtual sample array starting at start_row */
 765 /* and extending for num_rows rows.  writable is true if  */
 766 /* caller intends to modify the accessed area. */
 767 {
 768   JDIMENSION end_row = start_row + num_rows;
 769   JDIMENSION undef_row;
 770 
 771   /* debugging check */
 772   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 773       ptr-&gt;mem_buffer == NULL)
 774     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 775 
 776   /* Make the desired part of the virtual array accessible */
 777   if (start_row &lt; ptr-&gt;cur_start_row ||
<span class="line-modified"> 778       end_row &gt; ptr-&gt;cur_start_row + ptr-&gt;rows_in_mem) {</span>
 779     if (! ptr-&gt;b_s_open)
 780       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 781     /* Flush old buffer contents if necessary */
 782     if (ptr-&gt;dirty) {
 783       do_sarray_io(cinfo, ptr, TRUE);
 784       ptr-&gt;dirty = FALSE;
 785     }
 786     /* Decide what part of virtual array to access.
 787      * Algorithm: if target address &gt; current window, assume forward scan,
 788      * load starting at target address.  If target address &lt; current window,
 789      * assume backward scan, load so that target area is top of window.
 790      * Note that when switching from forward write to forward read, will have
 791      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 792      */
 793     if (start_row &gt; ptr-&gt;cur_start_row) {
 794       ptr-&gt;cur_start_row = start_row;
 795     } else {
 796       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 797       long ltemp;
 798 
</pre>
<hr />
<pre>
 843 
 844 
 845 METHODDEF(JBLOCKARRAY)
 846 access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
 847             JDIMENSION start_row, JDIMENSION num_rows,
 848             boolean writable)
 849 /* Access the part of a virtual block array starting at start_row */
 850 /* and extending for num_rows rows.  writable is true if  */
 851 /* caller intends to modify the accessed area. */
 852 {
 853   JDIMENSION end_row = start_row + num_rows;
 854   JDIMENSION undef_row;
 855 
 856   /* debugging check */
 857   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 858       ptr-&gt;mem_buffer == NULL)
 859     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 860 
 861   /* Make the desired part of the virtual array accessible */
 862   if (start_row &lt; ptr-&gt;cur_start_row ||
<span class="line-modified"> 863       end_row &gt; ptr-&gt;cur_start_row + ptr-&gt;rows_in_mem) {</span>
 864     if (! ptr-&gt;b_s_open)
 865       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 866     /* Flush old buffer contents if necessary */
 867     if (ptr-&gt;dirty) {
 868       do_barray_io(cinfo, ptr, TRUE);
 869       ptr-&gt;dirty = FALSE;
 870     }
 871     /* Decide what part of virtual array to access.
 872      * Algorithm: if target address &gt; current window, assume forward scan,
 873      * load starting at target address.  If target address &lt; current window,
 874      * assume backward scan, load so that target area is top of window.
 875      * Note that when switching from forward write to forward read, will have
 876      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 877      */
 878     if (start_row &gt; ptr-&gt;cur_start_row) {
 879       ptr-&gt;cur_start_row = start_row;
 880     } else {
 881       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 882       long ltemp;
 883 
</pre>
<hr />
<pre>
1080   mem-&gt;pub.access_virt_barray = access_virt_barray;
1081   mem-&gt;pub.free_pool = free_pool;
1082   mem-&gt;pub.self_destruct = self_destruct;
1083 
1084   /* Make MAX_ALLOC_CHUNK accessible to other modules */
1085   mem-&gt;pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
1086 
1087   /* Initialize working state */
1088   mem-&gt;pub.max_memory_to_use = max_to_use;
1089 
1090   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {
1091     mem-&gt;small_list[pool] = NULL;
1092     mem-&gt;large_list[pool] = NULL;
1093   }
1094   mem-&gt;virt_sarray_list = NULL;
1095   mem-&gt;virt_barray_list = NULL;
1096 
1097   mem-&gt;total_space_allocated = SIZEOF(my_memory_mgr);
1098 
1099   /* Declare ourselves open for business */
<span class="line-modified">1100   cinfo-&gt;mem = &amp;mem-&gt;pub;</span>
1101 
1102   /* Check for an environment variable JPEGMEM; if found, override the
1103    * default max_memory setting from jpeg_mem_init.  Note that the
1104    * surrounding application may again override this value.
1105    * If your system doesn&#39;t support getenv(), define NO_GETENV to disable
1106    * this feature.
1107    */
1108 #ifndef NO_GETENV
1109   { char * memenv;
1110 
1111     if ((memenv = getenv(&quot;JPEGMEM&quot;)) != NULL) {
1112       char ch = &#39;x&#39;;
1113 
1114       if (sscanf(memenv, &quot;%ld%c&quot;, &amp;max_to_use, &amp;ch) &gt; 0) {
1115     if (ch == &#39;m&#39; || ch == &#39;M&#39;)
1116       max_to_use *= 1000L;
1117     mem-&gt;pub.max_memory_to_use = max_to_use * 1000L;
1118       }
1119     }
1120   }
</pre>
</td>
</tr>
</table>
<center><a href="jidctint.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="jmemnobs.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
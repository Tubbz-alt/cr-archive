<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-iio/libjpeg/jmemmgr.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * jmemmgr.c
   3  *
   4  * Copyright (C) 1991-1997, Thomas G. Lane.
   5  * Modified 2011-2012 by Guido Vollbeding.
   6  * This file is part of the Independent JPEG Group&#39;s software.
   7  * For conditions of distribution and use, see the accompanying README file.
   8  *
   9  * This file contains the JPEG system-independent memory management
  10  * routines.  This code is usable across a wide variety of machines; most
  11  * of the system dependencies have been isolated in a separate file.
  12  * The major functions provided here are:
  13  *   * pool-based allocation and freeing of memory;
  14  *   * policy decisions about how to divide available memory among the
  15  *     virtual arrays;
  16  *   * control logic for swapping virtual arrays between main memory and
  17  *     backing storage.
  18  * The separate system-dependent file provides the actual backing-storage
  19  * access code, and it contains the policy decision about how much total
  20  * main memory to use.
  21  * This file is system-dependent in the sense that some of its functions
  22  * are unnecessary in some systems.  For example, if there is enough virtual
  23  * memory so that backing storage will never be used, much of the virtual
  24  * array control logic could be removed.  (Of course, if you have that much
  25  * memory then you shouldn&#39;t care about a little bit of unused code...)
  26  */
  27 
  28 #define JPEG_INTERNALS
  29 #define AM_MEMORY_MANAGER    /* we define jvirt_Xarray_control structs */
  30 #include &quot;jinclude.h&quot;
  31 #include &quot;jpeglib.h&quot;
  32 #include &quot;jmemsys.h&quot;        /* import the system-dependent declarations */
  33 
  34 #ifndef NO_GETENV
  35 #ifndef HAVE_STDLIB_H        /* &lt;stdlib.h&gt; should declare getenv() */
  36 extern char * getenv JPP((const char * name));
  37 #endif
  38 #endif
  39 
  40 
  41 /*
  42  * Some important notes:
  43  *   The allocation routines provided here must never return NULL.
  44  *   They should exit to error_exit if unsuccessful.
  45  *
  46  *   It&#39;s not a good idea to try to merge the sarray and barray routines,
  47  *   even though they are textually almost the same, because samples are
  48  *   usually stored as bytes while coefficients are shorts or ints.  Thus,
  49  *   in machines where byte pointers have a different representation from
  50  *   word pointers, the resulting machine code could not be the same.
  51  */
  52 
  53 
  54 /*
  55  * Many machines require storage alignment: longs must start on 4-byte
  56  * boundaries, doubles on 8-byte boundaries, etc.  On such machines, malloc()
  57  * always returns pointers that are multiples of the worst-case alignment
  58  * requirement, and we had better do so too.
  59  * There isn&#39;t any really portable way to determine the worst-case alignment
  60  * requirement.  This module assumes that the alignment requirement is
  61  * multiples of sizeof(ALIGN_TYPE).
  62  * By default, we define ALIGN_TYPE as double.  This is necessary on some
  63  * workstations (where doubles really do need 8-byte alignment) and will work
  64  * fine on nearly everything.  If your machine has lesser alignment needs,
  65  * you can save a few bytes by making ALIGN_TYPE smaller.
  66  * The only place I know of where this will NOT work is certain Macintosh
  67  * 680x0 compilers that define double as a 10-byte IEEE extended float.
  68  * Doing 10-byte alignment is counterproductive because longwords won&#39;t be
  69  * aligned well.  Put &quot;#define ALIGN_TYPE long&quot; in jconfig.h if you have
  70  * such a compiler.
  71  */
  72 
  73 #ifndef ALIGN_TYPE        /* so can override from jconfig.h */
  74 #define ALIGN_TYPE  double
  75 #endif
  76 
  77 
  78 /*
  79  * We allocate objects from &quot;pools&quot;, where each pool is gotten with a single
  80  * request to jpeg_get_small() or jpeg_get_large().  There is no per-object
  81  * overhead within a pool, except for alignment padding.  Each pool has a
  82  * header with a link to the next pool of the same class.
  83  * Small and large pool headers are identical except that the latter&#39;s
  84  * link pointer must be FAR on 80x86 machines.
  85  * Notice that the &quot;real&quot; header fields are union&#39;ed with a dummy ALIGN_TYPE
  86  * field.  This forces the compiler to make SIZEOF(small_pool_hdr) a multiple
  87  * of the alignment requirement of ALIGN_TYPE.
  88  */
  89 
  90 typedef union small_pool_struct * small_pool_ptr;
  91 
  92 typedef union small_pool_struct {
  93   struct {
  94     small_pool_ptr next;    /* next in list of pools */
  95     size_t bytes_used;        /* how many bytes already used within pool */
  96     size_t bytes_left;        /* bytes still available in this pool */
  97   } hdr;
  98   ALIGN_TYPE dummy;        /* included in union to ensure alignment */
  99 } small_pool_hdr;
 100 
 101 typedef union large_pool_struct FAR * large_pool_ptr;
 102 
 103 typedef union large_pool_struct {
 104   struct {
 105     large_pool_ptr next;    /* next in list of pools */
 106     size_t bytes_used;        /* how many bytes already used within pool */
 107     size_t bytes_left;        /* bytes still available in this pool */
 108   } hdr;
 109   ALIGN_TYPE dummy;        /* included in union to ensure alignment */
 110 } large_pool_hdr;
 111 
 112 
 113 /*
 114  * Here is the full definition of a memory manager object.
 115  */
 116 
 117 typedef struct {
 118   struct jpeg_memory_mgr pub;    /* public fields */
 119 
 120   /* Each pool identifier (lifetime class) names a linked list of pools. */
 121   small_pool_ptr small_list[JPOOL_NUMPOOLS];
 122   large_pool_ptr large_list[JPOOL_NUMPOOLS];
 123 
 124   /* Since we only have one lifetime class of virtual arrays, only one
 125    * linked list is necessary (for each datatype).  Note that the virtual
 126    * array control blocks being linked together are actually stored somewhere
 127    * in the small-pool list.
 128    */
 129   jvirt_sarray_ptr virt_sarray_list;
 130   jvirt_barray_ptr virt_barray_list;
 131 
 132   /* This counts total space obtained from jpeg_get_small/large */
 133   long total_space_allocated;
 134 
 135   /* alloc_sarray and alloc_barray set this value for use by virtual
 136    * array routines.
 137    */
 138   JDIMENSION last_rowsperchunk;    /* from most recent alloc_sarray/barray */
 139 } my_memory_mgr;
 140 
 141 typedef my_memory_mgr * my_mem_ptr;
 142 
 143 
 144 /*
 145  * The control blocks for virtual arrays.
 146  * Note that these blocks are allocated in the &quot;small&quot; pool area.
 147  * System-dependent info for the associated backing store (if any) is hidden
 148  * inside the backing_store_info struct.
 149  */
 150 
 151 struct jvirt_sarray_control {
 152   JSAMPARRAY mem_buffer;    /* =&gt; the in-memory buffer */
 153   JDIMENSION rows_in_array;    /* total virtual array height */
 154   JDIMENSION samplesperrow;    /* width of array (and of memory buffer) */
 155   JDIMENSION maxaccess;        /* max rows accessed by access_virt_sarray */
 156   JDIMENSION rows_in_mem;    /* height of memory buffer */
 157   JDIMENSION rowsperchunk;    /* allocation chunk size in mem_buffer */
 158   JDIMENSION cur_start_row;    /* first logical row # in the buffer */
 159   JDIMENSION first_undef_row;    /* row # of first uninitialized row */
 160   boolean pre_zero;        /* pre-zero mode requested? */
 161   boolean dirty;        /* do current buffer contents need written? */
 162   boolean b_s_open;        /* is backing-store data valid? */
 163   jvirt_sarray_ptr next;    /* link to next virtual sarray control block */
 164   backing_store_info b_s_info;    /* System-dependent control info */
 165 };
 166 
 167 struct jvirt_barray_control {
 168   JBLOCKARRAY mem_buffer;    /* =&gt; the in-memory buffer */
 169   JDIMENSION rows_in_array;    /* total virtual array height */
 170   JDIMENSION blocksperrow;    /* width of array (and of memory buffer) */
 171   JDIMENSION maxaccess;        /* max rows accessed by access_virt_barray */
 172   JDIMENSION rows_in_mem;    /* height of memory buffer */
 173   JDIMENSION rowsperchunk;    /* allocation chunk size in mem_buffer */
 174   JDIMENSION cur_start_row;    /* first logical row # in the buffer */
 175   JDIMENSION first_undef_row;    /* row # of first uninitialized row */
 176   boolean pre_zero;        /* pre-zero mode requested? */
 177   boolean dirty;        /* do current buffer contents need written? */
 178   boolean b_s_open;        /* is backing-store data valid? */
 179   jvirt_barray_ptr next;    /* link to next virtual barray control block */
 180   backing_store_info b_s_info;    /* System-dependent control info */
 181 };
 182 
 183 
 184 #ifdef MEM_STATS        /* optional extra stuff for statistics */
 185 
 186 LOCAL(void)
 187 print_mem_stats (j_common_ptr cinfo, int pool_id)
 188 {
 189   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 190   small_pool_ptr shdr_ptr;
 191   large_pool_ptr lhdr_ptr;
 192 
 193   /* Since this is only a debugging stub, we can cheat a little by using
 194    * fprintf directly rather than going through the trace message code.
 195    * This is helpful because message parm array can&#39;t handle longs.
 196    */
 197   fprintf(stderr, &quot;Freeing pool %d, total space = %ld\n&quot;,
 198       pool_id, mem-&gt;total_space_allocated);
 199 
 200   for (lhdr_ptr = mem-&gt;large_list[pool_id]; lhdr_ptr != NULL;
 201        lhdr_ptr = lhdr_ptr-&gt;hdr.next) {
 202     fprintf(stderr, &quot;  Large chunk used %ld\n&quot;,
 203         (long) lhdr_ptr-&gt;hdr.bytes_used);
 204   }
 205 
 206   for (shdr_ptr = mem-&gt;small_list[pool_id]; shdr_ptr != NULL;
 207        shdr_ptr = shdr_ptr-&gt;hdr.next) {
 208     fprintf(stderr, &quot;  Small chunk used %ld free %ld\n&quot;,
 209         (long) shdr_ptr-&gt;hdr.bytes_used,
 210         (long) shdr_ptr-&gt;hdr.bytes_left);
 211   }
 212 }
 213 
 214 #endif /* MEM_STATS */
 215 
 216 
 217 LOCAL(noreturn_t)
 218 out_of_memory (j_common_ptr cinfo, int which)
 219 /* Report an out-of-memory error and stop execution */
 220 /* If we compiled MEM_STATS support, report alloc requests before dying */
 221 {
 222 #ifdef MEM_STATS
 223   cinfo-&gt;err-&gt;trace_level = 2;    /* force self_destruct to report stats */
 224 #endif
 225   ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
 226 }
 227 
 228 
 229 /*
 230  * Allocation of &quot;small&quot; objects.
 231  *
 232  * For these, we use pooled storage.  When a new pool must be created,
 233  * we try to get enough space for the current request plus a &quot;slop&quot; factor,
 234  * where the slop will be the amount of leftover space in the new pool.
 235  * The speed vs. space tradeoff is largely determined by the slop values.
 236  * A different slop value is provided for each pool class (lifetime),
 237  * and we also distinguish the first pool of a class from later ones.
 238  * NOTE: the values given work fairly well on both 16- and 32-bit-int
 239  * machines, but may be too small if longs are 64 bits or more.
 240  */
 241 
 242 static const size_t first_pool_slop[JPOOL_NUMPOOLS] =
 243 {
 244     1600,            /* first PERMANENT pool */
 245     16000            /* first IMAGE pool */
 246 };
 247 
 248 static const size_t extra_pool_slop[JPOOL_NUMPOOLS] =
 249 {
 250     0,            /* additional PERMANENT pools */
 251     5000            /* additional IMAGE pools */
 252 };
 253 
 254 #define MIN_SLOP  50        /* greater than 0 to avoid futile looping */
 255 
 256 
 257 METHODDEF(void *)
 258 alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 259 /* Allocate a &quot;small&quot; object */
 260 {
 261   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 262   small_pool_ptr hdr_ptr, prev_hdr_ptr;
 263   char * data_ptr;
 264   size_t odd_bytes, min_request, slop;
 265 
 266   /* Check for unsatisfiable request (do now to ensure no overflow below) */
 267   if (sizeofobject &gt; (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
 268     out_of_memory(cinfo, 1);    /* request exceeds malloc&#39;s ability */
 269 
 270   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 271   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 272   if (odd_bytes &gt; 0)
 273     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 274 
 275   /* See if space is available in any existing pool */
 276   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 277     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 278   prev_hdr_ptr = NULL;
 279   hdr_ptr = mem-&gt;small_list[pool_id];
 280   while (hdr_ptr != NULL) {
 281     if (hdr_ptr-&gt;hdr.bytes_left &gt;= sizeofobject)
 282       break;            /* found pool with enough space */
 283     prev_hdr_ptr = hdr_ptr;
 284     hdr_ptr = hdr_ptr-&gt;hdr.next;
 285   }
 286 
 287   /* Time to make a new pool? */
 288   if (hdr_ptr == NULL) {
 289     /* min_request is what we need now, slop is what will be leftover */
 290     min_request = sizeofobject + SIZEOF(small_pool_hdr);
 291     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 292       slop = first_pool_slop[pool_id];
 293     else
 294       slop = extra_pool_slop[pool_id];
 295     /* Don&#39;t ask for more than MAX_ALLOC_CHUNK */
 296     if (slop &gt; (size_t) (MAX_ALLOC_CHUNK-min_request))
 297       slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
 298     /* Try to get space, if fail reduce slop and try again */
 299     for (;;) {
 300       hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
 301       if (hdr_ptr != NULL)
 302     break;
 303       slop /= 2;
 304       if (slop &lt; MIN_SLOP)    /* give up when it gets real small */
 305     out_of_memory(cinfo, 2); /* jpeg_get_small failed */
 306     }
 307     mem-&gt;total_space_allocated += min_request + slop;
 308     /* Success, initialize the new pool header and add to end of list */
 309     hdr_ptr-&gt;hdr.next = NULL;
 310     hdr_ptr-&gt;hdr.bytes_used = 0;
 311     hdr_ptr-&gt;hdr.bytes_left = sizeofobject + slop;
 312     if (prev_hdr_ptr == NULL)    /* first pool in class? */
 313       mem-&gt;small_list[pool_id] = hdr_ptr;
 314     else
 315       prev_hdr_ptr-&gt;hdr.next = hdr_ptr;
 316   }
 317 
 318   /* OK, allocate the object from the current pool */
 319   data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
 320   data_ptr += hdr_ptr-&gt;hdr.bytes_used; /* point to place for object */
 321   hdr_ptr-&gt;hdr.bytes_used += sizeofobject;
 322   hdr_ptr-&gt;hdr.bytes_left -= sizeofobject;
 323 
 324   return (void *) data_ptr;
 325 }
 326 
 327 
 328 /*
 329  * Allocation of &quot;large&quot; objects.
 330  *
 331  * The external semantics of these are the same as &quot;small&quot; objects,
 332  * except that FAR pointers are used on 80x86.  However the pool
 333  * management heuristics are quite different.  We assume that each
 334  * request is large enough that it may as well be passed directly to
 335  * jpeg_get_large; the pool management just links everything together
 336  * so that we can free it all on demand.
 337  * Note: the major use of &quot;large&quot; objects is in JSAMPARRAY and JBLOCKARRAY
 338  * structures.  The routines that create these structures (see below)
 339  * deliberately bunch rows together to ensure a large request size.
 340  */
 341 
 342 METHODDEF(void FAR *)
 343 alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
 344 /* Allocate a &quot;large&quot; object */
 345 {
 346   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 347   large_pool_ptr hdr_ptr;
 348   size_t odd_bytes;
 349 
 350   /* Check for unsatisfiable request (do now to ensure no overflow below) */
 351   if (sizeofobject &gt; (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)))
 352     out_of_memory(cinfo, 3);    /* request exceeds malloc&#39;s ability */
 353 
 354   /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
 355   odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
 356   if (odd_bytes &gt; 0)
 357     sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
 358 
 359   /* Always make a new pool */
 360   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 361     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 362 
 363   hdr_ptr = (large_pool_ptr) jpeg_get_large(cinfo, sizeofobject +
 364                         SIZEOF(large_pool_hdr));
 365   if (hdr_ptr == NULL)
 366     out_of_memory(cinfo, 4);    /* jpeg_get_large failed */
 367   mem-&gt;total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
 368 
 369   /* Success, initialize the new pool header and add to list */
 370   hdr_ptr-&gt;hdr.next = mem-&gt;large_list[pool_id];
 371   /* We maintain space counts in each pool header for statistical purposes,
 372    * even though they are not needed for allocation.
 373    */
 374   hdr_ptr-&gt;hdr.bytes_used = sizeofobject;
 375   hdr_ptr-&gt;hdr.bytes_left = 0;
 376   mem-&gt;large_list[pool_id] = hdr_ptr;
 377 
 378   return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
 379 }
 380 
 381 
 382 /*
 383  * Creation of 2-D sample arrays.
 384  * The pointers are in near heap, the samples themselves in FAR heap.
 385  *
 386  * To minimize allocation overhead and to allow I/O of large contiguous
 387  * blocks, we allocate the sample rows in groups of as many rows as possible
 388  * without exceeding MAX_ALLOC_CHUNK total bytes per allocation request.
 389  * NB: the virtual array control routines, later in this file, know about
 390  * this chunking of rows.  The rowsperchunk value is left in the mem manager
 391  * object so that it can be saved away if this sarray is the workspace for
 392  * a virtual array.
 393  */
 394 
 395 METHODDEF(JSAMPARRAY)
 396 alloc_sarray (j_common_ptr cinfo, int pool_id,
 397           JDIMENSION samplesperrow, JDIMENSION numrows)
 398 /* Allocate a 2-D sample array */
 399 {
 400   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 401   JSAMPARRAY result;
 402   JSAMPROW workspace;
 403   JDIMENSION rowsperchunk, currow, i;
 404   long ltemp;
 405 
 406   if (samplesperrow == 0) {
 407     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 408   }
 409 
 410   /* Calculate max # of rows allowed in one allocation chunk */
 411   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 412       ((long) samplesperrow * SIZEOF(JSAMPLE));
 413   if (ltemp &lt;= 0)
 414     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 415   if (ltemp &lt; (long) numrows)
 416     rowsperchunk = (JDIMENSION) ltemp;
 417   else
 418     rowsperchunk = numrows;
 419   mem-&gt;last_rowsperchunk = rowsperchunk;
 420 
 421   /* Get space for row pointers (small object) */
 422   result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
 423                     (size_t) (numrows * SIZEOF(JSAMPROW)));
 424 
 425   /* Get the rows themselves (large objects) */
 426   currow = 0;
 427   while (currow &lt; numrows) {
 428     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 429     workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
 430     (size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
 431           * SIZEOF(JSAMPLE)));
 432     for (i = rowsperchunk; i &gt; 0; i--) {
 433       result[currow++] = workspace;
 434       workspace += samplesperrow;
 435     }
 436   }
 437 
 438   return result;
 439 }
 440 
 441 
 442 /*
 443  * Creation of 2-D coefficient-block arrays.
 444  * This is essentially the same as the code for sample arrays, above.
 445  */
 446 
 447 METHODDEF(JBLOCKARRAY)
 448 alloc_barray (j_common_ptr cinfo, int pool_id,
 449           JDIMENSION blocksperrow, JDIMENSION numrows)
 450 /* Allocate a 2-D coefficient-block array */
 451 {
 452   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 453   JBLOCKARRAY result;
 454   JBLOCKROW workspace;
 455   JDIMENSION rowsperchunk, currow, i;
 456   long ltemp;
 457 
 458   if (blocksperrow == 0) {
 459     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 460   }
 461 
 462   /* Calculate max # of rows allowed in one allocation chunk */
 463   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
 464       ((long) blocksperrow * SIZEOF(JBLOCK));
 465   if (ltemp &lt;= 0)
 466     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 467   if (ltemp &lt; (long) numrows)
 468     rowsperchunk = (JDIMENSION) ltemp;
 469   else
 470     rowsperchunk = numrows;
 471   mem-&gt;last_rowsperchunk = rowsperchunk;
 472 
 473   /* Get space for row pointers (small object) */
 474   result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
 475                      (size_t) (numrows * SIZEOF(JBLOCKROW)));
 476 
 477   /* Get the rows themselves (large objects) */
 478   currow = 0;
 479   while (currow &lt; numrows) {
 480     rowsperchunk = MIN(rowsperchunk, numrows - currow);
 481     workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
 482     (size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
 483           * SIZEOF(JBLOCK)));
 484     for (i = rowsperchunk; i &gt; 0; i--) {
 485       result[currow++] = workspace;
 486       workspace += blocksperrow;
 487     }
 488   }
 489 
 490   return result;
 491 }
 492 
 493 
 494 /*
 495  * About virtual array management:
 496  *
 497  * The above &quot;normal&quot; array routines are only used to allocate strip buffers
 498  * (as wide as the image, but just a few rows high).  Full-image-sized buffers
 499  * are handled as &quot;virtual&quot; arrays.  The array is still accessed a strip at a
 500  * time, but the memory manager must save the whole array for repeated
 501  * accesses.  The intended implementation is that there is a strip buffer in
 502  * memory (as high as is possible given the desired memory limit), plus a
 503  * backing file that holds the rest of the array.
 504  *
 505  * The request_virt_array routines are told the total size of the image and
 506  * the maximum number of rows that will be accessed at once.  The in-memory
 507  * buffer must be at least as large as the maxaccess value.
 508  *
 509  * The request routines create control blocks but not the in-memory buffers.
 510  * That is postponed until realize_virt_arrays is called.  At that time the
 511  * total amount of space needed is known (approximately, anyway), so free
 512  * memory can be divided up fairly.
 513  *
 514  * The access_virt_array routines are responsible for making a specific strip
 515  * area accessible (after reading or writing the backing file, if necessary).
 516  * Note that the access routines are told whether the caller intends to modify
 517  * the accessed strip; during a read-only pass this saves having to rewrite
 518  * data to disk.  The access routines are also responsible for pre-zeroing
 519  * any newly accessed rows, if pre-zeroing was requested.
 520  *
 521  * In current usage, the access requests are usually for nonoverlapping
 522  * strips; that is, successive access start_row numbers differ by exactly
 523  * num_rows = maxaccess.  This means we can get good performance with simple
 524  * buffer dump/reload logic, by making the in-memory buffer be a multiple
 525  * of the access height; then there will never be accesses across bufferload
 526  * boundaries.  The code will still work with overlapping access requests,
 527  * but it doesn&#39;t handle bufferload overlaps very efficiently.
 528  */
 529 
 530 
 531 METHODDEF(jvirt_sarray_ptr)
 532 request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 533              JDIMENSION samplesperrow, JDIMENSION numrows,
 534              JDIMENSION maxaccess)
 535 /* Request a virtual 2-D sample array */
 536 {
 537   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 538   jvirt_sarray_ptr result;
 539 
 540   /* Only IMAGE-lifetime virtual arrays are currently supported */
 541   if (pool_id != JPOOL_IMAGE)
 542     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 543 
 544   /* get control block */
 545   result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id,
 546                       SIZEOF(struct jvirt_sarray_control));
 547 
 548   result-&gt;mem_buffer = NULL;    /* marks array not yet realized */
 549   result-&gt;rows_in_array = numrows;
 550   result-&gt;samplesperrow = samplesperrow;
 551   result-&gt;maxaccess = maxaccess;
 552   result-&gt;pre_zero = pre_zero;
 553   result-&gt;b_s_open = FALSE;    /* no associated backing-store object */
 554   result-&gt;next = mem-&gt;virt_sarray_list; /* add to list of virtual arrays */
 555   mem-&gt;virt_sarray_list = result;
 556 
 557   return result;
 558 }
 559 
 560 
 561 METHODDEF(jvirt_barray_ptr)
 562 request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 563              JDIMENSION blocksperrow, JDIMENSION numrows,
 564              JDIMENSION maxaccess)
 565 /* Request a virtual 2-D coefficient-block array */
 566 {
 567   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 568   jvirt_barray_ptr result;
 569 
 570   /* Only IMAGE-lifetime virtual arrays are currently supported */
 571   if (pool_id != JPOOL_IMAGE)
 572     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 573 
 574   /* get control block */
 575   result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id,
 576                       SIZEOF(struct jvirt_barray_control));
 577 
 578   result-&gt;mem_buffer = NULL;    /* marks array not yet realized */
 579   result-&gt;rows_in_array = numrows;
 580   result-&gt;blocksperrow = blocksperrow;
 581   result-&gt;maxaccess = maxaccess;
 582   result-&gt;pre_zero = pre_zero;
 583   result-&gt;b_s_open = FALSE;    /* no associated backing-store object */
 584   result-&gt;next = mem-&gt;virt_barray_list; /* add to list of virtual arrays */
 585   mem-&gt;virt_barray_list = result;
 586 
 587   return result;
 588 }
 589 
 590 
 591 METHODDEF(void)
 592 realize_virt_arrays (j_common_ptr cinfo)
 593 /* Allocate the in-memory buffers for any unrealized virtual arrays */
 594 {
 595   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 596   long space_per_minheight, maximum_space, avail_mem;
 597   long minheights, max_minheights;
 598   jvirt_sarray_ptr sptr;
 599   jvirt_barray_ptr bptr;
 600 
 601   /* Compute the minimum space needed (maxaccess rows in each buffer)
 602    * and the maximum space needed (full image height in each buffer).
 603    * These may be of use to the system-dependent jpeg_mem_available routine.
 604    */
 605   space_per_minheight = 0;
 606   maximum_space = 0;
 607   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 608     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
 609       space_per_minheight += (long) sptr-&gt;maxaccess *
 610                  (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
 611       maximum_space += (long) sptr-&gt;rows_in_array *
 612                (long) sptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
 613     }
 614   }
 615   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 616     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */
 617       space_per_minheight += (long) bptr-&gt;maxaccess *
 618                  (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);
 619       maximum_space += (long) bptr-&gt;rows_in_array *
 620                (long) bptr-&gt;blocksperrow * SIZEOF(JBLOCK);
 621     }
 622   }
 623 
 624   if (space_per_minheight &lt;= 0)
 625     return;            /* no unrealized arrays, no work */
 626 
 627   /* Determine amount of memory to actually use; this is system-dependent. */
 628   avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space,
 629                  mem-&gt;total_space_allocated);
 630 
 631   /* If the maximum space needed is available, make all the buffers full
 632    * height; otherwise parcel it out with the same number of minheights
 633    * in each buffer.
 634    */
 635   if (avail_mem &gt;= maximum_space)
 636     max_minheights = 1000000000L;
 637   else {
 638     max_minheights = avail_mem / space_per_minheight;
 639     /* If there doesn&#39;t seem to be enough space, try to get the minimum
 640      * anyway.  This allows a &quot;stub&quot; implementation of jpeg_mem_available().
 641      */
 642     if (max_minheights &lt;= 0)
 643       max_minheights = 1;
 644   }
 645 
 646   /* Allocate the in-memory buffers and initialize backing store as needed. */
 647 
 648   for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 649     if (sptr-&gt;mem_buffer == NULL) { /* if not realized yet */
 650       minheights = ((long) sptr-&gt;rows_in_array - 1L) / sptr-&gt;maxaccess + 1L;
 651       if (minheights &lt;= max_minheights) {
 652     /* This buffer fits in memory */
 653     sptr-&gt;rows_in_mem = sptr-&gt;rows_in_array;
 654       } else {
 655     /* It doesn&#39;t fit in memory, create backing store. */
 656     sptr-&gt;rows_in_mem = (JDIMENSION) (max_minheights * sptr-&gt;maxaccess);
 657     jpeg_open_backing_store(cinfo, &amp; sptr-&gt;b_s_info,
 658                 (long) sptr-&gt;rows_in_array *
 659                 (long) sptr-&gt;samplesperrow *
 660                 (long) SIZEOF(JSAMPLE));
 661     sptr-&gt;b_s_open = TRUE;
 662       }
 663       sptr-&gt;mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
 664                       sptr-&gt;samplesperrow, sptr-&gt;rows_in_mem);
 665       sptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;
 666       sptr-&gt;cur_start_row = 0;
 667       sptr-&gt;first_undef_row = 0;
 668       sptr-&gt;dirty = FALSE;
 669     }
 670   }
 671 
 672   for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 673     if (bptr-&gt;mem_buffer == NULL) { /* if not realized yet */
 674       minheights = ((long) bptr-&gt;rows_in_array - 1L) / bptr-&gt;maxaccess + 1L;
 675       if (minheights &lt;= max_minheights) {
 676     /* This buffer fits in memory */
 677     bptr-&gt;rows_in_mem = bptr-&gt;rows_in_array;
 678       } else {
 679     /* It doesn&#39;t fit in memory, create backing store. */
 680     bptr-&gt;rows_in_mem = (JDIMENSION) (max_minheights * bptr-&gt;maxaccess);
 681     jpeg_open_backing_store(cinfo, &amp; bptr-&gt;b_s_info,
 682                 (long) bptr-&gt;rows_in_array *
 683                 (long) bptr-&gt;blocksperrow *
 684                 (long) SIZEOF(JBLOCK));
 685     bptr-&gt;b_s_open = TRUE;
 686       }
 687       bptr-&gt;mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
 688                       bptr-&gt;blocksperrow, bptr-&gt;rows_in_mem);
 689       bptr-&gt;rowsperchunk = mem-&gt;last_rowsperchunk;
 690       bptr-&gt;cur_start_row = 0;
 691       bptr-&gt;first_undef_row = 0;
 692       bptr-&gt;dirty = FALSE;
 693     }
 694   }
 695 }
 696 
 697 
 698 LOCAL(void)
 699 do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
 700 /* Do backing store read or write of a virtual sample array */
 701 {
 702   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 703 
 704   bytesperrow = (long) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
 705   file_offset = ptr-&gt;cur_start_row * bytesperrow;
 706   /* Loop to read or write each allocation chunk in mem_buffer */
 707   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 708     /* One chunk, but check for short chunk at end of buffer */
 709     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 710     /* Transfer no more than is currently defined */
 711     thisrow = (long) ptr-&gt;cur_start_row + i;
 712     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 713     /* Transfer no more than fits in file */
 714     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 715     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 716       break;
 717     byte_count = rows * bytesperrow;
 718     if (writing)
 719       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 720                         (void FAR *) ptr-&gt;mem_buffer[i],
 721                         file_offset, byte_count);
 722     else
 723       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 724                        (void FAR *) ptr-&gt;mem_buffer[i],
 725                        file_offset, byte_count);
 726     file_offset += byte_count;
 727   }
 728 }
 729 
 730 
 731 LOCAL(void)
 732 do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
 733 /* Do backing store read or write of a virtual coefficient-block array */
 734 {
 735   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 736 
 737   bytesperrow = (long) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);
 738   file_offset = ptr-&gt;cur_start_row * bytesperrow;
 739   /* Loop to read or write each allocation chunk in mem_buffer */
 740   for (i = 0; i &lt; (long) ptr-&gt;rows_in_mem; i += ptr-&gt;rowsperchunk) {
 741     /* One chunk, but check for short chunk at end of buffer */
 742     rows = MIN((long) ptr-&gt;rowsperchunk, (long) ptr-&gt;rows_in_mem - i);
 743     /* Transfer no more than is currently defined */
 744     thisrow = (long) ptr-&gt;cur_start_row + i;
 745     rows = MIN(rows, (long) ptr-&gt;first_undef_row - thisrow);
 746     /* Transfer no more than fits in file */
 747     rows = MIN(rows, (long) ptr-&gt;rows_in_array - thisrow);
 748     if (rows &lt;= 0)        /* this chunk might be past end of file! */
 749       break;
 750     byte_count = rows * bytesperrow;
 751     if (writing)
 752       (*ptr-&gt;b_s_info.write_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 753                         (void FAR *) ptr-&gt;mem_buffer[i],
 754                         file_offset, byte_count);
 755     else
 756       (*ptr-&gt;b_s_info.read_backing_store) (cinfo, &amp; ptr-&gt;b_s_info,
 757                        (void FAR *) ptr-&gt;mem_buffer[i],
 758                        file_offset, byte_count);
 759     file_offset += byte_count;
 760   }
 761 }
 762 
 763 
 764 METHODDEF(JSAMPARRAY)
 765 access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 766             JDIMENSION start_row, JDIMENSION num_rows,
 767             boolean writable)
 768 /* Access the part of a virtual sample array starting at start_row */
 769 /* and extending for num_rows rows.  writable is true if  */
 770 /* caller intends to modify the accessed area. */
 771 {
 772   JDIMENSION end_row = start_row + num_rows;
 773   JDIMENSION undef_row;
 774 
 775   /* debugging check */
 776   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 777       ptr-&gt;mem_buffer == NULL)
 778     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 779 
 780   /* Make the desired part of the virtual array accessible */
 781   if (start_row &lt; ptr-&gt;cur_start_row ||
 782       end_row &gt; ptr-&gt;cur_start_row+ptr-&gt;rows_in_mem) {
 783     if (! ptr-&gt;b_s_open)
 784       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 785     /* Flush old buffer contents if necessary */
 786     if (ptr-&gt;dirty) {
 787       do_sarray_io(cinfo, ptr, TRUE);
 788       ptr-&gt;dirty = FALSE;
 789     }
 790     /* Decide what part of virtual array to access.
 791      * Algorithm: if target address &gt; current window, assume forward scan,
 792      * load starting at target address.  If target address &lt; current window,
 793      * assume backward scan, load so that target area is top of window.
 794      * Note that when switching from forward write to forward read, will have
 795      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 796      */
 797     if (start_row &gt; ptr-&gt;cur_start_row) {
 798       ptr-&gt;cur_start_row = start_row;
 799     } else {
 800       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 801       long ltemp;
 802 
 803       ltemp = (long) end_row - (long) ptr-&gt;rows_in_mem;
 804       if (ltemp &lt; 0)
 805     ltemp = 0;        /* don&#39;t fall off front end of file */
 806       ptr-&gt;cur_start_row = (JDIMENSION) ltemp;
 807     }
 808     /* Read in the selected part of the array.
 809      * During the initial write pass, we will do no actual read
 810      * because the selected part is all undefined.
 811      */
 812     do_sarray_io(cinfo, ptr, FALSE);
 813   }
 814   /* Ensure the accessed part of the array is defined; prezero if needed.
 815    * To improve locality of access, we only prezero the part of the array
 816    * that the caller is about to access, not the entire in-memory array.
 817    */
 818   if (ptr-&gt;first_undef_row &lt; end_row) {
 819     if (ptr-&gt;first_undef_row &lt; start_row) {
 820       if (writable)        /* writer skipped over a section of array */
 821     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 822       undef_row = start_row;    /* but reader is allowed to read ahead */
 823     } else {
 824       undef_row = ptr-&gt;first_undef_row;
 825     }
 826     if (writable)
 827       ptr-&gt;first_undef_row = end_row;
 828     if (ptr-&gt;pre_zero) {
 829       size_t bytesperrow = (size_t) ptr-&gt;samplesperrow * SIZEOF(JSAMPLE);
 830       undef_row -= ptr-&gt;cur_start_row; /* make indexes relative to buffer */
 831       end_row -= ptr-&gt;cur_start_row;
 832       while (undef_row &lt; end_row) {
 833     FMEMZERO((void FAR *) ptr-&gt;mem_buffer[undef_row], bytesperrow);
 834     undef_row++;
 835       }
 836     } else {
 837       if (! writable)        /* reader looking at undefined data */
 838     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 839     }
 840   }
 841   /* Flag the buffer dirty if caller will write in it */
 842   if (writable)
 843     ptr-&gt;dirty = TRUE;
 844   /* Return address of proper part of the buffer */
 845   return ptr-&gt;mem_buffer + (start_row - ptr-&gt;cur_start_row);
 846 }
 847 
 848 
 849 METHODDEF(JBLOCKARRAY)
 850 access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr,
 851             JDIMENSION start_row, JDIMENSION num_rows,
 852             boolean writable)
 853 /* Access the part of a virtual block array starting at start_row */
 854 /* and extending for num_rows rows.  writable is true if  */
 855 /* caller intends to modify the accessed area. */
 856 {
 857   JDIMENSION end_row = start_row + num_rows;
 858   JDIMENSION undef_row;
 859 
 860   /* debugging check */
 861   if (end_row &gt; ptr-&gt;rows_in_array || num_rows &gt; ptr-&gt;maxaccess ||
 862       ptr-&gt;mem_buffer == NULL)
 863     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 864 
 865   /* Make the desired part of the virtual array accessible */
 866   if (start_row &lt; ptr-&gt;cur_start_row ||
 867       end_row &gt; ptr-&gt;cur_start_row+ptr-&gt;rows_in_mem) {
 868     if (! ptr-&gt;b_s_open)
 869       ERREXIT(cinfo, JERR_VIRTUAL_BUG);
 870     /* Flush old buffer contents if necessary */
 871     if (ptr-&gt;dirty) {
 872       do_barray_io(cinfo, ptr, TRUE);
 873       ptr-&gt;dirty = FALSE;
 874     }
 875     /* Decide what part of virtual array to access.
 876      * Algorithm: if target address &gt; current window, assume forward scan,
 877      * load starting at target address.  If target address &lt; current window,
 878      * assume backward scan, load so that target area is top of window.
 879      * Note that when switching from forward write to forward read, will have
 880      * start_row = 0, so the limiting case applies and we load from 0 anyway.
 881      */
 882     if (start_row &gt; ptr-&gt;cur_start_row) {
 883       ptr-&gt;cur_start_row = start_row;
 884     } else {
 885       /* use long arithmetic here to avoid overflow &amp; unsigned problems */
 886       long ltemp;
 887 
 888       ltemp = (long) end_row - (long) ptr-&gt;rows_in_mem;
 889       if (ltemp &lt; 0)
 890     ltemp = 0;        /* don&#39;t fall off front end of file */
 891       ptr-&gt;cur_start_row = (JDIMENSION) ltemp;
 892     }
 893     /* Read in the selected part of the array.
 894      * During the initial write pass, we will do no actual read
 895      * because the selected part is all undefined.
 896      */
 897     do_barray_io(cinfo, ptr, FALSE);
 898   }
 899   /* Ensure the accessed part of the array is defined; prezero if needed.
 900    * To improve locality of access, we only prezero the part of the array
 901    * that the caller is about to access, not the entire in-memory array.
 902    */
 903   if (ptr-&gt;first_undef_row &lt; end_row) {
 904     if (ptr-&gt;first_undef_row &lt; start_row) {
 905       if (writable)        /* writer skipped over a section of array */
 906     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 907       undef_row = start_row;    /* but reader is allowed to read ahead */
 908     } else {
 909       undef_row = ptr-&gt;first_undef_row;
 910     }
 911     if (writable)
 912       ptr-&gt;first_undef_row = end_row;
 913     if (ptr-&gt;pre_zero) {
 914       size_t bytesperrow = (size_t) ptr-&gt;blocksperrow * SIZEOF(JBLOCK);
 915       undef_row -= ptr-&gt;cur_start_row; /* make indexes relative to buffer */
 916       end_row -= ptr-&gt;cur_start_row;
 917       while (undef_row &lt; end_row) {
 918     FMEMZERO((void FAR *) ptr-&gt;mem_buffer[undef_row], bytesperrow);
 919     undef_row++;
 920       }
 921     } else {
 922       if (! writable)        /* reader looking at undefined data */
 923     ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
 924     }
 925   }
 926   /* Flag the buffer dirty if caller will write in it */
 927   if (writable)
 928     ptr-&gt;dirty = TRUE;
 929   /* Return address of proper part of the buffer */
 930   return ptr-&gt;mem_buffer + (start_row - ptr-&gt;cur_start_row);
 931 }
 932 
 933 
 934 /*
 935  * Release all objects belonging to a specified pool.
 936  */
 937 
 938 METHODDEF(void)
 939 free_pool (j_common_ptr cinfo, int pool_id)
 940 {
 941   my_mem_ptr mem = (my_mem_ptr) cinfo-&gt;mem;
 942   small_pool_ptr shdr_ptr;
 943   large_pool_ptr lhdr_ptr;
 944   size_t space_freed;
 945 
 946   if (pool_id &lt; 0 || pool_id &gt;= JPOOL_NUMPOOLS)
 947     ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);    /* safety check */
 948 
 949 #ifdef MEM_STATS
 950   if (cinfo-&gt;err-&gt;trace_level &gt; 1)
 951     print_mem_stats(cinfo, pool_id); /* print pool&#39;s memory usage statistics */
 952 #endif
 953 
 954   /* If freeing IMAGE pool, close any virtual arrays first */
 955   if (pool_id == JPOOL_IMAGE) {
 956     jvirt_sarray_ptr sptr;
 957     jvirt_barray_ptr bptr;
 958 
 959     for (sptr = mem-&gt;virt_sarray_list; sptr != NULL; sptr = sptr-&gt;next) {
 960       if (sptr-&gt;b_s_open) {    /* there may be no backing store */
 961     sptr-&gt;b_s_open = FALSE;    /* prevent recursive close if error */
 962     (*sptr-&gt;b_s_info.close_backing_store) (cinfo, &amp; sptr-&gt;b_s_info);
 963       }
 964     }
 965     mem-&gt;virt_sarray_list = NULL;
 966     for (bptr = mem-&gt;virt_barray_list; bptr != NULL; bptr = bptr-&gt;next) {
 967       if (bptr-&gt;b_s_open) {    /* there may be no backing store */
 968     bptr-&gt;b_s_open = FALSE;    /* prevent recursive close if error */
 969     (*bptr-&gt;b_s_info.close_backing_store) (cinfo, &amp; bptr-&gt;b_s_info);
 970       }
 971     }
 972     mem-&gt;virt_barray_list = NULL;
 973   }
 974 
 975   /* Release large objects */
 976   lhdr_ptr = mem-&gt;large_list[pool_id];
 977   mem-&gt;large_list[pool_id] = NULL;
 978 
 979   while (lhdr_ptr != NULL) {
 980     large_pool_ptr next_lhdr_ptr = lhdr_ptr-&gt;hdr.next;
 981     space_freed = lhdr_ptr-&gt;hdr.bytes_used +
 982           lhdr_ptr-&gt;hdr.bytes_left +
 983           SIZEOF(large_pool_hdr);
 984     jpeg_free_large(cinfo, (void FAR *) lhdr_ptr, space_freed);
 985     mem-&gt;total_space_allocated -= space_freed;
 986     lhdr_ptr = next_lhdr_ptr;
 987   }
 988 
 989   /* Release small objects */
 990   shdr_ptr = mem-&gt;small_list[pool_id];
 991   mem-&gt;small_list[pool_id] = NULL;
 992 
 993   while (shdr_ptr != NULL) {
 994     small_pool_ptr next_shdr_ptr = shdr_ptr-&gt;hdr.next;
 995     space_freed = shdr_ptr-&gt;hdr.bytes_used +
 996           shdr_ptr-&gt;hdr.bytes_left +
 997           SIZEOF(small_pool_hdr);
 998     jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
 999     mem-&gt;total_space_allocated -= space_freed;
1000     shdr_ptr = next_shdr_ptr;
1001   }
1002 }
1003 
1004 
1005 /*
1006  * Close up shop entirely.
1007  * Note that this cannot be called unless cinfo-&gt;mem is non-NULL.
1008  */
1009 
1010 METHODDEF(void)
1011 self_destruct (j_common_ptr cinfo)
1012 {
1013   int pool;
1014 
1015   /* Close all backing store, release all memory.
1016    * Releasing pools in reverse order might help avoid fragmentation
1017    * with some (brain-damaged) malloc libraries.
1018    */
1019   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {
1020     free_pool(cinfo, pool);
1021   }
1022 
1023   /* Release the memory manager control block too. */
1024   jpeg_free_small(cinfo, (void *) cinfo-&gt;mem, SIZEOF(my_memory_mgr));
1025   cinfo-&gt;mem = NULL;        /* ensures I will be called only once */
1026 
1027   jpeg_mem_term(cinfo);        /* system-dependent cleanup */
1028 }
1029 
1030 
1031 /*
1032  * Memory manager initialization.
1033  * When this is called, only the error manager pointer is valid in cinfo!
1034  */
1035 
1036 GLOBAL(void)
1037 jinit_memory_mgr (j_common_ptr cinfo)
1038 {
1039   my_mem_ptr mem;
1040   long max_to_use;
1041   int pool;
1042   size_t test_mac;
1043 
1044   cinfo-&gt;mem = NULL;        /* for safety if init fails */
1045 
1046   /* Check for configuration errors.
1047    * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
1048    * doesn&#39;t reflect any real hardware alignment requirement.
1049    * The test is a little tricky: for X&gt;0, X and X-1 have no one-bits
1050    * in common if and only if X is a power of 2, ie has only one one-bit.
1051    * Some compilers may give an &quot;unreachable code&quot; warning here; ignore it.
1052    */
1053   if ((SIZEOF(ALIGN_TYPE) &amp; (SIZEOF(ALIGN_TYPE)-1)) != 0)
1054     ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
1055   /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
1056    * a multiple of SIZEOF(ALIGN_TYPE).
1057    * Again, an &quot;unreachable code&quot; warning may be ignored here.
1058    * But a &quot;constant too large&quot; warning means you need to fix MAX_ALLOC_CHUNK.
1059    */
1060   test_mac = (size_t) MAX_ALLOC_CHUNK;
1061   if ((long) test_mac != MAX_ALLOC_CHUNK ||
1062       (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
1063     ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
1064 
1065   max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
1066 
1067   /* Attempt to allocate memory manager&#39;s control block */
1068   mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
1069 
1070   if (mem == NULL) {
1071     jpeg_mem_term(cinfo);    /* system-dependent cleanup */
1072     ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
1073   }
1074 
1075   /* OK, fill in the method pointers */
1076   mem-&gt;pub.alloc_small = alloc_small;
1077   mem-&gt;pub.alloc_large = alloc_large;
1078   mem-&gt;pub.alloc_sarray = alloc_sarray;
1079   mem-&gt;pub.alloc_barray = alloc_barray;
1080   mem-&gt;pub.request_virt_sarray = request_virt_sarray;
1081   mem-&gt;pub.request_virt_barray = request_virt_barray;
1082   mem-&gt;pub.realize_virt_arrays = realize_virt_arrays;
1083   mem-&gt;pub.access_virt_sarray = access_virt_sarray;
1084   mem-&gt;pub.access_virt_barray = access_virt_barray;
1085   mem-&gt;pub.free_pool = free_pool;
1086   mem-&gt;pub.self_destruct = self_destruct;
1087 
1088   /* Make MAX_ALLOC_CHUNK accessible to other modules */
1089   mem-&gt;pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
1090 
1091   /* Initialize working state */
1092   mem-&gt;pub.max_memory_to_use = max_to_use;
1093 
1094   for (pool = JPOOL_NUMPOOLS-1; pool &gt;= JPOOL_PERMANENT; pool--) {
1095     mem-&gt;small_list[pool] = NULL;
1096     mem-&gt;large_list[pool] = NULL;
1097   }
1098   mem-&gt;virt_sarray_list = NULL;
1099   mem-&gt;virt_barray_list = NULL;
1100 
1101   mem-&gt;total_space_allocated = SIZEOF(my_memory_mgr);
1102 
1103   /* Declare ourselves open for business */
1104   cinfo-&gt;mem = &amp; mem-&gt;pub;
1105 
1106   /* Check for an environment variable JPEGMEM; if found, override the
1107    * default max_memory setting from jpeg_mem_init.  Note that the
1108    * surrounding application may again override this value.
1109    * If your system doesn&#39;t support getenv(), define NO_GETENV to disable
1110    * this feature.
1111    */
1112 #ifndef NO_GETENV
1113   { char * memenv;
1114 
1115     if ((memenv = getenv(&quot;JPEGMEM&quot;)) != NULL) {
1116       char ch = &#39;x&#39;;
1117 
1118       if (sscanf(memenv, &quot;%ld%c&quot;, &amp;max_to_use, &amp;ch) &gt; 0) {
1119     if (ch == &#39;m&#39; || ch == &#39;M&#39;)
1120       max_to_use *= 1000L;
1121     mem-&gt;pub.max_memory_to_use = max_to_use * 1000L;
1122       }
1123     }
1124   }
1125 #endif
1126 
1127 }
    </pre>
  </body>
</html>
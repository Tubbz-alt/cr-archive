<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-iio/libjpeg/jcparam.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * jcparam.c
  3  *
  4  * Copyright (C) 1991-1998, Thomas G. Lane.
  5  * Modified 2003-2013 by Guido Vollbeding.
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file contains optional default-setting code for the JPEG compressor.
 10  * Applications do not have to use this file, but those that don&#39;t use it
 11  * must know a lot more about the innards of the JPEG code.
 12  */
 13 
 14 #define JPEG_INTERNALS
 15 #include &quot;jinclude.h&quot;
 16 #include &quot;jpeglib.h&quot;
 17 
 18 
 19 /*
 20  * Quantization table setup routines
 21  */
 22 
 23 GLOBAL(void)
 24 jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
 25               const unsigned int *basic_table,
 26               int scale_factor, boolean force_baseline)
 27 /* Define a quantization table equal to the basic_table times
 28  * a scale factor (given as a percentage).
 29  * If force_baseline is TRUE, the computed quantization table entries
 30  * are limited to 1..255 for JPEG baseline compatibility.
 31  */
 32 {
 33   JQUANT_TBL ** qtblptr;
 34   int i;
 35   long temp;
 36 
 37   /* Safety check to ensure start_compress not called yet. */
 38   if (cinfo-&gt;global_state != CSTATE_START)
 39     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo-&gt;global_state);
 40 
 41   if (which_tbl &lt; 0 || which_tbl &gt;= NUM_QUANT_TBLS)
 42     ERREXIT1(cinfo, JERR_DQT_INDEX, which_tbl);
 43 
 44   qtblptr = &amp; cinfo-&gt;quant_tbl_ptrs[which_tbl];
 45 
 46   if (*qtblptr == NULL)
 47     *qtblptr = jpeg_alloc_quant_table((j_common_ptr) cinfo);
 48 
 49   for (i = 0; i &lt; DCTSIZE2; i++) {
 50     temp = ((long) basic_table[i] * scale_factor + 50L) / 100L;
 51     /* limit the values to the valid range */
 52     if (temp &lt;= 0L) temp = 1L;
 53     if (temp &gt; 32767L) temp = 32767L; /* max quantizer needed for 12 bits */
 54     if (force_baseline &amp;&amp; temp &gt; 255L)
 55       temp = 255L;        /* limit to baseline range if requested */
 56     (*qtblptr)-&gt;quantval[i] = (UINT16) temp;
 57   }
 58 
 59   /* Initialize sent_table FALSE so table will be written to JPEG file. */
 60   (*qtblptr)-&gt;sent_table = FALSE;
 61 }
 62 
 63 
 64 /* These are the sample quantization tables given in JPEG spec section K.1.
 65  * The spec says that the values given produce &quot;good&quot; quality, and
 66  * when divided by 2, &quot;very good&quot; quality.
 67  */
 68 static const unsigned int std_luminance_quant_tbl[DCTSIZE2] = {
 69   16,  11,  10,  16,  24,  40,  51,  61,
 70   12,  12,  14,  19,  26,  58,  60,  55,
 71   14,  13,  16,  24,  40,  57,  69,  56,
 72   14,  17,  22,  29,  51,  87,  80,  62,
 73   18,  22,  37,  56,  68, 109, 103,  77,
 74   24,  35,  55,  64,  81, 104, 113,  92,
 75   49,  64,  78,  87, 103, 121, 120, 101,
 76   72,  92,  95,  98, 112, 100, 103,  99
 77 };
 78 static const unsigned int std_chrominance_quant_tbl[DCTSIZE2] = {
 79   17,  18,  24,  47,  99,  99,  99,  99,
 80   18,  21,  26,  66,  99,  99,  99,  99,
 81   24,  26,  56,  99,  99,  99,  99,  99,
 82   47,  66,  99,  99,  99,  99,  99,  99,
 83   99,  99,  99,  99,  99,  99,  99,  99,
 84   99,  99,  99,  99,  99,  99,  99,  99,
 85   99,  99,  99,  99,  99,  99,  99,  99,
 86   99,  99,  99,  99,  99,  99,  99,  99
 87 };
 88 
 89 
 90 GLOBAL(void)
 91 jpeg_default_qtables (j_compress_ptr cinfo, boolean force_baseline)
 92 /* Set or change the &#39;quality&#39; (quantization) setting, using default tables
 93  * and straight percentage-scaling quality scales.
 94  * This entry point allows different scalings for luminance and chrominance.
 95  */
 96 {
 97   /* Set up two quantization tables using the specified scaling */
 98   jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
 99                cinfo-&gt;q_scale_factor[0], force_baseline);
100   jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
101                cinfo-&gt;q_scale_factor[1], force_baseline);
102 }
103 
104 
105 GLOBAL(void)
106 jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
107              boolean force_baseline)
108 /* Set or change the &#39;quality&#39; (quantization) setting, using default tables
109  * and a straight percentage-scaling quality scale.  In most cases it&#39;s better
110  * to use jpeg_set_quality (below); this entry point is provided for
111  * applications that insist on a linear percentage scaling.
112  */
113 {
114   /* Set up two quantization tables using the specified scaling */
115   jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
116                scale_factor, force_baseline);
117   jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
118                scale_factor, force_baseline);
119 }
120 
121 
122 GLOBAL(int)
123 jpeg_quality_scaling (int quality)
124 /* Convert a user-specified quality rating to a percentage scaling factor
125  * for an underlying quantization table, using our recommended scaling curve.
126  * The input &#39;quality&#39; factor should be 0 (terrible) to 100 (very good).
127  */
128 {
129   /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
130   if (quality &lt;= 0) quality = 1;
131   if (quality &gt; 100) quality = 100;
132 
133   /* The basic table is used as-is (scaling 100) for a quality of 50.
134    * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
135    * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
136    * to make all the table entries 1 (hence, minimum quantization loss).
137    * Qualities 1..50 are converted to scaling percentage 5000/Q.
138    */
139   if (quality &lt; 50)
140     quality = 5000 / quality;
141   else
142     quality = 200 - quality*2;
143 
144   return quality;
145 }
146 
147 
148 GLOBAL(void)
149 jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
150 /* Set or change the &#39;quality&#39; (quantization) setting, using default tables.
151  * This is the standard quality-adjusting entry point for typical user
152  * interfaces; only those who want detailed control over quantization tables
153  * would use the preceding routines directly.
154  */
155 {
156   /* Convert user 0-100 rating to percentage scaling */
157   quality = jpeg_quality_scaling(quality);
158 
159   /* Set up standard quality tables */
160   jpeg_set_linear_quality(cinfo, quality, force_baseline);
161 }
162 
163 
164 /*
165  * Huffman table setup routines
166  */
167 
168 LOCAL(void)
169 add_huff_table (j_compress_ptr cinfo,
170         JHUFF_TBL **htblptr, const UINT8 *bits, const UINT8 *val)
171 /* Define a Huffman table */
172 {
173   int nsymbols, len;
174 
175   if (*htblptr == NULL)
176     *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
177 
178   /* Copy the number-of-symbols-of-each-code-length counts */
179   MEMCOPY((*htblptr)-&gt;bits, bits, SIZEOF((*htblptr)-&gt;bits));
180 
181   /* Validate the counts.  We do this here mainly so we can copy the right
182    * number of symbols from the val[] array, without risking marching off
183    * the end of memory.  jchuff.c will do a more thorough test later.
184    */
185   nsymbols = 0;
186   for (len = 1; len &lt;= 16; len++)
187     nsymbols += bits[len];
188   if (nsymbols &lt; 1 || nsymbols &gt; 256)
189     ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
190 
191   MEMCOPY((*htblptr)-&gt;huffval, val, nsymbols * SIZEOF(UINT8));
192 
193   /* Initialize sent_table FALSE so table will be written to JPEG file. */
194   (*htblptr)-&gt;sent_table = FALSE;
195 }
196 
197 
198 LOCAL(void)
199 std_huff_tables (j_compress_ptr cinfo)
200 /* Set up the standard Huffman tables (cf. JPEG standard section K.3) */
201 /* IMPORTANT: these are only valid for 8-bit data precision! */
202 {
203   static const UINT8 bits_dc_luminance[17] =
204     { /* 0-base */ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 };
205   static const UINT8 val_dc_luminance[] =
206     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
207 
208   static const UINT8 bits_dc_chrominance[17] =
209     { /* 0-base */ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 };
210   static const UINT8 val_dc_chrominance[] =
211     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };
212 
213   static const UINT8 bits_ac_luminance[17] =
214     { /* 0-base */ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d };
215   static const UINT8 val_ac_luminance[] =
216     { 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
217       0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
218       0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
219       0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
220       0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
221       0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
222       0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
223       0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
224       0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
225       0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
226       0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
227       0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
228       0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
229       0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
230       0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
231       0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
232       0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
233       0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
234       0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
235       0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
236       0xf9, 0xfa };
237 
238   static const UINT8 bits_ac_chrominance[17] =
239     { /* 0-base */ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 };
240   static const UINT8 val_ac_chrominance[] =
241     { 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
242       0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
243       0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
244       0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
245       0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
246       0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
247       0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
248       0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
249       0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
250       0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
251       0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
252       0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
253       0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
254       0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
255       0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
256       0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
257       0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
258       0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
259       0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
260       0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
261       0xf9, 0xfa };
262 
263   add_huff_table(cinfo, &amp;cinfo-&gt;dc_huff_tbl_ptrs[0],
264          bits_dc_luminance, val_dc_luminance);
265   add_huff_table(cinfo, &amp;cinfo-&gt;ac_huff_tbl_ptrs[0],
266          bits_ac_luminance, val_ac_luminance);
267   add_huff_table(cinfo, &amp;cinfo-&gt;dc_huff_tbl_ptrs[1],
268          bits_dc_chrominance, val_dc_chrominance);
269   add_huff_table(cinfo, &amp;cinfo-&gt;ac_huff_tbl_ptrs[1],
270          bits_ac_chrominance, val_ac_chrominance);
271 }
272 
273 
274 /*
275  * Default parameter setup for compression.
276  *
277  * Applications that don&#39;t choose to use this routine must do their
278  * own setup of all these parameters.  Alternately, you can call this
279  * to establish defaults and then alter parameters selectively.  This
280  * is the recommended approach since, if we add any new parameters,
281  * your code will still work (they&#39;ll be set to reasonable defaults).
282  */
283 
284 GLOBAL(void)
285 jpeg_set_defaults (j_compress_ptr cinfo)
286 {
287   int i;
288 
289   /* Safety check to ensure start_compress not called yet. */
290   if (cinfo-&gt;global_state != CSTATE_START)
291     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo-&gt;global_state);
292 
293   /* Allocate comp_info array large enough for maximum component count.
294    * Array is made permanent in case application wants to compress
295    * multiple images at same param settings.
296    */
297   if (cinfo-&gt;comp_info == NULL)
298     cinfo-&gt;comp_info = (jpeg_component_info *)
299       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
300                   MAX_COMPONENTS * SIZEOF(jpeg_component_info));
301 
302   /* Initialize everything not dependent on the color space */
303 
304   cinfo-&gt;scale_num = 1;        /* 1:1 scaling */
305   cinfo-&gt;scale_denom = 1;
306   cinfo-&gt;data_precision = BITS_IN_JSAMPLE;
307   /* Set up two quantization tables using default quality of 75 */
308   jpeg_set_quality(cinfo, 75, TRUE);
309   /* Set up two Huffman tables */
310   std_huff_tables(cinfo);
311 
312   /* Initialize default arithmetic coding conditioning */
313   for (i = 0; i &lt; NUM_ARITH_TBLS; i++) {
314     cinfo-&gt;arith_dc_L[i] = 0;
315     cinfo-&gt;arith_dc_U[i] = 1;
316     cinfo-&gt;arith_ac_K[i] = 5;
317   }
318 
319   /* Default is no multiple-scan output */
320   cinfo-&gt;scan_info = NULL;
321   cinfo-&gt;num_scans = 0;
322 
323   /* Expect normal source image, not raw downsampled data */
324   cinfo-&gt;raw_data_in = FALSE;
325 
326   /* The standard Huffman tables are only valid for 8-bit data precision.
327    * If the precision is higher, use arithmetic coding.
328    * (Alternatively, using Huffman coding would be possible with forcing
329    * optimization on so that usable tables will be computed, or by
330    * supplying default tables that are valid for the desired precision.)
331    * Otherwise, use Huffman coding by default.
332    */
333   cinfo-&gt;arith_code = cinfo-&gt;data_precision &gt; 8 ? TRUE : FALSE;
334 
335   /* By default, don&#39;t do extra passes to optimize entropy coding */
336   cinfo-&gt;optimize_coding = FALSE;
337 
338   /* By default, use the simpler non-cosited sampling alignment */
339   cinfo-&gt;CCIR601_sampling = FALSE;
340 
341   /* By default, apply fancy downsampling */
342   cinfo-&gt;do_fancy_downsampling = TRUE;
343 
344   /* No input smoothing */
345   cinfo-&gt;smoothing_factor = 0;
346 
347   /* DCT algorithm preference */
348   cinfo-&gt;dct_method = JDCT_DEFAULT;
349 
350   /* No restart markers */
351   cinfo-&gt;restart_interval = 0;
352   cinfo-&gt;restart_in_rows = 0;
353 
354   /* Fill in default JFIF marker parameters.  Note that whether the marker
355    * will actually be written is determined by jpeg_set_colorspace.
356    *
357    * By default, the library emits JFIF version code 1.01.
358    * An application that wants to emit JFIF 1.02 extension markers should set
359    * JFIF_minor_version to 2.  We could probably get away with just defaulting
360    * to 1.02, but there may still be some decoders in use that will complain
361    * about that; saying 1.01 should minimize compatibility problems.
362    *
363    * For wide gamut colorspaces (BG_RGB and BG_YCC), the major version will be
364    * overridden by jpeg_set_colorspace and set to 2.
365    */
366   cinfo-&gt;JFIF_major_version = 1; /* Default JFIF version = 1.01 */
367   cinfo-&gt;JFIF_minor_version = 1;
368   cinfo-&gt;density_unit = 0;    /* Pixel size is unknown by default */
369   cinfo-&gt;X_density = 1;        /* Pixel aspect ratio is square by default */
370   cinfo-&gt;Y_density = 1;
371 
372   /* No color transform */
373   cinfo-&gt;color_transform = JCT_NONE;
374 
375   /* Choose JPEG colorspace based on input space, set defaults accordingly */
376 
377   jpeg_default_colorspace(cinfo);
378 }
379 
380 
381 /*
382  * Select an appropriate JPEG colorspace for in_color_space.
383  */
384 
385 GLOBAL(void)
386 jpeg_default_colorspace (j_compress_ptr cinfo)
387 {
388   switch (cinfo-&gt;in_color_space) {
389   case JCS_UNKNOWN:
390     jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
391     break;
392   case JCS_GRAYSCALE:
393     jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
394     break;
395   case JCS_RGB:
396     jpeg_set_colorspace(cinfo, JCS_YCbCr);
397     break;
398   case JCS_YCbCr:
399     jpeg_set_colorspace(cinfo, JCS_YCbCr);
400     break;
401   case JCS_CMYK:
402     jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
403     break;
404   case JCS_YCCK:
405     jpeg_set_colorspace(cinfo, JCS_YCCK);
406     break;
407   case JCS_BG_RGB:
408     /* No translation for now -- conversion to BG_YCC not yet supportet */
409     jpeg_set_colorspace(cinfo, JCS_BG_RGB);
410     break;
411   case JCS_BG_YCC:
412     jpeg_set_colorspace(cinfo, JCS_BG_YCC);
413     break;
414   default:
415     ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
416   }
417 }
418 
419 
420 /*
421  * Set the JPEG colorspace, and choose colorspace-dependent default values.
422  */
423 
424 GLOBAL(void)
425 jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
426 {
427   jpeg_component_info * compptr;
428   int ci;
429 
430 #define SET_COMP(index,id,hsamp,vsamp,quant,dctbl,actbl)  \
431   (compptr = &amp;cinfo-&gt;comp_info[index], \
432    compptr-&gt;component_id = (id), \
433    compptr-&gt;h_samp_factor = (hsamp), \
434    compptr-&gt;v_samp_factor = (vsamp), \
435    compptr-&gt;quant_tbl_no = (quant), \
436    compptr-&gt;dc_tbl_no = (dctbl), \
437    compptr-&gt;ac_tbl_no = (actbl) )
438 
439   /* Safety check to ensure start_compress not called yet. */
440   if (cinfo-&gt;global_state != CSTATE_START)
441     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo-&gt;global_state);
442 
443   /* For all colorspaces, we use Q and Huff tables 0 for luminance components,
444    * tables 1 for chrominance components.
445    */
446 
447   cinfo-&gt;jpeg_color_space = colorspace;
448 
449   cinfo-&gt;write_JFIF_header = FALSE; /* No marker for non-JFIF colorspaces */
450   cinfo-&gt;write_Adobe_marker = FALSE; /* write no Adobe marker by default */
451 
452   switch (colorspace) {
453   case JCS_UNKNOWN:
454     cinfo-&gt;num_components = cinfo-&gt;input_components;
455     if (cinfo-&gt;num_components &lt; 1 || cinfo-&gt;num_components &gt; MAX_COMPONENTS)
456       ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo-&gt;num_components,
457            MAX_COMPONENTS);
458     for (ci = 0; ci &lt; cinfo-&gt;num_components; ci++) {
459       SET_COMP(ci, ci, 1,1, 0, 0,0);
460     }
461     break;
462   case JCS_GRAYSCALE:
463     cinfo-&gt;write_JFIF_header = TRUE; /* Write a JFIF marker */
464     cinfo-&gt;num_components = 1;
465     /* JFIF specifies component ID 1 */
466     SET_COMP(0, 0x01, 1,1, 0, 0,0);
467     break;
468   case JCS_RGB:
469     cinfo-&gt;write_Adobe_marker = TRUE; /* write Adobe marker to flag RGB */
470     cinfo-&gt;num_components = 3;
471     SET_COMP(0, 0x52 /* &#39;R&#39; */, 1,1, 0,
472         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,
473         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0);
474     SET_COMP(1, 0x47 /* &#39;G&#39; */, 1,1, 0, 0,0);
475     SET_COMP(2, 0x42 /* &#39;B&#39; */, 1,1, 0,
476         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,
477         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0);
478     break;
479   case JCS_YCbCr:
480     cinfo-&gt;write_JFIF_header = TRUE; /* Write a JFIF marker */
481     cinfo-&gt;num_components = 3;
482     /* JFIF specifies component IDs 1,2,3 */
483     /* We default to 2x2 subsamples of chrominance */
484     SET_COMP(0, 0x01, 2,2, 0, 0,0);
485     SET_COMP(1, 0x02, 1,1, 1, 1,1);
486     SET_COMP(2, 0x03, 1,1, 1, 1,1);
487     break;
488   case JCS_CMYK:
489     cinfo-&gt;write_Adobe_marker = TRUE; /* write Adobe marker to flag CMYK */
490     cinfo-&gt;num_components = 4;
491     SET_COMP(0, 0x43 /* &#39;C&#39; */, 1,1, 0, 0,0);
492     SET_COMP(1, 0x4D /* &#39;M&#39; */, 1,1, 0, 0,0);
493     SET_COMP(2, 0x59 /* &#39;Y&#39; */, 1,1, 0, 0,0);
494     SET_COMP(3, 0x4B /* &#39;K&#39; */, 1,1, 0, 0,0);
495     break;
496   case JCS_YCCK:
497     cinfo-&gt;write_Adobe_marker = TRUE; /* write Adobe marker to flag YCCK */
498     cinfo-&gt;num_components = 4;
499     SET_COMP(0, 0x01, 2,2, 0, 0,0);
500     SET_COMP(1, 0x02, 1,1, 1, 1,1);
501     SET_COMP(2, 0x03, 1,1, 1, 1,1);
502     SET_COMP(3, 0x04, 2,2, 0, 0,0);
503     break;
504   case JCS_BG_RGB:
505     cinfo-&gt;write_JFIF_header = TRUE; /* Write a JFIF marker */
506     cinfo-&gt;JFIF_major_version = 2;   /* Set JFIF major version = 2 */
507     cinfo-&gt;num_components = 3;
508     /* Add offset 0x20 to the normal R/G/B component IDs */
509     SET_COMP(0, 0x72 /* &#39;r&#39; */, 1,1, 0,
510         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,
511         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0);
512     SET_COMP(1, 0x67 /* &#39;g&#39; */, 1,1, 0, 0,0);
513     SET_COMP(2, 0x62 /* &#39;b&#39; */, 1,1, 0,
514         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0,
515         cinfo-&gt;color_transform == JCT_SUBTRACT_GREEN ? 1 : 0);
516     break;
517   case JCS_BG_YCC:
518     cinfo-&gt;write_JFIF_header = TRUE; /* Write a JFIF marker */
519     cinfo-&gt;JFIF_major_version = 2;   /* Set JFIF major version = 2 */
520     cinfo-&gt;num_components = 3;
521     /* Add offset 0x20 to the normal Cb/Cr component IDs */
522     /* We default to 2x2 subsamples of chrominance */
523     SET_COMP(0, 0x01, 2,2, 0, 0,0);
524     SET_COMP(1, 0x22, 1,1, 1, 1,1);
525     SET_COMP(2, 0x23, 1,1, 1, 1,1);
526     break;
527   default:
528     ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
529   }
530 }
531 
532 
533 #ifdef C_PROGRESSIVE_SUPPORTED
534 
535 LOCAL(jpeg_scan_info *)
536 fill_a_scan (jpeg_scan_info * scanptr, int ci,
537          int Ss, int Se, int Ah, int Al)
538 /* Support routine: generate one scan for specified component */
539 {
540   scanptr-&gt;comps_in_scan = 1;
541   scanptr-&gt;component_index[0] = ci;
542   scanptr-&gt;Ss = Ss;
543   scanptr-&gt;Se = Se;
544   scanptr-&gt;Ah = Ah;
545   scanptr-&gt;Al = Al;
546   scanptr++;
547   return scanptr;
548 }
549 
550 LOCAL(jpeg_scan_info *)
551 fill_scans (jpeg_scan_info * scanptr, int ncomps,
552         int Ss, int Se, int Ah, int Al)
553 /* Support routine: generate one scan for each component */
554 {
555   int ci;
556 
557   for (ci = 0; ci &lt; ncomps; ci++) {
558     scanptr-&gt;comps_in_scan = 1;
559     scanptr-&gt;component_index[0] = ci;
560     scanptr-&gt;Ss = Ss;
561     scanptr-&gt;Se = Se;
562     scanptr-&gt;Ah = Ah;
563     scanptr-&gt;Al = Al;
564     scanptr++;
565   }
566   return scanptr;
567 }
568 
569 LOCAL(jpeg_scan_info *)
570 fill_dc_scans (jpeg_scan_info * scanptr, int ncomps, int Ah, int Al)
571 /* Support routine: generate interleaved DC scan if possible, else N scans */
572 {
573   int ci;
574 
575   if (ncomps &lt;= MAX_COMPS_IN_SCAN) {
576     /* Single interleaved DC scan */
577     scanptr-&gt;comps_in_scan = ncomps;
578     for (ci = 0; ci &lt; ncomps; ci++)
579       scanptr-&gt;component_index[ci] = ci;
580     scanptr-&gt;Ss = scanptr-&gt;Se = 0;
581     scanptr-&gt;Ah = Ah;
582     scanptr-&gt;Al = Al;
583     scanptr++;
584   } else {
585     /* Noninterleaved DC scan for each component */
586     scanptr = fill_scans(scanptr, ncomps, 0, 0, Ah, Al);
587   }
588   return scanptr;
589 }
590 
591 
592 /*
593  * Create a recommended progressive-JPEG script.
594  * cinfo-&gt;num_components and cinfo-&gt;jpeg_color_space must be correct.
595  */
596 
597 GLOBAL(void)
598 jpeg_simple_progression (j_compress_ptr cinfo)
599 {
600   int ncomps = cinfo-&gt;num_components;
601   int nscans;
602   jpeg_scan_info * scanptr;
603 
604   /* Safety check to ensure start_compress not called yet. */
605   if (cinfo-&gt;global_state != CSTATE_START)
606     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo-&gt;global_state);
607 
608   /* Figure space needed for script.  Calculation must match code below! */
609   if (ncomps == 3 &amp;&amp;
610       (cinfo-&gt;jpeg_color_space == JCS_YCbCr ||
611        cinfo-&gt;jpeg_color_space == JCS_BG_YCC)) {
612     /* Custom script for YCC color images. */
613     nscans = 10;
614   } else {
615     /* All-purpose script for other color spaces. */
616     if (ncomps &gt; MAX_COMPS_IN_SCAN)
617       nscans = 6 * ncomps;    /* 2 DC + 4 AC scans per component */
618     else
619       nscans = 2 + 4 * ncomps;    /* 2 DC scans; 4 AC scans per component */
620   }
621 
622   /* Allocate space for script.
623    * We need to put it in the permanent pool in case the application performs
624    * multiple compressions without changing the settings.  To avoid a memory
625    * leak if jpeg_simple_progression is called repeatedly for the same JPEG
626    * object, we try to re-use previously allocated space, and we allocate
627    * enough space to handle YCC even if initially asked for grayscale.
628    */
629   if (cinfo-&gt;script_space == NULL || cinfo-&gt;script_space_size &lt; nscans) {
630     cinfo-&gt;script_space_size = MAX(nscans, 10);
631     cinfo-&gt;script_space = (jpeg_scan_info *)
632       (*cinfo-&gt;mem-&gt;alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
633             cinfo-&gt;script_space_size * SIZEOF(jpeg_scan_info));
634   }
635   scanptr = cinfo-&gt;script_space;
636   cinfo-&gt;scan_info = scanptr;
637   cinfo-&gt;num_scans = nscans;
638 
639   if (ncomps == 3 &amp;&amp;
640       (cinfo-&gt;jpeg_color_space == JCS_YCbCr ||
641        cinfo-&gt;jpeg_color_space == JCS_BG_YCC)) {
642     /* Custom script for YCC color images. */
643     /* Initial DC scan */
644     scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
645     /* Initial AC scan: get some luma data out in a hurry */
646     scanptr = fill_a_scan(scanptr, 0, 1, 5, 0, 2);
647     /* Chroma data is too small to be worth expending many scans on */
648     scanptr = fill_a_scan(scanptr, 2, 1, 63, 0, 1);
649     scanptr = fill_a_scan(scanptr, 1, 1, 63, 0, 1);
650     /* Complete spectral selection for luma AC */
651     scanptr = fill_a_scan(scanptr, 0, 6, 63, 0, 2);
652     /* Refine next bit of luma AC */
653     scanptr = fill_a_scan(scanptr, 0, 1, 63, 2, 1);
654     /* Finish DC successive approximation */
655     scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
656     /* Finish AC successive approximation */
657     scanptr = fill_a_scan(scanptr, 2, 1, 63, 1, 0);
658     scanptr = fill_a_scan(scanptr, 1, 1, 63, 1, 0);
659     /* Luma bottom bit comes last since it&#39;s usually largest scan */
660     scanptr = fill_a_scan(scanptr, 0, 1, 63, 1, 0);
661   } else {
662     /* All-purpose script for other color spaces. */
663     /* Successive approximation first pass */
664     scanptr = fill_dc_scans(scanptr, ncomps, 0, 1);
665     scanptr = fill_scans(scanptr, ncomps, 1, 5, 0, 2);
666     scanptr = fill_scans(scanptr, ncomps, 6, 63, 0, 2);
667     /* Successive approximation second pass */
668     scanptr = fill_scans(scanptr, ncomps, 1, 63, 2, 1);
669     /* Successive approximation final pass */
670     scanptr = fill_dc_scans(scanptr, ncomps, 1, 0);
671     scanptr = fill_scans(scanptr, ncomps, 1, 63, 1, 0);
672   }
673 }
674 
675 #endif /* C_PROGRESSIVE_SUPPORTED */
    </pre>
  </body>
</html>
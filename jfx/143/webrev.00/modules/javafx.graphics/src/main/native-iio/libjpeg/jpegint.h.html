<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-iio/libjpeg/jpegint.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * jpegint.h
  3  *
  4  * Copyright (C) 1991-1997, Thomas G. Lane.
  5  * Modified 1997-2019 by Guido Vollbeding.
  6  * This file is part of the Independent JPEG Group&#39;s software.
  7  * For conditions of distribution and use, see the accompanying README file.
  8  *
  9  * This file provides common declarations for the various JPEG modules.
 10  * These declarations are considered internal to the JPEG library; most
 11  * applications using the library shouldn&#39;t need to include this file.
 12  */
 13 
 14 
 15 /* Declarations for both compression &amp; decompression */
 16 
 17 typedef enum {            /* Operating modes for buffer controllers */
 18     JBUF_PASS_THRU,        /* Plain stripwise operation */
 19     /* Remaining modes require a full-image buffer to have been created */
 20     JBUF_SAVE_SOURCE,    /* Run source subobject only, save output */
 21     JBUF_CRANK_DEST,    /* Run dest subobject only, using saved data */
 22     JBUF_SAVE_AND_PASS    /* Run both subobjects, save output */
 23 } J_BUF_MODE;
 24 
 25 /* Values of global_state field (jdapi.c has some dependencies on ordering!) */
 26 #define CSTATE_START    100    /* after create_compress */
 27 #define CSTATE_SCANNING    101    /* start_compress done, write_scanlines OK */
 28 #define CSTATE_RAW_OK    102    /* start_compress done, write_raw_data OK */
 29 #define CSTATE_WRCOEFS    103    /* jpeg_write_coefficients done */
 30 #define DSTATE_START    200    /* after create_decompress */
 31 #define DSTATE_INHEADER    201    /* reading header markers, no SOS yet */
 32 #define DSTATE_READY    202    /* found SOS, ready for start_decompress */
 33 #define DSTATE_PRELOAD    203    /* reading multiscan file in start_decompress*/
 34 #define DSTATE_PRESCAN    204    /* performing dummy pass for 2-pass quant */
 35 #define DSTATE_SCANNING    205    /* start_decompress done, read_scanlines OK */
 36 #define DSTATE_RAW_OK    206    /* start_decompress done, read_raw_data OK */
 37 #define DSTATE_BUFIMAGE    207    /* expecting jpeg_start_output */
 38 #define DSTATE_BUFPOST    208    /* looking for SOS/EOI in jpeg_finish_output */
 39 #define DSTATE_RDCOEFS    209    /* reading file in jpeg_read_coefficients */
 40 #define DSTATE_STOPPING    210    /* looking for EOI in jpeg_finish_decompress */
 41 
 42 
 43 /* Declarations for compression modules */
 44 
 45 /* Master control module */
 46 struct jpeg_comp_master {
 47   JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
 48   JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
 49   JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
 50 
 51   /* State variables made visible to other modules */
 52   boolean call_pass_startup;    /* True if pass_startup must be called */
 53   boolean is_last_pass;        /* True during last pass */
 54 };
 55 
 56 /* Main buffer control (downsampled-data buffer) */
 57 struct jpeg_c_main_controller {
 58   JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
 59   JMETHOD(void, process_data, (j_compress_ptr cinfo,
 60                    JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
 61                    JDIMENSION in_rows_avail));
 62 };
 63 
 64 /* Compression preprocessing (downsampling input buffer control) */
 65 struct jpeg_c_prep_controller {
 66   JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
 67   JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
 68                    JSAMPARRAY input_buf,
 69                    JDIMENSION *in_row_ctr,
 70                    JDIMENSION in_rows_avail,
 71                    JSAMPIMAGE output_buf,
 72                    JDIMENSION *out_row_group_ctr,
 73                    JDIMENSION out_row_groups_avail));
 74 };
 75 
 76 /* Coefficient buffer control */
 77 struct jpeg_c_coef_controller {
 78   JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
 79   JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
 80                    JSAMPIMAGE input_buf));
 81 };
 82 
 83 /* Colorspace conversion */
 84 struct jpeg_color_converter {
 85   JMETHOD(void, start_pass, (j_compress_ptr cinfo));
 86   JMETHOD(void, color_convert, (j_compress_ptr cinfo,
 87                 JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
 88                 JDIMENSION output_row, int num_rows));
 89 };
 90 
 91 /* Downsampling */
 92 struct jpeg_downsampler {
 93   JMETHOD(void, start_pass, (j_compress_ptr cinfo));
 94   JMETHOD(void, downsample, (j_compress_ptr cinfo,
 95                  JSAMPIMAGE input_buf, JDIMENSION in_row_index,
 96                  JSAMPIMAGE output_buf,
 97                  JDIMENSION out_row_group_index));
 98 
 99   boolean need_context_rows;    /* TRUE if need rows above &amp; below */
100 };
101 
102 /* Forward DCT (also controls coefficient quantization) */
103 typedef JMETHOD(void, forward_DCT_ptr,
104         (j_compress_ptr cinfo, jpeg_component_info * compptr,
105          JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
106          JDIMENSION start_row, JDIMENSION start_col,
107          JDIMENSION num_blocks));
108 
109 struct jpeg_forward_dct {
110   JMETHOD(void, start_pass, (j_compress_ptr cinfo));
111   /* It is useful to allow each component to have a separate FDCT method. */
112   forward_DCT_ptr forward_DCT[MAX_COMPONENTS];
113 };
114 
115 /* Entropy encoding */
116 struct jpeg_entropy_encoder {
117   JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
118   JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
119   JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
120 };
121 
122 /* Marker writing */
123 struct jpeg_marker_writer {
124   JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
125   JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
126   JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
127   JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
128   JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
129   /* These routines are exported to allow insertion of extra markers */
130   /* Probably only COM and APPn markers should be written this way */
131   JMETHOD(void, write_marker_header, (j_compress_ptr cinfo, int marker,
132                       unsigned int datalen));
133   JMETHOD(void, write_marker_byte, (j_compress_ptr cinfo, int val));
134 };
135 
136 
137 /* Declarations for decompression modules */
138 
139 /* Master control module */
140 struct jpeg_decomp_master {
141   JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
142   JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));
143 
144   /* State variables made visible to other modules */
145   boolean is_dummy_pass;    /* True during 1st pass for 2-pass quant */
146 };
147 
148 /* Input control module */
149 struct jpeg_input_controller {
150   JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
151   JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
152   JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
153   JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));
154 
155   /* State variables made visible to other modules */
156   boolean has_multiple_scans;    /* True if file has multiple scans */
157   boolean eoi_reached;        /* True when EOI has been consumed */
158 };
159 
160 /* Main buffer control (downsampled-data buffer) */
161 struct jpeg_d_main_controller {
162   JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
163   JMETHOD(void, process_data, (j_decompress_ptr cinfo,
164                    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
165                    JDIMENSION out_rows_avail));
166 };
167 
168 /* Coefficient buffer control */
169 struct jpeg_d_coef_controller {
170   JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
171   JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
172   JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
173   JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
174                  JSAMPIMAGE output_buf));
175   /* Pointer to array of coefficient virtual arrays, or NULL if none */
176   jvirt_barray_ptr *coef_arrays;
177 };
178 
179 /* Decompression postprocessing (color quantization buffer control) */
180 struct jpeg_d_post_controller {
181   JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
182   JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
183                     JSAMPIMAGE input_buf,
184                     JDIMENSION *in_row_group_ctr,
185                     JDIMENSION in_row_groups_avail,
186                     JSAMPARRAY output_buf,
187                     JDIMENSION *out_row_ctr,
188                     JDIMENSION out_rows_avail));
189 };
190 
191 /* Marker reading &amp; parsing */
192 struct jpeg_marker_reader {
193   JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
194   /* Read markers until SOS or EOI.
195    * Returns same codes as are defined for jpeg_consume_input:
196    * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
197    */
198   JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
199   /* Read a restart marker --- exported for use by entropy decoder only */
200   jpeg_marker_parser_method read_restart_marker;
201 
202   /* State of marker reader --- nominally internal, but applications
203    * supplying COM or APPn handlers might like to know the state.
204    */
205   boolean saw_SOI;        /* found SOI? */
206   boolean saw_SOF;        /* found SOF? */
207   int next_restart_num;        /* next restart number expected (0-7) */
208   unsigned int discarded_bytes;    /* # of bytes skipped looking for a marker */
209 };
210 
211 /* Entropy decoding */
212 struct jpeg_entropy_decoder {
213   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
214   JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo, JBLOCKROW *MCU_data));
215   JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
216 };
217 
218 /* Inverse DCT (also performs dequantization) */
219 typedef JMETHOD(void, inverse_DCT_method_ptr,
220         (j_decompress_ptr cinfo, jpeg_component_info * compptr,
221          JCOEFPTR coef_block,
222          JSAMPARRAY output_buf, JDIMENSION output_col));
223 
224 struct jpeg_inverse_dct {
225   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
226   /* It is useful to allow each component to have a separate IDCT method. */
227   inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
228 };
229 
230 /* Upsampling (note that upsampler must also call color converter) */
231 struct jpeg_upsampler {
232   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
233   JMETHOD(void, upsample, (j_decompress_ptr cinfo,
234                JSAMPIMAGE input_buf,
235                JDIMENSION *in_row_group_ctr,
236                JDIMENSION in_row_groups_avail,
237                JSAMPARRAY output_buf,
238                JDIMENSION *out_row_ctr,
239                JDIMENSION out_rows_avail));
240 
241   boolean need_context_rows;    /* TRUE if need rows above &amp; below */
242 };
243 
244 /* Colorspace conversion */
245 struct jpeg_color_deconverter {
246   JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
247   JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
248                 JSAMPIMAGE input_buf, JDIMENSION input_row,
249                 JSAMPARRAY output_buf, int num_rows));
250 };
251 
252 /* Color quantization or color precision reduction */
253 struct jpeg_color_quantizer {
254   JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
255   JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
256                  JSAMPARRAY input_buf, JSAMPARRAY output_buf,
257                  int num_rows));
258   JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
259   JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
260 };
261 
262 
263 /* Definition of range extension bits for decompression processes.
264  * See the comments with prepare_range_limit_table (in jdmaster.c)
265  * for more info.
266  * The recommended default value for normal applications is 2.
267  * Applications with special requirements may use a different value.
268  * For example, Ghostscript wants to use 3 for proper handling of
269  * wacky images with oversize coefficient values.
270  */
271 
272 #define RANGE_BITS    2
273 #define RANGE_CENTER    (CENTERJSAMPLE &lt;&lt; RANGE_BITS)
274 
275 
276 /* Miscellaneous useful macros */
277 
278 #undef MAX
279 #define MAX(a,b)    ((a) &gt; (b) ? (a) : (b))
280 #undef MIN
281 #define MIN(a,b)    ((a) &lt; (b) ? (a) : (b))
282 
283 
284 /* We assume that right shift corresponds to signed division by 2 with
285  * rounding towards minus infinity.  This is correct for typical &quot;arithmetic
286  * shift&quot; instructions that shift in copies of the sign bit.  But some
287  * C compilers implement &gt;&gt; with an unsigned shift.  For these machines you
288  * must define RIGHT_SHIFT_IS_UNSIGNED.
289  * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
290  * It is only applied with constant shift counts.  SHIFT_TEMPS must be
291  * included in the variables of any routine using RIGHT_SHIFT.
292  */
293 
294 #ifdef RIGHT_SHIFT_IS_UNSIGNED
295 #define SHIFT_TEMPS    INT32 shift_temp;
296 #define RIGHT_SHIFT(x,shft)  \
297     ((shift_temp = (x)) &lt; 0 ? \
298      (shift_temp &gt;&gt; (shft)) | ((~((INT32) 0)) &lt;&lt; (32-(shft))) : \
299      (shift_temp &gt;&gt; (shft)))
300 #else
301 #define SHIFT_TEMPS
302 #define RIGHT_SHIFT(x,shft)    ((x) &gt;&gt; (shft))
303 #endif
304 
305 /* Descale and correctly round an INT32 value that&#39;s scaled by N bits.
306  * We assume RIGHT_SHIFT rounds towards minus infinity, so adding
307  * the fudge factor is correct for either sign of X.
308  */
309 
310 #define DESCALE(x,n)    RIGHT_SHIFT((x) + ((INT32) 1 &lt;&lt; ((n)-1)), n)
311 
312 
313 /* Short forms of external names for systems with brain-damaged linkers. */
314 
315 #ifdef NEED_SHORT_EXTERNAL_NAMES
316 #define jinit_compress_master    jICompress
317 #define jinit_c_master_control    jICMaster
318 #define jinit_c_main_controller    jICMainC
319 #define jinit_c_prep_controller    jICPrepC
320 #define jinit_c_coef_controller    jICCoefC
321 #define jinit_color_converter    jICColor
322 #define jinit_downsampler    jIDownsampler
323 #define jinit_forward_dct    jIFDCT
324 #define jinit_huff_encoder    jIHEncoder
325 #define jinit_arith_encoder    jIAEncoder
326 #define jinit_marker_writer    jIMWriter
327 #define jinit_master_decompress    jIDMaster
328 #define jinit_d_main_controller    jIDMainC
329 #define jinit_d_coef_controller    jIDCoefC
330 #define jinit_d_post_controller    jIDPostC
331 #define jinit_input_controller    jIInCtlr
332 #define jinit_marker_reader    jIMReader
333 #define jinit_huff_decoder    jIHDecoder
334 #define jinit_arith_decoder    jIADecoder
335 #define jinit_inverse_dct    jIIDCT
336 #define jinit_upsampler        jIUpsampler
337 #define jinit_color_deconverter    jIDColor
338 #define jinit_1pass_quantizer    jI1Quant
339 #define jinit_2pass_quantizer    jI2Quant
340 #define jinit_merged_upsampler    jIMUpsampler
341 #define jinit_memory_mgr    jIMemMgr
342 #define jdiv_round_up        jDivRound
343 #define jround_up        jRound
344 #define jzero_far        jZeroFar
345 #define jcopy_sample_rows    jCopySamples
346 #define jcopy_block_row        jCopyBlocks
347 #define jpeg_zigzag_order    jZIGTable
348 #define jpeg_natural_order    jZAGTable
349 #define jpeg_natural_order7    jZAG7Table
350 #define jpeg_natural_order6    jZAG6Table
351 #define jpeg_natural_order5    jZAG5Table
352 #define jpeg_natural_order4    jZAG4Table
353 #define jpeg_natural_order3    jZAG3Table
354 #define jpeg_natural_order2    jZAG2Table
355 #define jpeg_aritab        jAriTab
356 #endif /* NEED_SHORT_EXTERNAL_NAMES */
357 
358 
359 /* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays
360  * and coefficient-block arrays.  This won&#39;t work on 80x86 because the arrays
361  * are FAR and we&#39;re assuming a small-pointer memory model.  However, some
362  * DOS compilers provide far-pointer versions of memcpy() and memset() even
363  * in the small-model libraries.  These will be used if USE_FMEM is defined.
364  * Otherwise, the routines in jutils.c do it the hard way.
365  */
366 
367 #ifndef NEED_FAR_POINTERS    /* normal case, same as regular macro */
368 #define FMEMZERO(target,size)    MEMZERO(target,size)
369 #else                /* 80x86 case */
370 #ifdef USE_FMEM
371 #define FMEMZERO(target,size)    _fmemset((void FAR *)(target), 0, (size_t)(size))
372 #else
373 EXTERN(void) jzero_far JPP((void FAR * target, size_t bytestozero));
374 #define FMEMZERO(target,size)    jzero_far(target, size)
375 #endif
376 #endif
377 
378 
379 /* Compression module initialization routines */
380 EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
381 EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
382                      boolean transcode_only));
383 EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
384                       boolean need_full_buffer));
385 EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
386                       boolean need_full_buffer));
387 EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
388                       boolean need_full_buffer));
389 EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
390 EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
391 EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
392 EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
393 EXTERN(void) jinit_arith_encoder JPP((j_compress_ptr cinfo));
394 EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
395 /* Decompression module initialization routines */
396 EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
397 EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
398                       boolean need_full_buffer));
399 EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
400                       boolean need_full_buffer));
401 EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
402                       boolean need_full_buffer));
403 EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
404 EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
405 EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
406 EXTERN(void) jinit_arith_decoder JPP((j_decompress_ptr cinfo));
407 EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
408 EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
409 EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
410 EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
411 EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
412 EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
413 /* Memory manager initialization */
414 EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));
415 
416 /* Utility routines in jutils.c */
417 EXTERN(long) jdiv_round_up JPP((long a, long b));
418 EXTERN(long) jround_up JPP((long a, long b));
419 EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
420                     JSAMPARRAY output_array, int dest_row,
421                     int num_rows, JDIMENSION num_cols));
422 EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
423                   JDIMENSION num_blocks));
424 /* Constant tables in jutils.c */
425 #if 0                /* This table is not actually needed in v6a */
426 extern const int jpeg_zigzag_order[]; /* natural coef order to zigzag order */
427 #endif
428 extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
429 extern const int jpeg_natural_order7[]; /* zz to natural order for 7x7 block */
430 extern const int jpeg_natural_order6[]; /* zz to natural order for 6x6 block */
431 extern const int jpeg_natural_order5[]; /* zz to natural order for 5x5 block */
432 extern const int jpeg_natural_order4[]; /* zz to natural order for 4x4 block */
433 extern const int jpeg_natural_order3[]; /* zz to natural order for 3x3 block */
434 extern const int jpeg_natural_order2[]; /* zz to natural order for 2x2 block */
435 
436 /* Arithmetic coding probability estimation tables in jaricom.c */
437 extern const INT32 jpeg_aritab[];
438 
439 /* Suppress undefined-structure complaints if necessary. */
440 
441 #ifdef INCOMPLETE_TYPES_BROKEN
442 #ifndef AM_MEMORY_MANAGER    /* only jmemmgr.c defines these */
443 struct jvirt_sarray_control { long dummy; };
444 struct jvirt_barray_control { long dummy; };
445 #endif
446 #endif /* INCOMPLETE_TYPES_BROKEN */
    </pre>
  </body>
</html>
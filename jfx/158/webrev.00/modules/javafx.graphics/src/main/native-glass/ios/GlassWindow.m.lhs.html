<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-glass/ios/GlassWindow.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &lt;UIKit/UIKit.h&gt;
  27 #import &lt;Foundation/NSNotification.h&gt;
  28 
  29 #include &quot;GlassWindow.h&quot;
  30 
  31 #include &quot;com_sun_glass_events_WindowEvent.h&quot;
  32 #include &quot;com_sun_glass_ui_Window_Level.h&quot;
  33 #include &quot;com_sun_glass_ui_Window.h&quot;
  34 #include &quot;GlassViewGL.h&quot;
  35 #include &quot;GlassApplication.h&quot;
  36 #include &quot;GlassViewController.h&quot;
  37 
  38 static UIView * s_grabWindow = nil;
  39 static GlassWindow   * focusOwner; // currently focused GlassWindow - i.e. key events receiver
  40 
  41 
  42 @implementation GlassMainWindow
  43 
  44 -(id)initWithFrame:(CGRect)frame {
  45     self = [super initWithFrame:frame];
  46 
  47     [[NSNotificationCenter defaultCenter] addObserver:self
  48                                              selector:@selector(keyboardDidShow:)
  49                                                  name:UIKeyboardDidShowNotification
  50                                                object:nil];
  51 
  52     [[NSNotificationCenter defaultCenter] addObserver:self
  53                                              selector:@selector(keyboardDidHide:)
  54                                                  name:UIKeyboardDidHideNotification
  55                                                object:nil];
  56     return self;
  57 }
  58 
  59 // multitouch debugging
  60 - (void) sendEvent:(UIEvent *)event
  61 {
  62     GLASS_LOG(&quot;GlassMainWindow received UIEvent: %@&quot;, event);
  63     [super sendEvent:event];
  64 }
  65 
  66 - (void) keyboardDidShow:(NSNotification *) notification
  67 {
  68 #if MAT_IOS_DEBUG
  69     GLASS_LOG(&quot;[GlassMainWindow keyboardDidShow]&quot;);
  70     NSDictionary *info = [notification userInfo];
  71     CGRect keyboardFrame = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];
  72     GLASS_LOG(&quot;Keyboard frame x = %f, y = %f, width = %f, height = %f&quot;, keyboardFrame.origin.x, keyboardFrame.origin.y, keyboardFrame.size.width, keyboardFrame.size.height);
  73 #endif
  74 }
  75 
  76 - (void) keyboardDidHide:(NSNotification *) notification
  77 {
  78     GLASS_LOG(&quot;[GlassMainWindow keyboardidHide]&quot;);
  79     [self resignFocusOwner];
  80 }
  81 
  82 - (void) resignFocusOwner {
  83     [focusOwner resignKeyWindow];
  84 }
  85 
  86 @end
  87 
  88 @implementation GlassMainView
  89 
  90 - (id) initWithFrame:(CGRect)frame
  91 {
  92     self = [super initWithFrame:frame];
  93     if (self != nil) {
  94         [GlassDragDelegate setDragViewParent:self];
  95     }
  96     return self;
  97 }
  98 
  99 - (void) dealloc {
 100     [GlassDragDelegate setDragViewParent:nil];
 101     [GlassDragDelegate cleanup];
 102     [super dealloc];
 103 }
 104 
 105 @end
 106 
 107 //Toplevel containers of all GlassWindows
 108 //once we support multiple screens on iOS - there will be one masterWindow/
 109 //masterWindowHost per screen
 110 static GlassMainWindow * masterWindow = nil;
 111 static GlassMainView * masterWindowHost = nil;
 112 
 113 @interface GlassWindow (JavaAdditions)
 114 - (void)displaySubviews;
 115 - (void)_setLevel;
 116 - (void)orderBack;
 117 - (void)_orderBack;
 118 - (void)orderFrontRegardless;
 119 - (void)_orderFrontRegardless;
 120 
 121 - (void)addChildWindow:(GlassWindow*)child;
 122 - (void)removeChildWindow:(GlassWindow*)child;
 123 
 124 - (void)_setAlpha;
 125 - (void)_setBoundsAndPosition;
 126 - (CGSize)_constrainBounds:(CGRect)cFrame;
 127 - (void)_setMinimumSize;
 128 - (void)_setMaximumSize;
 129 - (void)_setVisible;
 130 
 131 + (void)_resetGrab;
 132 - (void)_grabFocus;
 133 - (void)_ungrabFocus;
 134 - (void)_checkUngrab;
 135 
 136 - (void)_sendJavaWindowMoveEventForFrame:(CGRect)frame;
 137 - (void)_sendJavaWindowResizeEvent:(int)type forFrame:(CGRect)frame;
 138 
 139 - (void)becomeKeyWindow;
 140 - (void)resignKeyWindow;
 141 - (void)windowWillClose;
 142 - (void)sendEvent:(UIEvent *)event;
 143 @end
 144 
 145 
 146 @interface GlassWindow (Java)
 147 - (id)initWithScreen:(UIScreen *)screen jwindow:(jobject)jwindow;
 148 @end
 149 
 150 
 151 
 152 static inline GlassWindow *getGlassWindow(JNIEnv *env, jlong jPtr)
 153 {
 154     if (jPtr != 0L)
 155     {
 156         return (GlassWindow*)jlong_to_ptr(jPtr);
 157     }
 158     else
 159     {
 160         return nil;
 161     }
 162 }
 163 
 164 
 165 static inline UIView&lt;GlassView&gt;* getiOSView(JNIEnv *env, jobject jview)
 166 {
 167     if (jview != NULL)
 168     {
 169         return (UIView&lt;GlassView&gt;*)jlong_to_ptr((*env)-&gt;GetLongField(env, jview, (*env)-&gt;GetFieldID(env, mat_jViewClass, &quot;nativePtr&quot;, &quot;J&quot;)));
 170     }
 171     else
 172     {
 173         return nil;
 174     }
 175 }
 176 
 177 
 178 static inline void setWindowFrame(GlassWindow *window, CGFloat x, CGFloat y, CGFloat w, CGFloat h, jboolean display, jboolean animate)
 179 {
 180     // set help variables
 181     window-&gt;_setFrameX = x;
 182     window-&gt;_setFrameY = y;
 183     window-&gt;_setFrameWidth = w;
 184     window-&gt;_setFrameHeight = h;
 185     window-&gt;_setFrameDisplay = display;
 186     window-&gt;_setFrameAnimated = animate;
 187 
 188     if ([[NSThread currentThread] isMainThread] == YES)
 189     {
 190         [window _setBoundsAndPosition]; // update origin and bounds
 191         if (display == JNI_TRUE) {
 192             GLASS_LOG(&quot;calling displaySubviews&quot;);
 193             [window displaySubviews];
 194             GLASS_LOG(&quot;called displaySubviews&quot;);
 195         }
 196         GLASS_LOG(&quot;GlassWindow frame after setWindowFrame: %f,%f,%f,%f&quot;,[window center].x - [window bounds].size.width / 2,[window center].y - [window bounds].size.height / 2, [window bounds].size.width,[window bounds].size.height);
 197     }
 198     else
 199     {
 200         [window performSelectorOnMainThread:@selector(_setBoundsAndPosition) withObject:nil waitUntilDone:YES];
 201         if (display == JNI_TRUE)
 202             [window performSelectorOnMainThread:@selector(displaySubviews) withObject:nil waitUntilDone:YES];
 203     }
 204 }
 205 
 206 
 207 @implementation GlassWindow
 208 
 209 +(GlassMainWindow *)  getMasterWindow {
 210     return masterWindow;
 211 }
 212 
 213 +(GlassMainView *) getMasterWindowHost {
 214     return masterWindowHost;
 215 }
<a name="1" id="anc1"></a>
















































 216 // request subviews to repaint
 217 - (void) displaySubviews
 218 {
 219     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 220     for (UIView * subView in [self-&gt;hostView subviews]) {
 221         if (subView != nil) {
 222             [subView setNeedsDisplay];
 223         }
 224     }
 225 }
 226 
 227 #pragma mark ---
 228 
 229 // close window (hide and destroy it)
 230 - (void) close {
 231     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 232     [self _ungrabFocus];
 233     [self setHidden:YES];
 234 
 235     [self windowWillClose];
 236 
 237     [masterWindowHost release];
 238     [masterWindow release];//decrease retaincount
 239 }
 240 
 241 
 242 - (void)setEnabled:(BOOL)enabled
 243 {
 244     GLASS_LOG(&quot;GlassWindow setEnabled&quot;);
 245     self-&gt;isEnabled = enabled;
 246 }
 247 
 248 
 249 #pragma mark --- Java
 250 
 251 - (id)initWithScreen:(UIScreen *)screen jwindow:(jobject)jwindow
 252 {
 253     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 254     CGRect bounds = CGRectMake(0.0f,0.0f,0.0f,0.0f);
 255     self = (GlassWindow *)[super initWithFrame: bounds];
 256     if (self != nil)
 257     {
 258         self-&gt;jWindow = jwindow;
 259         self-&gt;isFocusable = YES; // can become key window
 260 
 261         self-&gt;suppressWindowMoveEvent = NO;
 262         self-&gt;suppressWindowResizeEvent = NO;
 263         self-&gt;isEnabled = YES;
 264 
 265         //default values of min/max frame sizes
 266         self-&gt;minWidth = self-&gt;minHeight = 0.0f;
 267         self-&gt;maxWidth = self-&gt;maxHeight = CGFLOAT_MAX;
 268 
 269         self-&gt;childWindows = [NSMutableArray arrayWithCapacity:(NSUInteger)1];
 270         self-&gt;childWindows = [self-&gt;childWindows retain];
 271 
 272         // default to opaque
 273         [self _setTransparent:NO];
 274 
 275         [self setAutoresizesSubviews:NO];
 276 
 277     }
 278     return self;
 279 }
 280 
 281 
 282 #pragma mark ---
 283 
 284 - (void)_setTransparent:(BOOL)state
 285 {
 286     GLASS_LOG(&quot;GlassWindow _setTransparent called.&quot;);
 287     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 288     // should we store original background color?
 289     // This is only set during window creation so I don&#39;t think it&#39;s necessary
 290     self-&gt;isTransparent = state;
 291     if (self-&gt;isTransparent == YES)
 292     {
 293         [super setBackgroundColor:[UIColor clearColor]];
 294         [super setOpaque:NO];
 295     }
 296     else
 297     {
 298         [super setBackgroundColor:[UIColor blackColor]];
 299         [super setOpaque:YES];
 300     }
 301 }
 302 
 303 
 304 #pragma mark --- JavaAdditions
 305 
 306 - (void)_setAlpha
 307 {
 308     GLASS_LOG(&quot;GlassWindow _setAlpha called.&quot;);
 309     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 310     [self setAlpha:_setAlpha];
 311 }
 312 
 313 
 314 - (void)_setBoundsAndPosition
 315 {
 316     GLASS_LOG(&quot;_GlassWindow _setFrame called&quot;);
 317     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 318     CGRect frameRect = CGRectMake(0.0, 0.0, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 319 
 320     GLASS_LOG(&quot;bounds width, height before constraining %f, %f &quot;, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 321 
 322     CGSize constrainedSize = [self _constrainBounds:frameRect];
 323     //if larger than maxSize | smaller than minSize
 324     if (frameRect.size.width != constrainedSize.width ||
 325         frameRect.size.height != constrainedSize.height) {
 326         self-&gt;_setFrameWidth = constrainedSize.width;
 327         self-&gt;_setFrameHeight = constrainedSize.height;
 328         frameRect.size.width = constrainedSize.width;
 329         frameRect.size.height = constrainedSize.height;
 330     }
 331 
 332     GLASS_LOG(&quot;bounds width, height after constraining %f, %f &quot;, self-&gt;_setFrameWidth, self-&gt;_setFrameHeight);
 333 
 334 
 335     [self setBounds: frameRect];
 336 
 337 
 338     CGPoint newCenter = CGPointMake(self-&gt;_setFrameX + self-&gt;_setFrameWidth / 2, self-&gt;_setFrameY + self-&gt;_setFrameHeight / 2);
 339 
 340     [self setCenter:newCenter];
 341 
 342     GLASS_LOG(&quot;BOUNDS after GlassWindow _setFrame == %f, %f, center == %f %f&quot;,[self bounds].size.width,[self bounds].size.height ,[self center].x, [self center].y);
 343 
 344     GLASS_LOG(&quot;FRAME after GlassWindow _setFrame == %f, %f, %f, %f&quot;,[self frame].size.width,[self frame].size.height ,[self frame].origin.x, [self frame].origin.y);
 345 }
 346 
 347 -(void) setBounds:(CGRect)bounds
 348 {
 349     CGRect frameRect = bounds;
 350     if (self-&gt;owner == nil) { // primary Stage
 351         GLASS_LOG(&quot;primaryStage was asked to resize to %f, %f&quot;,bounds.size.width, bounds.size.height);
 352         frameRect = [[self superview] bounds];
 353         GLASS_LOG(&quot;primaryStage resized to %f, %f&quot;,frameRect.size.width, frameRect.size.height);
 354     }
 355 
 356     [super setBounds:frameRect];
 357 
 358     [self-&gt;hostView setFrame:frameRect];//hostView is always same size as GlassWindow
 359 
 360     for(GlassViewGL * subView in [self-&gt;hostView subviews]) {
 361         if(subView != nil &amp;&amp; [subView isKindOfClass:[GlassViewGL class]] == YES) {
 362             [subView setFrame:frameRect];
 363         }
 364     }
 365 
 366     [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 367 }
 368 
 369 -(void) setCenter:(CGPoint)center
 370 {
 371     CGPoint newCenter = center;
 372 
 373     if (self-&gt;owner == nil) { // primary Stage
 374         GLASS_LOG(&quot;primaryStage was asked to setCenter to %f, %f&quot;,center.x, center.y);
 375         CGRect frameRect = [[self superview] bounds];
 376         newCenter = CGPointMake(frameRect.size.width/2, frameRect.size.height/2);
 377 
 378         GLASS_LOG(&quot;primaryStage setCenter to %f, %f&quot;,newCenter.x, newCenter.y);
 379     }
 380 
 381     [super setCenter:newCenter];
 382 
 383     [self _sendJavaWindowMoveEventForFrame:CGRectMake([self center].x - [self bounds].size.width / 2, [self center].y - [self bounds].size.height / 2, [self bounds].size.width,[self bounds].size.height )];
 384 }
 385 
 386 
 387 - (CGSize)_constrainBounds:(CGRect)frame
 388 {
 389     GLASS_LOG(&quot;GlassWindow _constrainBounds called&quot;);
 390     CGSize size = frame.size;
 391 
 392     CGSize constrained = CGSizeMake(frame.size.width, frame.size.height);
 393     {
 394         if (size.width &lt; self-&gt;minWidth)
 395         {
 396             constrained.width = self-&gt;minWidth;
 397         }
 398         else if (size.width &gt; self-&gt;maxWidth)
 399         {
 400             constrained.width = self-&gt;maxWidth;
 401         }
 402         if (size.height &lt; self-&gt;minHeight)
 403         {
 404             constrained.height = self-&gt;minHeight;
 405         }
 406         else if (size.height &gt; self-&gt;maxHeight)
 407         {
 408             constrained.height = self-&gt;maxHeight;
 409         }
 410     }
 411     return constrained;
 412 }
 413 
 414 
 415 - (void)_setMinimumSize
 416 {
 417     GLASS_LOG(&quot;GlassWindow _setMinimumSize called. (w %f, h %f)&quot;,self-&gt;minWidth, self-&gt;minHeight);
 418     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 419     CGSize currentSize = [self bounds].size;
 420     if (currentSize.width &lt; self-&gt;minWidth || currentSize.height &lt; self-&gt;minHeight) {
 421         [self _setBoundsAndPosition];
 422         [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 423     }
 424 }
 425 
 426 
 427 - (void)_setMaximumSize
 428 {
 429     GLASS_LOG(&quot;GlassWindow _setMaximumSize called. (w %f, h %f)&quot;,self-&gt;maxWidth, self-&gt;maxHeight);
 430     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 431     CGSize currentSize = [self bounds].size;
 432     if (currentSize.width &gt; self-&gt;maxWidth || currentSize.height &gt; self-&gt;maxHeight) {
 433         [self _setBoundsAndPosition];
 434         [self _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[self bounds]];
 435     }
 436 }
 437 
 438 
 439 - (void)_setLevel
 440 {
 441     GLASS_LOG(&quot;GlassWindow _setLevel called.&quot;);
 442     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 443     UIWindowLevel level = UIWindowLevelNormal;
 444     switch (self-&gt;_setLevel)
 445     {
 446         case com_sun_glass_ui_Window_Level_FLOATING:
 447             level = UIWindowLevelStatusBar;
 448             break;
 449         case com_sun_glass_ui_Window_Level_TOPMOST:
 450             level = UIWindowLevelAlert;
 451             break;
 452     }
 453     //[self setWindowLevel:level];         // implemenation comes here
 454 }
 455 
 456 
 457 - (void)orderBack
 458 {
 459     GLASS_LOG(&quot;GlassWindow orderBack&quot;);
 460     if ([[NSThread currentThread] isMainThread] == YES) {
 461         [self _orderBack];
 462     } else {
 463         [self performSelectorOnMainThread:@selector(_orderBack) withObject:nil waitUntilDone:YES];
 464     }
 465 }
 466 
 467 
 468 - (void)_orderBack
 469 {
 470     GLASS_LOG(&quot;GlassWindow _orderBack&quot;);
 471     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 472     if ([self superview] != nil) {
 473         [[self superview] sendSubviewToBack:self];
 474     }
 475 }
 476 
 477 
 478 - (void) _orderFrontRegardless
 479 {
 480     GLASS_LOG(&quot;GlassWindow _orderFrontRegardless &quot;);
 481     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 482     if ([self superview] != nil) {
 483         [[self superview] bringSubviewToFront:self];
 484     }
 485 }
 486 
 487 
 488 - (void) orderFrontRegardless
 489 {
 490     if ([[NSThread currentThread] isMainThread] == YES) {
 491         [self _orderFrontRegardless];
 492     } else {
 493         [self performSelectorOnMainThread:@selector(_orderFrontRegardless) withObject:nil waitUntilDone:YES];
 494     }
 495 }
 496 
 497 
 498 - (void)addChildWindow:(GlassWindow*)child
 499 {
 500     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 501     if (child != nil) {
 502         child-&gt;parentWindow = self;
 503         [self-&gt;childWindows addObject:child];
 504 
 505         [child _setBoundsAndPosition];
 506     }
 507 }
 508 
 509 
 510 - (void)removeChildWindow:(GlassWindow*)child
 511 {
 512     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 513     if (child != nil) {
 514         child-&gt;parentWindow = nil;
 515         [self-&gt;childWindows removeObject:child];
 516     }
 517 }
 518 
 519 
 520 + (void)_resetGrab
 521 {
 522     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 523     if (s_grabWindow &amp;&amp; [s_grabWindow isKindOfClass:[GlassWindow class]]) {
 524         GlassWindow * window = (GlassWindow*)s_grabWindow;
 525         [window _ungrabFocus];
 526     }
 527     s_grabWindow = nil; // unconditionally
 528 }
 529 
 530 
 531 - (void)_ungrabFocus
 532 {
 533     if (s_grabWindow != self) {
 534         return;
 535     }
 536 
 537     GET_MAIN_JENV;
 538     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, jWindowNotifyFocusUngrab);
 539 
 540     s_grabWindow = nil;
 541 }
 542 
 543 
 544 - (void)_checkUngrab
 545 {
 546     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 547     if (!s_grabWindow) {
 548         return;
 549     }
 550 
 551     // If this window doesn&#39;t belong to an owned windows hierarchy that
 552     // holds the grab currently, then the grab should be released.
 553     for (GlassWindow * window = self; window; window = window-&gt;parentWindow) {
 554         if (window == s_grabWindow) {
 555             return;
 556         }
 557     }
 558 
 559     [GlassWindow _resetGrab];
 560 }
 561 
 562 
 563 - (void)_grabFocus
 564 {
 565     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 566     if (s_grabWindow == self) {
 567         return;
 568     }
 569 
 570     [GlassWindow _resetGrab];
 571     s_grabWindow = self;
 572 }
 573 
 574 
 575 - (void)_setVisible
 576 {
 577     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 578     if (self-&gt;isEnabled == YES)
 579     {
 580         GLASS_LOG(&quot;making GlassWindow Visible %p&quot;,self);
 581         [self setHidden:NO];
 582 
 583         if (self-&gt;isFocusable == YES) {
 584             GLASS_LOG(&quot;making GlassWindow key %p&quot;,self);
 585             [self makeKeyWindow];
 586         }
 587 
 588         [self orderFrontRegardless];
 589     } else {
 590         [self orderFrontRegardless];
 591     }
 592 
 593     if ((self-&gt;owner != nil &amp;&amp; self-&gt;parentWindow == nil))
 594     {
 595         [(GlassWindow *)self-&gt;owner addChildWindow:self];
 596     }
 597 }
 598 
 599 
 600 - (void)_sendJavaWindowMoveEventForFrame:(CGRect)frame
 601 {
 602     if (self-&gt;suppressWindowMoveEvent == NO)
 603     {
 604         GET_MAIN_JENV;
 605         (*env)-&gt;CallVoidMethod(env, jWindow, mat_jWindowNotifyMove, (int)frame.origin.x,  (int)frame.origin.y);
 606     }
 607 }
 608 
 609 
 610 - (void)_sendJavaWindowResizeEvent:(int)type forFrame:(CGRect)frame
 611 {
 612     if (self-&gt;suppressWindowResizeEvent == NO)
 613     {
 614         GET_MAIN_JENV;
 615         (*env)-&gt;CallVoidMethod(env, jWindow, mat_jWindowNotifyResize, type, (int)frame.size.width, (int)frame.size.height);
 616     }
 617 }
 618 
 619 
 620 #pragma mark --- UIView
 621 
 622 - (void) setBackgroundColor:(UIColor *)color
 623 {
 624     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 625     if (self-&gt;isTransparent == NO)
 626     {
 627         // allow color if we&#39;re opaque
 628         [super setBackgroundColor:color];
 629     }
 630     else
 631     {
 632         // for transparent window, ignore and set to clear color
 633         // do we want to store the background color in case we switch to non-transparent mode?
 634         [super setBackgroundColor:[UIColor clearColor]];
 635     }
 636 }
 637 
 638 - (void) makeKeyWindow
 639 {
 640     if (self-&gt;isEnabled &amp;&amp; self-&gt;isFocusable &amp;&amp; focusOwner != self) {
 641 
 642         [focusOwner resignKeyWindow];
 643 
 644         [self becomeKeyWindow];
 645     }
 646 }
 647 
 648 - (BOOL) isKeyWindow
 649 {
 650     return self == focusOwner;
 651 }
 652 
 653 - (void)becomeKeyWindow
 654 {
 655     GLASS_LOG(&quot;Window did become key&quot;);
 656     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 657 
 658 
 659     GET_MAIN_JENV;
 660     if (!self-&gt;isEnabled)
 661     {
 662         (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocusDisabled);
 663         return;
 664     }
 665 
 666     focusOwner = self;
 667 
 668     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);
 669 }
 670 
 671 
 672 - (void)resignKeyWindow
 673 {
 674     GLASS_LOG(&quot;Window did resign key&quot;);
 675     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 676 
 677     if (focusOwner == self) {
 678         focusOwner = nil;
 679     }
 680 
 681     [self _ungrabFocus];
 682 
 683     GET_MAIN_JENV;
 684     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_LOST);
 685 }
 686 
 687 
 688 - (void)windowWillClose
 689 {
 690     GLASS_LOG(&quot;GlassWindow windowWillClose&quot;);
 691     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot; );
 692     // Unparent self
 693     if (self-&gt;parentWindow != nil)
 694     {
 695         [self-&gt;parentWindow removeChildWindow:self];
 696     }
 697 
 698     // Call the notification method
 699     GET_MAIN_JENV;
 700     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, mat_jWindowNotifyDestroy);
 701 
 702     if (childWindows != NULL) {
 703 
 704         // Finally, close owned windows to mimic MS Windows behavior
 705         for (GlassWindow * child in self-&gt;childWindows)
 706         {
 707             [child close];
 708         }
 709 
 710         [childWindows release];
 711     }
 712 
 713     [self-&gt;hostView removeFromSuperview];
 714     [self-&gt;hostView release];
 715 
 716     if ([self superview] != nil) {
 717         [self removeFromSuperview];
 718     }
 719 
 720     if (focusOwner == self) {
 721         focusOwner = nil;
 722     }
 723 
 724     (*jEnv)-&gt;DeleteGlobalRef(jEnv, self-&gt;jWindow);
 725     GLASS_CHECK_EXCEPTION(jEnv);
 726 
 727     self-&gt;jWindow = NULL;
 728 }
 729 
 730 
 731 - (void) requestInput:(NSString *)text type:(int)type width:(double)width height:(double)height
 732                   mxx:(double)mxx mxy:(double)mxy mxz:(double)mxz mxt:(double)mxt
 733                   myx:(double)myx myy:(double)myy myz:(double)myz myt:(double)myt
 734                   mzx:(double)mzx mzy:(double)mzy mzz:(double)mzz mzt:(double)mzt
 735 
 736 {
 737     [view requestInput:text type:type width:width height:height
 738                    mxx:mxx mxy:mxy mxz:mxz mxt:mxt
 739                    myx:myx myy:myy myz:myz myt:myt
 740                    mzx:mzx mzy:mzy mzz:mzz mzt:mzt];
 741 }
 742 
 743 
 744 - (void) releaseInput
 745 {
 746     [view releaseInput];
 747 }
 748 
 749 @end
 750 
 751 
 752 
 753 jlong _1createWindow(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask)
 754 {
 755     [[NSThread currentThread] isMainThread];
 756     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[1] must be on main thread&quot;);
 757     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 758 
 759     GlassWindow *window;
 760 
 761     {
 762         UIScreen *screen = (UIScreen*)jlong_to_ptr(jScreenPtr);
 763         BOOL hidden = YES;
 764         if (jOwnerPtr == 0L) {
 765             // no owner means it is the primary stage; Decorated primary stage shows status bar by default
 766             hidden = ((jStyleMask &amp; com_sun_glass_ui_Window_TITLED) == 0);
 767 
 768             NSObject * values = [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;UIStatusBarHidden&quot;];
 769             //we prefer explicit settings from .plist
 770             if (values != nil) {
 771                 hidden = (values == @(YES))?YES:NO;
 772             }
 773 
 774             [UIApplication sharedApplication].statusBarHidden = hidden;
 775         }
 776 
 777 
 778         if (masterWindow == nil) {
 779             //We have to remove rootViewController of splashscreen UIWindow in order to avoid
 780             //StatusBar orientation change ...
 781             UIWindow *splashScreen = [[UIApplication sharedApplication] keyWindow];
 782             splashScreen.rootViewController = nil;
 783 
 784             GLASS_LOG(&quot;SCREEN: %@&quot;, screen);
 785             CGRect applicationFrame = [screen bounds];
 786             GLASS_LOG(&quot;FRAME: %@&quot;, applicationFrame);
 787 
 788             masterWindow = [[GlassMainWindow alloc] initWithFrame:applicationFrame];
 789             masterWindowHost = [[GlassMainView alloc] initWithFrame:CGRectMake(0.0, 0.0, applicationFrame.size.width, applicationFrame.size.height)];
 790 
 791             // Set GlassViewController - responsible for orientation change, etc.
 792             GlassViewController *rvc = [[GlassViewController alloc] init];
 793             [rvc setView:masterWindowHost];
 794             [masterWindow setRootViewController:rvc];
 795             [rvc release];
 796 
 797             [masterWindow setHidden:NO];
 798             [masterWindowHost setHidden:NO];
 799         } else {
 800             masterWindow = [masterWindow retain];//increase retain count per each GlassWindow
 801             masterWindowHost = [masterWindowHost retain];
 802         }
 803 
 804         [masterWindow setAutoresizesSubviews:YES];
 805         [masterWindowHost setAutoresizesSubviews:NO];
 806 
 807         [masterWindow makeKeyWindow];
 808 
 809         GLASS_LOG(&quot;GlassWindow _1createWindow&quot;);
 810         window = [[GlassWindow alloc] initWithScreen:screen jwindow:jWindow];
 811 
 812         window-&gt;isResizable = NO;
 813 
 814         window-&gt;hostView = [[UIView alloc] init];
 815         [window-&gt;hostView setAutoresizesSubviews:NO];
 816 
 817         [window addSubview:window-&gt;hostView];
 818 
 819         window.backgroundColor = [UIColor whiteColor];
 820 
 821         if ((jStyleMask &amp; com_sun_glass_ui_Window_TRANSPARENT) != 0)
 822         {
 823             [window _setTransparent:YES];
 824         }
 825         else
 826         {
 827             [window _setTransparent:NO];
 828         }
 829 
 830         [masterWindowHost addSubview:window];
 831 
 832         if (jOwnerPtr != 0L)
 833         {
 834             GLASS_LOG(&quot;Adding %p window as usbview of owner window %lld&quot;, window, jOwnerPtr);
 835             window-&gt;owner = (UIWindow*)jlong_to_ptr(jOwnerPtr);
 836         } else {
 837             NSArray *views = [masterWindowHost subviews];
 838             // if there exists any secondary stage, its owner is primary stage internally if
 839             // not set explicitly
 840             if ([views count] &gt; 1) {
 841                 window-&gt;owner = [views objectAtIndex:0];
 842             }
 843         }
 844     }
 845     [pool drain];
 846 
 847     GLASS_CHECK_EXCEPTION(env);
 848 
 849     return ptr_to_jlong(window);
 850 }
 851 
 852 
 853 
 854 @interface GlassWindowDispatcher : NSObject
 855 {
 856 @public
 857     jobject     jWindow;
 858     jlong       jOwnerPtr;
 859     jlong       jScreenPtr;
 860     jint        jStyleMask;
 861     jlong       jlongReturn;
 862 }
 863 @end
 864 
 865 
 866 
 867 @implementation GlassWindowDispatcher
 868 
 869 - (void) _createWindow
 870 {
 871     NSAssert([[NSThread currentThread] isMainThread] == YES, @&quot;must be on main thread&quot;);
 872     GET_MAIN_JENV;
 873     self-&gt;jlongReturn = _1createWindow(env, self-&gt;jWindow, self-&gt;jOwnerPtr, self-&gt;jScreenPtr, self-&gt;jStyleMask);
 874 }
 875 
 876 @end
 877 
 878 
 879 
 880 /*
 881  * Class:     com_sun_glass_ui_ios_IosWindow
 882  * Method:    _createWindow
 883  * Signature: (JJZI)J
 884  */
 885 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createWindow
 886 (JNIEnv *env, jobject jwindow, jlong jownerPtr, jlong jscreenPtr, jint jstyleMask)
 887 {
 888     jlong value;
 889 
 890     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 891     GLASS_POOL_ENTER;
 892     {
 893         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createWindow&quot;);
 894         jobject jWindowRef = (*env)-&gt;NewGlobalRef(env, jwindow);
 895         if ([[NSThread currentThread] isMainThread] == YES)
 896         {
 897             value = _1createWindow(env, jWindowRef, jownerPtr, jscreenPtr, jstyleMask);
 898             GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createWindow  from NSMainThread called&quot;);
 899 
 900         }
 901         else
 902         {
 903             GlassWindowDispatcher *dispatcher = [[GlassWindowDispatcher alloc] autorelease];
 904             dispatcher-&gt;jWindow = jWindowRef;
 905             dispatcher-&gt;jOwnerPtr = jownerPtr;
 906             dispatcher-&gt;jScreenPtr = jscreenPtr;
 907             dispatcher-&gt;jStyleMask = jstyleMask;
 908             [dispatcher performSelectorOnMainThread:@selector(_createWindow) withObject:dispatcher waitUntilDone:YES];
 909             value = dispatcher-&gt;jlongReturn;
 910         }
 911     }
 912     GLASS_POOL_EXIT;
 913     GLASS_CHECK_EXCEPTION(env);
 914 
 915     return value;
 916 }
 917 
 918 
 919 /*
 920  * Class:     com_sun_glass_ui_ios_IosWindow
 921  * Method:    _createChildWindow
 922  * Signature: (J)J
 923  */
 924 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow
 925 (JNIEnv *env, jobject jwindow, jlong parent) {
 926     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1createChildWindow&quot;);
 927     // implementation comes here
 928     return 0L;
 929 }
 930 
 931 
 932 /*
 933  * Class:     com_sun_glass_ui_ios_IosWindow
 934  * Method:    _close
 935  * Signature: (J)Z
 936  */
 937 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1close
 938 (JNIEnv *env, jclass jwindow, jlong ptr) {
 939     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1close&quot;);
 940     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 941     GLASS_POOL_ENTER;
 942     {
 943         GlassWindow *window = (GlassWindow*)jlong_to_ptr(ptr);
 944         if ([[NSThread currentThread] isMainThread] == YES)
 945         {
 946             // this call will always close the window
 947             // without calling the windowShouldClose
 948             [window close];
 949             [window release];
 950         }
 951         else
 952         {
 953             // this call will always close the window
 954             // without calling the windowShouldClose
 955             [window performSelectorOnMainThread:@selector(close) withObject:nil waitUntilDone:YES];
 956             [window performSelectorOnMainThread:@selector(release) withObject:nil waitUntilDone:YES];
 957         }
 958         // The window is released here since we retain it - different from Mac OS X
 959     }
 960     GLASS_POOL_EXIT;
 961     GLASS_CHECK_EXCEPTION(env);
 962 
 963     return JNI_TRUE;
 964 }
 965 
 966 
 967 /*
 968  * Class:     com_sun_glass_ui_ios_IosWindow
 969  * Method:    _setView
 970  * Signature: (JLcom/sun/glass/ui/View;)Z
 971  */
 972 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setView
 973 (JNIEnv *env, jobject jwindow, jlong windowPtr, jobject jview) {
 974 
 975     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[2] must be on main thread&quot;);
 976 
 977     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 978     GLASS_POOL_ENTER;
 979     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setView&quot;);
 980     {
 981         GlassWindow *window = getGlassWindow(env, windowPtr);
 982 
 983         window-&gt;view = getiOSView(env, jview);
 984 
 985 
 986         GLASS_LOG(&quot;window: %@&quot;, window);
 987         GLASS_LOG(&quot;frame: %.2f,%.2f %.2fx%.2f&quot;, [window frame].origin.x, [window frame].origin.y, [window frame].size.width, [window frame].size.height);
 988         GLASS_LOG(&quot;view: %@&quot;, window-&gt;view);
 989         GLASS_LOG(&quot;frame: %.2f,%.2f %.2fx%.2f&quot;, [window-&gt;view frame].origin.x, [window-&gt;view frame].origin.y, [window-&gt;view frame].size.width, [window-&gt;view frame].size.height);
 990 
 991         if (window-&gt;view != nil)
 992         {
 993             window-&gt;suppressWindowMoveEvent = YES; // RT-11215
 994             {
 995                 CGRect viewFrame = [window-&gt;view bounds];
 996                 if ((viewFrame.size.width != 0.0f) &amp;&amp; (viewFrame.size.height != 0.0f))
 997                 {
 998                     CGRect windowFrame = CGRectMake(0.0, 0.0, viewFrame.size.width, viewFrame.size.height);
 999                     windowFrame.origin.x = [window center].x - viewFrame.size.width / 2 ;
1000                     windowFrame.origin.y = [window center].y - viewFrame.size.height / 2;
1001                     setWindowFrame(window, windowFrame.origin.x, windowFrame.origin.y, windowFrame.size.width, windowFrame.size.height, JNI_TRUE, JNI_FALSE);
1002                 }
1003 
1004                 if ([[NSThread currentThread] isMainThread] == YES)
1005                 {
1006                     [window-&gt;hostView addSubview: window-&gt;view];
1007                 }
1008                 else
1009                 {
1010                     [window-&gt;hostView performSelectorOnMainThread:@selector(addSubview:) withObject:window-&gt;view waitUntilDone:YES];
1011                 }
1012             }
1013             window-&gt;suppressWindowMoveEvent = NO;
1014         }
1015     }
1016     GLASS_POOL_EXIT;
1017     GLASS_CHECK_EXCEPTION(env);
1018 
1019     return JNI_TRUE;
1020 }
1021 
1022 
1023 /*
1024  * Class:     com_sun_glass_ui_ios_IosWindow
1025  * Method:    _setMenubar
1026  * Signature: (JJ)Z
1027  */
1028 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMenubar
1029 (JNIEnv *env, jobject jwindow, jlong windowPtr, jlong menubarPtr) {
1030 
1031     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1032     GLASS_POOL_ENTER;
1033     {
1034         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMenubar - setMenuBar called.&quot;);
1035         // implementation comes here
1036     }
1037     GLASS_POOL_EXIT;
1038     GLASS_CHECK_EXCEPTION(env);
1039 
1040     return JNI_TRUE;
1041 }
1042 
1043 
1044 /*
1045  * Class:     com_sun_glass_ui_ios_IosWindow
1046  * Method:    _minimize
1047  * Signature: (JZ)Z
1048  */
1049 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1minimize
1050 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean minimize) {
1051     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1minimize called.&quot;);
1052 
1053     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1054     GLASS_POOL_ENTER;
1055     {
1056         // implementation comes here
1057     }
1058     GLASS_POOL_EXIT;
1059     GLASS_CHECK_EXCEPTION(env);
1060 
1061     return JNI_TRUE;
1062 }
1063 
1064 
1065 /*
1066  * Class:     com_sun_glass_ui_ios_IosWindow
1067  * Method:    _maximize
1068  * Signature: (JZZ)Z
1069  */
1070 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1maximize
1071 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean maximize, jboolean wasMaximized) {
1072     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1maximize called.&quot;);
1073     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1074     GLASS_POOL_ENTER;
1075     {
1076         // implementation comes here
1077     }
1078     GLASS_POOL_EXIT;
1079     GLASS_CHECK_EXCEPTION(env);
1080 
1081     return JNI_TRUE;
1082 }
1083 
1084 
1085 /*
1086  * Class:     com_sun_glass_ui_ios_IosWindow
1087  * Method:    _setBoundsAndPosition
1088  * Signature: (JIIZZIIIIFF)V
1089  */
1090 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setBounds
1091 (JNIEnv *env, jobject jWindow, jlong jPtr,
1092  jint x, jint y, jboolean xSet, jboolean ySet,
1093  jint w, jint h, jint cw, jint ch, jfloat xGravity, jfloat yGravity)
1094 {
1095     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setBounds&quot;);
1096     if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[3] must be on main thread&quot;);
1097 
1098     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1099     GLASS_POOL_ENTER;
1100     {
1101         GLASS_LOG(&quot;Called setBounds with x %ld,y %ld,xSet %d,ySet %d,w %ld,h %ld,cw %ld,ch %ld&quot;,x,y,xSet,ySet,w,h,cw,ch);
1102 
1103         GlassWindow *window = (GlassWindow *)jlong_to_ptr(jPtr);
1104 
1105         CGPoint origin = CGPointMake([window center].x - [window bounds].size.width / 2, [window center].y - [window bounds].size.height / 2);
1106         GLASS_LOG(&quot;window original position x,y %f, %f&quot;,origin.x,origin.y);
1107 
1108         CGSize size = [window bounds].size;
1109         GLASS_LOG(&quot;window size w,h %f,%f&quot;,size.width,size.height);
1110 
1111         CGSize sizeForClient = CGRectMake(0, 0, cw &gt; 0 ? cw : 0, ch &gt; 0 ? ch : 0).size;
1112         GLASS_LOG(&quot;sizeForClient %f, %f&quot;, sizeForClient.width, sizeForClient.height);
1113 
1114         CGFloat newX = xSet == JNI_TRUE ? x : origin.x;
1115         CGFloat newY = ySet == JNI_TRUE ? y : origin.y;
1116         CGFloat newW = (w &gt; 0) ? w :
1117         (cw &gt; 0) ? sizeForClient.width : size.width;
1118         CGFloat newH = (h &gt; 0) ? h :
1119         (ch &gt; 0) ? sizeForClient.height : size.height;
1120         GLASS_LOG(&quot;FRAME: x,y,w,h - %f, %f, %f %f&quot;,newX, newY, newW, newH);
1121 
1122         setWindowFrame(window, newX, newY, newW, newH, JNI_TRUE, JNI_FALSE);
1123 
1124         //Let&#39;s notify JavaFX about move,size change (as we don&#39;t have window&#39;s size,position) Notifications on iOS
1125         if(xSet == JNI_TRUE || ySet == JNI_TRUE) {
1126             [window _sendJavaWindowMoveEventForFrame:CGRectMake([window center].x - [window bounds].size.width / 2, [window center].y - [window bounds].size.height / 2, [window bounds].size.width,[window bounds].size.height )];
1127         } else {
1128             [window _sendJavaWindowResizeEvent:com_sun_glass_events_WindowEvent_RESIZE forFrame:[window bounds]];
1129         }
1130     }
1131     GLASS_POOL_EXIT;
1132     GLASS_CHECK_EXCEPTION(env);
1133 }
1134 
1135 
1136 /*
1137  * Class:     com_sun_glass_ui_ios_IosWindow
1138  * Method:    _setVisible
1139  * Signature: (JZ)Z
1140  */
1141 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setVisible
1142 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean visible) {
1143     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setVisible called.&quot;);
1144     jboolean now;
1145 
1146     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1147     GLASS_POOL_ENTER;
1148     {
1149         GlassWindow *window = getGlassWindow(env, windowPtr);
1150         if (visible == JNI_TRUE)
1151         {
1152             if ([[NSThread currentThread] isMainThread] == YES)
1153             {
1154                 [window _setVisible];
1155             }
1156             else
1157             {
1158                 [window performSelectorOnMainThread:@selector(_setVisible) withObject:nil waitUntilDone:YES];
1159             }
1160         }
1161         else
1162         {
1163             if ([[NSThread currentThread] isMainThread] == YES)
1164             {
1165                 [window _ungrabFocus];
1166                 if (window-&gt;owner != nil)
1167                 {
1168                     [(GlassWindow *)window-&gt;owner removeChildWindow: window];
1169                 }
1170                 //[window orderOut:window];
1171             }
1172             else
1173             {
1174                 [window performSelectorOnMainThread:@selector(_ungrabFocus) withObject:nil waitUntilDone:YES];
1175                 if (window-&gt;owner != nil)
1176                 {
1177                     [(GlassWindow *)(window-&gt;owner) performSelectorOnMainThread:@selector(removeChildWindow:) withObject:window waitUntilDone:YES];
1178                 }
1179                 //[window performSelectorOnMainThread:@selector(orderOut:) withObject:window waitUntilDone:YES];
1180             }
1181         }
1182         if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[4] must be on main thread&quot;);
1183         now = ([window isHidden] == NO) ? JNI_TRUE : JNI_FALSE;
1184     }
1185     GLASS_POOL_EXIT;
1186     GLASS_CHECK_EXCEPTION(env);
1187 
1188     return now;
1189 }
1190 
1191 
1192 /*
1193  * Class:     com_sun_glass_ui_ios_IosWindow
1194  * Method:    _requestFocus
1195  * Signature: (J)Z
1196  */
1197 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1requestFocus
1198 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1199     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1requestFocus  called.&quot;);
1200     jboolean focused;
1201 
1202     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1203     GLASS_POOL_ENTER;
1204     {
1205         GlassWindow *window = getGlassWindow(env, windowPtr);
1206         if (window-&gt;isFocusable == YES) {
1207             if ([[NSThread currentThread] isMainThread] == YES)
1208             {
1209                 [window makeKeyWindow];//for iOS
1210                 [window orderFrontRegardless];
1211             }
1212             else
1213             {
1214                 [window performSelectorOnMainThread:@selector(makeKeyWindow) withObject:nil waitUntilDone:YES];
1215                 [window performSelectorOnMainThread:@selector(orderFrontRegardless) withObject:window waitUntilDone:YES];
1216             }
1217         }
1218         if ([[NSThread currentThread] isMainThread] == NO) NSLog(@&quot;[5] must be on main thread&quot;);
1219         focused = [window isKeyWindow] ? JNI_TRUE : JNI_FALSE;
1220     }
1221     GLASS_POOL_EXIT;
1222     GLASS_CHECK_EXCEPTION(env);
1223 
1224     return focused;
1225 }
1226 
1227 
1228 /*
1229  * Class:     com_sun_glass_ui_ios_IosWindow
1230  * Method:    _grabFocus
1231  * Signature: (J)Z
1232  */
1233 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1grabFocus
1234 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1235     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1grabFocus&quot;);
1236     jboolean ret;
1237 
1238     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1239     GLASS_POOL_ENTER;
1240     {
1241         GlassWindow * window = getGlassWindow(env, windowPtr);
1242         if ([[NSThread currentThread] isMainThread] == YES)
1243         {
1244             [window _grabFocus];
1245         }
1246         else
1247         {
1248             [window performSelectorOnMainThread:@selector(_grabFocus) withObject:nil waitUntilDone:YES];
1249         }
1250         ret = JNI_TRUE;
1251     }
1252     GLASS_POOL_EXIT;
1253     GLASS_CHECK_EXCEPTION(env);
1254 
1255     return ret;
1256 }
1257 
1258 
1259 /*
1260  * Class:     com_sun_glass_ui_ios_IosWindow
1261  * Method:    _ungrabFocus
1262  * Signature: (J)
1263  */
1264 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1ungrabFocus
1265 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1266     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1ungrabFocus&quot;);
1267 
1268     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1269     GLASS_POOL_ENTER;
1270     {
1271         GlassWindow * window = getGlassWindow(env, windowPtr);
1272 
1273         if ([[NSThread currentThread] isMainThread] == YES)
1274         {
1275             [window _ungrabFocus];
1276         } else {
1277             [window performSelectorOnMainThread:@selector(_ungrabFocus) withObject:nil waitUntilDone:YES];
1278         }
1279     }
1280     GLASS_POOL_EXIT;
1281     GLASS_CHECK_EXCEPTION(env);
1282 }
1283 
1284 
1285 /*
1286  * Class:     com_sun_glass_ui_ios_IosWindow
1287  * Method:    _setTitle
1288  * Signature: (JLjava/lang/String;)Z
1289  */
1290 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setTitle
1291 (JNIEnv *env, jobject jwindow, jlong windowPtr, jstring title) {
1292     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setTitle called.&quot;);
1293     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1294     GLASS_POOL_ENTER;
1295     {
1296         // implementation comes here when feature is requested on iOS
1297     }
1298     GLASS_POOL_EXIT;
1299     GLASS_CHECK_EXCEPTION(env);
1300 
1301     return JNI_TRUE;
1302 }
1303 
1304 
1305 /*
1306  * Class:     com_sun_glass_ui_ios_IosWindow
1307  * Method:    _setLevel
1308  * Signature: (JI)V
1309  */
1310 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setLevel
1311 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint level) {
1312     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setLevel called.&quot;);
1313     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1314     GLASS_POOL_ENTER;
1315     {
1316         GlassWindow *window = getGlassWindow(env, windowPtr);
1317         window-&gt;_setLevel = level;
1318 
1319         if ([[NSThread currentThread] isMainThread] == YES)
1320         {
1321             [window _setLevel];
1322         }
1323         else
1324         {
1325             [window performSelectorOnMainThread:@selector(setLevel) withObject:nil waitUntilDone:YES];
1326         }
1327     }
1328     GLASS_POOL_EXIT;
1329     GLASS_CHECK_EXCEPTION(env);
1330 }
1331 
1332 
1333 /*
1334  * Class:     com_sun_glass_ui_ios_IosWindow
1335  * Method:    _setResizable
1336  * Signature: (JZ)Z
1337  */
1338 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setResizable
1339 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean resizeable) {
1340     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1341     GLASS_POOL_ENTER;
1342     {
1343         GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setResizable called.&quot;);
1344         GlassWindow *window = getGlassWindow(env, windowPtr);
1345         if (window-&gt;isResizable != resizeable)
1346         {
1347             window-&gt;isResizable = resizeable;
1348         }
1349     }
1350     GLASS_POOL_EXIT;
1351     GLASS_CHECK_EXCEPTION(env);
1352 
1353     return JNI_TRUE;
1354 }
1355 
1356 
1357 /*
1358  * Class:     com_sun_glass_ui_ios_IosWindow
1359  * Method:    _setFocusable
1360  * Signature: (JZ)V
1361  */
1362 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setFocusable
1363 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean isFocusable) {
1364     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setFocusable called.&quot;);
1365     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1366     GLASS_POOL_ENTER;
1367     {
1368         GlassWindow *window = getGlassWindow(env, windowPtr);
1369         window-&gt;isFocusable = isFocusable;
1370     }
1371     GLASS_POOL_EXIT;
1372     GLASS_CHECK_EXCEPTION(env);
1373 }
1374 
1375 
1376 /*
1377  * Class:     com_sun_glass_ui_ios_IosWindow
1378  * Method:    _setAlpha
1379  * Signature: (JF)V
1380  */
1381 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setAlpha
1382 (JNIEnv *env, jobject jwindow, jlong windowPtr, jfloat alpha) {
1383     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setAlpha(%f)&quot;,alpha);
1384     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1385     GLASS_POOL_ENTER;
1386     {
1387         GlassWindow *window = getGlassWindow(env, windowPtr);
1388         window-&gt;_setAlpha = alpha;
1389 
1390         if ([[NSThread currentThread] isMainThread] == YES)
1391         {
1392             [window _setAlpha];
1393         }
1394         else
1395         {
1396             [window performSelectorOnMainThread:@selector(_setAlpha) withObject:nil waitUntilDone:YES];
1397         }
1398     }
1399     GLASS_POOL_EXIT;
1400     GLASS_CHECK_EXCEPTION(env);
1401 }
1402 
1403 
1404 /*
1405  * Class:     com_sun_glass_ui_ios_IosWindow
1406  * Method:    _setBackground
1407  * Signature: (JFFF)Z
1408  */
1409 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setBackground
1410 (JNIEnv *env, jobject jwindow, jlong windowPtr, jfloat r, jfloat g, jfloat b) {
1411     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setBackground&quot;);
1412     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1413     GLASS_POOL_ENTER;
1414     {
1415         GlassWindow *window = getGlassWindow(env, windowPtr);
1416         if ([[NSThread currentThread] isMainThread] == YES)
1417         {
1418             [window setBackgroundColor:[UIColor colorWithRed:r green:g blue:b alpha:1.0f]];
1419         }
1420         else
1421         {
1422             [window performSelectorOnMainThread:@selector(setBackgroundColor:) withObject:[UIColor colorWithRed:r green:g blue:b alpha:1.0f] waitUntilDone:YES];
1423         }
1424     }
1425     GLASS_POOL_EXIT;
1426     GLASS_CHECK_EXCEPTION(env);
1427 
1428     return JNI_TRUE;
1429 }
1430 
1431 
1432 /*
1433  * Class:     com_sun_glass_ui_ios_IosWindow
1434  * Method:    _setMinimumSize
1435  * Signature: (JII)Z
1436  */
1437 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMinimumSize
1438 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint width, jint height) {
1439     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMinimumSize called.&quot;);
1440     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1441     GLASS_POOL_ENTER;
1442     {
1443         GlassWindow *window = getGlassWindow(env, windowPtr);
1444         window-&gt;minWidth = (jfloat) width;
1445         window-&gt;minHeight = (jfloat) height;
1446 
1447         if ([[NSThread currentThread] isMainThread] == YES)
1448         {
1449             [window _setMinimumSize];
1450         }
1451         else
1452         {
1453             [window performSelectorOnMainThread:@selector(_setMinimumSize) withObject:nil waitUntilDone:YES];
1454         }
1455     }
1456     GLASS_POOL_EXIT;
1457     GLASS_CHECK_EXCEPTION(env);
1458 
1459     return JNI_TRUE;
1460 }
1461 
1462 
1463 /*
1464  * Class:     com_sun_glass_ui_ios_IosWindow
1465  * Method:    _setMaximumSize
1466  * Signature: (JII)Z
1467  */
1468 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setMaximumSize
1469 (JNIEnv *env, jobject jwindow, jlong windowPtr, jint width, jint height) {
1470     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setMaximumSize called.&quot;);
1471     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1472     GLASS_POOL_ENTER;
1473     {
1474         GlassWindow *window = getGlassWindow(env, windowPtr);
1475         window-&gt;maxWidth = (jfloat)(width &gt;= 0 ? width : CGFLOAT_MAX);
1476         window-&gt;maxHeight = (jfloat)(height &gt;= 0 ? height : CGFLOAT_MAX);
1477 
1478         if ([[NSThread currentThread] isMainThread] == YES)
1479         {
1480             [window _setMaximumSize];
1481         }
1482         else
1483         {
1484             [window performSelectorOnMainThread:@selector(_setMaximumSize) withObject:nil waitUntilDone:YES];
1485         }
1486     }
1487     GLASS_POOL_EXIT;
1488     GLASS_CHECK_EXCEPTION(env);
1489 
1490     return JNI_TRUE;
1491 }
1492 
1493 
1494 /*
1495  * Class:     com_sun_glass_ui_ios_IosWindow
1496  * Method:    _setIcon
1497  * Signature: (JIILjava/nio/ByteBuffer;)V
1498  */
1499 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setIcon
1500 (JNIEnv *env, jobject jwindow, jlong windowPtr, jobject pixels) {
1501     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setIcon called.&quot;);
1502     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1503     GLASS_POOL_ENTER;
1504     {
1505         // implemenation comes here
1506     }
1507     GLASS_POOL_EXIT;
1508     GLASS_CHECK_EXCEPTION(env);
1509 }
1510 
1511 
1512 /*
1513  * Class:     com_sun_glass_ui_ios_IosWindow
1514  * Method:    _toFront
1515  * Signature: (J)V
1516  */
1517 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1toFront
1518 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1519     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1toFront called.&quot;);
1520     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1521     GLASS_POOL_ENTER;
1522     {
1523         GlassWindow *window = getGlassWindow(env, windowPtr);
1524         [window orderFrontRegardless];
1525     }
1526     GLASS_POOL_EXIT;
1527     GLASS_CHECK_EXCEPTION(env);
1528 }
1529 
1530 
1531 /*
1532  * Class:     com_sun_glass_ui_ios_IosWindow
1533  * Method:    _toBack
1534  * Signature: (J)V
1535  */
1536 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1toBack
1537 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1538     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1toBack called.&quot;);
1539     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1540     GLASS_POOL_ENTER;
1541     {
1542         GlassWindow *window = getGlassWindow(env, windowPtr);
1543         [window orderBack];
1544     }
1545     GLASS_POOL_EXIT;
1546     GLASS_CHECK_EXCEPTION(env);
1547 }
1548 
1549 
1550 /*
1551  * Class:     com_sun_glass_ui_ios_IosWindow
1552  * Method:    _enterModal
1553  * Signature: (J)V
1554  */
1555 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1enterModal
1556 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1557     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1enterModal called.&quot;);
1558     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1559     GLASS_POOL_ENTER;
1560     {
1561         // implementation omes here
1562     }
1563     GLASS_POOL_EXIT;
1564     GLASS_CHECK_EXCEPTION(env);
1565 }
1566 
1567 
1568 /*
1569  * Class:     com_sun_glass_ui_ios_IosWindow
1570  * Method:    _enterModalWithWindow
1571  * Signature: (JJ)V
1572  */
1573 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1enterModalWithWindow
1574 (JNIEnv *env, jobject jwindow, jlong windowPtr, jlong window) {
1575     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1enterModalWithWindow called.&quot;);
1576     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1577     GLASS_POOL_ENTER;
1578     {
1579         // implemenation comes here
1580     }
1581     GLASS_POOL_EXIT;
1582     GLASS_CHECK_EXCEPTION(env);
1583 }
1584 
1585 
1586 /*
1587  * Class:     com_sun_glass_ui_ios_IosWindow
1588  * Method:    _exitModal
1589  * Signature: (J)V
1590  */
1591 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1exitModal
1592 (JNIEnv *env, jobject jwindow, jlong windowPtr) {
1593     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1exitModal called.&quot;);
1594     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1595     GLASS_POOL_ENTER;
1596     {
1597         // implementation comes here
1598     }
1599     GLASS_POOL_EXIT;
1600     GLASS_CHECK_EXCEPTION(env);
1601 }
1602 
1603 
1604 /*
1605  * Class:     com_sun_glass_ui_ios_IosWindow
1606  * Method:    _setEnabled
1607  * Signature: (JZ)V
1608  */
1609 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1setEnabled
1610 (JNIEnv *env, jobject jwindow, jlong windowPtr, jboolean enabled) {
1611     GLASS_LOG(&quot;Java_com_sun_glass_ui_ios_IosWindow__1setEnabled called.&quot;);
1612     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1613     GLASS_POOL_ENTER;
1614 
1615     GlassWindow *window = (GlassWindow*)jlong_to_ptr(windowPtr);
1616     [window setEnabled:(BOOL)enabled];
1617 
1618     GLASS_POOL_EXIT;
1619     GLASS_CHECK_EXCEPTION(env);
1620 }
1621 
1622 
1623 /*
1624  * Class:     com_sun_glass_ui_ios_IosWindow
1625  * Method:    _requestInput
1626  * Signature: (JLjava/lang/String;IDDDDDDDDDDDDDD)V
1627  */
1628 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1requestInput
1629 (JNIEnv *env, jobject jwin, jlong ptr, jstring text, jint type, jdouble width, jdouble height,
1630     jdouble mxx, jdouble mxy, jdouble mxz, jdouble mxt,
1631     jdouble myx, jdouble myy, jdouble myz, jdouble myt,
1632     jdouble mzx, jdouble mzy, jdouble mzz, jdouble mzt)
1633 {
<a name="2" id="anc2"></a><span class="line-modified">1634     GLASS_ASSERT_MAIN_JAVA_THREAD(env);</span>
<span class="line-modified">1635     GLASS_POOL_ENTER;</span>
<span class="line-removed">1636 </span>
<span class="line-removed">1637     GlassWindow *window = getGlassWindow(env, ptr);</span>
<span class="line-removed">1638 </span>
<span class="line-removed">1639     const char *str;</span>
<span class="line-removed">1640     str = (*env)-&gt;GetStringUTFChars(env, text, NULL);</span>
<span class="line-removed">1641     if (str == nil) {</span>
<span class="line-removed">1642         return;</span>
<span class="line-removed">1643     }</span>
<span class="line-removed">1644     NSString *nsstr = [NSString stringWithUTF8String:str];</span>
<span class="line-removed">1645     (*env)-&gt;ReleaseStringUTFChars(env, text, str);</span>
<span class="line-removed">1646 </span>
<span class="line-removed">1647     [window requestInput:nsstr type:(int)type width:(double)width height:(double)height</span>
<span class="line-removed">1648                      mxx:(double)mxx mxy:(double)mxy mxz:(double)mxz mxt:(double)mxt</span>
<span class="line-removed">1649                      myx:(double)myx myy:(double)myy myz:(double)myz myt:(double)myt</span>
<span class="line-removed">1650                      mzx:(double)mzx mzy:(double)mzy mzz:(double)mzz mzt:(double)mzt];</span>
<span class="line-removed">1651     GLASS_POOL_EXIT;</span>
<span class="line-removed">1652     GLASS_CHECK_EXCEPTION(env);</span>
1653 }
1654 
1655 
1656 /*
1657  * Class:     com_sun_glass_ui_ios_IosWindow
1658  * Method:    _releaseInput
1659  * Signature: (J)V
1660  */
1661 JNIEXPORT void JNICALL Java_com_sun_glass_ui_ios_IosWindow__1releaseInput (JNIEnv *env, jobject jwin, jlong ptr)
1662 {
1663     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1664     GLASS_POOL_ENTER;
1665 
1666     GlassWindow *window = getGlassWindow(env, ptr);
1667     [window releaseInput];
1668 
1669     GLASS_POOL_EXIT;
1670     GLASS_CHECK_EXCEPTION(env);
1671 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="skin/ButtonSkin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.controls/src/main/java/javafx/scene/control/TreeTableView.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;

  59 import java.util.LinkedHashSet;
  60 import java.util.List;
  61 import java.util.Map;
  62 import java.util.Set;
  63 import java.util.WeakHashMap;
  64 
  65 import javafx.application.Platform;
  66 import javafx.beans.DefaultProperty;
  67 import javafx.beans.InvalidationListener;
  68 import javafx.beans.WeakInvalidationListener;
  69 import javafx.beans.property.BooleanProperty;
  70 import javafx.beans.property.ObjectProperty;
  71 import javafx.beans.property.ObjectPropertyBase;
  72 import javafx.beans.property.ReadOnlyIntegerProperty;
  73 import javafx.beans.property.ReadOnlyIntegerWrapper;
  74 import javafx.beans.property.ReadOnlyObjectProperty;
  75 import javafx.beans.property.ReadOnlyObjectWrapper;
  76 import javafx.beans.property.SimpleBooleanProperty;
  77 import javafx.beans.property.SimpleObjectProperty;
  78 import javafx.beans.value.ChangeListener;
</pre>
<hr />
<pre>
1787      * @param column the column
1788      * @return the position of the given column, relative to all other
1789      * visible leaf columns
1790      */
1791     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1792         return getVisibleLeafColumns().indexOf(column);
1793     }
1794 
1795     /**
1796      * Returns the TreeTableColumn in the given column index, relative to all other
1797      * visible leaf columns.
1798      * @param column the column
1799      * @return the TreeTableColumn in the given column index, relative to all other
1800      * visible leaf columns
1801      */
1802     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1803         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1804         return visibleLeafColumns.get(column);
1805     }
1806 





1807     /**
1808      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1809      * often than not it is not necessary to call this method directly, as it is
1810      * automatically called when the {@link #getSortOrder() sort order},
1811      * {@link #sortPolicyProperty() sort policy}, or the state of the
1812      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1813      * change. In other words, this method should only be called directly when
1814      * something external changes and a sort is required.
1815      */
1816     public void sort() {

1817         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1818 
1819         // update the Comparator property
1820         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1821         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1822 
1823         // fire the onSort event and check if it is consumed, if
1824         // so, don&#39;t run the sort
1825         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1826         fireEvent(sortEvent);
1827         if (sortEvent.isConsumed()) {
1828             // if the sort is consumed we could back out the last action (the code
1829             // is commented out right below), but we don&#39;t as we take it as a
1830             // sign that the developer has decided to handle the event themselves.
1831 
1832             // sortLock = true;
1833             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1834             // sortLock = false;

1835             return;
1836         }
1837 
1838         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1839         final int itemCount = prevState.size();
1840 
1841         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1842         // sort events - instead we send a single permutation event at the end
1843         // of this method.
1844         getSelectionModel().startAtomic();
1845 
1846         // get the sort policy and run it
1847         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
<span class="line-modified">1848         if (sortPolicy == null) return;</span>



1849         Boolean success = sortPolicy.call(this);
1850 















1851         getSelectionModel().stopAtomic();
1852 
1853         if (success == null || ! success) {
1854             // the sort was a failure. Need to backout if possible
1855             sortLock = true;
1856             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1857             setComparator(oldComparator);
1858             sortLock = false;
1859         } else {
1860             // sorting was a success, now we possibly fire an event on the
1861             // selection model that the items list has &#39;permutated&#39; to a new ordering
1862 
1863             // FIXME we should support alternative selection model implementations!
1864             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1865                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1866                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1867 
1868                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1869                 for (int i = 0; i &lt; itemCount; i++) {
1870                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1871                     if (!newState.contains(prevItem)) {
1872                         removed.add(prevItem);
1873                     }
1874                 }
<span class="line-removed">1875 </span>
1876                 if (!removed.isEmpty()) {
1877                     // the sort operation effectively permutates the selectedCells list,
1878                     // but we cannot fire a permutation event as we are talking about
1879                     // TreeTablePosition&#39;s changing (which may reside in the same list
1880                     // position before and after the sort). Therefore, we need to fire
1881                     // a single add/remove event to cover the added and removed positions.
1882                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1883                     sm.fireCustomSelectedCellsListChangeEvent(c);
1884                 }
1885             }


1886         }

1887     }
1888 
1889     /**
1890      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1891      * repopulate the cells necessary to populate the visual bounds of the control.
1892      * In other words, this forces the TreeTableView to update what it is showing to
1893      * the user. This is useful in cases where the underlying data source has
1894      * changed in a way that is not observed by the TreeTableView itself.
1895      *
1896      * @since JavaFX 8u60
1897      */
1898     public void refresh() {
1899         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1900     }
1901 
1902 
1903 
1904     /***************************************************************************
1905      *                                                                         *
1906      * Private Implementation                                                  *
</pre>
<hr />
<pre>
2523 
2524                         ControlUtils.reducingChange(selectedIndices, removed);
2525 
2526                         for (int index : removed) {
2527                             startAtomic();
2528                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2529                             // and results in JDK-8152396
2530                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2531                             stopAtomic();
2532                         }
2533                         selectedIndices._endChange();
2534 
2535                         // put selection onto the newly-collapsed tree item
2536                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2537                             select(startRow, selectedColumn);
2538                         }
2539 
2540                         shift += -count + 1;
2541                         startRow++;
2542                     } else if (e.wasPermutated()) {
<span class="line-modified">2543                         // General approach:</span>
<span class="line-modified">2544                         //   -- detected a sort has happened</span>
<span class="line-modified">2545                         //   -- Create a permutation lookup map (1)</span>
<span class="line-modified">2546                         //   -- dump all the selected indices into a list (2)</span>
<span class="line-modified">2547                         //   -- create a list containing the new indices (3)</span>
<span class="line-modified">2548                         //   -- for each previously-selected index (4)</span>
<span class="line-modified">2549                         //     -- if index is in the permutation lookup map</span>
<span class="line-modified">2550                         //       -- add the new index to the new indices list</span>
<span class="line-modified">2551                         //   -- Perform batch selection (5)</span>
<span class="line-modified">2552 </span>
<span class="line-modified">2553                         startAtomic();</span>
<span class="line-removed">2554 </span>
<span class="line-removed">2555                         final int offset = startRow + 1;</span>
<span class="line-removed">2556 </span>
<span class="line-removed">2557                         // (1)</span>
<span class="line-removed">2558                         int length = e.getTo() - e.getFrom();</span>
<span class="line-removed">2559                         HashMap&lt;Integer, Integer&gt; pMap = new HashMap&lt;&gt; (length);</span>
<span class="line-removed">2560                         for (int i = e.getFrom(); i &lt; e.getTo(); i++) {</span>
<span class="line-removed">2561                             pMap.put(i, e.getChange().getPermutation(i));</span>
<span class="line-removed">2562                         }</span>
<span class="line-removed">2563 </span>
<span class="line-removed">2564                         // (2)</span>
<span class="line-removed">2565                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedIndices = new ArrayList&lt;&gt;(getSelectedCells());</span>
2566 
<span class="line-removed">2567                         // (3)</span>
<span class="line-removed">2568                         List&lt;TreeTablePosition&lt;S,?&gt;&gt; newIndices = new ArrayList&lt;&gt;(selectedIndices.size());</span>
<span class="line-removed">2569 </span>
<span class="line-removed">2570                         // (4)</span>
2571                         boolean selectionIndicesChanged = false;
<span class="line-modified">2572                         for (int i = 0; i &lt; selectedIndices.size(); i++) {</span>
<span class="line-modified">2573                             final TreeTablePosition&lt;S,?&gt; oldIndex = selectedIndices.get(i);</span>
<span class="line-modified">2574                             final int oldRow = oldIndex.getRow() - offset;</span>
<span class="line-modified">2575 </span>
<span class="line-removed">2576                             if (pMap.containsKey(oldRow)) {</span>
<span class="line-removed">2577                                 int newIndex = pMap.get(oldRow) + offset;</span>
<span class="line-removed">2578 </span>
<span class="line-removed">2579                                 selectionIndicesChanged = selectionIndicesChanged || newIndex != oldRow;</span>
<span class="line-removed">2580 </span>
<span class="line-removed">2581                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), newIndex, oldIndex.getTableColumn()));</span>
<span class="line-removed">2582                             }</span>
<span class="line-removed">2583 </span>
<span class="line-removed">2584                             // check if the root element of this event was selected, so that we can retain it</span>
<span class="line-removed">2585                             if (oldIndex.getRow() == startRow) {</span>
<span class="line-removed">2586                                 newIndices.add(new TreeTablePosition&lt;&gt;(oldIndex.getTreeTableView(), oldIndex.getRow(), oldIndex.getTableColumn()));</span>
2587                             }

2588                         }
<span class="line-removed">2589 </span>
2590                         if (selectionIndicesChanged) {
<span class="line-modified">2591                             // (5)</span>
<span class="line-modified">2592                             quietClearSelection();</span>
<span class="line-modified">2593                             stopAtomic();</span>
<span class="line-modified">2594 </span>
<span class="line-modified">2595                             selectedCellsMap.setAll(newIndices);</span>
<span class="line-modified">2596 </span>
<span class="line-modified">2597                             final int offsetOldIndex = oldSelectedIndex - offset;</span>
<span class="line-modified">2598                             if (offsetOldIndex &gt;= 0 &amp;&amp; offsetOldIndex &lt; getItemCount()) {</span>
<span class="line-modified">2599                                 int newIndex = e.getChange().getPermutation(offsetOldIndex);</span>
<span class="line-modified">2600                                 setSelectedIndex(newIndex + offset);</span>
<span class="line-modified">2601                                 focus(newIndex + offset);</span>

2602                             }
<span class="line-removed">2603                         } else {</span>
<span class="line-removed">2604                             stopAtomic();</span>
2605                         }
2606                     } else if (e.wasAdded()) {
2607                         // shuffle selection by the number of added items
2608                         shift += treeItem.isExpanded() ? addedSize : 0;
2609 
2610                         // RT-32963: We were taking the startRow from the TreeItem
2611                         // in which the children were added, rather than from the
2612                         // actual position of the new child. This led to selection
2613                         // being moved off the parent TreeItem by mistake.
2614                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2615                         // subsequently commented out due to RT-33894.
2616                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2617 
2618                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2619                         if (anchor != null) {
2620                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2621                             if (isAnchorSelected) {
2622                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2623                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2624                             }
</pre>
<hr />
<pre>
2646                             int index = selectedIndices.get(i);
2647                             if (index &gt; selectedItems.size()) break;
2648 
2649                             if (removedChildren.size() == 1 &amp;&amp;
2650                                     selectedItems.size() == 1 &amp;&amp;
2651                                     selectedItem != null &amp;&amp;
2652                                     selectedItem.equals(removedChildren.get(0))) {
2653                                 // Bug fix for RT-28637
2654                                 if (oldSelectedIndex &lt; getItemCount()) {
2655                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2656                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2657                                     if (!selectedItem.equals(newSelectedItem)) {
2658                                         clearAndSelect(previousRow);
2659                                     }
2660                                 }
2661                             }
2662                         }
2663                     }
2664                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2665 
<span class="line-modified">2666                 shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2667                     @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2668 </span>
<span class="line-modified">2669                         // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2670                         // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2671                         // noise. They eventually get the summary event fired</span>
<span class="line-modified">2672                         // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2673                         startAtomic();</span>
<span class="line-modified">2674 </span>
<span class="line-modified">2675                         final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2676                         final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2677                         TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2678                         if (clearIndex &gt; -1) {</span>
<span class="line-modified">2679                             for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2680                                 TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2681                                 if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2682                                     oldTP = tp;</span>
<span class="line-modified">2683                                     selectedCellsMap.remove(tp);</span>
<span class="line-modified">2684                                 } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-modified">2685                                     selectedCellsMap.remove(tp);</span>


2686                                 }
2687                             }
<span class="line-removed">2688                         }</span>
2689 
<span class="line-modified">2690                         if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2691                             TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2692                                     treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2693 
<span class="line-modified">2694                             selectedCellsMap.add(newTP);</span>
<span class="line-modified">2695                         }</span>
2696 
<span class="line-modified">2697                         stopAtomic();</span>
2698 
<span class="line-modified">2699                         return null;</span>
<span class="line-modified">2700                     }</span>
<span class="line-modified">2701                 });</span>

2702             }
2703         };
2704 
2705         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2706                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2707 
2708         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2709 
2710 
2711 
2712         /***********************************************************************
2713          *                                                                     *
2714          * Observable properties (and getters/setters)                         *
2715          *                                                                     *
2716          **********************************************************************/
2717 
2718         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2719         // are both &#39;read-only and unbacked&#39;.
2720         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2721 
</pre>
</td>
<td>
<hr />
<pre>
  39 import javafx.css.PseudoClass;
  40 
  41 import javafx.css.converter.SizeConverter;
  42 import com.sun.javafx.scene.control.ReadOnlyUnbackedObservableList;
  43 import com.sun.javafx.scene.control.TableColumnComparatorBase;
  44 
  45 import javafx.css.Styleable;
  46 import javafx.css.StyleableDoubleProperty;
  47 import javafx.css.StyleableProperty;
  48 import javafx.event.WeakEventHandler;
  49 
  50 import javafx.scene.control.skin.TreeTableViewSkin;
  51 
  52 import java.lang.ref.SoftReference;
  53 import java.lang.ref.WeakReference;
  54 import java.util.ArrayList;
  55 import java.util.Collection;
  56 import java.util.Collections;
  57 import java.util.Comparator;
  58 import java.util.HashMap;
<span class="line-added">  59 import java.util.HashSet;</span>
  60 import java.util.LinkedHashSet;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Set;
  64 import java.util.WeakHashMap;
  65 
  66 import javafx.application.Platform;
  67 import javafx.beans.DefaultProperty;
  68 import javafx.beans.InvalidationListener;
  69 import javafx.beans.WeakInvalidationListener;
  70 import javafx.beans.property.BooleanProperty;
  71 import javafx.beans.property.ObjectProperty;
  72 import javafx.beans.property.ObjectPropertyBase;
  73 import javafx.beans.property.ReadOnlyIntegerProperty;
  74 import javafx.beans.property.ReadOnlyIntegerWrapper;
  75 import javafx.beans.property.ReadOnlyObjectProperty;
  76 import javafx.beans.property.ReadOnlyObjectWrapper;
  77 import javafx.beans.property.SimpleBooleanProperty;
  78 import javafx.beans.property.SimpleObjectProperty;
  79 import javafx.beans.value.ChangeListener;
</pre>
<hr />
<pre>
1788      * @param column the column
1789      * @return the position of the given column, relative to all other
1790      * visible leaf columns
1791      */
1792     public int getVisibleLeafIndex(TreeTableColumn&lt;S,?&gt; column) {
1793         return getVisibleLeafColumns().indexOf(column);
1794     }
1795 
1796     /**
1797      * Returns the TreeTableColumn in the given column index, relative to all other
1798      * visible leaf columns.
1799      * @param column the column
1800      * @return the TreeTableColumn in the given column index, relative to all other
1801      * visible leaf columns
1802      */
1803     public TreeTableColumn&lt;S,?&gt; getVisibleLeafColumn(int column) {
1804         if (column &lt; 0 || column &gt;= visibleLeafColumns.size()) return null;
1805         return visibleLeafColumns.get(column);
1806     }
1807 
<span class="line-added">1808     private boolean sortingInProgress;</span>
<span class="line-added">1809     boolean isSortingInProgress() {</span>
<span class="line-added">1810         return sortingInProgress;</span>
<span class="line-added">1811     }</span>
<span class="line-added">1812 </span>
1813     /**
1814      * The sort method forces the TreeTableView to re-run its sorting algorithm. More
1815      * often than not it is not necessary to call this method directly, as it is
1816      * automatically called when the {@link #getSortOrder() sort order},
1817      * {@link #sortPolicyProperty() sort policy}, or the state of the
1818      * TreeTableColumn {@link TreeTableColumn#sortTypeProperty() sort type} properties
1819      * change. In other words, this method should only be called directly when
1820      * something external changes and a sort is required.
1821      */
1822     public void sort() {
<span class="line-added">1823         sortingInProgress = true;</span>
1824         final ObservableList&lt;TreeTableColumn&lt;S,?&gt;&gt; sortOrder = getSortOrder();
1825 
1826         // update the Comparator property
1827         final Comparator&lt;TreeItem&lt;S&gt;&gt; oldComparator = getComparator();
1828         setComparator(sortOrder.isEmpty() ? null : new TableColumnComparatorBase.TreeTableColumnComparator(sortOrder));
1829 
1830         // fire the onSort event and check if it is consumed, if
1831         // so, don&#39;t run the sort
1832         SortEvent&lt;TreeTableView&lt;S&gt;&gt; sortEvent = new SortEvent&lt;&gt;(TreeTableView.this, TreeTableView.this);
1833         fireEvent(sortEvent);
1834         if (sortEvent.isConsumed()) {
1835             // if the sort is consumed we could back out the last action (the code
1836             // is commented out right below), but we don&#39;t as we take it as a
1837             // sign that the developer has decided to handle the event themselves.
1838 
1839             // sortLock = true;
1840             // TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1841             // sortLock = false;
<span class="line-added">1842             sortingInProgress = false;</span>
1843             return;
1844         }
1845 
1846         final List&lt;TreeTablePosition&lt;S,?&gt;&gt; prevState = new ArrayList&lt;&gt;(getSelectionModel().getSelectedCells());
1847         final int itemCount = prevState.size();
1848 
1849         // we set makeAtomic to true here, so that we don&#39;t fire intermediate
1850         // sort events - instead we send a single permutation event at the end
1851         // of this method.
1852         getSelectionModel().startAtomic();
1853 
1854         // get the sort policy and run it
1855         Callback&lt;TreeTableView&lt;S&gt;, Boolean&gt; sortPolicy = getSortPolicy();
<span class="line-modified">1856         if (sortPolicy == null) {</span>
<span class="line-added">1857             sortingInProgress = false;</span>
<span class="line-added">1858             return;</span>
<span class="line-added">1859         }</span>
1860         Boolean success = sortPolicy.call(this);
1861 
<span class="line-added">1862         if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {</span>
<span class="line-added">1863             Set&lt;TreeItem&lt;S&gt;&gt; sortedParents = new HashSet&lt;&gt;();</span>
<span class="line-added">1864             for (TreeTablePosition&lt;S,?&gt; selectedPosition : prevState) {</span>
<span class="line-added">1865                 // This null check is not required ideally.</span>
<span class="line-added">1866                 // The selectedPosition.getTreeItem() should always return a valid TreeItem.</span>
<span class="line-added">1867                 // But, it is possible to be null due to JDK-8248217.</span>
<span class="line-added">1868                 if (selectedPosition.getTreeItem() != null) {</span>
<span class="line-added">1869                     TreeItem&lt;S&gt; parent = selectedPosition.getTreeItem().getParent();</span>
<span class="line-added">1870                     while (parent != null &amp;&amp; sortedParents.add(parent)) {</span>
<span class="line-added">1871                         parent.getChildren();</span>
<span class="line-added">1872                         parent = parent.getParent();</span>
<span class="line-added">1873                     }</span>
<span class="line-added">1874                 }</span>
<span class="line-added">1875             }</span>
<span class="line-added">1876         }</span>
1877         getSelectionModel().stopAtomic();
1878 
1879         if (success == null || ! success) {
1880             // the sort was a failure. Need to backout if possible
1881             sortLock = true;
1882             TableUtil.handleSortFailure(sortOrder, lastSortEventType, lastSortEventSupportInfo);
1883             setComparator(oldComparator);
1884             sortLock = false;
1885         } else {
1886             // sorting was a success, now we possibly fire an event on the
1887             // selection model that the items list has &#39;permutated&#39; to a new ordering
1888 
1889             // FIXME we should support alternative selection model implementations!
1890             if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {
1891                 final TreeTableViewArrayListSelectionModel&lt;S&gt; sm = (TreeTableViewArrayListSelectionModel&lt;S&gt;) getSelectionModel();
1892                 final ObservableList&lt;TreeTablePosition&lt;S, ?&gt;&gt; newState = sm.getSelectedCells();
1893 
1894                 List&lt;TreeTablePosition&lt;S, ?&gt;&gt; removed = new ArrayList&lt;&gt;();
1895                 for (int i = 0; i &lt; itemCount; i++) {
1896                     TreeTablePosition&lt;S, ?&gt; prevItem = prevState.get(i);
1897                     if (!newState.contains(prevItem)) {
1898                         removed.add(prevItem);
1899                     }
1900                 }

1901                 if (!removed.isEmpty()) {
1902                     // the sort operation effectively permutates the selectedCells list,
1903                     // but we cannot fire a permutation event as we are talking about
1904                     // TreeTablePosition&#39;s changing (which may reside in the same list
1905                     // position before and after the sort). Therefore, we need to fire
1906                     // a single add/remove event to cover the added and removed positions.
1907                     ListChangeListener.Change&lt;TreeTablePosition&lt;S, ?&gt;&gt; c = new NonIterableChange.GenericAddRemoveChange&lt;&gt;(0, itemCount, removed, newState);
1908                     sm.fireCustomSelectedCellsListChangeEvent(c);
1909                 }
1910             }
<span class="line-added">1911             getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));</span>
<span class="line-added">1912             getFocusModel().focus(getSelectionModel().getSelectedIndex());</span>
1913         }
<span class="line-added">1914         sortingInProgress = false;</span>
1915     }
1916 
1917     /**
1918      * Calling {@code refresh()} forces the TreeTableView control to recreate and
1919      * repopulate the cells necessary to populate the visual bounds of the control.
1920      * In other words, this forces the TreeTableView to update what it is showing to
1921      * the user. This is useful in cases where the underlying data source has
1922      * changed in a way that is not observed by the TreeTableView itself.
1923      *
1924      * @since JavaFX 8u60
1925      */
1926     public void refresh() {
1927         getProperties().put(Properties.RECREATE, Boolean.TRUE);
1928     }
1929 
1930 
1931 
1932     /***************************************************************************
1933      *                                                                         *
1934      * Private Implementation                                                  *
</pre>
<hr />
<pre>
2551 
2552                         ControlUtils.reducingChange(selectedIndices, removed);
2553 
2554                         for (int index : removed) {
2555                             startAtomic();
2556                             // we pass in false here to prevent a lookup into the TreeItem, as it is unnecessary
2557                             // and results in JDK-8152396
2558                             clearSelection(new TreeTablePosition&lt;&gt;(treeTableView, index, null, false));
2559                             stopAtomic();
2560                         }
2561                         selectedIndices._endChange();
2562 
2563                         // put selection onto the newly-collapsed tree item
2564                         if (wasPrimarySelectionInChild &amp;&amp; wasAnyChildSelected) {
2565                             select(startRow, selectedColumn);
2566                         }
2567 
2568                         shift += -count + 1;
2569                         startRow++;
2570                     } else if (e.wasPermutated()) {
<span class="line-modified">2571                         // Approach:</span>
<span class="line-modified">2572                         // Get the current selection.</span>
<span class="line-modified">2573                         // Create a new selection with updated index(row).</span>
<span class="line-modified">2574                         // Update the current selection with new selection.</span>
<span class="line-modified">2575                         // If sorting is in progress then one Selection change event will be sent from</span>
<span class="line-modified">2576                         // TreeTableView.sort() method, and should not be sent from here.</span>
<span class="line-modified">2577                         // else, in case otherwise, the selection change events would be generated.</span>
<span class="line-modified">2578                         // Do not call shiftSelection() in case of permutation change(when shift == 0).</span>
<span class="line-modified">2579 </span>
<span class="line-modified">2580                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; currentSelection = new ArrayList&lt;&gt;(selectedCellsMap.getSelectedCells());</span>
<span class="line-modified">2581                         List&lt;TreeTablePosition&lt;S, ?&gt;&gt; updatedSelection = new ArrayList&lt;&gt;();</span>












2582 




2583                         boolean selectionIndicesChanged = false;
<span class="line-modified">2584                         for (TreeTablePosition&lt;S, ?&gt; selectedCell : currentSelection) {</span>
<span class="line-modified">2585                             int newRow = treeTableView.getRow(selectedCell.getTreeItem());</span>
<span class="line-modified">2586                             if (selectedCell.getRow() != newRow) {</span>
<span class="line-modified">2587                                 selectionIndicesChanged = true;</span>











2588                             }
<span class="line-added">2589                             updatedSelection.add(new TreeTablePosition&lt;&gt;(selectedCell, newRow));</span>
2590                         }

2591                         if (selectionIndicesChanged) {
<span class="line-modified">2592                             if (treeTableView.isSortingInProgress()) {</span>
<span class="line-modified">2593                                 startAtomic();</span>
<span class="line-modified">2594                                 selectedCellsMap.setAll(updatedSelection);</span>
<span class="line-modified">2595                                 stopAtomic();</span>
<span class="line-modified">2596                             } else {</span>
<span class="line-modified">2597                                 startAtomic();</span>
<span class="line-modified">2598                                 quietClearSelection();</span>
<span class="line-modified">2599                                 stopAtomic();</span>
<span class="line-modified">2600                                 selectedCellsMap.setAll(updatedSelection);</span>
<span class="line-modified">2601                                 int selectedIndex = treeTableView.getRow(getSelectedItem());</span>
<span class="line-modified">2602                                 setSelectedIndex(selectedIndex);</span>
<span class="line-added">2603                                 focus(selectedIndex);</span>
2604                             }


2605                         }
2606                     } else if (e.wasAdded()) {
2607                         // shuffle selection by the number of added items
2608                         shift += treeItem.isExpanded() ? addedSize : 0;
2609 
2610                         // RT-32963: We were taking the startRow from the TreeItem
2611                         // in which the children were added, rather than from the
2612                         // actual position of the new child. This led to selection
2613                         // being moved off the parent TreeItem by mistake.
2614                         // The &#39;if (e.getAddedSize() == 1)&#39; condition here was
2615                         // subsequently commented out due to RT-33894.
2616                         startRow = treeTableView.getRow(e.getChange().getAddedSubList().get(0));
2617 
2618                         TreeTablePosition&lt;S, ?&gt; anchor = TreeTableCellBehavior.getAnchor(treeTableView, null);
2619                         if (anchor != null) {
2620                             boolean isAnchorSelected = isSelected(anchor.getRow(), anchor.getTableColumn());
2621                             if (isAnchorSelected) {
2622                                 TreeTablePosition&lt;S, ?&gt; newAnchor = new TreeTablePosition&lt;&gt;(treeTableView, anchor.getRow() + shift, anchor.getTableColumn());
2623                                 TreeTableCellBehavior.setAnchor(treeTableView, newAnchor, false);
2624                             }
</pre>
<hr />
<pre>
2646                             int index = selectedIndices.get(i);
2647                             if (index &gt; selectedItems.size()) break;
2648 
2649                             if (removedChildren.size() == 1 &amp;&amp;
2650                                     selectedItems.size() == 1 &amp;&amp;
2651                                     selectedItem != null &amp;&amp;
2652                                     selectedItem.equals(removedChildren.get(0))) {
2653                                 // Bug fix for RT-28637
2654                                 if (oldSelectedIndex &lt; getItemCount()) {
2655                                     final int previousRow = oldSelectedIndex == 0 ? 0 : oldSelectedIndex - 1;
2656                                     TreeItem&lt;S&gt; newSelectedItem = getModelItem(previousRow);
2657                                     if (!selectedItem.equals(newSelectedItem)) {
2658                                         clearAndSelect(previousRow);
2659                                     }
2660                                 }
2661                             }
2662                         }
2663                     }
2664                 } while (e.getChange() != null &amp;&amp; e.getChange().next());
2665 
<span class="line-modified">2666                 if (shift != 0) {</span>
<span class="line-modified">2667                     shiftSelection(startRow, shift, new Callback&lt;ShiftParams, Void&gt;() {</span>
<span class="line-modified">2668                         @Override public Void call(ShiftParams param) {</span>
<span class="line-modified">2669 </span>
<span class="line-modified">2670                             // we make the shifts atomic, as otherwise listeners to</span>
<span class="line-modified">2671                             // the items / indices lists get a lot of intermediate</span>
<span class="line-modified">2672                             // noise. They eventually get the summary event fired</span>
<span class="line-modified">2673                             // from within shiftSelection, so this is ok.</span>
<span class="line-modified">2674                             startAtomic();</span>
<span class="line-modified">2675 </span>
<span class="line-modified">2676                             final int clearIndex = param.getClearIndex();</span>
<span class="line-modified">2677                             final int setIndex = param.getSetIndex();</span>
<span class="line-modified">2678                             TreeTablePosition&lt;S,?&gt; oldTP = null;</span>
<span class="line-modified">2679                             if (clearIndex &gt; -1) {</span>
<span class="line-modified">2680                                 for (int i = 0; i &lt; selectedCellsMap.size(); i++) {</span>
<span class="line-modified">2681                                     TreeTablePosition&lt;S,?&gt; tp = selectedCellsMap.get(i);</span>
<span class="line-modified">2682                                     if (tp.getRow() == clearIndex) {</span>
<span class="line-modified">2683                                         oldTP = tp;</span>
<span class="line-modified">2684                                         selectedCellsMap.remove(tp);</span>
<span class="line-modified">2685                                     } else if (tp.getRow() == setIndex &amp;&amp; !param.isSelected()) {</span>
<span class="line-added">2686                                         selectedCellsMap.remove(tp);</span>
<span class="line-added">2687                                     }</span>
2688                                 }
2689                             }

2690 
<span class="line-modified">2691                             if (oldTP != null &amp;&amp; param.isSelected()) {</span>
<span class="line-modified">2692                                 TreeTablePosition&lt;S,?&gt; newTP = new TreeTablePosition&lt;&gt;(</span>
<span class="line-modified">2693                                         treeTableView, param.getSetIndex(), oldTP.getTableColumn());</span>
2694 
<span class="line-modified">2695                                 selectedCellsMap.add(newTP);</span>
<span class="line-modified">2696                             }</span>
2697 
<span class="line-modified">2698                             stopAtomic();</span>
2699 
<span class="line-modified">2700                             return null;</span>
<span class="line-modified">2701                         }</span>
<span class="line-modified">2702                     });</span>
<span class="line-added">2703                 }</span>
2704             }
2705         };
2706 
2707         private WeakChangeListener&lt;TreeItem&lt;S&gt;&gt; weakRootPropertyListener =
2708                 new WeakChangeListener&lt;&gt;(rootPropertyListener);
2709 
2710         private WeakEventHandler&lt;TreeItem.TreeModificationEvent&lt;S&gt;&gt; weakTreeItemListener;
2711 
2712 
2713 
2714         /***********************************************************************
2715          *                                                                     *
2716          * Observable properties (and getters/setters)                         *
2717          *                                                                     *
2718          **********************************************************************/
2719 
2720         // the only &#39;proper&#39; internal data structure, selectedItems and selectedIndices
2721         // are both &#39;read-only and unbacked&#39;.
2722         private final SelectedCellsMap&lt;TreeTablePosition&lt;S,?&gt;&gt; selectedCellsMap;
2723 
</pre>
</td>
</tr>
</table>
<center><a href="TreeTablePosition.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="skin/ButtonSkin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
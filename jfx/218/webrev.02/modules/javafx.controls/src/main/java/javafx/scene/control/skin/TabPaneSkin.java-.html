<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.controls/src/main/java/javafx/scene/control/skin/TabPaneSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.scene.control.skin;
  27 
  28 import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;
  29 import com.sun.javafx.scene.control.Properties;
  30 import com.sun.javafx.scene.control.TabObservableList;
  31 import com.sun.javafx.util.Utils;
  32 import javafx.animation.Animation;
  33 import javafx.animation.Interpolator;
  34 import javafx.animation.KeyFrame;
  35 import javafx.animation.KeyValue;
  36 import javafx.animation.Timeline;
  37 import javafx.animation.Transition;
  38 import javafx.beans.InvalidationListener;
  39 import javafx.beans.Observable;
  40 import javafx.beans.WeakInvalidationListener;
  41 import javafx.beans.property.DoubleProperty;
  42 import javafx.beans.property.ObjectProperty;
  43 import javafx.beans.property.SimpleDoubleProperty;
  44 import javafx.beans.value.WritableValue;
  45 import javafx.collections.FXCollections;
  46 import javafx.collections.ListChangeListener;
  47 import javafx.collections.ObservableList;
  48 import javafx.collections.WeakListChangeListener;
  49 import javafx.css.CssMetaData;
  50 import javafx.css.PseudoClass;
  51 import javafx.css.Styleable;
  52 import javafx.css.StyleableObjectProperty;
  53 import javafx.css.StyleableProperty;
  54 import javafx.event.ActionEvent;
  55 import javafx.event.EventHandler;
  56 import javafx.geometry.Bounds;
  57 import javafx.geometry.HPos;
  58 import javafx.geometry.NodeOrientation;
  59 import javafx.geometry.Point2D;
  60 import javafx.geometry.Pos;
  61 import javafx.geometry.Side;
  62 import javafx.geometry.VPos;
  63 import javafx.scene.AccessibleAction;
  64 import javafx.scene.AccessibleAttribute;
  65 import javafx.scene.AccessibleRole;
  66 import javafx.scene.Node;
  67 import javafx.scene.control.ContextMenu;
  68 import javafx.scene.control.Control;
  69 import javafx.scene.control.Label;
  70 import javafx.scene.control.MenuItem;
  71 import javafx.scene.control.RadioMenuItem;
  72 import javafx.scene.control.SelectionModel;
  73 import javafx.scene.control.SkinBase;
  74 import javafx.scene.control.Tab;
  75 import javafx.scene.control.TabPane;
  76 import javafx.scene.control.TabPane.TabClosingPolicy;
  77 import javafx.scene.control.TabPane.TabDragPolicy;
  78 import javafx.scene.control.ToggleGroup;
  79 import javafx.scene.control.Tooltip;
  80 import javafx.scene.effect.DropShadow;
  81 import javafx.scene.image.ImageView;
  82 import javafx.scene.input.ContextMenuEvent;
  83 import javafx.scene.input.MouseButton;
  84 import javafx.scene.input.MouseEvent;
  85 import javafx.scene.input.ScrollEvent;
  86 import javafx.scene.input.SwipeEvent;
  87 import javafx.scene.layout.Pane;
  88 import javafx.scene.layout.Region;
  89 import javafx.scene.layout.StackPane;
  90 import javafx.scene.shape.Rectangle;
  91 import javafx.scene.transform.Rotate;
  92 import javafx.util.Duration;
  93 import javafx.util.Pair;
  94 
  95 import java.util.ArrayList;
  96 import java.util.Collections;
  97 import java.util.Iterator;
  98 import java.util.List;
  99 
 100 import javafx.css.converter.EnumConverter;
 101 import com.sun.javafx.scene.control.behavior.TabPaneBehavior;
 102 
 103 import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;
 104 
 105 /**
 106  * Default skin implementation for the {@link TabPane} control.
 107  *
 108  * @see TabPane
 109  * @since 9
 110  */
 111 public class TabPaneSkin extends SkinBase&lt;TabPane&gt; {
 112 
 113     /***************************************************************************
 114      *                                                                         *
 115      * Enums                                                                   *
 116      *                                                                         *
 117      **************************************************************************/
 118 
 119     private enum TabAnimation {
 120         NONE,
 121         GROW
 122         // In future we could add FADE, ...
 123     }
 124 
 125     private enum TabAnimationState {
 126         SHOWING, HIDING, NONE;
 127     }
 128 
 129 
 130 
 131     /***************************************************************************
 132      *                                                                         *
 133      * Static fields                                                           *
 134      *                                                                         *
 135      **************************************************************************/
 136 
 137     static int CLOSE_BTN_SIZE = 16;
 138 
 139 
 140 
 141     /***************************************************************************
 142      *                                                                         *
 143      * Private fields                                                          *
 144      *                                                                         *
 145      **************************************************************************/
 146 
 147     private static final double ANIMATION_SPEED = 150;
 148     private static final int SPACER = 10;
 149 
 150     private TabHeaderArea tabHeaderArea;
 151     private ObservableList&lt;TabContentRegion&gt; tabContentRegions;
 152     private Rectangle clipRect;
 153     private Rectangle tabHeaderAreaClipRect;
 154     private Tab selectedTab;
 155     private boolean isSelectingTab;
 156 
 157     private final TabPaneBehavior behavior;
 158 
 159 
 160 
 161     /***************************************************************************
 162      *                                                                         *
 163      * Constructors                                                            *
 164      *                                                                         *
 165      **************************************************************************/
 166 
 167     /**
 168      * Creates a new TabPaneSkin instance, installing the necessary child
 169      * nodes into the Control {@link Control#getChildren() children} list, as
 170      * well as the necessary input mappings for handling key, mouse, etc events.
 171      *
 172      * @param control The control that this skin should be installed onto.
 173      */
 174     public TabPaneSkin(TabPane control) {
 175         super(control);
 176 
 177         // install default input map for the TabPane control
 178         this.behavior = new TabPaneBehavior(control);
 179 //        control.setInputMap(behavior.getInputMap());
 180 
 181         clipRect = new Rectangle(control.getWidth(), control.getHeight());
 182         getSkinnable().setClip(clipRect);
 183 
 184         tabContentRegions = FXCollections.&lt;TabContentRegion&gt;observableArrayList();
 185 
 186         for (Tab tab : getSkinnable().getTabs()) {
 187             addTabContent(tab);
 188         }
 189 
 190         tabHeaderAreaClipRect = new Rectangle();
 191         tabHeaderArea = new TabHeaderArea();
 192         tabHeaderArea.setClip(tabHeaderAreaClipRect);
 193         getChildren().add(tabHeaderArea);
 194         if (getSkinnable().getTabs().size() == 0) {
 195             tabHeaderArea.setVisible(false);
 196         }
 197 
 198         initializeTabListener();
 199         updateSelectionModel();
 200 
 201         registerChangeListener(control.selectionModelProperty(), e -&gt; updateSelectionModel());
 202         registerChangeListener(control.sideProperty(), e -&gt; updateTabPosition());
 203         registerChangeListener(control.widthProperty(), e -&gt; clipRect.setWidth(getSkinnable().getWidth()));
 204         registerChangeListener(control.heightProperty(), e -&gt; clipRect.setHeight(getSkinnable().getHeight()));
 205 
 206         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 207         // Could not find the selected tab try and get the selected tab using the selected index
 208         if (selectedTab == null &amp;&amp; getSkinnable().getSelectionModel().getSelectedIndex() != -1) {
 209             getSkinnable().getSelectionModel().select(getSkinnable().getSelectionModel().getSelectedIndex());
 210             selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 211         }
 212         if (selectedTab == null) {
 213             // getSelectedItem and getSelectedIndex failed select the first.
 214             getSkinnable().getSelectionModel().selectFirst();
 215         }
 216         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 217         isSelectingTab = false;
 218 
 219         initializeSwipeHandlers();
 220     }
 221 
 222 
 223 
 224     /***************************************************************************
 225      *                                                                         *
 226      * Properties                                                              *
 227      *                                                                         *
 228      **************************************************************************/
 229 
 230     private ObjectProperty&lt;TabAnimation&gt; openTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
 231         @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
 232             return StyleableProperties.OPEN_TAB_ANIMATION;
 233         }
 234 
 235         @Override public Object getBean() {
 236             return TabPaneSkin.this;
 237         }
 238 
 239         @Override public String getName() {
 240             return &quot;openTabAnimation&quot;;
 241         }
 242     };
 243 
 244     private ObjectProperty&lt;TabAnimation&gt; closeTabAnimation = new StyleableObjectProperty&lt;TabAnimation&gt;(TabAnimation.GROW) {
 245         @Override public CssMetaData&lt;TabPane,TabAnimation&gt; getCssMetaData() {
 246             return StyleableProperties.CLOSE_TAB_ANIMATION;
 247         }
 248 
 249         @Override public Object getBean() {
 250             return TabPaneSkin.this;
 251         }
 252 
 253         @Override public String getName() {
 254             return &quot;closeTabAnimation&quot;;
 255         }
 256     };
 257 
 258     /***************************************************************************
 259      *                                                                         *
 260      * Public API                                                              *
 261      *                                                                         *
 262      **************************************************************************/
 263 
 264     /** {@inheritDoc} */
 265     @Override public void dispose() {
 266         if (selectionModel != null) {
 267             selectionModel.selectedItemProperty().removeListener(weakSelectionChangeListener);
 268             selectionModel = null;
 269         }
 270 
 271         super.dispose();
 272 
 273         if (behavior != null) {
 274             behavior.dispose();
 275         }
 276     }
 277 
 278     /** {@inheritDoc} */
 279     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
 280         // The TabPane can only be as wide as it widest content width.
 281         double maxw = 0.0;
 282         for (TabContentRegion contentRegion: tabContentRegions) {
 283             maxw = Math.max(maxw, snapSizeX(contentRegion.prefWidth(-1)));
 284         }
 285 
 286         final boolean isHorizontal = isHorizontal();
 287         final double tabHeaderAreaSize = isHorizontal
 288                 ? snapSizeX(tabHeaderArea.prefWidth(-1))
 289                 : snapSizeY(tabHeaderArea.prefHeight(-1));
 290 
 291         double prefWidth = isHorizontal ?
 292                 Math.max(maxw, tabHeaderAreaSize) : maxw + tabHeaderAreaSize;
 293         return snapSizeX(prefWidth) + rightInset + leftInset;
 294     }
 295 
 296     /** {@inheritDoc} */
 297     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
 298         // The TabPane can only be as high as it highest content height.
 299         double maxh = 0.0;
 300         for (TabContentRegion contentRegion: tabContentRegions) {
 301             maxh = Math.max(maxh, snapSizeY(contentRegion.prefHeight(-1)));
 302         }
 303 
 304         final boolean isHorizontal = isHorizontal();
 305         final double tabHeaderAreaSize = isHorizontal
 306                 ? snapSizeY(tabHeaderArea.prefHeight(-1))
 307                 : snapSizeX(tabHeaderArea.prefWidth(-1));
 308 
 309         double prefHeight = isHorizontal ?
 310                 maxh + snapSizeY(tabHeaderAreaSize) : Math.max(maxh, tabHeaderAreaSize);
 311         return snapSizeY(prefHeight) + topInset + bottomInset;
 312     }
 313 
 314     /** {@inheritDoc} */
 315     @Override public double computeBaselineOffset(double topInset, double rightInset, double bottomInset, double leftInset) {
 316         Side tabPosition = getSkinnable().getSide();
 317         if (tabPosition == Side.TOP) {
 318             return tabHeaderArea.getBaselineOffset() + topInset;
 319         }
 320         return 0;
 321     }
 322 
 323     /** {@inheritDoc} */
 324     @Override protected void layoutChildren(final double x, final double y,
 325                                             final double w, final double h) {
 326         TabPane tabPane = getSkinnable();
 327         Side tabPosition = tabPane.getSide();
 328 
 329         double headerHeight = tabPosition.isHorizontal()
 330                 ? snapSizeY(tabHeaderArea.prefHeight(-1))
 331                 : snapSizeX(tabHeaderArea.prefHeight(-1));
 332         double tabsStartX = tabPosition.equals(Side.RIGHT)? x + w - headerHeight : x;
 333         double tabsStartY = tabPosition.equals(Side.BOTTOM)? y + h - headerHeight : y;
 334 
 335         final double leftInset = snappedLeftInset();
 336         final double topInset = snappedTopInset();
 337 
 338         if (tabPosition == Side.TOP) {
 339             tabHeaderArea.resize(w, headerHeight);
 340             tabHeaderArea.relocate(tabsStartX, tabsStartY);
 341             tabHeaderArea.getTransforms().clear();
 342             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.TOP)));
 343         } else if (tabPosition == Side.BOTTOM) {
 344             tabHeaderArea.resize(w, headerHeight);
 345             tabHeaderArea.relocate(w + leftInset, tabsStartY - headerHeight);
 346             tabHeaderArea.getTransforms().clear();
 347             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.BOTTOM), 0, headerHeight));
 348         } else if (tabPosition == Side.LEFT) {
 349             tabHeaderArea.resize(h, headerHeight);
 350             tabHeaderArea.relocate(tabsStartX + headerHeight, h - headerHeight + topInset);
 351             tabHeaderArea.getTransforms().clear();
 352             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.LEFT), 0, headerHeight));
 353         } else if (tabPosition == Side.RIGHT) {
 354             tabHeaderArea.resize(h, headerHeight);
 355             tabHeaderArea.relocate(tabsStartX, y - headerHeight);
 356             tabHeaderArea.getTransforms().clear();
 357             tabHeaderArea.getTransforms().add(new Rotate(getRotation(Side.RIGHT), 0, headerHeight));
 358         }
 359 
 360         tabHeaderAreaClipRect.setX(0);
 361         tabHeaderAreaClipRect.setY(0);
 362         if (isHorizontal()) {
 363             tabHeaderAreaClipRect.setWidth(w);
 364         } else {
 365             tabHeaderAreaClipRect.setWidth(h);
 366         }
 367         tabHeaderAreaClipRect.setHeight(headerHeight);
 368 
 369         // ==================================
 370         // position the tab content for the selected tab only
 371         // ==================================
 372         // if the tabs are on the left, the content needs to be indented
 373         double contentStartX = 0;
 374         double contentStartY = 0;
 375 
 376         if (tabPosition == Side.TOP) {
 377             contentStartX = x;
 378             contentStartY = y + headerHeight;
 379             if (isFloatingStyleClass()) {
 380                 // This is to hide the top border content
 381                 contentStartY -= 1;
 382             }
 383         } else if (tabPosition == Side.BOTTOM) {
 384             contentStartX = x;
 385             contentStartY = y + topInset;
 386             if (isFloatingStyleClass()) {
 387                 // This is to hide the bottom border content
 388                 contentStartY = 1 + topInset;
 389             }
 390         } else if (tabPosition == Side.LEFT) {
 391             contentStartX = x + headerHeight;
 392             contentStartY = y;
 393             if (isFloatingStyleClass()) {
 394                 // This is to hide the left border content
 395                 contentStartX -= 1;
 396             }
 397         } else if (tabPosition == Side.RIGHT) {
 398             contentStartX = x + leftInset;
 399             contentStartY = y;
 400             if (isFloatingStyleClass()) {
 401                 // This is to hide the right border content
 402                 contentStartX = 1 + leftInset;
 403             }
 404         }
 405 
 406         double contentWidth = w - (isHorizontal() ? 0 : headerHeight);
 407         double contentHeight = h - (isHorizontal() ? headerHeight: 0);
 408 
 409         for (int i = 0, max = tabContentRegions.size(); i &lt; max; i++) {
 410             TabContentRegion tabContent = tabContentRegions.get(i);
 411 
 412             tabContent.setAlignment(Pos.TOP_LEFT);
 413             if (tabContent.getClip() != null) {
 414                 ((Rectangle)tabContent.getClip()).setWidth(contentWidth);
 415                 ((Rectangle)tabContent.getClip()).setHeight(contentHeight);
 416             }
 417 
 418             // we need to size all tabs, even if they aren&#39;t visible. For example,
 419             // see RT-29167
 420             tabContent.resize(contentWidth, contentHeight);
 421             tabContent.relocate(contentStartX, contentStartY);
 422         }
 423     }
 424 
 425 
 426 
 427     /***************************************************************************
 428      *                                                                         *
 429      * Private implementation                                                  *
 430      *                                                                         *
 431      **************************************************************************/
 432 
 433     private SelectionModel&lt;Tab&gt; selectionModel;
 434     private InvalidationListener selectionChangeListener = observable -&gt; {
 435         isSelectingTab = true;
 436         selectedTab = getSkinnable().getSelectionModel().getSelectedItem();
 437         getSkinnable().requestLayout();
 438     };
 439     private WeakInvalidationListener weakSelectionChangeListener =
 440             new WeakInvalidationListener(selectionChangeListener);
 441 
 442     private void updateSelectionModel() {
 443         if (selectionModel != null) {
 444             selectionModel.selectedItemProperty().removeListener(weakSelectionChangeListener);
 445         }
 446         selectionModel = getSkinnable().getSelectionModel();
 447         if (selectionModel != null) {
 448             selectionModel.selectedItemProperty().addListener(weakSelectionChangeListener);
 449         }
 450     }
 451 
 452     private static int getRotation(Side pos) {
 453         switch (pos) {
 454             case TOP:
 455                 return 0;
 456             case BOTTOM:
 457                 return 180;
 458             case LEFT:
 459                 return -90;
 460             case RIGHT:
 461                 return 90;
 462             default:
 463                 return 0;
 464         }
 465     }
 466 
 467     /**
 468      * VERY HACKY - this lets us &#39;duplicate&#39; Label and ImageView nodes to be used in a
 469      * Tab and the tabs menu at the same time.
 470      */
 471     private static Node clone(Node n) {
 472         if (n == null) {
 473             return null;
 474         }
 475         if (n instanceof ImageView) {
 476             ImageView iv = (ImageView) n;
 477             ImageView imageview = new ImageView();
 478             imageview.imageProperty().bind(iv.imageProperty());
 479             return imageview;
 480         }
 481         if (n instanceof Label) {
 482             Label l = (Label)n;
 483             Label label = new Label(l.getText(), clone(l.getGraphic()));
 484             label.textProperty().bind(l.textProperty());
 485             return label;
 486         }
 487         return null;
 488     }
 489 
 490     private void removeTabs(List&lt;? extends Tab&gt; removedList) {
 491         for (final Tab tab : removedList) {
 492             stopCurrentAnimation(tab);
 493             // Animate the tab removal
 494             final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 495             if (tabRegion != null) {
 496                 tabRegion.isClosing = true;
 497 
 498                 tabRegion.removeListeners(tab);
 499                 removeTabContent(tab);
 500 
 501                 EventHandler&lt;ActionEvent&gt; cleanup = ae -&gt; {
 502                     tabRegion.animationState = TabAnimationState.NONE;
 503 
 504                     tabHeaderArea.removeTab(tab);
 505                     tabHeaderArea.requestLayout();
 506                     if (getSkinnable().getTabs().isEmpty()) {
 507                         tabHeaderArea.setVisible(false);
 508                     }
 509                 };
 510 
 511                 if (closeTabAnimation.get() == TabAnimation.GROW) {
 512                     tabRegion.animationState = TabAnimationState.HIDING;
 513                     Timeline closedTabTimeline = tabRegion.currentAnimation =
 514                             createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 0.0F, cleanup);
 515                     closedTabTimeline.play();
 516                 } else {
 517                     cleanup.handle(null);
 518                 }
 519             }
 520         }
 521     }
 522 
 523     private void stopCurrentAnimation(Tab tab) {
 524         final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 525         if (tabRegion != null) {
 526             // Execute the code immediately, don&#39;t wait for the animation to finish.
 527             Timeline timeline = tabRegion.currentAnimation;
 528             if (timeline != null &amp;&amp; timeline.getStatus() == Animation.Status.RUNNING) {
 529                 timeline.getOnFinished().handle(null);
 530                 timeline.stop();
 531                 tabRegion.currentAnimation = null;
 532             }
 533         }
 534     }
 535 
 536     private void addTabs(List&lt;? extends Tab&gt; addedList, int from) {
 537         int i = 0;
 538 
 539         // RT-39984: check if any other tabs are animating - they must be completed first.
 540         List&lt;Node&gt; headers = new ArrayList&lt;&gt;(tabHeaderArea.headersRegion.getChildren());
 541         for (Node n : headers) {
 542             TabHeaderSkin header = (TabHeaderSkin) n;
 543             if (header.animationState == TabAnimationState.HIDING) {
 544                 stopCurrentAnimation(header.tab);
 545             }
 546         }
 547         // end of fix for RT-39984
 548 
 549         for (final Tab tab : addedList) {
 550             stopCurrentAnimation(tab); // Note that this must happen before addTab() call below
 551             // A new tab was added - animate it out
 552             if (!tabHeaderArea.isVisible()) {
 553                 tabHeaderArea.setVisible(true);
 554             }
 555             int index = from + i++;
 556             tabHeaderArea.addTab(tab, index);
 557             addTabContent(tab);
 558             final TabHeaderSkin tabRegion = tabHeaderArea.getTabHeaderSkin(tab);
 559             if (tabRegion != null) {
 560                 if (openTabAnimation.get() == TabAnimation.GROW) {
 561                     tabRegion.animationState = TabAnimationState.SHOWING;
 562                     tabRegion.animationTransition.setValue(0.0);
 563                     tabRegion.setVisible(true);
 564                     tabRegion.currentAnimation = createTimeline(tabRegion, Duration.millis(ANIMATION_SPEED), 1.0, event -&gt; {
 565                         tabRegion.animationState = TabAnimationState.NONE;
 566                         tabRegion.setVisible(true);
 567                         tabRegion.inner.requestLayout();
 568                     });
 569                     tabRegion.currentAnimation.play();
 570                 } else {
 571                     tabRegion.setVisible(true);
 572                     tabRegion.inner.requestLayout();
 573                 }
 574             }
 575         }
 576     }
 577 
 578     private void initializeTabListener() {
 579         getSkinnable().getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; {
 580             List&lt;Tab&gt; tabsToRemove = new ArrayList&lt;&gt;();
 581             List&lt;Tab&gt; tabsToAdd = new ArrayList&lt;&gt;();
 582             int insertPos = -1;
 583 
 584             while (c.next()) {
 585                 if (c.wasPermutated()) {
 586                     if (dragState != DragState.REORDER) {
 587                         TabPane tabPane = getSkinnable();
 588                         List&lt;Tab&gt; tabs = tabPane.getTabs();
 589 
 590                         // tabs sorted : create list of permutated tabs.
 591                         // clear selection, set tab animation to NONE
 592                         // remove permutated tabs, add them back in correct order.
 593                         // restore old selection, and old tab animation states.
 594                         int size = c.getTo() - c.getFrom();
 595                         Tab selTab = tabPane.getSelectionModel().getSelectedItem();
 596                         List&lt;Tab&gt; permutatedTabs = new ArrayList&lt;Tab&gt;(size);
 597                         getSkinnable().getSelectionModel().clearSelection();
 598 
 599                         // save and set tab animation to none - as it is not a good idea
 600                         // to animate on the same data for open and close.
 601                         TabAnimation prevOpenAnimation = openTabAnimation.get();
 602                         TabAnimation prevCloseAnimation = closeTabAnimation.get();
 603                         openTabAnimation.set(TabAnimation.NONE);
 604                         closeTabAnimation.set(TabAnimation.NONE);
 605                         for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
 606                             permutatedTabs.add(tabs.get(i));
 607                         }
 608 
 609                         removeTabs(permutatedTabs);
 610                         addTabs(permutatedTabs, c.getFrom());
 611                         openTabAnimation.set(prevOpenAnimation);
 612                         closeTabAnimation.set(prevCloseAnimation);
 613                         getSkinnable().getSelectionModel().select(selTab);
 614                     }
 615                 }
 616 
 617                 if (c.wasRemoved()) {
 618                     tabsToRemove.addAll(c.getRemoved());
 619                 }
 620                 if (c.wasAdded()) {
 621                     tabsToAdd.addAll(c.getAddedSubList());
 622                     insertPos = c.getFrom();
 623                 }
 624             }
 625 
 626             // now only remove the tabs that are not in the tabsToAdd list
 627             tabsToRemove.removeAll(tabsToAdd);
 628             removeTabs(tabsToRemove);
 629 
 630             // and add in any new tabs (that we don&#39;t already have showing)
 631             List&lt;Pair&lt;Integer, TabHeaderSkin&gt;&gt; headersToMove = new ArrayList();
 632             if (!tabsToAdd.isEmpty()) {
 633                 for (TabContentRegion tabContentRegion : tabContentRegions) {
 634                     Tab tab = tabContentRegion.getTab();
 635                     TabHeaderSkin tabHeader = tabHeaderArea.getTabHeaderSkin(tab);
 636                     if (!tabHeader.isClosing &amp;&amp; tabsToAdd.contains(tabContentRegion.getTab())) {
 637                         tabsToAdd.remove(tabContentRegion.getTab());
 638 
 639                         // If a tab is removed and added back at the same time,
 640                         // then we must ensure that the index of tabHeader in
 641                         // headersRegion is same as index of tab in getTabs().
 642                         int tabIndex = getSkinnable().getTabs().indexOf(tab);
 643                         int tabHeaderIndex = tabHeaderArea.headersRegion.getChildren().indexOf(tabHeader);
 644                         if (tabIndex != tabHeaderIndex) {
 645                             headersToMove.add(new Pair(tabIndex, tabHeader));
 646                         }
 647                     }
 648                 }
 649 
 650                 addTabs(tabsToAdd, insertPos == -1 ? tabContentRegions.size() : insertPos);
 651                 for (Pair&lt;Integer, TabHeaderSkin&gt; move : headersToMove) {
 652                     tabHeaderArea.moveTab(move.getKey(), move.getValue());
 653                 }
 654             }
 655 
 656             // Fix for RT-34692
 657             getSkinnable().requestLayout();
 658         });
 659     }
 660 
 661     private void addTabContent(Tab tab) {
 662         TabContentRegion tabContentRegion = new TabContentRegion(tab);
 663         tabContentRegion.setClip(new Rectangle());
 664         tabContentRegions.add(tabContentRegion);
 665         // We want the tab content to always sit below the tab headers
 666         getChildren().add(0, tabContentRegion);
 667     }
 668 
 669     private void removeTabContent(Tab tab) {
 670         for (TabContentRegion contentRegion : tabContentRegions) {
 671             if (contentRegion.getTab().equals(tab)) {
 672                 contentRegion.removeListeners(tab);
 673                 getChildren().remove(contentRegion);
 674                 tabContentRegions.remove(contentRegion);
 675                 break;
 676             }
 677         }
 678     }
 679 
 680     private void updateTabPosition() {
 681         tabHeaderArea.setScrollOffset(0.0F);
 682         getSkinnable().applyCss();
 683         getSkinnable().requestLayout();
 684     }
 685 
 686     private Timeline createTimeline(final TabHeaderSkin tabRegion, final Duration duration, final double endValue, final EventHandler&lt;ActionEvent&gt; func) {
 687         Timeline timeline = new Timeline();
 688         timeline.setCycleCount(1);
 689 
 690         KeyValue keyValue = new KeyValue(tabRegion.animationTransition, endValue, Interpolator.LINEAR);
 691         timeline.getKeyFrames().clear();
 692         timeline.getKeyFrames().add(new KeyFrame(duration, keyValue));
 693 
 694         timeline.setOnFinished(func);
 695         return timeline;
 696     }
 697 
 698     private boolean isHorizontal() {
 699         Side tabPosition = getSkinnable().getSide();
 700         return Side.TOP.equals(tabPosition) || Side.BOTTOM.equals(tabPosition);
 701     }
 702 
 703     private void initializeSwipeHandlers() {
 704         if (Properties.IS_TOUCH_SUPPORTED) {
 705             getSkinnable().addEventHandler(SwipeEvent.SWIPE_LEFT, t -&gt; {
 706                 behavior.selectNextTab();
 707             });
 708 
 709             getSkinnable().addEventHandler(SwipeEvent.SWIPE_RIGHT, t -&gt; {
 710                 behavior.selectPreviousTab();
 711             });
 712         }
 713     }
 714 
 715     //TODO need to cache this.
 716     private boolean isFloatingStyleClass() {
 717         return getSkinnable().getStyleClass().contains(TabPane.STYLE_CLASS_FLOATING);
 718     }
 719 
 720 
 721 
 722     /***************************************************************************
 723      *                                                                         *
 724      * CSS                                                                     *
 725      *                                                                         *
 726      **************************************************************************/
 727 
 728    /*
 729     * Super-lazy instantiation pattern from Bill Pugh.
 730     */
 731    private static class StyleableProperties {
 732         private static final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; STYLEABLES;
 733 
 734         private final static CssMetaData&lt;TabPane,TabAnimation&gt; OPEN_TAB_ANIMATION =
 735                 new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-open-tab-animation&quot;,
 736                     new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {
 737 
 738             @Override public boolean isSettable(TabPane node) {
 739                 return true;
 740             }
 741 
 742             @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
 743                 TabPaneSkin skin = (TabPaneSkin) node.getSkin();
 744                 return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.openTabAnimation;
 745             }
 746         };
 747 
 748         private final static CssMetaData&lt;TabPane,TabAnimation&gt; CLOSE_TAB_ANIMATION =
 749                 new CssMetaData&lt;TabPane, TabPaneSkin.TabAnimation&gt;(&quot;-fx-close-tab-animation&quot;,
 750                     new EnumConverter&lt;TabAnimation&gt;(TabAnimation.class), TabAnimation.GROW) {
 751 
 752             @Override public boolean isSettable(TabPane node) {
 753                 return true;
 754             }
 755 
 756             @Override public StyleableProperty&lt;TabAnimation&gt; getStyleableProperty(TabPane node) {
 757                 TabPaneSkin skin = (TabPaneSkin) node.getSkin();
 758                 return (StyleableProperty&lt;TabAnimation&gt;)(WritableValue&lt;TabAnimation&gt;)skin.closeTabAnimation;
 759             }
 760         };
 761 
 762         static {
 763 
 764            final List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; styleables =
 765                new ArrayList&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt;(SkinBase.getClassCssMetaData());
 766            styleables.add(OPEN_TAB_ANIMATION);
 767            styleables.add(CLOSE_TAB_ANIMATION);
 768            STYLEABLES = Collections.unmodifiableList(styleables);
 769 
 770         }
 771     }
 772 
 773     /**
 774      * Returns the CssMetaData associated with this class, which may include the
 775      * CssMetaData of its superclasses.
 776      * @return the CssMetaData associated with this class, which may include the
 777      * CssMetaData of its superclasses
 778      */
 779     public static List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getClassCssMetaData() {
 780         return StyleableProperties.STYLEABLES;
 781     }
 782 
 783     /**
 784      * {@inheritDoc}
 785      */
 786     @Override public List&lt;CssMetaData&lt;? extends Styleable, ?&gt;&gt; getCssMetaData() {
 787         return getClassCssMetaData();
 788     }
 789 
 790 
 791 
 792     /***************************************************************************
 793      *                                                                         *
 794      * Support classes                                                         *
 795      *                                                                         *
 796      **************************************************************************/
 797 
 798     /**************************************************************************
 799      *
 800      * TabHeaderArea: Area responsible for painting all tabs
 801      *
 802      **************************************************************************/
 803     class TabHeaderArea extends StackPane {
 804         private Rectangle headerClip;
 805         private StackPane headersRegion;
 806         private StackPane headerBackground;
 807         private TabControlButtons controlButtons;
 808 
 809         private boolean measureClosingTabs = false;
 810 
 811         private double scrollOffset;
 812 
 813         public TabHeaderArea() {
 814             getStyleClass().setAll(&quot;tab-header-area&quot;);
 815             setManaged(false);
 816             final TabPane tabPane = getSkinnable();
 817 
 818             headerClip = new Rectangle();
 819 
 820             headersRegion = new StackPane() {
 821                 @Override protected double computePrefWidth(double height) {
 822                     double width = 0.0F;
 823                     for (Node child : getChildren()) {
 824                         TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 825                         if (tabHeaderSkin.isVisible() &amp;&amp; (measureClosingTabs || ! tabHeaderSkin.isClosing)) {
 826                             width += tabHeaderSkin.prefWidth(height);
 827                         }
 828                     }
 829                     return snapSize(width) + snappedLeftInset() + snappedRightInset();
 830                 }
 831 
 832                 @Override protected double computePrefHeight(double width) {
 833                     double height = 0.0F;
 834                     for (Node child : getChildren()) {
 835                         TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
 836                         height = Math.max(height, tabHeaderSkin.prefHeight(width));
 837                     }
 838                     return snapSize(height) + snappedTopInset() + snappedBottomInset();
 839                 }
 840 
 841                 @Override protected void layoutChildren() {
 842                     if (tabsFit()) {
 843                         setScrollOffset(0.0);
 844                     } else {
 845                         if (isSelectingTab) {
 846                             ensureSelectedTabIsVisible();
 847                         } else {
 848                             validateScrollOffset();
 849                         }
 850                     }
 851                     isSelectingTab = false;
 852 
 853                     Side tabPosition = getSkinnable().getSide();
 854                     double tabBackgroundHeight = snapSize(prefHeight(-1));
 855                     double tabX = (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) ?
 856                         snapSize(getWidth()) - getScrollOffset() : getScrollOffset();
 857 
 858                     updateHeaderClip();
 859                     for (Node node : getChildren()) {
 860                         TabHeaderSkin tabHeader = (TabHeaderSkin)node;
 861 
 862                         // size and position the header relative to the other headers
 863                         double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1) * tabHeader.animationTransition.get());
 864                         double tabHeaderPrefHeight = snapSize(tabHeader.prefHeight(-1));
 865                         tabHeader.resize(tabHeaderPrefWidth, tabHeaderPrefHeight);
 866 
 867                         // This ensures that the tabs are located in the correct position
 868                         // when there are tabs of differing heights.
 869                         double startY = tabPosition.equals(Side.BOTTOM) ?
 870                             0 : tabBackgroundHeight - tabHeaderPrefHeight - snappedBottomInset();
 871                         if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
 872                             // build from the right
 873                             tabX -= tabHeaderPrefWidth;
 874                             if (dragState != DragState.REORDER ||
 875                                     (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
 876                                 tabHeader.relocate(tabX, startY);
 877                             }
 878                         } else {
 879                             // build from the left
 880                             if (dragState != DragState.REORDER ||
 881                                     (tabHeader != dragTabHeader &amp;&amp; tabHeader != dropAnimHeader)) {
 882                                 tabHeader.relocate(tabX, startY);
 883                             }
 884                             tabX += tabHeaderPrefWidth;
 885                         }
 886                     }
 887                 }
 888 
 889             };
 890             headersRegion.getStyleClass().setAll(&quot;headers-region&quot;);
 891             headersRegion.setClip(headerClip);
 892             setupReordering(headersRegion);
 893 
 894             headerBackground = new StackPane();
 895             headerBackground.getStyleClass().setAll(&quot;tab-header-background&quot;);
 896 
 897             int i = 0;
 898             for (Tab tab: tabPane.getTabs()) {
 899                 addTab(tab, i++);
 900             }
 901 
 902             controlButtons = new TabControlButtons();
 903             controlButtons.setVisible(false);
 904             if (controlButtons.isVisible()) {
 905                 controlButtons.setVisible(true);
 906             }
 907             getChildren().addAll(headerBackground, headersRegion, controlButtons);
 908 
 909             // support for mouse scroll of header area (for when the tabs exceed
 910             // the available space).
 911             // Scrolling the mouse wheel downwards results in the tabs scrolling left (i.e. exposing the right-most tabs)
 912             // Scrolling the mouse wheel upwards results in the tabs scrolling right (i.e. exposing th left-most tabs)
 913             addEventHandler(ScrollEvent.SCROLL, (ScrollEvent e) -&gt; {
 914                 Side side = getSkinnable().getSide();
 915                 side = side == null ? Side.TOP : side;
 916                 switch (side) {
 917                     default:
 918                     case TOP:
 919                     case BOTTOM:
 920                         setScrollOffset(scrollOffset + e.getDeltaY());
 921                         break;
 922                     case LEFT:
 923                     case RIGHT:
 924                         setScrollOffset(scrollOffset - e.getDeltaY());
 925                         break;
 926                 }
 927 
 928             });
 929         }
 930 
 931         private void updateHeaderClip() {
 932             Side tabPosition = getSkinnable().getSide();
 933 
 934             double x = 0;
 935             double y = 0;
 936             double clipWidth = 0;
 937             double clipHeight = 0;
 938             double maxWidth = 0;
 939             double shadowRadius = 0;
 940             double clipOffset = firstTabIndent();
 941             double controlButtonPrefWidth = snapSize(controlButtons.prefWidth(-1));
 942 
 943             measureClosingTabs = true;
 944             double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
 945             measureClosingTabs = false;
 946 
 947             double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));
 948 
 949             // Add the spacer if isShowTabsMenu is true.
 950             if (controlButtonPrefWidth &gt; 0) {
 951                 controlButtonPrefWidth = controlButtonPrefWidth + SPACER;
 952             }
 953 
 954             if (headersRegion.getEffect() instanceof DropShadow) {
 955                 DropShadow shadow = (DropShadow)headersRegion.getEffect();
 956                 shadowRadius = shadow.getRadius();
 957             }
 958 
 959             maxWidth = snapSize(getWidth()) - controlButtonPrefWidth - clipOffset;
 960             if (tabPosition.equals(Side.LEFT) || tabPosition.equals(Side.BOTTOM)) {
 961                 if (headersPrefWidth &lt; maxWidth) {
 962                     clipWidth = headersPrefWidth + shadowRadius;
 963                 } else {
 964                     x = headersPrefWidth - maxWidth;
 965                     clipWidth = maxWidth + shadowRadius;
 966                 }
 967                 clipHeight = headersPrefHeight;
 968             } else {
 969                 // If x = 0 the header region&#39;s drop shadow is clipped.
 970                 x = -shadowRadius;
 971                 clipWidth = (headersPrefWidth &lt; maxWidth ? headersPrefWidth : maxWidth) + shadowRadius;
 972                 clipHeight = headersPrefHeight;
 973             }
 974 
 975             headerClip.setX(x);
 976             headerClip.setY(y);
 977             headerClip.setWidth(clipWidth);
 978             headerClip.setHeight(clipHeight);
 979         }
 980 
 981         private void addTab(Tab tab, int addToIndex) {
 982             TabHeaderSkin tabHeaderSkin = new TabHeaderSkin(tab);
 983             headersRegion.getChildren().add(addToIndex, tabHeaderSkin);
 984         }
 985 
 986         private void removeTab(Tab tab) {
 987             TabHeaderSkin tabHeaderSkin = getTabHeaderSkin(tab);
 988             if (tabHeaderSkin != null) {
 989                 headersRegion.getChildren().remove(tabHeaderSkin);
 990             }
 991         }
 992 
 993         private void moveTab(int moveToIndex, TabHeaderSkin tabHeaderSkin) {
 994             headersRegion.getChildren().remove(tabHeaderSkin);
 995             headersRegion.getChildren().add(moveToIndex, tabHeaderSkin);
 996         }
 997 
 998         private TabHeaderSkin getTabHeaderSkin(Tab tab) {
 999             for (Node child: headersRegion.getChildren()) {
1000                 TabHeaderSkin tabHeaderSkin = (TabHeaderSkin)child;
1001                 if (tabHeaderSkin.getTab().equals(tab)) {
1002                     return tabHeaderSkin;
1003                 }
1004             }
1005             return null;
1006         }
1007 
1008         private boolean tabsFit() {
1009             double headerPrefWidth = snapSize(headersRegion.prefWidth(-1));
1010             double controlTabWidth = snapSize(controlButtons.prefWidth(-1));
1011             double visibleWidth = headerPrefWidth + controlTabWidth + firstTabIndent() + SPACER;
1012             return visibleWidth &lt; getWidth();
1013         }
1014 
1015         private void ensureSelectedTabIsVisible() {
1016             // work out the visible width of the tab header
1017             double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
1018             double controlTabWidth = snapSize(controlButtons.getWidth());
1019             double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;
1020 
1021             // and get where the selected tab is in the header area
1022             double offset = 0.0;
1023             double selectedTabOffset = 0.0;
1024             double selectedTabWidth = 0.0;
1025             for (Node node : headersRegion.getChildren()) {
1026                 TabHeaderSkin tabHeader = (TabHeaderSkin)node;
1027 
1028                 double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
1029 
1030                 if (selectedTab != null &amp;&amp; selectedTab.equals(tabHeader.getTab())) {
1031                     selectedTabOffset = offset;
1032                     selectedTabWidth = tabHeaderPrefWidth;
1033                 }
1034                 offset += tabHeaderPrefWidth;
1035             }
1036 
1037             final double scrollOffset = getScrollOffset();
1038             final double selectedTabStartX = selectedTabOffset;
1039             final double selectedTabEndX = selectedTabOffset + selectedTabWidth;
1040 
1041             final double visibleAreaEndX = visibleWidth;
1042 
1043             if (selectedTabStartX &lt; -scrollOffset) {
1044                 setScrollOffset(-selectedTabStartX);
1045             } else if (selectedTabEndX &gt; (visibleAreaEndX - scrollOffset)) {
1046                 setScrollOffset(visibleAreaEndX - selectedTabEndX);
1047             }
1048         }
1049 
1050         public double getScrollOffset() {
1051             return scrollOffset;
1052         }
1053 
1054         private void validateScrollOffset() {
1055             setScrollOffset(getScrollOffset());
1056         }
1057 
1058         private void setScrollOffset(double newScrollOffset) {
1059             // work out the visible width of the tab header
1060             double tabPaneWidth = snapSize(isHorizontal() ? getSkinnable().getWidth() : getSkinnable().getHeight());
1061             double controlTabWidth = snapSize(controlButtons.getWidth());
1062             double visibleWidth = tabPaneWidth - controlTabWidth - firstTabIndent() - SPACER;
1063 
1064             // measure the width of all tabs
1065             double offset = 0.0;
1066             for (Node node : headersRegion.getChildren()) {
1067                 TabHeaderSkin tabHeader = (TabHeaderSkin)node;
1068                 double tabHeaderPrefWidth = snapSize(tabHeader.prefWidth(-1));
1069                 offset += tabHeaderPrefWidth;
1070             }
1071 
1072             double actualNewScrollOffset;
1073 
1074             if ((visibleWidth - newScrollOffset) &gt; offset &amp;&amp; newScrollOffset &lt; 0) {
1075                 // need to make sure the right-most tab is attached to the
1076                 // right-hand side of the tab header (e.g. if the tab header area width
1077                 // is expanded), and if it isn&#39;t modify the scroll offset to bring
1078                 // it into line. See RT-35194 for a test case.
1079                 actualNewScrollOffset = visibleWidth - offset;
1080             } else if (newScrollOffset &gt; 0) {
1081                 // need to prevent the left-most tab from becoming detached
1082                 // from the left-hand side of the tab header.
1083                 actualNewScrollOffset = 0;
1084             } else {
1085                 actualNewScrollOffset = newScrollOffset;
1086             }
1087 
1088             if (Math.abs(actualNewScrollOffset - scrollOffset) &gt; 0.001) {
1089                 scrollOffset = actualNewScrollOffset;
1090                 headersRegion.requestLayout();
1091             }
1092         }
1093 
1094         private double firstTabIndent() {
1095             switch (getSkinnable().getSide()) {
1096                 case TOP:
1097                 case BOTTOM:
1098                     return snappedLeftInset();
1099                 case RIGHT:
1100                 case LEFT:
1101                     return snappedTopInset();
1102                 default:
1103                     return 0;
1104             }
1105         }
1106 
1107         @Override protected double computePrefWidth(double height) {
1108             double padding = isHorizontal() ?
1109                 snappedLeftInset() + snappedRightInset() :
1110                 snappedTopInset() + snappedBottomInset();
1111             return snapSize(headersRegion.prefWidth(height)) + controlButtons.prefWidth(height) +
1112                     firstTabIndent() + SPACER + padding;
1113         }
1114 
1115         @Override protected double computePrefHeight(double width) {
1116             double padding = isHorizontal() ?
1117                 snappedTopInset() + snappedBottomInset() :
1118                 snappedLeftInset() + snappedRightInset();
1119             return snapSize(headersRegion.prefHeight(-1)) + padding;
1120         }
1121 
1122         @Override public double getBaselineOffset() {
1123             if (getSkinnable().getSide() == Side.TOP) {
1124                 return headersRegion.getBaselineOffset() + snappedTopInset();
1125             }
1126             return 0;
1127         }
1128 
1129         @Override protected void layoutChildren() {
1130             final double leftInset = snappedLeftInset();
1131             final double rightInset = snappedRightInset();
1132             final double topInset = snappedTopInset();
1133             final double bottomInset = snappedBottomInset();
1134             double w = snapSize(getWidth()) - (isHorizontal() ?
1135                     leftInset + rightInset : topInset + bottomInset);
1136             double h = snapSize(getHeight()) - (isHorizontal() ?
1137                     topInset + bottomInset : leftInset + rightInset);
1138             double tabBackgroundHeight = snapSize(prefHeight(-1));
1139             double headersPrefWidth = snapSize(headersRegion.prefWidth(-1));
1140             double headersPrefHeight = snapSize(headersRegion.prefHeight(-1));
1141 
1142             controlButtons.showTabsMenu(! tabsFit());
1143 
1144             updateHeaderClip();
1145             headersRegion.requestLayout();
1146 
1147             // RESIZE CONTROL BUTTONS
1148             double btnWidth = snapSize(controlButtons.prefWidth(-1));
1149             final double btnHeight = controlButtons.prefHeight(btnWidth);
1150             controlButtons.resize(btnWidth, btnHeight);
1151 
1152             // POSITION TABS
1153             headersRegion.resize(headersPrefWidth, headersPrefHeight);
1154 
1155             if (isFloatingStyleClass()) {
1156                 headerBackground.setVisible(false);
1157             } else {
1158                 headerBackground.resize(snapSize(getWidth()), snapSize(getHeight()));
1159                 headerBackground.setVisible(true);
1160             }
1161 
1162             double startX = 0;
1163             double startY = 0;
1164             double controlStartX = 0;
1165             double controlStartY = 0;
1166             Side tabPosition = getSkinnable().getSide();
1167 
1168             if (tabPosition.equals(Side.TOP)) {
1169                 startX = leftInset;
1170                 startY = tabBackgroundHeight - headersPrefHeight - bottomInset;
1171                 controlStartX = w - btnWidth + leftInset;
1172                 controlStartY = snapSize(getHeight()) - btnHeight - bottomInset;
1173             } else if (tabPosition.equals(Side.RIGHT)) {
1174                 startX = topInset;
1175                 startY = tabBackgroundHeight - headersPrefHeight - leftInset;
1176                 controlStartX = w - btnWidth + topInset;
1177                 controlStartY = snapSize(getHeight()) - btnHeight - leftInset;
1178             } else if (tabPosition.equals(Side.BOTTOM)) {
1179                 startX = snapSize(getWidth()) - headersPrefWidth - leftInset;
1180                 startY = tabBackgroundHeight - headersPrefHeight - topInset;
1181                 controlStartX = rightInset;
1182                 controlStartY = snapSize(getHeight()) - btnHeight - topInset;
1183             } else if (tabPosition.equals(Side.LEFT)) {
1184                 startX = snapSize(getWidth()) - headersPrefWidth - topInset;
1185                 startY = tabBackgroundHeight - headersPrefHeight - rightInset;
1186                 controlStartX = leftInset;
1187                 controlStartY = snapSize(getHeight()) - btnHeight - rightInset;
1188             }
1189             if (headerBackground.isVisible()) {
1190                 positionInArea(headerBackground, 0, 0,
1191                         snapSize(getWidth()), snapSize(getHeight()), /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1192             }
1193             positionInArea(headersRegion, startX, startY, w, h, /*baseline ignored*/0, HPos.LEFT, VPos.CENTER);
1194             positionInArea(controlButtons, controlStartX, controlStartY, btnWidth, btnHeight,
1195                         /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1196         }
1197     } /* End TabHeaderArea */
1198 
1199 
1200 
1201 
1202     /**************************************************************************
1203      *
1204      * TabHeaderSkin: skin for each tab
1205      *
1206      **************************************************************************/
1207 
1208     class TabHeaderSkin extends StackPane {
1209         private final Tab tab;
1210         public Tab getTab() {
1211             return tab;
1212         }
1213         private Label label;
1214         private StackPane closeBtn;
1215         private StackPane inner;
1216         private Tooltip oldTooltip;
1217         private Tooltip tooltip;
1218         private Rectangle clip;
1219 
1220         private boolean isClosing = false;
1221 
1222         private LambdaMultiplePropertyChangeListenerHandler listener = new LambdaMultiplePropertyChangeListenerHandler();
1223 
1224         private final ListChangeListener&lt;String&gt; styleClassListener = new ListChangeListener&lt;String&gt;() {
1225             @Override
1226             public void onChanged(Change&lt;? extends String&gt; c) {
1227                 getStyleClass().setAll(tab.getStyleClass());
1228             }
1229         };
1230 
1231         private final WeakListChangeListener&lt;String&gt; weakStyleClassListener =
1232                 new WeakListChangeListener&lt;&gt;(styleClassListener);
1233 
1234         public TabHeaderSkin(final Tab tab) {
1235             getStyleClass().setAll(tab.getStyleClass());
1236             setId(tab.getId());
1237             setStyle(tab.getStyle());
1238             setAccessibleRole(AccessibleRole.TAB_ITEM);
1239             setViewOrder(1);
1240 
1241             this.tab = tab;
1242             clip = new Rectangle();
1243             setClip(clip);
1244 
1245             label = new Label(tab.getText(), tab.getGraphic());
1246             label.getStyleClass().setAll(&quot;tab-label&quot;);
1247 
1248             closeBtn = new StackPane() {
1249                 @Override protected double computePrefWidth(double h) {
1250                     return CLOSE_BTN_SIZE;
1251                 }
1252                 @Override protected double computePrefHeight(double w) {
1253                     return CLOSE_BTN_SIZE;
1254                 }
1255                 @Override
1256                 public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1257                     switch (action) {
1258                         case FIRE: {
1259                             Tab tab = getTab();
1260                             if (behavior.canCloseTab(tab)) {
1261                                 behavior.closeTab(tab);
1262                                 setOnMousePressed(null);
1263                             }
1264                             break;
1265                         }
1266                         default: super.executeAccessibleAction(action, parameters);
1267                     }
1268                 }
1269             };
1270             closeBtn.setAccessibleRole(AccessibleRole.BUTTON);
1271             closeBtn.setAccessibleText(getString(&quot;Accessibility.title.TabPane.CloseButton&quot;));
1272             closeBtn.getStyleClass().setAll(&quot;tab-close-button&quot;);
1273             closeBtn.setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
1274                 @Override
1275                 public void handle(MouseEvent me) {
1276                     Tab tab = getTab();
1277                     if (me.getButton().equals(MouseButton.PRIMARY) &amp;&amp; behavior.canCloseTab(tab)) {
1278                         behavior.closeTab(tab);
1279                         setOnMousePressed(null);
1280                         me.consume();
1281                     }
1282                 }
1283             });
1284 
1285             updateGraphicRotation();
1286 
1287             final Region focusIndicator = new Region();
1288             focusIndicator.setMouseTransparent(true);
1289             focusIndicator.getStyleClass().add(&quot;focus-indicator&quot;);
1290 
1291             inner = new StackPane() {
1292                 @Override protected void layoutChildren() {
1293                     final TabPane skinnable = getSkinnable();
1294 
1295                     final double paddingTop = snappedTopInset();
1296                     final double paddingRight = snappedRightInset();
1297                     final double paddingBottom = snappedBottomInset();
1298                     final double paddingLeft = snappedLeftInset();
1299                     final double w = getWidth() - (paddingLeft + paddingRight);
1300                     final double h = getHeight() - (paddingTop + paddingBottom);
1301 
1302                     final double prefLabelWidth = snapSize(label.prefWidth(-1));
1303                     final double prefLabelHeight = snapSize(label.prefHeight(-1));
1304 
1305                     final double closeBtnWidth = showCloseButton() ? snapSize(closeBtn.prefWidth(-1)) : 0;
1306                     final double closeBtnHeight = showCloseButton() ? snapSize(closeBtn.prefHeight(-1)) : 0;
1307                     final double minWidth = snapSize(skinnable.getTabMinWidth());
1308                     final double maxWidth = snapSize(skinnable.getTabMaxWidth());
1309                     final double maxHeight = snapSize(skinnable.getTabMaxHeight());
1310 
1311                     double labelAreaWidth = prefLabelWidth;
1312                     double labelWidth = prefLabelWidth;
1313                     double labelHeight = prefLabelHeight;
1314 
1315                     final double childrenWidth = labelAreaWidth + closeBtnWidth;
1316                     final double childrenHeight = Math.max(labelHeight, closeBtnHeight);
1317 
1318                     if (childrenWidth &gt; maxWidth &amp;&amp; maxWidth != Double.MAX_VALUE) {
1319                         labelAreaWidth = maxWidth - closeBtnWidth;
1320                         labelWidth = maxWidth - closeBtnWidth;
1321                     } else if (childrenWidth &lt; minWidth) {
1322                         labelAreaWidth = minWidth - closeBtnWidth;
1323                     }
1324 
1325                     if (childrenHeight &gt; maxHeight &amp;&amp; maxHeight != Double.MAX_VALUE) {
1326                         labelHeight = maxHeight;
1327                     }
1328 
1329                     if (animationState != TabAnimationState.NONE) {
1330 //                        if (prefWidth.getValue() &lt; labelAreaWidth) {
1331 //                            labelAreaWidth = prefWidth.getValue();
1332 //                        }
1333                         labelAreaWidth *= animationTransition.get();
1334                         closeBtn.setVisible(false);
1335                     } else {
1336                         closeBtn.setVisible(showCloseButton());
1337                     }
1338 
1339 
1340                     label.resize(labelWidth, labelHeight);
1341 
1342 
1343                     double labelStartX = paddingLeft;
1344 
1345                     // If maxWidth is less than Double.MAX_VALUE, the user has
1346                     // clamped the max width, but we should
1347                     // position the close button at the end of the tab,
1348                     // which may not necessarily be the entire width of the
1349                     // provided max width.
1350                     double closeBtnStartX = (maxWidth &lt; Double.MAX_VALUE ? Math.min(w, maxWidth) : w) - paddingRight - closeBtnWidth;
1351 
1352                     positionInArea(label, labelStartX, paddingTop, labelAreaWidth, h,
1353                             /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1354 
1355                     if (closeBtn.isVisible()) {
1356                         closeBtn.resize(closeBtnWidth, closeBtnHeight);
1357                         positionInArea(closeBtn, closeBtnStartX, paddingTop, closeBtnWidth, h,
1358                                 /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1359                     }
1360 
1361                     // Magic numbers regretfully introduced for RT-28944 (so that
1362                     // the focus rect appears as expected on Windows and Mac).
1363                     // In short we use the vPadding to shift the focus rect down
1364                     // into the content area (whereas previously it was being clipped
1365                     // on Windows, whilst it still looked fine on Mac). In the
1366                     // future we may want to improve this code to remove the
1367                     // magic number. Similarly, the hPadding differs on Mac.
1368                     final int vPadding = Utils.isMac() ? 2 : 3;
1369                     final int hPadding = Utils.isMac() ? 2 : 1;
1370                     focusIndicator.resizeRelocate(
1371                             paddingLeft - hPadding,
1372                             paddingTop + vPadding,
1373                             w + 2 * hPadding,
1374                             h - 2 * vPadding);
1375                 }
1376             };
1377             inner.getStyleClass().add(&quot;tab-container&quot;);
1378             inner.setRotate(getSkinnable().getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
1379             inner.getChildren().addAll(label, closeBtn, focusIndicator);
1380 
1381             getChildren().addAll(inner);
1382 
1383             tooltip = tab.getTooltip();
1384             if (tooltip != null) {
1385                 Tooltip.install(this, tooltip);
1386                 oldTooltip = tooltip;
1387             }
1388 
1389             listener.registerChangeListener(tab.closableProperty(), e -&gt; {
1390                 inner.requestLayout();
1391                 requestLayout();
1392             });
1393             listener.registerChangeListener(tab.selectedProperty(), e -&gt; {
1394                 pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
1395                 // Need to request a layout pass for inner because if the width
1396                 // and height didn&#39;t not change the label or close button may have
1397                 // changed.
1398                 inner.requestLayout();
1399                 requestLayout();
1400             });
1401             listener.registerChangeListener(tab.textProperty(),e -&gt; label.setText(getTab().getText()));
1402             listener.registerChangeListener(tab.graphicProperty(), e -&gt; label.setGraphic(getTab().getGraphic()));
1403             listener.registerChangeListener(tab.tooltipProperty(), e -&gt; {
1404                 // uninstall the old tooltip
1405                 if (oldTooltip != null) {
1406                     Tooltip.uninstall(this, oldTooltip);
1407                 }
1408                 tooltip = tab.getTooltip();
1409                 if (tooltip != null) {
1410                     // install new tooltip and save as old tooltip.
1411                     Tooltip.install(this, tooltip);
1412                     oldTooltip = tooltip;
1413                 }
1414             });
1415             listener.registerChangeListener(tab.disabledProperty(), e -&gt; {
1416                 updateTabDisabledState();
1417             });
1418             listener.registerChangeListener(tab.getTabPane().disabledProperty(), e -&gt; {
1419                 updateTabDisabledState();
1420             });
1421             listener.registerChangeListener(tab.styleProperty(), e -&gt; setStyle(tab.getStyle()));
1422 
1423             tab.getStyleClass().addListener(weakStyleClassListener);
1424 
1425             listener.registerChangeListener(getSkinnable().tabClosingPolicyProperty(),e -&gt; {
1426                 inner.requestLayout();
1427                 requestLayout();
1428             });
1429             listener.registerChangeListener(getSkinnable().sideProperty(),e -&gt; {
1430                 final Side side = getSkinnable().getSide();
1431                 pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
1432                 pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
1433                 pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
1434                 pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
1435                 inner.setRotate(side == Side.BOTTOM ? 180.0F : 0.0F);
1436                 if (getSkinnable().isRotateGraphic()) {
1437                     updateGraphicRotation();
1438                 }
1439             });
1440             listener.registerChangeListener(getSkinnable().rotateGraphicProperty(), e -&gt; updateGraphicRotation());
1441             listener.registerChangeListener(getSkinnable().tabMinWidthProperty(), e -&gt; {
1442                 requestLayout();
1443                 getSkinnable().requestLayout();
1444             });
1445             listener.registerChangeListener(getSkinnable().tabMaxWidthProperty(), e -&gt; {
1446                 requestLayout();
1447                 getSkinnable().requestLayout();
1448             });
1449             listener.registerChangeListener(getSkinnable().tabMinHeightProperty(), e -&gt; {
1450                 requestLayout();
1451                 getSkinnable().requestLayout();
1452             });
1453             listener.registerChangeListener(getSkinnable().tabMaxHeightProperty(), e -&gt; {
1454                 requestLayout();
1455                 getSkinnable().requestLayout();
1456             });
1457 
1458             getProperties().put(Tab.class, tab);
1459             getProperties().put(ContextMenu.class, tab.getContextMenu());
1460 
1461             setOnContextMenuRequested((ContextMenuEvent me) -&gt; {
1462                if (getTab().getContextMenu() != null) {
1463                     getTab().getContextMenu().show(inner, me.getScreenX(), me.getScreenY());
1464                     me.consume();
1465                 }
1466             });
1467             setOnMousePressed(new EventHandler&lt;MouseEvent&gt;() {
1468                 @Override public void handle(MouseEvent me) {
1469                     Tab tab = getTab();
1470                     if (tab.isDisable()) {
1471                         return;
1472                     }
1473                     if (me.getButton().equals(MouseButton.MIDDLE)
1474                         || me.getButton().equals(MouseButton.PRIMARY)) {
1475 
1476                         if (tab.getContextMenu() != null
1477                             &amp;&amp; tab.getContextMenu().isShowing()) {
1478                             tab.getContextMenu().hide();
1479                         }
1480                     }
1481                     if (me.getButton().equals(MouseButton.MIDDLE)) {
1482                         if (showCloseButton()) {
1483                             if (behavior.canCloseTab(tab)) {
1484                                 removeListeners(tab);
1485                                 behavior.closeTab(tab);
1486                             }
1487                         }
1488                     } else if (me.getButton().equals(MouseButton.PRIMARY)) {
1489                         behavior.selectTab(tab);
1490                     }
1491                 }
1492             });
1493 
1494             // initialize pseudo-class state
1495             pseudoClassStateChanged(SELECTED_PSEUDOCLASS_STATE, tab.isSelected());
1496             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
1497             final Side side = getSkinnable().getSide();
1498             pseudoClassStateChanged(TOP_PSEUDOCLASS_STATE, (side == Side.TOP));
1499             pseudoClassStateChanged(RIGHT_PSEUDOCLASS_STATE, (side == Side.RIGHT));
1500             pseudoClassStateChanged(BOTTOM_PSEUDOCLASS_STATE, (side == Side.BOTTOM));
1501             pseudoClassStateChanged(LEFT_PSEUDOCLASS_STATE, (side == Side.LEFT));
1502         }
1503 
1504         private void updateTabDisabledState() {
1505             pseudoClassStateChanged(DISABLED_PSEUDOCLASS_STATE, tab.isDisabled());
1506             inner.requestLayout();
1507             requestLayout();
1508         }
1509 
1510         private void updateGraphicRotation() {
1511             if (label.getGraphic() != null) {
1512                 label.getGraphic().setRotate(getSkinnable().isRotateGraphic() ? 0.0F :
1513                     (getSkinnable().getSide().equals(Side.RIGHT) ? -90.0F :
1514                         (getSkinnable().getSide().equals(Side.LEFT) ? 90.0F : 0.0F)));
1515             }
1516         }
1517 
1518         private boolean showCloseButton() {
1519             return tab.isClosable() &amp;&amp;
1520                     (getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.ALL_TABS) ||
1521                     getSkinnable().getTabClosingPolicy().equals(TabClosingPolicy.SELECTED_TAB) &amp;&amp; tab.isSelected());
1522         }
1523 
1524         private final DoubleProperty animationTransition = new SimpleDoubleProperty(this, &quot;animationTransition&quot;, 1.0) {
1525             @Override protected void invalidated() {
1526                 requestLayout();
1527             }
1528         };
1529 
1530         private void removeListeners(Tab tab) {
1531             listener.dispose();
1532             inner.getChildren().clear();
1533             getChildren().clear();
1534             setOnContextMenuRequested(null);
1535             setOnMousePressed(null);
1536         }
1537 
1538         private TabAnimationState animationState = TabAnimationState.NONE;
1539         private Timeline currentAnimation;
1540 
1541         @Override protected double computePrefWidth(double height) {
1542 //            if (animating) {
1543 //                return prefWidth.getValue();
1544 //            }
1545             double minWidth = snapSize(getSkinnable().getTabMinWidth());
1546             double maxWidth = snapSize(getSkinnable().getTabMaxWidth());
1547             double paddingRight = snappedRightInset();
1548             double paddingLeft = snappedLeftInset();
1549             double tmpPrefWidth = snapSize(label.prefWidth(-1));
1550 
1551             // only include the close button width if it is relevant
1552             if (showCloseButton()) {
1553                 tmpPrefWidth += snapSize(closeBtn.prefWidth(-1));
1554             }
1555 
1556             if (tmpPrefWidth &gt; maxWidth) {
1557                 tmpPrefWidth = maxWidth;
1558             } else if (tmpPrefWidth &lt; minWidth) {
1559                 tmpPrefWidth = minWidth;
1560             }
1561             tmpPrefWidth += paddingRight + paddingLeft;
1562 //            prefWidth.setValue(tmpPrefWidth);
1563             return tmpPrefWidth;
1564         }
1565 
1566         @Override protected double computePrefHeight(double width) {
1567             double minHeight = snapSize(getSkinnable().getTabMinHeight());
1568             double maxHeight = snapSize(getSkinnable().getTabMaxHeight());
1569             double paddingTop = snappedTopInset();
1570             double paddingBottom = snappedBottomInset();
1571             double tmpPrefHeight = snapSize(label.prefHeight(width));
1572 
1573             if (tmpPrefHeight &gt; maxHeight) {
1574                 tmpPrefHeight = maxHeight;
1575             } else if (tmpPrefHeight &lt; minHeight) {
1576                 tmpPrefHeight = minHeight;
1577             }
1578             tmpPrefHeight += paddingTop + paddingBottom;
1579             return tmpPrefHeight;
1580         }
1581 
1582         @Override protected void layoutChildren() {
1583             double w = (snapSize(getWidth()) - snappedRightInset() - snappedLeftInset()) * animationTransition.getValue();
1584             inner.resize(w, snapSize(getHeight()) - snappedTopInset() - snappedBottomInset());
1585             inner.relocate(snappedLeftInset(), snappedTopInset());
1586         }
1587 
1588         @Override protected void setWidth(double value) {
1589             super.setWidth(value);
1590             clip.setWidth(value);
1591         }
1592 
1593         @Override protected void setHeight(double value) {
1594             super.setHeight(value);
1595             clip.setHeight(value);
1596         }
1597 
1598         /** {@inheritDoc} */
1599         @Override
1600         public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1601             switch (attribute) {
1602                 case TEXT: return getTab().getText();
1603                 case SELECTED: return selectedTab == getTab();
1604                 default: return super.queryAccessibleAttribute(attribute, parameters);
1605             }
1606         }
1607 
1608         /** {@inheritDoc} */
1609         @Override
1610         public void executeAccessibleAction(AccessibleAction action, Object... parameters) {
1611             switch (action) {
1612                 case REQUEST_FOCUS:
1613                     getSkinnable().getSelectionModel().select(getTab());
1614                     break;
1615                 default: super.executeAccessibleAction(action, parameters);
1616             }
1617         }
1618 
1619     } /* End TabHeaderSkin */
1620 
1621     private static final PseudoClass SELECTED_PSEUDOCLASS_STATE =
1622             PseudoClass.getPseudoClass(&quot;selected&quot;);
1623     private static final PseudoClass TOP_PSEUDOCLASS_STATE =
1624             PseudoClass.getPseudoClass(&quot;top&quot;);
1625     private static final PseudoClass BOTTOM_PSEUDOCLASS_STATE =
1626             PseudoClass.getPseudoClass(&quot;bottom&quot;);
1627     private static final PseudoClass LEFT_PSEUDOCLASS_STATE =
1628             PseudoClass.getPseudoClass(&quot;left&quot;);
1629     private static final PseudoClass RIGHT_PSEUDOCLASS_STATE =
1630             PseudoClass.getPseudoClass(&quot;right&quot;);
1631     private static final PseudoClass DISABLED_PSEUDOCLASS_STATE =
1632             PseudoClass.getPseudoClass(&quot;disabled&quot;);
1633 
1634 
1635     /**************************************************************************
1636      *
1637      * TabContentRegion: each tab has one to contain the tab&#39;s content node
1638      *
1639      **************************************************************************/
1640     static class TabContentRegion extends StackPane {
1641 
1642         private Tab tab;
1643 
1644         private InvalidationListener tabContentListener = valueModel -&gt; {
1645             updateContent();
1646         };
1647         private InvalidationListener tabSelectedListener = new InvalidationListener() {
1648             @Override public void invalidated(Observable valueModel) {
1649                 setVisible(tab.isSelected());
1650             }
1651         };
1652 
1653         private WeakInvalidationListener weakTabContentListener =
1654                 new WeakInvalidationListener(tabContentListener);
1655         private WeakInvalidationListener weakTabSelectedListener =
1656                 new WeakInvalidationListener(tabSelectedListener);
1657 
1658         public Tab getTab() {
1659             return tab;
1660         }
1661 
1662         public TabContentRegion(Tab tab) {
1663             getStyleClass().setAll(&quot;tab-content-area&quot;);
1664             setManaged(false);
1665             this.tab = tab;
1666             updateContent();
1667             setVisible(tab.isSelected());
1668 
1669             tab.selectedProperty().addListener(weakTabSelectedListener);
1670             tab.contentProperty().addListener(weakTabContentListener);
1671         }
1672 
1673         private void updateContent() {
1674             Node newContent = getTab().getContent();
1675             if (newContent == null) {
1676                 getChildren().clear();
1677             } else {
1678                 getChildren().setAll(newContent);
1679             }
1680         }
1681 
1682         private void removeListeners(Tab tab) {
1683             tab.selectedProperty().removeListener(weakTabSelectedListener);
1684             tab.contentProperty().removeListener(weakTabContentListener);
1685         }
1686 
1687     } /* End TabContentRegion */
1688 
1689     /**************************************************************************
1690      *
1691      * TabControlButtons: controls to manipulate tab interaction
1692      *
1693      **************************************************************************/
1694     class TabControlButtons extends StackPane {
1695         private StackPane inner;
1696         private StackPane downArrow;
1697         private Pane downArrowBtn;
1698         private boolean showControlButtons;
1699         private ContextMenu popup;
1700 
1701         public TabControlButtons() {
1702             getStyleClass().setAll(&quot;control-buttons-tab&quot;);
1703 
1704             TabPane tabPane = getSkinnable();
1705 
1706             downArrowBtn = new Pane();
1707             downArrowBtn.getStyleClass().setAll(&quot;tab-down-button&quot;);
1708             downArrowBtn.setVisible(isShowTabsMenu());
1709             downArrow = new StackPane();
1710             downArrow.setManaged(false);
1711             downArrow.getStyleClass().setAll(&quot;arrow&quot;);
1712             downArrow.setRotate(tabPane.getSide().equals(Side.BOTTOM) ? 180.0F : 0.0F);
1713             downArrowBtn.getChildren().add(downArrow);
1714             downArrowBtn.setOnMouseClicked(me -&gt; {
1715                 showPopupMenu();
1716             });
1717 
1718             setupPopupMenu();
1719 
1720             inner = new StackPane() {
1721                 @Override protected double computePrefWidth(double height) {
1722                     double pw;
1723                     double maxArrowWidth = ! isShowTabsMenu() ? 0 : snapSize(downArrow.prefWidth(getHeight())) + snapSize(downArrowBtn.prefWidth(getHeight()));
1724                     pw = 0.0F;
1725                     if (isShowTabsMenu()) {
1726                         pw += maxArrowWidth;
1727                     }
1728                     if (pw &gt; 0) {
1729                         pw += snappedLeftInset() + snappedRightInset();
1730                     }
1731                     return pw;
1732                 }
1733 
1734                 @Override protected double computePrefHeight(double width) {
1735                     double height = 0.0F;
1736                     if (isShowTabsMenu()) {
1737                         height = Math.max(height, snapSize(downArrowBtn.prefHeight(width)));
1738                     }
1739                     if (height &gt; 0) {
1740                         height += snappedTopInset() + snappedBottomInset();
1741                     }
1742                     return height;
1743                 }
1744 
1745                 @Override protected void layoutChildren() {
1746                     if (isShowTabsMenu()) {
1747                         double x = 0;
1748                         double y = snappedTopInset();
1749                         double w = snapSize(getWidth()) - x + snappedLeftInset();
1750                         double h = snapSize(getHeight()) - y + snappedBottomInset();
1751                         positionArrow(downArrowBtn, downArrow, x, y, w, h);
1752                     }
1753                 }
1754 
1755                 private void positionArrow(Pane btn, StackPane arrow, double x, double y, double width, double height) {
1756                     btn.resize(width, height);
1757                     positionInArea(btn, x, y, width, height, /*baseline ignored*/0,
1758                             HPos.CENTER, VPos.CENTER);
1759                     // center arrow region within arrow button
1760                     double arrowWidth = snapSize(arrow.prefWidth(-1));
1761                     double arrowHeight = snapSize(arrow.prefHeight(-1));
1762                     arrow.resize(arrowWidth, arrowHeight);
1763                     positionInArea(arrow, btn.snappedLeftInset(), btn.snappedTopInset(),
1764                             width - btn.snappedLeftInset() - btn.snappedRightInset(),
1765                             height - btn.snappedTopInset() - btn.snappedBottomInset(),
1766                             /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
1767                 }
1768             };
1769             inner.getStyleClass().add(&quot;container&quot;);
1770             inner.getChildren().add(downArrowBtn);
1771 
1772             getChildren().add(inner);
1773 
1774             tabPane.sideProperty().addListener(valueModel -&gt; {
1775                 Side tabPosition = getSkinnable().getSide();
1776                 downArrow.setRotate(tabPosition.equals(Side.BOTTOM)? 180.0F : 0.0F);
1777             });
1778             tabPane.getTabs().addListener((ListChangeListener&lt;Tab&gt;) c -&gt; setupPopupMenu());
1779             showControlButtons = false;
1780             if (isShowTabsMenu()) {
1781                 showControlButtons = true;
1782                 requestLayout();
1783             }
1784             getProperties().put(ContextMenu.class, popup);
1785         }
1786 
1787         private boolean showTabsMenu = false;
1788 
1789         private void showTabsMenu(boolean value) {
1790             final boolean wasTabsMenuShowing = isShowTabsMenu();
1791             this.showTabsMenu = value;
1792 
1793             if (showTabsMenu &amp;&amp; !wasTabsMenuShowing) {
1794                 downArrowBtn.setVisible(true);
1795                 showControlButtons = true;
1796                 inner.requestLayout();
1797                 tabHeaderArea.requestLayout();
1798             } else if (!showTabsMenu &amp;&amp; wasTabsMenuShowing) {
1799                 hideControlButtons();
1800             }
1801         }
1802 
1803         private boolean isShowTabsMenu() {
1804             return showTabsMenu;
1805         }
1806 
1807         @Override protected double computePrefWidth(double height) {
1808             double pw = snapSize(inner.prefWidth(height));
1809             if (pw &gt; 0) {
1810                 pw += snappedLeftInset() + snappedRightInset();
1811             }
1812             return pw;
1813         }
1814 
1815         @Override protected double computePrefHeight(double width) {
1816             return Math.max(getSkinnable().getTabMinHeight(), snapSize(inner.prefHeight(width))) +
1817                     snappedTopInset() + snappedBottomInset();
1818         }
1819 
1820         @Override protected void layoutChildren() {
1821             double x = snappedLeftInset();
1822             double y = snappedTopInset();
1823             double w = snapSize(getWidth()) - x + snappedRightInset();
1824             double h = snapSize(getHeight()) - y + snappedBottomInset();
1825 
1826             if (showControlButtons) {
1827                 showControlButtons();
1828                 showControlButtons = false;
1829             }
1830 
1831             inner.resize(w, h);
1832             positionInArea(inner, x, y, w, h, /*baseline ignored*/0, HPos.CENTER, VPos.BOTTOM);
1833         }
1834 
1835         private void showControlButtons() {
1836             setVisible(true);
1837             if (popup == null) {
1838                 setupPopupMenu();
1839             }
1840         }
1841 
1842         private void hideControlButtons() {
1843             // If the scroll arrows or tab menu is still visible we don&#39;t want
1844             // to hide it animate it back it.
1845             if (isShowTabsMenu()) {
1846                 showControlButtons = true;
1847             } else {
1848                 setVisible(false);
1849                 clearPopupMenu();
1850                 popup = null;
1851             }
1852 
1853             // This needs to be called when we are in the left tabPosition
1854             // to allow for the clip offset to move properly (otherwise
1855             // it jumps too early - before the animation is done).
1856             requestLayout();
1857         }
1858 
1859         private void setupPopupMenu() {
1860             if (popup == null) {
1861                 popup = new ContextMenu();
1862             }
1863             clearPopupMenu();
1864             ToggleGroup group = new ToggleGroup();
1865             ObservableList&lt;RadioMenuItem&gt; menuitems = FXCollections.&lt;RadioMenuItem&gt;observableArrayList();
1866             for (final Tab tab : getSkinnable().getTabs()) {
1867                 TabMenuItem item = new TabMenuItem(tab);
1868                 item.setToggleGroup(group);
1869                 item.setOnAction(t -&gt; getSkinnable().getSelectionModel().select(tab));
1870                 menuitems.add(item);
1871             }
1872             popup.getItems().addAll(menuitems);
1873         }
1874 
1875         private void clearPopupMenu() {
1876             for (MenuItem item : popup.getItems()) {
1877                 ((TabMenuItem) item).dispose();
1878             }
1879             popup.getItems().clear();
1880         }
1881 
1882         private void showPopupMenu() {
1883             for (MenuItem mi: popup.getItems()) {
1884                 TabMenuItem tmi = (TabMenuItem)mi;
1885                 if (selectedTab.equals(tmi.getTab())) {
1886                     tmi.setSelected(true);
1887                     break;
1888                 }
1889             }
1890             popup.show(downArrowBtn, Side.BOTTOM, 0, 0);
1891         }
1892     } /* End TabControlButtons*/
1893 
1894     static class TabMenuItem extends RadioMenuItem {
1895         Tab tab;
1896 
1897         private InvalidationListener disableListener = new InvalidationListener() {
1898             @Override public void invalidated(Observable o) {
1899                 setDisable(tab.isDisable());
1900             }
1901         };
1902 
1903         private WeakInvalidationListener weakDisableListener =
1904                 new WeakInvalidationListener(disableListener);
1905 
1906         public TabMenuItem(final Tab tab) {
1907             super(tab.getText(), TabPaneSkin.clone(tab.getGraphic()));
1908             this.tab = tab;
1909             setDisable(tab.isDisable());
1910             tab.disableProperty().addListener(weakDisableListener);
1911             textProperty().bind(tab.textProperty());
1912         }
1913 
1914         public Tab getTab() {
1915             return tab;
1916         }
1917 
1918         public void dispose() {
1919             textProperty().unbind();
1920             tab.disableProperty().removeListener(weakDisableListener);
1921             tab = null;
1922         }
1923     }
1924 
1925     @Override
1926     public Object queryAccessibleAttribute(AccessibleAttribute attribute, Object... parameters) {
1927         switch (attribute) {
1928             case FOCUS_ITEM: return tabHeaderArea.getTabHeaderSkin(selectedTab);
1929             case ITEM_COUNT: return tabHeaderArea.headersRegion.getChildren().size();
1930             case ITEM_AT_INDEX: {
1931                 Integer index = (Integer)parameters[0];
1932                 if (index == null) return null;
1933                 return tabHeaderArea.headersRegion.getChildren().get(index);
1934             }
1935             default: return super.queryAccessibleAttribute(attribute, parameters);
1936         }
1937     }
1938 
1939     // --------------------------
1940     // Tab Reordering
1941     // --------------------------
1942     private enum DragState {
1943         NONE,
1944         START,
1945         REORDER
1946     }
1947     private EventHandler&lt;MouseEvent&gt; headerDraggedHandler = this::handleHeaderDragged;
1948     private EventHandler&lt;MouseEvent&gt; headerMousePressedHandler = this::handleHeaderMousePressed;
1949     private EventHandler&lt;MouseEvent&gt; headerMouseReleasedHandler = this::handleHeaderMouseReleased;
1950 
1951     private int dragTabHeaderStartIndex;
1952     private int dragTabHeaderIndex;
1953     private TabHeaderSkin dragTabHeader;
1954     private TabHeaderSkin dropTabHeader;
1955     private StackPane headersRegion;
1956     private DragState dragState;
1957     private final int MIN_TO_MAX = 1;
1958     private final int MAX_TO_MIN = -1;
1959     private int xLayoutDirection;
1960     private double dragEventPrevLoc;
1961     private int prevDragDirection = MIN_TO_MAX;
1962     private final double DRAG_DIST_THRESHOLD = 0.75;
1963 
1964     // Reordering Animation
1965     private final double ANIM_DURATION = 120;
1966     private TabHeaderSkin dropAnimHeader;
1967     private double dropHeaderSourceX;
1968     private double dropHeaderTransitionX;
1969     private final Animation dropHeaderAnim = new Transition() {
1970         {
1971             setInterpolator(Interpolator.EASE_BOTH);
1972             setCycleDuration(Duration.millis(ANIM_DURATION));
1973             setOnFinished(event -&gt; {
1974                 completeHeaderReordering();
1975             });
1976         }
1977         protected void interpolate(double frac) {
1978             dropAnimHeader.setLayoutX(dropHeaderSourceX + dropHeaderTransitionX * frac);
1979         }
1980     };
1981     private double dragHeaderDestX;
1982     private double dragHeaderSourceX;
1983     private double dragHeaderTransitionX;
1984     private final Animation dragHeaderAnim = new Transition() {
1985         {
1986             setInterpolator(Interpolator.EASE_OUT);
1987             setCycleDuration(Duration.millis(ANIM_DURATION));
1988             setOnFinished(event -&gt; {
1989                 reorderTabs();
1990                 resetDrag();
1991             });
1992         }
1993         protected void interpolate(double frac) {
1994             dragTabHeader.setLayoutX(dragHeaderSourceX + dragHeaderTransitionX * frac);
1995         }
1996     };
1997 
1998     // Helper methods for managing the listeners based on TabDragPolicy.
1999     private void addReorderListeners(Node n) {
2000         n.addEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
2001         n.addEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
2002         n.addEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
2003     }
2004 
2005     private void removeReorderListeners(Node n) {
2006         n.removeEventHandler(MouseEvent.MOUSE_PRESSED, headerMousePressedHandler);
2007         n.removeEventHandler(MouseEvent.MOUSE_RELEASED, headerMouseReleasedHandler);
2008         n.removeEventHandler(MouseEvent.MOUSE_DRAGGED, headerDraggedHandler);
2009     }
2010 
2011     private ListChangeListener childListener = new ListChangeListener&lt;Node&gt;() {
2012         public void onChanged(Change&lt;? extends Node&gt; change) {
2013             while (change.next()) {
2014                 if (change.wasAdded()) {
2015                     for(Node n : change.getAddedSubList()) {
2016                         addReorderListeners(n);
2017                     }
2018                 }
2019                 if (change.wasRemoved()) {
2020                     for(Node n : change.getRemoved()) {
2021                         removeReorderListeners(n);
2022                     }
2023                 }
2024             }
2025         }
2026     };
2027 
2028     private void updateListeners() {
2029         if (getSkinnable().getTabDragPolicy() == TabDragPolicy.FIXED ||
2030                 getSkinnable().getTabDragPolicy() == null) {
2031             for (Node n : headersRegion.getChildren()) {
2032                 removeReorderListeners(n);
2033             }
2034             headersRegion.getChildren().removeListener(childListener);
2035         } else if (getSkinnable().getTabDragPolicy() == TabDragPolicy.REORDER) {
2036             for (Node n : headersRegion.getChildren()) {
2037                 addReorderListeners(n);
2038             }
2039             headersRegion.getChildren().addListener(childListener);
2040         }
2041     }
2042 
2043     private void setupReordering(StackPane headersRegion) {
2044         dragState = DragState.NONE;
2045         this.headersRegion = headersRegion;
2046         updateListeners();
2047         getSkinnable().tabDragPolicyProperty().addListener((observable, oldValue, newValue) -&gt; {
2048             if (oldValue != newValue) {
2049                 updateListeners();
2050             }
2051         });
2052     }
2053 
2054     private void handleHeaderMousePressed(MouseEvent event) {
2055         if (event.getButton().equals(MouseButton.PRIMARY)) {
2056             ((StackPane) event.getSource()).setMouseTransparent(true);
2057             startDrag(event);
2058         }
2059     }
2060 
2061     private void handleHeaderMouseReleased(MouseEvent event) {
2062         if (event.getButton().equals(MouseButton.PRIMARY)) {
2063             ((StackPane) event.getSource()).setMouseTransparent(false);
2064             stopDrag();
2065             event.consume();
2066         }
2067     }
2068 
2069     private void handleHeaderDragged(MouseEvent event) {
2070         if (event.getButton().equals(MouseButton.PRIMARY)) {
2071             performDrag(event);
2072         }
2073     }
2074 
2075     private double getDragDelta(double curr, double prev) {
2076         if (getSkinnable().getSide().equals(Side.TOP) ||
2077                 getSkinnable().getSide().equals(Side.RIGHT)) {
2078             return curr - prev;
2079         } else {
2080             return prev - curr;
2081         }
2082     }
2083 
2084     private int deriveTabHeaderLayoutXDirection() {
2085         if (getSkinnable().getSide().equals(Side.TOP) ||
2086                 getSkinnable().getSide().equals(Side.RIGHT)) {
2087             // TabHeaderSkin are laid out in left to right direction inside headersRegion
2088             return MIN_TO_MAX;
2089         }
2090         // TabHeaderSkin are laid out in right to left direction inside headersRegion
2091         return MAX_TO_MIN;
2092     }
2093 
2094     private void performDrag(MouseEvent event) {
2095         if (dragState == DragState.NONE) {
2096             return;
2097         }
2098         int dragDirection;
2099         double dragHeaderNewLayoutX;
2100         Bounds dragHeaderBounds;
2101         Bounds dropHeaderBounds;
2102         double draggedDist;
2103         double mouseCurrentLoc = getHeaderRegionLocalX(event);
2104         double dragDelta = getDragDelta(mouseCurrentLoc, dragEventPrevLoc);
2105 
2106         if (dragDelta &gt; 0) {
2107             // Dragging the tab header towards higher indexed tab headers inside headersRegion.
2108             dragDirection = MIN_TO_MAX;
2109         } else {
2110             // Dragging the tab header towards lower indexed tab headers inside headersRegion.
2111             dragDirection = MAX_TO_MIN;
2112         }
2113         // Stop dropHeaderAnim if direction of drag is changed
2114         if (prevDragDirection != dragDirection) {
2115             stopAnim(dropHeaderAnim);
2116             prevDragDirection = dragDirection;
2117         }
2118 
2119         dragHeaderNewLayoutX = dragTabHeader.getLayoutX() + xLayoutDirection * dragDelta;
2120 
2121         if (dragHeaderNewLayoutX &gt;= 0 &amp;&amp;
2122                 dragHeaderNewLayoutX + dragTabHeader.getWidth() &lt;= headersRegion.getWidth()) {
2123 
2124             dragState = DragState.REORDER;
2125             dragTabHeader.setLayoutX(dragHeaderNewLayoutX);
2126             dragHeaderBounds = dragTabHeader.getBoundsInParent();
2127 
2128             if (dragDirection == MIN_TO_MAX) {
2129                 // Dragging the tab header towards higher indexed tab headers
2130                 // Last tab header can not be dragged outside headersRegion.
2131 
2132                 // When the mouse is moved too fast, sufficient number of events
2133                 // are not generated. Hence it is required to check all possible
2134                 // headers to be reordered.
2135                 for (int i = dragTabHeaderIndex + 1; i &lt; headersRegion.getChildren().size(); i++) {
2136                     dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);
2137 
2138                     // dropTabHeader should not be already reordering.
2139                     if (dropAnimHeader != dropTabHeader) {
2140                         dropHeaderBounds = dropTabHeader.getBoundsInParent();
2141 
2142                         if (xLayoutDirection == MIN_TO_MAX) {
2143                             draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
2144                         } else {
2145                             draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
2146                         }
2147 
2148                         // A tab header is reordered when dragged tab header crosses DRAG_DIST_THRESHOLD% of next tab header&#39;s width.
2149                         if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
2150                             stopAnim(dropHeaderAnim);
2151                             // Distance by which tab header should be animated.
2152                             dropHeaderTransitionX = xLayoutDirection * -dragHeaderBounds.getWidth();
2153                             if (xLayoutDirection == MIN_TO_MAX) {
2154                                 dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
2155                             } else {
2156                                 dragHeaderDestX = dropHeaderBounds.getMinX();
2157                             }
2158                             startHeaderReorderingAnim();
2159                         } else {
2160                             break;
2161                         }
2162                     }
2163                 }
2164             } else {
2165                 // dragDirection is MAX_TO_MIN
2166                 // Dragging the tab header towards lower indexed tab headers.
2167                 // First tab header can not be dragged outside headersRegion.
2168 
2169                 // When the mouse is moved too fast, sufficient number of events
2170                 // are not generated. Hence it is required to check all possible
2171                 // tab headers to be reordered.
2172                 for (int i = dragTabHeaderIndex - 1; i &gt;= 0; i--) {
2173                     dropTabHeader = (TabHeaderSkin) headersRegion.getChildren().get(i);
2174 
2175                     // dropTabHeader should not be already reordering.
2176                     if (dropAnimHeader != dropTabHeader) {
2177                         dropHeaderBounds = dropTabHeader.getBoundsInParent();
2178 
2179                         if (xLayoutDirection == MIN_TO_MAX) {
2180                             draggedDist = dropHeaderBounds.getMaxX() - dragHeaderBounds.getMinX();
2181                         } else {
2182                             draggedDist = dragHeaderBounds.getMaxX() - dropHeaderBounds.getMinX();
2183                         }
2184 
2185                         // A tab header is reordered when dragged tab crosses DRAG_DIST_THRESHOLD% of next tab header&#39;s width.
2186                         if (draggedDist &gt; dropHeaderBounds.getWidth() * DRAG_DIST_THRESHOLD) {
2187                             stopAnim(dropHeaderAnim);
2188                             // Distance by which tab header should be animated.
2189                             dropHeaderTransitionX = xLayoutDirection * dragHeaderBounds.getWidth();
2190                             if (xLayoutDirection == MIN_TO_MAX) {
2191                                 dragHeaderDestX = dropHeaderBounds.getMinX();
2192                             } else {
2193                                 dragHeaderDestX = dropHeaderBounds.getMaxX() - dragHeaderBounds.getWidth();
2194                             }
2195                             startHeaderReorderingAnim();
2196                         } else {
2197                             break;
2198                         }
2199                     }
2200                 }
2201             }
2202         }
2203         dragEventPrevLoc = mouseCurrentLoc;
2204         event.consume();
2205     }
2206 
2207     private void startDrag(MouseEvent event) {
2208         // Stop the animations if any are running from previous reorder.
2209         stopAnim(dropHeaderAnim);
2210         stopAnim(dragHeaderAnim);
2211 
2212         dragTabHeader = (TabHeaderSkin) event.getSource();
2213         if (dragTabHeader != null) {
2214             dragState = DragState.START;
2215             xLayoutDirection = deriveTabHeaderLayoutXDirection();
2216             dragEventPrevLoc = getHeaderRegionLocalX(event);
2217             dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
2218             dragTabHeaderStartIndex = dragTabHeaderIndex;
2219             dragTabHeader.setViewOrder(0);
2220             dragHeaderDestX = dragTabHeader.getLayoutX();
2221         }
2222     }
2223 
2224     private double getHeaderRegionLocalX(MouseEvent ev) {
2225         // The event is converted to tab header&#39;s parent i.e. headersRegion&#39;s local space.
2226         // This will provide a value of X co-ordinate with all transformations of TabPane
2227         // and transformations of all nodes in the TabPane&#39;s parent hierarchy.
2228         Point2D sceneToLocalHR = headersRegion.sceneToLocal(ev.getSceneX(), ev.getSceneY());
2229         return sceneToLocalHR.getX();
2230     }
2231 
2232     private void stopDrag() {
2233         if (dragState == DragState.START) {
2234             // No drag action was performed.
2235             resetDrag();
2236         } else if (dragState == DragState.REORDER) {
2237             // Animate tab header being dragged to its final position.
2238             dragHeaderSourceX = dragTabHeader.getLayoutX();
2239             dragHeaderTransitionX = dragHeaderDestX - dragHeaderSourceX;
2240             dragHeaderAnim.playFromStart();
2241         }
2242     }
2243 
2244     private void reorderTabs() {
2245         if (dragTabHeaderIndex != dragTabHeaderStartIndex) {
2246             ((TabObservableList&lt;Tab&gt;) getSkinnable().getTabs()).reorder(
2247                     getSkinnable().getTabs().get(dragTabHeaderStartIndex),
2248                     getSkinnable().getTabs().get(dragTabHeaderIndex));
2249         }
2250     }
2251 
2252     private void resetDrag() {
2253         dragState = DragState.NONE;
2254         dragTabHeader.setViewOrder(1);
2255         dragTabHeader = null;
2256         dropTabHeader = null;
2257         headersRegion.requestLayout();
2258     }
2259 
2260     // Animate tab header being dropped-on to its new position.
2261     private void startHeaderReorderingAnim() {
2262         dropAnimHeader = dropTabHeader;
2263         dropHeaderSourceX = dropAnimHeader.getLayoutX();
2264         dropHeaderAnim.playFromStart();
2265     }
2266 
2267     // Remove dropAnimHeader and add at the index position of dragTabHeader.
2268     private void completeHeaderReordering() {
2269         if (dropAnimHeader != null) {
2270             headersRegion.getChildren().remove(dropAnimHeader);
2271             headersRegion.getChildren().add(dragTabHeaderIndex, dropAnimHeader);
2272             dropAnimHeader = null;
2273             headersRegion.requestLayout();
2274             dragTabHeaderIndex = headersRegion.getChildren().indexOf(dragTabHeader);
2275         }
2276     }
2277 
2278     // Helper method to stop an animation.
2279     private void stopAnim(Animation anim) {
2280         if (anim.getStatus() == Animation.Status.RUNNING) {
2281             anim.getOnFinished().handle(null);
2282             anim.stop();
2283         }
2284     }
2285 
2286     // For testing purpose.
2287     ContextMenu test_getTabsMenu() {
2288         return tabHeaderArea.controlButtons.popup;
2289     }
2290 }
    </pre>
  </body>
</html>
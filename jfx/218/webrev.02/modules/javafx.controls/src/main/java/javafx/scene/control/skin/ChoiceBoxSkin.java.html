<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.controls/src/main/java/javafx/scene/control/skin/ChoiceBoxSkin.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javafx.scene.control.skin;
 27 
 28 import com.sun.javafx.scene.control.ContextMenuContent;
 29 import com.sun.javafx.scene.control.behavior.BehaviorBase;
 30 import javafx.beans.WeakInvalidationListener;
 31 import javafx.scene.control.Control;
 32 import javafx.scene.control.SkinBase;
 33 import javafx.util.StringConverter;
 34 import javafx.beans.InvalidationListener;
 35 import javafx.collections.ListChangeListener;
 36 import javafx.collections.ObservableList;
 37 import javafx.geometry.HPos;
 38 import javafx.geometry.Side;
 39 import javafx.geometry.VPos;
 40 import javafx.scene.control.ChoiceBox;
 41 import javafx.scene.control.ContextMenu;
 42 import javafx.scene.control.Label;
 43 import javafx.scene.control.MenuItem;
 44 import javafx.scene.control.RadioMenuItem;
 45 import javafx.scene.control.SelectionModel;
 46 import javafx.scene.control.Separator;
 47 import javafx.scene.control.SeparatorMenuItem;
 48 import javafx.scene.control.ToggleGroup;
 49 import javafx.scene.layout.StackPane;
 50 import javafx.scene.text.Text;
 51 
 52 import com.sun.javafx.scene.control.behavior.ChoiceBoxBehavior;
 53 import javafx.collections.WeakListChangeListener;
 54 
 55 
 56 /**
 57  * Default skin implementation for the {@link ChoiceBox} control.
 58  *
 59  * @see ChoiceBox
 60  * @since 9
 61  */
 62 public class ChoiceBoxSkin&lt;T&gt; extends SkinBase&lt;ChoiceBox&lt;T&gt;&gt; {
 63 
 64     /***************************************************************************
 65      *                                                                         *
 66      * Private fields                                                          *
 67      *                                                                         *
 68      **************************************************************************/
 69 
 70     private ObservableList&lt;T&gt; choiceBoxItems;
 71 
 72     private ContextMenu popup;
 73 
 74     // The region that shows the &quot;arrow&quot; box portion
 75     private StackPane openButton;
 76 
 77     private final ToggleGroup toggleGroup = new ToggleGroup();
 78 
 79     /*
 80      * Watch for if the user changes the selected index, and if so, we toggle
 81      * the selection in the toggle group (so the check shows in the right place)
 82      */
 83     private SelectionModel&lt;T&gt; selectionModel;
 84 
 85     private Label label;
 86 
 87     private final BehaviorBase&lt;ChoiceBox&lt;T&gt;&gt; behavior;
 88 
 89 
 90 
 91     /***************************************************************************
 92      *                                                                         *
 93      * Listeners                                                               *
 94      *                                                                         *
 95      **************************************************************************/
 96 
 97     private final ListChangeListener&lt;T&gt; choiceBoxItemsListener = new ListChangeListener&lt;T&gt;() {
 98         @Override public void onChanged(Change&lt;? extends T&gt; c) {
 99             while (c.next()) {
100                 if (c.getRemovedSize() &gt; 0 || c.wasPermutated()) {
101                     toggleGroup.getToggles().clear();
102                     popup.getItems().clear();
103                     int i = 0;
104                     for (T obj : c.getList()) {
105                         addPopupItem(obj, i);
106                         i++;
107                     }
108                 } else {
109                     for (int i = c.getFrom(); i &lt; c.getTo(); i++) {
110                         final T obj = c.getList().get(i);
111                         addPopupItem(obj, i);
112                     }
113                 }
114             }
115             updateSelection();
116             getSkinnable().requestLayout(); // RT-18052 resize of choicebox should happen immediately.
117         }
118     };
119 
120     private final WeakListChangeListener&lt;T&gt; weakChoiceBoxItemsListener =
121             new WeakListChangeListener&lt;T&gt;(choiceBoxItemsListener);
122 
123     private final InvalidationListener itemsObserver;
124 
125 
126 
127     /***************************************************************************
128      *                                                                         *
129      * Constructors                                                            *
130      *                                                                         *
131      **************************************************************************/
132 
133     /**
134      * Creates a new ChoiceBoxSkin instance, installing the necessary child
135      * nodes into the Control {@link Control#getChildren() children} list, as
136      * well as the necessary input mappings for handling key, mouse, etc events.
137      *
138      * @param control The control that this skin should be installed onto.
139      */
140     public ChoiceBoxSkin(ChoiceBox&lt;T&gt; control) {
141         super(control);
142 
143         // install default input map for the ChoiceBox control
144         behavior = new ChoiceBoxBehavior&lt;&gt;(control);
145 //        control.setInputMap(behavior.getInputMap());
146 
147         initialize();
148 
149         itemsObserver = observable -&gt; updateChoiceBoxItems();
150         control.itemsProperty().addListener(new WeakInvalidationListener(itemsObserver));
151 
152         control.requestLayout();
153         registerChangeListener(control.selectionModelProperty(), e -&gt; updateSelectionModel());
154         registerChangeListener(control.showingProperty(), e -&gt; {
155             if (getSkinnable().isShowing()) {
156 
157                 SelectionModel&lt;T&gt; sm = getSkinnable().getSelectionModel();
158                 if (sm == null) return;
159 
160                 long currentSelectedIndex = sm.getSelectedIndex();
161 
162                 // This is a fix for RT-9071. Ideally this won&#39;t be necessary in
163                 // the long-run, but for now at least this resolves the
164                 // positioning
165                 // problem of ChoiceBox inside a Cell.
166                 getSkinnable().autosize();
167                 // -- End of RT-9071 fix
168 
169                 double y = 0;
170 
171                 if (popup.getSkin() != null) {
172                     ContextMenuContent cmContent = (ContextMenuContent)popup.getSkin().getNode();
173                     if (cmContent != null &amp;&amp; currentSelectedIndex != -1) {
174                         y = -(cmContent.getMenuYOffset((int)currentSelectedIndex));
175                     }
176                 }
177 
178                 popup.show(getSkinnable(), Side.BOTTOM, 2, y);
179             } else {
180                 popup.hide();
181             }
182         });
183         registerChangeListener(control.itemsProperty(), e -&gt; {
184             updateChoiceBoxItems();
185             updatePopupItems();
186             updateSelectionModel();
187             updateSelection();
188         });
189         registerChangeListener(control.converterProperty(), e -&gt; {
190             updateChoiceBoxItems();
191             updatePopupItems();
192             updateLabelText();
193         });
194         registerChangeListener(control.valueProperty(), e -&gt; {
195             updateLabelText();
196         });
197     }
198 
199 
200 
201     /***************************************************************************
202      *                                                                         *
203      * Public API                                                              *
204      *                                                                         *
205      **************************************************************************/
206 
207     /** {@inheritDoc} */
208     @Override public void dispose() {
209          // removing the content listener fixes NPE from listener
210         if (choiceBoxItems != null) {
211             choiceBoxItems.removeListener(weakChoiceBoxItemsListener);
212             choiceBoxItems = null;
213         }
214         // removing the path listener fixes the memory leak on replacing skin
215         if (selectionModel != null) {
216             selectionModel.selectedIndexProperty().removeListener(selectionChangeListener);
217             selectionModel = null;
218         }
219 
220         super.dispose();
221 
222         if (behavior != null) {
223             behavior.dispose();
224         }
225     }
226 
227     /** {@inheritDoc} */
228     @Override protected void layoutChildren(final double x, final double y,
229                                             final double w, final double h) {
230         // open button width/height
231         double obw = openButton.prefWidth(-1);
232 
233         label.resizeRelocate(x, y, w, h);
234         openButton.resize(obw, openButton.prefHeight(-1));
235         positionInArea(openButton, (x+w) - obw,
236                 y, obw, h, /*baseline ignored*/0, HPos.CENTER, VPos.CENTER);
237     }
238 
239     /** {@inheritDoc} */
240     @Override protected double computeMinWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
241         final double boxWidth = label.minWidth(-1) + openButton.minWidth(-1);
242         final double popupWidth = popup.minWidth(-1);
243         return leftInset + Math.max(boxWidth, popupWidth) + rightInset;
244     }
245 
246     /** {@inheritDoc} */
247     @Override protected double computeMinHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
248         final double displayHeight = label.minHeight(-1);
249         final double openButtonHeight = openButton.minHeight(-1);
250         return topInset + Math.max(displayHeight, openButtonHeight) + bottomInset;
251     }
252 
253     /** {@inheritDoc} */
254     @Override protected double computePrefWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
255         final double boxWidth = label.prefWidth(-1)
256                 + openButton.prefWidth(-1);
257         double popupWidth = popup.prefWidth(-1);
258         if (popupWidth &lt;= 0) { // first time: when the popup has not shown yet
259             if (popup.getItems().size() &gt; 0){
260                 popupWidth = (new Text(((MenuItem)popup.getItems().get(0)).getText())).prefWidth(-1);
261             }
262         }
263         return (popup.getItems().size() == 0) ? 50 : leftInset + Math.max(boxWidth, popupWidth)
264                 + rightInset;
265     }
266 
267     /** {@inheritDoc} */
268     @Override protected double computePrefHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
269         final double displayHeight = label.prefHeight(-1);
270         final double openButtonHeight = openButton.prefHeight(-1);
271         return topInset
272                 + Math.max(displayHeight, openButtonHeight)
273                 + bottomInset;
274     }
275 
276     /** {@inheritDoc} */
277     @Override protected double computeMaxHeight(double width, double topInset, double rightInset, double bottomInset, double leftInset) {
278         return getSkinnable().prefHeight(width);
279     }
280 
281     /** {@inheritDoc} */
282     @Override protected double computeMaxWidth(double height, double topInset, double rightInset, double bottomInset, double leftInset) {
283         return getSkinnable().prefWidth(height);
284     }
285 
286 
287 
288     /***************************************************************************
289      *                                                                         *
290      * Private implementation                                                  *
291      *                                                                         *
292      **************************************************************************/
293 
294     private void initialize() {
295         updateChoiceBoxItems();
296 
297         label = new Label();
298         label.setMnemonicParsing(false);  // ChoiceBox doesn&#39;t do Mnemonics
299 
300         openButton = new StackPane();
301         openButton.getStyleClass().setAll(&quot;open-button&quot;);
302 
303         StackPane region = new StackPane();
304         region.getStyleClass().setAll(&quot;arrow&quot;);
305         openButton.getChildren().clear();
306         openButton.getChildren().addAll(region);
307 
308         popup = new ContextMenu();
309         // When popup is hidden by autohide - the ChoiceBox Showing property needs
310         // to be updated. So we listen to when autohide happens. Calling hide()
311         // there after causes Showing to be set to false
312         popup.showingProperty().addListener((o, ov, nv) -&gt; {
313             if (!nv) {
314                 getSkinnable().hide();
315             }
316         });
317         // This is used as a way of accessing the context menu within the ChoiceBox.
318         popup.setId(&quot;choice-box-popup-menu&quot;);
319 //        popup.getItems().clear();
320 //        popup.getItems().addAll(popupItems);
321 //        popup.setManaged(false);
322 //        popup.visibleProperty().addListener(new InvalidationListener() {
323 //            @Override public void invalidated(ObservableValue valueModel) {
324 //                if (popup.isVisible() {
325 ////                    RadioMenuItem selected = (RadioMenuItem) toggleGroup.getSelectedToggle();
326 ////                    if (selected != null) selected.requestFocus();
327 //                } else {
328 //                    getBehavior().close();
329 //                }
330 //            }
331 //        });
332         getChildren().setAll(label, openButton);
333 
334         updatePopupItems();
335 
336         updateSelectionModel();
337         updateSelection();
338         updateLabelText();
339     }
340 
341     private void updateLabelText() {
342         T value = getSkinnable().getValue();
343         label.setText(getDisplayText(value));
344     }
345 
346     private String getDisplayText(T value) {
347         if (getSkinnable().getConverter() != null) {
348             return getSkinnable().getConverter().toString(value);
349         }
350         return value == null ? &quot;&quot; : value.toString();
351     }
352 
353     private void updateChoiceBoxItems() {
354         if (choiceBoxItems != null) {
355             choiceBoxItems.removeListener(weakChoiceBoxItemsListener);
356         }
357         choiceBoxItems = getSkinnable().getItems();
358         if (choiceBoxItems != null) {
359             choiceBoxItems.addListener(weakChoiceBoxItemsListener);
360         }
361     }
362 
363     // Test only purpose
364     String getChoiceBoxSelectedText() {
365         return label.getText();
366     }
367 
368     // Test only purpose
369     ContextMenu getChoiceBoxPopup() {
370         return popup;
371     }
372 
373     private void addPopupItem(final T o, int i) {
374         MenuItem popupItem = null;
375         if (o instanceof Separator) {
376             // We translate the Separator into a SeparatorMenuItem...
377             popupItem = new SeparatorMenuItem();
378         } else if (o instanceof SeparatorMenuItem) {
379             popupItem = (SeparatorMenuItem) o;
380         } else {
381             final RadioMenuItem item = new RadioMenuItem(getDisplayText(o));
382             item.setId(&quot;choice-box-menu-item&quot;);
383             item.setToggleGroup(toggleGroup);
384             item.setOnAction(e -&gt; {
385                 if (selectionModel == null) return;
386                 int index = getSkinnable().getItems().indexOf(o);
387                 selectionModel.select(index);
388                 item.setSelected(true);
389             });
390             popupItem = item;
391         }
392         popupItem.setMnemonicParsing(false);   // ChoiceBox doesn&#39;t do Mnemonics
393         popup.getItems().add(i, popupItem);
394     }
395 
396     private void updatePopupItems() {
397         toggleGroup.getToggles().clear();
398         popup.getItems().clear();
399         toggleGroup.selectToggle(null);
400 
401         for (int i = 0; i &lt; choiceBoxItems.size(); i++) {
402             T o = choiceBoxItems.get(i);
403             addPopupItem(o, i);
404         }
405     }
406 
407     private void updateSelectionModel() {
408         if (selectionModel != null) {
409             selectionModel.selectedIndexProperty().removeListener(selectionChangeListener);
410         }
411         this.selectionModel = getSkinnable().getSelectionModel();
412         if (selectionModel != null) {
413             selectionModel.selectedIndexProperty().addListener(selectionChangeListener);
414         }
415     }
416 
417     private InvalidationListener selectionChangeListener = observable -&gt; {
418         updateSelection();
419     };
420 
421     private void updateSelection() {
422         if (selectionModel == null || selectionModel.isEmpty()) {
423             toggleGroup.selectToggle(null);
424          } else {
425             int selectedIndex = selectionModel.getSelectedIndex();
426             if (selectedIndex == -1 || selectedIndex &gt; popup.getItems().size()) {
427                 // FIXME: when do we get here?
428                 // and if, shouldn&#39;t we unselect the toggles?
429                 return;
430             }
431             if (selectedIndex &lt; popup.getItems().size()) {
432                 MenuItem selectedItem = popup.getItems().get(selectedIndex);
433                 if (selectedItem instanceof RadioMenuItem) {
434                     ((RadioMenuItem) selectedItem).setSelected(true);
435                 } else {
436                     // need to unselect toggles if selectionModel allows a Separator/MenuItem
437                     // to be selected
438                     toggleGroup.selectToggle(null);
439                 }
440             }
441         }
442     }
443 }
    </pre>
  </body>
</html>
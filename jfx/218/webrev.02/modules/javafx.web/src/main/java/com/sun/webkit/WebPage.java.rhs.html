<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/java/com/sun/webkit/WebPage.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.webkit;
  27 
  28 import javafx.application.ConditionalFeature;
  29 import javafx.application.Platform;
  30 import com.sun.glass.utils.NativeLibLoader;
  31 import com.sun.javafx.logging.PlatformLogger;
  32 import com.sun.javafx.logging.PlatformLogger.Level;
  33 import com.sun.webkit.event.WCFocusEvent;
  34 import com.sun.webkit.event.WCInputMethodEvent;
  35 import com.sun.webkit.event.WCKeyEvent;
  36 import com.sun.webkit.event.WCMouseEvent;
  37 import com.sun.webkit.event.WCMouseWheelEvent;
  38 import com.sun.webkit.graphics.*;
  39 import com.sun.webkit.network.CookieManager;
  40 import static com.sun.webkit.network.URLs.newURL;
  41 import java.net.CookieHandler;
  42 import java.net.MalformedURLException;
  43 import java.net.URL;
  44 import java.nio.ByteBuffer;
  45 import java.nio.ByteOrder;
  46 import java.security.AccessControlContext;
  47 import java.security.AccessController;
  48 import java.security.PrivilegedAction;
  49 import java.util.ArrayList;
  50 import java.util.HashMap;
  51 import java.util.HashSet;
  52 import java.util.Iterator;
  53 import java.util.LinkedList;
  54 import java.util.List;
  55 import java.util.Map;
  56 import java.util.Queue;
  57 import java.util.Set;
  58 import java.util.concurrent.CountDownLatch;
  59 import java.util.concurrent.ExecutionException;
  60 import java.util.concurrent.FutureTask;
  61 import java.util.concurrent.atomic.AtomicReference;
  62 import java.util.concurrent.locks.ReentrantLock;
  63 import netscape.javascript.JSException;
  64 import org.w3c.dom.Document;
  65 import org.w3c.dom.Element;
  66 
  67 /**
  68  * This class provides two-side interaction between native webkit core and
  69  * number of clients representing different subsystems of the WebPane component
  70  * such as
  71  * &lt;ul&gt;
  72  * &lt;li&gt;webpage rendering({@link WebPageClient})
  73  * &lt;li&gt;creating/disposing web frames ({@link WebFrameClient})
  74  * &lt;li&gt;creating new windows, alert dialogues ... ({@link UIClient})
  75  * &lt;li&gt;handling menus {@link MenuClient}
  76  * &lt;li&gt;supporting policy checking {@link PolicyClient}
  77  * &lt;/ul&gt;
  78  */
  79 
  80 public final class WebPage {
  81     private final static PlatformLogger log = PlatformLogger.getLogger(WebPage.class.getName());
  82     private final static PlatformLogger paintLog = PlatformLogger.getLogger(WebPage.class.getName() + &quot;.paint&quot;);
  83 
  84     private static final int MAX_FRAME_QUEUE_SIZE = 10;
  85 
  86     // Native WebPage* pointer
  87     private long pPage = 0;
  88 
  89     // A flag to distinguish whether the web page hasn&#39;t been created
  90     // yet or had been already disposed - in both cases pPage is 0
  91     private boolean isDisposed = false;
  92 
  93     private int width, height;
  94 
  95     private int fontSmoothingType;
  96 
  97     private final WCFrameView hostWindow;
  98 
  99     // List of created frames
 100     private final Set&lt;Long&gt; frames = new HashSet&lt;Long&gt;();
 101 
 102     // The access control context associated with this object
 103     private final AccessControlContext accessControlContext;
 104 
 105     // Maps load request identifiers to URLs
 106     private final Map&lt;Integer, String&gt; requestURLs =
 107             new HashMap&lt;Integer, String&gt;();
 108 
 109     // There may be several RESOURCE_STARTED events for a resource,
 110     // so this map is used to convert them to RESOURCE_REDIRECTED
 111     private final Set&lt;Integer&gt; requestStarted = new HashSet&lt;Integer&gt;();
 112 
 113     // PAGE_LOCK is used to synchronize the following operations b/w Event &amp; Main threads:
 114     // - rendering of the page (Main thread)
 115     // - native calls &amp; other manipulations on the page (Event &amp; Main threads)
 116     // - timer invocations (Event thread)
 117     private static final ReentrantLock PAGE_LOCK = new ReentrantLock();
 118 
 119     // The queue of render frames awaiting rendering.
 120     // Access to this object is synchronized on its monitor.
 121     // Accessed on: Event thread and Main thread.
 122     private final Queue&lt;RenderFrame&gt; frameQueue = new LinkedList&lt;RenderFrame&gt;();
 123 
 124     // The current frame being generated.
 125     // Accessed on: Event thread only.
 126     private RenderFrame currentFrame = new RenderFrame();
 127 
 128     // An ID of the current updateContent cycle associated with an updateContent call.
 129     private int updateContentCycleID;
 130 
 131     static {
 132         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 133             NativeLibLoader.loadLibrary(&quot;jfxwebkit&quot;);
 134             log.finer(&quot;jfxwebkit loaded&quot;);
 135 
 136             if (CookieHandler.getDefault() == null) {
 137                 boolean setDefault = Boolean.valueOf(System.getProperty(
 138                         &quot;com.sun.webkit.setDefaultCookieHandler&quot;,
 139                         &quot;true&quot;));
 140                 if (setDefault) {
 141                     CookieHandler.setDefault(new CookieManager());
 142                 }
 143             }
 144 
 145             final boolean useJIT = Boolean.valueOf(System.getProperty(
 146                     &quot;com.sun.webkit.useJIT&quot;, &quot;true&quot;));
 147             final boolean useDFGJIT = Boolean.valueOf(System.getProperty(
 148                     &quot;com.sun.webkit.useDFGJIT&quot;, &quot;true&quot;));
 149 
 150             // TODO: Enable CSS3D by default once it is stabilized.
 151             boolean useCSS3D = Boolean.valueOf(System.getProperty(
 152                     &quot;com.sun.webkit.useCSS3D&quot;, &quot;false&quot;));
 153             useCSS3D = useCSS3D &amp;&amp; Platform.isSupported(ConditionalFeature.SCENE3D);
 154 
 155             // Initialize WTF, WebCore and JavaScriptCore.
 156             twkInitWebCore(useJIT, useDFGJIT, useCSS3D);
 157             return null;
 158         });
 159 
 160     }
 161 
 162     private static boolean firstWebPageCreated = false;
 163 
 164     private static void collectJSCGarbages() {
 165         Invoker.getInvoker().checkEventThread();
 166         // Add dummy object to get notification as soon as it is collected
 167         // by the JVM GC.
 168         Disposer.addRecord(new Object(), WebPage::collectJSCGarbages);
 169         // Invoke JavaScriptCore GC.
 170         twkDoJSCGarbageCollection();
 171     }
 172 
 173     public WebPage(WebPageClient pageClient,
 174                    UIClient uiClient,
 175                    PolicyClient policyClient,
 176                    InspectorClient inspectorClient,
 177                    ThemeClient themeClient,
 178                    boolean editable)
 179     {
 180         Invoker.getInvoker().checkEventThread();
 181 
 182         this.pageClient = pageClient;
 183         this.uiClient = uiClient;
 184         this.policyClient = policyClient;
 185         this.inspectorClient = inspectorClient;
 186         if (themeClient != null) {
 187             this.renderTheme = themeClient.createRenderTheme();
 188             this.scrollbarTheme = themeClient.createScrollBarTheme();
 189         } else {
 190             this.renderTheme = null;
 191             this.scrollbarTheme = null;
 192         }
 193 
 194         accessControlContext = AccessController.getContext();
 195 
 196         hostWindow = new WCFrameView(this);
 197         pPage = twkCreatePage(editable);
 198 
 199         twkInit(pPage, false, WCGraphicsManager.getGraphicsManager().getDevicePixelScale());
 200 
 201         if (pageClient != null &amp;&amp; pageClient.isBackBufferSupported()) {
 202             backbuffer = pageClient.createBackBuffer();
 203             backbuffer.ref();
 204         }
 205 
 206         if (!firstWebPageCreated) {
 207             // Add dummy object to get notification as soon as it is collected
 208             // by the JVM GC.
 209             Disposer.addRecord(new Object(), WebPage::collectJSCGarbages);
 210             firstWebPageCreated = true;
 211         }
 212     }
 213 
 214     long getPage() {
 215         return pPage;
 216     }
 217 
 218     // Called from the native code
 219     private WCWidget getHostWindow() {
 220         return hostWindow;
 221     }
 222 
 223     /**
 224      * Returns the access control context associated with this object.
 225      * May be called on any thread.
 226      * @return the access control context associated with this object
 227      */
 228     public AccessControlContext getAccessControlContext() {
 229         return accessControlContext;
 230     }
 231 
 232     static boolean lockPage() {
 233         return Invoker.getInvoker().lock(PAGE_LOCK);
 234     }
 235 
 236     static boolean unlockPage() {
 237         return Invoker.getInvoker().unlock(PAGE_LOCK);
 238     }
 239 
 240     // *************************************************************************
 241     // Backbuffer support
 242     // *************************************************************************
 243 
 244     private WCPageBackBuffer backbuffer;
 245     private List&lt;WCRectangle&gt; dirtyRects = new LinkedList&lt;WCRectangle&gt;();
 246 
 247     private void addDirtyRect(WCRectangle toPaint) {
 248         if (toPaint.getWidth() &lt;= 0 || toPaint.getHeight() &lt;= 0) {
 249             return;
 250         }
 251         for (Iterator&lt;WCRectangle&gt; it = dirtyRects.iterator(); it.hasNext();) {
 252             WCRectangle rect = it.next();
 253             // if already covered
 254             if (rect.contains(toPaint)) {
 255                 return;
 256             }
 257             // if covers an existing one
 258             if (toPaint.contains(rect)) {
 259                 it.remove();
 260                 continue;
 261             }
 262             WCRectangle u = rect.createUnion(toPaint);
 263             // if squre of union is less than summary of squares
 264             if (u.getIntWidth() * u.getIntHeight() &lt;
 265                 rect.getIntWidth() * rect.getIntHeight() +
 266                 toPaint.getIntWidth() * toPaint.getIntHeight())
 267             {
 268                 it.remove();
 269                 toPaint = u; // replace both the rects with their union
 270                 continue;
 271             }
 272         }
 273         dirtyRects.add(toPaint);
 274     }
 275 
 276     public boolean isDirty() {
 277         lockPage();
 278         try {
 279             return !dirtyRects.isEmpty();
 280         } finally {
 281             unlockPage();
 282         }
 283     }
 284 
 285     private void updateDirty(WCRectangle clip) {
 286         if (paintLog.isLoggable(Level.FINEST)) {
 287             paintLog.finest(&quot;Entering, dirtyRects: {0}, currentFrame: {1}&quot;,
 288                     new Object[] {dirtyRects, currentFrame});
 289         }
 290 
 291         if (isDisposed || width &lt;= 0 || height &lt;= 0) {
 292             // If there&#39;re any dirty rects left, they are invalid.
 293             // Clear the list so that the platform doesn&#39;t consider
 294             // the page dirty.
 295             dirtyRects.clear();
 296             return;
 297         }
 298         if (clip == null) {
 299             clip = new WCRectangle(0, 0, width, height);
 300         }
 301         List&lt;WCRectangle&gt; oldDirtyRects = dirtyRects;
 302         dirtyRects = new LinkedList&lt;WCRectangle&gt;();
 303         twkPrePaint(getPage());
 304         while (!oldDirtyRects.isEmpty()) {
 305             WCRectangle r = oldDirtyRects.remove(0).intersection(clip);
 306             if (r.getWidth() &lt;= 0 || r.getHeight() &lt;= 0) {
 307                 continue;
 308             }
 309             paintLog.finest(&quot;Updating: {0}&quot;, r);
 310             WCRenderQueue rq = WCGraphicsManager.getGraphicsManager()
 311                     .createRenderQueue(r, true);
 312             twkUpdateContent(getPage(), rq, r.getIntX() - 1, r.getIntY() - 1,
 313                              r.getIntWidth() + 2, r.getIntHeight() + 2);
 314             currentFrame.addRenderQueue(rq);
 315         }
 316         {
 317             WCRenderQueue rq = WCGraphicsManager.getGraphicsManager()
 318                     .createRenderQueue(clip, false);
 319             twkPostPaint(getPage(), rq,
 320                          clip.getIntX(), clip.getIntY(),
 321                          clip.getIntWidth(), clip.getIntHeight());
 322             currentFrame.addRenderQueue(rq);
 323         }
 324 
 325         if (paintLog.isLoggable(Level.FINEST)) {
 326             paintLog.finest(&quot;Dirty rects processed, dirtyRects: {0}, currentFrame: {1}&quot;,
 327                     new Object[] {dirtyRects, currentFrame});
 328         }
 329 
 330         if (currentFrame.getRQList().size() &gt; 0) {
 331             synchronized (frameQueue) {
 332                 paintLog.finest(&quot;About to update frame queue, frameQueue: {0}&quot;, frameQueue);
 333 
 334                 Iterator&lt;RenderFrame&gt; it = frameQueue.iterator();
 335                 while (it.hasNext()) {
 336                     RenderFrame frame = it.next();
 337                     for (WCRenderQueue rq : currentFrame.getRQList()) {
 338                         WCRectangle rqRect = rq.getClip();
 339                         if (rq.isOpaque()
 340                                 &amp;&amp; rqRect.contains(frame.getEnclosingRect()))
 341                         {
 342                             paintLog.finest(&quot;Dropping: {0}&quot;, frame);
 343                             frame.drop();
 344                             it.remove();
 345                             break;
 346                         }
 347                     }
 348                 }
 349 
 350                 frameQueue.add(currentFrame);
 351                 currentFrame = new RenderFrame();
 352 
 353                 if (frameQueue.size() &gt; MAX_FRAME_QUEUE_SIZE) {
 354                     paintLog.finest(&quot;Frame queue exceeded maximum &quot;
 355                             + &quot;size, clearing and requesting full repaint&quot;);
 356                     dropRenderFrames();
 357                     repaintAll();
 358                 }
 359 
 360                 paintLog.finest(&quot;Frame queue updated, frameQueue: {0}&quot;, frameQueue);
 361             }
 362         }
 363 
 364         if (paintLog.isLoggable(Level.FINEST)) {
 365             paintLog.finest(&quot;Exiting, dirtyRects: {0}, currentFrame: {1}&quot;,
 366                     new Object[] {dirtyRects, currentFrame});
 367         }
 368     }
 369 
 370     private void scroll(int x, int y, int w, int h, int dx, int dy) {
 371         if (paintLog.isLoggable(Level.FINEST)) {
 372             paintLog.finest(&quot;rect=[&quot; + x + &quot;, &quot; + y + &quot; &quot; + w + &quot;x&quot; + h +
 373                             &quot;] delta=[&quot; + dx + &quot;, &quot; + dy + &quot;]&quot;);
 374         }
 375         dx += currentFrame.scrollDx;
 376         dy += currentFrame.scrollDy;
 377 
 378         if (Math.abs(dx) &lt; w &amp;&amp; Math.abs(dy) &lt; h) {
 379             int cx = (dx &gt;= 0) ? x : x - dx;
 380             int cy = (dy &gt;= 0) ? y : y - dy;
 381             int cw = (dx == 0) ? w : w - Math.abs(dx);
 382             int ch = (dy == 0) ? h : h - Math.abs(dy);
 383 
 384             WCRenderQueue rq = WCGraphicsManager.getGraphicsManager()
 385                     .createRenderQueue(
 386                             new WCRectangle(0, 0, width, height), false);
 387             ByteBuffer buffer = ByteBuffer.allocate(32)
 388                     .order(ByteOrder.nativeOrder())
 389                     .putInt(GraphicsDecoder.COPYREGION)
 390                     .putInt(backbuffer.getID())
 391                     .putInt(cx).putInt(cy).putInt(cw).putInt(ch)
 392                     .putInt(dx).putInt(dy);
 393             buffer.flip();
 394             rq.addBuffer(buffer);
 395             // Ignore previous COPYREGION
 396             currentFrame.drop();
 397             currentFrame.addRenderQueue(rq);
 398             currentFrame.scrollDx = dx;
 399             currentFrame.scrollDy = dy;
 400             // Now we have to translate &quot;old&quot; dirty rects that fit to the frame&#39;s
 401             // content as the content is already scrolled at the moment by webkit.
 402             if (!dirtyRects.isEmpty()) {
 403                 WCRectangle scrollRect = new WCRectangle(x, y, w, h);
 404                 for (WCRectangle r: dirtyRects) {
 405                     if (scrollRect.contains(r)) {
 406                         if (paintLog.isLoggable(Level.FINEST)) {
 407                             paintLog.finest(&quot;translating old dirty rect by the delta: &quot; + r);
 408                         }
 409                         r.translate(dx, dy);
 410                     }
 411                 }
 412             }
 413         }
 414 
 415         // Add the dirty (not copied) rects
 416         addDirtyRect(new WCRectangle(x, dy &gt;= 0 ? y : y + h + dy,
 417                                      w, Math.abs(dy)));
 418         addDirtyRect(new WCRectangle(dx &gt;= 0 ? x : x + w + dx, y,
 419                                      Math.abs(dx), h - Math.abs(dy)));
 420     }
 421 
 422     // Instances of this class may not be accessed and modified concurrently
 423     // by multiple threads
 424     private static final class RenderFrame {
 425         private final List&lt;WCRenderQueue&gt; rqList =
 426                 new LinkedList&lt;WCRenderQueue&gt;();
 427         private int scrollDx, scrollDy;
 428         private final WCRectangle enclosingRect = new WCRectangle();
 429 
 430         // Called on: Event thread only
 431         private void addRenderQueue(WCRenderQueue rq) {
 432             if (rq.isEmpty()) {
 433                 return;
 434             }
 435             rqList.add(rq);
 436             WCRectangle rqRect = rq.getClip();
 437             if (enclosingRect.isEmpty()) {
 438                 enclosingRect.setFrame(rqRect.getX(), rqRect.getY(),
 439                                        rqRect.getWidth(), rqRect.getHeight());
 440             } else if (rqRect.isEmpty()) {
 441                 // do nothing
 442             } else {
 443                 WCRectangle.union(enclosingRect, rqRect, enclosingRect);
 444             }
 445         }
 446 
 447         // Called on: Event thread and Main thread
 448         private List&lt;WCRenderQueue&gt; getRQList() {
 449             return rqList;
 450         }
 451 
 452         // Called on: Event thread only
 453         private WCRectangle getEnclosingRect() {
 454             return enclosingRect;
 455         }
 456 
 457         // Called on: Event thread only
 458         private void drop() {
 459             for (WCRenderQueue rq : rqList) {
 460                 rq.dispose();
 461             }
 462             rqList.clear();
 463             enclosingRect.setFrame(0, 0, 0, 0);
 464             scrollDx = 0;
 465             scrollDy = 0;
 466         }
 467 
 468         @Override
 469         public String toString() {
 470             return &quot;RenderFrame{&quot;
 471                     + &quot;rqList=&quot; + rqList + &quot;, &quot;
 472                     + &quot;enclosingRect=&quot; + enclosingRect
 473                     + &quot;}&quot;;
 474         }
 475     }
 476 
 477     // *************************************************************************
 478     // Callback API
 479     // *************************************************************************
 480 
 481     private final WebPageClient pageClient;
 482     private final UIClient uiClient;
 483     private final PolicyClient policyClient;
 484     private InputMethodClient imClient;
 485     private final List&lt;LoadListenerClient&gt; loadListenerClients =
 486         new LinkedList&lt;LoadListenerClient&gt;();
 487     private final InspectorClient inspectorClient;
 488     private final RenderTheme renderTheme;
 489     private final ScrollBarTheme scrollbarTheme;
 490 
 491     public WebPageClient getPageClient() {
 492         return pageClient;
 493     }
 494 
 495     public void setInputMethodClient(InputMethodClient imClient) {
 496         this.imClient = imClient;
 497     }
 498 
 499     public void setInputMethodState(boolean state) {
 500         if (imClient != null) {
 501             // A web page containing multiple clients is a single client from Java
 502             // Input Method Framework&#39;s viewpoint. We need to control activation and
 503             // deactivation for each text field/area here. Also, we need to control
 504             // enabling and disabling input methods here so that input method events
 505             // won&#39;t get delivered to wrong places (e.g., background).
 506             imClient.activateInputMethods(state);
 507         }
 508     }
 509 
 510     public void addLoadListenerClient(LoadListenerClient l) {
 511         if (!loadListenerClients.contains(l)) {
 512             loadListenerClients.add(l);
 513         }
 514     }
 515 
 516     private RenderTheme getRenderTheme() {
 517         return renderTheme;
 518     }
 519 
 520     private static RenderTheme fwkGetDefaultRenderTheme() {
 521         return ThemeClient.getDefaultRenderTheme();
 522     }
 523 
 524     private ScrollBarTheme getScrollBarTheme() {
 525         return scrollbarTheme;
 526     }
 527 
 528     // *************************************************************************
 529     // UI stuff API
 530     // *************************************************************************
 531 
 532     public void setBounds(int x, int y, int w, int h) {
 533         lockPage();
 534         try {
 535             log.fine(&quot;setBounds: &quot; + x + &quot; &quot; + y + &quot; &quot; + w + &quot; &quot; + h);
 536             if (isDisposed) {
 537                 log.fine(&quot;setBounds() request for a disposed web page.&quot;);
 538                 return;
 539             }
 540             width = w;
 541             height = h;
 542             twkSetBounds(getPage(), 0, 0, w, h);
 543             // In response to the above call, WebKit will issue many
 544             // repaint requests, one of which will be meant to invalidate
 545             // the entire visible area. However, if the current scroll
 546             // offset is non-zero, that repaint request will contain
 547             // incorrect coordinates.
 548             // As of time of writing this, this problem exists in both
 549             // MiniBrowser and WinLauncher.
 550             // MiniBrowser is based on WebKit2, and WebKit2 workarounds
 551             // this problem by calling m_drawingArea-&gt;setNeedsDisplay()
 552             // for the entire visible area from within the WebKit2&#39;s
 553             // WebPage::setSize().
 554             // WinLauncher workarounds this problem by setting the main
 555             // window class style to CS_HREDRAW | CS_VREDRAW and calling
 556             // MoveWindow() with bRepaint = TRUE when resizing the web
 557             // view.
 558             // We workaround this problem by invalidating the entire
 559             // visible area here.
 560             repaintAll();
 561 
 562         } finally {
 563             unlockPage();
 564         }
 565     }
 566 
 567     public void setOpaque(long frameID, boolean isOpaque) {
 568         lockPage();
 569         try {
 570             log.fine(&quot;setOpaque: &quot; + isOpaque);
 571             if (isDisposed) {
 572                 log.fine(&quot;setOpaque() request for a disposed web page.&quot;);
 573                 return;
 574             }
 575             if (!frames.contains(frameID)) {
 576                 return;
 577             }
 578             twkSetTransparent(frameID, !isOpaque);
 579 
 580         } finally {
 581             unlockPage();
 582         }
 583     }
 584 
 585     public void setBackgroundColor(long frameID, int backgroundColor) {
 586         lockPage();
 587         try {
 588             log.fine(&quot;setBackgroundColor: &quot; + backgroundColor);
 589             if (isDisposed) {
 590                 log.fine(&quot;setBackgroundColor() request for a disposed web page.&quot;);
 591                 return;
 592             }
 593             if (!frames.contains(frameID)) {
 594                 return;
 595             }
 596             twkSetBackgroundColor(frameID, backgroundColor);
 597 
 598         } finally {
 599             unlockPage();
 600         }
 601     }
 602 
 603     public void setBackgroundColor(int backgroundColor) {
 604         lockPage();
 605         try {
 606             log.fine(&quot;setBackgroundColor: &quot; + backgroundColor +
 607                    &quot; for all frames&quot;);
 608             if (isDisposed) {
 609                 log.fine(&quot;setBackgroundColor() request for a disposed web page.&quot;);
 610                 return;
 611             }
 612 
 613             for (long frameID: frames) {
 614                 twkSetBackgroundColor(frameID, backgroundColor);
 615             }
 616 
 617         } finally {
 618             unlockPage();
 619         }
 620     }
 621 
 622     /*
 623      * Executed on the Event Thread.
 624      */
 625     public void updateContent(WCRectangle toPaint) {
 626         lockPage();
 627         try {
 628             ++updateContentCycleID;
 629 
 630             paintLog.finest(&quot;toPaint: {0}&quot;, toPaint);
 631             if (isDisposed) {
 632                 paintLog.fine(&quot;updateContent() request for a disposed web page.&quot;);
 633                 return;
 634             }
 635             updateDirty(toPaint);
<a name="1" id="anc1"></a><span class="line-modified"> 636             updateRendering();</span>
 637         } finally {
 638             unlockPage();
 639         }
 640     }
 641 
<a name="2" id="anc2"></a><span class="line-added"> 642     public void updateRendering() {</span>
<span class="line-added"> 643         twkUpdateRendering(getPage());</span>
<span class="line-added"> 644     }</span>
<span class="line-added"> 645 </span>
 646     public int getUpdateContentCycleID() {
 647         return updateContentCycleID;
 648     }
 649 
 650     public boolean isRepaintPending() {
 651         lockPage();
 652         try {
 653             synchronized (frameQueue) {
 654                 return !frameQueue.isEmpty();
 655             }
 656         } finally {
 657             unlockPage();
 658         }
 659     }
 660 
 661     /*
 662      * Executed on printing thread.
 663      */
 664     public void print(WCGraphicsContext gc,
 665             final int x, final int y, final int w, final int h)
 666     {
 667         lockPage();
 668         try {
 669             final WCRenderQueue rq = WCGraphicsManager.getGraphicsManager().
 670                     createRenderQueue(new WCRectangle(x, y, w, h), true);
 671             FutureTask&lt;Void&gt; f = new FutureTask&lt;Void&gt;(() -&gt; {
 672                 twkUpdateContent(getPage(), rq, x, y, w, h);
 673             }, null);
 674             Invoker.getInvoker().invokeOnEventThread(f);
 675 
 676             try {
 677                 // block until job is complete
 678                 f.get();
 679             } catch (ExecutionException ex) {
 680                 throw new AssertionError(ex);
 681             } catch (InterruptedException ex) {
 682                 // ignore; recovery is impossible
 683             }
 684 
 685             rq.decode(gc);
 686         } finally {
 687             unlockPage();
 688         }
 689     }
 690 
 691     /*
 692      * Executed on the Render Thread.
 693      */
 694     public void paint(WCGraphicsContext gc, int x, int y, int w, int h) {
 695         lockPage();
 696         try {
 697             if (pageClient != null &amp;&amp; pageClient.isBackBufferSupported()) {
 698                 if (!backbuffer.validate(width, height)) {
 699                     // We need to repaint the whole page on the next turn
 700                     Invoker.getInvoker().invokeOnEventThread(() -&gt; {
 701                         repaintAll();
 702                     });
 703                     return;
 704                 }
 705                 WCGraphicsContext bgc = backbuffer.createGraphics();
 706                 try {
 707                     paint2GC(bgc);
 708                     bgc.flush();
 709                 } finally {
 710                     backbuffer.disposeGraphics(bgc);
 711                 }
 712                 backbuffer.flush(gc, x, y, w, h);
 713             } else {
 714                 paint2GC(gc);
 715             }
 716         } finally {
 717             unlockPage();
 718         }
 719     }
 720 
 721     private void paint2GC(WCGraphicsContext gc) {
 722         paintLog.finest(&quot;Entering&quot;);
 723         gc.setFontSmoothingType(this.fontSmoothingType);
 724 
 725         List&lt;RenderFrame&gt; framesToRender;
 726         synchronized (frameQueue) {
 727             framesToRender = new ArrayList(frameQueue);
 728             frameQueue.clear();
 729         }
 730 
 731         paintLog.finest(&quot;Frames to render: {0}&quot;, framesToRender);
 732 
 733         for (RenderFrame frame : framesToRender) {
 734             paintLog.finest(&quot;Rendering: {0}&quot;, frame);
 735             for (WCRenderQueue rq : frame.getRQList()) {
 736                 gc.saveState();
 737                 if (rq.getClip() != null) {
 738                     gc.setClip(rq.getClip());
 739                 }
 740                 rq.decode(gc);
 741                 gc.restoreState();
 742             }
 743         }
 744         paintLog.finest(&quot;Exiting&quot;);
 745     }
 746 
 747     /*
 748      * Executed on the Event Thread.
 749      */
 750     public void dropRenderFrames() {
 751         lockPage();
 752         try {
 753             currentFrame.drop();
 754             synchronized (frameQueue) {
 755                 for (RenderFrame frame = frameQueue.poll(); frame != null; frame = frameQueue.poll()) {
 756                     frame.drop();
 757                 }
 758             }
 759         } finally {
 760             unlockPage();
 761         }
 762     }
 763 
 764     public void dispatchFocusEvent(WCFocusEvent fe) {
 765         lockPage();
 766         try {
 767             log.finest(&quot;dispatchFocusEvent: &quot; + fe);
 768             if (isDisposed) {
 769                 log.fine(&quot;Focus event for a disposed web page.&quot;);
 770                 return;
 771             }
 772             twkProcessFocusEvent(getPage(), fe.getID(), fe.getDirection());
 773 
 774         } finally {
 775             unlockPage();
 776         }
 777     }
 778 
 779     public boolean dispatchKeyEvent(WCKeyEvent ke) {
 780         lockPage();
 781         try {
 782             log.finest(&quot;dispatchKeyEvent: &quot; + ke);
 783             if (isDisposed) {
 784                 log.fine(&quot;Key event for a disposed web page.&quot;);
 785                 return false;
 786             }
 787             if (WCKeyEvent.filterEvent(ke)) {
 788                 log.finest(&quot;filtered&quot;);
 789                 return false;
 790             }
 791             return twkProcessKeyEvent(getPage(), ke.getType(), ke.getText(),
 792                                       ke.getKeyIdentifier(),
 793                                       ke.getWindowsVirtualKeyCode(),
 794                                       ke.isShiftDown(), ke.isCtrlDown(),
 795                                       ke.isAltDown(), ke.isMetaDown(), ke.getWhen() / 1000.0);
 796         } finally {
 797             unlockPage();
 798         }
 799     }
 800 
 801     public boolean dispatchMouseEvent(WCMouseEvent me) {
 802         lockPage();
 803         try {
 804             log.finest(&quot;dispatchMouseEvent: &quot; + me.getX() + &quot;,&quot; + me.getY());
 805             if (isDisposed) {
 806                 log.fine(&quot;Mouse event for a disposed web page.&quot;);
 807                 return false;
 808             }
 809 
 810             return !isDragConfirmed() //When Webkit informes FX about drag start, it waits
 811                                       //for system DnD loop and not intereasted in
 812                                       //intermediate mouse events that can change text selection.
 813                 &amp;&amp; twkProcessMouseEvent(getPage(), me.getID(),
 814                                         me.getButton(), me.getClickCount(),
 815                                         me.getX(), me.getY(), me.getScreenX(), me.getScreenY(),
 816                                         me.isShiftDown(), me.isControlDown(), me.isAltDown(), me.isMetaDown(), me.isPopupTrigger(),
 817                                         me.getWhen() / 1000.0);
 818         } finally {
 819             unlockPage();
 820         }
 821     }
 822 
 823     public boolean dispatchMouseWheelEvent(WCMouseWheelEvent me) {
 824         lockPage();
 825         try {
 826             log.finest(&quot;dispatchMouseWheelEvent: &quot; + me);
 827             if (isDisposed) {
 828                 log.fine(&quot;MouseWheel event for a disposed web page.&quot;);
 829                 return false;
 830             }
 831             return twkProcessMouseWheelEvent(getPage(),
 832                                              me.getX(), me.getY(), me.getScreenX(), me.getScreenY(),
 833                                              me.getDeltaX(), me.getDeltaY(),
 834                                              me.isShiftDown(), me.isControlDown(), me.isAltDown(), me.isMetaDown(),
 835                                              me.getWhen() / 1000.0);
 836         } finally {
 837             unlockPage();
 838         }
 839     }
 840 
 841     public boolean dispatchInputMethodEvent(WCInputMethodEvent ie) {
 842         lockPage();
 843         try {
 844             log.finest(&quot;dispatchInputMethodEvent: &quot; + ie);
 845             if (isDisposed) {
 846                 log.fine(&quot;InputMethod event for a disposed web page.&quot;);
 847                 return false;
 848             }
 849             switch (ie.getID()) {
 850                 case WCInputMethodEvent.INPUT_METHOD_TEXT_CHANGED:
 851                     return twkProcessInputTextChange(getPage(),
 852                                                      ie.getComposed(), ie.getCommitted(),
 853                                                      ie.getAttributes(), ie.getCaretPosition());
 854 
 855                 case WCInputMethodEvent.CARET_POSITION_CHANGED:
 856                     return twkProcessCaretPositionChange(getPage(),
 857                                                          ie.getCaretPosition());
 858             }
 859             return false;
 860 
 861         } finally {
 862             unlockPage();
 863         }
 864     }
 865 
 866     public final static int DND_DST_ENTER = 0;
 867     public final static int DND_DST_OVER = 1;
 868     public final static int DND_DST_CHANGE = 2;
 869     public final static int DND_DST_EXIT = 3;
 870     public final static int DND_DST_DROP = 4;
 871 
 872     public final static int DND_SRC_ENTER = 100;
 873     public final static int DND_SRC_OVER = 101;
 874     public final static int DND_SRC_CHANGE = 102;
 875     public final static int DND_SRC_EXIT = 103;
 876     public final static int DND_SRC_DROP = 104;
 877 
 878     public int dispatchDragOperation(
 879             int commandId,
 880             String[] mimeTypes, String[] values,
 881             int x, int y,
 882             int screenX, int screenY,
 883             int dndActionId)
 884     {
 885         lockPage();
 886         try {
 887             log.finest(&quot;dispatchDragOperation: &quot; + x + &quot;,&quot; + y
 888                     + &quot; dndCommand:&quot; + commandId
 889                     + &quot; dndAction&quot; + dndActionId);
 890             if (isDisposed) {
 891                 log.fine(&quot;DnD event for a disposed web page.&quot;);
 892                 return 0;
 893             }
 894             return twkProcessDrag(getPage(),
 895                     commandId,
 896                     mimeTypes, values,
 897                     x, y,
 898                     screenX, screenY,
 899                     dndActionId);
 900         } finally {
 901             unlockPage();
 902         }
 903     }
 904 
 905     public void confirmStartDrag() {
 906         if (uiClient != null)
 907             uiClient.confirmStartDrag();
 908     }
 909 
 910     public boolean isDragConfirmed(){
 911         return (uiClient != null)
 912             ? uiClient.isDragConfirmed()
 913             : false;
 914     }
 915 
 916     // *************************************************************************
 917     // Input methods
 918     // *************************************************************************
 919 
 920     public int[] getClientTextLocation(int index) {
 921         lockPage();
 922         try {
 923             if (isDisposed) {
 924                 log.fine(&quot;getClientTextLocation() request for a disposed web page.&quot;);
 925                 return new int[] { 0, 0, 0, 0 };
 926             }
 927             Invoker.getInvoker().checkEventThread();
 928             return twkGetTextLocation(getPage(), index);
 929 
 930         } finally {
 931             unlockPage();
 932         }
 933     }
 934 
 935     public int getClientLocationOffset(int x, int y) {
 936         lockPage();
 937         try {
 938             if (isDisposed) {
 939                 log.fine(&quot;getClientLocationOffset() request for a disposed web page.&quot;);
 940                 return 0;
 941             }
 942             Invoker.getInvoker().checkEventThread();
 943             return twkGetInsertPositionOffset(getPage());
 944 
 945         } finally {
 946             unlockPage();
 947         }
 948     }
 949 
 950     public int getClientInsertPositionOffset() {
 951         lockPage();
 952         try {
 953             if (isDisposed) {
 954                 log.fine(&quot;getClientInsertPositionOffset() request for a disposed web page.&quot;);
 955                 return 0;
 956             }
 957             return twkGetInsertPositionOffset(getPage());
 958 
 959         } finally {
 960             unlockPage();
 961         }
 962     }
 963 
 964     public int getClientCommittedTextLength() {
 965         lockPage();
 966         try {
 967             if (isDisposed) {
 968                 log.fine(&quot;getClientCommittedTextOffset() request for a disposed web page.&quot;);
 969                 return 0;
 970             }
 971             return twkGetCommittedTextLength(getPage());
 972 
 973         } finally {
 974             unlockPage();
 975         }
 976     }
 977 
 978     public String getClientCommittedText() {
 979         lockPage();
 980         try {
 981             if (isDisposed) {
 982                 log.fine(&quot;getClientCommittedText() request for a disposed web page.&quot;);
 983                 return &quot;&quot;;
 984             }
 985             return twkGetCommittedText(getPage());
 986 
 987         } finally {
 988             unlockPage();
 989         }
 990     }
 991 
 992     public String getClientSelectedText() {
 993         lockPage();
 994         try {
 995             if (isDisposed) {
 996                 log.fine(&quot;getClientSelectedText() request for a disposed web page.&quot;);
 997                 return &quot;&quot;;
 998             }
 999             final String selectedText = twkGetSelectedText(getPage());
1000             return selectedText != null ? selectedText : &quot;&quot;;
1001 
1002         } finally {
1003             unlockPage();
1004         }
1005     }
1006 
1007     // *************************************************************************
1008     // Browser API
1009     // *************************************************************************
1010 
1011     public void dispose() {
1012         lockPage();
1013         try {
1014             log.finer(&quot;dispose&quot;);
1015 
1016             stop();
1017             dropRenderFrames();
1018             isDisposed = true;
1019 
1020             twkDestroyPage(pPage);
1021             pPage = 0;
1022 
1023             for (long frameID : frames) {
1024                 log.fine(&quot;Undestroyed frame view: &quot; + frameID);
1025             }
1026             frames.clear();
1027 
1028             if (backbuffer != null) {
1029                 backbuffer.deref();
1030                 backbuffer = null;
1031             }
1032         } finally {
1033             unlockPage();
1034         }
1035     }
1036 
1037     public String getName(long frameID) {
1038         lockPage();
1039         try {
1040             log.fine(&quot;Get Name: frame = &quot; + frameID);
1041             if (isDisposed) {
1042                 log.fine(&quot;getName() request for a disposed web page.&quot;);
1043                 return null;
1044             }
1045             if (!frames.contains(frameID)) {
1046                 return null;
1047             }
1048             return twkGetName(frameID);
1049 
1050         } finally {
1051             unlockPage();
1052         }
1053     }
1054 
1055     public String getURL(long frameID) {
1056         lockPage();
1057         try {
1058             log.fine(&quot;Get URL: frame = &quot; + frameID);
1059             if (isDisposed) {
1060                 log.fine(&quot;getURL() request for a disposed web page.&quot;);
1061                 return null;
1062             }
1063             if (!frames.contains(frameID)) {
1064                 return null;
1065             }
1066             return twkGetURL(frameID);
1067 
1068         } finally {
1069             unlockPage();
1070         }
1071     }
1072 
1073     public String getEncoding() {
1074         lockPage();
1075         try {
1076             log.fine(&quot;Get encoding&quot;);
1077             if (isDisposed) {
1078                 log.fine(&quot;getEncoding() request for a disposed web page.&quot;);
1079                 return null;
1080             }
1081             return twkGetEncoding(getPage());
1082 
1083         } finally {
1084             unlockPage();
1085         }
1086     }
1087 
1088     public void setEncoding(String encoding) {
1089         lockPage();
1090         try {
1091             log.fine(&quot;Set encoding: encoding = &quot; + encoding);
1092             if (isDisposed) {
1093                 log.fine(&quot;setEncoding() request for a disposed web page.&quot;);
1094                 return;
1095             }
1096             if (encoding != null &amp;&amp; !encoding.isEmpty()) {
1097                 twkSetEncoding(getPage(), encoding);
1098             }
1099 
1100         } finally {
1101             unlockPage();
1102         }
1103     }
1104 
1105     // DRT support
1106     public String getInnerText(long frameID) {
1107         lockPage();
1108         try {
1109             log.fine(&quot;Get inner text: frame = &quot; + frameID);
1110             if (isDisposed) {
1111                 log.fine(&quot;getInnerText() request for a disposed web page.&quot;);
1112                 return null;
1113             }
1114             if (!frames.contains(frameID)) {
1115                 return null;
1116             }
1117             return twkGetInnerText(frameID);
1118 
1119         } finally {
1120             unlockPage();
1121         }
1122     }
1123 
1124     // DRT support
1125     public String getRenderTree(long frameID) {
1126         lockPage();
1127         try {
1128             log.fine(&quot;Get render tree: frame = &quot; + frameID);
1129             if (isDisposed) {
1130                 log.fine(&quot;getRenderTree() request for a disposed web page.&quot;);
1131                 return null;
1132             }
1133             if (!frames.contains(frameID)) {
1134                 return null;
1135             }
1136             return twkGetRenderTree(frameID);
1137 
1138         } finally {
1139             unlockPage();
1140         }
1141     }
1142 
1143     // DRT support
1144     public int getUnloadEventListenersCount(long frameID) {
1145         lockPage();
1146         try {
1147             log.fine(&quot;frame: &quot; + frameID);
1148             if (isDisposed) {
1149                 log.fine(&quot;request for a disposed web page.&quot;);
1150                 return 0;
1151             }
1152             if (!frames.contains(frameID)) {
1153                 return 0;
1154             }
1155             return twkGetUnloadEventListenersCount(frameID);
1156 
1157         } finally {
1158             unlockPage();
1159         }
1160     }
1161 
<a name="3" id="anc3"></a><span class="line-added">1162     // DRT support</span>
<span class="line-added">1163     public void forceRepaint() {</span>
<span class="line-added">1164         repaintAll();</span>
<span class="line-added">1165         updateContent(new WCRectangle(0, 0, width, height));</span>
<span class="line-added">1166     }</span>
<span class="line-added">1167 </span>
1168     public String getContentType(long frameID) {
1169         lockPage();
1170         try {
1171             log.fine(&quot;Get content type: frame = &quot; + frameID);
1172             if (isDisposed) {
1173                 log.fine(&quot;getContentType() request for a disposed web page.&quot;);
1174                 return null;
1175             }
1176             if (!frames.contains(frameID)) {
1177                 return null;
1178             }
1179             return twkGetContentType(frameID);
1180 
1181         } finally {
1182             unlockPage();
1183         }
1184     }
1185 
1186     public String getTitle(long frameID) {
1187         lockPage();
1188         try {
1189             log.fine(&quot;Get title: frame = &quot; + frameID);
1190             if (isDisposed) {
1191                 log.fine(&quot;getTitle() request for a disposed web page.&quot;);
1192                 return null;
1193             }
1194             if (!frames.contains(frameID)) {
1195                 return null;
1196             }
1197             return twkGetTitle(frameID);
1198 
1199         } finally {
1200             unlockPage();
1201         }
1202     }
1203 
1204     public WCImage getIcon(long frameID) {
1205         lockPage();
1206         try {
1207             log.fine(&quot;Get icon: frame = &quot; + frameID);
1208             if (isDisposed) {
1209                 log.fine(&quot;getIcon() request for a disposed web page.&quot;);
1210                 return null;
1211             }
1212             if (!frames.contains(frameID)) {
1213                 return null;
1214             }
1215             String iconURL = twkGetIconURL(frameID);
1216             // do we need any cache for icons here?
1217             if (iconURL != null &amp;&amp; !iconURL.isEmpty()) {
1218                 return WCGraphicsManager.getGraphicsManager().getIconImage(iconURL);
1219             }
1220             return null;
1221 
1222         } finally {
1223             unlockPage();
1224         }
1225     }
1226 
1227     public void open(final long frameID, final String url) {
1228         lockPage();
1229         try {
1230             log.fine(&quot;Open URL: &quot; + url);
1231             if (isDisposed) {
1232                 log.fine(&quot;open() request for a disposed web page.&quot;);
1233                 return;
1234             }
1235             if (!frames.contains(frameID)) {
1236                 return;
1237             }
1238             if (twkIsLoading(frameID)) {
1239                 Invoker.getInvoker().postOnEventThread(() -&gt; {
1240                     // Postpone new load request while webkit is
1241                     // about to commit the DocumentLoader from
1242                     // provisional state to committed state
1243                     twkOpen(frameID, url);
1244                 });
1245             } else {
1246                 twkOpen(frameID, url);
1247             }
1248         } finally {
1249             unlockPage();
1250         }
1251     }
1252 
1253     public void load(final long frameID, final String text, final String contentType) {
1254         lockPage();
1255         try {
1256             log.fine(&quot;Load text: &quot; + text);
1257             if (text == null) {
1258                 return;
1259             }
1260             if (isDisposed) {
1261                 log.fine(&quot;load() request for a disposed web page.&quot;);
1262                 return;
1263             }
1264             if (!frames.contains(frameID)) {
1265                 return;
1266             }
1267             // TODO: handle contentType
1268             if (twkIsLoading(frameID)) {
1269                 // Postpone loading new content while webkit is
1270                 // about to commit the DocumentLoader from
1271                 // provisional state to committed state
1272                 Invoker.getInvoker().postOnEventThread(() -&gt; {
1273                     twkLoad(frameID, text, contentType);
1274                 });
1275             } else {
1276                 twkLoad(frameID, text, contentType);
1277             }
1278         } finally {
1279             unlockPage();
1280         }
1281     }
1282 
1283     public void stop(final long frameID) {
1284         lockPage();
1285         try {
1286             log.fine(&quot;Stop loading: frame = &quot; + frameID);
1287 
1288             String url;
1289             String contentType;
1290             if (isDisposed) {
1291                 log.fine(&quot;cancel() request for a disposed web page.&quot;);
1292                 return;
1293             }
1294             if (!frames.contains(frameID)) {
1295                 return;
1296             }
1297             url = twkGetURL(frameID);
1298             contentType = twkGetContentType(frameID);
1299             twkStop(frameID);
1300             // WebKit doesn&#39;t send any notifications about loading stopped,
1301             // so sending it here
1302             fireLoadEvent(frameID, LoadListenerClient.LOAD_STOPPED, url, contentType, 1.0, 0);
1303 
1304         } finally {
1305             unlockPage();
1306         }
1307     }
1308 
1309     // stops all loading synchronously
1310     public void stop() {
1311         lockPage();
1312         try {
1313             log.fine(&quot;Stop loading sync&quot;);
1314             if (isDisposed) {
1315                 log.fine(&quot;stopAll() request for a disposed web page.&quot;);
1316                 return;
1317             }
1318             twkStopAll(getPage());
1319 
1320         } finally {
1321             unlockPage();
1322         }
1323     }
1324 
1325     public void refresh(final long frameID) {
1326         lockPage();
1327         try {
1328             log.fine(&quot;Refresh: frame = &quot; + frameID);
1329             if (isDisposed) {
1330                 log.fine(&quot;refresh() request for a disposed web page.&quot;);
1331                 return;
1332             }
1333             if (!frames.contains(frameID)) {
1334                 return;
1335             }
1336             twkRefresh(frameID);
1337 
1338         } finally {
1339             unlockPage();
1340         }
1341     }
1342 
1343     public BackForwardList createBackForwardList() {
1344         return new BackForwardList(this);
1345     }
1346 
1347     public boolean goBack() {
1348         lockPage();
1349         try {
1350             log.fine(&quot;Go back&quot;);
1351             if (isDisposed) {
1352                 log.fine(&quot;goBack() request for a disposed web page.&quot;);
1353                 return false;
1354             }
1355             return twkGoBackForward(getPage(), -1);
1356 
1357         } finally {
1358             unlockPage();
1359         }
1360     }
1361 
1362     public boolean goForward() {
1363         lockPage();
1364         try {
1365             log.fine(&quot;Go forward&quot;);
1366             if (isDisposed) {
1367                 log.fine(&quot;goForward() request for a disposed web page.&quot;);
1368                 return false;
1369             }
1370             return twkGoBackForward(getPage(), 1);
1371 
1372         } finally {
1373             unlockPage();
1374         }
1375     }
1376 
1377     public boolean copy() {
1378         lockPage();
1379         try {
1380             log.fine(&quot;Copy&quot;);
1381             if (isDisposed) {
1382                 log.fine(&quot;copy() request for a disposed web page.&quot;);
1383                 return false;
1384             }
1385             long frameID = getMainFrame();
1386             if (!frames.contains(frameID)) {
1387                 return false;
1388             }
1389             return twkCopy(frameID);
1390 
1391         } finally {
1392             unlockPage();
1393         }
1394     }
1395 
1396     // Find in page
1397     public boolean find(String stringToFind, boolean forward, boolean wrap, boolean matchCase) {
1398         lockPage();
1399         try {
1400             log.fine(&quot;Find in page: stringToFind = &quot; + stringToFind + &quot;, &quot; +
1401                     (forward ? &quot;forward&quot; : &quot;backward&quot;) + (wrap ? &quot;, wrap&quot; : &quot;&quot;) + (matchCase ? &quot;, matchCase&quot; : &quot;&quot;));
1402             if (isDisposed) {
1403                 log.fine(&quot;find() request for a disposed web page.&quot;);
1404                 return false;
1405             }
1406             return twkFindInPage(getPage(), stringToFind, forward, wrap, matchCase);
1407 
1408         } finally {
1409             unlockPage();
1410         }
1411     }
1412 
1413     // Find in frame
1414     public boolean find(long frameID,
1415         String stringToFind, boolean forward, boolean wrap, boolean matchCase)
1416     {
1417         lockPage();
1418         try {
1419             log.fine(&quot;Find in frame: stringToFind = &quot; + stringToFind + &quot;, &quot; +
1420                     (forward ? &quot;forward&quot; : &quot;backward&quot;) + (wrap ? &quot;, wrap&quot; : &quot;&quot;) + (matchCase ? &quot;, matchCase&quot; : &quot;&quot;));
1421             if (isDisposed) {
1422                 log.fine(&quot;find() request for a disposed web page.&quot;);
1423                 return false;
1424             }
1425             if (!frames.contains(frameID)) {
1426                 return false;
1427             }
1428             return twkFindInFrame(frameID, stringToFind, forward, wrap, matchCase);
1429 
1430         } finally {
1431             unlockPage();
1432         }
1433     }
1434 
1435     public void overridePreference(String key, String value) {
1436         lockPage();
1437         try {
1438             twkOverridePreference(getPage(), key, value);
1439         } finally {
1440             unlockPage();
1441         }
1442     }
1443 
1444     public void resetToConsistentStateBeforeTesting() {
1445         lockPage();
1446         try {
1447             twkResetToConsistentStateBeforeTesting(getPage());
1448         } finally {
1449             unlockPage();
1450         }
1451     }
1452 
1453     public float getZoomFactor(boolean textOnly) {
1454         lockPage();
1455         try {
1456             log.fine(&quot;Get zoom factor, textOnly=&quot; + textOnly);
1457             if (isDisposed) {
1458                 log.fine(&quot;getZoomFactor() request for a disposed web page.&quot;);
1459                 return 1.0f;
1460             }
1461             long frameID = getMainFrame();
1462             if (!frames.contains(frameID)) {
1463                 return 1.0f;
1464             }
1465             return twkGetZoomFactor(frameID, textOnly);
1466         } finally {
1467             unlockPage();
1468         }
1469     }
1470 
1471     public void setZoomFactor(float zoomFactor, boolean textOnly) {
1472         lockPage();
1473         try {
1474             log.fine(String.format(&quot;Set zoom factor %.2f, textOnly=%b&quot;, zoomFactor, textOnly));
1475             if (isDisposed) {
1476                 log.fine(&quot;setZoomFactor() request for a disposed web page.&quot;);
1477                 return;
1478             }
1479             long frameID = getMainFrame();
1480             if ((frameID == 0) || !frames.contains(frameID)) {
1481                 return;
1482             }
1483             twkSetZoomFactor(frameID, zoomFactor, textOnly);
1484         } finally {
1485             unlockPage();
1486         }
1487     }
1488 
1489     public void setFontSmoothingType(int fontSmoothingType) {
1490         this.fontSmoothingType = fontSmoothingType;
1491         repaintAll();
1492     }
1493 
1494     // DRT support
1495     public void reset(long frameID) {
1496         lockPage();
1497         try {
1498             log.fine(&quot;Reset: frame = &quot; + frameID);
1499             if (isDisposed) {
1500                 log.fine(&quot;reset() request for a disposed web page.&quot;);
1501                 return;
1502             }
1503             if ((frameID == 0) || !frames.contains(frameID)) {
1504                 return;
1505             }
1506             twkReset(frameID);
1507 
1508         } finally {
1509             unlockPage();
1510         }
1511     }
1512 
1513     public Object executeScript(long frameID, String script) throws JSException {
1514         lockPage();
1515         try {
1516             log.fine(&quot;execute script: \&quot;&quot; + script + &quot;\&quot; in frame = &quot; + frameID);
1517             if (isDisposed) {
1518                 log.fine(&quot;executeScript() request for a disposed web page.&quot;);
1519                 return null;
1520             }
1521             if ((frameID == 0) || !frames.contains(frameID)) {
1522                 return null;
1523             }
1524             return twkExecuteScript(frameID, script);
1525 
1526         } finally {
1527             unlockPage();
1528         }
1529     }
1530 
1531     public long getMainFrame() {
1532         lockPage();
1533         try {
1534             log.finer(&quot;getMainFrame: page = &quot; + pPage);
1535             if (isDisposed) {
1536                 log.fine(&quot;getMainFrame() request for a disposed web page.&quot;);
1537                 return 0L;
1538             }
1539             long mainFrameID = twkGetMainFrame(getPage());
1540             log.finer(&quot;Main frame = &quot; + mainFrameID);
1541             frames.add(mainFrameID);
1542             return mainFrameID;
1543         } finally {
1544             unlockPage();
1545         }
1546     }
1547 
1548     public long getParentFrame(long childID) {
1549         lockPage();
1550         try {
1551             log.fine(&quot;getParentFrame: child = &quot; + childID);
1552             if (isDisposed) {
1553                 log.fine(&quot;getParentFrame() request for a disposed web page.&quot;);
1554                 return 0L;
1555             }
1556             if (!frames.contains(childID)) {
1557                 return 0L;
1558             }
1559             return twkGetParentFrame(childID);
1560         } finally {
1561             unlockPage();
1562         }
1563     }
1564 
1565     public List&lt;Long&gt; getChildFrames(long parentID) {
1566         lockPage();
1567         try {
1568             log.fine(&quot;getChildFrames: parent = &quot; + parentID);
1569             if (isDisposed) {
1570                 log.fine(&quot;getChildFrames() request for a disposed web page.&quot;);
1571                 return null;
1572             }
1573             if (!frames.contains(parentID)) {
1574                 return null;
1575             }
1576             long[] children = twkGetChildFrames(parentID);
1577             List&lt;Long&gt; childrenList = new LinkedList&lt;Long&gt;();
1578             for (long child : children) {
1579                 childrenList.add(Long.valueOf(child));
1580             }
1581             return childrenList;
1582         } finally {
1583             unlockPage();
1584         }
1585     }
1586 
1587     public WCRectangle getVisibleRect(long frameID) {
1588         lockPage();
1589         try {
1590             if (!frames.contains(frameID)) {
1591                 return null;
1592             }
1593             int[] arr = twkGetVisibleRect(frameID);
1594             if (arr != null) {
1595                 return new WCRectangle(arr[0], arr[1], arr[2], arr[3]);
1596             }
1597             return null;
1598         } finally {
1599             unlockPage();
1600         }
1601     }
1602 
1603     public void scrollToPosition(long frameID, WCPoint p) {
1604         lockPage();
1605         try {
1606             if (!frames.contains(frameID)) {
1607                 return;
1608             }
1609             twkScrollToPosition(frameID, p.getIntX(), p.getIntY());
1610         } finally {
1611             unlockPage();
1612         }
1613     }
1614 
1615     public WCSize getContentSize(long frameID) {
1616         lockPage();
1617         try {
1618             if (!frames.contains(frameID)) {
1619                 return null;
1620             }
1621             int[] arr = twkGetContentSize(frameID);
1622             if (arr != null) {
1623                 return new WCSize(arr[0], arr[1]);
1624             }
1625             return null;
1626         } finally {
1627             unlockPage();
1628         }
1629     }
1630 
1631     // ---- DOM ---- //
1632 
1633     public Document getDocument(long frameID) {
1634         lockPage();
1635         try {
1636             log.fine(&quot;getDocument&quot;);
1637             if (isDisposed) {
1638                 log.fine(&quot;getDocument() request for a disposed web page.&quot;);
1639                 return null;
1640             }
1641 
1642             if (!frames.contains(frameID)) {
1643                 return null;
1644             }
1645             return twkGetDocument(frameID);
1646         } finally {
1647             unlockPage();
1648         }
1649     }
1650 
1651     public Element getOwnerElement(long frameID) {
1652         lockPage();
1653         try {
1654             log.fine(&quot;getOwnerElement&quot;);
1655             if (isDisposed) {
1656                 log.fine(&quot;getOwnerElement() request for a disposed web page.&quot;);
1657                 return null;
1658             }
1659 
1660             if (!frames.contains(frameID)) {
1661                 return null;
1662             }
1663             return twkGetOwnerElement(frameID);
1664         } finally {
1665             unlockPage();
1666         }
1667     }
1668 
1669    // ---- EDITING SUPPORT ---- //
1670 
1671     public boolean executeCommand(String command, String value) {
1672         lockPage();
1673         try {
1674             if (log.isLoggable(Level.FINE)) {
1675                 log.fine(&quot;command: [{0}], value: [{1}]&quot;,
1676                         new Object[] {command, value});
1677             }
1678             if (isDisposed) {
1679                 log.fine(&quot;Web page is already disposed&quot;);
1680                 return false;
1681             }
1682 
1683             boolean result = twkExecuteCommand(getPage(), command, value);
1684 
1685             log.fine(&quot;result: [{0}]&quot;, result);
1686             return result;
1687         } finally {
1688             unlockPage();
1689         }
1690     }
1691 
1692     public boolean queryCommandEnabled(String command) {
1693         lockPage();
1694         try {
1695             log.fine(&quot;command: [{0}]&quot;, command);
1696             if (isDisposed) {
1697                 log.fine(&quot;Web page is already disposed&quot;);
1698                 return false;
1699             }
1700 
1701             boolean result = twkQueryCommandEnabled(getPage(), command);
1702 
1703             log.fine(&quot;result: [{0}]&quot;, result);
1704             return result;
1705         } finally {
1706             unlockPage();
1707         }
1708     }
1709 
1710     public boolean queryCommandState(String command) {
1711         lockPage();
1712         try {
1713             log.fine(&quot;command: [{0}]&quot;, command);
1714             if (isDisposed) {
1715                 log.fine(&quot;Web page is already disposed&quot;);
1716                 return false;
1717             }
1718 
1719             boolean result = twkQueryCommandState(getPage(), command);
1720 
1721             log.fine(&quot;result: [{0}]&quot;, result);
1722             return result;
1723         } finally {
1724             unlockPage();
1725         }
1726     }
1727 
1728     public String queryCommandValue(String command) {
1729         lockPage();
1730         try {
1731             log.fine(&quot;command: [{0}]&quot;, command);
1732             if (isDisposed) {
1733                 log.fine(&quot;Web page is already disposed&quot;);
1734                 return null;
1735             }
1736 
1737             String result = twkQueryCommandValue(getPage(), command);
1738 
1739             log.fine(&quot;result: [{0}]&quot;, result);
1740             return result;
1741         } finally {
1742             unlockPage();
1743         }
1744     }
1745 
1746     public boolean isEditable() {
1747         lockPage();
1748         try {
1749             log.fine(&quot;isEditable&quot;);
1750             if (isDisposed) {
1751                 log.fine(&quot;isEditable() request for a disposed web page.&quot;);
1752                 return false;
1753             }
1754 
1755             return twkIsEditable(getPage());
1756         } finally {
1757             unlockPage();
1758         }
1759     }
1760 
1761     public void setEditable(boolean editable) {
1762         lockPage();
1763         try {
1764             log.fine(&quot;setEditable&quot;);
1765             if (isDisposed) {
1766                 log.fine(&quot;setEditable() request for a disposed web page.&quot;);
1767                 return;
1768             }
1769 
1770             twkSetEditable(getPage(), editable);
1771         } finally {
1772             unlockPage();
1773         }
1774     }
1775 
1776     /**
1777      * @return HTML content of the frame,
1778      *         or null if frame document is absent or non-HTML.
1779      */
1780     public String getHtml(long frameID) {
1781         lockPage();
1782         try {
1783             log.fine(&quot;getHtml&quot;);
1784             if (isDisposed) {
1785                 log.fine(&quot;getHtml() request for a disposed web page.&quot;);
1786                 return null;
1787             }
1788             if (!frames.contains(frameID)) {
1789                 return null;
1790             }
1791             return twkGetHtml(frameID);
1792         } finally {
1793             unlockPage();
1794         }
1795     }
1796 
1797     // ---- PRINTING SUPPORT ---- //
1798 
1799     public int beginPrinting(float width, float height) {
1800         lockPage();
1801         try {
1802             if (isDisposed) {
1803                 log.warning(&quot;beginPrinting() called for a disposed web page.&quot;);
1804                 return 0;
1805             }
1806             AtomicReference&lt;Integer&gt; retVal = new AtomicReference&lt;&gt;(0);
1807             final CountDownLatch l = new CountDownLatch(1);
1808             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
1809                 try {
1810                     int nPages = twkBeginPrinting(getPage(), width, height);
1811                     retVal.set(nPages);
1812                 } finally {
1813                     l.countDown();
1814                 }
1815             });
1816 
1817             try {
1818                 l.await();
1819             } catch (InterruptedException e) {
1820                 throw new RuntimeException(e);
1821             }
1822             return retVal.get();
1823         } finally {
1824             unlockPage();
1825         }
1826     }
1827 
1828     public void endPrinting() {
1829         lockPage();
1830         try {
1831             if (isDisposed) {
1832                 log.warning(&quot;endPrinting() called for a disposed web page.&quot;);
1833                 return;
1834             }
1835             final CountDownLatch l = new CountDownLatch(1);
1836             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
1837                 try {
1838                     twkEndPrinting(getPage());
1839                 } finally {
1840                     l.countDown();
1841                 }
1842             });
1843 
1844             try {
1845                 l.await();
1846             } catch (InterruptedException e) {
1847                 throw new RuntimeException(e);
1848             }
1849         } finally {
1850             unlockPage();
1851         }
1852     }
1853 
1854     public void print(final WCGraphicsContext gc, final int pageNumber, final float width) {
1855         lockPage();
1856         try {
1857             if (isDisposed) {
1858                 log.warning(&quot;print() called for a disposed web page.&quot;);
1859                 return;
1860             }
1861             final WCRenderQueue rq = WCGraphicsManager.getGraphicsManager().
1862                     createRenderQueue(null, true);
1863             final CountDownLatch l = new CountDownLatch(1);
1864             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
1865                 try {
1866                     twkPrint(getPage(), rq, pageNumber, width);
1867                 } finally {
1868                     l.countDown();
1869                 }
1870             });
1871 
1872             try {
1873                 l.await();
1874             } catch (InterruptedException e) {
1875                 rq.dispose();
1876                 return;
1877             }
1878             rq.decode(gc);
1879         } finally {
1880             unlockPage();
1881         }
1882     }
1883 
1884     public int getPageHeight() {
1885         return getFrameHeight(getMainFrame());
1886     }
1887 
1888     public int getFrameHeight(long frameID) {
1889         lockPage();
1890         try {
1891             log.fine(&quot;Get page height&quot;);
1892             if (isDisposed) {
1893                 log.fine(&quot;getFrameHeight() request for a disposed web page.&quot;);
1894                 return 0;
1895             }
1896             if (!frames.contains(frameID)) {
1897                 return 0;
1898             }
1899             int height = twkGetFrameHeight(frameID);
1900             log.fine(&quot;Height = &quot; + height);
1901             return height;
1902         } finally {
1903             unlockPage();
1904         }
1905     }
1906 
1907     public float adjustFrameHeight(long frameID,
1908                                    float oldTop, float oldBottom, float bottomLimit)
1909     {
1910         lockPage();
1911         try {
1912             log.fine(&quot;Adjust page height&quot;);
1913             if (isDisposed) {
1914                 log.fine(&quot;adjustFrameHeight() request for a disposed web page.&quot;);
1915                 return 0;
1916             }
1917             if (!frames.contains(frameID)) {
1918                 return 0;
1919             }
1920             return twkAdjustFrameHeight(frameID, oldTop, oldBottom, bottomLimit);
1921         } finally {
1922             unlockPage();
1923         }
1924     }
1925 
1926     // ---- SETTINGS ---- //
1927 
1928     /**
1929      * Returns the usePageCache settings field.
1930      * @return {@code true} if this object uses the page cache,
1931      *         {@code false} otherwise.
1932      */
1933     public boolean getUsePageCache() {
1934         lockPage();
1935         try {
1936             return twkGetUsePageCache(getPage());
1937         } finally {
1938             unlockPage();
1939         }
1940     }
1941 
1942     /**
1943      * Sets the usePageCache settings field.
1944      * @param usePageCache {@code true} to use the page cache,
1945      *        {@code false} to not use the page cache.
1946      */
1947     public void setUsePageCache(boolean usePageCache) {
1948         lockPage();
1949         try {
1950             twkSetUsePageCache(getPage(), usePageCache);
1951         } finally {
1952             unlockPage();
1953         }
1954     }
1955 
1956     public boolean getDeveloperExtrasEnabled() {
1957         lockPage();
1958         try {
1959             boolean result = twkGetDeveloperExtrasEnabled(getPage());
1960             log.fine(&quot;Getting developerExtrasEnabled, result: [{0}]&quot;, result);
1961             return result;
1962         } finally {
1963             unlockPage();
1964         }
1965     }
1966 
1967     public void setDeveloperExtrasEnabled(boolean enabled) {
1968         lockPage();
1969         try {
1970             log.fine(&quot;Setting developerExtrasEnabled, value: [{0}]&quot;, enabled);
1971             twkSetDeveloperExtrasEnabled(getPage(), enabled);
1972         } finally {
1973             unlockPage();
1974         }
1975     }
1976 
1977     public boolean isJavaScriptEnabled() {
1978         lockPage();
1979         try {
1980             return twkIsJavaScriptEnabled(getPage());
1981         } finally {
1982             unlockPage();
1983         }
1984     }
1985 
1986     public void setJavaScriptEnabled(boolean enable) {
1987         lockPage();
1988         try {
1989             twkSetJavaScriptEnabled(getPage(), enable);
1990         } finally {
1991             unlockPage();
1992         }
1993     }
1994 
1995     public boolean isContextMenuEnabled() {
1996         lockPage();
1997         try {
1998             return twkIsContextMenuEnabled(getPage());
1999         } finally {
2000             unlockPage();
2001         }
2002     }
2003 
2004     public void setContextMenuEnabled(boolean enable) {
2005         lockPage();
2006         try {
2007             twkSetContextMenuEnabled(getPage(), enable);
2008         } finally {
2009             unlockPage();
2010         }
2011     }
2012 
2013     public void setUserStyleSheetLocation(String url) {
2014         lockPage();
2015         try {
2016             twkSetUserStyleSheetLocation(getPage(), url);
2017         } finally {
2018             unlockPage();
2019         }
2020     }
2021 
2022     public String getUserAgent() {
2023         lockPage();
2024         try {
2025             return twkGetUserAgent(getPage());
2026         } finally {
2027             unlockPage();
2028         }
2029     }
2030 
2031     public void setUserAgent(String userAgent) {
2032         lockPage();
2033         try {
2034             twkSetUserAgent(getPage(), userAgent);
2035         } finally {
2036             unlockPage();
2037         }
2038     }
2039 
2040     public void setLocalStorageDatabasePath(String path) {
2041         lockPage();
2042         try {
2043             twkSetLocalStorageDatabasePath(getPage(), path);
2044         } finally {
2045             unlockPage();
2046         }
2047     }
2048 
2049     public void setLocalStorageEnabled(boolean enabled) {
2050         lockPage();
2051         try {
2052             twkSetLocalStorageEnabled(getPage(), enabled);
2053         } finally {
2054             unlockPage();
2055         }
2056     }
2057 
2058     // ---- INSPECTOR SUPPORT ---- //
2059 
2060     public void connectInspectorFrontend() {
2061         lockPage();
2062         try {
2063             log.fine(&quot;Connecting inspector frontend&quot;);
2064             twkConnectInspectorFrontend(getPage());
2065         } finally {
2066             unlockPage();
2067         }
2068     }
2069 
2070     public void disconnectInspectorFrontend() {
2071         lockPage();
2072         try {
2073             log.fine(&quot;Disconnecting inspector frontend&quot;);
2074             twkDisconnectInspectorFrontend(getPage());
2075         } finally {
2076             unlockPage();
2077         }
2078     }
2079 
2080     public void dispatchInspectorMessageFromFrontend(String message) {
2081         lockPage();
2082         try {
2083             if (log.isLoggable(Level.FINE)) {
2084                 log.fine(&quot;Dispatching inspector message from frontend, &quot;
2085                         + &quot;message: [{0}]&quot;,  message);
2086             }
2087             twkDispatchInspectorMessageFromFrontend(getPage(), message);
2088         } finally {
2089             unlockPage();
2090         }
2091     }
2092 
2093     // *************************************************************************
2094     // Native callbacks
2095     // *************************************************************************
2096 
2097     private void fwkFrameCreated(long frameID) {
2098         log.fine(&quot;Frame created: frame = &quot; + frameID);
2099         if (frames.contains(frameID)) {
2100             log.fine(&quot;Error in fwkFrameCreated: frame is already in frames&quot;);
2101             return;
2102         }
2103         frames.add(frameID);
2104     }
2105 
2106     private void fwkFrameDestroyed(long frameID) {
2107         log.fine(&quot;Frame destroyed: frame = &quot; + frameID);
2108         if (!frames.contains(frameID)) {
2109             log.fine(&quot;Error in fwkFrameDestroyed: frame is not found in frames&quot;);
2110             return;
2111         }
2112         frames.remove(frameID);
2113     }
2114 
2115     private void fwkRepaint(int x, int y, int w, int h) {
2116         lockPage();
2117         try {
2118             if (paintLog.isLoggable(Level.FINEST)) {
2119                 paintLog.finest(&quot;x: {0}, y: {1}, w: {2}, h: {3}&quot;,
2120                         new Object[] {x, y, w, h});
2121             }
2122             addDirtyRect(new WCRectangle(x, y, w, h));
2123         } finally {
2124             unlockPage();
2125         }
2126     }
2127 
2128     private void fwkScroll(int x, int y, int w, int h, int deltaX, int deltaY) {
2129         if (paintLog.isLoggable(Level.FINEST)) {
2130             paintLog.finest(&quot;Scroll: &quot; + x + &quot; &quot; + y + &quot; &quot; + w + &quot; &quot; + h + &quot;  &quot; + deltaX + &quot; &quot; + deltaY);
2131         }
2132         if (pageClient == null || !pageClient.isBackBufferSupported()) {
2133             paintLog.finest(&quot;blit scrolling is switched off&quot;);
2134             // TODO: check why we return void, not boolean (see ScrollView::m_canBlitOnScroll)
2135             return;
2136         }
2137         scroll(x, y, w, h, deltaX, deltaY);
2138     }
2139 
2140     private void fwkTransferFocus(boolean forward) {
2141         log.finer(&quot;Transfer focus &quot; + (forward ? &quot;forward&quot; : &quot;backward&quot;));
2142 
2143         if (pageClient != null) {
2144             pageClient.transferFocus(forward);
2145         }
2146     }
2147 
2148     private void fwkSetCursor(long id) {
2149         log.finer(&quot;Set cursor: &quot; + id);
2150 
2151         if (pageClient != null) {
2152             pageClient.setCursor(id);
2153         }
2154     }
2155 
2156     private void fwkSetFocus(boolean focus) {
2157         log.finer(&quot;Set focus: &quot; + (focus ? &quot;true&quot; : &quot;false&quot;));
2158 
2159         if (pageClient != null) {
2160             pageClient.setFocus(focus);
2161         }
2162     }
2163 
2164     private void fwkSetTooltip(String tooltip) {
2165         log.finer(&quot;Set tooltip: &quot; + tooltip);
2166 
2167         if (pageClient != null) {
2168             pageClient.setTooltip(tooltip);
2169         }
2170     }
2171 
2172     private void fwkPrint() {
2173         log.finer(&quot;Print&quot;);
2174 
2175         if (uiClient != null) {
2176             uiClient.print();
2177         }
2178     }
2179 
2180     private void fwkSetRequestURL(long pFrame, int id, String url) {
2181         log.finer(&quot;Set request URL: id = &quot; + id + &quot;, url = &quot; + url);
2182 
2183         synchronized (requestURLs) {
2184             requestURLs.put(id, url);
2185         }
2186     }
2187 
2188     private void fwkRemoveRequestURL(long pFrame, int id) {
2189         log.finer(&quot;Set request URL: id = &quot; + id);
2190 
2191         synchronized (requestURLs) {
2192             requestURLs.remove(id);
2193             requestStarted.remove(id);
2194         }
2195     }
2196 
2197     private WebPage fwkCreateWindow(
2198             boolean menu, boolean status, boolean toolbar, boolean resizable) {
2199         log.finer(&quot;Create window&quot;);
2200 
2201         if (uiClient != null) {
2202             return uiClient.createPage(menu, status, toolbar, resizable);
2203         }
2204         return null;
2205     }
2206 
2207     private void fwkShowWindow() {
2208         log.finer(&quot;Show window&quot;);
2209 
2210         if (uiClient != null) {
2211             uiClient.showView();
2212         }
2213     }
2214 
2215     private void fwkCloseWindow() {
2216         log.finer(&quot;Close window&quot;);
2217 
2218         if (permitCloseWindowAction()) {
2219             if (uiClient != null) {
2220                 uiClient.closePage();
2221             }
2222         }
2223     }
2224 
2225     private WCRectangle fwkGetWindowBounds() {
2226         log.fine(&quot;Get window bounds&quot;);
2227 
2228         if (uiClient != null) {
2229             WCRectangle bounds = uiClient.getViewBounds();
2230             if (bounds != null) {
2231                 return bounds;
2232             }
2233         }
2234         return fwkGetPageBounds();
2235     }
2236 
2237     private void fwkSetWindowBounds(int x, int y, int w, int h) {
2238         log.finer(&quot;Set window bounds: &quot; + x + &quot; &quot; + y + &quot; &quot; + w + &quot; &quot; + h);
2239 
2240         if (uiClient != null) {
2241             uiClient.setViewBounds(new WCRectangle(x, y, w, h));
2242         }
2243     }
2244 
2245     private WCRectangle fwkGetPageBounds() {
2246         log.finer(&quot;Get page bounds&quot;);
2247         return new WCRectangle(0, 0, width, height);
2248     }
2249 
2250     private void fwkSetScrollbarsVisible(boolean visible) {
2251         // TODO: handle this request internally
2252     }
2253 
2254     private void fwkSetStatusbarText(String text) {
2255         log.finer(&quot;Set statusbar text: &quot; + text);
2256 
2257         if (uiClient != null) {
2258             uiClient.setStatusbarText(text);
2259         }
2260     }
2261 
2262     private String[] fwkChooseFile(String initialFileName, boolean multiple, String mimeFilters) {
2263         log.finer(&quot;Choose file, initial=&quot; + initialFileName);
2264 
2265         return uiClient != null
2266                 ? uiClient.chooseFile(initialFileName, multiple, mimeFilters)
2267                 : null;
2268     }
2269 
2270     private void fwkStartDrag(
2271           Object image,
2272           int imageOffsetX, int imageOffsetY,
2273           int eventPosX, int eventPosY,
2274           String[] mimeTypes, Object[] values,
2275           boolean isImageSource)
2276     {
2277         log.finer(&quot;Start drag: &quot;);
2278         if (uiClient != null) {
2279             uiClient.startDrag(
2280                   WCImage.getImage(image),
2281                   imageOffsetX, imageOffsetY,
2282                   eventPosX, eventPosY,
2283                   mimeTypes, values,
2284                   isImageSource);
2285         }
2286     }
2287 
2288     private WCPoint fwkScreenToWindow(WCPoint ptScreen) {
2289         log.finer(&quot;fwkScreenToWindow&quot;);
2290 
2291         if (pageClient != null) {
2292             return pageClient.screenToWindow(ptScreen);
2293         }
2294         return ptScreen;
2295     }
2296 
2297     private WCPoint fwkWindowToScreen(WCPoint ptWindow) {
2298         log.finer(&quot;fwkWindowToScreen&quot;);
2299 
2300         if (pageClient != null) {
2301             return pageClient.windowToScreen(ptWindow);
2302         }
2303         return ptWindow;
2304     }
2305 
2306 
2307     private void fwkAlert(String text) {
2308         log.fine(&quot;JavaScript alert(): text = &quot; + text);
2309 
2310         if (uiClient != null) {
2311             uiClient.alert(text);
2312         }
2313     }
2314 
2315     private boolean fwkConfirm(String text) {
2316         log.fine(&quot;JavaScript confirm(): text = &quot; + text);
2317 
2318         if (uiClient != null) {
2319             return uiClient.confirm(text);
2320         }
2321         return false;
2322     }
2323 
2324     private String fwkPrompt(String text, String defaultValue) {
2325         log.fine(&quot;JavaScript prompt(): text = &quot; + text + &quot;, default = &quot; + defaultValue);
2326 
2327         if (uiClient != null) {
2328             return uiClient.prompt(text, defaultValue);
2329         }
2330         return null;
2331     }
2332 
2333     private boolean fwkCanRunBeforeUnloadConfirmPanel() {
2334         log.fine(&quot;JavaScript canRunBeforeUnloadConfirmPanel()&quot;);
2335 
2336         if (uiClient != null) {
2337             return uiClient.canRunBeforeUnloadConfirmPanel();
2338         }
2339         return false;
2340     }
2341 
2342     private boolean fwkRunBeforeUnloadConfirmPanel(String message) {
2343         log.fine(&quot;JavaScript runBeforeUnloadConfirmPanel(): message = &quot; + message);
2344 
2345         if (uiClient != null) {
2346             return uiClient.runBeforeUnloadConfirmPanel(message);
2347         }
2348         return false;
2349     }
2350 
2351     private void fwkAddMessageToConsole(String message, int lineNumber,
2352             String sourceId)
2353     {
2354         log.fine(&quot;fwkAddMessageToConsole(): message = &quot; + message
2355                 + &quot;, lineNumber = &quot; + lineNumber + &quot;, sourceId = &quot; + sourceId);
2356         if (pageClient != null) {
2357             pageClient.addMessageToConsole(message, lineNumber, sourceId);
2358         }
2359     }
2360 
2361     private void fwkFireLoadEvent(long frameID, int state,
2362                                   String url, String contentType,
2363                                   double progress, int errorCode)
2364     {
2365         log.finer(&quot;Load event: pFrame = &quot; + frameID + &quot;, state = &quot; + state +
2366                 &quot;, url = &quot; + url + &quot;, contenttype=&quot; + contentType +
2367                 &quot;, progress = &quot; + progress + &quot;, error = &quot; + errorCode);
2368 
2369         fireLoadEvent(frameID, state, url, contentType, progress, errorCode);
2370     }
2371 
2372     private void fwkFireResourceLoadEvent(long frameID, int state,
2373                                           int id, String contentType,
2374                                           double progress, int errorCode)
2375     {
2376         log.finer(&quot;Resource load event: pFrame = &quot; + frameID + &quot;, state = &quot; + state +
2377                 &quot;, id = &quot; + id + &quot;, contenttype=&quot; + contentType +
2378                 &quot;, progress = &quot; + progress + &quot;, error = &quot; + errorCode);
2379 
2380         String url = requestURLs.get(id);
2381         if (url == null) {
2382             log.fine(&quot;Error in fwkFireResourceLoadEvent: unknown request id &quot; + id);
2383             return;
2384         }
2385 
2386         int eventState = state;
2387         // convert second and all subsequent STARTED into REDIRECTED
2388         if (state == LoadListenerClient.RESOURCE_STARTED) {
2389             if (requestStarted.contains(id)) {
2390                 eventState = LoadListenerClient.RESOURCE_REDIRECTED;
2391             } else {
2392                 requestStarted.add(id);
2393             }
2394         }
2395 
2396         fireResourceLoadEvent(frameID, eventState, url, contentType, progress, errorCode);
2397     }
2398 
2399     private boolean fwkPermitNavigateAction(long pFrame, String url) {
2400         log.fine(&quot;Policy: permit NAVIGATE: pFrame = &quot; + pFrame + &quot;, url = &quot; + url);
2401 
2402         if (policyClient != null) {
2403             return policyClient.permitNavigateAction(pFrame, str2url(url));
2404         }
2405         return true;
2406     }
2407 
2408     private boolean fwkPermitRedirectAction(long pFrame, String url) {
2409         log.fine(&quot;Policy: permit REDIRECT: pFrame = &quot; + pFrame + &quot;, url = &quot; + url);
2410 
2411         if (policyClient != null) {
2412             return policyClient.permitRedirectAction(pFrame, str2url(url));
2413         }
2414         return true;
2415     }
2416 
2417     private boolean fwkPermitAcceptResourceAction(long pFrame, String url) {
2418         log.fine(&quot;Policy: permit ACCEPT_RESOURCE: pFrame + &quot; + pFrame + &quot;, url = &quot; + url);
2419 
2420         if (policyClient != null) {
2421             return policyClient.permitAcceptResourceAction(pFrame, str2url(url));
2422         }
2423         return true;
2424     }
2425 
2426     private boolean fwkPermitSubmitDataAction(long pFrame, String url,
2427                                               String httpMethod, boolean isSubmit)
2428     {
2429         log.fine(&quot;Policy: permit &quot; + (isSubmit ? &quot;&quot; : &quot;RE&quot;) + &quot;SUBMIT_DATA: pFrame = &quot; +
2430                 pFrame + &quot;, url = &quot; + url + &quot;, httpMethod = &quot; + httpMethod);
2431 
2432         if (policyClient != null) {
2433             if (isSubmit) {
2434                 return policyClient.permitSubmitDataAction(pFrame, str2url(url), httpMethod);
2435             } else {
2436                 return policyClient.permitResubmitDataAction(pFrame, str2url(url), httpMethod);
2437             }
2438         }
2439         return true;
2440     }
2441 
2442     private boolean fwkPermitEnableScriptsAction(long pFrame, String url) {
2443         log.fine(&quot;Policy: permit ENABLE_SCRIPTS: pFrame + &quot; + pFrame + &quot;, url = &quot; + url);
2444 
2445         if (policyClient != null) {
2446             return policyClient.permitEnableScriptsAction(pFrame, str2url(url));
2447         }
2448         return true;
2449     }
2450 
2451     private boolean fwkPermitNewWindowAction(long pFrame, String url) {
2452         log.fine(&quot;Policy: permit NEW_PAGE: pFrame = &quot; + pFrame + &quot;, url = &quot; + url);
2453 
2454         if (policyClient != null) {
2455             return policyClient.permitNewPageAction(pFrame, str2url(url));
2456         }
2457         return true;
2458     }
2459 
2460     // Called from fwkCloseWindow, that&#39;s why no &quot;fwk&quot; prefix
2461     private boolean permitCloseWindowAction() {
2462         log.fine(&quot;Policy: permit CLOSE_PAGE&quot;);
2463 
2464         if (policyClient != null) {
2465             // Unfortunately, webkit doesn&#39;t provide an information about what
2466             // web frame initiated close window request, so using main frame here
2467             return policyClient.permitClosePageAction(getMainFrame());
2468         }
2469         return true;
2470     }
2471 
2472     private void fwkRepaintAll() {
2473         log.fine(&quot;Repainting the entire page&quot;);
2474         repaintAll();
2475     }
2476 
2477     private boolean fwkSendInspectorMessageToFrontend(String message) {
2478         if (log.isLoggable(Level.FINE)) {
2479             log.fine(&quot;Sending inspector message to frontend, message: [{0}]&quot;,
2480                     message);
2481         }
2482         boolean result = false;
2483         if (inspectorClient != null) {
2484             log.fine(&quot;Invoking inspector client&quot;);
2485             result = inspectorClient.sendMessageToFrontend(message);
2486         }
2487         if (log.isLoggable(Level.FINE)) {
2488             log.fine(&quot;Result: [{0}]&quot;, result);
2489         }
2490         return result;
2491     }
2492 
2493     // ---- DumpRenderTree support ---- //
2494 
2495     public static int getWorkerThreadCount() {
2496         return twkWorkerThreadCount();
2497     }
2498 
2499     private static native int twkWorkerThreadCount();
2500 
2501     private void fwkDidClearWindowObject(long pContext, long pWindowObject) {
2502         if (pageClient != null) {
2503             pageClient.didClearWindowObject(pContext, pWindowObject);
2504         }
2505     }
2506 
2507     // *************************************************************************
2508     // Private methods
2509     // *************************************************************************
2510 
2511     private URL str2url(String url) {
2512         try {
2513             return newURL(url);
2514         } catch (MalformedURLException ex) {
2515             log.fine(&quot;Exception while converting \&quot;&quot; + url + &quot;\&quot; to URL&quot;, ex);
2516         }
2517         return null;
2518     }
2519 
2520     private void fireLoadEvent(long frameID, int state, String url,
2521             String contentType, double progress, int errorCode)
2522     {
2523         for (LoadListenerClient l : loadListenerClients) {
2524             l.dispatchLoadEvent(frameID, state, url, contentType, progress, errorCode);
2525         }
2526     }
2527 
2528     private void fireResourceLoadEvent(long frameID, int state, String url,
2529             String contentType, double progress, int errorCode)
2530     {
2531         for (LoadListenerClient l : loadListenerClients) {
2532             l.dispatchResourceLoadEvent(frameID, state, url, contentType, progress, errorCode);
2533         }
2534     }
2535 
2536     private void repaintAll() {
2537         dirtyRects.clear();
2538         addDirtyRect(new WCRectangle(0, 0, width, height));
2539     }
2540 
2541     // Package scope method for testing
2542     int test_getFramesCount() {
2543         return frames.size();
2544     }
2545 
2546     // *************************************************************************
2547     // Native methods
2548     // *************************************************************************
2549 
2550     private static native void twkInitWebCore(boolean useJIT, boolean useDFGJIT, boolean useCSS3D);
2551     private native long twkCreatePage(boolean editable);
2552     private native void twkInit(long pPage, boolean usePlugins, float devicePixelScale);
2553     private native void twkDestroyPage(long pPage);
2554 
2555     private native long twkGetMainFrame(long pPage);
2556     private native long twkGetParentFrame(long pFrame);
2557     private native long[] twkGetChildFrames(long pFrame);
2558 
2559     private native String twkGetName(long pFrame);
2560     private native String twkGetURL(long pFrame);
2561     private native String twkGetInnerText(long pFrame);
2562     private native String twkGetRenderTree(long pFrame);
2563     private native String twkGetContentType(long pFrame);
2564     private native String twkGetTitle(long pFrame);
2565     private native String twkGetIconURL(long pFrame);
2566     private native static Document twkGetDocument(long pFrame);
2567     private native static Element twkGetOwnerElement(long pFrame);
2568 
2569     private native void twkOpen(long pFrame, String url);
2570     private native void twkOverridePreference(long pPage, String key, String value);
2571     private native void twkResetToConsistentStateBeforeTesting(long pPage);
2572     private native void twkLoad(long pFrame, String text, String contentType);
2573     private native boolean twkIsLoading(long pFrame);
2574     private native void twkStop(long pFrame);
2575     private native void twkStopAll(long pPage); // sync
2576     private native void twkRefresh(long pFrame);
2577 
2578     private native boolean twkGoBackForward(long pPage, int distance);
2579 
2580     private native boolean twkCopy(long pFrame);
2581     private native boolean twkFindInPage(long pPage,
2582                                          String stringToFind, boolean forward,
2583                                          boolean wrap, boolean matchCase);
2584     private native boolean twkFindInFrame(long pFrame,
2585                                           String stringToFind, boolean forward,
2586                                           boolean wrap, boolean matchCase);
2587 
2588     private native float twkGetZoomFactor(long pFrame, boolean textOnly);
2589     private native void twkSetZoomFactor(long pFrame, float zoomFactor, boolean textOnly);
2590 
2591     private native Object twkExecuteScript(long pFrame, String script);
2592 
2593     private native void twkReset(long pFrame);
2594 
2595     private native int twkGetFrameHeight(long pFrame);
2596     private native int twkBeginPrinting(long pPage, float width, float height);
2597     private native void twkEndPrinting(long pPage);
2598     private native void twkPrint(long pPage, WCRenderQueue gc, int pageNumber, float width);
2599     private native float twkAdjustFrameHeight(long pFrame, float oldTop, float oldBottom, float bottomLimit);
2600 
2601     private native int[] twkGetVisibleRect(long pFrame);
2602     private native void twkScrollToPosition(long pFrame, int x, int y);
2603     private native int[] twkGetContentSize(long pFrame);
2604     private native void twkSetTransparent(long pFrame, boolean isTransparent);
2605     private native void twkSetBackgroundColor(long pFrame, int backgroundColor);
2606 
2607     private native void twkSetBounds(long pPage, int x, int y, int w, int h);
2608     private native void twkPrePaint(long pPage);
2609     private native void twkUpdateContent(long pPage, WCRenderQueue rq, int x, int y, int w, int h);
<a name="4" id="anc4"></a><span class="line-added">2610     private native void twkUpdateRendering(long pPage);</span>
2611     private native void twkPostPaint(long pPage, WCRenderQueue rq,
2612                                      int x, int y, int w, int h);
2613 
2614     private native String twkGetEncoding(long pPage);
2615     private native void twkSetEncoding(long pPage, String encoding);
2616 
2617     private native void twkProcessFocusEvent(long pPage, int id, int direction);
2618     private native boolean twkProcessKeyEvent(long pPage, int type, String text,
2619                                               String keyIdentifier,
2620                                               int windowsVirtualKeyCode,
2621                                               boolean shift, boolean ctrl,
2622                                               boolean alt, boolean meta, double when);
2623     private native boolean twkProcessMouseEvent(long pPage, int id,
2624                                                 int button, int clickCount,
2625                                                 int x, int y, int sx, int sy,
2626                                                 boolean shift, boolean control, boolean alt, boolean meta,
2627                                                 boolean popupTrigger, double when);
2628     private native boolean twkProcessMouseWheelEvent(long pPage,
2629                                                      int x, int y, int sx, int sy,
2630                                                      float dx, float dy,
2631                                                      boolean shift, boolean control, boolean alt, boolean meta,
2632                                                      double when);
2633     private native boolean twkProcessInputTextChange(long pPage, String committed, String composed,
2634                                                      int[] attributes, int caretPosition);
2635     private native boolean twkProcessCaretPositionChange(long pPage, int caretPosition);
2636     private native int[] twkGetTextLocation(long pPage, int charIndex);
2637     private native int twkGetInsertPositionOffset(long pPage);
2638     private native int twkGetCommittedTextLength(long pPage);
2639     private native String twkGetCommittedText(long pPage);
2640     private native String twkGetSelectedText(long pPage);
2641 
2642     private native int twkProcessDrag(long page,
2643             int commandId,
2644             String[] mimeTypes, String[] values,
2645             int x, int y,
2646             int screenX, int screenY,
2647             int dndActionId);
2648 
2649     private native boolean twkExecuteCommand(long page, String command,
2650                                              String value);
2651     private native boolean twkQueryCommandEnabled(long page, String command);
2652     private native boolean twkQueryCommandState(long page, String command);
2653     private native String twkQueryCommandValue(long page, String command);
2654     private native boolean twkIsEditable(long page);
2655     private native void twkSetEditable(long page, boolean editable);
2656     private native String twkGetHtml(long pFrame);
2657 
2658     private native boolean twkGetUsePageCache(long page);
2659     private native void twkSetUsePageCache(long page, boolean usePageCache);
2660     private native boolean twkGetDeveloperExtrasEnabled(long page);
2661     private native void twkSetDeveloperExtrasEnabled(long page,
2662                                                      boolean enabled);
2663     private native boolean twkIsJavaScriptEnabled(long page);
2664     private native void twkSetJavaScriptEnabled(long page, boolean enable);
2665     private native boolean twkIsContextMenuEnabled(long page);
2666     private native void twkSetContextMenuEnabled(long page, boolean enable);
2667     private native void twkSetUserStyleSheetLocation(long page, String url);
2668     private native String twkGetUserAgent(long page);
2669     private native void twkSetUserAgent(long page, String userAgent);
2670     private native void twkSetLocalStorageDatabasePath(long page, String path);
2671     private native void twkSetLocalStorageEnabled(long page, boolean enabled);
2672 
2673     private native int twkGetUnloadEventListenersCount(long pFrame);
2674 
2675     private native void twkConnectInspectorFrontend(long pPage);
2676     private native void twkDisconnectInspectorFrontend(long pPage);
2677     private native void twkDispatchInspectorMessageFromFrontend(long pPage,
2678                                                                 String message);
2679     private static native void twkDoJSCGarbageCollection();
2680 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorker.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorker.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorker.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorker.cpp
@@ -38,10 +38,11 @@
 #include "ServiceWorkerClientData.h"
 #include "ServiceWorkerContainer.h"
 #include "ServiceWorkerGlobalScope.h"
 #include "ServiceWorkerProvider.h"
 #include "ServiceWorkerThread.h"
+#include "WorkerSWClientConnection.h"
 #include <JavaScriptCore/JSCJSValueInlines.h>
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/NeverDestroyed.h>
 
 #define WORKER_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), ServiceWorker, "%p - ServiceWorker::" fmt, this, ##__VA_ARGS__)
@@ -88,46 +89,44 @@
     }
 
     updatePendingActivityForEventDispatch();
 }
 
-ExceptionOr<void> ServiceWorker::postMessage(ScriptExecutionContext& context, JSC::JSValue messageValue, Vector<JSC::Strong<JSC::JSObject>>&& transfer)
+SWClientConnection& ServiceWorker::swConnection()
 {
-    if (m_isStopped || !context.sessionID().isValid())
-        return Exception { InvalidStateError };
-
-    if (state() == State::Redundant)
-        return Exception { InvalidStateError, "Service Worker state is redundant"_s };
-
-    // FIXME: Invoke Run Service Worker algorithm with serviceWorker as the argument.
+    ASSERT(scriptExecutionContext());
+    if (is<WorkerGlobalScope>(scriptExecutionContext()))
+        return downcast<WorkerGlobalScope>(scriptExecutionContext())->swClientConnection();
+    return ServiceWorkerProvider::singleton().serviceWorkerConnection();
+}
 
-    auto* execState = context.execState();
-    ASSERT(execState);
+ExceptionOr<void> ServiceWorker::postMessage(JSC::JSGlobalObject& globalObject, JSC::JSValue messageValue, PostMessageOptions&& options)
+{
+    if (m_isStopped)
+        return Exception { InvalidStateError };
 
     Vector<RefPtr<MessagePort>> ports;
-    auto messageData = SerializedScriptValue::create(*execState, messageValue, WTFMove(transfer), ports, SerializationContext::WorkerPostMessage);
+    auto messageData = SerializedScriptValue::create(globalObject, messageValue, WTFMove(options.transfer), ports, SerializationContext::WorkerPostMessage);
     if (messageData.hasException())
         return messageData.releaseException();
 
     // Disentangle the port in preparation for sending it to the remote context.
     auto portsOrException = MessagePort::disentanglePorts(WTFMove(ports));
     if (portsOrException.hasException())
         return portsOrException.releaseException();
 
+    auto& context = *scriptExecutionContext();
     ServiceWorkerOrClientIdentifier sourceIdentifier;
     if (is<ServiceWorkerGlobalScope>(context))
         sourceIdentifier = downcast<ServiceWorkerGlobalScope>(context).thread().identifier();
     else {
-        auto& connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(context.sessionID());
+        auto& connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();
         sourceIdentifier = ServiceWorkerClientIdentifier { connection.serverConnectionIdentifier(), downcast<Document>(context).identifier() };
     }
 
-    MessageWithMessagePorts message = { messageData.releaseReturnValue(), portsOrException.releaseReturnValue() };
-    callOnMainThread([sessionID = context.sessionID(), destinationIdentifier = identifier(), message = WTFMove(message), sourceIdentifier = WTFMove(sourceIdentifier)]() mutable {
-        auto& connection = ServiceWorkerProvider::singleton().serviceWorkerConnectionForSession(sessionID);
-        connection.postMessageToServiceWorker(destinationIdentifier, WTFMove(message), sourceIdentifier);
-    });
+    MessageWithMessagePorts message { messageData.releaseReturnValue(), portsOrException.releaseReturnValue() };
+    swConnection().postMessageToServiceWorker(identifier(), WTFMove(message), sourceIdentifier);
     return { };
 }
 
 EventTargetInterface ServiceWorker::eventTargetInterface() const
 {
@@ -142,16 +141,10 @@
 const char* ServiceWorker::activeDOMObjectName() const
 {
     return "ServiceWorker";
 }
 
-bool ServiceWorker::canSuspendForDocumentSuspension() const
-{
-    // FIXME: We should do better as this prevents the page from entering PageCache when there is a Service Worker.
-    return !hasPendingActivity();
-}
-
 void ServiceWorker::stop()
 {
     m_isStopped = true;
     removeAllEventListeners();
     scriptExecutionContext()->unregisterServiceWorker(*this);

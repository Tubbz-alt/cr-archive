<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStoreBarrierInsertionPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGStackLayoutPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGGraph.h&quot;
 32 #include &quot;DFGPhase.h&quot;
 33 #include &quot;DFGValueSource.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 class StackLayoutPhase : public Phase {
<span class="line-modified"> 39     static const bool verbose = false;</span>
 40 
 41 public:
 42     StackLayoutPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;stack layout&quot;)
 44     {
 45     }
 46 
 47     bool run()
 48     {
 49         // This enumerates the locals that we actually care about and packs them. So for example
 50         // if we use local 1, 3, 4, 5, 7, then we remap them: 1-&gt;0, 3-&gt;1, 4-&gt;2, 5-&gt;3, 7-&gt;4. We
 51         // treat a variable as being &quot;used&quot; if there exists an access to it (SetLocal, GetLocal,
 52         // Flush, PhantomLocal).
 53 
<span class="line-modified"> 54         BitVector usedLocals;</span>
 55 
 56         // Collect those variables that are used from IR.
 57         bool hasNodesThatNeedFixup = false;
 58         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 59             BasicBlock* block = m_graph.block(blockIndex);
 60             if (!block)
 61                 continue;
 62             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
 63                 Node* node = block-&gt;at(nodeIndex);
 64                 switch (node-&gt;op()) {
 65                 case GetLocal:
 66                 case SetLocal:
 67                 case Flush:
 68                 case PhantomLocal: {
 69                     VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified"> 70                     if (variable-&gt;local().isArgument())</span>
 71                         break;
<span class="line-modified"> 72                     usedLocals.set(variable-&gt;local().toLocal());</span>
 73                     break;
 74                 }
 75 
 76                 case LoadVarargs:
 77                 case ForwardVarargs: {
 78                     LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified"> 79                     if (data-&gt;count.isLocal())</span>
<span class="line-removed"> 80                         usedLocals.set(data-&gt;count.toLocal());</span>
 81                     if (data-&gt;start.isLocal()) {
 82                         // This part really relies on the contiguity of stack layout
 83                         // assignments.
 84                         ASSERT(VirtualRegister(data-&gt;start.offset() + data-&gt;limit - 1).isLocal());
 85                         for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified"> 86                             usedLocals.set(VirtualRegister(data-&gt;start.offset() + i).toLocal());</span>
 87                     } // the else case shouldn&#39;t happen.
 88                     hasNodesThatNeedFixup = true;
 89                     break;
 90                 }
 91 
 92                 case PutStack:
 93                 case GetStack: {
 94                     StackAccessData* stack = node-&gt;stackAccessData();
<span class="line-modified"> 95                     if (stack-&gt;local.isArgument())</span>
 96                         break;
<span class="line-modified"> 97                     usedLocals.set(stack-&gt;local.toLocal());</span>
 98                     break;
 99                 }
100 
101                 default:
102                     break;
103                 }
104             }
105         }
106 
107         for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
108             InlineCallFrame* inlineCallFrame = *iter;
109 
110             if (inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified">111                 usedLocals.set(VirtualRegister(</span>
<span class="line-modified">112                     CallFrameSlot::argumentCount + inlineCallFrame-&gt;stackOffset).toLocal());</span>
113             }
114 
115             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
<span class="line-modified">116                 usedLocals.set(VirtualRegister(</span>
<span class="line-modified">117                     virtualRegisterForArgument(argument).offset() +</span>
<span class="line-modified">118                     inlineCallFrame-&gt;stackOffset).toLocal());</span>
119             }
120         }
121 
<span class="line-modified">122         Vector&lt;unsigned&gt; allocation(usedLocals.size());</span>
123         m_graph.m_nextMachineLocal = codeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters();
<span class="line-modified">124         for (unsigned i = 0; i &lt; usedLocals.size(); ++i) {</span>
<span class="line-modified">125             if (!usedLocals.get(i)) {</span>
126                 allocation[i] = UINT_MAX;
127                 continue;
128             }
129 
130             allocation[i] = m_graph.m_nextMachineLocal++;
131         }
132 
133         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
134             VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
135             if (!variable-&gt;isRoot())
136                 continue;
137 
<span class="line-modified">138             if (variable-&gt;local().isArgument()) {</span>
<span class="line-modified">139                 variable-&gt;machineLocal() = variable-&gt;local();</span>
140                 continue;
141             }
142 
<span class="line-modified">143             size_t local = variable-&gt;local().toLocal();</span>
<span class="line-modified">144             if (local &gt;= allocation.size())</span>

145                 continue;
146 
<span class="line-modified">147             if (allocation[local] == UINT_MAX)</span>
148                 continue;
149 
<span class="line-modified">150             variable-&gt;machineLocal() = assign(allocation, variable-&gt;local());</span>
151         }
152 
153         for (StackAccessData* data : m_graph.m_stackAccessData) {
<span class="line-modified">154             if (!data-&gt;local.isLocal()) {</span>
<span class="line-modified">155                 data-&gt;machineLocal = data-&gt;local;</span>
156                 continue;
157             }
158 
<span class="line-modified">159             if (static_cast&lt;size_t&gt;(data-&gt;local.toLocal()) &gt;= allocation.size())</span>
<span class="line-modified">160                 continue;</span>
<span class="line-modified">161             if (allocation[data-&gt;local.toLocal()] == UINT_MAX)</span>
<span class="line-modified">162                 continue;</span>


163 
<span class="line-modified">164             data-&gt;machineLocal = assign(allocation, data-&gt;local);</span>
165         }
166 
167         if (!m_graph.needsScopeRegister())
168             codeBlock()-&gt;setScopeRegister(VirtualRegister());
169         else
<span class="line-modified">170             codeBlock()-&gt;setScopeRegister(assign(allocation, codeBlock()-&gt;scopeRegister()));</span>
171 
172         for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
173             InlineVariableData data = m_graph.m_inlineVariableData[i];
174             InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
175 
<span class="line-modified">176             if (inlineCallFrame-&gt;isVarargs()) {</span>
<span class="line-modified">177                 inlineCallFrame-&gt;argumentCountRegister = assign(</span>
<span class="line-removed">178                     allocation, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount));</span>
<span class="line-removed">179             }</span>
180 
181             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
182                 ArgumentPosition&amp; position = m_graph.m_argumentPositions[
183                     data.argumentPositionStart + argument];
184                 VariableAccessData* variable = position.someVariable();
185                 ValueSource source;
186                 if (!variable)
187                     source = ValueSource(SourceIsDead);
188                 else {
189                     source = ValueSource::forFlushFormat(
190                         variable-&gt;machineLocal(), variable-&gt;flushFormat());
191                 }
192                 inlineCallFrame-&gt;argumentsWithFixup[argument] = source.valueRecovery();
193             }
194 
195             RELEASE_ASSERT(inlineCallFrame-&gt;isClosureCall == !!data.calleeVariable);
196             if (inlineCallFrame-&gt;isClosureCall) {
197                 VariableAccessData* variable = data.calleeVariable-&gt;find();
198                 ValueSource source = ValueSource::forFlushFormat(
199                     variable-&gt;machineLocal(),
200                     variable-&gt;flushFormat());
201                 inlineCallFrame-&gt;calleeRecovery = source.valueRecovery();
202             } else
203                 RELEASE_ASSERT(inlineCallFrame-&gt;calleeRecovery.isConstant());
204         }
205 
206         // Fix Varargs&#39; variable references.
207         if (hasNodesThatNeedFixup) {
208             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
209                 BasicBlock* block = m_graph.block(blockIndex);
210                 if (!block)
211                     continue;
212                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
213                     Node* node = block-&gt;at(nodeIndex);
214                     switch (node-&gt;op()) {
215                     case LoadVarargs:
216                     case ForwardVarargs: {
217                         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">218                         data-&gt;machineCount = assign(allocation, data-&gt;count);</span>
<span class="line-modified">219                         data-&gt;machineStart = assign(allocation, data-&gt;start);</span>
220                         break;
221                     }
222 
223                     default:
224                         break;
225                     }
226                 }
227             }
228         }
229 
230         return true;
231     }
232 
233 private:
<span class="line-modified">234     VirtualRegister assign(const Vector&lt;unsigned&gt;&amp; allocation, VirtualRegister src)</span>
235     {
<span class="line-modified">236         VirtualRegister result = src;</span>
<span class="line-modified">237         if (result.isLocal()) {</span>
<span class="line-modified">238             unsigned myAllocation = allocation[result.toLocal()];</span>
<span class="line-modified">239             if (myAllocation == UINT_MAX)</span>
<span class="line-modified">240                 result = VirtualRegister();</span>
<span class="line-modified">241             else</span>
<span class="line-modified">242                 result = virtualRegisterForLocal(myAllocation);</span>
<span class="line-modified">243         }</span>
<span class="line-removed">244         return result;</span>
245     }
246 };
247 
248 bool performStackLayout(Graph&amp; graph)
249 {
250     return runPhase&lt;StackLayoutPhase&gt;(graph);
251 }
252 
253 } } // namespace JSC::DFG
254 
255 #endif // ENABLE(DFG_JIT)
256 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGStackLayoutPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGGraph.h&quot;
 32 #include &quot;DFGPhase.h&quot;
 33 #include &quot;DFGValueSource.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 class StackLayoutPhase : public Phase {
<span class="line-modified"> 39     static constexpr bool verbose = false;</span>
 40 
 41 public:
 42     StackLayoutPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;stack layout&quot;)
 44     {
 45     }
 46 
 47     bool run()
 48     {
 49         // This enumerates the locals that we actually care about and packs them. So for example
 50         // if we use local 1, 3, 4, 5, 7, then we remap them: 1-&gt;0, 3-&gt;1, 4-&gt;2, 5-&gt;3, 7-&gt;4. We
 51         // treat a variable as being &quot;used&quot; if there exists an access to it (SetLocal, GetLocal,
 52         // Flush, PhantomLocal).
 53 
<span class="line-modified"> 54         Operands&lt;bool&gt; usedOperands(0, graph().m_localVars, graph().m_tmps, false);</span>
 55 
 56         // Collect those variables that are used from IR.
 57         bool hasNodesThatNeedFixup = false;
 58         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 59             BasicBlock* block = m_graph.block(blockIndex);
 60             if (!block)
 61                 continue;
 62             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
 63                 Node* node = block-&gt;at(nodeIndex);
 64                 switch (node-&gt;op()) {
 65                 case GetLocal:
 66                 case SetLocal:
 67                 case Flush:
 68                 case PhantomLocal: {
 69                     VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified"> 70                     if (variable-&gt;operand().isArgument())</span>
 71                         break;
<span class="line-modified"> 72                     usedOperands.setOperand(variable-&gt;operand(), true);</span>
 73                     break;
 74                 }
 75 
 76                 case LoadVarargs:
 77                 case ForwardVarargs: {
 78                     LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified"> 79                     usedOperands.setOperand(data-&gt;count, true);</span>

 80                     if (data-&gt;start.isLocal()) {
 81                         // This part really relies on the contiguity of stack layout
 82                         // assignments.
 83                         ASSERT(VirtualRegister(data-&gt;start.offset() + data-&gt;limit - 1).isLocal());
 84                         for (unsigned i = data-&gt;limit; i--;)
<span class="line-modified"> 85                             usedOperands.setOperand(VirtualRegister(data-&gt;start.offset() + i), true);</span>
 86                     } // the else case shouldn&#39;t happen.
 87                     hasNodesThatNeedFixup = true;
 88                     break;
 89                 }
 90 
 91                 case PutStack:
 92                 case GetStack: {
 93                     StackAccessData* stack = node-&gt;stackAccessData();
<span class="line-modified"> 94                     if (stack-&gt;operand.isArgument())</span>
 95                         break;
<span class="line-modified"> 96                     usedOperands.setOperand(stack-&gt;operand, true);</span>
 97                     break;
 98                 }
 99 
100                 default:
101                     break;
102                 }
103             }
104         }
105 
106         for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
107             InlineCallFrame* inlineCallFrame = *iter;
108 
109             if (inlineCallFrame-&gt;isVarargs()) {
<span class="line-modified">110                 usedOperands.setOperand(VirtualRegister(</span>
<span class="line-modified">111                     CallFrameSlot::argumentCountIncludingThis + inlineCallFrame-&gt;stackOffset), true);</span>
112             }
113 
114             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
<span class="line-modified">115                 usedOperands.setOperand(VirtualRegister(</span>
<span class="line-modified">116                     virtualRegisterForArgumentIncludingThis(argument).offset() +</span>
<span class="line-modified">117                     inlineCallFrame-&gt;stackOffset), true);</span>
118             }
119         }
120 
<span class="line-modified">121         Vector&lt;unsigned&gt; allocation(usedOperands.size());</span>
122         m_graph.m_nextMachineLocal = codeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters();
<span class="line-modified">123         for (unsigned i = 0; i &lt; usedOperands.size(); ++i) {</span>
<span class="line-modified">124             if (!usedOperands.getForOperandIndex(i)) {</span>
125                 allocation[i] = UINT_MAX;
126                 continue;
127             }
128 
129             allocation[i] = m_graph.m_nextMachineLocal++;
130         }
131 
132         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
133             VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
134             if (!variable-&gt;isRoot())
135                 continue;
136 
<span class="line-modified">137             if (variable-&gt;operand().isArgument()) {</span>
<span class="line-modified">138                 variable-&gt;machineLocal() = variable-&gt;operand().virtualRegister();</span>
139                 continue;
140             }
141 
<span class="line-modified">142             Operand operand = variable-&gt;operand();</span>
<span class="line-modified">143             size_t index = usedOperands.operandIndex(operand);</span>
<span class="line-added">144             if (index &gt;= allocation.size())</span>
145                 continue;
146 
<span class="line-modified">147             if (allocation[index] == UINT_MAX)</span>
148                 continue;
149 
<span class="line-modified">150             variable-&gt;machineLocal() = assign(usedOperands, allocation, variable-&gt;operand());</span>
151         }
152 
153         for (StackAccessData* data : m_graph.m_stackAccessData) {
<span class="line-modified">154             if (data-&gt;operand.isArgument()) {</span>
<span class="line-modified">155                 data-&gt;machineLocal = data-&gt;operand.virtualRegister();</span>
156                 continue;
157             }
158 
<span class="line-modified">159             if (data-&gt;operand.isLocal()) {</span>
<span class="line-modified">160                 if (static_cast&lt;size_t&gt;(data-&gt;operand.toLocal()) &gt;= allocation.size())</span>
<span class="line-modified">161                     continue;</span>
<span class="line-modified">162                 if (allocation[data-&gt;operand.toLocal()] == UINT_MAX)</span>
<span class="line-added">163                     continue;</span>
<span class="line-added">164             }</span>
165 
<span class="line-modified">166             data-&gt;machineLocal = assign(usedOperands, allocation, data-&gt;operand);</span>
167         }
168 
169         if (!m_graph.needsScopeRegister())
170             codeBlock()-&gt;setScopeRegister(VirtualRegister());
171         else
<span class="line-modified">172             codeBlock()-&gt;setScopeRegister(assign(usedOperands, allocation, codeBlock()-&gt;scopeRegister()));</span>
173 
174         for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
175             InlineVariableData data = m_graph.m_inlineVariableData[i];
176             InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
177 
<span class="line-modified">178             if (inlineCallFrame-&gt;isVarargs())</span>
<span class="line-modified">179                 inlineCallFrame-&gt;argumentCountRegister = assign(usedOperands, allocation, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>


180 
181             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
182                 ArgumentPosition&amp; position = m_graph.m_argumentPositions[
183                     data.argumentPositionStart + argument];
184                 VariableAccessData* variable = position.someVariable();
185                 ValueSource source;
186                 if (!variable)
187                     source = ValueSource(SourceIsDead);
188                 else {
189                     source = ValueSource::forFlushFormat(
190                         variable-&gt;machineLocal(), variable-&gt;flushFormat());
191                 }
192                 inlineCallFrame-&gt;argumentsWithFixup[argument] = source.valueRecovery();
193             }
194 
195             RELEASE_ASSERT(inlineCallFrame-&gt;isClosureCall == !!data.calleeVariable);
196             if (inlineCallFrame-&gt;isClosureCall) {
197                 VariableAccessData* variable = data.calleeVariable-&gt;find();
198                 ValueSource source = ValueSource::forFlushFormat(
199                     variable-&gt;machineLocal(),
200                     variable-&gt;flushFormat());
201                 inlineCallFrame-&gt;calleeRecovery = source.valueRecovery();
202             } else
203                 RELEASE_ASSERT(inlineCallFrame-&gt;calleeRecovery.isConstant());
204         }
205 
206         // Fix Varargs&#39; variable references.
207         if (hasNodesThatNeedFixup) {
208             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
209                 BasicBlock* block = m_graph.block(blockIndex);
210                 if (!block)
211                     continue;
212                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
213                     Node* node = block-&gt;at(nodeIndex);
214                     switch (node-&gt;op()) {
215                     case LoadVarargs:
216                     case ForwardVarargs: {
217                         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">218                         data-&gt;machineCount = assign(usedOperands, allocation, data-&gt;count);</span>
<span class="line-modified">219                         data-&gt;machineStart = assign(usedOperands, allocation, data-&gt;start);</span>
220                         break;
221                     }
222 
223                     default:
224                         break;
225                     }
226                 }
227             }
228         }
229 
230         return true;
231     }
232 
233 private:
<span class="line-modified">234     VirtualRegister assign(const Operands&lt;bool&gt;&amp; usedOperands, const Vector&lt;unsigned&gt;&amp; allocation, Operand operand)</span>
235     {
<span class="line-modified">236         if (operand.isArgument())</span>
<span class="line-modified">237             return operand.virtualRegister();</span>
<span class="line-modified">238 </span>
<span class="line-modified">239         size_t operandIndex = usedOperands.operandIndex(operand);</span>
<span class="line-modified">240         unsigned myAllocation = allocation[operandIndex];</span>
<span class="line-modified">241         if (myAllocation == UINT_MAX)</span>
<span class="line-modified">242             return VirtualRegister();</span>
<span class="line-modified">243         return virtualRegisterForLocal(myAllocation);</span>

244     }
245 };
246 
247 bool performStackLayout(Graph&amp; graph)
248 {
249     return runPhase&lt;StackLayoutPhase&gt;(graph);
250 }
251 
252 } } // namespace JSC::DFG
253 
254 #endif // ENABLE(DFG_JIT)
255 
</pre>
</td>
</tr>
</table>
<center><a href="DFGSpeculativeJIT64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStoreBarrierInsertionPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
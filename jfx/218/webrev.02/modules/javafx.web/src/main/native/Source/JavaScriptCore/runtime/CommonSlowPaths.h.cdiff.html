<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonSlowPaths.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Completion.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-removed">- #include &quot;BytecodeStructs.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeSpecializationKind.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;FunctionCodeBlock.h&quot;
<span class="line-new-header">--- 23,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,36 ***</span>
      if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
          return 0;
      return numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis) + numberOfExtraSlots(argumentCountIncludingThis);
  }
  
<span class="line-modified">! ALWAYS_INLINE CodeBlock* codeBlockFromCallFrameCallee(ExecState* exec, CodeSpecializationKind kind)</span>
  {
<span class="line-modified">!     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
      ASSERT(!callee-&gt;isHostFunction());
      return callee-&gt;jsExecutable()-&gt;codeBlockFor(kind);
  }
  
<span class="line-modified">! ALWAYS_INLINE int arityCheckFor(ExecState* exec, VM&amp; vm, CodeSpecializationKind kind)</span>
  {
<span class="line-modified">!     CodeBlock* newCodeBlock = codeBlockFromCallFrameCallee(exec, kind);</span>
<span class="line-modified">!     ASSERT(exec-&gt;argumentCountIncludingThis() &lt; static_cast&lt;unsigned&gt;(newCodeBlock-&gt;numParameters()));</span>
<span class="line-modified">!     int padding = numberOfStackPaddingSlotsWithExtraSlots(newCodeBlock, exec-&gt;argumentCountIncludingThis());</span>
  
<span class="line-modified">!     Register* newStack = exec-&gt;registers() - WTF::roundUpToMultipleOf(stackAlignmentRegisters(), padding);</span>
  
      if (UNLIKELY(!vm.ensureStackCapacityFor(newStack)))
          return -1;
      return padding;
  }
  
<span class="line-modified">! inline bool opInByVal(ExecState* exec, JSValue baseVal, JSValue propName, ArrayProfile* arrayProfile = nullptr)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (!baseVal.isObject()) {
<span class="line-modified">!         throwException(exec, scope, createInvalidInParameterError(exec, baseVal));</span>
          return false;
      }
  
      JSObject* baseObj = asObject(baseVal);
      if (arrayProfile)
<span class="line-new-header">--- 69,36 ---</span>
      if (argumentCountIncludingThis &gt;= codeBlock-&gt;numParameters())
          return 0;
      return numberOfStackPaddingSlots(codeBlock, argumentCountIncludingThis) + numberOfExtraSlots(argumentCountIncludingThis);
  }
  
<span class="line-modified">! ALWAYS_INLINE CodeBlock* codeBlockFromCallFrameCallee(CallFrame* callFrame, CodeSpecializationKind kind)</span>
  {
<span class="line-modified">!     JSFunction* callee = jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee());</span>
      ASSERT(!callee-&gt;isHostFunction());
      return callee-&gt;jsExecutable()-&gt;codeBlockFor(kind);
  }
  
<span class="line-modified">! ALWAYS_INLINE int arityCheckFor(VM&amp; vm, CallFrame* callFrame, CodeSpecializationKind kind)</span>
  {
<span class="line-modified">!     CodeBlock* newCodeBlock = codeBlockFromCallFrameCallee(callFrame, kind);</span>
<span class="line-modified">!     ASSERT(callFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;unsigned&gt;(newCodeBlock-&gt;numParameters()));</span>
<span class="line-modified">!     int padding = numberOfStackPaddingSlotsWithExtraSlots(newCodeBlock, callFrame-&gt;argumentCountIncludingThis());</span>
  
<span class="line-modified">!     Register* newStack = callFrame-&gt;registers() - WTF::roundUpToMultipleOf(stackAlignmentRegisters(), padding);</span>
  
      if (UNLIKELY(!vm.ensureStackCapacityFor(newStack)))
          return -1;
      return padding;
  }
  
<span class="line-modified">! inline bool opInByVal(JSGlobalObject* globalObject, JSValue baseVal, JSValue propName, ArrayProfile* arrayProfile = nullptr)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (!baseVal.isObject()) {
<span class="line-modified">!         throwException(globalObject, scope, createInvalidInParameterError(globalObject, baseVal));</span>
          return false;
      }
  
      JSObject* baseObj = asObject(baseVal);
      if (arrayProfile)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,135 ***</span>
  
      uint32_t i;
      if (propName.getUInt32(i)) {
          if (arrayProfile)
              arrayProfile-&gt;observeIndexedRead(vm, baseObj, i);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(exec, i));</span>
      }
  
<span class="line-modified">!     auto property = propName.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(exec, property));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline void tryCachePutToScopeGlobal(</span>
<span class="line-removed">-     ExecState* exec, CodeBlock* codeBlock, OpPutToScope&amp; bytecode, JSObject* scope,</span>
<span class="line-removed">-     PutPropertySlot&amp; slot, const Identifier&amp; ident)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.</span>
<span class="line-removed">-     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">-     ResolveType resolveType = metadata.m_getPutInfo.resolveType();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     switch (resolveType) {</span>
<span class="line-removed">-     case UnresolvedProperty:</span>
<span class="line-removed">-     case UnresolvedPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">-         if (scope-&gt;isGlobalObject()) {</span>
<span class="line-removed">-             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;</span>
<span class="line-removed">-             resolveType = newResolveType; // Allow below caching mechanism to kick in.</span>
<span class="line-removed">-             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">-             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         FALLTHROUGH;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     case GlobalProperty:</span>
<span class="line-removed">-     case GlobalPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">-          // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.</span>
<span class="line-removed">-         if (scope-&gt;isGlobalLexicalEnvironment()) {</span>
<span class="line-removed">-             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);</span>
<span class="line-removed">-             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;</span>
<span class="line-removed">-             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">-             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());</span>
<span class="line-removed">-             ASSERT(!entry.isNull());</span>
<span class="line-removed">-             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">-             metadata.m_watchpointSet = entry.watchpointSet();</span>
<span class="line-removed">-             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {</span>
<span class="line-removed">-         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-removed">-         ASSERT(globalObject == scope || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());</span>
<span class="line-removed">-         if (!slot.isCacheablePut()</span>
<span class="line-removed">-             || slot.base() != scope</span>
<span class="line-removed">-             || scope != globalObject</span>
<span class="line-removed">-             || !scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable())</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (slot.type() == PutPropertySlot::NewProperty) {</span>
<span class="line-removed">-             // Don&#39;t cache if we&#39;ve done a transition. We want to detect the first replace so that we</span>
<span class="line-removed">-             // can invalidate the watchpoint.</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         scope-&gt;structure(vm)-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">-         metadata.m_structure.set(vm, codeBlock, scope-&gt;structure(vm));</span>
<span class="line-removed">-         metadata.m_operand = slot.cachedOffset();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline void tryCacheGetFromScopeGlobal(</span>
<span class="line-removed">-     ExecState* exec, VM&amp; vm, OpGetFromScope&amp; bytecode, JSObject* scope, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">-     ResolveType resolveType = metadata.m_getPutInfo.resolveType();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     switch (resolveType) {</span>
<span class="line-removed">-     case UnresolvedProperty:</span>
<span class="line-removed">-     case UnresolvedPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">-         if (scope-&gt;isGlobalObject()) {</span>
<span class="line-removed">-             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;</span>
<span class="line-removed">-             resolveType = newResolveType; // Allow below caching mechanism to kick in.</span>
<span class="line-removed">-             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
<span class="line-removed">-             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         FALLTHROUGH;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     case GlobalProperty:</span>
<span class="line-removed">-     case GlobalPropertyWithVarInjectionChecks: {</span>
<span class="line-removed">-          // Global Lexical Binding Epoch is changed. Update op_get_from_scope from GlobalProperty to GlobalLexicalVar.</span>
<span class="line-removed">-         if (scope-&gt;isGlobalLexicalEnvironment()) {</span>
<span class="line-removed">-             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(scope);</span>
<span class="line-removed">-             ResolveType newResolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;</span>
<span class="line-removed">-             SymbolTableEntry entry = globalLexicalEnvironment-&gt;symbolTable()-&gt;get(ident.impl());</span>
<span class="line-removed">-             ASSERT(!entry.isNull());</span>
<span class="line-removed">-             ConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock);</span>
<span class="line-removed">-             metadata.m_getPutInfo = GetPutInfo(metadata.m_getPutInfo.resolveMode(), newResolveType, metadata.m_getPutInfo.initializationMode());</span>
<span class="line-removed">-             metadata.m_watchpointSet = entry.watchpointSet();</span>
<span class="line-removed">-             metadata.m_operand = reinterpret_cast&lt;uintptr_t&gt;(globalLexicalEnvironment-&gt;variableAt(entry.scopeOffset()).slot());</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Covers implicit globals. Since they don&#39;t exist until they first execute, we didn&#39;t know how to cache them at compile time.</span>
<span class="line-removed">-     if (resolveType == GlobalProperty || resolveType == GlobalPropertyWithVarInjectionChecks) {</span>
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-         JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-removed">-         ASSERT(scope == globalObject || globalObject-&gt;varInjectionWatchpoint()-&gt;hasBeenInvalidated());</span>
<span class="line-removed">-         if (slot.isCacheableValue() &amp;&amp; slot.slotBase() == scope &amp;&amp; scope == globalObject &amp;&amp; scope-&gt;structure(vm)-&gt;propertyAccessesAreCacheable()) {</span>
<span class="line-removed">-             Structure* structure = scope-&gt;structure(vm);</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">-                 metadata.m_structure.set(vm, codeBlock, structure);</span>
<span class="line-removed">-                 metadata.m_operand = slot.cachedOffset();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  }
  
  inline bool canAccessArgumentIndexQuickly(JSObject&amp; object, uint32_t index)
  {
      switch (object.type()) {
<span class="line-new-header">--- 106,16 ---</span>
  
      uint32_t i;
      if (propName.getUInt32(i)) {
          if (arrayProfile)
              arrayProfile-&gt;observeIndexedRead(vm, baseObj, i);
<span class="line-modified">!         RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(globalObject, i));</span>
      }
  
<span class="line-modified">!     auto property = propName.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, baseObj-&gt;hasProperty(globalObject, property));</span>
  }
  
  inline bool canAccessArgumentIndexQuickly(JSObject&amp; object, uint32_t index)
  {
      switch (object.type()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,32 ***</span>
          break;
      }
      return false;
  }
  
<span class="line-modified">! static ALWAYS_INLINE void putDirectWithReify(VM&amp; vm, ExecState* exec, JSObject* baseObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, Structure** result = nullptr)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">!         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
      if (result)
          *result = baseObject-&gt;structure(vm);
      scope.release();
      baseObject-&gt;putDirect(vm, propertyName, value, slot);
  }
  
<span class="line-modified">! static ALWAYS_INLINE void putDirectAccessorWithReify(VM&amp; vm, ExecState* exec, JSObject* baseObject, PropertyName propertyName, GetterSetter* accessor, unsigned attribute)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">!         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, exec, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
      scope.release();
<span class="line-modified">!     baseObject-&gt;putDirectAccessor(exec, propertyName, accessor, attribute);</span>
  }
  
  inline JSArray* allocateNewArrayBuffer(VM&amp; vm, Structure* structure, JSImmutableButterfly* immutableButterfly)
  {
      JSGlobalObject* globalObject = structure-&gt;globalObject();
<span class="line-new-header">--- 135,32 ---</span>
          break;
      }
      return false;
  }
  
<span class="line-modified">! static ALWAYS_INLINE void putDirectWithReify(VM&amp; vm, JSGlobalObject* globalObject, JSObject* baseObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, Structure** result = nullptr)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">!         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
      if (result)
          *result = baseObject-&gt;structure(vm);
      scope.release();
      baseObject-&gt;putDirect(vm, propertyName, value, slot);
  }
  
<span class="line-modified">! static ALWAYS_INLINE void putDirectAccessorWithReify(VM&amp; vm, JSGlobalObject* globalObject, JSObject* baseObject, PropertyName propertyName, GetterSetter* accessor, unsigned attribute)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (baseObject-&gt;inherits&lt;JSFunction&gt;(vm)) {
<span class="line-modified">!         jsCast&lt;JSFunction*&gt;(baseObject)-&gt;reifyLazyPropertyIfNeeded(vm, globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
      scope.release();
<span class="line-modified">!     baseObject-&gt;putDirectAccessor(globalObject, propertyName, accessor, attribute);</span>
  }
  
  inline JSArray* allocateNewArrayBuffer(VM&amp; vm, Structure* structure, JSImmutableButterfly* immutableButterfly)
  {
      JSGlobalObject* globalObject = structure-&gt;globalObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,27 ***</span>
      return result;
  }
  
  } // namespace CommonSlowPaths
  
<span class="line-modified">! class ExecState;</span>
  struct Instruction;
  
  #define SLOW_PATH
  
  #define SLOW_PATH_DECL(name) \
<span class="line-modified">! extern &quot;C&quot; SlowPathReturnType SLOW_PATH name(ExecState* exec, const Instruction* pc)</span>
  
  #define SLOW_PATH_HIDDEN_DECL(name) \
  SLOW_PATH_DECL(name) WTF_INTERNAL
  
  SLOW_PATH_HIDDEN_DECL(slow_path_call_arityCheck);
  SLOW_PATH_HIDDEN_DECL(slow_path_construct_arityCheck);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_direct_arguments);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_scoped_arguments);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_cloned_arguments);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_get_callee);
  SLOW_PATH_HIDDEN_DECL(slow_path_to_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_throw_tdz_error);
  SLOW_PATH_HIDDEN_DECL(slow_path_check_tdz);
  SLOW_PATH_HIDDEN_DECL(slow_path_throw_strict_mode_readonly_property_write_error);
<span class="line-new-header">--- 184,29 ---</span>
      return result;
  }
  
  } // namespace CommonSlowPaths
  
<span class="line-modified">! class CallFrame;</span>
  struct Instruction;
  
  #define SLOW_PATH
  
  #define SLOW_PATH_DECL(name) \
<span class="line-modified">! extern &quot;C&quot; SlowPathReturnType SLOW_PATH name(CallFrame* callFrame, const Instruction* pc)</span>
  
  #define SLOW_PATH_HIDDEN_DECL(name) \
  SLOW_PATH_DECL(name) WTF_INTERNAL
  
  SLOW_PATH_HIDDEN_DECL(slow_path_call_arityCheck);
  SLOW_PATH_HIDDEN_DECL(slow_path_construct_arityCheck);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_direct_arguments);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_scoped_arguments);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_cloned_arguments);
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_create_arguments_butterfly);</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_create_this);
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_enter);</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_get_callee);
  SLOW_PATH_HIDDEN_DECL(slow_path_to_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_throw_tdz_error);
  SLOW_PATH_HIDDEN_DECL(slow_path_check_tdz);
  SLOW_PATH_HIDDEN_DECL(slow_path_throw_strict_mode_readonly_property_write_error);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,10 ***</span>
<span class="line-new-header">--- 220,11 ---</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_greater);
  SLOW_PATH_HIDDEN_DECL(slow_path_greatereq);
  SLOW_PATH_HIDDEN_DECL(slow_path_inc);
  SLOW_PATH_HIDDEN_DECL(slow_path_dec);
  SLOW_PATH_HIDDEN_DECL(slow_path_to_number);
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_to_numeric);</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_to_string);
  SLOW_PATH_HIDDEN_DECL(slow_path_to_object);
  SLOW_PATH_HIDDEN_DECL(slow_path_negate);
  SLOW_PATH_HIDDEN_DECL(slow_path_add);
  SLOW_PATH_HIDDEN_DECL(slow_path_mul);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,10 ***</span>
<span class="line-new-header">--- 247,11 ---</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_in_by_id);
  SLOW_PATH_HIDDEN_DECL(slow_path_in_by_val);
  SLOW_PATH_HIDDEN_DECL(slow_path_del_by_val);
  SLOW_PATH_HIDDEN_DECL(slow_path_strcat);
  SLOW_PATH_HIDDEN_DECL(slow_path_to_primitive);
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_to_property_key);</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_get_enumerable_length);
  SLOW_PATH_HIDDEN_DECL(slow_path_has_generic_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_has_structure_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_has_indexed_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_get_direct_pname);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,20 ***</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_create_lexical_environment);
  SLOW_PATH_HIDDEN_DECL(slow_path_push_with_scope);
  SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope);
  SLOW_PATH_HIDDEN_DECL(slow_path_is_var_scope);
  SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval);
  SLOW_PATH_HIDDEN_DECL(slow_path_create_rest);
  SLOW_PATH_HIDDEN_DECL(slow_path_get_by_id_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_get_by_val_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_put_by_id_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_put_by_val_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_define_data_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_define_accessor_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_throw_static_error);
  SLOW_PATH_HIDDEN_DECL(slow_path_new_array_with_spread);
  SLOW_PATH_HIDDEN_DECL(slow_path_new_array_buffer);
  SLOW_PATH_HIDDEN_DECL(slow_path_spread);
  
<span class="line-modified">! using SlowPathFunction = SlowPathReturnType(SLOW_PATH *)(ExecState*, const Instruction*);</span>
  
  } // namespace JSC
<span class="line-new-header">--- 264,25 ---</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_create_lexical_environment);
  SLOW_PATH_HIDDEN_DECL(slow_path_push_with_scope);
  SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope);
  SLOW_PATH_HIDDEN_DECL(slow_path_is_var_scope);
  SLOW_PATH_HIDDEN_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval);
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_create_promise);</span>
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_create_generator);</span>
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_create_async_generator);</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_create_rest);
  SLOW_PATH_HIDDEN_DECL(slow_path_get_by_id_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_get_by_val_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_put_by_id_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_put_by_val_with_this);
  SLOW_PATH_HIDDEN_DECL(slow_path_define_data_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_define_accessor_property);
  SLOW_PATH_HIDDEN_DECL(slow_path_throw_static_error);
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_new_promise);</span>
<span class="line-added">+ SLOW_PATH_HIDDEN_DECL(slow_path_new_generator);</span>
  SLOW_PATH_HIDDEN_DECL(slow_path_new_array_with_spread);
  SLOW_PATH_HIDDEN_DECL(slow_path_new_array_buffer);
  SLOW_PATH_HIDDEN_DECL(slow_path_spread);
  
<span class="line-modified">! using SlowPathFunction = SlowPathReturnType(SLOW_PATH *)(CallFrame*, const Instruction*);</span>
  
  } // namespace JSC
</pre>
<center><a href="CommonSlowPaths.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Completion.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
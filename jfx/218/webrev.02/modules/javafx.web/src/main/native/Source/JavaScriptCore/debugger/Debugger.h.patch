diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h
@@ -32,19 +32,17 @@
 #include <wtf/RefPtr.h>
 #include <wtf/text/TextPosition.h>
 
 namespace JSC {
 
+class CallFrame;
 class CodeBlock;
 class Exception;
-class ExecState;
 class JSGlobalObject;
 class SourceProvider;
 class VM;
 
-typedef ExecState CallFrame;
-
 class JS_EXPORT_PRIVATE Debugger {
     WTF_MAKE_FAST_ALLOCATED;
 public:
     Debugger(VM&);
     virtual ~Debugger();
@@ -89,19 +87,22 @@
         PauseOnUncaughtExceptions
     };
     PauseOnExceptionsState pauseOnExceptionsState() const { return m_pauseOnExceptionsState; }
     void setPauseOnExceptionsState(PauseOnExceptionsState);
 
+    void setPauseOnDebuggerStatements(bool enabled) { m_pauseOnDebuggerStatements = enabled; }
+
     enum ReasonForPause {
         NotPaused,
         PausedForException,
         PausedAtStatement,
         PausedAtExpression,
         PausedBeforeReturn,
         PausedAtEndOfProgram,
         PausedForBreakpoint,
         PausedForDebuggerStatement,
+        PausedAfterBlackboxedScript,
     };
     ReasonForPause reasonForPause() const { return m_reasonForPause; }
     BreakpointID pausingBreakpointID() const { return m_pausingBreakpointID; }
 
     void setPauseOnNextStatement(bool);
@@ -109,33 +110,33 @@
     void continueProgram();
     void stepIntoStatement();
     void stepOverStatement();
     void stepOutOfFunction();
 
-    bool isBlacklisted(SourceID) const;
-    void addToBlacklist(SourceID);
-    void clearBlacklist();
+    enum class BlackboxType { Deferred, Ignored };
+    void setBlackboxType(SourceID, Optional<BlackboxType>);
+    void clearBlackbox();
 
     bool isPaused() const { return m_isPaused; }
     bool isStepping() const { return m_steppingMode == SteppingModeEnabled; }
 
     bool suppressAllPauses() const { return m_suppressAllPauses; }
     void setSuppressAllPauses(bool suppress) { m_suppressAllPauses = suppress; }
 
-    virtual void sourceParsed(ExecState*, SourceProvider*, int errorLineNumber, const WTF::String& errorMessage) = 0;
+    virtual void sourceParsed(JSGlobalObject*, SourceProvider*, int errorLineNumber, const WTF::String& errorMessage) = 0;
     virtual void willRunMicrotask() { }
     virtual void didRunMicrotask() { }
 
-    void exception(CallFrame*, JSValue exceptionValue, bool hasCatchHandler);
+    void exception(JSGlobalObject*, CallFrame*, JSValue exceptionValue, bool hasCatchHandler);
     void atStatement(CallFrame*);
     void atExpression(CallFrame*);
     void callEvent(CallFrame*);
     void returnEvent(CallFrame*);
     void unwindEvent(CallFrame*);
     void willExecuteProgram(CallFrame*);
     void didExecuteProgram(CallFrame*);
-    void didReachBreakpoint(CallFrame*);
+    void didReachDebuggerStatement(CallFrame*);
 
     virtual void recompileAllJSFunctions();
 
     void registerCodeBlock(CodeBlock*);
 
@@ -153,11 +154,11 @@
     Seconds willEvaluateScript();
     void didEvaluateScript(Seconds startTime, ProfilingReason);
 
 protected:
     virtual void handleBreakpointHit(JSGlobalObject*, const Breakpoint&) { }
-    virtual void handleExceptionInBreakpointCondition(ExecState*, Exception*) const { }
+    virtual void handleExceptionInBreakpointCondition(JSGlobalObject*, Exception*) const { }
     virtual void handlePause(JSGlobalObject*, ReasonForPause) { }
     virtual void notifyDoneProcessingDebuggerEvents() { }
 
 private:
     typedef HashMap<BreakpointID, Breakpoint*> BreakpointIDToBreakpointMap;
@@ -196,13 +197,13 @@
     // key'ed off the source position instead of the bytecode PC. This ensures
     // that we don't break on the same line more than once. Once we switch to a
     // bytecode PC key'ed breakpoint, we will not need these anymore and should
     // be able to remove them.
     enum CallFrameUpdateAction { AttemptPause, NoPause };
-    void updateCallFrame(JSC::CallFrame*, CallFrameUpdateAction);
+    void updateCallFrame(JSC::JSGlobalObject*, JSC::CallFrame*, CallFrameUpdateAction);
     void updateCallFrameInternal(JSC::CallFrame*);
-    void pauseIfNeeded(JSC::CallFrame*);
+    void pauseIfNeeded(JSC::JSGlobalObject*);
     void clearNextPauseState();
 
     enum SteppingMode {
         SteppingModeDisabled,
         SteppingModeEnabled
@@ -222,13 +223,14 @@
     void clearParsedData();
 
     VM& m_vm;
     HashSet<JSGlobalObject*> m_globalObjects;
     HashMap<SourceID, DebuggerParseData, WTF::IntHash<SourceID>, WTF::UnsignedWithZeroKeyHashTraits<SourceID>> m_parseDataMap;
-    HashSet<SourceID, WTF::IntHash<SourceID>, WTF::UnsignedWithZeroKeyHashTraits<SourceID>> m_blacklistedScripts;
+    HashMap<SourceID, BlackboxType, WTF::IntHash<SourceID>, WTF::UnsignedWithZeroKeyHashTraits<SourceID>> m_blackboxedScripts;
 
     PauseOnExceptionsState m_pauseOnExceptionsState;
+    bool m_pauseOnDebuggerStatements : 1;
     bool m_pauseAtNextOpportunity : 1;
     bool m_pauseOnStepOut : 1;
     bool m_pastFirstExpressionInStatement : 1;
     bool m_isPaused : 1;
     bool m_breakpointsActivated : 1;
@@ -240,10 +242,11 @@
     JSValue m_currentException;
     CallFrame* m_pauseOnCallFrame { nullptr };
     CallFrame* m_currentCallFrame { nullptr };
     unsigned m_lastExecutedLine;
     SourceID m_lastExecutedSourceID;
+    bool m_afterBlackboxedScript { false };
 
     BreakpointID m_topBreakpointID;
     BreakpointID m_pausingBreakpointID;
     BreakpointIDToBreakpointMap m_breakpointIDToBreakpoint;
     SourceIDToBreakpointsMap m_sourceIDToBreakpoints;

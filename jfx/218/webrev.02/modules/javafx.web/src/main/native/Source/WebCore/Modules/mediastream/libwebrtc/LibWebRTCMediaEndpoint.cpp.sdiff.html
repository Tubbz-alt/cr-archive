<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LibWebRTCDataChannelHandler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCMediaEndpoint.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;EventNames.h&quot;

 31 #include &quot;JSRTCStatsReport.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 34 #include &quot;LibWebRTCProvider.h&quot;
 35 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 36 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 37 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 38 #include &quot;LibWebRTCStatsCollector.h&quot;
 39 #include &quot;LibWebRTCUtils.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;NotImplemented.h&quot;
 42 #include &quot;Performance.h&quot;
 43 #include &quot;PlatformStrategies.h&quot;
 44 #include &quot;RTCDataChannel.h&quot;
 45 #include &quot;RTCDataChannelEvent.h&quot;
 46 #include &quot;RTCOfferOptions.h&quot;
 47 #include &quot;RTCPeerConnection.h&quot;
 48 #include &quot;RTCSessionDescription.h&quot;
 49 #include &quot;RTCStatsReport.h&quot;
 50 #include &quot;RealtimeIncomingAudioSource.h&quot;
 51 #include &quot;RealtimeIncomingVideoSource.h&quot;
 52 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 53 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-modified"> 55 #include &lt;webrtc/rtc_base/physicalsocketserver.h&gt;</span>
<span class="line-modified"> 56 #include &lt;webrtc/p2p/base/basicpacketsocketfactory.h&gt;</span>
<span class="line-modified"> 57 #include &lt;webrtc/p2p/client/basicportallocator.h&gt;</span>
<span class="line-modified"> 58 #include &lt;webrtc/pc/peerconnectionfactory.h&gt;</span>
 59 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 60 #include &lt;wtf/MainThread.h&gt;
 61 
 62 namespace WebCore {
 63 
 64 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 65     : m_peerConnectionBackend(peerConnection)
 66     , m_peerConnectionFactory(*client.factory())
 67     , m_createSessionDescriptionObserver(*this)
 68     , m_setLocalSessionDescriptionObserver(*this)
 69     , m_setRemoteSessionDescriptionObserver(*this)
 70     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 71 #if !RELEASE_LOG_DISABLED
 72     , m_logger(peerConnection.logger())
 73     , m_logIdentifier(peerConnection.logIdentifier())
 74 #endif
 75 {
 76     ASSERT(isMainThread());
 77     ASSERT(client.factory());
 78 
 79     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 80         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 81 }
 82 
 83 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 84 {
<span class="line-modified"> 85     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed"> 86         configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;</span>
 87 
 88     if (!m_backend) {
 89         if (!m_rtcSocketFactory) {
 90             auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
<span class="line-modified"> 91             m_rtcSocketFactory = client.createSocketFactory(document.sessionID(), document.userAgent(document.url()));</span>
 92         }
 93         m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));
 94         return !!m_backend;
 95     }
 96     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 97     configuration.certificates = oldConfiguration.certificates;
<span class="line-modified"> 98     return m_backend-&gt;SetConfiguration(WTFMove(configuration));</span>












 99 }
100 
101 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
102 {
103     switch (sdpType) {
104     case RTCSdpType::Offer:
105         return &quot;offer&quot;;
106     case RTCSdpType::Pranswer:
107         return &quot;pranswer&quot;;
108     case RTCSdpType::Answer:
109         return &quot;answer&quot;;
110     case RTCSdpType::Rollback:
111         return &quot;rollback&quot;;
112     }
113 
114     ASSERT_NOT_REACHED();
115     return &quot;&quot;;
116 }
117 
118 static inline RTCSdpType fromSessionDescriptionType(const webrtc::SessionDescriptionInterface&amp; description)
</pre>
<hr />
<pre>
191 
192 void LibWebRTCMediaEndpoint::doSetRemoteDescription(RTCSessionDescription&amp; description)
193 {
194     ASSERT(m_backend);
195 
196     webrtc::SdpParseError error;
197     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
198     if (!sessionDescription) {
199         m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { SyntaxError, fromStdString(error.description) });
200         return;
201     }
202     m_backend-&gt;SetRemoteDescription(&amp;m_setRemoteSessionDescriptionObserver, sessionDescription.release());
203 
204     startLoggingStats();
205 }
206 
207 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
208 {
209     ASSERT(m_backend);
210 
<span class="line-removed">211     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {</span>
<span class="line-removed">212         String mediaStreamId = mediaStreamIds.isEmpty() ? createCanonicalUUIDString() : mediaStreamIds[0];</span>
<span class="line-removed">213         m_localStreams.ensure(mediaStreamId, [&amp;] {</span>
<span class="line-removed">214             auto mediaStream = m_peerConnectionFactory.CreateLocalMediaStream(mediaStreamId.utf8().data());</span>
<span class="line-removed">215             m_backend-&gt;AddStream(mediaStream);</span>
<span class="line-removed">216             return mediaStream;</span>
<span class="line-removed">217         });</span>
<span class="line-removed">218     }</span>
<span class="line-removed">219 </span>
220     LibWebRTCRtpSenderBackend::Source source;
221     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
222     switch (track.privateTrack().type()) {
223     case RealtimeMediaSource::Type::Audio: {
224         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
225         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
226         source = WTFMove(audioSource);
227         break;
228     }
229     case RealtimeMediaSource::Type::Video: {
230         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
231         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
232         source = WTFMove(videoSource);
233         break;
234     }
235     case RealtimeMediaSource::Type::None:
236         ASSERT_NOT_REACHED();
237         return false;
238     }
239 
</pre>
<hr />
<pre>
253     sender.setRTCSender(newRTPSender.MoveValue());
254     return true;
255 }
256 
257 void LibWebRTCMediaEndpoint::removeTrack(LibWebRTCRtpSenderBackend&amp; sender)
258 {
259     ASSERT(m_backend);
260     m_backend-&gt;RemoveTrack(sender.rtcSender());
261     sender.clearSource();
262 }
263 
264 void LibWebRTCMediaEndpoint::doCreateOffer(const RTCOfferOptions&amp; options)
265 {
266     ASSERT(m_backend);
267 
268     m_isInitiator = true;
269     webrtc::PeerConnectionInterface::RTCOfferAnswerOptions rtcOptions;
270     rtcOptions.ice_restart = options.iceRestart;
271     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
272 
<span class="line-removed">273     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {</span>
<span class="line-removed">274         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;audio&quot;_s))</span>
<span class="line-removed">275             rtcOptions.offer_to_receive_audio = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;</span>
<span class="line-removed">276         if (m_peerConnectionBackend.shouldOfferAllowToReceive(&quot;video&quot;_s))</span>
<span class="line-removed">277             rtcOptions.offer_to_receive_video = webrtc::PeerConnectionInterface::RTCOfferAnswerOptions::kOfferToReceiveMediaTrue;</span>
<span class="line-removed">278     }</span>
279     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
280 }
281 
282 void LibWebRTCMediaEndpoint::doCreateAnswer()
283 {
284     ASSERT(m_backend);
285 
286     m_isInitiator = false;
287     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
288 }
289 
290 rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
291 {
<span class="line-modified">292     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)]() mutable -&gt; RefPtr&lt;RTCStatsReport&gt; {</span>
293         ASSERT(isMainThread());
<span class="line-modified">294         if (protectedThis-&gt;isStopped())</span>
<span class="line-modified">295             return nullptr;</span>
<span class="line-removed">296 </span>
<span class="line-removed">297         auto report = RTCStatsReport::create();</span>
<span class="line-removed">298 </span>
<span class="line-removed">299         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.copyRef());</span>
300 
<span class="line-modified">301         // The promise resolution might fail in which case no backing map will be created.</span>
<span class="line-removed">302         if (!report-&gt;backingMap())</span>
<span class="line-removed">303             return nullptr;</span>
<span class="line-removed">304         return report;</span>
305     });
306 }
307 
308 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
309 {
310     if (m_backend)
311         m_backend-&gt;GetStats(createStatsCollector(WTFMove(promise)));
312 }
313 
314 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
315 {
316     if (m_backend)
317         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver), createStatsCollector(WTFMove(promise)));
318 }
319 
320 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
321 {
322     if (m_backend)
323         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender), createStatsCollector(WTFMove(promise)));
324 }
</pre>
<hr />
<pre>
446     case cricket::MEDIA_TYPE_DATA:
447         return nullptr;
448     case cricket::MEDIA_TYPE_AUDIO: {
449         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
450         return RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));
451     }
452     case cricket::MEDIA_TYPE_VIDEO: {
453         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
454         return RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));
455     }
456     }
457 
458     RELEASE_ASSERT_NOT_REACHED();
459 }
460 
461 void LibWebRTCMediaEndpoint::collectTransceivers()
462 {
463     if (!m_backend)
464         return;
465 
<span class="line-removed">466     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">467         return;</span>
<span class="line-removed">468 </span>
469     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
470         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
471             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
472         });
473         if (existingTransceiver)
474             continue;
475 
476         auto rtcReceiver = rtcTransceiver-&gt;receiver();
477         auto source = sourceFromNewReceiver(*rtcReceiver);
478         if (!source)
479             return;
480 
481         m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
482     }
483 }
484 
485 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
486 {
487     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
488         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
489     });
490     if (transceiver) {
491         auto rtcReceiver = rtcTransceiver-&gt;receiver();
492         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
493         addPendingTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));
494         return;
495     }
496 
497     auto rtcReceiver = rtcTransceiver-&gt;receiver();
498     auto source = sourceFromNewReceiver(*rtcReceiver);
499     if (!source)
500         return;
501 
502     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
503 
504     addPendingTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));
505 }
506 
507 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
508 {
<span class="line-removed">509     // FIXME: Support plan B code path.</span>
<span class="line-removed">510     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">511         return;</span>
<span class="line-removed">512 </span>
513     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
514         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
515         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
516     });
517     if (!transceiver)
518         return;
519 
520     auto&amp; track = transceiver-&gt;receiver().track();
521 
522     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
523         if (auto stream = m_remoteStreamsById.get(id))
524             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
525     }
526 
527     track.source().setMuted(true);
528 }
529 
530 template&lt;typename T&gt;
531 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
532 {
</pre>
<hr />
<pre>
600 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
601 {
602     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
603         if (protectedThis-&gt;isStopped())
604             return;
605         ASSERT(stream);
606         protectedThis-&gt;addRemoteStream(*stream.get());
607     });
608 }
609 
610 void LibWebRTCMediaEndpoint::OnRemoveStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
611 {
612     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
613         if (protectedThis-&gt;isStopped())
614             return;
615         ASSERT(stream);
616         protectedThis-&gt;removeRemoteStream(*stream.get());
617     });
618 }
619 
<span class="line-removed">620 void LibWebRTCMediaEndpoint::OnAddTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; streams)</span>
<span class="line-removed">621 {</span>
<span class="line-removed">622     if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">623         return;</span>
<span class="line-removed">624 </span>
<span class="line-removed">625     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver), streams]() mutable {</span>
<span class="line-removed">626         if (protectedThis-&gt;isStopped())</span>
<span class="line-removed">627             return;</span>
<span class="line-removed">628         protectedThis-&gt;addRemoteTrack(WTFMove(receiver), streams);</span>
<span class="line-removed">629     });</span>
<span class="line-removed">630 }</span>
<span class="line-removed">631 </span>
632 void LibWebRTCMediaEndpoint::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt; transceiver)
633 {
<span class="line-removed">634     if (!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())</span>
<span class="line-removed">635         return;</span>
<span class="line-removed">636 </span>
637     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
638         if (protectedThis-&gt;isStopped())
639             return;
640         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
641     });
642 }
643 
644 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
645 {
646     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
647         if (protectedThis-&gt;isStopped())
648             return;
649         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
650     });
651 }
652 
653 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
654 {
655     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
656     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
657     return channel ? makeUnique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;
658 }
659 
660 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
661 {
662     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
663         if (protectedThis-&gt;isStopped())
664             return;
665         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
<span class="line-modified">666         connection.fireEvent(LibWebRTCDataChannelHandler::channelEvent(*connection.scriptExecutionContext(), WTFMove(dataChannel)));</span>
667     });
668 }
669 






670 void LibWebRTCMediaEndpoint::stop()
671 {
672     if (!m_backend)
673         return;
674 
675     stopLoggingStats();
676 
677     m_backend-&gt;Close();
678     m_backend = nullptr;
679     m_remoteStreamsById.clear();
680     m_remoteStreamsFromRemoteTrack.clear();
681 }
682 
683 void LibWebRTCMediaEndpoint::OnRenegotiationNeeded()
684 {
685     callOnMainThread([protectedThis = makeRef(*this)] {
686         if (protectedThis-&gt;isStopped())
687             return;
688         protectedThis-&gt;m_peerConnectionBackend.markAsNeedingNegotiation();
689     });
</pre>
</td>
<td>
<hr />
<pre>
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;EventNames.h&quot;
<span class="line-added"> 31 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 32 #include &quot;JSRTCStatsReport.h&quot;
 33 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 34 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 35 #include &quot;LibWebRTCProvider.h&quot;
 36 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 37 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 38 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 39 #include &quot;LibWebRTCStatsCollector.h&quot;
 40 #include &quot;LibWebRTCUtils.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;NotImplemented.h&quot;
 43 #include &quot;Performance.h&quot;
 44 #include &quot;PlatformStrategies.h&quot;
 45 #include &quot;RTCDataChannel.h&quot;
 46 #include &quot;RTCDataChannelEvent.h&quot;
 47 #include &quot;RTCOfferOptions.h&quot;
 48 #include &quot;RTCPeerConnection.h&quot;
 49 #include &quot;RTCSessionDescription.h&quot;
 50 #include &quot;RTCStatsReport.h&quot;
 51 #include &quot;RealtimeIncomingAudioSource.h&quot;
 52 #include &quot;RealtimeIncomingVideoSource.h&quot;
 53 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 54 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-modified"> 56 #include &lt;webrtc/rtc_base/physical_socket_server.h&gt;</span>
<span class="line-modified"> 57 #include &lt;webrtc/p2p/base/basic_packet_socket_factory.h&gt;</span>
<span class="line-modified"> 58 #include &lt;webrtc/p2p/client/basic_port_allocator.h&gt;</span>
<span class="line-modified"> 59 #include &lt;webrtc/pc/peer_connection_factory.h&gt;</span>
 60 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 61 #include &lt;wtf/MainThread.h&gt;
 62 
 63 namespace WebCore {
 64 
 65 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 66     : m_peerConnectionBackend(peerConnection)
 67     , m_peerConnectionFactory(*client.factory())
 68     , m_createSessionDescriptionObserver(*this)
 69     , m_setLocalSessionDescriptionObserver(*this)
 70     , m_setRemoteSessionDescriptionObserver(*this)
 71     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 72 #if !RELEASE_LOG_DISABLED
 73     , m_logger(peerConnection.logger())
 74     , m_logIdentifier(peerConnection.logIdentifier())
 75 #endif
 76 {
 77     ASSERT(isMainThread());
 78     ASSERT(client.factory());
 79 
 80     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 81         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 82 }
 83 
 84 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 85 {
<span class="line-modified"> 86     configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;</span>

 87 
 88     if (!m_backend) {
 89         if (!m_rtcSocketFactory) {
 90             auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
<span class="line-modified"> 91             m_rtcSocketFactory = client.createSocketFactory(document.userAgent(document.url()));</span>
 92         }
 93         m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));
 94         return !!m_backend;
 95     }
 96     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 97     configuration.certificates = oldConfiguration.certificates;
<span class="line-modified"> 98     return m_backend-&gt;SetConfiguration(WTFMove(configuration)).ok();</span>
<span class="line-added"> 99 }</span>
<span class="line-added">100 </span>
<span class="line-added">101 void LibWebRTCMediaEndpoint::suspend()</span>
<span class="line-added">102 {</span>
<span class="line-added">103     if (m_rtcSocketFactory)</span>
<span class="line-added">104         m_rtcSocketFactory-&gt;suspend();</span>
<span class="line-added">105 }</span>
<span class="line-added">106 </span>
<span class="line-added">107 void LibWebRTCMediaEndpoint::resume()</span>
<span class="line-added">108 {</span>
<span class="line-added">109     if (m_rtcSocketFactory)</span>
<span class="line-added">110         m_rtcSocketFactory-&gt;resume();</span>
111 }
112 
113 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
114 {
115     switch (sdpType) {
116     case RTCSdpType::Offer:
117         return &quot;offer&quot;;
118     case RTCSdpType::Pranswer:
119         return &quot;pranswer&quot;;
120     case RTCSdpType::Answer:
121         return &quot;answer&quot;;
122     case RTCSdpType::Rollback:
123         return &quot;rollback&quot;;
124     }
125 
126     ASSERT_NOT_REACHED();
127     return &quot;&quot;;
128 }
129 
130 static inline RTCSdpType fromSessionDescriptionType(const webrtc::SessionDescriptionInterface&amp; description)
</pre>
<hr />
<pre>
203 
204 void LibWebRTCMediaEndpoint::doSetRemoteDescription(RTCSessionDescription&amp; description)
205 {
206     ASSERT(m_backend);
207 
208     webrtc::SdpParseError error;
209     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
210     if (!sessionDescription) {
211         m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { SyntaxError, fromStdString(error.description) });
212         return;
213     }
214     m_backend-&gt;SetRemoteDescription(&amp;m_setRemoteSessionDescriptionObserver, sessionDescription.release());
215 
216     startLoggingStats();
217 }
218 
219 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
220 {
221     ASSERT(m_backend);
222 









223     LibWebRTCRtpSenderBackend::Source source;
224     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
225     switch (track.privateTrack().type()) {
226     case RealtimeMediaSource::Type::Audio: {
227         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
228         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
229         source = WTFMove(audioSource);
230         break;
231     }
232     case RealtimeMediaSource::Type::Video: {
233         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
234         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
235         source = WTFMove(videoSource);
236         break;
237     }
238     case RealtimeMediaSource::Type::None:
239         ASSERT_NOT_REACHED();
240         return false;
241     }
242 
</pre>
<hr />
<pre>
256     sender.setRTCSender(newRTPSender.MoveValue());
257     return true;
258 }
259 
260 void LibWebRTCMediaEndpoint::removeTrack(LibWebRTCRtpSenderBackend&amp; sender)
261 {
262     ASSERT(m_backend);
263     m_backend-&gt;RemoveTrack(sender.rtcSender());
264     sender.clearSource();
265 }
266 
267 void LibWebRTCMediaEndpoint::doCreateOffer(const RTCOfferOptions&amp; options)
268 {
269     ASSERT(m_backend);
270 
271     m_isInitiator = true;
272     webrtc::PeerConnectionInterface::RTCOfferAnswerOptions rtcOptions;
273     rtcOptions.ice_restart = options.iceRestart;
274     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
275 






276     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
277 }
278 
279 void LibWebRTCMediaEndpoint::doCreateAnswer()
280 {
281     ASSERT(m_backend);
282 
283     m_isInitiator = false;
284     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
285 }
286 
287 rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
288 {
<span class="line-modified">289     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)](auto&amp;&amp; report) mutable {</span>
290         ASSERT(isMainThread());
<span class="line-modified">291         if (protectedThis-&gt;isStopped() || !report)</span>
<span class="line-modified">292             return;</span>




293 
<span class="line-modified">294         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.releaseNonNull());</span>



295     });
296 }
297 
298 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
299 {
300     if (m_backend)
301         m_backend-&gt;GetStats(createStatsCollector(WTFMove(promise)));
302 }
303 
304 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
305 {
306     if (m_backend)
307         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver), createStatsCollector(WTFMove(promise)));
308 }
309 
310 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
311 {
312     if (m_backend)
313         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender), createStatsCollector(WTFMove(promise)));
314 }
</pre>
<hr />
<pre>
436     case cricket::MEDIA_TYPE_DATA:
437         return nullptr;
438     case cricket::MEDIA_TYPE_AUDIO: {
439         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
440         return RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));
441     }
442     case cricket::MEDIA_TYPE_VIDEO: {
443         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
444         return RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));
445     }
446     }
447 
448     RELEASE_ASSERT_NOT_REACHED();
449 }
450 
451 void LibWebRTCMediaEndpoint::collectTransceivers()
452 {
453     if (!m_backend)
454         return;
455 



456     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
457         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
458             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
459         });
460         if (existingTransceiver)
461             continue;
462 
463         auto rtcReceiver = rtcTransceiver-&gt;receiver();
464         auto source = sourceFromNewReceiver(*rtcReceiver);
465         if (!source)
466             return;
467 
468         m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
469     }
470 }
471 
472 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
473 {
474     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
475         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
476     });
477     if (transceiver) {
478         auto rtcReceiver = rtcTransceiver-&gt;receiver();
479         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
480         addPendingTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));
481         return;
482     }
483 
484     auto rtcReceiver = rtcTransceiver-&gt;receiver();
485     auto source = sourceFromNewReceiver(*rtcReceiver);
486     if (!source)
487         return;
488 
489     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
490 
491     addPendingTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));
492 }
493 
494 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
495 {




496     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
497         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
498         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
499     });
500     if (!transceiver)
501         return;
502 
503     auto&amp; track = transceiver-&gt;receiver().track();
504 
505     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
506         if (auto stream = m_remoteStreamsById.get(id))
507             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
508     }
509 
510     track.source().setMuted(true);
511 }
512 
513 template&lt;typename T&gt;
514 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
515 {
</pre>
<hr />
<pre>
583 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
584 {
585     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
586         if (protectedThis-&gt;isStopped())
587             return;
588         ASSERT(stream);
589         protectedThis-&gt;addRemoteStream(*stream.get());
590     });
591 }
592 
593 void LibWebRTCMediaEndpoint::OnRemoveStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
594 {
595     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
596         if (protectedThis-&gt;isStopped())
597             return;
598         ASSERT(stream);
599         protectedThis-&gt;removeRemoteStream(*stream.get());
600     });
601 }
602 












603 void LibWebRTCMediaEndpoint::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt; transceiver)
604 {



605     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
606         if (protectedThis-&gt;isStopped())
607             return;
608         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
609     });
610 }
611 
612 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
613 {
614     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
615         if (protectedThis-&gt;isStopped())
616             return;
617         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
618     });
619 }
620 
621 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
622 {
623     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
624     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
625     return channel ? makeUnique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;
626 }
627 
628 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
629 {
630     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
631         if (protectedThis-&gt;isStopped())
632             return;
633         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
<span class="line-modified">634         connection.dispatchEventWhenFeasible(LibWebRTCDataChannelHandler::channelEvent(*connection.document(), WTFMove(dataChannel)));</span>
635     });
636 }
637 
<span class="line-added">638 void LibWebRTCMediaEndpoint::close()</span>
<span class="line-added">639 {</span>
<span class="line-added">640     m_backend-&gt;Close();</span>
<span class="line-added">641     stopLoggingStats();</span>
<span class="line-added">642 }</span>
<span class="line-added">643 </span>
644 void LibWebRTCMediaEndpoint::stop()
645 {
646     if (!m_backend)
647         return;
648 
649     stopLoggingStats();
650 
651     m_backend-&gt;Close();
652     m_backend = nullptr;
653     m_remoteStreamsById.clear();
654     m_remoteStreamsFromRemoteTrack.clear();
655 }
656 
657 void LibWebRTCMediaEndpoint::OnRenegotiationNeeded()
658 {
659     callOnMainThread([protectedThis = makeRef(*this)] {
660         if (protectedThis-&gt;isStopped())
661             return;
662         protectedThis-&gt;m_peerConnectionBackend.markAsNeedingNegotiation();
663     });
</pre>
</td>
</tr>
</table>
<center><a href="LibWebRTCDataChannelHandler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="LibWebRTCMediaEndpoint.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
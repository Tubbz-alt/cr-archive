<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleNamespaceObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSModuleLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleNamespaceObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleNamespaceObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,13 ***</span>
      : Base(vm, structure)
      , m_exports()
  {
  }
  
<span class="line-modified">! void JSModuleNamespaceObject::finishCreation(ExecState* exec, JSGlobalObject*, AbstractModuleRecord* moduleRecord, Vector&lt;std::pair&lt;Identifier, AbstractModuleRecord::Resolution&gt;&gt;&amp;&amp; resolutions)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects
<span class="line-new-header">--- 39,13 ---</span>
      : Base(vm, structure)
      , m_exports()
  {
  }
  
<span class="line-modified">! void JSModuleNamespaceObject::finishCreation(JSGlobalObject* globalObject, AbstractModuleRecord* moduleRecord, Vector&lt;std::pair&lt;Identifier, AbstractModuleRecord::Resolution&gt;&gt;&amp;&amp; resolutions)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,31 ***</span>
      std::sort(resolutions.begin(), resolutions.end(), [] (const auto&amp; lhs, const auto&amp; rhs) {
          return codePointCompare(lhs.first.impl(), rhs.first.impl()) &lt; 0;
      });
  
      m_moduleRecord.set(vm, this, moduleRecord);
      {
<span class="line-modified">!         unsigned moduleRecordOffset = 0;</span>
<span class="line-removed">-         m_names.reserveCapacity(resolutions.size());</span>
          for (const auto&amp; pair : resolutions) {
<span class="line-removed">-             moduleRecordAt(moduleRecordOffset).set(vm, this, pair.second.moduleRecord);</span>
              m_names.append(pair.first);
<span class="line-modified">!             m_exports.add(pair.first.impl(), ExportEntry {</span>
<span class="line-modified">!                 pair.second.localName,</span>
<span class="line-modified">!                 moduleRecordOffset</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-             ++moduleRecordOffset;</span>
          }
      }
  
<span class="line-modified">!     putDirect(vm, vm.propertyNames-&gt;toStringTagSymbol, jsString(vm, &quot;Module&quot;), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-getprototypeof
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-setprototypeof-v
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-isextensible
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-preventextensions
<span class="line-modified">!     methodTable(vm)-&gt;preventExtensions(this, exec);</span>
      scope.assertNoException();
  }
  
  void JSModuleNamespaceObject::destroy(JSCell* cell)
  {
<span class="line-new-header">--- 57,28 ---</span>
      std::sort(resolutions.begin(), resolutions.end(), [] (const auto&amp; lhs, const auto&amp; rhs) {
          return codePointCompare(lhs.first.impl(), rhs.first.impl()) &lt; 0;
      });
  
      m_moduleRecord.set(vm, this, moduleRecord);
<span class="line-added">+     m_names.reserveCapacity(resolutions.size());</span>
      {
<span class="line-modified">!         auto locker = holdLock(cellLock());</span>
          for (const auto&amp; pair : resolutions) {
              m_names.append(pair.first);
<span class="line-modified">!             auto addResult = m_exports.add(pair.first.impl(), ExportEntry());</span>
<span class="line-modified">!             addResult.iterator-&gt;value.localName = pair.second.localName;</span>
<span class="line-modified">!             addResult.iterator-&gt;value.moduleRecord.set(vm, this, pair.second.moduleRecord);</span>
          }
      }
  
<span class="line-modified">!     putDirect(vm, vm.propertyNames-&gt;toStringTagSymbol, jsNontrivialString(vm, &quot;Module&quot;_s), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-getprototypeof
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-setprototypeof-v
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-isextensible
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-preventextensions
<span class="line-modified">!     methodTable(vm)-&gt;preventExtensions(this, globalObject);</span>
      scope.assertNoException();
  }
  
  void JSModuleNamespaceObject::destroy(JSCell* cell)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,12 ***</span>
  {
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
      Base::visitChildren(thisObject, visitor);
      visitor.append(thisObject-&gt;m_moduleRecord);
<span class="line-modified">!     for (unsigned i = 0; i &lt; thisObject-&gt;m_names.size(); ++i)</span>
<span class="line-modified">!         visitor.appendHidden(thisObject-&gt;moduleRecordAt(i));</span>
  }
  
  static JSValue getValue(JSModuleEnvironment* environment, PropertyName localName, ScopeOffset&amp; scopeOffset)
  {
      SymbolTable* symbolTable = environment-&gt;symbolTable();
<span class="line-new-header">--- 90,15 ---</span>
  {
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
      Base::visitChildren(thisObject, visitor);
      visitor.append(thisObject-&gt;m_moduleRecord);
<span class="line-modified">!     {</span>
<span class="line-modified">!         auto locker = holdLock(thisObject-&gt;cellLock());</span>
<span class="line-added">+         for (auto&amp; pair : thisObject-&gt;m_exports)</span>
<span class="line-added">+             visitor.appendHidden(pair.value.moduleRecord);</span>
<span class="line-added">+     }</span>
  }
  
  static JSValue getValue(JSModuleEnvironment* environment, PropertyName localName, ScopeOffset&amp; scopeOffset)
  {
      SymbolTable* symbolTable = environment-&gt;symbolTable();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,22 ***</span>
          scopeOffset = entry.scopeOffset();
      }
      return environment-&gt;variableAt(scopeOffset).get();
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::getOwnPropertySlotCommon(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-getownproperty-p
  
      // step 1.
      // If the property name is a symbol, we don&#39;t look into the imported bindings.
      // It may return the descriptor with writable: true, but namespace objects does not allow it in [[Set]] / [[DefineOwnProperty]] side.
      if (propertyName.isSymbol())
<span class="line-modified">!         return JSObject::getOwnPropertySlot(this, exec, propertyName, slot);</span>
  
      slot.setIsTaintedByOpaqueObject();
  
      auto iterator = m_exports.find(propertyName.uid());
      if (iterator == m_exports.end())
<span class="line-new-header">--- 111,22 ---</span>
          scopeOffset = entry.scopeOffset();
      }
      return environment-&gt;variableAt(scopeOffset).get();
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::getOwnPropertySlotCommon(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-getownproperty-p
  
      // step 1.
      // If the property name is a symbol, we don&#39;t look into the imported bindings.
      // It may return the descriptor with writable: true, but namespace objects does not allow it in [[Set]] / [[DefineOwnProperty]] side.
      if (propertyName.isSymbol())
<span class="line-modified">!         return JSObject::getOwnPropertySlot(this, globalObject, propertyName, slot);</span>
  
      slot.setIsTaintedByOpaqueObject();
  
      auto iterator = m_exports.find(propertyName.uid());
      if (iterator == m_exports.end())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,16 ***</span>
      ExportEntry&amp; exportEntry = iterator-&gt;value;
  
      switch (slot.internalMethodType()) {
      case PropertySlot::InternalMethodType::GetOwnProperty:
      case PropertySlot::InternalMethodType::Get: {
<span class="line-modified">!         JSModuleEnvironment* environment = moduleRecordAt(exportEntry.moduleRecordOffset)-&gt;moduleEnvironment();</span>
          ScopeOffset scopeOffset;
          JSValue value = getValue(environment, exportEntry.localName, scopeOffset);
          // If the value is filled with TDZ value, throw a reference error.
          if (!value) {
<span class="line-modified">!             throwVMError(exec, scope, createTDZError(exec));</span>
              return false;
          }
  
          slot.setValueModuleNamespace(this, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), value, environment, scopeOffset);
          return true;
<span class="line-new-header">--- 134,16 ---</span>
      ExportEntry&amp; exportEntry = iterator-&gt;value;
  
      switch (slot.internalMethodType()) {
      case PropertySlot::InternalMethodType::GetOwnProperty:
      case PropertySlot::InternalMethodType::Get: {
<span class="line-modified">!         JSModuleEnvironment* environment = exportEntry.moduleRecord-&gt;moduleEnvironment();</span>
          ScopeOffset scopeOffset;
          JSValue value = getValue(environment, exportEntry.localName, scopeOffset);
          // If the value is filled with TDZ value, throw a reference error.
          if (!value) {
<span class="line-modified">!             throwVMError(globalObject, scope, createTDZError(globalObject));</span>
              return false;
          }
  
          slot.setValueModuleNamespace(this, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), value, environment, scopeOffset);
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,70 ***</span>
  
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::getOwnPropertySlot(JSObject* cell, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(exec, propertyName, slot);</span>
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::getOwnPropertySlotByIndex(JSObject* cell, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(exec, Identifier::from(vm, propertyName), slot);</span>
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::put(JSCell*, ExecState* exec, PropertyName, JSValue, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-set-p-v-receiver
      if (slot.isStrictMode())
<span class="line-modified">!         throwTypeError(exec, scope, ReadonlyPropertyWriteError);</span>
      return false;
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::putByIndex(JSCell*, ExecState* exec, unsigned, JSValue, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (shouldThrow)
<span class="line-modified">!         throwTypeError(exec, scope, ReadonlyPropertyWriteError);</span>
      return false;
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-delete-p
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
      if (propertyName.isSymbol())
<span class="line-modified">!         return JSObject::deleteProperty(thisObject, exec, propertyName);</span>
  
      return !thisObject-&gt;m_exports.contains(propertyName.uid());
  }
  
<span class="line-modified">! void JSModuleNamespaceObject::getOwnPropertyNames(JSObject* cell, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-ownpropertykeys</span>
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
<span class="line-modified">!     for (const auto&amp; name : thisObject-&gt;m_names)</span>
          propertyNames.add(name.impl());
<span class="line-modified">!     return JSObject::getOwnPropertyNames(thisObject, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::defineOwnProperty(JSObject*, ExecState* exec, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-defineownproperty-p-desc
      if (shouldThrow)
<span class="line-modified">!         throwTypeError(exec, scope, NonExtensibleObjectPropertyDefineError);</span>
      return false;
  }
  
  } // namespace JSC
<span class="line-new-header">--- 163,80 ---</span>
  
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::getOwnPropertySlot(JSObject* cell, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(globalObject, propertyName, slot);</span>
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::getOwnPropertySlotByIndex(JSObject* cell, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;getOwnPropertySlotCommon(globalObject, Identifier::from(vm, propertyName), slot);</span>
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::put(JSCell*, JSGlobalObject* globalObject, PropertyName, JSValue, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-set-p-v-receiver
      if (slot.isStrictMode())
<span class="line-modified">!         throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);</span>
      return false;
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::putByIndex(JSCell*, JSGlobalObject* globalObject, unsigned, JSValue, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (shouldThrow)
<span class="line-modified">!         throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);</span>
      return false;
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-delete-p
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
      if (propertyName.isSymbol())
<span class="line-modified">!         return JSObject::deleteProperty(thisObject, globalObject, propertyName);</span>
  
      return !thisObject-&gt;m_exports.contains(propertyName.uid());
  }
  
<span class="line-modified">! void JSModuleNamespaceObject::getOwnPropertyNames(JSObject* cell, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects-ownpropertykeys</span>
      JSModuleNamespaceObject* thisObject = jsCast&lt;JSModuleNamespaceObject*&gt;(cell);
<span class="line-modified">!     for (const auto&amp; name : thisObject-&gt;m_names) {</span>
<span class="line-added">+         if (!mode.includeDontEnumProperties()) {</span>
<span class="line-added">+             // Perform [[GetOwnProperty]] to throw ReferenceError if binding is uninitialized.</span>
<span class="line-added">+             PropertySlot slot(cell, PropertySlot::InternalMethodType::GetOwnProperty);</span>
<span class="line-added">+             thisObject-&gt;getOwnPropertySlotCommon(globalObject, name.impl(), slot);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+         }</span>
          propertyNames.add(name.impl());
<span class="line-modified">!     }</span>
<span class="line-added">+     JSObject::getOwnPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool JSModuleNamespaceObject::defineOwnProperty(JSObject*, JSGlobalObject* globalObject, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-namespace-exotic-objects-defineownproperty-p-desc
      if (shouldThrow)
<span class="line-modified">!         throwTypeError(globalObject, scope, NonExtensibleObjectPropertyDefineError);</span>
      return false;
  }
  
  } // namespace JSC
</pre>
<center><a href="JSModuleLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleNamespaceObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bridge/c/c_instance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CRuntimeObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="c_instance.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bridge/c/c_instance.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 63,20 ***</span>
  void CInstance::setGlobalException(String exception)
  {
      globalExceptionString() = exception;
  }
  
<span class="line-modified">! void CInstance::moveGlobalExceptionToExecState(ExecState* exec)</span>
  {
      if (globalExceptionString().isNull())
          return;
  
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          JSLockHolder lock(vm);
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwException(exec, scope, createError(exec, globalExceptionString()));</span>
      }
  
      globalExceptionString() = String();
  }
  
<span class="line-new-header">--- 63,20 ---</span>
  void CInstance::setGlobalException(String exception)
  {
      globalExceptionString() = exception;
  }
  
<span class="line-modified">! void CInstance::moveGlobalExceptionToExecState(JSGlobalObject* lexicalGlobalObject)</span>
  {
      if (globalExceptionString().isNull())
          return;
  
      {
<span class="line-modified">!         VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
          JSLockHolder lock(vm);
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, globalExceptionString()));</span>
      }
  
      globalExceptionString() = String();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,14 ***</span>
  CInstance::~CInstance()
  {
      _NPN_ReleaseObject(_object);
  }
  
<span class="line-modified">! RuntimeObject* CInstance::newRuntimeObject(ExecState* exec)</span>
  {
      // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object.
<span class="line-modified">!     return CRuntimeObject::create(exec-&gt;vm(), WebCore::deprecatedGetDOMStructure&lt;CRuntimeObject&gt;(exec), this);</span>
  }
  
  Class *CInstance::getClass() const
  {
      if (!_class)
<span class="line-new-header">--- 90,14 ---</span>
  CInstance::~CInstance()
  {
      _NPN_ReleaseObject(_object);
  }
  
<span class="line-modified">! RuntimeObject* CInstance::newRuntimeObject(JSGlobalObject* lexicalGlobalObject)</span>
  {
      // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object.
<span class="line-modified">!     return CRuntimeObject::create(lexicalGlobalObject-&gt;vm(), WebCore::deprecatedGetDOMStructure&lt;CRuntimeObject&gt;(lexicalGlobalObject), this);</span>
  }
  
  Class *CInstance::getClass() const
  {
      if (!_class)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,21 ***</span>
  bool CInstance::supportsInvokeDefaultMethod() const
  {
      return _object-&gt;_class-&gt;invokeDefault;
  }
  
<span class="line-modified">! class CRuntimeMethod : public RuntimeMethod {</span>
  public:
<span class="line-modified">!     typedef RuntimeMethod Base;</span>
  
<span class="line-modified">!     static CRuntimeMethod* create(ExecState* exec, JSGlobalObject* globalObject, const String&amp; name, Bindings::Method* method)</span>
      {
          VM&amp; vm = globalObject-&gt;vm();
          // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object
          // We need to pass in the right global object for &quot;i&quot;.
<span class="line-modified">!         Structure* domStructure = WebCore::deprecatedGetDOMStructure&lt;CRuntimeMethod&gt;(exec);</span>
<span class="line-modified">!         CRuntimeMethod* runtimeMethod = new (NotNull, allocateCell&lt;CRuntimeMethod&gt;(vm.heap)) CRuntimeMethod(globalObject, domStructure, method);</span>
          runtimeMethod-&gt;finishCreation(vm, name);
          return runtimeMethod;
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
<span class="line-new-header">--- 108,21 ---</span>
  bool CInstance::supportsInvokeDefaultMethod() const
  {
      return _object-&gt;_class-&gt;invokeDefault;
  }
  
<span class="line-modified">! class CRuntimeMethod final : public RuntimeMethod {</span>
  public:
<span class="line-modified">!     using Base = RuntimeMethod;</span>
  
<span class="line-modified">!     static CRuntimeMethod* create(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const String&amp; name, Bindings::Method* method)</span>
      {
          VM&amp; vm = globalObject-&gt;vm();
          // FIXME: deprecatedGetDOMStructure uses the prototype off of the wrong global object
          // We need to pass in the right global object for &quot;i&quot;.
<span class="line-modified">!         Structure* domStructure = WebCore::deprecatedGetDOMStructure&lt;CRuntimeMethod&gt;(lexicalGlobalObject);</span>
<span class="line-modified">!         CRuntimeMethod* runtimeMethod = new (NotNull, allocateCell&lt;CRuntimeMethod&gt;(vm.heap)) CRuntimeMethod(vm, domStructure, method);</span>
          runtimeMethod-&gt;finishCreation(vm, name);
          return runtimeMethod;
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,176 ***</span>
      }
  
      DECLARE_INFO;
  
  private:
<span class="line-modified">!     CRuntimeMethod(JSGlobalObject* globalObject, Structure* structure, Bindings::Method* method)</span>
<span class="line-modified">!         : RuntimeMethod(globalObject, structure, method)</span>
      {
      }
  
      void finishCreation(VM&amp; vm, const String&amp; name)
      {
          Base::finishCreation(vm, name);
          ASSERT(inherits(vm, info()));
      }
<span class="line-removed">- </span>
  };
  
  const ClassInfo CRuntimeMethod::s_info = { &quot;CRuntimeMethod&quot;, &amp;RuntimeMethod::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CRuntimeMethod) };
  
<span class="line-modified">! JSValue CInstance::getMethod(ExecState* exec, PropertyName propertyName)</span>
  {
      Method* method = getClass()-&gt;methodNamed(propertyName, this);
<span class="line-modified">!     return CRuntimeMethod::create(exec, exec-&gt;lexicalGlobalObject(), propertyName.publicName(), method);</span>
  }
  
<span class="line-modified">! JSValue CInstance::invokeMethod(ExecState* exec, RuntimeMethod* runtimeMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!asObject(runtimeMethod)-&gt;inherits&lt;CRuntimeMethod&gt;(vm))
<span class="line-modified">!         return throwTypeError(exec, scope, &quot;Attempt to invoke non-plug-in method on plug-in object.&quot;_s);</span>
  
      CMethod* method = static_cast&lt;CMethod*&gt;(runtimeMethod-&gt;method());
      ASSERT(method);
  
      NPIdentifier ident = method-&gt;identifier();
      if (!_object-&gt;_class-&gt;hasMethod(_object, ident))
          return jsUndefined();
  
<span class="line-modified">!     unsigned count = exec-&gt;argumentCount();</span>
      Vector&lt;NPVariant, 8&gt; cArgs(count);
  
      unsigned i;
      for (i = 0; i &lt; count; i++)
<span class="line-modified">!         convertValueToNPVariant(exec, exec-&gt;uncheckedArgument(i), &amp;cArgs[i]);</span>
  
      // Invoke the &#39;C&#39; method.
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
  
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(exec);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;invoke(_object, ident, cArgs.data(), count, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(exec);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(exec, scope, createError(exec, &quot;Error calling method on NPObject.&quot;_s));</span>
  
      for (i = 0; i &lt; count; i++)
          _NPN_ReleaseVariantValue(&amp;cArgs[i]);
  
<span class="line-modified">!     JSValue resultValue = convertNPVariantToValue(exec, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return resultValue;
  }
  
  
<span class="line-modified">! JSValue CInstance::invokeDefaultMethod(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!_object-&gt;_class-&gt;invokeDefault)
          return jsUndefined();
  
<span class="line-modified">!     unsigned count = exec-&gt;argumentCount();</span>
      Vector&lt;NPVariant, 8&gt; cArgs(count);
  
      unsigned i;
      for (i = 0; i &lt; count; i++)
<span class="line-modified">!         convertValueToNPVariant(exec, exec-&gt;uncheckedArgument(i), &amp;cArgs[i]);</span>
  
      // Invoke the &#39;C&#39; method.
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(exec);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;invokeDefault(_object, cArgs.data(), count, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(exec);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(exec, scope, createError(exec, &quot;Error calling method on NPObject.&quot;_s));</span>
  
      for (i = 0; i &lt; count; i++)
          _NPN_ReleaseVariantValue(&amp;cArgs[i]);
  
<span class="line-modified">!     JSValue resultValue = convertNPVariantToValue(exec, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return resultValue;
  }
  
  bool CInstance::supportsConstruct() const
  {
      return _object-&gt;_class-&gt;construct;
  }
  
<span class="line-modified">! JSValue CInstance::invokeConstruct(ExecState* exec, const ArgList&amp; args)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!_object-&gt;_class-&gt;construct)
          return jsUndefined();
  
      unsigned count = args.size();
      Vector&lt;NPVariant, 8&gt; cArgs(count);
  
      unsigned i;
      for (i = 0; i &lt; count; i++)
<span class="line-modified">!         convertValueToNPVariant(exec, args.at(i), &amp;cArgs[i]);</span>
  
      // Invoke the &#39;C&#39; method.
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(exec);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;construct(_object, cArgs.data(), count, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(exec);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(exec, scope, createError(exec, &quot;Error calling method on NPObject.&quot;_s));</span>
  
      for (i = 0; i &lt; count; i++)
          _NPN_ReleaseVariantValue(&amp;cArgs[i]);
  
<span class="line-modified">!     JSValue resultValue = convertNPVariantToValue(exec, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return resultValue;
  }
  
<span class="line-modified">! JSValue CInstance::defaultValue(ExecState* exec, PreferredPrimitiveType hint) const</span>
  {
      if (hint == PreferString)
<span class="line-modified">!         return stringValue(exec);</span>
      if (hint == PreferNumber)
<span class="line-modified">!         return numberValue(exec);</span>
<span class="line-modified">!     return valueOf(exec);</span>
  }
  
<span class="line-modified">! JSValue CInstance::stringValue(ExecState* exec) const</span>
  {
      JSValue value;
<span class="line-modified">!     if (toJSPrimitive(exec, &quot;toString&quot;, value))</span>
          return value;
  
      // Fallback to default implementation.
<span class="line-modified">!     return jsNontrivialString(exec-&gt;vm(), &quot;NPObject&quot;_s);</span>
  }
  
<span class="line-modified">! JSValue CInstance::numberValue(ExecState*) const</span>
  {
      // FIXME: Implement something sensible.
      return jsNumber(0);
  }
  
<span class="line-new-header">--- 131,175 ---</span>
      }
  
      DECLARE_INFO;
  
  private:
<span class="line-modified">!     CRuntimeMethod(VM&amp; vm, Structure* structure, Bindings::Method* method)</span>
<span class="line-modified">!         : RuntimeMethod(vm, structure, method)</span>
      {
      }
  
      void finishCreation(VM&amp; vm, const String&amp; name)
      {
          Base::finishCreation(vm, name);
          ASSERT(inherits(vm, info()));
      }
  };
  
  const ClassInfo CRuntimeMethod::s_info = { &quot;CRuntimeMethod&quot;, &amp;RuntimeMethod::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(CRuntimeMethod) };
  
<span class="line-modified">! JSValue CInstance::getMethod(JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)</span>
  {
      Method* method = getClass()-&gt;methodNamed(propertyName, this);
<span class="line-modified">!     return CRuntimeMethod::create(lexicalGlobalObject, lexicalGlobalObject, propertyName.publicName(), method);</span>
  }
  
<span class="line-modified">! JSValue CInstance::invokeMethod(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, RuntimeMethod* runtimeMethod)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!asObject(runtimeMethod)-&gt;inherits&lt;CRuntimeMethod&gt;(vm))
<span class="line-modified">!         return throwTypeError(lexicalGlobalObject, scope, &quot;Attempt to invoke non-plug-in method on plug-in object.&quot;_s);</span>
  
      CMethod* method = static_cast&lt;CMethod*&gt;(runtimeMethod-&gt;method());
      ASSERT(method);
  
      NPIdentifier ident = method-&gt;identifier();
      if (!_object-&gt;_class-&gt;hasMethod(_object, ident))
          return jsUndefined();
  
<span class="line-modified">!     unsigned count = callFrame-&gt;argumentCount();</span>
      Vector&lt;NPVariant, 8&gt; cArgs(count);
  
      unsigned i;
      for (i = 0; i &lt; count; i++)
<span class="line-modified">!         convertValueToNPVariant(lexicalGlobalObject, callFrame-&gt;uncheckedArgument(i), &amp;cArgs[i]);</span>
  
      // Invoke the &#39;C&#39; method.
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
  
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(lexicalGlobalObject);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;invoke(_object, ident, cArgs.data(), count, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(lexicalGlobalObject);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, &quot;Error calling method on NPObject.&quot;_s));</span>
  
      for (i = 0; i &lt; count; i++)
          _NPN_ReleaseVariantValue(&amp;cArgs[i]);
  
<span class="line-modified">!     JSValue resultValue = convertNPVariantToValue(lexicalGlobalObject, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return resultValue;
  }
  
  
<span class="line-modified">! JSValue CInstance::invokeDefaultMethod(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!_object-&gt;_class-&gt;invokeDefault)
          return jsUndefined();
  
<span class="line-modified">!     unsigned count = callFrame-&gt;argumentCount();</span>
      Vector&lt;NPVariant, 8&gt; cArgs(count);
  
      unsigned i;
      for (i = 0; i &lt; count; i++)
<span class="line-modified">!         convertValueToNPVariant(lexicalGlobalObject, callFrame-&gt;uncheckedArgument(i), &amp;cArgs[i]);</span>
  
      // Invoke the &#39;C&#39; method.
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(lexicalGlobalObject);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;invokeDefault(_object, cArgs.data(), count, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(lexicalGlobalObject);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, &quot;Error calling method on NPObject.&quot;_s));</span>
  
      for (i = 0; i &lt; count; i++)
          _NPN_ReleaseVariantValue(&amp;cArgs[i]);
  
<span class="line-modified">!     JSValue resultValue = convertNPVariantToValue(lexicalGlobalObject, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return resultValue;
  }
  
  bool CInstance::supportsConstruct() const
  {
      return _object-&gt;_class-&gt;construct;
  }
  
<span class="line-modified">! JSValue CInstance::invokeConstruct(JSGlobalObject* lexicalGlobalObject, CallFrame*, const ArgList&amp; args)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!_object-&gt;_class-&gt;construct)
          return jsUndefined();
  
      unsigned count = args.size();
      Vector&lt;NPVariant, 8&gt; cArgs(count);
  
      unsigned i;
      for (i = 0; i &lt; count; i++)
<span class="line-modified">!         convertValueToNPVariant(lexicalGlobalObject, args.at(i), &amp;cArgs[i]);</span>
  
      // Invoke the &#39;C&#39; method.
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(lexicalGlobalObject);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;construct(_object, cArgs.data(), count, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(lexicalGlobalObject);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, &quot;Error calling method on NPObject.&quot;_s));</span>
  
      for (i = 0; i &lt; count; i++)
          _NPN_ReleaseVariantValue(&amp;cArgs[i]);
  
<span class="line-modified">!     JSValue resultValue = convertNPVariantToValue(lexicalGlobalObject, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return resultValue;
  }
  
<span class="line-modified">! JSValue CInstance::defaultValue(JSGlobalObject* lexicalGlobalObject, PreferredPrimitiveType hint) const</span>
  {
      if (hint == PreferString)
<span class="line-modified">!         return stringValue(lexicalGlobalObject);</span>
      if (hint == PreferNumber)
<span class="line-modified">!         return numberValue(lexicalGlobalObject);</span>
<span class="line-modified">!     return valueOf(lexicalGlobalObject);</span>
  }
  
<span class="line-modified">! JSValue CInstance::stringValue(JSGlobalObject* lexicalGlobalObject) const</span>
  {
      JSValue value;
<span class="line-modified">!     if (toJSPrimitive(lexicalGlobalObject, &quot;toString&quot;, value))</span>
          return value;
  
      // Fallback to default implementation.
<span class="line-modified">!     return jsNontrivialString(lexicalGlobalObject-&gt;vm(), &quot;NPObject&quot;_s);</span>
  }
  
<span class="line-modified">! JSValue CInstance::numberValue(JSGlobalObject*) const</span>
  {
      // FIXME: Implement something sensible.
      return jsNumber(0);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,23 ***</span>
  {
      // As per ECMA 9.2.
      return jsBoolean(getObject());
  }
  
<span class="line-modified">! JSValue CInstance::valueOf(ExecState* exec) const</span>
  {
      JSValue value;
<span class="line-modified">!     if (toJSPrimitive(exec, &quot;valueOf&quot;, value))</span>
          return value;
  
      // Fallback to default implementation.
<span class="line-modified">!     return stringValue(exec);</span>
  }
  
<span class="line-modified">! bool CInstance::toJSPrimitive(ExecState* exec, const char* name, JSValue&amp; resultValue) const</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      NPIdentifier ident = _NPN_GetStringIdentifier(name);
      if (!_object-&gt;_class-&gt;hasMethod(_object, ident))
          return false;
<span class="line-new-header">--- 307,23 ---</span>
  {
      // As per ECMA 9.2.
      return jsBoolean(getObject());
  }
  
<span class="line-modified">! JSValue CInstance::valueOf(JSGlobalObject* lexicalGlobalObject) const</span>
  {
      JSValue value;
<span class="line-modified">!     if (toJSPrimitive(lexicalGlobalObject, &quot;valueOf&quot;, value))</span>
          return value;
  
      // Fallback to default implementation.
<span class="line-modified">!     return stringValue(lexicalGlobalObject);</span>
  }
  
<span class="line-modified">! bool CInstance::toJSPrimitive(JSGlobalObject* lexicalGlobalObject, const char* name, JSValue&amp; resultValue) const</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      NPIdentifier ident = _NPN_GetStringIdentifier(name);
      if (!_object-&gt;_class-&gt;hasMethod(_object, ident))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,47 ***</span>
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
  
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(exec);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;invoke(_object, ident, 0, 0, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(exec);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(exec, scope, createError(exec, &quot;Error calling method on NPObject.&quot;_s));</span>
  
<span class="line-modified">!     resultValue = convertNPVariantToValue(exec, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return true;
  }
  
<span class="line-modified">! void CInstance::getPropertyNames(ExecState* exec, PropertyNameArray&amp; nameArray)</span>
  {
      if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(_object-&gt;_class) || !_object-&gt;_class-&gt;enumerate)
          return;
  
      uint32_t count;
      NPIdentifier* identifiers;
  
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(exec);</span>
          ASSERT(globalExceptionString().isNull());
          bool ok = _object-&gt;_class-&gt;enumerate(_object, &amp;identifiers, &amp;count);
<span class="line-modified">!         moveGlobalExceptionToExecState(exec);</span>
          if (!ok)
              return;
      }
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      for (uint32_t i = 0; i &lt; count; i++) {
          IdentifierRep* identifier = static_cast&lt;IdentifierRep*&gt;(identifiers[i]);
  
          if (identifier-&gt;isString())
<span class="line-modified">!             nameArray.add(identifierFromNPIdentifier(exec, identifier-&gt;string()));</span>
          else
              nameArray.add(Identifier::from(vm, identifier-&gt;number()));
      }
  
      // FIXME: This should really call NPN_MemFree but that&#39;s in WebKit
<span class="line-new-header">--- 332,47 ---</span>
      bool retval = true;
      NPVariant resultVariant;
      VOID_TO_NPVARIANT(resultVariant);
  
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(lexicalGlobalObject);</span>
          ASSERT(globalExceptionString().isNull());
          retval = _object-&gt;_class-&gt;invoke(_object, ident, 0, 0, &amp;resultVariant);
<span class="line-modified">!         moveGlobalExceptionToExecState(lexicalGlobalObject);</span>
      }
  
      if (!retval)
<span class="line-modified">!         throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, &quot;Error calling method on NPObject.&quot;_s));</span>
  
<span class="line-modified">!     resultValue = convertNPVariantToValue(lexicalGlobalObject, &amp;resultVariant, m_rootObject.get());</span>
      _NPN_ReleaseVariantValue(&amp;resultVariant);
      return true;
  }
  
<span class="line-modified">! void CInstance::getPropertyNames(JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; nameArray)</span>
  {
      if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(_object-&gt;_class) || !_object-&gt;_class-&gt;enumerate)
          return;
  
      uint32_t count;
      NPIdentifier* identifiers;
  
      {
<span class="line-modified">!         JSLock::DropAllLocks dropAllLocks(lexicalGlobalObject);</span>
          ASSERT(globalExceptionString().isNull());
          bool ok = _object-&gt;_class-&gt;enumerate(_object, &amp;identifiers, &amp;count);
<span class="line-modified">!         moveGlobalExceptionToExecState(lexicalGlobalObject);</span>
          if (!ok)
              return;
      }
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      for (uint32_t i = 0; i &lt; count; i++) {
          IdentifierRep* identifier = static_cast&lt;IdentifierRep*&gt;(identifiers[i]);
  
          if (identifier-&gt;isString())
<span class="line-modified">!             nameArray.add(identifierFromNPIdentifier(lexicalGlobalObject, identifier-&gt;string()));</span>
          else
              nameArray.add(Identifier::from(vm, identifier-&gt;number()));
      }
  
      // FIXME: This should really call NPN_MemFree but that&#39;s in WebKit
</pre>
<center><a href="CRuntimeObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="c_instance.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
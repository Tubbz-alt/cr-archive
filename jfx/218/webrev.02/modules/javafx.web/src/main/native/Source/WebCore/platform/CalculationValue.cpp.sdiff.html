<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../page/scrolling/nicosia/ScrollingTreeStickyNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CalculationValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 
 39 namespace WebCore {
 40 
 41 Ref&lt;CalculationValue&gt; CalculationValue::create(std::unique_ptr&lt;CalcExpressionNode&gt; value, ValueRange range)
 42 {
 43     return adoptRef(*new CalculationValue(WTFMove(value), range));
 44 }
 45 
 46 float CalcExpressionNumber::evaluate(float) const
 47 {
 48     return m_value;
 49 }
 50 
 51 void CalcExpressionNumber::dump(TextStream&amp; ts) const
 52 {
 53     ts &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_value);
 54 }
 55 
 56 bool CalcExpressionNumber::operator==(const CalcExpressionNode&amp; other) const
 57 {
<span class="line-modified"> 58     return other.type() == CalcExpressionNodeType::Number &amp;&amp; *this == toCalcExpressionNumber(other);</span>
 59 }
 60 
 61 float CalculationValue::evaluate(float maxValue) const
 62 {
 63     float result = m_expression-&gt;evaluate(maxValue);
 64     // FIXME: This test was originally needed when we did not detect division by zero at parse time.
 65     // It&#39;s possible that this is now unneeded code and can be removed.
 66     if (std::isnan(result))
 67         return 0;
 68     return m_shouldClampToNonNegative &amp;&amp; result &lt; 0 ? 0 : result;
 69 }
 70 












































 71 float CalcExpressionOperation::evaluate(float maxValue) const
 72 {
 73     switch (m_operator) {
 74     case CalcOperator::Add: {
<span class="line-modified"> 75         ASSERT(m_children.size() == 2);</span>
<span class="line-modified"> 76         float left = m_children[0]-&gt;evaluate(maxValue);</span>
<span class="line-modified"> 77         float right = m_children[1]-&gt;evaluate(maxValue);</span>
<span class="line-modified"> 78         return left + right;</span>
 79     }
 80     case CalcOperator::Subtract: {

 81         ASSERT(m_children.size() == 2);
 82         float left = m_children[0]-&gt;evaluate(maxValue);
 83         float right = m_children[1]-&gt;evaluate(maxValue);
 84         return left - right;
 85     }
 86     case CalcOperator::Multiply: {
<span class="line-modified"> 87         ASSERT(m_children.size() == 2);</span>
<span class="line-modified"> 88         float left = m_children[0]-&gt;evaluate(maxValue);</span>
<span class="line-modified"> 89         float right = m_children[1]-&gt;evaluate(maxValue);</span>
<span class="line-modified"> 90         return left * right;</span>
 91     }
 92     case CalcOperator::Divide: {

 93         ASSERT(m_children.size() == 1 || m_children.size() == 2);
 94         if (m_children.size() == 1)
 95             return std::numeric_limits&lt;float&gt;::quiet_NaN();
 96         float left = m_children[0]-&gt;evaluate(maxValue);
 97         float right = m_children[1]-&gt;evaluate(maxValue);
 98         return left / right;
 99     }
100     case CalcOperator::Min: {
101         if (m_children.isEmpty())
102             return std::numeric_limits&lt;float&gt;::quiet_NaN();
103         float minimum = m_children[0]-&gt;evaluate(maxValue);
104         for (auto&amp; child : m_children)
105             minimum = std::min(minimum, child-&gt;evaluate(maxValue));
106         return minimum;
107     }
108     case CalcOperator::Max: {
109         if (m_children.isEmpty())
110             return std::numeric_limits&lt;float&gt;::quiet_NaN();
111         float maximum = m_children[0]-&gt;evaluate(maxValue);
112         for (auto&amp; child : m_children)
113             maximum = std::max(maximum, child-&gt;evaluate(maxValue));
114         return maximum;
115     }









116     }
117     ASSERT_NOT_REACHED();
118     return std::numeric_limits&lt;float&gt;::quiet_NaN();
119 }
120 
121 bool CalcExpressionOperation::operator==(const CalcExpressionNode&amp; other) const
122 {
<span class="line-modified">123     return other.type() == CalcExpressionNodeType::Operation &amp;&amp; *this == toCalcExpressionOperation(other);</span>
124 }
125 
126 bool operator==(const CalcExpressionOperation&amp; a, const CalcExpressionOperation&amp; b)
127 {
128     if (a.getOperator() != b.getOperator())
129         return false;
130     // Maybe Vectors of unique_ptrs should always do deep compare?
131     if (a.children().size() != b.children().size())
132         return false;
133     for (unsigned i = 0; i &lt; a.children().size(); ++i) {
134         if (!(*a.children()[i] == *b.children()[i]))
135             return false;
136     }
137     return true;
138 }
139 
140 void CalcExpressionOperation::dump(TextStream&amp; ts) const
141 {
142     if (m_operator == CalcOperator::Min || m_operator == CalcOperator::Max) {
143         ts &lt;&lt; m_operator &lt;&lt; &quot;(&quot;;
144         size_t childrenCount = m_children.size();
145         for (size_t i = 0; i &lt; childrenCount; i++) {
146             ts &lt;&lt; m_children[i].get();
147             if (i &lt; childrenCount - 1)
148                 ts &lt;&lt; &quot;, &quot;;
149         }
150         ts &lt;&lt; &quot;)&quot;;
151     } else
152         ts &lt;&lt; m_children[0].get() &lt;&lt; &quot; &quot; &lt;&lt; m_operator &lt;&lt; &quot; &quot; &lt;&lt; m_children[1].get();
153 }
154 
155 float CalcExpressionLength::evaluate(float maxValue) const
156 {
157     return floatValueForLength(m_length, maxValue);
158 }
159 
160 bool CalcExpressionLength::operator==(const CalcExpressionNode&amp; other) const
161 {
<span class="line-modified">162     return other.type() == CalcExpressionNodeType::Length &amp;&amp; *this == toCalcExpressionLength(other);</span>
163 }
164 
165 void CalcExpressionLength::dump(TextStream&amp; ts) const
166 {
167     ts &lt;&lt; m_length;
168 }
169 
170 CalcExpressionBlendLength::CalcExpressionBlendLength(Length from, Length to, float progress)
171     : CalcExpressionNode(CalcExpressionNodeType::BlendLength)
172     , m_from(from)
173     , m_to(to)
174     , m_progress(progress)
175 {
176     // Flatten nesting of CalcExpressionBlendLength as a speculative fix for rdar://problem/30533005.
177     // CalcExpressionBlendLength is only used as a result of animation and they don&#39;t nest in normal cases.
178     if (m_from.isCalculated() &amp;&amp; m_from.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">179         m_from = toCalcExpressionBlendLength(m_from.calculationValue().expression()).from();</span>
180     if (m_to.isCalculated() &amp;&amp; m_to.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">181         m_to = toCalcExpressionBlendLength(m_to.calculationValue().expression()).to();</span>
182 }
183 
184 float CalcExpressionBlendLength::evaluate(float maxValue) const
185 {
186     return (1.0f - m_progress) * floatValueForLength(m_from, maxValue) + m_progress * floatValueForLength(m_to, maxValue);
187 }
188 
189 bool CalcExpressionBlendLength::operator==(const CalcExpressionNode&amp; other) const
190 {
<span class="line-modified">191     return other.type() == CalcExpressionNodeType::BlendLength &amp;&amp; *this == toCalcExpressionBlendLength(other);</span>
192 }
193 
194 void CalcExpressionBlendLength::dump(TextStream&amp; ts) const
195 {
196     ts &lt;&lt; &quot;blend(&quot; &lt;&lt; m_from &lt;&lt; &quot;, &quot; &lt;&lt; m_to &lt;&lt; &quot;, &quot; &lt;&lt; m_progress &lt;&lt; &quot;)&quot;;
197 }
198 
199 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CalcOperator op)
200 {
201     switch (op) {
202     case CalcOperator::Add: ts &lt;&lt; &quot;+&quot;; break;
203     case CalcOperator::Subtract: ts &lt;&lt; &quot;-&quot;; break;
204     case CalcOperator::Multiply: ts &lt;&lt; &quot;*&quot;; break;
205     case CalcOperator::Divide: ts &lt;&lt; &quot;/&quot;; break;
<span class="line-modified">206     case CalcOperator::Min: ts &lt;&lt; &quot;max&quot;; break;</span>
<span class="line-modified">207     case CalcOperator::Max: ts &lt;&lt; &quot;min&quot;; break;</span>

208     }
209     return ts;
210 }
211 
212 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalculationValue&amp; value)
213 {
214     ts &lt;&lt; &quot;calc(&quot;;
215     ts &lt;&lt; value.expression();
216     ts &lt;&lt; &quot;)&quot;;
217     return ts;
218 }
219 
220 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalcExpressionNode&amp; expressionNode)
221 {
222     expressionNode.dump(ts);
223     return ts;
224 }
225 
226 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 38 
 39 namespace WebCore {
 40 
 41 Ref&lt;CalculationValue&gt; CalculationValue::create(std::unique_ptr&lt;CalcExpressionNode&gt; value, ValueRange range)
 42 {
 43     return adoptRef(*new CalculationValue(WTFMove(value), range));
 44 }
 45 
 46 float CalcExpressionNumber::evaluate(float) const
 47 {
 48     return m_value;
 49 }
 50 
 51 void CalcExpressionNumber::dump(TextStream&amp; ts) const
 52 {
 53     ts &lt;&lt; TextStream::FormatNumberRespectingIntegers(m_value);
 54 }
 55 
 56 bool CalcExpressionNumber::operator==(const CalcExpressionNode&amp; other) const
 57 {
<span class="line-modified"> 58     return is&lt;CalcExpressionNumber&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionNumber&gt;(other);</span>
 59 }
 60 
 61 float CalculationValue::evaluate(float maxValue) const
 62 {
 63     float result = m_expression-&gt;evaluate(maxValue);
 64     // FIXME: This test was originally needed when we did not detect division by zero at parse time.
 65     // It&#39;s possible that this is now unneeded code and can be removed.
 66     if (std::isnan(result))
 67         return 0;
 68     return m_shouldClampToNonNegative &amp;&amp; result &lt; 0 ? 0 : result;
 69 }
 70 
<span class="line-added"> 71 float CalcExpressionNegation::evaluate(float maxValue) const</span>
<span class="line-added"> 72 {</span>
<span class="line-added"> 73     return -m_child-&gt;evaluate(maxValue);</span>
<span class="line-added"> 74 }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76 bool CalcExpressionNegation::operator==(const CalcExpressionNode&amp; other) const</span>
<span class="line-added"> 77 {</span>
<span class="line-added"> 78     return is&lt;CalcExpressionNegation&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionNegation&gt;(other);</span>
<span class="line-added"> 79 }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 void CalcExpressionNegation::dump(TextStream&amp; ts) const</span>
<span class="line-added"> 82 {</span>
<span class="line-added"> 83     ts &lt;&lt; &quot;-(&quot;;</span>
<span class="line-added"> 84     ts &lt;&lt; *m_child;</span>
<span class="line-added"> 85     ts &lt;&lt; &quot;)&quot;;</span>
<span class="line-added"> 86 }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88 bool operator==(const CalcExpressionNegation&amp; a, const CalcExpressionNegation&amp; b)</span>
<span class="line-added"> 89 {</span>
<span class="line-added"> 90     return *a.child() == *b.child();</span>
<span class="line-added"> 91 }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 float CalcExpressionInversion::evaluate(float maxValue) const</span>
<span class="line-added"> 94 {</span>
<span class="line-added"> 95     return 1.0f / m_child-&gt;evaluate(maxValue);</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 void CalcExpressionInversion::dump(TextStream&amp; ts) const</span>
<span class="line-added"> 99 {</span>
<span class="line-added">100     ts &lt;&lt; &quot;1.0 / &quot; &lt;&lt; &quot;(&quot;;</span>
<span class="line-added">101     ts &lt;&lt; *m_child;</span>
<span class="line-added">102     ts &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">103 }</span>
<span class="line-added">104 </span>
<span class="line-added">105 bool CalcExpressionInversion::operator==(const CalcExpressionNode&amp; other) const</span>
<span class="line-added">106 {</span>
<span class="line-added">107     return is&lt;CalcExpressionInversion&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionInversion&gt;(other);</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
<span class="line-added">110 bool operator==(const CalcExpressionInversion&amp; a, const CalcExpressionInversion&amp; b)</span>
<span class="line-added">111 {</span>
<span class="line-added">112     return *a.child() == *b.child();</span>
<span class="line-added">113 }</span>
<span class="line-added">114 </span>
115 float CalcExpressionOperation::evaluate(float maxValue) const
116 {
117     switch (m_operator) {
118     case CalcOperator::Add: {
<span class="line-modified">119         float sum = 0;</span>
<span class="line-modified">120         for (auto&amp; child : m_children)</span>
<span class="line-modified">121             sum += child-&gt;evaluate(maxValue);</span>
<span class="line-modified">122         return sum;</span>
123     }
124     case CalcOperator::Subtract: {
<span class="line-added">125         // FIXME</span>
126         ASSERT(m_children.size() == 2);
127         float left = m_children[0]-&gt;evaluate(maxValue);
128         float right = m_children[1]-&gt;evaluate(maxValue);
129         return left - right;
130     }
131     case CalcOperator::Multiply: {
<span class="line-modified">132         float product = 1;</span>
<span class="line-modified">133         for (auto&amp; child : m_children)</span>
<span class="line-modified">134             product *= child-&gt;evaluate(maxValue);</span>
<span class="line-modified">135         return product;</span>
136     }
137     case CalcOperator::Divide: {
<span class="line-added">138         // FIXME</span>
139         ASSERT(m_children.size() == 1 || m_children.size() == 2);
140         if (m_children.size() == 1)
141             return std::numeric_limits&lt;float&gt;::quiet_NaN();
142         float left = m_children[0]-&gt;evaluate(maxValue);
143         float right = m_children[1]-&gt;evaluate(maxValue);
144         return left / right;
145     }
146     case CalcOperator::Min: {
147         if (m_children.isEmpty())
148             return std::numeric_limits&lt;float&gt;::quiet_NaN();
149         float minimum = m_children[0]-&gt;evaluate(maxValue);
150         for (auto&amp; child : m_children)
151             minimum = std::min(minimum, child-&gt;evaluate(maxValue));
152         return minimum;
153     }
154     case CalcOperator::Max: {
155         if (m_children.isEmpty())
156             return std::numeric_limits&lt;float&gt;::quiet_NaN();
157         float maximum = m_children[0]-&gt;evaluate(maxValue);
158         for (auto&amp; child : m_children)
159             maximum = std::max(maximum, child-&gt;evaluate(maxValue));
160         return maximum;
161     }
<span class="line-added">162     case CalcOperator::Clamp: {</span>
<span class="line-added">163         if (m_children.size() != 3)</span>
<span class="line-added">164             return std::numeric_limits&lt;float&gt;::quiet_NaN();</span>
<span class="line-added">165 </span>
<span class="line-added">166         float min = m_children[0]-&gt;evaluate(maxValue);</span>
<span class="line-added">167         float value = m_children[1]-&gt;evaluate(maxValue);</span>
<span class="line-added">168         float max = m_children[2]-&gt;evaluate(maxValue);</span>
<span class="line-added">169         return std::max(min, std::min(value, max));</span>
<span class="line-added">170     }</span>
171     }
172     ASSERT_NOT_REACHED();
173     return std::numeric_limits&lt;float&gt;::quiet_NaN();
174 }
175 
176 bool CalcExpressionOperation::operator==(const CalcExpressionNode&amp; other) const
177 {
<span class="line-modified">178     return is&lt;CalcExpressionOperation&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionOperation&gt;(other);</span>
179 }
180 
181 bool operator==(const CalcExpressionOperation&amp; a, const CalcExpressionOperation&amp; b)
182 {
183     if (a.getOperator() != b.getOperator())
184         return false;
185     // Maybe Vectors of unique_ptrs should always do deep compare?
186     if (a.children().size() != b.children().size())
187         return false;
188     for (unsigned i = 0; i &lt; a.children().size(); ++i) {
189         if (!(*a.children()[i] == *b.children()[i]))
190             return false;
191     }
192     return true;
193 }
194 
195 void CalcExpressionOperation::dump(TextStream&amp; ts) const
196 {
197     if (m_operator == CalcOperator::Min || m_operator == CalcOperator::Max) {
198         ts &lt;&lt; m_operator &lt;&lt; &quot;(&quot;;
199         size_t childrenCount = m_children.size();
200         for (size_t i = 0; i &lt; childrenCount; i++) {
201             ts &lt;&lt; m_children[i].get();
202             if (i &lt; childrenCount - 1)
203                 ts &lt;&lt; &quot;, &quot;;
204         }
205         ts &lt;&lt; &quot;)&quot;;
206     } else
207         ts &lt;&lt; m_children[0].get() &lt;&lt; &quot; &quot; &lt;&lt; m_operator &lt;&lt; &quot; &quot; &lt;&lt; m_children[1].get();
208 }
209 
210 float CalcExpressionLength::evaluate(float maxValue) const
211 {
212     return floatValueForLength(m_length, maxValue);
213 }
214 
215 bool CalcExpressionLength::operator==(const CalcExpressionNode&amp; other) const
216 {
<span class="line-modified">217     return is&lt;CalcExpressionLength&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionLength&gt;(other);</span>
218 }
219 
220 void CalcExpressionLength::dump(TextStream&amp; ts) const
221 {
222     ts &lt;&lt; m_length;
223 }
224 
225 CalcExpressionBlendLength::CalcExpressionBlendLength(Length from, Length to, float progress)
226     : CalcExpressionNode(CalcExpressionNodeType::BlendLength)
227     , m_from(from)
228     , m_to(to)
229     , m_progress(progress)
230 {
231     // Flatten nesting of CalcExpressionBlendLength as a speculative fix for rdar://problem/30533005.
232     // CalcExpressionBlendLength is only used as a result of animation and they don&#39;t nest in normal cases.
233     if (m_from.isCalculated() &amp;&amp; m_from.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">234         m_from = downcast&lt;CalcExpressionBlendLength&gt;(m_from.calculationValue().expression()).from();</span>
235     if (m_to.isCalculated() &amp;&amp; m_to.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
<span class="line-modified">236         m_to = downcast&lt;CalcExpressionBlendLength&gt;(m_to.calculationValue().expression()).to();</span>
237 }
238 
239 float CalcExpressionBlendLength::evaluate(float maxValue) const
240 {
241     return (1.0f - m_progress) * floatValueForLength(m_from, maxValue) + m_progress * floatValueForLength(m_to, maxValue);
242 }
243 
244 bool CalcExpressionBlendLength::operator==(const CalcExpressionNode&amp; other) const
245 {
<span class="line-modified">246     return is&lt;CalcExpressionBlendLength&gt;(other) &amp;&amp; *this == downcast&lt;CalcExpressionBlendLength&gt;(other);</span>
247 }
248 
249 void CalcExpressionBlendLength::dump(TextStream&amp; ts) const
250 {
251     ts &lt;&lt; &quot;blend(&quot; &lt;&lt; m_from &lt;&lt; &quot;, &quot; &lt;&lt; m_to &lt;&lt; &quot;, &quot; &lt;&lt; m_progress &lt;&lt; &quot;)&quot;;
252 }
253 
254 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CalcOperator op)
255 {
256     switch (op) {
257     case CalcOperator::Add: ts &lt;&lt; &quot;+&quot;; break;
258     case CalcOperator::Subtract: ts &lt;&lt; &quot;-&quot;; break;
259     case CalcOperator::Multiply: ts &lt;&lt; &quot;*&quot;; break;
260     case CalcOperator::Divide: ts &lt;&lt; &quot;/&quot;; break;
<span class="line-modified">261     case CalcOperator::Min: ts &lt;&lt; &quot;min&quot;; break;</span>
<span class="line-modified">262     case CalcOperator::Max: ts &lt;&lt; &quot;max&quot;; break;</span>
<span class="line-added">263     case CalcOperator::Clamp: ts &lt;&lt; &quot;clamp&quot;; break;</span>
264     }
265     return ts;
266 }
267 
268 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalculationValue&amp; value)
269 {
270     ts &lt;&lt; &quot;calc(&quot;;
271     ts &lt;&lt; value.expression();
272     ts &lt;&lt; &quot;)&quot;;
273     return ts;
274 }
275 
276 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CalcExpressionNode&amp; expressionNode)
277 {
278     expressionNode.dump(ts);
279     return ts;
280 }
281 
282 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="../page/scrolling/nicosia/ScrollingTreeStickyNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CalculationValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
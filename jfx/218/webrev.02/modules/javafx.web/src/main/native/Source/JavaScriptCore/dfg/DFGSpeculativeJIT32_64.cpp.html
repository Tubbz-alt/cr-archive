<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Intel Corporation. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;DFGSpeculativeJIT.h&quot;
  29 
  30 #if ENABLE(DFG_JIT)
  31 
  32 #include &quot;ArrayPrototype.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGOperations.h&quot;
  37 #include &quot;DFGSlowPathGenerator.h&quot;
  38 #include &quot;DirectArguments.h&quot;
  39 #include &quot;GetterSetter.h&quot;
  40 #include &quot;HasOwnPropertyCache.h&quot;
  41 #include &quot;HashMapImpl.h&quot;
  42 #include &quot;JSLexicalEnvironment.h&quot;
  43 #include &quot;JSPropertyNameEnumerator.h&quot;
  44 #include &quot;ObjectPrototype.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &quot;SetupVarargsFrame.h&quot;
  47 #include &quot;SuperSampler.h&quot;
  48 #include &quot;Watchdog.h&quot;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 #if USE(JSVALUE32_64)
  53 
  54 static_assert(SpecCellCheck == SpecCell, &quot;This is strongly assumed in the 32-bit DFG backend.&quot;);
  55 
  56 bool SpeculativeJIT::fillJSValue(Edge edge, GPRReg&amp; tagGPR, GPRReg&amp; payloadGPR, FPRReg&amp; fpr)
  57 {
  58     // FIXME: For double we could fill with a FPR.
  59     UNUSED_PARAM(fpr);
  60 
  61     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  62     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  63 
  64     switch (info.registerFormat()) {
  65     case DataFormatNone: {
  66 
  67         if (edge-&gt;hasConstant()) {
  68             tagGPR = allocate();
  69             payloadGPR = allocate();
  70             JSValue value = edge-&gt;asJSValue();
  71             m_jit.move(Imm32(value.tag()), tagGPR);
  72             m_jit.move(Imm32(value.payload()), payloadGPR);
  73             m_gprs.retain(tagGPR, virtualRegister, SpillOrderConstant);
  74             m_gprs.retain(payloadGPR, virtualRegister, SpillOrderConstant);
  75             info.fillJSValue(*m_stream, tagGPR, payloadGPR, DataFormatJS);
  76         } else {
  77             DataFormat spillFormat = info.spillFormat();
  78             ASSERT(spillFormat != DataFormatNone &amp;&amp; spillFormat != DataFormatStorage);
  79             tagGPR = allocate();
  80             payloadGPR = allocate();
  81             switch (spillFormat) {
  82             case DataFormatInt32:
  83                 m_jit.move(TrustedImm32(JSValue::Int32Tag), tagGPR);
  84                 spillFormat = DataFormatJSInt32; // This will be used as the new register format.
  85                 break;
  86             case DataFormatCell:
  87                 m_jit.move(TrustedImm32(JSValue::CellTag), tagGPR);
  88                 spillFormat = DataFormatJSCell; // This will be used as the new register format.
  89                 break;
  90             case DataFormatBoolean:
  91                 m_jit.move(TrustedImm32(JSValue::BooleanTag), tagGPR);
  92                 spillFormat = DataFormatJSBoolean; // This will be used as the new register format.
  93                 break;
  94             default:
  95                 m_jit.load32(JITCompiler::tagFor(virtualRegister), tagGPR);
  96                 break;
  97             }
  98             m_jit.load32(JITCompiler::payloadFor(virtualRegister), payloadGPR);
  99             m_gprs.retain(tagGPR, virtualRegister, SpillOrderSpilled);
 100             m_gprs.retain(payloadGPR, virtualRegister, SpillOrderSpilled);
 101             info.fillJSValue(*m_stream, tagGPR, payloadGPR, spillFormat == DataFormatJSDouble ? DataFormatJS : spillFormat);
 102         }
 103 
 104         return true;
 105     }
 106 
 107     case DataFormatInt32:
 108     case DataFormatCell:
 109     case DataFormatBoolean: {
 110         GPRReg gpr = info.gpr();
 111         // If the register has already been locked we need to take a copy.
 112         if (m_gprs.isLocked(gpr)) {
 113             payloadGPR = allocate();
 114             m_jit.move(gpr, payloadGPR);
 115         } else {
 116             payloadGPR = gpr;
 117             m_gprs.lock(gpr);
 118         }
 119         tagGPR = allocate();
 120         int32_t tag = JSValue::EmptyValueTag;
 121         DataFormat fillFormat = DataFormatJS;
 122         switch (info.registerFormat()) {
 123         case DataFormatInt32:
 124             tag = JSValue::Int32Tag;
 125             fillFormat = DataFormatJSInt32;
 126             break;
 127         case DataFormatCell:
 128             tag = JSValue::CellTag;
 129             fillFormat = DataFormatJSCell;
 130             break;
 131         case DataFormatBoolean:
 132             tag = JSValue::BooleanTag;
 133             fillFormat = DataFormatJSBoolean;
 134             break;
 135         default:
 136             RELEASE_ASSERT_NOT_REACHED();
 137             break;
 138         }
 139         m_jit.move(TrustedImm32(tag), tagGPR);
 140         m_gprs.release(gpr);
 141         m_gprs.retain(tagGPR, virtualRegister, SpillOrderJS);
 142         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderJS);
 143         info.fillJSValue(*m_stream, tagGPR, payloadGPR, fillFormat);
 144         return true;
 145     }
 146 
 147     case DataFormatJSDouble:
 148     case DataFormatJS:
 149     case DataFormatJSInt32:
 150     case DataFormatJSCell:
 151     case DataFormatJSBoolean: {
 152         tagGPR = info.tagGPR();
 153         payloadGPR = info.payloadGPR();
 154         m_gprs.lock(tagGPR);
 155         m_gprs.lock(payloadGPR);
 156         return true;
 157     }
 158 
 159     case DataFormatStorage:
 160     case DataFormatDouble:
 161         // this type currently never occurs
 162         RELEASE_ASSERT_NOT_REACHED();
 163 
 164     default:
 165         RELEASE_ASSERT_NOT_REACHED();
 166         return true;
 167     }
 168 }
 169 
 170 void SpeculativeJIT::cachedGetById(CodeOrigin origin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget , SpillRegistersMode mode, AccessType type)
 171 {
 172     cachedGetById(origin, base.tagGPR(), base.payloadGPR(), result.tagGPR(), result.payloadGPR(), identifierNumber, slowPathTarget, mode, type);
 173 }
 174 
 175 void SpeculativeJIT::cachedGetById(
 176     CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR,
 177     unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode, AccessType type)
 178 {
 179     // This is a hacky fix for when the register allocator decides to alias the base payload with the result tag. This only happens
 180     // in the case of GetByIdFlush/GetByIdDirectFlush, which has a relatively expensive register allocation story already so we probably don&#39;t need to
 181     // trip over one move instruction.
 182     if (basePayloadGPR == resultTagGPR) {
 183         RELEASE_ASSERT(basePayloadGPR != resultPayloadGPR);
 184 
 185         if (baseTagGPROrNone == resultPayloadGPR) {
 186             m_jit.swap(basePayloadGPR, baseTagGPROrNone);
 187             baseTagGPROrNone = resultTagGPR;
 188         } else
 189             m_jit.move(basePayloadGPR, resultPayloadGPR);
 190         basePayloadGPR = resultPayloadGPR;
 191     }
 192 
 193     RegisterSet usedRegisters = this-&gt;usedRegisters();
 194     if (spillMode == DontSpill) {
 195         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 196         usedRegisters.set(JSValueRegs(baseTagGPROrNone, basePayloadGPR), false);
 197         usedRegisters.set(JSValueRegs(resultTagGPR, resultPayloadGPR), false);
 198     }
 199 
 200     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 201     JITGetByIdGenerator gen(
 202         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 203         JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(resultTagGPR, resultPayloadGPR), type);
 204 
 205     gen.generateFastPath(m_jit);
 206 
 207     JITCompiler::JumpList slowCases;
 208     if (slowPathTarget.isSet())
 209         slowCases.append(slowPathTarget);
 210     slowCases.append(gen.slowPathJump());
 211 
 212     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 213     if (baseTagGPROrNone == InvalidGPRReg) {
 214         slowPath = slowPathCall(
 215             slowCases, this, appropriateOptimizingGetByIdFunction(type),
 216             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(),
 217             CCallHelpers::CellValue(basePayloadGPR),
 218             identifierUID(identifierNumber));
 219     } else {
 220         slowPath = slowPathCall(
 221             slowCases, this, appropriateOptimizingGetByIdFunction(type),
 222             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), identifierUID(identifierNumber));
 223     }
 224 
 225     m_jit.addGetById(gen, slowPath.get());
 226     addSlowPathGenerator(WTFMove(slowPath));
 227 }
 228 
 229 void SpeculativeJIT::cachedGetByIdWithThis(
 230     CodeOrigin codeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg thisTagGPR, GPRReg thisPayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR,
 231     unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 232 {
 233     RegisterSet usedRegisters = this-&gt;usedRegisters();
 234 
 235     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 236     JITGetByIdWithThisGenerator gen(
 237         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 238         JSValueRegs(resultTagGPR, resultPayloadGPR), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR));
 239 
 240     gen.generateFastPath(m_jit);
 241 
 242     JITCompiler::JumpList slowCases;
 243     if (!slowPathTarget.empty())
 244         slowCases.append(slowPathTarget);
 245     slowCases.append(gen.slowPathJump());
 246 
 247     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
 248     if (baseTagGPROrNone == InvalidGPRReg &amp;&amp; thisTagGPR == InvalidGPRReg) {
 249         slowPath = slowPathCall(
 250             slowCases, this, operationGetByIdWithThisOptimize,
 251             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(),
 252             CCallHelpers::CellValue(basePayloadGPR),
 253             CCallHelpers::CellValue(thisPayloadGPR),
 254             identifierUID(identifierNumber));
 255     } else {
 256         ASSERT(baseTagGPROrNone != InvalidGPRReg);
 257         ASSERT(thisTagGPR != InvalidGPRReg);
 258 
 259         slowPath = slowPathCall(
 260             slowCases, this, operationGetByIdWithThisOptimize,
 261             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), identifierUID(identifierNumber));
 262     }
 263 
 264     m_jit.addGetByIdWithThis(gen, slowPath.get());
 265     addSlowPathGenerator(WTFMove(slowPath));
 266 }
 267 
 268 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 269 {
 270     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 271     GPRReg argTagGPR = arg.tagGPR();
 272     GPRReg argPayloadGPR = arg.payloadGPR();
 273 
 274     GPRTemporary resultPayload(this, Reuse, arg, PayloadWord);
 275     GPRReg resultPayloadGPR = resultPayload.gpr();
 276 
 277     JITCompiler::Jump notCell;
 278     JITCompiler::Jump notMasqueradesAsUndefined;
 279     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 280         if (!isKnownCell(operand.node()))
 281             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 282 
 283         m_jit.move(TrustedImm32(0), resultPayloadGPR);
 284         notMasqueradesAsUndefined = m_jit.jump();
 285     } else {
 286         GPRTemporary localGlobalObject(this);
 287         GPRTemporary remoteGlobalObject(this);
 288 
 289         if (!isKnownCell(operand.node()))
 290             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 291 
 292         JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
 293             JITCompiler::NonZero,
 294             JITCompiler::Address(argPayloadGPR, JSCell::typeInfoFlagsOffset()),
 295             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 296 
 297         m_jit.move(TrustedImm32(0), resultPayloadGPR);
 298         notMasqueradesAsUndefined = m_jit.jump();
 299 
 300         isMasqueradesAsUndefined.link(&amp;m_jit);
 301         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 302         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 303         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 304         m_jit.loadPtr(JITCompiler::Address(argPayloadGPR, JSCell::structureIDOffset()), resultPayloadGPR);
 305         m_jit.loadPtr(JITCompiler::Address(resultPayloadGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 306         m_jit.compare32(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultPayloadGPR);
 307     }
 308 
 309     if (!isKnownCell(operand.node())) {
 310         JITCompiler::Jump done = m_jit.jump();
 311 
 312         notCell.link(&amp;m_jit);
 313         // null or undefined?
 314         COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
 315         m_jit.or32(TrustedImm32(1), argTagGPR, resultPayloadGPR);
 316         m_jit.compare32(JITCompiler::Equal, resultPayloadGPR, TrustedImm32(JSValue::NullTag), resultPayloadGPR);
 317 
 318         done.link(&amp;m_jit);
 319     }
 320 
 321     notMasqueradesAsUndefined.link(&amp;m_jit);
 322 
 323     booleanResult(resultPayloadGPR, m_currentNode);
 324 }
 325 
 326 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 327 {
 328     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 329     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 330 
 331     bool invert = false;
 332     if (taken == nextBlock()) {
 333         invert = !invert;
 334         BasicBlock* tmp = taken;
 335         taken = notTaken;
 336         notTaken = tmp;
 337     }
 338 
 339     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 340     GPRReg argTagGPR = arg.tagGPR();
 341     GPRReg argPayloadGPR = arg.payloadGPR();
 342 
 343     GPRTemporary result(this, Reuse, arg, TagWord);
 344     GPRReg resultGPR = result.gpr();
 345 
 346     JITCompiler::Jump notCell;
 347 
 348     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 349         if (!isKnownCell(operand.node()))
 350             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 351 
 352         jump(invert ? taken : notTaken, ForceJump);
 353     } else {
 354         GPRTemporary localGlobalObject(this);
 355         GPRTemporary remoteGlobalObject(this);
 356 
 357         if (!isKnownCell(operand.node()))
 358             notCell = m_jit.branchIfNotCell(arg.jsValueRegs());
 359 
 360         branchTest8(JITCompiler::Zero,
 361             JITCompiler::Address(argPayloadGPR, JSCell::typeInfoFlagsOffset()),
 362             JITCompiler::TrustedImm32(MasqueradesAsUndefined),
 363             invert ? taken : notTaken);
 364 
 365         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 366         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 367         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 368         m_jit.loadPtr(JITCompiler::Address(argPayloadGPR, JSCell::structureIDOffset()), resultGPR);
 369         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 370         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, invert ? notTaken : taken);
 371     }
 372 
 373     if (!isKnownCell(operand.node())) {
 374         jump(notTaken, ForceJump);
 375 
 376         notCell.link(&amp;m_jit);
 377         // null or undefined?
 378         COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
 379         m_jit.or32(TrustedImm32(1), argTagGPR, resultGPR);
 380         branch32(invert ? JITCompiler::NotEqual : JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(JSValue::NullTag), taken);
 381     }
 382 
 383     jump(notTaken);
 384 }
 385 
 386 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 387 {
 388     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 389     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 390 
 391     // The branch instruction will branch to the taken block.
 392     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 393     if (taken == nextBlock()) {
 394         invert = !invert;
 395         BasicBlock* tmp = taken;
 396         taken = notTaken;
 397         notTaken = tmp;
 398     }
 399 
 400     JSValueOperand arg1(this, node-&gt;child1());
 401     JSValueOperand arg2(this, node-&gt;child2());
 402     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 403     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 404     JSValueRegs arg1Regs = arg1.jsValueRegs();
 405     JSValueRegs arg2Regs = arg2.jsValueRegs();
 406 
 407     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 408     GPRReg resultPayloadGPR = resultPayload.gpr();
 409 
 410     arg1.use();
 411     arg2.use();
 412 
 413     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 414         // see if we get lucky: if the arguments are cells and they reference the same
 415         // cell, then they must be strictly equal.
 416         branchPtr(JITCompiler::Equal, arg1PayloadGPR, arg2PayloadGPR, invert ? notTaken : taken);
 417 
 418         silentSpillAllRegisters(resultPayloadGPR);
 419         callOperation(operationCompareStrictEqCell, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1PayloadGPR, arg2PayloadGPR);
 420         m_jit.exceptionCheck();
 421         silentFillAllRegisters();
 422 
 423         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 424     } else {
 425         // FIXME: Add fast paths for twoCells, number etc.
 426 
 427         silentSpillAllRegisters(resultPayloadGPR);
 428         callOperation(operationCompareStrictEq, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);
 429         m_jit.exceptionCheck();
 430         silentFillAllRegisters();
 431 
 432         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
 433     }
 434 
 435     jump(notTaken);
 436 }
 437 
 438 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 439 {
 440     JSValueOperand arg1(this, node-&gt;child1());
 441     JSValueOperand arg2(this, node-&gt;child2());
 442     GPRReg arg1PayloadGPR = arg1.payloadGPR();
 443     GPRReg arg2PayloadGPR = arg2.payloadGPR();
 444     JSValueRegs arg1Regs = arg1.jsValueRegs();
 445     JSValueRegs arg2Regs = arg2.jsValueRegs();
 446 
 447     GPRTemporary resultPayload(this, Reuse, arg1, PayloadWord);
 448     GPRReg resultPayloadGPR = resultPayload.gpr();
 449 
 450     arg1.use();
 451     arg2.use();
 452 
 453     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 454         // see if we get lucky: if the arguments are cells and they reference the same
 455         // cell, then they must be strictly equal.
 456         // FIXME: this should flush registers instead of silent spill/fill.
 457         JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, arg1PayloadGPR, arg2PayloadGPR);
 458 
 459         m_jit.move(JITCompiler::TrustedImm32(!invert), resultPayloadGPR);
 460         JITCompiler::Jump done = m_jit.jump();
 461 
 462         notEqualCase.link(&amp;m_jit);
 463 
 464         silentSpillAllRegisters(resultPayloadGPR);
 465         callOperation(operationCompareStrictEqCell, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1PayloadGPR, arg2PayloadGPR);
 466         m_jit.exceptionCheck();
 467         silentFillAllRegisters();
 468 
 469         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 470 
 471         done.link(&amp;m_jit);
 472     } else {
 473         // FIXME: Add fast paths.
 474 
 475         silentSpillAllRegisters(resultPayloadGPR);
 476         callOperation(operationCompareStrictEq, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);
 477         silentFillAllRegisters();
 478         m_jit.exceptionCheck();
 479 
 480         m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
 481     }
 482 
 483     booleanResult(resultPayloadGPR, node, UseChildrenCalledExplicitly);
 484 }
 485 
 486 void SpeculativeJIT::compileCompareEqPtr(Node* node)
 487 {
 488     JSValueOperand operand(this, node-&gt;child1());
 489     GPRTemporary result(this);
 490     JSValueRegs regs = operand.jsValueRegs();
 491     GPRReg resultGPR = result.gpr();
 492     m_jit.boxBooleanPayload(false, resultGPR);
 493     JITCompiler::JumpList notEqual = m_jit.branchIfNotEqual(regs, node-&gt;cellOperand()-&gt;value());
 494     m_jit.boxBooleanPayload(true, resultGPR);
 495     notEqual.link(&amp;m_jit);
 496     blessedBooleanResult(resultGPR, node);
 497 }
 498 
 499 void SpeculativeJIT::emitCall(Node* node)
 500 {
 501     CallLinkInfo::CallType callType;
 502     bool isVarargs = false;
 503     bool isForwardVarargs = false;
 504     bool isTail = false;
 505     bool isDirect = false;
 506     bool isEmulatedTail = false;
 507     switch (node-&gt;op()) {
 508     case Call:
 509     case CallEval:
 510         callType = CallLinkInfo::Call;
 511         break;
 512     case TailCall:
 513         callType = CallLinkInfo::TailCall;
 514         isTail = true;
 515         break;
 516     case TailCallInlinedCaller:
 517         callType = CallLinkInfo::Call;
 518         isEmulatedTail = true;
 519         break;
 520     case Construct:
 521         callType = CallLinkInfo::Construct;
 522         break;
 523     case CallVarargs:
 524         callType = CallLinkInfo::CallVarargs;
 525         isVarargs = true;
 526         break;
 527     case TailCallVarargs:
 528         callType = CallLinkInfo::TailCallVarargs;
 529         isVarargs = true;
 530         isTail = true;
 531         break;
 532     case TailCallVarargsInlinedCaller:
 533         callType = CallLinkInfo::CallVarargs;
 534         isVarargs = true;
 535         isEmulatedTail = true;
 536         break;
 537     case ConstructVarargs:
 538         callType = CallLinkInfo::ConstructVarargs;
 539         isVarargs = true;
 540         break;
 541     case CallForwardVarargs:
 542         callType = CallLinkInfo::CallVarargs;
 543         isForwardVarargs = true;
 544         break;
 545     case TailCallForwardVarargs:
 546         callType = CallLinkInfo::TailCallVarargs;
 547         isTail = true;
 548         isForwardVarargs = true;
 549         break;
 550     case TailCallForwardVarargsInlinedCaller:
 551         callType = CallLinkInfo::CallVarargs;
 552         isEmulatedTail = true;
 553         isForwardVarargs = true;
 554         break;
 555     case ConstructForwardVarargs:
 556         callType = CallLinkInfo::ConstructVarargs;
 557         isForwardVarargs = true;
 558         break;
 559     case DirectCall:
 560         callType = CallLinkInfo::DirectCall;
 561         isDirect = true;
 562         break;
 563     case DirectConstruct:
 564         callType = CallLinkInfo::DirectConstruct;
 565         isDirect = true;
 566         break;
 567     case DirectTailCall:
 568         callType = CallLinkInfo::DirectTailCall;
 569         isTail = true;
 570         isDirect = true;
 571         break;
 572     case DirectTailCallInlinedCaller:
 573         callType = CallLinkInfo::DirectCall;
 574         isEmulatedTail = true;
 575         isDirect = true;
 576         break;
 577     default:
 578         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 579         break;
 580     }
 581 
 582     Edge calleeEdge = m_jit.graph().child(node, 0);
 583     GPRReg calleeTagGPR = InvalidGPRReg;
 584     GPRReg calleePayloadGPR = InvalidGPRReg;
 585     CallFrameShuffleData shuffleData;
 586 
 587     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 588     ExecutableBase* executable = nullptr;
 589     FunctionExecutable* functionExecutable = nullptr;
 590     if (isDirect) {
 591         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 592         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 593     }
 594 
 595     unsigned numPassedArgs = 0;
 596     unsigned numAllocatedArgs = 0;
 597 
 598     // Gotta load the arguments somehow. Varargs is trickier.
 599     if (isVarargs || isForwardVarargs) {
 600         RELEASE_ASSERT(!isDirect);
 601         CallVarargsData* data = node-&gt;callVarargsData();
 602 
 603         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 604 
 605         if (isForwardVarargs) {
 606             flushRegisters();
 607             if (node-&gt;child3())
 608                 use(node-&gt;child3());
 609 
 610             GPRReg scratchGPR1;
 611             GPRReg scratchGPR2;
 612             GPRReg scratchGPR3;
 613 
 614             scratchGPR1 = JITCompiler::selectScratchGPR();
 615             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 616             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 617 
 618             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 619             JITCompiler::JumpList slowCase;
 620             InlineCallFrame* inlineCallFrame;
 621             if (node-&gt;child3())
 622                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 623             else
 624                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 625             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 626             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 627             JITCompiler::Jump done = m_jit.jump();
 628             slowCase.link(&amp;m_jit);
 629             callOperation(operationThrowStackOverflowForVarargs, TrustedImmPtr::weakPointer(m_graph, globalObject));
 630             m_jit.exceptionCheck();
 631             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 632             done.link(&amp;m_jit);
 633         } else {
 634             GPRReg argumentsPayloadGPR;
 635             GPRReg argumentsTagGPR;
 636             GPRReg scratchGPR1;
 637             GPRReg scratchGPR2;
 638             GPRReg scratchGPR3;
 639 
 640             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 641                 if (reservedGPR != InvalidGPRReg)
 642                     lock(reservedGPR);
 643                 JSValueOperand arguments(this, node-&gt;child3());
 644                 argumentsTagGPR = arguments.tagGPR();
 645                 argumentsPayloadGPR = arguments.payloadGPR();
 646                 if (reservedGPR != InvalidGPRReg)
 647                     unlock(reservedGPR);
 648                 flushRegisters();
 649 
 650                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, reservedGPR);
 651                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, reservedGPR);
 652                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsPayloadGPR, argumentsTagGPR, scratchGPR1, scratchGPR2, reservedGPR);
 653             };
 654 
 655             loadArgumentsGPR(InvalidGPRReg);
 656 
 657             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 658 
 659             // Right now, arguments is in argumentsTagGPR/argumentsPayloadGPR and the register file is
 660             // flushed.
 661             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), numUsedStackSlots, data-&gt;firstVarArgOffset);
 662             m_jit.exceptionCheck();
 663 
 664             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 665             // Reconstruct the arguments operand while preserving the callee frame.
 666             loadArgumentsGPR(GPRInfo::returnValueGPR);
 667             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 668             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 669             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 670 
 671             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scratchGPR1, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);
 672             m_jit.exceptionCheck();
 673             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 674         }
 675 
 676         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 677 
 678         // We don&#39;t need the arguments array anymore.
 679         if (isVarargs)
 680             use(node-&gt;child3());
 681 
 682         // Now set up the &quot;this&quot; argument.
 683         JSValueOperand thisArgument(this, node-&gt;child2());
 684         GPRReg thisArgumentTagGPR = thisArgument.tagGPR();
 685         GPRReg thisArgumentPayloadGPR = thisArgument.payloadGPR();
 686         thisArgument.use();
 687 
 688         m_jit.store32(thisArgumentTagGPR, JITCompiler::calleeArgumentTagSlot(0));
 689         m_jit.store32(thisArgumentPayloadGPR, JITCompiler::calleeArgumentPayloadSlot(0));
 690     } else {
 691         // The call instruction&#39;s first child is either the function (normal call) or the
 692         // receiver (method call). subsequent children are the arguments.
 693         numPassedArgs = node-&gt;numChildren() - 1;
 694         numAllocatedArgs = numPassedArgs;
 695 
 696         if (functionExecutable) {
 697             // Allocate more args if this would let us avoid arity checks. This is throttled by
 698             // CallLinkInfo&#39;s limit. It&#39;s probably good to throttle it - if the callee wants a
 699             // ginormous amount of argument space then it&#39;s better for them to do it so that when we
 700             // make calls to other things, we don&#39;t waste space.
 701             unsigned desiredNumAllocatedArgs = static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1;
 702             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 703                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 704 
 705                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 706                 // do this adjustment now since we will have already emitted code that relied on the
 707                 // value of m_parameterSlots.
 708                 DFG_ASSERT(
 709                     m_jit.graph(), node,
 710                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 711                     &lt;= m_jit.graph().m_parameterSlots);
 712             }
 713         }
 714 
 715         if (isTail) {
 716             JSValueOperand callee(this, calleeEdge);
 717             calleeTagGPR = callee.tagGPR();
 718             calleePayloadGPR = callee.payloadGPR();
 719             if (!isDirect)
 720                 use(calleeEdge);
 721 
 722             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 723             shuffleData.callee = ValueRecovery::inPair(calleeTagGPR, calleePayloadGPR);
 724             shuffleData.args.resize(numAllocatedArgs);
 725             shuffleData.numPassedArgs = numPassedArgs;
 726 
 727             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 728                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 729                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 730                 if (!isDirect)
 731                     use(argEdge);
 732                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 733             }
 734 
 735             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 736                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 737         } else {
 738             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), m_jit.calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));
 739 
 740             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 741                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 742                 JSValueOperand arg(this, argEdge);
 743                 GPRReg argTagGPR = arg.tagGPR();
 744                 GPRReg argPayloadGPR = arg.payloadGPR();
 745                 use(argEdge);
 746 
 747                 m_jit.store32(argTagGPR, m_jit.calleeArgumentTagSlot(i));
 748                 m_jit.store32(argPayloadGPR, m_jit.calleeArgumentPayloadSlot(i));
 749             }
 750 
 751             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 752                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 753         }
 754     }
 755 
 756     if (!isTail || isVarargs || isForwardVarargs) {
 757         JSValueOperand callee(this, calleeEdge);
 758         calleeTagGPR = callee.tagGPR();
 759         calleePayloadGPR = callee.payloadGPR();
 760         use(calleeEdge);
 761         m_jit.store32(calleePayloadGPR, m_jit.calleeFramePayloadSlot(CallFrameSlot::callee));
 762         m_jit.store32(calleeTagGPR, m_jit.calleeFrameTagSlot(CallFrameSlot::callee));
 763 
 764         if (!isTail)
 765             flushRegisters();
 766     }
 767 
 768     JITCompiler::DataLabelPtr targetToCheck;
 769     JITCompiler::JumpList slowPath;
 770 
 771     CodeOrigin staticOrigin = node-&gt;origin.semantic;
 772     InlineCallFrame* staticInlineCallFrame = staticOrigin.inlineCallFrame();
 773     ASSERT(!isTail || !staticInlineCallFrame || !staticInlineCallFrame-&gt;getCallerSkippingTailCalls());
 774     ASSERT(!isEmulatedTail || (staticInlineCallFrame &amp;&amp; staticInlineCallFrame-&gt;getCallerSkippingTailCalls()));
 775     CodeOrigin dynamicOrigin =
 776         isEmulatedTail ? *staticInlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;
 777     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 778 
 779     CallLinkInfo* info = m_jit.codeBlock()-&gt;addCallLinkInfo();
 780     info-&gt;setUpCall(callType, node-&gt;origin.semantic, calleePayloadGPR);
 781 
 782     auto setResultAndResetStack = [&amp;] () {
 783         JSValueRegsFlushedCallResult result(this);
 784         JSValueRegs resultRegs = result.regs();
 785 
 786         m_jit.setupResults(resultRegs);
 787 
 788         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 789         // After the calls are done, we need to reestablish our stack
 790         // pointer. We rely on this for varargs calls, calls with arity
 791         // mismatch (the callframe is slided) and tail calls.
 792         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 793     };
 794 
 795     if (node-&gt;op() == CallEval) {
 796         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 797         // which we have created a prototypical eval call frame. This means that we have to
 798         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 799         // register file to ourselves.
 800 
 801         m_jit.emitStoreCallSiteIndex(callSite);
 802         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 803         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 804 
 805         // Now we need to make room for:
 806         // - The caller frame and PC of a call to operationCallEval.
 807         // - Potentially two arguments on the stack.
 808         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;
 809         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 810         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 811         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT0);
 812         prepareForExternalCall();
 813         m_jit.appendCall(operationCallEval);
 814         m_jit.exceptionCheck();
 815         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
 816 
 817         // This is the part where we meant to make a normal call. Oops.
 818         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 819         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
 820         m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
 821         m_jit.emitDumbVirtualCall(vm(), globalObject, info);
 822 
 823         done.link(&amp;m_jit);
 824         setResultAndResetStack();
 825         return;
 826     }
 827 
 828     if (isDirect) {
 829         info-&gt;setExecutableDuringCompilation(executable);
 830         info-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);
 831 
 832         if (isTail) {
 833             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 834 
 835             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 836             JITCompiler::Label mainPath = m_jit.label();
 837 
 838             m_jit.emitStoreCallSiteIndex(callSite);
 839 
 840             info-&gt;setFrameShuffleData(shuffleData);
 841             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 842 
 843             JITCompiler::Call call = m_jit.nearTailCall();
 844 
 845             JITCompiler::Label slowPath = m_jit.label();
 846             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 847 
 848             silentSpillAllRegisters(InvalidGPRReg);
 849             callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 850             silentFillAllRegisters();
 851             m_jit.exceptionCheck();
 852             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 853 
 854             useChildren(node);
 855 
 856             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, info);
 857             return;
 858         }
 859 
 860         JITCompiler::Label mainPath = m_jit.label();
 861 
 862         m_jit.emitStoreCallSiteIndex(callSite);
 863 
 864         JITCompiler::Call call = m_jit.nearCall();
 865         JITCompiler::Jump done = m_jit.jump();
 866 
 867         JITCompiler::Label slowPath = m_jit.label();
 868         callOperation(operationLinkDirectCall, info, calleePayloadGPR);
 869         m_jit.exceptionCheck();
 870         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 871 
 872         done.link(&amp;m_jit);
 873 
 874         setResultAndResetStack();
 875 
 876         m_jit.addJSDirectCall(call, slowPath, info);
 877         return;
 878     }
 879 
 880     m_jit.emitStoreCallSiteIndex(callSite);
 881 
 882     slowPath.append(m_jit.branchIfNotCell(JSValueRegs(calleeTagGPR, calleePayloadGPR)));
 883     slowPath.append(m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleePayloadGPR, targetToCheck));
 884 
 885     if (isTail) {
 886         if (node-&gt;op() == TailCall) {
 887             info-&gt;setFrameShuffleData(shuffleData);
 888             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 889         } else {
 890             m_jit.emitRestoreCalleeSaves();
 891             m_jit.prepareForTailCallSlow();
 892         }
 893     }
 894 
 895     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 896 
 897     JITCompiler::Jump done = m_jit.jump();
 898 
 899     slowPath.link(&amp;m_jit);
 900 
 901     if (node-&gt;op() == TailCall) {
 902         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 903         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(
 904             GPRInfo::regT1, GPRInfo::regT0));
 905         callFrameShuffler.prepareForSlowPath();
 906     } else {
 907         // Callee payload needs to be in regT0, tag in regT1
 908         if (calleeTagGPR == GPRInfo::regT0) {
 909             if (calleePayloadGPR == GPRInfo::regT1)
 910                 m_jit.swap(GPRInfo::regT1, GPRInfo::regT0);
 911             else {
 912                 m_jit.move(calleeTagGPR, GPRInfo::regT1);
 913                 m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 914             }
 915         } else {
 916             m_jit.move(calleePayloadGPR, GPRInfo::regT0);
 917             m_jit.move(calleeTagGPR, GPRInfo::regT1);
 918         }
 919 
 920         if (isTail)
 921             m_jit.emitRestoreCalleeSaves();
 922     }
 923 
 924     m_jit.move(TrustedImmPtr(info), GPRInfo::regT2);
 925     m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT3);
 926     JITCompiler::Call slowCall = m_jit.nearCall();
 927 
 928     done.link(&amp;m_jit);
 929 
 930     if (isTail)
 931         m_jit.abortWithReason(JITDidReturnFromTailCall);
 932     else
 933         setResultAndResetStack();
 934 
 935     m_jit.addJSCall(fastCall, slowCall, targetToCheck, info);
 936 }
 937 
 938 template&lt;bool strict&gt;
 939 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 940 {
 941     AbstractValue&amp; value = m_state.forNode(edge);
 942     SpeculatedType type = value.m_type;
 943     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 944 
 945     m_interpreter.filter(value, SpecInt32Only);
 946     if (value.isClear()) {
 947         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 948         returnFormat = DataFormatInt32;
 949         return allocate();
 950     }
 951 
 952     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
 953     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 954 
 955     switch (info.registerFormat()) {
 956     case DataFormatNone: {
 957         if (edge-&gt;hasConstant()) {
 958             ASSERT(edge-&gt;isInt32Constant());
 959             GPRReg gpr = allocate();
 960             m_jit.move(MacroAssembler::Imm32(edge-&gt;asInt32()), gpr);
 961             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
 962             info.fillInt32(*m_stream, gpr);
 963             returnFormat = DataFormatInt32;
 964             return gpr;
 965         }
 966 
 967         DataFormat spillFormat = info.spillFormat();
 968 
 969         ASSERT_UNUSED(spillFormat, (spillFormat &amp; DataFormatJS) || spillFormat == DataFormatInt32);
 970 
 971         // If we know this was spilled as an integer we can fill without checking.
 972         if (type &amp; ~SpecInt32Only)
 973             speculationCheck(BadType, JSValueSource(JITCompiler::addressFor(virtualRegister)), edge, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 974 
 975         GPRReg gpr = allocate();
 976         m_jit.load32(JITCompiler::payloadFor(virtualRegister), gpr);
 977         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 978         info.fillInt32(*m_stream, gpr);
 979         returnFormat = DataFormatInt32;
 980         return gpr;
 981     }
 982 
 983     case DataFormatJSInt32:
 984     case DataFormatJS: {
 985         // Check the value is an integer.
 986         GPRReg tagGPR = info.tagGPR();
 987         GPRReg payloadGPR = info.payloadGPR();
 988         m_gprs.lock(tagGPR);
 989         m_gprs.lock(payloadGPR);
 990         if (type &amp; ~SpecInt32Only)
 991             speculationCheck(BadType, JSValueRegs(tagGPR, payloadGPR), edge, m_jit.branchIfNotInt32(tagGPR));
 992         m_gprs.unlock(tagGPR);
 993         m_gprs.release(tagGPR);
 994         m_gprs.release(payloadGPR);
 995         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderInteger);
 996         info.fillInt32(*m_stream, payloadGPR);
 997         // If !strict we&#39;re done, return.
 998         returnFormat = DataFormatInt32;
 999         return payloadGPR;
1000     }
1001 
1002     case DataFormatInt32: {
1003         GPRReg gpr = info.gpr();
1004         m_gprs.lock(gpr);
1005         returnFormat = DataFormatInt32;
1006         return gpr;
1007     }
1008 
1009     case DataFormatCell:
1010     case DataFormatBoolean:
1011     case DataFormatJSDouble:
1012     case DataFormatJSCell:
1013     case DataFormatJSBoolean:
1014     case DataFormatDouble:
1015     case DataFormatStorage:
1016     default:
1017         RELEASE_ASSERT_NOT_REACHED();
1018         return InvalidGPRReg;
1019     }
1020 }
1021 
1022 GPRReg SpeculativeJIT::fillSpeculateInt32(Edge edge, DataFormat&amp; returnFormat)
1023 {
1024     return fillSpeculateInt32Internal&lt;false&gt;(edge, returnFormat);
1025 }
1026 
1027 GPRReg SpeculativeJIT::fillSpeculateInt32Strict(Edge edge)
1028 {
1029     DataFormat mustBeDataFormatInt32;
1030     GPRReg result = fillSpeculateInt32Internal&lt;true&gt;(edge, mustBeDataFormatInt32);
1031     ASSERT(mustBeDataFormatInt32 == DataFormatInt32);
1032     return result;
1033 }
1034 
1035 FPRReg SpeculativeJIT::fillSpeculateDouble(Edge edge)
1036 {
1037     ASSERT(isDouble(edge.useKind()));
1038     ASSERT(edge-&gt;hasDoubleResult());
1039     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1040     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1041 
1042     if (info.registerFormat() == DataFormatNone) {
1043 
1044         if (edge-&gt;hasConstant()) {
1045             RELEASE_ASSERT(edge-&gt;isNumberConstant());
1046             FPRReg fpr = fprAllocate();
1047             m_jit.loadDouble(TrustedImmPtr(m_jit.addressOfDoubleConstant(edge.node())), fpr);
1048             m_fprs.retain(fpr, virtualRegister, SpillOrderConstant);
1049             info.fillDouble(*m_stream, fpr);
1050             return fpr;
1051         }
1052 
1053         RELEASE_ASSERT(info.spillFormat() == DataFormatDouble);
1054         FPRReg fpr = fprAllocate();
1055         m_jit.loadDouble(JITCompiler::addressFor(virtualRegister), fpr);
1056         m_fprs.retain(fpr, virtualRegister, SpillOrderSpilled);
1057         info.fillDouble(*m_stream, fpr);
1058         return fpr;
1059     }
1060 
1061     RELEASE_ASSERT(info.registerFormat() == DataFormatDouble);
1062     FPRReg fpr = info.fpr();
1063     m_fprs.lock(fpr);
1064     return fpr;
1065 }
1066 
1067 GPRReg SpeculativeJIT::fillSpeculateCell(Edge edge)
1068 {
1069     AbstractValue&amp; value = m_state.forNode(edge);
1070     SpeculatedType type = value.m_type;
1071     ASSERT((edge.useKind() != KnownCellUse &amp;&amp; edge.useKind() != KnownStringUse) || !(value.m_type &amp; ~SpecCell));
1072 
1073     m_interpreter.filter(value, SpecCell);
1074     if (value.isClear()) {
1075         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1076         return allocate();
1077     }
1078 
1079     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1080     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1081 
1082     switch (info.registerFormat()) {
1083     case DataFormatNone: {
1084         if (edge-&gt;hasConstant()) {
1085             GPRReg gpr = allocate();
1086             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1087             m_jit.move(TrustedImmPtr(edge-&gt;constant()), gpr);
1088             info.fillCell(*m_stream, gpr);
1089             return gpr;
1090         }
1091 
1092         ASSERT((info.spillFormat() &amp; DataFormatJS) || info.spillFormat() == DataFormatCell);
1093         if (type &amp; ~SpecCell) {
1094             speculationCheck(
1095                 BadType,
1096                 JSValueSource(JITCompiler::addressFor(virtualRegister)),
1097                 edge,
1098                 m_jit.branch32(
1099                     MacroAssembler::NotEqual,
1100                     JITCompiler::tagFor(virtualRegister),
1101                     TrustedImm32(JSValue::CellTag)));
1102         }
1103         GPRReg gpr = allocate();
1104         m_jit.load32(JITCompiler::payloadFor(virtualRegister), gpr);
1105         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1106         info.fillCell(*m_stream, gpr);
1107         return gpr;
1108     }
1109 
1110     case DataFormatCell: {
1111         GPRReg gpr = info.gpr();
1112         m_gprs.lock(gpr);
1113         return gpr;
1114     }
1115 
1116     case DataFormatJSCell:
1117     case DataFormatJS: {
1118         GPRReg tagGPR = info.tagGPR();
1119         GPRReg payloadGPR = info.payloadGPR();
1120         m_gprs.lock(tagGPR);
1121         m_gprs.lock(payloadGPR);
1122         if (type &amp; ~SpecCell) {
1123             speculationCheck(
1124                 BadType, JSValueRegs(tagGPR, payloadGPR), edge,
1125                 m_jit.branchIfNotCell(info.jsValueRegs()));
1126         }
1127         m_gprs.unlock(tagGPR);
1128         m_gprs.release(tagGPR);
1129         m_gprs.release(payloadGPR);
1130         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderCell);
1131         info.fillCell(*m_stream, payloadGPR);
1132         return payloadGPR;
1133     }
1134 
1135     case DataFormatJSInt32:
1136     case DataFormatInt32:
1137     case DataFormatJSDouble:
1138     case DataFormatJSBoolean:
1139     case DataFormatBoolean:
1140     case DataFormatDouble:
1141     case DataFormatStorage:
1142         RELEASE_ASSERT_NOT_REACHED();
1143 
1144     default:
1145         RELEASE_ASSERT_NOT_REACHED();
1146         return InvalidGPRReg;
1147     }
1148 }
1149 
1150 GPRReg SpeculativeJIT::fillSpeculateBoolean(Edge edge)
1151 {
1152     AbstractValue&amp; value = m_state.forNode(edge);
1153     SpeculatedType type = value.m_type;
1154     ASSERT(edge.useKind() != KnownBooleanUse || !(value.m_type &amp; ~SpecBoolean));
1155 
1156     m_interpreter.filter(value, SpecBoolean);
1157     if (value.isClear()) {
1158         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1159         return allocate();
1160     }
1161 
1162     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1163     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1164 
1165     switch (info.registerFormat()) {
1166     case DataFormatNone: {
1167         if (edge-&gt;hasConstant()) {
1168             JSValue jsValue = edge-&gt;asJSValue();
1169             GPRReg gpr = allocate();
1170             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1171             m_jit.move(MacroAssembler::TrustedImm32(jsValue.asBoolean()), gpr);
1172             info.fillBoolean(*m_stream, gpr);
1173             return gpr;
1174         }
1175 
1176         ASSERT((info.spillFormat() &amp; DataFormatJS) || info.spillFormat() == DataFormatBoolean);
1177 
1178         if (type &amp; ~SpecBoolean)
1179             speculationCheck(BadType, JSValueSource(JITCompiler::addressFor(virtualRegister)), edge, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
1180 
1181         GPRReg gpr = allocate();
1182         m_jit.load32(JITCompiler::payloadFor(virtualRegister), gpr);
1183         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1184         info.fillBoolean(*m_stream, gpr);
1185         return gpr;
1186     }
1187 
1188     case DataFormatBoolean: {
1189         GPRReg gpr = info.gpr();
1190         m_gprs.lock(gpr);
1191         return gpr;
1192     }
1193 
1194     case DataFormatJSBoolean:
1195     case DataFormatJS: {
1196         GPRReg tagGPR = info.tagGPR();
1197         GPRReg payloadGPR = info.payloadGPR();
1198         m_gprs.lock(tagGPR);
1199         m_gprs.lock(payloadGPR);
1200         if (type &amp; ~SpecBoolean)
1201             speculationCheck(BadType, JSValueRegs(tagGPR, payloadGPR), edge, m_jit.branchIfNotBoolean(tagGPR, InvalidGPRReg));
1202 
1203         m_gprs.unlock(tagGPR);
1204         m_gprs.release(tagGPR);
1205         m_gprs.release(payloadGPR);
1206         m_gprs.retain(payloadGPR, virtualRegister, SpillOrderBoolean);
1207         info.fillBoolean(*m_stream, payloadGPR);
1208         return payloadGPR;
1209     }
1210 
1211     case DataFormatJSInt32:
1212     case DataFormatInt32:
1213     case DataFormatJSDouble:
1214     case DataFormatJSCell:
1215     case DataFormatCell:
1216     case DataFormatDouble:
1217     case DataFormatStorage:
1218         RELEASE_ASSERT_NOT_REACHED();
1219 
1220     default:
1221         RELEASE_ASSERT_NOT_REACHED();
1222         return InvalidGPRReg;
1223     }
1224 }
1225 
1226 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1227 {
1228     SpeculateCellOperand op1(this, objectChild);
1229     JSValueOperand op2(this, otherChild);
1230 
1231     GPRReg op1GPR = op1.gpr();
1232     GPRReg op2GPR = op2.payloadGPR();
1233 
1234     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1235 
1236     GPRTemporary resultPayload(this, Reuse, op1);
1237     GPRReg resultPayloadGPR = resultPayload.gpr();
1238 
1239     MacroAssembler::Jump op2CellJump = m_jit.branchIfCell(op2.jsValueRegs());
1240 
1241     m_jit.move(TrustedImm32(0), resultPayloadGPR);
1242     MacroAssembler::Jump op2NotCellJump = m_jit.jump();
1243 
1244     // At this point we know that we can perform a straight-forward equality comparison on pointer
1245     // values because we are doing strict equality.
1246     op2CellJump.link(&amp;m_jit);
1247     m_jit.compare32(MacroAssembler::Equal, op1GPR, op2GPR, resultPayloadGPR);
1248 
1249     op2NotCellJump.link(&amp;m_jit);
1250     booleanResult(resultPayloadGPR, m_currentNode);
1251 }
1252 
1253 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1254 {
1255     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1256     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1257 
1258     SpeculateCellOperand op1(this, objectChild);
1259     JSValueOperand op2(this, otherChild);
1260 
1261     GPRReg op1GPR = op1.gpr();
1262     GPRReg op2GPR = op2.payloadGPR();
1263 
1264     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1265 
1266     branch32(MacroAssembler::NotEqual, op2.tagGPR(), TrustedImm32(JSValue::CellTag), notTaken);
1267 
1268     if (taken == nextBlock()) {
1269         branch32(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1270         jump(taken);
1271     } else {
1272         branch32(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1273         jump(notTaken);
1274     }
1275 }
1276 
1277 void SpeculativeJIT::compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild)
1278 {
1279     SpeculateCellOperand op1(this, leftChild);
1280     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1281     GPRTemporary result(this);
1282 
1283     GPRReg op1GPR = op1.gpr();
1284     GPRReg op2TagGPR = op2.tagGPR();
1285     GPRReg op2PayloadGPR = op2.payloadGPR();
1286     GPRReg resultGPR = result.gpr();
1287 
1288     bool masqueradesAsUndefinedWatchpointValid =
1289         masqueradesAsUndefinedWatchpointIsStillValid();
1290 
1291     if (masqueradesAsUndefinedWatchpointValid) {
1292         DFG_TYPE_CHECK(
1293             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1294     } else {
1295         DFG_TYPE_CHECK(
1296             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1297         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1298             m_jit.branchTest8(
1299                 MacroAssembler::NonZero,
1300                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1301                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1302     }
1303 
1304 
1305     // It seems that most of the time when programs do a == b where b may be either null/undefined
1306     // or an object, b is usually an object. Balance the branches to make that case fast.
1307     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(op2.jsValueRegs());
1308 
1309     // We know that within this branch, rightChild must be a cell.
1310     if (masqueradesAsUndefinedWatchpointValid) {
1311         DFG_TYPE_CHECK(
1312             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject, m_jit.branchIfNotObject(op2PayloadGPR));
1313     } else {
1314         DFG_TYPE_CHECK(
1315             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject, m_jit.branchIfNotObject(op2PayloadGPR));
1316         speculationCheck(BadType, JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild,
1317             m_jit.branchTest8(
1318                 MacroAssembler::NonZero,
1319                 MacroAssembler::Address(op2PayloadGPR, JSCell::typeInfoFlagsOffset()),
1320                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1321     }
1322 
1323     // At this point we know that we can perform a straight-forward equality comparison on pointer
1324     // values because both left and right are pointers to objects that have no special equality
1325     // protocols.
1326     MacroAssembler::Jump falseCase = m_jit.branchPtr(MacroAssembler::NotEqual, op1GPR, op2PayloadGPR);
1327     MacroAssembler::Jump trueCase = m_jit.jump();
1328 
1329     rightNotCell.link(&amp;m_jit);
1330 
1331     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1332     // prove that it is either null or undefined.
1333     if (needsTypeCheck(rightChild, SpecCell | SpecOther)) {
1334         m_jit.or32(TrustedImm32(1), op2TagGPR, resultGPR);
1335 
1336         typeCheck(
1337             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, SpecCell | SpecOther,
1338             m_jit.branch32(
1339                 MacroAssembler::NotEqual, resultGPR,
1340                 MacroAssembler::TrustedImm32(JSValue::NullTag)));
1341     }
1342 
1343     falseCase.link(&amp;m_jit);
1344     m_jit.move(TrustedImm32(0), resultGPR);
1345     MacroAssembler::Jump done = m_jit.jump();
1346     trueCase.link(&amp;m_jit);
1347     m_jit.move(TrustedImm32(1), resultGPR);
1348     done.link(&amp;m_jit);
1349 
1350     booleanResult(resultGPR, m_currentNode);
1351 }
1352 
1353 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1354 {
1355     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1356     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1357 
1358     SpeculateCellOperand op1(this, leftChild);
1359     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1360     GPRTemporary result(this);
1361 
1362     GPRReg op1GPR = op1.gpr();
1363     GPRReg op2TagGPR = op2.tagGPR();
1364     GPRReg op2PayloadGPR = op2.payloadGPR();
1365     GPRReg resultGPR = result.gpr();
1366 
1367     bool masqueradesAsUndefinedWatchpointValid =
1368         masqueradesAsUndefinedWatchpointIsStillValid();
1369 
1370     if (masqueradesAsUndefinedWatchpointValid) {
1371         DFG_TYPE_CHECK(
1372             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1373     } else {
1374         DFG_TYPE_CHECK(
1375             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1376         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1377             m_jit.branchTest8(
1378                 MacroAssembler::NonZero,
1379                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1380                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1381     }
1382 
1383     // It seems that most of the time when programs do a == b where b may be either null/undefined
1384     // or an object, b is usually an object. Balance the branches to make that case fast.
1385     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(op2.jsValueRegs());
1386 
1387     // We know that within this branch, rightChild must be a cell.
1388     if (masqueradesAsUndefinedWatchpointValid) {
1389         DFG_TYPE_CHECK(
1390             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject,
1391             m_jit.branchIfNotObject(op2PayloadGPR));
1392     } else {
1393         DFG_TYPE_CHECK(
1394             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, (~SpecCell) | SpecObject,
1395             m_jit.branchIfNotObject(op2PayloadGPR));
1396         speculationCheck(BadType, JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild,
1397             m_jit.branchTest8(
1398                 MacroAssembler::NonZero,
1399                 MacroAssembler::Address(op2PayloadGPR, JSCell::typeInfoFlagsOffset()),
1400                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1401     }
1402 
1403     // At this point we know that we can perform a straight-forward equality comparison on pointer
1404     // values because both left and right are pointers to objects that have no special equality
1405     // protocols.
1406     branch32(MacroAssembler::Equal, op1GPR, op2PayloadGPR, taken);
1407 
1408     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1409     // prove that it is either null or undefined.
1410     if (!needsTypeCheck(rightChild, SpecCell | SpecOther))
1411         rightNotCell.link(&amp;m_jit);
1412     else {
1413         jump(notTaken, ForceJump);
1414 
1415         rightNotCell.link(&amp;m_jit);
1416         m_jit.or32(TrustedImm32(1), op2TagGPR, resultGPR);
1417 
1418         typeCheck(
1419             JSValueRegs(op2TagGPR, op2PayloadGPR), rightChild, SpecCell | SpecOther,
1420             m_jit.branch32(
1421                 MacroAssembler::NotEqual, resultGPR,
1422                 MacroAssembler::TrustedImm32(JSValue::NullTag)));
1423     }
1424 
1425     jump(notTaken);
1426 }
1427 
1428 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1429 {
1430     SpeculateCellOperand symbol(this, symbolEdge);
1431     JSValueOperand untyped(this, untypedEdge);
1432 
1433     GPRReg symbolGPR = symbol.gpr();
1434     GPRReg untypedGPR = untyped.payloadGPR();
1435 
1436     speculateSymbol(symbolEdge, symbolGPR);
1437 
1438     GPRTemporary resultPayload(this, Reuse, symbol);
1439     GPRReg resultPayloadGPR = resultPayload.gpr();
1440 
1441     MacroAssembler::Jump untypedCellJump = m_jit.branchIfCell(untyped.jsValueRegs());
1442 
1443     m_jit.move(TrustedImm32(0), resultPayloadGPR);
1444     MacroAssembler::Jump untypedNotCellJump = m_jit.jump();
1445 
1446     // At this point we know that we can perform a straight-forward equality comparison on pointer
1447     // values because we are doing strict equality.
1448     untypedCellJump.link(&amp;m_jit);
1449     m_jit.compare32(MacroAssembler::Equal, symbolGPR, untypedGPR, resultPayloadGPR);
1450 
1451     untypedNotCellJump.link(&amp;m_jit);
1452     booleanResult(resultPayloadGPR, node);
1453 }
1454 
1455 void SpeculativeJIT::compileObjectOrOtherLogicalNot(Edge nodeUse)
1456 {
1457     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1458     GPRTemporary resultPayload(this);
1459     GPRReg valueTagGPR = value.tagGPR();
1460     GPRReg valuePayloadGPR = value.payloadGPR();
1461     GPRReg resultPayloadGPR = resultPayload.gpr();
1462     GPRTemporary structure;
1463     GPRReg structureGPR = InvalidGPRReg;
1464 
1465     bool masqueradesAsUndefinedWatchpointValid =
1466         masqueradesAsUndefinedWatchpointIsStillValid();
1467 
1468     if (!masqueradesAsUndefinedWatchpointValid) {
1469         // The masquerades as undefined case will use the structure register, so allocate it here.
1470         // Do this at the top of the function to avoid branching around a register allocation.
1471         GPRTemporary realStructure(this);
1472         structure.adopt(realStructure);
1473         structureGPR = structure.gpr();
1474     }
1475 
1476     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(value.jsValueRegs());
1477     if (masqueradesAsUndefinedWatchpointValid) {
1478         DFG_TYPE_CHECK(
1479             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1480             m_jit.branchIfNotObject(valuePayloadGPR));
1481     } else {
1482         DFG_TYPE_CHECK(
1483             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1484             m_jit.branchIfNotObject(valuePayloadGPR));
1485 
1486         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1487             m_jit.branchTest8(
1488                 MacroAssembler::Zero,
1489                 MacroAssembler::Address(valuePayloadGPR, JSCell::typeInfoFlagsOffset()),
1490                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1491 
1492         m_jit.loadPtr(MacroAssembler::Address(valuePayloadGPR, JSCell::structureIDOffset()), structureGPR);
1493         speculationCheck(BadType, JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse,
1494             m_jit.branchPtr(
1495                 MacroAssembler::Equal,
1496                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1497                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1498 
1499         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1500     }
1501     m_jit.move(TrustedImm32(0), resultPayloadGPR);
1502     MacroAssembler::Jump done = m_jit.jump();
1503 
1504     notCell.link(&amp;m_jit);
1505 
1506     COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
1507     if (needsTypeCheck(nodeUse, SpecCell | SpecOther)) {
1508         m_jit.or32(TrustedImm32(1), valueTagGPR, resultPayloadGPR);
1509         typeCheck(
1510             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, SpecCell | SpecOther,
1511             m_jit.branch32(
1512                 MacroAssembler::NotEqual,
1513                 resultPayloadGPR,
1514                 TrustedImm32(JSValue::NullTag)));
1515     }
1516     m_jit.move(TrustedImm32(1), resultPayloadGPR);
1517 
1518     done.link(&amp;m_jit);
1519 
1520     booleanResult(resultPayloadGPR, m_currentNode);
1521 }
1522 
1523 void SpeculativeJIT::compileLogicalNot(Node* node)
1524 {
1525     switch (node-&gt;child1().useKind()) {
1526     case BooleanUse:
1527     case KnownBooleanUse: {
1528         SpeculateBooleanOperand value(this, node-&gt;child1());
1529         GPRTemporary result(this, Reuse, value);
1530         m_jit.xor32(TrustedImm32(1), value.gpr(), result.gpr());
1531         booleanResult(result.gpr(), node);
1532         return;
1533     }
1534 
1535     case ObjectOrOtherUse: {
1536         compileObjectOrOtherLogicalNot(node-&gt;child1());
1537         return;
1538     }
1539 
1540     case Int32Use: {
1541         SpeculateInt32Operand value(this, node-&gt;child1());
1542         GPRTemporary resultPayload(this, Reuse, value);
1543         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), resultPayload.gpr());
1544         booleanResult(resultPayload.gpr(), node);
1545         return;
1546     }
1547 
1548     case DoubleRepUse: {
1549         SpeculateDoubleOperand value(this, node-&gt;child1());
1550         FPRTemporary scratch(this);
1551         GPRTemporary resultPayload(this);
1552         m_jit.move(TrustedImm32(0), resultPayload.gpr());
1553         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1554         m_jit.move(TrustedImm32(1), resultPayload.gpr());
1555         nonZero.link(&amp;m_jit);
1556         booleanResult(resultPayload.gpr(), node);
1557         return;
1558     }
1559 
1560     case UntypedUse: {
1561         JSValueOperand arg1(this, node-&gt;child1());
1562         GPRTemporary result(this);
1563         GPRTemporary temp(this);
1564         FPRTemporary valueFPR(this);
1565         FPRTemporary tempFPR(this);
1566 
1567         GPRReg resultGPR = result.gpr();
1568 
1569         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1570         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1571         bool negateResult = true;
1572         m_jit.emitConvertValueToBoolean(vm(), arg1.jsValueRegs(), resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);
1573         booleanResult(resultGPR, node);
1574         return;
1575     }
1576     case StringUse:
1577         return compileStringZeroLength(node);
1578 
1579     case StringOrOtherUse:
1580         return compileLogicalNotStringOrOther(node);
1581 
1582     default:
1583         RELEASE_ASSERT_NOT_REACHED();
1584         break;
1585     }
1586 }
1587 
1588 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1589 {
1590     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1591     GPRTemporary scratch(this);
1592     GPRReg valueTagGPR = value.tagGPR();
1593     GPRReg valuePayloadGPR = value.payloadGPR();
1594     GPRReg scratchGPR = scratch.gpr();
1595 
1596     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(value.jsValueRegs());
1597     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
1598         DFG_TYPE_CHECK(
1599             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1600             m_jit.branchIfNotObject(valuePayloadGPR));
1601     } else {
1602         DFG_TYPE_CHECK(
1603             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, (~SpecCell) | SpecObject,
1604             m_jit.branchIfNotObject(valuePayloadGPR));
1605 
1606         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1607             JITCompiler::Zero,
1608             MacroAssembler::Address(valuePayloadGPR, JSCell::typeInfoFlagsOffset()),
1609             TrustedImm32(MasqueradesAsUndefined));
1610 
1611         m_jit.loadPtr(MacroAssembler::Address(valuePayloadGPR, JSCell::structureIDOffset()), scratchGPR);
1612         speculationCheck(BadType, JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse,
1613             m_jit.branchPtr(
1614                 MacroAssembler::Equal,
1615                 MacroAssembler::Address(scratchGPR, Structure::globalObjectOffset()),
1616                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1617 
1618         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1619     }
1620     jump(taken, ForceJump);
1621 
1622     notCell.link(&amp;m_jit);
1623 
1624     COMPILE_ASSERT((JSValue::UndefinedTag | 1) == JSValue::NullTag, UndefinedTag_OR_1_EQUALS_NullTag);
1625     if (needsTypeCheck(nodeUse, SpecCell | SpecOther)) {
1626         m_jit.or32(TrustedImm32(1), valueTagGPR, scratchGPR);
1627         typeCheck(
1628             JSValueRegs(valueTagGPR, valuePayloadGPR), nodeUse, SpecCell | SpecOther,
1629             m_jit.branch32(MacroAssembler::NotEqual, scratchGPR, TrustedImm32(JSValue::NullTag)));
1630     }
1631 
1632     jump(notTaken);
1633 
1634     noResult(m_currentNode);
1635 }
1636 
1637 void SpeculativeJIT::emitBranch(Node* node)
1638 {
1639     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1640     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1641 
1642     switch (node-&gt;child1().useKind()) {
1643     case BooleanUse:
1644     case KnownBooleanUse: {
1645         SpeculateBooleanOperand value(this, node-&gt;child1());
1646         MacroAssembler::ResultCondition condition = MacroAssembler::NonZero;
1647 
1648         if (taken == nextBlock()) {
1649             condition = MacroAssembler::Zero;
1650             BasicBlock* tmp = taken;
1651             taken = notTaken;
1652             notTaken = tmp;
1653         }
1654 
1655         branchTest32(condition, value.gpr(), TrustedImm32(1), taken);
1656         jump(notTaken);
1657 
1658         noResult(node);
1659         return;
1660     }
1661 
1662     case ObjectOrOtherUse: {
1663         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1664         return;
1665     }
1666 
1667     case StringUse: {
1668         emitStringBranch(node-&gt;child1(), taken, notTaken);
1669         return;
1670     }
1671 
1672     case StringOrOtherUse: {
1673         emitStringOrOtherBranch(node-&gt;child1(), taken, notTaken);
1674         return;
1675     }
1676 
1677     case DoubleRepUse:
1678     case Int32Use: {
1679         if (node-&gt;child1().useKind() == Int32Use) {
1680             bool invert = false;
1681 
1682             if (taken == nextBlock()) {
1683                 invert = true;
1684                 BasicBlock* tmp = taken;
1685                 taken = notTaken;
1686                 notTaken = tmp;
1687             }
1688 
1689             SpeculateInt32Operand value(this, node-&gt;child1());
1690             branchTest32(invert ? MacroAssembler::Zero : MacroAssembler::NonZero, value.gpr(), taken);
1691         } else {
1692             SpeculateDoubleOperand value(this, node-&gt;child1());
1693             FPRTemporary scratch(this);
1694             branchDoubleNonZero(value.fpr(), scratch.fpr(), taken);
1695         }
1696 
1697         jump(notTaken);
1698 
1699         noResult(node);
1700         return;
1701     }
1702 
1703     case UntypedUse: {
1704         JSValueOperand value(this, node-&gt;child1());
1705         FPRTemporary valueFPR(this);
1706         FPRTemporary tempFPR(this);
1707         GPRTemporary result(this);
1708         GPRTemporary temp(this);
1709 
1710         JSValueRegs valueRegs = value.jsValueRegs();
1711         GPRReg resultGPR = result.gpr();
1712 
1713         use(node-&gt;child1());
1714 
1715         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1716         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1717         auto falsey = m_jit.branchIfFalsey(vm(), valueRegs, resultGPR, temp.gpr(), valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject);
1718         addBranch(falsey, notTaken);
1719         jump(taken, ForceJump);
1720 
1721         noResult(node, UseChildrenCalledExplicitly);
1722         return;
1723     }
1724 
1725     default:
1726         RELEASE_ASSERT_NOT_REACHED();
1727         break;
1728     }
1729 }
1730 
1731 template&lt;typename BaseOperandType, typename PropertyOperandType, typename ValueOperandType, typename TagType&gt;
1732 void SpeculativeJIT::compileContiguousPutByVal(Node* node, BaseOperandType&amp; base, PropertyOperandType&amp; property, ValueOperandType&amp; value, GPRReg valuePayloadReg, TagType valueTag)
1733 {
1734     Edge child4 = m_jit.graph().varArgChild(node, 3);
1735 
1736     ArrayMode arrayMode = node-&gt;arrayMode();
1737 
1738     GPRReg baseReg = base.gpr();
1739     GPRReg propertyReg = property.gpr();
1740 
1741     StorageOperand storage(this, child4);
1742     GPRReg storageReg = storage.gpr();
1743 
1744     if (node-&gt;op() == PutByValAlias) {
1745         // Store the value to the array.
1746         GPRReg propertyReg = property.gpr();
1747         m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1748         m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1749 
1750         noResult(node);
1751         return;
1752     }
1753 
1754     MacroAssembler::Jump slowCase;
1755 
1756     if (arrayMode.isInBounds()) {
1757         speculationCheck(
1758             OutOfBounds, JSValueRegs(), 0,
1759             m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
1760     } else {
1761         MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1762 
1763         slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
1764 
1765         if (!arrayMode.isOutOfBounds())
1766             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
1767 
1768         m_jit.add32(TrustedImm32(1), propertyReg);
1769         m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
1770         m_jit.sub32(TrustedImm32(1), propertyReg);
1771 
1772         inBounds.link(&amp;m_jit);
1773     }
1774 
1775     m_jit.store32(valueTag, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
1776     m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
1777 
1778     base.use();
1779     property.use();
1780     value.use();
1781     storage.use();
1782 
1783     if (arrayMode.isOutOfBounds()) {
1784         if (node-&gt;op() == PutByValDirect) {
1785             addSlowPathGenerator(slowPathCall(
1786                 slowCase, this,
1787                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
1788                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1789         } else {
1790             addSlowPathGenerator(slowPathCall(
1791                 slowCase, this,
1792                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
1793                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));
1794         }
1795     }
1796 
1797     noResult(node, UseChildrenCalledExplicitly);
1798 }
1799 
1800 void SpeculativeJIT::compile(Node* node)
1801 {
1802     NodeType op = node-&gt;op();
1803 
1804 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1805     m_jit.clearRegisterAllocationOffsets();
1806 #endif
1807 
1808     switch (op) {
1809     case JSConstant:
1810     case DoubleConstant:
1811     case PhantomDirectArguments:
1812     case PhantomClonedArguments:
1813         initConstantInfo(node);
1814         break;
1815 
1816     case LazyJSConstant:
1817         compileLazyJSConstant(node);
1818         break;
1819 
1820     case Identity: {
1821         compileIdentity(node);
1822         break;
1823     }
1824 
1825     case Inc:
1826     case Dec:
1827         compileIncOrDec(node);
1828         break;
1829 
1830     case GetLocal: {
1831         AbstractValue&amp; value = m_state.operand(node-&gt;operand());
1832 
1833         // If the CFA is tracking this variable and it found that the variable
1834         // cannot have been assigned, then don&#39;t attempt to proceed.
1835         if (value.isClear()) {
1836             m_compileOkay = false;
1837             break;
1838         }
1839 
1840         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1841         case FlushedDouble: {
1842             FPRTemporary result(this);
1843             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1844             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1845             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1846             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1847             break;
1848         }
1849 
1850         case FlushedInt32: {
1851             GPRTemporary result(this);
1852             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1853 
1854             // Like int32Result, but don&#39;t useChildren - our children are phi nodes,
1855             // and don&#39;t represent values within this dataflow with virtual registers.
1856             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1857             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderInteger);
1858             generationInfoFromVirtualRegister(virtualRegister).initInt32(node, node-&gt;refCount(), result.gpr());
1859             break;
1860         }
1861 
1862         case FlushedCell: {
1863             GPRTemporary result(this);
1864             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1865 
1866             // Like cellResult, but don&#39;t useChildren - our children are phi nodes,
1867             // and don&#39;t represent values within this dataflow with virtual registers.
1868             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1869             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderCell);
1870             generationInfoFromVirtualRegister(virtualRegister).initCell(node, node-&gt;refCount(), result.gpr());
1871             break;
1872         }
1873 
1874         case FlushedBoolean: {
1875             GPRTemporary result(this);
1876             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1877 
1878             // Like booleanResult, but don&#39;t useChildren - our children are phi nodes,
1879             // and don&#39;t represent values within this dataflow with virtual registers.
1880             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1881             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderBoolean);
1882             generationInfoFromVirtualRegister(virtualRegister).initBoolean(node, node-&gt;refCount(), result.gpr());
1883             break;
1884         }
1885 
1886         case FlushedJSValue: {
1887             GPRTemporary result(this);
1888             GPRTemporary tag(this);
1889             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1890             m_jit.load32(JITCompiler::tagFor(node-&gt;machineLocal()), tag.gpr());
1891 
1892             // Like jsValueResult, but don&#39;t useChildren - our children are phi nodes,
1893             // and don&#39;t represent values within this dataflow with virtual registers.
1894             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1895             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1896             m_gprs.retain(tag.gpr(), virtualRegister, SpillOrderJS);
1897 
1898             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), tag.gpr(), result.gpr(), DataFormatJS);
1899             break;
1900         }
1901 
1902         default:
1903             RELEASE_ASSERT_NOT_REACHED();
1904         }
1905         break;
1906     }
1907 
1908     case MovHint: {
1909         compileMovHint(m_currentNode);
1910         noResult(node);
1911         break;
1912     }
1913 
1914     case ZombieHint: {
1915         recordSetLocal(m_currentNode-&gt;unlinkedOperand(), VirtualRegister(), DataFormatDead);
1916         noResult(node);
1917         break;
1918     }
1919 
1920     case ExitOK: {
1921         noResult(node);
1922         break;
1923     }
1924 
1925     case SetLocal: {
1926         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1927         case FlushedDouble: {
1928             SpeculateDoubleOperand value(this, node-&gt;child1());
1929             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
1930             noResult(node);
1931             // Indicate that it&#39;s no longer necessary to retrieve the value of
1932             // this bytecode variable from registers or other locations in the stack,
1933             // but that it is stored as a double.
1934             recordSetLocal(DataFormatDouble);
1935             break;
1936         }
1937 
1938         case FlushedInt32: {
1939             SpeculateInt32Operand value(this, node-&gt;child1());
1940             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1941             noResult(node);
1942             recordSetLocal(DataFormatInt32);
1943             break;
1944         }
1945 
1946         case FlushedCell: {
1947             SpeculateCellOperand cell(this, node-&gt;child1());
1948             GPRReg cellGPR = cell.gpr();
1949             m_jit.storePtr(cellGPR, JITCompiler::payloadFor(node-&gt;machineLocal()));
1950             noResult(node);
1951             recordSetLocal(DataFormatCell);
1952             break;
1953         }
1954 
1955         case FlushedBoolean: {
1956             SpeculateBooleanOperand value(this, node-&gt;child1());
1957             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1958             noResult(node);
1959             recordSetLocal(DataFormatBoolean);
1960             break;
1961         }
1962 
1963         case FlushedJSValue: {
1964             JSValueOperand value(this, node-&gt;child1());
1965             m_jit.store32(value.payloadGPR(), JITCompiler::payloadFor(node-&gt;machineLocal()));
1966             m_jit.store32(value.tagGPR(), JITCompiler::tagFor(node-&gt;machineLocal()));
1967             noResult(node);
1968             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1969             break;
1970         }
1971 
1972         default:
1973             RELEASE_ASSERT_NOT_REACHED();
1974             break;
1975         }
1976         break;
1977     }
1978 
1979     case SetArgumentDefinitely:
1980     case SetArgumentMaybe:
1981         // This is a no-op; it just marks the fact that the argument is being used.
1982         // But it may be profitable to use this as a hook to run speculation checks
1983         // on arguments, thereby allowing us to trivially eliminate such checks if
1984         // the argument is not used.
1985         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
1986         break;
1987 
1988     case ValueBitOr:
1989     case ValueBitAnd:
1990     case ValueBitXor:
1991         compileValueBitwiseOp(node);
1992         break;
1993 
1994     case ArithBitAnd:
1995     case ArithBitOr:
1996     case ArithBitXor:
1997         compileBitwiseOp(node);
1998         break;
1999 
2000     case ValueBitNot:
2001         compileValueBitNot(node);
2002         break;
2003 
2004     case ArithBitNot:
2005         compileBitwiseNot(node);
2006         break;
2007 
2008     case ValueBitLShift:
2009         compileValueLShiftOp(node);
2010         break;
2011 
2012     case ValueBitRShift:
2013         compileValueBitRShift(node);
2014         break;
2015 
2016     case ArithBitRShift:
2017     case ArithBitLShift:
2018     case BitURShift:
2019         compileShiftOp(node);
2020         break;
2021 
2022     case UInt32ToNumber: {
2023         compileUInt32ToNumber(node);
2024         break;
2025     }
2026 
2027     case DoubleAsInt32: {
2028         compileDoubleAsInt32(node);
2029         break;
2030     }
2031 
2032     case ValueToInt32: {
2033         compileValueToInt32(node);
2034         break;
2035     }
2036 
2037     case DoubleRep: {
2038         compileDoubleRep(node);
2039         break;
2040     }
2041 
2042     case ValueRep: {
2043         compileValueRep(node);
2044         break;
2045     }
2046 
2047     case ValueNegate:
2048         compileValueNegate(node);
2049         break;
2050 
2051     case ValueAdd:
2052         compileValueAdd(node);
2053         break;
2054 
2055     case ValueSub:
2056         compileValueSub(node);
2057         break;
2058 
2059     case StrCat: {
2060         compileStrCat(node);
2061         break;
2062     }
2063 
2064     case ArithAdd:
2065         compileArithAdd(node);
2066         break;
2067 
2068     case ArithClz32:
2069         compileArithClz32(node);
2070         break;
2071 
2072     case MakeRope:
2073         compileMakeRope(node);
2074         break;
2075 
2076     case ArithSub:
2077         compileArithSub(node);
2078         break;
2079 
2080     case ArithNegate:
2081         compileArithNegate(node);
2082         break;
2083 
2084     case ArithMul:
2085         compileArithMul(node);
2086         break;
2087 
2088     case ValueMul:
2089         compileValueMul(node);
2090         break;
2091 
2092     case ValueDiv: {
2093         compileValueDiv(node);
2094         break;
2095     }
2096 
2097     case ArithDiv: {
2098         compileArithDiv(node);
2099         break;
2100     }
2101 
2102     case ValueMod: {
2103         compileValueMod(node);
2104         break;
2105     }
2106 
2107     case ArithMod: {
2108         compileArithMod(node);
2109         break;
2110     }
2111 
2112     case ValuePow: {
2113         compileValuePow(node);
2114         break;
2115     }
2116 
2117     case ArithPow: {
2118         compileArithPow(node);
2119         break;
2120     }
2121 
2122     case ArithAbs:
2123         compileArithAbs(node);
2124         break;
2125 
2126     case ArithMin:
2127     case ArithMax: {
2128         compileArithMinMax(node);
2129         break;
2130     }
2131 
2132     case ArithSqrt:
2133         compileArithSqrt(node);
2134         break;
2135 
2136     case ArithFRound:
2137         compileArithFRound(node);
2138         break;
2139 
2140     case ArithRandom:
2141         compileArithRandom(node);
2142         break;
2143 
2144     case ArithRound:
2145     case ArithFloor:
2146     case ArithCeil:
2147     case ArithTrunc:
2148         compileArithRounding(node);
2149         break;
2150 
2151     case ArithUnary:
2152         compileArithUnary(node);
2153         break;
2154 
2155     case LogicalNot:
2156         compileLogicalNot(node);
2157         break;
2158 
2159     case CompareLess:
2160         if (compare(node, JITCompiler::LessThan, JITCompiler::DoubleLessThan, operationCompareLess))
2161             return;
2162         break;
2163 
2164     case CompareLessEq:
2165         if (compare(node, JITCompiler::LessThanOrEqual, JITCompiler::DoubleLessThanOrEqual, operationCompareLessEq))
2166             return;
2167         break;
2168 
2169     case CompareGreater:
2170         if (compare(node, JITCompiler::GreaterThan, JITCompiler::DoubleGreaterThan, operationCompareGreater))
2171             return;
2172         break;
2173 
2174     case CompareGreaterEq:
2175         if (compare(node, JITCompiler::GreaterThanOrEqual, JITCompiler::DoubleGreaterThanOrEqual, operationCompareGreaterEq))
2176             return;
2177         break;
2178 
2179     case CompareBelow:
2180         compileCompareUnsigned(node, JITCompiler::Below);
2181         break;
2182 
2183     case CompareBelowEq:
2184         compileCompareUnsigned(node, JITCompiler::BelowOrEqual);
2185         break;
2186 
2187     case CompareEq:
2188         if (compare(node, JITCompiler::Equal, JITCompiler::DoubleEqual, operationCompareEq))
2189             return;
2190         break;
2191 
2192     case CompareStrictEq:
2193         if (compileStrictEq(node))
2194             return;
2195         break;
2196 
2197     case CompareEqPtr:
2198         compileCompareEqPtr(node);
2199         break;
2200 
2201     case SameValue:
2202         compileSameValue(node);
2203         break;
2204 
2205     case StringCharCodeAt: {
2206         compileGetCharCodeAt(node);
2207         break;
2208     }
2209 
2210     case StringCharAt: {
2211         // Relies on StringCharAt node having same basic layout as GetByVal
2212         compileGetByValOnString(node);
2213         break;
2214     }
2215 
2216     case StringFromCharCode: {
2217         compileFromCharCode(node);
2218         break;
2219     }
2220 
2221     case CheckNeutered: {
2222         compileCheckNeutered(node);
2223         break;
2224     }
2225 
2226     case CheckArray: {
2227         checkArray(node);
2228         break;
2229     }
2230 
2231     case Arrayify:
2232     case ArrayifyToStructure: {
2233         arrayify(node);
2234         break;
2235     }
2236 
2237     case GetByVal: {
2238         switch (node-&gt;arrayMode().type()) {
2239         case Array::SelectUsingPredictions:
2240         case Array::ForceExit:
2241             RELEASE_ASSERT_NOT_REACHED();
2242 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
2243             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
2244 #endif
2245             break;
2246         case Array::Undecided: {
2247             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2248             GPRTemporary resultTag(this, Reuse, index);
2249             GPRTemporary resultPayload(this);
2250 
2251             GPRReg indexGPR = index.gpr();
2252             GPRReg resultTagGPR = resultTag.gpr();
2253             GPRReg resultPayloadGPR = resultPayload.gpr();
2254 
2255             speculationCheck(OutOfBounds, JSValueRegs(), node,
2256                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2257 
2258             use(m_graph.varArgChild(node, 0));
2259             index.use();
2260 
2261             m_jit.move(MacroAssembler::TrustedImm32(JSValue::UndefinedTag), resultTagGPR);
2262             m_jit.move(MacroAssembler::TrustedImm32(0), resultPayloadGPR);
2263             jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
2264             break;
2265         }
2266         case Array::Generic: {
2267             if (m_graph.m_slowGetByVal.contains(node)) {
2268                 if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {
2269                     if (m_graph.varArgChild(node, 1).useKind() == StringUse) {
2270                         compileGetByValForObjectWithString(node);
2271                         break;
2272                     }
2273 
2274                     if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {
2275                         compileGetByValForObjectWithSymbol(node);
2276                         break;
2277                     }
2278                 }
2279 
2280                 SpeculateCellOperand base(this, m_graph.varArgChild(node, 0)); // Save a register, speculate cell. We&#39;ll probably be right.
2281                 JSValueOperand property(this, m_graph.varArgChild(node, 1));
2282                 GPRReg baseGPR = base.gpr();
2283                 JSValueRegs propertyRegs = property.jsValueRegs();
2284 
2285                 flushRegisters();
2286                 JSValueRegsFlushedCallResult result(this);
2287                 JSValueRegs resultRegs = result.regs();
2288                 callOperation(operationGetByValCell, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs);
2289                 m_jit.exceptionCheck();
2290 
2291                 jsValueResult(resultRegs, node);
2292                 break;
2293             }
2294 
2295             speculate(node, m_graph.varArgChild(node, 0));
2296             speculate(node, m_graph.varArgChild(node, 1));
2297 
2298             JSValueOperand base(this, m_graph.varArgChild(node, 0), ManualOperandSpeculation);
2299             JSValueOperand property(this, m_graph.varArgChild(node, 1), ManualOperandSpeculation);
2300             GPRTemporary resultTag(this, Reuse, property, TagWord);
2301             GPRTemporary resultPayload(this, Reuse, property, PayloadWord);
2302 
2303             JSValueRegs baseRegs = base.jsValueRegs();
2304             JSValueRegs propertyRegs = property.jsValueRegs();
2305             JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());
2306 
2307             CodeOrigin codeOrigin = node-&gt;origin.semantic;
2308             CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
2309             RegisterSet usedRegisters = this-&gt;usedRegisters();
2310 
2311             JITCompiler::JumpList slowCases;
2312             if (!m_state.forNode(m_graph.varArgChild(node, 0)).isType(SpecCell))
2313                 slowCases.append(m_jit.branchIfNotCell(baseRegs.tagGPR()));
2314 
2315             JITGetByValGenerator gen(
2316                 m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,
2317                 baseRegs, propertyRegs, resultRegs);
2318 
2319             if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecString))
2320                 gen.stubInfo()-&gt;propertyIsString = true;
2321             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))
2322                 gen.stubInfo()-&gt;propertyIsInt32 = true;
2323             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecSymbol))
2324                 gen.stubInfo()-&gt;propertyIsSymbol = true;
2325 
2326             gen.generateFastPath(m_jit);
2327 
2328             slowCases.append(gen.slowPathJump());
2329 
2330             std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
2331                 slowCases, this, operationGetByValOptimize,
2332                 resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), nullptr, baseRegs, propertyRegs);
2333 
2334             m_jit.addGetByVal(gen, slowPath.get());
2335             addSlowPathGenerator(WTFMove(slowPath));
2336 
2337             jsValueResult(resultRegs, node);
2338             break;
2339         }
2340         case Array::Int32:
2341         case Array::Contiguous: {
2342             if (node-&gt;arrayMode().isInBounds()) {
2343                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2344                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2345 
2346                 GPRReg propertyReg = property.gpr();
2347                 GPRReg storageReg = storage.gpr();
2348 
2349                 if (!m_compileOkay)
2350                     return;
2351 
2352                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2353 
2354                 GPRTemporary resultPayload(this);
2355                 if (node-&gt;arrayMode().type() == Array::Int32) {
2356                     ASSERT(!node-&gt;arrayMode().isSaneChain());
2357 
2358                     speculationCheck(
2359                         OutOfBounds, JSValueRegs(), 0,
2360                         m_jit.branch32(
2361                             MacroAssembler::Equal,
2362                             MacroAssembler::BaseIndex(
2363                                 storageReg, propertyReg, MacroAssembler::TimesEight, TagOffset),
2364                             TrustedImm32(JSValue::EmptyValueTag)));
2365                     m_jit.load32(
2366                         MacroAssembler::BaseIndex(
2367                             storageReg, propertyReg, MacroAssembler::TimesEight, PayloadOffset),
2368                         resultPayload.gpr());
2369                     int32Result(resultPayload.gpr(), node);
2370                     break;
2371                 }
2372 
2373                 GPRTemporary resultTag(this);
2374                 m_jit.load32(
2375                     MacroAssembler::BaseIndex(
2376                         storageReg, propertyReg, MacroAssembler::TimesEight, TagOffset),
2377                     resultTag.gpr());
2378                 m_jit.load32(
2379                     MacroAssembler::BaseIndex(
2380                         storageReg, propertyReg, MacroAssembler::TimesEight, PayloadOffset),
2381                     resultPayload.gpr());
2382                 if (node-&gt;arrayMode().isSaneChain()) {
2383                     JITCompiler::Jump notHole = m_jit.branchIfNotEmpty(resultTag.gpr());
2384                     m_jit.move(TrustedImm32(JSValue::UndefinedTag), resultTag.gpr());
2385                     m_jit.move(TrustedImm32(0), resultPayload.gpr());
2386                     notHole.link(&amp;m_jit);
2387                 } else {
2388                     speculationCheck(
2389                         LoadFromHole, JSValueRegs(), 0,
2390                         m_jit.branchIfEmpty(resultTag.gpr()));
2391                 }
2392                 jsValueResult(resultTag.gpr(), resultPayload.gpr(), node);
2393                 break;
2394             }
2395 
2396             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2397             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2398             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2399 
2400             GPRReg baseReg = base.gpr();
2401             GPRReg propertyReg = property.gpr();
2402             GPRReg storageReg = storage.gpr();
2403 
2404             if (!m_compileOkay)
2405                 return;
2406 
2407             GPRTemporary resultTag(this);
2408             GPRTemporary resultPayload(this);
2409             GPRReg resultTagReg = resultTag.gpr();
2410             GPRReg resultPayloadReg = resultPayload.gpr();
2411 
2412             MacroAssembler::JumpList slowCases;
2413 
2414             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2415 
2416             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2417             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2418             slowCases.append(m_jit.branchIfEmpty(resultTagReg));
2419 
2420             addSlowPathGenerator(
2421                 slowPathCall(
2422                     slowCases, this, operationGetByValObjectInt,
2423                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));
2424 
2425             jsValueResult(resultTagReg, resultPayloadReg, node);
2426             break;
2427         }
2428         case Array::Double: {
2429             if (node-&gt;arrayMode().isInBounds()) {
2430                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2431                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2432 
2433                 GPRReg propertyReg = property.gpr();
2434                 GPRReg storageReg = storage.gpr();
2435 
2436                 if (!m_compileOkay)
2437                     return;
2438 
2439                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2440 
2441                 FPRTemporary result(this);
2442                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.fpr());
2443                 if (!node-&gt;arrayMode().isSaneChain())
2444                     speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfNaN(result.fpr()));
2445                 doubleResult(result.fpr(), node);
2446                 break;
2447             }
2448 
2449             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2450             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2451             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2452 
2453             GPRReg baseReg = base.gpr();
2454             GPRReg propertyReg = property.gpr();
2455             GPRReg storageReg = storage.gpr();
2456 
2457             if (!m_compileOkay)
2458                 return;
2459 
2460             GPRTemporary resultTag(this);
2461             GPRTemporary resultPayload(this);
2462             FPRTemporary temp(this);
2463             GPRReg resultTagReg = resultTag.gpr();
2464             GPRReg resultPayloadReg = resultPayload.gpr();
2465             FPRReg tempReg = temp.fpr();
2466 
2467             MacroAssembler::JumpList slowCases;
2468 
2469             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2470 
2471             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2472             slowCases.append(m_jit.branchIfNaN(tempReg));
2473             boxDouble(tempReg, resultTagReg, resultPayloadReg);
2474 
2475             addSlowPathGenerator(
2476                 slowPathCall(
2477                     slowCases, this, operationGetByValObjectInt,
2478                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));
2479 
2480             jsValueResult(resultTagReg, resultPayloadReg, node);
2481             break;
2482         }
2483         case Array::ArrayStorage:
2484         case Array::SlowPutArrayStorage: {
2485             if (node-&gt;arrayMode().isInBounds()) {
2486                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2487                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2488                 GPRReg propertyReg = property.gpr();
2489                 GPRReg storageReg = storage.gpr();
2490 
2491                 if (!m_compileOkay)
2492                     return;
2493 
2494                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2495 
2496                 GPRTemporary resultTag(this);
2497                 GPRTemporary resultPayload(this);
2498 
2499                 m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTag.gpr());
2500                 speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfEmpty(resultTag.gpr()));
2501                 m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayload.gpr());
2502 
2503                 jsValueResult(resultTag.gpr(), resultPayload.gpr(), node);
2504                 break;
2505             }
2506 
2507             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2508             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2509             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2510             GPRReg propertyReg = property.gpr();
2511             GPRReg storageReg = storage.gpr();
2512             GPRReg baseReg = base.gpr();
2513 
2514             if (!m_compileOkay)
2515                 return;
2516 
2517             GPRTemporary resultTag(this);
2518             GPRTemporary resultPayload(this);
2519             GPRReg resultTagReg = resultTag.gpr();
2520             GPRReg resultPayloadReg = resultPayload.gpr();
2521 
2522             JITCompiler::Jump outOfBounds = m_jit.branch32(
2523                 MacroAssembler::AboveOrEqual, propertyReg,
2524                 MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2525 
2526             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), resultTagReg);
2527             JITCompiler::Jump hole = m_jit.branchIfEmpty(resultTag.gpr());
2528             m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), resultPayloadReg);
2529 
2530             JITCompiler::JumpList slowCases;
2531             slowCases.append(outOfBounds);
2532             slowCases.append(hole);
2533             addSlowPathGenerator(
2534                 slowPathCall(
2535                     slowCases, this, operationGetByValObjectInt,
2536                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)),
2537                     baseReg, propertyReg));
2538 
2539             jsValueResult(resultTagReg, resultPayloadReg, node);
2540             break;
2541         }
2542         case Array::String:
2543             compileGetByValOnString(node);
2544             break;
2545         case Array::DirectArguments:
2546             compileGetByValOnDirectArguments(node);
2547             break;
2548         case Array::ScopedArguments:
2549             compileGetByValOnScopedArguments(node);
2550             break;
2551         default: {
2552             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2553             if (isInt(type))
2554                 compileGetByValOnIntTypedArray(node, type);
2555             else
2556                 compileGetByValOnFloatTypedArray(node, type);
2557         } }
2558         break;
2559     }
2560 
2561     case StringSlice: {
2562         compileStringSlice(node);
2563         break;
2564     }
2565 
2566     case ToLowerCase: {
2567         compileToLowerCase(node);
2568         break;
2569     }
2570 
2571     case NumberToStringWithRadix: {
2572         compileNumberToStringWithRadix(node);
2573         break;
2574     }
2575 
2576     case NumberToStringWithValidRadixConstant: {
2577         compileNumberToStringWithValidRadixConstant(node);
2578         break;
2579     }
2580 
2581     case GetByValWithThis: {
2582         compileGetByValWithThis(node);
2583         break;
2584     }
2585 
2586     case PutByValDirect:
2587     case PutByVal:
2588     case PutByValAlias: {
2589         Edge child1 = m_jit.graph().varArgChild(node, 0);
2590         Edge child2 = m_jit.graph().varArgChild(node, 1);
2591         Edge child3 = m_jit.graph().varArgChild(node, 2);
2592         Edge child4 = m_jit.graph().varArgChild(node, 3);
2593 
2594         ArrayMode arrayMode = node-&gt;arrayMode().modeForPut();
2595         bool alreadyHandled = false;
2596 
2597         switch (arrayMode.type()) {
2598         case Array::SelectUsingPredictions:
2599         case Array::ForceExit:
2600             RELEASE_ASSERT_NOT_REACHED();
2601 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
2602             terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
2603             alreadyHandled = true;
2604 #endif
2605             break;
2606         case Array::Generic: {
2607             ASSERT(node-&gt;op() == PutByVal || node-&gt;op() == PutByValDirect);
2608 
2609             if (child1.useKind() == CellUse) {
2610                 if (child2.useKind() == StringUse) {
2611                     compilePutByValForCellWithString(node, child1, child2, child3);
2612                     alreadyHandled = true;
2613                     break;
2614                 }
2615 
2616                 if (child2.useKind() == SymbolUse) {
2617                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2618                     alreadyHandled = true;
2619                     break;
2620                 }
2621             }
2622 
2623             SpeculateCellOperand base(this, child1); // Save a register, speculate cell. We&#39;ll probably be right.
2624             JSValueOperand property(this, child2);
2625             JSValueOperand value(this, child3);
2626             GPRReg baseGPR = base.gpr();
2627             JSValueRegs propertyRegs = property.jsValueRegs();
2628             JSValueRegs valueRegs = value.jsValueRegs();
2629 
2630             flushRegisters();
2631             if (node-&gt;op() == PutByValDirect)
2632                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs);
2633             else
2634                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs);
2635             m_jit.exceptionCheck();
2636 
2637             noResult(node);
2638             alreadyHandled = true;
2639             break;
2640         }
2641         default:
2642             break;
2643         }
2644 
2645         if (alreadyHandled)
2646             break;
2647 
2648         SpeculateCellOperand base(this, child1);
2649         SpeculateStrictInt32Operand property(this, child2);
2650 
2651         GPRReg baseReg = base.gpr();
2652         GPRReg propertyReg = property.gpr();
2653 
2654         switch (arrayMode.type()) {
2655         case Array::Int32: {
2656             speculateInt32(child3);
2657             FALLTHROUGH;
2658         }
2659         case Array::Contiguous: {
2660             JSValueOperand value(this, child3, ManualOperandSpeculation);
2661 
2662             GPRReg valueTagReg = value.tagGPR();
2663             GPRReg valuePayloadReg = value.payloadGPR();
2664 
2665             if (!m_compileOkay)
2666                 return;
2667 
2668             compileContiguousPutByVal(node, base, property, value, valuePayloadReg, valueTagReg);
2669             break;
2670         }
2671         case Array::Double: {
2672             compileDoublePutByVal(node, base, property);
2673             break;
2674         }
2675         case Array::ArrayStorage:
2676         case Array::SlowPutArrayStorage: {
2677             JSValueOperand value(this, child3);
2678 
2679             GPRReg valueTagReg = value.tagGPR();
2680             GPRReg valuePayloadReg = value.payloadGPR();
2681 
2682             if (!m_compileOkay)
2683                 return;
2684 
2685             StorageOperand storage(this, child4);
2686             GPRReg storageReg = storage.gpr();
2687 
2688             if (node-&gt;op() == PutByValAlias) {
2689                 // Store the value to the array.
2690                 GPRReg propertyReg = property.gpr();
2691                 m_jit.store32(value.tagGPR(), MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2692                 m_jit.store32(value.payloadGPR(), MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2693 
2694                 noResult(node);
2695                 break;
2696             }
2697 
2698             MacroAssembler::JumpList slowCases;
2699 
2700             MacroAssembler::Jump beyondArrayBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2701             if (!arrayMode.isOutOfBounds())
2702                 speculationCheck(OutOfBounds, JSValueRegs(), 0, beyondArrayBounds);
2703             else
2704                 slowCases.append(beyondArrayBounds);
2705 
2706             // Check if we&#39;re writing to a hole; if so increment m_numValuesInVector.
2707             if (arrayMode.isInBounds()) {
2708                 speculationCheck(
2709                     StoreToHole, JSValueRegs(), 0,
2710                     m_jit.branch32(MacroAssembler::Equal, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag)));
2711             } else {
2712                 MacroAssembler::Jump notHoleValue = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag));
2713                 if (arrayMode.isSlowPut()) {
2714                     // This is sort of strange. If we wanted to optimize this code path, we would invert
2715                     // the above branch. But it&#39;s simply not worth it since this only happens if we&#39;re
2716                     // already having a bad time.
2717                     slowCases.append(m_jit.jump());
2718                 } else {
2719                     m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageReg, ArrayStorage::numValuesInVectorOffset()));
2720 
2721                     // If we&#39;re writing to a hole we might be growing the array;
2722                     MacroAssembler::Jump lengthDoesNotNeedUpdate = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2723                     m_jit.add32(TrustedImm32(1), propertyReg);
2724                     m_jit.store32(propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2725                     m_jit.sub32(TrustedImm32(1), propertyReg);
2726 
2727                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2728                 }
2729                 notHoleValue.link(&amp;m_jit);
2730             }
2731 
2732             // Store the value to the array.
2733             m_jit.store32(valueTagReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2734             m_jit.store32(valuePayloadReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2735 
2736             base.use();
2737             property.use();
2738             value.use();
2739             storage.use();
2740 
2741             if (!slowCases.empty()) {
2742                 if (node-&gt;op() == PutByValDirect) {
2743                     addSlowPathGenerator(slowPathCall(
2744                         slowCases, this,
2745                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
2746                         NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2747                 } else {
2748                     addSlowPathGenerator(slowPathCall(
2749                         slowCases, this,
2750                         m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
2751                         NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));
2752                 }
2753             }
2754 
2755             noResult(node, UseChildrenCalledExplicitly);
2756             break;
2757         }
2758 
2759         default: {
2760             TypedArrayType type = arrayMode.typedArrayType();
2761             if (isInt(type))
2762                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2763             else
2764                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2765         } }
2766         break;
2767     }
2768 
2769     case PutByValWithThis: {
2770         static_assert(GPRInfo::numberOfRegisters &gt;= 8, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
2771 
2772         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
2773         JSValueRegs baseRegs = base.jsValueRegs();
2774 
2775         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
2776         JSValueRegs thisRegs = thisValue.jsValueRegs();
2777 
2778         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
2779         JSValueRegs propertyRegs = property.jsValueRegs();
2780 
2781         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
2782         JSValueRegs valueRegs = value.jsValueRegs();
2783 
2784         flushRegisters();
2785         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,
2786             TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisRegs, propertyRegs, valueRegs);
2787         m_jit.exceptionCheck();
2788 
2789         noResult(node);
2790         break;
2791     }
2792 
2793     case RegExpExec: {
2794         compileRegExpExec(node);
2795         break;
2796     }
2797 
2798     case RegExpExecNonGlobalOrSticky: {
2799         compileRegExpExecNonGlobalOrSticky(node);
2800         break;
2801     }
2802 
2803     case RegExpMatchFastGlobal: {
2804         compileRegExpMatchFastGlobal(node);
2805         break;
2806     }
2807 
2808     case RegExpTest: {
2809         compileRegExpTest(node);
2810         break;
2811     }
2812 
2813     case RegExpMatchFast: {
2814         compileRegExpMatchFast(node);
2815         break;
2816     }
2817 
2818     case StringReplace:
2819     case StringReplaceRegExp: {
2820         compileStringReplace(node);
2821         break;
2822     }
2823 
2824     case GetRegExpObjectLastIndex: {
2825         compileGetRegExpObjectLastIndex(node);
2826         break;
2827     }
2828 
2829     case SetRegExpObjectLastIndex: {
2830         compileSetRegExpObjectLastIndex(node);
2831         break;
2832     }
2833 
2834     case RecordRegExpCachedResult: {
2835         compileRecordRegExpCachedResult(node);
2836         break;
2837     }
2838 
2839     case ArrayPush: {
2840         compileArrayPush(node);
2841         break;
2842     }
2843 
2844     case ArrayPop: {
2845         ASSERT(node-&gt;arrayMode().isJSArray());
2846 
2847         SpeculateCellOperand base(this, node-&gt;child1());
2848         StorageOperand storage(this, node-&gt;child2());
2849         GPRTemporary valueTag(this);
2850         GPRTemporary valuePayload(this);
2851 
2852         GPRReg baseGPR = base.gpr();
2853         GPRReg valueTagGPR = valueTag.gpr();
2854         GPRReg valuePayloadGPR = valuePayload.gpr();
2855         GPRReg storageGPR = storage.gpr();
2856 
2857         switch (node-&gt;arrayMode().type()) {
2858         case Array::Int32:
2859         case Array::Contiguous: {
2860             m_jit.load32(
2861                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), valuePayloadGPR);
2862             MacroAssembler::Jump undefinedCase =
2863                 m_jit.branchTest32(MacroAssembler::Zero, valuePayloadGPR);
2864             m_jit.sub32(TrustedImm32(1), valuePayloadGPR);
2865             m_jit.store32(
2866                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2867             m_jit.load32(
2868                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)),
2869                 valueTagGPR);
2870             MacroAssembler::Jump slowCase = m_jit.branchIfEmpty(valueTagGPR);
2871             m_jit.store32(
2872                 MacroAssembler::TrustedImm32(JSValue::EmptyValueTag),
2873                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2874             m_jit.load32(
2875                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)),
2876                 valuePayloadGPR);
2877 
2878             addSlowPathGenerator(
2879                 slowPathMove(
2880                     undefinedCase, this,
2881                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2882                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2883             addSlowPathGenerator(
2884                 slowPathCall(
2885                     slowCase, this, operationArrayPopAndRecoverLength,
2886                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));
2887 
2888             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2889             break;
2890         }
2891 
2892         case Array::Double: {
2893             FPRTemporary temp(this);
2894             FPRReg tempFPR = temp.fpr();
2895 
2896             m_jit.load32(
2897                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), valuePayloadGPR);
2898             MacroAssembler::Jump undefinedCase =
2899                 m_jit.branchTest32(MacroAssembler::Zero, valuePayloadGPR);
2900             m_jit.sub32(TrustedImm32(1), valuePayloadGPR);
2901             m_jit.store32(
2902                 valuePayloadGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
2903             m_jit.loadDouble(
2904                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight),
2905                 tempFPR);
2906             MacroAssembler::Jump slowCase = m_jit.branchIfNaN(tempFPR);
2907             JSValue nan = JSValue(JSValue::EncodeAsDouble, PNaN);
2908             m_jit.store32(
2909                 MacroAssembler::TrustedImm32(nan.u.asBits.tag),
2910                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2911             m_jit.store32(
2912                 MacroAssembler::TrustedImm32(nan.u.asBits.payload),
2913                 MacroAssembler::BaseIndex(storageGPR, valuePayloadGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
2914             boxDouble(tempFPR, valueTagGPR, valuePayloadGPR);
2915 
2916             addSlowPathGenerator(
2917                 slowPathMove(
2918                     undefinedCase, this,
2919                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2920                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2921             addSlowPathGenerator(
2922                 slowPathCall(
2923                     slowCase, this, operationArrayPopAndRecoverLength,
2924                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));
2925 
2926             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2927             break;
2928         }
2929 
2930         case Array::ArrayStorage: {
2931             GPRTemporary storageLength(this);
2932             GPRReg storageLengthGPR = storageLength.gpr();
2933 
2934             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
2935 
2936             JITCompiler::JumpList setUndefinedCases;
2937             setUndefinedCases.append(m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR));
2938 
2939             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
2940 
2941             MacroAssembler::Jump slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
2942 
2943             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), valueTagGPR);
2944             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), valuePayloadGPR);
2945 
2946             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
2947 
2948             setUndefinedCases.append(m_jit.branchIfEmpty(valueTagGPR));
2949 
2950             m_jit.store32(TrustedImm32(JSValue::EmptyValueTag), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
2951 
2952             m_jit.sub32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
2953 
2954             addSlowPathGenerator(
2955                 slowPathMove(
2956                     setUndefinedCases, this,
2957                     MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
2958                     MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
2959 
2960             addSlowPathGenerator(
2961                 slowPathCall(
2962                     slowCase, this, operationArrayPop,
2963                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));
2964 
2965             jsValueResult(valueTagGPR, valuePayloadGPR, node);
2966             break;
2967         }
2968 
2969         default:
2970             CRASH();
2971             break;
2972         }
2973         break;
2974     }
2975 
2976     case ArraySlice: {
2977         compileArraySlice(node);
2978         break;
2979     }
2980 
2981     case ArrayIndexOf: {
2982         compileArrayIndexOf(node);
2983         break;
2984     }
2985 
2986     case DFG::Jump: {
2987         jump(node-&gt;targetBlock());
2988         noResult(node);
2989         break;
2990     }
2991 
2992     case Branch:
2993         emitBranch(node);
2994         break;
2995 
2996     case Switch:
2997         emitSwitch(node);
2998         break;
2999 
3000     case Return: {
3001         ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT2);
3002         ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);
3003         ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);
3004 
3005         // Return the result in returnValueGPR.
3006         JSValueOperand op1(this, node-&gt;child1());
3007         op1.fill();
3008         if (op1.isDouble())
3009             boxDouble(op1.fpr(), GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);
3010         else {
3011             if (op1.payloadGPR() == GPRInfo::returnValueGPR2 &amp;&amp; op1.tagGPR() == GPRInfo::returnValueGPR)
3012                 m_jit.swap(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
3013             else if (op1.payloadGPR() == GPRInfo::returnValueGPR2) {
3014                 m_jit.move(op1.payloadGPR(), GPRInfo::returnValueGPR);
3015                 m_jit.move(op1.tagGPR(), GPRInfo::returnValueGPR2);
3016             } else {
3017                 m_jit.move(op1.tagGPR(), GPRInfo::returnValueGPR2);
3018                 m_jit.move(op1.payloadGPR(), GPRInfo::returnValueGPR);
3019             }
3020         }
3021 
3022         m_jit.emitRestoreCalleeSaves();
3023         m_jit.emitFunctionEpilogue();
3024         m_jit.ret();
3025 
3026         noResult(node);
3027         break;
3028     }
3029 
3030     case Throw: {
3031         compileThrow(node);
3032         break;
3033     }
3034 
3035     case ThrowStaticError: {
3036         compileThrowStaticError(node);
3037         break;
3038     }
3039 
3040     case BooleanToNumber: {
3041         switch (node-&gt;child1().useKind()) {
3042         case BooleanUse: {
3043             SpeculateBooleanOperand value(this, node-&gt;child1());
3044             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3045 
3046             m_jit.move(value.gpr(), result.gpr());
3047 
3048             int32Result(result.gpr(), node);
3049             break;
3050         }
3051 
3052         case UntypedUse: {
3053             JSValueOperand value(this, node-&gt;child1());
3054 
3055             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3056                 GPRTemporary result(this);
3057 
3058                 GPRReg valueGPR = value.payloadGPR();
3059                 GPRReg resultGPR = result.gpr();
3060 
3061                 m_jit.move(valueGPR, resultGPR);
3062                 int32Result(result.gpr(), node);
3063                 break;
3064             }
3065 
3066             GPRTemporary resultTag(this);
3067             GPRTemporary resultPayload(this);
3068 
3069             GPRReg valueTagGPR = value.tagGPR();
3070             GPRReg valuePayloadGPR = value.payloadGPR();
3071             GPRReg resultTagGPR = resultTag.gpr();
3072             GPRReg resultPayloadGPR = resultPayload.gpr();
3073 
3074             m_jit.move(valuePayloadGPR, resultPayloadGPR);
3075             JITCompiler::Jump isBoolean = m_jit.branchIfBoolean(valueTagGPR, InvalidGPRReg);
3076             m_jit.move(valueTagGPR, resultTagGPR);
3077             JITCompiler::Jump done = m_jit.jump();
3078             isBoolean.link(&amp;m_jit);
3079             m_jit.move(TrustedImm32(JSValue::Int32Tag), resultTagGPR);
3080             done.link(&amp;m_jit);
3081 
3082             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3083             break;
3084         }
3085 
3086         default:
3087             RELEASE_ASSERT_NOT_REACHED();
3088             break;
3089         }
3090         break;
3091     }
3092 
3093     case ToPrimitive: {
3094         compileToPrimitive(node);
3095         break;
3096     }
3097 
3098     case ToPropertyKey: {
3099         compileToPropertyKey(node);
3100         break;
3101     }
3102 
3103     case ToNumber: {
3104         JSValueOperand argument(this, node-&gt;child1());
3105         GPRTemporary resultTag(this, Reuse, argument, TagWord);
3106         GPRTemporary resultPayload(this, Reuse, argument, PayloadWord);
3107 
3108         GPRReg argumentPayloadGPR = argument.payloadGPR();
3109         GPRReg argumentTagGPR = argument.tagGPR();
3110         JSValueRegs argumentRegs = argument.jsValueRegs();
3111         JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());
3112 
3113         argument.use();
3114 
3115         // We have several attempts to remove ToNumber. But ToNumber still exists.
3116         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3117         // Instead of the slow path generator, we emit callOperation here.
3118         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3119             flushRegisters();
3120             callOperation(operationToNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);
3121             m_jit.exceptionCheck();
3122         } else {
3123             MacroAssembler::Jump notNumber;
3124             {
3125                 GPRTemporary scratch(this);
3126                 notNumber = m_jit.branchIfNotNumber(argument.jsValueRegs(), scratch.gpr());
3127             }
3128             m_jit.move(argumentTagGPR, resultRegs.tagGPR());
3129             m_jit.move(argumentPayloadGPR, resultRegs.payloadGPR());
3130             MacroAssembler::Jump done = m_jit.jump();
3131 
3132             notNumber.link(&amp;m_jit);
3133             silentSpillAllRegisters(resultRegs);
3134             callOperation(operationToNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);
3135             silentFillAllRegisters();
3136             m_jit.exceptionCheck();
3137 
3138             done.link(&amp;m_jit);
3139         }
3140 
3141         jsValueResult(resultRegs.tagGPR(), resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
3142         break;
3143     }
3144 
3145     case ToNumeric: {
3146         compileToNumeric(node);
3147         break;
3148     }
3149 
3150     case ToString:
3151     case CallStringConstructor:
3152     case StringValueOf: {
3153         compileToStringOrCallStringConstructorOrStringValueOf(node);
3154         break;
3155     }
3156 
3157     case NewStringObject: {
3158         compileNewStringObject(node);
3159         break;
3160     }
3161 
3162     case NewSymbol: {
3163         compileNewSymbol(node);
3164         break;
3165     }
3166 
3167     case NewArray: {
3168         compileNewArray(node);
3169         break;
3170     }
3171 
3172     case NewArrayWithSpread: {
3173         compileNewArrayWithSpread(node);
3174         break;
3175     }
3176 
3177     case Spread: {
3178         compileSpread(node);
3179         break;
3180     }
3181 
3182     case NewArrayWithSize: {
3183         compileNewArrayWithSize(node);
3184         break;
3185     }
3186 
3187     case NewArrayBuffer: {
3188         compileNewArrayBuffer(node);
3189         break;
3190     }
3191 
3192     case NewTypedArray: {
3193         compileNewTypedArray(node);
3194         break;
3195     }
3196 
3197     case NewRegexp: {
3198         compileNewRegexp(node);
3199         break;
3200     }
3201 
3202     case ToObject:
3203     case CallObjectConstructor: {
3204         compileToObjectOrCallObjectConstructor(node);
3205         break;
3206     }
3207 
3208     case ToThis: {
3209         compileToThis(node);
3210         break;
3211     }
3212 
3213     case ObjectCreate: {
3214         compileObjectCreate(node);
3215         break;
3216     }
3217 
3218     case ObjectKeys: {
3219         compileObjectKeys(node);
3220         break;
3221     }
3222 
3223     case CreateThis: {
3224         compileCreateThis(node);
3225         break;
3226     }
3227 
3228     case CreatePromise: {
3229         compileCreatePromise(node);
3230         break;
3231     }
3232 
3233     case CreateGenerator: {
3234         compileCreateGenerator(node);
3235         break;
3236     }
3237 
3238     case CreateAsyncGenerator: {
3239         compileCreateAsyncGenerator(node);
3240         break;
3241     }
3242 
3243     case NewObject: {
3244         compileNewObject(node);
3245         break;
3246     }
3247 
3248     case NewPromise: {
3249         compileNewPromise(node);
3250         break;
3251     }
3252 
3253     case NewGenerator: {
3254         compileNewGenerator(node);
3255         break;
3256     }
3257 
3258     case NewAsyncGenerator: {
3259         compileNewAsyncGenerator(node);
3260         break;
3261     }
3262 
3263     case NewArrayIterator: {
3264         compileNewArrayIterator(node);
3265         break;
3266     }
3267 
3268     case GetCallee: {
3269         compileGetCallee(node);
3270         break;
3271     }
3272 
3273     case SetCallee: {
3274         compileSetCallee(node);
3275         break;
3276     }
3277 
3278     case GetArgumentCountIncludingThis: {
3279         compileGetArgumentCountIncludingThis(node);
3280         break;
3281     }
3282 
3283     case SetArgumentCountIncludingThis:
3284         compileSetArgumentCountIncludingThis(node);
3285         break;
3286 
3287     case GetScope:
3288         compileGetScope(node);
3289         break;
3290 
3291     case SkipScope:
3292         compileSkipScope(node);
3293         break;
3294 
3295     case GetGlobalObject:
3296         compileGetGlobalObject(node);
3297         break;
3298 
3299     case GetGlobalThis:
3300         compileGetGlobalThis(node);
3301         break;
3302 
3303     case GetClosureVar: {
3304         compileGetClosureVar(node);
3305         break;
3306     }
3307 
3308     case PutClosureVar: {
3309         compilePutClosureVar(node);
3310         break;
3311     }
3312 
3313     case GetInternalField: {
3314         compileGetInternalField(node);
3315         break;
3316     }
3317 
3318     case PutInternalField: {
3319         compilePutInternalField(node);
3320         break;
3321     }
3322 
3323     case TryGetById: {
3324         compileGetById(node, AccessType::TryGetById);
3325         break;
3326     }
3327 
3328     case GetByIdDirect: {
3329         compileGetById(node, AccessType::GetByIdDirect);
3330         break;
3331     }
3332 
3333     case GetByIdDirectFlush: {
3334         compileGetByIdFlush(node, AccessType::GetByIdDirect);
3335         break;
3336     }
3337 
3338     case GetById: {
3339         compileGetById(node, AccessType::GetById);
3340         break;
3341     }
3342 
3343     case GetByIdFlush: {
3344         compileGetByIdFlush(node, AccessType::GetById);
3345         break;
3346     }
3347 
3348     case GetByIdWithThis: {
3349         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3350             SpeculateCellOperand base(this, node-&gt;child1());
3351             SpeculateCellOperand thisValue(this, node-&gt;child2());
3352             GPRTemporary resultTag(this);
3353             GPRTemporary resultPayload(this);
3354 
3355             GPRReg baseGPR = base.gpr();
3356             GPRReg thisGPR = thisValue.gpr();
3357             GPRReg resultTagGPR = resultTag.gpr();
3358             GPRReg resultPayloadGPR = resultPayload.gpr();
3359 
3360             cachedGetByIdWithThis(node-&gt;origin.semantic, InvalidGPRReg, baseGPR, InvalidGPRReg, thisGPR, resultTagGPR, resultPayloadGPR, node-&gt;identifierNumber());
3361 
3362             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3363         } else {
3364             JSValueOperand base(this, node-&gt;child1());
3365             JSValueOperand thisValue(this, node-&gt;child2());
3366             GPRTemporary resultTag(this);
3367             GPRTemporary resultPayload(this);
3368 
3369             GPRReg baseTagGPR = base.tagGPR();
3370             GPRReg basePayloadGPR = base.payloadGPR();
3371             GPRReg thisTagGPR = thisValue.tagGPR();
3372             GPRReg thisPayloadGPR = thisValue.payloadGPR();
3373             GPRReg resultTagGPR = resultTag.gpr();
3374             GPRReg resultPayloadGPR = resultPayload.gpr();
3375 
3376             JITCompiler::JumpList notCellList;
3377             notCellList.append(m_jit.branchIfNotCell(base.jsValueRegs()));
3378             notCellList.append(m_jit.branchIfNotCell(thisValue.jsValueRegs()));
3379 
3380             cachedGetByIdWithThis(node-&gt;origin.semantic, baseTagGPR, basePayloadGPR, thisTagGPR, thisPayloadGPR, resultTagGPR, resultPayloadGPR, node-&gt;identifierNumber(), notCellList);
3381 
3382             jsValueResult(resultTagGPR, resultPayloadGPR, node);
3383         }
3384 
3385         break;
3386     }
3387 
3388     case GetArrayLength:
3389         compileGetArrayLength(node);
3390         break;
3391 
3392     case DeleteById: {
3393         compileDeleteById(node);
3394         break;
3395     }
3396 
3397     case DeleteByVal: {
3398         compileDeleteByVal(node);
3399         break;
3400     }
3401 
3402     case CheckCell: {
3403         compileCheckCell(node);
3404         break;
3405     }
3406 
3407     case CheckNotEmpty: {
3408         compileCheckNotEmpty(node);
3409         break;
3410     }
3411 
3412     case CheckIdent:
3413         compileCheckIdent(node);
3414         break;
3415 
3416     case GetExecutable: {
3417         compileGetExecutable(node);
3418         break;
3419     }
3420 
3421     case CheckStructure: {
3422         compileCheckStructure(node);
3423         break;
3424     }
3425 
3426     case PutStructure: {
3427         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3428         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3429 
3430         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3431 
3432         SpeculateCellOperand base(this, node-&gt;child1());
3433         GPRReg baseGPR = base.gpr();
3434 
3435         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
3436         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
3437         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
3438         m_jit.storePtr(TrustedImmPtr(newStructure), MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()));
3439 
3440         noResult(node);
3441         break;
3442     }
3443 
3444     case AllocatePropertyStorage:
3445         compileAllocatePropertyStorage(node);
3446         break;
3447 
3448     case ReallocatePropertyStorage:
3449         compileReallocatePropertyStorage(node);
3450         break;
3451 
3452     case NukeStructureAndSetButterfly:
3453         compileNukeStructureAndSetButterfly(node);
3454         break;
3455 
3456     case GetButterfly:
3457         compileGetButterfly(node);
3458         break;
3459 
3460     case GetIndexedPropertyStorage: {
3461         compileGetIndexedPropertyStorage(node);
3462         break;
3463     }
3464 
3465     case ConstantStoragePointer: {
3466         compileConstantStoragePointer(node);
3467         break;
3468     }
3469 
3470     case GetTypedArrayByteOffset: {
3471         compileGetTypedArrayByteOffset(node);
3472         break;
3473     }
3474 
3475     case GetPrototypeOf: {
3476         compileGetPrototypeOf(node);
3477         break;
3478     }
3479 
3480     case GetByOffset: {
3481         compileGetByOffset(node);
3482         break;
3483     }
3484 
3485     case GetGetterSetterByOffset: {
3486         StorageOperand storage(this, node-&gt;child1());
3487         GPRTemporary resultPayload(this);
3488 
3489         GPRReg storageGPR = storage.gpr();
3490         GPRReg resultPayloadGPR = resultPayload.gpr();
3491 
3492         StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
3493 
3494         m_jit.load32(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)), resultPayloadGPR);
3495 
3496         cellResult(resultPayloadGPR, node);
3497         break;
3498     }
3499 
3500     case MatchStructure: {
3501         compileMatchStructure(node);
3502         break;
3503     }
3504 
3505     case GetGetter: {
3506         compileGetGetter(node);
3507         break;
3508     }
3509 
3510     case GetSetter: {
3511         compileGetSetter(node);
3512         break;
3513     }
3514 
3515     case PutByOffset: {
3516         compilePutByOffset(node);
3517         break;
3518     }
3519 
3520     case PutByIdFlush: {
3521         compilePutByIdFlush(node);
3522         break;
3523     }
3524 
3525     case PutById: {
3526         compilePutById(node);
3527         break;
3528     }
3529 
3530     case PutByIdDirect: {
3531         compilePutByIdDirect(node);
3532         break;
3533     }
3534 
3535     case PutByIdWithThis: {
3536         compilePutByIdWithThis(node);
3537         break;
3538     }
3539 
3540     case PutGetterById:
3541     case PutSetterById: {
3542         compilePutAccessorById(node);
3543         break;
3544     }
3545 
3546     case PutGetterSetterById: {
3547         compilePutGetterSetterById(node);
3548         break;
3549     }
3550 
3551     case PutGetterByVal:
3552     case PutSetterByVal: {
3553         compilePutAccessorByVal(node);
3554         break;
3555     }
3556 
3557     case DefineDataProperty: {
3558         compileDefineDataProperty(node);
3559         break;
3560     }
3561 
3562     case DefineAccessorProperty: {
3563         compileDefineAccessorProperty(node);
3564         break;
3565     }
3566 
3567     case GetGlobalLexicalVariable:
3568     case GetGlobalVar: {
3569         compileGetGlobalVariable(node);
3570         break;
3571     }
3572 
3573     case PutGlobalVariable: {
3574         compilePutGlobalVariable(node);
3575         break;
3576     }
3577 
3578     case NotifyWrite: {
3579         compileNotifyWrite(node);
3580         break;
3581     }
3582 
3583     case ParseInt: {
3584         compileParseInt(node);
3585         break;
3586     }
3587 
3588     case CheckTypeInfoFlags: {
3589         compileCheckTypeInfoFlags(node);
3590         break;
3591     }
3592 
3593     case OverridesHasInstance: {
3594         compileOverridesHasInstance(node);
3595         break;
3596     }
3597 
3598     case InstanceOf: {
3599         compileInstanceOf(node);
3600         break;
3601     }
3602 
3603     case InstanceOfCustom: {
3604         compileInstanceOfCustom(node);
3605         break;
3606     }
3607 
3608     case IsEmpty: {
3609         JSValueOperand value(this, node-&gt;child1());
3610         GPRTemporary result(this, Reuse, value, TagWord);
3611         m_jit.comparePtr(JITCompiler::Equal, value.tagGPR(), TrustedImm32(JSValue::EmptyValueTag), result.gpr());
3612         booleanResult(result.gpr(), node);
3613         break;
3614     }
3615 
3616     case IsUndefined: {
3617         JSValueOperand value(this, node-&gt;child1());
3618         GPRTemporary result(this);
3619         GPRTemporary localGlobalObject(this);
3620         GPRTemporary remoteGlobalObject(this);
3621 
3622         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
3623 
3624         m_jit.compare32(JITCompiler::Equal, value.tagGPR(), TrustedImm32(JSValue::UndefinedTag), result.gpr());
3625         JITCompiler::Jump done = m_jit.jump();
3626 
3627         isCell.link(&amp;m_jit);
3628         JITCompiler::Jump notMasqueradesAsUndefined;
3629         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
3630             m_jit.move(TrustedImm32(0), result.gpr());
3631             notMasqueradesAsUndefined = m_jit.jump();
3632         } else {
3633             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
3634                 JITCompiler::NonZero,
3635                 JITCompiler::Address(value.payloadGPR(), JSCell::typeInfoFlagsOffset()),
3636                 TrustedImm32(MasqueradesAsUndefined));
3637             m_jit.move(TrustedImm32(0), result.gpr());
3638             notMasqueradesAsUndefined = m_jit.jump();
3639 
3640             isMasqueradesAsUndefined.link(&amp;m_jit);
3641             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
3642             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
3643             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
3644             m_jit.loadPtr(JITCompiler::Address(value.payloadGPR(), JSCell::structureIDOffset()), result.gpr());
3645             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
3646             m_jit.compare32(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
3647         }
3648 
3649         notMasqueradesAsUndefined.link(&amp;m_jit);
3650         done.link(&amp;m_jit);
3651         booleanResult(result.gpr(), node);
3652         break;
3653     }
3654 
3655     case IsUndefinedOrNull: {
3656         JSValueOperand value(this, node-&gt;child1());
3657         GPRTemporary result(this, Reuse, value, TagWord);
3658 
3659         GPRReg valueTagGPR = value.tagGPR();
3660         GPRReg resultGPR = result.gpr();
3661 
3662         m_jit.move(valueTagGPR, resultGPR);
3663         static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
3664         m_jit.or32(CCallHelpers::TrustedImm32(1), resultGPR);
3665         m_jit.compare32(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(JSValue::NullTag), resultGPR);
3666 
3667         booleanResult(resultGPR, node);
3668         break;
3669     }
3670 
3671 
3672     case IsBoolean: {
3673         JSValueOperand value(this, node-&gt;child1());
3674         GPRTemporary result(this, Reuse, value, TagWord);
3675 
3676         m_jit.compare32(JITCompiler::Equal, value.tagGPR(), JITCompiler::TrustedImm32(JSValue::BooleanTag), result.gpr());
3677         booleanResult(result.gpr(), node);
3678         break;
3679     }
3680 
3681     case IsNumber: {
3682         JSValueOperand value(this, node-&gt;child1());
3683         GPRTemporary result(this, Reuse, value, TagWord);
3684 
3685         m_jit.add32(TrustedImm32(1), value.tagGPR(), result.gpr());
3686         m_jit.compare32(JITCompiler::Below, result.gpr(), JITCompiler::TrustedImm32(JSValue::LowestTag + 1), result.gpr());
3687         booleanResult(result.gpr(), node);
3688         break;
3689     }
3690 
3691     case NumberIsInteger: {
3692         JSValueOperand input(this, node-&gt;child1());
3693         JSValueRegs inputRegs = input.jsValueRegs();
3694         flushRegisters();
3695         GPRFlushedCallResult result(this);
3696         GPRReg resultGPR = result.gpr();
3697         callOperation(operationNumberIsInteger, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), inputRegs);
3698         booleanResult(resultGPR, node);
3699         break;
3700     }
3701 
3702     case IsObject: {
3703         compileIsObject(node);
3704         break;
3705     }
3706 
3707     case IsObjectOrNull: {
3708         compileIsObjectOrNull(node);
3709         break;
3710     }
3711 
3712     case IsFunction: {
3713         compileIsFunction(node);
3714         break;
3715     }
3716 
3717     case IsCellWithType: {
3718         compileIsCellWithType(node);
3719         break;
3720     }
3721 
3722     case IsTypedArrayView: {
3723         compileIsTypedArrayView(node);
3724         break;
3725     }
3726 
3727     case TypeOf: {
3728         compileTypeOf(node);
3729         break;
3730     }
3731 
3732     case MapHash: {
3733         JSValueOperand input(this, node-&gt;child1());
3734 
3735         JSValueRegs inputRegs = input.jsValueRegs();
3736 
3737         flushRegisters();
3738         GPRFlushedCallResult result(this);
3739         GPRReg resultGPR = result.gpr();
3740         callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), inputRegs);
3741         m_jit.exceptionCheck();
3742         int32Result(resultGPR, node);
3743         break;
3744     }
3745 
3746     case NormalizeMapKey: {
3747         compileNormalizeMapKey(node);
3748         break;
3749     }
3750 
3751     case GetMapBucket: {
3752         SpeculateCellOperand map(this, node-&gt;child1());
3753         JSValueOperand key(this, node-&gt;child2());
3754         SpeculateInt32Operand hash(this, node-&gt;child3());
3755 
3756         GPRReg mapGPR = map.gpr();
3757         JSValueRegs keyRegs = key.jsValueRegs();
3758         GPRReg hashGPR = hash.gpr();
3759 
3760         if (node-&gt;child1().useKind() == MapObjectUse)
3761             speculateMapObject(node-&gt;child1(), mapGPR);
3762         else if (node-&gt;child1().useKind() == SetObjectUse)
3763             speculateSetObject(node-&gt;child1(), mapGPR);
3764         else
3765             RELEASE_ASSERT_NOT_REACHED();
3766 
3767         flushRegisters();
3768         GPRFlushedCallResult result(this);
3769         GPRReg resultGPR = result.gpr();
3770         if (node-&gt;child1().useKind() == MapObjectUse)
3771             callOperation(operationJSMapFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, hashGPR);
3772         else
3773             callOperation(operationJSSetFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, hashGPR);
3774         m_jit.exceptionCheck();
3775         cellResult(resultGPR, node);
3776         break;
3777     }
3778 
3779     case GetMapBucketHead:
3780         compileGetMapBucketHead(node);
3781         break;
3782 
3783     case GetMapBucketNext:
3784         compileGetMapBucketNext(node);
3785         break;
3786 
3787     case LoadKeyFromMapBucket:
3788         compileLoadKeyFromMapBucket(node);
3789         break;
3790 
3791     case LoadValueFromMapBucket:
3792         compileLoadValueFromMapBucket(node);
3793         break;
3794 
3795     case ExtractValueFromWeakMapGet:
3796         compileExtractValueFromWeakMapGet(node);
3797         break;
3798 
3799     case SetAdd:
3800         compileSetAdd(node);
3801         break;
3802 
3803     case MapSet:
3804         compileMapSet(node);
3805         break;
3806 
3807     case WeakMapGet:
3808         compileWeakMapGet(node);
3809         break;
3810 
3811     case WeakSetAdd:
3812         compileWeakSetAdd(node);
3813         break;
3814 
3815     case WeakMapSet:
3816         compileWeakMapSet(node);
3817         break;
3818 
3819     case Flush:
3820         break;
3821 
3822     case Call:
3823     case TailCall:
3824     case TailCallInlinedCaller:
3825     case Construct:
3826     case CallVarargs:
3827     case TailCallVarargs:
3828     case TailCallVarargsInlinedCaller:
3829     case ConstructVarargs:
3830     case CallForwardVarargs:
3831     case TailCallForwardVarargs:
3832     case TailCallForwardVarargsInlinedCaller:
3833     case ConstructForwardVarargs:
3834     case CallEval:
3835     case DirectCall:
3836     case DirectConstruct:
3837     case DirectTailCall:
3838     case DirectTailCallInlinedCaller:
3839         emitCall(node);
3840         break;
3841 
3842     case VarargsLength: {
3843         compileVarargsLength(node);
3844         break;
3845     }
3846 
3847     case LoadVarargs: {
3848         compileLoadVarargs(node);
3849         break;
3850     }
3851 
3852     case ForwardVarargs: {
3853         compileForwardVarargs(node);
3854         break;
3855     }
3856 
3857     case CreateActivation: {
3858         compileCreateActivation(node);
3859         break;
3860     }
3861 
3862     case PushWithScope: {
3863         compilePushWithScope(node);
3864         break;
3865     }
3866 
3867     case CreateDirectArguments: {
3868         compileCreateDirectArguments(node);
3869         break;
3870     }
3871 
3872     case GetFromArguments: {
3873         compileGetFromArguments(node);
3874         break;
3875     }
3876 
3877     case PutToArguments: {
3878         compilePutToArguments(node);
3879         break;
3880     }
3881 
3882     case GetArgument: {
3883         compileGetArgument(node);
3884         break;
3885     }
3886 
3887     case CreateScopedArguments: {
3888         compileCreateScopedArguments(node);
3889         break;
3890     }
3891 
3892     case CreateClonedArguments: {
3893         compileCreateClonedArguments(node);
3894         break;
3895     }
3896 
3897     case CreateArgumentsButterfly: {
3898         compileCreateArgumentsButterfly(node);
3899         break;
3900     }
3901 
3902     case CreateRest: {
3903         compileCreateRest(node);
3904         break;
3905     }
3906 
3907     case GetRestLength: {
3908         compileGetRestLength(node);
3909         break;
3910     }
3911 
3912     case NewFunction:
3913     case NewGeneratorFunction:
3914     case NewAsyncFunction:
3915     case NewAsyncGeneratorFunction:
3916         compileNewFunction(node);
3917         break;
3918 
3919     case SetFunctionName:
3920         compileSetFunctionName(node);
3921         break;
3922 
3923     case InById:
3924         compileInById(node);
3925         break;
3926 
3927     case InByVal:
3928         compileInByVal(node);
3929         break;
3930 
3931     case HasOwnProperty: {
3932         SpeculateCellOperand object(this, node-&gt;child1());
3933         GPRTemporary uniquedStringImpl(this);
3934         GPRTemporary temp(this);
3935         GPRTemporary hash(this);
3936         GPRTemporary structureID(this);
3937         GPRTemporary result(this);
3938 
3939         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
3940         Optional&lt;JSValueOperand&gt; keyAsValue;
3941         JSValueRegs keyRegs;
3942         if (node-&gt;child2().useKind() == UntypedUse) {
3943             keyAsValue.emplace(this, node-&gt;child2());
3944             keyRegs = keyAsValue-&gt;jsValueRegs();
3945         } else {
3946             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
3947             keyAsCell.emplace(this, node-&gt;child2());
3948             keyRegs = JSValueRegs::payloadOnly(keyAsCell-&gt;gpr());
3949         }
3950 
3951         GPRReg objectGPR = object.gpr();
3952         GPRReg implGPR = uniquedStringImpl.gpr();
3953         GPRReg tempGPR = temp.gpr();
3954         GPRReg hashGPR = hash.gpr();
3955         GPRReg structureIDGPR = structureID.gpr();
3956         GPRReg resultGPR = result.gpr();
3957 
3958         speculateObject(node-&gt;child1());
3959 
3960         MacroAssembler::JumpList slowPath;
3961         switch (node-&gt;child2().useKind()) {
3962         case SymbolUse: {
3963             speculateSymbol(node-&gt;child2(), keyRegs.payloadGPR());
3964             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3965             break;
3966         }
3967         case StringUse: {
3968             speculateString(node-&gt;child2(), keyRegs.payloadGPR());
3969             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3970             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3971             slowPath.append(m_jit.branchTest32(
3972                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
3973                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));
3974             break;
3975         }
3976         case UntypedUse: {
3977             slowPath.append(m_jit.branchIfNotCell(keyRegs));
3978             auto isNotString = m_jit.branchIfNotString(keyRegs.payloadGPR());
3979             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), JSString::offsetOfValue()), implGPR);
3980             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
3981             slowPath.append(m_jit.branchTest32(
3982                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
3983                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));
3984             auto hasUniquedImpl = m_jit.jump();
3985 
3986             isNotString.link(&amp;m_jit);
3987             slowPath.append(m_jit.branchIfNotSymbol(keyRegs.payloadGPR()));
3988             m_jit.loadPtr(MacroAssembler::Address(keyRegs.payloadGPR(), Symbol::offsetOfSymbolImpl()), implGPR);
3989 
3990             hasUniquedImpl.link(&amp;m_jit);
3991             break;
3992         }
3993         default:
3994             RELEASE_ASSERT_NOT_REACHED();
3995         }
3996 
3997         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero
3998         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
3999         // ever load the result from the cache if the cache entry matches what we are querying for.
4000         // So we either get super lucky and use zero for the hash and somehow collide with the entity
4001         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
4002         // slow path anyways.
4003         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
4004         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4005         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4006         m_jit.add32(structureIDGPR, hashGPR);
4007         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4008         m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
4009         ASSERT(vm().hasOwnPropertyCache());
4010         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);
4011         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4012             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4013         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4014         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4015         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4016         auto done = m_jit.jump();
4017 
4018         slowPath.link(&amp;m_jit);
4019         silentSpillAllRegisters(resultGPR);
4020         if (node-&gt;child2().useKind() != UntypedUse) {
4021             m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
4022             keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
4023         }
4024         callOperation(operationHasOwnProperty, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR, keyRegs);
4025         silentFillAllRegisters();
4026         m_jit.exceptionCheck();
4027 
4028         done.link(&amp;m_jit);
4029         booleanResult(resultGPR, node);
4030         break;
4031     }
4032 
4033     case StoreBarrier:
4034     case FencedStoreBarrier: {
4035         compileStoreBarrier(node);
4036         break;
4037     }
4038 
4039     case GetEnumerableLength: {
4040         compileGetEnumerableLength(node);
4041         break;
4042     }
4043     case HasGenericProperty: {
4044         compileHasGenericProperty(node);
4045         break;
4046     }
4047     case HasStructureProperty: {
4048         compileHasStructureProperty(node);
4049         break;
4050     }
4051     case HasIndexedProperty: {
4052         compileHasIndexedProperty(node);
4053         break;
4054     }
4055     case GetDirectPname: {
4056         compileGetDirectPname(node);
4057         break;
4058     }
4059     case GetPropertyEnumerator: {
4060         compileGetPropertyEnumerator(node);
4061         break;
4062     }
4063     case GetEnumeratorStructurePname:
4064     case GetEnumeratorGenericPname: {
4065         compileGetEnumeratorPname(node);
4066         break;
4067     }
4068     case ToIndexString: {
4069         compileToIndexString(node);
4070         break;
4071     }
4072     case ProfileType: {
4073         compileProfileType(node);
4074         break;
4075     }
4076     case ProfileControlFlow: {
4077         GPRTemporary scratch1(this);
4078         BasicBlockLocation* basicBlockLocation = node-&gt;basicBlockLocation();
4079         basicBlockLocation-&gt;emitExecuteCode(m_jit, scratch1.gpr());
4080         noResult(node);
4081         break;
4082     }
4083 
4084     case LogShadowChickenPrologue: {
4085         compileLogShadowChickenPrologue(node);
4086         break;
4087     }
4088 
4089     case LogShadowChickenTail: {
4090         compileLogShadowChickenTail(node);
4091         break;
4092     }
4093 
4094     case ForceOSRExit: {
4095         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4096         break;
4097     }
4098 
4099     case InvalidationPoint:
4100         emitInvalidationPoint(node);
4101         break;
4102 
4103     case CheckTraps:
4104         compileCheckTraps(node);
4105         break;
4106 
4107     case CountExecution:
4108         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4109         break;
4110 
4111     case SuperSamplerBegin:
4112         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4113         break;
4114 
4115     case SuperSamplerEnd:
4116         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4117         break;
4118 
4119     case Phantom:
4120     case Check:
4121     case CheckVarargs:
4122         DFG_NODE_DO_TO_CHILDREN(m_jit.graph(), node, speculate);
4123         noResult(node);
4124         break;
4125 
4126     case PhantomLocal:
4127     case LoopHint:
4128         // This is a no-op.
4129         noResult(node);
4130         break;
4131 
4132     case MaterializeNewObject:
4133         compileMaterializeNewObject(node);
4134         break;
4135 
4136     case PutDynamicVar: {
4137         compilePutDynamicVar(node);
4138         break;
4139     }
4140 
4141     case GetDynamicVar: {
4142         compileGetDynamicVar(node);
4143         break;
4144     }
4145 
4146     case ResolveScopeForHoistingFuncDeclInEval: {
4147         compileResolveScopeForHoistingFuncDeclInEval(node);
4148         break;
4149     }
4150 
4151     case ResolveScope: {
4152         compileResolveScope(node);
4153         break;
4154     }
4155 
4156     case CallDOM:
4157         compileCallDOM(node);
4158         break;
4159 
4160     case CallDOMGetter:
4161         compileCallDOMGetter(node);
4162         break;
4163 
4164     case CheckSubClass:
4165         compileCheckSubClass(node);
4166         break;
4167 
4168     case Unreachable:
4169         unreachable(node);
4170         break;
4171 
4172     case ExtractCatchLocal: {
4173         compileExtractCatchLocal(node);
4174         break;
4175     }
4176 
4177     case ClearCatchLocals:
4178         compileClearCatchLocals(node);
4179         break;
4180 
4181     case CheckStructureOrEmpty:
4182         DFG_CRASH(m_jit.graph(), node, &quot;CheckStructureOrEmpty only used in 64-bit DFG&quot;);
4183         break;
4184 
4185     case CheckArrayOrEmpty:
4186         DFG_CRASH(m_jit.graph(), node, &quot;CheckArrayOrEmpty only used in 64-bit DFG&quot;);
4187         break;
4188 
4189     case FilterCallLinkStatus:
4190     case FilterGetByStatus:
4191     case FilterPutByIdStatus:
4192     case FilterInByIdStatus:
4193         m_interpreter.filterICStatus(node);
4194         noResult(node);
4195         break;
4196 
4197     case LastNodeType:
4198     case Phi:
4199     case Upsilon:
4200     case ExtractOSREntryLocal:
4201     case CheckTierUpInLoop:
4202     case CheckTierUpAtReturn:
4203     case CheckTierUpAndOSREnter:
4204     case Int52Rep:
4205     case FiatInt52:
4206     case Int52Constant:
4207     case CheckInBounds:
4208     case ArithIMul:
4209     case MultiGetByOffset:
4210     case MultiPutByOffset:
4211     case CheckBadCell:
4212     case BottomValue:
4213     case PhantomNewObject:
4214     case PhantomNewFunction:
4215     case PhantomNewGeneratorFunction:
4216     case PhantomNewAsyncFunction:
4217     case PhantomNewAsyncGeneratorFunction:
4218     case PhantomCreateActivation:
4219     case PhantomNewArrayIterator:
4220     case PhantomNewRegexp:
4221     case PutHint:
4222     case CheckStructureImmediate:
4223     case MaterializeCreateActivation:
4224     case MaterializeNewInternalFieldObject:
4225     case PutStack:
4226     case KillStack:
4227     case GetStack:
4228     case GetMyArgumentByVal:
4229     case GetMyArgumentByValOutOfBounds:
4230     case GetVectorLength:
4231     case PhantomCreateRest:
4232     case PhantomSpread:
4233     case PhantomNewArrayWithSpread:
4234     case PhantomNewArrayBuffer:
4235     case AtomicsIsLockFree:
4236     case AtomicsAdd:
4237     case AtomicsAnd:
4238     case AtomicsCompareExchange:
4239     case AtomicsExchange:
4240     case AtomicsLoad:
4241     case AtomicsOr:
4242     case AtomicsStore:
4243     case AtomicsSub:
4244     case AtomicsXor:
4245     case IdentityWithProfile:
4246     case InitializeEntrypointArguments:
4247     case EntrySwitch:
4248     case CPUIntrinsic:
4249     case AssertNotEmpty:
4250     case DataViewGetInt:
4251     case DataViewGetFloat:
4252     case DataViewSet:
4253     case DateGetInt32OrNaN:
4254     case DateGetTime:
4255     case StringCodePointAt:
4256         DFG_CRASH(m_jit.graph(), node, &quot;unexpected node in DFG backend&quot;);
4257         break;
4258     }
4259 
4260     if (!m_compileOkay)
4261         return;
4262 
4263     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
4264         use(node);
4265 }
4266 
4267 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
4268 {
4269     m_jit.move(TrustedImm32(1), gpr);
4270 }
4271 
4272 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
4273 {
4274     m_jit.move(TrustedImm32(0), gpr);
4275 }
4276 
4277 void SpeculativeJIT::blessBoolean(GPRReg)
4278 {
4279 }
4280 
4281 void SpeculativeJIT::compileArithRandom(Node* node)
4282 {
4283     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
4284 
4285     flushRegisters();
4286 
4287     FPRResult result(this);
4288     callOperation(operationRandom, result.fpr(), globalObject);
4289     // operationRandom does not raise any exception.
4290     doubleResult(result.fpr(), node);
4291 }
4292 
4293 #endif
4294 
4295 } } // namespace JSC::DFG
4296 
4297 #endif
    </pre>
  </body>
</html>
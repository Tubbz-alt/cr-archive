diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperation.h b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperation.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperation.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMOperation.h
@@ -30,37 +30,37 @@
 
 template<typename JSClass>
 class IDLOperation {
 public:
     using ClassParameter = JSClass*;
-    using Operation = JSC::EncodedJSValue(JSC::ExecState*, ClassParameter, JSC::ThrowScope&);
-    using StaticOperation = JSC::EncodedJSValue(JSC::ExecState*, JSC::ThrowScope&);
+    using Operation = JSC::EncodedJSValue(JSC::JSGlobalObject*, JSC::CallFrame*, ClassParameter, JSC::ThrowScope&);
+    using StaticOperation = JSC::EncodedJSValue(JSC::JSGlobalObject*, JSC::CallFrame*, JSC::ThrowScope&);
 
-    static JSClass* cast(JSC::ExecState&);
+    static JSClass* cast(JSC::JSGlobalObject&, JSC::CallFrame&);
 
     template<Operation operation, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::Throw>
-    static JSC::EncodedJSValue call(JSC::ExecState& state, const char* operationName)
+    static JSC::EncodedJSValue call(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, const char* operationName)
     {
-        auto throwScope = DECLARE_THROW_SCOPE(state.vm());
+        auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(&lexicalGlobalObject));
 
-        auto* thisObject = cast(state);
+        auto* thisObject = cast(lexicalGlobalObject, callFrame);
         if (shouldThrow != CastedThisErrorBehavior::Assert && UNLIKELY(!thisObject))
-            return throwThisTypeError(state, throwScope, JSClass::info()->className, operationName);
+            return throwThisTypeError(lexicalGlobalObject, throwScope, JSClass::info()->className, operationName);
 
         ASSERT(thisObject);
         ASSERT_GC_OBJECT_INHERITS(thisObject, JSClass::info());
 
-        // FIXME: We should refactor the binding generated code to use references for state and thisObject.
-        return operation(&state, thisObject, throwScope);
+        // FIXME: We should refactor the binding generated code to use references for lexicalGlobalObject and thisObject.
+        return operation(&lexicalGlobalObject, &callFrame, thisObject, throwScope);
     }
 
     template<StaticOperation operation, CastedThisErrorBehavior shouldThrow = CastedThisErrorBehavior::Throw>
-    static JSC::EncodedJSValue callStatic(JSC::ExecState& state, const char*)
+    static JSC::EncodedJSValue callStatic(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, const char*)
     {
-        auto throwScope = DECLARE_THROW_SCOPE(state.vm());
+        auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(&lexicalGlobalObject));
 
-        // FIXME: We should refactor the binding generated code to use references for state.
-        return operation(&state, throwScope);
+        // FIXME: We should refactor the binding generated code to use references for lexicalGlobalObject.
+        return operation(&lexicalGlobalObject, &callFrame, throwScope);
     }
 };
 
 } // namespace WebCore

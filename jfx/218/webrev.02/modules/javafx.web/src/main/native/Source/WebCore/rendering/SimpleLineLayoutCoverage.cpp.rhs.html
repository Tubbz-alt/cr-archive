<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutCoverage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SimpleLineLayoutCoverage.h&quot;
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &quot;RenderBlockFlow.h&quot;
 31 #include &quot;RenderChildIterator.h&quot;
 32 #include &quot;RenderStyle.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &quot;Settings.h&quot;
 35 #include &quot;SimpleLineLayout.h&quot;
 36 #include &lt;wtf/text/TextStream.h&gt;
 37 
 38 namespace WebCore {
 39 namespace SimpleLineLayout {
 40 
 41 #ifndef NDEBUG
 42 static void printReason(AvoidanceReason reason, TextStream&amp; stream)
 43 {
 44     switch (reason) {
 45     case FlowIsInsideANonMultiColumnThread:
 46         stream &lt;&lt; &quot;flow is inside a non-multicolumn container&quot;;
 47         break;
 48     case FlowHasHorizonalWritingMode:
 49         stream &lt;&lt; &quot;horizontal writing mode&quot;;
 50         break;
 51     case FlowHasOutline:
 52         stream &lt;&lt; &quot;outline&quot;;
 53         break;
 54     case FlowIsRuby:
 55         stream &lt;&lt; &quot;ruby&quot;;
 56         break;
 57     case FlowHasHangingPunctuation:
 58         stream &lt;&lt; &quot;hanging punctuation&quot;;
 59         break;
 60     case FlowIsPaginated:
 61         stream &lt;&lt; &quot;paginated&quot;;
 62         break;
 63     case FlowHasTextOverflow:
 64         stream &lt;&lt; &quot;text-overflow&quot;;
 65         break;
 66     case FlowIsDepricatedFlexBox:
 67         stream &lt;&lt; &quot;depricatedFlexBox&quot;;
 68         break;
 69     case FlowParentIsPlaceholderElement:
 70         stream &lt;&lt; &quot;placeholder element&quot;;
 71         break;
 72     case FlowParentIsTextAreaWithWrapping:
 73         stream &lt;&lt; &quot;wrapping textarea&quot;;
 74         break;
 75     case FlowHasNonSupportedChild:
 76         stream &lt;&lt; &quot;nested renderers&quot;;
 77         break;
 78     case FlowHasUnsupportedFloat:
 79         stream &lt;&lt; &quot;complicated float&quot;;
 80         break;
 81     case FlowHasUnsupportedUnderlineDecoration:
 82         stream &lt;&lt; &quot;text-underline-position: under&quot;;
 83         break;
 84     case FlowHasJustifiedNonLatinText:
 85         stream &lt;&lt; &quot;text-align: justify with non-latin text&quot;;
 86         break;
 87     case FlowHasOverflowNotVisible:
 88         stream &lt;&lt; &quot;overflow: hidden | scroll | auto&quot;;
 89         break;
 90     case FlowHasWebKitNBSPMode:
 91         stream &lt;&lt; &quot;-webkit-nbsp-mode: space&quot;;
 92         break;
 93     case FlowIsNotLTR:
 94         stream &lt;&lt; &quot;dir is not LTR&quot;;
 95         break;
 96     case FlowHasLineBoxContainProperty:
 97         stream &lt;&lt; &quot;line-box-contain value indicates variable line height&quot;;
 98         break;
 99     case FlowIsNotTopToBottom:
100         stream &lt;&lt; &quot;non top-to-bottom flow&quot;;
101         break;
102     case FlowHasLineBreak:
103         stream &lt;&lt; &quot;line-break property&quot;;
104         break;
105     case FlowHasNonNormalUnicodeBiDi:
106         stream &lt;&lt; &quot;non-normal Unicode bidi&quot;;
107         break;
108     case FlowHasRTLOrdering:
109         stream &lt;&lt; &quot;-webkit-rtl-ordering&quot;;
110         break;
111     case FlowHasLineAlignEdges:
112         stream &lt;&lt; &quot;-webkit-line-align edges&quot;;
113         break;
114     case FlowHasLineSnap:
115         stream &lt;&lt; &quot;-webkit-line-snap property&quot;;
116         break;
117     case FlowHasTextEmphasisFillOrMark:
118         stream &lt;&lt; &quot;text-emphasis (fill/mark)&quot;;
119         break;
120     case FlowHasPseudoFirstLine:
121         stream &lt;&lt; &quot;first-line&quot;;
122         break;
123     case FlowHasPseudoFirstLetter:
124         stream &lt;&lt; &quot;first-letter&quot;;
125         break;
126     case FlowHasTextCombine:
127         stream &lt;&lt; &quot;text combine&quot;;
128         break;
129     case FlowHasTextFillBox:
130         stream &lt;&lt; &quot;background-color (text-fill)&quot;;
131         break;
132     case FlowHasBorderFitLines:
133         stream &lt;&lt; &quot;-webkit-border-fit&quot;;
134         break;
135     case FlowHasNonAutoLineBreak:
136         stream &lt;&lt; &quot;line-break is not auto&quot;;
137         break;
138     case FlowHasSVGFont:
139         stream &lt;&lt; &quot;SVG font&quot;;
140         break;
141     case FlowTextHasSoftHyphen:
142         stream &lt;&lt; &quot;soft hyphen character&quot;;
143         break;
144     case FlowTextHasDirectionCharacter:
145         stream &lt;&lt; &quot;direction character&quot;;
146         break;
147     case FlowIsMissingPrimaryFont:
148         stream &lt;&lt; &quot;missing primary font&quot;;
149         break;
150     case FlowPrimaryFontIsInsufficient:
151         stream &lt;&lt; &quot;missing glyph or glyph needs another font&quot;;
152         break;
153     case FlowTextIsCombineText:
154         stream &lt;&lt; &quot;text is combine&quot;;
155         break;
156     case FlowTextIsRenderCounter:
157         stream &lt;&lt; &quot;unsupported RenderCounter&quot;;
158         break;
159     case FlowTextIsRenderQuote:
160         stream &lt;&lt; &quot;unsupported RenderQuote&quot;;
161         break;
162     case FlowTextIsTextFragment:
163         stream &lt;&lt; &quot;unsupported TextFragment&quot;;
164         break;
165     case FlowTextIsSVGInlineText:
166         stream &lt;&lt; &quot;unsupported SVGInlineText&quot;;
167         break;
168     case FlowHasComplexFontCodePath:
169         stream &lt;&lt; &quot;text with complex font codepath&quot;;
170         break;
171     case FlowHasTextShadow:
172         stream &lt;&lt; &quot;text-shadow&quot;;
173         break;
174     case FlowChildIsSelected:
175         stream &lt;&lt; &quot;selected content&quot;;
176         break;
177     case FlowFontHasOverflowGlyph:
178         stream &lt;&lt; &quot;-webkit-line-box-contain: glyphs with overflowing text.&quot;;
179         break;
180     case FlowTextHasSurrogatePair:
181         stream &lt;&lt; &quot;surrogate pair&quot;;
182         break;
183     case MultiColumnFlowIsNotTopLevel:
184         stream &lt;&lt; &quot;non top level column&quot;;
185         break;
186     case MultiColumnFlowHasColumnSpanner:
187         stream &lt;&lt; &quot;column has spanner&quot;;
188         break;
189     case MultiColumnFlowVerticalAlign:
190         stream &lt;&lt; &quot;column with vertical-align != baseline&quot;;
191         break;
192     case MultiColumnFlowIsFloating:
193         stream &lt;&lt; &quot;column with floating objects&quot;;
194         break;
195     case FlowIncludesDocumentMarkers:
196         stream &lt;&lt; &quot;text includes document markers&quot;;
197         break;
198     case FlowTextIsEmpty:
199     case FlowHasNoChild:
200     case FlowHasNoParent:
201     case FeatureIsDisabled:
202     default:
203         break;
204     }
205 }
206 
207 static void printReasons(AvoidanceReasonFlags reasons, TextStream&amp; stream)
208 {
209     bool first = true;
210     for (auto reasonItem = EndOfReasons &gt;&gt; 1; reasonItem != NoReason; reasonItem &gt;&gt;= 1) {
211         if (!(reasons &amp; reasonItem))
212             continue;
213         stream &lt;&lt; (first ? &quot; &quot; : &quot;, &quot;);
214         first = false;
215         printReason(reasonItem, stream);
216     }
217 }
218 
219 static void printTextForSubtree(const RenderObject&amp; renderer, unsigned&amp; charactersLeft, TextStream&amp; stream)
220 {
221     if (!charactersLeft)
222         return;
223     if (is&lt;RenderText&gt;(renderer)) {
224         String text = downcast&lt;RenderText&gt;(renderer).text();
225         text = text.stripWhiteSpace();
226         unsigned len = std::min(charactersLeft, text.length());
227         stream &lt;&lt; text.left(len);
228         charactersLeft -= len;
229         return;
230     }
231     if (!is&lt;RenderElement&gt;(renderer))
232         return;
233     for (const auto* child = downcast&lt;RenderElement&gt;(renderer).firstChild(); child; child = child-&gt;nextSibling())
234         printTextForSubtree(*child, charactersLeft, stream);
235 }
236 
237 static unsigned textLengthForSubtree(const RenderObject&amp; renderer)
238 {
239     if (is&lt;RenderText&gt;(renderer))
240         return downcast&lt;RenderText&gt;(renderer).text().length();
241     if (!is&lt;RenderElement&gt;(renderer))
242         return 0;
243     unsigned textLength = 0;
244     for (const auto* child = downcast&lt;RenderElement&gt;(renderer).firstChild(); child; child = child-&gt;nextSibling())
245         textLength += textLengthForSubtree(*child);
246     return textLength;
247 }
248 
249 static void collectNonEmptyLeafRenderBlockFlows(const RenderObject&amp; renderer, HashSet&lt;const RenderBlockFlow*&gt;&amp; leafRenderers)
250 {
251     if (is&lt;RenderText&gt;(renderer)) {
252         if (!downcast&lt;RenderText&gt;(renderer).text().length())
253             return;
254         // Find RenderBlockFlow ancestor.
255         for (const auto* current = renderer.parent(); current; current = current-&gt;parent()) {
256             if (!is&lt;RenderBlockFlow&gt;(current))
257                 continue;
258             leafRenderers.add(downcast&lt;RenderBlockFlow&gt;(current));
259             break;
260         }
261         return;
262     }
263     if (!is&lt;RenderElement&gt;(renderer))
264         return;
265     for (const auto* child = downcast&lt;RenderElement&gt;(renderer).firstChild(); child; child = child-&gt;nextSibling())
266         collectNonEmptyLeafRenderBlockFlows(*child, leafRenderers);
267 }
268 
269 static void collectNonEmptyLeafRenderBlockFlowsForCurrentPage(HashSet&lt;const RenderBlockFlow*&gt;&amp; leafRenderers)
270 {
271     for (const auto* document : Document::allDocuments()) {
<a name="1" id="anc1"></a><span class="line-modified">272         if (!document-&gt;renderView() || document-&gt;backForwardCacheState() != Document::NotInBackForwardCache)</span>
273             continue;
274         if (!document-&gt;isHTMLDocument() &amp;&amp; !document-&gt;isXHTMLDocument())
275             continue;
276         collectNonEmptyLeafRenderBlockFlows(*document-&gt;renderView(), leafRenderers);
277     }
278 }
279 
280 void toggleSimpleLineLayout()
281 {
282     for (auto* document : Document::allDocuments()) {
283         auto&amp; settings = document-&gt;mutableSettings();
284         settings.setSimpleLineLayoutEnabled(!settings.simpleLineLayoutEnabled());
285     }
286 }
287 
288 void printSimpleLineLayoutBlockList()
289 {
290     HashSet&lt;const RenderBlockFlow*&gt; leafRenderers;
291     collectNonEmptyLeafRenderBlockFlowsForCurrentPage(leafRenderers);
292     if (!leafRenderers.size()) {
293         WTFLogAlways(&quot;No text found in this document\n&quot;);
294         return;
295     }
296     TextStream stream;
297     stream &lt;&lt; &quot;---------------------------------------------------\n&quot;;
298     for (const auto* flow : leafRenderers) {
299         auto reason = canUseForWithReason(*flow, IncludeReasons::All);
300         if (reason == NoReason)
301             continue;
302         unsigned printedLength = 30;
303         stream &lt;&lt; &quot;\&quot;&quot;;
304         printTextForSubtree(*flow, printedLength, stream);
305         for (;printedLength &gt; 0; --printedLength)
306             stream &lt;&lt; &quot; &quot;;
307         stream &lt;&lt; &quot;\&quot;(&quot; &lt;&lt; textLengthForSubtree(*flow) &lt;&lt; &quot;):&quot;;
308         printReasons(reason, stream);
309         stream &lt;&lt; &quot;\n&quot;;
310     }
311     stream &lt;&lt; &quot;---------------------------------------------------\n&quot;;
312     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
313 }
314 
315 void printSimpleLineLayoutCoverage()
316 {
317     HashSet&lt;const RenderBlockFlow*&gt; leafRenderers;
318     collectNonEmptyLeafRenderBlockFlowsForCurrentPage(leafRenderers);
319     if (!leafRenderers.size()) {
320         WTFLogAlways(&quot;No text found in this document\n&quot;);
321         return;
322     }
323     TextStream stream;
324     HashMap&lt;AvoidanceReason, unsigned&gt; flowStatistics;
325     unsigned textLength = 0;
326     unsigned unsupportedTextLength = 0;
327     unsigned numberOfUnsupportedLeafBlocks = 0;
328     unsigned supportedButForcedToLineLayoutTextLength = 0;
329     unsigned numberOfSupportedButForcedToLineLayoutLeafBlocks = 0;
330     for (const auto* flow : leafRenderers) {
331         auto flowLength = textLengthForSubtree(*flow);
332         textLength += flowLength;
333         auto reasons = canUseForWithReason(*flow, IncludeReasons::All);
334         if (reasons == NoReason) {
335             if (flow-&gt;lineLayoutPath() == RenderBlockFlow::ForceLineBoxesPath) {
336                 supportedButForcedToLineLayoutTextLength += flowLength;
337                 ++numberOfSupportedButForcedToLineLayoutLeafBlocks;
338             }
339             continue;
340         }
341         ++numberOfUnsupportedLeafBlocks;
342         unsupportedTextLength += flowLength;
343         for (auto reasonItem = EndOfReasons &gt;&gt; 1; reasonItem != NoReason; reasonItem &gt;&gt;= 1) {
344             if (!(reasons &amp; reasonItem))
345                 continue;
346             auto result = flowStatistics.add(reasonItem, flowLength);
347             if (!result.isNewEntry)
348                 result.iterator-&gt;value += flowLength;
349         }
350     }
351     stream &lt;&lt; &quot;---------------------------------------------------\n&quot;;
352     stream &lt;&lt; &quot;Number of blocks: total(&quot; &lt;&lt;  leafRenderers.size() &lt;&lt; &quot;) non-simple(&quot; &lt;&lt; numberOfUnsupportedLeafBlocks &lt;&lt; &quot;)\nContent length: total(&quot; &lt;&lt;
353         textLength &lt;&lt; &quot;) non-simple(&quot; &lt;&lt; unsupportedTextLength &lt;&lt; &quot;)\n&quot;;
354     for (const auto&amp; reasonEntry : flowStatistics) {
355         printReason(reasonEntry.key, stream);
356         stream &lt;&lt; &quot;: &quot; &lt;&lt; (float)reasonEntry.value / (float)textLength * 100 &lt;&lt; &quot;%\n&quot;;
357     }
358     if (supportedButForcedToLineLayoutTextLength) {
359         stream &lt;&lt; &quot;Simple line layout potential coverage: &quot; &lt;&lt; (float)(textLength - unsupportedTextLength) / (float)textLength * 100 &lt;&lt; &quot;%\n\n&quot;;
360         stream &lt;&lt; &quot;Simple line layout actual coverage: &quot; &lt;&lt; (float)(textLength - unsupportedTextLength - supportedButForcedToLineLayoutTextLength) / (float)textLength * 100 &lt;&lt; &quot;%\nForced line layout blocks: &quot; &lt;&lt; numberOfSupportedButForcedToLineLayoutLeafBlocks &lt;&lt; &quot; content length: &quot; &lt;&lt; supportedButForcedToLineLayoutTextLength &lt;&lt; &quot;(&quot; &lt;&lt; (float)supportedButForcedToLineLayoutTextLength / (float)textLength * 100 &lt;&lt; &quot;%)&quot;;
361     } else
362         stream &lt;&lt; &quot;Simple line layout coverage: &quot; &lt;&lt; (float)(textLength - unsupportedTextLength) / (float)textLength * 100 &lt;&lt; &quot;%&quot;;
363     stream &lt;&lt; &quot;\n---------------------------------------------------\n&quot;;
364     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
365 }
366 #endif
367 
368 }
369 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
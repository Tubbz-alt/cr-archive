<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegistrationDatabase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  26 #include &quot;config.h&quot;
  27 #include &quot;SWServer.h&quot;
  28 
  29 #if ENABLE(SERVICE_WORKER)
  30 
  31 #include &quot;ExceptionCode.h&quot;
  32 #include &quot;ExceptionData.h&quot;
  33 #include &quot;Logging.h&quot;
  34 #include &quot;RegistrationStore.h&quot;
  35 #include &quot;SWOriginStore.h&quot;
  36 #include &quot;SWServerJobQueue.h&quot;
  37 #include &quot;SWServerRegistration.h&quot;
  38 #include &quot;SWServerToContextConnection.h&quot;
  39 #include &quot;SWServerWorker.h&quot;
  40 #include &quot;SecurityOrigin.h&quot;
  41 #include &quot;ServiceWorkerClientType.h&quot;
  42 #include &quot;ServiceWorkerContextData.h&quot;
  43 #include &quot;ServiceWorkerFetchResult.h&quot;
  44 #include &quot;ServiceWorkerJobData.h&quot;
  45 #include &lt;wtf/CompletionHandler.h&gt;

  46 #include &lt;wtf/NeverDestroyed.h&gt;
  47 #include &lt;wtf/text/WTFString.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 static Seconds terminationDelay { 10_s };
  52 
<span class="line-modified">  53 SWServer::Connection::Connection(SWServer&amp; server)</span>
  54     : m_server(server)
<span class="line-modified">  55     , m_identifier(SWServerConnectionIdentifier::generate())</span>
  56 {
  57 }
  58 
  59 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
  60 {
  61     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
  62     return servers;
  63 }
  64 
  65 SWServer::~SWServer()
  66 {
  67     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
  68     // to the server and since they try to unregister clients from the server in their destructor.
  69     auto connections = WTFMove(m_connections);
  70     connections.clear();
  71 



  72     Vector&lt;SWServerWorker*&gt; runningWorkers;
  73     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
  74         if (worker-&gt;isRunning())
  75             runningWorkers.append(worker.ptr());
  76     }
  77     for (auto&amp; runningWorker : runningWorkers)
  78         terminateWorker(*runningWorker);
  79 
  80     allServers().remove(this);
  81 }
  82 
  83 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
  84 {
  85     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
  86     ASSERT(!worker || worker-&gt;server() == this);
  87     return worker;
  88 }
  89 
  90 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
  91 {
</pre>
<hr />
<pre>
  94         return WTF::nullopt;
  95 
  96     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
  97         return WTF::nullopt;
  98 
  99     auto clientIterator = m_clientsById.find(clientIdentifier);
 100     ASSERT(clientIterator != m_clientsById.end());
 101     return clientIterator-&gt;value;
 102 }
 103 
 104 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
 105 {
 106     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 107     if (iterator == m_clientIdentifiersPerOrigin.end())
 108         return String();
 109     return iterator-&gt;value.userAgent;
 110 }
 111 
 112 SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
 113 {
<span class="line-modified"> 114     auto* registration = m_registrationsByID.get(identifier);</span>
 115     return registration ? registration-&gt;activeWorker() : nullptr;
 116 }
 117 
 118 SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
 119 {
<span class="line-modified"> 120     return m_registrations.get(registrationKey);</span>
 121 }
 122 
 123 void SWServer::registrationStoreImportComplete()
 124 {
 125     ASSERT(!m_importCompleted);
 126     m_importCompleted = true;
 127     m_originStore-&gt;importComplete();
 128 
 129     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
 130     for (auto&amp; callback : clearCallbacks)
 131         callback();
 132 
 133     performGetOriginsWithRegistrationsCallbacks();



 134 }
 135 







 136 void SWServer::registrationStoreDatabaseFailedToOpen()
 137 {
 138     if (!m_importCompleted)
 139         registrationStoreImportComplete();
 140 }
 141 
 142 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
 143 {
 144     // Pages should not have been able to make a new registration to this key while the import was still taking place.
<span class="line-modified"> 145     ASSERT(!m_registrations.contains(data.registration.key));</span>
 146 
 147     auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
 148     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
 149     auto registrationPtr = registration.get();
 150     addRegistration(WTFMove(registration));
 151 
 152     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, WTFMove(data.scriptResourceMap));
 153     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
 154     worker-&gt;setState(ServiceWorkerState::Activated);
 155 }
 156 
 157 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
 158 {
<span class="line-modified"> 159     auto key = registration-&gt;key();</span>
<span class="line-modified"> 160     auto* registrationPtr = registration.get();</span>
<span class="line-modified"> 161     auto addResult1 = m_registrations.add(key, WTFMove(registration));</span>


 162     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
<span class="line-removed"> 163 </span>
<span class="line-removed"> 164     auto addResult2 = m_registrationsByID.add(registrationPtr-&gt;identifier(), registrationPtr);</span>
<span class="line-removed"> 165     ASSERT_UNUSED(addResult2, addResult2.isNewEntry);</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167     m_originStore-&gt;add(key.topOrigin());</span>
 168 }
 169 
<span class="line-modified"> 170 void SWServer::removeRegistration(const ServiceWorkerRegistrationKey&amp; key)</span>
 171 {
<span class="line-modified"> 172     auto topOrigin = key.topOrigin();</span>
<span class="line-removed"> 173     auto registration = m_registrations.take(key);</span>
 174     ASSERT(registration);
<span class="line-removed"> 175     bool wasRemoved = m_registrationsByID.remove(registration-&gt;identifier());</span>
<span class="line-removed"> 176     ASSERT_UNUSED(wasRemoved, wasRemoved);</span>
 177 
<span class="line-modified"> 178     m_originStore-&gt;remove(topOrigin);</span>




 179     if (m_registrationStore)
<span class="line-modified"> 180         m_registrationStore-&gt;removeRegistration(key);</span>
 181 }
 182 
 183 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 184 {
 185     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
<span class="line-modified"> 186     for (auto&amp; item : m_registrations) {</span>
<span class="line-modified"> 187         if (!item.value-&gt;isUninstalling() &amp;&amp; item.key.originIsMatching(topOrigin, clientURL))</span>
<span class="line-modified"> 188             matchingRegistrations.append(item.value.get());</span>




 189     }
 190     // The specification mandates that registrations are returned in the insertion order.
 191     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
 192         return a-&gt;creationTime() &lt; b-&gt;creationTime();
 193     });
 194     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
 195     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
 196     for (auto* registration : matchingRegistrations)
 197         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
 198     return matchingRegistrationDatas;
 199 }
 200 
 201 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 202 {
 203     if (!m_importCompleted) {
 204         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
 205             ASSERT(m_importCompleted);
 206             clearAll(WTFMove(completionHandler));
 207         });
 208         return;
 209     }
 210 
 211     m_jobQueues.clear();
 212     while (!m_registrations.isEmpty())
 213         m_registrations.begin()-&gt;value-&gt;clear();
<span class="line-removed"> 214     ASSERT(m_registrationsByID.isEmpty());</span>
 215     m_pendingContextDatas.clear();
 216     m_originStore-&gt;clearAll();
 217     if (m_registrationStore)
 218         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
 219 }
 220 
 221 void SWServer::startSuspension(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 222 {
 223     if (!m_registrationStore) {
 224         completionHandler();
 225         return;
 226     }
 227     m_registrationStore-&gt;startSuspension(WTFMove(completionHandler));
 228 }
 229 
 230 void SWServer::endSuspension()
 231 {
 232     if (m_registrationStore)
 233         m_registrationStore-&gt;endSuspension();
 234 }
 235 
 236 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 237 {
 238     if (!m_importCompleted) {
 239         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
 240             ASSERT(m_importCompleted);
 241             clear(securityOrigin, WTFMove(completionHandler));
 242         });
 243         return;
 244     }
 245 
 246     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
 247         return keyAndValue.key.relatesToOrigin(securityOrigin);
 248     });
 249 
 250     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
<span class="line-modified"> 251     for (auto&amp; keyAndValue : m_registrations) {</span>
<span class="line-modified"> 252         if (keyAndValue.key.relatesToOrigin(securityOrigin))</span>
<span class="line-modified"> 253             registrationsToRemove.append(keyAndValue.value.get());</span>
 254     }
 255 
 256     for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
 257         contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
 258             return contextData.registration.key.relatesToOrigin(securityOrigin);
 259         });
 260     }
 261 
 262     if (registrationsToRemove.isEmpty()) {
 263         completionHandler();
 264         return;
 265     }
 266 
 267     // Calling SWServerRegistration::clear() takes care of updating m_registrations, m_originStore and m_registrationStore.
 268     for (auto* registration : registrationsToRemove)
 269         registration-&gt;clear();
 270 
 271     if (m_registrationStore)
 272         m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
 273 }
 274 
 275 void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
 276 {
<span class="line-modified"> 277     m_server.scriptFetchFinished(*this, result);</span>
 278 }
 279 
 280 void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
 281 {
<span class="line-modified"> 282     m_server.didResolveRegistrationPromise(*this, key);</span>
 283 }
 284 
 285 void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 286 {
 287     m_server.addClientServiceWorkerRegistration(*this, identifier);
 288 }
 289 
 290 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 291 {
 292     m_server.removeClientServiceWorkerRegistration(*this, identifier);
 293 }
 294 
 295 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
 296 {
 297     if (auto* worker = m_server.workerByID(identifier))
 298         m_server.syncTerminateWorker(*worker);
 299 }
 300 
<span class="line-modified"> 301 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID)</span>
 302     : m_originStore(WTFMove(originStore))
 303     , m_sessionID(sessionID)



 304 {
<span class="line-modified"> 305     ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());</span>
 306     if (!m_sessionID.isEphemeral())
 307         m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
 308     else
 309         registrationStoreImportComplete();
 310 
 311     UNUSED_PARAM(registrationDatabaseDirectory);
 312     allServers().add(this);
 313 }
 314 
 315 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
 316 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
 317 {
<span class="line-modified"> 318     ASSERT(m_connections.contains(jobData.connectionIdentifier()));</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.</span>
<span class="line-removed"> 321     // If it is, stack it along with that job.</span>
 322 
 323     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
 324         return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
 325     }).iterator-&gt;value;
 326 
<span class="line-modified"> 327     jobQueue.enqueueJob(jobData);</span>













 328     if (jobQueue.size() == 1)
 329         jobQueue.runNextJob();
 330 }
 331 
 332 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
 333 {
 334     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
 335     auto* connection = m_connections.get(jobData.connectionIdentifier());
 336     if (!connection)
 337         return;
 338 
 339     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
 340 }
 341 
 342 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 343 {
 344     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
 345     auto* connection = m_connections.get(jobData.connectionIdentifier());
<span class="line-modified"> 346     if (!connection)</span>


 347         return;

 348 
 349     connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
 350 }
 351 
 352 void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
 353 {
 354     auto* connection = m_connections.get(jobData.connectionIdentifier());
 355     if (!connection)
 356         return;
 357 
 358     connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
 359 }
 360 
<span class="line-modified"> 361 void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, FetchOptions::Cache cachePolicy)</span>










 362 {
 363     LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
 364     auto* connection = m_connections.get(jobData.connectionIdentifier());





























 365     ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);
<span class="line-removed"> 366     if (connection)</span>
<span class="line-removed"> 367         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), cachePolicy);</span>
 368 }
 369 
<span class="line-modified"> 370 void SWServer::scriptFetchFinished(Connection&amp; connection, const ServiceWorkerFetchResult&amp; result)</span>
 371 {
 372     LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
 373 
<span class="line-modified"> 374     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier));</span>
 375 
 376     auto jobQueue = m_jobQueues.get(result.registrationKey);
 377     if (!jobQueue)
 378         return;
 379 
<span class="line-modified"> 380     jobQueue-&gt;scriptFetchFinished(connection, result);</span>
 381 }
 382 
 383 void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
 384 {
 385     if (!jobDataIdentifier)
 386         return;
 387 
 388     RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::scriptContextFailedToStart: Failed to start SW for job %s, error: %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data(), message.utf8().data());
 389 
 390     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
 391     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
 392         // The job which started this worker has been canceled, terminate this worker.
 393         terminatePreinstallationWorker(worker);
 394         return;
 395     }
 396     jobQueue-&gt;scriptContextFailedToStart(*jobDataIdentifier, worker.identifier(), message);
 397 }
 398 
 399 void SWServer::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker)
 400 {
 401     if (!jobDataIdentifier)
 402         return;
 403 
 404     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
 405     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
 406         // The job which started this worker has been canceled, terminate this worker.
 407         terminatePreinstallationWorker(worker);
 408         return;
 409     }
 410     jobQueue-&gt;scriptContextStarted(*jobDataIdentifier, worker.identifier());
 411 }
 412 
 413 void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
 414 {
 415     worker.terminate();
<span class="line-modified"> 416     auto* registration = getRegistration(worker.registrationKey());</span>
 417     if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
 418         registration-&gt;setPreInstallationWorker(nullptr);
 419 }
 420 
 421 void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
 422 {
 423     if (!jobDataIdentifier)
 424         return;
 425 
 426     if (wasSuccessful)
 427         RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
 428     else
 429         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
 430 
 431     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
<span class="line-modified"> 432         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker.identifier(), wasSuccessful);</span>
 433 }
 434 
 435 void SWServer::didFinishActivation(SWServerWorker&amp; worker)
 436 {
 437     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
 438 
<span class="line-modified"> 439     auto* registration = getRegistration(worker.registrationKey());</span>
 440     if (!registration)
 441         return;
 442 
 443     if (m_registrationStore)
 444         m_registrationStore-&gt;updateRegistration(worker.contextData());
 445     registration-&gt;didFinishActivation(worker.identifier());
 446 }
 447 
 448 // https://w3c.github.io/ServiceWorker/#clients-getall
 449 void SWServer::matchAll(SWServerWorker&amp; worker, const ServiceWorkerClientQueryOptions&amp; options, ServiceWorkerClientsMatchAllCallback&amp;&amp; callback)
 450 {
 451     // FIXME: Support reserved client filtering.
 452     // FIXME: Support WindowClient additional properties.
 453 
 454     Vector&lt;ServiceWorkerClientData&gt; matchingClients;
 455     forEachClientForOrigin(worker.origin(), [&amp;](auto&amp; clientData) {
 456         if (!options.includeUncontrolled) {
 457             auto registrationIdentifier = m_clientToControllingRegistration.get(clientData.identifier);
 458             if (worker.data().registrationIdentifier != registrationIdentifier)
 459                 return;
</pre>
<hr />
<pre>
 477         auto clientIterator = m_clientsById.find(clientIdentifier);
 478         ASSERT(clientIterator != m_clientsById.end());
 479         apply(clientIterator-&gt;value);
 480     }
 481 }
 482 
 483 void SWServer::claim(SWServerWorker&amp; worker)
 484 {
 485     auto&amp; origin = worker.origin();
 486     forEachClientForOrigin(origin, [&amp;](auto&amp; clientData) {
 487         auto* registration = this-&gt;doRegistrationMatching(origin.topOrigin, clientData.url);
 488         if (!(registration &amp;&amp; registration-&gt;key() == worker.registrationKey()))
 489             return;
 490 
 491         auto result = m_clientToControllingRegistration.add(clientData.identifier, registration-&gt;identifier());
 492         if (!result.isNewEntry) {
 493             auto previousIdentifier = result.iterator-&gt;value;
 494             if (previousIdentifier == registration-&gt;identifier())
 495                 return;
 496             result.iterator-&gt;value = registration-&gt;identifier();
<span class="line-modified"> 497             if (auto* controllingRegistration = m_registrationsByID.get(previousIdentifier))</span>
 498                 controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
 499         }
 500         registration-&gt;controlClient(clientData.identifier);
 501     });
 502 }
 503 
<span class="line-modified"> 504 void SWServer::didResolveRegistrationPromise(Connection&amp; connection, const ServiceWorkerRegistrationKey&amp; registrationKey)</span>
 505 {
<span class="line-modified"> 506     ASSERT_UNUSED(connection, m_connections.contains(connection.identifier()));</span>
 507 
 508     if (auto* jobQueue = m_jobQueues.get(registrationKey))
 509         jobQueue-&gt;didResolveRegistrationPromise();
 510 }
 511 
 512 void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
 513 {
<span class="line-modified"> 514     auto* registration = m_registrationsByID.get(identifier);</span>
 515     if (!registration) {
 516         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
 517         return;
 518     }
 519 
 520     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
 521 }
 522 
 523 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
 524 {
<span class="line-modified"> 525     if (auto* registration = m_registrationsByID.get(identifier))</span>
 526         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
 527 }
 528 
<span class="line-modified"> 529 void SWServer::updateWorker(Connection&amp;, const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)</span>
 530 {
<span class="line-modified"> 531     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });</span>
 532 }
 533 
 534 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
 535 {
 536     RegistrableDomain registrableDomain(data.scriptURL);
<span class="line-modified"> 537     auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(registrableDomain);</span>
 538     if (!connection) {
<span class="line-modified"> 539         m_pendingContextDatas.ensure(WTFMove(registrableDomain), [] {</span>
 540             return Vector&lt;ServiceWorkerContextData&gt; { };
 541         }).iterator-&gt;value.append(WTFMove(data));


 542         return;
 543     }
 544 
 545     installContextData(data);
 546 }
 547 
<span class="line-modified"> 548 void SWServer::serverToContextConnectionCreated(SWServerToContextConnection&amp; contextConnection)</span>
 549 {
 550     for (auto&amp; connection : m_connections.values())
<span class="line-modified"> 551         connection-&gt;serverToContextConnectionCreated(contextConnection);</span>
 552 
 553     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
 554     for (auto&amp; data : pendingContextDatas)
 555         installContextData(data);
 556 
 557     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.registrableDomain());
 558     for (auto&amp; item : serviceWorkerRunRequests) {
 559         bool success = runServiceWorker(item.key);
 560         for (auto&amp; callback : item.value)
 561             callback(success ? &amp;contextConnection : nullptr);
 562     }
 563 }
 564 
 565 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
 566 {
 567     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
 568 
 569     if (data.jobDataIdentifier) {
 570         // Abort if the job that scheduled this has been cancelled.
 571         auto* jobQueue = m_jobQueues.get(data.registration.key);
 572         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
 573             return;
 574     }
 575 
<span class="line-modified"> 576     auto* registration = m_registrations.get(data.registration.key);</span>
<span class="line-removed"> 577     RELEASE_ASSERT(registration);</span>
<span class="line-removed"> 578 </span>
 579     auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
 580 
 581     auto* connection = worker-&gt;contextConnection();
 582     ASSERT(connection);
 583 
 584     registration-&gt;setPreInstallationWorker(worker.ptr());
 585     worker-&gt;setState(SWServerWorker::State::Running);
 586     auto userAgent = worker-&gt;userAgent();
 587     auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
 588     ASSERT_UNUSED(result, result.isNewEntry);
 589 
<span class="line-modified"> 590     connection-&gt;installServiceWorkerContext(data, m_sessionID, userAgent);</span>
 591 }
 592 
 593 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
 594 {
 595     auto* worker = workerByID(identifier);
 596     if (!worker) {
 597         callback(nullptr);
 598         return;
 599     }
 600 
 601     auto* contextConnection = worker-&gt;contextConnection();
 602     if (worker-&gt;isRunning()) {
 603         ASSERT(contextConnection);
 604         callback(contextConnection);
 605         return;
 606     }
 607 





 608     if (!contextConnection) {
 609         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;registrableDomain(), [] {
 610             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
 611         }).iterator-&gt;value;
 612         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
 613             return Vector&lt;RunServiceWorkerCallback&gt; { };
 614         }).iterator-&gt;value.append(WTFMove(callback));


 615         return;
 616     }
 617 
 618     bool success = runServiceWorker(identifier);
 619     callback(success ? contextConnection : nullptr);
 620 }
 621 
 622 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
 623 {
 624     auto* worker = workerByID(identifier);
 625     if (!worker)
 626         return false;
 627 
<span class="line-modified"> 628     // If the registration for a working has been removed then the request to run</span>
 629     // the worker is moot.
<span class="line-modified"> 630     if (!getRegistration(worker-&gt;registrationKey()))</span>
 631         return false;
 632 
 633     auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
 634     ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
 635 
 636     worker-&gt;setState(SWServerWorker::State::Running);
 637 
 638     auto* contextConnection = worker-&gt;contextConnection();
 639     ASSERT(contextConnection);
 640 
<span class="line-modified"> 641     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), m_sessionID, worker-&gt;userAgent());</span>
 642 
 643     return true;
 644 }
 645 
 646 void SWServer::terminateWorker(SWServerWorker&amp; worker)
 647 {
 648     terminateWorkerInternal(worker, Asynchronous);
 649 }
 650 
 651 void SWServer::syncTerminateWorker(SWServerWorker&amp; worker)
 652 {
 653     terminateWorkerInternal(worker, Synchronous);
 654 }
 655 
 656 void SWServer::terminateWorkerInternal(SWServerWorker&amp; worker, TerminationMode mode)
 657 {
 658     ASSERT(m_runningOrTerminatingWorkers.get(worker.identifier()) == &amp;worker);
 659     ASSERT(worker.isRunning());
 660 
 661     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::terminateWorkerInternal: Terminating service worker %llu&quot;, this, worker.identifier().toUInt64());
</pre>
<hr />
<pre>
 730 {
 731     auto identifier = connection-&gt;identifier();
 732     ASSERT(!m_connections.contains(identifier));
 733     m_connections.add(identifier, WTFMove(connection));
 734 }
 735 
 736 void SWServer::removeConnection(SWServerConnectionIdentifier connectionIdentifier)
 737 {
 738     ASSERT(m_connections.contains(connectionIdentifier));
 739     m_connections.remove(connectionIdentifier);
 740 
 741     for (auto&amp; registration : m_registrations.values())
 742         registration-&gt;unregisterServerConnection(connectionIdentifier);
 743 
 744     for (auto&amp; jobQueue : m_jobQueues.values())
 745         jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
 746 }
 747 
 748 SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 749 {

 750     SWServerRegistration* selectedRegistration = nullptr;
<span class="line-modified"> 751     for (auto&amp; registration : m_registrations.values()) {</span>
<span class="line-modified"> 752         if (!registration-&gt;key().isMatching(topOrigin, clientURL))</span>
 753             continue;
<span class="line-modified"> 754         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; registration-&gt;key().scopeLength())</span>
<span class="line-modified"> 755             selectedRegistration = registration.get();</span>
 756     }
 757 
<span class="line-modified"> 758     return (selectedRegistration &amp;&amp; !selectedRegistration-&gt;isUninstalling()) ? selectedRegistration : nullptr;</span>
 759 }
 760 
 761 SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
 762 {
 763     auto iterator = m_runningOrTerminatingWorkers.find(identifier);
 764     if (iterator == m_runningOrTerminatingWorkers.end())
 765         return nullptr;
<span class="line-modified"> 766 </span>
<span class="line-removed"> 767     return m_registrations.get(iterator-&gt;value-&gt;registrationKey());</span>
 768 }
 769 
 770 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
 771 {
 772     auto clientIdentifier = data.identifier;
 773 
 774     ASSERT(!m_clientsById.contains(clientIdentifier));
 775     m_clientsById.add(clientIdentifier, WTFMove(data));
 776 
 777     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
 778         return Clients { };
 779     }).iterator-&gt;value;
 780 
 781     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
 782     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
 783 
 784     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
 785         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
 786     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
 787 
 788     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
 789 
 790     m_clientsByRegistrableDomain.ensure(clientOrigin.clientRegistrableDomain(), [] {
 791         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
 792     }).iterator-&gt;value.add(clientIdentifier);
 793 
 794     if (!controllingServiceWorkerRegistrationIdentifier)
 795         return;
 796 
<span class="line-modified"> 797     auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);</span>
 798     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
 799         return;
 800 
 801     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
 802     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
 803     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
 804 }
 805 
 806 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
 807 {
 808     auto clientRegistrableDomain = clientOrigin.clientRegistrableDomain();
 809 
 810     bool wasRemoved = m_clientsById.remove(clientIdentifier);
 811     ASSERT_UNUSED(wasRemoved, wasRemoved);
 812 
 813     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 814     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
 815 
 816     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
 817     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
 818         return clientIdentifier == identifier;
 819     });
 820 
 821     if (clientIdentifiers.isEmpty()) {
 822         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
 823         iterator-&gt;value.terminateServiceWorkersTimer = makeUnique&lt;Timer&gt;([clientOrigin, clientRegistrableDomain, this] {
 824             Vector&lt;SWServerWorker*&gt; workersToTerminate;
 825             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
 826                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
 827                     workersToTerminate.append(worker.ptr());
 828             }
 829             for (auto* worker : workersToTerminate)
 830                 terminateWorker(*worker);
 831 
 832             if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
<span class="line-modified"> 833                 if (auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(clientRegistrableDomain))</span>
<span class="line-modified"> 834                     connection-&gt;connectionMayNoLongerBeNeeded();</span>


 835             }
 836 
 837             m_clientIdentifiersPerOrigin.remove(clientOrigin);
 838         });
<span class="line-modified"> 839         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);</span>
 840     }
 841 
 842     auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
 843     ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
 844     auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;
 845     clientsForRegistrableDomain.remove(clientIdentifier);
 846     if (clientsForRegistrableDomain.isEmpty())
 847         m_clientsByRegistrableDomain.remove(clientsByRegistrableDomainIterator);
 848 
 849     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
 850     if (registrationIterator == m_clientToControllingRegistration.end())
 851         return;
 852 
<span class="line-modified"> 853     if (auto* registration = m_registrationsByID.get(registrationIterator-&gt;value))</span>
 854         registration-&gt;removeClientUsingRegistration(clientIdentifier);
 855 
 856     m_clientToControllingRegistration.remove(registrationIterator);
 857 }
 858 
<span class="line-modified"> 859 bool SWServer::needsServerToContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const</span>
















 860 {
 861     return m_clientsByRegistrableDomain.contains(registrableDomain);
 862 }
 863 
 864 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
 865 {
 866     for (auto&amp; connection : m_connections.values())
 867         connection-&gt;resolveRegistrationReadyRequests(registration);
 868 }
 869 
 870 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 871 {
 872     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
 873         if (registration-&gt;activeWorker()) {
 874             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
 875             return;
 876         }
 877     }
 878     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
 879 }
</pre>
<hr />
<pre>
 898     });
 899 }
 900 
 901 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
 902 {
 903     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
 904 
 905     if (m_importCompleted)
 906         performGetOriginsWithRegistrationsCallbacks();
 907 }
 908 
 909 void SWServer::performGetOriginsWithRegistrationsCallbacks()
 910 {
 911     ASSERT(isMainThread());
 912     ASSERT(m_importCompleted);
 913 
 914     if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
 915         return;
 916 
 917     HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
<span class="line-modified"> 918     for (auto&amp; key : m_registrations.keys()) {</span>
 919         originsWithRegistrations.add(key.topOrigin());
 920         originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
 921     }
 922 
 923     auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
 924     for (auto&amp; callback : callbacks)
 925         callback(originsWithRegistrations);
 926 }
 927 









































































 928 } // namespace WebCore
 929 
 930 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
  26 #include &quot;config.h&quot;
  27 #include &quot;SWServer.h&quot;
  28 
  29 #if ENABLE(SERVICE_WORKER)
  30 
  31 #include &quot;ExceptionCode.h&quot;
  32 #include &quot;ExceptionData.h&quot;
  33 #include &quot;Logging.h&quot;
  34 #include &quot;RegistrationStore.h&quot;
  35 #include &quot;SWOriginStore.h&quot;
  36 #include &quot;SWServerJobQueue.h&quot;
  37 #include &quot;SWServerRegistration.h&quot;
  38 #include &quot;SWServerToContextConnection.h&quot;
  39 #include &quot;SWServerWorker.h&quot;
  40 #include &quot;SecurityOrigin.h&quot;
  41 #include &quot;ServiceWorkerClientType.h&quot;
  42 #include &quot;ServiceWorkerContextData.h&quot;
  43 #include &quot;ServiceWorkerFetchResult.h&quot;
  44 #include &quot;ServiceWorkerJobData.h&quot;
  45 #include &lt;wtf/CompletionHandler.h&gt;
<span class="line-added">  46 #include &lt;wtf/MemoryPressureHandler.h&gt;</span>
  47 #include &lt;wtf/NeverDestroyed.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace WebCore {
  51 
  52 static Seconds terminationDelay { 10_s };
  53 
<span class="line-modified">  54 SWServer::Connection::Connection(SWServer&amp; server, Identifier identifier)</span>
  55     : m_server(server)
<span class="line-modified">  56     , m_identifier(identifier)</span>
  57 {
  58 }
  59 
  60 HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
  61 {
  62     static NeverDestroyed&lt;HashSet&lt;SWServer*&gt;&gt; servers;
  63     return servers;
  64 }
  65 
  66 SWServer::~SWServer()
  67 {
  68     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
  69     // to the server and since they try to unregister clients from the server in their destructor.
  70     auto connections = WTFMove(m_connections);
  71     connections.clear();
  72 
<span class="line-added">  73     for (auto&amp; callback : std::exchange(m_importCompletedCallbacks, { }))</span>
<span class="line-added">  74         callback();</span>
<span class="line-added">  75 </span>
  76     Vector&lt;SWServerWorker*&gt; runningWorkers;
  77     for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
  78         if (worker-&gt;isRunning())
  79             runningWorkers.append(worker.ptr());
  80     }
  81     for (auto&amp; runningWorker : runningWorkers)
  82         terminateWorker(*runningWorker);
  83 
  84     allServers().remove(this);
  85 }
  86 
  87 SWServerWorker* SWServer::workerByID(ServiceWorkerIdentifier identifier) const
  88 {
  89     auto* worker = SWServerWorker::existingWorkerForIdentifier(identifier);
  90     ASSERT(!worker || worker-&gt;server() == this);
  91     return worker;
  92 }
  93 
  94 Optional&lt;ServiceWorkerClientData&gt; SWServer::serviceWorkerClientWithOriginByID(const ClientOrigin&amp; clientOrigin, const ServiceWorkerClientIdentifier&amp; clientIdentifier) const
  95 {
</pre>
<hr />
<pre>
  98         return WTF::nullopt;
  99 
 100     if (!iterator-&gt;value.identifiers.contains(clientIdentifier))
 101         return WTF::nullopt;
 102 
 103     auto clientIterator = m_clientsById.find(clientIdentifier);
 104     ASSERT(clientIterator != m_clientsById.end());
 105     return clientIterator-&gt;value;
 106 }
 107 
 108 String SWServer::serviceWorkerClientUserAgent(const ClientOrigin&amp; clientOrigin) const
 109 {
 110     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 111     if (iterator == m_clientIdentifiersPerOrigin.end())
 112         return String();
 113     return iterator-&gt;value.userAgent;
 114 }
 115 
 116 SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
 117 {
<span class="line-modified"> 118     auto* registration = m_registrations.get(identifier);</span>
 119     return registration ? registration-&gt;activeWorker() : nullptr;
 120 }
 121 
 122 SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
 123 {
<span class="line-modified"> 124     return m_scopeToRegistrationMap.get(registrationKey).get();</span>
 125 }
 126 
 127 void SWServer::registrationStoreImportComplete()
 128 {
 129     ASSERT(!m_importCompleted);
 130     m_importCompleted = true;
 131     m_originStore-&gt;importComplete();
 132 
 133     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
 134     for (auto&amp; callback : clearCallbacks)
 135         callback();
 136 
 137     performGetOriginsWithRegistrationsCallbacks();
<span class="line-added"> 138 </span>
<span class="line-added"> 139     for (auto&amp; callback : std::exchange(m_importCompletedCallbacks, { }))</span>
<span class="line-added"> 140         callback();</span>
 141 }
 142 
<span class="line-added"> 143 void SWServer::whenImportIsCompleted(CompletionHandler&lt;void()&gt;&amp;&amp; callback)</span>
<span class="line-added"> 144 {</span>
<span class="line-added"> 145     ASSERT(!m_importCompleted);</span>
<span class="line-added"> 146     m_importCompletedCallbacks.append(WTFMove(callback));</span>
<span class="line-added"> 147 }</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149 </span>
 150 void SWServer::registrationStoreDatabaseFailedToOpen()
 151 {
 152     if (!m_importCompleted)
 153         registrationStoreImportComplete();
 154 }
 155 
 156 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
 157 {
 158     // Pages should not have been able to make a new registration to this key while the import was still taking place.
<span class="line-modified"> 159     ASSERT(!m_scopeToRegistrationMap.contains(data.registration.key));</span>
 160 
 161     auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
 162     registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
 163     auto registrationPtr = registration.get();
 164     addRegistration(WTFMove(registration));
 165 
 166     auto worker = SWServerWorker::create(*this, *registrationPtr, data.scriptURL, data.script, data.contentSecurityPolicy, WTFMove(data.referrerPolicy), data.workerType, data.serviceWorkerIdentifier, WTFMove(data.scriptResourceMap));
 167     registrationPtr-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Active, worker.ptr());
 168     worker-&gt;setState(ServiceWorkerState::Activated);
 169 }
 170 
 171 void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
 172 {
<span class="line-modified"> 173     m_originStore-&gt;add(registration-&gt;key().topOrigin());</span>
<span class="line-modified"> 174     auto registrationID = registration-&gt;identifier();</span>
<span class="line-modified"> 175     ASSERT(!m_scopeToRegistrationMap.contains(registration-&gt;key()));</span>
<span class="line-added"> 176     m_scopeToRegistrationMap.set(registration-&gt;key(), makeWeakPtr(*registration));</span>
<span class="line-added"> 177     auto addResult1 = m_registrations.add(registrationID, WTFMove(registration));</span>
 178     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);





 179 }
 180 
<span class="line-modified"> 181 void SWServer::removeRegistration(ServiceWorkerRegistrationIdentifier registrationID)</span>
 182 {
<span class="line-modified"> 183     auto registration = m_registrations.take(registrationID);</span>

 184     ASSERT(registration);


 185 
<span class="line-modified"> 186     auto it = m_scopeToRegistrationMap.find(registration-&gt;key());</span>
<span class="line-added"> 187     if (it != m_scopeToRegistrationMap.end() &amp;&amp; it-&gt;value == registration.get())</span>
<span class="line-added"> 188         m_scopeToRegistrationMap.remove(it);</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190     m_originStore-&gt;remove(registration-&gt;key().topOrigin());</span>
 191     if (m_registrationStore)
<span class="line-modified"> 192         m_registrationStore-&gt;removeRegistration(registration-&gt;key());</span>
 193 }
 194 
 195 Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 196 {
 197     Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
<span class="line-modified"> 198     for (auto&amp; item : m_scopeToRegistrationMap) {</span>
<span class="line-modified"> 199         if (item.key.originIsMatching(topOrigin, clientURL)) {</span>
<span class="line-modified"> 200             auto* registration = item.value.get();</span>
<span class="line-added"> 201             ASSERT(registration);</span>
<span class="line-added"> 202             if (registration)</span>
<span class="line-added"> 203                 matchingRegistrations.append(registration);</span>
<span class="line-added"> 204         }</span>
 205     }
 206     // The specification mandates that registrations are returned in the insertion order.
 207     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
 208         return a-&gt;creationTime() &lt; b-&gt;creationTime();
 209     });
 210     Vector&lt;ServiceWorkerRegistrationData&gt; matchingRegistrationDatas;
 211     matchingRegistrationDatas.reserveInitialCapacity(matchingRegistrations.size());
 212     for (auto* registration : matchingRegistrations)
 213         matchingRegistrationDatas.uncheckedAppend(registration-&gt;data());
 214     return matchingRegistrationDatas;
 215 }
 216 
 217 void SWServer::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 218 {
 219     if (!m_importCompleted) {
 220         m_clearCompletionCallbacks.append([this, completionHandler = WTFMove(completionHandler)] () mutable {
 221             ASSERT(m_importCompleted);
 222             clearAll(WTFMove(completionHandler));
 223         });
 224         return;
 225     }
 226 
 227     m_jobQueues.clear();
 228     while (!m_registrations.isEmpty())
 229         m_registrations.begin()-&gt;value-&gt;clear();

 230     m_pendingContextDatas.clear();
 231     m_originStore-&gt;clearAll();
 232     if (m_registrationStore)
 233         m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
 234 }
 235 
 236 void SWServer::startSuspension(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 237 {
 238     if (!m_registrationStore) {
 239         completionHandler();
 240         return;
 241     }
 242     m_registrationStore-&gt;startSuspension(WTFMove(completionHandler));
 243 }
 244 
 245 void SWServer::endSuspension()
 246 {
 247     if (m_registrationStore)
 248         m_registrationStore-&gt;endSuspension();
 249 }
 250 
 251 void SWServer::clear(const SecurityOriginData&amp; securityOrigin, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 252 {
 253     if (!m_importCompleted) {
 254         m_clearCompletionCallbacks.append([this, securityOrigin, completionHandler = WTFMove(completionHandler)] () mutable {
 255             ASSERT(m_importCompleted);
 256             clear(securityOrigin, WTFMove(completionHandler));
 257         });
 258         return;
 259     }
 260 
 261     m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
 262         return keyAndValue.key.relatesToOrigin(securityOrigin);
 263     });
 264 
 265     Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
<span class="line-modified"> 266     for (auto&amp; registration : m_registrations.values()) {</span>
<span class="line-modified"> 267         if (registration-&gt;key().relatesToOrigin(securityOrigin))</span>
<span class="line-modified"> 268             registrationsToRemove.append(registration.get());</span>
 269     }
 270 
 271     for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
 272         contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
 273             return contextData.registration.key.relatesToOrigin(securityOrigin);
 274         });
 275     }
 276 
 277     if (registrationsToRemove.isEmpty()) {
 278         completionHandler();
 279         return;
 280     }
 281 
 282     // Calling SWServerRegistration::clear() takes care of updating m_registrations, m_originStore and m_registrationStore.
 283     for (auto* registration : registrationsToRemove)
 284         registration-&gt;clear();
 285 
 286     if (m_registrationStore)
 287         m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
 288 }
 289 
 290 void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
 291 {
<span class="line-modified"> 292     m_server.scriptFetchFinished(result);</span>
 293 }
 294 
 295 void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
 296 {
<span class="line-modified"> 297     m_server.didResolveRegistrationPromise(this, key);</span>
 298 }
 299 
 300 void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 301 {
 302     m_server.addClientServiceWorkerRegistration(*this, identifier);
 303 }
 304 
 305 void SWServer::Connection::removeServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 306 {
 307     m_server.removeClientServiceWorkerRegistration(*this, identifier);
 308 }
 309 
 310 void SWServer::Connection::syncTerminateWorker(ServiceWorkerIdentifier identifier)
 311 {
 312     if (auto* worker = m_server.workerByID(identifier))
 313         m_server.syncTerminateWorker(*worker);
 314 }
 315 
<span class="line-modified"> 316 SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, bool processTerminationDelayEnabled, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID, SoftUpdateCallback&amp;&amp; softUpdateCallback, CreateContextConnectionCallback&amp;&amp; callback)</span>
 317     : m_originStore(WTFMove(originStore))
 318     , m_sessionID(sessionID)
<span class="line-added"> 319     , m_isProcessTerminationDelayEnabled(processTerminationDelayEnabled)</span>
<span class="line-added"> 320     , m_createContextConnectionCallback(WTFMove(callback))</span>
<span class="line-added"> 321     , m_softUpdateCallback(WTFMove(softUpdateCallback))</span>
 322 {
<span class="line-modified"> 323     RELEASE_LOG_IF(registrationDatabaseDirectory.isEmpty() &amp;&amp; !m_sessionID.isEphemeral(), ServiceWorker, &quot;No path to store the service worker registrations&quot;);</span>
 324     if (!m_sessionID.isEphemeral())
 325         m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
 326     else
 327         registrationStoreImportComplete();
 328 
 329     UNUSED_PARAM(registrationDatabaseDirectory);
 330     allServers().add(this);
 331 }
 332 
 333 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
 334 void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
 335 {
<span class="line-modified"> 336     ASSERT(m_connections.contains(jobData.connectionIdentifier()) || jobData.connectionIdentifier() == Process::identifier());</span>



 337 
 338     auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
 339         return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
 340     }).iterator-&gt;value;
 341 
<span class="line-modified"> 342     if (!jobQueue.size()) {</span>
<span class="line-added"> 343         jobQueue.enqueueJob(WTFMove(jobData));</span>
<span class="line-added"> 344         jobQueue.runNextJob();</span>
<span class="line-added"> 345         return;</span>
<span class="line-added"> 346     }</span>
<span class="line-added"> 347     auto&amp; lastJob = jobQueue.lastJob();</span>
<span class="line-added"> 348     if (jobData.isEquivalent(lastJob)) {</span>
<span class="line-added"> 349         // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.</span>
<span class="line-added"> 350         // If it is, stack it along with that job. For now, we just make sure to not call soft-update too often.</span>
<span class="line-added"> 351         if (jobData.type == ServiceWorkerJobType::Update &amp;&amp; jobData.connectionIdentifier() == Process::identifier())</span>
<span class="line-added"> 352             return;</span>
<span class="line-added"> 353     }</span>
<span class="line-added"> 354 </span>
<span class="line-added"> 355     jobQueue.enqueueJob(WTFMove(jobData));</span>
 356     if (jobQueue.size() == 1)
 357         jobQueue.runNextJob();
 358 }
 359 
 360 void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
 361 {
 362     LOG(ServiceWorker, &quot;Rejected ServiceWorker job %s in server&quot;, jobData.identifier().loggingString().utf8().data());
 363     auto* connection = m_connections.get(jobData.connectionIdentifier());
 364     if (!connection)
 365         return;
 366 
 367     connection-&gt;rejectJobInClient(jobData.identifier().jobIdentifier, exceptionData);
 368 }
 369 
 370 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 371 {
 372     LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
 373     auto* connection = m_connections.get(jobData.connectionIdentifier());
<span class="line-modified"> 374     if (!connection) {</span>
<span class="line-added"> 375         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes &amp;&amp; jobData.connectionIdentifier() == Process::identifier())</span>
<span class="line-added"> 376             didResolveRegistrationPromise(nullptr, registrationData.key);</span>
 377         return;
<span class="line-added"> 378     }</span>
 379 
 380     connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
 381 }
 382 
 383 void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
 384 {
 385     auto* connection = m_connections.get(jobData.connectionIdentifier());
 386     if (!connection)
 387         return;
 388 
 389     connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
 390 }
 391 
<span class="line-modified"> 392 URL static inline originURL(const SecurityOrigin&amp; origin)</span>
<span class="line-added"> 393 {</span>
<span class="line-added"> 394     URL url;</span>
<span class="line-added"> 395     url.setProtocol(origin.protocol());</span>
<span class="line-added"> 396     url.setHost(origin.host());</span>
<span class="line-added"> 397     if (origin.port())</span>
<span class="line-added"> 398         url.setPort(*origin.port());</span>
<span class="line-added"> 399     return url;</span>
<span class="line-added"> 400 }</span>
<span class="line-added"> 401 </span>
<span class="line-added"> 402 void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, bool shouldRefreshCache)</span>
 403 {
 404     LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
 405     auto* connection = m_connections.get(jobData.connectionIdentifier());
<span class="line-added"> 406     if (connection) {</span>
<span class="line-added"> 407         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), shouldRefreshCache ? FetchOptions::Cache::NoCache : FetchOptions::Cache::Default);</span>
<span class="line-added"> 408         return;</span>
<span class="line-added"> 409     }</span>
<span class="line-added"> 410     if (jobData.connectionIdentifier() == Process::identifier()) {</span>
<span class="line-added"> 411         ASSERT(jobData.type == ServiceWorkerJobType::Update);</span>
<span class="line-added"> 412         // This is a soft-update job, create directly a network load to fetch the script.</span>
<span class="line-added"> 413         ResourceRequest request { jobData.scriptURL };</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415         auto topOrigin = jobData.topOrigin.securityOrigin();</span>
<span class="line-added"> 416         auto origin = SecurityOrigin::create(jobData.scriptURL);</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418         request.setDomainForCachePartition(topOrigin-&gt;domainForCachePartition());</span>
<span class="line-added"> 419         request.setAllowCookies(true);</span>
<span class="line-added"> 420         request.setFirstPartyForCookies(originURL(topOrigin));</span>
<span class="line-added"> 421 </span>
<span class="line-added"> 422         request.setHTTPHeaderField(HTTPHeaderName::Origin, origin-&gt;toString());</span>
<span class="line-added"> 423         request.setHTTPHeaderField(HTTPHeaderName::ServiceWorker, &quot;script&quot;_s);</span>
<span class="line-added"> 424         request.setHTTPReferrer(originURL(origin));</span>
<span class="line-added"> 425         request.setHTTPUserAgent(serviceWorkerClientUserAgent(ClientOrigin { jobData.topOrigin, SecurityOrigin::create(jobData.scriptURL)-&gt;data() }));</span>
<span class="line-added"> 426         request.setPriority(ResourceLoadPriority::Low);</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428         m_softUpdateCallback(ServiceWorkerJobData { jobData }, shouldRefreshCache, WTFMove(request), [this, weakThis = makeWeakPtr(this)](auto&amp; result) {</span>
<span class="line-added"> 429             if (!weakThis)</span>
<span class="line-added"> 430                 return;</span>
<span class="line-added"> 431             scriptFetchFinished(result);</span>
<span class="line-added"> 432         });</span>
<span class="line-added"> 433         return;</span>
<span class="line-added"> 434     }</span>
 435     ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);


 436 }
 437 
<span class="line-modified"> 438 void SWServer::scriptFetchFinished(const ServiceWorkerFetchResult&amp; result)</span>
 439 {
 440     LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
 441 
<span class="line-modified"> 442     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier) || result.jobDataIdentifier.connectionIdentifier == Process::identifier());</span>
 443 
 444     auto jobQueue = m_jobQueues.get(result.registrationKey);
 445     if (!jobQueue)
 446         return;
 447 
<span class="line-modified"> 448     jobQueue-&gt;scriptFetchFinished(result);</span>
 449 }
 450 
 451 void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
 452 {
 453     if (!jobDataIdentifier)
 454         return;
 455 
 456     RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::scriptContextFailedToStart: Failed to start SW for job %s, error: %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data(), message.utf8().data());
 457 
 458     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
 459     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
 460         // The job which started this worker has been canceled, terminate this worker.
 461         terminatePreinstallationWorker(worker);
 462         return;
 463     }
 464     jobQueue-&gt;scriptContextFailedToStart(*jobDataIdentifier, worker.identifier(), message);
 465 }
 466 
 467 void SWServer::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker)
 468 {
 469     if (!jobDataIdentifier)
 470         return;
 471 
 472     auto* jobQueue = m_jobQueues.get(worker.registrationKey());
 473     if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*jobDataIdentifier)) {
 474         // The job which started this worker has been canceled, terminate this worker.
 475         terminatePreinstallationWorker(worker);
 476         return;
 477     }
 478     jobQueue-&gt;scriptContextStarted(*jobDataIdentifier, worker.identifier());
 479 }
 480 
 481 void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
 482 {
 483     worker.terminate();
<span class="line-modified"> 484     auto* registration = worker.registration();</span>
 485     if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
 486         registration-&gt;setPreInstallationWorker(nullptr);
 487 }
 488 
 489 void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
 490 {
 491     if (!jobDataIdentifier)
 492         return;
 493 
 494     if (wasSuccessful)
 495         RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
 496     else
 497         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
 498 
 499     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
<span class="line-modified"> 500         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker, wasSuccessful);</span>
 501 }
 502 
 503 void SWServer::didFinishActivation(SWServerWorker&amp; worker)
 504 {
 505     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
 506 
<span class="line-modified"> 507     auto* registration = worker.registration();</span>
 508     if (!registration)
 509         return;
 510 
 511     if (m_registrationStore)
 512         m_registrationStore-&gt;updateRegistration(worker.contextData());
 513     registration-&gt;didFinishActivation(worker.identifier());
 514 }
 515 
 516 // https://w3c.github.io/ServiceWorker/#clients-getall
 517 void SWServer::matchAll(SWServerWorker&amp; worker, const ServiceWorkerClientQueryOptions&amp; options, ServiceWorkerClientsMatchAllCallback&amp;&amp; callback)
 518 {
 519     // FIXME: Support reserved client filtering.
 520     // FIXME: Support WindowClient additional properties.
 521 
 522     Vector&lt;ServiceWorkerClientData&gt; matchingClients;
 523     forEachClientForOrigin(worker.origin(), [&amp;](auto&amp; clientData) {
 524         if (!options.includeUncontrolled) {
 525             auto registrationIdentifier = m_clientToControllingRegistration.get(clientData.identifier);
 526             if (worker.data().registrationIdentifier != registrationIdentifier)
 527                 return;
</pre>
<hr />
<pre>
 545         auto clientIterator = m_clientsById.find(clientIdentifier);
 546         ASSERT(clientIterator != m_clientsById.end());
 547         apply(clientIterator-&gt;value);
 548     }
 549 }
 550 
 551 void SWServer::claim(SWServerWorker&amp; worker)
 552 {
 553     auto&amp; origin = worker.origin();
 554     forEachClientForOrigin(origin, [&amp;](auto&amp; clientData) {
 555         auto* registration = this-&gt;doRegistrationMatching(origin.topOrigin, clientData.url);
 556         if (!(registration &amp;&amp; registration-&gt;key() == worker.registrationKey()))
 557             return;
 558 
 559         auto result = m_clientToControllingRegistration.add(clientData.identifier, registration-&gt;identifier());
 560         if (!result.isNewEntry) {
 561             auto previousIdentifier = result.iterator-&gt;value;
 562             if (previousIdentifier == registration-&gt;identifier())
 563                 return;
 564             result.iterator-&gt;value = registration-&gt;identifier();
<span class="line-modified"> 565             if (auto* controllingRegistration = m_registrations.get(previousIdentifier))</span>
 566                 controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
 567         }
 568         registration-&gt;controlClient(clientData.identifier);
 569     });
 570 }
 571 
<span class="line-modified"> 572 void SWServer::didResolveRegistrationPromise(Connection* connection, const ServiceWorkerRegistrationKey&amp; registrationKey)</span>
 573 {
<span class="line-modified"> 574     ASSERT_UNUSED(connection, !connection || m_connections.contains(connection-&gt;identifier()));</span>
 575 
 576     if (auto* jobQueue = m_jobQueues.get(registrationKey))
 577         jobQueue-&gt;didResolveRegistrationPromise();
 578 }
 579 
 580 void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
 581 {
<span class="line-modified"> 582     auto* registration = m_registrations.get(identifier);</span>
 583     if (!registration) {
 584         LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
 585         return;
 586     }
 587 
 588     registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
 589 }
 590 
 591 void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
 592 {
<span class="line-modified"> 593     if (auto* registration = m_registrations.get(identifier))</span>
 594         registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
 595 }
 596 
<span class="line-modified"> 597 void SWServer::updateWorker(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)</span>
 598 {
<span class="line-modified"> 599     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, false, WTFMove(scriptResourceMap) });</span>
 600 }
 601 
 602 void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
 603 {
 604     RegistrableDomain registrableDomain(data.scriptURL);
<span class="line-modified"> 605     auto* connection = contextConnectionForRegistrableDomain(registrableDomain);</span>
 606     if (!connection) {
<span class="line-modified"> 607         m_pendingContextDatas.ensure(registrableDomain, [] {</span>
 608             return Vector&lt;ServiceWorkerContextData&gt; { };
 609         }).iterator-&gt;value.append(WTFMove(data));
<span class="line-added"> 610 </span>
<span class="line-added"> 611         createContextConnection(registrableDomain);</span>
 612         return;
 613     }
 614 
 615     installContextData(data);
 616 }
 617 
<span class="line-modified"> 618 void SWServer::contextConnectionCreated(SWServerToContextConnection&amp; contextConnection)</span>
 619 {
 620     for (auto&amp; connection : m_connections.values())
<span class="line-modified"> 621         connection-&gt;contextConnectionCreated(contextConnection);</span>
 622 
 623     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
 624     for (auto&amp; data : pendingContextDatas)
 625         installContextData(data);
 626 
 627     auto serviceWorkerRunRequests = m_serviceWorkerRunRequests.take(contextConnection.registrableDomain());
 628     for (auto&amp; item : serviceWorkerRunRequests) {
 629         bool success = runServiceWorker(item.key);
 630         for (auto&amp; callback : item.value)
 631             callback(success ? &amp;contextConnection : nullptr);
 632     }
 633 }
 634 
 635 void SWServer::installContextData(const ServiceWorkerContextData&amp; data)
 636 {
 637     ASSERT_WITH_MESSAGE(!data.loadedFromDisk, &quot;Workers we just read from disk should only be launched as needed&quot;);
 638 
 639     if (data.jobDataIdentifier) {
 640         // Abort if the job that scheduled this has been cancelled.
 641         auto* jobQueue = m_jobQueues.get(data.registration.key);
 642         if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
 643             return;
 644     }
 645 
<span class="line-modified"> 646     auto* registration = m_scopeToRegistrationMap.get(data.registration.key).get();</span>


 647     auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
 648 
 649     auto* connection = worker-&gt;contextConnection();
 650     ASSERT(connection);
 651 
 652     registration-&gt;setPreInstallationWorker(worker.ptr());
 653     worker-&gt;setState(SWServerWorker::State::Running);
 654     auto userAgent = worker-&gt;userAgent();
 655     auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
 656     ASSERT_UNUSED(result, result.isNewEntry);
 657 
<span class="line-modified"> 658     connection-&gt;installServiceWorkerContext(data, userAgent);</span>
 659 }
 660 
 661 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
 662 {
 663     auto* worker = workerByID(identifier);
 664     if (!worker) {
 665         callback(nullptr);
 666         return;
 667     }
 668 
 669     auto* contextConnection = worker-&gt;contextConnection();
 670     if (worker-&gt;isRunning()) {
 671         ASSERT(contextConnection);
 672         callback(contextConnection);
 673         return;
 674     }
 675 
<span class="line-added"> 676     if (worker-&gt;state() == ServiceWorkerState::Redundant) {</span>
<span class="line-added"> 677         callback(nullptr);</span>
<span class="line-added"> 678         return;</span>
<span class="line-added"> 679     }</span>
<span class="line-added"> 680 </span>
 681     if (!contextConnection) {
 682         auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;registrableDomain(), [] {
 683             return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
 684         }).iterator-&gt;value;
 685         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
 686             return Vector&lt;RunServiceWorkerCallback&gt; { };
 687         }).iterator-&gt;value.append(WTFMove(callback));
<span class="line-added"> 688 </span>
<span class="line-added"> 689         createContextConnection(worker-&gt;registrableDomain());</span>
 690         return;
 691     }
 692 
 693     bool success = runServiceWorker(identifier);
 694     callback(success ? contextConnection : nullptr);
 695 }
 696 
 697 bool SWServer::runServiceWorker(ServiceWorkerIdentifier identifier)
 698 {
 699     auto* worker = workerByID(identifier);
 700     if (!worker)
 701         return false;
 702 
<span class="line-modified"> 703     // If the registration for a worker has been removed then the request to run</span>
 704     // the worker is moot.
<span class="line-modified"> 705     if (!worker-&gt;registration())</span>
 706         return false;
 707 
 708     auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
 709     ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
 710 
 711     worker-&gt;setState(SWServerWorker::State::Running);
 712 
 713     auto* contextConnection = worker-&gt;contextConnection();
 714     ASSERT(contextConnection);
 715 
<span class="line-modified"> 716     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), worker-&gt;userAgent());</span>
 717 
 718     return true;
 719 }
 720 
 721 void SWServer::terminateWorker(SWServerWorker&amp; worker)
 722 {
 723     terminateWorkerInternal(worker, Asynchronous);
 724 }
 725 
 726 void SWServer::syncTerminateWorker(SWServerWorker&amp; worker)
 727 {
 728     terminateWorkerInternal(worker, Synchronous);
 729 }
 730 
 731 void SWServer::terminateWorkerInternal(SWServerWorker&amp; worker, TerminationMode mode)
 732 {
 733     ASSERT(m_runningOrTerminatingWorkers.get(worker.identifier()) == &amp;worker);
 734     ASSERT(worker.isRunning());
 735 
 736     RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::terminateWorkerInternal: Terminating service worker %llu&quot;, this, worker.identifier().toUInt64());
</pre>
<hr />
<pre>
 805 {
 806     auto identifier = connection-&gt;identifier();
 807     ASSERT(!m_connections.contains(identifier));
 808     m_connections.add(identifier, WTFMove(connection));
 809 }
 810 
 811 void SWServer::removeConnection(SWServerConnectionIdentifier connectionIdentifier)
 812 {
 813     ASSERT(m_connections.contains(connectionIdentifier));
 814     m_connections.remove(connectionIdentifier);
 815 
 816     for (auto&amp; registration : m_registrations.values())
 817         registration-&gt;unregisterServerConnection(connectionIdentifier);
 818 
 819     for (auto&amp; jobQueue : m_jobQueues.values())
 820         jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
 821 }
 822 
 823 SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 824 {
<span class="line-added"> 825     ASSERT(isImportCompleted());</span>
 826     SWServerRegistration* selectedRegistration = nullptr;
<span class="line-modified"> 827     for (auto&amp; pair : m_scopeToRegistrationMap) {</span>
<span class="line-modified"> 828         if (!pair.key.isMatching(topOrigin, clientURL))</span>
 829             continue;
<span class="line-modified"> 830         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; pair.key.scopeLength())</span>
<span class="line-modified"> 831             selectedRegistration = pair.value.get();</span>
 832     }
 833 
<span class="line-modified"> 834     return selectedRegistration;</span>
 835 }
 836 
 837 SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
 838 {
 839     auto iterator = m_runningOrTerminatingWorkers.find(identifier);
 840     if (iterator == m_runningOrTerminatingWorkers.end())
 841         return nullptr;
<span class="line-modified"> 842     return iterator-&gt;value-&gt;registration();</span>

 843 }
 844 
 845 void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
 846 {
 847     auto clientIdentifier = data.identifier;
 848 
 849     ASSERT(!m_clientsById.contains(clientIdentifier));
 850     m_clientsById.add(clientIdentifier, WTFMove(data));
 851 
 852     auto&amp; clientIdentifiersForOrigin = m_clientIdentifiersPerOrigin.ensure(clientOrigin, [] {
 853         return Clients { };
 854     }).iterator-&gt;value;
 855 
 856     ASSERT(!clientIdentifiersForOrigin.identifiers.contains(clientIdentifier));
 857     clientIdentifiersForOrigin.identifiers.append(clientIdentifier);
 858 
 859     if (!clientIdentifiersForOrigin.userAgent.isNull() &amp;&amp; clientIdentifiersForOrigin.userAgent != userAgent)
 860         RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::registerServiceWorkerClient: Service worker has clients using different user agents&quot;, this);
 861     clientIdentifiersForOrigin.userAgent = WTFMove(userAgent);
 862 
 863     clientIdentifiersForOrigin.terminateServiceWorkersTimer = nullptr;
 864 
 865     m_clientsByRegistrableDomain.ensure(clientOrigin.clientRegistrableDomain(), [] {
 866         return HashSet&lt;ServiceWorkerClientIdentifier&gt; { };
 867     }).iterator-&gt;value.add(clientIdentifier);
 868 
 869     if (!controllingServiceWorkerRegistrationIdentifier)
 870         return;
 871 
<span class="line-modified"> 872     auto* controllingRegistration = m_registrations.get(*controllingServiceWorkerRegistrationIdentifier);</span>
 873     if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
 874         return;
 875 
 876     controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
 877     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
 878     m_clientToControllingRegistration.add(clientIdentifier, *controllingServiceWorkerRegistrationIdentifier);
 879 }
 880 
 881 void SWServer::unregisterServiceWorkerClient(const ClientOrigin&amp; clientOrigin, ServiceWorkerClientIdentifier clientIdentifier)
 882 {
 883     auto clientRegistrableDomain = clientOrigin.clientRegistrableDomain();
 884 
 885     bool wasRemoved = m_clientsById.remove(clientIdentifier);
 886     ASSERT_UNUSED(wasRemoved, wasRemoved);
 887 
 888     auto iterator = m_clientIdentifiersPerOrigin.find(clientOrigin);
 889     ASSERT(iterator != m_clientIdentifiersPerOrigin.end());
 890 
 891     auto&amp; clientIdentifiers = iterator-&gt;value.identifiers;
 892     clientIdentifiers.removeFirstMatching([&amp;] (const auto&amp; identifier) {
 893         return clientIdentifier == identifier;
 894     });
 895 
 896     if (clientIdentifiers.isEmpty()) {
 897         ASSERT(!iterator-&gt;value.terminateServiceWorkersTimer);
 898         iterator-&gt;value.terminateServiceWorkersTimer = makeUnique&lt;Timer&gt;([clientOrigin, clientRegistrableDomain, this] {
 899             Vector&lt;SWServerWorker*&gt; workersToTerminate;
 900             for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
 901                 if (worker-&gt;isRunning() &amp;&amp; worker-&gt;origin() == clientOrigin)
 902                     workersToTerminate.append(worker.ptr());
 903             }
 904             for (auto* worker : workersToTerminate)
 905                 terminateWorker(*worker);
 906 
 907             if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
<span class="line-modified"> 908                 if (auto* connection = contextConnectionForRegistrableDomain(clientRegistrableDomain)) {</span>
<span class="line-modified"> 909                     removeContextConnection(*connection);</span>
<span class="line-added"> 910                     connection-&gt;connectionIsNoLongerNeeded();</span>
<span class="line-added"> 911                 }</span>
 912             }
 913 
 914             m_clientIdentifiersPerOrigin.remove(clientOrigin);
 915         });
<span class="line-modified"> 916         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_isProcessTerminationDelayEnabled &amp;&amp; !MemoryPressureHandler::singleton().isUnderMemoryPressure() ? terminationDelay : 0_s);</span>
 917     }
 918 
 919     auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
 920     ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
 921     auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;
 922     clientsForRegistrableDomain.remove(clientIdentifier);
 923     if (clientsForRegistrableDomain.isEmpty())
 924         m_clientsByRegistrableDomain.remove(clientsByRegistrableDomainIterator);
 925 
 926     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
 927     if (registrationIterator == m_clientToControllingRegistration.end())
 928         return;
 929 
<span class="line-modified"> 930     if (auto* registration = m_registrations.get(registrationIterator-&gt;value))</span>
 931         registration-&gt;removeClientUsingRegistration(clientIdentifier);
 932 
 933     m_clientToControllingRegistration.remove(registrationIterator);
 934 }
 935 
<span class="line-modified"> 936 void SWServer::handleLowMemoryWarning()</span>
<span class="line-added"> 937 {</span>
<span class="line-added"> 938     // Accelerating the delayed termination of unused service workers due to memory pressure.</span>
<span class="line-added"> 939     if (m_isProcessTerminationDelayEnabled) {</span>
<span class="line-added"> 940         for (auto&amp; clients : m_clientIdentifiersPerOrigin.values()) {</span>
<span class="line-added"> 941             if (clients.terminateServiceWorkersTimer)</span>
<span class="line-added"> 942                 clients.terminateServiceWorkersTimer-&gt;startOneShot(0_s);</span>
<span class="line-added"> 943         }</span>
<span class="line-added"> 944     }</span>
<span class="line-added"> 945 }</span>
<span class="line-added"> 946 </span>
<span class="line-added"> 947 void SWServer::removeFromScopeToRegistrationMap(const ServiceWorkerRegistrationKey&amp; key)</span>
<span class="line-added"> 948 {</span>
<span class="line-added"> 949     m_scopeToRegistrationMap.remove(key);</span>
<span class="line-added"> 950 }</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952 bool SWServer::needsContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const</span>
 953 {
 954     return m_clientsByRegistrableDomain.contains(registrableDomain);
 955 }
 956 
 957 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
 958 {
 959     for (auto&amp; connection : m_connections.values())
 960         connection-&gt;resolveRegistrationReadyRequests(registration);
 961 }
 962 
 963 void SWServer::Connection::whenRegistrationReady(uint64_t registrationReadyRequestIdentifier, const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
 964 {
 965     if (auto* registration = doRegistrationMatching(topOrigin, clientURL)) {
 966         if (registration-&gt;activeWorker()) {
 967             registrationReady(registrationReadyRequestIdentifier, registration-&gt;data());
 968             return;
 969         }
 970     }
 971     m_registrationReadyRequests.append({ topOrigin, clientURL, registrationReadyRequestIdentifier });
 972 }
</pre>
<hr />
<pre>
 991     });
 992 }
 993 
 994 void SWServer::getOriginsWithRegistrations(Function&lt;void(const HashSet&lt;SecurityOriginData&gt;&amp;)&gt;&amp;&amp; callback)
 995 {
 996     m_getOriginsWithRegistrationsCallbacks.append(WTFMove(callback));
 997 
 998     if (m_importCompleted)
 999         performGetOriginsWithRegistrationsCallbacks();
1000 }
1001 
1002 void SWServer::performGetOriginsWithRegistrationsCallbacks()
1003 {
1004     ASSERT(isMainThread());
1005     ASSERT(m_importCompleted);
1006 
1007     if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
1008         return;
1009 
1010     HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
<span class="line-modified">1011     for (auto&amp; key : m_scopeToRegistrationMap.keys()) {</span>
1012         originsWithRegistrations.add(key.topOrigin());
1013         originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
1014     }
1015 
1016     auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
1017     for (auto&amp; callback : callbacks)
1018         callback(originsWithRegistrations);
1019 }
1020 
<span class="line-added">1021 void SWServer::addContextConnection(SWServerToContextConnection&amp; connection)</span>
<span class="line-added">1022 {</span>
<span class="line-added">1023     RELEASE_LOG(ServiceWorker, &quot;SWServer::addContextConnection&quot;);</span>
<span class="line-added">1024 </span>
<span class="line-added">1025     ASSERT(!m_contextConnections.contains(connection.registrableDomain()));</span>
<span class="line-added">1026 </span>
<span class="line-added">1027     m_contextConnections.add(connection.registrableDomain(), &amp;connection);</span>
<span class="line-added">1028 </span>
<span class="line-added">1029     contextConnectionCreated(connection);</span>
<span class="line-added">1030 }</span>
<span class="line-added">1031 </span>
<span class="line-added">1032 void SWServer::removeContextConnection(SWServerToContextConnection&amp; connection)</span>
<span class="line-added">1033 {</span>
<span class="line-added">1034     RELEASE_LOG(ServiceWorker, &quot;SWServer::removeContextConnection&quot;);</span>
<span class="line-added">1035 </span>
<span class="line-added">1036     auto&amp; registrableDomain = connection.registrableDomain();</span>
<span class="line-added">1037 </span>
<span class="line-added">1038     ASSERT(m_contextConnections.get(registrableDomain) == &amp;connection);</span>
<span class="line-added">1039 </span>
<span class="line-added">1040     m_contextConnections.remove(registrableDomain);</span>
<span class="line-added">1041     markAllWorkersForRegistrableDomainAsTerminated(registrableDomain);</span>
<span class="line-added">1042     if (needsContextConnectionForRegistrableDomain(registrableDomain))</span>
<span class="line-added">1043         createContextConnection(registrableDomain);</span>
<span class="line-added">1044 }</span>
<span class="line-added">1045 </span>
<span class="line-added">1046 void SWServer::createContextConnection(const RegistrableDomain&amp; registrableDomain)</span>
<span class="line-added">1047 {</span>
<span class="line-added">1048     ASSERT(!m_contextConnections.contains(registrableDomain));</span>
<span class="line-added">1049     if (m_pendingConnectionDomains.contains(registrableDomain))</span>
<span class="line-added">1050         return;</span>
<span class="line-added">1051 </span>
<span class="line-added">1052     RELEASE_LOG(ServiceWorker, &quot;SWServer::createContextConnection will create a connection&quot;);</span>
<span class="line-added">1053 </span>
<span class="line-added">1054     m_pendingConnectionDomains.add(registrableDomain);</span>
<span class="line-added">1055     m_createContextConnectionCallback(registrableDomain, [this, weakThis = makeWeakPtr(this), registrableDomain] {</span>
<span class="line-added">1056         if (!weakThis)</span>
<span class="line-added">1057             return;</span>
<span class="line-added">1058 </span>
<span class="line-added">1059         RELEASE_LOG(ServiceWorker, &quot;SWServer::createContextConnection should now have created a connection&quot;);</span>
<span class="line-added">1060 </span>
<span class="line-added">1061         ASSERT(m_pendingConnectionDomains.contains(registrableDomain));</span>
<span class="line-added">1062         m_pendingConnectionDomains.remove(registrableDomain);</span>
<span class="line-added">1063 </span>
<span class="line-added">1064         if (m_contextConnections.contains(registrableDomain))</span>
<span class="line-added">1065             return;</span>
<span class="line-added">1066 </span>
<span class="line-added">1067         if (needsContextConnectionForRegistrableDomain(registrableDomain))</span>
<span class="line-added">1068             createContextConnection(registrableDomain);</span>
<span class="line-added">1069     });</span>
<span class="line-added">1070 }</span>
<span class="line-added">1071 </span>
<span class="line-added">1072 bool SWServer::canHandleScheme(StringView scheme) const</span>
<span class="line-added">1073 {</span>
<span class="line-added">1074     if (scheme.isNull())</span>
<span class="line-added">1075         return false;</span>
<span class="line-added">1076     if (!equalLettersIgnoringASCIICase(scheme.substring(0, 4), &quot;http&quot;))</span>
<span class="line-added">1077         return false;</span>
<span class="line-added">1078     if (scheme.length() == 5 &amp;&amp; isASCIIAlphaCaselessEqual(scheme[4], &#39;s&#39;))</span>
<span class="line-added">1079         return true;</span>
<span class="line-added">1080     return scheme.length() == 4;</span>
<span class="line-added">1081 }</span>
<span class="line-added">1082 </span>
<span class="line-added">1083 // https://w3c.github.io/ServiceWorker/#soft-update</span>
<span class="line-added">1084 void SWServer::softUpdate(SWServerRegistration&amp; registration)</span>
<span class="line-added">1085 {</span>
<span class="line-added">1086     ServiceWorkerJobData jobData(Process::identifier(), ServiceWorkerIdentifier::generate());</span>
<span class="line-added">1087     jobData.scriptURL = registration.scriptURL();</span>
<span class="line-added">1088     jobData.topOrigin = registration.key().topOrigin();</span>
<span class="line-added">1089     jobData.scopeURL = registration.scopeURLWithoutFragment();</span>
<span class="line-added">1090     jobData.type = ServiceWorkerJobType::Update;</span>
<span class="line-added">1091     scheduleJob(WTFMove(jobData));</span>
<span class="line-added">1092 }</span>
<span class="line-added">1093 </span>
1094 } // namespace WebCore
1095 
1096 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="RegistrationDatabase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
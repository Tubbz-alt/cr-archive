<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderGrid.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderImage.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 243,14 ***</span>
      if (m_needsToSetSizeForAltText) {
          if (!m_altText.isEmpty() &amp;&amp; setImageSizeForAltText(cachedImage()))
              repaintOrMarkForLayout(ImageSizeChangeForAltText);
          m_needsToSetSizeForAltText = false;
      }
<span class="line-removed">- #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
      if (diff == StyleDifference::Layout &amp;&amp; oldStyle-&gt;imageOrientation() != style().imageOrientation())
          return repaintOrMarkForLayout(ImageSizeChangeNone);
<span class="line-removed">- #endif</span>
  
  #if ENABLE(CSS_IMAGE_RESOLUTION)
      if (diff == StyleDifference::Layout
          &amp;&amp; (oldStyle-&gt;imageResolution() != style().imageResolution()
              || oldStyle-&gt;imageResolutionSnap() != style().imageResolutionSnap()
<span class="line-new-header">--- 243,12 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,20 ***</span>
<span class="line-new-header">--- 376,34 ---</span>
  
      if (is&lt;HTMLImageElement&gt;(element()))
          page().didFinishLoadingImageForElement(downcast&lt;HTMLImageElement&gt;(*element()));
  }
  
<span class="line-added">+ void RenderImage::setImageDevicePixelRatio(float factor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_imageDevicePixelRatio == factor)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_imageDevicePixelRatio = factor;</span>
<span class="line-added">+     intrinsicSizeChanged();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool RenderImage::isShowingMissingOrImageError() const
  {
      return !imageResource().cachedImage() || imageResource().errorOccurred();
  }
  
  bool RenderImage::isShowingAltText() const
  {
      return isShowingMissingOrImageError() &amp;&amp; !m_altText.isEmpty();
  }
  
<span class="line-added">+ bool RenderImage::shouldDisplayBrokenImageIcon() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return imageResource().errorOccurred();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  bool RenderImage::hasNonBitmapImage() const
  {
      if (!imageResource().cachedImage())
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,11 ***</span>
  
      auto contentSize = this-&gt;contentSize();
      float deviceScaleFactor = document().deviceScaleFactor();
      LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
  
<span class="line-modified">!     if (!imageResource().cachedImage() || imageResource().errorOccurred()) {</span>
          if (paintInfo.phase == PaintPhase::Selection)
              return;
  
          if (paintInfo.phase == PaintPhase::Foreground)
              page().addRelevantUnpaintedObject(this, visualOverflowRect());
<span class="line-new-header">--- 441,11 ---</span>
  
      auto contentSize = this-&gt;contentSize();
      float deviceScaleFactor = document().deviceScaleFactor();
      LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
  
<span class="line-modified">!     if (!imageResource().cachedImage() || shouldDisplayBrokenImageIcon()) {</span>
          if (paintInfo.phase == PaintPhase::Selection)
              return;
  
          if (paintInfo.phase == PaintPhase::Foreground)
              page().addRelevantUnpaintedObject(this, visualOverflowRect());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 447,21 ***</span>
              LayoutUnit topPad = paddingTop();
  
              bool errorPictureDrawn = false;
              LayoutSize imageOffset;
              // When calculating the usable dimensions, exclude the pixels of
<span class="line-modified">!             // the ouline rect so the error image/alt text doesn&#39;t draw on it.</span>
              LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
  
              RefPtr&lt;Image&gt; image = imageResource().image();
  
<span class="line-modified">!             if (imageResource().errorOccurred() &amp;&amp; !image-&gt;isNull() &amp;&amp; usableSize.width() &gt;= image-&gt;width() &amp;&amp; usableSize.height() &gt;= image-&gt;height()) {</span>
                  // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
                  std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = cachedImage()-&gt;brokenImage(deviceScaleFactor);
                  image = brokenImageAndImageScaleFactor.first;
                  FloatSize imageSize = image-&gt;size();
                  imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
                  // Center the error image, accounting for border and padding.
                  LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };
                  if (centerX &lt; 0)
                      centerX = 0;
                  LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };
<span class="line-new-header">--- 459,22 ---</span>
              LayoutUnit topPad = paddingTop();
  
              bool errorPictureDrawn = false;
              LayoutSize imageOffset;
              // When calculating the usable dimensions, exclude the pixels of
<span class="line-modified">!             // the outline rect so the error image/alt text doesn&#39;t draw on it.</span>
              LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
  
              RefPtr&lt;Image&gt; image = imageResource().image();
  
<span class="line-modified">!             if (shouldDisplayBrokenImageIcon() &amp;&amp; !image-&gt;isNull() &amp;&amp; usableSize.width() &gt;= image-&gt;width() &amp;&amp; usableSize.height() &gt;= image-&gt;height()) {</span>
                  // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
                  std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = cachedImage()-&gt;brokenImage(deviceScaleFactor);
                  image = brokenImageAndImageScaleFactor.first;
                  FloatSize imageSize = image-&gt;size();
                  imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
<span class="line-added">+ </span>
                  // Center the error image, accounting for border and padding.
                  LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };
                  if (centerX &lt; 0)
                      centerX = 0;
                  LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 615,26 ***</span>
      RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(rect.size()));
      if (!img || img-&gt;isNull())
          return ImageDrawResult::DidNothing;
  
      HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr;
<span class="line-removed">-     CompositeOperator compositeOperator = imageElement ? imageElement-&gt;compositeOperator() : CompositeSourceOver;</span>
  
      // FIXME: Document when image != img.get().
      Image* image = imageResource().image().get();
<span class="line-removed">-     InterpolationQuality interpolation = image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationDefault;</span>
  
  #if USE(CG)
      if (is&lt;PDFDocumentImage&gt;(image))
          downcast&lt;PDFDocumentImage&gt;(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
  #endif
  
      if (is&lt;BitmapImage&gt;(image))
          downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
  
<span class="line-modified">!     auto decodingMode = decodingModeForImageDraw(*image, paintInfo);</span>
<span class="line-modified">!     auto drawResult = paintInfo.context().drawImage(*img, rect, { compositeOperator, BlendMode::Normal, decodingMode, imageOrientation(), interpolation });</span>
      if (drawResult == ImageDrawResult::DidRequestDecoding)
          imageResource().cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
  
  #if USE(SYSTEM_PREVIEW)
      if (imageElement &amp;&amp; imageElement-&gt;isSystemPreviewImage() &amp;&amp; drawResult == ImageDrawResult::DidDraw &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
<span class="line-new-header">--- 628,30 ---</span>
      RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(rect.size()));
      if (!img || img-&gt;isNull())
          return ImageDrawResult::DidNothing;
  
      HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr;
  
      // FIXME: Document when image != img.get().
      Image* image = imageResource().image().get();
  
  #if USE(CG)
      if (is&lt;PDFDocumentImage&gt;(image))
          downcast&lt;PDFDocumentImage&gt;(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
  #endif
  
      if (is&lt;BitmapImage&gt;(image))
          downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
  
<span class="line-modified">!     ImagePaintingOptions options = {</span>
<span class="line-modified">!         imageElement ? imageElement-&gt;compositeOperator() : CompositeOperator::SourceOver,</span>
<span class="line-added">+         decodingModeForImageDraw(*image, paintInfo),</span>
<span class="line-added">+         imageOrientation(),</span>
<span class="line-added">+         image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationQuality::Default</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto drawResult = paintInfo.context().drawImage(*img, rect, options);</span>
      if (drawResult == ImageDrawResult::DidRequestDecoding)
          imageResource().cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
  
  #if USE(SYSTEM_PREVIEW)
      if (imageElement &amp;&amp; imageElement-&gt;isSystemPreviewImage() &amp;&amp; drawResult == ImageDrawResult::DidDraw &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 817,12 ***</span>
              auto&amp; box = downcast&lt;RenderBox&gt;(*containingBlock);
              intrinsicSize.setWidth(box.availableLogicalWidth());
              intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
          }
      }
      // Don&#39;t compute an intrinsic ratio to preserve historical WebKit behavior if we&#39;re painting alt text and/or a broken image.
<span class="line-modified">!     if (imageResource().errorOccurred()) {</span>
          intrinsicRatio = 1;
          return;
      }
  }
  
<span class="line-new-header">--- 834,13 ---</span>
              auto&amp; box = downcast&lt;RenderBox&gt;(*containingBlock);
              intrinsicSize.setWidth(box.availableLogicalWidth());
              intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
          }
      }
<span class="line-added">+ </span>
      // Don&#39;t compute an intrinsic ratio to preserve historical WebKit behavior if we&#39;re painting alt text and/or a broken image.
<span class="line-modified">!     if (shouldDisplayBrokenImageIcon()) {</span>
          intrinsicRatio = 1;
          return;
      }
  }
  
</pre>
<center><a href="RenderGrid.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderImage.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
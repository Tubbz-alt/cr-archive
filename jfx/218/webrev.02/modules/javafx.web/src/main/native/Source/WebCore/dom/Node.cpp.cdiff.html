<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NameNodeList.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 75,10 ***</span>
<span class="line-new-header">--- 75,11 ---</span>
  #include &quot;TextEvent.h&quot;
  #include &quot;TouchEvent.h&quot;
  #include &quot;WheelEvent.h&quot;
  #include &quot;XMLNSNames.h&quot;
  #include &quot;XMLNames.h&quot;
<span class="line-added">+ #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/RefCountedLeakCounter.h&gt;
  #include &lt;wtf/SHA1.h&gt;
  #include &lt;wtf/Variant.h&gt;
  #include &lt;wtf/text/CString.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
      if (hasEventTargetData())
          clearEventTargetData();
  
      document().decrementReferencingNodeCount();
  
<span class="line-modified">! #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (!ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS))</span>
      for (auto* document : Document::allDocuments()) {
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
      }
<span class="line-new-header">--- 362,11 ---</span>
      if (hasEventTargetData())
          clearEventTargetData();
  
      document().decrementReferencingNodeCount();
  
<span class="line-modified">! #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS))</span>
      for (auto* document : Document::allDocuments()) {
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
          ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,12 ***</span>
                  continue;
              }
  
              // Both non-empty text nodes. Merge them.
              unsigned offset = text-&gt;length();
<span class="line-modified">!             text-&gt;appendData(nextText-&gt;data());</span>
              document().textNodesMerged(nextText, offset);
              nextText-&gt;remove();
          }
  
          node = NodeTraversal::nextPostOrder(*node);
      }
<span class="line-new-header">--- 668,17 ---</span>
                  continue;
              }
  
              // Both non-empty text nodes. Merge them.
              unsigned offset = text-&gt;length();
<span class="line-modified">! </span>
<span class="line-added">+             // Update start/end for any affected Ranges before appendData since modifying contents might trigger mutation events that modify ordering.</span>
              document().textNodesMerged(nextText, offset);
<span class="line-added">+ </span>
<span class="line-added">+             // FIXME: DOM spec requires contents to be replaced all at once (see https://dom.spec.whatwg.org/#dom-node-normalize).</span>
<span class="line-added">+             // Appending once per sibling may trigger mutation events too many times.</span>
<span class="line-added">+             text-&gt;appendData(nextText-&gt;data());</span>
              nextText-&gt;remove();
          }
  
          node = NodeTraversal::nextPostOrder(*node);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1127,11 ***</span>
  {
      ContainerNode&amp; root = treeScope().rootNode();
      return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
  static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
  {
      return A.isInShadowTree()
          &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
<span class="line-new-header">--- 1133,11 ---</span>
  {
      ContainerNode&amp; root = treeScope().rootNode();
      return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
  static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
  {
      return A.isInShadowTree()
          &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1607,10 ***</span>
<span class="line-new-header">--- 1613,18 ---</span>
      unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
  
      return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
  }
  
<span class="line-added">+ bool areNodesConnectedInSameTreeScope(const Node* a, const Node* b)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!a || !b)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     // Note that we avoid comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).</span>
<span class="line-added">+     return a-&gt;isConnected() == b-&gt;isConnected() &amp;&amp; &amp;a-&gt;treeScope() == &amp;b-&gt;treeScope();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
  {
      if (&amp;otherNode == this)
          return DOCUMENT_POSITION_EQUIVALENT;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1651,13 ***</span>
          ASSERT_NOT_REACHED();
          return DOCUMENT_POSITION_DISCONNECTED;
      }
  
      // If one node is in the document and the other is not, we must be disconnected.
<span class="line-modified">!     // If the nodes have different owning documents, they must be disconnected.  Note that we avoid</span>
<span class="line-modified">!     // comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).</span>
<span class="line-removed">-     if (start1-&gt;isConnected() != start2-&gt;isConnected() || &amp;start1-&gt;treeScope() != &amp;start2-&gt;treeScope())</span>
          return compareDetachedElementsPosition(*this, otherNode);
  
      // We need to find a common ancestor container, and then compare the indices of the two immediate children.
      Node* current;
      for (current = start1; current; current = current-&gt;parentNode())
<span class="line-new-header">--- 1665,12 ---</span>
          ASSERT_NOT_REACHED();
          return DOCUMENT_POSITION_DISCONNECTED;
      }
  
      // If one node is in the document and the other is not, we must be disconnected.
<span class="line-modified">!     // If the nodes have different owning documents, they must be disconnected.</span>
<span class="line-modified">!     if (!areNodesConnectedInSameTreeScope(start1, start2))</span>
          return compareDetachedElementsPosition(*this, otherNode);
  
      // We need to find a common ancestor container, and then compare the indices of the two immediate children.
      Node* current;
      for (current = start1; current; current = current-&gt;parentNode())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1904,24 ***</span>
  
  // --------
  
  void NodeListsNodeData::invalidateCaches()
  {
<span class="line-modified">!     for (auto&amp; atomicName : m_atomicNameCaches)</span>
<span class="line-modified">!         atomicName.value-&gt;invalidateCache();</span>
  
      for (auto&amp; collection : m_cachedCollections)
          collection.value-&gt;invalidateCache();
  
      for (auto&amp; tagCollection : m_tagCollectionNSCache)
          tagCollection.value-&gt;invalidateCache();
  }
  
  void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
  {
<span class="line-modified">!     for (auto&amp; atomicName : m_atomicNameCaches)</span>
<span class="line-modified">!         atomicName.value-&gt;invalidateCacheForAttribute(attrName);</span>
  
      for (auto&amp; collection : m_cachedCollections)
          collection.value-&gt;invalidateCacheForAttribute(attrName);
  }
  
<span class="line-new-header">--- 1917,24 ---</span>
  
  // --------
  
  void NodeListsNodeData::invalidateCaches()
  {
<span class="line-modified">!     for (auto&amp; atomName : m_atomNameCaches)</span>
<span class="line-modified">!         atomName.value-&gt;invalidateCache();</span>
  
      for (auto&amp; collection : m_cachedCollections)
          collection.value-&gt;invalidateCache();
  
      for (auto&amp; tagCollection : m_tagCollectionNSCache)
          tagCollection.value-&gt;invalidateCache();
  }
  
  void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
  {
<span class="line-modified">!     for (auto&amp; atomName : m_atomNameCaches)</span>
<span class="line-modified">!         atomName.value-&gt;invalidateCacheForAttribute(attrName);</span>
  
      for (auto&amp; collection : m_cachedCollections)
          collection.value-&gt;invalidateCacheForAttribute(attrName);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2086,11 ***</span>
              newDocument.addTouchEventHandler(*this);
          }
  #endif
      }
  
<span class="line-modified">! #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
      ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
      ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
  #endif
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
<span class="line-new-header">--- 2099,11 ---</span>
              newDocument.addTouchEventHandler(*this);
          }
  #endif
      }
  
<span class="line-modified">! #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
      ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
      ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
  #endif
  #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2112,12 ***</span>
          targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
      else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)</span>
<span class="line-modified">!         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();</span>
  
  #if ENABLE(TOUCH_EVENTS)
      if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().addTouchEventListener(*targetNode);
  #endif
<span class="line-new-header">--- 2125,14 ---</span>
          targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
      else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {</span>
<span class="line-modified">!         if (auto* window = targetNode-&gt;document().domWindow())</span>
<span class="line-added">+             window-&gt;incrementScrollEventListenersCount();</span>
<span class="line-added">+     }</span>
  
  #if ENABLE(TOUCH_EVENTS)
      if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().addTouchEventListener(*targetNode);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2147,12 ***</span>
          targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
      else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)</span>
<span class="line-modified">!         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();</span>
  
  #if ENABLE(TOUCH_EVENTS)
      if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().removeTouchEventListener(*targetNode);
  #endif
<span class="line-new-header">--- 2162,14 ---</span>
          targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
      else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {</span>
<span class="line-modified">!         if (auto* window = targetNode-&gt;document().domWindow())</span>
<span class="line-added">+             window-&gt;decrementScrollEventListenersCount();</span>
<span class="line-added">+     }</span>
  
  #if ENABLE(TOUCH_EVENTS)
      if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
          targetNode-&gt;document().removeTouchEventListener(*targetNode);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2426,10 ***</span>
<span class="line-new-header">--- 2443,16 ---</span>
      } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
          if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
              if (enclosingLinkEventParentOrSelf())
                  return;
  
<span class="line-added">+             // Avoid that canBeScrolledAndHasScrollableArea changes render tree</span>
<span class="line-added">+             // structure.</span>
<span class="line-added">+             // FIXME: We should avoid synchronous layout if possible. We can</span>
<span class="line-added">+             // remove this synchronous layout if we avoid synchronous layout in</span>
<span class="line-added">+             // RenderTextControlSingleLine::scrollHeight</span>
<span class="line-added">+             document().updateLayoutIgnorePendingStylesheets();</span>
              RenderObject* renderer = this-&gt;renderer();
              while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
                  renderer = renderer-&gt;parent();
  
              if (renderer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2521,11 ***</span>
      // may outlive the SVGElement. The only difference after the detach is no commit will
      // be carried out unless these properties are attached to another owner.
      if (is&lt;SVGElement&gt;(*this))
          downcast&lt;SVGElement&gt;(*this).detachAllProperties();
  
<span class="line-modified">! #ifndef NDEBUG</span>
      m_deletionHasBegun = true;
  #endif
      delete this;
  }
  
<span class="line-new-header">--- 2544,11 ---</span>
      // may outlive the SVGElement. The only difference after the detach is no commit will
      // be carried out unless these properties are attached to another owner.
      if (is&lt;SVGElement&gt;(*this))
          downcast&lt;SVGElement&gt;(*this).detachAllProperties();
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      m_deletionHasBegun = true;
  #endif
      delete this;
  }
  
</pre>
<center><a href="NameNodeList.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
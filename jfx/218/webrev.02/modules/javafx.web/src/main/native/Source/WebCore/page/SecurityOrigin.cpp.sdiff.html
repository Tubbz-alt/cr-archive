<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollToOptions.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SecurityOrigin.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SecurityOrigin.h&quot;
 31 
 32 #include &quot;BlobURL.h&quot;

 33 #include &quot;OriginAccessEntry.h&quot;
 34 #include &quot;PublicSuffix.h&quot;
<span class="line-modified"> 35 #include &quot;SchemeRegistry.h&quot;</span>
 36 #include &quot;SecurityPolicy.h&quot;
 37 #include &quot;TextEncoding.h&quot;
 38 #include &quot;ThreadableBlobRegistry.h&quot;
 39 #include &lt;wtf/FileSystem.h&gt;
 40 #include &lt;wtf/MainThread.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/StdLibExtras.h&gt;
 43 #include &lt;wtf/URL.h&gt;
 44 #include &lt;wtf/text/StringBuilder.h&gt;
 45 
 46 namespace WebCore {
 47 


 48 static bool schemeRequiresHost(const URL&amp; url)
 49 {
 50     // We expect URLs with these schemes to have authority components. If the
 51     // URL lacks an authority component, we get concerned and mark the origin
 52     // as unique.
 53     return url.protocolIsInHTTPFamily() || url.protocolIs(&quot;ftp&quot;);
 54 }
 55 





 56 bool SecurityOrigin::shouldUseInnerURL(const URL&amp; url)
 57 {
 58     // FIXME: Blob URLs don&#39;t have inner URLs. Their form is &quot;blob:&lt;inner-origin&gt;/&lt;UUID&gt;&quot;, so treating the part after &quot;blob:&quot; as a URL is incorrect.
 59     if (url.protocolIsBlob())
 60         return true;
 61     UNUSED_PARAM(url);
 62     return false;
 63 }
 64 
 65 // In general, extracting the inner URL varies by scheme. It just so happens
 66 // that all the URL schemes we currently support that use inner URLs for their
 67 // security origin can be parsed using this algorithm.
 68 URL SecurityOrigin::extractInnerURL(const URL&amp; url)
 69 {
 70     // FIXME: Update this callsite to use the innerURL member function when
 71     // we finish implementing it.
 72     return { URL(), decodeURLEscapeSequences(url.path()) };
 73 }
 74 
 75 static RefPtr&lt;SecurityOrigin&gt; getCachedOrigin(const URL&amp; url)
</pre>
<hr />
<pre>
 78         return ThreadableBlobRegistry::getCachedOrigin(url);
 79     return nullptr;
 80 }
 81 
 82 static bool shouldTreatAsUniqueOrigin(const URL&amp; url)
 83 {
 84     if (!url.isValid())
 85         return true;
 86 
 87     // FIXME: Do we need to unwrap the URL further?
 88     URL innerURL = SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 89 
 90     // FIXME: Check whether innerURL is valid.
 91 
 92     // For edge case URLs that were probably misparsed, make sure that the origin is unique.
 93     // This is an additional safety net against bugs in URL parsing, and for network back-ends that parse URLs differently,
 94     // and could misinterpret another component for hostname.
 95     if (schemeRequiresHost(innerURL) &amp;&amp; innerURL.host().isEmpty())
 96         return true;
 97 
<span class="line-modified"> 98     if (SchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))</span>
 99         return true;
100 
101     // This is the common case.
102     return false;
103 }
104 
105 static bool isLoopbackIPAddress(StringView host)
106 {
107     // The IPv6 loopback address is 0:0:0:0:0:0:0:1, which compresses to ::1.
108     if (host == &quot;[::1]&quot;)
109         return true;
110 
111     // Check to see if it&#39;s a valid IPv4 address that has the form 127.*.*.*.
112     if (!host.startsWith(&quot;127.&quot;))
113         return false;
114     size_t dotsFound = 0;
115     for (size_t i = 0; i &lt; host.length(); ++i) {
116         if (host[i] == &#39;.&#39;) {
117             dotsFound++;
118             continue;
119         }
120         if (!isASCIIDigit(host[i]))
121             return false;
122     }
123     return dotsFound == 3;
124 }
125 
126 // https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy (Editor&#39;s Draft, 17 November 2016)
127 static bool shouldTreatAsPotentiallyTrustworthy(const String&amp; protocol, const String&amp; host)
128 {
<span class="line-modified">129     if (SchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))</span>
130         return true;
131 
132     if (SecurityOrigin::isLocalHostOrLoopbackIPAddress(host))
133         return true;
134 
<span class="line-modified">135     if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
136         return true;
137 
138     return false;
139 }
140 
141 bool shouldTreatAsPotentiallyTrustworthy(const URL&amp; url)
142 {
143     return shouldTreatAsPotentiallyTrustworthy(url.protocol().toStringWithoutCopying(), url.host().toStringWithoutCopying());
144 }
145 
146 SecurityOrigin::SecurityOrigin(const URL&amp; url)
147     : m_data(SecurityOriginData::fromURL(url))
<span class="line-modified">148     , m_isLocal(SchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))</span>
149 {
150     // document.domain starts as m_data.host, but can be set by the DOM.
151     m_domain = m_data.host;
152 
153     if (m_data.port &amp;&amp; WTF::isDefaultPortForProtocol(m_data.port.value(), m_data.protocol))
154         m_data.port = WTF::nullopt;
155 
156     // By default, only local SecurityOrigins can load local resources.
157     m_canLoadLocalResources = isLocal();
158 
159     if (m_canLoadLocalResources)
160         m_filePath = url.fileSystemPath(); // In case enforceFilePathSeparation() is called.
161 
162     m_isPotentiallyTrustworthy = shouldTreatAsPotentiallyTrustworthy(url);
163 }
164 
165 SecurityOrigin::SecurityOrigin()
166     : m_data { emptyString(), emptyString(), WTF::nullopt }
167     , m_domain { emptyString() }
168     , m_isUnique { true }
</pre>
<hr />
<pre>
212     ASSERT(!url.isLocalFile());
213     auto securityOrigin = SecurityOrigin::create(url);
214     securityOrigin-&gt;m_filePath = filePath;
215     return securityOrigin;
216 }
217 
218 Ref&lt;SecurityOrigin&gt; SecurityOrigin::isolatedCopy() const
219 {
220     return adoptRef(*new SecurityOrigin(this));
221 }
222 
223 void SecurityOrigin::setDomainFromDOM(const String&amp; newDomain)
224 {
225     m_domainWasSetInDOM = true;
226     m_domain = newDomain.convertToASCIILowercase();
227 }
228 
229 bool SecurityOrigin::isSecure(const URL&amp; url)
230 {
231     // Invalid URLs are secure, as are URLs which have a secure protocol.
<span class="line-modified">232     if (!url.isValid() || SchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))</span>
233         return true;
234 
235     // URLs that wrap inner URLs are secure if those inner URLs are secure.
<span class="line-modified">236     if (shouldUseInnerURL(url) &amp;&amp; SchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))</span>
237         return true;
238 
239     return false;
240 }
241 
242 bool SecurityOrigin::canAccess(const SecurityOrigin&amp; other) const
243 {
244     if (m_universalAccess)
245         return true;
246 
247     if (this == &amp;other)
248         return true;
249 
250     if (isUnique() || other.isUnique())
251         return false;
252 
253     // Here are two cases where we should permit access:
254     //
255     // 1) Neither document has set document.domain. In this case, we insist
256     //    that the scheme, host, and port of the URLs match.
</pre>
<hr />
<pre>
336 // local or remote depending on what is nested. Currently we just check if we are nesting
337 // http or https, otherwise we ignore the nesting for the purpose of a security check. We need
338 // a facility for registering nesting schemes, and some generalized logic for them.
339 // This function should be removed as an outcome of https://bugs.webkit.org/show_bug.cgi?id=69196
340 static bool isFeedWithNestedProtocolInHTTPFamily(const URL&amp; url)
341 {
342     const String&amp; string = url.string();
343     if (!startsWithLettersIgnoringASCIICase(string, &quot;feed&quot;))
344         return false;
345     return startsWithLettersIgnoringASCIICase(string, &quot;feed://&quot;)
346         || startsWithLettersIgnoringASCIICase(string, &quot;feed:http:&quot;)
347         || startsWithLettersIgnoringASCIICase(string, &quot;feed:https:&quot;)
348         || startsWithLettersIgnoringASCIICase(string, &quot;feeds:http:&quot;)
349         || startsWithLettersIgnoringASCIICase(string, &quot;feeds:https:&quot;)
350         || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:http:&quot;)
351         || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:https:&quot;);
352 }
353 
354 bool SecurityOrigin::canDisplay(const URL&amp; url) const
355 {

356     if (m_universalAccess)
357         return true;
358 
<span class="line-modified">359 #if !PLATFORM(IOS_FAMILY)</span>



360     if (m_data.protocol == &quot;file&quot; &amp;&amp; url.isLocalFile() &amp;&amp; !FileSystem::filesHaveSameVolume(m_filePath, url.fileSystemPath()))
361         return false;
362 #endif
363 
364     if (isFeedWithNestedProtocolInHTTPFamily(url))
365         return true;
366 
367     String protocol = url.protocol().toString();
368 
<span class="line-modified">369     if (SchemeRegistry::canDisplayOnlyIfCanRequest(protocol))</span>
370         return canRequest(url);
371 
<span class="line-modified">372     if (SchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))</span>
373         return equalIgnoringASCIICase(m_data.protocol, protocol) || SecurityPolicy::isAccessToURLWhiteListed(this, url);
374 
375     if (!SecurityPolicy::restrictAccessToLocal())
376         return true;
377 
378     if (url.isLocalFile() &amp;&amp; url.fileSystemPath() == m_filePath)
379         return true;
380 
<span class="line-modified">381     if (SchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
382         return canLoadLocalResources() || SecurityPolicy::isAccessToURLWhiteListed(this, url);
383 
384     return true;
385 }
386 
387 bool SecurityOrigin::canAccessStorage(const SecurityOrigin* topOrigin, ShouldAllowFromThirdParty shouldAllowFromThirdParty) const
388 {
389     if (isUnique())
390         return false;
391 
392     if (isLocal() &amp;&amp; !needsStorageAccessFromFileURLsQuirk() &amp;&amp; !m_universalAccess &amp;&amp; shouldAllowFromThirdParty != AlwaysAllowFromThirdParty)
393         return false;
394 
395     if (m_storageBlockingPolicy == BlockAllStorage)
396         return false;
397 
398     // FIXME: This check should be replaced with an ASSERT once we can guarantee that topOrigin is not null.
399     if (!topOrigin)
400         return true;
401 
</pre>
<hr />
<pre>
465 }
466 
467 void SecurityOrigin::grantUniversalAccess()
468 {
469     m_universalAccess = true;
470 }
471 
472 void SecurityOrigin::grantStorageAccessFromFileURLsQuirk()
473 {
474     m_needsStorageAccessFromFileURLsQuirk = true;
475 }
476 
477 String SecurityOrigin::domainForCachePartition() const
478 {
479     if (m_storageBlockingPolicy != BlockThirdPartyStorage)
480         return emptyString();
481 
482     if (isHTTPFamily())
483         return host();
484 
<span class="line-modified">485     if (SchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))</span>
486         return host();
487 
488     return emptyString();
489 }
490 
491 void SecurityOrigin::setEnforcesFilePathSeparation()
492 {
493     ASSERT(isLocal());
494     m_enforcesFilePathSeparation = true;
495 }
496 
497 String SecurityOrigin::toString() const
498 {
499     if (isUnique())
500         return &quot;null&quot;_s;
501     if (m_data.protocol == &quot;file&quot; &amp;&amp; m_enforcesFilePathSeparation)
502         return &quot;null&quot;_s;
503     return toRawString();
504 }
505 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SecurityOrigin.h&quot;
 31 
 32 #include &quot;BlobURL.h&quot;
<span class="line-added"> 33 #include &quot;LegacySchemeRegistry.h&quot;</span>
 34 #include &quot;OriginAccessEntry.h&quot;
 35 #include &quot;PublicSuffix.h&quot;
<span class="line-modified"> 36 #include &quot;RuntimeApplicationChecks.h&quot;</span>
 37 #include &quot;SecurityPolicy.h&quot;
 38 #include &quot;TextEncoding.h&quot;
 39 #include &quot;ThreadableBlobRegistry.h&quot;
 40 #include &lt;wtf/FileSystem.h&gt;
 41 #include &lt;wtf/MainThread.h&gt;
 42 #include &lt;wtf/NeverDestroyed.h&gt;
 43 #include &lt;wtf/StdLibExtras.h&gt;
 44 #include &lt;wtf/URL.h&gt;
 45 #include &lt;wtf/text/StringBuilder.h&gt;
 46 
 47 namespace WebCore {
 48 
<span class="line-added"> 49 constexpr unsigned maximumURLSize = 0x04000000;</span>
<span class="line-added"> 50 </span>
 51 static bool schemeRequiresHost(const URL&amp; url)
 52 {
 53     // We expect URLs with these schemes to have authority components. If the
 54     // URL lacks an authority component, we get concerned and mark the origin
 55     // as unique.
 56     return url.protocolIsInHTTPFamily() || url.protocolIs(&quot;ftp&quot;);
 57 }
 58 
<span class="line-added"> 59 bool SecurityOrigin::shouldIgnoreHost(const URL&amp; url)</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61     return url.protocolIsData() || url.protocolIsAbout() || protocolIsJavaScript(url) || url.protocolIs(&quot;file&quot;);</span>
<span class="line-added"> 62 }</span>
<span class="line-added"> 63 </span>
 64 bool SecurityOrigin::shouldUseInnerURL(const URL&amp; url)
 65 {
 66     // FIXME: Blob URLs don&#39;t have inner URLs. Their form is &quot;blob:&lt;inner-origin&gt;/&lt;UUID&gt;&quot;, so treating the part after &quot;blob:&quot; as a URL is incorrect.
 67     if (url.protocolIsBlob())
 68         return true;
 69     UNUSED_PARAM(url);
 70     return false;
 71 }
 72 
 73 // In general, extracting the inner URL varies by scheme. It just so happens
 74 // that all the URL schemes we currently support that use inner URLs for their
 75 // security origin can be parsed using this algorithm.
 76 URL SecurityOrigin::extractInnerURL(const URL&amp; url)
 77 {
 78     // FIXME: Update this callsite to use the innerURL member function when
 79     // we finish implementing it.
 80     return { URL(), decodeURLEscapeSequences(url.path()) };
 81 }
 82 
 83 static RefPtr&lt;SecurityOrigin&gt; getCachedOrigin(const URL&amp; url)
</pre>
<hr />
<pre>
 86         return ThreadableBlobRegistry::getCachedOrigin(url);
 87     return nullptr;
 88 }
 89 
 90 static bool shouldTreatAsUniqueOrigin(const URL&amp; url)
 91 {
 92     if (!url.isValid())
 93         return true;
 94 
 95     // FIXME: Do we need to unwrap the URL further?
 96     URL innerURL = SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 97 
 98     // FIXME: Check whether innerURL is valid.
 99 
100     // For edge case URLs that were probably misparsed, make sure that the origin is unique.
101     // This is an additional safety net against bugs in URL parsing, and for network back-ends that parse URLs differently,
102     // and could misinterpret another component for hostname.
103     if (schemeRequiresHost(innerURL) &amp;&amp; innerURL.host().isEmpty())
104         return true;
105 
<span class="line-modified">106     if (LegacySchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))</span>
107         return true;
108 
109     // This is the common case.
110     return false;
111 }
112 
113 static bool isLoopbackIPAddress(StringView host)
114 {
115     // The IPv6 loopback address is 0:0:0:0:0:0:0:1, which compresses to ::1.
116     if (host == &quot;[::1]&quot;)
117         return true;
118 
119     // Check to see if it&#39;s a valid IPv4 address that has the form 127.*.*.*.
120     if (!host.startsWith(&quot;127.&quot;))
121         return false;
122     size_t dotsFound = 0;
123     for (size_t i = 0; i &lt; host.length(); ++i) {
124         if (host[i] == &#39;.&#39;) {
125             dotsFound++;
126             continue;
127         }
128         if (!isASCIIDigit(host[i]))
129             return false;
130     }
131     return dotsFound == 3;
132 }
133 
134 // https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy (Editor&#39;s Draft, 17 November 2016)
135 static bool shouldTreatAsPotentiallyTrustworthy(const String&amp; protocol, const String&amp; host)
136 {
<span class="line-modified">137     if (LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))</span>
138         return true;
139 
140     if (SecurityOrigin::isLocalHostOrLoopbackIPAddress(host))
141         return true;
142 
<span class="line-modified">143     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
144         return true;
145 
146     return false;
147 }
148 
149 bool shouldTreatAsPotentiallyTrustworthy(const URL&amp; url)
150 {
151     return shouldTreatAsPotentiallyTrustworthy(url.protocol().toStringWithoutCopying(), url.host().toStringWithoutCopying());
152 }
153 
154 SecurityOrigin::SecurityOrigin(const URL&amp; url)
155     : m_data(SecurityOriginData::fromURL(url))
<span class="line-modified">156     , m_isLocal(LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))</span>
157 {
158     // document.domain starts as m_data.host, but can be set by the DOM.
159     m_domain = m_data.host;
160 
161     if (m_data.port &amp;&amp; WTF::isDefaultPortForProtocol(m_data.port.value(), m_data.protocol))
162         m_data.port = WTF::nullopt;
163 
164     // By default, only local SecurityOrigins can load local resources.
165     m_canLoadLocalResources = isLocal();
166 
167     if (m_canLoadLocalResources)
168         m_filePath = url.fileSystemPath(); // In case enforceFilePathSeparation() is called.
169 
170     m_isPotentiallyTrustworthy = shouldTreatAsPotentiallyTrustworthy(url);
171 }
172 
173 SecurityOrigin::SecurityOrigin()
174     : m_data { emptyString(), emptyString(), WTF::nullopt }
175     , m_domain { emptyString() }
176     , m_isUnique { true }
</pre>
<hr />
<pre>
220     ASSERT(!url.isLocalFile());
221     auto securityOrigin = SecurityOrigin::create(url);
222     securityOrigin-&gt;m_filePath = filePath;
223     return securityOrigin;
224 }
225 
226 Ref&lt;SecurityOrigin&gt; SecurityOrigin::isolatedCopy() const
227 {
228     return adoptRef(*new SecurityOrigin(this));
229 }
230 
231 void SecurityOrigin::setDomainFromDOM(const String&amp; newDomain)
232 {
233     m_domainWasSetInDOM = true;
234     m_domain = newDomain.convertToASCIILowercase();
235 }
236 
237 bool SecurityOrigin::isSecure(const URL&amp; url)
238 {
239     // Invalid URLs are secure, as are URLs which have a secure protocol.
<span class="line-modified">240     if (!url.isValid() || LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))</span>
241         return true;
242 
243     // URLs that wrap inner URLs are secure if those inner URLs are secure.
<span class="line-modified">244     if (shouldUseInnerURL(url) &amp;&amp; LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))</span>
245         return true;
246 
247     return false;
248 }
249 
250 bool SecurityOrigin::canAccess(const SecurityOrigin&amp; other) const
251 {
252     if (m_universalAccess)
253         return true;
254 
255     if (this == &amp;other)
256         return true;
257 
258     if (isUnique() || other.isUnique())
259         return false;
260 
261     // Here are two cases where we should permit access:
262     //
263     // 1) Neither document has set document.domain. In this case, we insist
264     //    that the scheme, host, and port of the URLs match.
</pre>
<hr />
<pre>
344 // local or remote depending on what is nested. Currently we just check if we are nesting
345 // http or https, otherwise we ignore the nesting for the purpose of a security check. We need
346 // a facility for registering nesting schemes, and some generalized logic for them.
347 // This function should be removed as an outcome of https://bugs.webkit.org/show_bug.cgi?id=69196
348 static bool isFeedWithNestedProtocolInHTTPFamily(const URL&amp; url)
349 {
350     const String&amp; string = url.string();
351     if (!startsWithLettersIgnoringASCIICase(string, &quot;feed&quot;))
352         return false;
353     return startsWithLettersIgnoringASCIICase(string, &quot;feed://&quot;)
354         || startsWithLettersIgnoringASCIICase(string, &quot;feed:http:&quot;)
355         || startsWithLettersIgnoringASCIICase(string, &quot;feed:https:&quot;)
356         || startsWithLettersIgnoringASCIICase(string, &quot;feeds:http:&quot;)
357         || startsWithLettersIgnoringASCIICase(string, &quot;feeds:https:&quot;)
358         || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:http:&quot;)
359         || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:https:&quot;);
360 }
361 
362 bool SecurityOrigin::canDisplay(const URL&amp; url) const
363 {
<span class="line-added">364     ASSERT(!isInNetworkProcess());</span>
365     if (m_universalAccess)
366         return true;
367 
<span class="line-modified">368     if (url.pathEnd() &gt; maximumURLSize)</span>
<span class="line-added">369         return false;</span>
<span class="line-added">370 </span>
<span class="line-added">371 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !ENABLE(BUBBLEWRAP_SANDBOX)</span>
372     if (m_data.protocol == &quot;file&quot; &amp;&amp; url.isLocalFile() &amp;&amp; !FileSystem::filesHaveSameVolume(m_filePath, url.fileSystemPath()))
373         return false;
374 #endif
375 
376     if (isFeedWithNestedProtocolInHTTPFamily(url))
377         return true;
378 
379     String protocol = url.protocol().toString();
380 
<span class="line-modified">381     if (LegacySchemeRegistry::canDisplayOnlyIfCanRequest(protocol))</span>
382         return canRequest(url);
383 
<span class="line-modified">384     if (LegacySchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))</span>
385         return equalIgnoringASCIICase(m_data.protocol, protocol) || SecurityPolicy::isAccessToURLWhiteListed(this, url);
386 
387     if (!SecurityPolicy::restrictAccessToLocal())
388         return true;
389 
390     if (url.isLocalFile() &amp;&amp; url.fileSystemPath() == m_filePath)
391         return true;
392 
<span class="line-modified">393     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
394         return canLoadLocalResources() || SecurityPolicy::isAccessToURLWhiteListed(this, url);
395 
396     return true;
397 }
398 
399 bool SecurityOrigin::canAccessStorage(const SecurityOrigin* topOrigin, ShouldAllowFromThirdParty shouldAllowFromThirdParty) const
400 {
401     if (isUnique())
402         return false;
403 
404     if (isLocal() &amp;&amp; !needsStorageAccessFromFileURLsQuirk() &amp;&amp; !m_universalAccess &amp;&amp; shouldAllowFromThirdParty != AlwaysAllowFromThirdParty)
405         return false;
406 
407     if (m_storageBlockingPolicy == BlockAllStorage)
408         return false;
409 
410     // FIXME: This check should be replaced with an ASSERT once we can guarantee that topOrigin is not null.
411     if (!topOrigin)
412         return true;
413 
</pre>
<hr />
<pre>
477 }
478 
479 void SecurityOrigin::grantUniversalAccess()
480 {
481     m_universalAccess = true;
482 }
483 
484 void SecurityOrigin::grantStorageAccessFromFileURLsQuirk()
485 {
486     m_needsStorageAccessFromFileURLsQuirk = true;
487 }
488 
489 String SecurityOrigin::domainForCachePartition() const
490 {
491     if (m_storageBlockingPolicy != BlockThirdPartyStorage)
492         return emptyString();
493 
494     if (isHTTPFamily())
495         return host();
496 
<span class="line-modified">497     if (LegacySchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))</span>
498         return host();
499 
500     return emptyString();
501 }
502 
503 void SecurityOrigin::setEnforcesFilePathSeparation()
504 {
505     ASSERT(isLocal());
506     m_enforcesFilePathSeparation = true;
507 }
508 
509 String SecurityOrigin::toString() const
510 {
511     if (isUnique())
512         return &quot;null&quot;_s;
513     if (m_data.protocol == &quot;file&quot; &amp;&amp; m_enforcesFilePathSeparation)
514         return &quot;null&quot;_s;
515     return toRawString();
516 }
517 
</pre>
</td>
</tr>
</table>
<center><a href="ScrollToOptions.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SecurityOrigin.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
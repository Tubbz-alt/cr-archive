diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp
@@ -50,11 +50,11 @@
 }
 
 template <typename CharType>
 bool LiteralParser<CharType>::tryJSONPParse(Vector<JSONPData>& results, bool needsFullSourceInfo)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     if (m_lexer.next() != TokIdentifier)
         return false;
     do {
         Vector<JSONPPathEntry> path;
@@ -134,11 +134,11 @@
 }
 
 template <typename CharType>
 ALWAYS_INLINE const Identifier LiteralParser<CharType>::makeIdentifier(const LChar* characters, size_t length)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     if (!length)
         return vm.propertyNames->emptyIdentifier;
     if (characters[0] >= MaximumCachableCharacter)
         return Identifier::fromString(vm, characters, length);
 
@@ -155,11 +155,11 @@
 }
 
 template <typename CharType>
 ALWAYS_INLINE const Identifier LiteralParser<CharType>::makeIdentifier(const UChar* characters, size_t length)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     if (!length)
         return vm.propertyNames->emptyIdentifier;
     if (characters[0] >= MaximumCachableCharacter)
         return Identifier::fromString(vm, characters, length);
 
@@ -436,11 +436,11 @@
 };
 
 template <typename CharType>
 ALWAYS_INLINE TokenType LiteralParser<CharType>::Lexer::lex(LiteralParserToken<CharType>& token)
 {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     m_currentTokenID++;
 #endif
 
     while (m_ptr < m_end && isJSONWhiteSpace(*m_ptr))
         ++m_ptr;
@@ -818,11 +818,11 @@
 }
 
 template <typename CharType>
 JSValue LiteralParser<CharType>::parse(ParserState initialState)
 {
-    VM& vm = m_exec->vm();
+    VM& vm = m_globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     ParserState state = initialState;
     MarkedArgumentBuffer objectStack;
     JSValue lastValue;
     Vector<ParserState, 16, UnsafeVectorOverflow> stateStack;
@@ -830,11 +830,11 @@
     HashSet<JSObject*> visitedUnderscoreProto;
     while (1) {
         switch(state) {
             startParseArray:
             case StartParseArray: {
-                JSArray* array = constructEmptyArray(m_exec, 0);
+                JSArray* array = constructEmptyArray(m_globalObject, 0);
                 RETURN_IF_EXCEPTION(scope, JSValue());
                 objectStack.appendWithCrashOnOverflow(array);
             }
             doParseArrayStartExpression:
             FALLTHROUGH;
@@ -853,11 +853,11 @@
                 stateStack.append(DoParseArrayEndExpression);
                 goto startParseExpression;
             }
             case DoParseArrayEndExpression: {
                 JSArray* array = asArray(objectStack.last());
-                array->putDirectIndex(m_exec, array->length(), lastValue);
+                array->putDirectIndex(m_globalObject, array->length(), lastValue);
                 RETURN_IF_EXCEPTION(scope, JSValue());
 
                 if (m_lexer.currentToken()->type == TokComma)
                     goto doParseArrayStartExpression;
 
@@ -870,11 +870,11 @@
                 lastValue = objectStack.takeLast();
                 break;
             }
             startParseObject:
             case StartParseObject: {
-                JSObject* object = constructEmptyObject(m_exec);
+                JSObject* object = constructEmptyObject(m_globalObject);
                 objectStack.appendWithCrashOnOverflow(object);
 
                 TokenType type = m_lexer.next();
                 if (type == TokString || (m_mode != StrictJSON && type == TokIdentifier)) {
                     typename Lexer::LiteralParserTokenPtr identifierToken = m_lexer.currentToken();
@@ -931,16 +931,15 @@
                 if (m_mode != StrictJSON && ident == vm.propertyNames->underscoreProto) {
                     if (!visitedUnderscoreProto.add(object).isNewEntry) {
                         m_parseErrorMessage = "Attempted to redefine __proto__ property"_s;
                         return JSValue();
                     }
-                    CodeBlock* codeBlock = m_exec->codeBlock();
-                    PutPropertySlot slot(object, codeBlock ? codeBlock->isStrictMode() : false);
-                    objectStack.last().put(m_exec, ident, lastValue, slot);
+                    PutPropertySlot slot(object, m_nullOrCodeBlock ? m_nullOrCodeBlock->isStrictMode() : false);
+                    objectStack.last().put(m_globalObject, ident, lastValue, slot);
                 } else {
                     if (Optional<uint32_t> index = parseIndex(ident))
-                        object->putDirectIndex(m_exec, index.value(), lastValue);
+                        object->putDirectIndex(m_globalObject, index.value(), lastValue);
                     else
                         object->putDirect(vm, ident, lastValue);
                 }
                 RETURN_IF_EXCEPTION(scope, JSValue());
                 if (m_lexer.currentToken()->type == TokComma)

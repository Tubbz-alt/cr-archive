<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RotateTransformOperation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../wayland/PlatformDisplayWayland.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/transforms/TransformationMatrix.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;TransformationMatrix.h&quot;
  29 
  30 #include &quot;AffineTransform.h&quot;
  31 #include &quot;FloatQuad.h&quot;
  32 #include &quot;FloatRect.h&quot;
  33 #include &quot;IntRect.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &lt;cmath&gt;
  36 #include &lt;wtf/Assertions.h&gt;
  37 #include &lt;wtf/MathExtras.h&gt;
  38 #include &lt;wtf/Optional.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 




  41 #if CPU(X86_64)
  42 #include &lt;emmintrin.h&gt;
  43 #endif
  44 
  45 namespace WebCore {
  46 
  47 //
  48 // Adapted from Matrix Inversion by Richard Carling, Graphics Gems &lt;http://tog.acm.org/GraphicsGems/index.html&gt;.
  49 
  50 // EULA: The Graphics Gems code is copyright-protected. In other words, you cannot claim the text of the code
  51 // as your own and resell it. Using the code is permitted in any program, product, or library, non-commercial
  52 // or commercial. Giving credit is not required, though is a nice gesture. The code comes as-is, and if there
  53 // are any flaws or problems with any Gems code, nobody involved with Gems - authors, editors, publishers, or
  54 // webmasters - are to be held responsible. Basically, don&#39;t be a jerk, and remember that anything free comes
  55 // with no guarantee.
  56 
  57 // A clarification about the storage of matrix elements
  58 //
  59 // This class uses a 2 dimensional array internally to store the elements of the matrix. The first index into
  60 // the array refers to the column that the element lies in; the second index refers to the row.
</pre>
<hr />
<pre>
 237     for (int i = 0; i &lt; 4; i++)
 238         for (int j = 0; j &lt; 4; j++)
 239             b[i][j] = a[j][i];
 240 }
 241 
 242 // Multiply a homogeneous point by a matrix and return the transformed point
 243 static void v4MulPointByMatrix(const Vector4 p, const TransformationMatrix::Matrix4&amp; m, Vector4 result)
 244 {
 245     result[0] = (p[0] * m[0][0]) + (p[1] * m[1][0]) +
 246                 (p[2] * m[2][0]) + (p[3] * m[3][0]);
 247     result[1] = (p[0] * m[0][1]) + (p[1] * m[1][1]) +
 248                 (p[2] * m[2][1]) + (p[3] * m[3][1]);
 249     result[2] = (p[0] * m[0][2]) + (p[1] * m[1][2]) +
 250                 (p[2] * m[2][2]) + (p[3] * m[3][2]);
 251     result[3] = (p[0] * m[0][3]) + (p[1] * m[1][3]) +
 252                 (p[2] * m[2][3]) + (p[3] * m[3][3]);
 253 }
 254 
 255 static double v3Length(Vector3 a)
 256 {
<span class="line-modified"> 257     return sqrt((a[0] * a[0]) + (a[1] * a[1]) + (a[2] * a[2]));</span>




 258 }
 259 
 260 static void v3Scale(Vector3 v, double desiredLength)
 261 {
 262     double len = v3Length(v);
 263     if (len != 0) {
 264         double l = desiredLength / len;
 265         v[0] *= l;
 266         v[1] *= l;
 267         v[2] *= l;
 268     }
 269 }
 270 
 271 static double v3Dot(const Vector3 a, const Vector3 b)
 272 {
 273     return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
 274 }
 275 
 276 // Make a linear combination of two vectors and return the result.
 277 // result = (a * ascl) + (b * bscl)
</pre>
<hr />
<pre>
 283 }
 284 
 285 // Return the cross product result = a cross b */
 286 static void v3Cross(const Vector3 a, const Vector3 b, Vector3 result)
 287 {
 288     result[0] = (a[1] * b[2]) - (a[2] * b[1]);
 289     result[1] = (a[2] * b[0]) - (a[0] * b[2]);
 290     result[2] = (a[0] * b[1]) - (a[1] * b[0]);
 291 }
 292 
 293 static bool decompose2(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Decomposed2Type&amp; result)
 294 {
 295     double row0x = matrix[0][0];
 296     double row0y = matrix[0][1];
 297     double row1x = matrix[1][0];
 298     double row1y = matrix[1][1];
 299     result.translateX = matrix[3][0];
 300     result.translateY = matrix[3][1];
 301 
 302     // Compute scaling factors.
<span class="line-modified"> 303     result.scaleX = sqrt(row0x * row0x + row0y * row0y);</span>
<span class="line-modified"> 304     result.scaleY = sqrt(row1x * row1x + row1y * row1y);</span>
 305 
 306     // If determinant is negative, one axis was flipped.
 307     double determinant = row0x * row1y - row0y * row1x;
 308     if (determinant &lt; 0) {
 309         // Flip axis with minimum unit vector dot product.
 310         if (row0x &lt; row1y)
 311             result.scaleX = -result.scaleX;
 312         else
 313             result.scaleY = -result.scaleY;
 314     }
 315 
 316     // Renormalize matrix to remove scale.
 317     if (result.scaleX) {
 318         row0x *= 1 / result.scaleX;
 319         row0y *= 1 / result.scaleX;
 320     }
 321     if (result.scaleY) {
 322         row1x *= 1 / result.scaleY;
 323         row1y *= 1 / result.scaleY;
 324     }
</pre>
<hr />
<pre>
 796     m_matrix[1][1] *= sy;
 797     m_matrix[1][2] *= sy;
 798     m_matrix[1][3] *= sy;
 799     return *this;
 800 }
 801 
 802 TransformationMatrix&amp; TransformationMatrix::scale3d(double sx, double sy, double sz)
 803 {
 804     scaleNonUniform(sx, sy);
 805 
 806     m_matrix[2][0] *= sz;
 807     m_matrix[2][1] *= sz;
 808     m_matrix[2][2] *= sz;
 809     m_matrix[2][3] *= sz;
 810     return *this;
 811 }
 812 
 813 TransformationMatrix&amp; TransformationMatrix::rotate3d(double x, double y, double z, double angle)
 814 {
 815     // Normalize the axis of rotation
<span class="line-modified"> 816     double length = sqrt(x * x + y * y + z * z);</span>




 817     if (length == 0) {
 818         // A direction vector that cannot be normalized, such as [0, 0, 0], will cause the rotation to not be applied.
 819         return *this;
 820     } else if (length != 1) {
 821         x /= length;
 822         y /= length;
 823         z /= length;
 824     }
 825 
 826     // Angles are in degrees. Switch to radians.
 827     angle = deg2rad(angle);
 828 
 829     double sinTheta = sin(angle);
 830     double cosTheta = cos(angle);
 831 
 832     TransformationMatrix mat;
 833 
 834     // Optimize cases where the axis is along a major axis
 835     if (x == 1.0 &amp;&amp; y == 0.0 &amp;&amp; z == 0.0) {
 836         mat.m_matrix[0][0] = 1.0;
</pre>
</td>
<td>
<hr />
<pre>
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;TransformationMatrix.h&quot;
  29 
  30 #include &quot;AffineTransform.h&quot;
  31 #include &quot;FloatQuad.h&quot;
  32 #include &quot;FloatRect.h&quot;
  33 #include &quot;IntRect.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &lt;cmath&gt;
  36 #include &lt;wtf/Assertions.h&gt;
  37 #include &lt;wtf/MathExtras.h&gt;
  38 #include &lt;wtf/Optional.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 
<span class="line-added">  41 #if PLATFORM(JAVA)</span>
<span class="line-added">  42 #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="line-added">  43 #endif</span>
<span class="line-added">  44 </span>
  45 #if CPU(X86_64)
  46 #include &lt;emmintrin.h&gt;
  47 #endif
  48 
  49 namespace WebCore {
  50 
  51 //
  52 // Adapted from Matrix Inversion by Richard Carling, Graphics Gems &lt;http://tog.acm.org/GraphicsGems/index.html&gt;.
  53 
  54 // EULA: The Graphics Gems code is copyright-protected. In other words, you cannot claim the text of the code
  55 // as your own and resell it. Using the code is permitted in any program, product, or library, non-commercial
  56 // or commercial. Giving credit is not required, though is a nice gesture. The code comes as-is, and if there
  57 // are any flaws or problems with any Gems code, nobody involved with Gems - authors, editors, publishers, or
  58 // webmasters - are to be held responsible. Basically, don&#39;t be a jerk, and remember that anything free comes
  59 // with no guarantee.
  60 
  61 // A clarification about the storage of matrix elements
  62 //
  63 // This class uses a 2 dimensional array internally to store the elements of the matrix. The first index into
  64 // the array refers to the column that the element lies in; the second index refers to the row.
</pre>
<hr />
<pre>
 241     for (int i = 0; i &lt; 4; i++)
 242         for (int j = 0; j &lt; 4; j++)
 243             b[i][j] = a[j][i];
 244 }
 245 
 246 // Multiply a homogeneous point by a matrix and return the transformed point
 247 static void v4MulPointByMatrix(const Vector4 p, const TransformationMatrix::Matrix4&amp; m, Vector4 result)
 248 {
 249     result[0] = (p[0] * m[0][0]) + (p[1] * m[1][0]) +
 250                 (p[2] * m[2][0]) + (p[3] * m[3][0]);
 251     result[1] = (p[0] * m[0][1]) + (p[1] * m[1][1]) +
 252                 (p[2] * m[2][1]) + (p[3] * m[3][1]);
 253     result[2] = (p[0] * m[0][2]) + (p[1] * m[1][2]) +
 254                 (p[2] * m[2][2]) + (p[3] * m[3][2]);
 255     result[3] = (p[0] * m[0][3]) + (p[1] * m[1][3]) +
 256                 (p[2] * m[2][3]) + (p[3] * m[3][3]);
 257 }
 258 
 259 static double v3Length(Vector3 a)
 260 {
<span class="line-modified"> 261 #if PLATFORM(JAVA)</span>
<span class="line-added"> 262     return javamath::hypot(a[0], a[1], a[2]);</span>
<span class="line-added"> 263 #else</span>
<span class="line-added"> 264     return std::hypot(a[0], a[1], a[2]);</span>
<span class="line-added"> 265 #endif</span>
 266 }
 267 
 268 static void v3Scale(Vector3 v, double desiredLength)
 269 {
 270     double len = v3Length(v);
 271     if (len != 0) {
 272         double l = desiredLength / len;
 273         v[0] *= l;
 274         v[1] *= l;
 275         v[2] *= l;
 276     }
 277 }
 278 
 279 static double v3Dot(const Vector3 a, const Vector3 b)
 280 {
 281     return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);
 282 }
 283 
 284 // Make a linear combination of two vectors and return the result.
 285 // result = (a * ascl) + (b * bscl)
</pre>
<hr />
<pre>
 291 }
 292 
 293 // Return the cross product result = a cross b */
 294 static void v3Cross(const Vector3 a, const Vector3 b, Vector3 result)
 295 {
 296     result[0] = (a[1] * b[2]) - (a[2] * b[1]);
 297     result[1] = (a[2] * b[0]) - (a[0] * b[2]);
 298     result[2] = (a[0] * b[1]) - (a[1] * b[0]);
 299 }
 300 
 301 static bool decompose2(const TransformationMatrix::Matrix4&amp; matrix, TransformationMatrix::Decomposed2Type&amp; result)
 302 {
 303     double row0x = matrix[0][0];
 304     double row0y = matrix[0][1];
 305     double row1x = matrix[1][0];
 306     double row1y = matrix[1][1];
 307     result.translateX = matrix[3][0];
 308     result.translateY = matrix[3][1];
 309 
 310     // Compute scaling factors.
<span class="line-modified"> 311     result.scaleX = std::hypot(row0x, row0y);</span>
<span class="line-modified"> 312     result.scaleY = std::hypot(row1x, row1y);</span>
 313 
 314     // If determinant is negative, one axis was flipped.
 315     double determinant = row0x * row1y - row0y * row1x;
 316     if (determinant &lt; 0) {
 317         // Flip axis with minimum unit vector dot product.
 318         if (row0x &lt; row1y)
 319             result.scaleX = -result.scaleX;
 320         else
 321             result.scaleY = -result.scaleY;
 322     }
 323 
 324     // Renormalize matrix to remove scale.
 325     if (result.scaleX) {
 326         row0x *= 1 / result.scaleX;
 327         row0y *= 1 / result.scaleX;
 328     }
 329     if (result.scaleY) {
 330         row1x *= 1 / result.scaleY;
 331         row1y *= 1 / result.scaleY;
 332     }
</pre>
<hr />
<pre>
 804     m_matrix[1][1] *= sy;
 805     m_matrix[1][2] *= sy;
 806     m_matrix[1][3] *= sy;
 807     return *this;
 808 }
 809 
 810 TransformationMatrix&amp; TransformationMatrix::scale3d(double sx, double sy, double sz)
 811 {
 812     scaleNonUniform(sx, sy);
 813 
 814     m_matrix[2][0] *= sz;
 815     m_matrix[2][1] *= sz;
 816     m_matrix[2][2] *= sz;
 817     m_matrix[2][3] *= sz;
 818     return *this;
 819 }
 820 
 821 TransformationMatrix&amp; TransformationMatrix::rotate3d(double x, double y, double z, double angle)
 822 {
 823     // Normalize the axis of rotation
<span class="line-modified"> 824 #if PLATFORM(JAVA)</span>
<span class="line-added"> 825     double length = javamath::hypot(x, y, z);</span>
<span class="line-added"> 826 #else</span>
<span class="line-added"> 827     double length = std::hypot(x, y, z);</span>
<span class="line-added"> 828 #endif</span>
 829     if (length == 0) {
 830         // A direction vector that cannot be normalized, such as [0, 0, 0], will cause the rotation to not be applied.
 831         return *this;
 832     } else if (length != 1) {
 833         x /= length;
 834         y /= length;
 835         z /= length;
 836     }
 837 
 838     // Angles are in degrees. Switch to radians.
 839     angle = deg2rad(angle);
 840 
 841     double sinTheta = sin(angle);
 842     double cosTheta = cos(angle);
 843 
 844     TransformationMatrix mat;
 845 
 846     // Optimize cases where the axis is along a major axis
 847     if (x == 1.0 &amp;&amp; y == 0.0 &amp;&amp; z == 0.0) {
 848         mat.m_matrix[0][0] = 1.0;
</pre>
</td>
</tr>
</table>
<center><a href="RotateTransformOperation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../wayland/PlatformDisplayWayland.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/FunctionOverrides.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilerTimingScope.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FunctionOverrides.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/FunctionOverrides.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 72      The override keyword must be at the start of the line.
 73 
 74      &lt;delimiter&gt; may be any string of any ASCII characters (except for &#39;{&#39;,
 75      &#39;}&#39;, and whitespace characters) as long as the pattern of &quot;}&lt;delimiter&gt;&quot;
 76      does not appear in the function body e.g. the override clause of Example 2
 77      above illustrates this.
 78 
 79      The start and end &lt;delimiter&gt; must be identical.
 80 
 81      The space between the override keyword and the start &lt;delimiter&gt; is
 82      required.
 83 
 84      All characters between the pair of delimiters will be considered to
 85      be part of the function body string. This allows us to also work
 86      with script source that are multi-lined i.e. newlines are allowed.
 87 
 88   4. A &#39;with&#39; clause is identical in form to an &#39;override&#39; clause except that
 89      it uses the &#39;with&#39; keyword instead of the &#39;override&#39; keyword.
 90  */
 91 





 92 FunctionOverrides&amp; FunctionOverrides::overrides()
 93 {

 94     static LazyNeverDestroyed&lt;FunctionOverrides&gt; overrides;
 95     static std::once_flag initializeListFlag;
 96     std::call_once(initializeListFlag, [] {

 97         const char* overridesFileName = Options::functionOverrides();
 98         overrides.construct(overridesFileName);
 99     });
100     return overrides;
101 }
102 
103 FunctionOverrides::FunctionOverrides(const char* overridesFileName)
104 {
<span class="line-modified">105     parseOverridesInFile(overridesFileName);</span>

106 }
107 
108 void FunctionOverrides::reinstallOverrides()
109 {

110     FunctionOverrides&amp; overrides = FunctionOverrides::overrides();

111     const char* overridesFileName = Options::functionOverrides();
<span class="line-modified">112     overrides.clear();</span>
<span class="line-modified">113     overrides.parseOverridesInFile(overridesFileName);</span>
114 }
115 
116 static void initializeOverrideInfo(const SourceCode&amp; origCode, const String&amp; newBody, FunctionOverrides::OverrideInfo&amp; info)
117 {

118     String origProviderStr = origCode.provider()-&gt;source().toString();
119     unsigned origStart = origCode.startOffset();
120     unsigned origFunctionStart = origProviderStr.reverseFind(&quot;function&quot;, origStart);
121     unsigned origBraceStart = origProviderStr.find(&quot;{&quot;, origStart);
122     unsigned headerLength = origBraceStart - origFunctionStart;
123     String origHeader = origProviderStr.substring(origFunctionStart, headerLength);
124 
125     String newProviderStr;
126     newProviderStr.append(origHeader);
127     newProviderStr.append(newBody);
128 
129     Ref&lt;SourceProvider&gt; newProvider = StringSourceProvider::create(newProviderStr, SourceOrigin { &quot;&lt;overridden&gt;&quot; }, URL({ }, &quot;&lt;overridden&gt;&quot;));
130 
131     info.firstLine = 1;
132     info.lineCount = 1; // Faking it. This doesn&#39;t really matter for now.
133     info.startColumn = 1;
134     info.endColumn = 1; // Faking it. This doesn&#39;t really matter for now.
135     info.parametersStartOffset = newProviderStr.find(&quot;(&quot;);
136     info.typeProfilingStartOffset = newProviderStr.find(&quot;{&quot;);
137     info.typeProfilingEndOffset = newProviderStr.length() - 1;
138 
139     info.sourceCode =
140         SourceCode(WTFMove(newProvider), info.parametersStartOffset, info.typeProfilingEndOffset + 1, 1, 1);
141 }
142 
143 bool FunctionOverrides::initializeOverrideFor(const SourceCode&amp; origCode, FunctionOverrides::OverrideInfo&amp; result)
144 {
<span class="line-modified">145     ASSERT(Options::functionOverrides());</span>

146     FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
147 
148     String sourceString = origCode.view().toString();
149     size_t sourceBodyStart = sourceString.find(&#39;{&#39;);
150     if (sourceBodyStart == notFound)
151         return false;
152     String sourceBodyString = sourceString.substring(sourceBodyStart);
153 
<span class="line-modified">154     auto it = overrides.m_entries.find(sourceBodyString);</span>
<span class="line-modified">155     if (it == overrides.m_entries.end())</span>
<span class="line-modified">156         return false;</span>





157 
<span class="line-modified">158     initializeOverrideInfo(origCode, it-&gt;value, result);</span>

159     return true;
160 }
161 
162 #define SYNTAX_ERROR &quot;SYNTAX ERROR&quot;
163 #define IO_ERROR &quot;IO ERROR&quot;
164 #define FAIL_WITH_ERROR(error, errorMessageInBrackets) \
165     do { \
166         dataLog(&quot;functionOverrides &quot;, error, &quot;: &quot;); \
167         dataLog errorMessageInBrackets; \
168         exit(EXIT_FAILURE); \
169     } while (false)
170 
171 static bool hasDisallowedCharacters(const char* str, size_t length)
172 {
173     while (length--) {
174         char c = *str++;
175         // &#39;{&#39; is also disallowed, but we don&#39;t need to check for it because
176         // parseClause() searches for &#39;{&#39; as the end of the start delimiter.
177         // As a result, the parsed delimiter string will never include &#39;{&#39;.
178         if (c == &#39;}&#39; || isASCIISpace(c))
179             return true;
180     }
181     return false;
182 }
183 
184 static String parseClause(const char* keyword, size_t keywordLength, FILE* file, const char* line, char* buffer, size_t bufferSize)
185 {

186     const char* keywordPos = strstr(line, keyword);
187     if (!keywordPos)
188         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Expecting &#39;&quot;, keyword, &quot;&#39; clause:\n&quot;, line, &quot;\n&quot;));
189     if (keywordPos != line)
190         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Cannot have any characters before &#39;&quot;, keyword, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
191     if (line[keywordLength] != &#39; &#39;)
192         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; must be followed by a &#39; &#39;:\n&quot;, line, &quot;\n&quot;));
193 
194     const char* delimiterStart = &amp;line[keywordLength + 1];
195     const char* delimiterEnd = strstr(delimiterStart, &quot;{&quot;);
196     if (!delimiterEnd)
197         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Missing { after &#39;&quot;, keyword, &quot;&#39; clause start delimiter:\n&quot;, line, &quot;\n&quot;));
198 
199     size_t delimiterLength = delimiterEnd - delimiterStart;
200     String delimiter(delimiterStart, delimiterLength);
201 
202     if (hasDisallowedCharacters(delimiterStart, delimiterLength))
203         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Delimiter &#39;&quot;, delimiter, &quot;&#39; cannot have &#39;{&#39;, &#39;}&#39;, or whitespace:\n&quot;, line, &quot;\n&quot;));
204 
205     String terminatorString;
</pre>
<hr />
<pre>
210     const char* terminator = terminatorCString.data();
211     line = delimiterEnd; // Start from the {.
212 
213     StringBuilder builder;
214     do {
215         const char* p = strstr(line, terminator);
216         if (p) {
217             if (p[strlen(terminator)] != &#39;\n&#39;)
218                 FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Unexpected characters after &#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
219 
220             builder.appendCharacters(line, p - line + 1);
221             return builder.toString();
222         }
223         builder.append(line);
224 
225     } while ((line = fgets(buffer, bufferSize, file)));
226 
227     FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39; not found:\n&quot;, builder.toString(), &quot;\n&quot;, &quot;Are you missing a &#39;}&#39; before the delimiter?\n&quot;));
228 }
229 
<span class="line-modified">230 void FunctionOverrides::parseOverridesInFile(const char* fileName)</span>
231 {

232     if (!fileName)
233         return;
234 
235     FILE* file = fopen(fileName, &quot;r&quot;);
236     if (!file)
237         FAIL_WITH_ERROR(IO_ERROR, (&quot;Failed to open file &quot;, fileName, &quot;. Did you add the file-read-data entitlement to WebProcess.sb?\n&quot;));
238 
239     char* line;
240     char buffer[BUFSIZ];
241     while ((line = fgets(buffer, sizeof(buffer), file))) {
242         if (strstr(line, &quot;//&quot;) == line)
243             continue;
244 
245         if (line[0] == &#39;\n&#39; || line[0] == &#39;\0&#39;)
246             continue;
247 
248         size_t keywordLength;
249 
250         keywordLength = sizeof(&quot;override&quot;) - 1;
251         String keyStr = parseClause(&quot;override&quot;, keywordLength, file, line, buffer, sizeof(buffer));
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 72      The override keyword must be at the start of the line.
 73 
 74      &lt;delimiter&gt; may be any string of any ASCII characters (except for &#39;{&#39;,
 75      &#39;}&#39;, and whitespace characters) as long as the pattern of &quot;}&lt;delimiter&gt;&quot;
 76      does not appear in the function body e.g. the override clause of Example 2
 77      above illustrates this.
 78 
 79      The start and end &lt;delimiter&gt; must be identical.
 80 
 81      The space between the override keyword and the start &lt;delimiter&gt; is
 82      required.
 83 
 84      All characters between the pair of delimiters will be considered to
 85      be part of the function body string. This allows us to also work
 86      with script source that are multi-lined i.e. newlines are allowed.
 87 
 88   4. A &#39;with&#39; clause is identical in form to an &#39;override&#39; clause except that
 89      it uses the &#39;with&#39; keyword instead of the &#39;override&#39; keyword.
 90  */
 91 
<span class="line-added"> 92 struct FunctionOverridesAssertScope {</span>
<span class="line-added"> 93     FunctionOverridesAssertScope() { RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled); }</span>
<span class="line-added"> 94     ~FunctionOverridesAssertScope() { RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled); }</span>
<span class="line-added"> 95 };</span>
<span class="line-added"> 96 </span>
 97 FunctionOverrides&amp; FunctionOverrides::overrides()
 98 {
<span class="line-added"> 99     FunctionOverridesAssertScope assertScope;</span>
100     static LazyNeverDestroyed&lt;FunctionOverrides&gt; overrides;
101     static std::once_flag initializeListFlag;
102     std::call_once(initializeListFlag, [] {
<span class="line-added">103         FunctionOverridesAssertScope assertScope;</span>
104         const char* overridesFileName = Options::functionOverrides();
105         overrides.construct(overridesFileName);
106     });
107     return overrides;
108 }
109 
110 FunctionOverrides::FunctionOverrides(const char* overridesFileName)
111 {
<span class="line-modified">112     FunctionOverridesAssertScope assertScope;</span>
<span class="line-added">113     parseOverridesInFile(holdLock(m_lock), overridesFileName);</span>
114 }
115 
116 void FunctionOverrides::reinstallOverrides()
117 {
<span class="line-added">118     FunctionOverridesAssertScope assertScope;</span>
119     FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
<span class="line-added">120     auto locker = holdLock(overrides.m_lock);</span>
121     const char* overridesFileName = Options::functionOverrides();
<span class="line-modified">122     overrides.clear(locker);</span>
<span class="line-modified">123     overrides.parseOverridesInFile(locker, overridesFileName);</span>
124 }
125 
126 static void initializeOverrideInfo(const SourceCode&amp; origCode, const String&amp; newBody, FunctionOverrides::OverrideInfo&amp; info)
127 {
<span class="line-added">128     FunctionOverridesAssertScope assertScope;</span>
129     String origProviderStr = origCode.provider()-&gt;source().toString();
130     unsigned origStart = origCode.startOffset();
131     unsigned origFunctionStart = origProviderStr.reverseFind(&quot;function&quot;, origStart);
132     unsigned origBraceStart = origProviderStr.find(&quot;{&quot;, origStart);
133     unsigned headerLength = origBraceStart - origFunctionStart;
134     String origHeader = origProviderStr.substring(origFunctionStart, headerLength);
135 
136     String newProviderStr;
137     newProviderStr.append(origHeader);
138     newProviderStr.append(newBody);
139 
140     Ref&lt;SourceProvider&gt; newProvider = StringSourceProvider::create(newProviderStr, SourceOrigin { &quot;&lt;overridden&gt;&quot; }, URL({ }, &quot;&lt;overridden&gt;&quot;));
141 
142     info.firstLine = 1;
143     info.lineCount = 1; // Faking it. This doesn&#39;t really matter for now.
144     info.startColumn = 1;
145     info.endColumn = 1; // Faking it. This doesn&#39;t really matter for now.
146     info.parametersStartOffset = newProviderStr.find(&quot;(&quot;);
147     info.typeProfilingStartOffset = newProviderStr.find(&quot;{&quot;);
148     info.typeProfilingEndOffset = newProviderStr.length() - 1;
149 
150     info.sourceCode =
151         SourceCode(WTFMove(newProvider), info.parametersStartOffset, info.typeProfilingEndOffset + 1, 1, 1);
152 }
153 
154 bool FunctionOverrides::initializeOverrideFor(const SourceCode&amp; origCode, FunctionOverrides::OverrideInfo&amp; result)
155 {
<span class="line-modified">156     FunctionOverridesAssertScope assertScope;</span>
<span class="line-added">157     RELEASE_ASSERT(Options::functionOverrides());</span>
158     FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
159 
160     String sourceString = origCode.view().toString();
161     size_t sourceBodyStart = sourceString.find(&#39;{&#39;);
162     if (sourceBodyStart == notFound)
163         return false;
164     String sourceBodyString = sourceString.substring(sourceBodyStart);
165 
<span class="line-modified">166     String newBody;</span>
<span class="line-modified">167     {</span>
<span class="line-modified">168         auto locker = holdLock(overrides.m_lock);</span>
<span class="line-added">169         auto it = overrides.m_entries.find(sourceBodyString.isolatedCopy());</span>
<span class="line-added">170         if (it == overrides.m_entries.end())</span>
<span class="line-added">171             return false;</span>
<span class="line-added">172         newBody = it-&gt;value.isolatedCopy();</span>
<span class="line-added">173     }</span>
174 
<span class="line-modified">175     initializeOverrideInfo(origCode, newBody, result);</span>
<span class="line-added">176     RELEASE_ASSERT(Options::functionOverrides());</span>
177     return true;
178 }
179 
180 #define SYNTAX_ERROR &quot;SYNTAX ERROR&quot;
181 #define IO_ERROR &quot;IO ERROR&quot;
182 #define FAIL_WITH_ERROR(error, errorMessageInBrackets) \
183     do { \
184         dataLog(&quot;functionOverrides &quot;, error, &quot;: &quot;); \
185         dataLog errorMessageInBrackets; \
186         exit(EXIT_FAILURE); \
187     } while (false)
188 
189 static bool hasDisallowedCharacters(const char* str, size_t length)
190 {
191     while (length--) {
192         char c = *str++;
193         // &#39;{&#39; is also disallowed, but we don&#39;t need to check for it because
194         // parseClause() searches for &#39;{&#39; as the end of the start delimiter.
195         // As a result, the parsed delimiter string will never include &#39;{&#39;.
196         if (c == &#39;}&#39; || isASCIISpace(c))
197             return true;
198     }
199     return false;
200 }
201 
202 static String parseClause(const char* keyword, size_t keywordLength, FILE* file, const char* line, char* buffer, size_t bufferSize)
203 {
<span class="line-added">204     FunctionOverridesAssertScope assertScope;</span>
205     const char* keywordPos = strstr(line, keyword);
206     if (!keywordPos)
207         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Expecting &#39;&quot;, keyword, &quot;&#39; clause:\n&quot;, line, &quot;\n&quot;));
208     if (keywordPos != line)
209         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Cannot have any characters before &#39;&quot;, keyword, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
210     if (line[keywordLength] != &#39; &#39;)
211         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; must be followed by a &#39; &#39;:\n&quot;, line, &quot;\n&quot;));
212 
213     const char* delimiterStart = &amp;line[keywordLength + 1];
214     const char* delimiterEnd = strstr(delimiterStart, &quot;{&quot;);
215     if (!delimiterEnd)
216         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Missing { after &#39;&quot;, keyword, &quot;&#39; clause start delimiter:\n&quot;, line, &quot;\n&quot;));
217 
218     size_t delimiterLength = delimiterEnd - delimiterStart;
219     String delimiter(delimiterStart, delimiterLength);
220 
221     if (hasDisallowedCharacters(delimiterStart, delimiterLength))
222         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Delimiter &#39;&quot;, delimiter, &quot;&#39; cannot have &#39;{&#39;, &#39;}&#39;, or whitespace:\n&quot;, line, &quot;\n&quot;));
223 
224     String terminatorString;
</pre>
<hr />
<pre>
229     const char* terminator = terminatorCString.data();
230     line = delimiterEnd; // Start from the {.
231 
232     StringBuilder builder;
233     do {
234         const char* p = strstr(line, terminator);
235         if (p) {
236             if (p[strlen(terminator)] != &#39;\n&#39;)
237                 FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Unexpected characters after &#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
238 
239             builder.appendCharacters(line, p - line + 1);
240             return builder.toString();
241         }
242         builder.append(line);
243 
244     } while ((line = fgets(buffer, bufferSize, file)));
245 
246     FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39; not found:\n&quot;, builder.toString(), &quot;\n&quot;, &quot;Are you missing a &#39;}&#39; before the delimiter?\n&quot;));
247 }
248 
<span class="line-modified">249 void FunctionOverrides::parseOverridesInFile(const AbstractLocker&amp;, const char* fileName)</span>
250 {
<span class="line-added">251     FunctionOverridesAssertScope assertScope;</span>
252     if (!fileName)
253         return;
254 
255     FILE* file = fopen(fileName, &quot;r&quot;);
256     if (!file)
257         FAIL_WITH_ERROR(IO_ERROR, (&quot;Failed to open file &quot;, fileName, &quot;. Did you add the file-read-data entitlement to WebProcess.sb?\n&quot;));
258 
259     char* line;
260     char buffer[BUFSIZ];
261     while ((line = fgets(buffer, sizeof(buffer), file))) {
262         if (strstr(line, &quot;//&quot;) == line)
263             continue;
264 
265         if (line[0] == &#39;\n&#39; || line[0] == &#39;\0&#39;)
266             continue;
267 
268         size_t keywordLength;
269 
270         keywordLength = sizeof(&quot;override&quot;) - 1;
271         String keyStr = parseClause(&quot;override&quot;, keywordLength, file, line, buffer, sizeof(buffer));
</pre>
</td>
</tr>
</table>
<center><a href="CompilerTimingScope.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FunctionOverrides.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
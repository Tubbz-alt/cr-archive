<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLIFrameElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLImageElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLImageElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;HTMLImageElement.h&quot;
 25 
 26 #include &quot;CSSPropertyNames.h&quot;
 27 #include &quot;CSSValueKeywords.h&quot;
 28 #include &quot;CachedImage.h&quot;
 29 #include &quot;Chrome.h&quot;
 30 #include &quot;ChromeClient.h&quot;
 31 #include &quot;EditableImageReference.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;ElementIterator.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLAttachmentElement.h&quot;
 38 #include &quot;HTMLDocument.h&quot;
 39 #include &quot;HTMLFormElement.h&quot;

 40 #include &quot;HTMLParserIdioms.h&quot;
 41 #include &quot;HTMLPictureElement.h&quot;
 42 #include &quot;HTMLMapElement.h&quot;
 43 #include &quot;HTMLSourceElement.h&quot;
 44 #include &quot;HTMLSrcsetParser.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MIMETypeRegistry.h&quot;
 47 #include &quot;MediaList.h&quot;
 48 #include &quot;MediaQueryEvaluator.h&quot;
 49 #include &quot;MouseEvent.h&quot;
 50 #include &quot;NodeTraversal.h&quot;
 51 #include &quot;PlatformMouseEvent.h&quot;
 52 #include &quot;RenderImage.h&quot;
 53 #include &quot;RenderView.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;ShadowRoot.h&quot;
 57 #include &quot;SizesAttributeParser.h&quot;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 #include &lt;wtf/text/StringBuilder.h&gt;
 60 
 61 #if ENABLE(SERVICE_CONTROLS)
 62 #include &quot;ImageControlsRootElement.h&quot;
 63 #endif
 64 
 65 namespace WebCore {
 66 
 67 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLImageElement);
 68 
 69 using namespace HTMLNames;
 70 
<span class="line-modified"> 71 HTMLImageElement::HTMLImageElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)</span>
 72     : HTMLElement(tagName, document)
<span class="line-modified"> 73     , m_imageLoader(*this)</span>
 74     , m_form(nullptr)
 75     , m_formSetByParser(makeWeakPtr(form))
<span class="line-modified"> 76     , m_compositeOperator(CompositeSourceOver)</span>
 77     , m_imageDevicePixelRatio(1.0f)
 78     , m_experimentalImageMenuEnabled(false)

 79 {
 80     ASSERT(hasTagName(imgTag));
 81     setHasCustomStyleResolveCallbacks();
 82 }
 83 
 84 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(Document&amp; document)
 85 {
 86     return adoptRef(*new HTMLImageElement(imgTag, document));
 87 }
 88 
<span class="line-modified"> 89 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)</span>
 90 {
<span class="line-modified"> 91     return adoptRef(*new HTMLImageElement(tagName, document, form));</span>
 92 }
 93 
 94 HTMLImageElement::~HTMLImageElement()
 95 {


 96     if (m_form)
 97         m_form-&gt;removeImgElement(this);
 98     setPictureElement(nullptr);
 99 }
100 
101 Ref&lt;HTMLImageElement&gt; HTMLImageElement::createForJSConstructor(Document&amp; document, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height)
102 {
103     auto image = adoptRef(*new HTMLImageElement(imgTag, document));
104     if (width)
105         image-&gt;setWidth(width.value());
106     if (height)
107         image-&gt;setHeight(height.value());
108     return image;
109 }
110 
111 bool HTMLImageElement::isPresentationAttribute(const QualifiedName&amp; name) const
112 {
113     if (name == widthAttr || name == heightAttr || name == borderAttr || name == vspaceAttr || name == hspaceAttr || name == valignAttr)
114         return true;
115     return HTMLElement::isPresentationAttribute(name);
</pre>
<hr />
<pre>
141 {
142     return m_bestFitImageURL.isEmpty() ? attributeWithoutSynchronization(srcAttr) : m_bestFitImageURL;
143 }
144 
145 void HTMLImageElement::setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp; candidate)
146 {
147     m_bestFitImageURL = candidate.string.toAtomString();
148     m_currentSrc = AtomString(document().completeURL(imageSourceURL()).string());
149     if (candidate.density &gt;= 0)
150         m_imageDevicePixelRatio = 1 / candidate.density;
151     if (is&lt;RenderImage&gt;(renderer()))
152         downcast&lt;RenderImage&gt;(*renderer()).setImageDevicePixelRatio(m_imageDevicePixelRatio);
153 }
154 
155 ImageCandidate HTMLImageElement::bestFitSourceFromPictureElement()
156 {
157     auto picture = makeRefPtr(pictureElement());
158     if (!picture)
159         return { };
160 
<span class="line-modified">161     picture-&gt;clearViewportDependentResults();</span>
<span class="line-removed">162     document().removeViewportDependentPicture(*picture);</span>
<span class="line-removed">163 </span>
<span class="line-removed">164     picture-&gt;clearAppearanceDependentResults();</span>
<span class="line-removed">165     document().removeAppearanceDependentPicture(*picture);</span>
166 
167     for (RefPtr&lt;Node&gt; child = picture-&gt;firstChild(); child &amp;&amp; child != this; child = child-&gt;nextSibling()) {
168         if (!is&lt;HTMLSourceElement&gt;(*child))
169             continue;
170         auto&amp; source = downcast&lt;HTMLSourceElement&gt;(*child);
171 
172         auto&amp; srcset = source.attributeWithoutSynchronization(srcsetAttr);
173         if (srcset.isEmpty())
174             continue;
175 
176         auto&amp; typeAttribute = source.attributeWithoutSynchronization(typeAttr);
177         if (!typeAttribute.isNull()) {
178             String type = typeAttribute.string();
179             type.truncate(type.find(&#39;;&#39;));
180             type = stripLeadingAndTrailingHTMLSpaces(type);
181             if (!type.isEmpty() &amp;&amp; !MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(type))
182                 continue;
183         }
184 
185         auto documentElement = makeRefPtr(document().documentElement());
186         MediaQueryEvaluator evaluator { document().printing() ? &quot;print&quot; : &quot;screen&quot;, document(), documentElement ? documentElement-&gt;computedStyle() : nullptr };
187         auto* queries = source.parsedMediaAttribute(document());
188         LOG(MediaQueries, &quot;HTMLImageElement %p bestFitSourceFromPictureElement evaluating media queries&quot;, this);
<span class="line-modified">189         auto evaluation = !queries || evaluator.evaluate(*queries, picture-&gt;viewportDependentResults(), picture-&gt;appearanceDependentResults());</span>
<span class="line-modified">190         if (picture-&gt;hasViewportDependentResults())</span>
<span class="line-removed">191             document().addViewportDependentPicture(*picture);</span>
<span class="line-removed">192         if (picture-&gt;hasAppearanceDependentResults())</span>
<span class="line-removed">193             document().addAppearanceDependentPicture(*picture);</span>
194         if (!evaluation)
195             continue;
196 
<span class="line-modified">197         auto sourceSize = SizesAttributeParser(source.attributeWithoutSynchronization(sizesAttr).string(), document()).length();</span>
<span class="line-modified">198         auto candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), nullAtom(), srcset, sourceSize);</span>


199         if (!candidate.isEmpty())
<span class="line-modified">200             return candidate;</span>
201     }
<span class="line-modified">202     return { };</span>












203 }
204 
205 void HTMLImageElement::selectImageSource()
206 {



207     // First look for the best fit source from our &lt;picture&gt; parent if we have one.
208     ImageCandidate candidate = bestFitSourceFromPictureElement();
209     if (candidate.isEmpty()) {
210         // If we don&#39;t have a &lt;picture&gt; or didn&#39;t find a source, then we use our own attributes.
<span class="line-modified">211         auto sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length();</span>

212         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);
213     }
214     setBestFitURLAndDPRFromImageCandidate(candidate);
<span class="line-modified">215     m_imageLoader.updateFromElementIgnoringPreviousError();</span>



216 }
217 
218 void HTMLImageElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
219 {
220     if (name == altAttr) {
221         if (is&lt;RenderImage&gt;(renderer()))
222             downcast&lt;RenderImage&gt;(*renderer()).updateAltText();
223     } else if (name == srcAttr || name == srcsetAttr || name == sizesAttr)
224         selectImageSource();
225     else if (name == usemapAttr) {
226         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
227             treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
228 
229         m_parsedUsemap = parseHTMLHashNameReference(value);
230 
231         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
232             treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
233     } else if (name == compositeAttr) {
234         // FIXME: images don&#39;t support blend modes in their compositing attribute.
235         BlendMode blendOp = BlendMode::Normal;
236         if (!parseCompositeAndBlendOperator(value, m_compositeOperator, blendOp))
<span class="line-modified">237             m_compositeOperator = CompositeSourceOver;</span>
238 #if ENABLE(SERVICE_CONTROLS)
239     } else if (name == webkitimagemenuAttr) {
240         m_experimentalImageMenuEnabled = !value.isNull();
241         updateImageControls();
242 #endif
243     } else if (name == x_apple_editable_imageAttr)
244         updateEditableImage();
245     else {
246         if (name == nameAttr) {
247             bool willHaveName = !value.isNull();
248             if (m_hadNameBeforeAttributeChanged != willHaveName &amp;&amp; isConnected() &amp;&amp; !isInShadowTree() &amp;&amp; is&lt;HTMLDocument&gt;(document())) {
249                 HTMLDocument&amp; document = downcast&lt;HTMLDocument&gt;(this-&gt;document());
250                 const AtomString&amp; id = getIdAttribute();
251                 if (!id.isEmpty() &amp;&amp; id != getNameAttribute()) {
252                     if (willHaveName)
253                         document.addDocumentNamedItem(*id.impl(), *this);
254                     else
255                         document.removeDocumentNamedItem(*id.impl(), *this);
256                 }
257             }
</pre>
<hr />
<pre>
295         return true;
296     return HTMLElement::supportsFocus();
297 }
298 
299 bool HTMLImageElement::isFocusable() const
300 {
301     if (hasEditableImageAttribute())
302         return true;
303     return HTMLElement::isFocusable();
304 }
305 
306 bool HTMLImageElement::isInteractiveContent() const
307 {
308     return hasAttributeWithoutSynchronization(usemapAttr);
309 }
310 
311 void HTMLImageElement::didAttachRenderers()
312 {
313     if (!is&lt;RenderImage&gt;(renderer()))
314         return;
<span class="line-modified">315     if (m_imageLoader.hasPendingBeforeLoadEvent())</span>
316         return;
317 
318 #if ENABLE(SERVICE_CONTROLS)
319     updateImageControls();
320 #endif
321 
322     auto&amp; renderImage = downcast&lt;RenderImage&gt;(*renderer());
323     RenderImageResource&amp; renderImageResource = renderImage.imageResource();
324     if (renderImageResource.cachedImage())
325         return;
<span class="line-modified">326     renderImageResource.setCachedImage(m_imageLoader.image());</span>
327 
328     // If we have no image at all because we have no src attribute, set
329     // image height and width for the alt text instead.
<span class="line-modified">330     if (!m_imageLoader.image() &amp;&amp; !renderImageResource.cachedImage())</span>
331         renderImage.setImageSizeForAltText();
332 }
333 
334 Node::InsertedIntoAncestorResult HTMLImageElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
335 {
336     if (m_formSetByParser) {
337         m_form = WTFMove(m_formSetByParser);
338         m_form-&gt;registerImgElement(this);
339     }
340 
341     if (m_form &amp;&amp; rootElement() != m_form-&gt;rootElement()) {
342         m_form-&gt;removeImgElement(this);
343         m_form = nullptr;
344     }
345 
346     if (!m_form) {
347         if (auto* newForm = HTMLFormElement::findClosestFormAncestor(*this)) {
348             m_form = makeWeakPtr(newForm);
349             newForm-&gt;registerImgElement(this);
350         }
351     }
352 
353     // Insert needs to complete first, before we start updating the loader. Loader dispatches events which could result
354     // in callbacks back to this node.
355     Node::InsertedIntoAncestorResult insertNotificationRequest = HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
356 
357     if (insertionType.connectedToDocument &amp;&amp; hasEditableImageAttribute())
358         insertNotificationRequest = InsertedIntoAncestorResult::NeedsPostInsertionCallback;
359 
360     if (insertionType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
361         treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
362 
363     if (is&lt;HTMLPictureElement&gt;(parentNode())) {
364         setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(*parentNode()));
365         selectImageSource();
366     }
367 
368     // If we have been inserted from a renderer-less document,
369     // our loader may have not fetched the image, so do it now.
<span class="line-modified">370     if (insertionType.connectedToDocument &amp;&amp; !m_imageLoader.image())</span>
<span class="line-modified">371         m_imageLoader.updateFromElement();</span>
372 
373     return insertNotificationRequest;
374 }
375 
376 void HTMLImageElement::didFinishInsertingNode()
377 {
378     if (hasEditableImageAttribute())
379         updateEditableImage();
380 }
381 
382 void HTMLImageElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
383 {
384     if (m_form)
385         m_form-&gt;removeImgElement(this);
386 
387     if (removalType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
388         oldParentOfRemovedTree.treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
389 
390     if (is&lt;HTMLPictureElement&gt;(parentNode()))
391         setPictureElement(nullptr);
</pre>
<hr />
<pre>
455 
456 HTMLPictureElement* HTMLImageElement::pictureElement() const
457 {
458     return m_pictureElement.get();
459 }
460 
461 void HTMLImageElement::setPictureElement(HTMLPictureElement* pictureElement)
462 {
463     m_pictureElement = makeWeakPtr(pictureElement);
464 }
465 
466 unsigned HTMLImageElement::width(bool ignorePendingStylesheets)
467 {
468     if (!renderer()) {
469         // check the attribute first for an explicit pixel value
470         auto optionalWidth = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(widthAttr));
471         if (optionalWidth)
472             return optionalWidth.value();
473 
474         // if the image is available, use its width
<span class="line-modified">475         if (m_imageLoader.image())</span>
<span class="line-modified">476             return m_imageLoader.image()-&gt;imageSizeForRenderer(renderer(), 1.0f).width().toUnsigned();</span>
477     }
478 
479     if (ignorePendingStylesheets)
480         document().updateLayoutIgnorePendingStylesheets();
481     else
482         document().updateLayout();
483 
484     RenderBox* box = renderBox();
485     if (!box)
486         return 0;
487     LayoutRect contentRect = box-&gt;contentBoxRect();
488     return adjustForAbsoluteZoom(snappedIntRect(contentRect).width(), *box);
489 }
490 
491 unsigned HTMLImageElement::height(bool ignorePendingStylesheets)
492 {
493     if (!renderer()) {
494         // check the attribute first for an explicit pixel value
495         auto optionalHeight = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(heightAttr));
496         if (optionalHeight)
497             return optionalHeight.value();
498 
499         // if the image is available, use its height
<span class="line-modified">500         if (m_imageLoader.image())</span>
<span class="line-modified">501             return m_imageLoader.image()-&gt;imageSizeForRenderer(renderer(), 1.0f).height().toUnsigned();</span>
502     }
503 
504     if (ignorePendingStylesheets)
505         document().updateLayoutIgnorePendingStylesheets();
506     else
507         document().updateLayout();
508 
509     RenderBox* box = renderBox();
510     if (!box)
511         return 0;
512     LayoutRect contentRect = box-&gt;contentBoxRect();
513     return adjustForAbsoluteZoom(snappedIntRect(contentRect).height(), *box);
514 }
515 













516 int HTMLImageElement::naturalWidth() const
517 {
<span class="line-modified">518     if (!m_imageLoader.image())</span>
519         return 0;
520 
<span class="line-modified">521     return m_imageLoader.image()-&gt;imageSizeForRenderer(renderer(), 1.0f).width();</span>
522 }
523 
524 int HTMLImageElement::naturalHeight() const
525 {
<span class="line-modified">526     if (!m_imageLoader.image())</span>
527         return 0;
528 
<span class="line-modified">529     return m_imageLoader.image()-&gt;imageSizeForRenderer(renderer(), 1.0f).height();</span>
530 }
531 
532 bool HTMLImageElement::isURLAttribute(const Attribute&amp; attribute) const
533 {
534     return attribute.name() == srcAttr
535         || attribute.name() == lowsrcAttr
536         || attribute.name() == longdescAttr
537         || (attribute.name() == usemapAttr &amp;&amp; attribute.value().string()[0] != &#39;#&#39;)
538         || HTMLElement::isURLAttribute(attribute);
539 }
540 
541 bool HTMLImageElement::attributeContainsURL(const Attribute&amp; attribute) const
542 {
543     return attribute.name() == srcsetAttr
544         || HTMLElement::attributeContainsURL(attribute);
545 }
546 
547 String HTMLImageElement::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
548 {
549     if (attribute.name() == srcsetAttr) {
550         Vector&lt;ImageCandidate&gt; imageCandidates = parseImageCandidatesFromSrcsetAttribute(StringView(attribute.value()));
551         StringBuilder result;
552         for (const auto&amp; candidate : imageCandidates) {
553             if (&amp;candidate != &amp;imageCandidates[0])
554                 result.appendLiteral(&quot;, &quot;);
555             result.append(URL(base, candidate.string.toString()).string());
<span class="line-modified">556             if (candidate.density != UninitializedDescriptor) {</span>
<span class="line-modified">557                 result.append(&#39; &#39;);</span>
<span class="line-modified">558                 result.appendFixedPrecisionNumber(candidate.density);</span>
<span class="line-modified">559                 result.append(&#39;x&#39;);</span>
<span class="line-removed">560             }</span>
<span class="line-removed">561             if (candidate.resourceWidth != UninitializedDescriptor) {</span>
<span class="line-removed">562                 result.append(&#39; &#39;);</span>
<span class="line-removed">563                 result.appendNumber(candidate.resourceWidth);</span>
<span class="line-removed">564                 result.append(&#39;w&#39;);</span>
<span class="line-removed">565             }</span>
566         }
567         return result.toString();
568     }
569     return HTMLElement::completeURLsInAttributeValue(base, attribute);
570 }
571 
572 bool HTMLImageElement::matchesUsemap(const AtomStringImpl&amp; name) const
573 {
574     return m_parsedUsemap.impl() == &amp;name;
575 }
576 
577 HTMLMapElement* HTMLImageElement::associatedMapElement() const
578 {
579     return treeScope().getImageMap(m_parsedUsemap);
580 }
581 
582 const AtomString&amp; HTMLImageElement::alt() const
583 {
584     return attributeWithoutSynchronization(altAttr);
585 }
</pre>
<hr />
<pre>
617     if (!renderer)
618         return 0;
619 
620     // FIXME: This doesn&#39;t work correctly with transforms.
621     return renderer-&gt;localToAbsolute().x();
622 }
623 
624 int HTMLImageElement::y() const
625 {
626     document().updateLayoutIgnorePendingStylesheets();
627     auto renderer = this-&gt;renderer();
628     if (!renderer)
629         return 0;
630 
631     // FIXME: This doesn&#39;t work correctly with transforms.
632     return renderer-&gt;localToAbsolute().y();
633 }
634 
635 bool HTMLImageElement::complete() const
636 {
<span class="line-modified">637     return m_imageLoader.imageComplete();</span>
638 }
639 
640 DecodingMode HTMLImageElement::decodingMode() const
641 {
642     const AtomString&amp; decodingMode = attributeWithoutSynchronization(decodingAttr);
643     if (equalLettersIgnoringASCIICase(decodingMode, &quot;sync&quot;))
644         return DecodingMode::Synchronous;
645     if (equalLettersIgnoringASCIICase(decodingMode, &quot;async&quot;))
646         return DecodingMode::Asynchronous;
647     return DecodingMode::Auto;
648 }
649 
650 void HTMLImageElement::decode(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
651 {
<span class="line-modified">652     return m_imageLoader.decode(WTFMove(promise));</span>
653 }
654 
655 void HTMLImageElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
656 {
657     HTMLElement::addSubresourceAttributeURLs(urls);
658 
659     addSubresourceURL(urls, document().completeURL(imageSourceURL()));
660     // FIXME: What about when the usemap attribute begins with &quot;#&quot;?
661     addSubresourceURL(urls, document().completeURL(attributeWithoutSynchronization(usemapAttr)));
662 }
663 
664 void HTMLImageElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
665 {
<span class="line-modified">666     m_imageLoader.elementDidMoveToNewDocument();</span>


667     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
668 }
669 
670 bool HTMLImageElement::isServerMap() const
671 {
672     if (!hasAttributeWithoutSynchronization(ismapAttr))
673         return false;
674 
675     const AtomString&amp; usemap = attributeWithoutSynchronization(usemapAttr);
676 
677     // If the usemap attribute starts with &#39;#&#39;, it refers to a map element in the document.
678     if (usemap.string()[0] == &#39;#&#39;)
679         return false;
680 
681     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(usemap)).isEmpty();
682 }
683 
684 void HTMLImageElement::setCrossOrigin(const AtomString&amp; value)
685 {
686     setAttributeWithoutSynchronization(crossoriginAttr, value);
</pre>
<hr />
<pre>
822 void HTMLImageElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
823 {
824     auto&amp; sourceImage = static_cast&lt;const HTMLImageElement&amp;&gt;(source);
825 #if ENABLE(ATTACHMENT_ELEMENT)
826     m_pendingClonedAttachmentID = !sourceImage.m_pendingClonedAttachmentID.isEmpty() ? sourceImage.m_pendingClonedAttachmentID : sourceImage.attachmentIdentifier();
827 #endif
828     m_editableImage = sourceImage.m_editableImage;
829     Element::copyNonAttributePropertiesFromElement(source);
830 }
831 
832 void HTMLImageElement::defaultEventHandler(Event&amp; event)
833 {
834     if (hasEditableImageAttribute() &amp;&amp; event.type() == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
835         focus();
836         event.setDefaultHandled();
837         return;
838     }
839     HTMLElement::defaultEventHandler(event);
840 }
841 




















842 }
</pre>
</td>
<td>
<hr />
<pre>
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;HTMLImageElement.h&quot;
 25 
 26 #include &quot;CSSPropertyNames.h&quot;
 27 #include &quot;CSSValueKeywords.h&quot;
 28 #include &quot;CachedImage.h&quot;
 29 #include &quot;Chrome.h&quot;
 30 #include &quot;ChromeClient.h&quot;
 31 #include &quot;EditableImageReference.h&quot;
 32 #include &quot;Editor.h&quot;
 33 #include &quot;ElementIterator.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLAttachmentElement.h&quot;
 38 #include &quot;HTMLDocument.h&quot;
 39 #include &quot;HTMLFormElement.h&quot;
<span class="line-added"> 40 #include &quot;HTMLImageLoader.h&quot;</span>
 41 #include &quot;HTMLParserIdioms.h&quot;
 42 #include &quot;HTMLPictureElement.h&quot;
 43 #include &quot;HTMLMapElement.h&quot;
 44 #include &quot;HTMLSourceElement.h&quot;
 45 #include &quot;HTMLSrcsetParser.h&quot;
 46 #include &quot;Logging.h&quot;
 47 #include &quot;MIMETypeRegistry.h&quot;
 48 #include &quot;MediaList.h&quot;
 49 #include &quot;MediaQueryEvaluator.h&quot;
 50 #include &quot;MouseEvent.h&quot;
 51 #include &quot;NodeTraversal.h&quot;
 52 #include &quot;PlatformMouseEvent.h&quot;
 53 #include &quot;RenderImage.h&quot;
 54 #include &quot;RenderView.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &quot;Settings.h&quot;
 57 #include &quot;ShadowRoot.h&quot;
 58 #include &quot;SizesAttributeParser.h&quot;
 59 #include &lt;wtf/IsoMallocInlines.h&gt;
 60 #include &lt;wtf/text/StringBuilder.h&gt;
 61 
 62 #if ENABLE(SERVICE_CONTROLS)
 63 #include &quot;ImageControlsRootElement.h&quot;
 64 #endif
 65 
 66 namespace WebCore {
 67 
 68 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLImageElement);
 69 
 70 using namespace HTMLNames;
 71 
<span class="line-modified"> 72 HTMLImageElement::HTMLImageElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)</span>
 73     : HTMLElement(tagName, document)
<span class="line-modified"> 74     , m_imageLoader(WTF::makeUnique&lt;HTMLImageLoader&gt;(*this))</span>
 75     , m_form(nullptr)
 76     , m_formSetByParser(makeWeakPtr(form))
<span class="line-modified"> 77     , m_compositeOperator(CompositeOperator::SourceOver)</span>
 78     , m_imageDevicePixelRatio(1.0f)
 79     , m_experimentalImageMenuEnabled(false)
<span class="line-added"> 80     , m_createdByParser(createdByParser)</span>
 81 {
 82     ASSERT(hasTagName(imgTag));
 83     setHasCustomStyleResolveCallbacks();
 84 }
 85 
 86 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(Document&amp; document)
 87 {
 88     return adoptRef(*new HTMLImageElement(imgTag, document));
 89 }
 90 
<span class="line-modified"> 91 Ref&lt;HTMLImageElement&gt; HTMLImageElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form, bool createdByParser)</span>
 92 {
<span class="line-modified"> 93     return adoptRef(*new HTMLImageElement(tagName, document, form, createdByParser));</span>
 94 }
 95 
 96 HTMLImageElement::~HTMLImageElement()
 97 {
<span class="line-added"> 98     document().removeDynamicMediaQueryDependentImage(*this);</span>
<span class="line-added"> 99 </span>
100     if (m_form)
101         m_form-&gt;removeImgElement(this);
102     setPictureElement(nullptr);
103 }
104 
105 Ref&lt;HTMLImageElement&gt; HTMLImageElement::createForJSConstructor(Document&amp; document, Optional&lt;unsigned&gt; width, Optional&lt;unsigned&gt; height)
106 {
107     auto image = adoptRef(*new HTMLImageElement(imgTag, document));
108     if (width)
109         image-&gt;setWidth(width.value());
110     if (height)
111         image-&gt;setHeight(height.value());
112     return image;
113 }
114 
115 bool HTMLImageElement::isPresentationAttribute(const QualifiedName&amp; name) const
116 {
117     if (name == widthAttr || name == heightAttr || name == borderAttr || name == vspaceAttr || name == hspaceAttr || name == valignAttr)
118         return true;
119     return HTMLElement::isPresentationAttribute(name);
</pre>
<hr />
<pre>
145 {
146     return m_bestFitImageURL.isEmpty() ? attributeWithoutSynchronization(srcAttr) : m_bestFitImageURL;
147 }
148 
149 void HTMLImageElement::setBestFitURLAndDPRFromImageCandidate(const ImageCandidate&amp; candidate)
150 {
151     m_bestFitImageURL = candidate.string.toAtomString();
152     m_currentSrc = AtomString(document().completeURL(imageSourceURL()).string());
153     if (candidate.density &gt;= 0)
154         m_imageDevicePixelRatio = 1 / candidate.density;
155     if (is&lt;RenderImage&gt;(renderer()))
156         downcast&lt;RenderImage&gt;(*renderer()).setImageDevicePixelRatio(m_imageDevicePixelRatio);
157 }
158 
159 ImageCandidate HTMLImageElement::bestFitSourceFromPictureElement()
160 {
161     auto picture = makeRefPtr(pictureElement());
162     if (!picture)
163         return { };
164 
<span class="line-modified">165     ImageCandidate candidate;</span>




166 
167     for (RefPtr&lt;Node&gt; child = picture-&gt;firstChild(); child &amp;&amp; child != this; child = child-&gt;nextSibling()) {
168         if (!is&lt;HTMLSourceElement&gt;(*child))
169             continue;
170         auto&amp; source = downcast&lt;HTMLSourceElement&gt;(*child);
171 
172         auto&amp; srcset = source.attributeWithoutSynchronization(srcsetAttr);
173         if (srcset.isEmpty())
174             continue;
175 
176         auto&amp; typeAttribute = source.attributeWithoutSynchronization(typeAttr);
177         if (!typeAttribute.isNull()) {
178             String type = typeAttribute.string();
179             type.truncate(type.find(&#39;;&#39;));
180             type = stripLeadingAndTrailingHTMLSpaces(type);
181             if (!type.isEmpty() &amp;&amp; !MIMETypeRegistry::isSupportedImageVideoOrSVGMIMEType(type))
182                 continue;
183         }
184 
185         auto documentElement = makeRefPtr(document().documentElement());
186         MediaQueryEvaluator evaluator { document().printing() ? &quot;print&quot; : &quot;screen&quot;, document(), documentElement ? documentElement-&gt;computedStyle() : nullptr };
187         auto* queries = source.parsedMediaAttribute(document());
188         LOG(MediaQueries, &quot;HTMLImageElement %p bestFitSourceFromPictureElement evaluating media queries&quot;, this);
<span class="line-modified">189 </span>
<span class="line-modified">190         auto evaluation = !queries || evaluator.evaluate(*queries, &amp;m_mediaQueryDynamicResults);</span>



191         if (!evaluation)
192             continue;
193 
<span class="line-modified">194         SizesAttributeParser sizesParser(source.attributeWithoutSynchronization(sizesAttr).string(), document(), &amp;m_mediaQueryDynamicResults);</span>
<span class="line-modified">195         auto sourceSize = sizesParser.length();</span>
<span class="line-added">196 </span>
<span class="line-added">197         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), nullAtom(), srcset, sourceSize);</span>
198         if (!candidate.isEmpty())
<span class="line-modified">199             break;</span>
200     }
<span class="line-modified">201 </span>
<span class="line-added">202     return candidate;</span>
<span class="line-added">203 }</span>
<span class="line-added">204 </span>
<span class="line-added">205 void HTMLImageElement::evaluateDynamicMediaQueryDependencies()</span>
<span class="line-added">206 {</span>
<span class="line-added">207     auto documentElement = makeRefPtr(document().documentElement());</span>
<span class="line-added">208     MediaQueryEvaluator evaluator { document().printing() ? &quot;print&quot; : &quot;screen&quot;, document(), documentElement ? documentElement-&gt;computedStyle() : nullptr };</span>
<span class="line-added">209 </span>
<span class="line-added">210     if (!evaluator.evaluateForChanges(m_mediaQueryDynamicResults))</span>
<span class="line-added">211         return;</span>
<span class="line-added">212 </span>
<span class="line-added">213     selectImageSource();</span>
214 }
215 
216 void HTMLImageElement::selectImageSource()
217 {
<span class="line-added">218     m_mediaQueryDynamicResults = { };</span>
<span class="line-added">219     document().removeDynamicMediaQueryDependentImage(*this);</span>
<span class="line-added">220 </span>
221     // First look for the best fit source from our &lt;picture&gt; parent if we have one.
222     ImageCandidate candidate = bestFitSourceFromPictureElement();
223     if (candidate.isEmpty()) {
224         // If we don&#39;t have a &lt;picture&gt; or didn&#39;t find a source, then we use our own attributes.
<span class="line-modified">225         SizesAttributeParser sizesParser(attributeWithoutSynchronization(sizesAttr).string(), document(), &amp;m_mediaQueryDynamicResults);</span>
<span class="line-added">226         auto sourceSize = sizesParser.length();</span>
227         candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);
228     }
229     setBestFitURLAndDPRFromImageCandidate(candidate);
<span class="line-modified">230     m_imageLoader-&gt;updateFromElementIgnoringPreviousError();</span>
<span class="line-added">231 </span>
<span class="line-added">232     if (!m_mediaQueryDynamicResults.isEmpty())</span>
<span class="line-added">233         document().addDynamicMediaQueryDependentImage(*this);</span>
234 }
235 
236 void HTMLImageElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
237 {
238     if (name == altAttr) {
239         if (is&lt;RenderImage&gt;(renderer()))
240             downcast&lt;RenderImage&gt;(*renderer()).updateAltText();
241     } else if (name == srcAttr || name == srcsetAttr || name == sizesAttr)
242         selectImageSource();
243     else if (name == usemapAttr) {
244         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
245             treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
246 
247         m_parsedUsemap = parseHTMLHashNameReference(value);
248 
249         if (isInTreeScope() &amp;&amp; !m_parsedUsemap.isNull())
250             treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
251     } else if (name == compositeAttr) {
252         // FIXME: images don&#39;t support blend modes in their compositing attribute.
253         BlendMode blendOp = BlendMode::Normal;
254         if (!parseCompositeAndBlendOperator(value, m_compositeOperator, blendOp))
<span class="line-modified">255             m_compositeOperator = CompositeOperator::SourceOver;</span>
256 #if ENABLE(SERVICE_CONTROLS)
257     } else if (name == webkitimagemenuAttr) {
258         m_experimentalImageMenuEnabled = !value.isNull();
259         updateImageControls();
260 #endif
261     } else if (name == x_apple_editable_imageAttr)
262         updateEditableImage();
263     else {
264         if (name == nameAttr) {
265             bool willHaveName = !value.isNull();
266             if (m_hadNameBeforeAttributeChanged != willHaveName &amp;&amp; isConnected() &amp;&amp; !isInShadowTree() &amp;&amp; is&lt;HTMLDocument&gt;(document())) {
267                 HTMLDocument&amp; document = downcast&lt;HTMLDocument&gt;(this-&gt;document());
268                 const AtomString&amp; id = getIdAttribute();
269                 if (!id.isEmpty() &amp;&amp; id != getNameAttribute()) {
270                     if (willHaveName)
271                         document.addDocumentNamedItem(*id.impl(), *this);
272                     else
273                         document.removeDocumentNamedItem(*id.impl(), *this);
274                 }
275             }
</pre>
<hr />
<pre>
313         return true;
314     return HTMLElement::supportsFocus();
315 }
316 
317 bool HTMLImageElement::isFocusable() const
318 {
319     if (hasEditableImageAttribute())
320         return true;
321     return HTMLElement::isFocusable();
322 }
323 
324 bool HTMLImageElement::isInteractiveContent() const
325 {
326     return hasAttributeWithoutSynchronization(usemapAttr);
327 }
328 
329 void HTMLImageElement::didAttachRenderers()
330 {
331     if (!is&lt;RenderImage&gt;(renderer()))
332         return;
<span class="line-modified">333     if (m_imageLoader-&gt;hasPendingBeforeLoadEvent())</span>
334         return;
335 
336 #if ENABLE(SERVICE_CONTROLS)
337     updateImageControls();
338 #endif
339 
340     auto&amp; renderImage = downcast&lt;RenderImage&gt;(*renderer());
341     RenderImageResource&amp; renderImageResource = renderImage.imageResource();
342     if (renderImageResource.cachedImage())
343         return;
<span class="line-modified">344     renderImageResource.setCachedImage(m_imageLoader-&gt;image());</span>
345 
346     // If we have no image at all because we have no src attribute, set
347     // image height and width for the alt text instead.
<span class="line-modified">348     if (!m_imageLoader-&gt;image() &amp;&amp; !renderImageResource.cachedImage())</span>
349         renderImage.setImageSizeForAltText();
350 }
351 
352 Node::InsertedIntoAncestorResult HTMLImageElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
353 {
354     if (m_formSetByParser) {
355         m_form = WTFMove(m_formSetByParser);
356         m_form-&gt;registerImgElement(this);
357     }
358 
359     if (m_form &amp;&amp; rootElement() != m_form-&gt;rootElement()) {
360         m_form-&gt;removeImgElement(this);
361         m_form = nullptr;
362     }
363 
364     if (!m_form) {
365         if (auto* newForm = HTMLFormElement::findClosestFormAncestor(*this)) {
366             m_form = makeWeakPtr(newForm);
367             newForm-&gt;registerImgElement(this);
368         }
369     }
370 
371     // Insert needs to complete first, before we start updating the loader. Loader dispatches events which could result
372     // in callbacks back to this node.
373     Node::InsertedIntoAncestorResult insertNotificationRequest = HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
374 
375     if (insertionType.connectedToDocument &amp;&amp; hasEditableImageAttribute())
376         insertNotificationRequest = InsertedIntoAncestorResult::NeedsPostInsertionCallback;
377 
378     if (insertionType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
379         treeScope().addImageElementByUsemap(*m_parsedUsemap.impl(), *this);
380 
381     if (is&lt;HTMLPictureElement&gt;(parentNode())) {
382         setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(*parentNode()));
383         selectImageSource();
384     }
385 
386     // If we have been inserted from a renderer-less document,
387     // our loader may have not fetched the image, so do it now.
<span class="line-modified">388     if (insertionType.connectedToDocument &amp;&amp; !m_imageLoader-&gt;image())</span>
<span class="line-modified">389         m_imageLoader-&gt;updateFromElement();</span>
390 
391     return insertNotificationRequest;
392 }
393 
394 void HTMLImageElement::didFinishInsertingNode()
395 {
396     if (hasEditableImageAttribute())
397         updateEditableImage();
398 }
399 
400 void HTMLImageElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
401 {
402     if (m_form)
403         m_form-&gt;removeImgElement(this);
404 
405     if (removalType.treeScopeChanged &amp;&amp; !m_parsedUsemap.isNull())
406         oldParentOfRemovedTree.treeScope().removeImageElementByUsemap(*m_parsedUsemap.impl(), *this);
407 
408     if (is&lt;HTMLPictureElement&gt;(parentNode()))
409         setPictureElement(nullptr);
</pre>
<hr />
<pre>
473 
474 HTMLPictureElement* HTMLImageElement::pictureElement() const
475 {
476     return m_pictureElement.get();
477 }
478 
479 void HTMLImageElement::setPictureElement(HTMLPictureElement* pictureElement)
480 {
481     m_pictureElement = makeWeakPtr(pictureElement);
482 }
483 
484 unsigned HTMLImageElement::width(bool ignorePendingStylesheets)
485 {
486     if (!renderer()) {
487         // check the attribute first for an explicit pixel value
488         auto optionalWidth = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(widthAttr));
489         if (optionalWidth)
490             return optionalWidth.value();
491 
492         // if the image is available, use its width
<span class="line-modified">493         if (m_imageLoader-&gt;image())</span>
<span class="line-modified">494             return m_imageLoader-&gt;image()-&gt;imageSizeForRenderer(renderer(), 1.0f).width().toUnsigned();</span>
495     }
496 
497     if (ignorePendingStylesheets)
498         document().updateLayoutIgnorePendingStylesheets();
499     else
500         document().updateLayout();
501 
502     RenderBox* box = renderBox();
503     if (!box)
504         return 0;
505     LayoutRect contentRect = box-&gt;contentBoxRect();
506     return adjustForAbsoluteZoom(snappedIntRect(contentRect).width(), *box);
507 }
508 
509 unsigned HTMLImageElement::height(bool ignorePendingStylesheets)
510 {
511     if (!renderer()) {
512         // check the attribute first for an explicit pixel value
513         auto optionalHeight = parseHTMLNonNegativeInteger(attributeWithoutSynchronization(heightAttr));
514         if (optionalHeight)
515             return optionalHeight.value();
516 
517         // if the image is available, use its height
<span class="line-modified">518         if (m_imageLoader-&gt;image())</span>
<span class="line-modified">519             return m_imageLoader-&gt;image()-&gt;imageSizeForRenderer(renderer(), 1.0f).height().toUnsigned();</span>
520     }
521 
522     if (ignorePendingStylesheets)
523         document().updateLayoutIgnorePendingStylesheets();
524     else
525         document().updateLayout();
526 
527     RenderBox* box = renderBox();
528     if (!box)
529         return 0;
530     LayoutRect contentRect = box-&gt;contentBoxRect();
531     return adjustForAbsoluteZoom(snappedIntRect(contentRect).height(), *box);
532 }
533 
<span class="line-added">534 float HTMLImageElement::effectiveImageDevicePixelRatio() const</span>
<span class="line-added">535 {</span>
<span class="line-added">536     if (!m_imageLoader-&gt;image())</span>
<span class="line-added">537         return 1.0f;</span>
<span class="line-added">538 </span>
<span class="line-added">539     auto* image = m_imageLoader-&gt;image()-&gt;image();</span>
<span class="line-added">540 </span>
<span class="line-added">541     if (image &amp;&amp; image-&gt;isSVGImage())</span>
<span class="line-added">542         return 1.0f;</span>
<span class="line-added">543 </span>
<span class="line-added">544     return m_imageDevicePixelRatio;</span>
<span class="line-added">545 }</span>
<span class="line-added">546 </span>
547 int HTMLImageElement::naturalWidth() const
548 {
<span class="line-modified">549     if (!m_imageLoader-&gt;image())</span>
550         return 0;
551 
<span class="line-modified">552     return m_imageLoader-&gt;image()-&gt;unclampedImageSizeForRenderer(renderer(), effectiveImageDevicePixelRatio()).width();</span>
553 }
554 
555 int HTMLImageElement::naturalHeight() const
556 {
<span class="line-modified">557     if (!m_imageLoader-&gt;image())</span>
558         return 0;
559 
<span class="line-modified">560     return m_imageLoader-&gt;image()-&gt;unclampedImageSizeForRenderer(renderer(), effectiveImageDevicePixelRatio()).height();</span>
561 }
562 
563 bool HTMLImageElement::isURLAttribute(const Attribute&amp; attribute) const
564 {
565     return attribute.name() == srcAttr
566         || attribute.name() == lowsrcAttr
567         || attribute.name() == longdescAttr
568         || (attribute.name() == usemapAttr &amp;&amp; attribute.value().string()[0] != &#39;#&#39;)
569         || HTMLElement::isURLAttribute(attribute);
570 }
571 
572 bool HTMLImageElement::attributeContainsURL(const Attribute&amp; attribute) const
573 {
574     return attribute.name() == srcsetAttr
575         || HTMLElement::attributeContainsURL(attribute);
576 }
577 
578 String HTMLImageElement::completeURLsInAttributeValue(const URL&amp; base, const Attribute&amp; attribute) const
579 {
580     if (attribute.name() == srcsetAttr) {
581         Vector&lt;ImageCandidate&gt; imageCandidates = parseImageCandidatesFromSrcsetAttribute(StringView(attribute.value()));
582         StringBuilder result;
583         for (const auto&amp; candidate : imageCandidates) {
584             if (&amp;candidate != &amp;imageCandidates[0])
585                 result.appendLiteral(&quot;, &quot;);
586             result.append(URL(base, candidate.string.toString()).string());
<span class="line-modified">587             if (candidate.density != UninitializedDescriptor)</span>
<span class="line-modified">588                 result.append(&#39; &#39;, candidate.density, &#39;x&#39;);</span>
<span class="line-modified">589             if (candidate.resourceWidth != UninitializedDescriptor)</span>
<span class="line-modified">590                 result.append(&#39; &#39;, candidate.resourceWidth, &#39;w&#39;);</span>






591         }
592         return result.toString();
593     }
594     return HTMLElement::completeURLsInAttributeValue(base, attribute);
595 }
596 
597 bool HTMLImageElement::matchesUsemap(const AtomStringImpl&amp; name) const
598 {
599     return m_parsedUsemap.impl() == &amp;name;
600 }
601 
602 HTMLMapElement* HTMLImageElement::associatedMapElement() const
603 {
604     return treeScope().getImageMap(m_parsedUsemap);
605 }
606 
607 const AtomString&amp; HTMLImageElement::alt() const
608 {
609     return attributeWithoutSynchronization(altAttr);
610 }
</pre>
<hr />
<pre>
642     if (!renderer)
643         return 0;
644 
645     // FIXME: This doesn&#39;t work correctly with transforms.
646     return renderer-&gt;localToAbsolute().x();
647 }
648 
649 int HTMLImageElement::y() const
650 {
651     document().updateLayoutIgnorePendingStylesheets();
652     auto renderer = this-&gt;renderer();
653     if (!renderer)
654         return 0;
655 
656     // FIXME: This doesn&#39;t work correctly with transforms.
657     return renderer-&gt;localToAbsolute().y();
658 }
659 
660 bool HTMLImageElement::complete() const
661 {
<span class="line-modified">662     return m_imageLoader-&gt;imageComplete();</span>
663 }
664 
665 DecodingMode HTMLImageElement::decodingMode() const
666 {
667     const AtomString&amp; decodingMode = attributeWithoutSynchronization(decodingAttr);
668     if (equalLettersIgnoringASCIICase(decodingMode, &quot;sync&quot;))
669         return DecodingMode::Synchronous;
670     if (equalLettersIgnoringASCIICase(decodingMode, &quot;async&quot;))
671         return DecodingMode::Asynchronous;
672     return DecodingMode::Auto;
673 }
674 
675 void HTMLImageElement::decode(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
676 {
<span class="line-modified">677     return m_imageLoader-&gt;decode(WTFMove(promise));</span>
678 }
679 
680 void HTMLImageElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
681 {
682     HTMLElement::addSubresourceAttributeURLs(urls);
683 
684     addSubresourceURL(urls, document().completeURL(imageSourceURL()));
685     // FIXME: What about when the usemap attribute begins with &quot;#&quot;?
686     addSubresourceURL(urls, document().completeURL(attributeWithoutSynchronization(usemapAttr)));
687 }
688 
689 void HTMLImageElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
690 {
<span class="line-modified">691     oldDocument.removeDynamicMediaQueryDependentImage(*this);</span>
<span class="line-added">692 </span>
<span class="line-added">693     m_imageLoader-&gt;elementDidMoveToNewDocument();</span>
694     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
695 }
696 
697 bool HTMLImageElement::isServerMap() const
698 {
699     if (!hasAttributeWithoutSynchronization(ismapAttr))
700         return false;
701 
702     const AtomString&amp; usemap = attributeWithoutSynchronization(usemapAttr);
703 
704     // If the usemap attribute starts with &#39;#&#39;, it refers to a map element in the document.
705     if (usemap.string()[0] == &#39;#&#39;)
706         return false;
707 
708     return document().completeURL(stripLeadingAndTrailingHTMLSpaces(usemap)).isEmpty();
709 }
710 
711 void HTMLImageElement::setCrossOrigin(const AtomString&amp; value)
712 {
713     setAttributeWithoutSynchronization(crossoriginAttr, value);
</pre>
<hr />
<pre>
849 void HTMLImageElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
850 {
851     auto&amp; sourceImage = static_cast&lt;const HTMLImageElement&amp;&gt;(source);
852 #if ENABLE(ATTACHMENT_ELEMENT)
853     m_pendingClonedAttachmentID = !sourceImage.m_pendingClonedAttachmentID.isEmpty() ? sourceImage.m_pendingClonedAttachmentID : sourceImage.attachmentIdentifier();
854 #endif
855     m_editableImage = sourceImage.m_editableImage;
856     Element::copyNonAttributePropertiesFromElement(source);
857 }
858 
859 void HTMLImageElement::defaultEventHandler(Event&amp; event)
860 {
861     if (hasEditableImageAttribute() &amp;&amp; event.type() == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event) &amp;&amp; downcast&lt;MouseEvent&gt;(event).button() == LeftButton) {
862         focus();
863         event.setDefaultHandled();
864         return;
865     }
866     HTMLElement::defaultEventHandler(event);
867 }
868 
<span class="line-added">869 CachedImage* HTMLImageElement::cachedImage() const</span>
<span class="line-added">870 {</span>
<span class="line-added">871     return m_imageLoader-&gt;image();</span>
<span class="line-added">872 }</span>
<span class="line-added">873 </span>
<span class="line-added">874 void HTMLImageElement::setLoadManually(bool loadManually)</span>
<span class="line-added">875 {</span>
<span class="line-added">876     m_imageLoader-&gt;setLoadManually(loadManually);</span>
<span class="line-added">877 }</span>
<span class="line-added">878 </span>
<span class="line-added">879 bool HTMLImageElement::hasPendingActivity() const</span>
<span class="line-added">880 {</span>
<span class="line-added">881     return m_imageLoader-&gt;hasPendingActivity();</span>
<span class="line-added">882 }</span>
<span class="line-added">883 </span>
<span class="line-added">884 size_t HTMLImageElement::pendingDecodePromisesCountForTesting() const</span>
<span class="line-added">885 {</span>
<span class="line-added">886     return m_imageLoader-&gt;pendingDecodePromisesCountForTesting();</span>
<span class="line-added">887 }</span>
<span class="line-added">888 </span>
889 }
</pre>
</td>
</tr>
</table>
<center><a href="HTMLIFrameElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLImageElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageRuntimeAgent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageRuntimeAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageRuntimeAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageRuntimeAgent.cpp
@@ -30,33 +30,35 @@
  */
 
 #include "config.h"
 #include "PageRuntimeAgent.h"
 
-#include "Chrome.h"
-#include "ChromeClient.h"
+#include "DOMWrapperWorld.h"
 #include "Document.h"
 #include "Frame.h"
 #include "InspectorPageAgent.h"
 #include "InstrumentingAgents.h"
 #include "JSDOMWindowBase.h"
 #include "Page.h"
 #include "PageConsoleClient.h"
 #include "ScriptController.h"
 #include "ScriptState.h"
 #include "SecurityOrigin.h"
-#include "UserGestureIndicator.h"
+#include "UserGestureEmulationScope.h"
 #include <JavaScriptCore/InjectedScript.h>
 #include <JavaScriptCore/InjectedScriptManager.h>
-
-using Inspector::Protocol::Runtime::ExecutionContextDescription;
-
+#include <JavaScriptCore/InspectorProtocolObjects.h>
 
 namespace WebCore {
 
 using namespace Inspector;
 
+static bool asBool(const bool* b)
+{
+    return b && *b;
+}
+
 PageRuntimeAgent::PageRuntimeAgent(PageAgentContext& context)
     : InspectorRuntimeAgent(context)
     , m_frontendDispatcher(makeUnique<Inspector::RuntimeFrontendDispatcher>(context.frontendRouter))
     , m_backendDispatcher(Inspector::RuntimeBackendDispatcher::create(context.backendDispatcher, this))
     , m_instrumentingAgents(context.instrumentingAgents)
@@ -66,42 +68,50 @@
 
 PageRuntimeAgent::~PageRuntimeAgent() = default;
 
 void PageRuntimeAgent::enable(ErrorString& errorString)
 {
-    bool enabled = m_instrumentingAgents.pageRuntimeAgent() == this;
+    if (m_instrumentingAgents.pageRuntimeAgent() == this)
+        return;
 
     InspectorRuntimeAgent::enable(errorString);
+    if (!errorString.isEmpty())
+        return;
 
-    m_instrumentingAgents.setPageRuntimeAgent(this);
+    // Report initial contexts before enabling instrumentation as the reporting
+    // can force creation of script state which could result in duplicate notifications.
+    reportExecutionContextCreation();
 
-    if (!enabled)
-        reportExecutionContextCreation();
+    m_instrumentingAgents.setPageRuntimeAgent(this);
 }
 
 void PageRuntimeAgent::disable(ErrorString& errorString)
 {
     m_instrumentingAgents.setPageRuntimeAgent(nullptr);
 
     InspectorRuntimeAgent::disable(errorString);
 }
 
-void PageRuntimeAgent::didCreateMainWorldContext(Frame& frame)
+void PageRuntimeAgent::frameNavigated(Frame& frame)
+{
+    // Ensure execution context is created for the frame even if it doesn't have scripts.
+    mainWorldExecState(&frame);
+}
+
+void PageRuntimeAgent::didClearWindowObjectInWorld(Frame& frame, DOMWrapperWorld& world)
 {
     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
     if (!pageAgent)
         return;
 
-    auto frameId = pageAgent->frameId(&frame);
-    auto* scriptState = mainWorldExecState(&frame);
-    notifyContextCreated(frameId, scriptState, nullptr, true);
+    notifyContextCreated(pageAgent->frameId(&frame), frame.script().globalObject(world), world);
 }
 
 InjectedScript PageRuntimeAgent::injectedScriptForEval(ErrorString& errorString, const int* executionContextId)
 {
     if (!executionContextId) {
-        JSC::ExecState* scriptState = mainWorldExecState(&m_inspectedPage.mainFrame());
+        JSC::JSGlobalObject* scriptState = mainWorldExecState(&m_inspectedPage.mainFrame());
         InjectedScript result = injectedScriptManager().injectedScriptFor(scriptState);
         if (result.hasNoValue())
             errorString = "Internal error: main world execution context not found"_s;
         return result;
     }
@@ -126,64 +136,72 @@
 {
     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
     if (!pageAgent)
         return;
 
-    Vector<std::pair<JSC::ExecState*, SecurityOrigin*>> isolatedContexts;
-    for (Frame* frame = &m_inspectedPage.mainFrame(); frame; frame = frame->tree().traverseNext()) {
+    for (auto* frame = &m_inspectedPage.mainFrame(); frame; frame = frame->tree().traverseNext()) {
         if (!frame->script().canExecuteScripts(NotAboutToExecuteScript))
             continue;
 
-        String frameId = pageAgent->frameId(frame);
+        auto frameId = pageAgent->frameId(frame);
 
-        JSC::ExecState* scriptState = mainWorldExecState(frame);
-        notifyContextCreated(frameId, scriptState, nullptr, true);
-        frame->script().collectIsolatedContexts(isolatedContexts);
-        if (isolatedContexts.isEmpty())
-            continue;
-        for (auto& context : isolatedContexts)
-            notifyContextCreated(frameId, context.first, context.second, false);
-        isolatedContexts.clear();
+        // Always send the main world first.
+        auto* mainGlobalObject = mainWorldExecState(frame);
+        notifyContextCreated(frameId, mainGlobalObject, mainThreadNormalWorld());
+
+        for (auto& jsWindowProxy : frame->windowProxy().jsWindowProxiesAsVector()) {
+            auto* globalObject = jsWindowProxy->window();
+            if (globalObject == mainGlobalObject)
+                continue;
+
+            auto& securityOrigin = downcast<DOMWindow>(jsWindowProxy->wrapped()).document()->securityOrigin();
+            notifyContextCreated(frameId, globalObject, jsWindowProxy->world(), &securityOrigin);
+        }
     }
 }
 
-void PageRuntimeAgent::notifyContextCreated(const String& frameId, JSC::ExecState* scriptState, SecurityOrigin* securityOrigin, bool isPageContext)
+static Inspector::Protocol::Runtime::ExecutionContextType toProtocol(DOMWrapperWorld::Type type)
 {
-    ASSERT(securityOrigin || isPageContext);
+    switch (type) {
+    case DOMWrapperWorld::Type::Normal:
+        return Inspector::Protocol::Runtime::ExecutionContextType::Normal;
+    case DOMWrapperWorld::Type::User:
+        return Inspector::Protocol::Runtime::ExecutionContextType::User;
+    case DOMWrapperWorld::Type::Internal:
+        return Inspector::Protocol::Runtime::ExecutionContextType::Internal;
+    }
+
+    ASSERT_NOT_REACHED();
+    return Inspector::Protocol::Runtime::ExecutionContextType::Internal;
+}
 
-    InjectedScript result = injectedScriptManager().injectedScriptFor(scriptState);
-    if (result.hasNoValue())
+void PageRuntimeAgent::notifyContextCreated(const String& frameId, JSC::JSGlobalObject* globalObject, const DOMWrapperWorld& world, SecurityOrigin* securityOrigin)
+{
+    auto injectedScript = injectedScriptManager().injectedScriptFor(globalObject);
+    if (injectedScript.hasNoValue())
         return;
 
-    int executionContextId = injectedScriptManager().injectedScriptIdFor(scriptState);
-    String name = securityOrigin ? securityOrigin->toRawString() : String();
-    m_frontendDispatcher->executionContextCreated(ExecutionContextDescription::create()
-        .setId(executionContextId)
-        .setIsPageContext(isPageContext)
+    auto name = world.name();
+    if (name.isEmpty() && securityOrigin)
+        name = securityOrigin->toRawString();
+
+    m_frontendDispatcher->executionContextCreated(Inspector::Protocol::Runtime::ExecutionContextDescription::create()
+        .setId(injectedScriptManager().injectedScriptIdFor(globalObject))
+        .setType(toProtocol(world.type()))
         .setName(name)
         .setFrameId(frameId)
         .release());
 }
 
 void PageRuntimeAgent::evaluate(ErrorString& errorString, const String& expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const int* executionContextId, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* emulateUserGesture, RefPtr<Inspector::Protocol::Runtime::RemoteObject>& result, Optional<bool>& wasThrown, Optional<int>& savedResultIndex)
 {
-    auto& pageChromeClient = m_inspectedPage.chrome().client();
-
-    auto shouldEmulateUserGesture = emulateUserGesture && *emulateUserGesture;
-
-    Optional<ProcessingUserGestureState> userGestureState = shouldEmulateUserGesture ? Optional<ProcessingUserGestureState>(ProcessingUserGesture) : WTF::nullopt;
-    UserGestureIndicator gestureIndicator(userGestureState);
-
-    bool userWasInteracting = false;
-    if (shouldEmulateUserGesture) {
-        userWasInteracting = pageChromeClient.userIsInteracting();
-        if (!userWasInteracting)
-            pageChromeClient.setUserIsInteracting(true);
-    }
-
+    UserGestureEmulationScope userGestureScope(m_inspectedPage, asBool(emulateUserGesture));
     InspectorRuntimeAgent::evaluate(errorString, expression, objectGroup, includeCommandLineAPI, doNotPauseOnExceptionsAndMuteConsole, executionContextId, returnByValue, generatePreview, saveResult, emulateUserGesture, result, wasThrown, savedResultIndex);
+}
 
-    if (shouldEmulateUserGesture && !userWasInteracting && pageChromeClient.userIsInteracting())
-        pageChromeClient.setUserIsInteracting(false);
+void PageRuntimeAgent::callFunctionOn(ErrorString& errorString, const String& objectId, const String& expression, const JSON::Array* optionalArguments, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* emulateUserGesture, RefPtr<Inspector::Protocol::Runtime::RemoteObject>& result, Optional<bool>& wasThrown)
+{
+    UserGestureEmulationScope userGestureScope(m_inspectedPage, asBool(emulateUserGesture));
+    InspectorRuntimeAgent::callFunctionOn(errorString, objectId, expression, optionalArguments, doNotPauseOnExceptionsAndMuteConsole, returnByValue, generatePreview, emulateUserGesture, result, wasThrown);
 }
 
 } // namespace WebCore

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008, 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SQLTransaction.h&quot;
 31 
 32 #include &quot;Database.h&quot;
 33 #include &quot;DatabaseAuthorizer.h&quot;
 34 #include &quot;DatabaseContext.h&quot;
 35 #include &quot;DatabaseThread.h&quot;
 36 #include &quot;DatabaseTracker.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;OriginLock.h&quot;
 40 #include &quot;SQLError.h&quot;
 41 #include &quot;SQLStatement.h&quot;
 42 #include &quot;SQLStatementCallback.h&quot;
 43 #include &quot;SQLStatementErrorCallback.h&quot;
 44 #include &quot;SQLTransactionBackend.h&quot;
 45 #include &quot;SQLTransactionCallback.h&quot;
 46 #include &quot;SQLTransactionCoordinator.h&quot;
 47 #include &quot;SQLTransactionErrorCallback.h&quot;
 48 #include &quot;SQLiteTransaction.h&quot;
 49 #include &quot;VoidCallback.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 50 #include &quot;WindowEventLoop.h&quot;</span>
 51 #include &lt;wtf/Optional.h&gt;
 52 #include &lt;wtf/StdLibExtras.h&gt;
 53 #include &lt;wtf/Vector.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 Ref&lt;SQLTransaction&gt; SQLTransaction::create(Ref&lt;Database&gt;&amp;&amp; database, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
 58 {
 59     return adoptRef(*new SQLTransaction(WTFMove(database), WTFMove(callback), WTFMove(successCallback), WTFMove(errorCallback), WTFMove(wrapper), readOnly));
 60 }
 61 
 62 SQLTransaction::SQLTransaction(Ref&lt;Database&gt;&amp;&amp; database, RefPtr&lt;SQLTransactionCallback&gt;&amp;&amp; callback, RefPtr&lt;VoidCallback&gt;&amp;&amp; successCallback, RefPtr&lt;SQLTransactionErrorCallback&gt;&amp;&amp; errorCallback, RefPtr&lt;SQLTransactionWrapper&gt;&amp;&amp; wrapper, bool readOnly)
 63     : m_database(WTFMove(database))
 64     , m_callbackWrapper(WTFMove(callback), &amp;m_database-&gt;document())
 65     , m_successCallbackWrapper(WTFMove(successCallback), &amp;m_database-&gt;document())
 66     , m_errorCallbackWrapper(WTFMove(errorCallback), &amp;m_database-&gt;document())
 67     , m_wrapper(WTFMove(wrapper))
 68     , m_nextStep(&amp;SQLTransaction::acquireLock)
 69     , m_readOnly(readOnly)
 70     , m_backend(*this)
 71 {
 72 }
 73 
 74 SQLTransaction::~SQLTransaction() = default;
 75 
 76 ExceptionOr&lt;void&gt; SQLTransaction::executeSql(const String&amp; sqlStatement, Optional&lt;Vector&lt;SQLValue&gt;&gt;&amp;&amp; arguments, RefPtr&lt;SQLStatementCallback&gt;&amp;&amp; callback, RefPtr&lt;SQLStatementErrorCallback&gt;&amp;&amp; callbackError)
 77 {
 78     if (!m_executeSqlAllowed || !m_database-&gt;opened())
 79         return Exception { InvalidStateError };
 80 
 81     int permissions = DatabaseAuthorizer::ReadWriteMask;
 82     if (!m_database-&gt;databaseContext().allowDatabaseAccess())
 83         permissions |= DatabaseAuthorizer::NoAccessMask;
 84     else if (m_readOnly)
 85         permissions |= DatabaseAuthorizer::ReadOnlyMask;
 86 
 87     auto statement = makeUnique&lt;SQLStatement&gt;(m_database, sqlStatement, arguments.valueOr(Vector&lt;SQLValue&gt; { }), WTFMove(callback), WTFMove(callbackError), permissions);
 88 
 89     if (m_database-&gt;deleted())
 90         statement-&gt;setDatabaseDeletedError();
 91 
 92     enqueueStatement(WTFMove(statement));
 93 
 94     return { };
 95 }
 96 
 97 void SQLTransaction::lockAcquired()
 98 {
 99     m_lockAcquired = true;
100 
101     m_backend.m_requestedState = SQLTransactionState::OpenTransactionAndPreflight;
102     m_database-&gt;scheduleTransactionStep(*this);
103 }
104 
105 void SQLTransaction::performNextStep()
106 {
107     m_backend.computeNextStateAndCleanupIfNeeded();
108     m_backend.runStateMachine();
109 }
110 
111 void SQLTransaction::performPendingCallback()
112 {
<a name="2" id="anc2"></a><span class="line-added">113     ASSERT(isMainThread());</span>
114     LOG(StorageAPI, &quot;Callback %s\n&quot;, debugStepName(m_nextStep));
115 
116     ASSERT(m_nextStep == &amp;SQLTransaction::deliverTransactionCallback
117            || m_nextStep == &amp;SQLTransaction::deliverTransactionErrorCallback
118            || m_nextStep == &amp;SQLTransaction::deliverStatementCallback
119            || m_nextStep == &amp;SQLTransaction::deliverQuotaIncreaseCallback
120            || m_nextStep == &amp;SQLTransaction::deliverSuccessCallback);
121 
122     checkAndHandleClosedDatabase();
123 
124     if (m_nextStep)
125         (this-&gt;*m_nextStep)();
126 }
127 
128 void SQLTransaction::notifyDatabaseThreadIsShuttingDown()
129 {
130     m_backend.notifyDatabaseThreadIsShuttingDown();
131 }
132 
<a name="3" id="anc3"></a><span class="line-added">133 void SQLTransaction::callErrorCallbackDueToInterruption()</span>
<span class="line-added">134 {</span>
<span class="line-added">135     ASSERT(isMainThread());</span>
<span class="line-added">136     auto errorCallback = m_errorCallbackWrapper.unwrap();</span>
<span class="line-added">137     if (!errorCallback)</span>
<span class="line-added">138         return;</span>
<span class="line-added">139 </span>
<span class="line-added">140     m_database-&gt;document().eventLoop().queueTask(TaskSource::Networking, [errorCallback = WTFMove(errorCallback)]() mutable {</span>
<span class="line-added">141         errorCallback-&gt;handleEvent(SQLError::create(SQLError::DATABASE_ERR, &quot;the database was closed&quot;));</span>
<span class="line-added">142     });</span>
<span class="line-added">143 }</span>
<span class="line-added">144 </span>
145 void SQLTransaction::enqueueStatement(std::unique_ptr&lt;SQLStatement&gt; statement)
146 {
147     LockHolder locker(m_statementMutex);
148     m_statementQueue.append(WTFMove(statement));
149 }
150 
151 SQLTransaction::StateFunction SQLTransaction::stateFunctionFor(SQLTransactionState state)
152 {
153     static const StateFunction stateFunctions[] = {
154         &amp;SQLTransaction::unreachableState,                // 0. illegal
155         &amp;SQLTransaction::unreachableState,                // 1. idle
156         &amp;SQLTransaction::unreachableState,                // 2. acquireLock
157         &amp;SQLTransaction::unreachableState,                // 3. openTransactionAndPreflight
158         &amp;SQLTransaction::unreachableState,                // 4. runStatements
159         &amp;SQLTransaction::unreachableState,                // 5. postflightAndCommit
160         &amp;SQLTransaction::unreachableState,                // 6. cleanupAndTerminate
161         &amp;SQLTransaction::unreachableState,                // 7. cleanupAfterTransactionErrorCallback
162         &amp;SQLTransaction::deliverTransactionCallback,      // 8.
163         &amp;SQLTransaction::deliverTransactionErrorCallback, // 9.
164         &amp;SQLTransaction::deliverStatementCallback,        // 10.
165         &amp;SQLTransaction::deliverQuotaIncreaseCallback,    // 11.
166         &amp;SQLTransaction::deliverSuccessCallback           // 12.
167     };
168 
169     ASSERT(WTF_ARRAY_LENGTH(stateFunctions) == static_cast&lt;int&gt;(SQLTransactionState::NumberOfStates));
170     ASSERT(state &lt; SQLTransactionState::NumberOfStates);
171 
172     return stateFunctions[static_cast&lt;int&gt;(state)];
173 }
174 
175 // requestTransitToState() can be called from the backend. Hence, it should
176 // NOT be modifying SQLTransactionBackend in general. The only safe field to
177 // modify is m_requestedState which is meant for this purpose.
178 void SQLTransaction::requestTransitToState(SQLTransactionState nextState)
179 {
180     LOG(StorageAPI, &quot;Scheduling %s for transaction %p\n&quot;, nameForSQLTransactionState(nextState), this);
181     m_requestedState = nextState;
182     m_database-&gt;scheduleTransactionCallback(this);
183 }
184 
185 void SQLTransaction::checkAndHandleClosedDatabase()
186 {
187     if (m_database-&gt;opened())
188         return;
189 
190     // If the database was stopped, don&#39;t do anything and cancel queued work
191     LOG(StorageAPI, &quot;Database was stopped or interrupted - cancelling work for this transaction&quot;);
192 
193     LockHolder locker(m_statementMutex);
194     m_statementQueue.clear();
195     m_nextStep = nullptr;
196 
<a name="4" id="anc4"></a><span class="line-added">197     callErrorCallbackDueToInterruption();</span>
<span class="line-added">198 </span>
199     // Release the unneeded callbacks, to break reference cycles.
200     m_callbackWrapper.clear();
201     m_successCallbackWrapper.clear();
202     m_errorCallbackWrapper.clear();
203 
204     // The next steps should be executed only if we&#39;re on the DB thread.
205     if (m_database-&gt;databaseThread().getThread() != &amp;Thread::current())
206         return;
207 
208     // The current SQLite transaction should be stopped, as well
209     if (m_sqliteTransaction) {
210         m_sqliteTransaction-&gt;stop();
211         m_sqliteTransaction = nullptr;
212     }
213 
214     if (m_lockAcquired)
215         m_database-&gt;transactionCoordinator()-&gt;releaseLock(*this);
216 }
217 
218 void SQLTransaction::scheduleCallback(void (SQLTransaction::*step)())
219 {
220     m_nextStep = step;
221 
222     LOG(StorageAPI, &quot;Scheduling %s for transaction %p\n&quot;, debugStepName(step), this);
223     m_database-&gt;scheduleTransactionCallback(this);
224 }
225 
226 void SQLTransaction::acquireLock()
227 {
228     m_database-&gt;transactionCoordinator()-&gt;acquireLock(*this);
229 }
230 
231 void SQLTransaction::openTransactionAndPreflight()
232 {
233     ASSERT(!m_database-&gt;sqliteDatabase().transactionInProgress());
234     ASSERT(m_lockAcquired);
235 
236     LOG(StorageAPI, &quot;Opening and preflighting transaction %p&quot;, this);
237 
238     // If the database was deleted, jump to the error callback
239     if (m_database-&gt;deleted()) {
240         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;unable to open a transaction, because the user deleted the database&quot;);
241 
242         handleTransactionError();
243         return;
244     }
245 
246     // Set the maximum usage for this transaction if this transactions is not read-only
247     if (!m_readOnly) {
248         acquireOriginLock();
249         m_database-&gt;sqliteDatabase().setMaximumSize(m_database-&gt;maximumSize());
250     }
251 
252     ASSERT(!m_sqliteTransaction);
253     m_sqliteTransaction = makeUnique&lt;SQLiteTransaction&gt;(m_database-&gt;sqliteDatabase(), m_readOnly);
254 
255     m_database-&gt;resetDeletes();
256     m_database-&gt;disableAuthorizer();
257     m_sqliteTransaction-&gt;begin();
258     m_database-&gt;enableAuthorizer();
259 
260     // Spec 4.3.2.1+2: Open a transaction to the database, jumping to the error callback if that fails
261     if (!m_sqliteTransaction-&gt;inProgress()) {
262         ASSERT(!m_database-&gt;sqliteDatabase().transactionInProgress());
263         m_transactionError = SQLError::create(SQLError::DATABASE_ERR, &quot;unable to begin transaction&quot;, m_database-&gt;sqliteDatabase().lastError(), m_database-&gt;sqliteDatabase().lastErrorMsg());
264         m_sqliteTransaction = nullptr;
265 
266         handleTransactionError();
267         return;
268     }
269 
270     // Note: We intentionally retrieve the actual version even with an empty expected version.
271     // In multi-process browsers, we take this opportinutiy to update the cached value for
272     // the actual version. In single-process browsers, this is just a map lookup.
273     String actualVersion;
274     if (!m_database-&gt;getActualVersionForTransaction(actualVersion)) {
275         m_transactionError = SQLError::create(SQLError::DATABASE_ERR, &quot;unable to read version&quot;, m_database-&gt;sqliteDatabase().lastError(), m_database-&gt;sqliteDatabase().lastErrorMsg());
276         m_database-&gt;disableAuthorizer();
277         m_sqliteTransaction = nullptr;
278         m_database-&gt;enableAuthorizer();
279 
280         handleTransactionError();
281         return;
282     }
283 
284     auto expectedVersion = m_database-&gt;expectedVersionIsolatedCopy();
285     m_hasVersionMismatch = !expectedVersion.isEmpty() &amp;&amp; expectedVersion != actualVersion;
286 
287     // Spec 4.3.2.3: Perform preflight steps, jumping to the error callback if they fail
288     if (m_wrapper &amp;&amp; !m_wrapper-&gt;performPreflight(*this)) {
289         m_database-&gt;disableAuthorizer();
290         m_sqliteTransaction = nullptr;
291         m_database-&gt;enableAuthorizer();
292         m_transactionError = m_wrapper-&gt;sqlError();
293         if (!m_transactionError)
294             m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;unknown error occurred during transaction preflight&quot;);
295 
296         handleTransactionError();
297         return;
298     }
299 
300     // Spec 4.3.2.4: Invoke the transaction callback with the new SQLTransaction object
301     if (m_callbackWrapper.hasCallback()) {
302         scheduleCallback(&amp;SQLTransaction::deliverTransactionCallback);
303         return;
304     }
305 
306     // If we have no callback to make, skip pass to the state after:
307     runStatements();
308 }
309 
310 void SQLTransaction::runStatements()
311 {
312     ASSERT(m_lockAcquired);
313 
314     // If there is a series of statements queued up that are all successful and have no associated
315     // SQLStatementCallback objects, then we can burn through the queue
316     do {
317         if (m_shouldRetryCurrentStatement &amp;&amp; !m_sqliteTransaction-&gt;wasRolledBackBySqlite()) {
318             m_shouldRetryCurrentStatement = false;
319             // FIXME - Another place that needs fixing up after &lt;rdar://problem/5628468&gt; is addressed.
320             // See ::openTransactionAndPreflight() for discussion
321 
322             // Reset the maximum size here, as it was increased to allow us to retry this statement.
323             // m_shouldRetryCurrentStatement is set to true only when a statement exceeds
324             // the quota, which can happen only in a read-write transaction. Therefore, there
325             // is no need to check here if the transaction is read-write.
326             m_database-&gt;sqliteDatabase().setMaximumSize(m_database-&gt;maximumSize());
327         } else {
328             // If the current statement has already been run, failed due to quota constraints, and we&#39;re not retrying it,
329             // that means it ended in an error. Handle it now
330             if (m_currentStatement &amp;&amp; m_currentStatement-&gt;lastExecutionFailedDueToQuota()) {
331                 handleCurrentStatementError();
332                 break;
333             }
334 
335             // Otherwise, advance to the next statement
336             getNextStatement();
337         }
338     } while (runCurrentStatement());
339 
340     // If runCurrentStatement() returned false, that means either there was no current statement to run,
341     // or the current statement requires a callback to complete. In the later case, it also scheduled
342     // the callback or performed any other additional work so we can return.
343     if (!m_currentStatement)
344         postflightAndCommit();
345 }
346 
347 void SQLTransaction::cleanupAndTerminate()
348 {
349     ASSERT(m_lockAcquired);
350 
351     // Spec 4.3.2.9: End transaction steps. There is no next step.
352     LOG(StorageAPI, &quot;Transaction %p is complete\n&quot;, this);
353     ASSERT(!m_database-&gt;sqliteDatabase().transactionInProgress());
354 
355     // Phase 5 cleanup. See comment on the SQLTransaction life-cycle above.
356     m_backend.doCleanup();
357     m_database-&gt;inProgressTransactionCompleted();
358 }
359 
360 void SQLTransaction::cleanupAfterTransactionErrorCallback()
361 {
362     ASSERT(m_lockAcquired);
363 
364     LOG(StorageAPI, &quot;Transaction %p is complete with an error\n&quot;, this);
365     m_database-&gt;disableAuthorizer();
366     if (m_sqliteTransaction) {
367         // Spec 4.3.2.10: Rollback the transaction.
368         m_sqliteTransaction-&gt;rollback();
369 
370         ASSERT(!m_database-&gt;sqliteDatabase().transactionInProgress());
371         m_sqliteTransaction = nullptr;
372     }
373     m_database-&gt;enableAuthorizer();
374 
375     releaseOriginLockIfNeeded();
376 
377     ASSERT(!m_database-&gt;sqliteDatabase().transactionInProgress());
378 
379     cleanupAndTerminate();
380 }
381 
382 void SQLTransaction::deliverTransactionCallback()
383 {
384     bool shouldDeliverErrorCallback = false;
385 
386     // Spec 4.3.2 4: Invoke the transaction callback with the new SQLTransaction object
387     RefPtr&lt;SQLTransactionCallback&gt; callback = m_callbackWrapper.unwrap();
388     if (callback) {
389         m_executeSqlAllowed = true;
390 
391         auto result = callback-&gt;handleEvent(*this);
392         shouldDeliverErrorCallback = result.type() == CallbackResultType::ExceptionThrown;
393 
394         m_executeSqlAllowed = false;
395     }
396 
397     // Spec 4.3.2 5: If the transaction callback was null or raised an exception, jump to the error callback
398     if (shouldDeliverErrorCallback) {
399         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;the SQLTransactionCallback was null or threw an exception&quot;);
400         return deliverTransactionErrorCallback();
401     }
402 
403     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
404 }
405 
406 void SQLTransaction::deliverTransactionErrorCallback()
407 {
408     ASSERT(m_transactionError);
409 
410     // Spec 4.3.2.10: If exists, invoke error callback with the last
411     // error to have occurred in this transaction.
412     RefPtr&lt;SQLTransactionErrorCallback&gt; errorCallback = m_errorCallbackWrapper.unwrap();
<a name="5" id="anc5"></a><span class="line-modified">413     if (errorCallback) {</span>
<span class="line-modified">414         m_database-&gt;document().eventLoop().queueTask(TaskSource::Networking, [errorCallback = WTFMove(errorCallback), transactionError = m_transactionError]() mutable {</span>
<span class="line-added">415             errorCallback-&gt;handleEvent(*transactionError);</span>
<span class="line-added">416         });</span>
<span class="line-added">417     }</span>
418 
419     clearCallbackWrappers();
420 
421     // Spec 4.3.2.10: Rollback the transaction.
422     m_backend.requestTransitToState(SQLTransactionState::CleanupAfterTransactionErrorCallback);
423 }
424 
425 void SQLTransaction::deliverStatementCallback()
426 {
427     ASSERT(m_currentStatement);
428 
429     // Spec 4.3.2.6.6 and 4.3.2.6.3: If the statement callback went wrong, jump to the transaction error callback
430     // Otherwise, continue to loop through the statement queue
431     m_executeSqlAllowed = true;
432     bool result = m_currentStatement-&gt;performCallback(*this);
433     m_executeSqlAllowed = false;
434 
435     if (result) {
436         m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;the statement callback raised an exception or statement error callback did not return false&quot;);
437 
438         if (m_errorCallbackWrapper.hasCallback())
439             return deliverTransactionErrorCallback();
440 
441         // No error callback, so fast-forward to:
442         // Transaction Step 11 - Rollback the transaction.
443         m_backend.requestTransitToState(SQLTransactionState::CleanupAfterTransactionErrorCallback);
444         return;
445     }
446 
447     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
448 }
449 
450 void SQLTransaction::deliverQuotaIncreaseCallback()
451 {
452     ASSERT(m_currentStatement);
453     ASSERT(!m_shouldRetryCurrentStatement);
454 
455     m_shouldRetryCurrentStatement = m_database-&gt;didExceedQuota();
456 
457     m_backend.requestTransitToState(SQLTransactionState::RunStatements);
458 }
459 
460 void SQLTransaction::deliverSuccessCallback()
461 {
462     // Spec 4.3.2.8: Deliver success callback.
463     RefPtr&lt;VoidCallback&gt; successCallback = m_successCallbackWrapper.unwrap();
<a name="6" id="anc6"></a><span class="line-modified">464     if (successCallback) {</span>
<span class="line-modified">465         m_database-&gt;document().eventLoop().queueTask(TaskSource::Networking, [successCallback = WTFMove(successCallback)]() mutable {</span>
<span class="line-added">466             successCallback-&gt;handleEvent();</span>
<span class="line-added">467         });</span>
<span class="line-added">468     }</span>
469 
470     clearCallbackWrappers();
471 
472     // Schedule a &quot;post-success callback&quot; step to return control to the database thread in case there
473     // are further transactions queued up for this Database
474     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
475 }
476 
477 // This state function is used as a stub function to plug unimplemented states
478 // in the state dispatch table. They are unimplemented because they should
479 // never be reached in the course of correct execution.
480 void SQLTransaction::unreachableState()
481 {
482     ASSERT_NOT_REACHED();
483 }
484 
485 void SQLTransaction::computeNextStateAndCleanupIfNeeded()
486 {
487     // Only honor the requested state transition if we&#39;re not supposed to be
488     // cleaning up and shutting down:
489     if (m_database-&gt;opened()) {
490         setStateToRequestedState();
491         ASSERT(m_nextState == SQLTransactionState::End
492             || m_nextState == SQLTransactionState::DeliverTransactionCallback
493             || m_nextState == SQLTransactionState::DeliverTransactionErrorCallback
494             || m_nextState == SQLTransactionState::DeliverStatementCallback
495             || m_nextState == SQLTransactionState::DeliverQuotaIncreaseCallback
496             || m_nextState == SQLTransactionState::DeliverSuccessCallback);
497 
498         LOG(StorageAPI, &quot;Callback %s\n&quot;, nameForSQLTransactionState(m_nextState));
499         return;
<a name="7" id="anc7"></a><span class="line-modified">500     } else</span>
<span class="line-added">501         callErrorCallbackDueToInterruption();</span>
502 
503     clearCallbackWrappers();
504     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
505 }
506 
507 void SQLTransaction::clearCallbackWrappers()
508 {
509     // Release the unneeded callbacks, to break reference cycles.
510     m_callbackWrapper.clear();
511     m_successCallbackWrapper.clear();
512     m_errorCallbackWrapper.clear();
513 }
514 
515 void SQLTransaction::getNextStatement()
516 {
517     m_currentStatement = nullptr;
518 
519     LockHolder locker(m_statementMutex);
520     if (!m_statementQueue.isEmpty())
521         m_currentStatement = m_statementQueue.takeFirst();
522 }
523 
524 bool SQLTransaction::runCurrentStatement()
525 {
526     if (!m_currentStatement) {
527         // No more statements to run. So move on to the next state.
528         return false;
529     }
530 
531     m_database-&gt;resetAuthorizer();
532 
533     if (m_hasVersionMismatch)
534         m_currentStatement-&gt;setVersionMismatchedError();
535 
536     if (m_currentStatement-&gt;execute(m_database)) {
537         if (m_database-&gt;lastActionChangedDatabase()) {
538             // Flag this transaction as having changed the database for later delegate notification
539             m_modifiedDatabase = true;
540         }
541 
542         if (m_currentStatement-&gt;hasStatementCallback()) {
543             scheduleCallback(&amp;SQLTransaction::deliverStatementCallback);
544             return false;
545         }
546 
547         // If we get here, then the statement doesn&#39;t have a callback to invoke.
548         // We can move on to the next statement. Hence, stay in this state.
549         return true;
550     }
551 
552     if (m_currentStatement-&gt;lastExecutionFailedDueToQuota()) {
553         scheduleCallback(&amp;SQLTransaction::deliverQuotaIncreaseCallback);
554         return false;
555     }
556 
557     handleCurrentStatementError();
558     return false;
559 }
560 
561 void SQLTransaction::handleCurrentStatementError()
562 {
563     // Spec 4.3.2.6.6: error - Call the statement&#39;s error callback, but if there was no error callback,
564     // or the transaction was rolled back, jump to the transaction error callback
565     if (m_currentStatement-&gt;hasStatementErrorCallback() &amp;&amp; !m_sqliteTransaction-&gt;wasRolledBackBySqlite()) {
566         scheduleCallback(&amp;SQLTransaction::deliverStatementCallback);
567         return;
568     }
569 
570     m_transactionError = m_currentStatement-&gt;sqlError();
571     if (!m_transactionError)
572         m_transactionError = SQLError::create(SQLError::DATABASE_ERR, &quot;the statement failed to execute&quot;);
573 
574     handleTransactionError();
575 }
576 
577 void SQLTransaction::handleTransactionError()
578 {
579     ASSERT(m_transactionError);
580     if (m_errorCallbackWrapper.hasCallback()) {
581         scheduleCallback(&amp;SQLTransaction::deliverTransactionErrorCallback);
582         return;
583     }
584 
585     // No error callback, so fast-forward to the next state and rollback the
586     // transaction.
587     m_backend.cleanupAfterTransactionErrorCallback();
588 }
589 
590 void SQLTransaction::postflightAndCommit()
591 {
592     ASSERT(m_lockAcquired);
593 
594     // Spec 4.3.2.7: Perform postflight steps, jumping to the error callback if they fail.
595     if (m_wrapper &amp;&amp; !m_wrapper-&gt;performPostflight(*this)) {
596         m_transactionError = m_wrapper-&gt;sqlError();
597         if (!m_transactionError)
598             m_transactionError = SQLError::create(SQLError::UNKNOWN_ERR, &quot;unknown error occurred during transaction postflight&quot;);
599 
600         handleTransactionError();
601         return;
602     }
603 
604     // Spec 4.3.2.7: Commit the transaction, jumping to the error callback if that fails.
605     ASSERT(m_sqliteTransaction);
606 
607     m_database-&gt;disableAuthorizer();
608     m_sqliteTransaction-&gt;commit();
609     m_database-&gt;enableAuthorizer();
610 
611     releaseOriginLockIfNeeded();
612 
613     // If the commit failed, the transaction will still be marked as &quot;in progress&quot;
614     if (m_sqliteTransaction-&gt;inProgress()) {
615         if (m_wrapper)
616             m_wrapper-&gt;handleCommitFailedAfterPostflight(*this);
617         m_transactionError = SQLError::create(SQLError::DATABASE_ERR, &quot;unable to commit transaction&quot;, m_database-&gt;sqliteDatabase().lastError(), m_database-&gt;sqliteDatabase().lastErrorMsg());
618 
619         handleTransactionError();
620         return;
621     }
622 
623     // Vacuum the database if anything was deleted.
624     if (m_database-&gt;hadDeletes())
625         m_database-&gt;incrementalVacuumIfNeeded();
626 
627     // The commit was successful. If the transaction modified this database, notify the delegates.
628     if (m_modifiedDatabase)
629         m_database-&gt;didCommitWriteTransaction();
630 
631     // Spec 4.3.2.8: Deliver success callback, if there is one.
632     scheduleCallback(&amp;SQLTransaction::deliverSuccessCallback);
633 }
634 
635 void SQLTransaction::acquireOriginLock()
636 {
637     ASSERT(!m_originLock);
638     m_originLock = DatabaseTracker::singleton().originLockFor(m_database-&gt;securityOrigin());
639     m_originLock-&gt;lock();
640 }
641 
642 void SQLTransaction::releaseOriginLockIfNeeded()
643 {
644     if (m_originLock) {
645         m_originLock-&gt;unlock();
646         m_originLock = nullptr;
647     }
648 }
649 
650 #if !LOG_DISABLED
651 const char* SQLTransaction::debugStepName(void (SQLTransaction::*step)())
652 {
653     if (step == &amp;SQLTransaction::acquireLock)
654         return &quot;acquireLock&quot;;
655     if (step == &amp;SQLTransaction::openTransactionAndPreflight)
656         return &quot;openTransactionAndPreflight&quot;;
657     if (step == &amp;SQLTransaction::runStatements)
658         return &quot;runStatements&quot;;
659     if (step == &amp;SQLTransaction::postflightAndCommit)
660         return &quot;postflightAndCommit&quot;;
661     if (step == &amp;SQLTransaction::cleanupAfterTransactionErrorCallback)
662         return &quot;cleanupAfterTransactionErrorCallback&quot;;
663     if (step == &amp;SQLTransaction::deliverTransactionCallback)
664         return &quot;deliverTransactionCallback&quot;;
665     if (step == &amp;SQLTransaction::deliverTransactionErrorCallback)
666         return &quot;deliverTransactionErrorCallback&quot;;
667     if (step == &amp;SQLTransaction::deliverStatementCallback)
668         return &quot;deliverStatementCallback&quot;;
669     if (step == &amp;SQLTransaction::deliverQuotaIncreaseCallback)
670         return &quot;deliverQuotaIncreaseCallback&quot;;
671     if (step == &amp;SQLTransaction::deliverSuccessCallback)
672         return &quot;deliverSuccessCallback&quot;;
673 
674     ASSERT_NOT_REACHED();
675     return &quot;UNKNOWN&quot;;
676 }
677 #endif
678 
679 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
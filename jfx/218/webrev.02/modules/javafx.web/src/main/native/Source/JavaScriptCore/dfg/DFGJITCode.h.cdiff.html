<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGJITCode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCompiler.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 52,22 ***</span>
      virtual ~JITCode();
  
      CommonData* dfgCommon() override;
      JITCode* dfg() override;
  
<span class="line-modified">!     OSREntryData* appendOSREntryData(unsigned bytecodeIndex, CodeLocationLabel&lt;OSREntryPtrTag&gt; machineCode)</span>
      {
          DFG::OSREntryData entry;
          entry.m_bytecodeIndex = bytecodeIndex;
          entry.m_machineCode = machineCode;
          osrEntry.append(entry);
          return &amp;osrEntry.last();
      }
  
<span class="line-modified">!     OSREntryData* osrEntryDataForBytecodeIndex(unsigned bytecodeIndex)</span>
      {
<span class="line-modified">!         return tryBinarySearch&lt;OSREntryData, unsigned&gt;(</span>
              osrEntry, osrEntry.size(), bytecodeIndex,
              getOSREntryDataBytecodeIndex);
      }
  
      void finalizeOSREntrypoints();
<span class="line-new-header">--- 52,22 ---</span>
      virtual ~JITCode();
  
      CommonData* dfgCommon() override;
      JITCode* dfg() override;
  
<span class="line-modified">!     OSREntryData* appendOSREntryData(BytecodeIndex bytecodeIndex, CodeLocationLabel&lt;OSREntryPtrTag&gt; machineCode)</span>
      {
          DFG::OSREntryData entry;
          entry.m_bytecodeIndex = bytecodeIndex;
          entry.m_machineCode = machineCode;
          osrEntry.append(entry);
          return &amp;osrEntry.last();
      }
  
<span class="line-modified">!     OSREntryData* osrEntryDataForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
      {
<span class="line-modified">!         return tryBinarySearch&lt;OSREntryData, BytecodeIndex&gt;(</span>
              osrEntry, osrEntry.size(), bytecodeIndex,
              getOSREntryDataBytecodeIndex);
      }
  
      void finalizeOSREntrypoints();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,11 ***</span>
  
      // This is only applicable if we&#39;re at a point where all values are spilled to the
      // stack. Currently, it also has the restriction that the values must be in their
      // bytecode-designated stack slots.
      void reconstruct(
<span class="line-modified">!         ExecState*, CodeBlock*, CodeOrigin, unsigned streamIndex, Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; result);</span>
  
  #if ENABLE(FTL_JIT)
      // NB. All of these methods take CodeBlock* because they may want to use
      // CodeBlock&#39;s logic about scaling thresholds. It should be a DFG CodeBlock.
  
<span class="line-new-header">--- 96,11 ---</span>
  
      // This is only applicable if we&#39;re at a point where all values are spilled to the
      // stack. Currently, it also has the restriction that the values must be in their
      // bytecode-designated stack slots.
      void reconstruct(
<span class="line-modified">!         CallFrame*, CodeBlock*, CodeOrigin, unsigned streamIndex, Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; result);</span>
  
  #if ENABLE(FTL_JIT)
      // NB. All of these methods take CodeBlock* because they may want to use
      // CodeBlock&#39;s logic about scaling thresholds. It should be a DFG CodeBlock.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,11 ***</span>
      void setOptimizationThresholdBasedOnCompilationResult(CodeBlock*, CompilationResult);
  #endif // ENABLE(FTL_JIT)
  
      void validateReferences(const TrackedReferences&amp;) override;
  
<span class="line-modified">!     void shrinkToFit();</span>
  
      RegisterSet liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock*, CallSiteIndex) override;
  #if ENABLE(FTL_JIT)
      CodeBlock* osrEntryBlock() { return m_osrEntryBlock.get(); }
      void setOSREntryBlock(VM&amp;, const JSCell* owner, CodeBlock* osrEntryBlock);
<span class="line-new-header">--- 113,11 ---</span>
      void setOptimizationThresholdBasedOnCompilationResult(CodeBlock*, CompilationResult);
  #endif // ENABLE(FTL_JIT)
  
      void validateReferences(const TrackedReferences&amp;) override;
  
<span class="line-modified">!     void shrinkToFit(const ConcurrentJSLocker&amp;) override;</span>
  
      RegisterSet liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock*, CallSiteIndex) override;
  #if ENABLE(FTL_JIT)
      CodeBlock* osrEntryBlock() { return m_osrEntryBlock.get(); }
      void setOSREntryBlock(VM&amp;, const JSCell* owner, CodeBlock* osrEntryBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,25 ***</span>
      // For osrEntryPoint that are in inner loop, this maps their bytecode to the bytecode
      // of the outerloop entry points in order (from innermost to outermost).
      //
      // The key may not always be a target for OSR Entry but the list in the value is guaranteed
      // to be usable for OSR Entry.
<span class="line-modified">!     HashMap&lt;unsigned, Vector&lt;unsigned&gt;&gt; tierUpInLoopHierarchy;</span>
  
      // Map each bytecode of CheckTierUpAndOSREnter to its stream index.
<span class="line-modified">!     HashMap&lt;unsigned, unsigned, WTF::IntHash&lt;unsigned&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; bytecodeIndexToStreamIndex;</span>
  
      enum class TriggerReason : uint8_t {
          DontTrigger,
          CompilationDone,
          StartCompilation,
      };
  
      // Map each bytecode of CheckTierUpAndOSREnter to its trigger forcing OSR Entry.
      // This can never be modified after it has been initialized since the addresses of the triggers
      // are used by the JIT.
<span class="line-modified">!     HashMap&lt;unsigned, TriggerReason&gt; tierUpEntryTriggers;</span>
  
      WriteBarrier&lt;CodeBlock&gt; m_osrEntryBlock;
      unsigned osrEntryRetry;
      bool abandonOSREntry;
  #endif // ENABLE(FTL_JIT)
<span class="line-new-header">--- 149,25 ---</span>
      // For osrEntryPoint that are in inner loop, this maps their bytecode to the bytecode
      // of the outerloop entry points in order (from innermost to outermost).
      //
      // The key may not always be a target for OSR Entry but the list in the value is guaranteed
      // to be usable for OSR Entry.
<span class="line-modified">!     HashMap&lt;BytecodeIndex, Vector&lt;BytecodeIndex&gt;&gt; tierUpInLoopHierarchy;</span>
  
      // Map each bytecode of CheckTierUpAndOSREnter to its stream index.
<span class="line-modified">!     HashMap&lt;BytecodeIndex, unsigned&gt; bytecodeIndexToStreamIndex;</span>
  
      enum class TriggerReason : uint8_t {
          DontTrigger,
          CompilationDone,
          StartCompilation,
      };
  
      // Map each bytecode of CheckTierUpAndOSREnter to its trigger forcing OSR Entry.
      // This can never be modified after it has been initialized since the addresses of the triggers
      // are used by the JIT.
<span class="line-modified">!     HashMap&lt;BytecodeIndex, TriggerReason&gt; tierUpEntryTriggers;</span>
  
      WriteBarrier&lt;CodeBlock&gt; m_osrEntryBlock;
      unsigned osrEntryRetry;
      bool abandonOSREntry;
  #endif // ENABLE(FTL_JIT)
</pre>
<center><a href="DFGJITCode.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCompiler.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
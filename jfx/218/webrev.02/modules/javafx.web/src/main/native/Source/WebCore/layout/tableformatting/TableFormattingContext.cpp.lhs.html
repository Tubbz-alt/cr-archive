<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<a name="1" id="anc1"></a>

 31 #include &quot;LayoutBox.h&quot;
<a name="2" id="anc2"></a>

 32 #include &quot;TableFormattingState.h&quot;
 33 #include &lt;wtf/IsoMallocInlines.h&gt;
 34 
 35 namespace WebCore {
 36 namespace Layout {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
 39 
<a name="3" id="anc3"></a>












 40 // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
<a name="4" id="anc4"></a><span class="line-modified"> 41 TableFormattingContext::TableFormattingContext(const Box&amp; formattingContextRoot, TableFormattingState&amp; formattingState)</span>
 42     : FormattingContext(formattingContextRoot, formattingState)
 43 {
 44 }
 45 
<a name="5" id="anc5"></a><span class="line-modified"> 46 void TableFormattingContext::layout() const</span>
 47 {
 48     auto&amp; grid = formattingState().tableGrid();
<a name="6" id="anc6"></a>













 49     auto&amp; cellList = grid.cells();
 50     ASSERT(!cellList.isEmpty());
<a name="7" id="anc7"></a><span class="line-removed"> 51     // Layout and position each table cell (and compute row height as well).</span>
<span class="line-removed"> 52     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-removed"> 53     auto&amp; columnList = grid.columnsContext().columns();</span>
<span class="line-removed"> 54     auto&amp; rowList = grid.rows();</span>
 55     for (auto&amp; cell : cellList) {
 56         auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
<a name="8" id="anc8"></a><span class="line-modified"> 57         ASSERT(cellLayoutBox.establishesBlockFormattingContext());</span>
<span class="line-modified"> 58 </span>
<span class="line-modified"> 59         auto&amp; cellDisplayBox = layoutState.displayBoxForLayoutBox(cellLayoutBox);</span>
<span class="line-modified"> 60         // FIXME: Add support for column and row spanning.</span>
<span class="line-modified"> 61         auto cellPosition = cell-&gt;position;</span>
<span class="line-modified"> 62         auto&amp; row = rowList.at(cellPosition.y());</span>
<span class="line-modified"> 63         auto&amp; column = columnList.at(cellPosition.x());</span>
<span class="line-modified"> 64         cellDisplayBox.setContentBoxWidth(column.logicalWidth());</span>
<span class="line-modified"> 65         // FIXME: Do not use blanks.</span>
<span class="line-modified"> 66         cellDisplayBox.setBorder({ });</span>
<span class="line-modified"> 67         cellDisplayBox.setPadding({ });</span>
<span class="line-modified"> 68         cellDisplayBox.setHorizontalMargin({ });</span>
<span class="line-modified"> 69         cellDisplayBox.setHorizontalComputedMargin({ });</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71         cellDisplayBox.setTopLeft({ column.logicalLeft(), row.logicalTop() });</span>
<span class="line-modified"> 72 </span>
<span class="line-modified"> 73         layoutState.createFormattingContext(cellLayoutBox)-&gt;layout();</span>
<span class="line-modified"> 74 </span>
<span class="line-modified"> 75         // FIXME: This requires a 2 pass layout.</span>
<span class="line-modified"> 76         auto heightAndMargin = Geometry::tableCellHeightAndMargin(layoutState, cellLayoutBox);</span>
<span class="line-modified"> 77         cellDisplayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified"> 78         cellDisplayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>
<span class="line-modified"> 79 </span>
<span class="line-modified"> 80         row.setLogicalHeight(std::max(row.logicalHeight(), heightAndMargin.height));</span>
<span class="line-modified"> 81         // FIXME: This also requires spanning support/check.</span>
<span class="line-modified"> 82         if (!cellPosition.x() &amp;&amp; cellPosition.y()) {</span>
<span class="line-modified"> 83             auto&amp; previousRow = rowList.at(cellPosition.y() - 1);</span>
<span class="line-modified"> 84             row.setLogicalTop(previousRow.logicalBottom());</span>
<span class="line-modified"> 85         }</span>

















 86     }
 87 }
 88 
<a name="9" id="anc9"></a><span class="line-modified"> 89 FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints() const</span>





























 90 {
 91     // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
 92     // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
 93     // can actually be streched way over.
<a name="10" id="anc10"></a><span class="line-modified"> 94 </span>
<span class="line-modified"> 95     // 1. Ensure each cell slot is occupied by at least one cell.</span>
<span class="line-modified"> 96     ensureTableGrid();</span>
<span class="line-modified"> 97     // 2. Compute the minimum width of each column.</span>
<span class="line-modified"> 98     computePreferredWidthForColumns();</span>
<span class="line-modified"> 99     // 3. Compute the width of the table.</span>
<span class="line-modified">100     auto width = computedTableWidth();</span>
<span class="line-modified">101     // This is the actual computed table width that we want to present as min/max width.</span>
<span class="line-removed">102     return { width, width };</span>
103 }
104 
<a name="11" id="anc11"></a><span class="line-modified">105 void TableFormattingContext::ensureTableGrid() const</span>
106 {
<a name="12" id="anc12"></a><span class="line-modified">107     auto&amp; tableWrapperBox = downcast&lt;Container&gt;(root());</span>
108     auto&amp; tableGrid = formattingState().tableGrid();
<a name="13" id="anc13"></a>

























109 
<a name="14" id="anc14"></a><span class="line-modified">110     for (auto* section = tableWrapperBox.firstChild(); section; section = section-&gt;nextSibling()) {</span>

111         ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
112         for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
113             ASSERT(row-&gt;isTableRow());
114             for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
115                 ASSERT(cell-&gt;isTableCell());
116                 tableGrid.appendCell(*cell);
117             }
118         }
119     }
120 }
121 
<a name="15" id="anc15"></a><span class="line-modified">122 void TableFormattingContext::computePreferredWidthForColumns() const</span>
123 {
124     auto&amp; formattingState = this-&gt;formattingState();
125     auto&amp; grid = formattingState.tableGrid();
<a name="16" id="anc16"></a>
126 
127     // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
128     //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
129     //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
130     for (auto&amp; cell : grid.cells()) {
<a name="17" id="anc17"></a><span class="line-modified">131         ASSERT(cell-&gt;tableCellBox.establishesFormattingContext());</span>

132 
<a name="18" id="anc18"></a><span class="line-modified">133         auto intrinsicWidth = layoutState().createFormattingContext(cell-&gt;tableCellBox)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">134         intrinsicWidth = Geometry::constrainByMinMaxWidth(cell-&gt;tableCellBox, intrinsicWidth);</span>
<span class="line-modified">135         formattingState.setIntrinsicWidthConstraints(intrinsicWidth);</span>









136 
137         auto columnSpan = cell-&gt;size.width();
<a name="19" id="anc19"></a><span class="line-modified">138         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth.minimum / columnSpan, intrinsicWidth.maximum / columnSpan };</span>
139         auto initialPosition = cell-&gt;position;
140         for (auto i = 0; i &lt; columnSpan; ++i)
141             grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
142     }
143     // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
144     //    The minimum is that required by the cell with the largest minimum cell width (or the column &#39;width&#39;, whichever is larger).
145     //    The maximum is that required by the cell with the largest maximum cell width (or the column &#39;width&#39;, whichever is larger).
146     auto&amp; columns = grid.columnsContext().columns();
147     int numberOfRows = grid.rows().size();
148     int numberOfColumns = columns.size();
149     for (int columnIndex = 0; columnIndex &lt; numberOfColumns; ++columnIndex) {
150         auto columnIntrinsicWidths = FormattingContext::IntrinsicWidthConstraints { };
151         for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
152             auto* slot = grid.slot({ columnIndex, rowIndex });
153             columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
154             columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
155         }
<a name="20" id="anc20"></a>






156         columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
157     }
<a name="21" id="anc21"></a><span class="line-removed">158     // FIXME: Take column group elements into account.</span>
159 }
160 
<a name="22" id="anc22"></a><span class="line-modified">161 LayoutUnit TableFormattingContext::computedTableWidth() const</span>
162 {
<a name="23" id="anc23"></a>



163     // Column and caption widths influence the final table width as follows:
164     // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
165     // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
166     // If the used width is greater than MIN, the extra width should be distributed over the columns.
167     // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
168     // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
169     // less than that of the containing block, use max(MAX, CAPMIN).
<a name="24" id="anc24"></a>


170 
<a name="25" id="anc25"></a><span class="line-modified">171     // FIXME: This kind of code usually lives in *FormattingContextGeometry class.</span>
<span class="line-modified">172     auto&amp; tableWrapperBox = root();</span>
<span class="line-modified">173     auto&amp; style = tableWrapperBox.style();</span>
<span class="line-modified">174     auto&amp; containingBlock = *tableWrapperBox.containingBlock();</span>
<span class="line-modified">175     auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(containingBlock);</span>
<span class="line-modified">176     auto containingBlockWidth = containingBlockDisplayBox.contentBoxWidth();</span>



177 
<a name="26" id="anc26"></a><span class="line-modified">178     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-modified">179     auto&amp; columnsContext = grid.columnsContext();</span>
<span class="line-removed">180     auto tableWidthConstraints = grid.widthConstraints();</span>
<span class="line-removed">181 </span>
<span class="line-removed">182     auto width = Geometry::computedValueIfNotAuto(style.width(), containingBlockWidth);</span>
<span class="line-removed">183     LayoutUnit usedWidth;</span>
<span class="line-removed">184     if (width) {</span>
<span class="line-removed">185         if (*width &gt; tableWidthConstraints.minimum) {</span>
<span class="line-removed">186             distributeAvailableWidth(*width - tableWidthConstraints.minimum);</span>
<span class="line-removed">187             usedWidth = *width;</span>
<span class="line-removed">188         } else {</span>
<span class="line-removed">189             usedWidth = tableWidthConstraints.minimum;</span>
<span class="line-removed">190             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Minimum);</span>
191         }
<a name="27" id="anc27"></a><span class="line-modified">192     } else {</span>
<span class="line-modified">193         if (tableWidthConstraints.minimum &gt; containingBlockWidth) {</span>
<span class="line-modified">194             usedWidth = tableWidthConstraints.minimum;</span>
<span class="line-modified">195             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Minimum);</span>
<span class="line-modified">196         } else if (tableWidthConstraints.maximum &lt; containingBlockWidth) {</span>
<span class="line-modified">197             usedWidth = tableWidthConstraints.maximum;</span>
<span class="line-modified">198             columnsContext.useAsLogicalWidth(TableGrid::ColumnsContext::WidthConstraintsType::Maximum);</span>
<span class="line-modified">199         } else {</span>
<span class="line-modified">200             usedWidth = containingBlockWidth;</span>
<span class="line-removed">201             distributeAvailableWidth(*width - tableWidthConstraints.minimum);</span>
202         }
<a name="28" id="anc28"></a>
















203     }
<a name="29" id="anc29"></a><span class="line-removed">204     // FIXME: This should also deal with collapsing borders etc.</span>
<span class="line-removed">205     LayoutUnit columnLogicalLeft;</span>
<span class="line-removed">206     auto&amp; columns = columnsContext.columns();</span>
<span class="line-removed">207     for (auto&amp; column : columns) {</span>
<span class="line-removed">208         column.setLogicalLeft(columnLogicalLeft);</span>
<span class="line-removed">209         columnLogicalLeft += column.logicalWidth();</span>
<span class="line-removed">210     }</span>
<span class="line-removed">211     return usedWidth;</span>
212 }
213 
<a name="30" id="anc30"></a><span class="line-modified">214 void TableFormattingContext::distributeAvailableWidth(LayoutUnit extraHorizontalSpace) const</span>
215 {
<a name="31" id="anc31"></a><span class="line-removed">216     // FIXME: Right now just distribute the extra space equaly among the columns.</span>
217     auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
218     ASSERT(!columns.isEmpty());
219 
<a name="32" id="anc32"></a><span class="line-removed">220     auto columnExtraSpace = extraHorizontalSpace / columns.size();</span>
221     for (auto&amp; column : columns)
<a name="33" id="anc33"></a><span class="line-modified">222         column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);</span>
223 }
224 
225 }
226 }
227 
228 #endif
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>
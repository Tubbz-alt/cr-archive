<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/URL.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Forward.h&gt;
 29 #include &lt;wtf/RetainPtr.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 #if USE(CF)
 33 typedef const struct __CFURL* CFURLRef;
 34 #endif
 35 
 36 #if USE(FOUNDATION)
 37 OBJC_CLASS NSURL;
 38 #endif
 39 
 40 #if PLATFORM(JAVA)
 41 #include &lt;wtf/java/JavaEnv.h&gt;
 42 #endif
 43 
 44 namespace WTF {
 45 class TextStream;
 46 
 47 class URLTextEncoding {
 48 public:
 49     virtual Vector&lt;uint8_t&gt; encodeForURLParsing(StringView) const = 0;
 50     virtual ~URLTextEncoding() { };
 51 };
 52 
 53 struct URLHash;
 54 
 55 class WTF_EXPORT_PRIVATE URL {
 56     WTF_MAKE_FAST_ALLOCATED;
 57 public:
 58     // Generates a URL which contains a null string.
 59     URL() { invalidate(); }
 60 
 61     explicit URL(WTF::HashTableDeletedValueType) : m_string(WTF::HashTableDeletedValue) { }
 62     bool isHashTableDeletedValue() const { return string().isHashTableDeletedValue(); }
 63 
 64     // Resolves the relative URL with the given base URL. If provided, the
 65     // URLTextEncoding is used to encode non-ASCII characers. The base URL can be
 66     // null or empty, in which case the relative URL will be interpreted as
 67     // absolute.
 68     // FIXME: If the base URL is invalid, this always creates an invalid
 69     // URL. Instead I think it would be better to treat all invalid base URLs
 70     // the same way we treate null and empty base URLs.
 71     URL(const URL&amp; base, const String&amp; relative, const URLTextEncoding* = nullptr);
 72 
 73     static URL fakeURLWithRelativePart(const String&amp;);
 74     static URL fileURLWithFileSystemPath(const String&amp;);
 75 
 76     String strippedForUseAsReferrer() const;
 77 
 78     // FIXME: The above functions should be harmonized so that passing a
 79     // base of null or the empty string gives the same result as the
 80     // standard String constructor.
 81 
 82     // Makes a deep copy. Helpful only if you need to use a URL on another
 83     // thread. Since the underlying StringImpl objects are immutable, there&#39;s
 84     // no other reason to ever prefer isolatedCopy() over plain old assignment.
 85     URL isolatedCopy() const;
 86 
 87     bool isNull() const;
 88     bool isEmpty() const;
 89     bool isValid() const;
 90 
 91     // Returns true if you can set the host and port for the URL.
 92     // Non-hierarchical URLs don&#39;t have a host and port.
 93     bool canSetHostOrPort() const { return isHierarchical(); }
 94 
 95     bool canSetPathname() const { return isHierarchical(); }
 96     bool isHierarchical() const;
 97 
 98     const String&amp; string() const { return m_string; }
 99 
100     String stringCenterEllipsizedToLength(unsigned length = 1024) const;
101 
102     StringView protocol() const;
103     StringView host() const;
104     Optional&lt;uint16_t&gt; port() const;
105     String hostAndPort() const;
106     String protocolHostAndPort() const;
107     String user() const;
108     String pass() const;
109     String path() const;
110     String lastPathComponent() const;
111     String query() const;
112     String fragmentIdentifier() const;
113     bool hasFragmentIdentifier() const;
114 
115     bool hasUsername() const;
116     bool hasPassword() const;
117     bool hasQuery() const;
118     bool hasFragment() const;
119     bool hasPath() const;
120 
121     // Unlike user() and pass(), these functions don&#39;t decode escape sequences.
122     // This is necessary for accurate round-tripping, because encoding doesn&#39;t encode &#39;%&#39; characters.
123     String encodedUser() const;
124     String encodedPass() const;
125 
126     String baseAsString() const;
127 
128     String fileSystemPath() const;
129 
130     // Returns true if the current URL&#39;s protocol is the same as the null-
131     // terminated ASCII argument. The argument must be lower-case.
132     bool protocolIs(const char*) const;
133     bool protocolIs(StringView) const;
134     bool protocolIsBlob() const { return protocolIs(&quot;blob&quot;); }
135     bool protocolIsData() const { return protocolIs(&quot;data&quot;); }
136     bool protocolIsAbout() const;
137     bool protocolIsInHTTPFamily() const;
138     bool isLocalFile() const;
139     bool isBlankURL() const;
140     bool cannotBeABaseURL() const { return m_cannotBeABaseURL; }
141 
142     bool isMatchingDomain(const String&amp;) const;
143 
144     bool setProtocol(const String&amp;);
145     void setHost(const String&amp;);
146 
147     void removePort();
148     void setPort(unsigned short);
149 
150     // Input is like &quot;foo.com&quot; or &quot;foo.com:8000&quot;.
151     void setHostAndPort(const String&amp;);
152 
153     void setUser(const String&amp;);
154     void setPass(const String&amp;);
155 
156     // If you pass an empty path for HTTP or HTTPS URLs, the resulting path
157     // will be &quot;/&quot;.
158     void setPath(const String&amp;);
159 
160     // The query may begin with a question mark, or, if not, one will be added
161     // for you. Setting the query to the empty string will leave a &quot;?&quot; in the
162     // URL (with nothing after it). To clear the query, pass a null string.
163     void setQuery(const String&amp;);
164 
165     void setFragmentIdentifier(StringView);
166     void removeFragmentIdentifier();
167 
168     void removeQueryAndFragmentIdentifier();
169 
170     static bool hostIsIPAddress(StringView);
171 
172     unsigned pathStart() const;
173     unsigned pathEnd() const;
174     unsigned pathAfterLastSlash() const;
175 
176     operator const String&amp;() const { return string(); }
177 
178 #if USE(CF)
179     URL(CFURLRef);
180     RetainPtr&lt;CFURLRef&gt; createCFURL() const;
181 #endif
182 
183 #if USE(FOUNDATION)
184     URL(NSURL*);
185     operator NSURL*() const;
186 #endif
187 #ifdef __OBJC__
188     operator NSString*() const { return string(); }
189 #endif
190 
191 #if PLATFORM(JAVA)
192     URL(JNIEnv* env, jstring url) : URL(URL(), String(env, url)) {}
193 #endif
194 
195 #ifndef NDEBUG
196     void print() const;
197 #endif
198 
199     template &lt;class Encoder&gt; void encode(Encoder&amp;) const;
200     template &lt;class Decoder&gt; static bool decode(Decoder&amp;, URL&amp;);
201     template &lt;class Decoder&gt; static Optional&lt;URL&gt; decode(Decoder&amp;);
202 
203 private:
204     friend class URLParser;
205     void invalidate();
206     static bool protocolIs(const String&amp;, const char*);
207     void copyToBuffer(Vector&lt;char, 512&gt;&amp; buffer) const;
208     unsigned hostStart() const;
209 
210     friend WTF_EXPORT_PRIVATE bool equalIgnoringFragmentIdentifier(const URL&amp;, const URL&amp;);
211     friend WTF_EXPORT_PRIVATE bool protocolHostAndPortAreEqual(const URL&amp;, const URL&amp;);
212     friend WTF_EXPORT_PRIVATE bool hostsAreEqual(const URL&amp;, const URL&amp;);
213 
214     String m_string;
215 
216     unsigned m_isValid : 1;
217     unsigned m_protocolIsInHTTPFamily : 1;
218     unsigned m_cannotBeABaseURL : 1;
219 
220     // This is out of order to align the bits better. The port is after the host.
221     unsigned m_portLength : 3;
222     static constexpr unsigned maxPortLength = (1 &lt;&lt; 3) - 1;
223 
224     static constexpr unsigned maxSchemeLength = (1 &lt;&lt; 26) - 1;
225     unsigned m_schemeEnd : 26;
226     unsigned m_userStart;
227     unsigned m_userEnd;
228     unsigned m_passwordEnd;
229     unsigned m_hostEnd;
230     unsigned m_pathAfterLastSlash;
231     unsigned m_pathEnd;
232     unsigned m_queryEnd;
233 };
234 
235 static_assert(sizeof(URL) == sizeof(String) + 8 * sizeof(unsigned), &quot;URL should stay small&quot;);
236 
237 template &lt;class Encoder&gt;
238 void URL::encode(Encoder&amp; encoder) const
239 {
240     encoder &lt;&lt; m_string;
241 }
242 
243 template &lt;class Decoder&gt;
244 bool URL::decode(Decoder&amp; decoder, URL&amp; url)
245 {
246     auto optionalURL = URL::decode(decoder);
247     if (!optionalURL)
248         return false;
249     url = WTFMove(*optionalURL);
250     return true;
251 }
252 
253 template &lt;class Decoder&gt;
254 Optional&lt;URL&gt; URL::decode(Decoder&amp; decoder)
255 {
256     String string;
257     if (!decoder.decode(string))
258         return WTF::nullopt;
259     return URL(URL(), string);
260 }
261 
262 WTF_EXPORT_PRIVATE bool equalIgnoringFragmentIdentifier(const URL&amp;, const URL&amp;);
263 WTF_EXPORT_PRIVATE bool equalIgnoringQueryAndFragment(const URL&amp;, const URL&amp;);
264 WTF_EXPORT_PRIVATE bool protocolHostAndPortAreEqual(const URL&amp;, const URL&amp;);
265 WTF_EXPORT_PRIVATE bool hostsAreEqual(const URL&amp;, const URL&amp;);
266 
267 WTF_EXPORT_PRIVATE const URL&amp; blankURL();
268 
269 // Functions to do URL operations on strings.
270 // These are operations that aren&#39;t faster on a parsed URL.
271 // These are also different from the URL functions in that they don&#39;t require the string to be a valid and parsable URL.
272 // This is especially important because valid javascript URLs are not necessarily considered valid by URL.
273 
274 WTF_EXPORT_PRIVATE bool protocolIs(const String&amp; url, const char* protocol);
275 WTF_EXPORT_PRIVATE bool protocolIsJavaScript(const String&amp; url);
276 WTF_EXPORT_PRIVATE bool protocolIsJavaScript(StringView url);
277 WTF_EXPORT_PRIVATE bool protocolIsInHTTPFamily(const String&amp; url);
278 
279 WTF_EXPORT_PRIVATE Optional&lt;uint16_t&gt; defaultPortForProtocol(StringView protocol);
280 WTF_EXPORT_PRIVATE bool isDefaultPortForProtocol(uint16_t port, StringView protocol);
281 WTF_EXPORT_PRIVATE bool portAllowed(const URL&amp;); // Blacklist ports that should never be used for Web resources.
282 
283 WTF_EXPORT_PRIVATE void registerDefaultPortForProtocolForTesting(uint16_t port, const String&amp; protocol);
284 WTF_EXPORT_PRIVATE void clearDefaultPortForProtocolMapForTesting();
285 
286 WTF_EXPORT_PRIVATE bool isValidProtocol(const String&amp;);
287 
288 WTF_EXPORT_PRIVATE String mimeTypeFromDataURL(const String&amp; url);
289 
290 // FIXME: This is a wrong concept to expose, different parts of a URL need different escaping per the URL Standard.
291 WTF_EXPORT_PRIVATE String encodeWithURLEscapeSequences(const String&amp;);
292 
293 // Inlines.
294 
295 inline bool operator==(const URL&amp; a, const URL&amp; b)
296 {
297     return a.string() == b.string();
298 }
299 
300 inline bool operator==(const URL&amp; a, const String&amp; b)
301 {
302     return a.string() == b;
303 }
304 
305 inline bool operator==(const String&amp; a, const URL&amp; b)
306 {
307     return a == b.string();
308 }
309 
310 inline bool operator!=(const URL&amp; a, const URL&amp; b)
311 {
312     return a.string() != b.string();
313 }
314 
315 inline bool operator!=(const URL&amp; a, const String&amp; b)
316 {
317     return a.string() != b;
318 }
319 
320 inline bool operator!=(const String&amp; a, const URL&amp; b)
321 {
322     return a != b.string();
323 }
324 
325 // Inline versions of some non-GoogleURL functions so we can get inlining
326 // without having to have a lot of ugly ifdefs in the class definition.
327 
328 inline bool URL::isNull() const
329 {
330     return m_string.isNull();
331 }
332 
333 inline bool URL::isEmpty() const
334 {
335     return m_string.isEmpty();
336 }
337 
338 inline bool URL::isValid() const
339 {
340     return m_isValid;
341 }
342 
343 inline bool URL::hasPath() const
344 {
345     return m_pathEnd != m_hostEnd + m_portLength;
346 }
347 
348 inline bool URL::hasUsername() const
349 {
350     return m_userEnd &gt; m_userStart;
351 }
352 
353 inline bool URL::hasPassword() const
354 {
355     return m_passwordEnd &gt; (m_userEnd + 1);
356 }
357 
358 inline bool URL::hasQuery() const
359 {
360     return m_queryEnd &gt; m_pathEnd;
361 }
362 
363 inline bool URL::hasFragment() const
364 {
365     return m_isValid &amp;&amp; m_string.length() &gt; m_queryEnd;
366 }
367 
368 inline bool URL::protocolIsInHTTPFamily() const
369 {
370     return m_protocolIsInHTTPFamily;
371 }
372 
373 inline unsigned URL::pathStart() const
374 {
375     return m_hostEnd + m_portLength;
376 }
377 
378 inline unsigned URL::pathEnd() const
379 {
380     return m_pathEnd;
381 }
382 
383 inline unsigned URL::pathAfterLastSlash() const
384 {
385     return m_pathAfterLastSlash;
386 }
387 
388 WTF_EXPORT_PRIVATE WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const URL&amp;);
389 
390 template&lt;&gt; struct DefaultHash&lt;URL&gt;;
391 template&lt;&gt; struct HashTraits&lt;URL&gt;;
392 
393 } // namespace WTF
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/angle/ExtensionsGLANGLE.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(ANGLE)
 29 #include &quot;ExtensionsGLANGLE.h&quot;
 30 
 31 #include &quot;GraphicsContextGLOpenGL.h&quot;
 32 
 33 #include &lt;ANGLE/entry_points_gles_2_0_autogen.h&gt;
 34 #include &lt;ANGLE/entry_points_gles_3_0_autogen.h&gt;
 35 // Skip the inclusion of ANGLE&#39;s explicit context entry points for now.
 36 #define GL_ANGLE_explicit_context
 37 #define GL_ANGLE_explicit_context_gles1
 38 typedef void* GLeglContext;
 39 #include &lt;ANGLE/entry_points_gles_ext_autogen.h&gt;
 40 
 41 // Note: this file can&#39;t be compiled in the same unified source file
 42 // as others which include the system&#39;s OpenGL headers.
 43 
 44 namespace WebCore {
 45 
 46 ExtensionsGLANGLE::ExtensionsGLANGLE(GraphicsContextGLOpenGL* context, bool useIndexedGetString)
 47     : m_initializedAvailableExtensions(false)
 48     , m_context(context)
 49     , m_isNVIDIA(false)
 50     , m_isAMD(false)
 51     , m_isIntel(false)
 52     , m_isImagination(false)
 53     , m_requiresBuiltInFunctionEmulation(false)
 54     , m_requiresRestrictedMaximumTextureSize(false)
 55     , m_useIndexedGetString(useIndexedGetString)
 56 {
 57     // FIXME: ideally, remove this initialization altogether. ANGLE
 58     // subsumes the responsibility for graphics driver workarounds.
 59     m_vendor = String(reinterpret_cast&lt;const char*&gt;(gl::GetString(GL_VENDOR)));
 60     m_renderer = String(reinterpret_cast&lt;const char*&gt;(gl::GetString(GL_RENDERER)));
 61 
 62     Vector&lt;String&gt; vendorComponents = m_vendor.convertToASCIILowercase().split(&#39; &#39;);
 63     if (vendorComponents.contains(&quot;nvidia&quot;))
 64         m_isNVIDIA = true;
 65     if (vendorComponents.contains(&quot;ati&quot;) || vendorComponents.contains(&quot;amd&quot;))
 66         m_isAMD = true;
 67     if (vendorComponents.contains(&quot;intel&quot;))
 68         m_isIntel = true;
 69     if (vendorComponents.contains(&quot;imagination&quot;))
 70         m_isImagination = true;
 71 }
 72 
 73 ExtensionsGLANGLE::~ExtensionsGLANGLE() = default;
 74 
 75 bool ExtensionsGLANGLE::supports(const String&amp; name)
 76 {
 77     if (!m_initializedAvailableExtensions)
 78         initializeAvailableExtensions();
 79 
 80     return supportsExtension(name);
 81 }
 82 
 83 void ExtensionsGLANGLE::ensureEnabled(const String&amp; name)
 84 {
 85     // Enable support in ANGLE (if not enabled already).
 86     if (m_requestableExtensions.contains(name) &amp;&amp; !m_enabledExtensions.contains(name)) {
 87         m_context-&gt;makeContextCurrent();
 88         gl::RequestExtensionANGLE(name.ascii().data());
 89         m_enabledExtensions.add(name);
 90     }
 91 }
 92 
 93 bool ExtensionsGLANGLE::isEnabled(const String&amp; name)
 94 {
 95     return m_availableExtensions.contains(name) || m_enabledExtensions.contains(name);
 96 }
 97 
 98 int ExtensionsGLANGLE::getGraphicsResetStatusARB()
 99 {
100     return GraphicsContextGL::NO_ERROR;
101 }
102 
103 String ExtensionsGLANGLE::getTranslatedShaderSourceANGLE(PlatformGLObject shader)
104 {
105     int sourceLength = 0;
106     m_context-&gt;getShaderiv(shader, GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE, &amp;sourceLength);
107     if (!sourceLength)
108         return emptyString();
109     Vector&lt;GLchar&gt; name(sourceLength); // GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE includes null termination.
110     int returnedLength = 0;
111     gl::GetTranslatedShaderSourceANGLE(shader, sourceLength, &amp;returnedLength, name.data());
112     if (!returnedLength)
113         return emptyString();
114     // returnedLength does not include the null terminator.
115     ASSERT(returnedLength == sourceLength - 1);
116     return String(name.data(), returnedLength);
117 }
118 
119 void ExtensionsGLANGLE::initializeAvailableExtensions()
120 {
121     if (m_useIndexedGetString) {
122         GLint numExtensions = 0;
123         gl::GetIntegerv(GL_NUM_EXTENSIONS, &amp;numExtensions);
124         for (GLint i = 0; i &lt; numExtensions; ++i)
125             m_availableExtensions.add(gl::GetStringi(GL_EXTENSIONS, i));
126         gl::GetIntegerv(GL_NUM_REQUESTABLE_EXTENSIONS_ANGLE, &amp;numExtensions);
127         for (GLint i = 0; i &lt; numExtensions; ++i)
128             m_requestableExtensions.add(gl::GetStringi(GL_REQUESTABLE_EXTENSIONS_ANGLE, i));
129     } else {
130         String extensionsString = getExtensions();
131         for (auto&amp; extension : extensionsString.split(&#39; &#39;))
132             m_availableExtensions.add(extension);
133         extensionsString = String(reinterpret_cast&lt;const char*&gt;(gl::GetString(GL_REQUESTABLE_EXTENSIONS_ANGLE)));
134         for (auto&amp; extension : extensionsString.split(&#39; &#39;))
135             m_requestableExtensions.add(extension);
136     }
137     m_initializedAvailableExtensions = true;
138 }
139 
140 void ExtensionsGLANGLE::readnPixelsEXT(int, int, GCGLsizei, GCGLsizei, GCGLenum, GCGLenum, GCGLsizei, void *)
141 {
142     m_context-&gt;synthesizeGLError(GL_INVALID_OPERATION);
143 }
144 
145 void ExtensionsGLANGLE::getnUniformfvEXT(GCGLuint, int, GCGLsizei, float *)
146 {
147     m_context-&gt;synthesizeGLError(GL_INVALID_OPERATION);
148 }
149 
150 void ExtensionsGLANGLE::getnUniformivEXT(GCGLuint, int, GCGLsizei, int *)
151 {
152     m_context-&gt;synthesizeGLError(GL_INVALID_OPERATION);
153 }
154 
155 void ExtensionsGLANGLE::blitFramebuffer(long srcX0, long srcY0, long srcX1, long srcY1, long dstX0, long dstY0, long dstX1, long dstY1, unsigned long mask, unsigned long filter)
156 {
157     // FIXME: consider adding support for APPLE_framebuffer_multisample.
158     gl::BlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
159 }
160 
161 void ExtensionsGLANGLE::renderbufferStorageMultisample(unsigned long target, unsigned long samples, unsigned long internalformat, unsigned long width, unsigned long height)
162 {
163     gl::RenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
164 }
165 
166 PlatformGLObject ExtensionsGLANGLE::createVertexArrayOES()
167 {
168     m_context-&gt;makeContextCurrent();
169     GLuint array = 0;
170     gl::GenVertexArraysOES(1, &amp;array);
171     return array;
172 }
173 
174 void ExtensionsGLANGLE::deleteVertexArrayOES(PlatformGLObject array)
175 {
176     if (!array)
177         return;
178 
179     m_context-&gt;makeContextCurrent();
180     gl::DeleteVertexArraysOES(1, &amp;array);
181 }
182 
183 GCGLboolean ExtensionsGLANGLE::isVertexArrayOES(PlatformGLObject array)
184 {
185     if (!array)
186         return GL_FALSE;
187 
188     m_context-&gt;makeContextCurrent();
189     return gl::IsVertexArrayOES(array);
190 }
191 
192 void ExtensionsGLANGLE::bindVertexArrayOES(PlatformGLObject array)
193 {
194     m_context-&gt;makeContextCurrent();
195     gl::BindVertexArrayOES(array);
196 }
197 
198 void ExtensionsGLANGLE::insertEventMarkerEXT(const String&amp;)
199 {
200     // FIXME: implement this function and add GL_EXT_debug_marker in supports().
201     return;
202 }
203 
204 void ExtensionsGLANGLE::pushGroupMarkerEXT(const String&amp;)
205 {
206     // FIXME: implement this function and add GL_EXT_debug_marker in supports().
207     return;
208 }
209 
210 void ExtensionsGLANGLE::popGroupMarkerEXT(void)
211 {
212     // FIXME: implement this function and add GL_EXT_debug_marker in supports().
213     return;
214 }
215 
216 bool ExtensionsGLANGLE::supportsExtension(const String&amp; name)
217 {
218     return m_availableExtensions.contains(name) || m_requestableExtensions.contains(name);
219 }
220 
221 void ExtensionsGLANGLE::drawBuffersEXT(GCGLsizei n, const GCGLenum* bufs)
222 {
223     gl::DrawBuffersEXT(n, bufs);
224 }
225 
226 void ExtensionsGLANGLE::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)
227 {
228     m_context-&gt;makeContextCurrent();
229     gl::DrawArraysInstancedANGLE(mode, first, count, primcount);
230 }
231 
232 void ExtensionsGLANGLE::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount)
233 {
234     m_context-&gt;makeContextCurrent();
235     gl::DrawElementsInstancedANGLE(mode, count, type, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)), primcount);
236 }
237 
238 void ExtensionsGLANGLE::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
239 {
240     m_context-&gt;makeContextCurrent();
241     gl::VertexAttribDivisorANGLE(index, divisor);
242 }
243 
244 String ExtensionsGLANGLE::getExtensions()
245 {
246     return String(reinterpret_cast&lt;const char*&gt;(gl::GetString(GL_EXTENSIONS)));
247 }
248 
249 } // namespace WebCore
250 
251 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(ANGLE)
    </pre>
  </body>
</html>
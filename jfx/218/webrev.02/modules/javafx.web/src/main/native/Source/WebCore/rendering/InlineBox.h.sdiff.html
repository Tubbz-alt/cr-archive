<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
103 
104     bool isHorizontal() const { return m_bitfields.isHorizontal(); }
105     void setIsHorizontal(bool isHorizontal) { m_bitfields.setIsHorizontal(isHorizontal); }
106 
107     virtual FloatRect calculateBoundaries() const
108     {
109         ASSERT_NOT_REACHED();
110         return FloatRect();
111     }
112 
113     bool isConstructed() { return m_bitfields.constructed(); }
114     virtual void setConstructed() { m_bitfields.setConstructed(true); }
115 
116     void setExtracted(bool extracted = true) { m_bitfields.setExtracted(extracted); }
117 
118     void setIsFirstLine(bool firstLine) { m_bitfields.setFirstLine(firstLine); }
119     bool isFirstLine() const { return m_bitfields.firstLine(); }
120 
121     void removeFromParent();
122 
<span class="line-modified">123     InlineBox* nextOnLine() const { return m_next; }</span>
<span class="line-modified">124     InlineBox* prevOnLine() const { return m_prev; }</span>
125     void setNextOnLine(InlineBox* next)
126     {
127         ASSERT(m_parent || !next);
<span class="line-modified">128         m_next = next;</span>
129     }
<span class="line-modified">130     void setPrevOnLine(InlineBox* prev)</span>
131     {
<span class="line-modified">132         ASSERT(m_parent || !prev);</span>
<span class="line-modified">133         m_prev = prev;</span>
134     }
135     bool nextOnLineExists() const;
136     bool previousOnLineExists() const;
137 
138     virtual bool isLeaf() const { return true; }
139 
<span class="line-modified">140     InlineBox* nextLeafChild() const;</span>
<span class="line-modified">141     InlineBox* prevLeafChild() const;</span>
142 
143     // Helper functions for editing and hit-testing code.
144     // FIXME: These two functions should be moved to RenderedPosition once the code to convert between
145     // Position and inline box, offset pair is moved to RenderedPosition.
<span class="line-modified">146     InlineBox* nextLeafChildIgnoringLineBreak() const;</span>
<span class="line-modified">147     InlineBox* prevLeafChildIgnoringLineBreak() const;</span>
148 
149     // FIXME: Hide this once all callers are using tighter types.
150     RenderObject&amp; renderer() const { return m_renderer; }
151 
152     InlineFlowBox* parent() const
153     {
154         assertNotDeleted();
155         ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadParent);
156         return m_parent;
157     }
158     void setParent(InlineFlowBox* par) { m_parent = par; }
159 
160     const RootInlineBox&amp; root() const;
161     RootInlineBox&amp; root();
162 
163     // x() is the left side of the box in the containing block&#39;s coordinate system.
164     void setX(float x) { m_topLeft.setX(x); }
165     float x() const { return m_topLeft.x(); }
166     float left() const { return m_topLeft.x(); }
167 
</pre>
<hr />
<pre>
270     void setExpansion(float newExpansion)
271     {
272         m_logicalWidth -= m_expansion;
273         m_expansion = newExpansion;
274         m_logicalWidth += m_expansion;
275     }
276     void setExpansionWithoutGrowing(float newExpansion)
277     {
278         ASSERT(!m_expansion);
279         m_expansion = newExpansion;
280     }
281     float expansion() const { return m_expansion; }
282 
283     void setHasHyphen(bool hasHyphen) { m_bitfields.setHasEllipsisBoxOrHyphen(hasHyphen); }
284     void setCanHaveLeadingExpansion(bool canHaveLeadingExpansion) { m_bitfields.setHasSelectedChildrenOrCanHaveLeadingExpansion(canHaveLeadingExpansion); }
285     void setCanHaveTrailingExpansion(bool canHaveTrailingExpansion) { m_bitfields.setCanHaveTrailingExpansion(canHaveTrailingExpansion); }
286     void setForceTrailingExpansion() { m_bitfields.setForceTrailingExpansion(true); }
287     void setForceLeadingExpansion() { m_bitfields.setForceLeadingExpansion(true); }
288 
289 private:
<span class="line-modified">290     InlineBox* m_next { nullptr }; // The next element on the same line as us.</span>
<span class="line-modified">291     InlineBox* m_prev { nullptr }; // The previous element on the same line as us.</span>
292 
293     InlineFlowBox* m_parent { nullptr }; // The box that contains us.
294 
295     RenderObject&amp; m_renderer;
296 
297 private:
298     float m_logicalWidth { 0 };
299     float m_expansion { 0 };
300     FloatPoint m_topLeft;
301 
302 #define ADD_BOOLEAN_BITFIELD(name, Name) \
303     private:\
304     unsigned m_##name : 1;\
305     public:\
306     bool name() const { return m_##name; }\
307     void set##Name(bool name) { m_##name = name; }\
308 
309     class InlineBoxBitfields {
310     public:
311         explicit InlineBoxBitfields(bool firstLine = false, bool constructed = false, bool dirty = false, bool extracted = false, bool isHorizontal = true)
</pre>
<hr />
<pre>
366         bool determinedIfNextOnLineExists() const { return m_determinedIfNextOnLineExists; }
367         void setDeterminedIfNextOnLineExists(bool determinedIfNextOnLineExists) const { m_determinedIfNextOnLineExists = determinedIfNextOnLineExists; }
368 
369     private:
370         mutable unsigned m_nextOnLineExists : 1;
371 
372     public:
373         bool nextOnLineExists() const { return m_nextOnLineExists; }
374         void setNextOnLineExists(bool nextOnLineExists) const { m_nextOnLineExists = nextOnLineExists; }
375     };
376 #undef ADD_BOOLEAN_BITFIELD
377 
378     InlineBoxBitfields m_bitfields;
379 
380 protected:
381     explicit InlineBox(RenderObject&amp; renderer)
382         : m_renderer(renderer)
383     {
384     }
385 
<span class="line-modified">386     InlineBox(RenderObject&amp; renderer, FloatPoint topLeft, float logicalWidth, bool firstLine, bool constructed, bool dirty, bool extracted, bool isHorizontal, InlineBox* next, InlineBox* prev, InlineFlowBox* parent)</span>
<span class="line-modified">387         : m_next(next)</span>
<span class="line-modified">388         , m_prev(prev)</span>
389         , m_parent(parent)
390         , m_renderer(renderer)
391         , m_logicalWidth(logicalWidth)
392         , m_topLeft(topLeft)
393         , m_bitfields(firstLine, constructed, dirty, extracted, isHorizontal)
394     {
395     }
396 
397     // For RootInlineBox
398     bool endsWithBreak() const { return m_bitfields.endsWithBreak(); }
399     void setEndsWithBreak(bool endsWithBreak) { m_bitfields.setEndsWithBreak(endsWithBreak); }
400     bool hasEllipsisBox() const { return m_bitfields.hasEllipsisBoxOrHyphen(); }
401     bool hasSelectedChildren() const { return m_bitfields.hasSelectedChildrenOrCanHaveLeadingExpansion(); }
402     void setHasSelectedChildren(bool hasSelectedChildren) { m_bitfields.setHasSelectedChildrenOrCanHaveLeadingExpansion(hasSelectedChildren); }
403     void setHasEllipsisBox(bool hasEllipsisBox) { m_bitfields.setHasEllipsisBoxOrHyphen(hasEllipsisBox); }
404 
405     // For InlineTextBox
406     bool hasHyphen() const { return m_bitfields.hasEllipsisBoxOrHyphen(); }
407     bool canHaveLeadingExpansion() const { return m_bitfields.hasSelectedChildrenOrCanHaveLeadingExpansion(); }
408     bool canHaveTrailingExpansion() const { return m_bitfields.canHaveTrailingExpansion(); }
</pre>
</td>
<td>
<hr />
<pre>
103 
104     bool isHorizontal() const { return m_bitfields.isHorizontal(); }
105     void setIsHorizontal(bool isHorizontal) { m_bitfields.setIsHorizontal(isHorizontal); }
106 
107     virtual FloatRect calculateBoundaries() const
108     {
109         ASSERT_NOT_REACHED();
110         return FloatRect();
111     }
112 
113     bool isConstructed() { return m_bitfields.constructed(); }
114     virtual void setConstructed() { m_bitfields.setConstructed(true); }
115 
116     void setExtracted(bool extracted = true) { m_bitfields.setExtracted(extracted); }
117 
118     void setIsFirstLine(bool firstLine) { m_bitfields.setFirstLine(firstLine); }
119     bool isFirstLine() const { return m_bitfields.firstLine(); }
120 
121     void removeFromParent();
122 
<span class="line-modified">123     InlineBox* nextOnLine() const { return m_nextOnLine; }</span>
<span class="line-modified">124     InlineBox* previousOnLine() const { return m_previousOnLine; }</span>
125     void setNextOnLine(InlineBox* next)
126     {
127         ASSERT(m_parent || !next);
<span class="line-modified">128         m_nextOnLine = next;</span>
129     }
<span class="line-modified">130     void setPreviousOnLine(InlineBox* previous)</span>
131     {
<span class="line-modified">132         ASSERT(m_parent || !previous);</span>
<span class="line-modified">133         m_previousOnLine = previous;</span>
134     }
135     bool nextOnLineExists() const;
136     bool previousOnLineExists() const;
137 
138     virtual bool isLeaf() const { return true; }
139 
<span class="line-modified">140     InlineBox* nextLeafOnLine() const;</span>
<span class="line-modified">141     InlineBox* previousLeafOnLine() const;</span>
142 
143     // Helper functions for editing and hit-testing code.
144     // FIXME: These two functions should be moved to RenderedPosition once the code to convert between
145     // Position and inline box, offset pair is moved to RenderedPosition.
<span class="line-modified">146     InlineBox* nextLeafOnLineIgnoringLineBreak() const;</span>
<span class="line-modified">147     InlineBox* previousLeafOnLineIgnoringLineBreak() const;</span>
148 
149     // FIXME: Hide this once all callers are using tighter types.
150     RenderObject&amp; renderer() const { return m_renderer; }
151 
152     InlineFlowBox* parent() const
153     {
154         assertNotDeleted();
155         ASSERT_WITH_SECURITY_IMPLICATION(!m_hasBadParent);
156         return m_parent;
157     }
158     void setParent(InlineFlowBox* par) { m_parent = par; }
159 
160     const RootInlineBox&amp; root() const;
161     RootInlineBox&amp; root();
162 
163     // x() is the left side of the box in the containing block&#39;s coordinate system.
164     void setX(float x) { m_topLeft.setX(x); }
165     float x() const { return m_topLeft.x(); }
166     float left() const { return m_topLeft.x(); }
167 
</pre>
<hr />
<pre>
270     void setExpansion(float newExpansion)
271     {
272         m_logicalWidth -= m_expansion;
273         m_expansion = newExpansion;
274         m_logicalWidth += m_expansion;
275     }
276     void setExpansionWithoutGrowing(float newExpansion)
277     {
278         ASSERT(!m_expansion);
279         m_expansion = newExpansion;
280     }
281     float expansion() const { return m_expansion; }
282 
283     void setHasHyphen(bool hasHyphen) { m_bitfields.setHasEllipsisBoxOrHyphen(hasHyphen); }
284     void setCanHaveLeadingExpansion(bool canHaveLeadingExpansion) { m_bitfields.setHasSelectedChildrenOrCanHaveLeadingExpansion(canHaveLeadingExpansion); }
285     void setCanHaveTrailingExpansion(bool canHaveTrailingExpansion) { m_bitfields.setCanHaveTrailingExpansion(canHaveTrailingExpansion); }
286     void setForceTrailingExpansion() { m_bitfields.setForceTrailingExpansion(true); }
287     void setForceLeadingExpansion() { m_bitfields.setForceLeadingExpansion(true); }
288 
289 private:
<span class="line-modified">290     InlineBox* m_nextOnLine { nullptr }; // The next element on the same line as us.</span>
<span class="line-modified">291     InlineBox* m_previousOnLine { nullptr }; // The previous element on the same line as us.</span>
292 
293     InlineFlowBox* m_parent { nullptr }; // The box that contains us.
294 
295     RenderObject&amp; m_renderer;
296 
297 private:
298     float m_logicalWidth { 0 };
299     float m_expansion { 0 };
300     FloatPoint m_topLeft;
301 
302 #define ADD_BOOLEAN_BITFIELD(name, Name) \
303     private:\
304     unsigned m_##name : 1;\
305     public:\
306     bool name() const { return m_##name; }\
307     void set##Name(bool name) { m_##name = name; }\
308 
309     class InlineBoxBitfields {
310     public:
311         explicit InlineBoxBitfields(bool firstLine = false, bool constructed = false, bool dirty = false, bool extracted = false, bool isHorizontal = true)
</pre>
<hr />
<pre>
366         bool determinedIfNextOnLineExists() const { return m_determinedIfNextOnLineExists; }
367         void setDeterminedIfNextOnLineExists(bool determinedIfNextOnLineExists) const { m_determinedIfNextOnLineExists = determinedIfNextOnLineExists; }
368 
369     private:
370         mutable unsigned m_nextOnLineExists : 1;
371 
372     public:
373         bool nextOnLineExists() const { return m_nextOnLineExists; }
374         void setNextOnLineExists(bool nextOnLineExists) const { m_nextOnLineExists = nextOnLineExists; }
375     };
376 #undef ADD_BOOLEAN_BITFIELD
377 
378     InlineBoxBitfields m_bitfields;
379 
380 protected:
381     explicit InlineBox(RenderObject&amp; renderer)
382         : m_renderer(renderer)
383     {
384     }
385 
<span class="line-modified">386     InlineBox(RenderObject&amp; renderer, FloatPoint topLeft, float logicalWidth, bool firstLine, bool constructed, bool dirty, bool extracted, bool isHorizontal, InlineBox* next, InlineBox* previous, InlineFlowBox* parent)</span>
<span class="line-modified">387         : m_nextOnLine(next)</span>
<span class="line-modified">388         , m_previousOnLine(previous)</span>
389         , m_parent(parent)
390         , m_renderer(renderer)
391         , m_logicalWidth(logicalWidth)
392         , m_topLeft(topLeft)
393         , m_bitfields(firstLine, constructed, dirty, extracted, isHorizontal)
394     {
395     }
396 
397     // For RootInlineBox
398     bool endsWithBreak() const { return m_bitfields.endsWithBreak(); }
399     void setEndsWithBreak(bool endsWithBreak) { m_bitfields.setEndsWithBreak(endsWithBreak); }
400     bool hasEllipsisBox() const { return m_bitfields.hasEllipsisBoxOrHyphen(); }
401     bool hasSelectedChildren() const { return m_bitfields.hasSelectedChildrenOrCanHaveLeadingExpansion(); }
402     void setHasSelectedChildren(bool hasSelectedChildren) { m_bitfields.setHasSelectedChildrenOrCanHaveLeadingExpansion(hasSelectedChildren); }
403     void setHasEllipsisBox(bool hasEllipsisBox) { m_bitfields.setHasEllipsisBoxOrHyphen(hasEllipsisBox); }
404 
405     // For InlineTextBox
406     bool hasHyphen() const { return m_bitfields.hasEllipsisBoxOrHyphen(); }
407     bool canHaveLeadingExpansion() const { return m_bitfields.hasSelectedChildrenOrCanHaveLeadingExpansion(); }
408     bool canHaveTrailingExpansion() const { return m_bitfields.canHaveTrailingExpansion(); }
</pre>
</td>
</tr>
</table>
<center><a href="InlineBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineFlowBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
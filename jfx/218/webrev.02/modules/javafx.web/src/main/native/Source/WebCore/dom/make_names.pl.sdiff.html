<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/make_names.pl</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="make_event_factory.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="messageports/MessagePortChannel.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/make_names.pl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 487             printConstructorInterior($F, $mappedName, $enabledTags{$mappedName}{interfaceName}, &quot;QualifiedName(tagName.prefix(), ${mappedName}Tag-&gt;localName(), tagName.namespaceURI())&quot;);
 488         }
 489     }
 490 }
 491 
 492 sub printFunctionTable
 493 {
 494     my ($F, $tagConstructorMap) = @_;
 495     my %tagConstructorMap = %$tagConstructorMap;
 496 
 497     for my $tagName (sort keys %tagConstructorMap) {
 498         next if $enabledTags{$tagName}{noConstructor};
 499 
 500         my $conditional = $enabledTags{$tagName}{conditional};
 501         if ($conditional) {
 502             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
 503             print F &quot;#if ${conditionalString}\n&quot;;
 504         }
 505 
 506         if ($enabledTags{$tagName}{mapToTagName}) {
<span class="line-modified"> 507             print F &quot;        { ${tagName}Tag, $enabledTags{$tagName}{mapToTagName}To${tagName}Constructor },\n&quot;;</span>
 508         } else {
<span class="line-modified"> 509             print F &quot;        { ${tagName}Tag, $tagConstructorMap{$tagName}Constructor },\n&quot;;</span>
 510         }
 511 
 512         if ($conditional) {
 513             print F &quot;#endif\n&quot;;
 514         }
 515     }
 516 }
 517 
 518 sub svgCapitalizationHacks
 519 {
 520     my $name = shift;
 521 
 522     $name = &quot;FE&quot; . ucfirst $1 if $name =~ /^fe(.+)$/;
 523 
 524     return $name;
 525 }
 526 
 527 sub upperCaseName
 528 {
 529     my $name = shift;
</pre>
<hr />
<pre>
 950 #include &quot;$parameters{namespace}ElementFactory.h&quot;
 951 
 952 #include &quot;$parameters{namespace}Names.h&quot;
 953 
 954 END
 955     ;
 956 
 957     printElementIncludes($F);
 958     printConditionalElementIncludes($F, 0);
 959 
 960     print F &lt;&lt;END
 961 
 962 #include &quot;Document.h&quot;
 963 #include &quot;RuntimeEnabledFeatures.h&quot;
 964 #include &quot;Settings.h&quot;
 965 #include &lt;wtf/HashMap.h&gt;
 966 #include &lt;wtf/NeverDestroyed.h&gt;
 967 
 968 namespace WebCore {
 969 
<span class="line-removed"> 970 using namespace $parameters{namespace}Names;</span>
<span class="line-removed"> 971 </span>
 972 typedef Ref&lt;$parameters{namespace}Element&gt; (*$parameters{namespace}ConstructorFunction)(const QualifiedName&amp;, Document&amp;$formElementArgumentForDeclaration, bool createdByParser);
 973 
 974 END
 975     ;
 976 
 977     my %tagConstructorMap = buildConstructorMap();
 978     my $argumentList;
 979 
 980     if ($parameters{namespace} eq &quot;HTML&quot;) {
 981         $argumentList = &quot;name, document, formElement, createdByParser&quot;;
 982     } else {
 983         $argumentList = &quot;name, document, createdByParser&quot;;
 984     }
 985 
 986     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 987 
 988     printConstructors($F, \%tagConstructorMap);
 989 
 990     print F &lt;&lt;END
 991 
</pre>
<hr />
<pre>
1042     }
1043     return nullptr;
1044 }
1045 
1046 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1047 {
1048     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1049     if (LIKELY(entry.function))
1050         return entry.function($argumentList);
1051     return nullptr;
1052 }
1053 
1054 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const AtomString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1055 {
1056     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1057     if (LIKELY(entry.function)) {
1058         ASSERT(entry.qualifiedName);
1059         const auto&amp; name = *entry.qualifiedName;
1060         return entry.function($argumentList);
1061     }
<span class="line-modified">1062     return $parameters{fallbackInterfaceName}::create(QualifiedName(nullAtom(), localName, ${lowercaseNamespacePrefix}NamespaceURI), document);</span>
1063 }
1064 
1065 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1066 {
1067     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1068     if (LIKELY(entry.function))
1069         return entry.function($argumentList);
1070     return $parameters{fallbackInterfaceName}::create(name, document);
1071 }
1072 
1073 } // namespace WebCore
1074 
1075 END
1076     ;
1077 
1078     print F &quot;#endif\n&quot; if $parameters{guardFactoryWith};
1079 
1080     close F;
1081 }
1082 
</pre>
<hr />
<pre>
1232 
1233     print F &quot;\n#include \&quot;$parameters{namespace}Names.h\&quot;\n&quot;;
1234     print F &lt;&lt;END
1235 
1236 #include &quot;Document.h&quot;
1237 #include &quot;RuntimeEnabledFeatures.h&quot;
1238 #include &quot;Settings.h&quot;
1239 #include &lt;wtf/NeverDestroyed.h&gt;
1240 #include &lt;wtf/StdLibExtras.h&gt;
1241 END
1242 ;
1243 
1244     printConditionalElementIncludes($F, 1);
1245 
1246     print F &lt;&lt;END
1247 
1248 using namespace JSC;
1249 
1250 namespace WebCore {
1251 
<span class="line-removed">1252 using namespace $parameters{namespace}Names;</span>
<span class="line-removed">1253 </span>
1254 typedef JSDOMObject* (*Create$parameters{namespace}ElementWrapperFunction)(JSDOMGlobalObject*, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp;);
1255 
1256 END
1257 ;
1258 
1259     printWrapperFunctions($F);
1260 
1261 print F &lt;&lt;END
1262 
1263 static NEVER_INLINE HashMap&lt;AtomStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; create$parameters{namespace}WrapperMap()
1264 {
1265     struct TableEntry {
1266         const QualifiedName&amp; name;
1267         Create$parameters{namespace}ElementWrapperFunction function;
1268     };
1269 
1270     static const TableEntry table[] = {
1271 END
1272 ;
1273 
1274     for my $tag (sort keys %enabledTags) {
1275         # Do not add the name to the map if it does not have a JS wrapper constructor or uses the default wrapper.
1276         next if (usesDefaultJSWrapper($tag, \%enabledTags) &amp;&amp; ($parameters{fallbackJSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;));
1277 
1278         my $conditional = $enabledTags{$tag}{conditional};
1279         if ($conditional) {
1280             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
1281             print F &quot;#if ${conditionalString}\n&quot;;
1282         }
1283 
1284         my $ucTag;
1285         if ($enabledTags{$tag}{settingsConditional}) {
1286             $ucTag = $enabledTags{$tag}{interfaceName};
1287         } else {
1288             $ucTag = $enabledTags{$tag}{JSInterfaceName};
1289         }
1290 
<span class="line-modified">1291         print F &quot;        { ${tag}Tag, create${ucTag}Wrapper },\n&quot;;</span>
1292 
1293         if ($conditional) {
1294             print F &quot;#endif\n&quot;;
1295         }
1296     }
1297 
1298     print F &lt;&lt;END
1299     };
1300 
1301     HashMap&lt;AtomStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; map;
1302     for (auto&amp; entry : table)
1303         map.add(entry.name.localName().impl(), entry.function);
1304     return map;
1305 }
1306 
1307 JSDOMObject* createJS$parameters{namespace}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1308 {
1309     static const auto functions = makeNeverDestroyed(create$parameters{namespace}WrapperMap());
1310     if (auto function = functions.get().get(element-&gt;localName().impl()))
1311         return function(globalObject, WTFMove(element));
</pre>
</td>
<td>
<hr />
<pre>
 487             printConstructorInterior($F, $mappedName, $enabledTags{$mappedName}{interfaceName}, &quot;QualifiedName(tagName.prefix(), ${mappedName}Tag-&gt;localName(), tagName.namespaceURI())&quot;);
 488         }
 489     }
 490 }
 491 
 492 sub printFunctionTable
 493 {
 494     my ($F, $tagConstructorMap) = @_;
 495     my %tagConstructorMap = %$tagConstructorMap;
 496 
 497     for my $tagName (sort keys %tagConstructorMap) {
 498         next if $enabledTags{$tagName}{noConstructor};
 499 
 500         my $conditional = $enabledTags{$tagName}{conditional};
 501         if ($conditional) {
 502             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
 503             print F &quot;#if ${conditionalString}\n&quot;;
 504         }
 505 
 506         if ($enabledTags{$tagName}{mapToTagName}) {
<span class="line-modified"> 507             print F &quot;        { $parameters{namespace}Names::${tagName}Tag, $enabledTags{$tagName}{mapToTagName}To${tagName}Constructor },\n&quot;;</span>
 508         } else {
<span class="line-modified"> 509             print F &quot;        { $parameters{namespace}Names::${tagName}Tag, $tagConstructorMap{$tagName}Constructor },\n&quot;;</span>
 510         }
 511 
 512         if ($conditional) {
 513             print F &quot;#endif\n&quot;;
 514         }
 515     }
 516 }
 517 
 518 sub svgCapitalizationHacks
 519 {
 520     my $name = shift;
 521 
 522     $name = &quot;FE&quot; . ucfirst $1 if $name =~ /^fe(.+)$/;
 523 
 524     return $name;
 525 }
 526 
 527 sub upperCaseName
 528 {
 529     my $name = shift;
</pre>
<hr />
<pre>
 950 #include &quot;$parameters{namespace}ElementFactory.h&quot;
 951 
 952 #include &quot;$parameters{namespace}Names.h&quot;
 953 
 954 END
 955     ;
 956 
 957     printElementIncludes($F);
 958     printConditionalElementIncludes($F, 0);
 959 
 960     print F &lt;&lt;END
 961 
 962 #include &quot;Document.h&quot;
 963 #include &quot;RuntimeEnabledFeatures.h&quot;
 964 #include &quot;Settings.h&quot;
 965 #include &lt;wtf/HashMap.h&gt;
 966 #include &lt;wtf/NeverDestroyed.h&gt;
 967 
 968 namespace WebCore {
 969 


 970 typedef Ref&lt;$parameters{namespace}Element&gt; (*$parameters{namespace}ConstructorFunction)(const QualifiedName&amp;, Document&amp;$formElementArgumentForDeclaration, bool createdByParser);
 971 
 972 END
 973     ;
 974 
 975     my %tagConstructorMap = buildConstructorMap();
 976     my $argumentList;
 977 
 978     if ($parameters{namespace} eq &quot;HTML&quot;) {
 979         $argumentList = &quot;name, document, formElement, createdByParser&quot;;
 980     } else {
 981         $argumentList = &quot;name, document, createdByParser&quot;;
 982     }
 983 
 984     my $lowercaseNamespacePrefix = lc($parameters{namespacePrefix});
 985 
 986     printConstructors($F, \%tagConstructorMap);
 987 
 988     print F &lt;&lt;END
 989 
</pre>
<hr />
<pre>
1040     }
1041     return nullptr;
1042 }
1043 
1044 RefPtr&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createKnownElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1045 {
1046     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1047     if (LIKELY(entry.function))
1048         return entry.function($argumentList);
1049     return nullptr;
1050 }
1051 
1052 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const AtomString&amp; localName, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1053 {
1054     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(localName);
1055     if (LIKELY(entry.function)) {
1056         ASSERT(entry.qualifiedName);
1057         const auto&amp; name = *entry.qualifiedName;
1058         return entry.function($argumentList);
1059     }
<span class="line-modified">1060     return $parameters{fallbackInterfaceName}::create(QualifiedName(nullAtom(), localName, $parameters{namespace}Names::${lowercaseNamespacePrefix}NamespaceURI), document);</span>
1061 }
1062 
1063 Ref&lt;$parameters{namespace}Element&gt; $parameters{namespace}ElementFactory::createElement(const QualifiedName&amp; name, Document&amp; document$formElementArgumentForDefinition, bool createdByParser)
1064 {
1065     const $parameters{namespace}ConstructorFunctionMapEntry&amp; entry = find$parameters{namespace}ElementConstructorFunction(name.localName());
1066     if (LIKELY(entry.function))
1067         return entry.function($argumentList);
1068     return $parameters{fallbackInterfaceName}::create(name, document);
1069 }
1070 
1071 } // namespace WebCore
1072 
1073 END
1074     ;
1075 
1076     print F &quot;#endif\n&quot; if $parameters{guardFactoryWith};
1077 
1078     close F;
1079 }
1080 
</pre>
<hr />
<pre>
1230 
1231     print F &quot;\n#include \&quot;$parameters{namespace}Names.h\&quot;\n&quot;;
1232     print F &lt;&lt;END
1233 
1234 #include &quot;Document.h&quot;
1235 #include &quot;RuntimeEnabledFeatures.h&quot;
1236 #include &quot;Settings.h&quot;
1237 #include &lt;wtf/NeverDestroyed.h&gt;
1238 #include &lt;wtf/StdLibExtras.h&gt;
1239 END
1240 ;
1241 
1242     printConditionalElementIncludes($F, 1);
1243 
1244     print F &lt;&lt;END
1245 
1246 using namespace JSC;
1247 
1248 namespace WebCore {
1249 


1250 typedef JSDOMObject* (*Create$parameters{namespace}ElementWrapperFunction)(JSDOMGlobalObject*, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp;);
1251 
1252 END
1253 ;
1254 
1255     printWrapperFunctions($F);
1256 
1257 print F &lt;&lt;END
1258 
1259 static NEVER_INLINE HashMap&lt;AtomStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; create$parameters{namespace}WrapperMap()
1260 {
1261     struct TableEntry {
1262         const QualifiedName&amp; name;
1263         Create$parameters{namespace}ElementWrapperFunction function;
1264     };
1265 
1266     static const TableEntry table[] = {
1267 END
1268 ;
1269 
1270     for my $tag (sort keys %enabledTags) {
1271         # Do not add the name to the map if it does not have a JS wrapper constructor or uses the default wrapper.
1272         next if (usesDefaultJSWrapper($tag, \%enabledTags) &amp;&amp; ($parameters{fallbackJSInterfaceName} eq $parameters{namespace} . &quot;Element&quot;));
1273 
1274         my $conditional = $enabledTags{$tag}{conditional};
1275         if ($conditional) {
1276             my $conditionalString = &quot;ENABLE(&quot; . join(&quot;) &amp;&amp; ENABLE(&quot;, split(/&amp;/, $conditional)) . &quot;)&quot;;
1277             print F &quot;#if ${conditionalString}\n&quot;;
1278         }
1279 
1280         my $ucTag;
1281         if ($enabledTags{$tag}{settingsConditional}) {
1282             $ucTag = $enabledTags{$tag}{interfaceName};
1283         } else {
1284             $ucTag = $enabledTags{$tag}{JSInterfaceName};
1285         }
1286 
<span class="line-modified">1287         print F &quot;        { $parameters{namespace}Names::${tag}Tag, create${ucTag}Wrapper },\n&quot;;</span>
1288 
1289         if ($conditional) {
1290             print F &quot;#endif\n&quot;;
1291         }
1292     }
1293 
1294     print F &lt;&lt;END
1295     };
1296 
1297     HashMap&lt;AtomStringImpl*, Create$parameters{namespace}ElementWrapperFunction&gt; map;
1298     for (auto&amp; entry : table)
1299         map.add(entry.name.localName().impl(), entry.function);
1300     return map;
1301 }
1302 
1303 JSDOMObject* createJS$parameters{namespace}Wrapper(JSDOMGlobalObject* globalObject, Ref&lt;$parameters{namespace}Element&gt;&amp;&amp; element)
1304 {
1305     static const auto functions = makeNeverDestroyed(create$parameters{namespace}WrapperMap());
1306     if (auto function = functions.get().get(element-&gt;localName().impl()))
1307         return function(globalObject, WTFMove(element));
</pre>
</td>
</tr>
</table>
<center><a href="make_event_factory.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="messageports/MessagePortChannel.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
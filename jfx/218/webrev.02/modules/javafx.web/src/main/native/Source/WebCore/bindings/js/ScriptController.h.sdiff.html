<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptModuleLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Lesser General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Lesser General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Lesser General Public
 18  *  License along with this library; if not, write to the Free Software
 19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;FrameLoaderTypes.h&quot;
 25 #include &quot;JSWindowProxy.h&quot;

 26 #include &quot;WindowProxy.h&quot;
 27 #include &lt;JavaScriptCore/JSBase.h&gt;
 28 #include &lt;JavaScriptCore/Strong.h&gt;
 29 #include &lt;wtf/Forward.h&gt;

 30 #include &lt;wtf/RefPtr.h&gt;
 31 #include &lt;wtf/WeakPtr.h&gt;
 32 #include &lt;wtf/text/TextPosition.h&gt;
 33 
 34 #if PLATFORM(COCOA)
 35 #include &lt;wtf/RetainPtr.h&gt;
 36 OBJC_CLASS JSContext;
 37 OBJC_CLASS WebScriptObject;
 38 #endif
 39 
 40 struct NPObject;
 41 
 42 namespace JSC {
<span class="line-modified"> 43 class ExecState;</span>
 44 class JSGlobalObject;
 45 class JSInternalPromise;
 46 class JSModuleRecord;
 47 
 48 namespace Bindings {
 49 class Instance;
 50 class RootObject;
 51 }
 52 }
 53 
 54 namespace WebCore {
 55 
 56 class CachedScriptFetcher;
 57 class Frame;
 58 class HTMLDocument;
 59 class HTMLPlugInElement;
 60 class LoadableModuleScript;
 61 class ModuleFetchParameters;
 62 class ScriptSourceCode;
 63 class SecurityOrigin;
 64 class Widget;



 65 struct ExceptionDetails;

 66 
 67 enum ReasonForCallingCanExecuteScripts {
 68     AboutToCreateEventListener,
 69     AboutToExecuteScript,
 70     NotAboutToExecuteScript
 71 };
 72 


 73 class ScriptController : public CanMakeWeakPtr&lt;ScriptController&gt; {
 74     WTF_MAKE_FAST_ALLOCATED;
 75 
 76     using RootObjectMap = HashMap&lt;void*, Ref&lt;JSC::Bindings::RootObject&gt;&gt;;
 77 
 78 public:
 79     explicit ScriptController(Frame&amp;);
 80     ~ScriptController();
 81 
<span class="line-modified"> 82     WEBCORE_EXPORT static Ref&lt;DOMWrapperWorld&gt; createWorld();</span>

 83 
 84     JSDOMWindow* globalObject(DOMWrapperWorld&amp; world)
 85     {
 86         return JSC::jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy(world).window());
 87     }
 88 
 89     static void getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp;);
 90 
<span class="line-modified"> 91     JSC::JSValue executeScript(const ScriptSourceCode&amp;, ExceptionDetails* = nullptr);</span>
<span class="line-removed"> 92     WEBCORE_EXPORT JSC::JSValue executeScript(const String&amp; script, bool forceUserGesture = false, ExceptionDetails* = nullptr);</span>
<span class="line-removed"> 93     JSC::JSValue executeScriptInWorld(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture = false, ExceptionDetails* = nullptr);</span>
<span class="line-removed"> 94     WEBCORE_EXPORT JSC::JSValue executeUserAgentScriptInWorld(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture, ExceptionDetails* = nullptr);</span>
 95 
<span class="line-modified"> 96     bool shouldAllowUserAgentScripts(Document&amp;) const;</span>








 97 
 98     // Returns true if argument is a JavaScript URL.
<span class="line-modified"> 99     bool executeIfJavaScriptURL(const URL&amp;, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL = ReplaceDocumentIfJavaScriptURL);</span>
100 
101     // This function must be called from the main thread. It is safe to call it repeatedly.
102     // Darwin is an exception to this rule: it is OK to call this function from any thread, even reentrantly.
103     static void initializeThreading();
104 
<span class="line-removed">105     JSC::JSValue evaluate(const ScriptSourceCode&amp;, ExceptionDetails* = nullptr);</span>
<span class="line-removed">106     JSC::JSValue evaluateInWorld(const ScriptSourceCode&amp;, DOMWrapperWorld&amp;, ExceptionDetails* = nullptr);</span>
<span class="line-removed">107 </span>
108     void loadModuleScriptInWorld(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;, DOMWrapperWorld&amp;);
109     void loadModuleScript(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;);
110     void loadModuleScriptInWorld(LoadableModuleScript&amp;, const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);
111     void loadModuleScript(LoadableModuleScript&amp;, const ScriptSourceCode&amp;);
112 
113     JSC::JSValue linkAndEvaluateModuleScriptInWorld(LoadableModuleScript&amp; , DOMWrapperWorld&amp;);
114     JSC::JSValue linkAndEvaluateModuleScript(LoadableModuleScript&amp;);
115 
116     JSC::JSValue evaluateModule(const URL&amp;, JSC::JSModuleRecord&amp;, DOMWrapperWorld&amp;);
117     JSC::JSValue evaluateModule(const URL&amp;, JSC::JSModuleRecord&amp;);
118 
119     WTF::TextPosition eventHandlerPosition() const;
120 
121     void enableEval();
122     void enableWebAssembly();
123     void disableEval(const String&amp; errorMessage);
124     void disableWebAssembly(const String&amp; errorMessage);
125 
126     static bool canAccessFromCurrentOrigin(Frame*, Document&amp; accessingDocument);
127     WEBCORE_EXPORT bool canExecuteScripts(ReasonForCallingCanExecuteScripts);
</pre>
<hr />
<pre>
131 
132     const String* sourceURL() const { return m_sourceURL; } // 0 if we are not evaluating any script
133 
134     void updateDocument();
135 
136     void namedItemAdded(HTMLDocument*, const AtomString&amp;) { }
137     void namedItemRemoved(HTMLDocument*, const AtomString&amp;) { }
138 
139     void clearScriptObjects();
140     WEBCORE_EXPORT void cleanupScriptObjectsForPlugin(void*);
141 
142     void updatePlatformScriptObjects();
143 
144     RefPtr&lt;JSC::Bindings::Instance&gt;  createScriptInstanceForWidget(Widget*);
145     WEBCORE_EXPORT JSC::Bindings::RootObject* bindingRootObject();
146     JSC::Bindings::RootObject* cacheableBindingRootObject();
147     JSC::Bindings::RootObject* existingCacheableBindingRootObject() const { return m_cacheableBindingRootObject.get(); }
148 
149     WEBCORE_EXPORT Ref&lt;JSC::Bindings::RootObject&gt; createRootObject(void* nativeHandle);
150 
<span class="line-modified">151     void collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::ExecState*, SecurityOrigin*&gt;&gt;&amp;);</span>
152 
153 #if PLATFORM(COCOA)
154     WEBCORE_EXPORT WebScriptObject* windowScriptObject();
155     WEBCORE_EXPORT JSContext *javaScriptContext();
156 #endif
157 
158     WEBCORE_EXPORT JSC::JSObject* jsObjectForPluginElement(HTMLPlugInElement*);
159 
160 #if ENABLE(NETSCAPE_PLUGIN_API)
161     WEBCORE_EXPORT NPObject* windowScriptNPObject();
162 #endif
163 
164     void initScriptForWindowProxy(JSWindowProxy&amp;);
165 
166     bool willReplaceWithResultOfExecutingJavascriptURL() const { return m_willReplaceWithResultOfExecutingJavascriptURL; }
167 
168 private:





169     void setupModuleScriptHandlers(LoadableModuleScript&amp;, JSC::JSInternalPromise&amp;, DOMWrapperWorld&amp;);
170 
171     void disconnectPlatformScriptObjects();
172 
173     WEBCORE_EXPORT WindowProxy&amp; windowProxy();
174     WEBCORE_EXPORT JSWindowProxy&amp; jsWindowProxy(DOMWrapperWorld&amp;);
175 
176     Frame&amp; m_frame;
177     const String* m_sourceURL;
178 
179     bool m_paused;
180     bool m_willReplaceWithResultOfExecutingJavascriptURL { false };
181 
182     // The root object used for objects bound outside the context of a plugin, such
183     // as NPAPI plugins. The plugins using these objects prevent a page from being cached so they
184     // are safe to invalidate() when WebKit navigates away from the page that contains them.
185     RefPtr&lt;JSC::Bindings::RootObject&gt; m_bindingRootObject;
186     // Unlike m_bindingRootObject these objects are used in pages that are cached, so they are not invalidate()&#39;d.
187     // This ensures they are still available when the page is restored.
188     RefPtr&lt;JSC::Bindings::RootObject&gt; m_cacheableBindingRootObject;
</pre>
</td>
<td>
<hr />
<pre>
  6  *
  7  *  This library is free software; you can redistribute it and/or
  8  *  modify it under the terms of the GNU Lesser General Public
  9  *  License as published by the Free Software Foundation; either
 10  *  version 2 of the License, or (at your option) any later version.
 11  *
 12  *  This library is distributed in the hope that it will be useful,
 13  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  *  Lesser General Public License for more details.
 16  *
 17  *  You should have received a copy of the GNU Lesser General Public
 18  *  License along with this library; if not, write to the Free Software
 19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;FrameLoaderTypes.h&quot;
 25 #include &quot;JSWindowProxy.h&quot;
<span class="line-added"> 26 #include &quot;SerializedScriptValue.h&quot;</span>
 27 #include &quot;WindowProxy.h&quot;
 28 #include &lt;JavaScriptCore/JSBase.h&gt;
 29 #include &lt;JavaScriptCore/Strong.h&gt;
 30 #include &lt;wtf/Forward.h&gt;
<span class="line-added"> 31 #include &lt;wtf/Optional.h&gt;</span>
 32 #include &lt;wtf/RefPtr.h&gt;
 33 #include &lt;wtf/WeakPtr.h&gt;
 34 #include &lt;wtf/text/TextPosition.h&gt;
 35 
 36 #if PLATFORM(COCOA)
 37 #include &lt;wtf/RetainPtr.h&gt;
 38 OBJC_CLASS JSContext;
 39 OBJC_CLASS WebScriptObject;
 40 #endif
 41 
 42 struct NPObject;
 43 
 44 namespace JSC {
<span class="line-modified"> 45 class CallFrame;</span>
 46 class JSGlobalObject;
 47 class JSInternalPromise;
 48 class JSModuleRecord;
 49 
 50 namespace Bindings {
 51 class Instance;
 52 class RootObject;
 53 }
 54 }
 55 
 56 namespace WebCore {
 57 
 58 class CachedScriptFetcher;
 59 class Frame;
 60 class HTMLDocument;
 61 class HTMLPlugInElement;
 62 class LoadableModuleScript;
 63 class ModuleFetchParameters;
 64 class ScriptSourceCode;
 65 class SecurityOrigin;
 66 class Widget;
<span class="line-added"> 67 </span>
<span class="line-added"> 68 enum class RunAsAsyncFunction : bool;</span>
<span class="line-added"> 69 </span>
 70 struct ExceptionDetails;
<span class="line-added"> 71 struct RunJavaScriptParameters;</span>
 72 
 73 enum ReasonForCallingCanExecuteScripts {
 74     AboutToCreateEventListener,
 75     AboutToExecuteScript,
 76     NotAboutToExecuteScript
 77 };
 78 
<span class="line-added"> 79 using ValueOrException = Expected&lt;JSC::JSValue, ExceptionDetails&gt;;</span>
<span class="line-added"> 80 </span>
 81 class ScriptController : public CanMakeWeakPtr&lt;ScriptController&gt; {
 82     WTF_MAKE_FAST_ALLOCATED;
 83 
 84     using RootObjectMap = HashMap&lt;void*, Ref&lt;JSC::Bindings::RootObject&gt;&gt;;
 85 
 86 public:
 87     explicit ScriptController(Frame&amp;);
 88     ~ScriptController();
 89 
<span class="line-modified"> 90     enum class WorldType { User, Internal };</span>
<span class="line-added"> 91     WEBCORE_EXPORT static Ref&lt;DOMWrapperWorld&gt; createWorld(const String&amp; name, WorldType = WorldType::Internal);</span>
 92 
 93     JSDOMWindow* globalObject(DOMWrapperWorld&amp; world)
 94     {
 95         return JSC::jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy(world).window());
 96     }
 97 
 98     static void getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp;);
 99 
<span class="line-modified">100     using ResolveFunction = CompletionHandler&lt;void(ValueOrException)&gt;;</span>



101 
<span class="line-modified">102     WEBCORE_EXPORT JSC::JSValue executeScriptIgnoringException(const String&amp; script, bool forceUserGesture = false);</span>
<span class="line-added">103     WEBCORE_EXPORT JSC::JSValue executeScriptInWorldIgnoringException(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture = false);</span>
<span class="line-added">104     WEBCORE_EXPORT JSC::JSValue executeUserAgentScriptInWorldIgnoringException(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture);</span>
<span class="line-added">105     WEBCORE_EXPORT ValueOrException executeUserAgentScriptInWorld(DOMWrapperWorld&amp;, const String&amp; script, bool forceUserGesture);</span>
<span class="line-added">106     WEBCORE_EXPORT void executeAsynchronousUserAgentScriptInWorld(DOMWrapperWorld&amp;, RunJavaScriptParameters&amp;&amp;, ResolveFunction&amp;&amp;);</span>
<span class="line-added">107     JSC::JSValue evaluateIgnoringException(const ScriptSourceCode&amp;);</span>
<span class="line-added">108     JSC::JSValue evaluateInWorldIgnoringException(const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-added">109 </span>
<span class="line-added">110     Expected&lt;void, ExceptionDetails&gt; shouldAllowUserAgentScripts(Document&amp;) const;</span>
111 
112     // Returns true if argument is a JavaScript URL.
<span class="line-modified">113     bool executeIfJavaScriptURL(const URL&amp;, RefPtr&lt;SecurityOrigin&gt; = nullptr, ShouldReplaceDocumentIfJavaScriptURL = ReplaceDocumentIfJavaScriptURL);</span>
114 
115     // This function must be called from the main thread. It is safe to call it repeatedly.
116     // Darwin is an exception to this rule: it is OK to call this function from any thread, even reentrantly.
117     static void initializeThreading();
118 



119     void loadModuleScriptInWorld(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;, DOMWrapperWorld&amp;);
120     void loadModuleScript(LoadableModuleScript&amp;, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp;);
121     void loadModuleScriptInWorld(LoadableModuleScript&amp;, const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);
122     void loadModuleScript(LoadableModuleScript&amp;, const ScriptSourceCode&amp;);
123 
124     JSC::JSValue linkAndEvaluateModuleScriptInWorld(LoadableModuleScript&amp; , DOMWrapperWorld&amp;);
125     JSC::JSValue linkAndEvaluateModuleScript(LoadableModuleScript&amp;);
126 
127     JSC::JSValue evaluateModule(const URL&amp;, JSC::JSModuleRecord&amp;, DOMWrapperWorld&amp;);
128     JSC::JSValue evaluateModule(const URL&amp;, JSC::JSModuleRecord&amp;);
129 
130     WTF::TextPosition eventHandlerPosition() const;
131 
132     void enableEval();
133     void enableWebAssembly();
134     void disableEval(const String&amp; errorMessage);
135     void disableWebAssembly(const String&amp; errorMessage);
136 
137     static bool canAccessFromCurrentOrigin(Frame*, Document&amp; accessingDocument);
138     WEBCORE_EXPORT bool canExecuteScripts(ReasonForCallingCanExecuteScripts);
</pre>
<hr />
<pre>
142 
143     const String* sourceURL() const { return m_sourceURL; } // 0 if we are not evaluating any script
144 
145     void updateDocument();
146 
147     void namedItemAdded(HTMLDocument*, const AtomString&amp;) { }
148     void namedItemRemoved(HTMLDocument*, const AtomString&amp;) { }
149 
150     void clearScriptObjects();
151     WEBCORE_EXPORT void cleanupScriptObjectsForPlugin(void*);
152 
153     void updatePlatformScriptObjects();
154 
155     RefPtr&lt;JSC::Bindings::Instance&gt;  createScriptInstanceForWidget(Widget*);
156     WEBCORE_EXPORT JSC::Bindings::RootObject* bindingRootObject();
157     JSC::Bindings::RootObject* cacheableBindingRootObject();
158     JSC::Bindings::RootObject* existingCacheableBindingRootObject() const { return m_cacheableBindingRootObject.get(); }
159 
160     WEBCORE_EXPORT Ref&lt;JSC::Bindings::RootObject&gt; createRootObject(void* nativeHandle);
161 
<span class="line-modified">162     void collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::JSGlobalObject*, SecurityOrigin*&gt;&gt;&amp;);</span>
163 
164 #if PLATFORM(COCOA)
165     WEBCORE_EXPORT WebScriptObject* windowScriptObject();
166     WEBCORE_EXPORT JSContext *javaScriptContext();
167 #endif
168 
169     WEBCORE_EXPORT JSC::JSObject* jsObjectForPluginElement(HTMLPlugInElement*);
170 
171 #if ENABLE(NETSCAPE_PLUGIN_API)
172     WEBCORE_EXPORT NPObject* windowScriptNPObject();
173 #endif
174 
175     void initScriptForWindowProxy(JSWindowProxy&amp;);
176 
177     bool willReplaceWithResultOfExecutingJavascriptURL() const { return m_willReplaceWithResultOfExecutingJavascriptURL; }
178 
179 private:
<span class="line-added">180     ValueOrException executeUserAgentScriptInWorldInternal(DOMWrapperWorld&amp;, RunJavaScriptParameters&amp;&amp;);</span>
<span class="line-added">181     ValueOrException executeScriptInWorld(DOMWrapperWorld&amp;, RunJavaScriptParameters&amp;&amp;);</span>
<span class="line-added">182     ValueOrException evaluateInWorld(const ScriptSourceCode&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-added">183     ValueOrException callInWorld(RunJavaScriptParameters&amp;&amp;, DOMWrapperWorld&amp;);</span>
<span class="line-added">184 </span>
185     void setupModuleScriptHandlers(LoadableModuleScript&amp;, JSC::JSInternalPromise&amp;, DOMWrapperWorld&amp;);
186 
187     void disconnectPlatformScriptObjects();
188 
189     WEBCORE_EXPORT WindowProxy&amp; windowProxy();
190     WEBCORE_EXPORT JSWindowProxy&amp; jsWindowProxy(DOMWrapperWorld&amp;);
191 
192     Frame&amp; m_frame;
193     const String* m_sourceURL;
194 
195     bool m_paused;
196     bool m_willReplaceWithResultOfExecutingJavascriptURL { false };
197 
198     // The root object used for objects bound outside the context of a plugin, such
199     // as NPAPI plugins. The plugins using these objects prevent a page from being cached so they
200     // are safe to invalidate() when WebKit navigates away from the page that contains them.
201     RefPtr&lt;JSC::Bindings::RootObject&gt; m_bindingRootObject;
202     // Unlike m_bindingRootObject these objects are used in pages that are cached, so they are not invalidate()&#39;d.
203     // This ensures they are still available when the page is restored.
204     RefPtr&lt;JSC::Bindings::RootObject&gt; m_cacheableBindingRootObject;
</pre>
</td>
</tr>
</table>
<center><a href="ScriptController.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptModuleLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSNativeStdFunction.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSONObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  #include &quot;BigIntObject.h&quot;
  #include &quot;BooleanObject.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;JSArray.h&quot;
<span class="line-added">+ #include &quot;JSArrayInlines.h&quot;</span>
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;LiteralParser.h&quot;
  #include &quot;Lookup.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;JSCInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 43,12 ***</span>
  
  namespace JSC {
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSONObject);
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(ExecState*);</span>
  
  }
  
  #include &quot;JSONObject.lut.h&quot;
  
<span class="line-new-header">--- 44,12 ---</span>
  
  namespace JSC {
  
  STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSONObject);
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject*, CallFrame*);</span>
  
  }
  
  #include &quot;JSONObject.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,20 ***</span>
  void JSONObject::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  
<span class="line-modified">!     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsString(vm, &quot;JSON&quot;), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);</span>
  }
  
  // PropertyNameForFunctionCall objects must be on the stack, since the JSValue that they create is not marked.
  class PropertyNameForFunctionCall {
  public:
      PropertyNameForFunctionCall(const Identifier&amp;);
      PropertyNameForFunctionCall(unsigned);
  
<span class="line-modified">!     JSValue value(ExecState*) const;</span>
  
  private:
      const Identifier* m_identifier;
      unsigned m_number;
      mutable JSValue m_value;
<span class="line-new-header">--- 63,20 ---</span>
  void JSONObject::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  
<span class="line-modified">!     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsNontrivialString(vm, &quot;JSON&quot;_s), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);</span>
  }
  
  // PropertyNameForFunctionCall objects must be on the stack, since the JSValue that they create is not marked.
  class PropertyNameForFunctionCall {
  public:
      PropertyNameForFunctionCall(const Identifier&amp;);
      PropertyNameForFunctionCall(unsigned);
  
<span class="line-modified">!     JSValue value(JSGlobalObject*) const;</span>
  
  private:
      const Identifier* m_identifier;
      unsigned m_number;
      mutable JSValue m_value;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,18 ***</span>
  
  class Stringifier {
      WTF_MAKE_NONCOPYABLE(Stringifier);
      WTF_FORBID_HEAP_ALLOCATION;
  public:
<span class="line-modified">!     Stringifier(ExecState*, JSValue replacer, JSValue space);</span>
      JSValue stringify(JSValue);
  
  private:
      class Holder {
      public:
          enum RootHolderTag { RootHolder };
<span class="line-modified">!         Holder(ExecState*, JSObject*);</span>
          Holder(RootHolderTag, JSObject*);
  
          JSObject* object() const { return m_object; }
          bool isArray() const { return m_isArray; }
  
<span class="line-new-header">--- 84,18 ---</span>
  
  class Stringifier {
      WTF_MAKE_NONCOPYABLE(Stringifier);
      WTF_FORBID_HEAP_ALLOCATION;
  public:
<span class="line-modified">!     Stringifier(JSGlobalObject*, JSValue replacer, JSValue space);</span>
      JSValue stringify(JSValue);
  
  private:
      class Holder {
      public:
          enum RootHolderTag { RootHolder };
<span class="line-modified">!         Holder(JSGlobalObject*, JSObject*);</span>
          Holder(RootHolderTag, JSObject*);
  
          JSObject* object() const { return m_object; }
          bool isArray() const { return m_isArray; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
      void indent();
      void unindent();
      void startNewLine(StringBuilder&amp;) const;
      bool isCallableReplacer() const { return m_replacerCallType != CallType::None; }
  
<span class="line-modified">!     ExecState* const m_exec;</span>
      JSValue m_replacer;
      bool m_usingArrayReplacer { false };
      PropertyNameArray m_arrayReplacerPropertyNames;
      CallType m_replacerCallType { CallType::None };
      CallData m_replacerCallData;
<span class="line-new-header">--- 122,11 ---</span>
      void indent();
      void unindent();
      void startNewLine(StringBuilder&amp;) const;
      bool isCallableReplacer() const { return m_replacerCallType != CallType::None; }
  
<span class="line-modified">!     JSGlobalObject* const m_globalObject;</span>
      JSValue m_replacer;
      bool m_usingArrayReplacer { false };
      PropertyNameArray m_arrayReplacerPropertyNames;
      CallType m_replacerCallType { CallType::None };
      CallData m_replacerCallData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,35 ***</span>
      String m_indent;
  };
  
  // ------------------------------ helper functions --------------------------------
  
<span class="line-modified">! static inline JSValue unwrapBoxedPrimitive(ExecState* exec, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      if (!value.isObject())
          return value;
      JSObject* object = asObject(value);
      if (object-&gt;inherits&lt;NumberObject&gt;(vm))
<span class="line-modified">!         return jsNumber(object-&gt;toNumber(exec));</span>
      if (object-&gt;inherits&lt;StringObject&gt;(vm))
<span class="line-modified">!         return object-&gt;toString(exec);</span>
      if (object-&gt;inherits&lt;BooleanObject&gt;(vm) || object-&gt;inherits&lt;BigIntObject&gt;(vm))
          return jsCast&lt;JSWrapperObject*&gt;(object)-&gt;internalValue();
  
      // Do not unwrap SymbolObject to Symbol. It is not performed in the spec.
      // http://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonproperty
      return value;
  }
  
<span class="line-modified">! static inline String gap(ExecState* exec, JSValue space)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const unsigned maxGapLength = 10;
<span class="line-modified">!     space = unwrapBoxedPrimitive(exec, space);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // If the space value is a number, create a gap string with that number of spaces.
      if (space.isNumber()) {
          double spaceCount = space.asNumber();
<span class="line-new-header">--- 138,35 ---</span>
      String m_indent;
  };
  
  // ------------------------------ helper functions --------------------------------
  
<span class="line-modified">! static inline JSValue unwrapBoxedPrimitive(JSGlobalObject* globalObject, JSValue value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      if (!value.isObject())
          return value;
      JSObject* object = asObject(value);
      if (object-&gt;inherits&lt;NumberObject&gt;(vm))
<span class="line-modified">!         return jsNumber(object-&gt;toNumber(globalObject));</span>
      if (object-&gt;inherits&lt;StringObject&gt;(vm))
<span class="line-modified">!         return object-&gt;toString(globalObject);</span>
      if (object-&gt;inherits&lt;BooleanObject&gt;(vm) || object-&gt;inherits&lt;BigIntObject&gt;(vm))
          return jsCast&lt;JSWrapperObject*&gt;(object)-&gt;internalValue();
  
      // Do not unwrap SymbolObject to Symbol. It is not performed in the spec.
      // http://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonproperty
      return value;
  }
  
<span class="line-modified">! static inline String gap(JSGlobalObject* globalObject, JSValue space)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const unsigned maxGapLength = 10;
<span class="line-modified">!     space = unwrapBoxedPrimitive(globalObject, space);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // If the space value is a number, create a gap string with that number of spaces.
      if (space.isNumber()) {
          double spaceCount = space.asNumber();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,11 ***</span>
              spaces[i] = &#39; &#39;;
          return String(spaces, count);
      }
  
      // If the space value is a string, use it as the gap string, otherwise use no gap string.
<span class="line-modified">!     String spaces = space.getString(exec);</span>
      if (spaces.length() &lt;= maxGapLength)
          return spaces;
      return spaces.substringSharingImpl(0, maxGapLength);
  }
  
<span class="line-new-header">--- 182,12 ---</span>
              spaces[i] = &#39; &#39;;
          return String(spaces, count);
      }
  
      // If the space value is a string, use it as the gap string, otherwise use no gap string.
<span class="line-modified">!     String spaces = space.getString(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
      if (spaces.length() &lt;= maxGapLength)
          return spaces;
      return spaces.substringSharingImpl(0, maxGapLength);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,14 ***</span>
      : m_identifier(0)
      , m_number(number)
  {
  }
  
<span class="line-modified">! JSValue PropertyNameForFunctionCall::value(ExecState* exec) const</span>
  {
      if (!m_value) {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          if (m_identifier)
              m_value = jsString(vm, m_identifier-&gt;string());
          else {
              if (m_number &lt;= 9)
                  return vm.smallStrings.singleCharacterString(m_number + &#39;0&#39;);
<span class="line-new-header">--- 202,14 ---</span>
      : m_identifier(0)
      , m_number(number)
  {
  }
  
<span class="line-modified">! JSValue PropertyNameForFunctionCall::value(JSGlobalObject* globalObject) const</span>
  {
      if (!m_value) {
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          if (m_identifier)
              m_value = jsString(vm, m_identifier-&gt;string());
          else {
              if (m_number &lt;= 9)
                  return vm.smallStrings.singleCharacterString(m_number + &#39;0&#39;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,94 ***</span>
      return m_value;
  }
  
  // ------------------------------ Stringifier --------------------------------
  
<span class="line-modified">! Stringifier::Stringifier(ExecState* exec, JSValue replacer, JSValue space)</span>
<span class="line-modified">!     : m_exec(exec)</span>
      , m_replacer(replacer)
<span class="line-modified">!     , m_arrayReplacerPropertyNames(exec-&gt;vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (m_replacer.isObject()) {
          JSObject* replacerObject = asObject(m_replacer);
  
          m_replacerCallType = CallType::None;
          if (!replacerObject-&gt;isCallable(vm, m_replacerCallType, m_replacerCallData)) {
<span class="line-modified">!             bool isArrayReplacer = JSC::isArray(exec, replacerObject);</span>
              RETURN_IF_EXCEPTION(scope, );
              if (isArrayReplacer) {
                  m_usingArrayReplacer = true;
<span class="line-modified">!                 unsigned length = replacerObject-&gt;get(exec, vm.propertyNames-&gt;length).toUInt32(exec);</span>
                  RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">!                 for (unsigned i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">!                     JSValue name = replacerObject-&gt;get(exec, i);</span>
<span class="line-modified">!                     RETURN_IF_EXCEPTION(scope, );</span>
                      if (name.isObject()) {
                          auto* nameObject = jsCast&lt;JSObject*&gt;(name);
                          if (!nameObject-&gt;inherits&lt;NumberObject&gt;(vm) &amp;&amp; !nameObject-&gt;inherits&lt;StringObject&gt;(vm))
                              continue;
                      } else if (!name.isNumber() &amp;&amp; !name.isString())
                          continue;
<span class="line-modified">!                     JSString* propertyNameString = name.toString(exec);</span>
                      RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">!                     auto propertyName = propertyNameString-&gt;toIdentifier(exec);</span>
                      RETURN_IF_EXCEPTION(scope, );
                      m_arrayReplacerPropertyNames.add(WTFMove(propertyName));
                  }
              }
          }
      }
  
      scope.release();
<span class="line-modified">!     m_gap = gap(exec, space);</span>
  }
  
  JSValue Stringifier::stringify(JSValue value)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      PropertyNameForFunctionCall emptyPropertyName(vm.propertyNames-&gt;emptyIdentifier);
  
      // If the replacer is not callable, root object wrapper is non-user-observable.
      // We can skip creating this wrapper object.
      JSObject* object = nullptr;
      if (isCallableReplacer()) {
<span class="line-modified">!         object = constructEmptyObject(m_exec);</span>
<span class="line-removed">-         RETURN_IF_EXCEPTION(scope, jsUndefined());</span>
          object-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, value);
      }
  
      StringBuilder result(StringBuilder::OverflowHandler::RecordOverflow);
      Holder root(Holder::RootHolder, object);
      auto stringifyResult = appendStringifiedValue(result, value, root, emptyPropertyName);
      RETURN_IF_EXCEPTION(scope, jsUndefined());
      if (UNLIKELY(result.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(m_exec, scope);</span>
          return jsUndefined();
      }
      if (UNLIKELY(stringifyResult != StringifySucceeded))
          return jsUndefined();
      RELEASE_AND_RETURN(scope, jsString(vm, result.toString()));
  }
  
  ALWAYS_INLINE JSValue Stringifier::toJSON(JSValue baseValue, const PropertyNameForFunctionCall&amp; propertyName)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      scope.assertNoException();
  
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     bool hasProperty = baseValue.getPropertySlot(m_exec, vm.propertyNames-&gt;toJSON, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (!hasProperty)
          return baseValue;
  
<span class="line-modified">!     JSValue toJSONFunction = slot.getValue(m_exec, vm.propertyNames-&gt;toJSON);</span>
      RETURN_IF_EXCEPTION(scope, { });
      RELEASE_AND_RETURN(scope, toJSONImpl(vm, baseValue, toJSONFunction, propertyName));
  }
  
  JSValue Stringifier::toJSONImpl(VM&amp; vm, JSValue baseValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp; propertyName)
<span class="line-new-header">--- 219,98 ---</span>
      return m_value;
  }
  
  // ------------------------------ Stringifier --------------------------------
  
<span class="line-modified">! Stringifier::Stringifier(JSGlobalObject* globalObject, JSValue replacer, JSValue space)</span>
<span class="line-modified">!     : m_globalObject(globalObject)</span>
      , m_replacer(replacer)
<span class="line-modified">!     , m_arrayReplacerPropertyNames(globalObject-&gt;vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (m_replacer.isObject()) {
          JSObject* replacerObject = asObject(m_replacer);
  
          m_replacerCallType = CallType::None;
          if (!replacerObject-&gt;isCallable(vm, m_replacerCallType, m_replacerCallData)) {
<span class="line-modified">!             bool isArrayReplacer = JSC::isArray(globalObject, replacerObject);</span>
              RETURN_IF_EXCEPTION(scope, );
              if (isArrayReplacer) {
                  m_usingArrayReplacer = true;
<span class="line-modified">!                 unsigned length = toLength(globalObject, replacerObject);</span>
                  RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">!                 for (unsigned index = 0; index &lt; length; ++index) {</span>
<span class="line-modified">!                     JSValue name;</span>
<span class="line-modified">!                     if (isJSArray(replacerObject) &amp;&amp; replacerObject-&gt;canGetIndexQuickly(index))</span>
<span class="line-added">+                         name = replacerObject-&gt;getIndexQuickly(index);</span>
<span class="line-added">+                     else {</span>
<span class="line-added">+                         name = replacerObject-&gt;get(globalObject, index);</span>
<span class="line-added">+                         RETURN_IF_EXCEPTION(scope, );</span>
<span class="line-added">+                     }</span>
                      if (name.isObject()) {
                          auto* nameObject = jsCast&lt;JSObject*&gt;(name);
                          if (!nameObject-&gt;inherits&lt;NumberObject&gt;(vm) &amp;&amp; !nameObject-&gt;inherits&lt;StringObject&gt;(vm))
                              continue;
                      } else if (!name.isNumber() &amp;&amp; !name.isString())
                          continue;
<span class="line-modified">!                     JSString* propertyNameString = name.toString(globalObject);</span>
                      RETURN_IF_EXCEPTION(scope, );
<span class="line-modified">!                     auto propertyName = propertyNameString-&gt;toIdentifier(globalObject);</span>
                      RETURN_IF_EXCEPTION(scope, );
                      m_arrayReplacerPropertyNames.add(WTFMove(propertyName));
                  }
              }
          }
      }
  
      scope.release();
<span class="line-modified">!     m_gap = gap(globalObject, space);</span>
  }
  
  JSValue Stringifier::stringify(JSValue value)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      PropertyNameForFunctionCall emptyPropertyName(vm.propertyNames-&gt;emptyIdentifier);
  
      // If the replacer is not callable, root object wrapper is non-user-observable.
      // We can skip creating this wrapper object.
      JSObject* object = nullptr;
      if (isCallableReplacer()) {
<span class="line-modified">!         object = constructEmptyObject(m_globalObject);</span>
          object-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, value);
      }
  
      StringBuilder result(StringBuilder::OverflowHandler::RecordOverflow);
      Holder root(Holder::RootHolder, object);
      auto stringifyResult = appendStringifiedValue(result, value, root, emptyPropertyName);
      RETURN_IF_EXCEPTION(scope, jsUndefined());
      if (UNLIKELY(result.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(m_globalObject, scope);</span>
          return jsUndefined();
      }
      if (UNLIKELY(stringifyResult != StringifySucceeded))
          return jsUndefined();
      RELEASE_AND_RETURN(scope, jsString(vm, result.toString()));
  }
  
  ALWAYS_INLINE JSValue Stringifier::toJSON(JSValue baseValue, const PropertyNameForFunctionCall&amp; propertyName)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      scope.assertNoException();
  
      PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     bool hasProperty = baseValue.getPropertySlot(m_globalObject, vm.propertyNames-&gt;toJSON, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (!hasProperty)
          return baseValue;
  
<span class="line-modified">!     JSValue toJSONFunction = slot.getValue(m_globalObject, vm.propertyNames-&gt;toJSON);</span>
      RETURN_IF_EXCEPTION(scope, { });
      RELEASE_AND_RETURN(scope, toJSONImpl(vm, baseValue, toJSONFunction, propertyName));
  }
  
  JSValue Stringifier::toJSONImpl(VM&amp; vm, JSValue baseValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp; propertyName)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,18 ***</span>
      CallData callData;
      if (!toJSONFunction.isCallable(vm, callType, callData))
          return baseValue;
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(propertyName.value(m_exec));</span>
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     return call(m_exec, asObject(toJSONFunction), callType, callData, baseValue, args);</span>
  }
  
  Stringifier::StringifyResult Stringifier::appendStringifiedValue(StringBuilder&amp; builder, JSValue value, const Holder&amp; holder, const PropertyNameForFunctionCall&amp; propertyName)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // Call the toJSON function.
      if (value.isObject() || value.isBigInt()) {
          value = toJSON(value, propertyName);
<span class="line-new-header">--- 319,18 ---</span>
      CallData callData;
      if (!toJSONFunction.isCallable(vm, callType, callData))
          return baseValue;
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(propertyName.value(m_globalObject));</span>
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     return call(m_globalObject, asObject(toJSONFunction), callType, callData, baseValue, args);</span>
  }
  
  Stringifier::StringifyResult Stringifier::appendStringifiedValue(StringBuilder&amp; builder, JSValue value, const Holder&amp; holder, const PropertyNameForFunctionCall&amp; propertyName)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // Call the toJSON function.
      if (value.isObject() || value.isBigInt()) {
          value = toJSON(value, propertyName);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,15 ***</span>
      }
  
      // Call the replacer function.
      if (isCallableReplacer()) {
          MarkedArgumentBuffer args;
<span class="line-modified">!         args.append(propertyName.value(m_exec));</span>
          args.append(value);
          ASSERT(!args.hasOverflowed());
          ASSERT(holder.object());
<span class="line-modified">!         value = call(m_exec, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);</span>
          RETURN_IF_EXCEPTION(scope, StringifyFailed);
      }
  
      if ((value.isUndefined() || value.isSymbol()) &amp;&amp; !holder.isArray())
          return StringifyFailedDueToUndefinedOrSymbolValue;
<span class="line-new-header">--- 338,15 ---</span>
      }
  
      // Call the replacer function.
      if (isCallableReplacer()) {
          MarkedArgumentBuffer args;
<span class="line-modified">!         args.append(propertyName.value(m_globalObject));</span>
          args.append(value);
          ASSERT(!args.hasOverflowed());
          ASSERT(holder.object());
<span class="line-modified">!         value = call(m_globalObject, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);</span>
          RETURN_IF_EXCEPTION(scope, StringifyFailed);
      }
  
      if ((value.isUndefined() || value.isSymbol()) &amp;&amp; !holder.isArray())
          return StringifyFailedDueToUndefinedOrSymbolValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,11 ***</span>
      if (value.isNull()) {
          builder.appendLiteral(&quot;null&quot;);
          return StringifySucceeded;
      }
  
<span class="line-modified">!     value = unwrapBoxedPrimitive(m_exec, value);</span>
  
      RETURN_IF_EXCEPTION(scope, StringifyFailed);
  
      if (value.isBoolean()) {
          if (value.isTrue())
<span class="line-new-header">--- 354,11 ---</span>
      if (value.isNull()) {
          builder.appendLiteral(&quot;null&quot;);
          return StringifySucceeded;
      }
  
<span class="line-modified">!     value = unwrapBoxedPrimitive(m_globalObject, value);</span>
  
      RETURN_IF_EXCEPTION(scope, StringifyFailed);
  
      if (value.isBoolean()) {
          if (value.isTrue())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,11 ***</span>
              builder.appendLiteral(&quot;false&quot;);
          return StringifySucceeded;
      }
  
      if (value.isString()) {
<span class="line-modified">!         const String&amp; string = asString(value)-&gt;value(m_exec);</span>
          RETURN_IF_EXCEPTION(scope, StringifyFailed);
          builder.appendQuotedJSONString(string);
          return StringifySucceeded;
      }
  
<span class="line-new-header">--- 367,11 ---</span>
              builder.appendLiteral(&quot;false&quot;);
          return StringifySucceeded;
      }
  
      if (value.isString()) {
<span class="line-modified">!         const String&amp; string = asString(value)-&gt;value(m_globalObject);</span>
          RETURN_IF_EXCEPTION(scope, StringifyFailed);
          builder.appendQuotedJSONString(string);
          return StringifySucceeded;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,11 ***</span>
          }
          return StringifySucceeded;
      }
  
      if (value.isBigInt()) {
<span class="line-modified">!         throwTypeError(m_exec, scope, &quot;JSON.stringify cannot serialize BigInt.&quot;_s);</span>
          return StringifyFailed;
      }
  
      if (!value.isObject())
          return StringifyFailed;
<span class="line-new-header">--- 387,11 ---</span>
          }
          return StringifySucceeded;
      }
  
      if (value.isBigInt()) {
<span class="line-modified">!         throwTypeError(m_globalObject, scope, &quot;JSON.stringify cannot serialize BigInt.&quot;_s);</span>
          return StringifyFailed;
      }
  
      if (!value.isObject())
          return StringifyFailed;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,17 ***</span>
          return StringifyFailed;
  
      // Handle cycle detection, and put the holder on the stack.
      for (unsigned i = 0; i &lt; m_holderStack.size(); i++) {
          if (m_holderStack[i].object() == object) {
<span class="line-modified">!             throwTypeError(m_exec, scope, &quot;JSON.stringify cannot serialize cyclic structures.&quot;_s);</span>
              return StringifyFailed;
          }
      }
  
      bool holderStackWasEmpty = m_holderStack.isEmpty();
<span class="line-modified">!     m_holderStack.append(Holder(m_exec, object));</span>
      m_objectStack.appendWithCrashOnOverflow(object);
      RETURN_IF_EXCEPTION(scope, StringifyFailed);
      if (!holderStackWasEmpty)
          return StringifySucceeded;
  
<span class="line-new-header">--- 409,17 ---</span>
          return StringifyFailed;
  
      // Handle cycle detection, and put the holder on the stack.
      for (unsigned i = 0; i &lt; m_holderStack.size(); i++) {
          if (m_holderStack[i].object() == object) {
<span class="line-modified">!             throwTypeError(m_globalObject, scope, &quot;JSON.stringify cannot serialize cyclic structures.&quot;_s);</span>
              return StringifyFailed;
          }
      }
  
      bool holderStackWasEmpty = m_holderStack.isEmpty();
<span class="line-modified">!     m_holderStack.append(Holder(m_globalObject, object));</span>
      m_objectStack.appendWithCrashOnOverflow(object);
      RETURN_IF_EXCEPTION(scope, StringifyFailed);
      if (!holderStackWasEmpty)
          return StringifySucceeded;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 456,14 ***</span>
          return;
      builder.append(&#39;\n&#39;);
      builder.append(m_indent);
  }
  
<span class="line-modified">! inline Stringifier::Holder::Holder(ExecState* exec, JSObject* object)</span>
      : m_object(object)
      , m_isJSArray(isJSArray(object))
<span class="line-modified">!     , m_isArray(JSC::isArray(exec, object))</span>
  {
  }
  
  inline Stringifier::Holder::Holder(RootHolderTag, JSObject* object)
      : m_object(object)
<span class="line-new-header">--- 462,14 ---</span>
          return;
      builder.append(&#39;\n&#39;);
      builder.append(m_indent);
  }
  
<span class="line-modified">! inline Stringifier::Holder::Holder(JSGlobalObject* globalObject, JSObject* object)</span>
      : m_object(object)
      , m_isJSArray(isJSArray(object))
<span class="line-modified">!     , m_isArray(JSC::isArray(globalObject, object))</span>
  {
  }
  
  inline Stringifier::Holder::Holder(RootHolderTag, JSObject* object)
      : m_object(object)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,32 ***</span>
  
  bool Stringifier::Holder::appendNextProperty(Stringifier&amp; stringifier, StringBuilder&amp; builder)
  {
      ASSERT(m_index &lt;= m_size);
  
<span class="line-modified">!     ExecState* exec = stringifier.m_exec;</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // First time through, initialize.
      if (!m_index) {
          if (m_isArray) {
<span class="line-modified">!             if (m_isJSArray)</span>
<span class="line-modified">!                 m_size = asArray(m_object)-&gt;length();</span>
<span class="line-removed">-             else {</span>
<span class="line-removed">-                 JSValue value = m_object-&gt;get(exec, vm.propertyNames-&gt;length);</span>
<span class="line-removed">-                 RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-removed">-                 m_size = value.toUInt32(exec);</span>
<span class="line-removed">-                 RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-removed">-             }</span>
              builder.append(&#39;[&#39;);
          } else {
              if (stringifier.m_usingArrayReplacer)
                  m_propertyNames = stringifier.m_arrayReplacerPropertyNames.data();
              else {
                  PropertyNameArray objectPropertyNames(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!                 m_object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(m_object, exec, objectPropertyNames, EnumerationMode());</span>
                  RETURN_IF_EXCEPTION(scope, false);
                  m_propertyNames = objectPropertyNames.releaseData();
              }
              m_size = m_propertyNames-&gt;propertyNameVector().size();
              builder.append(&#39;{&#39;);
<span class="line-new-header">--- 480,26 ---</span>
  
  bool Stringifier::Holder::appendNextProperty(Stringifier&amp; stringifier, StringBuilder&amp; builder)
  {
      ASSERT(m_index &lt;= m_size);
  
<span class="line-modified">!     JSGlobalObject* globalObject = stringifier.m_globalObject;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // First time through, initialize.
      if (!m_index) {
          if (m_isArray) {
<span class="line-modified">!             m_size = toLength(globalObject, m_object);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, false);</span>
              builder.append(&#39;[&#39;);
          } else {
              if (stringifier.m_usingArrayReplacer)
                  m_propertyNames = stringifier.m_arrayReplacerPropertyNames.data();
              else {
                  PropertyNameArray objectPropertyNames(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!                 m_object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(m_object, globalObject, objectPropertyNames, EnumerationMode());</span>
                  RETURN_IF_EXCEPTION(scope, false);
                  m_propertyNames = objectPropertyNames.releaseData();
              }
              m_size = m_propertyNames-&gt;propertyNameVector().size();
              builder.append(&#39;{&#39;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,18 ***</span>
      unsigned rollBackPoint = 0;
      StringifyResult stringifyResult;
      if (m_isArray) {
          // Get the value.
          JSValue value;
<span class="line-modified">!         if (m_isJSArray &amp;&amp; asArray(m_object)-&gt;canGetIndexQuickly(index))</span>
<span class="line-modified">!             value = asArray(m_object)-&gt;getIndexQuickly(index);</span>
          else {
              PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!             bool hasProperty = m_object-&gt;getPropertySlot(exec, index, slot);</span>
              EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
              if (hasProperty)
<span class="line-modified">!                 value = slot.getValue(exec, index);</span>
              else
                  value = jsUndefined();
              RETURN_IF_EXCEPTION(scope, false);
          }
  
<span class="line-new-header">--- 523,18 ---</span>
      unsigned rollBackPoint = 0;
      StringifyResult stringifyResult;
      if (m_isArray) {
          // Get the value.
          JSValue value;
<span class="line-modified">!         if (m_isJSArray &amp;&amp; m_object-&gt;canGetIndexQuickly(index))</span>
<span class="line-modified">!             value = m_object-&gt;getIndexQuickly(index);</span>
          else {
              PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!             bool hasProperty = m_object-&gt;getPropertySlot(globalObject, index, slot);</span>
              EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
              if (hasProperty)
<span class="line-modified">!                 value = slot.getValue(globalObject, index);</span>
              else
                  value = jsUndefined();
              RETURN_IF_EXCEPTION(scope, false);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,15 ***</span>
          ASSERT(stringifyResult != StringifyFailedDueToUndefinedOrSymbolValue);
      } else {
          // Get the value.
          PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
          Identifier&amp; propertyName = m_propertyNames-&gt;propertyNameVector()[index];
<span class="line-modified">!         bool hasProperty = m_object-&gt;getPropertySlot(exec, propertyName, slot);</span>
          EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
          if (!hasProperty)
              return true;
<span class="line-modified">!         JSValue value = slot.getValue(exec, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, false);
  
          rollBackPoint = builder.length();
  
          // Append the separator string.
<span class="line-new-header">--- 548,15 ---</span>
          ASSERT(stringifyResult != StringifyFailedDueToUndefinedOrSymbolValue);
      } else {
          // Get the value.
          PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
          Identifier&amp; propertyName = m_propertyNames-&gt;propertyNameVector()[index];
<span class="line-modified">!         bool hasProperty = m_object-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
          EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
          if (!hasProperty)
              return true;
<span class="line-modified">!         JSValue value = slot.getValue(globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, false);
  
          rollBackPoint = builder.length();
  
          // Append the separator string.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,12 ***</span>
  
  class Walker {
      WTF_MAKE_NONCOPYABLE(Walker);
      WTF_FORBID_HEAP_ALLOCATION;
  public:
<span class="line-modified">!     Walker(ExecState* exec, JSObject* function, CallType callType, CallData callData)</span>
<span class="line-modified">!         : m_exec(exec)</span>
          , m_function(function)
          , m_callType(callType)
          , m_callData(callData)
      {
      }
<span class="line-new-header">--- 611,12 ---</span>
  
  class Walker {
      WTF_MAKE_NONCOPYABLE(Walker);
      WTF_FORBID_HEAP_ALLOCATION;
  public:
<span class="line-modified">!     Walker(JSGlobalObject* globalObject, JSObject* function, CallType callType, CallData callData)</span>
<span class="line-modified">!         : m_globalObject(globalObject)</span>
          , m_function(function)
          , m_callType(callType)
          , m_callData(callData)
      {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,28 ***</span>
      {
          MarkedArgumentBuffer args;
          args.append(property);
          args.append(unfiltered);
          ASSERT(!args.hasOverflowed());
<span class="line-modified">!         return call(m_exec, m_function, m_callType, m_callData, thisObj, args);</span>
      }
  
      friend class Holder;
  
<span class="line-modified">!     ExecState* m_exec;</span>
      JSObject* m_function;
      CallType m_callType;
      CallData m_callData;
  };
  
  // We clamp recursion well beyond anything reasonable.
<span class="line-modified">! static const unsigned maximumFilterRecursion = 40000;</span>
  enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
                                   ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember };
  NEVER_INLINE JSValue Walker::walk(JSValue unfiltered)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Vector&lt;PropertyNameArray, 16, UnsafeVectorOverflow&gt; propertyStack;
      Vector&lt;uint32_t, 16, UnsafeVectorOverflow&gt; indexStack;
      MarkedArgumentBuffer markedStack;
<span class="line-new-header">--- 626,28 ---</span>
      {
          MarkedArgumentBuffer args;
          args.append(property);
          args.append(unfiltered);
          ASSERT(!args.hasOverflowed());
<span class="line-modified">!         return call(m_globalObject, m_function, m_callType, m_callData, thisObj, args);</span>
      }
  
      friend class Holder;
  
<span class="line-modified">!     JSGlobalObject* m_globalObject;</span>
      JSObject* m_function;
      CallType m_callType;
      CallData m_callData;
  };
  
  // We clamp recursion well beyond anything reasonable.
<span class="line-modified">! static constexpr unsigned maximumFilterRecursion = 40000;</span>
  enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
                                   ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember };
  NEVER_INLINE JSValue Walker::walk(JSValue unfiltered)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Vector&lt;PropertyNameArray, 16, UnsafeVectorOverflow&gt; propertyStack;
      Vector&lt;uint32_t, 16, UnsafeVectorOverflow&gt; indexStack;
      MarkedArgumentBuffer markedStack;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,23 ***</span>
      while (1) {
          switch (state) {
              arrayStartState:
              case ArrayStartState: {
                  ASSERT(inValue.isObject());
<span class="line-modified">!                 ASSERT(asObject(inValue)-&gt;inherits&lt;JSArray&gt;(vm));</span>
                  if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">!                     return throwStackOverflowError(m_exec, scope);</span>
  
<span class="line-modified">!                 JSArray* array = asArray(inValue);</span>
                  markedStack.appendWithCrashOnOverflow(array);
<span class="line-modified">!                 arrayLengthStack.append(array-&gt;length());</span>
                  indexStack.append(0);
              }
              arrayStartVisitMember:
              FALLTHROUGH;
              case ArrayStartVisitMember: {
<span class="line-modified">!                 JSArray* array = jsCast&lt;JSArray*&gt;(markedStack.last());</span>
                  uint32_t index = indexStack.last();
                  unsigned arrayLength = arrayLengthStack.last();
                  if (index == arrayLength) {
                      outValue = array;
                      markedStack.removeLast();
<span class="line-new-header">--- 661,27 ---</span>
      while (1) {
          switch (state) {
              arrayStartState:
              case ArrayStartState: {
                  ASSERT(inValue.isObject());
<span class="line-modified">!                 ASSERT(isArray(m_globalObject, inValue));</span>
<span class="line-added">+                 EXCEPTION_ASSERT(!scope.exception());</span>
<span class="line-added">+ </span>
                  if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">!                     return throwStackOverflowError(m_globalObject, scope);</span>
  
<span class="line-modified">!                 JSObject* array = asObject(inValue);</span>
                  markedStack.appendWithCrashOnOverflow(array);
<span class="line-modified">!                 unsigned length = toLength(m_globalObject, array);</span>
<span class="line-added">+                 RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+                 arrayLengthStack.append(length);</span>
                  indexStack.append(0);
              }
              arrayStartVisitMember:
              FALLTHROUGH;
              case ArrayStartVisitMember: {
<span class="line-modified">!                 JSObject* array = asObject(markedStack.last());</span>
                  uint32_t index = indexStack.last();
                  unsigned arrayLength = arrayLengthStack.last();
                  if (index == arrayLength) {
                      outValue = array;
                      markedStack.removeLast();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,15 ***</span>
                      break;
                  }
                  if (isJSArray(array) &amp;&amp; array-&gt;canGetIndexQuickly(index))
                      inValue = array-&gt;getIndexQuickly(index);
                  else {
<span class="line-modified">!                     PropertySlot slot(array, PropertySlot::InternalMethodType::Get);</span>
<span class="line-removed">-                     if (array-&gt;methodTable(vm)-&gt;getOwnPropertySlotByIndex(array, m_exec, index, slot))</span>
<span class="line-removed">-                         inValue = slot.getValue(m_exec, index);</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         inValue = jsUndefined();</span>
                      RETURN_IF_EXCEPTION(scope, { });
                  }
  
                  if (inValue.isObject()) {
                      stateStack.append(ArrayEndVisitMember);
<span class="line-new-header">--- 690,11 ---</span>
                      break;
                  }
                  if (isJSArray(array) &amp;&amp; array-&gt;canGetIndexQuickly(index))
                      inValue = array-&gt;getIndexQuickly(index);
                  else {
<span class="line-modified">!                     inValue = array-&gt;get(m_globalObject, index);</span>
                      RETURN_IF_EXCEPTION(scope, { });
                  }
  
                  if (inValue.isObject()) {
                      stateStack.append(ArrayEndVisitMember);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,33 ***</span>
                  } else
                      outValue = inValue;
                  FALLTHROUGH;
              }
              case ArrayEndVisitMember: {
<span class="line-modified">!                 JSArray* array = jsCast&lt;JSArray*&gt;(markedStack.last());</span>
                  JSValue filteredValue = callReviver(array, jsString(vm, String::number(indexStack.last())), outValue);
                  RETURN_IF_EXCEPTION(scope, { });
                  if (filteredValue.isUndefined())
<span class="line-modified">!                     array-&gt;methodTable(vm)-&gt;deletePropertyByIndex(array, m_exec, indexStack.last());</span>
                  else
<span class="line-modified">!                     array-&gt;putDirectIndex(m_exec, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  indexStack.last()++;
                  goto arrayStartVisitMember;
              }
              objectStartState:
              case ObjectStartState: {
                  ASSERT(inValue.isObject());
<span class="line-modified">!                 ASSERT(!asObject(inValue)-&gt;inherits&lt;JSArray&gt;(vm));</span>
                  if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">!                     return throwStackOverflowError(m_exec, scope);</span>
  
                  JSObject* object = asObject(inValue);
                  markedStack.appendWithCrashOnOverflow(object);
                  indexStack.append(0);
                  propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                 object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());</span>
                  RETURN_IF_EXCEPTION(scope, { });
              }
              objectStartVisitMember:
              FALLTHROUGH;
              case ObjectStartVisitMember: {
<span class="line-new-header">--- 702,33 ---</span>
                  } else
                      outValue = inValue;
                  FALLTHROUGH;
              }
              case ArrayEndVisitMember: {
<span class="line-modified">!                 JSObject* array = asObject(markedStack.last());</span>
                  JSValue filteredValue = callReviver(array, jsString(vm, String::number(indexStack.last())), outValue);
                  RETURN_IF_EXCEPTION(scope, { });
                  if (filteredValue.isUndefined())
<span class="line-modified">!                     array-&gt;methodTable(vm)-&gt;deletePropertyByIndex(array, m_globalObject, indexStack.last());</span>
                  else
<span class="line-modified">!                     array-&gt;putDirectIndex(m_globalObject, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  indexStack.last()++;
                  goto arrayStartVisitMember;
              }
              objectStartState:
              case ObjectStartState: {
                  ASSERT(inValue.isObject());
<span class="line-modified">!                 ASSERT(!isJSArray(inValue));</span>
                  if (markedStack.size() &gt; maximumFilterRecursion)
<span class="line-modified">!                     return throwStackOverflowError(m_globalObject, scope);</span>
  
                  JSObject* object = asObject(inValue);
                  markedStack.appendWithCrashOnOverflow(object);
                  indexStack.append(0);
                  propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">!                 object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_globalObject, propertyStack.last(), EnumerationMode());</span>
                  RETURN_IF_EXCEPTION(scope, { });
              }
              objectStartVisitMember:
              FALLTHROUGH;
              case ObjectStartVisitMember: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 740,16 ***</span>
                      markedStack.removeLast();
                      indexStack.removeLast();
                      propertyStack.removeLast();
                      break;
                  }
<span class="line-modified">!                 PropertySlot slot(object, PropertySlot::InternalMethodType::Get);</span>
<span class="line-removed">-                 if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_exec, properties[index], slot))</span>
<span class="line-removed">-                     inValue = slot.getValue(m_exec, properties[index]);</span>
<span class="line-removed">-                 else</span>
<span class="line-removed">-                     inValue = jsUndefined();</span>
<span class="line-removed">- </span>
                  // The holder may be modified by the reviver function so any lookup may throw
                  RETURN_IF_EXCEPTION(scope, { });
  
                  if (inValue.isObject()) {
                      stateStack.append(ObjectEndVisitMember);
<span class="line-new-header">--- 740,11 ---</span>
                      markedStack.removeLast();
                      indexStack.removeLast();
                      propertyStack.removeLast();
                      break;
                  }
<span class="line-modified">!                 inValue = object-&gt;get(m_globalObject, properties[index]);</span>
                  // The holder may be modified by the reviver function so any lookup may throw
                  RETURN_IF_EXCEPTION(scope, { });
  
                  if (inValue.isObject()) {
                      stateStack.append(ObjectEndVisitMember);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 763,120 ***</span>
                  Identifier prop = propertyStack.last()[indexStack.last()];
                  PutPropertySlot slot(object);
                  JSValue filteredValue = callReviver(object, jsString(vm, prop.string()), outValue);
                  RETURN_IF_EXCEPTION(scope, { });
                  if (filteredValue.isUndefined())
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;deleteProperty(object, m_exec, prop);</span>
                  else
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;put(object, m_exec, prop, filteredValue, slot);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  indexStack.last()++;
                  goto objectStartVisitMember;
              }
              stateUnknown:
              case StateUnknown:
                  if (!inValue.isObject()) {
                      outValue = inValue;
                      break;
                  }
<span class="line-modified">!                 JSObject* object = asObject(inValue);</span>
<span class="line-modified">!                 if (object-&gt;inherits&lt;JSArray&gt;(vm))</span>
                      goto arrayStartState;
                  goto objectStartState;
          }
          if (stateStack.isEmpty())
              break;
  
          state = stateStack.last();
          stateStack.removeLast();
      }
<span class="line-modified">!     JSObject* finalHolder = constructEmptyObject(m_exec);</span>
<span class="line-modified">!     PutPropertySlot slot(finalHolder);</span>
<span class="line-removed">-     finalHolder-&gt;methodTable(vm)-&gt;put(finalHolder, m_exec, vm.propertyNames-&gt;emptyIdentifier, outValue, slot);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, { });</span>
      RELEASE_AND_RETURN(scope, callReviver(finalHolder, jsEmptyString(vm), outValue));
  }
  
  // ECMA-262 v5 15.12.2
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
      StringView view = viewWithString.view;
  
      JSValue unfiltered;
      if (view.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; jsonParser(exec, view.characters8(), view.length(), StrictJSON);</span>
          unfiltered = jsonParser.tryLiteralParse();
          EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
          if (!unfiltered) {
              RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!             return throwVMError(exec, scope, createSyntaxError(exec, jsonParser.getErrorMessage()));</span>
          }
      } else {
<span class="line-modified">!         LiteralParser&lt;UChar&gt; jsonParser(exec, view.characters16(), view.length(), StrictJSON);</span>
          unfiltered = jsonParser.tryLiteralParse();
          EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
          if (!unfiltered) {
              RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!             return throwVMError(exec, scope, createSyntaxError(exec, jsonParser.getErrorMessage()));</span>
          }
      }
  
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 2)</span>
          return JSValue::encode(unfiltered);
  
<span class="line-modified">!     JSValue function = exec-&gt;uncheckedArgument(1);</span>
      CallData callData;
      CallType callType = getCallData(vm, function, callData);
      if (callType == CallType::None)
          return JSValue::encode(unfiltered);
      scope.release();
<span class="line-modified">!     Walker walker(exec, asObject(function), callType, callData);</span>
      return JSValue::encode(walker.walk(unfiltered));
  }
  
  // ECMA-262 v5 15.12.3
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Stringifier stringifier(exec, exec-&gt;argument(1), exec-&gt;argument(2));</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(exec-&gt;argument(0))));</span>
  }
  
<span class="line-modified">! JSValue JSONParse(ExecState* exec, const String&amp; json)</span>
  {
      if (json.isNull())
          return JSValue();
  
      if (json.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; jsonParser(exec, json.characters8(), json.length(), StrictJSON);</span>
          return jsonParser.tryLiteralParse();
      }
  
<span class="line-modified">!     LiteralParser&lt;UChar&gt; jsonParser(exec, json.characters16(), json.length(), StrictJSON);</span>
      return jsonParser.tryLiteralParse();
  }
  
<span class="line-modified">! String JSONStringify(ExecState* exec, JSValue value, JSValue space)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Stringifier stringifier(exec, jsNull(), space);</span>
      RETURN_IF_EXCEPTION(throwScope, { });
      JSValue result = stringifier.stringify(value);
      if (UNLIKELY(throwScope.exception()) || result.isUndefinedOrNull())
          return String();
<span class="line-modified">!     return result.getString(exec);</span>
  }
  
<span class="line-modified">! String JSONStringify(ExecState* exec, JSValue value, unsigned indent)</span>
  {
<span class="line-modified">!     return JSONStringify(exec, value, jsNumber(indent));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 758,119 ---</span>
                  Identifier prop = propertyStack.last()[indexStack.last()];
                  PutPropertySlot slot(object);
                  JSValue filteredValue = callReviver(object, jsString(vm, prop.string()), outValue);
                  RETURN_IF_EXCEPTION(scope, { });
                  if (filteredValue.isUndefined())
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;deleteProperty(object, m_globalObject, prop);</span>
                  else
<span class="line-modified">!                     object-&gt;methodTable(vm)-&gt;put(object, m_globalObject, prop, filteredValue, slot);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  indexStack.last()++;
                  goto objectStartVisitMember;
              }
              stateUnknown:
              case StateUnknown:
                  if (!inValue.isObject()) {
                      outValue = inValue;
                      break;
                  }
<span class="line-modified">!                 bool valueIsArray = isArray(m_globalObject, inValue);</span>
<span class="line-modified">!                 RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+                 if (valueIsArray)</span>
                      goto arrayStartState;
                  goto objectStartState;
          }
          if (stateStack.isEmpty())
              break;
  
          state = stateStack.last();
          stateStack.removeLast();
      }
<span class="line-modified">!     JSObject* finalHolder = constructEmptyObject(m_globalObject);</span>
<span class="line-modified">!     finalHolder-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, outValue);</span>
      RELEASE_AND_RETURN(scope, callReviver(finalHolder, jsEmptyString(vm), outValue));
  }
  
  // ECMA-262 v5 15.12.2
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
      StringView view = viewWithString.view;
  
      JSValue unfiltered;
      if (view.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; jsonParser(globalObject, view.characters8(), view.length(), StrictJSON);</span>
          unfiltered = jsonParser.tryLiteralParse();
          EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
          if (!unfiltered) {
              RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!             return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));</span>
          }
      } else {
<span class="line-modified">!         LiteralParser&lt;UChar&gt; jsonParser(globalObject, view.characters16(), view.length(), StrictJSON);</span>
          unfiltered = jsonParser.tryLiteralParse();
          EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
          if (!unfiltered) {
              RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!             return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));</span>
          }
      }
  
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 2)</span>
          return JSValue::encode(unfiltered);
  
<span class="line-modified">!     JSValue function = callFrame-&gt;uncheckedArgument(1);</span>
      CallData callData;
      CallType callType = getCallData(vm, function, callData);
      if (callType == CallType::None)
          return JSValue::encode(unfiltered);
      scope.release();
<span class="line-modified">!     Walker walker(globalObject, asObject(function), callType, callData);</span>
      return JSValue::encode(walker.walk(unfiltered));
  }
  
  // ECMA-262 v5 15.12.3
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Stringifier stringifier(globalObject, callFrame-&gt;argument(1), callFrame-&gt;argument(2));</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(callFrame-&gt;argument(0))));</span>
  }
  
<span class="line-modified">! JSValue JSONParse(JSGlobalObject* globalObject, const String&amp; json)</span>
  {
      if (json.isNull())
          return JSValue();
  
      if (json.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; jsonParser(globalObject, json.characters8(), json.length(), StrictJSON);</span>
          return jsonParser.tryLiteralParse();
      }
  
<span class="line-modified">!     LiteralParser&lt;UChar&gt; jsonParser(globalObject, json.characters16(), json.length(), StrictJSON);</span>
      return jsonParser.tryLiteralParse();
  }
  
<span class="line-modified">! String JSONStringify(JSGlobalObject* globalObject, JSValue value, JSValue space)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Stringifier stringifier(globalObject, jsNull(), space);</span>
      RETURN_IF_EXCEPTION(throwScope, { });
      JSValue result = stringifier.stringify(value);
      if (UNLIKELY(throwScope.exception()) || result.isUndefinedOrNull())
          return String();
<span class="line-modified">!     return result.getString(globalObject);</span>
  }
  
<span class="line-modified">! String JSONStringify(JSGlobalObject* globalObject, JSValue value, unsigned indent)</span>
  {
<span class="line-modified">!     return JSONStringify(globalObject, value, jsNumber(indent));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSNativeStdFunction.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSONObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;GraphicsContext.h&quot;
 29 #include &quot;PlatformJavaClasses.h&quot;
 30 #include &quot;MediaPlayerPrivateJava.h&quot;
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;PlatformContextJava.h&quot;
 33 
 34 #include &quot;Document.h&quot;
 35 #include &quot;Settings.h&quot;
 36 
 37 #include &lt;wtf/text/CString.h&gt; // todo tav remove when building w/ pch
 38 
 39 #include &quot;com_sun_webkit_graphics_WCMediaPlayer.h&quot;
 40 #include &quot;com_sun_webkit_graphics_GraphicsDecoder.h&quot;
 41 
 42 
 43 namespace WebCore {
 44 
 45 
 46 ///////////////////////// log support
 47 
 48 #if defined(NDEBUG)
 49 
 50     #define LOG_TRACE0(szFormat)                    ((void)0)
 51     #define LOG_TRACE1(szFormat, p1)                ((void)0)
 52     #define LOG_TRACE2(szFormat, p1, p2)            ((void)0)
 53     #define LOG_TRACE3(szFormat, p1, p2, p3)        ((void)0)
 54     #define LOG_TRACE4(szFormat, p1, p2, p3, p4)    ((void)0)
 55 
 56     #define LOG_ERROR0(szFormat)                    ((void)0)
 57     #define LOG_ERROR1(szFormat, p1)                ((void)0)
 58 
 59     #define PLOG_TRACE0(szFormat)                    ((void)0)
 60     #define PLOG_TRACE1(szFormat, p1)                ((void)0)
 61     #define PLOG_TRACE2(szFormat, p1, p2)            ((void)0)
 62     #define PLOG_TRACE3(szFormat, p1, p2, p3)        ((void)0)
 63     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)    ((void)0)
 64 
 65     #define PLOG_ERROR0(szFormat)                    ((void)0)
 66     #define PLOG_ERROR1(szFormat, p1)                ((void)0)
 67 
 68 #else
 69 
 70     #include &lt;stdio.h&gt;
 71     #include &lt;wtf/Threading.h&gt;
 72 
 73     const char* networkStateStr(MediaPlayer::NetworkState networkState) {
 74         switch (networkState) {
<a name="1" id="anc1"></a><span class="line-modified"> 75         case MediaPlayer::NetworkState::Empty:</span>
 76             return &quot;Empty&quot;;
<a name="2" id="anc2"></a><span class="line-modified"> 77         case MediaPlayer::NetworkState::Idle:</span>
 78             return &quot;Idle&quot;;
<a name="3" id="anc3"></a><span class="line-modified"> 79         case MediaPlayer::NetworkState::Loading:</span>
 80             return &quot;Loading&quot;;
<a name="4" id="anc4"></a><span class="line-modified"> 81         case MediaPlayer::NetworkState::Loaded:</span>
 82             return &quot;Loaded&quot;;
<a name="5" id="anc5"></a><span class="line-modified"> 83         case MediaPlayer::NetworkState::FormatError:</span>
 84             return &quot;FormatError&quot;;
<a name="6" id="anc6"></a><span class="line-modified"> 85         case MediaPlayer::NetworkState::NetworkError:</span>
 86             return &quot;NetworkError&quot;;
<a name="7" id="anc7"></a><span class="line-modified"> 87         case MediaPlayer::NetworkState::DecodeError:</span>
 88             return &quot;DecodeError&quot;;
 89         }
 90         return &quot;&lt;unknown network state&gt;&quot;;
 91     }
 92 
 93     const char* readyStateStr(MediaPlayer::ReadyState readyState) {
 94         switch (readyState) {
<a name="8" id="anc8"></a><span class="line-modified"> 95         case MediaPlayer::ReadyState::HaveNothing:</span>
 96             return &quot;HaveNothing&quot;;
<a name="9" id="anc9"></a><span class="line-modified"> 97         case MediaPlayer::ReadyState::HaveMetadata:</span>
 98             return &quot;HaveMetadata&quot;;
<a name="10" id="anc10"></a><span class="line-modified"> 99         case MediaPlayer::ReadyState::HaveCurrentData:</span>
100             return &quot;HaveCurrentData&quot;;
<a name="11" id="anc11"></a><span class="line-modified">101         case MediaPlayer::ReadyState::HaveFutureData:</span>
102             return &quot;HaveFutureData&quot;;
<a name="12" id="anc12"></a><span class="line-modified">103         case MediaPlayer::ReadyState::HaveEnoughData:</span>
104             return &quot;HaveEnoughData&quot;;
105         }
106         return &quot;&lt;unknown ready state&gt;&quot;;
107     }
108 
109     namespace Logger {
110 
111         FILE* getLogStream() {
112             FILE *stream = stderr;
113             //FILE *stream = fopen(&quot;webVideo.log&quot;, &quot;a&quot;);
114             return stream;
115         }
116 
117         void releaseLogStream(FILE *stream) {
118             fflush(stream);
119             //fclose(stream);
120         }
121 
122         void AMLogf(const char* szLevel, const char* szFormat, ...) {
123             FILE *stream = getLogStream();
124             fprintf(stream, &quot;[%s (native)] &quot;, szLevel);
125             va_list args;
126             va_start(args, szFormat);
127             vfprintf(stream, szFormat, args);
128             releaseLogStream(stream);
129         }
130 
131         void AMLogf_p(const MediaPlayerPrivate *p, const char* szLevel, const char* szFormat, ...) {
132             FILE *stream = getLogStream();
133             fprintf(stream, &quot;[%s (native),states:(%s,%s), paused:%d, seeking:%d, pos:%f/%f]&quot;,
134                 szLevel, networkStateStr(p-&gt;networkState()), readyStateStr(p-&gt;readyState()),
135                 (p-&gt;paused() ? 1 : 0), (p-&gt;seeking() ? 1 : 0),
136                 p-&gt;currentTime(), p-&gt;duration());
137             va_list args;
138             va_start(args, szFormat);
139             vfprintf(stream, szFormat, args);
140             releaseLogStream(stream);
141         }
142     }
143 
144     #define LOG_TRACE0(szFormat)                    Logger::AMLogf(&quot;INFO&quot;, szFormat)
145     #define LOG_TRACE1(szFormat, p1)                Logger::AMLogf(&quot;INFO&quot;, szFormat, p1)
146     #define LOG_TRACE2(szFormat, p1, p2)            Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2)
147     #define LOG_TRACE3(szFormat, p1, p2, p3)        Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3)
148     #define LOG_TRACE4(szFormat, p1, p2, p3, p4)    Logger::AMLogf(&quot;INFO&quot;, szFormat, p1, p2, p3, p4)
149 
150     #define LOG_ERROR0(szFormat)                    Logger::AMLogf(&quot;SEVERE&quot;, szFormat)
151     #define LOG_ERROR1(szFormat, p1)                Logger::AMLogf(&quot;SEVERE&quot;, szFormat, p1)
152 
153     #define PLOG_TRACE0(szFormat)                   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat)
154     #define PLOG_TRACE1(szFormat, p1)               Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1)
155     #define PLOG_TRACE2(szFormat, p1, p2)           Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2)
156     #define PLOG_TRACE3(szFormat, p1, p2, p3)       Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3)
157     #define PLOG_TRACE4(szFormat, p1, p2, p3, p4)   Logger::AMLogf_p(this, &quot;INFO&quot;, szFormat, p1, p2, p3, p4)
158 
159     #define PLOG_ERROR0(szFormat)                   Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat)
160     #define PLOG_ERROR1(szFormat, p1)               Logger::AMLogf_p(this, &quot;SEVERE&quot;, szFormat, p1)
161 
162 #endif
163 
164 ////////////////////////
165 
<a name="13" id="anc13"></a><span class="line-added">166 class MediaPlayerFactoryJava final : public MediaPlayerFactory {</span>
<span class="line-added">167 private:</span>
<span class="line-added">168     MediaPlayerEnums::MediaEngineIdentifier identifier() const final { return MediaPlayerEnums::MediaEngineIdentifier::MediaFoundation; };</span>
169 
<a name="14" id="anc14"></a><span class="line-added">170     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer* player) const final</span>
<span class="line-added">171     {</span>
<span class="line-added">172         return makeUnique&lt;MediaPlayerPrivate&gt;(player);</span>
<span class="line-added">173     }</span>
174 
<a name="15" id="anc15"></a><span class="line-added">175     void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types) const final</span>
<span class="line-added">176     {</span>
<span class="line-added">177         return MediaPlayerPrivate::MediaEngineSupportedTypes(types);</span>
<span class="line-added">178     }</span>
<span class="line-added">179 </span>
<span class="line-added">180     MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp; parameters) const final</span>
<span class="line-added">181     {</span>
<span class="line-added">182         return MediaPlayerPrivate::MediaEngineSupportsType(parameters);</span>
<span class="line-added">183     }</span>
<span class="line-added">184 };</span>
185 
186 void MediaPlayerPrivate::registerMediaEngine(MediaEngineRegistrar registrar)
187 {
188     LOG_TRACE0(&quot;&gt;&gt;registerMediaEngine\n&quot;);
189     JNIEnv* env = WTF::GetJavaEnv();
190     jclass playerCls = PG_GetMediaPlayerClass(env);
191     if (!playerCls) {
192         LOG_ERROR0(&quot;&lt;&lt;registerMediaEngine ERROR: MediaPlayer class is unavailable\n&quot;);
193         return;
194     }
<a name="16" id="anc16"></a><span class="line-modified">195 </span>
<span class="line-modified">196     registrar(makeUnique&lt;MediaPlayerFactoryJava&gt;());</span>


197 }
198 
199 void MediaPlayerPrivate::MediaEngineSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types)
200 {
201     LOG_TRACE0(&quot;&gt;&gt;MediaEngineSupportedTypes\n&quot;);
202     HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; supportedTypes = GetSupportedTypes();
203     for (const auto&amp; type : supportedTypes) {
204         types.add(type);
205     }
206     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportedTypes\n&quot;);
207 }
208 
209 MediaPlayer::SupportsType MediaPlayerPrivate::MediaEngineSupportsType(const MediaEngineSupportParameters&amp; parameters)
210 {
211     for (const auto&amp; codecValue: parameters.type.codecs()) {
212         UNUSED_PARAM(codecValue);
213         LOG_TRACE2(&quot;&gt;&gt;MediaEngineSupportsType, type=%s, codecs=%s\n&quot;, parameters.type.raw().utf8().data(), codecValue.utf8().data());
214     }
215 
216     if (parameters.type.isEmpty()) {
217         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported (type is empty)\n&quot;);
<a name="17" id="anc17"></a><span class="line-modified">218         return MediaPlayer::SupportsType::IsNotSupported;</span>
219     }
220 
221     if (GetSupportedTypes().contains(parameters.type.containerType())) {
222         LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: MayBeSupported/IsSupported\n&quot;);
223         auto codecs = parameters.type.parameter(ContentType::codecsParameter());
<a name="18" id="anc18"></a><span class="line-modified">224         return codecs.isEmpty() ? MediaPlayer::SupportsType::MayBeSupported : MediaPlayer::SupportsType::IsSupported;</span>
225     }
226     LOG_TRACE0(&quot;&lt;&lt;MediaEngineSupportsType: NOT supported\n&quot;);
<a name="19" id="anc19"></a><span class="line-modified">227     return MediaPlayer::SupportsType::IsNotSupported;</span>
228 }
229 
230 HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; MediaPlayerPrivate::GetSupportedTypes()
231 {
232     static HashSet&lt;String, ASCIICaseInsensitiveHash&gt; supportedTypes;
233     // TODO: refresh after change
234 
235     if (!supportedTypes.isEmpty()) {
236         return supportedTypes;
237     }
238 
239     JNIEnv* env = WTF::GetJavaEnv();
240     static jmethodID s_mID = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
241         &quot;getSupportedMediaTypes&quot;, &quot;()[Ljava/lang/String;&quot;);
242     ASSERT(s_mID);
243 
244     JLocalRef&lt;jobjectArray&gt; jArray(
245         (jobjectArray)env-&gt;CallObjectMethod(PL_GetGraphicsManager(env), s_mID));
246     ASSERT(jArray);
247     WTF::CheckAndClearException(env);
248 
249     jsize len = env-&gt;GetArrayLength(jArray);
250     for (jsize  i=0; i&lt;len; i++) {
251         JLString jStr((jstring)env-&gt;GetObjectArrayElement(jArray, i));
252         String s(env, jStr);
253         supportedTypes.add(s);
254     }
255 
256     return supportedTypes;
257 }
258 
259 
260 // *********************************************************
261 // MediaPlayerPrivate
262 // *********************************************************
263 MediaPlayerPrivate::MediaPlayerPrivate(MediaPlayer *player)
264     : m_player(player)
<a name="20" id="anc20"></a><span class="line-modified">265     , m_networkState(MediaPlayer::NetworkState::Empty)</span>
<span class="line-modified">266     , m_readyState(MediaPlayer::ReadyState::HaveNothing)</span>
267     , m_isVisible(false)
268     , m_hasVideo(false)
269     , m_hasAudio(false)
270     , m_paused(true)
271     , m_seeking(false)
272     , m_seekTime(0)
273     , m_duration(0)
274     , m_bytesLoaded(0)
275     , m_didLoadingProgress(false)
276 {
277     JNIEnv* env = WTF::GetJavaEnv();
278     static jmethodID mid = env-&gt;GetMethodID(PG_GetGraphicsManagerClass(env),
279         &quot;fwkCreateMediaPlayer&quot;, &quot;(J)Lcom/sun/webkit/graphics/WCMediaPlayer;&quot;);
280     ASSERT(mid);
281 
282     JLocalRef&lt;jobject&gt; obj(env-&gt;CallObjectMethod(PL_GetGraphicsManager(env),
283         mid, ptr_to_jlong(this)));
284     ASSERT(obj);
285     WTF::CheckAndClearException(env);
286 
287     m_buffered = std::make_unique&lt;PlatformTimeRanges&gt;();
288     m_jPlayer = RQRef::create(obj);
289 }
290 
291 MediaPlayerPrivate::~MediaPlayerPrivate()
292 {
293     WC_GETJAVAENV_CHKRET(env);
294     static jmethodID s_mID
295         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkDispose&quot;, &quot;()V&quot;);
296     ASSERT(s_mID);
297 
298     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
299     WTF::CheckAndClearException(env);
300 }
301 
302 void MediaPlayerPrivate::load(const String&amp; url)
303 {
<a name="21" id="anc21"></a><span class="line-modified">304     if (m_networkState == MediaPlayer::NetworkState::Loading) {</span>
305         cancelLoad();
306     }
307 
308     String userAgent;
309     // MediaPlayerClient mpClient = m_player-&gt;client();
310     // Document* doc = mpClient.mediaPlayerOwningDocument(); //XXX: mediaPlayerOwningDocument removed
311     // if (doc != NULL &amp;&amp; doc-&gt;settings() != NULL) {
312     //     userAgent = doc-&gt;settings()-&gt;userAgent();
313     // }
314 
315     JNIEnv* env = WTF::GetJavaEnv();
316     static jmethodID s_mID
317         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkLoad&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;);
318     ASSERT(s_mID);
319 
320     env-&gt;CallVoidMethod(*m_jPlayer, s_mID,
321         (jstring)url.toJavaString(env),
322         userAgent.isEmpty() ? NULL : (jstring)userAgent.toJavaString(env));
323     WTF::CheckAndClearException(env);
324 }
325 
326 void MediaPlayerPrivate::cancelLoad()
327 {
328     m_paused = true;
329     m_seeking = false;
330 
331     JNIEnv* env = WTF::GetJavaEnv();
332     static jmethodID s_mID
333         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkCancelLoad&quot;, &quot;()V&quot;);
334     ASSERT(s_mID);
335 
336     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
337     WTF::CheckAndClearException(env);
338 }
339 
340 void MediaPlayerPrivate::prepareToPlay()
341 {
342     JNIEnv* env = WTF::GetJavaEnv();
343     static jmethodID s_mID
344         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkPrepareToPlay&quot;, &quot;()V&quot;);
345     ASSERT(s_mID);
346 
347     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
348     WTF::CheckAndClearException(env);
349 }
350 
351 //PlatformMedia MediaPlayerPrivate::platformMedia() const { return NoPlatformMedia; }
352 
353 //#if USE(ACCELERATED_COMPOSITING)
354 //        PlatformLayer* MediaPlayerPrivate::platformLayer() const { return 0; }
355 //#endif
356 
357 void MediaPlayerPrivate::play()
358 {
359     PLOG_TRACE0(&quot;&gt;&gt;MediaPlayerPrivate::play\n&quot;);
360 
361     if (!paused()) {
362         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate::play - already playing\n&quot;);
363         return;
364     }
365 
366     JNIEnv* env = WTF::GetJavaEnv();
367     static jmethodID s_mID
368         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkPlay&quot;, &quot;()V&quot;);
369     ASSERT(s_mID);
370 
371     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
372     WTF::CheckAndClearException(env);
373 
374     PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate::play\n&quot;);
375 }
376 
377 void MediaPlayerPrivate::pause()
378 {
379     if (paused()) {
380         return;
381     }
382 
383     JNIEnv* env = WTF::GetJavaEnv();
384     static jmethodID s_mID
385         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkPause&quot;, &quot;()V&quot;);
386     ASSERT(s_mID);
387 
388     env-&gt;CallVoidMethod(*m_jPlayer, s_mID);
389     WTF::CheckAndClearException(env);
390 }
391 
392 //bool MediaPlayerPrivate::supportsFullscreen() const { return false; }
393 //bool MediaPlayerPrivate::supportsSave() const { return false; }
394 
395 FloatSize MediaPlayerPrivate::naturalSize() const
396 {
397 //    PLOG_TRACE2(&quot;MediaPlayerPrivate naturalSize - return %d x %d\n&quot;, m_naturalSize.width(), m_naturalSize.height());
398     return m_naturalSize;
399 }
400 
401 bool MediaPlayerPrivate::hasVideo() const
402 {
403 //    PLOG_TRACE1(&quot;MediaPlayerPrivate hasVideo - return %d\n&quot;, m_hasVideo ? 1 : 0);
404     return m_hasVideo;
405 }
406 
407 bool MediaPlayerPrivate::hasAudio() const
408 {
409 //    PLOG_TRACE1(&quot;MediaPlayerPrivate hasAudio - return %d\n&quot;, m_hasAudio ? 1 : 0);
410     return m_hasAudio;
411 }
412 
413 void MediaPlayerPrivate::setVisible(bool visible)
414 {
415     if (m_isVisible != visible) {
416         PLOG_TRACE2(&quot;MediaPlayerPrivate setVisible: %d =&gt; %d\n&quot;, m_isVisible ? 1 : 0, visible ? 1 : 0);
417         m_isVisible = visible;
418     }
419 }
420 
421 float MediaPlayerPrivate::duration() const
422 {
423     // return numeric_limits&lt;float&gt;::infinity(); // &quot;live&quot; stream
424     return m_duration;
425 }
426 
427 float MediaPlayerPrivate::currentTime() const
428 {
429     if (m_seeking) {
430         LOG_TRACE1(&quot;MediaPlayerPrivate currentTime returns (seekTime): %f\n&quot;, m_seekTime);
431         return m_seekTime;
432     }
433     JNIEnv* env = WTF::GetJavaEnv();
434     static jmethodID s_mID
435         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkGetCurrentTime&quot;, &quot;()F&quot;);
436     ASSERT(s_mID);
437 
438     double result = env-&gt;CallFloatMethod(*m_jPlayer, s_mID);
439     WTF::CheckAndClearException(env);
440 
441 //    LOG_TRACE1(&quot;MediaPlayerPrivate currentTime returns: %f\n&quot;, (float)result);
442 
443     return (float)result;
444 }
445 
446 void MediaPlayerPrivate::seek(float time)
447 {
448     PLOG_TRACE1(&quot;&gt;&gt;MediaPlayerPrivate::seek(%f)\n&quot;, time);
449 
450     m_seekTime = time;
451 
452     JNIEnv* env = WTF::GetJavaEnv();
453     static jmethodID s_mID
454         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSeek&quot;, &quot;(F)V&quot;);
455     ASSERT(s_mID);
456 
457     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, time);
458     WTF::CheckAndClearException(env);
459 
460     PLOG_TRACE1(&quot;&lt;&lt;MediaPlayerPrivate::seek(%f)\n&quot;, time);
461 }
462 
463 bool MediaPlayerPrivate::seeking() const
464 {
465     return m_seeking;
466 }
467 
468 MediaTime MediaPlayerPrivate::startTime() const
469 {
470     // always 0
471     return MediaTime::zeroTime();
472 }
473 
474 void MediaPlayerPrivate::setRate(float rate)
475 {
476     JNIEnv* env = WTF::GetJavaEnv();
477     static jmethodID s_mID
478         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetRate&quot;, &quot;(F)V&quot;);
479     ASSERT(s_mID);
480 
481     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, rate);
482     WTF::CheckAndClearException(env);
483 }
484 
485 void MediaPlayerPrivate::setPreservesPitch(bool preserve)
486 {
487     JNIEnv* env = WTF::GetJavaEnv();
488     static jmethodID s_mID
489         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetPreservesPitch&quot;, &quot;(Z)V&quot;);
490     ASSERT(s_mID);
491 
492     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, bool_to_jbool(preserve));
493     WTF::CheckAndClearException(env);
494 }
495 
496 bool MediaPlayerPrivate::paused() const
497 {
498     return m_paused;
499 }
500 
501 void MediaPlayerPrivate::setVolume(float volume)
502 {
503     JNIEnv* env = WTF::GetJavaEnv();
504     static jmethodID s_mID
505         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetVolume&quot;, &quot;(F)V&quot;);
506     ASSERT(s_mID);
507 
508     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, volume);
509     WTF::CheckAndClearException(env);
510 }
511 
512 bool MediaPlayerPrivate::supportsMuting() const
513 {
514     return true;
515 }
516 
517 void MediaPlayerPrivate::setMuted(bool mute)
518 {
519     JNIEnv* env = WTF::GetJavaEnv();
520     static jmethodID
521         s_mID = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetMute&quot;, &quot;(Z)V&quot;);
522     ASSERT(s_mID);
523 
524     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, bool_to_jbool(mute));
525     WTF::CheckAndClearException(env);
526 }
527 
528 //bool MediaPlayerPrivate::hasClosedCaptions() const { return false; }
529 //void MediaPlayerPrivate::setClosedCaptionsVisible(bool) { }
530 
531 MediaPlayer::NetworkState MediaPlayerPrivate::networkState() const
532 {
533 //    LOG_TRACE1(&quot;MediaPlayerPrivate networkState - return %d\n&quot;, (int)m_networkState);
534     return m_networkState;
535 }
536 
537 MediaPlayer::ReadyState MediaPlayerPrivate::readyState() const
538 {
539 //    LOG_TRACE1(&quot;MediaPlayerPrivate readyState - return %d\n&quot;, (int)m_readyState);
540     return m_readyState;
541 }
542 
543 float MediaPlayerPrivate::maxTimeSeekable() const
544 {
545     return m_duration;
546 }
547 
548 bool MediaPlayerPrivate::didLoadingProgress() const
549 {
550     bool didLoadingProgress = m_didLoadingProgress;
551     m_didLoadingProgress = false;
552     PLOG_TRACE1(&quot;MediaPlayerPrivate didLoadingProgress - returning %d&quot;, didLoadingProgress ? 1 : 0);
553     return didLoadingProgress;
554 }
555 
556 std::unique_ptr&lt;PlatformTimeRanges&gt; MediaPlayerPrivate::buffered() const
557 {
558     return std::make_unique&lt;PlatformTimeRanges&gt;(); //XXX recheck; USE m_buffered
559 }
560 
561 unsigned MediaPlayerPrivate::bytesLoaded() const
562 {
563     return m_bytesLoaded;
564 }
565 
566 void MediaPlayerPrivate::setSize(const IntSize&amp; size)
567 {
568     JNIEnv* env = WTF::GetJavaEnv();
569     static jmethodID s_mID
570         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetSize&quot;, &quot;(II)V&quot;);
571     ASSERT(s_mID);
572 
573     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, (jint)size.width(), (jint)size.height());
574     WTF::CheckAndClearException(env);
575 }
576 
577 void MediaPlayerPrivate::paint(GraphicsContext&amp; gc, const FloatRect&amp; r)
578 {
579 //    PLOG_TRACE4(&quot;&gt;&gt;MediaPlayerPrivate paint (%d, %d), [%d x %d]\n&quot;, r.x(), r.y(), r.width(), r.height());
580     if (gc.paintingDisabled()) {
581         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (!gc or paintingDisabled)\n&quot;);
582         return;
583     }
584     if (!m_isVisible) {
585         PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (!visible)\n&quot;);
586         return;
587     }
588 
589     gc.platformContext()-&gt;rq().freeSpace(24)
590     &lt;&lt; (jint)com_sun_webkit_graphics_GraphicsDecoder_RENDERMEDIAPLAYER
591     &lt;&lt; m_jPlayer &lt;&lt; (jint)r.x() &lt;&lt;  (jint)r.y()
592     &lt;&lt; (jint)r.width() &lt;&lt; (jint)r.height();
593 
594 //    PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate paint (OK)\n&quot;);
595 }
596 
597 //void MediaPlayerPrivate::paintCurrentFrameInContext(GraphicsContext* c, const IntRect&amp; r) { paint(c, r); }
598 
599 void MediaPlayerPrivate::setPreload(MediaPlayer::Preload preload)
600 {
601     // enum Preload { None, MetaData, Auto };
602     PLOG_TRACE1(&quot;MediaPlayerPrivate setPreload, preload=%u\n&quot;, (int)preload);
603     jint jPreload =
<a name="22" id="anc22"></a><span class="line-modified">604         (preload == MediaPlayer::Preload::None) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_NONE</span>
<span class="line-modified">605         : (preload == MediaPlayer::Preload::MetaData) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_METADATA</span>
<span class="line-modified">606         : (preload == MediaPlayer::Preload::Auto) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_AUTO</span>
607         : -1;
608     if (jPreload &lt; 0) {
609         // unexpected preload value
610         return;
611     }
612     JNIEnv* env = WTF::GetJavaEnv();
613     static jmethodID s_mID
614         = env-&gt;GetMethodID(PG_GetMediaPlayerClass(env), &quot;fwkSetPreload&quot;, &quot;(I)V&quot;);
615     ASSERT(s_mID);
616 
617     env-&gt;CallVoidMethod(*m_jPlayer, s_mID, jPreload);
618     WTF::CheckAndClearException(env);
619 }
620 
<a name="23" id="anc23"></a><span class="line-modified">621 //bool MediaPlayerPrivate::hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::ReadyState::HaveCurrentData; }</span>
622 
623 //bool MediaPlayerPrivate::canLoadPoster() const { return false; }
624 //void MediaPlayerPrivate::setPoster(const String&amp;) { }
625 
626 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
627 //        virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
628 //        virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
629 //#endif
630 
631 //#if USE(ACCELERATED_COMPOSITING)
632 //        // whether accelerated rendering is supported by the media engine for the current media.
633 //        virtual bool supportsAcceleratedRendering() const { return false; }
634 //        // called when the rendering system flips the into or out of accelerated rendering mode.
635 //        virtual void acceleratedRenderingStateChanged() { }
636 //#endif
637 
638 //bool MediaPlayerPrivate::hasSingleSecurityOrigin() const { return false; }
639 
<a name="24" id="anc24"></a><span class="line-modified">640 //MediaPlayer::MovieLoadType MediaPlayerPrivate::movieLoadType() const { return MediaPlayer::MovieLoadType::Unknown; }</span>
641 
642 void MediaPlayerPrivate::setNetworkState(MediaPlayer::NetworkState networkState)
643 {
644     if (m_networkState != networkState) {
645         PLOG_TRACE4(&quot;MediaPlayerPrivate NetworkState: %s (%d) =&gt; %s (%d)\n&quot;,
646             networkStateStr(m_networkState), (int)m_networkState, networkStateStr(networkState), (int)networkState);
647         m_networkState = networkState;
648         m_player-&gt;networkStateChanged();
649     }
650 }
651 
652 void MediaPlayerPrivate::setReadyState(MediaPlayer::ReadyState readyState)
653 {
654     if (m_readyState != readyState) {
655         PLOG_TRACE4(&quot;MediaPlayerPrivate ReadyState: %s (%d) =&gt; %s (%d)\n&quot;,
656             readyStateStr(m_readyState), (int)m_readyState, readyStateStr(readyState), (int)readyState);
657         m_readyState = readyState;
658         m_player-&gt;readyStateChanged();
659     }
660 }
661 
662 
663 MediaPlayerPrivate* MediaPlayerPrivate::getPlayer(jlong ptr)
664 {
665     return reinterpret_cast&lt;MediaPlayerPrivate *&gt;(jlong_to_ptr(ptr));
666 }
667 
668 void MediaPlayerPrivate::notifyNetworkStateChanged(int networkState)
669 {
670     switch (networkState) {
671     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_EMPTY:
<a name="25" id="anc25"></a><span class="line-modified">672         setNetworkState(MediaPlayer::NetworkState::Empty);</span>
673         break;
674     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_IDLE:
<a name="26" id="anc26"></a><span class="line-modified">675         setNetworkState(MediaPlayer::NetworkState::Idle);</span>
676         break;
677     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADING:
<a name="27" id="anc27"></a><span class="line-modified">678         setNetworkState(MediaPlayer::NetworkState::Loading);</span>
679         break;
680     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADED:
<a name="28" id="anc28"></a><span class="line-modified">681         setNetworkState(MediaPlayer::NetworkState::Loaded);</span>
682         break;
683     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_FORMAT_ERROR:
<a name="29" id="anc29"></a><span class="line-modified">684         setNetworkState(MediaPlayer::NetworkState::FormatError);</span>
685         break;
686     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_NETWORK_ERROR:
<a name="30" id="anc30"></a><span class="line-modified">687         setNetworkState(MediaPlayer::NetworkState::NetworkError);</span>
688         break;
689     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_DECODE_ERROR:
<a name="31" id="anc31"></a><span class="line-modified">690         setNetworkState(MediaPlayer::NetworkState::DecodeError);</span>
691         break;
692     }
693 }
694 
695 void MediaPlayerPrivate::notifyReadyStateChanged(int readyState)
696 {
697     switch (readyState) {
698     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_NOTHING:
<a name="32" id="anc32"></a><span class="line-modified">699         setReadyState(MediaPlayer::ReadyState::HaveNothing);</span>
700         break;
701     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_METADATA:
<a name="33" id="anc33"></a><span class="line-modified">702         setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
703         break;
704     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_CURRENT_DATA:
<a name="34" id="anc34"></a><span class="line-modified">705         setReadyState(MediaPlayer::ReadyState::HaveCurrentData);</span>
706         break;
707     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_FUTURE_DATA:
<a name="35" id="anc35"></a><span class="line-modified">708         setReadyState(MediaPlayer::ReadyState::HaveFutureData);</span>
709         break;
710     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_ENOUGH_DATA:
<a name="36" id="anc36"></a><span class="line-modified">711         setReadyState(MediaPlayer::ReadyState::HaveEnoughData);</span>
712         break;
713     }
714 }
715 
716 void MediaPlayerPrivate::notifyPaused(bool paused)
717 {
718     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyPaused: %d =&gt; %d\n&quot;, m_paused ? 1 : 0, paused ? 1 : 0);
719 
720     if (m_paused != paused) {
721         m_paused = paused;
722         m_player-&gt;playbackStateChanged();
723     }
724 }
725 
726 void MediaPlayerPrivate::notifySeeking(bool seeking)
727 {
728     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifySeeking: %d =&gt; %d\n&quot;, m_seeking ? 1 : 0, seeking ? 1 : 0);
729     if (m_seeking != seeking) {
730         m_seeking = seeking;
731         if (!seeking) {
732             // notify time change after seek completed
733             //LOG_TRACE0(&quot;==MediaPlayerPrivate notifySeeking: NOTIFYING time changed\n&quot;);
734             m_player-&gt;timeChanged();
735         }
736     }
737 }
738 
739 void MediaPlayerPrivate::notifyFinished() {
740     PLOG_TRACE0(&quot;&gt;&gt;MediaPlayerPrivate notifyFinished\n&quot;);
741     m_player-&gt;timeChanged();
742 }
743 
744 void MediaPlayerPrivate::notifyReady(bool hasVideo, bool hasAudio)
745 {
746     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyReady: hasVideo=%d, hasAudio=%d\n&quot;, hasVideo ? 1 : 0, hasAudio ? 1 : 0);
747     m_hasVideo = hasVideo;
748     m_hasAudio = hasAudio;
749     PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate notifyReady\n&quot;);
750 }
751 
752 void MediaPlayerPrivate::notifyDurationChanged(float duration)
753 {
754     PLOG_TRACE2(&quot;&gt;&gt;MediaPlayerPrivate notifyDurationChanged, %f =&gt; %f\n&quot;,
755         m_duration, duration);
756     m_duration = duration;
757     m_player-&gt;durationChanged();
758 }
759 
760 void MediaPlayerPrivate::notifySizeChanged(int width, int height)
761 {
762     PLOG_TRACE2(&quot;MediaPlayerPrivate notifySizeChanged: %d x %d\n&quot;, width, height);
763     m_naturalSize = FloatSize(width, height); //XXX leave it as IntSize?
764 }
765 
766 void MediaPlayerPrivate::notifyNewFrame()
767 {
768     PLOG_TRACE0(&quot;&gt;&gt;MediaPlayerPrivate notifyNewFrame\n&quot;);
769     m_player-&gt;repaint();
770     //PLOG_TRACE0(&quot;&lt;&lt;MediaPlayerPrivate notifyNewFrame\n&quot;);
771 }
772 
773 void MediaPlayerPrivate::notifyBufferChanged(std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges, int bytesLoaded)
774 {
775     PLOG_TRACE0(&quot;MediaPlayerPrivate notifyBufferChanged\n&quot;);
776     m_buffered = std::move(timeRanges);
777     m_bytesLoaded = bytesLoaded;
778     m_didLoadingProgress = true;
779 }
780 
781 
782 // *********************************************************
783 // JNI functions
784 // *********************************************************
785 extern &quot;C&quot; {
786 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyNetworkStateChanged
787     (JNIEnv*, jobject, jlong ptr, jint networkState)
788 {
789     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
790     player-&gt;notifyNetworkStateChanged(networkState);
791 }
792 
793 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyReadyStateChanged
794     (JNIEnv*, jobject, jlong ptr, jint readyState)
795 {
796     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
797     player-&gt;notifyReadyStateChanged(readyState);
798 }
799 
800 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyPaused
801     (JNIEnv*, jobject, jlong ptr, jboolean paused)
802 {
803     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
804     player-&gt;notifyPaused(jbool_to_bool(paused));
805 }
806 
807 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifySeeking
808     (JNIEnv*, jobject, jlong ptr, jboolean seeking, jint /*readyState*/)
809 {
810     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
811     player-&gt;notifySeeking(jbool_to_bool(seeking));
812 }
813 
814 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyFinished
815     (JNIEnv*, jobject, jlong ptr)
816 {
817     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
818     player-&gt;notifyFinished();
819 }
820 
821 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyReady
822     (JNIEnv*, jobject, jlong ptr, jboolean hasVideo, jboolean hasAudio, jfloat duration)
823 {
824     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
825     player-&gt;notifyReady(jbool_to_bool(hasVideo), jbool_to_bool(hasAudio));
826     if (duration &gt;= 0) {
827         player-&gt;notifyDurationChanged(duration);
828     }
829 }
830 
831 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyDurationChanged
832   (JNIEnv*, jobject, jlong ptr, jfloat duration)
833 {
834     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
835     if (duration != player-&gt;duration()) {
836         player-&gt;notifyDurationChanged(duration);
837     }
838 }
839 
840 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifySizeChanged
841     (JNIEnv*, jobject, jlong ptr, jint width, jint height)
842 {
843     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
844     player-&gt;notifySizeChanged(width, height);
845 }
846 
847 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyNewFrame
848     (JNIEnv*, jobject, jlong ptr)
849 {
850     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
851     player-&gt;notifyNewFrame();
852 }
853 
854 JNIEXPORT void JNICALL Java_com_sun_webkit_graphics_WCMediaPlayer_notifyBufferChanged
855   (JNIEnv *env, jobject, jlong ptr, jfloatArray ranges, jint bytesLoaded)
856 {
857     MediaPlayerPrivate* player = MediaPlayerPrivate::getPlayer(ptr);
858 
859     jboolean isCopy;
860     jint len = env-&gt;GetArrayLength(ranges);
861     jfloat* rangesElems = env-&gt;GetFloatArrayElements(ranges, &amp;isCopy);
862 
863     PlatformTimeRanges* timeRanges = new PlatformTimeRanges();
864     for (int i = 0; i &lt; len; i+=2) {
865         timeRanges-&gt;add(MediaTime::createWithDouble(rangesElems[i]),
866                         MediaTime::createWithDouble(rangesElems[i+1]));
867     }
868     if (isCopy == JNI_TRUE) {
869        env-&gt;ReleaseFloatArrayElements(ranges, rangesElems, JNI_ABORT);
870     }
871 
872     player-&gt;notifyBufferChanged(std::unique_ptr&lt;PlatformTimeRanges&gt;(timeRanges), bytesLoaded);
873 }
874 
875 } // extern &quot;C&quot;
876 
877 } // namespace WebCore
878 
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperGC3DPlatformLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperGL.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperGL.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  version 2 of the License, or (at your option) any later version.
 10 
 11  This library is distributed in the hope that it will be useful,
 12  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  Library General Public License for more details.
 15 
 16  You should have received a copy of the GNU Library General Public License
 17  along with this library; see the file COPYING.LIB.  If not, write to
 18  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;TextureMapperGL.h&quot;
 24 
 25 #if USE(TEXTURE_MAPPER_GL)
 26 
 27 #include &quot;BitmapTextureGL.h&quot;
 28 #include &quot;BitmapTexturePool.h&quot;
<span class="line-modified"> 29 #include &quot;Extensions3D.h&quot;</span>
 30 #include &quot;FilterOperations.h&quot;
 31 #include &quot;FloatQuad.h&quot;
 32 #include &quot;GLContext.h&quot;
 33 #include &quot;GraphicsContext.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;LengthFunctions.h&quot;
 36 #include &quot;NotImplemented.h&quot;
 37 #include &quot;TextureMapperShaderProgram.h&quot;
 38 #include &quot;Timer.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/Ref.h&gt;
 42 #include &lt;wtf/RefCounted.h&gt;
 43 #include &lt;wtf/SetForScope.h&gt;
 44 
 45 #if USE(CAIRO)
 46 #include &quot;CairoUtilities.h&quot;
 47 #include &quot;RefPtrCairo.h&quot;
 48 #include &lt;cairo.h&gt;
 49 #include &lt;wtf/text/CString.h&gt;
</pre>
<hr />
<pre>
302     int stride = cairo_image_surface_get_stride(surface);
303     static_cast&lt;BitmapTextureGL*&gt;(texture.get())-&gt;updateContents(bits, sourceRect, IntPoint::zero(), stride);
304     drawTexture(*texture, targetRect, modelViewMatrix, 1.0f, AllEdges);
305 
306     cairo_surface_destroy(surface);
307     cairo_destroy(cr);
308 
309 #else
310     UNUSED_PARAM(number);
311     UNUSED_PARAM(pointSize);
312     UNUSED_PARAM(targetPoint);
313     UNUSED_PARAM(modelViewMatrix);
314     notImplemented();
315 #endif
316 }
317 
318 static TextureMapperShaderProgram::Options optionsForFilterType(FilterOperation::OperationType type, unsigned pass)
319 {
320     switch (type) {
321     case FilterOperation::GRAYSCALE:
<span class="line-modified">322         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::GrayscaleFilter;</span>
323     case FilterOperation::SEPIA:
<span class="line-modified">324         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::SepiaFilter;</span>
325     case FilterOperation::SATURATE:
<span class="line-modified">326         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::SaturateFilter;</span>
327     case FilterOperation::HUE_ROTATE:
<span class="line-modified">328         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::HueRotateFilter;</span>
329     case FilterOperation::INVERT:
<span class="line-modified">330         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::InvertFilter;</span>
331     case FilterOperation::BRIGHTNESS:
<span class="line-modified">332         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::BrightnessFilter;</span>
333     case FilterOperation::CONTRAST:
<span class="line-modified">334         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::ContrastFilter;</span>
335     case FilterOperation::OPACITY:
<span class="line-modified">336         return TextureMapperShaderProgram::Texture | TextureMapperShaderProgram::OpacityFilter;</span>
337     case FilterOperation::BLUR:
338         return TextureMapperShaderProgram::BlurFilter;
339     case FilterOperation::DROP_SHADOW:
340         return TextureMapperShaderProgram::AlphaBlur
341             | (pass ? TextureMapperShaderProgram::ContentTexture | TextureMapperShaderProgram::SolidColor: 0);
342     default:
343         ASSERT_NOT_REACHED();
344         return 0;
345     }
346 }
347 
348 // Create a normal distribution of 21 values between -2 and 2.
349 static const unsigned GaussianKernelHalfWidth = 11;
350 static const float GaussianKernelStep = 0.2;
351 
352 static inline float gauss(float x)
353 {
354     return exp(-(x * x) / 2.);
355 }
356 
</pre>
<hr />
<pre>
453 {
454     if (!texture.isValid())
455         return;
456 
457     if (clipStack().isCurrentScissorBoxEmpty())
458         return;
459 
460     const BitmapTextureGL&amp; textureGL = static_cast&lt;const BitmapTextureGL&amp;&gt;(texture);
461     SetForScope&lt;const BitmapTextureGL::FilterInfo*&gt; filterInfo(data().filterInfo, textureGL.filterInfo());
462 
463     drawTexture(textureGL.id(), textureGL.colorConvertFlags() | (textureGL.isOpaque() ? 0 : ShouldBlend), textureGL.size(), targetRect, matrix, opacity, exposedEdges);
464 }
465 
466 void TextureMapperGL::drawTexture(GLuint texture, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)
467 {
468     bool useRect = flags &amp; ShouldUseARBTextureRect;
469     bool useAntialiasing = m_enableEdgeDistanceAntialiasing
470         &amp;&amp; exposedEdges == AllEdges
471         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();
472 
<span class="line-modified">473     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::Texture;</span>
474     if (useRect)
475         options |= TextureMapperShaderProgram::Rect;
476     if (opacity &lt; 1)
477         options |= TextureMapperShaderProgram::Opacity;
478     if (useAntialiasing) {
479         options |= TextureMapperShaderProgram::Antialiasing;
480         flags |= ShouldAntialias;
481     }
482     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)
483         options |= TextureMapperShaderProgram::ManualRepeat;
484 
485     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;
486     GLuint filterContentTextureID = 0;
487 
488     if (filter) {
489         if (data().filterInfo-&gt;contentTexture)
490             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();
491         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);
492         if (filter-&gt;affectsOpacity())
493             flags |= ShouldBlend;
494     }
495 
496     if (useAntialiasing || opacity &lt; 1)
497         flags |= ShouldBlend;
498 
499     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);
500 
501     if (filter)
502         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);
503 
504     drawTexturedQuadWithProgram(program.get(), texture, flags, textureSize, targetRect, modelViewMatrix, opacity);
505 }
506 







































































































































































507 void TextureMapperGL::drawSolidColor(const FloatRect&amp; rect, const TransformationMatrix&amp; matrix, const Color&amp; color, bool isBlendingAllowed)
508 {
509     Flags flags = 0;
510     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::SolidColor;
511     if (!matrix.mapQuad(rect).isRectilinear()) {
512         options |= TextureMapperShaderProgram::Antialiasing;
513         flags |= ShouldAntialias | (isBlendingAllowed ? ShouldBlend : 0);
514     }
515 
516     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);
517     glUseProgram(program-&gt;programID());
518 
519     float r, g, b, a;
520     Color(premultipliedARGBFromColor(color)).getRGBA(r, g, b, a);
521     glUniform4f(program-&gt;colorLocation(), r, g, b, a);
522     if (a &lt; 1 &amp;&amp; isBlendingAllowed)
523         flags |= ShouldBlend;
524 
525     draw(rect, matrix, program.get(), GL_TRIANGLE_FAN, flags);
526 }
</pre>
<hr />
<pre>
537     const GLfloat top = 0;
538     const GLfloat right = 1;
539     const GLfloat bottom = 1;
540     const GLfloat center = 0.5;
541 
542 // Each 4d triangle consists of a center point and two edge points, where the zw coordinates
543 // of each vertex equals the nearest point to the vertex on the edge.
544 #define SIDE_TRIANGLE_DATA(x1, y1, x2, y2) \
545     x1, y1, x1, y1, \
546     x2, y2, x2, y2, \
547     center, center, (x1 + x2) / 2, (y1 + y2) / 2
548 
549     static const GLfloat unitRectSideTriangles[] = {
550         SIDE_TRIANGLE_DATA(left, top, right, top),
551         SIDE_TRIANGLE_DATA(left, top, left, bottom),
552         SIDE_TRIANGLE_DATA(right, top, right, bottom),
553         SIDE_TRIANGLE_DATA(left, bottom, right, bottom)
554     };
555 #undef SIDE_TRIANGLE_DATA
556 
<span class="line-modified">557     GLuint vbo = data().getStaticVBO(GL_ARRAY_BUFFER, sizeof(GC3Dfloat) * 48, unitRectSideTriangles);</span>
558     glBindBuffer(GL_ARRAY_BUFFER, vbo);
559     glVertexAttribPointer(program.vertexLocation(), 4, GL_FLOAT, false, 0, 0);
560     glDrawArrays(GL_TRIANGLES, 0, 12);
561     glBindBuffer(GL_ARRAY_BUFFER, 0);
562 }
563 
564 void TextureMapperGL::drawUnitRect(TextureMapperShaderProgram&amp; program, GLenum drawingMode)
565 {
566     static const GLfloat unitRect[] = { 0, 0, 1, 0, 1, 1, 0, 1 };
567     GLuint vbo = data().getStaticVBO(GL_ARRAY_BUFFER, sizeof(GLfloat) * 8, unitRect);
568     glBindBuffer(GL_ARRAY_BUFFER, vbo);
569     glVertexAttribPointer(program.vertexLocation(), 2, GL_FLOAT, false, 0, 0);
570     glDrawArrays(drawingMode, 0, 4);
571     glBindBuffer(GL_ARRAY_BUFFER, 0);
572 }
573 
574 void TextureMapperGL::draw(const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, TextureMapperShaderProgram&amp; program, GLenum drawingMode, Flags flags)
575 {
576     TransformationMatrix matrix(modelViewMatrix);
577     matrix.multiply(TransformationMatrix::rectToRect(FloatRect(0, 0, 1, 1), rect));
</pre>
<hr />
<pre>
584         glBlendFunc(GL_ZERO, GL_SRC_ALPHA);
585         glEnable(GL_BLEND);
586     } else {
587         if (flags &amp; ShouldBlend) {
588             glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
589             glEnable(GL_BLEND);
590         } else
591             glDisable(GL_BLEND);
592     }
593 
594     if (flags &amp; ShouldAntialias)
595         drawEdgeTriangles(program);
596     else
597         drawUnitRect(program, drawingMode);
598 
599     glDisableVertexAttribArray(program.vertexLocation());
600     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
601     glEnable(GL_BLEND);
602 }
603 
<span class="line-modified">604 void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram&amp; program, uint32_t texture, Flags flags, const IntSize&amp; size, const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
605 {
606     glUseProgram(program.programID());
<span class="line-modified">607     glActiveTexture(GL_TEXTURE0);</span>
<span class="line-modified">608     GLenum target = flags &amp; ShouldUseARBTextureRect ? GLenum(GL_TEXTURE_RECTANGLE_ARB) : GLenum(GL_TEXTURE_2D);</span>
<span class="line-modified">609     glBindTexture(target, texture);</span>
<span class="line-modified">610     glUniform1i(program.samplerLocation(), 0);</span>
<span class="line-modified">611     if (wrapMode() == RepeatWrap &amp;&amp; m_contextAttributes.supportsNPOTTextures) {</span>
<span class="line-modified">612         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span>
<span class="line-modified">613         glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span>












614     }
615 
616     TransformationMatrix patternTransform = this-&gt;patternTransform();
<span class="line-modified">617     if (flags &amp; ShouldRotateTexture90) {</span>
<span class="line-removed">618         patternTransform.rotate(-90);</span>
<span class="line-removed">619         patternTransform.translate(-1, 0);</span>
<span class="line-removed">620     }</span>
<span class="line-removed">621     if (flags &amp; ShouldRotateTexture180) {</span>
<span class="line-removed">622         patternTransform.rotate(180);</span>
<span class="line-removed">623         patternTransform.translate(-1, -1);</span>
<span class="line-removed">624     }</span>
<span class="line-removed">625     if (flags &amp; ShouldRotateTexture270) {</span>
<span class="line-removed">626         patternTransform.rotate(-270);</span>
<span class="line-removed">627         patternTransform.translate(0, -1);</span>
<span class="line-removed">628     }</span>
<span class="line-removed">629     if (flags &amp; ShouldFlipTexture)</span>
<span class="line-removed">630         patternTransform.flipY();</span>
<span class="line-removed">631     if (flags &amp; ShouldUseARBTextureRect)</span>
<span class="line-removed">632         patternTransform.scaleNonUniform(size.width(), size.height());</span>
<span class="line-removed">633     if (flags &amp; ShouldFlipTexture)</span>
<span class="line-removed">634         patternTransform.translate(0, -1);</span>
635 
636     program.setMatrix(program.textureSpaceMatrixLocation(), patternTransform);
637     program.setMatrix(program.textureColorSpaceMatrixLocation(), colorSpaceMatrixForFlags(flags));
638     glUniform1f(program.opacityLocation(), opacity);
639 
640     if (opacity &lt; 1)
641         flags |= ShouldBlend;
642 
643     draw(rect, modelViewMatrix, program, GL_TRIANGLE_FAN, flags);
<span class="line-modified">644     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span>
<span class="line-modified">645     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span>











646 }
647 
648 void TextureMapperGL::drawFiltered(const BitmapTexture&amp; sampler, const BitmapTexture* contentTexture, const FilterOperation&amp; filter, int pass)
649 {
650     // For standard filters, we always draw the whole texture without transformations.
651     TextureMapperShaderProgram::Options options = optionsForFilterType(filter.type(), pass);
652     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);
653 
654     prepareFilterProgram(program.get(), filter, pass, sampler.contentSize(), contentTexture ? static_cast&lt;const BitmapTextureGL*&gt;(contentTexture)-&gt;id() : 0);
655     FloatRect targetRect(IntPoint::zero(), sampler.contentSize());
656     drawTexturedQuadWithProgram(program.get(), static_cast&lt;const BitmapTextureGL&amp;&gt;(sampler).id(), 0, IntSize(1, 1), targetRect, TransformationMatrix(), 1);
657 }
658 
659 static inline TransformationMatrix createProjectionMatrix(const IntSize&amp; size, bool mirrored)
660 {
661     const float nearValue = 9999999;
662     const float farValue = -99999;
663 
664     return TransformationMatrix(2.0 / float(size.width()), 0, 0, 0,
665                                 0, (mirrored ? 2.0 : -2.0) / float(size.height()), 0, 0,
</pre>
<hr />
<pre>
776 {
777     clipStack().pop();
778     clipStack().applyIfNeeded();
779 }
780 
781 IntRect TextureMapperGL::clipBounds()
782 {
783     return clipStack().current().scissorBox;
784 }
785 
786 Ref&lt;BitmapTexture&gt; TextureMapperGL::createTexture(GLint internalFormat)
787 {
788     return BitmapTextureGL::create(m_contextAttributes, internalFormat);
789 }
790 
791 std::unique_ptr&lt;TextureMapper&gt; TextureMapper::platformCreateAccelerated()
792 {
793     return makeUnique&lt;TextureMapperGL&gt;();
794 }
795 







796 };
797 
798 #endif // USE(TEXTURE_MAPPER_GL)
</pre>
</td>
<td>
<hr />
<pre>
  9  version 2 of the License, or (at your option) any later version.
 10 
 11  This library is distributed in the hope that it will be useful,
 12  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  Library General Public License for more details.
 15 
 16  You should have received a copy of the GNU Library General Public License
 17  along with this library; see the file COPYING.LIB.  If not, write to
 18  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;TextureMapperGL.h&quot;
 24 
 25 #if USE(TEXTURE_MAPPER_GL)
 26 
 27 #include &quot;BitmapTextureGL.h&quot;
 28 #include &quot;BitmapTexturePool.h&quot;
<span class="line-modified"> 29 #include &quot;ExtensionsGL.h&quot;</span>
 30 #include &quot;FilterOperations.h&quot;
 31 #include &quot;FloatQuad.h&quot;
 32 #include &quot;GLContext.h&quot;
 33 #include &quot;GraphicsContext.h&quot;
 34 #include &quot;Image.h&quot;
 35 #include &quot;LengthFunctions.h&quot;
 36 #include &quot;NotImplemented.h&quot;
 37 #include &quot;TextureMapperShaderProgram.h&quot;
 38 #include &quot;Timer.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/Ref.h&gt;
 42 #include &lt;wtf/RefCounted.h&gt;
 43 #include &lt;wtf/SetForScope.h&gt;
 44 
 45 #if USE(CAIRO)
 46 #include &quot;CairoUtilities.h&quot;
 47 #include &quot;RefPtrCairo.h&quot;
 48 #include &lt;cairo.h&gt;
 49 #include &lt;wtf/text/CString.h&gt;
</pre>
<hr />
<pre>
302     int stride = cairo_image_surface_get_stride(surface);
303     static_cast&lt;BitmapTextureGL*&gt;(texture.get())-&gt;updateContents(bits, sourceRect, IntPoint::zero(), stride);
304     drawTexture(*texture, targetRect, modelViewMatrix, 1.0f, AllEdges);
305 
306     cairo_surface_destroy(surface);
307     cairo_destroy(cr);
308 
309 #else
310     UNUSED_PARAM(number);
311     UNUSED_PARAM(pointSize);
312     UNUSED_PARAM(targetPoint);
313     UNUSED_PARAM(modelViewMatrix);
314     notImplemented();
315 #endif
316 }
317 
318 static TextureMapperShaderProgram::Options optionsForFilterType(FilterOperation::OperationType type, unsigned pass)
319 {
320     switch (type) {
321     case FilterOperation::GRAYSCALE:
<span class="line-modified">322         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::GrayscaleFilter;</span>
323     case FilterOperation::SEPIA:
<span class="line-modified">324         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::SepiaFilter;</span>
325     case FilterOperation::SATURATE:
<span class="line-modified">326         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::SaturateFilter;</span>
327     case FilterOperation::HUE_ROTATE:
<span class="line-modified">328         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::HueRotateFilter;</span>
329     case FilterOperation::INVERT:
<span class="line-modified">330         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::InvertFilter;</span>
331     case FilterOperation::BRIGHTNESS:
<span class="line-modified">332         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::BrightnessFilter;</span>
333     case FilterOperation::CONTRAST:
<span class="line-modified">334         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::ContrastFilter;</span>
335     case FilterOperation::OPACITY:
<span class="line-modified">336         return TextureMapperShaderProgram::TextureRGB | TextureMapperShaderProgram::OpacityFilter;</span>
337     case FilterOperation::BLUR:
338         return TextureMapperShaderProgram::BlurFilter;
339     case FilterOperation::DROP_SHADOW:
340         return TextureMapperShaderProgram::AlphaBlur
341             | (pass ? TextureMapperShaderProgram::ContentTexture | TextureMapperShaderProgram::SolidColor: 0);
342     default:
343         ASSERT_NOT_REACHED();
344         return 0;
345     }
346 }
347 
348 // Create a normal distribution of 21 values between -2 and 2.
349 static const unsigned GaussianKernelHalfWidth = 11;
350 static const float GaussianKernelStep = 0.2;
351 
352 static inline float gauss(float x)
353 {
354     return exp(-(x * x) / 2.);
355 }
356 
</pre>
<hr />
<pre>
453 {
454     if (!texture.isValid())
455         return;
456 
457     if (clipStack().isCurrentScissorBoxEmpty())
458         return;
459 
460     const BitmapTextureGL&amp; textureGL = static_cast&lt;const BitmapTextureGL&amp;&gt;(texture);
461     SetForScope&lt;const BitmapTextureGL::FilterInfo*&gt; filterInfo(data().filterInfo, textureGL.filterInfo());
462 
463     drawTexture(textureGL.id(), textureGL.colorConvertFlags() | (textureGL.isOpaque() ? 0 : ShouldBlend), textureGL.size(), targetRect, matrix, opacity, exposedEdges);
464 }
465 
466 void TextureMapperGL::drawTexture(GLuint texture, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)
467 {
468     bool useRect = flags &amp; ShouldUseARBTextureRect;
469     bool useAntialiasing = m_enableEdgeDistanceAntialiasing
470         &amp;&amp; exposedEdges == AllEdges
471         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();
472 
<span class="line-modified">473     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::TextureRGB;</span>
474     if (useRect)
475         options |= TextureMapperShaderProgram::Rect;
476     if (opacity &lt; 1)
477         options |= TextureMapperShaderProgram::Opacity;
478     if (useAntialiasing) {
479         options |= TextureMapperShaderProgram::Antialiasing;
480         flags |= ShouldAntialias;
481     }
482     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)
483         options |= TextureMapperShaderProgram::ManualRepeat;
484 
485     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;
486     GLuint filterContentTextureID = 0;
487 
488     if (filter) {
489         if (data().filterInfo-&gt;contentTexture)
490             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();
491         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);
492         if (filter-&gt;affectsOpacity())
493             flags |= ShouldBlend;
494     }
495 
496     if (useAntialiasing || opacity &lt; 1)
497         flags |= ShouldBlend;
498 
499     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);
500 
501     if (filter)
502         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);
503 
504     drawTexturedQuadWithProgram(program.get(), texture, flags, textureSize, targetRect, modelViewMatrix, opacity);
505 }
506 
<span class="line-added">507 static void prepareTransformationMatrixWithFlags(TransformationMatrix&amp; patternTransform, TextureMapperGL::Flags flags, const IntSize&amp; size)</span>
<span class="line-added">508 {</span>
<span class="line-added">509     if (flags &amp; TextureMapperGL::ShouldRotateTexture90) {</span>
<span class="line-added">510         patternTransform.rotate(-90);</span>
<span class="line-added">511         patternTransform.translate(-1, 0);</span>
<span class="line-added">512     }</span>
<span class="line-added">513     if (flags &amp; TextureMapperGL::ShouldRotateTexture180) {</span>
<span class="line-added">514         patternTransform.rotate(180);</span>
<span class="line-added">515         patternTransform.translate(-1, -1);</span>
<span class="line-added">516     }</span>
<span class="line-added">517     if (flags &amp; TextureMapperGL::ShouldRotateTexture270) {</span>
<span class="line-added">518         patternTransform.rotate(-270);</span>
<span class="line-added">519         patternTransform.translate(0, -1);</span>
<span class="line-added">520     }</span>
<span class="line-added">521     if (flags &amp; TextureMapperGL::ShouldFlipTexture)</span>
<span class="line-added">522         patternTransform.flipY();</span>
<span class="line-added">523     if (flags &amp; TextureMapperGL::ShouldUseARBTextureRect)</span>
<span class="line-added">524         patternTransform.scaleNonUniform(size.width(), size.height());</span>
<span class="line-added">525     if (flags &amp; TextureMapperGL::ShouldFlipTexture)</span>
<span class="line-added">526         patternTransform.translate(0, -1);</span>
<span class="line-added">527 }</span>
<span class="line-added">528 </span>
<span class="line-added">529 void TextureMapperGL::drawTexturePlanarYUV(const std::array&lt;GLuint, 3&gt;&amp; textures, const std::array&lt;GLfloat, 9&gt;&amp; yuvToRgbMatrix, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)</span>
<span class="line-added">530 {</span>
<span class="line-added">531     bool useRect = flags &amp; ShouldUseARBTextureRect;</span>
<span class="line-added">532     bool useAntialiasing = m_enableEdgeDistanceAntialiasing</span>
<span class="line-added">533         &amp;&amp; exposedEdges == AllEdges</span>
<span class="line-added">534         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();</span>
<span class="line-added">535 </span>
<span class="line-added">536     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::TextureYUV;</span>
<span class="line-added">537     if (useRect)</span>
<span class="line-added">538         options |= TextureMapperShaderProgram::Rect;</span>
<span class="line-added">539     if (opacity &lt; 1)</span>
<span class="line-added">540         options |= TextureMapperShaderProgram::Opacity;</span>
<span class="line-added">541     if (useAntialiasing) {</span>
<span class="line-added">542         options |= TextureMapperShaderProgram::Antialiasing;</span>
<span class="line-added">543         flags |= ShouldAntialias;</span>
<span class="line-added">544     }</span>
<span class="line-added">545     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)</span>
<span class="line-added">546         options |= TextureMapperShaderProgram::ManualRepeat;</span>
<span class="line-added">547 </span>
<span class="line-added">548     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;</span>
<span class="line-added">549     GLuint filterContentTextureID = 0;</span>
<span class="line-added">550 </span>
<span class="line-added">551     if (filter) {</span>
<span class="line-added">552         if (data().filterInfo-&gt;contentTexture)</span>
<span class="line-added">553             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();</span>
<span class="line-added">554         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);</span>
<span class="line-added">555         if (filter-&gt;affectsOpacity())</span>
<span class="line-added">556             flags |= ShouldBlend;</span>
<span class="line-added">557     }</span>
<span class="line-added">558 </span>
<span class="line-added">559     if (useAntialiasing || opacity &lt; 1)</span>
<span class="line-added">560         flags |= ShouldBlend;</span>
<span class="line-added">561 </span>
<span class="line-added">562     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);</span>
<span class="line-added">563 </span>
<span class="line-added">564     if (filter)</span>
<span class="line-added">565         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);</span>
<span class="line-added">566 </span>
<span class="line-added">567     Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt; texturesAndSamplers = {</span>
<span class="line-added">568         { textures[0], program-&gt;samplerYLocation() },</span>
<span class="line-added">569         { textures[1], program-&gt;samplerULocation() },</span>
<span class="line-added">570         { textures[2], program-&gt;samplerVLocation() }</span>
<span class="line-added">571     };</span>
<span class="line-added">572 </span>
<span class="line-added">573     glUseProgram(program-&gt;programID());</span>
<span class="line-added">574     glUniformMatrix3fv(program-&gt;yuvToRgbLocation(), 1, GL_FALSE, static_cast&lt;const GLfloat *&gt;(&amp;yuvToRgbMatrix[0]));</span>
<span class="line-added">575     drawTexturedQuadWithProgram(program.get(), texturesAndSamplers, flags, textureSize, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">576 }</span>
<span class="line-added">577 </span>
<span class="line-added">578 void TextureMapperGL::drawTextureSemiPlanarYUV(const std::array&lt;GLuint, 2&gt;&amp; textures, bool uvReversed, const std::array&lt;GLfloat, 9&gt;&amp; yuvToRgbMatrix, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)</span>
<span class="line-added">579 {</span>
<span class="line-added">580     bool useRect = flags &amp; ShouldUseARBTextureRect;</span>
<span class="line-added">581     bool useAntialiasing = m_enableEdgeDistanceAntialiasing</span>
<span class="line-added">582         &amp;&amp; exposedEdges == AllEdges</span>
<span class="line-added">583         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();</span>
<span class="line-added">584 </span>
<span class="line-added">585     TextureMapperShaderProgram::Options options = uvReversed ?</span>
<span class="line-added">586         TextureMapperShaderProgram::TextureNV21 : TextureMapperShaderProgram::TextureNV12;</span>
<span class="line-added">587     if (useRect)</span>
<span class="line-added">588         options |= TextureMapperShaderProgram::Rect;</span>
<span class="line-added">589     if (opacity &lt; 1)</span>
<span class="line-added">590         options |= TextureMapperShaderProgram::Opacity;</span>
<span class="line-added">591     if (useAntialiasing) {</span>
<span class="line-added">592         options |= TextureMapperShaderProgram::Antialiasing;</span>
<span class="line-added">593         flags |= ShouldAntialias;</span>
<span class="line-added">594     }</span>
<span class="line-added">595     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)</span>
<span class="line-added">596         options |= TextureMapperShaderProgram::ManualRepeat;</span>
<span class="line-added">597 </span>
<span class="line-added">598     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;</span>
<span class="line-added">599     GLuint filterContentTextureID = 0;</span>
<span class="line-added">600 </span>
<span class="line-added">601     if (filter) {</span>
<span class="line-added">602         if (data().filterInfo-&gt;contentTexture)</span>
<span class="line-added">603             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();</span>
<span class="line-added">604         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);</span>
<span class="line-added">605         if (filter-&gt;affectsOpacity())</span>
<span class="line-added">606             flags |= ShouldBlend;</span>
<span class="line-added">607     }</span>
<span class="line-added">608 </span>
<span class="line-added">609     if (useAntialiasing || opacity &lt; 1)</span>
<span class="line-added">610         flags |= ShouldBlend;</span>
<span class="line-added">611 </span>
<span class="line-added">612     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);</span>
<span class="line-added">613 </span>
<span class="line-added">614     if (filter)</span>
<span class="line-added">615         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);</span>
<span class="line-added">616 </span>
<span class="line-added">617     Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt; texturesAndSamplers = {</span>
<span class="line-added">618         { textures[0], program-&gt;samplerYLocation() },</span>
<span class="line-added">619         { textures[1], program-&gt;samplerULocation() }</span>
<span class="line-added">620     };</span>
<span class="line-added">621 </span>
<span class="line-added">622     glUseProgram(program-&gt;programID());</span>
<span class="line-added">623     glUniformMatrix3fv(program-&gt;yuvToRgbLocation(), 1, GL_FALSE, static_cast&lt;const GLfloat *&gt;(&amp;yuvToRgbMatrix[0]));</span>
<span class="line-added">624     drawTexturedQuadWithProgram(program.get(), texturesAndSamplers, flags, textureSize, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">625 }</span>
<span class="line-added">626 </span>
<span class="line-added">627 void TextureMapperGL::drawTexturePackedYUV(GLuint texture, const std::array&lt;GLfloat, 9&gt;&amp; yuvToRgbMatrix, Flags flags, const IntSize&amp; textureSize, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity, unsigned exposedEdges)</span>
<span class="line-added">628 {</span>
<span class="line-added">629     bool useRect = flags &amp; ShouldUseARBTextureRect;</span>
<span class="line-added">630     bool useAntialiasing = m_enableEdgeDistanceAntialiasing</span>
<span class="line-added">631         &amp;&amp; exposedEdges == AllEdges</span>
<span class="line-added">632         &amp;&amp; !modelViewMatrix.mapQuad(targetRect).isRectilinear();</span>
<span class="line-added">633 </span>
<span class="line-added">634     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::TexturePackedYUV;</span>
<span class="line-added">635     if (useRect)</span>
<span class="line-added">636         options |= TextureMapperShaderProgram::Rect;</span>
<span class="line-added">637     if (opacity &lt; 1)</span>
<span class="line-added">638         options |= TextureMapperShaderProgram::Opacity;</span>
<span class="line-added">639     if (useAntialiasing) {</span>
<span class="line-added">640         options |= TextureMapperShaderProgram::Antialiasing;</span>
<span class="line-added">641         flags |= ShouldAntialias;</span>
<span class="line-added">642     }</span>
<span class="line-added">643     if (wrapMode() == RepeatWrap &amp;&amp; !m_contextAttributes.supportsNPOTTextures)</span>
<span class="line-added">644         options |= TextureMapperShaderProgram::ManualRepeat;</span>
<span class="line-added">645 </span>
<span class="line-added">646     RefPtr&lt;FilterOperation&gt; filter = data().filterInfo ? data().filterInfo-&gt;filter: 0;</span>
<span class="line-added">647     GLuint filterContentTextureID = 0;</span>
<span class="line-added">648 </span>
<span class="line-added">649     if (filter) {</span>
<span class="line-added">650         if (data().filterInfo-&gt;contentTexture)</span>
<span class="line-added">651             filterContentTextureID = toBitmapTextureGL(data().filterInfo-&gt;contentTexture.get())-&gt;id();</span>
<span class="line-added">652         options |= optionsForFilterType(filter-&gt;type(), data().filterInfo-&gt;pass);</span>
<span class="line-added">653         if (filter-&gt;affectsOpacity())</span>
<span class="line-added">654             flags |= ShouldBlend;</span>
<span class="line-added">655     }</span>
<span class="line-added">656 </span>
<span class="line-added">657     if (useAntialiasing || opacity &lt; 1)</span>
<span class="line-added">658         flags |= ShouldBlend;</span>
<span class="line-added">659 </span>
<span class="line-added">660     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);</span>
<span class="line-added">661 </span>
<span class="line-added">662     if (filter)</span>
<span class="line-added">663         prepareFilterProgram(program.get(), *filter.get(), data().filterInfo-&gt;pass, textureSize, filterContentTextureID);</span>
<span class="line-added">664 </span>
<span class="line-added">665     Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt; texturesAndSamplers = {</span>
<span class="line-added">666         { texture, program-&gt;samplerLocation() }</span>
<span class="line-added">667     };</span>
<span class="line-added">668 </span>
<span class="line-added">669     glUseProgram(program-&gt;programID());</span>
<span class="line-added">670     glUniformMatrix3fv(program-&gt;yuvToRgbLocation(), 1, GL_FALSE, static_cast&lt;const GLfloat *&gt;(&amp;yuvToRgbMatrix[0]));</span>
<span class="line-added">671     drawTexturedQuadWithProgram(program.get(), texturesAndSamplers, flags, textureSize, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">672 }</span>
<span class="line-added">673 </span>
674 void TextureMapperGL::drawSolidColor(const FloatRect&amp; rect, const TransformationMatrix&amp; matrix, const Color&amp; color, bool isBlendingAllowed)
675 {
676     Flags flags = 0;
677     TextureMapperShaderProgram::Options options = TextureMapperShaderProgram::SolidColor;
678     if (!matrix.mapQuad(rect).isRectilinear()) {
679         options |= TextureMapperShaderProgram::Antialiasing;
680         flags |= ShouldAntialias | (isBlendingAllowed ? ShouldBlend : 0);
681     }
682 
683     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);
684     glUseProgram(program-&gt;programID());
685 
686     float r, g, b, a;
687     Color(premultipliedARGBFromColor(color)).getRGBA(r, g, b, a);
688     glUniform4f(program-&gt;colorLocation(), r, g, b, a);
689     if (a &lt; 1 &amp;&amp; isBlendingAllowed)
690         flags |= ShouldBlend;
691 
692     draw(rect, matrix, program.get(), GL_TRIANGLE_FAN, flags);
693 }
</pre>
<hr />
<pre>
704     const GLfloat top = 0;
705     const GLfloat right = 1;
706     const GLfloat bottom = 1;
707     const GLfloat center = 0.5;
708 
709 // Each 4d triangle consists of a center point and two edge points, where the zw coordinates
710 // of each vertex equals the nearest point to the vertex on the edge.
711 #define SIDE_TRIANGLE_DATA(x1, y1, x2, y2) \
712     x1, y1, x1, y1, \
713     x2, y2, x2, y2, \
714     center, center, (x1 + x2) / 2, (y1 + y2) / 2
715 
716     static const GLfloat unitRectSideTriangles[] = {
717         SIDE_TRIANGLE_DATA(left, top, right, top),
718         SIDE_TRIANGLE_DATA(left, top, left, bottom),
719         SIDE_TRIANGLE_DATA(right, top, right, bottom),
720         SIDE_TRIANGLE_DATA(left, bottom, right, bottom)
721     };
722 #undef SIDE_TRIANGLE_DATA
723 
<span class="line-modified">724     GLuint vbo = data().getStaticVBO(GL_ARRAY_BUFFER, sizeof(GCGLfloat) * 48, unitRectSideTriangles);</span>
725     glBindBuffer(GL_ARRAY_BUFFER, vbo);
726     glVertexAttribPointer(program.vertexLocation(), 4, GL_FLOAT, false, 0, 0);
727     glDrawArrays(GL_TRIANGLES, 0, 12);
728     glBindBuffer(GL_ARRAY_BUFFER, 0);
729 }
730 
731 void TextureMapperGL::drawUnitRect(TextureMapperShaderProgram&amp; program, GLenum drawingMode)
732 {
733     static const GLfloat unitRect[] = { 0, 0, 1, 0, 1, 1, 0, 1 };
734     GLuint vbo = data().getStaticVBO(GL_ARRAY_BUFFER, sizeof(GLfloat) * 8, unitRect);
735     glBindBuffer(GL_ARRAY_BUFFER, vbo);
736     glVertexAttribPointer(program.vertexLocation(), 2, GL_FLOAT, false, 0, 0);
737     glDrawArrays(drawingMode, 0, 4);
738     glBindBuffer(GL_ARRAY_BUFFER, 0);
739 }
740 
741 void TextureMapperGL::draw(const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, TextureMapperShaderProgram&amp; program, GLenum drawingMode, Flags flags)
742 {
743     TransformationMatrix matrix(modelViewMatrix);
744     matrix.multiply(TransformationMatrix::rectToRect(FloatRect(0, 0, 1, 1), rect));
</pre>
<hr />
<pre>
751         glBlendFunc(GL_ZERO, GL_SRC_ALPHA);
752         glEnable(GL_BLEND);
753     } else {
754         if (flags &amp; ShouldBlend) {
755             glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
756             glEnable(GL_BLEND);
757         } else
758             glDisable(GL_BLEND);
759     }
760 
761     if (flags &amp; ShouldAntialias)
762         drawEdgeTriangles(program);
763     else
764         drawUnitRect(program, drawingMode);
765 
766     glDisableVertexAttribArray(program.vertexLocation());
767     glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
768     glEnable(GL_BLEND);
769 }
770 
<span class="line-modified">771 void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram&amp; program, const Vector&lt;std::pair&lt;GLuint, GLuint&gt; &gt;&amp; texturesAndSamplers, Flags flags, const IntSize&amp; size, const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
772 {
773     glUseProgram(program.programID());
<span class="line-modified">774 </span>
<span class="line-modified">775     bool repeatWrap = wrapMode() == RepeatWrap &amp;&amp; m_contextAttributes.supportsNPOTTextures;</span>
<span class="line-modified">776     GLenum target;</span>
<span class="line-modified">777     if (flags &amp; ShouldUseExternalOESTextureRect)</span>
<span class="line-modified">778         target = GLenum(GL_TEXTURE_EXTERNAL_OES);</span>
<span class="line-modified">779     else</span>
<span class="line-modified">780         target = flags &amp; ShouldUseARBTextureRect ? GLenum(GL_TEXTURE_RECTANGLE_ARB) : GLenum(GL_TEXTURE_2D);</span>
<span class="line-added">781 </span>
<span class="line-added">782     for (unsigned i = 0; i &lt; texturesAndSamplers.size(); ++i) {</span>
<span class="line-added">783         auto&amp; textureAndSampler = texturesAndSamplers[i];</span>
<span class="line-added">784 </span>
<span class="line-added">785         glActiveTexture(GL_TEXTURE0 + i);</span>
<span class="line-added">786         glBindTexture(target, textureAndSampler.first);</span>
<span class="line-added">787         glUniform1i(textureAndSampler.second, i);</span>
<span class="line-added">788 </span>
<span class="line-added">789         if (repeatWrap) {</span>
<span class="line-added">790             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span>
<span class="line-added">791             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span>
<span class="line-added">792         }</span>
793     }
794 
795     TransformationMatrix patternTransform = this-&gt;patternTransform();
<span class="line-modified">796     prepareTransformationMatrixWithFlags(patternTransform, flags, size);</span>

















797 
798     program.setMatrix(program.textureSpaceMatrixLocation(), patternTransform);
799     program.setMatrix(program.textureColorSpaceMatrixLocation(), colorSpaceMatrixForFlags(flags));
800     glUniform1f(program.opacityLocation(), opacity);
801 
802     if (opacity &lt; 1)
803         flags |= ShouldBlend;
804 
805     draw(rect, modelViewMatrix, program, GL_TRIANGLE_FAN, flags);
<span class="line-modified">806 </span>
<span class="line-modified">807     if (repeatWrap) {</span>
<span class="line-added">808         for (auto&amp; textureAndSampler : texturesAndSamplers) {</span>
<span class="line-added">809             glBindTexture(target, textureAndSampler.first);</span>
<span class="line-added">810             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span>
<span class="line-added">811             glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span>
<span class="line-added">812         }</span>
<span class="line-added">813     }</span>
<span class="line-added">814 }</span>
<span class="line-added">815 </span>
<span class="line-added">816 void TextureMapperGL::drawTexturedQuadWithProgram(TextureMapperShaderProgram&amp; program, uint32_t texture, Flags flags, const IntSize&amp; size, const FloatRect&amp; rect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
<span class="line-added">817 {</span>
<span class="line-added">818     drawTexturedQuadWithProgram(program, { { texture, program.samplerLocation() } }, flags, size, rect, modelViewMatrix, opacity);</span>
819 }
820 
821 void TextureMapperGL::drawFiltered(const BitmapTexture&amp; sampler, const BitmapTexture* contentTexture, const FilterOperation&amp; filter, int pass)
822 {
823     // For standard filters, we always draw the whole texture without transformations.
824     TextureMapperShaderProgram::Options options = optionsForFilterType(filter.type(), pass);
825     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(options);
826 
827     prepareFilterProgram(program.get(), filter, pass, sampler.contentSize(), contentTexture ? static_cast&lt;const BitmapTextureGL*&gt;(contentTexture)-&gt;id() : 0);
828     FloatRect targetRect(IntPoint::zero(), sampler.contentSize());
829     drawTexturedQuadWithProgram(program.get(), static_cast&lt;const BitmapTextureGL&amp;&gt;(sampler).id(), 0, IntSize(1, 1), targetRect, TransformationMatrix(), 1);
830 }
831 
832 static inline TransformationMatrix createProjectionMatrix(const IntSize&amp; size, bool mirrored)
833 {
834     const float nearValue = 9999999;
835     const float farValue = -99999;
836 
837     return TransformationMatrix(2.0 / float(size.width()), 0, 0, 0,
838                                 0, (mirrored ? 2.0 : -2.0) / float(size.height()), 0, 0,
</pre>
<hr />
<pre>
949 {
950     clipStack().pop();
951     clipStack().applyIfNeeded();
952 }
953 
954 IntRect TextureMapperGL::clipBounds()
955 {
956     return clipStack().current().scissorBox;
957 }
958 
959 Ref&lt;BitmapTexture&gt; TextureMapperGL::createTexture(GLint internalFormat)
960 {
961     return BitmapTextureGL::create(m_contextAttributes, internalFormat);
962 }
963 
964 std::unique_ptr&lt;TextureMapper&gt; TextureMapper::platformCreateAccelerated()
965 {
966     return makeUnique&lt;TextureMapperGL&gt;();
967 }
968 
<span class="line-added">969 void TextureMapperGL::drawTextureExternalOES(GLuint texture, Flags flags, const IntSize&amp; size, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)</span>
<span class="line-added">970 {</span>
<span class="line-added">971     Ref&lt;TextureMapperShaderProgram&gt; program = data().getShaderProgram(TextureMapperShaderProgram::Option::TextureExternalOES);</span>
<span class="line-added">972     drawTexturedQuadWithProgram(program.get(), { { texture, program-&gt;externalOESTextureLocation() } },</span>
<span class="line-added">973         flags | TextureMapperGL::ShouldUseExternalOESTextureRect, size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">974 }</span>
<span class="line-added">975 </span>
976 };
977 
978 #endif // USE(TEXTURE_MAPPER_GL)
</pre>
</td>
</tr>
</table>
<center><a href="TextureMapperGC3DPlatformLayer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperGL.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
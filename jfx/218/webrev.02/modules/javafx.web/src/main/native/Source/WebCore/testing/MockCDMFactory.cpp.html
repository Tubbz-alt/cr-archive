<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/testing/MockCDMFactory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MockCDMFactory.h&quot;
 28 
 29 #if ENABLE(ENCRYPTED_MEDIA)
 30 
 31 #include &quot;InitDataRegistry.h&quot;
 32 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 33 #include &lt;wtf/Algorithms.h&gt;
 34 #include &lt;wtf/NeverDestroyed.h&gt;
 35 #include &lt;wtf/UUID.h&gt;
 36 #include &lt;wtf/text/StringHash.h&gt;
 37 #include &lt;wtf/text/StringView.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 MockCDMFactory::MockCDMFactory()
 42     : m_supportedSessionTypes({ MediaKeySessionType::Temporary, MediaKeySessionType::PersistentUsageRecord, MediaKeySessionType::PersistentLicense })
 43     , m_supportedEncryptionSchemes({ MediaKeyEncryptionScheme::cenc })
 44 {
 45     CDMFactory::registerFactory(*this);
 46 }
 47 
 48 MockCDMFactory::~MockCDMFactory()
 49 {
 50     unregister();
 51 }
 52 
 53 void MockCDMFactory::unregister()
 54 {
 55     if (m_registered) {
 56         CDMFactory::unregisterFactory(*this);
 57         m_registered = false;
 58     }
 59 }
 60 
 61 bool MockCDMFactory::supportsKeySystem(const String&amp; keySystem)
 62 {
 63     return equalIgnoringASCIICase(keySystem, &quot;org.webkit.mock&quot;);
 64 }
 65 
 66 void MockCDMFactory::addKeysToSessionWithID(const String&amp; id, Vector&lt;Ref&lt;SharedBuffer&gt;&gt;&amp;&amp; keys)
 67 {
 68     auto addResult = m_sessions.add(id, WTFMove(keys));
 69     if (addResult.isNewEntry)
 70         return;
 71 
 72     auto&amp; value = addResult.iterator-&gt;value;
 73     for (auto&amp; key : keys)
 74         value.append(WTFMove(key));
 75 }
 76 
 77 Vector&lt;Ref&lt;SharedBuffer&gt;&gt; MockCDMFactory::removeKeysFromSessionWithID(const String&amp; id)
 78 {
 79     auto it = m_sessions.find(id);
 80     if (it == m_sessions.end())
 81         return { };
 82 
 83     return WTFMove(it-&gt;value);
 84 }
 85 
 86 const Vector&lt;Ref&lt;SharedBuffer&gt;&gt;* MockCDMFactory::keysForSessionWithID(const String&amp; id) const
 87 {
 88     auto it = m_sessions.find(id);
 89     if (it == m_sessions.end())
 90         return nullptr;
 91     return &amp;it-&gt;value;
 92 }
 93 
 94 void MockCDMFactory::setSupportedDataTypes(Vector&lt;String&gt;&amp;&amp; types)
 95 {
 96     m_supportedDataTypes.clear();
 97     for (auto&amp; type : types)
 98         m_supportedDataTypes.append(type);
 99 }
100 
101 std::unique_ptr&lt;CDMPrivate&gt; MockCDMFactory::createCDM(const String&amp;)
102 {
103     return makeUnique&lt;MockCDM&gt;(makeWeakPtr(*this));
104 }
105 
106 MockCDM::MockCDM(WeakPtr&lt;MockCDMFactory&gt; factory)
107     : m_factory(WTFMove(factory))
108 {
109 }
110 
111 bool MockCDM::supportsInitDataType(const AtomString&amp; initDataType) const
112 {
113     if (m_factory)
114         return m_factory-&gt;supportedDataTypes().contains(initDataType);
115     return false;
116 }
117 
118 bool MockCDM::supportsConfiguration(const MediaKeySystemConfiguration&amp; configuration) const
119 {
120     auto capabilityHasSupportedEncryptionScheme = [&amp;] (auto&amp; capability) {
121         if (capability.encryptionScheme)
122             return m_factory-&gt;supportedEncryptionSchemes().contains(capability.encryptionScheme.value());
123         return true;
124     };
125 
126     if (!configuration.audioCapabilities.isEmpty() &amp;&amp; !anyOf(configuration.audioCapabilities, capabilityHasSupportedEncryptionScheme))
127         return false;
128 
129     if (!configuration.videoCapabilities.isEmpty() &amp;&amp; !anyOf(configuration.videoCapabilities, capabilityHasSupportedEncryptionScheme))
130         return false;
131 
132     return true;
133 
134 }
135 
136 bool MockCDM::supportsConfigurationWithRestrictions(const MediaKeySystemConfiguration&amp;, const MediaKeysRestrictions&amp;) const
137 {
138     // NOTE: Implement;
139     return true;
140 }
141 
142 bool MockCDM::supportsSessionTypeWithConfiguration(MediaKeySessionType&amp; sessionType, const MediaKeySystemConfiguration&amp;) const
143 {
144     if (!m_factory || !m_factory-&gt;supportedSessionTypes().contains(sessionType))
145         return false;
146 
147     // NOTE: Implement configuration checking;
148     return true;
149 }
150 
151 bool MockCDM::supportsRobustness(const String&amp; robustness) const
152 {
153     if (m_factory)
154         return m_factory-&gt;supportedRobustness().contains(robustness);
155     return false;
156 }
157 
158 MediaKeysRequirement MockCDM::distinctiveIdentifiersRequirement(const MediaKeySystemConfiguration&amp;, const MediaKeysRestrictions&amp;) const
159 {
160     if (m_factory)
161         return m_factory-&gt;distinctiveIdentifiersRequirement();
162     return MediaKeysRequirement::Optional;
163 }
164 
165 MediaKeysRequirement MockCDM::persistentStateRequirement(const MediaKeySystemConfiguration&amp;, const MediaKeysRestrictions&amp;) const
166 {
167     if (m_factory)
168         return m_factory-&gt;persistentStateRequirement();
169     return MediaKeysRequirement::Optional;
170 }
171 
172 bool MockCDM::distinctiveIdentifiersAreUniquePerOriginAndClearable(const MediaKeySystemConfiguration&amp;) const
173 {
174     // NOTE: Implement;
175     return true;
176 }
177 
178 RefPtr&lt;CDMInstance&gt; MockCDM::createInstance()
179 {
180     if (m_factory &amp;&amp; !m_factory-&gt;canCreateInstances())
181         return nullptr;
182     return adoptRef(new MockCDMInstance(makeWeakPtr(*this)));
183 }
184 
185 void MockCDM::loadAndInitialize()
186 {
187     // No-op.
188 }
189 
190 bool MockCDM::supportsServerCertificates() const
191 {
192     return m_factory &amp;&amp; m_factory-&gt;supportsServerCertificates();
193 }
194 
195 bool MockCDM::supportsSessions() const
196 {
197     return m_factory &amp;&amp; m_factory-&gt;supportsSessions();
198 }
199 
200 bool MockCDM::supportsInitData(const AtomString&amp; initDataType, const SharedBuffer&amp; initData) const
201 {
202     if (!supportsInitDataType(initDataType))
203         return false;
204 
205     UNUSED_PARAM(initData);
206     return true;
207 }
208 
209 RefPtr&lt;SharedBuffer&gt; MockCDM::sanitizeResponse(const SharedBuffer&amp; response) const
210 {
211     if (!charactersAreAllASCII(reinterpret_cast&lt;const LChar*&gt;(response.data()), response.size()))
212         return nullptr;
213 
214     Vector&lt;String&gt; responseArray = String(response.data(), response.size()).split(&#39; &#39;);
215 
216     if (!responseArray.contains(String(&quot;valid-response&quot;_s)))
217         return nullptr;
218 
219     return response.copy();
220 }
221 
222 Optional&lt;String&gt; MockCDM::sanitizeSessionId(const String&amp; sessionId) const
223 {
224     if (equalLettersIgnoringASCIICase(sessionId, &quot;valid-loaded-session&quot;))
225         return sessionId;
226     return WTF::nullopt;
227 }
228 
229 ProxyCDMMock::~ProxyCDMMock() = default;
230 
231 MockCDMInstance::MockCDMInstance(WeakPtr&lt;MockCDM&gt; cdm)
232     : m_cdm(cdm)
233 {
234 }
235 
236 CDMInstance::SuccessValue MockCDMInstance::initializeWithConfiguration(const MediaKeySystemConfiguration&amp; configuration)
237 {
238     if (!m_cdm || !m_cdm-&gt;supportsConfiguration(configuration))
239         return Failed;
240 
241     return Succeeded;
242 }
243 
244 CDMInstance::SuccessValue MockCDMInstance::setDistinctiveIdentifiersAllowed(bool distinctiveIdentifiersAllowed)
245 {
246     if (m_distinctiveIdentifiersAllowed == distinctiveIdentifiersAllowed)
247         return Succeeded;
248 
249     auto* factory = m_cdm ? m_cdm-&gt;factory() : nullptr;
250 
251     if (!factory || (!distinctiveIdentifiersAllowed &amp;&amp; factory-&gt;distinctiveIdentifiersRequirement() == MediaKeysRequirement::Required))
252         return Failed;
253 
254     m_distinctiveIdentifiersAllowed = distinctiveIdentifiersAllowed;
255     return Succeeded;
256 }
257 
258 CDMInstance::SuccessValue MockCDMInstance::setPersistentStateAllowed(bool persistentStateAllowed)
259 {
260     if (m_persistentStateAllowed == persistentStateAllowed)
261         return Succeeded;
262 
263     MockCDMFactory* factory = m_cdm ? m_cdm-&gt;factory() : nullptr;
264 
265     if (!factory || (!persistentStateAllowed &amp;&amp; factory-&gt;persistentStateRequirement() == MediaKeysRequirement::Required))
266         return Failed;
267 
268     m_persistentStateAllowed = persistentStateAllowed;
269     return Succeeded;
270 }
271 
272 CDMInstance::SuccessValue MockCDMInstance::setServerCertificate(Ref&lt;SharedBuffer&gt;&amp;&amp; certificate)
273 {
274     StringView certificateStringView(certificate-&gt;data(), certificate-&gt;size());
275 
276     if (equalIgnoringASCIICase(certificateStringView, &quot;valid&quot;))
277         return Succeeded;
278     return Failed;
279 }
280 
281 CDMInstance::SuccessValue MockCDMInstance::setStorageDirectory(const String&amp;)
282 {
283     // On disk storage is unused; no-op.
284     return Succeeded;
285 }
286 
287 const String&amp; MockCDMInstance::keySystem() const
288 {
289     static const NeverDestroyed&lt;String&gt; s_keySystem = MAKE_STATIC_STRING_IMPL(&quot;org.webkit.mock&quot;);
290 
291     return s_keySystem;
292 }
293 
294 RefPtr&lt;CDMInstanceSession&gt; MockCDMInstance::createSession()
295 {
296     return adoptRef(new MockCDMInstanceSession(makeWeakPtr(*this)));
297 }
298 
299 RefPtr&lt;ProxyCDM&gt; MockCDMInstance::proxyCDM() const
300 {
301     return adoptRef(new ProxyCDMMock());
302 }
303 
304 MockCDMInstanceSession::MockCDMInstanceSession(WeakPtr&lt;MockCDMInstance&gt;&amp;&amp; instance)
305     : m_instance(WTFMove(instance))
306 {
307 }
308 
309 void MockCDMInstanceSession::requestLicense(LicenseType licenseType, const AtomString&amp; initDataType, Ref&lt;SharedBuffer&gt;&amp;&amp; initData, LicenseCallback&amp;&amp; callback)
310 {
311     MockCDMFactory* factory = m_instance ? m_instance-&gt;factory() : nullptr;
312     if (!factory) {
313         callback(SharedBuffer::create(), emptyAtom(), false, SuccessValue::Failed);
314         return;
315     }
316 
317     if (!factory-&gt;supportedSessionTypes().contains(licenseType) || !factory-&gt;supportedDataTypes().contains(initDataType)) {
318         callback(SharedBuffer::create(), emptyString(), false, SuccessValue::Failed);
319         return;
320     }
321 
322     auto keyIDs = InitDataRegistry::shared().extractKeyIDs(initDataType, initData);
323     if (!keyIDs || keyIDs.value().isEmpty()) {
324         callback(SharedBuffer::create(), emptyString(), false, SuccessValue::Failed);
325         return;
326     }
327 
328     String sessionID = createCanonicalUUIDString();
329     factory-&gt;addKeysToSessionWithID(sessionID, WTFMove(keyIDs.value()));
330 
331     CString license { &quot;license&quot; };
332     callback(SharedBuffer::create(license.data(), license.length()), sessionID, false, SuccessValue::Succeeded);
333 }
334 
335 void MockCDMInstanceSession::updateLicense(const String&amp; sessionID, LicenseType, const SharedBuffer&amp; response, LicenseUpdateCallback&amp;&amp; callback)
336 {
337     MockCDMFactory* factory = m_instance ? m_instance-&gt;factory() : nullptr;
338     if (!factory) {
339         callback(false, WTF::nullopt, WTF::nullopt, WTF::nullopt, SuccessValue::Failed);
340         return;
341     }
342 
343     Vector&lt;String&gt; responseVector = String(response.data(), response.size()).split(&#39; &#39;);
344 
345     if (responseVector.contains(String(&quot;invalid-format&quot;_s))) {
346         callback(false, WTF::nullopt, WTF::nullopt, WTF::nullopt, SuccessValue::Failed);
347         return;
348     }
349 
350     Optional&lt;KeyStatusVector&gt; changedKeys;
351     if (responseVector.contains(String(&quot;keys-changed&quot;_s))) {
352         const auto* keys = factory-&gt;keysForSessionWithID(sessionID);
353         if (keys) {
354             KeyStatusVector keyStatusVector;
355             keyStatusVector.reserveInitialCapacity(keys-&gt;size());
356             for (auto&amp; key : *keys)
357                 keyStatusVector.uncheckedAppend({ key.copyRef(), KeyStatus::Usable });
358 
359             changedKeys = WTFMove(keyStatusVector);
360         }
361     }
362 
363     // FIXME: Session closure, expiration and message handling should be implemented
364     // once the relevant algorithms are supported.
365 
366     callback(false, WTFMove(changedKeys), WTF::nullopt, WTF::nullopt, SuccessValue::Succeeded);
367 }
368 
369 void MockCDMInstanceSession::loadSession(LicenseType, const String&amp;, const String&amp;, LoadSessionCallback&amp;&amp; callback)
370 {
371     MockCDMFactory* factory = m_instance ? m_instance-&gt;factory() : nullptr;
372     if (!factory) {
373         callback(WTF::nullopt, WTF::nullopt, WTF::nullopt, SuccessValue::Failed, SessionLoadFailure::Other);
374         return;
375     }
376 
377     // FIXME: Key status and expiration handling should be implemented once the relevant algorithms are supported.
378 
379     CString messageData { &quot;session loaded&quot; };
380     Message message { MessageType::LicenseRenewal, SharedBuffer::create(messageData.data(), messageData.length()) };
381 
382     callback(WTF::nullopt, WTF::nullopt, WTFMove(message), SuccessValue::Succeeded, SessionLoadFailure::None);
383 }
384 
385 void MockCDMInstanceSession::closeSession(const String&amp; sessionID, CloseSessionCallback&amp;&amp; callback)
386 {
387     MockCDMFactory* factory = m_instance ? m_instance-&gt;factory() : nullptr;
388     if (!factory) {
389         callback();
390         return;
391     }
392 
393     factory-&gt;removeSessionWithID(sessionID);
394     callback();
395 }
396 
397 void MockCDMInstanceSession::removeSessionData(const String&amp; id, LicenseType, RemoveSessionDataCallback&amp;&amp; callback)
398 {
399     MockCDMFactory* factory = m_instance ? m_instance-&gt;factory() : nullptr;
400     if (!factory) {
401         callback({ }, WTF::nullopt, SuccessValue::Failed);
402         return;
403     }
404 
405     auto keys = factory-&gt;removeKeysFromSessionWithID(id);
406     KeyStatusVector keyStatusVector;
407     keyStatusVector.reserveInitialCapacity(keys.size());
408     for (auto&amp; key : keys)
409         keyStatusVector.uncheckedAppend({ WTFMove(key), KeyStatus::Released });
410 
411     CString message { &quot;remove-message&quot; };
412     callback(WTFMove(keyStatusVector), SharedBuffer::create(message.data(), message.length()), SuccessValue::Succeeded);
413 }
414 
415 void MockCDMInstanceSession::storeRecordOfKeyUsage(const String&amp;)
416 {
417     // FIXME: This should be implemented along with the support for persistent-usage-record sessions.
418 }
419 
420 }
421 
422 #endif
    </pre>
  </body>
</html>
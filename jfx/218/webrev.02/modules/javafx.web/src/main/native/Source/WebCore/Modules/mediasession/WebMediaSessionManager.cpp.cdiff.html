<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../mediarecorder/MediaRecorderErrorEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebMediaSessionManager.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,16 ***</span>
<span class="line-new-header">--- 30,24 ---</span>
  
  #include &quot;FloatRect.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MediaPlaybackTargetPickerMock.h&quot;
  #include &quot;WebMediaSessionManagerClient.h&quot;
<span class="line-added">+ #include &lt;wtf/Algorithms.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/Logger.h&gt;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  static const Seconds taskDelayInterval { 100_ms };
  
<span class="line-added">+ #undef LOGIDENTIFIER</span>
<span class="line-added">+ #define LOGIDENTIFIER __func__</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef ALWAYS_LOG</span>
<span class="line-added">+ #define ALWAYS_LOG logger().logAlways</span>
<span class="line-added">+ </span>
  struct ClientState {
      WTF_MAKE_STRUCT_FAST_ALLOCATED;
  
      explicit ClientState(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
          : client(client)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,56 ***</span>
  static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
  {
      return value &amp; flags;
  }
  
<span class="line-modified">! #if !LOG_DISABLED</span>
<span class="line-removed">- static String mediaProducerStateString(MediaProducer::MediaStateFlags flags)</span>
  {
      StringBuilder string;
      if (flags &amp; MediaProducer::IsPlayingAudio)
<span class="line-modified">!         string.append(&quot;IsPlayingAudio + &quot;);</span>
      if (flags &amp; MediaProducer::IsPlayingVideo)
<span class="line-modified">!         string.append(&quot;IsPlayingVideo + &quot;);</span>
      if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
<span class="line-modified">!         string.append(&quot;IsPlayingToExternalDevice + &quot;);</span>
      if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
<span class="line-modified">!         string.append(&quot;HasPlaybackTargetAvailabilityListener + &quot;);</span>
      if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
<span class="line-modified">!         string.append(&quot;RequiresPlaybackTargetMonitoring + &quot;);</span>
      if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
<span class="line-modified">!         string.append(&quot;ExternalDeviceAutoPlayCandidate + &quot;);</span>
      if (flags &amp; MediaProducer::DidPlayToEnd)
<span class="line-modified">!         string.append(&quot;DidPlayToEnd + &quot;);</span>
      if (flags &amp; MediaProducer::HasAudioOrVideo)
<span class="line-modified">!         string.append(&quot;HasAudioOrVideo + &quot;);</span>
      if (string.isEmpty())
          string.append(&quot;IsNotPlaying&quot;);
      else
<span class="line-modified">!         string.resize(string.length() - 2);</span>
  
<span class="line-modified">!     return string.toString();</span>
  }
<span class="line-removed">- #endif</span>
  
<span class="line-modified">! void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)</span>
  {
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled - enabled = %i&quot;, (int)enabled);</span>
  
      if (m_mockPickerEnabled == enabled)
          return;
  
      m_mockPickerEnabled = enabled;
  }
  
  void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
  {
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::setMockMediaPlaybackTargetPickerState - name = %s, state = %i&quot;, name.utf8().data(), (int)state);</span>
<span class="line-removed">- </span>
      mockPicker().setState(name, state);
  }
  
  MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
  {
      if (!m_pickerOverride)
          m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
  
<span class="line-new-header">--- 72,113 ---</span>
  static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
  {
      return value &amp; flags;
  }
  
<span class="line-modified">! String mediaProducerStateString(MediaProducer::MediaStateFlags flags)</span>
  {
      StringBuilder string;
      if (flags &amp; MediaProducer::IsPlayingAudio)
<span class="line-modified">!         string.append(&quot;IsPlayingAudio+&quot;);</span>
      if (flags &amp; MediaProducer::IsPlayingVideo)
<span class="line-modified">!         string.append(&quot;IsPlayingVideo+&quot;);</span>
      if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
<span class="line-modified">!         string.append(&quot;IsPlayingToExternalDevice+&quot;);</span>
      if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
<span class="line-modified">!         string.append(&quot;HasTargetAvailabilityListener+&quot;);</span>
      if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
<span class="line-modified">!         string.append(&quot;RequiresTargetMonitoring+&quot;);</span>
      if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
<span class="line-modified">!         string.append(&quot;ExternalDeviceAutoPlayCandidate+&quot;);</span>
      if (flags &amp; MediaProducer::DidPlayToEnd)
<span class="line-modified">!         string.append(&quot;DidPlayToEnd+&quot;);</span>
      if (flags &amp; MediaProducer::HasAudioOrVideo)
<span class="line-modified">!         string.append(&quot;HasAudioOrVideo+&quot;);</span>
      if (string.isEmpty())
          string.append(&quot;IsNotPlaying&quot;);
      else
<span class="line-modified">!         string.resize(string.length() - 1);</span>
  
<span class="line-modified">!     return makeString(&quot; { &quot;, string.toString(), &quot; }&quot;);</span>
  }
  
<span class="line-modified">! class WebMediaSessionLogger {</span>
<span class="line-added">+     WTF_MAKE_NONCOPYABLE(WebMediaSessionLogger);</span>
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+ </span>
<span class="line-added">+     static std::unique_ptr&lt;WebMediaSessionLogger&gt; create(WebMediaSessionManager&amp; manager)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return makeUnique&lt;WebMediaSessionLogger&gt;(manager);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename... Arguments&gt;</span>
<span class="line-added">+     inline void logAlways(const char* methodName, ClientState* state, const Arguments&amp;... arguments) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!state-&gt;client.alwaysOnLoggingAllowed())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), state-&gt;contextId, state-&gt;flags, arguments...);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename... Arguments&gt;</span>
<span class="line-added">+     inline void logAlways(const char* methodName, const Arguments&amp;... arguments) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (!m_manager.alwaysOnLoggingAllowed())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), arguments...);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     friend std::unique_ptr&lt;WebMediaSessionLogger&gt; std::make_unique&lt;WebMediaSessionLogger&gt;(WebMediaSessionManager&amp;);</span>
<span class="line-added">+     WebMediaSessionLogger(WebMediaSessionManager&amp; manager)</span>
<span class="line-added">+         : m_manager(manager)</span>
<span class="line-added">+         , m_logger(Logger::create(this))</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     WebMediaSessionManager&amp; m_manager;</span>
<span class="line-added">+     Ref&lt;Logger&gt; m_logger;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ WebMediaSessionLogger&amp; WebMediaSessionManager::logger()</span>
  {
<span class="line-modified">!     if (!m_logger)</span>
<span class="line-added">+         m_logger = WebMediaSessionLogger::create(*this);</span>
  
<span class="line-added">+     return *m_logger;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool WebMediaSessionManager::alwaysOnLoggingAllowed() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return allOf(m_clientState, [] (auto&amp; state) {</span>
<span class="line-added">+         return state-&gt;client.alwaysOnLoggingAllowed();</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)</span>
<span class="line-added">+ {</span>
      if (m_mockPickerEnabled == enabled)
          return;
  
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
      m_mockPickerEnabled = enabled;
  }
  
  void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
  {
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER);</span>
      mockPicker().setState(name, state);
  }
  
<span class="line-added">+ void WebMediaSessionManager::mockMediaPlaybackTargetPickerDismissPopup()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+     mockPicker().dismissPopup();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
  {
      if (!m_pickerOverride)
          m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,12 ***</span>
      size_t index = find(&amp;client, contextId);
      ASSERT(index == notFound);
      if (index != notFound)
          return 0;
  
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::addPlaybackTargetPickerClient(%p + %llu)&quot;, &amp;client, contextId);</span>
<span class="line-removed">- </span>
      m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
  
      if (m_externalOutputDeviceAvailable || m_playbackTarget)
          scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
  
<span class="line-new-header">--- 206,11 ---</span>
      size_t index = find(&amp;client, contextId);
      ASSERT(index == notFound);
      if (index != notFound)
          return 0;
  
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER, contextId);</span>
      m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
  
      if (m_externalOutputDeviceAvailable || m_playbackTarget)
          scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,26 ***</span>
      size_t index = find(&amp;client, contextId);
      ASSERT(index != notFound);
      if (index == notFound)
          return;
  
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::removePlaybackTargetPickerClient(%p + %llu)&quot;, &amp;client, contextId);</span>
  
      m_clientState.remove(index);
      scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
  }
  
  void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
  {
      if (m_clientState.isEmpty())
          return;
  
<span class="line-removed">-     LOG(Media, &quot;WebMediaSessionManager::removeAllPlaybackTargetPickerClients(%p)&quot;, &amp;client);</span>
<span class="line-removed">- </span>
      for (size_t i = m_clientState.size(); i &gt; 0; --i) {
<span class="line-modified">!         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client)</span>
              m_clientState.remove(i - 1);
      }
      scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
  }
  
  void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
<span class="line-new-header">--- 222,26 ---</span>
      size_t index = find(&amp;client, contextId);
      ASSERT(index != notFound);
      if (index == notFound)
          return;
  
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());</span>
  
      m_clientState.remove(index);
      scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
  }
  
  void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
  {
      if (m_clientState.isEmpty())
          return;
  
      for (size_t i = m_clientState.size(); i &gt; 0; --i) {
<span class="line-modified">!         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, m_clientState[i - 1].get());</span>
              m_clientState.remove(i - 1);
<span class="line-added">+         }</span>
      }
      scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
  }
  
  void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,12 ***</span>
      for (auto&amp; state : m_clientState) {
          state-&gt;requestedPicker = state == clientRequestingPicker;
          state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
      }
  
      bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);
<span class="line-removed">-     LOG(Media, &quot;WebMediaSessionManager::showPlaybackTargetPicker(%p + %llu) - hasActiveRoute = %i&quot;, &amp;client, contextId, (int)hasActiveRoute);</span>
      targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
  }
  
  void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
  {
<span class="line-new-header">--- 255,13 ---</span>
      for (auto&amp; state : m_clientState) {
          state-&gt;requestedPicker = state == clientRequestingPicker;
          state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
      }
  
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());</span>
<span class="line-added">+ </span>
      bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);
      targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
  }
  
  void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
      auto&amp; changedClientState = m_clientState[index];
      MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
      if (newFlags == oldFlags)
          return;
  
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::clientStateDidChange(%p + %llu) - new flags = %s, old flags = %s&quot;, &amp;client, contextId, mediaProducerStateString(newFlags).utf8().data(), mediaProducerStateString(oldFlags).utf8().data());</span>
  
      changedClientState-&gt;flags = newFlags;
  
      MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
      if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
<span class="line-new-header">--- 273,11 ---</span>
      auto&amp; changedClientState = m_clientState[index];
      MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
      if (newFlags == oldFlags)
          return;
  
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get(), &quot;new flags = &quot;, newFlags);</span>
  
      changedClientState-&gt;flags = newFlags;
  
      MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
      if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,46 ***</span>
      // Do not interrupt another element already playing to a device.
      for (auto&amp; state : m_clientState) {
          if (state == changedClientState)
              continue;
  
<span class="line-modified">!         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))</span>
              return;
      }
  
      // Do not begin playing to the device unless playback has just started.
<span class="line-modified">!     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo))</span>
          return;
  
      for (auto&amp; state : m_clientState) {
          if (state == changedClientState)
              continue;
          state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
      }
  
      changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
  
      if (index &amp;&amp; m_clientState.size() &gt; 1)
          std::swap(m_clientState.at(index), m_clientState.at(0));
  }
  
  void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
  {
      m_playbackTarget = WTFMove(target);
      m_targetChanged = true;
      scheduleDelayedTask(TargetClientsConfigurationTask);
  }
  
  void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
  {
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::externalOutputDeviceAvailableDidChange - clients = %zu, available = %i&quot;, m_clientState.size(), (int)available);</span>
<span class="line-removed">- </span>
      m_externalOutputDeviceAvailable = available;
      for (auto&amp; state : m_clientState)
          state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
  }
  
  void WebMediaSessionManager::configureNewClients()
  {
      for (auto&amp; state : m_clientState) {
          if (!state-&gt;configurationRequired)
              continue;
<span class="line-new-header">--- 296,59 ---</span>
      // Do not interrupt another element already playing to a device.
      for (auto&amp; state : m_clientState) {
          if (state == changedClientState)
              continue;
  
<span class="line-modified">!         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo)) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; returning early&quot;);</span>
              return;
<span class="line-added">+         }</span>
      }
  
      // Do not begin playing to the device unless playback has just started.
<span class="line-modified">!     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo)) {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning early, playback didn&#39;t just start&quot;);</span>
          return;
<span class="line-added">+     }</span>
  
      for (auto&amp; state : m_clientState) {
          if (state == changedClientState)
              continue;
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
          state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
      }
  
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER, changedClientState.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);</span>
      changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
  
      if (index &amp;&amp; m_clientState.size() &gt; 1)
          std::swap(m_clientState.at(index), m_clientState.at(0));
  }
  
  void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
  {
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER, &quot;has active route = &quot;, target-&gt;hasActiveRoute());</span>
      m_playbackTarget = WTFMove(target);
      m_targetChanged = true;
      scheduleDelayedTask(TargetClientsConfigurationTask);
  }
  
  void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
  {
<span class="line-modified">!     ALWAYS_LOG(LOGIDENTIFIER, available);</span>
      m_externalOutputDeviceAvailable = available;
      for (auto&amp; state : m_clientState)
          state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
  }
  
<span class="line-added">+ void WebMediaSessionManager::playbackTargetPickerWasDismissed()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">+     m_playbackTargetPickerDismissed = true;</span>
<span class="line-added">+     scheduleDelayedTask(TargetClientsConfigurationTask);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void WebMediaSessionManager::configureNewClients()
  {
      for (auto&amp; state : m_clientState) {
          if (!state-&gt;configurationRequired)
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,13 ***</span>
      bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
  
      for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
          auto&amp; state = m_clientState[i];
  
<span class="line-modified">!         LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetClients %zu - client (%p + %llu) requestedPicker = %i, flags = %s&quot;, i, &amp;state-&gt;client, state-&gt;contextId, state-&gt;requestedPicker, mediaProducerStateString(state-&gt;flags).utf8().data());</span>
  
<span class="line-modified">!         if (m_targetChanged &amp;&amp; state-&gt;requestedPicker)</span>
              indexOfClientThatRequestedPicker = i;
  
          if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
              indexOfClientWillPlayToTarget = i;
  
<span class="line-new-header">--- 373,13 ---</span>
      bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
  
      for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
          auto&amp; state = m_clientState[i];
  
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot;, requestedPicker = &quot;, state-&gt;requestedPicker);</span>
  
<span class="line-modified">!         if ((m_targetChanged || m_playbackTargetPickerDismissed) &amp;&amp; state-&gt;requestedPicker)</span>
              indexOfClientThatRequestedPicker = i;
  
          if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
              indexOfClientWillPlayToTarget = i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,30 ***</span>
      if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
          indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
      if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
          indexOfClientWillPlayToTarget = 0;
  
<span class="line-removed">-     LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetClients - indexOfClientWillPlayToTarget = %zu&quot;, indexOfClientWillPlayToTarget);</span>
<span class="line-removed">- </span>
      for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
          auto&amp; state = m_clientState[i];
  
          if (m_playbackTarget)
              state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
  
<span class="line-modified">!         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute)</span>
              state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
  
          state-&gt;configurationRequired = false;
<span class="line-modified">!         if (m_targetChanged)</span>
              state-&gt;requestedPicker = false;
      }
  
      if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
          auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
<span class="line-modified">!         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))</span>
              state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);
      }
  
      m_targetChanged = false;
      configureWatchdogTimer();
  }
<span class="line-new-header">--- 392,37 ---</span>
      if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
          indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
      if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
          indexOfClientWillPlayToTarget = 0;
  
      for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
          auto&amp; state = m_clientState[i];
  
          if (m_playbackTarget)
              state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
  
<span class="line-modified">!         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
              state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (state-&gt;requestedPicker &amp;&amp; m_playbackTargetPickerDismissed) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling playbackTargetPickerWasDismissed&quot;);</span>
<span class="line-added">+             state-&gt;client.playbackTargetPickerWasDismissed(state-&gt;contextId);</span>
<span class="line-added">+         }</span>
  
          state-&gt;configurationRequired = false;
<span class="line-modified">!         if (m_targetChanged || m_playbackTargetPickerDismissed)</span>
              state-&gt;requestedPicker = false;
      }
  
      if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
          auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
<span class="line-modified">!         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice)) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);</span>
              state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);
<span class="line-added">+         }</span>
      }
  
      m_targetChanged = false;
      configureWatchdogTimer();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 346,61 ***</span>
  {
      bool monitoringRequired = false;
      bool hasAvailabilityListener = false;
      bool haveClientWithMedia = false;
      for (auto&amp; state : m_clientState) {
          if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
              monitoringRequired = true;
              break;
          }
          if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
              hasAvailabilityListener = true;
          if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
              haveClientWithMedia = true;
      }
  
<span class="line-modified">!     LOG(Media, &quot;WebMediaSessionManager::configurePlaybackTargetMonitoring - monitoringRequired = %i&quot;, static_cast&lt;int&gt;(monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)));</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia))</span>
          targetPicker().startingMonitoringPlaybackTargets();
<span class="line-modified">!     else</span>
          targetPicker().stopMonitoringPlaybackTargets();
  }
  
<span class="line-removed">- #if !LOG_DISABLED</span>
<span class="line-removed">- String WebMediaSessionManager::toString(ConfigurationTasks tasks)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     StringBuilder string;</span>
<span class="line-removed">-     if (tasks &amp; InitialConfigurationTask)</span>
<span class="line-removed">-         string.append(&quot;InitialConfigurationTask + &quot;);</span>
<span class="line-removed">-     if (tasks &amp; TargetClientsConfigurationTask)</span>
<span class="line-removed">-         string.append(&quot;TargetClientsConfigurationTask + &quot;);</span>
<span class="line-removed">-     if (tasks &amp; TargetMonitoringConfigurationTask)</span>
<span class="line-removed">-         string.append(&quot;TargetMonitoringConfigurationTask + &quot;);</span>
<span class="line-removed">-     if (tasks &amp; WatchdogTimerConfigurationTask)</span>
<span class="line-removed">-         string.append(&quot;WatchdogTimerConfigurationTask + &quot;);</span>
<span class="line-removed">-     if (string.isEmpty())</span>
<span class="line-removed">-         string.append(&quot;NoTask&quot;);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         string.resize(string.length() - 2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return string.toString();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
  {
<span class="line-removed">-     LOG(Media, &quot;WebMediaSessionManager::scheduleDelayedTask - %s&quot;, toString(tasks).utf8().data());</span>
<span class="line-removed">- </span>
      m_taskFlags |= tasks;
      m_taskTimer.startOneShot(taskDelayInterval);
  }
  
  void WebMediaSessionManager::taskTimerFired()
  {
<span class="line-removed">-     LOG(Media, &quot;WebMediaSessionManager::taskTimerFired - tasks = %s&quot;, toString(m_taskFlags).utf8().data());</span>
<span class="line-removed">- </span>
      if (m_taskFlags &amp; InitialConfigurationTask)
          configureNewClients();
      if (m_taskFlags &amp; TargetClientsConfigurationTask)
          configurePlaybackTargetClients();
      if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
<span class="line-new-header">--- 431,38 ---</span>
  {
      bool monitoringRequired = false;
      bool hasAvailabilityListener = false;
      bool haveClientWithMedia = false;
      for (auto&amp; state : m_clientState) {
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, state.get());</span>
          if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
              monitoringRequired = true;
              break;
          }
          if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
              hasAvailabilityListener = true;
          if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
              haveClientWithMedia = true;
      }
  
<span class="line-modified">!     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)) {</span>
<span class="line-modified">!         ALWAYS_LOG(LOGIDENTIFIER, &quot;starting monitoring&quot;);</span>
          targetPicker().startingMonitoringPlaybackTargets();
<span class="line-modified">!     } else {</span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping monitoring&quot;);</span>
          targetPicker().stopMonitoringPlaybackTargets();
<span class="line-added">+     }</span>
  }
  
  void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
  {
      m_taskFlags |= tasks;
      m_taskTimer.startOneShot(taskDelayInterval);
  }
  
  void WebMediaSessionManager::taskTimerFired()
  {
      if (m_taskFlags &amp; InitialConfigurationTask)
          configureNewClients();
      if (m_taskFlags &amp; TargetClientsConfigurationTask)
          configurePlaybackTargetClients();
      if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,44 ***</span>
  {
      static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
      static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
  
      if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
<span class="line-modified">!         m_watchdogTimer.stop();</span>
          return;
      }
  
      bool stopTimer = false;
      bool didPlayToEnd = false;
      for (auto&amp; state : m_clientState) {
          if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
              stopTimer = true;
          if (state-&gt;playedToEnd)
              didPlayToEnd = true;
          state-&gt;playedToEnd = false;
      }
  
      if (stopTimer) {
          m_currentWatchdogInterval = { };
          m_watchdogTimer.stop();
<span class="line-removed">-         LOG(Media, &quot;WebMediaSessionManager::configureWatchdogTimer - timer stopped&quot;);</span>
      } else {
          Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
          if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
              m_watchdogTimer.startOneShot(interval);
<span class="line-removed">-             LOG(Media, &quot;WebMediaSessionManager::configureWatchdogTimer - timer scheduled for %.0f seconds&quot;, interval.value());</span>
          }
          m_currentWatchdogInterval = interval;
      }
  }
  
  void WebMediaSessionManager::watchdogTimerFired()
  {
<span class="line-removed">-     LOG(Media, &quot;WebMediaSessionManager::watchdogTimerFired&quot;);</span>
      if (!m_playbackTarget)
          return;
  
      targetPicker().invalidatePlaybackTargets();
  }
  
  } // namespace WebCore
  
<span class="line-new-header">--- 487,52 ---</span>
  {
      static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
      static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
  
      if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
<span class="line-modified">!         if (m_watchdogTimer.isActive()) {</span>
<span class="line-added">+             ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);</span>
<span class="line-added">+             m_currentWatchdogInterval = { };</span>
<span class="line-added">+             m_watchdogTimer.stop();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          return;
      }
  
      bool stopTimer = false;
      bool didPlayToEnd = false;
      for (auto&amp; state : m_clientState) {
<span class="line-added">+ </span>
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; playedToEnd = &quot;, state-&gt;playedToEnd);</span>
<span class="line-added">+ </span>
          if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
              stopTimer = true;
          if (state-&gt;playedToEnd)
              didPlayToEnd = true;
          state-&gt;playedToEnd = false;
      }
  
      if (stopTimer) {
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);</span>
          m_currentWatchdogInterval = { };
          m_watchdogTimer.stop();
      } else {
          Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
          if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
              m_watchdogTimer.startOneShot(interval);
          }
<span class="line-added">+         ALWAYS_LOG(LOGIDENTIFIER, &quot;timer scheduled for &quot;, interval.value(), &quot; seconds&quot;);</span>
          m_currentWatchdogInterval = interval;
      }
  }
  
  void WebMediaSessionManager::watchdogTimerFired()
  {
      if (!m_playbackTarget)
          return;
  
<span class="line-added">+     ALWAYS_LOG(LOGIDENTIFIER);</span>
      targetPicker().invalidatePlaybackTargets();
  }
  
  } // namespace WebCore
  
</pre>
<center><a href="../mediarecorder/MediaRecorderErrorEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebMediaSessionManager.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
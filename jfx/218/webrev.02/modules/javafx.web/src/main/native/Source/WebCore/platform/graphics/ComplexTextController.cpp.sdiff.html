<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ColorSpace.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ComplexTextController.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ComplexTextController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>
<hr />
<pre>
 26 #include &quot;ComplexTextController.h&quot;
 27 
 28 #include &quot;CharacterProperties.h&quot;
 29 #include &quot;FloatSize.h&quot;
 30 #include &quot;FontCascade.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderText.h&quot;
 33 #include &quot;TextRun.h&quot;
 34 #include &lt;unicode/ubrk.h&gt;
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/StdLibExtras.h&gt;
 37 #include &lt;wtf/text/TextBreakIterator.h&gt;
 38 #include &lt;wtf/unicode/CharacterNames.h&gt;
 39 
 40 #if PLATFORM(IOS_FAMILY)
 41 #include &lt;CoreText/CoreText.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 
<span class="line-removed"> 46 #if PLATFORM(WIN)</span>
<span class="line-removed"> 47 </span>
<span class="line-removed"> 48 class TextLayout {</span>
<span class="line-removed"> 49 };</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51 void TextLayoutDeleter::operator()(TextLayout*) const</span>
<span class="line-removed"> 52 {</span>
<span class="line-removed"> 53 }</span>
<span class="line-removed"> 54 </span>
<span class="line-removed"> 55 std::unique_ptr&lt;TextLayout, TextLayoutDeleter&gt; FontCascade::createLayout(RenderText&amp;, float, bool) const</span>
<span class="line-removed"> 56 {</span>
<span class="line-removed"> 57     return nullptr;</span>
<span class="line-removed"> 58 }</span>
<span class="line-removed"> 59 </span>
<span class="line-removed"> 60 float FontCascade::width(TextLayout&amp;, unsigned, unsigned, HashSet&lt;const Font*&gt;*)</span>
<span class="line-removed"> 61 {</span>
<span class="line-removed"> 62     ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 63     return 0;</span>
<span class="line-removed"> 64 }</span>
<span class="line-removed"> 65 </span>
<span class="line-removed"> 66 #else</span>
<span class="line-removed"> 67 </span>
 68 class TextLayout {
 69     WTF_MAKE_FAST_ALLOCATED;
 70 public:
 71     static bool isNeeded(RenderText&amp; text, const FontCascade&amp; font)
 72     {
 73         TextRun run = RenderBlock::constructTextRun(text, text.style());
 74         return font.codePath(run) == FontCascade::Complex;
 75     }
 76 
 77     TextLayout(RenderText&amp; text, const FontCascade&amp; font, float xPos)
 78         : m_font(font)
 79         , m_run(constructTextRun(text, xPos))
 80         , m_controller(makeUnique&lt;ComplexTextController&gt;(m_font, m_run, true))
 81     {
 82     }
 83 
 84     float width(unsigned from, unsigned len, HashSet&lt;const Font*&gt;* fallbackFonts)
 85     {
 86         m_controller-&gt;advance(from, 0, ByWholeGlyphs, fallbackFonts);
 87         float beforeWidth = m_controller-&gt;runWidthSoFar();
</pre>
<hr />
<pre>
129         m_expansionPerOpportunity = 0;
130     else {
131         unsigned expansionOpportunityCount = FontCascade::expansionOpportunityCount(m_run.text(), m_run.ltr() ? TextDirection::LTR : TextDirection::RTL, m_run.expansionBehavior()).first;
132 
133         if (!expansionOpportunityCount)
134             m_expansionPerOpportunity = 0;
135         else
136             m_expansionPerOpportunity = m_expansion / expansionOpportunityCount;
137     }
138 }
139 
140 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, bool mayUseNaturalWritingDirection, HashSet&lt;const Font*&gt;* fallbackFonts, bool forTextEmphasis)
141     : m_fallbackFonts(fallbackFonts)
142     , m_font(font)
143     , m_run(run)
144     , m_end(run.length())
145     , m_expansion(run.expansion())
146     , m_mayUseNaturalWritingDirection(mayUseNaturalWritingDirection)
147     , m_forTextEmphasis(forTextEmphasis)
148 {
<span class="line-removed">149 #if PLATFORM(WIN)</span>
<span class="line-removed">150     ASSERT_NOT_REACHED();</span>
<span class="line-removed">151 #endif</span>
<span class="line-removed">152 </span>
153     computeExpansionOpportunity();
154 
155     collectComplexTextRuns();
156 
157     finishConstruction();
158 }
159 
160 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, Vector&lt;Ref&lt;ComplexTextRun&gt;&gt;&amp; runs)
161     : m_font(font)
162     , m_run(run)
163     , m_end(run.length())
164     , m_expansion(run.expansion())
165 {
166     computeExpansionOpportunity();
167 
168     for (auto&amp; run : runs)
169         m_complexTextRuns.append(run.ptr());
170 
171     finishConstruction();
172 }
173 
174 void ComplexTextController::finishConstruction()
175 {
176     adjustGlyphsAndAdvances();
177 
178     if (!m_isLTROnly) {
179         m_runIndices.reserveInitialCapacity(m_complexTextRuns.size());
180 
181         m_glyphCountFromStartToIndex.reserveInitialCapacity(m_complexTextRuns.size());
182         unsigned glyphCountSoFar = 0;
183         for (unsigned i = 0; i &lt; m_complexTextRuns.size(); ++i) {
184             m_glyphCountFromStartToIndex.uncheckedAppend(glyphCountSoFar);
185             glyphCountSoFar += m_complexTextRuns[i]-&gt;glyphCount();
186         }
187     }
188 }
189 
190 unsigned ComplexTextController::offsetForPosition(float h, bool includePartialGlyphs)
191 {
<span class="line-modified">192     if (h &gt;= m_totalWidth)</span>
193         return m_run.ltr() ? m_end : 0;
194 
195     if (h &lt; 0)
196         return m_run.ltr() ? 0 : m_end;
197 
198     float x = h;
199 
200     size_t runCount = m_complexTextRuns.size();
201     unsigned offsetIntoAdjustedGlyphs = 0;
202 
203     for (size_t r = 0; r &lt; runCount; ++r) {
204         const ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[r];
205         for (unsigned j = 0; j &lt; complexTextRun.glyphCount(); ++j) {
206             unsigned index = offsetIntoAdjustedGlyphs + j;
207             float adjustedAdvance = m_adjustedBaseAdvances[index].width();
208             bool hit = m_run.ltr() ? x &lt; adjustedAdvance : (x &lt;= adjustedAdvance &amp;&amp; adjustedAdvance);
209             if (hit) {
210                 unsigned hitGlyphStart = complexTextRun.indexAt(j);
211                 unsigned hitGlyphEnd;
212                 if (m_run.ltr())
</pre>
<hr />
<pre>
742         FloatPoint glyphOrigin;
743         unsigned lastCharacterIndex = m_run.ltr() ? std::numeric_limits&lt;unsigned&gt;::min() : std::numeric_limits&lt;unsigned&gt;::max();
744         bool isMonotonic = true;
745 
746         for (unsigned i = 0; i &lt; glyphCount; i++) {
747             unsigned characterIndex = complexTextRun.indexAt(i);
748             if (m_run.ltr()) {
749                 if (characterIndex &lt; lastCharacterIndex)
750                     isMonotonic = false;
751             } else {
752                 if (characterIndex &gt; lastCharacterIndex)
753                     isMonotonic = false;
754             }
755             UChar ch = *(cp + characterIndex);
756 
757             bool treatAsSpace = FontCascade::treatAsSpace(ch);
758             CGGlyph glyph = treatAsSpace ? font.spaceGlyph() : glyphs[i];
759             FloatSize advance = treatAsSpace ? FloatSize(spaceWidth, advances[i].height()) : advances[i];
760 
761             if (ch == &#39;\t&#39; &amp;&amp; m_run.allowTabs())
<span class="line-modified">762                 advance.setWidth(m_font.tabWidth(font, m_run.tabSize(), m_run.xPos() + m_totalWidth));</span>
763             else if (FontCascade::treatAsZeroWidthSpace(ch) &amp;&amp; !treatAsSpace) {
764                 advance.setWidth(0);
765                 glyph = font.spaceGlyph();
766             }
767 
768             if (!i) {
769                 advance.expand(complexTextRun.initialAdvance().width(), complexTextRun.initialAdvance().height());
770                 if (auto* origins = complexTextRun.glyphOrigins())
771                     advance.expand(-origins[0].x(), -origins[0].y());
772             }
773 
774             advance.expand(font.syntheticBoldOffset(), 0);
775 
776             if (hasExtraSpacing) {
777                 // If we&#39;re a glyph with an advance, add in letter-spacing.
778                 // That way we weed out zero width lurkers. This behavior matches the fast text code path.
779                 if (advance.width())
780                     advance.expand(m_font.letterSpacing(), 0);
781 
782                 unsigned characterIndexInRun = characterIndex + complexTextRun.stringLocation();
783                 bool isFirstCharacter = !(characterIndex + complexTextRun.stringLocation());
784                 bool isLastCharacter = characterIndexInRun + 1 == m_run.length() || (U16_IS_LEAD(ch) &amp;&amp; characterIndexInRun + 2 == m_run.length() &amp;&amp; U16_IS_TRAIL(*(cp + characterIndex + 1)));
785 
786                 bool forceLeadingExpansion = false; // On the left, regardless of m_run.ltr()
787                 bool forceTrailingExpansion = false; // On the right, regardless of m_run.ltr()
788                 bool forbidLeadingExpansion = false;
789                 bool forbidTrailingExpansion = false;
790                 if (runForcesLeadingExpansion)
791                     forceLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
792                 if (runForcesTrailingExpansion)
793                     forceTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
794                 if (runForbidsLeadingExpansion)
795                     forbidLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
796                 if (runForbidsTrailingExpansion)
797                     forbidTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
798                 // Handle justification and word-spacing.
<span class="line-modified">799                 bool ideograph = FontCascade::isCJKIdeographOrSymbol(ch);</span>

800                 if (treatAsSpace || ideograph || forceLeadingExpansion || forceTrailingExpansion) {
801                     // Distribute the run&#39;s total expansion evenly over all expansion opportunities in the run.
802                     if (m_expansion) {
803                         auto [expandLeft, expandRight] = expansionLocation(ideograph, treatAsSpace, m_run.ltr(), afterExpansion, forbidLeadingExpansion, forbidTrailingExpansion, forceLeadingExpansion, forceTrailingExpansion);
804                         if (expandLeft) {
805                             m_expansion -= m_expansionPerOpportunity;
806                             // Increase previous width
807                             if (m_adjustedBaseAdvances.isEmpty()) {
808                                 advance.expand(m_expansionPerOpportunity, 0);
809                                 complexTextRun.growInitialAdvanceHorizontally(m_expansionPerOpportunity);
810                             } else {
811                                 m_adjustedBaseAdvances.last().expand(m_expansionPerOpportunity, 0);
<span class="line-modified">812                                 m_totalWidth += m_expansionPerOpportunity;</span>
813                             }
814                         }
815                         if (expandRight) {
816                             m_expansion -= m_expansionPerOpportunity;
817                             advance.expand(m_expansionPerOpportunity, 0);
818                             afterExpansion = true;
819                         }
820                     } else
821                         afterExpansion = false;
822 
823                     // Account for word-spacing.
824                     if (treatAsSpace &amp;&amp; (ch != &#39;\t&#39; || !m_run.allowTabs()) &amp;&amp; (characterIndex &gt; 0 || runIndex &gt; 0 || ch == noBreakSpace) &amp;&amp; m_font.wordSpacing())
825                         advance.expand(m_font.wordSpacing(), 0);
826                 } else
827                     afterExpansion = false;
828             }
829 
<span class="line-modified">830             m_totalWidth += advance.width();</span>
831 
832             // FIXME: Combining marks should receive a text emphasis mark if they are combine with a space.
833             if (m_forTextEmphasis &amp;&amp; (!FontCascade::canReceiveTextEmphasis(ch) || (U_GET_GC_MASK(ch) &amp; U_GC_M_MASK)))
834                 glyph = 0;
835 
836             m_adjustedBaseAdvances.append(advance);
837             if (auto* origins = complexTextRun.glyphOrigins()) {
838                 ASSERT(m_glyphOrigins.size() &lt; m_adjustedBaseAdvances.size());
839                 m_glyphOrigins.grow(m_adjustedBaseAdvances.size());
840                 m_glyphOrigins[m_glyphOrigins.size() - 1] = origins[i];
841                 ASSERT(m_glyphOrigins.size() == m_adjustedBaseAdvances.size());
842             }
843             m_adjustedGlyphs.append(glyph);
844 
845             FloatRect glyphBounds = font.boundsForGlyph(glyph);
846             glyphBounds.move(glyphOrigin.x(), glyphOrigin.y());
847             m_minGlyphBoundingBoxX = std::min(m_minGlyphBoundingBoxX, glyphBounds.x());
848             m_maxGlyphBoundingBoxX = std::max(m_maxGlyphBoundingBoxX, glyphBounds.maxX());
849             m_minGlyphBoundingBoxY = std::min(m_minGlyphBoundingBoxY, glyphBounds.y());
850             m_maxGlyphBoundingBoxY = std::max(m_maxGlyphBoundingBoxY, glyphBounds.maxY());
</pre>
<hr />
<pre>
887     m_baseAdvances.fill(FloatSize(m_font.widthForGlyph(0), 0), m_glyphCount);
888 }
889 
890 ComplexTextController::ComplexTextRun::ComplexTextRun(const Vector&lt;FloatSize&gt;&amp; advances, const Vector&lt;FloatPoint&gt;&amp; origins, const Vector&lt;Glyph&gt;&amp; glyphs, const Vector&lt;unsigned&gt;&amp; stringIndices, FloatSize initialAdvance, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
891     : m_baseAdvances(advances)
892     , m_glyphOrigins(origins)
893     , m_glyphs(glyphs)
894     , m_coreTextIndices(stringIndices)
895     , m_initialAdvance(initialAdvance)
896     , m_font(font)
897     , m_characters(characters)
898     , m_stringLength(stringLength)
899     , m_indexBegin(indexBegin)
900     , m_indexEnd(indexEnd)
901     , m_glyphCount(glyphs.size())
902     , m_stringLocation(stringLocation)
903     , m_isLTR(ltr)
904 {
905 }
906 
<span class="line-removed">907 #endif</span>
<span class="line-removed">908 </span>
909 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre>
<hr />
<pre>
 26 #include &quot;ComplexTextController.h&quot;
 27 
 28 #include &quot;CharacterProperties.h&quot;
 29 #include &quot;FloatSize.h&quot;
 30 #include &quot;FontCascade.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderText.h&quot;
 33 #include &quot;TextRun.h&quot;
 34 #include &lt;unicode/ubrk.h&gt;
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/StdLibExtras.h&gt;
 37 #include &lt;wtf/text/TextBreakIterator.h&gt;
 38 #include &lt;wtf/unicode/CharacterNames.h&gt;
 39 
 40 #if PLATFORM(IOS_FAMILY)
 41 #include &lt;CoreText/CoreText.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 






















 46 class TextLayout {
 47     WTF_MAKE_FAST_ALLOCATED;
 48 public:
 49     static bool isNeeded(RenderText&amp; text, const FontCascade&amp; font)
 50     {
 51         TextRun run = RenderBlock::constructTextRun(text, text.style());
 52         return font.codePath(run) == FontCascade::Complex;
 53     }
 54 
 55     TextLayout(RenderText&amp; text, const FontCascade&amp; font, float xPos)
 56         : m_font(font)
 57         , m_run(constructTextRun(text, xPos))
 58         , m_controller(makeUnique&lt;ComplexTextController&gt;(m_font, m_run, true))
 59     {
 60     }
 61 
 62     float width(unsigned from, unsigned len, HashSet&lt;const Font*&gt;* fallbackFonts)
 63     {
 64         m_controller-&gt;advance(from, 0, ByWholeGlyphs, fallbackFonts);
 65         float beforeWidth = m_controller-&gt;runWidthSoFar();
</pre>
<hr />
<pre>
107         m_expansionPerOpportunity = 0;
108     else {
109         unsigned expansionOpportunityCount = FontCascade::expansionOpportunityCount(m_run.text(), m_run.ltr() ? TextDirection::LTR : TextDirection::RTL, m_run.expansionBehavior()).first;
110 
111         if (!expansionOpportunityCount)
112             m_expansionPerOpportunity = 0;
113         else
114             m_expansionPerOpportunity = m_expansion / expansionOpportunityCount;
115     }
116 }
117 
118 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, bool mayUseNaturalWritingDirection, HashSet&lt;const Font*&gt;* fallbackFonts, bool forTextEmphasis)
119     : m_fallbackFonts(fallbackFonts)
120     , m_font(font)
121     , m_run(run)
122     , m_end(run.length())
123     , m_expansion(run.expansion())
124     , m_mayUseNaturalWritingDirection(mayUseNaturalWritingDirection)
125     , m_forTextEmphasis(forTextEmphasis)
126 {




127     computeExpansionOpportunity();
128 
129     collectComplexTextRuns();
130 
131     finishConstruction();
132 }
133 
134 ComplexTextController::ComplexTextController(const FontCascade&amp; font, const TextRun&amp; run, Vector&lt;Ref&lt;ComplexTextRun&gt;&gt;&amp; runs)
135     : m_font(font)
136     , m_run(run)
137     , m_end(run.length())
138     , m_expansion(run.expansion())
139 {
140     computeExpansionOpportunity();
141 
142     for (auto&amp; run : runs)
143         m_complexTextRuns.append(run.ptr());
144 
145     finishConstruction();
146 }
147 
148 void ComplexTextController::finishConstruction()
149 {
150     adjustGlyphsAndAdvances();
151 
152     if (!m_isLTROnly) {
153         m_runIndices.reserveInitialCapacity(m_complexTextRuns.size());
154 
155         m_glyphCountFromStartToIndex.reserveInitialCapacity(m_complexTextRuns.size());
156         unsigned glyphCountSoFar = 0;
157         for (unsigned i = 0; i &lt; m_complexTextRuns.size(); ++i) {
158             m_glyphCountFromStartToIndex.uncheckedAppend(glyphCountSoFar);
159             glyphCountSoFar += m_complexTextRuns[i]-&gt;glyphCount();
160         }
161     }
162 }
163 
164 unsigned ComplexTextController::offsetForPosition(float h, bool includePartialGlyphs)
165 {
<span class="line-modified">166     if (h &gt;= m_totalAdvance.width())</span>
167         return m_run.ltr() ? m_end : 0;
168 
169     if (h &lt; 0)
170         return m_run.ltr() ? 0 : m_end;
171 
172     float x = h;
173 
174     size_t runCount = m_complexTextRuns.size();
175     unsigned offsetIntoAdjustedGlyphs = 0;
176 
177     for (size_t r = 0; r &lt; runCount; ++r) {
178         const ComplexTextRun&amp; complexTextRun = *m_complexTextRuns[r];
179         for (unsigned j = 0; j &lt; complexTextRun.glyphCount(); ++j) {
180             unsigned index = offsetIntoAdjustedGlyphs + j;
181             float adjustedAdvance = m_adjustedBaseAdvances[index].width();
182             bool hit = m_run.ltr() ? x &lt; adjustedAdvance : (x &lt;= adjustedAdvance &amp;&amp; adjustedAdvance);
183             if (hit) {
184                 unsigned hitGlyphStart = complexTextRun.indexAt(j);
185                 unsigned hitGlyphEnd;
186                 if (m_run.ltr())
</pre>
<hr />
<pre>
716         FloatPoint glyphOrigin;
717         unsigned lastCharacterIndex = m_run.ltr() ? std::numeric_limits&lt;unsigned&gt;::min() : std::numeric_limits&lt;unsigned&gt;::max();
718         bool isMonotonic = true;
719 
720         for (unsigned i = 0; i &lt; glyphCount; i++) {
721             unsigned characterIndex = complexTextRun.indexAt(i);
722             if (m_run.ltr()) {
723                 if (characterIndex &lt; lastCharacterIndex)
724                     isMonotonic = false;
725             } else {
726                 if (characterIndex &gt; lastCharacterIndex)
727                     isMonotonic = false;
728             }
729             UChar ch = *(cp + characterIndex);
730 
731             bool treatAsSpace = FontCascade::treatAsSpace(ch);
732             CGGlyph glyph = treatAsSpace ? font.spaceGlyph() : glyphs[i];
733             FloatSize advance = treatAsSpace ? FloatSize(spaceWidth, advances[i].height()) : advances[i];
734 
735             if (ch == &#39;\t&#39; &amp;&amp; m_run.allowTabs())
<span class="line-modified">736                 advance.setWidth(m_font.tabWidth(font, m_run.tabSize(), m_run.xPos() + m_totalAdvance.width()));</span>
737             else if (FontCascade::treatAsZeroWidthSpace(ch) &amp;&amp; !treatAsSpace) {
738                 advance.setWidth(0);
739                 glyph = font.spaceGlyph();
740             }
741 
742             if (!i) {
743                 advance.expand(complexTextRun.initialAdvance().width(), complexTextRun.initialAdvance().height());
744                 if (auto* origins = complexTextRun.glyphOrigins())
745                     advance.expand(-origins[0].x(), -origins[0].y());
746             }
747 
748             advance.expand(font.syntheticBoldOffset(), 0);
749 
750             if (hasExtraSpacing) {
751                 // If we&#39;re a glyph with an advance, add in letter-spacing.
752                 // That way we weed out zero width lurkers. This behavior matches the fast text code path.
753                 if (advance.width())
754                     advance.expand(m_font.letterSpacing(), 0);
755 
756                 unsigned characterIndexInRun = characterIndex + complexTextRun.stringLocation();
757                 bool isFirstCharacter = !(characterIndex + complexTextRun.stringLocation());
758                 bool isLastCharacter = characterIndexInRun + 1 == m_run.length() || (U16_IS_LEAD(ch) &amp;&amp; characterIndexInRun + 2 == m_run.length() &amp;&amp; U16_IS_TRAIL(*(cp + characterIndex + 1)));
759 
760                 bool forceLeadingExpansion = false; // On the left, regardless of m_run.ltr()
761                 bool forceTrailingExpansion = false; // On the right, regardless of m_run.ltr()
762                 bool forbidLeadingExpansion = false;
763                 bool forbidTrailingExpansion = false;
764                 if (runForcesLeadingExpansion)
765                     forceLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
766                 if (runForcesTrailingExpansion)
767                     forceTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
768                 if (runForbidsLeadingExpansion)
769                     forbidLeadingExpansion = m_run.ltr() ? isFirstCharacter : isLastCharacter;
770                 if (runForbidsTrailingExpansion)
771                     forbidTrailingExpansion = m_run.ltr() ? isLastCharacter : isFirstCharacter;
772                 // Handle justification and word-spacing.
<span class="line-modified">773                 static bool expandAroundIdeographs = FontCascade::canExpandAroundIdeographsInComplexText();</span>
<span class="line-added">774                 bool ideograph = expandAroundIdeographs &amp;&amp; FontCascade::isCJKIdeographOrSymbol(ch);</span>
775                 if (treatAsSpace || ideograph || forceLeadingExpansion || forceTrailingExpansion) {
776                     // Distribute the run&#39;s total expansion evenly over all expansion opportunities in the run.
777                     if (m_expansion) {
778                         auto [expandLeft, expandRight] = expansionLocation(ideograph, treatAsSpace, m_run.ltr(), afterExpansion, forbidLeadingExpansion, forbidTrailingExpansion, forceLeadingExpansion, forceTrailingExpansion);
779                         if (expandLeft) {
780                             m_expansion -= m_expansionPerOpportunity;
781                             // Increase previous width
782                             if (m_adjustedBaseAdvances.isEmpty()) {
783                                 advance.expand(m_expansionPerOpportunity, 0);
784                                 complexTextRun.growInitialAdvanceHorizontally(m_expansionPerOpportunity);
785                             } else {
786                                 m_adjustedBaseAdvances.last().expand(m_expansionPerOpportunity, 0);
<span class="line-modified">787                                 m_totalAdvance.expand(m_expansionPerOpportunity, 0);</span>
788                             }
789                         }
790                         if (expandRight) {
791                             m_expansion -= m_expansionPerOpportunity;
792                             advance.expand(m_expansionPerOpportunity, 0);
793                             afterExpansion = true;
794                         }
795                     } else
796                         afterExpansion = false;
797 
798                     // Account for word-spacing.
799                     if (treatAsSpace &amp;&amp; (ch != &#39;\t&#39; || !m_run.allowTabs()) &amp;&amp; (characterIndex &gt; 0 || runIndex &gt; 0 || ch == noBreakSpace) &amp;&amp; m_font.wordSpacing())
800                         advance.expand(m_font.wordSpacing(), 0);
801                 } else
802                     afterExpansion = false;
803             }
804 
<span class="line-modified">805             m_totalAdvance += advance;</span>
806 
807             // FIXME: Combining marks should receive a text emphasis mark if they are combine with a space.
808             if (m_forTextEmphasis &amp;&amp; (!FontCascade::canReceiveTextEmphasis(ch) || (U_GET_GC_MASK(ch) &amp; U_GC_M_MASK)))
809                 glyph = 0;
810 
811             m_adjustedBaseAdvances.append(advance);
812             if (auto* origins = complexTextRun.glyphOrigins()) {
813                 ASSERT(m_glyphOrigins.size() &lt; m_adjustedBaseAdvances.size());
814                 m_glyphOrigins.grow(m_adjustedBaseAdvances.size());
815                 m_glyphOrigins[m_glyphOrigins.size() - 1] = origins[i];
816                 ASSERT(m_glyphOrigins.size() == m_adjustedBaseAdvances.size());
817             }
818             m_adjustedGlyphs.append(glyph);
819 
820             FloatRect glyphBounds = font.boundsForGlyph(glyph);
821             glyphBounds.move(glyphOrigin.x(), glyphOrigin.y());
822             m_minGlyphBoundingBoxX = std::min(m_minGlyphBoundingBoxX, glyphBounds.x());
823             m_maxGlyphBoundingBoxX = std::max(m_maxGlyphBoundingBoxX, glyphBounds.maxX());
824             m_minGlyphBoundingBoxY = std::min(m_minGlyphBoundingBoxY, glyphBounds.y());
825             m_maxGlyphBoundingBoxY = std::max(m_maxGlyphBoundingBoxY, glyphBounds.maxY());
</pre>
<hr />
<pre>
862     m_baseAdvances.fill(FloatSize(m_font.widthForGlyph(0), 0), m_glyphCount);
863 }
864 
865 ComplexTextController::ComplexTextRun::ComplexTextRun(const Vector&lt;FloatSize&gt;&amp; advances, const Vector&lt;FloatPoint&gt;&amp; origins, const Vector&lt;Glyph&gt;&amp; glyphs, const Vector&lt;unsigned&gt;&amp; stringIndices, FloatSize initialAdvance, const Font&amp; font, const UChar* characters, unsigned stringLocation, unsigned stringLength, unsigned indexBegin, unsigned indexEnd, bool ltr)
866     : m_baseAdvances(advances)
867     , m_glyphOrigins(origins)
868     , m_glyphs(glyphs)
869     , m_coreTextIndices(stringIndices)
870     , m_initialAdvance(initialAdvance)
871     , m_font(font)
872     , m_characters(characters)
873     , m_stringLength(stringLength)
874     , m_indexBegin(indexBegin)
875     , m_indexEnd(indexEnd)
876     , m_glyphCount(glyphs.size())
877     , m_stringLocation(stringLocation)
878     , m_isLTR(ltr)
879 {
880 }
881 


882 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ColorSpace.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ComplexTextController.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArgList.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Library General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Library General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Library General Public License
 16  *  along with this library; see the file COPYING.LIB.  If not, write to
 17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  *  Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CallFrame.h&quot;
 25 #include &lt;wtf/CheckedArithmetic.h&gt;
 26 #include &lt;wtf/ForbidHeapAllocation.h&gt;
 27 #include &lt;wtf/HashSet.h&gt;
 28 
 29 namespace JSC {
 30 
 31 class MarkedArgumentBuffer : public RecordOverflow {
 32     WTF_MAKE_NONCOPYABLE(MarkedArgumentBuffer);
 33     WTF_FORBID_HEAP_ALLOCATION;
 34     friend class VM;
 35     friend class ArgList;
 36 
 37 public:
 38     using Base = RecordOverflow;
 39     static const size_t inlineCapacity = 8;
 40     typedef HashSet&lt;MarkedArgumentBuffer*&gt; ListSet;
 41 
 42     // Constructor for a read-write list, to which you may append values.
 43     // FIXME: Remove all clients of this API, then remove this API.
 44     MarkedArgumentBuffer()
 45         : m_size(0)
 46         , m_capacity(inlineCapacity)
 47         , m_buffer(m_inlineBuffer)
 48         , m_markSet(0)
 49     {
 50     }
 51 
 52     ~MarkedArgumentBuffer()
 53     {
 54         ASSERT(!m_needsOverflowCheck);
 55         if (m_markSet)
 56             m_markSet-&gt;remove(this);
 57 
 58         if (EncodedJSValue* base = mallocBase())
 59             Gigacage::free(Gigacage::JSValue, base);
 60     }
 61 
 62     size_t size() const { return m_size; }
 63     bool isEmpty() const { return !m_size; }
 64 
 65     JSValue at(int i) const
 66     {
 67         if (i &gt;= m_size)
 68             return jsUndefined();
 69 
 70         return JSValue::decode(slotFor(i));
 71     }
 72 
 73     void clear()
 74     {
 75         ASSERT(!m_needsOverflowCheck);
 76         clearOverflow();
 77         m_size = 0;
 78     }
 79 
 80     enum OverflowCheckAction {
 81         CrashOnOverflow,
 82         WillCheckLater
 83     };
 84     template&lt;OverflowCheckAction action&gt;
 85     void appendWithAction(JSValue v)
 86     {
 87         ASSERT(m_size &lt;= m_capacity);
 88         if (m_size == m_capacity || mallocBase()) {
 89             slowAppend(v);
 90             if (action == CrashOnOverflow)
 91                 RELEASE_ASSERT(!hasOverflowed());
 92             return;
 93         }
 94 
 95         slotFor(m_size) = JSValue::encode(v);
 96         ++m_size;
 97     }
 98     void append(JSValue v) { appendWithAction&lt;WillCheckLater&gt;(v); }
 99     void appendWithCrashOnOverflow(JSValue v) { appendWithAction&lt;CrashOnOverflow&gt;(v); }
100 
101     void removeLast()
102     {
103         ASSERT(m_size);
104         m_size--;
105     }
106 
107     JSValue last()
108     {
109         ASSERT(m_size);
110         return JSValue::decode(slotFor(m_size - 1));
111     }
112 
113     JSValue takeLast()
114     {
115         JSValue result = last();
116         removeLast();
117         return result;
118     }
119 
120     static void markLists(SlotVisitor&amp;, ListSet&amp;);
121 
122     void ensureCapacity(size_t requestedCapacity)
123     {
124         if (requestedCapacity &gt; static_cast&lt;size_t&gt;(m_capacity))
125             slowEnsureCapacity(requestedCapacity);
126     }
127 
128     bool hasOverflowed()
129     {
130         clearNeedsOverflowCheck();
131         return Base::hasOverflowed();
132     }
133 
134     void overflowCheckNotNeeded() { clearNeedsOverflowCheck(); }
135 
<a name="1" id="anc1"></a><span class="line-added">136     template&lt;typename Functor&gt;</span>
<span class="line-added">137     void fill(size_t count, const Functor&amp; func)</span>
<span class="line-added">138     {</span>
<span class="line-added">139         ASSERT(!m_size);</span>
<span class="line-added">140         ensureCapacity(count);</span>
<span class="line-added">141         if (Base::hasOverflowed())</span>
<span class="line-added">142             return;</span>
<span class="line-added">143         m_size = count;</span>
<span class="line-added">144         func(reinterpret_cast&lt;JSValue*&gt;(&amp;slotFor(0)));</span>
<span class="line-added">145     }</span>
<span class="line-added">146 </span>
147 private:
148     void expandCapacity();
149     void expandCapacity(int newCapacity);
150     void slowEnsureCapacity(size_t requestedCapacity);
151 
152     void addMarkSet(JSValue);
153 
154     JS_EXPORT_PRIVATE void slowAppend(JSValue);
155 
156     EncodedJSValue&amp; slotFor(int item) const
157     {
158         return m_buffer[item];
159     }
160 
161     EncodedJSValue* mallocBase()
162     {
163         if (m_buffer == m_inlineBuffer)
164             return 0;
165         return &amp;slotFor(0);
166     }
167 
<a name="2" id="anc2"></a><span class="line-modified">168 #if ASSERT_ENABLED</span>



169     void setNeedsOverflowCheck() { m_needsOverflowCheck = true; }
170     void clearNeedsOverflowCheck() { m_needsOverflowCheck = false; }
171 
172     bool m_needsOverflowCheck { false };
<a name="3" id="anc3"></a><span class="line-modified">173 #else</span>
<span class="line-added">174     void setNeedsOverflowCheck() { }</span>
<span class="line-added">175     void clearNeedsOverflowCheck() { }</span>
<span class="line-added">176 #endif // ASSERT_ENABLED</span>
177     int m_size;
178     int m_capacity;
179     EncodedJSValue m_inlineBuffer[inlineCapacity];
180     EncodedJSValue* m_buffer;
181     ListSet* m_markSet;
182 };
183 
184 class ArgList {
185     WTF_MAKE_FAST_ALLOCATED;
186     friend class Interpreter;
187     friend class JIT;
188 public:
189     ArgList()
190         : m_args(0)
191         , m_argCount(0)
192     {
193     }
194 
<a name="4" id="anc4"></a><span class="line-modified">195     ArgList(CallFrame* callFrame)</span>
<span class="line-modified">196         : m_args(reinterpret_cast&lt;JSValue*&gt;(&amp;callFrame[CallFrame::argumentOffset(0)]))</span>
<span class="line-modified">197         , m_argCount(callFrame-&gt;argumentCount())</span>
198     {
199     }
200 
201     ArgList(const MarkedArgumentBuffer&amp; args)
202         : m_args(reinterpret_cast&lt;JSValue*&gt;(args.m_buffer))
203         , m_argCount(args.size())
204     {
205     }
206 
207     JSValue at(int i) const
208     {
209         if (i &gt;= m_argCount)
210             return jsUndefined();
211         return m_args[i];
212     }
213 
214     bool isEmpty() const { return !m_argCount; }
215     size_t size() const { return m_argCount; }
216 
217     JS_EXPORT_PRIVATE void getSlice(int startIndex, ArgList&amp; result) const;
218 
219 private:
220     JSValue* data() const { return m_args; }
221 
222     JSValue* m_args;
223     int m_argCount;
224 };
225 
226 } // namespace JSC
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
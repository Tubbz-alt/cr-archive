<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRExit.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOSREntrypointCreationPhase.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSRExit.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRExit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,15 +27,16 @@</span>
  #include &quot;DFGOSRExit.h&quot;
  
  #if ENABLE(DFG_JIT)
  
  #include &quot;AssemblyHelpers.h&quot;
<span class="udiff-line-added">+ #include &quot;BytecodeUseDef.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;CheckpointOSRExitSideState.h&quot;</span>
  #include &quot;ClonedArguments.h&quot;
  #include &quot;DFGGraph.h&quot;
  #include &quot;DFGMayExit.h&quot;
  #include &quot;DFGOSRExitCompilerCommon.h&quot;
<span class="udiff-line-removed">- #include &quot;DFGOSRExitPreparation.h&quot;</span>
  #include &quot;DFGOperations.h&quot;
  #include &quot;DFGSpeculativeJIT.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;FrameTracers.h&quot;
  #include &quot;InlineCallFrame.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -45,892 +46,10 @@</span>
  #include &quot;ProbeContext.h&quot;
  #include &quot;ProbeFrame.h&quot;
  
  namespace JSC { namespace DFG {
  
<span class="udiff-line-removed">- // Probe based OSR Exit.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- using CPUState = Probe::CPUState;</span>
<span class="udiff-line-removed">- using Context = Probe::Context;</span>
<span class="udiff-line-removed">- using Frame = Probe::Frame;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void reifyInlinedCallFrames(Probe::Context&amp;, CodeBlock* baselineCodeBlock, const OSRExitBase&amp;);</span>
<span class="udiff-line-removed">- static void adjustAndJumpToTarget(Probe::Context&amp;, VM&amp;, CodeBlock*, CodeBlock* baselineCodeBlock, OSRExit&amp;);</span>
<span class="udiff-line-removed">- static void printOSRExit(Context&amp;, uint32_t osrExitIndex, const OSRExit&amp;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static JSValue jsValueFor(CPUState&amp; cpu, JSValueSource source)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (source.isAddress()) {</span>
<span class="udiff-line-removed">-         JSValue result;</span>
<span class="udiff-line-removed">-         std::memcpy(&amp;result, cpu.gpr&lt;uint8_t*&gt;(source.base()) + source.offset(), sizeof(JSValue));</span>
<span class="udiff-line-removed">-         return result;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-     return JSValue::decode(cpu.gpr&lt;EncodedJSValue&gt;(source.gpr()));</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     if (source.hasKnownTag())</span>
<span class="udiff-line-removed">-         return JSValue(source.tag(), cpu.gpr&lt;int32_t&gt;(source.payloadGPR()));</span>
<span class="udiff-line-removed">-     return JSValue(cpu.gpr&lt;int32_t&gt;(source.tagGPR()), cpu.gpr&lt;int32_t&gt;(source.payloadGPR()));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if NUMBER_OF_CALLEE_SAVES_REGISTERS &gt; 0</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Based on AssemblyHelpers::emitRestoreCalleeSavesFor().</span>
<span class="udiff-line-removed">- static void restoreCalleeSavesFor(Context&amp; context, CodeBlock* codeBlock)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(codeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const RegisterAtOffsetList* calleeSaves = codeBlock-&gt;calleeSaveRegisters();</span>
<span class="udiff-line-removed">-     RegisterSet dontRestoreRegisters = RegisterSet(RegisterSet::stackRegisters(), RegisterSet::allFPRs());</span>
<span class="udiff-line-removed">-     unsigned registerCount = calleeSaves-&gt;size();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     UCPURegister* physicalStackFrame = context.fp&lt;UCPURegister*&gt;();</span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; registerCount; i++) {</span>
<span class="udiff-line-removed">-         RegisterAtOffset entry = calleeSaves-&gt;at(i);</span>
<span class="udiff-line-removed">-         if (dontRestoreRegisters.get(entry.reg()))</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">-         // The callee saved values come from the original stack, not the recovered stack.</span>
<span class="udiff-line-removed">-         // Hence, we read the values directly from the physical stack memory instead of</span>
<span class="udiff-line-removed">-         // going through context.stack().</span>
<span class="udiff-line-removed">-         ASSERT(!(entry.offset() % sizeof(UCPURegister)));</span>
<span class="udiff-line-removed">-         context.gpr(entry.reg().gpr()) = physicalStackFrame[entry.offset() / sizeof(UCPURegister)];</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Based on AssemblyHelpers::emitSaveCalleeSavesFor().</span>
<span class="udiff-line-removed">- static void saveCalleeSavesFor(Context&amp; context, CodeBlock* codeBlock)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     auto&amp; stack = context.stack();</span>
<span class="udiff-line-removed">-     ASSERT(codeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const RegisterAtOffsetList* calleeSaves = codeBlock-&gt;calleeSaveRegisters();</span>
<span class="udiff-line-removed">-     RegisterSet dontSaveRegisters = RegisterSet(RegisterSet::stackRegisters(), RegisterSet::allFPRs());</span>
<span class="udiff-line-removed">-     unsigned registerCount = calleeSaves-&gt;size();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; registerCount; i++) {</span>
<span class="udiff-line-removed">-         RegisterAtOffset entry = calleeSaves-&gt;at(i);</span>
<span class="udiff-line-removed">-         if (dontSaveRegisters.get(entry.reg()))</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">-         stack.set(context.fp(), entry.offset(), context.gpr&lt;UCPURegister&gt;(entry.reg().gpr()));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Based on AssemblyHelpers::restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer().</span>
<span class="udiff-line-removed">- static void restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(Context&amp; context)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     VM&amp; vm = *context.arg&lt;VM*&gt;();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();</span>
<span class="udiff-line-removed">-     RegisterSet dontRestoreRegisters = RegisterSet::stackRegisters();</span>
<span class="udiff-line-removed">-     unsigned registerCount = allCalleeSaves-&gt;size();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     VMEntryRecord* entryRecord = vmEntryRecord(vm.topEntryFrame);</span>
<span class="udiff-line-removed">-     UCPURegister* calleeSaveBuffer = reinterpret_cast&lt;UCPURegister*&gt;(entryRecord-&gt;calleeSaveRegistersBuffer);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Restore all callee saves.</span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; registerCount; i++) {</span>
<span class="udiff-line-removed">-         RegisterAtOffset entry = allCalleeSaves-&gt;at(i);</span>
<span class="udiff-line-removed">-         if (dontRestoreRegisters.get(entry.reg()))</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">-         size_t uintptrOffset = entry.offset() / sizeof(UCPURegister);</span>
<span class="udiff-line-removed">-         if (entry.reg().isGPR())</span>
<span class="udiff-line-removed">-             context.gpr(entry.reg().gpr()) = calleeSaveBuffer[uintptrOffset];</span>
<span class="udiff-line-removed">-         else {</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-             context.fpr(entry.reg().fpr()) = bitwise_cast&lt;double&gt;(calleeSaveBuffer[uintptrOffset]);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-             // FIXME: &lt;https://webkit.org/b/193275&gt; support callee-saved floating point registers on 32-bit architectures</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Based on AssemblyHelpers::copyCalleeSavesToVMEntryFrameCalleeSavesBuffer().</span>
<span class="udiff-line-removed">- static void copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(Context&amp; context)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     VM&amp; vm = *context.arg&lt;VM*&gt;();</span>
<span class="udiff-line-removed">-     auto&amp; stack = context.stack();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     VMEntryRecord* entryRecord = vmEntryRecord(vm.topEntryFrame);</span>
<span class="udiff-line-removed">-     void* calleeSaveBuffer = entryRecord-&gt;calleeSaveRegistersBuffer;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();</span>
<span class="udiff-line-removed">-     RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();</span>
<span class="udiff-line-removed">-     unsigned registerCount = allCalleeSaves-&gt;size();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; registerCount; i++) {</span>
<span class="udiff-line-removed">-         RegisterAtOffset entry = allCalleeSaves-&gt;at(i);</span>
<span class="udiff-line-removed">-         if (dontCopyRegisters.get(entry.reg()))</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">-         if (entry.reg().isGPR())</span>
<span class="udiff-line-removed">-             stack.set(calleeSaveBuffer, entry.offset(), context.gpr&lt;UCPURegister&gt;(entry.reg().gpr()));</span>
<span class="udiff-line-removed">-         else {</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-             stack.set(calleeSaveBuffer, entry.offset(), context.fpr&lt;UCPURegister&gt;(entry.reg().fpr()));</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-             // FIXME: &lt;https://webkit.org/b/193275&gt; support callee-saved floating point registers on 32-bit architectures</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Based on AssemblyHelpers::emitSaveOrCopyCalleeSavesFor().</span>
<span class="udiff-line-removed">- static void saveOrCopyCalleeSavesFor(Context&amp; context, CodeBlock* codeBlock, VirtualRegister offsetVirtualRegister, bool wasCalledViaTailCall)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     Frame frame(context.fp(), context.stack());</span>
<span class="udiff-line-removed">-     ASSERT(codeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const RegisterAtOffsetList* calleeSaves = codeBlock-&gt;calleeSaveRegisters();</span>
<span class="udiff-line-removed">-     RegisterSet dontSaveRegisters = RegisterSet(RegisterSet::stackRegisters(), RegisterSet::allFPRs());</span>
<span class="udiff-line-removed">-     unsigned registerCount = calleeSaves-&gt;size();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     RegisterSet baselineCalleeSaves = RegisterSet::llintBaselineCalleeSaveRegisters();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; registerCount; i++) {</span>
<span class="udiff-line-removed">-         RegisterAtOffset entry = calleeSaves-&gt;at(i);</span>
<span class="udiff-line-removed">-         if (dontSaveRegisters.get(entry.reg()))</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         uintptr_t savedRegisterValue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (wasCalledViaTailCall &amp;&amp; baselineCalleeSaves.get(entry.reg()))</span>
<span class="udiff-line-removed">-             savedRegisterValue = frame.get&lt;uintptr_t&gt;(entry.offset());</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             savedRegisterValue = context.gpr(entry.reg().gpr());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         frame.set(offsetVirtualRegister.offsetInBytes() + entry.offset(), savedRegisterValue);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- #else // not NUMBER_OF_CALLEE_SAVES_REGISTERS &gt; 0</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void restoreCalleeSavesFor(Context&amp;, CodeBlock*) { }</span>
<span class="udiff-line-removed">- static void saveCalleeSavesFor(Context&amp;, CodeBlock*) { }</span>
<span class="udiff-line-removed">- static void restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(Context&amp;) { }</span>
<span class="udiff-line-removed">- static void copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(Context&amp;) { }</span>
<span class="udiff-line-removed">- static void saveOrCopyCalleeSavesFor(Context&amp;, CodeBlock*, VirtualRegister, bool) { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #endif // NUMBER_OF_CALLEE_SAVES_REGISTERS &gt; 0</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static JSCell* createDirectArgumentsDuringExit(Context&amp; context, CodeBlock* codeBlock, InlineCallFrame* inlineCallFrame, JSFunction* callee, int32_t argumentCount)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     VM&amp; vm = *context.arg&lt;VM*&gt;();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ASSERT(vm.heap.isDeferred());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (inlineCallFrame)</span>
<span class="udiff-line-removed">-         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     unsigned length = argumentCount - 1;</span>
<span class="udiff-line-removed">-     unsigned capacity = std::max(length, static_cast&lt;unsigned&gt;(codeBlock-&gt;numParameters() - 1));</span>
<span class="udiff-line-removed">-     DirectArguments* result = DirectArguments::create(</span>
<span class="udiff-line-removed">-         vm, codeBlock-&gt;globalObject()-&gt;directArgumentsStructure(), length, capacity);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     result-&gt;setCallee(vm, callee);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void* frameBase = context.fp&lt;Register*&gt;() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0);</span>
<span class="udiff-line-removed">-     Frame frame(frameBase, context.stack());</span>
<span class="udiff-line-removed">-     for (unsigned i = length; i--;)</span>
<span class="udiff-line-removed">-         result-&gt;setIndexQuickly(vm, i, frame.argument(i));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static JSCell* createClonedArgumentsDuringExit(Context&amp; context, CodeBlock* codeBlock, InlineCallFrame* inlineCallFrame, JSFunction* callee, int32_t argumentCount)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     VM&amp; vm = *context.arg&lt;VM*&gt;();</span>
<span class="udiff-line-removed">-     ExecState* exec = context.fp&lt;ExecState*&gt;();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ASSERT(vm.heap.isDeferred());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (inlineCallFrame)</span>
<span class="udiff-line-removed">-         codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     unsigned length = argumentCount - 1;</span>
<span class="udiff-line-removed">-     ClonedArguments* result = ClonedArguments::createEmpty(</span>
<span class="udiff-line-removed">-         vm, codeBlock-&gt;globalObject()-&gt;clonedArgumentsStructure(), callee, length);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void* frameBase = context.fp&lt;Register*&gt;() + (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0);</span>
<span class="udiff-line-removed">-     Frame frame(frameBase, context.stack());</span>
<span class="udiff-line-removed">-     for (unsigned i = length; i--;)</span>
<span class="udiff-line-removed">-         result-&gt;putDirectIndex(exec, i, frame.argument(i));</span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void emitRestoreArguments(Context&amp; context, CodeBlock* codeBlock, DFG::JITCode* dfgJITCode, const Operands&lt;ValueRecovery&gt;&amp; operands)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     Frame frame(context.fp(), context.stack());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     HashMap&lt;MinifiedID, int&gt; alreadyAllocatedArguments; // Maps phantom arguments node ID to operand.</span>
<span class="udiff-line-removed">-     for (size_t index = 0; index &lt; operands.size(); ++index) {</span>
<span class="udiff-line-removed">-         const ValueRecovery&amp; recovery = operands[index];</span>
<span class="udiff-line-removed">-         int operand = operands.operandForIndex(index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (recovery.technique() != DirectArgumentsThatWereNotCreated</span>
<span class="udiff-line-removed">-             &amp;&amp; recovery.technique() != ClonedArgumentsThatWereNotCreated)</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         MinifiedID id = recovery.nodeID();</span>
<span class="udiff-line-removed">-         auto iter = alreadyAllocatedArguments.find(id);</span>
<span class="udiff-line-removed">-         if (iter != alreadyAllocatedArguments.end()) {</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, frame.operand(iter-&gt;value));</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         InlineCallFrame* inlineCallFrame =</span>
<span class="udiff-line-removed">-             dfgJITCode-&gt;minifiedDFG.at(id)-&gt;inlineCallFrame();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         int stackOffset;</span>
<span class="udiff-line-removed">-         if (inlineCallFrame)</span>
<span class="udiff-line-removed">-             stackOffset = inlineCallFrame-&gt;stackOffset;</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             stackOffset = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         JSFunction* callee;</span>
<span class="udiff-line-removed">-         if (!inlineCallFrame || inlineCallFrame-&gt;isClosureCall)</span>
<span class="udiff-line-removed">-             callee = jsCast&lt;JSFunction*&gt;(frame.operand(stackOffset + CallFrameSlot::callee).asCell());</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             callee = jsCast&lt;JSFunction*&gt;(inlineCallFrame-&gt;calleeRecovery.constant().asCell());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         int32_t argumentCount;</span>
<span class="udiff-line-removed">-         if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs())</span>
<span class="udiff-line-removed">-             argumentCount = frame.operand&lt;int32_t&gt;(stackOffset + CallFrameSlot::argumentCount, PayloadOffset);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             argumentCount = inlineCallFrame-&gt;argumentCountIncludingThis;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         JSCell* argumentsObject;</span>
<span class="udiff-line-removed">-         switch (recovery.technique()) {</span>
<span class="udiff-line-removed">-         case DirectArgumentsThatWereNotCreated:</span>
<span class="udiff-line-removed">-             argumentsObject = createDirectArgumentsDuringExit(context, codeBlock, inlineCallFrame, callee, argumentCount);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         case ClonedArgumentsThatWereNotCreated:</span>
<span class="udiff-line-removed">-             argumentsObject = createClonedArgumentsDuringExit(context, codeBlock, inlineCallFrame, callee, argumentCount);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         frame.setOperand(operand, JSValue(argumentsObject));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         alreadyAllocatedArguments.add(id, operand);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // The following is a list of extra initializations that need to be done in order</span>
<span class="udiff-line-removed">- // of most likely needed (lower enum value) to least likely needed (higher enum value).</span>
<span class="udiff-line-removed">- // Each level initialization includes the previous lower enum value (see use of the</span>
<span class="udiff-line-removed">- // extraInitializationLevel value below).</span>
<span class="udiff-line-removed">- enum class ExtraInitializationLevel {</span>
<span class="udiff-line-removed">-     None,</span>
<span class="udiff-line-removed">-     SpeculationRecovery,</span>
<span class="udiff-line-removed">-     ValueProfileUpdate,</span>
<span class="udiff-line-removed">-     ArrayProfileUpdate,</span>
<span class="udiff-line-removed">-     Other</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void OSRExit::executeOSRExit(Context&amp; context)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     VM&amp; vm = *context.arg&lt;VM*&gt;();</span>
<span class="udiff-line-removed">-     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ExecState* exec = context.fp&lt;ExecState*&gt;();</span>
<span class="udiff-line-removed">-     ASSERT(&amp;exec-&gt;vm() == &amp;vm);</span>
<span class="udiff-line-removed">-     auto&amp; cpu = context.cpu;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (validateDFGDoesGC) {</span>
<span class="udiff-line-removed">-         // We&#39;re about to exit optimized code. So, there&#39;s no longer any optimized</span>
<span class="udiff-line-removed">-         // code running that expects no GC.</span>
<span class="udiff-line-removed">-         vm.heap.setExpectDoesGC(true);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (vm.callFrameForCatch) {</span>
<span class="udiff-line-removed">-         exec = vm.callFrameForCatch;</span>
<span class="udiff-line-removed">-         context.fp() = exec;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="udiff-line-removed">-     ASSERT(codeBlock);</span>
<span class="udiff-line-removed">-     ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t</span>
<span class="udiff-line-removed">-     // really be profitable.</span>
<span class="udiff-line-removed">-     DeferGCForAWhile deferGC(vm.heap);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     uint32_t exitIndex = vm.osrExitIndex;</span>
<span class="udiff-line-removed">-     DFG::JITCode* dfgJITCode = codeBlock-&gt;jitCode()-&gt;dfg();</span>
<span class="udiff-line-removed">-     OSRExit&amp; exit = dfgJITCode-&gt;osrExit[exitIndex];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ASSERT(!vm.callFrameForCatch || exit.m_kind == GenericUnwind);</span>
<span class="udiff-line-removed">-     EXCEPTION_ASSERT_UNUSED(scope, !!scope.exception() || !exit.isExceptionHandler());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (UNLIKELY(!exit.exitState)) {</span>
<span class="udiff-line-removed">-         ExtraInitializationLevel extraInitializationLevel = ExtraInitializationLevel::None;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // We only need to execute this block once for each OSRExit record. The computed</span>
<span class="udiff-line-removed">-         // results will be cached in the OSRExitState record for use of the rest of the</span>
<span class="udiff-line-removed">-         // exit ramp code.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Ensure we have baseline codeBlocks to OSR exit to.</span>
<span class="udiff-line-removed">-         prepareCodeOriginForOSRExit(exec, exit.m_codeOrigin);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         CodeBlock* baselineCodeBlock = codeBlock-&gt;baselineAlternative();</span>
<span class="udiff-line-removed">-         ASSERT(baselineCodeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         SpeculationRecovery* recovery = nullptr;</span>
<span class="udiff-line-removed">-         if (exit.m_recoveryIndex != UINT_MAX) {</span>
<span class="udiff-line-removed">-             recovery = &amp;dfgJITCode-&gt;speculationRecovery[exit.m_recoveryIndex];</span>
<span class="udiff-line-removed">-             extraInitializationLevel = std::max(extraInitializationLevel, ExtraInitializationLevel::SpeculationRecovery);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (UNLIKELY(exit.m_kind == GenericUnwind))</span>
<span class="udiff-line-removed">-             extraInitializationLevel = std::max(extraInitializationLevel, ExtraInitializationLevel::Other);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         ArrayProfile* arrayProfile = nullptr;</span>
<span class="udiff-line-removed">-         if (!!exit.m_jsValueSource) {</span>
<span class="udiff-line-removed">-             if (exit.m_valueProfile)</span>
<span class="udiff-line-removed">-                 extraInitializationLevel = std::max(extraInitializationLevel, ExtraInitializationLevel::ValueProfileUpdate);</span>
<span class="udiff-line-removed">-             if (exit.m_kind == BadCache || exit.m_kind == BadIndexingType) {</span>
<span class="udiff-line-removed">-                 CodeOrigin codeOrigin = exit.m_codeOriginForExitProfile;</span>
<span class="udiff-line-removed">-                 CodeBlock* profiledCodeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(codeOrigin, baselineCodeBlock);</span>
<span class="udiff-line-removed">-                 arrayProfile = profiledCodeBlock-&gt;getArrayProfile(codeOrigin.bytecodeIndex());</span>
<span class="udiff-line-removed">-                 if (arrayProfile)</span>
<span class="udiff-line-removed">-                     extraInitializationLevel = std::max(extraInitializationLevel, ExtraInitializationLevel::ArrayProfileUpdate);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         int32_t activeThreshold = baselineCodeBlock-&gt;adjustedCounterValue(Options::thresholdForOptimizeAfterLongWarmUp());</span>
<span class="udiff-line-removed">-         double adjustedThreshold = applyMemoryUsageHeuristicsAndConvertToInt(activeThreshold, baselineCodeBlock);</span>
<span class="udiff-line-removed">-         ASSERT(adjustedThreshold &gt; 0);</span>
<span class="udiff-line-removed">-         adjustedThreshold = BaselineExecutionCounter::clippedThreshold(codeBlock-&gt;globalObject(), adjustedThreshold);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         CodeBlock* codeBlockForExit = baselineCodeBlockForOriginAndBaselineCodeBlock(exit.m_codeOrigin, baselineCodeBlock);</span>
<span class="udiff-line-removed">-         const JITCodeMap&amp; codeMap = codeBlockForExit-&gt;jitCodeMap();</span>
<span class="udiff-line-removed">-         CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(exit.m_codeOrigin.bytecodeIndex());</span>
<span class="udiff-line-removed">-         ASSERT(codeLocation);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         void* jumpTarget = codeLocation.executableAddress();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Compute the value recoveries.</span>
<span class="udiff-line-removed">-         Operands&lt;ValueRecovery&gt; operands;</span>
<span class="udiff-line-removed">-         Vector&lt;UndefinedOperandSpan&gt; undefinedOperandSpans;</span>
<span class="udiff-line-removed">-         dfgJITCode-&gt;variableEventStream.reconstruct(codeBlock, exit.m_codeOrigin, dfgJITCode-&gt;minifiedDFG, exit.m_streamIndex, operands, &amp;undefinedOperandSpans);</span>
<span class="udiff-line-removed">-         ptrdiff_t stackPointerOffset = -static_cast&lt;ptrdiff_t&gt;(codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;requiredRegisterCountForExit) * sizeof(Register);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         exit.exitState = adoptRef(new OSRExitState(exit, codeBlock, baselineCodeBlock, operands, WTFMove(undefinedOperandSpans), recovery, stackPointerOffset, activeThreshold, adjustedThreshold, jumpTarget, arrayProfile));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (UNLIKELY(vm.m_perBytecodeProfiler &amp;&amp; codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;compilation)) {</span>
<span class="udiff-line-removed">-             Profiler::Database&amp; database = *vm.m_perBytecodeProfiler;</span>
<span class="udiff-line-removed">-             Profiler::Compilation* compilation = codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;compilation.get();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             Profiler::OSRExit* profilerExit = compilation-&gt;addOSRExit(</span>
<span class="udiff-line-removed">-                 exitIndex, Profiler::OriginStack(database, codeBlock, exit.m_codeOrigin),</span>
<span class="udiff-line-removed">-                 exit.m_kind, exit.m_kind == UncountableInvalidation);</span>
<span class="udiff-line-removed">-             exit.exitState-&gt;profilerExit = profilerExit;</span>
<span class="udiff-line-removed">-             extraInitializationLevel = std::max(extraInitializationLevel, ExtraInitializationLevel::Other);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (UNLIKELY(Options::printEachOSRExit()))</span>
<span class="udiff-line-removed">-             extraInitializationLevel = std::max(extraInitializationLevel, ExtraInitializationLevel::Other);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         exit.exitState-&gt;extraInitializationLevel = extraInitializationLevel;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (UNLIKELY(Options::verboseOSR() || Options::verboseDFGOSRExit())) {</span>
<span class="udiff-line-removed">-             dataLogF(&quot;DFG OSR exit #%u (%s, %s) from %s, with operands = %s\n&quot;,</span>
<span class="udiff-line-removed">-                 exitIndex, toCString(exit.m_codeOrigin).data(),</span>
<span class="udiff-line-removed">-                 exitKindToString(exit.m_kind), toCString(*codeBlock).data(),</span>
<span class="udiff-line-removed">-                 toCString(ignoringContext&lt;DumpContext&gt;(operands)).data());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     OSRExitState&amp; exitState = *exit.exitState.get();</span>
<span class="udiff-line-removed">-     CodeBlock* baselineCodeBlock = exitState.baselineCodeBlock;</span>
<span class="udiff-line-removed">-     ASSERT(baselineCodeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Operands&lt;ValueRecovery&gt;&amp; operands = exitState.operands;</span>
<span class="udiff-line-removed">-     Vector&lt;UndefinedOperandSpan&gt;&amp; undefinedOperandSpans = exitState.undefinedOperandSpans;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     context.sp() = context.fp&lt;uint8_t*&gt;() + exitState.stackPointerOffset;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // The only reason for using this do while loop is so we can break out midway when appropriate.</span>
<span class="udiff-line-removed">-     do {</span>
<span class="udiff-line-removed">-         auto extraInitializationLevel = static_cast&lt;ExtraInitializationLevel&gt;(exitState.extraInitializationLevel);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (extraInitializationLevel == ExtraInitializationLevel::None)</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Begin extra initilization level: SpeculationRecovery</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // We need to do speculation recovery first because array profiling and value profiling</span>
<span class="udiff-line-removed">-         // may rely on a value that it recovers. However, that doesn&#39;t mean that it is likely</span>
<span class="udiff-line-removed">-         // to have a recovery value. So, we&#39;ll decorate it as UNLIKELY.</span>
<span class="udiff-line-removed">-         SpeculationRecovery* recovery = exitState.recovery;</span>
<span class="udiff-line-removed">-         if (UNLIKELY(recovery)) {</span>
<span class="udiff-line-removed">-             switch (recovery-&gt;type()) {</span>
<span class="udiff-line-removed">-             case SpeculativeAdd:</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) = cpu.gpr&lt;uint32_t&gt;(recovery-&gt;dest()) - cpu.gpr&lt;uint32_t&gt;(recovery-&gt;src());</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-                 ASSERT(!(cpu.gpr(recovery-&gt;dest()) &gt;&gt; 32));</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) |= TagTypeNumber;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             case SpeculativeAddSelf:</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) = static_cast&lt;uint32_t&gt;(cpu.gpr&lt;int32_t&gt;(recovery-&gt;dest()) &gt;&gt; 1) ^ 0x80000000U;</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-                 ASSERT(!(cpu.gpr(recovery-&gt;dest()) &gt;&gt; 32));</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) |= TagTypeNumber;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             case SpeculativeAddImmediate:</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) = (cpu.gpr&lt;uint32_t&gt;(recovery-&gt;dest()) - recovery-&gt;immediate());</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-                 ASSERT(!(cpu.gpr(recovery-&gt;dest()) &gt;&gt; 32));</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) |= TagTypeNumber;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             case BooleanSpeculationCheck:</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-                 cpu.gpr(recovery-&gt;dest()) = cpu.gpr(recovery-&gt;dest()) ^ ValueFalse;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             default:</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (extraInitializationLevel &lt;= ExtraInitializationLevel::SpeculationRecovery)</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Begin extra initilization level: ValueProfileUpdate</span>
<span class="udiff-line-removed">-         JSValue profiledValue;</span>
<span class="udiff-line-removed">-         if (!!exit.m_jsValueSource) {</span>
<span class="udiff-line-removed">-             profiledValue = jsValueFor(cpu, exit.m_jsValueSource);</span>
<span class="udiff-line-removed">-             if (MethodOfGettingAValueProfile profile = exit.m_valueProfile)</span>
<span class="udiff-line-removed">-                 profile.reportValue(profiledValue);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (extraInitializationLevel &lt;= ExtraInitializationLevel::ValueProfileUpdate)</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Begin extra initilization level: ArrayProfileUpdate</span>
<span class="udiff-line-removed">-         ArrayProfile* arrayProfile = exitState.arrayProfile;</span>
<span class="udiff-line-removed">-         if (arrayProfile) {</span>
<span class="udiff-line-removed">-             ASSERT(!!exit.m_jsValueSource);</span>
<span class="udiff-line-removed">-             ASSERT(exit.m_kind == BadCache || exit.m_kind == BadIndexingType);</span>
<span class="udiff-line-removed">-             Structure* structure = profiledValue.asCell()-&gt;structure(vm);</span>
<span class="udiff-line-removed">-             arrayProfile-&gt;observeStructure(structure);</span>
<span class="udiff-line-removed">-             arrayProfile-&gt;observeArrayMode(arrayModesFromStructure(structure));</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (extraInitializationLevel &lt;= ExtraInitializationLevel::ArrayProfileUpdate)</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Begin Extra initilization level: Other</span>
<span class="udiff-line-removed">-         if (UNLIKELY(exit.m_kind == GenericUnwind)) {</span>
<span class="udiff-line-removed">-             // We are acting as a defacto op_catch because we arrive here from genericUnwind().</span>
<span class="udiff-line-removed">-             // So, we must restore our call frame and stack pointer.</span>
<span class="udiff-line-removed">-             restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(context);</span>
<span class="udiff-line-removed">-             ASSERT(context.fp() == vm.callFrameForCatch);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (exitState.profilerExit)</span>
<span class="udiff-line-removed">-             exitState.profilerExit-&gt;incCount();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (UNLIKELY(Options::printEachOSRExit()))</span>
<span class="udiff-line-removed">-             printOSRExit(context, vm.osrExitIndex, exit);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     } while (false); // End extra initialization.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Frame frame(cpu.fp(), context.stack());</span>
<span class="udiff-line-removed">-     ASSERT(!(context.fp&lt;uintptr_t&gt;() &amp; 0x7));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-     ASSERT(cpu.gpr(GPRInfo::tagTypeNumberRegister) == TagTypeNumber);</span>
<span class="udiff-line-removed">-     ASSERT(cpu.gpr(GPRInfo::tagMaskRegister) == TagMask);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Do all data format conversions and store the results into the stack.</span>
<span class="udiff-line-removed">-     // Note: we need to recover values before restoring callee save registers below</span>
<span class="udiff-line-removed">-     // because the recovery may rely on values in some of callee save registers.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     int calleeSaveSpaceAsVirtualRegisters = static_cast&lt;int&gt;(baselineCodeBlock-&gt;calleeSaveSpaceAsVirtualRegisters());</span>
<span class="udiff-line-removed">-     size_t numberOfOperands = operands.size();</span>
<span class="udiff-line-removed">-     size_t numUndefinedOperandSpans = undefinedOperandSpans.size();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     size_t nextUndefinedSpanIndex = 0;</span>
<span class="udiff-line-removed">-     size_t nextUndefinedOperandIndex = numberOfOperands;</span>
<span class="udiff-line-removed">-     if (numUndefinedOperandSpans)</span>
<span class="udiff-line-removed">-         nextUndefinedOperandIndex = undefinedOperandSpans[nextUndefinedSpanIndex].firstIndex;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     JSValue undefined = jsUndefined();</span>
<span class="udiff-line-removed">-     for (size_t spanIndex = 0; spanIndex &lt; numUndefinedOperandSpans; ++spanIndex) {</span>
<span class="udiff-line-removed">-         auto&amp; span = undefinedOperandSpans[spanIndex];</span>
<span class="udiff-line-removed">-         int firstOffset = span.minOffset;</span>
<span class="udiff-line-removed">-         int lastOffset = firstOffset + span.numberOfRegisters;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         for (int offset = firstOffset; offset &lt; lastOffset; ++offset)</span>
<span class="udiff-line-removed">-             frame.setOperand(offset, undefined);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (size_t index = 0; index &lt; numberOfOperands; ++index) {</span>
<span class="udiff-line-removed">-         const ValueRecovery&amp; recovery = operands[index];</span>
<span class="udiff-line-removed">-         VirtualRegister reg = operands.virtualRegisterForIndex(index);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (UNLIKELY(index == nextUndefinedOperandIndex)) {</span>
<span class="udiff-line-removed">-             index += undefinedOperandSpans[nextUndefinedSpanIndex++].numberOfRegisters - 1;</span>
<span class="udiff-line-removed">-             if (nextUndefinedSpanIndex &lt; numUndefinedOperandSpans)</span>
<span class="udiff-line-removed">-                 nextUndefinedOperandIndex = undefinedOperandSpans[nextUndefinedSpanIndex].firstIndex;</span>
<span class="udiff-line-removed">-             else</span>
<span class="udiff-line-removed">-                 nextUndefinedOperandIndex = numberOfOperands;</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (reg.isLocal() &amp;&amp; reg.toLocal() &lt; calleeSaveSpaceAsVirtualRegisters)</span>
<span class="udiff-line-removed">-             continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         int operand = reg.offset();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         switch (recovery.technique()) {</span>
<span class="udiff-line-removed">-         case DisplacedInJSStack:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, exec-&gt;r(recovery.virtualRegister()).asanUnsafeJSValue());</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case InFPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, cpu.fpr&lt;JSValue&gt;(recovery.fpr()));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-         case InGPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, cpu.gpr&lt;JSValue&gt;(recovery.gpr()));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-         case InPair:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(cpu.gpr&lt;int32_t&gt;(recovery.tagGPR()), cpu.gpr&lt;int32_t&gt;(recovery.payloadGPR())));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case UnboxedCellInGPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(cpu.gpr&lt;JSCell*&gt;(recovery.gpr())));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case CellDisplacedInJSStack:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(exec-&gt;r(recovery.virtualRegister()).asanUnsafeUnboxedCell()));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if USE(JSVALUE32_64)</span>
<span class="udiff-line-removed">-         case UnboxedBooleanInGPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, jsBoolean(cpu.gpr&lt;bool&gt;(recovery.gpr())));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case BooleanDisplacedInJSStack:</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, exec-&gt;r(recovery.virtualRegister()).asanUnsafeJSValue());</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, jsBoolean(exec-&gt;r(recovery.virtualRegister()).asanUnsafeJSValue().payload()));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case UnboxedInt32InGPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(cpu.gpr&lt;int32_t&gt;(recovery.gpr())));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case Int32DisplacedInJSStack:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(exec-&gt;r(recovery.virtualRegister()).asanUnsafeUnboxedInt32()));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-         case UnboxedInt52InGPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(cpu.gpr&lt;int64_t&gt;(recovery.gpr()) &gt;&gt; JSValue::int52ShiftAmount));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case Int52DisplacedInJSStack:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(exec-&gt;r(recovery.virtualRegister()).asanUnsafeUnboxedInt52()));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case UnboxedStrictInt52InGPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(cpu.gpr&lt;int64_t&gt;(recovery.gpr())));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case StrictInt52DisplacedInJSStack:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(exec-&gt;r(recovery.virtualRegister()).asanUnsafeUnboxedStrictInt52()));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case UnboxedDoubleInFPR:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(JSValue::EncodeAsDouble, purifyNaN(cpu.fpr(recovery.fpr()))));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case DoubleDisplacedInJSStack:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, JSValue(JSValue::EncodeAsDouble, purifyNaN(exec-&gt;r(recovery.virtualRegister()).asanUnsafeUnboxedDouble())));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case Constant:</span>
<span class="udiff-line-removed">-             frame.setOperand(operand, recovery.constant());</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case DirectArgumentsThatWereNotCreated:</span>
<span class="udiff-line-removed">-         case ClonedArgumentsThatWereNotCreated:</span>
<span class="udiff-line-removed">-             // Don&#39;t do this, yet.</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Restore the DFG callee saves and then save the ones the baseline JIT uses.</span>
<span class="udiff-line-removed">-     restoreCalleeSavesFor(context, codeBlock);</span>
<span class="udiff-line-removed">-     saveCalleeSavesFor(context, baselineCodeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-     cpu.gpr(GPRInfo::tagTypeNumberRegister) = static_cast&lt;uintptr_t&gt;(TagTypeNumber);</span>
<span class="udiff-line-removed">-     cpu.gpr(GPRInfo::tagMaskRegister) = static_cast&lt;uintptr_t&gt;(TagTypeNumber | TagBitTypeOther);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (exit.isExceptionHandler())</span>
<span class="udiff-line-removed">-         copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(context);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Now that things on the stack are recovered, do the arguments recovery. We assume that arguments</span>
<span class="udiff-line-removed">-     // recoveries don&#39;t recursively refer to each other. But, we don&#39;t try to assume that they only</span>
<span class="udiff-line-removed">-     // refer to certain ranges of locals. Hence why we need to do this here, once the stack is sensible.</span>
<span class="udiff-line-removed">-     // Note that we also roughly assume that the arguments might still be materialized outside of its</span>
<span class="udiff-line-removed">-     // inline call frame scope - but for now the DFG wouldn&#39;t do that.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     DFG::emitRestoreArguments(context, codeBlock, dfgJITCode, operands);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Adjust the old JIT&#39;s execute counter. Since we are exiting OSR, we know</span>
<span class="udiff-line-removed">-     // that all new calls into this code will go to the new JIT, so the execute</span>
<span class="udiff-line-removed">-     // counter only affects call frames that performed OSR exit and call frames</span>
<span class="udiff-line-removed">-     // that were still executing the old JIT at the time of another call frame&#39;s</span>
<span class="udiff-line-removed">-     // OSR exit. We want to ensure that the following is true:</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // (a) Code the performs an OSR exit gets a chance to reenter optimized</span>
<span class="udiff-line-removed">-     //     code eventually, since optimized code is faster. But we don&#39;t</span>
<span class="udiff-line-removed">-     //     want to do such reentery too aggressively (see (c) below).</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // (b) If there is code on the call stack that is still running the old</span>
<span class="udiff-line-removed">-     //     JIT&#39;s code and has never OSR&#39;d, then it should get a chance to</span>
<span class="udiff-line-removed">-     //     perform OSR entry despite the fact that we&#39;ve exited.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // (c) Code the performs an OSR exit should not immediately retry OSR</span>
<span class="udiff-line-removed">-     //     entry, since both forms of OSR are expensive. OSR entry is</span>
<span class="udiff-line-removed">-     //     particularly expensive.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // (d) Frequent OSR failures, even those that do not result in the code</span>
<span class="udiff-line-removed">-     //     running in a hot loop, result in recompilation getting triggered.</span>
<span class="udiff-line-removed">-     //</span>
<span class="udiff-line-removed">-     // To ensure (c), we&#39;d like to set the execute counter to</span>
<span class="udiff-line-removed">-     // counterValueForOptimizeAfterWarmUp(). This seems like it would endanger</span>
<span class="udiff-line-removed">-     // (a) and (b), since then every OSR exit would delay the opportunity for</span>
<span class="udiff-line-removed">-     // every call frame to perform OSR entry. Essentially, if OSR exit happens</span>
<span class="udiff-line-removed">-     // frequently and the function has few loops, then the counter will never</span>
<span class="udiff-line-removed">-     // become non-negative and OSR entry will never be triggered. OSR entry</span>
<span class="udiff-line-removed">-     // will only happen if a loop gets hot in the old JIT, which does a pretty</span>
<span class="udiff-line-removed">-     // good job of ensuring (a) and (b). But that doesn&#39;t take care of (d),</span>
<span class="udiff-line-removed">-     // since each speculation failure would reset the execute counter.</span>
<span class="udiff-line-removed">-     // So we check here if the number of speculation failures is significantly</span>
<span class="udiff-line-removed">-     // larger than the number of successes (we want 90% success rate), and if</span>
<span class="udiff-line-removed">-     // there have been a large enough number of failures. If so, we set the</span>
<span class="udiff-line-removed">-     // counter to 0; otherwise we set the counter to</span>
<span class="udiff-line-removed">-     // counterValueForOptimizeAfterWarmUp().</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (UNLIKELY(codeBlock-&gt;updateOSRExitCounterAndCheckIfNeedToReoptimize(exitState) == CodeBlock::OptimizeAction::ReoptimizeNow))</span>
<span class="udiff-line-removed">-         triggerReoptimizationNow(baselineCodeBlock, codeBlock, &amp;exit);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     reifyInlinedCallFrames(context, baselineCodeBlock, exit);</span>
<span class="udiff-line-removed">-     adjustAndJumpToTarget(context, vm, codeBlock, baselineCodeBlock, exit);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void reifyInlinedCallFrames(Context&amp; context, CodeBlock* outermostBaselineCodeBlock, const OSRExitBase&amp; exit)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     auto&amp; cpu = context.cpu;</span>
<span class="udiff-line-removed">-     Frame frame(cpu.fp(), context.stack());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // FIXME: We shouldn&#39;t leave holes on the stack when performing an OSR exit</span>
<span class="udiff-line-removed">-     // in presence of inlined tail calls.</span>
<span class="udiff-line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=147511</span>
<span class="udiff-line-removed">-     ASSERT(outermostBaselineCodeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
<span class="udiff-line-removed">-     frame.setOperand&lt;CodeBlock*&gt;(CallFrameSlot::codeBlock, outermostBaselineCodeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const CodeOrigin* codeOrigin;</span>
<span class="udiff-line-removed">-     for (codeOrigin = &amp;exit.m_codeOrigin; codeOrigin &amp;&amp; codeOrigin-&gt;inlineCallFrame(); codeOrigin = codeOrigin-&gt;inlineCallFrame()-&gt;getCallerSkippingTailCalls()) {</span>
<span class="udiff-line-removed">-         InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();</span>
<span class="udiff-line-removed">-         CodeBlock* baselineCodeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(*codeOrigin, outermostBaselineCodeBlock);</span>
<span class="udiff-line-removed">-         InlineCallFrame::Kind trueCallerCallKind;</span>
<span class="udiff-line-removed">-         CodeOrigin* trueCaller = inlineCallFrame-&gt;getCallerSkippingTailCalls(&amp;trueCallerCallKind);</span>
<span class="udiff-line-removed">-         void* callerFrame = cpu.fp();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (!trueCaller) {</span>
<span class="udiff-line-removed">-             ASSERT(inlineCallFrame-&gt;isTail());</span>
<span class="udiff-line-removed">-             void* returnPC = frame.get&lt;void*&gt;(CallFrame::returnPCOffset());</span>
<span class="udiff-line-removed">- #if CPU(ARM64E)</span>
<span class="udiff-line-removed">-             void* oldEntrySP = cpu.fp&lt;uint8_t*&gt;() + sizeof(CallerFrameAndPC);</span>
<span class="udiff-line-removed">-             void* newEntrySP = cpu.fp&lt;uint8_t*&gt;() + inlineCallFrame-&gt;returnPCOffset() + sizeof(void*);</span>
<span class="udiff-line-removed">-             returnPC = retagCodePtr(returnPC, bitwise_cast&lt;PtrTag&gt;(oldEntrySP), bitwise_cast&lt;PtrTag&gt;(newEntrySP));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-             frame.set&lt;void*&gt;(inlineCallFrame-&gt;returnPCOffset(), returnPC);</span>
<span class="udiff-line-removed">-             callerFrame = frame.get&lt;void*&gt;(CallFrame::callerFrameOffset());</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             CodeBlock* baselineCodeBlockForCaller = baselineCodeBlockForOriginAndBaselineCodeBlock(*trueCaller, outermostBaselineCodeBlock);</span>
<span class="udiff-line-removed">-             unsigned callBytecodeIndex = trueCaller-&gt;bytecodeIndex();</span>
<span class="udiff-line-removed">-             MacroAssemblerCodePtr&lt;JSInternalPtrTag&gt; jumpTarget;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             switch (trueCallerCallKind) {</span>
<span class="udiff-line-removed">-             case InlineCallFrame::Call:</span>
<span class="udiff-line-removed">-             case InlineCallFrame::Construct:</span>
<span class="udiff-line-removed">-             case InlineCallFrame::CallVarargs:</span>
<span class="udiff-line-removed">-             case InlineCallFrame::ConstructVarargs:</span>
<span class="udiff-line-removed">-             case InlineCallFrame::TailCall:</span>
<span class="udiff-line-removed">-             case InlineCallFrame::TailCallVarargs: {</span>
<span class="udiff-line-removed">-                 CallLinkInfo* callLinkInfo =</span>
<span class="udiff-line-removed">-                     baselineCodeBlockForCaller-&gt;getCallLinkInfoForBytecodeIndex(callBytecodeIndex);</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT(callLinkInfo);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 jumpTarget = callLinkInfo-&gt;callReturnLocation();</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             case InlineCallFrame::GetterCall:</span>
<span class="udiff-line-removed">-             case InlineCallFrame::SetterCall: {</span>
<span class="udiff-line-removed">-                 StructureStubInfo* stubInfo =</span>
<span class="udiff-line-removed">-                     baselineCodeBlockForCaller-&gt;findStubInfo(CodeOrigin(callBytecodeIndex));</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT(stubInfo);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 jumpTarget = stubInfo-&gt;doneLocation();</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             default:</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (trueCaller-&gt;inlineCallFrame())</span>
<span class="udiff-line-removed">-                 callerFrame = cpu.fp&lt;uint8_t*&gt;() + trueCaller-&gt;inlineCallFrame()-&gt;stackOffset * sizeof(EncodedJSValue);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             void* targetAddress = jumpTarget.executableAddress();</span>
<span class="udiff-line-removed">- #if CPU(ARM64E)</span>
<span class="udiff-line-removed">-             void* newEntrySP = cpu.fp&lt;uint8_t*&gt;() + inlineCallFrame-&gt;returnPCOffset() + sizeof(void*);</span>
<span class="udiff-line-removed">-             targetAddress = retagCodePtr(targetAddress, JSInternalPtrTag, bitwise_cast&lt;PtrTag&gt;(newEntrySP));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-             frame.set&lt;void*&gt;(inlineCallFrame-&gt;returnPCOffset(), targetAddress);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         frame.setOperand&lt;void*&gt;(inlineCallFrame-&gt;stackOffset + CallFrameSlot::codeBlock, baselineCodeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Restore the inline call frame&#39;s callee save registers.</span>
<span class="udiff-line-removed">-         // If this inlined frame is a tail call that will return back to the original caller, we need to</span>
<span class="udiff-line-removed">-         // copy the prior contents of the tag registers already saved for the outer frame to this frame.</span>
<span class="udiff-line-removed">-         saveOrCopyCalleeSavesFor(context, baselineCodeBlock, VirtualRegister(inlineCallFrame-&gt;stackOffset), !trueCaller);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (!inlineCallFrame-&gt;isVarargs())</span>
<span class="udiff-line-removed">-             frame.setOperand&lt;uint32_t&gt;(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount, PayloadOffset, inlineCallFrame-&gt;argumentCountIncludingThis);</span>
<span class="udiff-line-removed">-         ASSERT(callerFrame);</span>
<span class="udiff-line-removed">-         frame.set&lt;void*&gt;(inlineCallFrame-&gt;callerFrameOffset(), callerFrame);</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-         uint32_t locationBits = CallSiteIndex(codeOrigin-&gt;bytecodeIndex()).bits();</span>
<span class="udiff-line-removed">-         frame.setOperand&lt;uint32_t&gt;(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount, TagOffset, locationBits);</span>
<span class="udiff-line-removed">-         if (!inlineCallFrame-&gt;isClosureCall)</span>
<span class="udiff-line-removed">-             frame.setOperand(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee, JSValue(inlineCallFrame-&gt;calleeConstant()));</span>
<span class="udiff-line-removed">- #else // USE(JSVALUE64) // so this is the 32-bit part</span>
<span class="udiff-line-removed">-         const Instruction* instruction = baselineCodeBlock-&gt;instructions().at(codeOrigin-&gt;bytecodeIndex()).ptr();</span>
<span class="udiff-line-removed">-         uint32_t locationBits = CallSiteIndex(instruction).bits();</span>
<span class="udiff-line-removed">-         frame.setOperand&lt;uint32_t&gt;(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount, TagOffset, locationBits);</span>
<span class="udiff-line-removed">-         frame.setOperand&lt;uint32_t&gt;(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee, TagOffset, static_cast&lt;uint32_t&gt;(JSValue::CellTag));</span>
<span class="udiff-line-removed">-         if (!inlineCallFrame-&gt;isClosureCall)</span>
<span class="udiff-line-removed">-             frame.setOperand(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee, PayloadOffset, inlineCallFrame-&gt;calleeConstant());</span>
<span class="udiff-line-removed">- #endif // USE(JSVALUE64) // ending the #else part, so directly above is the 32-bit part</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Don&#39;t need to set the toplevel code origin if we only did inline tail calls</span>
<span class="udiff-line-removed">-     if (codeOrigin) {</span>
<span class="udiff-line-removed">- #if USE(JSVALUE64)</span>
<span class="udiff-line-removed">-         uint32_t locationBits = CallSiteIndex(codeOrigin-&gt;bytecodeIndex()).bits();</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-         const Instruction* instruction = outermostBaselineCodeBlock-&gt;instructions().at(codeOrigin-&gt;bytecodeIndex()).ptr();</span>
<span class="udiff-line-removed">-         uint32_t locationBits = CallSiteIndex(instruction).bits();</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         frame.setOperand&lt;uint32_t&gt;(CallFrameSlot::argumentCount, TagOffset, locationBits);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void adjustAndJumpToTarget(Context&amp; context, VM&amp; vm, CodeBlock* codeBlock, CodeBlock* baselineCodeBlock, OSRExit&amp; exit)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     OSRExitState* exitState = exit.exitState.get();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     WTF::storeLoadFence(); // The optimizing compiler expects that the OSR exit mechanism will execute this fence.</span>
<span class="udiff-line-removed">-     vm.heap.writeBarrier(baselineCodeBlock);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // We barrier all inlined frames -- and not just the current inline stack --</span>
<span class="udiff-line-removed">-     // because we don&#39;t know which inlined function owns the value profile that</span>
<span class="udiff-line-removed">-     // we&#39;ll update when we exit. In the case of &quot;f() { a(); b(); }&quot;, if both</span>
<span class="udiff-line-removed">-     // a and b are inlined, we might exit inside b due to a bad value loaded</span>
<span class="udiff-line-removed">-     // from a.</span>
<span class="udiff-line-removed">-     // FIXME: MethodOfGettingAValueProfile should remember which CodeBlock owns</span>
<span class="udiff-line-removed">-     // the value profile.</span>
<span class="udiff-line-removed">-     InlineCallFrameSet* inlineCallFrames = codeBlock-&gt;jitCode()-&gt;dfgCommon()-&gt;inlineCallFrames.get();</span>
<span class="udiff-line-removed">-     if (inlineCallFrames) {</span>
<span class="udiff-line-removed">-         for (InlineCallFrame* inlineCallFrame : *inlineCallFrames)</span>
<span class="udiff-line-removed">-             vm.heap.writeBarrier(inlineCallFrame-&gt;baselineCodeBlock.get());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto* exitInlineCallFrame = exit.m_codeOrigin.inlineCallFrame();</span>
<span class="udiff-line-removed">-     if (exitInlineCallFrame)</span>
<span class="udiff-line-removed">-         context.fp() = context.fp&lt;uint8_t*&gt;() + exitInlineCallFrame-&gt;stackOffset * sizeof(EncodedJSValue);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void* jumpTarget = exitState-&gt;jumpTarget;</span>
<span class="udiff-line-removed">-     ASSERT(jumpTarget);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (exit.isExceptionHandler()) {</span>
<span class="udiff-line-removed">-         // Since we&#39;re jumping to op_catch, we need to set callFrameForCatch.</span>
<span class="udiff-line-removed">-         vm.callFrameForCatch = context.fp&lt;ExecState*&gt;();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     vm.topCallFrame = context.fp&lt;ExecState*&gt;();</span>
<span class="udiff-line-removed">-     context.pc() = untagCodePtr&lt;JSEntryPtrTag&gt;(jumpTarget);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void printOSRExit(Context&amp; context, uint32_t osrExitIndex, const OSRExit&amp; exit)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ExecState* exec = context.fp&lt;ExecState*&gt;();</span>
<span class="udiff-line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="udiff-line-removed">-     CodeBlock* alternative = codeBlock-&gt;alternative();</span>
<span class="udiff-line-removed">-     ExitKind kind = exit.m_kind;</span>
<span class="udiff-line-removed">-     unsigned bytecodeOffset = exit.m_codeOrigin.bytecodeIndex();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     dataLog(&quot;Speculation failure in &quot;, *codeBlock);</span>
<span class="udiff-line-removed">-     dataLog(&quot; @ exit #&quot;, osrExitIndex, &quot; (bc#&quot;, bytecodeOffset, &quot;, &quot;, exitKindToString(kind), &quot;) with &quot;);</span>
<span class="udiff-line-removed">-     if (alternative) {</span>
<span class="udiff-line-removed">-         dataLog(</span>
<span class="udiff-line-removed">-             &quot;executeCounter = &quot;, alternative-&gt;jitExecuteCounter(),</span>
<span class="udiff-line-removed">-             &quot;, reoptimizationRetryCounter = &quot;, alternative-&gt;reoptimizationRetryCounter(),</span>
<span class="udiff-line-removed">-             &quot;, optimizationDelayCounter = &quot;, alternative-&gt;optimizationDelayCounter());</span>
<span class="udiff-line-removed">-     } else</span>
<span class="udiff-line-removed">-         dataLog(&quot;no alternative code block (i.e. we&#39;ve been jettisoned)&quot;);</span>
<span class="udiff-line-removed">-     dataLog(&quot;, osrExitCounter = &quot;, codeBlock-&gt;osrExitCounter(), &quot;\n&quot;);</span>
<span class="udiff-line-removed">-     dataLog(&quot;    GPRs at time of exit:&quot;);</span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {</span>
<span class="udiff-line-removed">-         GPRReg gpr = GPRInfo::toRegister(i);</span>
<span class="udiff-line-removed">-         dataLog(&quot; &quot;, context.gprName(gpr), &quot;:&quot;, RawPointer(context.gpr&lt;void*&gt;(gpr)));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     dataLog(&quot;\n&quot;);</span>
<span class="udiff-line-removed">-     dataLog(&quot;    FPRs at time of exit:&quot;);</span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {</span>
<span class="udiff-line-removed">-         FPRReg fpr = FPRInfo::toRegister(i);</span>
<span class="udiff-line-removed">-         dataLog(&quot; &quot;, context.fprName(fpr), &quot;:&quot;);</span>
<span class="udiff-line-removed">-         uint64_t bits = context.fpr&lt;uint64_t&gt;(fpr);</span>
<span class="udiff-line-removed">-         double value = context.fpr(fpr);</span>
<span class="udiff-line-removed">-         dataLogF(&quot;%llx:%lf&quot;, static_cast&lt;long long&gt;(bits), value);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     dataLog(&quot;\n&quot;);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // JIT based OSR Exit.</span>
<span class="udiff-line-removed">- </span>
  OSRExit::OSRExit(ExitKind kind, JSValueSource jsValueSource, MethodOfGettingAValueProfile valueProfile, SpeculativeJIT* jit, unsigned streamIndex, unsigned recoveryIndex)
      : OSRExitBase(kind, jit-&gt;m_origin.forExit, jit-&gt;m_origin.semantic, jit-&gt;m_origin.wasHoisted)
      , m_jsValueSource(jsValueSource)
      , m_valueProfile(valueProfile)
      , m_recoveryIndex(recoveryIndex)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -947,21 +66,24 @@</span>
  CodeLocationJump&lt;JSInternalPtrTag&gt; OSRExit::codeLocationForRepatch() const
  {
      return CodeLocationJump&lt;JSInternalPtrTag&gt;(m_patchableJumpLocation);
  }
  
<span class="udiff-line-modified-removed">- void OSRExit::emitRestoreArguments(CCallHelpers&amp; jit, const Operands&lt;ValueRecovery&gt;&amp; operands)</span>
<span class="udiff-line-modified-added">+ void OSRExit::emitRestoreArguments(CCallHelpers&amp; jit, VM&amp; vm, const Operands&lt;ValueRecovery&gt;&amp; operands)</span>
  {
<span class="udiff-line-modified-removed">-     HashMap&lt;MinifiedID, int&gt; alreadyAllocatedArguments; // Maps phantom arguments node ID to operand.</span>
<span class="udiff-line-modified-added">+     HashMap&lt;MinifiedID, VirtualRegister&gt; alreadyAllocatedArguments; // Maps phantom arguments node ID to operand.</span>
      for (size_t index = 0; index &lt; operands.size(); ++index) {
          const ValueRecovery&amp; recovery = operands[index];
<span class="udiff-line-removed">-         int operand = operands.operandForIndex(index);</span>
  
          if (recovery.technique() != DirectArgumentsThatWereNotCreated
              &amp;&amp; recovery.technique() != ClonedArgumentsThatWereNotCreated)
              continue;
  
<span class="udiff-line-added">+         Operand operand = operands.operandForIndex(index);</span>
<span class="udiff-line-added">+         if (operand.isTmp())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
          MinifiedID id = recovery.nodeID();
          auto iter = alreadyAllocatedArguments.find(id);
          if (iter != alreadyAllocatedArguments.end()) {
              JSValueRegs regs = JSValueRegs::withTwoAvailableRegs(GPRInfo::regT0, GPRInfo::regT1);
              jit.loadValue(CCallHelpers::addressFor(iter-&gt;value), regs);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -978,31 +100,32 @@</span>
          else
              stackOffset = 0;
  
          if (!inlineCallFrame || inlineCallFrame-&gt;isClosureCall) {
              jit.loadPtr(
<span class="udiff-line-modified-removed">-                 AssemblyHelpers::addressFor(stackOffset + CallFrameSlot::callee),</span>
<span class="udiff-line-modified-added">+                 AssemblyHelpers::addressFor(VirtualRegister(stackOffset + CallFrameSlot::callee)),</span>
                  GPRInfo::regT0);
          } else {
              jit.move(
                  AssemblyHelpers::TrustedImmPtr(inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
                  GPRInfo::regT0);
          }
  
          if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
              jit.load32(
<span class="udiff-line-modified-removed">-                 AssemblyHelpers::payloadFor(stackOffset + CallFrameSlot::argumentCount),</span>
<span class="udiff-line-modified-added">+                 AssemblyHelpers::payloadFor(VirtualRegister(stackOffset + CallFrameSlot::argumentCountIncludingThis)),</span>
                  GPRInfo::regT1);
          } else {
              jit.move(
                  AssemblyHelpers::TrustedImm32(inlineCallFrame-&gt;argumentCountIncludingThis),
                  GPRInfo::regT1);
          }
  
          static_assert(std::is_same&lt;decltype(operationCreateDirectArgumentsDuringExit), decltype(operationCreateClonedArgumentsDuringExit)&gt;::value, &quot;We assume these functions have the same signature below.&quot;);
          jit.setupArguments&lt;decltype(operationCreateDirectArgumentsDuringExit)&gt;(
<span class="udiff-line-modified-removed">-             AssemblyHelpers::TrustedImmPtr(inlineCallFrame), GPRInfo::regT0, GPRInfo::regT1);</span>
<span class="udiff-line-modified-added">+             AssemblyHelpers::TrustedImmPtr(&amp;vm), AssemblyHelpers::TrustedImmPtr(inlineCallFrame), GPRInfo::regT0, GPRInfo::regT1);</span>
<span class="udiff-line-added">+         jit.prepareCallOperation(vm);</span>
          switch (recovery.technique()) {
          case DirectArgumentsThatWereNotCreated:
              jit.move(AssemblyHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationCreateDirectArgumentsDuringExit)), GPRInfo::nonArgGPR0);
              break;
          case ClonedArgumentsThatWereNotCreated:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1013,29 +136,29 @@</span>
              break;
          }
          jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
          jit.storeCell(GPRInfo::returnValueGPR, AssemblyHelpers::addressFor(operand));
  
<span class="udiff-line-modified-removed">-         alreadyAllocatedArguments.add(id, operand);</span>
<span class="udiff-line-modified-added">+         alreadyAllocatedArguments.add(id, operand.virtualRegister());</span>
      }
  }
  
<span class="udiff-line-modified-removed">- void JIT_OPERATION OSRExit::compileOSRExit(ExecState* exec)</span>
<span class="udiff-line-modified-added">+ void JIT_OPERATION operationCompileOSRExit(CallFrame* callFrame)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (validateDFGDoesGC) {
          // We&#39;re about to exit optimized code. So, there&#39;s no longer any optimized
          // code running that expects no GC.
          vm.heap.setExpectDoesGC(true);
      }
  
      if (vm.callFrameForCatch)
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT(vm.callFrameForCatch == exec);</span>
<span class="udiff-line-modified-added">+         RELEASE_ASSERT(vm.callFrameForCatch == callFrame);</span>
  
<span class="udiff-line-modified-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="udiff-line-modified-added">+     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
      ASSERT(codeBlock);
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
  
      // It&#39;s sort of preferable that we don&#39;t GC while in here. Anyways, doing so wouldn&#39;t
      // really be profitable.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1045,12 +168,10 @@</span>
      OSRExit&amp; exit = codeBlock-&gt;jitCode()-&gt;dfg()-&gt;osrExit[exitIndex];
  
      ASSERT(!vm.callFrameForCatch || exit.m_kind == GenericUnwind);
      EXCEPTION_ASSERT_UNUSED(scope, !!scope.exception() || !exit.isExceptionHandler());
  
<span class="udiff-line-removed">-     prepareCodeOriginForOSRExit(exec, exit.m_codeOrigin);</span>
<span class="udiff-line-removed">- </span>
      // Compute the value recoveries.
      Operands&lt;ValueRecovery&gt; operands;
      codeBlock-&gt;jitCode()-&gt;dfg()-&gt;variableEventStream.reconstruct(codeBlock, exit.m_codeOrigin, codeBlock-&gt;jitCode()-&gt;dfg()-&gt;minifiedDFG, exit.m_streamIndex, operands);
  
      SpeculationRecovery* recovery = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1080,11 +201,11 @@</span>
                  exitIndex, Profiler::OriginStack(database, codeBlock, exit.m_codeOrigin),
                  exit.m_kind, exit.m_kind == UncountableInvalidation);
              jit.add64(CCallHelpers::TrustedImm32(1), CCallHelpers::AbsoluteAddress(profilerExit-&gt;counterAddress()));
          }
  
<span class="udiff-line-modified-removed">-         compileExit(jit, vm, exit, operands, recovery);</span>
<span class="udiff-line-modified-added">+         OSRExit::compileExit(jit, vm, exit, operands, recovery);</span>
  
          LinkBuffer patchBuffer(jit, codeBlock);
          exit.m_code = FINALIZE_CODE_IF(
              shouldDumpDisassembly() || Options::verboseOSR() || Options::verboseDFGOSRExit(),
              patchBuffer, OSRExitPtrTag,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1102,50 +223,50 @@</span>
  void OSRExit::compileExit(CCallHelpers&amp; jit, VM&amp; vm, const OSRExit&amp; exit, const Operands&lt;ValueRecovery&gt;&amp; operands, SpeculationRecovery* recovery)
  {
      jit.jitAssertTagsInPlace();
  
      // Pro-forma stuff.
<span class="udiff-line-modified-removed">-     if (Options::printEachOSRExit()) {</span>
<span class="udiff-line-modified-added">+     if (UNLIKELY(Options::printEachOSRExit())) {</span>
          SpeculationFailureDebugInfo* debugInfo = new SpeculationFailureDebugInfo;
          debugInfo-&gt;codeBlock = jit.codeBlock();
          debugInfo-&gt;kind = exit.m_kind;
<span class="udiff-line-modified-removed">-         debugInfo-&gt;bytecodeOffset = exit.m_codeOrigin.bytecodeIndex();</span>
<span class="udiff-line-modified-added">+         debugInfo-&gt;bytecodeIndex = exit.m_codeOrigin.bytecodeIndex();</span>
  
<span class="udiff-line-modified-removed">-         jit.debugCall(vm, debugOperationPrintSpeculationFailure, debugInfo);</span>
<span class="udiff-line-modified-added">+         jit.debugCall(vm, operationDebugPrintSpeculationFailure, debugInfo);</span>
      }
  
      // Perform speculation recovery. This only comes into play when an operation
      // starts mutating state before verifying the speculation it has already made.
  
      if (recovery) {
          switch (recovery-&gt;type()) {
          case SpeculativeAdd:
              jit.sub32(recovery-&gt;src(), recovery-&gt;dest());
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-             jit.or64(GPRInfo::tagTypeNumberRegister, recovery-&gt;dest());</span>
<span class="udiff-line-modified-added">+             jit.or64(GPRInfo::numberTagRegister, recovery-&gt;dest());</span>
  #endif
              break;
  
          case SpeculativeAddSelf:
              // If A + A = A (int32_t) overflows, A can be recovered by ((static_cast&lt;int32_t&gt;(A) &gt;&gt; 1) ^ 0x8000000).
              jit.rshift32(AssemblyHelpers::TrustedImm32(1), recovery-&gt;dest());
              jit.xor32(AssemblyHelpers::TrustedImm32(0x80000000), recovery-&gt;dest());
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-             jit.or64(GPRInfo::tagTypeNumberRegister, recovery-&gt;dest());</span>
<span class="udiff-line-modified-added">+             jit.or64(GPRInfo::numberTagRegister, recovery-&gt;dest());</span>
  #endif
              break;
  
          case SpeculativeAddImmediate:
              jit.sub32(AssemblyHelpers::Imm32(recovery-&gt;immediate()), recovery-&gt;dest());
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-             jit.or64(GPRInfo::tagTypeNumberRegister, recovery-&gt;dest());</span>
<span class="udiff-line-modified-added">+             jit.or64(GPRInfo::numberTagRegister, recovery-&gt;dest());</span>
  #endif
              break;
  
          case BooleanSpeculationCheck:
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-             jit.xor64(AssemblyHelpers::TrustedImm32(static_cast&lt;int32_t&gt;(ValueFalse)), recovery-&gt;dest());</span>
<span class="udiff-line-modified-added">+             jit.xor64(AssemblyHelpers::TrustedImm32(JSValue::ValueFalse), recovery-&gt;dest());</span>
  #endif
              break;
  
          default:
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1164,11 +285,19 @@</span>
              // while the former case is an outcome of a CheckStructure not knowing why
              // it was emitted (could be either due to an inline cache of a property
              // property access, or due to an array profile).
  
              CodeOrigin codeOrigin = exit.m_codeOriginForExitProfile;
<span class="udiff-line-modified-removed">-             if (ArrayProfile* arrayProfile = jit.baselineCodeBlockFor(codeOrigin)-&gt;getArrayProfile(codeOrigin.bytecodeIndex())) {</span>
<span class="udiff-line-modified-added">+             CodeBlock* codeBlock = jit.baselineCodeBlockFor(codeOrigin);</span>
<span class="udiff-line-added">+             if (ArrayProfile* arrayProfile = codeBlock-&gt;getArrayProfile(codeOrigin.bytecodeIndex())) {</span>
<span class="udiff-line-added">+                 const Instruction* instruction = codeBlock-&gt;instructions().at(codeOrigin.bytecodeIndex()).ptr();</span>
<span class="udiff-line-added">+                 CCallHelpers::Jump skipProfile;</span>
<span class="udiff-line-added">+                 if (instruction-&gt;is&lt;OpGetById&gt;()) {</span>
<span class="udiff-line-added">+                     auto&amp; metadata = instruction-&gt;as&lt;OpGetById&gt;().metadata(codeBlock);</span>
<span class="udiff-line-added">+                     skipProfile = jit.branch8(CCallHelpers::NotEqual, CCallHelpers::AbsoluteAddress(&amp;metadata.m_modeMetadata.mode), CCallHelpers::TrustedImm32(static_cast&lt;uint8_t&gt;(GetByIdMode::ArrayLength)));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
  #if USE(JSVALUE64)
                  GPRReg usedRegister;
                  if (exit.m_jsValueSource.isAddress())
                      usedRegister = exit.m_jsValueSource.base();
                  else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1240,21 +369,24 @@</span>
                      jit.popToRestore(scratch1);
                  } else {
                      jit.pop(scratch2);
                      jit.pop(scratch1);
                  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (skipProfile.isSet())</span>
<span class="udiff-line-added">+                     skipProfile.link(&amp;jit);</span>
              }
          }
  
          if (MethodOfGettingAValueProfile profile = exit.m_valueProfile) {
  #if USE(JSVALUE64)
              if (exit.m_jsValueSource.isAddress()) {
<span class="udiff-line-modified-removed">-                 // We can&#39;t be sure that we have a spare register. So use the tagTypeNumberRegister,</span>
<span class="udiff-line-modified-added">+                 // We can&#39;t be sure that we have a spare register. So use the numberTagRegister,</span>
                  // since we know how to restore it.
<span class="udiff-line-modified-removed">-                 jit.load64(AssemblyHelpers::Address(exit.m_jsValueSource.asAddress()), GPRInfo::tagTypeNumberRegister);</span>
<span class="udiff-line-modified-removed">-                 profile.emitReportValue(jit, JSValueRegs(GPRInfo::tagTypeNumberRegister));</span>
<span class="udiff-line-modified-removed">-                 jit.move(AssemblyHelpers::TrustedImm64(TagTypeNumber), GPRInfo::tagTypeNumberRegister);</span>
<span class="udiff-line-modified-added">+                 jit.load64(AssemblyHelpers::Address(exit.m_jsValueSource.asAddress()), GPRInfo::numberTagRegister);</span>
<span class="udiff-line-modified-added">+                 profile.emitReportValue(jit, JSValueRegs(GPRInfo::numberTagRegister));</span>
<span class="udiff-line-modified-added">+                 jit.move(AssemblyHelpers::TrustedImm64(JSValue::NumberTag), GPRInfo::numberTagRegister);</span>
              } else
                  profile.emitReportValue(jit, JSValueRegs(exit.m_jsValueSource.gpr()));
  #else // not USE(JSVALUE64)
              if (exit.m_jsValueSource.isAddress()) {
                  // Save a register so we can use it.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1447,20 +579,101 @@</span>
      jit.emitMaterializeTagCheckRegisters();
  
      if (exit.isExceptionHandler())
          jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
  
<span class="udiff-line-added">+     if (exit.m_codeOrigin.inlineStackContainsActiveCheckpoint()) {</span>
<span class="udiff-line-added">+         // FIXME: Maybe we shouldn&#39;t use a probe but filling all the side state objects is tricky otherwise...</span>
<span class="udiff-line-added">+         Vector&lt;ValueRecovery&gt; values(operands.numberOfTmps());</span>
<span class="udiff-line-added">+         for (size_t i = 0; i &lt; operands.numberOfTmps(); ++i)</span>
<span class="udiff-line-added">+             values[i] = operands.tmp(i);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         VM* vmPtr = &amp;vm;</span>
<span class="udiff-line-added">+         auto* tmpScratch = scratch + operands.tmpIndex(0);</span>
<span class="udiff-line-added">+         jit.probe([=, values = WTFMove(values)] (Probe::Context&amp; context) {</span>
<span class="udiff-line-added">+             auto addSideState = [&amp;] (CallFrame* frame, BytecodeIndex index, size_t tmpOffset) {</span>
<span class="udiff-line-added">+                 std::unique_ptr&lt;CheckpointOSRExitSideState&gt; sideState = WTF::makeUnique&lt;CheckpointOSRExitSideState&gt;();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 sideState-&gt;bytecodeIndex = index;</span>
<span class="udiff-line-added">+                 for (size_t i = 0; i &lt; maxNumCheckpointTmps; ++i) {</span>
<span class="udiff-line-added">+                     auto&amp; recovery = values[i + tmpOffset];</span>
<span class="udiff-line-added">+                     // FIXME: We should do what the FTL does and materialize all the JSValues into the scratch buffer.</span>
<span class="udiff-line-added">+                     switch (recovery.technique()) {</span>
<span class="udiff-line-added">+                     case Constant:</span>
<span class="udiff-line-added">+                         sideState-&gt;tmps[i] = recovery.constant();</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     case UnboxedInt32InGPR:</span>
<span class="udiff-line-added">+                     case Int32DisplacedInJSStack: {</span>
<span class="udiff-line-added">+                         sideState-&gt;tmps[i] = jsNumber(static_cast&lt;int32_t&gt;(tmpScratch[i + tmpOffset]));</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #if USE(JSVALUE32_64)</span>
<span class="udiff-line-added">+                     case InPair:</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+                     case InGPR:</span>
<span class="udiff-line-added">+                     case BooleanDisplacedInJSStack:</span>
<span class="udiff-line-added">+                     case CellDisplacedInJSStack:</span>
<span class="udiff-line-added">+                     case DisplacedInJSStack: {</span>
<span class="udiff-line-added">+                         sideState-&gt;tmps[i] = reinterpret_cast&lt;JSValue*&gt;(tmpScratch)[i + tmpOffset];</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     case UnboxedCellInGPR: {</span>
<span class="udiff-line-added">+ #if USE(JSVALUE64)</span>
<span class="udiff-line-added">+                         sideState-&gt;tmps[i] = reinterpret_cast&lt;JSValue*&gt;(tmpScratch)[i + tmpOffset];</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+                         EncodedValueDescriptor* valueDescriptor = bitwise_cast&lt;EncodedValueDescriptor*&gt;(tmpScratch + i + tmpOffset);</span>
<span class="udiff-line-added">+                         sideState-&gt;tmps[i] = JSValue(JSValue::CellTag, valueDescriptor-&gt;asBits.payload);</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     case UnboxedBooleanInGPR: {</span>
<span class="udiff-line-added">+                         sideState-&gt;tmps[i] = jsBoolean(static_cast&lt;bool&gt;(tmpScratch[i + tmpOffset]));</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     default:</span>
<span class="udiff-line-added">+                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 vmPtr-&gt;addCheckpointOSRSideState(frame, WTFMove(sideState));</span>
<span class="udiff-line-added">+             };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             const CodeOrigin* codeOrigin;</span>
<span class="udiff-line-added">+             CallFrame* callFrame = context.gpr&lt;CallFrame*&gt;(GPRInfo::callFrameRegister);</span>
<span class="udiff-line-added">+             for (codeOrigin = &amp;exit.m_codeOrigin; codeOrigin &amp;&amp; codeOrigin-&gt;inlineCallFrame(); codeOrigin = codeOrigin-&gt;inlineCallFrame()-&gt;getCallerSkippingTailCalls()) {</span>
<span class="udiff-line-added">+                 BytecodeIndex callBytecodeIndex = codeOrigin-&gt;bytecodeIndex();</span>
<span class="udiff-line-added">+                 if (!callBytecodeIndex.checkpoint())</span>
<span class="udiff-line-added">+                     continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 auto* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();</span>
<span class="udiff-line-added">+                 addSideState(reinterpret_cast_ptr&lt;CallFrame*&gt;(reinterpret_cast&lt;char*&gt;(callFrame) + inlineCallFrame-&gt;returnPCOffset() - sizeof(CPURegister)), callBytecodeIndex, inlineCallFrame-&gt;tmpOffset);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (!codeOrigin)</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (BytecodeIndex bytecodeIndex = codeOrigin-&gt;bytecodeIndex(); bytecodeIndex.checkpoint())</span>
<span class="udiff-line-added">+                 addSideState(callFrame, bytecodeIndex, 0);</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Do all data format conversions and store the results into the stack.
  
      for (size_t index = 0; index &lt; operands.size(); ++index) {
          const ValueRecovery&amp; recovery = operands[index];
<span class="udiff-line-modified-removed">-         VirtualRegister reg = operands.virtualRegisterForIndex(index);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-         if (reg.isLocal() &amp;&amp; reg.toLocal() &lt; static_cast&lt;int&gt;(jit.baselineCodeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters()))</span>
<span class="udiff-line-modified-added">+         Operand operand = operands.operandForIndex(index);</span>
<span class="udiff-line-modified-added">+         if (operand.isTmp())</span>
              continue;
  
<span class="udiff-line-modified-removed">-         int operand = reg.offset();</span>
<span class="udiff-line-modified-added">+         if (operand.isLocal() &amp;&amp; operand.toLocal() &lt; static_cast&lt;int&gt;(jit.baselineCodeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters()))</span>
<span class="udiff-line-added">+             continue;</span>
  
          switch (recovery.technique()) {
          case DisplacedInJSStack:
          case InFPR:
  #if USE(JSVALUE64)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1517,11 +730,11 @@</span>
          case UnboxedInt32InGPR:
          case Int32DisplacedInJSStack:
  #if USE(JSVALUE64)
              jit.load64(scratch + index, GPRInfo::regT0);
              jit.zeroExtend32ToPtr(GPRInfo::regT0, GPRInfo::regT0);
<span class="udiff-line-modified-removed">-             jit.or64(GPRInfo::tagTypeNumberRegister, GPRInfo::regT0);</span>
<span class="udiff-line-modified-added">+             jit.or64(GPRInfo::numberTagRegister, GPRInfo::regT0);</span>
              jit.store64(GPRInfo::regT0, AssemblyHelpers::addressFor(operand));
  #else
              jit.load32(
                  &amp;bitwise_cast&lt;EncodedValueDescriptor*&gt;(scratch + index)-&gt;asBits.payload,
                  GPRInfo::regT0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1595,11 +808,11 @@</span>
      // recoveries don&#39;t recursively refer to each other. But, we don&#39;t try to assume that they only
      // refer to certain ranges of locals. Hence why we need to do this here, once the stack is sensible.
      // Note that we also roughly assume that the arguments might still be materialized outside of its
      // inline call frame scope - but for now the DFG wouldn&#39;t do that.
  
<span class="udiff-line-modified-removed">-     emitRestoreArguments(jit, operands);</span>
<span class="udiff-line-modified-added">+     emitRestoreArguments(jit, vm, operands);</span>
  
      // Adjust the old JIT&#39;s execute counter. Since we are exiting OSR, we know
      // that all new calls into this code will go to the new JIT, so the execute
      // counter only affects call frames that performed OSR exit and call frames
      // that were still executing the old JIT at the time of another call frame&#39;s
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1633,30 +846,30 @@</span>
      // larger than the number of successes (we want 90% success rate), and if
      // there have been a large enough number of failures. If so, we set the
      // counter to 0; otherwise we set the counter to
      // counterValueForOptimizeAfterWarmUp().
  
<span class="udiff-line-modified-removed">-     handleExitCounts(jit, exit);</span>
<span class="udiff-line-modified-added">+     handleExitCounts(vm, jit, exit);</span>
  
      // Reify inlined call frames.
  
      reifyInlinedCallFrames(jit, exit);
  
      // And finish.
      adjustAndJumpToTarget(vm, jit, exit);
  }
  
<span class="udiff-line-modified-removed">- void JIT_OPERATION OSRExit::debugOperationPrintSpeculationFailure(ExecState* exec, void* debugInfoRaw, void* scratch)</span>
<span class="udiff-line-modified-added">+ void JIT_OPERATION operationDebugPrintSpeculationFailure(CallFrame* callFrame, void* debugInfoRaw, void* scratch)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="udiff-line-modified-added">+     NativeCallFrameTracer tracer(vm, callFrame);</span>
  
      SpeculationFailureDebugInfo* debugInfo = static_cast&lt;SpeculationFailureDebugInfo*&gt;(debugInfoRaw);
      CodeBlock* codeBlock = debugInfo-&gt;codeBlock;
      CodeBlock* alternative = codeBlock-&gt;alternative();
      dataLog(&quot;Speculation failure in &quot;, *codeBlock);
<span class="udiff-line-modified-removed">-     dataLog(&quot; @ exit #&quot;, vm.osrExitIndex, &quot; (bc#&quot;, debugInfo-&gt;bytecodeOffset, &quot;, &quot;, exitKindToString(debugInfo-&gt;kind), &quot;) with &quot;);</span>
<span class="udiff-line-modified-added">+     dataLog(&quot; @ exit #&quot;, vm.osrExitIndex, &quot; (&quot;, debugInfo-&gt;bytecodeIndex, &quot;, &quot;, exitKindToString(debugInfo-&gt;kind), &quot;) with &quot;);</span>
      if (alternative) {
          dataLog(
              &quot;executeCounter = &quot;, alternative-&gt;jitExecuteCounter(),
              &quot;, reoptimizationRetryCounter = &quot;, alternative-&gt;reoptimizationRetryCounter(),
              &quot;, optimizationDelayCounter = &quot;, alternative-&gt;optimizationDelayCounter());
</pre>
<center><a href="DFGOSREntrypointCreationPhase.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSRExit.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
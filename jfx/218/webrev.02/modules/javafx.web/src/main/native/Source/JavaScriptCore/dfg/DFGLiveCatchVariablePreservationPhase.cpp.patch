diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGLiveCatchVariablePreservationPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGLiveCatchVariablePreservationPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGLiveCatchVariablePreservationPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGLiveCatchVariablePreservationPhase.cpp
@@ -61,11 +61,11 @@
         }
 
         return true;
     }
 
-    bool isValidFlushLocation(BasicBlock* startingBlock, unsigned index, VirtualRegister operand)
+    bool isValidFlushLocation(BasicBlock* startingBlock, unsigned index, Operand operand)
     {
         // This code is not meant to be fast. We just use it for assertions. If we got liveness wrong,
         // this function would return false for a Flush that we insert.
         Vector<BasicBlock*, 4> worklist;
         BlockSet seen;
@@ -79,11 +79,11 @@
         };
 
         auto flushIsDefinitelyInvalid = [&] (BasicBlock* block, unsigned index) {
             bool allGood = false;
             for (unsigned i = index; i--; ) {
-                if (block->at(i)->accessesStack(m_graph) && block->at(i)->local() == operand) {
+                if (block->at(i)->accessesStack(m_graph) && block->at(i)->operand() == operand) {
                     allGood = true;
                     break;
                 }
             }
 
@@ -113,33 +113,32 @@
 
 
     void handleBlockForTryCatch(BasicBlock* block, InsertionSet& insertionSet)
     {
         HandlerInfo* currentExceptionHandler = nullptr;
-        FastBitVector liveAtCatchHead;
-        liveAtCatchHead.resize(m_graph.block(0)->variablesAtTail.numberOfLocals());
+        Operands<bool> liveAtCatchHead(0, m_graph.block(0)->variablesAtTail.numberOfLocals(), m_graph.block(0)->variablesAtTail.numberOfTmps());
 
         HandlerInfo* cachedHandlerResult;
         CodeOrigin cachedCodeOrigin;
         auto catchHandler = [&] (CodeOrigin origin) -> HandlerInfo* {
             ASSERT(origin);
             if (origin == cachedCodeOrigin)
                 return cachedHandlerResult;
 
-            unsigned bytecodeIndexToCheck = origin.bytecodeIndex();
+            BytecodeIndex bytecodeIndexToCheck = origin.bytecodeIndex();
 
             cachedCodeOrigin = origin;
 
             while (1) {
                 InlineCallFrame* inlineCallFrame = origin.inlineCallFrame();
                 CodeBlock* codeBlock = m_graph.baselineCodeBlockFor(inlineCallFrame);
-                if (HandlerInfo* handler = codeBlock->handlerForBytecodeOffset(bytecodeIndexToCheck)) {
-                    liveAtCatchHead.clearAll();
+                if (HandlerInfo* handler = codeBlock->handlerForBytecodeIndex(bytecodeIndexToCheck)) {
+                    liveAtCatchHead.fill(false);
 
-                    unsigned catchBytecodeIndex = handler->target;
-                    m_graph.forAllLocalsLiveInBytecode(CodeOrigin(catchBytecodeIndex, inlineCallFrame), [&] (VirtualRegister operand) {
-                        liveAtCatchHead[operand.toLocal()] = true;
+                    BytecodeIndex catchBytecodeIndex = BytecodeIndex(handler->target);
+                    m_graph.forAllLocalsAndTmpsLiveInBytecode(CodeOrigin(catchBytecodeIndex, inlineCallFrame), [&] (Operand operand) {
+                        liveAtCatchHead.operand(operand) = true;
                     });
 
                     cachedHandlerResult = handler;
                     break;
                 }
@@ -154,16 +153,16 @@
             }
 
             return cachedHandlerResult;
         };
 
-        Operands<VariableAccessData*> currentBlockAccessData(block->variablesAtTail.numberOfArguments(), block->variablesAtTail.numberOfLocals(), nullptr);
+        Operands<VariableAccessData*> currentBlockAccessData(OperandsLike, block->variablesAtTail, nullptr);
 
         auto flushEverything = [&] (NodeOrigin origin, unsigned index) {
             RELEASE_ASSERT(currentExceptionHandler);
-            auto flush = [&] (VirtualRegister operand) {
-                if ((operand.isLocal() && liveAtCatchHead[operand.toLocal()]) || operand.isArgument()) {
+            auto flush = [&] (Operand operand) {
+                if (operand.isArgument() || liveAtCatchHead.operand(operand)) {
 
                     ASSERT(isValidFlushLocation(block, index, operand));
 
                     VariableAccessData* accessData = currentBlockAccessData.operand(operand);
                     if (!accessData)
@@ -176,10 +175,12 @@
                 }
             };
 
             for (unsigned local = 0; local < block->variablesAtTail.numberOfLocals(); local++)
                 flush(virtualRegisterForLocal(local));
+            for (unsigned tmp = 0; tmp < block->variablesAtTail.numberOfTmps(); ++tmp)
+                flush(Operand::tmp(tmp));
             flush(VirtualRegister(CallFrame::thisArgumentOffset()));
         };
 
         for (unsigned nodeIndex = 0; nodeIndex < block->size(); nodeIndex++) {
             Node* node = block->at(nodeIndex);
@@ -190,13 +191,12 @@
                     flushEverything(node->origin, nodeIndex);
                 currentExceptionHandler = newHandler;
             }
 
             if (currentExceptionHandler && (node->op() == SetLocal || node->op() == SetArgumentDefinitely || node->op() == SetArgumentMaybe)) {
-                VirtualRegister operand = node->local();
-                if ((operand.isLocal() && liveAtCatchHead[operand.toLocal()]) || operand.isArgument()) {
-
+                Operand operand = node->operand();
+                if (operand.isArgument() || liveAtCatchHead.operand(operand)) {
                     ASSERT(isValidFlushLocation(block, nodeIndex, operand));
 
                     VariableAccessData* variableAccessData = currentBlockAccessData.operand(operand);
                     if (!variableAccessData)
                         variableAccessData = newVariableAccessData(operand);
@@ -205,20 +205,20 @@
                         Flush, node->origin, OpInfo(variableAccessData));
                 }
             }
 
             if (node->accessesStack(m_graph))
-                currentBlockAccessData.operand(node->local()) = node->variableAccessData();
+                currentBlockAccessData.operand(node->operand()) = node->variableAccessData();
         }
 
         if (currentExceptionHandler) {
             NodeOrigin origin = block->at(block->size() - 1)->origin;
             flushEverything(origin, block->size());
         }
     }
 
-    VariableAccessData* newVariableAccessData(VirtualRegister operand)
+    VariableAccessData* newVariableAccessData(Operand operand)
     {
         ASSERT(!operand.isConstant());
 
         m_graph.m_variableAccessData.append(operand);
         return &m_graph.m_variableAccessData.last();

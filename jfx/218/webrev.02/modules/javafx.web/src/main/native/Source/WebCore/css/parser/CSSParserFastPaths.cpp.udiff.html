<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserContext.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserFastPaths.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -62,10 +62,13 @@</span>
      case CSSPropertyMinBlockSize:
      case CSSPropertyPaddingBlockEnd:
      case CSSPropertyPaddingBlockStart:
      case CSSPropertyPaddingInlineEnd:
      case CSSPropertyPaddingInlineStart:
<span class="udiff-line-added">+     case CSSPropertyR:</span>
<span class="udiff-line-added">+     case CSSPropertyRx:</span>
<span class="udiff-line-added">+     case CSSPropertyRy:</span>
      case CSSPropertyShapeMargin:
          acceptsNegativeNumbers = false;
          return true;
      case CSSPropertyBottom:
      case CSSPropertyCx:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -85,29 +88,26 @@</span>
      case CSSPropertyMarginBlockStart:
      case CSSPropertyMarginInlineEnd:
      case CSSPropertyMarginInlineStart:
      case CSSPropertyX:
      case CSSPropertyY:
<span class="udiff-line-removed">-     case CSSPropertyR:</span>
<span class="udiff-line-removed">-     case CSSPropertyRx:</span>
<span class="udiff-line-removed">-     case CSSPropertyRy:</span>
          acceptsNegativeNumbers = true;
          return true;
      default:
          return false;
      }
  }
  
  template &lt;typename CharacterType&gt;
<span class="udiff-line-modified-removed">- static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType&amp; unit, double&amp; number)</span>
<span class="udiff-line-modified-added">+ static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSUnitType&amp; unit, double&amp; number)</span>
  {
      if (length &gt; 2 &amp;&amp; (characters[length - 2] | 0x20) == &#39;p&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;x&#39;) {
          length -= 2;
<span class="udiff-line-modified-removed">-         unit = CSSPrimitiveValue::UnitType::CSS_PX;</span>
<span class="udiff-line-modified-added">+         unit = CSSUnitType::CSS_PX;</span>
      } else if (length &gt; 1 &amp;&amp; characters[length - 1] == &#39;%&#39;) {
          length -= 1;
<span class="udiff-line-modified-removed">-         unit = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;</span>
<span class="udiff-line-modified-added">+         unit = CSSUnitType::CSS_PERCENTAGE;</span>
      }
  
      // We rely on charactersToDouble for validation as well. The function
      // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
      // not represent a double.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -117,22 +117,22 @@</span>
          return false;
      return true;
  }
  
  template &lt;typename CharacterType&gt;
<span class="udiff-line-modified-removed">- static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType&amp; unit, double&amp; number)</span>
<span class="udiff-line-modified-added">+ static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSUnitType&amp; unit, double&amp; number)</span>
  {
      // Just support deg and rad for now.
      if (length &lt; 4)
          return false;
  
      if ((characters[length - 3] | 0x20) == &#39;d&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;e&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;g&#39;) {
          length -= 3;
<span class="udiff-line-modified-removed">-         unit = CSSPrimitiveValue::UnitType::CSS_DEG;</span>
<span class="udiff-line-modified-added">+         unit = CSSUnitType::CSS_DEG;</span>
      } else if ((characters[length - 3] | 0x20) == &#39;r&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;a&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;d&#39;) {
          length -= 3;
<span class="udiff-line-modified-removed">-         unit = CSSPrimitiveValue::UnitType::CSS_RAD;</span>
<span class="udiff-line-modified-added">+         unit = CSSUnitType::CSS_RAD;</span>
      } else
          return false;
  
      // We rely on charactersToDouble for validation as well. The function
      // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -153,24 +153,24 @@</span>
      if (isCSSViewportParsingEnabledForMode(cssParserMode) || !isSimpleLengthPropertyID(propertyId, acceptsNegativeNumbers))
          return nullptr;
  
      unsigned length = string.length();
      double number;
<span class="udiff-line-modified-removed">-     CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
<span class="udiff-line-modified-added">+     CSSUnitType unit = CSSUnitType::CSS_NUMBER;</span>
  
      if (string.is8Bit()) {
          if (!parseSimpleLength(string.characters8(), length, unit, number))
              return nullptr;
      } else {
          if (!parseSimpleLength(string.characters16(), length, unit, number))
              return nullptr;
      }
  
<span class="udiff-line-modified-removed">-     if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER) {</span>
<span class="udiff-line-modified-added">+     if (unit == CSSUnitType::CSS_NUMBER) {</span>
          if (number &amp;&amp; cssParserMode != SVGAttributeMode)
              return nullptr;
<span class="udiff-line-modified-removed">-         unit = CSSPrimitiveValue::UnitType::CSS_PX;</span>
<span class="udiff-line-modified-added">+         unit = CSSUnitType::CSS_PX;</span>
      }
  
      if (number &lt; 0 &amp;&amp; !acceptsNegativeNumbers)
          return nullptr;
      if (std::isinf(number))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -278,11 +278,11 @@</span>
      value = localValue + fraction / scale;
      return length;
  }
  
  template &lt;typename CharacterType&gt;
<span class="udiff-line-modified-removed">- static bool parseColorIntOrPercentage(const CharacterType*&amp; string, const CharacterType* end, const char terminator, CSSPrimitiveValue::UnitType&amp; expect, int&amp; value)</span>
<span class="udiff-line-modified-added">+ static bool parseColorIntOrPercentage(const CharacterType*&amp; string, const CharacterType* end, const char terminator, CSSUnitType&amp; expect, int&amp; value)</span>
  {
      const CharacterType* current = string;
      double localValue = 0;
      bool negative = false;
      while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -306,11 +306,11 @@</span>
      }
  
      if (current == end)
          return false;
  
<span class="udiff-line-modified-removed">-     if (expect == CSSPrimitiveValue::UnitType::CSS_NUMBER &amp;&amp; (*current == &#39;.&#39; || *current == &#39;%&#39;))</span>
<span class="udiff-line-modified-added">+     if (expect == CSSUnitType::CSS_NUMBER &amp;&amp; (*current == &#39;.&#39; || *current == &#39;%&#39;))</span>
          return false;
  
      if (*current == &#39;.&#39;) {
          // We already parsed the integral part, try to parse
          // the fraction part of the percentage value.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -322,22 +322,22 @@</span>
          if (*current != &#39;%&#39;)
              return false;
          localValue += percentage;
      }
  
<span class="udiff-line-modified-removed">-     if (expect == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE &amp;&amp; *current != &#39;%&#39;)</span>
<span class="udiff-line-modified-added">+     if (expect == CSSUnitType::CSS_PERCENTAGE &amp;&amp; *current != &#39;%&#39;)</span>
          return false;
  
      if (*current == &#39;%&#39;) {
<span class="udiff-line-modified-removed">-         expect = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;</span>
<span class="udiff-line-modified-removed">-         localValue = localValue / 100.0 * 256.0;</span>
<span class="udiff-line-modified-added">+         expect = CSSUnitType::CSS_PERCENTAGE;</span>
<span class="udiff-line-modified-added">+         localValue = localValue / 100.0 * 255.0;</span>
          // Clamp values at 255 for percentages over 100%
          if (localValue &gt; 255)
              localValue = 255;
          current++;
      } else {
<span class="udiff-line-modified-removed">-         expect = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
<span class="udiff-line-modified-added">+         expect = CSSUnitType::CSS_NUMBER;</span>
      }
  
      while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
          current++;
      if (current == end || *current++ != terminator)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -398,20 +398,22 @@</span>
          string = end;
          return true;
      }
  
      if (isTenthAlpha(string, length - 1)) {
<span class="udiff-line-modified-removed">-         static const int tenthAlphaValues[] = { 0, 25, 51, 76, 102, 127, 153, 179, 204, 230 };</span>
<span class="udiff-line-modified-added">+         static const int tenthAlphaValues[] = { 0, 26, 51, 77, 102, 128, 153, 179, 204, 230 };</span>
          value = negative ? 0 : tenthAlphaValues[string[length - 2] - &#39;0&#39;];
          string = end;
          return true;
      }
  
      double alpha = 0;
      if (!parseDouble(string, end, terminator, alpha))
          return false;
<span class="udiff-line-modified-removed">-     value = negative ? 0 : static_cast&lt;int&gt;(alpha * nextafter(256.0, 0.0));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     // W3 standard stipulates a 2.55 alpha value multiplication factor.</span>
<span class="udiff-line-added">+     value = negative ? 0 : static_cast&lt;int&gt;(lroundf(clampTo&lt;double&gt;(alpha, 0.0, 1.0) * 255.0f));</span>
      string = end;
      return true;
  }
  
  template &lt;typename CharacterType&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -438,11 +440,11 @@</span>
  }
  
  template &lt;typename CharacterType&gt;
  static Color fastParseColorInternal(const CharacterType* characters, unsigned length, bool quirksMode)
  {
<span class="udiff-line-modified-removed">-     CSSPrimitiveValue::UnitType expect = CSSPrimitiveValue::UnitType::CSS_UNKNOWN;</span>
<span class="udiff-line-modified-added">+     CSSUnitType expect = CSSUnitType::CSS_UNKNOWN;</span>
  
      if (length &gt;= 4 &amp;&amp; characters[0] == &#39;#&#39;) {
          RGBA32 rgb;
          if (Color::parseHexColor(characters + 1, length - 1, rgb))
              return Color(rgb);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -495,18 +497,18 @@</span>
      }
  
      return Color();
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;CSSValue&gt; CSSParserFastPaths::parseColor(const String&amp; string, CSSParserMode parserMode)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;CSSValue&gt; CSSParserFastPaths::parseColor(const String&amp; string, CSSParserMode parserMode, CSSValuePool&amp; valuePool)</span>
  {
      ASSERT(!string.isEmpty());
      CSSValueID valueID = cssValueKeywordID(string);
      if (StyleColor::isColorKeyword(valueID)) {
          if (!isValueAllowedInMode(valueID, parserMode))
              return nullptr;
<span class="udiff-line-modified-removed">-         return CSSValuePool::singleton().createIdentifierValue(valueID);</span>
<span class="udiff-line-modified-added">+         return valuePool.createIdentifierValue(valueID);</span>
      }
  
      bool quirksMode = isQuirksModeBehavior(parserMode);
  
      // Fast path for hex colors and rgb()/rgba() colors
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -515,11 +517,11 @@</span>
          color = fastParseColorInternal(string.characters8(), string.length(), quirksMode);
      else
          color = fastParseColorInternal(string.characters16(), string.length(), quirksMode);
      if (!color.isValid())
          return nullptr;
<span class="udiff-line-modified-removed">-     return CSSValuePool::singleton().createColorValue(color);</span>
<span class="udiff-line-modified-added">+     return valuePool.createColorValue(color);</span>
  }
  
  bool CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyID propertyId, CSSValueID valueID, const CSSParserContext&amp; context)
  {
  #if !ENABLE(OVERFLOW_SCROLLING_TOUCH)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -587,10 +589,12 @@</span>
              || (valueID &gt;= CSSValueCentral &amp;&amp; valueID &lt;= CSSValueMathematical);
      case CSSPropertyEmptyCells: // show | hide
          return valueID == CSSValueShow || valueID == CSSValueHide;
      case CSSPropertyFloat: // left | right | none
          return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueNone;
<span class="udiff-line-added">+     case CSSPropertyImageOrientation: // from-image | none</span>
<span class="udiff-line-added">+         return valueID == CSSValueFromImage || valueID == CSSValueNone;</span>
      case CSSPropertyImageRendering: // auto | optimizeContrast | pixelated | optimizeSpeed | crispEdges | optimizeQuality | webkit-crispEdges
          return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality || valueID == CSSValueWebkitCrispEdges || valueID == CSSValueWebkitOptimizeContrast || valueID == CSSValueCrispEdges || valueID == CSSValuePixelated;
  #if ENABLE(CSS_COMPOSITING)
      case CSSPropertyIsolation: // auto | isolate
          return valueID == CSSValueAuto || valueID == CSSValueIsolate;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -623,23 +627,19 @@</span>
      case CSSPropertyBreakInside:
          return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValueAvoidColumn;
      case CSSPropertyPointerEvents:
          // none | visiblePainted | visibleFill | visibleStroke | visible |
          // painted | fill | stroke | auto | all | bounding-box
<span class="udiff-line-modified-removed">-         return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || (valueID &gt;= CSSValueVisiblePainted &amp;&amp; valueID &lt;= CSSValueStroke);</span>
<span class="udiff-line-modified-added">+         return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || valueID == CSSValueBoundingBox || (valueID &gt;= CSSValueVisiblePainted &amp;&amp; valueID &lt;= CSSValueStroke);</span>
      case CSSPropertyPosition: // static | relative | absolute | fixed | sticky
          return valueID == CSSValueStatic
              || valueID == CSSValueRelative
              || valueID == CSSValueAbsolute
              || valueID == CSSValueFixed
              || valueID == CSSValueSticky || valueID == CSSValueWebkitSticky;
      case CSSPropertyResize: // none | both | horizontal | vertical | auto
          return valueID == CSSValueNone || valueID == CSSValueBoth || valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
<span class="udiff-line-removed">-     // FIXME-NEWPARSER: Investigate this property.</span>
<span class="udiff-line-removed">-     // case CSSPropertyScrollBehavior: // auto | smooth</span>
<span class="udiff-line-removed">-     //     ASSERT(RuntimeEnabledFeatures::cssomSmoothScrollEnabled());</span>
<span class="udiff-line-removed">-     //   return valueID == CSSValueAuto || valueID == CSSValueSmooth;</span>
      case CSSPropertyShapeRendering:
          return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueCrispedges || valueID == CSSValueGeometricPrecision;
      case CSSPropertyStrokeLinejoin:
          return valueID == CSSValueMiter || valueID == CSSValueRound || valueID == CSSValueBevel;
      case CSSPropertyStrokeLinecap:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -853,10 +853,11 @@</span>
      case CSSPropertyFlexWrap:
      case CSSPropertyFloat:
      case CSSPropertyFontVariantAlternates:
      case CSSPropertyFontVariantCaps:
      case CSSPropertyFontVariantPosition:
<span class="udiff-line-added">+     case CSSPropertyImageOrientation:</span>
      case CSSPropertyImageRendering:
      case CSSPropertyListStylePosition:
      case CSSPropertyListStyleType:
      case CSSPropertyObjectFit:
      case CSSPropertyOutlineStyle:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -935,11 +936,10 @@</span>
      // FIXME-NEWPARSER: Add the following unprefixed properties:
      // case CSSPropertyBackfaceVisibility:
      // case CSSPropertyFontKerning:
      // case CSSPropertyHyphens:
      // case CSSPropertyOverflowAnchor:
<span class="udiff-line-removed">-     // case CSSPropertyScrollBehavior:</span>
      // case CSSPropertyScrollSnapType:
      // case CSSPropertyTextAlignLast:
      // case CSSPropertyTextCombineUpright:
      // case CSSPropertyTextDecorationStyle:
      // case CSSPropertyTextJustify:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1035,17 +1035,17 @@</span>
      while (expectedCount) {
          size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
          if (delimiter == notFound)
              return false;
          unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
<span class="udiff-line-modified-removed">-         CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
<span class="udiff-line-modified-added">+         CSSUnitType unit = CSSUnitType::CSS_NUMBER;</span>
          double number;
          if (!parseSimpleLength(pos, argumentLength, unit, number))
              return false;
<span class="udiff-line-modified-removed">-         if (!number &amp;&amp; unit == CSSPrimitiveValue::CSS_NUMBER)</span>
<span class="udiff-line-modified-removed">-             unit = CSSPrimitiveValue::UnitType::CSS_PX;</span>
<span class="udiff-line-modified-removed">-         if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER || (unit == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE &amp;&amp; (transformValue-&gt;name() == CSSValueTranslateZ || (transformValue-&gt;name() == CSSValueTranslate3d &amp;&amp; expectedCount == 1))))</span>
<span class="udiff-line-modified-added">+         if (!number &amp;&amp; unit == CSSUnitType::CSS_NUMBER)</span>
<span class="udiff-line-modified-added">+             unit = CSSUnitType::CSS_PX;</span>
<span class="udiff-line-modified-added">+         if (unit == CSSUnitType::CSS_NUMBER || (unit == CSSUnitType::CSS_PERCENTAGE &amp;&amp; (transformValue-&gt;name() == CSSValueTranslateZ || (transformValue-&gt;name() == CSSValueTranslate3d &amp;&amp; expectedCount == 1))))</span>
              return false;
          transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
          pos += argumentLength + 1;
          --expectedCount;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1058,16 +1058,16 @@</span>
      size_t delimiter = WTF::find(pos, end - pos, &#39;)&#39;);
      if (delimiter == notFound)
          return false;
  
      unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
<span class="udiff-line-modified-removed">-     CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;</span>
<span class="udiff-line-modified-added">+     CSSUnitType unit = CSSUnitType::CSS_NUMBER;</span>
      double number;
      if (!parseSimpleAngle(pos, argumentLength, unit, number))
          return false;
<span class="udiff-line-modified-removed">-     if (!number &amp;&amp; unit == CSSPrimitiveValue::CSS_NUMBER)</span>
<span class="udiff-line-modified-removed">-         unit = CSSPrimitiveValue::UnitType::CSS_DEG;</span>
<span class="udiff-line-modified-added">+     if (!number &amp;&amp; unit == CSSUnitType::CSS_NUMBER)</span>
<span class="udiff-line-modified-added">+         unit = CSSUnitType::CSS_DEG;</span>
  
      transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
      pos += argumentLength + 1;
  
      return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1083,11 +1083,11 @@</span>
          unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
          bool ok;
          double number = charactersToDouble(pos, argumentLength, &amp;ok);
          if (!ok)
              return false;
<span class="udiff-line-modified-removed">-         transformValue-&gt;append(CSSPrimitiveValue::create(number, CSSPrimitiveValue::UnitType::CSS_NUMBER));</span>
<span class="udiff-line-modified-added">+         transformValue-&gt;append(CSSPrimitiveValue::create(number, CSSUnitType::CSS_NUMBER));</span>
          pos += argumentLength + 1;
          --expectedCount;
      }
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1298,21 +1298,21 @@</span>
  {
      ASSERT(!string.isEmpty());
      CSSValueID valueID = cssValueKeywordID(string);
      if (valueID == CSSValueAuto)
          return CSSValuePool::singleton().createIdentifierValue(valueID);
<span class="udiff-line-modified-removed">-     return CSSParserFastPaths::parseColor(string, parserMode);</span>
<span class="udiff-line-modified-added">+     return CSSParserFastPaths::parseColor(string, parserMode, CSSValuePool::singleton());</span>
  }
  
  RefPtr&lt;CSSValue&gt; CSSParserFastPaths::maybeParseValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
  {
      if (auto result = parseSimpleLengthValue(propertyID, string, context.mode))
          return result;
      if (propertyID == CSSPropertyCaretColor)
          return parseCaretColor(string, context.mode);
      if (isColorPropertyID(propertyID))
<span class="udiff-line-modified-removed">-         return parseColor(string, context.mode);</span>
<span class="udiff-line-modified-added">+         return parseColor(string, context.mode, CSSValuePool::singleton());</span>
      if (auto result = parseKeywordValue(propertyID, string, context))
          return result;
      return parseSimpleTransform(propertyID, string);
  }
  
</pre>
<center><a href="CSSParserContext.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserFastPaths.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
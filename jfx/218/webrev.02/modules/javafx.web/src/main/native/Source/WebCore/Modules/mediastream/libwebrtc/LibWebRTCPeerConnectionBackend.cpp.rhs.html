<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;IceCandidate.h&quot;
 32 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 33 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 34 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 35 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 36 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 37 #include &quot;MediaEndpointConfiguration.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;RTCIceCandidate.h&quot;
 40 #include &quot;RTCPeerConnection.h&quot;
 41 #include &quot;RTCRtpCapabilities.h&quot;
 42 #include &quot;RTCRtpReceiver.h&quot;
 43 #include &quot;RTCSessionDescription.h&quot;
 44 #include &quot;RealtimeIncomingAudioSource.h&quot;
 45 #include &quot;RealtimeIncomingVideoSource.h&quot;
 46 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 47 #include &quot;RealtimeOutgoingVideoSource.h&quot;
<a name="1" id="anc1"></a>
 48 #include &quot;Settings.h&quot;
 49 
 50 namespace WebCore {
 51 
 52 static std::unique_ptr&lt;PeerConnectionBackend&gt; createLibWebRTCPeerConnectionBackend(RTCPeerConnection&amp; peerConnection)
 53 {
 54     if (!LibWebRTCProvider::webRTCAvailable())
 55         return nullptr;
 56 
 57     auto* page = downcast&lt;Document&gt;(*peerConnection.scriptExecutionContext()).page();
 58     if (!page)
 59         return nullptr;
 60 
 61     page-&gt;libWebRTCProvider().setEnableWebRTCEncryption(page-&gt;settings().webRTCEncryptionEnabled());
 62 
 63     return makeUnique&lt;LibWebRTCPeerConnectionBackend&gt;(peerConnection, page-&gt;libWebRTCProvider());
 64 }
 65 
 66 CreatePeerConnectionBackend PeerConnectionBackend::create = createLibWebRTCPeerConnectionBackend;
 67 
 68 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::receiverCapabilities(ScriptExecutionContext&amp; context, const String&amp; kind)
 69 {
 70     auto* page = downcast&lt;Document&gt;(context).page();
 71     if (!page)
 72         return { };
 73     return page-&gt;libWebRTCProvider().receiverCapabilities(kind);
 74 }
 75 
 76 Optional&lt;RTCRtpCapabilities&gt; PeerConnectionBackend::senderCapabilities(ScriptExecutionContext&amp; context, const String&amp; kind)
 77 {
 78     auto* page = downcast&lt;Document&gt;(context).page();
 79     if (!page)
 80         return { };
 81     return page-&gt;libWebRTCProvider().senderCapabilities(kind);
 82 }
 83 
 84 LibWebRTCPeerConnectionBackend::LibWebRTCPeerConnectionBackend(RTCPeerConnection&amp; peerConnection, LibWebRTCProvider&amp; provider)
 85     : PeerConnectionBackend(peerConnection)
 86     , m_endpoint(LibWebRTCMediaEndpoint::create(*this, provider))
 87 {
 88 }
 89 
 90 LibWebRTCPeerConnectionBackend::~LibWebRTCPeerConnectionBackend() = default;
 91 
<a name="2" id="anc2"></a><span class="line-added"> 92 void LibWebRTCPeerConnectionBackend::suspend()</span>
<span class="line-added"> 93 {</span>
<span class="line-added"> 94     m_endpoint-&gt;suspend();</span>
<span class="line-added"> 95 }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 void LibWebRTCPeerConnectionBackend::resume()</span>
<span class="line-added"> 98 {</span>
<span class="line-added"> 99     m_endpoint-&gt;resume();</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
102 static inline webrtc::PeerConnectionInterface::BundlePolicy bundlePolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
103 {
104     switch (configuration.bundlePolicy) {
105     case RTCBundlePolicy::MaxCompat:
106         return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
107     case RTCBundlePolicy::MaxBundle:
108         return webrtc::PeerConnectionInterface::kBundlePolicyMaxBundle;
109     case RTCBundlePolicy::Balanced:
110         return webrtc::PeerConnectionInterface::kBundlePolicyBalanced;
111     }
112 
113     ASSERT_NOT_REACHED();
114     return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
115 }
116 
117 static inline webrtc::PeerConnectionInterface::RtcpMuxPolicy rtcpMuxPolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
118 {
119     switch (configuration.rtcpMuxPolicy) {
120     case RTCPMuxPolicy::Negotiate:
121         return webrtc::PeerConnectionInterface::kRtcpMuxPolicyNegotiate;
122     case RTCPMuxPolicy::Require:
123         return webrtc::PeerConnectionInterface::kRtcpMuxPolicyRequire;
124     }
125 
126     ASSERT_NOT_REACHED();
127     return webrtc::PeerConnectionInterface::kRtcpMuxPolicyRequire;
128 }
129 
130 static inline webrtc::PeerConnectionInterface::IceTransportsType iceTransportPolicyfromConfiguration(const MediaEndpointConfiguration&amp; configuration)
131 {
132     switch (configuration.iceTransportPolicy) {
133     case RTCIceTransportPolicy::Relay:
134         return webrtc::PeerConnectionInterface::kRelay;
135     case RTCIceTransportPolicy::All:
136         return webrtc::PeerConnectionInterface::kAll;
137     }
138 
139     ASSERT_NOT_REACHED();
140     return webrtc::PeerConnectionInterface::kNone;
141 }
142 
143 static webrtc::PeerConnectionInterface::RTCConfiguration configurationFromMediaEndpointConfiguration(MediaEndpointConfiguration&amp;&amp; configuration)
144 {
145     webrtc::PeerConnectionInterface::RTCConfiguration rtcConfiguration;
146 
147     rtcConfiguration.type = iceTransportPolicyfromConfiguration(configuration);
148     rtcConfiguration.bundle_policy = bundlePolicyfromConfiguration(configuration);
149     rtcConfiguration.rtcp_mux_policy = rtcpMuxPolicyfromConfiguration(configuration);
150 
151     for (auto&amp; server : configuration.iceServers) {
152         webrtc::PeerConnectionInterface::IceServer iceServer;
153         iceServer.username = server.username.utf8().data();
154         iceServer.password = server.credential.utf8().data();
155         for (auto&amp; url : server.urls)
156             iceServer.urls.push_back({ url.string().utf8().data() });
157         rtcConfiguration.servers.push_back(WTFMove(iceServer));
158     }
159 
160     rtcConfiguration.set_cpu_adaptation(false);
161     // FIXME: Activate ice candidate pool size once it no longer bothers test bots.
162     // rtcConfiguration.ice_candidate_pool_size = configuration.iceCandidatePoolSize;
163 
164     for (auto&amp; pem : configuration.certificates) {
165         rtcConfiguration.certificates.push_back(rtc::RTCCertificate::FromPEM(rtc::RTCCertificatePEM {
166             pem.privateKey.utf8().data(), pem.certificate.utf8().data()
167         }));
168     }
169 
170     return rtcConfiguration;
171 }
172 
173 bool LibWebRTCPeerConnectionBackend::setConfiguration(MediaEndpointConfiguration&amp;&amp; configuration)
174 {
175     auto* page = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext()).page();
176     if (!page)
177         return false;
178 
179     return m_endpoint-&gt;setConfiguration(page-&gt;libWebRTCProvider(), configurationFromMediaEndpointConfiguration(WTFMove(configuration)));
180 }
181 
182 void LibWebRTCPeerConnectionBackend::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
183 {
184     m_endpoint-&gt;getStats(WTFMove(promise));
185 }
186 
187 static inline LibWebRTCRtpSenderBackend&amp; backendFromRTPSender(RTCRtpSender&amp; sender)
188 {
189     ASSERT(!sender.isStopped());
190     return static_cast&lt;LibWebRTCRtpSenderBackend&amp;&gt;(*sender.backend());
191 }
192 
193 void LibWebRTCPeerConnectionBackend::getStats(RTCRtpSender&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
194 {
195     webrtc::RtpSenderInterface* rtcSender = sender.backend() ? backendFromRTPSender(sender).rtcSender() : nullptr;
196 
197     if (!rtcSender) {
198         m_endpoint-&gt;getStats(WTFMove(promise));
199         return;
200     }
201     m_endpoint-&gt;getStats(*rtcSender, WTFMove(promise));
202 }
203 
204 void LibWebRTCPeerConnectionBackend::getStats(RTCRtpReceiver&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
205 {
206     webrtc::RtpReceiverInterface* rtcReceiver = receiver.backend() ? static_cast&lt;LibWebRTCRtpReceiverBackend*&gt;(receiver.backend())-&gt;rtcReceiver() : nullptr;
207 
208     if (!rtcReceiver) {
209         m_endpoint-&gt;getStats(WTFMove(promise));
210         return;
211     }
212     m_endpoint-&gt;getStats(*rtcReceiver, WTFMove(promise));
213 }
214 
215 void LibWebRTCPeerConnectionBackend::doSetLocalDescription(RTCSessionDescription&amp; description)
216 {
217     m_endpoint-&gt;doSetLocalDescription(description);
218     if (!m_isLocalDescriptionSet) {
219         if (m_isRemoteDescriptionSet) {
220             for (auto&amp; candidate : m_pendingCandidates)
221                 m_endpoint-&gt;addIceCandidate(*candidate);
222             m_pendingCandidates.clear();
223         }
224         m_isLocalDescriptionSet = true;
225     }
226 }
227 
228 void LibWebRTCPeerConnectionBackend::doSetRemoteDescription(RTCSessionDescription&amp; description)
229 {
230     m_endpoint-&gt;doSetRemoteDescription(description);
231     if (!m_isRemoteDescriptionSet) {
232         if (m_isLocalDescriptionSet) {
233             for (auto&amp; candidate : m_pendingCandidates)
234                 m_endpoint-&gt;addIceCandidate(*candidate);
235         }
236         m_isRemoteDescriptionSet = true;
237     }
238 }
239 
240 void LibWebRTCPeerConnectionBackend::doCreateOffer(RTCOfferOptions&amp;&amp; options)
241 {
242     m_endpoint-&gt;doCreateOffer(options);
243 }
244 
245 void LibWebRTCPeerConnectionBackend::doCreateAnswer(RTCAnswerOptions&amp;&amp;)
246 {
247     if (!m_isRemoteDescriptionSet) {
248         createAnswerFailed(Exception { InvalidStateError, &quot;No remote description set&quot; });
249         return;
250     }
251     m_endpoint-&gt;doCreateAnswer();
252 }
253 
<a name="3" id="anc3"></a><span class="line-added">254 void LibWebRTCPeerConnectionBackend::close()</span>
<span class="line-added">255 {</span>
<span class="line-added">256     m_endpoint-&gt;close();</span>
<span class="line-added">257 }</span>
<span class="line-added">258 </span>
259 void LibWebRTCPeerConnectionBackend::doStop()
260 {
261     m_endpoint-&gt;stop();
262     m_pendingReceivers.clear();
263 }
264 
265 void LibWebRTCPeerConnectionBackend::doAddIceCandidate(RTCIceCandidate&amp; candidate)
266 {
267     webrtc::SdpParseError error;
268     int sdpMLineIndex = candidate.sdpMLineIndex() ? candidate.sdpMLineIndex().value() : 0;
269     std::unique_ptr&lt;webrtc::IceCandidateInterface&gt; rtcCandidate(webrtc::CreateIceCandidate(candidate.sdpMid().utf8().data(), sdpMLineIndex, candidate.candidate().utf8().data(), &amp;error));
270 
271     if (!rtcCandidate) {
272         addIceCandidateFailed(Exception { OperationError, String::fromUTF8(error.description.data(), error.description.length()) });
273         return;
274     }
275 
276     // libwebrtc does not like that ice candidates are set before the description.
277     if (!m_isLocalDescriptionSet || !m_isRemoteDescriptionSet)
278         m_pendingCandidates.append(WTFMove(rtcCandidate));
279     else if (!m_endpoint-&gt;addIceCandidate(*rtcCandidate.get())) {
280         ASSERT_NOT_REACHED();
281         addIceCandidateFailed(Exception { OperationError, &quot;Failed to apply the received candidate&quot;_s });
282         return;
283     }
284     addIceCandidateSucceeded();
285 }
286 
287 Ref&lt;RTCRtpReceiver&gt; LibWebRTCPeerConnectionBackend::createReceiverForSource(Ref&lt;RealtimeMediaSource&gt;&amp;&amp; source, std::unique_ptr&lt;RTCRtpReceiverBackend&gt;&amp;&amp; backend)
288 {
289     auto&amp; document = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext());
290     auto trackID = source-&gt;persistentID();
291     auto remoteTrackPrivate = MediaStreamTrackPrivate::create(document.logger(), WTFMove(source), WTFMove(trackID));
292     auto remoteTrack = MediaStreamTrack::create(document, WTFMove(remoteTrackPrivate));
293 
294     return RTCRtpReceiver::create(*this, WTFMove(remoteTrack), WTFMove(backend));
295 }
296 
297 static inline Ref&lt;RealtimeMediaSource&gt; createEmptySource(const String&amp; trackKind, String&amp;&amp; trackId)
298 {
299     // FIXME: trackKind should be an enumeration
300     if (trackKind == &quot;audio&quot;)
301         return RealtimeIncomingAudioSource::create(nullptr, WTFMove(trackId));
302     ASSERT(trackKind == &quot;video&quot;);
303     return RealtimeIncomingVideoSource::create(nullptr, WTFMove(trackId));
304 }
305 
306 Ref&lt;RTCRtpReceiver&gt; LibWebRTCPeerConnectionBackend::createReceiver(const String&amp; trackKind, const String&amp; trackId)
307 {
308     auto receiver = createReceiverForSource(createEmptySource(trackKind, String(trackId)), nullptr);
309     m_pendingReceivers.append(receiver.copyRef());
310     return receiver;
311 }
312 
313 LibWebRTCPeerConnectionBackend::VideoReceiver LibWebRTCPeerConnectionBackend::videoReceiver(String&amp;&amp; trackId)
314 {
315     // FIXME: Add to Vector a utility routine for that take-or-create pattern.
316     // FIXME: We should be selecting the receiver based on track id.
317     for (size_t cptr = 0; cptr &lt; m_pendingReceivers.size(); ++cptr) {
318         if (m_pendingReceivers[cptr]-&gt;track().source().type() == RealtimeMediaSource::Type::Video) {
319             Ref&lt;RTCRtpReceiver&gt; receiver = m_pendingReceivers[cptr].copyRef();
320             m_pendingReceivers.remove(cptr);
321             Ref&lt;RealtimeIncomingVideoSource&gt; source = static_cast&lt;RealtimeIncomingVideoSource&amp;&gt;(receiver-&gt;track().source());
322             return { WTFMove(receiver), WTFMove(source) };
323         }
324     }
325     auto source = RealtimeIncomingVideoSource::create(nullptr, WTFMove(trackId));
326     auto receiver = createReceiverForSource(source.copyRef(), nullptr);
327 
328     auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);
329     auto transceiver = RTCRtpTransceiver::create(RTCRtpSender::create(*this, &quot;video&quot;_s, { }, WTFMove(senderBackend)), receiver.copyRef(), nullptr);
330     transceiver-&gt;disableSendingDirection();
331     m_peerConnection.addTransceiver(WTFMove(transceiver));
332 
333     return { WTFMove(receiver), WTFMove(source) };
334 }
335 
336 LibWebRTCPeerConnectionBackend::AudioReceiver LibWebRTCPeerConnectionBackend::audioReceiver(String&amp;&amp; trackId)
337 {
338     // FIXME: Add to Vector a utility routine for that take-or-create pattern.
339     // FIXME: We should be selecting the receiver based on track id.
340     for (size_t cptr = 0; cptr &lt; m_pendingReceivers.size(); ++cptr) {
341         if (m_pendingReceivers[cptr]-&gt;track().source().type() == RealtimeMediaSource::Type::Audio) {
342             Ref&lt;RTCRtpReceiver&gt; receiver = m_pendingReceivers[cptr].copyRef();
343             m_pendingReceivers.remove(cptr);
344             Ref&lt;RealtimeIncomingAudioSource&gt; source = static_cast&lt;RealtimeIncomingAudioSource&amp;&gt;(receiver-&gt;track().source());
345             return { WTFMove(receiver), WTFMove(source) };
346         }
347     }
348     auto source = RealtimeIncomingAudioSource::create(nullptr, WTFMove(trackId));
349     auto receiver = createReceiverForSource(source.copyRef(), nullptr);
350 
351     auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);
352     auto transceiver = RTCRtpTransceiver::create(RTCRtpSender::create(*this, &quot;audio&quot;_s, { }, WTFMove(senderBackend)), receiver.copyRef(), nullptr);
353     transceiver-&gt;disableSendingDirection();
354     m_peerConnection.addTransceiver(WTFMove(transceiver));
355 
356     return { WTFMove(receiver), WTFMove(source) };
357 }
358 
359 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCPeerConnectionBackend::createDataChannelHandler(const String&amp; label, const RTCDataChannelInit&amp; options)
360 {
361     return m_endpoint-&gt;createDataChannel(label, options);
362 }
363 
364 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::currentLocalDescription() const
365 {
366     auto description = m_endpoint-&gt;currentLocalDescription();
367     if (description)
368         description-&gt;setSdp(filterSDP(String(description-&gt;sdp())));
369     return description;
370 }
371 
372 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::currentRemoteDescription() const
373 {
374     return m_endpoint-&gt;currentRemoteDescription();
375 }
376 
377 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::pendingLocalDescription() const
378 {
379     auto description = m_endpoint-&gt;pendingLocalDescription();
380     if (description)
381         description-&gt;setSdp(filterSDP(String(description-&gt;sdp())));
382     return description;
383 }
384 
385 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::pendingRemoteDescription() const
386 {
387     return m_endpoint-&gt;pendingRemoteDescription();
388 }
389 
390 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::localDescription() const
391 {
392     auto description = m_endpoint-&gt;localDescription();
393     if (description)
394         description-&gt;setSdp(filterSDP(String(description-&gt;sdp())));
395     return description;
396 }
397 
398 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCPeerConnectionBackend::remoteDescription() const
399 {
400     return m_endpoint-&gt;remoteDescription();
401 }
402 
403 static inline RefPtr&lt;RTCRtpSender&gt; findExistingSender(const Vector&lt;RefPtr&lt;RTCRtpTransceiver&gt;&gt;&amp; transceivers, LibWebRTCRtpSenderBackend&amp; senderBackend)
404 {
405     ASSERT(senderBackend.rtcSender());
406     for (auto&amp; transceiver : transceivers) {
407         auto&amp; sender = transceiver-&gt;sender();
408         if (!sender.isStopped() &amp;&amp; senderBackend.rtcSender() == backendFromRTPSender(sender).rtcSender())
409             return makeRef(sender);
410     }
411     return nullptr;
412 }
413 
414 ExceptionOr&lt;Ref&lt;RTCRtpSender&gt;&gt; LibWebRTCPeerConnectionBackend::addTrack(MediaStreamTrack&amp; track, Vector&lt;String&gt;&amp;&amp; mediaStreamIds)
415 {
<a name="4" id="anc4"></a><span class="line-modified">416     auto senderBackend = makeUnique&lt;LibWebRTCRtpSenderBackend&gt;(*this, nullptr);</span>
<span class="line-modified">417     if (!m_endpoint-&gt;addTrack(*senderBackend, track, mediaStreamIds))</span>
<span class="line-modified">418         return Exception { TypeError, &quot;Unable to add track&quot;_s };</span>








































419 
<a name="5" id="anc5"></a><span class="line-modified">420     if (auto sender = findExistingSender(m_peerConnection.currentTransceivers(), *senderBackend)) {</span>
<span class="line-modified">421         backendFromRTPSender(*sender).takeSource(*senderBackend);</span>
<span class="line-added">422         sender-&gt;setTrack(makeRef(track));</span>
<span class="line-added">423         sender-&gt;setMediaStreamIds(WTFMove(mediaStreamIds));</span>
<span class="line-added">424         return sender.releaseNonNull();</span>
425     }
426 
<a name="6" id="anc6"></a><span class="line-modified">427     auto transceiverBackend = m_endpoint-&gt;transceiverBackendFromSender(*senderBackend);</span>

428 
<a name="7" id="anc7"></a><span class="line-modified">429     auto sender = RTCRtpSender::create(*this, makeRef(track), WTFMove(mediaStreamIds), WTFMove(senderBackend));</span>
<span class="line-added">430     auto receiver = createReceiverForSource(createEmptySource(track.kind(), createCanonicalUUIDString()), transceiverBackend-&gt;createReceiverBackend());</span>
<span class="line-added">431     auto transceiver = RTCRtpTransceiver::create(sender.copyRef(), WTFMove(receiver), WTFMove(transceiverBackend));</span>
<span class="line-added">432     m_peerConnection.addInternalTransceiver(WTFMove(transceiver));</span>
<span class="line-added">433     return sender;</span>
434 }
435 
436 template&lt;typename T&gt;
<a name="8" id="anc8"></a><span class="line-modified">437 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiverFromTrackOrKind(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init)</span>
438 {
439     auto backends = m_endpoint-&gt;addTransceiver(trackOrKind, init);
440     if (!backends)
441         return Exception { InvalidAccessError, &quot;Unable to add transceiver&quot;_s };
442 
443     auto sender = RTCRtpSender::create(*this, WTFMove(trackOrKind), Vector&lt;String&gt; { }, WTFMove(backends-&gt;senderBackend));
444     auto receiver = createReceiverForSource(createEmptySource(sender-&gt;trackKind(), createCanonicalUUIDString()), WTFMove(backends-&gt;receiverBackend));
445     auto transceiver = RTCRtpTransceiver::create(WTFMove(sender), WTFMove(receiver), WTFMove(backends-&gt;transceiverBackend));
446     m_peerConnection.addInternalTransceiver(transceiver.copyRef());
447     return transceiver;
448 }
449 
450 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
451 {
<a name="9" id="anc9"></a><span class="line-modified">452     return addTransceiverFromTrackOrKind(String { trackKind }, init);</span>





453 }
454 
455 ExceptionOr&lt;Ref&lt;RTCRtpTransceiver&gt;&gt; LibWebRTCPeerConnectionBackend::addTransceiver(Ref&lt;MediaStreamTrack&gt;&amp;&amp; track, const RTCRtpTransceiverInit&amp; init)
456 {
<a name="10" id="anc10"></a><span class="line-modified">457     return addTransceiverFromTrackOrKind(WTFMove(track), init);</span>









458 }
459 
460 void LibWebRTCPeerConnectionBackend::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
461 {
462     m_endpoint-&gt;setSenderSourceFromTrack(sender, track);
463 }
464 
465 static inline LibWebRTCRtpTransceiverBackend&amp; backendFromRTPTransceiver(RTCRtpTransceiver&amp; transceiver)
466 {
467     return static_cast&lt;LibWebRTCRtpTransceiverBackend&amp;&gt;(*transceiver.backend());
468 }
469 
470 RTCRtpTransceiver* LibWebRTCPeerConnectionBackend::existingTransceiver(WTF::Function&lt;bool(LibWebRTCRtpTransceiverBackend&amp;)&gt;&amp;&amp; matchingFunction)
471 {
472     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
473         if (matchingFunction(backendFromRTPTransceiver(*transceiver)))
474             return transceiver.get();
475     }
476     return nullptr;
477 }
478 
479 RTCRtpTransceiver&amp; LibWebRTCPeerConnectionBackend::newRemoteTransceiver(std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt;&amp;&amp; transceiverBackend, Ref&lt;RealtimeMediaSource&gt;&amp;&amp; receiverSource)
480 {
481     auto sender = RTCRtpSender::create(*this, receiverSource-&gt;type() == RealtimeMediaSource::Type::Audio ? &quot;audio&quot;_s : &quot;video&quot;_s, Vector&lt;String&gt; { }, transceiverBackend-&gt;createSenderBackend(*this, nullptr));
482     auto receiver = createReceiverForSource(WTFMove(receiverSource), transceiverBackend-&gt;createReceiverBackend());
483     auto transceiver = RTCRtpTransceiver::create(WTFMove(sender), WTFMove(receiver), WTFMove(transceiverBackend));
484     m_peerConnection.addInternalTransceiver(transceiver.copyRef());
485     return transceiver.get();
486 }
487 
488 Ref&lt;RTCRtpTransceiver&gt; LibWebRTCPeerConnectionBackend::completeAddTransceiver(Ref&lt;RTCRtpSender&gt;&amp;&amp; sender, const RTCRtpTransceiverInit&amp; init, const String&amp; trackId, const String&amp; trackKind)
489 {
490     auto transceiver = RTCRtpTransceiver::create(WTFMove(sender), createReceiver(trackKind, trackId), nullptr);
491 
492     transceiver-&gt;setDirection(init.direction);
493 
494     m_peerConnection.addInternalTransceiver(transceiver.copyRef());
495     return transceiver;
496 }
497 
498 void LibWebRTCPeerConnectionBackend::collectTransceivers()
499 {
500     m_endpoint-&gt;collectTransceivers();
501 }
502 
503 void LibWebRTCPeerConnectionBackend::removeTrack(RTCRtpSender&amp; sender)
504 {
505     m_endpoint-&gt;removeTrack(backendFromRTPSender(sender));
506 }
507 
508 void LibWebRTCPeerConnectionBackend::applyRotationForOutgoingVideoSources()
509 {
510     for (auto&amp; transceiver : m_peerConnection.currentTransceivers()) {
511         if (!transceiver-&gt;sender().isStopped()) {
512             if (auto* videoSource = backendFromRTPSender(transceiver-&gt;sender()).videoSource())
513                 videoSource-&gt;setApplyRotation(true);
514         }
515     }
516 }
517 
<a name="11" id="anc11"></a>



















518 } // namespace WebCore
519 
520 #endif // USE(LIBWEBRTC)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
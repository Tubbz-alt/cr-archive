<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SamplingProfiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScopedArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 88         StackFrame()
 89         { }
 90 
 91         FrameType frameType { FrameType::Unknown };
 92         const void* cCodePC { nullptr };
 93         ExecutableBase* executable { nullptr };
 94         JSObject* callee { nullptr };
 95 #if ENABLE(WEBASSEMBLY)
 96         Optional&lt;Wasm::IndexOrName&gt; wasmIndexOrName;
 97 #endif
 98         Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode;
 99 
100         struct CodeLocation {
101             bool hasCodeBlockHash() const
102             {
103                 return codeBlockHash.isSet();
104             }
105 
106             bool hasBytecodeIndex() const
107             {
<span class="line-modified">108                 return bytecodeIndex != std::numeric_limits&lt;unsigned&gt;::max();</span>
109             }
110 
111             bool hasExpressionInfo() const
112             {
113                 return lineNumber != std::numeric_limits&lt;unsigned&gt;::max()
114                     &amp;&amp; columnNumber != std::numeric_limits&lt;unsigned&gt;::max();
115             }
116 
117             // These attempt to be expression-level line and column number.
118             unsigned lineNumber { std::numeric_limits&lt;unsigned&gt;::max() };
119             unsigned columnNumber { std::numeric_limits&lt;unsigned&gt;::max() };
<span class="line-modified">120             unsigned bytecodeIndex { std::numeric_limits&lt;unsigned&gt;::max() };</span>
121             CodeBlockHash codeBlockHash;
122             JITType jitType { JITType::None };
123         };
124 
125         CodeLocation semanticLocation;
126         Optional&lt;std::pair&lt;CodeLocation, CodeBlock*&gt;&gt; machineLocation; // This is non-null if we were inlined. It represents the machine frame we were inlined into.
127 
128         bool hasExpressionInfo() const { return semanticLocation.hasExpressionInfo(); }
129         unsigned lineNumber() const
130         {
131             ASSERT(hasExpressionInfo());
132             return semanticLocation.lineNumber;
133         }
134         unsigned columnNumber() const
135         {
136             ASSERT(hasExpressionInfo());
137             return semanticLocation.columnNumber;
138         }
139 
140         // These are function-level data.
</pre>
<hr />
<pre>
163         StackTrace(StackTrace&amp;&amp; other)
164             : timestamp(other.timestamp)
165             , frames(WTFMove(other.frames))
166         { }
167     };
168 
169     SamplingProfiler(VM&amp;, RefPtr&lt;Stopwatch&gt;&amp;&amp;);
170     ~SamplingProfiler();
171     void noticeJSLockAcquisition();
172     void noticeVMEntry();
173     void shutdown();
174     void visit(SlotVisitor&amp;);
175     Lock&amp; getLock() { return m_lock; }
176     void setTimingInterval(Seconds interval) { m_timingInterval = interval; }
177     JS_EXPORT_PRIVATE void start();
178     void start(const AbstractLocker&amp;);
179     Vector&lt;StackTrace&gt; releaseStackTraces(const AbstractLocker&amp;);
180     JS_EXPORT_PRIVATE String stackTracesAsJSON();
181     JS_EXPORT_PRIVATE void noticeCurrentThreadAsJSCExecutionThread();
182     void noticeCurrentThreadAsJSCExecutionThread(const AbstractLocker&amp;);
<span class="line-modified">183     void processUnverifiedStackTraces(); // You should call this only after acquiring the lock.</span>
184     void setStopWatch(const AbstractLocker&amp;, Ref&lt;Stopwatch&gt;&amp;&amp; stopwatch) { m_stopwatch = WTFMove(stopwatch); }
185     void pause(const AbstractLocker&amp;);
186     void clearData(const AbstractLocker&amp;);
187 
188     // Used for debugging in the JSC shell/DRT.
189     void registerForReportAtExit();
190     void reportDataToOptionFile();
191     JS_EXPORT_PRIVATE void reportTopFunctions();
192     JS_EXPORT_PRIVATE void reportTopFunctions(PrintStream&amp;);
193     JS_EXPORT_PRIVATE void reportTopBytecodes();
194     JS_EXPORT_PRIVATE void reportTopBytecodes(PrintStream&amp;);
195 
196 #if OS(DARWIN)
197     JS_EXPORT_PRIVATE mach_port_t machThread();
198 #endif
199 
200 private:
201     void createThreadIfNecessary(const AbstractLocker&amp;);
202     void timerLoop();
203     void takeSample(const AbstractLocker&amp;, Seconds&amp; stackTraceProcessingTime);
</pre>
</td>
<td>
<hr />
<pre>
 88         StackFrame()
 89         { }
 90 
 91         FrameType frameType { FrameType::Unknown };
 92         const void* cCodePC { nullptr };
 93         ExecutableBase* executable { nullptr };
 94         JSObject* callee { nullptr };
 95 #if ENABLE(WEBASSEMBLY)
 96         Optional&lt;Wasm::IndexOrName&gt; wasmIndexOrName;
 97 #endif
 98         Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode;
 99 
100         struct CodeLocation {
101             bool hasCodeBlockHash() const
102             {
103                 return codeBlockHash.isSet();
104             }
105 
106             bool hasBytecodeIndex() const
107             {
<span class="line-modified">108                 return !!bytecodeIndex;</span>
109             }
110 
111             bool hasExpressionInfo() const
112             {
113                 return lineNumber != std::numeric_limits&lt;unsigned&gt;::max()
114                     &amp;&amp; columnNumber != std::numeric_limits&lt;unsigned&gt;::max();
115             }
116 
117             // These attempt to be expression-level line and column number.
118             unsigned lineNumber { std::numeric_limits&lt;unsigned&gt;::max() };
119             unsigned columnNumber { std::numeric_limits&lt;unsigned&gt;::max() };
<span class="line-modified">120             BytecodeIndex bytecodeIndex;</span>
121             CodeBlockHash codeBlockHash;
122             JITType jitType { JITType::None };
123         };
124 
125         CodeLocation semanticLocation;
126         Optional&lt;std::pair&lt;CodeLocation, CodeBlock*&gt;&gt; machineLocation; // This is non-null if we were inlined. It represents the machine frame we were inlined into.
127 
128         bool hasExpressionInfo() const { return semanticLocation.hasExpressionInfo(); }
129         unsigned lineNumber() const
130         {
131             ASSERT(hasExpressionInfo());
132             return semanticLocation.lineNumber;
133         }
134         unsigned columnNumber() const
135         {
136             ASSERT(hasExpressionInfo());
137             return semanticLocation.columnNumber;
138         }
139 
140         // These are function-level data.
</pre>
<hr />
<pre>
163         StackTrace(StackTrace&amp;&amp; other)
164             : timestamp(other.timestamp)
165             , frames(WTFMove(other.frames))
166         { }
167     };
168 
169     SamplingProfiler(VM&amp;, RefPtr&lt;Stopwatch&gt;&amp;&amp;);
170     ~SamplingProfiler();
171     void noticeJSLockAcquisition();
172     void noticeVMEntry();
173     void shutdown();
174     void visit(SlotVisitor&amp;);
175     Lock&amp; getLock() { return m_lock; }
176     void setTimingInterval(Seconds interval) { m_timingInterval = interval; }
177     JS_EXPORT_PRIVATE void start();
178     void start(const AbstractLocker&amp;);
179     Vector&lt;StackTrace&gt; releaseStackTraces(const AbstractLocker&amp;);
180     JS_EXPORT_PRIVATE String stackTracesAsJSON();
181     JS_EXPORT_PRIVATE void noticeCurrentThreadAsJSCExecutionThread();
182     void noticeCurrentThreadAsJSCExecutionThread(const AbstractLocker&amp;);
<span class="line-modified">183     void processUnverifiedStackTraces(const AbstractLocker&amp;);</span>
184     void setStopWatch(const AbstractLocker&amp;, Ref&lt;Stopwatch&gt;&amp;&amp; stopwatch) { m_stopwatch = WTFMove(stopwatch); }
185     void pause(const AbstractLocker&amp;);
186     void clearData(const AbstractLocker&amp;);
187 
188     // Used for debugging in the JSC shell/DRT.
189     void registerForReportAtExit();
190     void reportDataToOptionFile();
191     JS_EXPORT_PRIVATE void reportTopFunctions();
192     JS_EXPORT_PRIVATE void reportTopFunctions(PrintStream&amp;);
193     JS_EXPORT_PRIVATE void reportTopBytecodes();
194     JS_EXPORT_PRIVATE void reportTopBytecodes(PrintStream&amp;);
195 
196 #if OS(DARWIN)
197     JS_EXPORT_PRIVATE mach_port_t machThread();
198 #endif
199 
200 private:
201     void createThreadIfNecessary(const AbstractLocker&amp;);
202     void timerLoop();
203     void takeSample(const AbstractLocker&amp;, Seconds&amp; stackTraceProcessingTime);
</pre>
</td>
</tr>
</table>
<center><a href="SamplingProfiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScopedArguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
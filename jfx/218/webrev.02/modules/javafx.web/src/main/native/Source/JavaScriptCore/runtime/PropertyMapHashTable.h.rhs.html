<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &quot;JSExportMacros.h&quot;
 24 #include &quot;PropertyOffset.h&quot;
 25 #include &quot;Structure.h&quot;
 26 #include &quot;WriteBarrier.h&quot;
 27 #include &lt;wtf/HashTable.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/Vector.h&gt;
 30 #include &lt;wtf/text/AtomStringImpl.h&gt;
 31 
 32 
 33 #define DUMP_PROPERTYMAP_STATS 0
 34 #define DUMP_PROPERTYMAP_COLLISIONS 0
 35 
 36 #define PROPERTY_MAP_DELETED_ENTRY_KEY ((UniquedStringImpl*)1)
 37 
 38 namespace JSC {
 39 
<a name="2" id="anc2"></a><span class="line-added"> 40 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PropertyTable);</span>
<span class="line-added"> 41 </span>
 42 #if DUMP_PROPERTYMAP_STATS
 43 
 44 struct PropertyMapHashTableStats {
 45     std::atomic&lt;unsigned&gt; numFinds;
 46     std::atomic&lt;unsigned&gt; numCollisions;
 47     std::atomic&lt;unsigned&gt; numLookups;
 48     std::atomic&lt;unsigned&gt; numLookupProbing;
 49     std::atomic&lt;unsigned&gt; numAdds;
 50     std::atomic&lt;unsigned&gt; numRemoves;
 51     std::atomic&lt;unsigned&gt; numRehashes;
 52     std::atomic&lt;unsigned&gt; numReinserts;
 53 };
 54 
 55 JS_EXPORT_PRIVATE extern PropertyMapHashTableStats* propertyMapHashTableStats;
 56 
 57 #endif
 58 
 59 inline bool isPowerOf2(unsigned v)
 60 {
 61     return hasOneBitSet(v);
 62 }
 63 
 64 inline unsigned nextPowerOf2(unsigned v)
 65 {
 66     // Taken from http://www.cs.utk.edu/~vose/c-stuff/bithacks.html
 67     // Devised by Sean Anderson, Sepember 14, 2001
 68 
 69     v--;
 70     v |= v &gt;&gt; 1;
 71     v |= v &gt;&gt; 2;
 72     v |= v &gt;&gt; 4;
 73     v |= v &gt;&gt; 8;
 74     v |= v &gt;&gt; 16;
 75     v++;
 76 
 77     return v;
 78 }
 79 
 80 class PropertyTable final : public JSCell {
 81 
 82     // This is the implementation for &#39;iterator&#39; and &#39;const_iterator&#39;,
 83     // used for iterating over the table in insertion order.
 84     template&lt;typename T&gt;
 85     class ordered_iterator {
 86     public:
 87         ordered_iterator&lt;T&gt;&amp; operator++()
 88         {
 89             m_valuePtr = skipDeletedEntries(m_valuePtr + 1, m_endValuePtr);
 90             return *this;
 91         }
 92 
 93         bool operator==(const ordered_iterator&lt;T&gt;&amp; other)
 94         {
 95             return m_valuePtr == other.m_valuePtr;
 96         }
 97 
 98         bool operator!=(const ordered_iterator&lt;T&gt;&amp; other)
 99         {
100             return m_valuePtr != other.m_valuePtr;
101         }
102 
103         T&amp; operator*()
104         {
105             return *m_valuePtr;
106         }
107 
108         T* operator-&gt;()
109         {
110             return m_valuePtr;
111         }
112 
113         ordered_iterator(T* valuePtr, T* endValuePtr)
114             : m_valuePtr(valuePtr)
115             , m_endValuePtr(endValuePtr)
116         {
117         }
118 
119     private:
120         T* m_valuePtr;
121         T* m_endValuePtr;
122     };
123 
124 public:
125     typedef JSCell Base;
<a name="3" id="anc3"></a><span class="line-modified">126     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
127 
128     template&lt;typename CellType, SubspaceAccess&gt;
129     static IsoSubspace* subspaceFor(VM&amp; vm)
130     {
131         return &amp;vm.propertyTableSpace;
132     }
133 
<a name="4" id="anc4"></a><span class="line-modified">134     static constexpr bool needsDestruction = true;</span>
135     static void destroy(JSCell*);
136 
137     DECLARE_EXPORT_INFO;
138 
139     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
140     {
141         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
142     }
143 
144     typedef UniquedStringImpl* KeyType;
145     typedef PropertyMapEntry ValueType;
146 
147     // The in order iterator provides overloaded * and -&gt; to access the Value at the current position.
148     typedef ordered_iterator&lt;ValueType&gt; iterator;
149     typedef ordered_iterator&lt;const ValueType&gt; const_iterator;
150 
151     // The find_iterator is a pair of a pointer to a Value* an the entry in the index.
152     // If &#39;find&#39; does not find an entry then iter.first will be 0, and iter.second will
153     // give the point in m_index where an entry should be inserted.
154     typedef std::pair&lt;ValueType*, unsigned&gt; find_iterator;
155 
156     // Constructor is passed an initial capacity, a PropertyTable to copy, or both.
157     static PropertyTable* create(VM&amp;, unsigned initialCapacity);
158     static PropertyTable* clone(VM&amp;, const PropertyTable&amp;);
159     static PropertyTable* clone(VM&amp;, unsigned initialCapacity, const PropertyTable&amp;);
160     ~PropertyTable();
161 
162     // Ordered iteration methods.
163     iterator begin();
164     iterator end();
165     const_iterator begin() const;
166     const_iterator end() const;
167 
168     // Find a value in the table.
169     find_iterator find(const KeyType&amp;);
170     ValueType* get(const KeyType&amp;);
171     // Add a value to the table
<a name="5" id="anc5"></a><span class="line-modified">172     std::pair&lt;find_iterator, bool&gt; WARN_UNUSED_RETURN add(const ValueType&amp; entry);</span>

173     // Remove a value from the table.
174     void remove(const find_iterator&amp; iter);
175     void remove(const KeyType&amp; key);
176 
177     // Returns the number of values in the hashtable.
178     unsigned size() const;
179 
180     // Checks if there are any values in the hashtable.
181     bool isEmpty() const;
182 
183     // Number of slots in the property storage array in use, included deletedOffsets.
184     unsigned propertyStorageSize() const;
185 
186     // Used to maintain a list of unused entries in the property storage.
187     void clearDeletedOffsets();
188     bool hasDeletedOffset();
189     PropertyOffset getDeletedOffset();
190     void addDeletedOffset(PropertyOffset);
191 
192     PropertyOffset nextOffset(PropertyOffset inlineCapacity);
193 
194     // Copy this PropertyTable, ensuring the copy has at least the capacity provided.
195     PropertyTable* copy(VM&amp;, unsigned newCapacity);
196 
197 #ifndef NDEBUG
198     size_t sizeInMemory();
199     void checkConsistency();
200 #endif
201 
202     static ptrdiff_t offsetOfIndexSize() { return OBJECT_OFFSETOF(PropertyTable, m_indexSize); }
203     static ptrdiff_t offsetOfIndexMask() { return OBJECT_OFFSETOF(PropertyTable, m_indexMask); }
204     static ptrdiff_t offsetOfIndex() { return OBJECT_OFFSETOF(PropertyTable, m_index); }
205 
<a name="6" id="anc6"></a><span class="line-modified">206     static constexpr unsigned EmptyEntryIndex = 0;</span>
207 
208 private:
209     PropertyTable(VM&amp;, unsigned initialCapacity);
210     PropertyTable(VM&amp;, const PropertyTable&amp;);
211     PropertyTable(VM&amp;, unsigned initialCapacity, const PropertyTable&amp;);
212 
213     PropertyTable(const PropertyTable&amp;);
214     // Used to insert a value known not to be in the table, and where we know capacity to be available.
215     void reinsert(const ValueType&amp; entry);
216 
217     // Rehash the table.  Used to grow, or to recover deleted slots.
218     void rehash(unsigned newCapacity);
219 
220     // The capacity of the table of values is half of the size of the index.
221     unsigned tableCapacity() const;
222 
223     // We keep an extra deleted slot after the array to make iteration work,
224     // and to use for deleted values. Index values into the array are 1-based,
225     // so this is tableCapacity() + 1.
226     // For example, if m_tableSize is 16, then tableCapacity() is 8 - but the
227     // values array is actually 9 long (the 9th used for the deleted value/
228     // iteration guard).  The 8 valid entries are numbered 1..8, so the
229     // deleted index is 9 (0 being reserved for empty).
230     unsigned deletedEntryIndex() const;
231 
232     // Used in iterator creation/progression.
233     template&lt;typename T&gt;
234     static T* skipDeletedEntries(T* valuePtr, T* endValuePtr);
235 
236     // The table of values lies after the hash index.
237     ValueType* table();
238     const ValueType* table() const;
239 
240     ValueType* tableEnd() { return table() + usedCount(); }
241     const ValueType* tableEnd() const { return table() + usedCount(); }
242 
243     // total number of  used entries in the values array - by either valid entries, or deleted ones.
244     unsigned usedCount() const;
245 
246     // The size in bytes of data needed for by the table.
247     size_t dataSize();
248 
249     // Calculates the appropriate table size (rounds up to a power of two).
250     static unsigned sizeForCapacity(unsigned capacity);
251 
252     // Check if capacity is available.
253     bool canInsert();
254 
255     unsigned m_indexSize;
256     unsigned m_indexMask;
257     unsigned* m_index;
258     unsigned m_keyCount;
259     unsigned m_deletedCount;
260     std::unique_ptr&lt;Vector&lt;PropertyOffset&gt;&gt; m_deletedOffsets;
261 
<a name="7" id="anc7"></a><span class="line-modified">262     static constexpr unsigned MinimumTableSize = 16;</span>
263 };
264 
265 inline PropertyTable::iterator PropertyTable::begin()
266 {
267     auto* tableEnd = this-&gt;tableEnd();
268     return iterator(skipDeletedEntries(table(), tableEnd), tableEnd);
269 }
270 
271 inline PropertyTable::iterator PropertyTable::end()
272 {
273     auto* tableEnd = this-&gt;tableEnd();
274     return iterator(tableEnd, tableEnd);
275 }
276 
277 inline PropertyTable::const_iterator PropertyTable::begin() const
278 {
279     auto* tableEnd = this-&gt;tableEnd();
280     return const_iterator(skipDeletedEntries(table(), tableEnd), tableEnd);
281 }
282 
283 inline PropertyTable::const_iterator PropertyTable::end() const
284 {
285     auto* tableEnd = this-&gt;tableEnd();
286     return const_iterator(tableEnd, tableEnd);
287 }
288 
289 inline PropertyTable::find_iterator PropertyTable::find(const KeyType&amp; key)
290 {
291     ASSERT(key);
292     ASSERT(key-&gt;isAtom() || key-&gt;isSymbol());
293     unsigned hash = IdentifierRepHash::hash(key);
294 
295 #if DUMP_PROPERTYMAP_STATS
296     ++propertyMapHashTableStats-&gt;numFinds;
297 #endif
298 
299     while (true) {
300         unsigned entryIndex = m_index[hash &amp; m_indexMask];
301         if (entryIndex == EmptyEntryIndex)
302             return std::make_pair((ValueType*)0, hash &amp; m_indexMask);
303         if (key == table()[entryIndex - 1].key)
304             return std::make_pair(&amp;table()[entryIndex - 1], hash &amp; m_indexMask);
305 
306 #if DUMP_PROPERTYMAP_STATS
307         ++propertyMapHashTableStats-&gt;numCollisions;
308 #endif
309 
310 #if DUMP_PROPERTYMAP_COLLISIONS
311         dataLog(&quot;PropertyTable collision for &quot;, key, &quot; (&quot;, hash, &quot;)\n&quot;);
312         dataLog(&quot;Collided with &quot;, table()[entryIndex - 1].key, &quot;(&quot;, IdentifierRepHash::hash(table()[entryIndex - 1].key), &quot;)\n&quot;);
313 #endif
314 
315         hash++;
316     }
317 }
318 
319 inline PropertyTable::ValueType* PropertyTable::get(const KeyType&amp; key)
320 {
321     ASSERT(key);
322     ASSERT(key-&gt;isAtom() || key-&gt;isSymbol());
<a name="8" id="anc8"></a><span class="line-added">323     ASSERT(key != PROPERTY_MAP_DELETED_ENTRY_KEY);</span>
324 
325     if (!m_keyCount)
326         return nullptr;
327 
328     unsigned hash = IdentifierRepHash::hash(key);
329 
330 #if DUMP_PROPERTYMAP_STATS
331     ++propertyMapHashTableStats-&gt;numLookups;
332 #endif
333 
334     while (true) {
335         unsigned entryIndex = m_index[hash &amp; m_indexMask];
336         if (entryIndex == EmptyEntryIndex)
337             return nullptr;
<a name="9" id="anc9"></a><span class="line-modified">338         if (key == table()[entryIndex - 1].key) {</span>
<span class="line-added">339             ASSERT(!m_deletedOffsets || !m_deletedOffsets-&gt;contains(table()[entryIndex - 1].offset));</span>
340             return &amp;table()[entryIndex - 1];
<a name="10" id="anc10"></a><span class="line-added">341         }</span>
342 
343 #if DUMP_PROPERTYMAP_STATS
344         ++propertyMapHashTableStats-&gt;numLookupProbing;
345 #endif
346 
347         hash++;
348     }
349 }
350 
<a name="11" id="anc11"></a><span class="line-modified">351 inline std::pair&lt;PropertyTable::find_iterator, bool&gt; WARN_UNUSED_RETURN PropertyTable::add(const ValueType&amp; entry)</span>
352 {
<a name="12" id="anc12"></a><span class="line-added">353     ASSERT(!m_deletedOffsets || !m_deletedOffsets-&gt;contains(entry.offset));</span>
<span class="line-added">354 </span>
355     // Look for a value with a matching key already in the array.
356     find_iterator iter = find(entry.key);
<a name="13" id="anc13"></a><span class="line-modified">357     if (iter.first)</span>

358         return std::make_pair(iter, false);
<a name="14" id="anc14"></a>
359 
360 #if DUMP_PROPERTYMAP_STATS
361     ++propertyMapHashTableStats-&gt;numAdds;
362 #endif
363 
364     // Ref the key
365     entry.key-&gt;ref();
366 
367     // ensure capacity is available.
368     if (!canInsert()) {
369         rehash(m_keyCount + 1);
370         iter = find(entry.key);
371         ASSERT(!iter.first);
372     }
373 
374     // Allocate a slot in the hashtable, and set the index to reference this.
375     unsigned entryIndex = usedCount() + 1;
376     m_index[iter.second] = entryIndex;
377     iter.first = &amp;table()[entryIndex - 1];
378     *iter.first = entry;
379 
380     ++m_keyCount;
381 
<a name="15" id="anc15"></a>




382     return std::make_pair(iter, true);
383 }
384 
385 inline void PropertyTable::remove(const find_iterator&amp; iter)
386 {
387     // Removing a key that doesn&#39;t exist does nothing!
388     if (!iter.first)
389         return;
390 
391 #if DUMP_PROPERTYMAP_STATS
392     ++propertyMapHashTableStats-&gt;numRemoves;
393 #endif
394 
395     // Replace this one element with the deleted sentinel. Also clear out
396     // the entry so we can iterate all the entries as needed.
397     m_index[iter.second] = deletedEntryIndex();
398     iter.first-&gt;key-&gt;deref();
399     iter.first-&gt;key = PROPERTY_MAP_DELETED_ENTRY_KEY;
400 
401     ASSERT(m_keyCount &gt;= 1);
402     --m_keyCount;
403     ++m_deletedCount;
404 
405     if (m_deletedCount * 4 &gt;= m_indexSize)
406         rehash(m_keyCount);
407 }
408 
409 inline void PropertyTable::remove(const KeyType&amp; key)
410 {
411     remove(find(key));
412 }
413 
414 // returns the number of values in the hashtable.
415 inline unsigned PropertyTable::size() const
416 {
417     return m_keyCount;
418 }
419 
420 inline bool PropertyTable::isEmpty() const
421 {
422     return !m_keyCount;
423 }
424 
425 inline unsigned PropertyTable::propertyStorageSize() const
426 {
427     return size() + (m_deletedOffsets ? m_deletedOffsets-&gt;size() : 0);
428 }
429 
430 inline void PropertyTable::clearDeletedOffsets()
431 {
432     m_deletedOffsets = nullptr;
433 }
434 
435 inline bool PropertyTable::hasDeletedOffset()
436 {
437     return m_deletedOffsets &amp;&amp; !m_deletedOffsets-&gt;isEmpty();
438 }
439 
440 inline PropertyOffset PropertyTable::getDeletedOffset()
441 {
442     PropertyOffset offset = m_deletedOffsets-&gt;last();
443     m_deletedOffsets-&gt;removeLast();
444     return offset;
445 }
446 
447 inline void PropertyTable::addDeletedOffset(PropertyOffset offset)
448 {
449     if (!m_deletedOffsets)
450         m_deletedOffsets = makeUnique&lt;Vector&lt;PropertyOffset&gt;&gt;();
<a name="16" id="anc16"></a><span class="line-added">451     ASSERT(!m_deletedOffsets-&gt;contains(offset));</span>
452     m_deletedOffsets-&gt;append(offset);
453 }
454 
455 inline PropertyOffset PropertyTable::nextOffset(PropertyOffset inlineCapacity)
456 {
457     if (hasDeletedOffset())
458         return getDeletedOffset();
459 
460     return offsetForPropertyNumber(size(), inlineCapacity);
461 }
462 
463 inline PropertyTable* PropertyTable::copy(VM&amp; vm, unsigned newCapacity)
464 {
465     ASSERT(newCapacity &gt;= m_keyCount);
466 
467     // Fast case; if the new table will be the same m_indexSize as this one, we can memcpy it,
468     // save rehashing all keys.
469     if (sizeForCapacity(newCapacity) == m_indexSize)
470         return PropertyTable::clone(vm, *this);
471     return PropertyTable::clone(vm, newCapacity, *this);
472 }
473 
474 #ifndef NDEBUG
475 inline size_t PropertyTable::sizeInMemory()
476 {
477     size_t result = sizeof(PropertyTable) + dataSize();
478     if (m_deletedOffsets)
479         result += (m_deletedOffsets-&gt;capacity() * sizeof(PropertyOffset));
480     return result;
481 }
482 #endif
483 
484 inline void PropertyTable::reinsert(const ValueType&amp; entry)
485 {
486 #if DUMP_PROPERTYMAP_STATS
487     ++propertyMapHashTableStats-&gt;numReinserts;
488 #endif
489 
490     // Used to insert a value known not to be in the table, and where
491     // we know capacity to be available.
492     ASSERT(canInsert());
493     find_iterator iter = find(entry.key);
494     ASSERT(!iter.first);
495 
496     unsigned entryIndex = usedCount() + 1;
497     m_index[iter.second] = entryIndex;
498     table()[entryIndex - 1] = entry;
499 
500     ++m_keyCount;
501 }
502 
503 inline void PropertyTable::rehash(unsigned newCapacity)
504 {
505 #if DUMP_PROPERTYMAP_STATS
506     ++propertyMapHashTableStats-&gt;numRehashes;
507 #endif
508 
509     unsigned* oldEntryIndices = m_index;
510     iterator iter = this-&gt;begin();
511     iterator end = this-&gt;end();
512 
513     m_indexSize = sizeForCapacity(newCapacity);
514     m_indexMask = m_indexSize - 1;
515     m_keyCount = 0;
516     m_deletedCount = 0;
<a name="17" id="anc17"></a><span class="line-modified">517 </span>
<span class="line-added">518     m_index = static_cast&lt;unsigned*&gt;(PropertyTableMalloc::zeroedMalloc(dataSize()));</span>
519 
520     for (; iter != end; ++iter) {
521         ASSERT(canInsert());
522         reinsert(*iter);
523     }
524 
<a name="18" id="anc18"></a><span class="line-modified">525     PropertyTableMalloc::free(oldEntryIndices);</span>
526 }
527 
528 inline unsigned PropertyTable::tableCapacity() const { return m_indexSize &gt;&gt; 1; }
529 
530 inline unsigned PropertyTable::deletedEntryIndex() const { return tableCapacity() + 1; }
531 
532 template&lt;typename T&gt;
533 inline T* PropertyTable::skipDeletedEntries(T* valuePtr, T* endValuePtr)
534 {
535     while (valuePtr &lt; endValuePtr &amp;&amp; valuePtr-&gt;key == PROPERTY_MAP_DELETED_ENTRY_KEY)
536         ++valuePtr;
537     return valuePtr;
538 }
539 
540 inline PropertyTable::ValueType* PropertyTable::table()
541 {
542     // The table of values lies after the hash index.
543     return reinterpret_cast&lt;ValueType*&gt;(m_index + m_indexSize);
544 }
545 
546 inline const PropertyTable::ValueType* PropertyTable::table() const
547 {
548     // The table of values lies after the hash index.
549     return reinterpret_cast&lt;const ValueType*&gt;(m_index + m_indexSize);
550 }
551 
552 inline unsigned PropertyTable::usedCount() const
553 {
554     // Total number of  used entries in the values array - by either valid entries, or deleted ones.
555     return m_keyCount + m_deletedCount;
556 }
557 
558 inline size_t PropertyTable::dataSize()
559 {
560     // The size in bytes of data needed for by the table.
561     return m_indexSize * sizeof(unsigned) + ((tableCapacity()) + 1) * sizeof(ValueType);
562 }
563 
564 inline unsigned PropertyTable::sizeForCapacity(unsigned capacity)
565 {
566     if (capacity &lt; MinimumTableSize / 2)
567         return MinimumTableSize;
568     return nextPowerOf2(capacity + 1) * 2;
569 }
570 
571 inline bool PropertyTable::canInsert()
572 {
573     return usedCount() &lt; tableCapacity();
574 }
575 
576 } // namespace JSC
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
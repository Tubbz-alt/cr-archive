<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2003, 2009, 2012, 2015 Apple Inc. All rights reserved.
   3  *
   4  * Portions are Copyright (C) 1998 Netscape Communications Corporation.
   5  *
   6  * Other contributors:
   7  *   Robert O&#39;Callahan &lt;roc+@cs.cmu.edu&gt;
   8  *   David Baron &lt;dbaron@fas.harvard.edu&gt;
   9  *   Christian Biesinger &lt;cbiesinger@web.de&gt;
  10  *   Randall Jesup &lt;rjesup@wgate.com&gt;
  11  *   Roland Mainz &lt;roland.mainz@informatik.med.uni-giessen.de&gt;
  12  *   Josh Soref &lt;timeless@mac.com&gt;
  13  *   Boris Zbarsky &lt;bzbarsky@mit.edu&gt;
  14  *
  15  * This library is free software; you can redistribute it and/or
  16  * modify it under the terms of the GNU Lesser General Public
  17  * License as published by the Free Software Foundation; either
  18  * version 2.1 of the License, or (at your option) any later version.
  19  *
  20  * This library is distributed in the hope that it will be useful,
  21  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  22  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23  * Lesser General Public License for more details.
  24  *
  25  * You should have received a copy of the GNU Lesser General Public
  26  * License along with this library; if not, write to the Free Software
  27  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  28  *
  29  * Alternatively, the contents of this file may be used under the terms
  30  * of either the Mozilla Public License Version 1.1, found at
  31  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  32  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  33  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  34  * applicable instead of those above.  If you wish to allow use of your
  35  * version of this file only under the terms of one of those two
  36  * licenses (the MPL or the GPL) and not to allow others to use your
  37  * version of this file under the LGPL, indicate your decision by
  38  * deletingthe provisions above and replace them with the notice and
  39  * other provisions required by the MPL or the GPL, as the case may be.
  40  * If you do not delete the provisions above, a recipient may use your
  41  * version of this file under any of the LGPL, the MPL or the GPL.
  42  */
  43 
  44 #pragma once
  45 
  46 #include &quot;ClipRect.h&quot;
  47 #include &quot;GraphicsLayer.h&quot;
  48 #include &quot;LayerFragment.h&quot;
  49 #include &quot;PaintFrequencyTracker.h&quot;
  50 #include &quot;PaintInfo.h&quot;
  51 #include &quot;RenderBox.h&quot;
  52 #include &quot;RenderPtr.h&quot;
  53 #include &quot;ScrollableArea.h&quot;
  54 #include &lt;memory&gt;
  55 #include &lt;wtf/WeakPtr.h&gt;
  56 
  57 namespace WTF {
  58 class TextStream;
  59 }
  60 
  61 namespace WebCore {
  62 
  63 class CSSFilter;
  64 class ClipRects;
  65 class ClipRectsCache;
  66 class EventRegionContext;
  67 class HitTestRequest;
  68 class HitTestResult;
  69 class HitTestingTransformState;
  70 class Region;
  71 class RenderFragmentedFlow;
  72 class RenderGeometryMap;
  73 class RenderLayerBacking;
  74 class RenderLayerCompositor;
  75 class RenderLayerFilters;
  76 class RenderMarquee;
  77 class RenderReplica;
  78 class RenderScrollbarPart;
  79 class RenderStyle;
  80 class RenderView;
  81 class Scrollbar;
  82 class TransformationMatrix;
  83 
  84 enum BorderRadiusClippingRule { IncludeSelfForBorderRadius, DoNotIncludeSelfForBorderRadius };
  85 enum IncludeSelfOrNot { IncludeSelf, ExcludeSelf };
  86 
  87 enum RepaintStatus {
  88     NeedsNormalRepaint,
  89     NeedsFullRepaint,
  90     NeedsFullRepaintForPositionedMovementLayout
  91 };
  92 
  93 enum ClipRectsType {
  94     PaintingClipRects, // Relative to painting ancestor. Used for painting.
  95     RootRelativeClipRects, // Relative to the ancestor treated as the root (e.g. transformed layer). Used for hit testing.
  96     AbsoluteClipRects, // Relative to the RenderView&#39;s layer. Used for compositing overlap testing.
  97     NumCachedClipRectsTypes,
  98     AllClipRectTypes,
  99     TemporaryClipRects
 100 };
 101 
 102 enum ShouldRespectOverflowClip {
 103     IgnoreOverflowClip,
 104     RespectOverflowClip
 105 };
 106 
 107 enum ShouldApplyRootOffsetToFragments {
 108     ApplyRootOffsetToFragments,
 109     IgnoreRootOffsetForFragments
 110 };
 111 
 112 enum class RequestState {
 113     Unknown,
 114     DontCare,
 115     False,
 116     True,
 117     Undetermined
 118 };
 119 
 120 enum class IndirectCompositingReason {
 121     None,
<a name="1" id="anc1"></a><span class="line-added"> 122     Clipping,</span>
 123     Stacking,
 124     OverflowScrollPositioning,
 125     Overlap,
 126     BackgroundLayer,
 127     GraphicalEffect, // opacity, mask, filter, transform etc.
 128     Perspective,
 129     Preserve3D
 130 };
 131 
 132 struct ScrollRectToVisibleOptions {
 133     SelectionRevealMode revealMode { SelectionRevealMode::Reveal };
 134     const ScrollAlignment&amp; alignX { ScrollAlignment::alignCenterIfNeeded };
 135     const ScrollAlignment&amp; alignY { ScrollAlignment::alignCenterIfNeeded };
 136     ShouldAllowCrossOriginScrolling shouldAllowCrossOriginScrolling { ShouldAllowCrossOriginScrolling::No };
 137 };
 138 
<a name="2" id="anc2"></a><span class="line-added"> 139 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
 140 class RenderLayer final : public ScrollableArea {
<a name="3" id="anc3"></a><span class="line-modified"> 141     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(RenderLayer);</span>
 142 public:
 143     friend class RenderReplica;
 144     friend class RenderLayerFilters;
 145     friend class RenderLayerBacking;
 146     friend class RenderLayerCompositor;
 147 
 148     explicit RenderLayer(RenderLayerModelObject&amp;);
 149     virtual ~RenderLayer();
 150 
 151 #if PLATFORM(IOS_FAMILY)
 152     // Called before the renderer&#39;s widget (if any) has been nulled out.
 153     void willBeDestroyed();
 154 #endif
 155     String name() const;
 156 
 157     Page&amp; page() const { return renderer().page(); }
 158     RenderLayerModelObject&amp; renderer() const { return m_renderer; }
 159     RenderBox* renderBox() const { return is&lt;RenderBox&gt;(renderer()) ? &amp;downcast&lt;RenderBox&gt;(renderer()) : nullptr; }
 160 
 161     RenderLayer* parent() const { return m_parent; }
 162     RenderLayer* previousSibling() const { return m_previous; }
 163     RenderLayer* nextSibling() const { return m_next; }
 164     RenderLayer* firstChild() const { return m_first; }
 165     RenderLayer* lastChild() const { return m_last; }
 166     bool isDescendantOf(const RenderLayer&amp;) const;
<a name="4" id="anc4"></a><span class="line-added"> 167     RenderLayer* commonAncestorWithLayer(const RenderLayer&amp;) const;</span>
 168 
 169     // This does an ancestor tree walk. Avoid it!
 170     const RenderLayer* root() const
 171     {
 172         const RenderLayer* curr = this;
 173         while (curr-&gt;parent())
 174             curr = curr-&gt;parent();
 175         return curr;
 176     }
 177 
 178     void addChild(RenderLayer&amp; newChild, RenderLayer* beforeChild = nullptr);
 179     void removeChild(RenderLayer&amp;);
 180 
<a name="5" id="anc5"></a><span class="line-modified"> 181     enum class LayerChangeTiming {</span>
<span class="line-modified"> 182         StyleChange,</span>
<span class="line-added"> 183         RenderTreeConstruction,</span>
<span class="line-added"> 184     };</span>
<span class="line-added"> 185     void insertOnlyThisLayer(LayerChangeTiming);</span>
<span class="line-added"> 186     void removeOnlyThisLayer(LayerChangeTiming);</span>
 187 
 188     bool isNormalFlowOnly() const { return m_isNormalFlowOnly; }
 189 
 190     // isStackingContext is true for layers that we&#39;ve determined should be stacking contexts for painting.
 191     // Not all stacking contexts are CSS stacking contexts.
 192     bool isStackingContext() const { return isCSSStackingContext() || m_isOpportunisticStackingContext; }
 193 
 194     // isCSSStackingContext is true for layers that are stacking contexts from a CSS perspective.
 195     // isCSSStackingContext() =&gt; isStackingContext().
 196     // FIXME: m_forcedStackingContext should affect isStackingContext(), not isCSSStackingContext(), but doing so breaks media control mix-blend-mode.
 197     bool isCSSStackingContext() const { return m_isCSSStackingContext || m_forcedStackingContext; }
 198 
 199     // Gets the enclosing stacking context for this layer, excluding this layer itself.
 200     RenderLayer* stackingContext() const;
 201 
 202     // Gets the enclosing stacking container for this layer, possibly the layer
 203     // itself, if it is a stacking container.
 204     RenderLayer* enclosingStackingContext() { return isStackingContext() ? this : stackingContext(); }
 205 
 206     RenderLayer* paintOrderParent() const;
 207 
 208     void dirtyNormalFlowList();
 209     void dirtyZOrderLists();
 210     void dirtyStackingContextZOrderLists();
 211 
 212     bool normalFlowListDirty() const { return m_normalFlowListDirty; }
 213     bool zOrderListsDirty() const { return m_zOrderListsDirty; }
 214 
<a name="6" id="anc6"></a><span class="line-modified"> 215 #if ASSERT_ENABLED</span>
 216     bool layerListMutationAllowed() const { return m_layerListMutationAllowed; }
 217     void setLayerListMutationAllowed(bool flag) { m_layerListMutationAllowed = flag; }
 218 #endif
 219 
 220 private:
 221     // These flags propagate in paint order (z-order tree).
 222     enum class Compositing {
 223         HasDescendantNeedingRequirementsTraversal           = 1 &lt;&lt; 0, // Need to do the overlap-testing tree walk because hierarchy or geometry changed.
 224         HasDescendantNeedingBackingOrHierarchyTraversal     = 1 &lt;&lt; 1, // Need to update geometry, configuration and update the GraphicsLayer tree.
 225 
 226         // Things that trigger HasDescendantNeedingRequirementsTraversal
 227         NeedsPaintOrderChildrenUpdate                       = 1 &lt;&lt; 2, // The paint order children of this layer changed (gained/lost child, order change).
 228         NeedsPostLayoutUpdate                               = 1 &lt;&lt; 3, // Needs compositing to be re-evaluated after layout (it depends on geometry).
 229         DescendantsNeedRequirementsTraversal                = 1 &lt;&lt; 4, // Something changed that forces computeCompositingRequirements to traverse all descendant layers.
 230         SubsequentLayersNeedRequirementsTraversal           = 1 &lt;&lt; 5, // Something changed that forces computeCompositingRequirements to traverse all layers later in paint order.
 231 
 232         // Things that trigger HasDescendantNeedingBackingOrHierarchyTraversal
 233         NeedsGeometryUpdate                                 = 1 &lt;&lt; 6, // This layer needs a geometry update.
 234         NeedsConfigurationUpdate                            = 1 &lt;&lt; 7, // This layer needs a configuration update (updating its internal compositing hierarchy).
 235         NeedsScrollingTreeUpdate                            = 1 &lt;&lt; 8, // Something changed that requires this layer&#39;s scrolling tree node to be updated.
 236         NeedsLayerConnection                                = 1 &lt;&lt; 9, // This layer needs hookup with its parents or children.
 237         ChildrenNeedGeometryUpdate                          = 1 &lt;&lt; 10, // This layer&#39;s composited children need a geometry update.
 238         DescendantsNeedBackingAndHierarchyTraversal         = 1 &lt;&lt; 11, // Something changed that forces us to traverse all descendant layers in updateBackingAndHierarchy.
 239     };
 240 
 241     static constexpr OptionSet&lt;Compositing&gt; computeCompositingRequirementsFlags()
 242     {
 243         return {
 244             Compositing::NeedsPaintOrderChildrenUpdate,
 245             Compositing::NeedsPostLayoutUpdate,
 246             Compositing::DescendantsNeedRequirementsTraversal,
 247             Compositing::SubsequentLayersNeedRequirementsTraversal,
 248         };
 249     }
 250 
 251     static constexpr OptionSet&lt;Compositing&gt; updateBackingOrHierarchyFlags()
 252     {
 253         return {
 254             Compositing::NeedsLayerConnection,
 255             Compositing::NeedsGeometryUpdate,
 256             Compositing::NeedsConfigurationUpdate,
 257             Compositing::NeedsScrollingTreeUpdate,
 258             Compositing::ChildrenNeedGeometryUpdate,
 259             Compositing::DescendantsNeedBackingAndHierarchyTraversal,
 260         };
 261     }
 262 
 263     void setAncestorsHaveCompositingDirtyFlag(Compositing);
 264 
 265 public:
 266     bool hasDescendantNeedingCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingRequirementsTraversal); }
 267     bool hasDescendantNeedingUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal); }
 268 
 269     bool needsCompositingPaintOrderChildrenUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPaintOrderChildrenUpdate); }
 270     bool needsPostLayoutCompositingUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsPostLayoutUpdate); }
 271     bool descendantsNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedRequirementsTraversal); }
 272     bool subsequentLayersNeedCompositingRequirementsTraversal() const { return m_compositingDirtyBits.contains(Compositing::SubsequentLayersNeedRequirementsTraversal); }
 273 
 274     bool needsCompositingLayerConnection() const { return m_compositingDirtyBits.contains(Compositing::NeedsLayerConnection); }
 275     bool needsCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsGeometryUpdate); }
 276     bool needsCompositingConfigurationUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsConfigurationUpdate); }
 277     bool needsScrollingTreeUpdate() const { return m_compositingDirtyBits.contains(Compositing::NeedsScrollingTreeUpdate); }
 278     bool childrenNeedCompositingGeometryUpdate() const { return m_compositingDirtyBits.contains(Compositing::ChildrenNeedGeometryUpdate); }
 279     bool descendantsNeedUpdateBackingAndHierarchyTraversal() const { return m_compositingDirtyBits.contains(Compositing::DescendantsNeedBackingAndHierarchyTraversal); }
 280 
 281     template&lt;Compositing V&gt;
 282     void setRequirementsTraversalDirtyBit()
 283     {
 284         m_compositingDirtyBits.add(V);
 285         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingRequirementsTraversal);
 286     }
 287 
 288     void setNeedsCompositingPaintOrderChildrenUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPaintOrderChildrenUpdate&gt;(); }
 289     void setNeedsPostLayoutCompositingUpdate() { setRequirementsTraversalDirtyBit&lt;Compositing::NeedsPostLayoutUpdate&gt;(); }
 290     void setDescendantsNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::DescendantsNeedRequirementsTraversal&gt;(); }
 291     void setSubsequentLayersNeedCompositingRequirementsTraversal() { setRequirementsTraversalDirtyBit&lt;Compositing::SubsequentLayersNeedRequirementsTraversal&gt;(); }
 292 
 293     void setNeedsPostLayoutCompositingUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsPostLayoutUpdate); }
 294 
 295     template&lt;Compositing V&gt;
 296     void setBackingAndHierarchyTraversalDirtyBit()
 297     {
 298         m_compositingDirtyBits.add(V);
 299         setAncestorsHaveCompositingDirtyFlag(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 300     }
 301 
 302     void setNeedsCompositingLayerConnection() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsLayerConnection&gt;(); }
 303     void setNeedsCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsGeometryUpdate&gt;(); }
 304     void setNeedsCompositingConfigurationUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsConfigurationUpdate&gt;(); }
 305     void setNeedsScrollingTreeUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::NeedsScrollingTreeUpdate&gt;(); }
 306     void setChildrenNeedCompositingGeometryUpdate() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::ChildrenNeedGeometryUpdate&gt;(); }
 307     void setDescendantsNeedUpdateBackingAndHierarchyTraversal() { setBackingAndHierarchyTraversalDirtyBit&lt;Compositing::DescendantsNeedBackingAndHierarchyTraversal&gt;(); }
 308 
 309     void setNeedsCompositingGeometryUpdateOnAncestors() { setAncestorsHaveCompositingDirtyFlag(Compositing::NeedsGeometryUpdate); }
 310 
 311     bool needsCompositingRequirementsTraversal() const { return m_compositingDirtyBits.containsAny(computeCompositingRequirementsFlags()); }
 312     void clearCompositingRequirementsTraversalState()
 313     {
 314         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingRequirementsTraversal);
 315         m_compositingDirtyBits.remove(computeCompositingRequirementsFlags());
 316     }
 317 
 318     bool needsUpdateBackingOrHierarchyTraversal() const { return m_compositingDirtyBits.containsAny(updateBackingOrHierarchyFlags()); }
 319     void clearUpdateBackingOrHierarchyTraversalState()
 320     {
 321         m_compositingDirtyBits.remove(Compositing::HasDescendantNeedingBackingOrHierarchyTraversal);
 322         m_compositingDirtyBits.remove(updateBackingOrHierarchyFlags());
 323     }
 324 
 325     bool needsAnyCompositingTraversal() const { return !m_compositingDirtyBits.isEmpty(); }
 326     void clearCompositingPaintOrderState() { m_compositingDirtyBits = { }; }
 327 
 328     class LayerList {
 329         friend class RenderLayer;
 330     public:
 331         using iterator = RenderLayer**;
 332         using const_iterator = RenderLayer * const *;
 333         using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;
 334         using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;
 335 
 336         iterator begin() { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 337         iterator end() { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 338 
 339         reverse_iterator rbegin() { return reverse_iterator(end()); }
 340         reverse_iterator rend() { return reverse_iterator(begin()); }
 341 
 342         const_iterator begin() const { return m_layerList ? m_layerList-&gt;begin() : nullptr; }
 343         const_iterator end() const { return m_layerList ? m_layerList-&gt;end() : nullptr; }
 344 
 345         const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 346         const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
 347 
 348         size_t size() const { return m_layerList ? m_layerList-&gt;size() : 0; }
 349 
 350     private:
 351         LayerList(Vector&lt;RenderLayer*&gt;* layerList)
 352             : m_layerList(layerList)
 353         {
 354         }
 355 
 356         Vector&lt;RenderLayer*&gt;* m_layerList;
 357     };
 358 
 359     LayerList normalFlowLayers() const
 360     {
 361         ASSERT(!m_normalFlowListDirty);
 362         return LayerList(m_normalFlowList.get());
 363     }
 364 
 365     LayerList positiveZOrderLayers() const
 366     {
 367         ASSERT(!m_zOrderListsDirty);
 368         ASSERT(isStackingContext() || !m_posZOrderList);
 369         return LayerList(m_posZOrderList.get());
 370     }
 371 
 372     bool hasNegativeZOrderLayers() const
 373     {
 374         return m_negZOrderList &amp;&amp; m_negZOrderList-&gt;size();
 375     }
 376 
 377     LayerList negativeZOrderLayers() const
 378     {
 379         ASSERT(!m_zOrderListsDirty);
 380         ASSERT(isStackingContext() || !m_negZOrderList);
 381         return LayerList(m_negZOrderList.get());
 382     }
 383 
 384     // Update our normal and z-index lists.
 385     void updateLayerListsIfNeeded();
 386     void updateDescendantDependentFlags();
 387     bool descendantDependentFlagsAreDirty() const
 388     {
 389         return m_visibleDescendantStatusDirty || m_visibleContentStatusDirty || m_hasSelfPaintingLayerDescendantDirty
 390 #if ENABLE(CSS_COMPOSITING)
 391             || m_hasNotIsolatedBlendingDescendantsStatusDirty
 392 #endif
 393         ;
 394     }
 395 
 396     void repaintIncludingDescendants();
 397 
 398     // Indicate that the layer contents need to be repainted. Only has an effect
 399     // if layer compositing is being used.
 400     void setBackingNeedsRepaint(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 401 
 402     // The rect is in the coordinate space of the layer&#39;s render object.
 403     void setBackingNeedsRepaintInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
 404     void repaintIncludingNonCompositingDescendants(RenderLayerModelObject* repaintContainer);
 405 
 406     void styleChanged(StyleDifference, const RenderStyle* oldStyle);
 407 
 408     RenderMarquee* marquee() const { return m_marquee.get(); }
 409 
 410     bool isSelfPaintingLayer() const { return m_isSelfPaintingLayer; }
 411 
 412     bool cannotBlitToWindow() const;
 413 
 414     bool isTransparent() const { return renderer().isTransparent() || renderer().hasMask(); }
 415 
 416     bool hasReflection() const { return renderer().hasReflection(); }
 417     bool isReflection() const { return renderer().isReplica(); }
 418     RenderReplica* reflection() const { return m_reflection.get(); }
 419     RenderLayer* reflectionLayer() const;
 420     bool isReflectionLayer(const RenderLayer&amp;) const;
 421 
 422     const LayoutPoint&amp; location() const { return m_topLeft; }
 423     void setLocation(const LayoutPoint&amp; p) { m_topLeft = p; }
 424 
 425     const IntSize&amp; size() const { return m_layerSize; }
 426     void setSize(const IntSize&amp; size) { m_layerSize = size; } // Only public for RenderTreeAsText.
 427 
 428     LayoutRect rect() const { return LayoutRect(location(), size()); }
 429 
 430     IntSize visibleSize() const override;
 431     IntSize contentsSize() const override;
 432     IntSize reachableTotalContentsSize() const override;
 433 
 434     int scrollWidth() const;
 435     int scrollHeight() const;
 436 
 437     void panScrollFromPoint(const IntPoint&amp;);
 438 
 439     // Scrolling methods for layers that can scroll their overflow.
 440     void scrollByRecursively(const IntSize&amp; delta, ScrollableArea** scrolledArea = nullptr);
 441 
<a name="7" id="anc7"></a><span class="line-added"> 442     bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) override;</span>
<span class="line-added"> 443 </span>
 444     WEBCORE_EXPORT void scrollToOffset(const ScrollOffset&amp;, ScrollType = ScrollType::Programmatic, ScrollClamping = ScrollClamping::Clamped);
 445 
 446     void scrollToXPosition(int x, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 447     void scrollToYPosition(int y, ScrollType, ScrollClamping = ScrollClamping::Clamped);
 448 
 449     // These are only used by marquee.
 450     void scrollToXOffset(int x) { scrollToOffset(ScrollOffset(x, scrollOffset().y()), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 451     void scrollToYOffset(int y) { scrollToOffset(ScrollOffset(scrollOffset().x(), y), ScrollType::Programmatic, ScrollClamping::Unclamped); }
 452 
 453     void setPostLayoutScrollPosition(Optional&lt;ScrollPosition&gt;);
 454     void applyPostLayoutScrollPositionIfNeeded();
 455 
 456     void availableContentSizeChanged(AvailableSizeChangeReason) override;
 457 
 458     // &quot;absoluteRect&quot; is in scaled document coordinates.
 459     void scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 460 
 461     bool scrollsOverflow() const;
 462     bool hasScrollableHorizontalOverflow() const;
 463     bool hasScrollableVerticalOverflow() const;
 464     bool hasScrollbars() const { return m_hBar || m_vBar; }
 465     void setHasHorizontalScrollbar(bool);
 466     void setHasVerticalScrollbar(bool);
 467 
 468     Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
 469     void destroyScrollbar(ScrollbarOrientation);
 470 
 471     bool hasHorizontalScrollbar() const { return horizontalScrollbar(); }
 472     bool hasVerticalScrollbar() const { return verticalScrollbar(); }
 473 
 474     bool horizontalScrollbarHiddenByStyle() const override;
 475     bool verticalScrollbarHiddenByStyle() const override;
 476 
 477     // ScrollableArea overrides
 478     ScrollPosition scrollPosition() const override { return m_scrollPosition; }
 479 
 480     Scrollbar* horizontalScrollbar() const override { return m_hBar.get(); }
 481     Scrollbar* verticalScrollbar() const override { return m_vBar.get(); }
 482     ScrollableArea* enclosingScrollableArea() const override;
 483 
 484     bool isScrollableOrRubberbandable() override;
 485     bool hasScrollableOrRubberbandableAncestor() override;
 486     bool useDarkAppearance() const final;
 487 #if ENABLE(CSS_SCROLL_SNAP)
 488     void updateSnapOffsets() override;
 489 #endif
 490 
 491     bool requiresScrollPositionReconciliation() const { return m_requiresScrollPositionReconciliation; }
 492     void setRequiresScrollPositionReconciliation(bool requiresReconciliation = true) { m_requiresScrollPositionReconciliation = requiresReconciliation; }
 493 
 494 #if PLATFORM(IOS_FAMILY)
 495 #if ENABLE(IOS_TOUCH_EVENTS)
 496     bool handleTouchEvent(const PlatformTouchEvent&amp;) override;
 497 #endif
 498 
 499     void didStartScroll() override;
 500     void didEndScroll() override;
 501     void didUpdateScroll() override;
 502 #endif
 503 
 504     // Returns true when the layer could do touch scrolling, but doesn&#39;t look at whether there is actually scrollable overflow.
 505     bool canUseCompositedScrolling() const;
 506     // Returns true when there is actually scrollable overflow (requires layout to be up-to-date).
 507     bool hasCompositedScrollableOverflow() const { return m_hasCompositedScrollableOverflow; }
 508 
 509     int verticalScrollbarWidth(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 510     int horizontalScrollbarHeight(OverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize) const;
 511 
 512     bool hasOverflowControls() const;
 513     bool isPointInResizeControl(const IntPoint&amp; absolutePoint) const;
 514     bool hitTestOverflowControls(HitTestResult&amp;, const IntPoint&amp; localPoint);
 515     IntSize offsetFromResizeCorner(const IntPoint&amp; absolutePoint) const;
 516 
 517     void paintOverflowControls(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect, bool paintingOverlayControls = false);
 518     void paintScrollCorner(GraphicsContext&amp;, const IntPoint&amp;, const IntRect&amp; damageRect);
 519     void paintResizer(GraphicsContext&amp;, const LayoutPoint&amp;, const LayoutRect&amp; damageRect);
 520 
 521     void updateScrollInfoAfterLayout();
 522 
 523     bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 524     void autoscroll(const IntPoint&amp;);
 525 
 526     bool canResize() const;
 527     void resize(const PlatformMouseEvent&amp;, const LayoutSize&amp;);
 528     bool inResizeMode() const { return m_inResizeMode; }
 529     void setInResizeMode(bool b) { m_inResizeMode = b; }
 530 
 531     bool isRenderViewLayer() const { return m_isRenderViewLayer; }
 532     bool isForcedStackingContext() const { return m_forcedStackingContext; }
 533     bool isOpportunisticStackingContext() const { return m_isOpportunisticStackingContext; }
 534 
 535     RenderLayerCompositor&amp; compositor() const;
 536 
 537     // Notification from the renderer that its content changed (e.g. current frame of image changed).
 538     // Allows updates of layer content without repainting.
 539     void contentChanged(ContentChangeType);
 540 
 541     bool canRender3DTransforms() const;
 542 
 543     void updateLayerPositionsAfterStyleChange();
 544     void updateLayerPositionsAfterLayout(bool isRelayoutingSubtree, bool didFullRepaint);
 545 
 546     void updateLayerPositionsAfterOverflowScroll();
 547     void updateLayerPositionsAfterDocumentScroll();
 548 
 549     bool hasCompositedLayerInEnclosingPaginationChain() const;
 550     enum PaginationInclusionMode { ExcludeCompositedPaginatedLayers, IncludeCompositedPaginatedLayers };
 551     RenderLayer* enclosingPaginationLayer(PaginationInclusionMode mode) const
 552     {
 553         if (mode == ExcludeCompositedPaginatedLayers &amp;&amp; hasCompositedLayerInEnclosingPaginationChain())
 554             return nullptr;
 555         return m_enclosingPaginationLayer.get();
 556     }
 557 
 558     void updateTransform();
 559 
 560 #if ENABLE(CSS_COMPOSITING)
 561     void updateBlendMode();
 562     void willRemoveChildWithBlendMode();
 563 #endif
 564 
 565     const LayoutSize&amp; offsetForInFlowPosition() const { return m_offsetForInFlowPosition; }
 566 
 567     void clearClipRectsIncludingDescendants(ClipRectsType typeToClear = AllClipRectTypes);
 568     void clearClipRects(ClipRectsType typeToClear = AllClipRectTypes);
 569 
 570     void addBlockSelectionGapsBounds(const LayoutRect&amp;);
 571     void clearBlockSelectionGapsBounds();
 572     void repaintBlockSelectionGaps();
 573 
 574     // FIXME: We should ASSERT(!m_visibleContentStatusDirty) here, but see https://bugs.webkit.org/show_bug.cgi?id=71044
 575     // ditto for hasVisibleDescendant(), see https://bugs.webkit.org/show_bug.cgi?id=71277
 576     bool hasVisibleContent() const { return m_hasVisibleContent; }
 577     bool hasVisibleDescendant() const { return m_hasVisibleDescendant; }
 578 
 579     void setHasVisibleContent();
 580     void dirtyVisibleContentStatus();
 581 
 582     bool hasVisibleBoxDecorationsOrBackground() const;
 583     bool hasVisibleBoxDecorations() const;
 584 
 585     bool behavesAsFixed() const { return m_behavesAsFixed; }
 586 
 587     struct PaintedContentRequest {
 588         void makeStatesUndetermined()
 589         {
 590             if (hasPaintedContent == RequestState::Unknown)
 591                 hasPaintedContent = RequestState::Undetermined;
 592 
 593             if (hasSubpixelAntialiasedText == RequestState::Unknown)
 594                 hasSubpixelAntialiasedText = RequestState::Undetermined;
 595         }
 596 
 597         void setHasPaintedContent() { hasPaintedContent = RequestState::True; }
 598         void setHasSubpixelAntialiasedText() { hasSubpixelAntialiasedText = RequestState::True; }
 599 
 600         bool needToDeterminePaintedContentState() const { return hasPaintedContent == RequestState::Unknown; }
 601         bool needToDetermineSubpixelAntialiasedTextState() const { return hasSubpixelAntialiasedText == RequestState::Unknown; }
 602 
 603         bool probablyHasPaintedContent() const { return hasPaintedContent == RequestState::True || hasPaintedContent == RequestState::Undetermined; }
 604         bool probablyHasSubpixelAntialiasedText() const { return hasSubpixelAntialiasedText == RequestState::True || hasSubpixelAntialiasedText == RequestState::Undetermined; }
 605 
 606         bool isSatisfied() const { return hasPaintedContent != RequestState::Unknown &amp;&amp; hasSubpixelAntialiasedText != RequestState::Unknown; }
 607 
 608         RequestState hasPaintedContent { RequestState::Unknown };
 609         RequestState hasSubpixelAntialiasedText { RequestState::DontCare };
 610     };
 611 
 612     // Returns true if this layer has visible content (ignoring any child layers).
 613     bool isVisuallyNonEmpty(PaintedContentRequest* = nullptr) const;
 614     // True if this layer container renderers that paint.
 615     bool hasNonEmptyChildRenderers(PaintedContentRequest&amp;) const;
 616 
 617     // FIXME: We should ASSERT(!m_hasSelfPaintingLayerDescendantDirty); here but we hit the same bugs as visible content above.
 618     // Part of the issue is with subtree relayout: we don&#39;t check if our ancestors have some descendant flags dirty, missing some updates.
 619     bool hasSelfPaintingLayerDescendant() const { return m_hasSelfPaintingLayerDescendant; }
 620 
 621     bool ancestorLayerIsInContainingBlockChain(const RenderLayer&amp; ancestor, const RenderLayer* checkLimit = nullptr) const;
 622 
 623     // Gets the nearest enclosing positioned ancestor layer (also includes
 624     // the &lt;html&gt; layer and the root layer).
 625     RenderLayer* enclosingAncestorForPosition(PositionType) const;
 626 
 627     // Returns the nearest enclosing layer that is scrollable.
 628     RenderLayer* enclosingScrollableLayer() const;
 629 
 630     // The layer relative to which clipping rects for this layer are computed.
 631     RenderLayer* clippingRootForPainting() const;
 632 
 633     RenderLayer* enclosingOverflowClipLayer(IncludeSelfOrNot) const;
 634 
 635     // Enclosing compositing layer; if includeSelf is true, may return this.
 636     RenderLayer* enclosingCompositingLayer(IncludeSelfOrNot = IncludeSelf) const;
 637     RenderLayer* enclosingCompositingLayerForRepaint(IncludeSelfOrNot = IncludeSelf) const;
 638     // Ancestor compositing layer, excluding this.
 639     RenderLayer* ancestorCompositingLayer() const { return enclosingCompositingLayer(ExcludeSelf); }
 640 
 641     RenderLayer* enclosingFilterLayer(IncludeSelfOrNot = IncludeSelf) const;
 642     RenderLayer* enclosingFilterRepaintLayer() const;
 643     void setFilterBackendNeedsRepaintingInRect(const LayoutRect&amp;);
 644     bool hasAncestorWithFilterOutsets() const;
 645 
 646     bool canUseOffsetFromAncestor() const
 647     {
 648         // FIXME: This really needs to know if there are transforms on this layer and any of the layers
 649         // between it and the ancestor in question.
 650         return !renderer().hasTransform() &amp;&amp; !renderer().isSVGRoot();
 651     }
 652 
 653     // FIXME: adjustForColumns allows us to position compositing layers in columns correctly, but eventually they need to be split across columns too.
 654     enum ColumnOffsetAdjustment { DontAdjustForColumns, AdjustForColumns };
 655     void convertToPixelSnappedLayerCoords(const RenderLayer* ancestorLayer, IntPoint&amp; location, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 656     LayoutPoint convertToLayerCoords(const RenderLayer* ancestorLayer, const LayoutPoint&amp;, ColumnOffsetAdjustment adjustForColumns = DontAdjustForColumns) const;
 657     LayoutSize offsetFromAncestor(const RenderLayer*, ColumnOffsetAdjustment = DontAdjustForColumns) const;
 658 
<a name="8" id="anc8"></a><span class="line-modified"> 659     int zIndex() const { return renderer().style().usedZIndex(); }</span>
 660 
 661     enum PaintLayerFlag {
 662         PaintLayerHaveTransparency                      = 1 &lt;&lt; 0,
 663         PaintLayerAppliedTransform                      = 1 &lt;&lt; 1,
 664         PaintLayerTemporaryClipRects                    = 1 &lt;&lt; 2,
 665         PaintLayerPaintingReflection                    = 1 &lt;&lt; 3,
 666         PaintLayerPaintingOverlayScrollbars             = 1 &lt;&lt; 4,
 667         PaintLayerPaintingCompositingBackgroundPhase    = 1 &lt;&lt; 5,
 668         PaintLayerPaintingCompositingForegroundPhase    = 1 &lt;&lt; 6,
 669         PaintLayerPaintingCompositingMaskPhase          = 1 &lt;&lt; 7,
 670         PaintLayerPaintingCompositingClipPathPhase      = 1 &lt;&lt; 8,
 671         PaintLayerPaintingCompositingScrollingPhase     = 1 &lt;&lt; 9,
 672         PaintLayerPaintingOverflowContents              = 1 &lt;&lt; 10,
 673         PaintLayerPaintingRootBackgroundOnly            = 1 &lt;&lt; 11,
 674         PaintLayerPaintingSkipRootBackground            = 1 &lt;&lt; 12,
 675         PaintLayerPaintingChildClippingMaskPhase        = 1 &lt;&lt; 13,
 676         PaintLayerCollectingEventRegion                 = 1 &lt;&lt; 14,
 677     };
 678     static constexpr OptionSet&lt;PaintLayerFlag&gt; paintLayerPaintingCompositingAllPhasesFlags() { return { PaintLayerPaintingCompositingBackgroundPhase, PaintLayerPaintingCompositingForegroundPhase }; }
 679 
 680     enum class SecurityOriginPaintPolicy { AnyOrigin, AccessibleOriginOnly };
 681 
 682     // The two main functions that use the layer system.  The paint method
 683     // paints the layers that intersect the damage rect from back to
 684     // front.  The hitTest method looks for mouse events by walking
 685     // layers that intersect the point from front to back.
 686     void paint(GraphicsContext&amp;, const LayoutRect&amp; damageRect, const LayoutSize&amp; subpixelOffset = LayoutSize(), OptionSet&lt;PaintBehavior&gt; = PaintBehavior::Normal,
 687         RenderObject* subtreePaintRoot = nullptr, OptionSet&lt;PaintLayerFlag&gt; = { }, SecurityOriginPaintPolicy = SecurityOriginPaintPolicy::AnyOrigin);
 688     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
 689     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
 690     void paintOverlayScrollbars(GraphicsContext&amp;, const LayoutRect&amp; damageRect, OptionSet&lt;PaintBehavior&gt;, RenderObject* subtreePaintRoot = nullptr);
 691 
 692     struct ClipRectsContext {
 693         ClipRectsContext(const RenderLayer* inRootLayer, ClipRectsType inClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy = IgnoreOverlayScrollbarSize, ShouldRespectOverflowClip inRespectOverflowClip = RespectOverflowClip)
 694             : rootLayer(inRootLayer)
 695             , clipRectsType(inClipRectsType)
 696             , overlayScrollbarSizeRelevancy(inOverlayScrollbarSizeRelevancy)
 697             , respectOverflowClip(inRespectOverflowClip)
 698         { }
 699         const RenderLayer* rootLayer;
 700         ClipRectsType clipRectsType;
 701         OverlayScrollbarSizeRelevancy overlayScrollbarSizeRelevancy;
 702         ShouldRespectOverflowClip respectOverflowClip;
 703     };
 704 
 705     // This method figures out our layerBounds in coordinates relative to
 706     // |rootLayer}.  It also computes our background and foreground clip rects
 707     // for painting/event handling.
 708     // Pass offsetFromRoot if known.
 709     void calculateRects(const ClipRectsContext&amp;, const LayoutRect&amp; paintDirtyRect, LayoutRect&amp; layerBounds,
 710         ClipRect&amp; backgroundRect, ClipRect&amp; foregroundRect, const LayoutSize&amp; offsetFromRoot) const;
 711 
 712     // Public just for RenderTreeAsText.
 713     void collectFragments(LayerFragments&amp;, const RenderLayer* rootLayer, const LayoutRect&amp; dirtyRect,
 714         PaginationInclusionMode,
 715         ClipRectsType, OverlayScrollbarSizeRelevancy inOverlayScrollbarSizeRelevancy, ShouldRespectOverflowClip, const LayoutSize&amp; offsetFromRoot,
 716         const LayoutRect* layerBoundingBox = nullptr, ShouldApplyRootOffsetToFragments = IgnoreRootOffsetForFragments);
 717 
 718     LayoutRect childrenClipRect() const; // Returns the foreground clip rect of the layer in the document&#39;s coordinate space.
 719     LayoutRect selfClipRect() const; // Returns the background clip rect of the layer in the document&#39;s coordinate space.
 720     LayoutRect localClipRect(bool&amp; clipExceedsBounds) const; // Returns the background clip rect of the layer in the local coordinate space.
 721 
 722     bool clipCrossesPaintingBoundary() const;
 723 
 724     // Pass offsetFromRoot if known.
 725     bool intersectsDamageRect(const LayoutRect&amp; layerBounds, const LayoutRect&amp; damageRect, const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot, const LayoutRect* cachedBoundingBox = nullptr) const;
 726 
 727     enum CalculateLayerBoundsFlag {
 728         IncludeSelfTransform                    = 1 &lt;&lt; 0,
 729         UseLocalClipRectIfPossible              = 1 &lt;&lt; 1,
 730         IncludeFilterOutsets                    = 1 &lt;&lt; 2,
 731         IncludePaintedFilterOutsets             = 1 &lt;&lt; 3,
 732         ExcludeHiddenDescendants                = 1 &lt;&lt; 4,
 733         DontConstrainForMask                    = 1 &lt;&lt; 5,
 734         IncludeCompositedDescendants            = 1 &lt;&lt; 6,
 735         UseFragmentBoxesExcludingCompositing    = 1 &lt;&lt; 7,
 736         UseFragmentBoxesIncludingCompositing    = 1 &lt;&lt; 8,
 737     };
 738     static constexpr OptionSet&lt;CalculateLayerBoundsFlag&gt; defaultCalculateLayerBoundsFlags() { return { IncludeSelfTransform, UseLocalClipRectIfPossible, IncludePaintedFilterOutsets, UseFragmentBoxesExcludingCompositing }; }
 739 
 740     // Bounding box relative to some ancestor layer. Pass offsetFromRoot if known.
 741     LayoutRect boundingBox(const RenderLayer* rootLayer, const LayoutSize&amp; offsetFromRoot = LayoutSize(), OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 742     // Bounding box in the coordinates of this layer.
 743     LayoutRect localBoundingBox(OptionSet&lt;CalculateLayerBoundsFlag&gt; = { }) const;
 744     // Deprecated: Pixel snapped bounding box relative to the root.
 745     WEBCORE_EXPORT IntRect absoluteBoundingBox() const;
 746     // Device pixel snapped bounding box relative to the root. absoluteBoundingBox() callers will be directed to this.
 747     FloatRect absoluteBoundingBoxForPainting() const;
 748 
 749     // Bounds used for layer overlap testing in RenderLayerCompositor.
 750     LayoutRect overlapBounds() const;
 751 
 752     // Takes transform animations into account, returning true if they could be cheaply computed.
 753     // Unlike overlapBounds, these bounds include descendant layers.
 754     bool getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(LayoutRect&amp;, OptionSet&lt;CalculateLayerBoundsFlag&gt; additionalFlags = { }) const;
 755 
 756     // If true, this layer&#39;s children are included in its bounds for overlap testing.
 757     // We can&#39;t rely on the children&#39;s positions if this layer has a filter that could have moved the children&#39;s pixels around.
 758     bool overlapBoundsIncludeChildren() const { return hasFilter() &amp;&amp; renderer().style().filter().hasFilterThatMovesPixels(); }
 759 
 760     // Can pass offsetFromRoot if known.
 761     LayoutRect calculateLayerBounds(const RenderLayer* ancestorLayer, const LayoutSize&amp; offsetFromRoot, OptionSet&lt;CalculateLayerBoundsFlag&gt; = defaultCalculateLayerBoundsFlags()) const;
 762 
 763     // Return a cached repaint rect, computed relative to the layer renderer&#39;s containerForRepaint.
 764     bool hasComputedRepaintRects() const { return renderer().hasRepaintLayoutRects(); }
 765     LayoutRect repaintRectIncludingNonCompositingDescendants() const;
 766 
 767     void setRepaintStatus(RepaintStatus status) { m_repaintStatus = status; }
 768     RepaintStatus repaintStatus() const { return static_cast&lt;RepaintStatus&gt;(m_repaintStatus); }
 769 
 770     LayoutUnit staticInlinePosition() const { return m_staticInlinePosition; }
 771     LayoutUnit staticBlockPosition() const { return m_staticBlockPosition; }
 772 
 773     void setStaticInlinePosition(LayoutUnit position) { m_staticInlinePosition = position; }
 774     void setStaticBlockPosition(LayoutUnit position) { m_staticBlockPosition = position; }
 775 
 776 #if PLATFORM(IOS_FAMILY)
 777     bool adjustForIOSCaretWhenScrolling() const { return m_adjustForIOSCaretWhenScrolling; }
 778     void setAdjustForIOSCaretWhenScrolling(bool adjustForIOSCaretWhenScrolling) { m_adjustForIOSCaretWhenScrolling = adjustForIOSCaretWhenScrolling; }
 779 #endif
 780 
 781     bool hasTransform() const { return renderer().hasTransform(); }
 782     // Note that this transform has the transform-origin baked in.
 783     TransformationMatrix* transform() const { return m_transform.get(); }
 784     // currentTransform computes a transform which takes accelerated animations into account. The
 785     // resulting transform has transform-origin baked in. If the layer does not have a transform,
 786     // returns the identity matrix.
 787     TransformationMatrix currentTransform(RenderStyle::ApplyTransformOrigin = RenderStyle::IncludeTransformOrigin) const;
 788     TransformationMatrix renderableTransform(OptionSet&lt;PaintBehavior&gt;) const;
 789 
 790     // Get the perspective transform, which is applied to transformed sublayers.
 791     // Returns true if the layer has a -webkit-perspective.
 792     // Note that this transform has the perspective-origin baked in.
 793     TransformationMatrix perspectiveTransform() const;
 794     FloatPoint perspectiveOrigin() const;
 795     bool preserves3D() const { return renderer().style().transformStyle3D() == TransformStyle3D::Preserve3D; }
 796     bool has3DTransform() const { return m_transform &amp;&amp; !m_transform-&gt;isAffine(); }
 797     bool hasTransformedAncestor() const { return m_hasTransformedAncestor; }
 798 
 799     void filterNeedsRepaint();
 800     bool hasFilter() const { return renderer().hasFilter(); }
<a name="9" id="anc9"></a><span class="line-added"> 801     bool hasFilterOutsets() const { return !filterOutsets().isZero(); }</span>
<span class="line-added"> 802     IntOutsets filterOutsets() const;</span>
 803     bool hasBackdropFilter() const
 804     {
 805 #if ENABLE(FILTERS_LEVEL_2)
 806         return renderer().hasBackdropFilter();
 807 #else
 808         return false;
 809 #endif
 810     }
 811 
 812 #if ENABLE(CSS_COMPOSITING)
 813     bool hasBlendMode() const { return renderer().hasBlendMode(); }
 814     BlendMode blendMode() const { return static_cast&lt;BlendMode&gt;(m_blendMode); }
 815 
 816     bool isolatesCompositedBlending() const { return m_hasNotIsolatedCompositedBlendingDescendants &amp;&amp; isCSSStackingContext(); }
 817     bool hasNotIsolatedCompositedBlendingDescendants() const { return m_hasNotIsolatedCompositedBlendingDescendants; }
 818     void setHasNotIsolatedCompositedBlendingDescendants(bool hasNotIsolatedCompositedBlendingDescendants)
 819     {
 820         m_hasNotIsolatedCompositedBlendingDescendants = hasNotIsolatedCompositedBlendingDescendants;
 821     }
 822 
 823     bool isolatesBlending() const { return hasNotIsolatedBlendingDescendants() &amp;&amp; isCSSStackingContext(); }
 824 
 825     // FIXME: We should ASSERT(!m_hasNotIsolatedBlendingDescendantsStatusDirty); here but we hit the same bugs as visible content above.
 826     bool hasNotIsolatedBlendingDescendants() const { return m_hasNotIsolatedBlendingDescendants; }
 827     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return m_hasNotIsolatedBlendingDescendantsStatusDirty; }
 828 #else
 829     bool hasBlendMode() const { return false; }
 830     bool isolatesCompositedBlending() const { return false; }
 831     bool isolatesBlending() const { return false; }
 832     bool hasNotIsolatedBlendingDescendantsStatusDirty() const { return false; }
 833 #endif
 834 
 835     bool isComposited() const { return m_backing != nullptr; }
 836     bool hasCompositingDescendant() const { return m_hasCompositingDescendant; }
 837     bool hasCompositedMask() const;
 838 
 839     // If non-null, a non-ancestor composited layer that this layer paints into (it is sharing its backing store with this layer).
 840     RenderLayer* backingProviderLayer() const { return m_backingProviderLayer.get(); }
 841     void setBackingProviderLayer(RenderLayer*);
 842     void disconnectFromBackingProviderLayer();
 843 
 844     bool paintsIntoProvidedBacking() const { return !!m_backingProviderLayer; }
 845 
 846     RenderLayerBacking* backing() const { return m_backing.get(); }
 847     RenderLayerBacking* ensureBacking();
 848     void clearBacking(bool layerBeingDestroyed = false);
 849 
 850     GraphicsLayer* layerForHorizontalScrollbar() const override;
 851     GraphicsLayer* layerForVerticalScrollbar() const override;
 852     GraphicsLayer* layerForScrollCorner() const override;
 853 
 854     bool usesCompositedScrolling() const override;
 855     bool usesAsyncScrolling() const override;
 856 
 857     bool hasCompositedScrollingAncestor() const { return m_hasCompositedScrollingAncestor; }
 858     void setHasCompositedScrollingAncestor(bool hasCompositedScrollingAncestor) { m_hasCompositedScrollingAncestor = hasCompositedScrollingAncestor; }
 859 
 860     bool paintsWithTransparency(OptionSet&lt;PaintBehavior&gt; paintBehavior) const
 861     {
 862         return (isTransparent() || hasBlendMode() || (isolatesBlending() &amp;&amp; !renderer().isDocumentElementRenderer())) &amp;&amp; ((paintBehavior &amp; PaintBehavior::FlattenCompositingLayers) || !isComposited());
 863     }
 864 
 865     bool paintsWithTransform(OptionSet&lt;PaintBehavior&gt;) const;
 866     bool shouldPaintMask(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 867     bool shouldApplyClipPath(OptionSet&lt;PaintBehavior&gt;, OptionSet&lt;PaintLayerFlag&gt;) const;
 868 
 869     // Returns true if background phase is painted opaque in the given rect.
 870     // The query rect is given in local coordinates.
 871     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp;) const;
 872 
 873     bool scrollingMayRevealBackground() const;
 874 
 875     bool containsDirtyOverlayScrollbars() const { return m_containsDirtyOverlayScrollbars; }
 876     void setContainsDirtyOverlayScrollbars(bool dirtyScrollbars) { m_containsDirtyOverlayScrollbars = dirtyScrollbars; }
 877 
 878     bool paintsWithFilters() const;
 879     bool requiresFullLayerImageForFilters() const;
 880 
 881     Element* enclosingElement() const;
 882 
 883     enum ViewportConstrainedNotCompositedReason {
 884         NoNotCompositedReason,
 885         NotCompositedForBoundsOutOfView,
 886         NotCompositedForNonViewContainer,
 887         NotCompositedForNoVisibleContent,
 888     };
 889 
 890     void setViewportConstrainedNotCompositedReason(ViewportConstrainedNotCompositedReason reason) { m_viewportConstrainedNotCompositedReason = reason; }
 891     ViewportConstrainedNotCompositedReason viewportConstrainedNotCompositedReason() const { return static_cast&lt;ViewportConstrainedNotCompositedReason&gt;(m_viewportConstrainedNotCompositedReason); }
 892 
 893     IndirectCompositingReason indirectCompositingReason() const { return static_cast&lt;IndirectCompositingReason&gt;(m_indirectCompositingReason); }
 894 
 895     bool isRenderFragmentedFlow() const { return renderer().isRenderFragmentedFlow(); }
 896     bool isOutOfFlowRenderFragmentedFlow() const { return renderer().isOutOfFlowRenderFragmentedFlow(); }
 897     bool isInsideFragmentedFlow() const { return renderer().fragmentedFlowState() != RenderObject::NotInsideFragmentedFlow; }
 898     bool isDirtyRenderFragmentedFlow() const
 899     {
 900         ASSERT(isRenderFragmentedFlow());
 901         return zOrderListsDirty() || normalFlowListDirty();
 902     }
 903 
 904     RenderLayer* enclosingFragmentedFlowAncestor() const;
 905 
 906     bool shouldPlaceBlockDirectionScrollbarOnLeft() const final { return renderer().shouldPlaceBlockDirectionScrollbarOnLeft(); }
 907 
 908     void simulateFrequentPaint() { SinglePaintFrequencyTracking { m_paintFrequencyTracker }; }
 909     bool paintingFrequently() const { return m_paintFrequencyTracker.paintingFrequently(); }
 910 
<a name="10" id="anc10"></a><span class="line-modified"> 911     WEBCORE_EXPORT bool isTransparentRespectingParentFrames() const;</span>
 912 
 913     void invalidateEventRegion();
 914 
 915 private:
 916 
 917     void setNextSibling(RenderLayer* next) { m_next = next; }
 918     void setPreviousSibling(RenderLayer* prev) { m_previous = prev; }
 919     void setParent(RenderLayer*);
 920     void setFirstChild(RenderLayer* first) { m_first = first; }
 921     void setLastChild(RenderLayer* last) { m_last = last; }
 922 
 923     void dirtyPaintOrderListsOnChildChange(RenderLayer&amp;);
 924 
 925     bool shouldBeNormalFlowOnly() const;
 926     bool shouldBeCSSStackingContext() const;
 927 
 928     // Return true if changed.
 929     bool setIsNormalFlowOnly(bool);
 930 
 931     bool setIsOpportunisticStackingContext(bool);
 932     bool setIsCSSStackingContext(bool);
 933 
 934     void isStackingContextChanged();
 935 
 936     bool isDirtyStackingContext() const { return m_zOrderListsDirty &amp;&amp; isStackingContext(); }
 937 
 938     void updateZOrderLists();
 939     void rebuildZOrderLists();
<a name="11" id="anc11"></a><span class="line-modified"> 940     void rebuildZOrderLists(std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);</span>
<span class="line-modified"> 941     void collectLayers(bool includeHiddenLayers, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt;&amp;, OptionSet&lt;Compositing&gt;&amp;);</span>
 942     void clearZOrderLists();
 943 
 944     void updateNormalFlowList();
 945 
 946     struct LayerPaintingInfo {
 947         LayerPaintingInfo(RenderLayer* inRootLayer, const LayoutRect&amp; inDirtyRect, OptionSet&lt;PaintBehavior&gt; inPaintBehavior, const LayoutSize&amp; inSubpixelOffset, RenderObject* inSubtreePaintRoot = nullptr, OverlapTestRequestMap* inOverlapTestRequests = nullptr, bool inRequireSecurityOriginAccessForWidgets = false)
 948             : rootLayer(inRootLayer)
 949             , subtreePaintRoot(inSubtreePaintRoot)
 950             , paintDirtyRect(inDirtyRect)
 951             , subpixelOffset(inSubpixelOffset)
 952             , overlapTestRequests(inOverlapTestRequests)
 953             , paintBehavior(inPaintBehavior)
 954             , requireSecurityOriginAccessForWidgets(inRequireSecurityOriginAccessForWidgets)
 955         { }
 956 
 957         RenderLayer* rootLayer;
 958         RenderObject* subtreePaintRoot; // Only paint descendants of this object.
 959         LayoutRect paintDirtyRect; // Relative to rootLayer;
 960         LayoutSize subpixelOffset;
 961         OverlapTestRequestMap* overlapTestRequests; // May be null.
 962         OptionSet&lt;PaintBehavior&gt; paintBehavior;
 963         bool requireSecurityOriginAccessForWidgets;
 964         bool clipToDirtyRect { true };
 965         EventRegionContext* eventRegionContext { nullptr };
 966     };
 967 
 968     // Compute, cache and return clip rects computed with the given layer as the root.
 969     Ref&lt;ClipRects&gt; updateClipRects(const ClipRectsContext&amp;);
 970     // Compute and return the clip rects. If useCached is true, will used previously computed clip rects on ancestors
 971     // (rather than computing them all from scratch up the parent chain).
 972     void calculateClipRects(const ClipRectsContext&amp;, ClipRects&amp;) const;
 973     ClipRects* clipRects(const ClipRectsContext&amp;) const;
 974 
 975     void setAncestorChainHasSelfPaintingLayerDescendant();
 976     void dirtyAncestorChainHasSelfPaintingLayerDescendantStatus();
 977 
 978     void computeRepaintRects(const RenderLayerModelObject* repaintContainer, const RenderGeometryMap* = nullptr);
 979     void computeRepaintRectsIncludingDescendants();
 980     void clearRepaintRects();
 981 
 982     LayoutRect clipRectRelativeToAncestor(RenderLayer* ancestor, LayoutSize offsetFromAncestor, const LayoutRect&amp; constrainingRect) const;
 983 
 984     void clipToRect(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;, BorderRadiusClippingRule = IncludeSelfForBorderRadius);
 985     void restoreClip(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const ClipRect&amp;);
 986 
 987     bool shouldRepaintAfterLayout() const;
 988 
 989     void updateSelfPaintingLayer();
 990 
 991     void updateScrollbarsAfterStyleChange(const RenderStyle* oldStyle);
 992     void updateScrollbarsAfterLayout();
 993 
 994     enum UpdateLayerPositionsFlag {
 995         CheckForRepaint                     = 1 &lt;&lt; 0,
 996         NeedsFullRepaintInBacking           = 1 &lt;&lt; 1,
 997         ContainingClippingLayerChangedSize  = 1 &lt;&lt; 2,
 998         UpdatePagination                    = 1 &lt;&lt; 3,
 999         SeenFixedLayer                      = 1 &lt;&lt; 4,
1000         SeenTransformedLayer                = 1 &lt;&lt; 5,
1001         Seen3DTransformedLayer              = 1 &lt;&lt; 6,
1002         SeenCompositedScrollingLayer        = 1 &lt;&lt; 7,
1003     };
1004     static OptionSet&lt;UpdateLayerPositionsFlag&gt; flagsForUpdateLayerPositions(RenderLayer&amp; startingLayer);
1005 
1006     // Returns true if the position changed.
1007     bool updateLayerPosition(OptionSet&lt;UpdateLayerPositionsFlag&gt;* = nullptr);
1008 
1009     void updateLayerPositions(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsFlag&gt;);
1010 
1011     enum UpdateLayerPositionsAfterScrollFlag {
1012         IsOverflowScroll                        = 1 &lt;&lt; 0,
1013         HasSeenViewportConstrainedAncestor      = 1 &lt;&lt; 1,
1014         HasSeenAncestorWithOverflowClip         = 1 &lt;&lt; 2,
1015         HasChangedAncestor                      = 1 &lt;&lt; 3,
1016     };
1017     void updateLayerPositionsAfterScroll(RenderGeometryMap*, OptionSet&lt;UpdateLayerPositionsAfterScrollFlag&gt; = { });
1018 
1019     ScrollOffset clampScrollOffset(const ScrollOffset&amp;) const;
1020 
1021     RenderLayer* enclosingPaginationLayerInSubtree(const RenderLayer* rootLayer, PaginationInclusionMode) const;
1022 
1023     LayoutPoint renderBoxLocation() const { return is&lt;RenderBox&gt;(renderer()) ? downcast&lt;RenderBox&gt;(renderer()).location() : LayoutPoint(); }
1024 
1025     bool setupFontSubpixelQuantization(GraphicsContext&amp;, bool&amp; didQuantizeFonts);
1026 
1027     Path computeClipPath(const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, WindRule&amp;) const;
1028 
1029     bool setupClipPath(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1030 
1031     void ensureLayerFilters();
1032     void clearLayerFilters();
1033 
1034     RenderLayerFilters* filtersForPainting(GraphicsContext&amp;, OptionSet&lt;PaintLayerFlag&gt;) const;
1035     GraphicsContext* setupFilters(GraphicsContext&amp; destinationContext, LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; offsetFromRoot, LayoutRect&amp; rootRelativeBounds, bool&amp; rootRelativeBoundsComputed);
1036     void applyFilters(GraphicsContext&amp; originalContext, const LayerPaintingInfo&amp;, const LayerFragments&amp;);
1037 
1038     void paintLayer(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1039     void paintLayerWithEffects(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1040 
1041     void paintLayerContentsAndReflection(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1042     void paintLayerByApplyingTransform(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, const LayoutSize&amp; translationOffset = LayoutSize());
1043     void paintLayerContents(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1044     void paintList(LayerList, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1045 
1046     void updatePaintingInfoForFragments(LayerFragments&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;, bool shouldPaintContent, const LayoutSize&amp; offsetFromRoot);
1047     void paintBackgroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1048         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1049     void paintForegroundForFragments(const LayerFragments&amp;, GraphicsContext&amp;, GraphicsContext&amp; transparencyLayerContext,
1050         const LayoutRect&amp; transparencyPaintDirtyRect, bool haveTransparency, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1051     void paintForegroundForFragmentsWithPhase(PaintPhase, const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1052     void paintOutlineForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1053     void paintOverflowControlsForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
1054     void paintMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1055     void paintChildClippingMaskForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintBehavior&gt;, RenderObject* paintingRootForRenderer);
1056     void paintTransformedLayerIntoFragments(GraphicsContext&amp;, const LayerPaintingInfo&amp;, OptionSet&lt;PaintLayerFlag&gt;);
1057     void collectEventRegionForFragments(const LayerFragments&amp;, GraphicsContext&amp;, const LayerPaintingInfo&amp;);
1058 
1059     RenderLayer* transparentPaintingAncestor();
1060     void beginTransparencyLayers(GraphicsContext&amp;, const LayerPaintingInfo&amp;, const LayoutRect&amp; dirtyRect);
1061 
1062     RenderLayer* hitTestLayer(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1063         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, bool appliedTransform,
1064         const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1065     RenderLayer* hitTestLayerByApplyingTransform(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1066         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr,
1067         const LayoutSize&amp; translationOffset = LayoutSize());
1068     RenderLayer* hitTestList(LayerList, RenderLayer* rootLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1069         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1070         const HitTestingTransformState*, double* zOffsetForDescendants, double* zOffset,
1071         const HitTestingTransformState* unflattenedTransformState, bool depthSortDescendants);
1072 
1073     Ref&lt;HitTestingTransformState&gt; createLocalTransformState(RenderLayer* rootLayer, RenderLayer* containerLayer,
1074         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;,
1075         const HitTestingTransformState* containerTransformState,
1076         const LayoutSize&amp; translationOffset = LayoutSize()) const;
1077 
1078     bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const LayoutRect&amp; layerBounds, const HitTestLocation&amp;, HitTestFilter) const;
1079     bool hitTestContentsForFragments(const LayerFragments&amp;, const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, HitTestFilter, bool&amp; insideClipRect) const;
1080     bool hitTestResizerInFragments(const LayerFragments&amp;, const HitTestLocation&amp;) const;
1081     RenderLayer* hitTestTransformedLayerInFragments(RenderLayer* rootLayer, RenderLayer* containerLayer, const HitTestRequest&amp;, HitTestResult&amp;,
1082         const LayoutRect&amp; hitTestRect, const HitTestLocation&amp;, const HitTestingTransformState* = nullptr, double* zOffset = nullptr);
1083 
1084     bool listBackgroundIsKnownToBeOpaqueInRect(const LayerList&amp;, const LayoutRect&amp;) const;
1085 
1086     void computeScrollDimensions();
1087     bool hasHorizontalOverflow() const;
1088     bool hasVerticalOverflow() const;
1089 
1090     bool showsOverflowControls() const;
1091 
1092     bool shouldBeSelfPaintingLayer() const;
1093 
1094     // ScrollableArea interface
1095     void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) override;
1096     void invalidateScrollCornerRect(const IntRect&amp;) override;
1097     bool isActive() const override;
1098     bool isScrollCornerVisible() const override;
1099     IntRect scrollCornerRect() const override;
1100     IntRect convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntRect&amp;) const override;
1101     IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntRect&amp;) const override;
1102     IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp;, const IntPoint&amp;) const override;
1103     IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp;, const IntPoint&amp;) const override;
1104     void setScrollOffset(const ScrollOffset&amp;) override;
1105     ScrollingNodeID scrollingNodeID() const override;
1106 
1107     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const override;
1108     IntSize overhangAmount() const override;
1109     IntPoint lastKnownMousePosition() const override;
1110     bool isHandlingWheelEvent() const override;
1111     bool shouldSuspendScrollAnimations() const override;
1112     IntRect scrollableAreaBoundingBox(bool* isInsideFixed = nullptr) const override;
1113     bool isRubberBandInProgress() const override;
1114     bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const override;
1115 #if ENABLE(CSS_SCROLL_SNAP)
1116     bool isScrollSnapInProgress() const override;
1117 #endif
1118     bool usesMockScrollAnimator() const override;
1119     void logMockScrollAnimatorMessage(const String&amp;) const override;
1120 
1121 #if ENABLE(IOS_TOUCH_EVENTS)
1122     void registerAsTouchEventListenerForScrolling();
1123     void unregisterAsTouchEventListenerForScrolling();
1124 #endif
1125 
1126     // Rectangle encompassing the scroll corner and resizer rect.
1127     LayoutRect scrollCornerAndResizerRect() const;
1128 
1129     // NOTE: This should only be called by the overridden setScrollOffset from ScrollableArea.
1130     void scrollTo(const ScrollPosition&amp;);
1131     void updateCompositingLayersAfterScroll();
1132 
1133     IntSize scrollbarOffset(const Scrollbar&amp;) const;
1134 
1135     void updateScrollableAreaSet(bool hasOverflow);
1136 
1137     bool allowsCurrentScroll() const;
1138 
1139     void dirtyAncestorChainVisibleDescendantStatus();
1140     void setAncestorChainHasVisibleDescendant();
1141 
1142     bool has3DTransformedDescendant() const { return m_has3DTransformedDescendant; }
1143     bool has3DTransformedAncestor() const { return m_has3DTransformedAncestor; }
1144 
1145     void dirty3DTransformedDescendantStatus();
1146     // Both updates the status, and returns true if descendants of this have 3d.
1147     bool update3DTransformedDescendantStatus();
1148 
1149     void createReflection();
1150     void removeReflection();
1151 
1152     RenderStyle createReflectionStyle();
1153     bool paintingInsideReflection() const { return m_paintingInsideReflection; }
1154     void setPaintingInsideReflection(bool b) { m_paintingInsideReflection = b; }
1155 
1156     void updateFiltersAfterStyleChange();
1157     void updateFilterPaintingStrategy();
1158 
1159 #if ENABLE(CSS_COMPOSITING)
1160     void updateAncestorChainHasBlendingDescendants();
1161     void dirtyAncestorChainHasBlendingDescendants();
1162 #endif
1163 
1164     Ref&lt;ClipRects&gt; parentClipRects(const ClipRectsContext&amp;) const;
1165     ClipRect backgroundClipRect(const ClipRectsContext&amp;) const;
1166 
1167     RenderLayer* enclosingTransformedAncestor() const;
1168 
1169     LayoutRect getRectToExpose(const LayoutRect&amp; visibleRect, const LayoutRect&amp; exposeRect, bool insideFixed, const ScrollAlignment&amp; alignX, const ScrollAlignment&amp; alignY) const;
1170 
1171     // Convert a point in absolute coords into layer coords, taking transforms into account
1172     LayoutPoint absoluteToContents(const LayoutPoint&amp;) const;
1173 
1174     void positionOverflowControls(const IntSize&amp;);
1175     void updateScrollCornerStyle();
1176     void clearScrollCorner();
1177     void updateResizerStyle();
1178     void clearResizer();
1179 
1180     void drawPlatformResizerImage(GraphicsContext&amp;, const LayoutRect&amp; resizerCornerRect);
1181 
1182     void updatePagination();
1183 
1184     void setHasCompositingDescendant(bool b)  { m_hasCompositingDescendant = b; }
1185 
1186     void setIndirectCompositingReason(IndirectCompositingReason reason) { m_indirectCompositingReason = static_cast&lt;unsigned&gt;(reason); }
1187     bool mustCompositeForIndirectReasons() const { return m_indirectCompositingReason; }
1188 
1189     LayoutUnit overflowTop() const;
1190     LayoutUnit overflowBottom() const;
1191     LayoutUnit overflowLeft() const;
1192     LayoutUnit overflowRight() const;
1193 
1194     IntRect rectForHorizontalScrollbar(const IntRect&amp; borderBoxRect) const;
1195     IntRect rectForVerticalScrollbar(const IntRect&amp; borderBoxRect) const;
1196 
1197     LayoutUnit verticalScrollbarStart(int minX, int maxX) const;
1198     LayoutUnit horizontalScrollbarStart(int minX) const;
1199 
1200     bool overflowControlsIntersectRect(const IntRect&amp; localRect) const;
1201 
1202     OptionSet&lt;Compositing&gt; m_compositingDirtyBits;
1203 
1204     const bool m_isRenderViewLayer : 1;
1205     const bool m_forcedStackingContext : 1;
1206 
1207     bool m_isNormalFlowOnly : 1;
1208     bool m_isCSSStackingContext : 1;
1209     bool m_isOpportunisticStackingContext : 1;
1210 
1211     bool m_zOrderListsDirty : 1;
1212     bool m_normalFlowListDirty: 1;
1213     bool m_hadNegativeZOrderList : 1;
1214 
1215     // Keeps track of whether the layer is currently resizing, so events can cause resizing to start and stop.
1216     bool m_inResizeMode : 1;
1217 
1218     bool m_scrollDimensionsDirty : 1;
1219     bool m_isSelfPaintingLayer : 1;
1220 
1221     // If have no self-painting descendants, we don&#39;t have to walk our children during painting. This can lead to
1222     // significant savings, especially if the tree has lots of non-self-painting layers grouped together (e.g. table cells).
1223     bool m_hasSelfPaintingLayerDescendant : 1;
1224     bool m_hasSelfPaintingLayerDescendantDirty : 1;
1225 
1226     bool m_usedTransparency : 1; // Tracks whether we need to close a transparent layer, i.e., whether
1227                                  // we ended up painting this layer or any descendants (and therefore need to
1228                                  // blend).
1229     bool m_paintingInsideReflection : 1;  // A state bit tracking if we are painting inside a replica.
1230     bool m_inOverflowRelayout : 1;
1231     unsigned m_repaintStatus : 2; // RepaintStatus
1232 
1233     bool m_visibleContentStatusDirty : 1;
1234     bool m_hasVisibleContent : 1;
1235     bool m_visibleDescendantStatusDirty : 1;
1236     bool m_hasVisibleDescendant : 1;
1237     bool m_registeredScrollableArea : 1;
1238     bool m_isFixedIntersectingViewport : 1;
1239     bool m_behavesAsFixed : 1;
1240 
1241     bool m_3DTransformedDescendantStatusDirty : 1;
1242     bool m_has3DTransformedDescendant : 1;  // Set on a stacking context layer that has 3D descendants anywhere
1243                                             // in a preserves3D hierarchy. Hint to do 3D-aware hit testing.
1244     bool m_hasCompositingDescendant : 1; // In the z-order tree.
1245 
1246     bool m_hasCompositedScrollingAncestor : 1; // In the layer-order tree.
1247     bool m_hasCompositedScrollableOverflow : 1;
1248 
1249     bool m_hasTransformedAncestor : 1;
1250     bool m_has3DTransformedAncestor : 1;
1251 
<a name="12" id="anc12"></a><span class="line-modified">1252     unsigned m_indirectCompositingReason : 4; // IndirectCompositingReason</span>
<span class="line-modified">1253     unsigned m_viewportConstrainedNotCompositedReason : 2; // ViewportConstrainedNotCompositedReason</span>
1254 
1255 #if PLATFORM(IOS_FAMILY)
1256 #if ENABLE(IOS_TOUCH_EVENTS)
1257     bool m_registeredAsTouchEventListenerForScrolling : 1;
1258 #endif
1259     bool m_adjustForIOSCaretWhenScrolling : 1;
1260 #endif
1261 
1262     bool m_requiresScrollPositionReconciliation : 1;
1263     bool m_containsDirtyOverlayScrollbars : 1;
1264     bool m_updatingMarqueePosition : 1;
1265 
<a name="13" id="anc13"></a><span class="line-modified">1266 #if ASSERT_ENABLED</span>
1267     bool m_layerListMutationAllowed : 1;
1268 #endif
1269 
1270 #if ENABLE(CSS_COMPOSITING)
<a name="14" id="anc14"></a><span class="line-modified">1271     unsigned m_blendMode : 5; // BlendMode</span>
1272     bool m_hasNotIsolatedCompositedBlendingDescendants : 1;
1273     bool m_hasNotIsolatedBlendingDescendants : 1;
1274     bool m_hasNotIsolatedBlendingDescendantsStatusDirty : 1;
1275 #endif
1276 
1277     RenderLayerModelObject&amp; m_renderer;
1278 
1279     RenderLayer* m_parent { nullptr };
1280     RenderLayer* m_previous { nullptr };
1281     RenderLayer* m_next { nullptr };
1282     RenderLayer* m_first { nullptr };
1283     RenderLayer* m_last { nullptr };
1284 
1285     WeakPtr&lt;RenderLayer&gt; m_backingProviderLayer;
1286 
1287     // For layers that establish stacking contexts, m_posZOrderList holds a sorted list of all the
1288     // descendant layers within the stacking context that have z-indices of 0 or greater
1289     // (auto will count as 0). m_negZOrderList holds descendants within our stacking context with negative
1290     // z-indices.
1291     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_posZOrderList;
1292     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_negZOrderList;
1293 
1294     // This list contains child layers that cannot create stacking contexts and appear in normal flow order.
1295     std::unique_ptr&lt;Vector&lt;RenderLayer*&gt;&gt; m_normalFlowList;
1296 
1297     // Our current relative position offset.
1298     LayoutSize m_offsetForInFlowPosition;
1299 
1300     // Our (x,y) coordinates are in our parent layer&#39;s coordinate space.
1301     LayoutPoint m_topLeft;
1302 
1303     // The layer&#39;s width/height
1304     IntSize m_layerSize;
1305 
1306     ScrollPosition m_scrollPosition;
1307     Optional&lt;ScrollPosition&gt; m_postLayoutScrollPosition;
1308 
1309     // The width/height of our scrolled area.
1310     IntSize m_scrollSize;
1311 
1312     // For layers with overflow, we have a pair of scrollbars.
1313     RefPtr&lt;Scrollbar&gt; m_hBar;
1314     RefPtr&lt;Scrollbar&gt; m_vBar;
1315 
1316     std::unique_ptr&lt;ClipRectsCache&gt; m_clipRectsCache;
1317 
1318     IntPoint m_cachedOverlayScrollbarOffset;
1319 
1320     std::unique_ptr&lt;RenderMarquee&gt; m_marquee; // Used for &lt;marquee&gt;.
1321 
1322     // Cached normal flow values for absolute positioned elements with static left/top values.
1323     LayoutUnit m_staticInlinePosition;
1324     LayoutUnit m_staticBlockPosition;
1325 
1326     std::unique_ptr&lt;TransformationMatrix&gt; m_transform;
1327 
1328     // May ultimately be extended to many replicas (with their own paint order).
1329     RenderPtr&lt;RenderReplica&gt; m_reflection;
1330 
1331     // Renderers to hold our custom scroll corner and resizer.
1332     RenderPtr&lt;RenderScrollbarPart&gt; m_scrollCorner;
1333     RenderPtr&lt;RenderScrollbarPart&gt; m_resizer;
1334 
1335     // Pointer to the enclosing RenderLayer that caused us to be paginated. It is 0 if we are not paginated.
1336     WeakPtr&lt;RenderLayer&gt; m_enclosingPaginationLayer;
1337 
1338     IntRect m_blockSelectionGapsBounds;
1339 
1340     std::unique_ptr&lt;RenderLayerFilters&gt; m_filters;
1341     std::unique_ptr&lt;RenderLayerBacking&gt; m_backing;
1342 
1343     PaintFrequencyTracker m_paintFrequencyTracker;
1344 };
1345 
1346 inline void RenderLayer::clearZOrderLists()
1347 {
1348     ASSERT(!isStackingContext());
1349     ASSERT(layerListMutationAllowed());
1350 
1351     m_posZOrderList = nullptr;
1352     m_negZOrderList = nullptr;
1353 }
1354 
1355 inline void RenderLayer::updateZOrderLists()
1356 {
1357     if (!m_zOrderListsDirty)
1358         return;
1359 
1360     if (!isStackingContext()) {
1361         clearZOrderLists();
1362         m_zOrderListsDirty = false;
1363         return;
1364     }
1365 
1366     rebuildZOrderLists();
1367 }
1368 
1369 inline RenderLayer* RenderLayer::paintOrderParent() const
1370 {
1371     return m_isNormalFlowOnly ? m_parent : stackingContext();
1372 }
1373 
<a name="15" id="anc15"></a><span class="line-modified">1374 #if ASSERT_ENABLED</span>
1375 class LayerListMutationDetector {
1376 public:
1377     LayerListMutationDetector(RenderLayer&amp; layer)
1378         : m_layer(layer)
1379         , m_previousMutationAllowedState(layer.layerListMutationAllowed())
1380     {
1381         m_layer.setLayerListMutationAllowed(false);
1382     }
1383 
1384     ~LayerListMutationDetector()
1385     {
1386         m_layer.setLayerListMutationAllowed(m_previousMutationAllowedState);
1387     }
1388 
1389 private:
1390     RenderLayer&amp; m_layer;
1391     bool m_previousMutationAllowedState;
1392 };
<a name="16" id="anc16"></a><span class="line-modified">1393 #endif // ASSERT_ENABLED</span>
1394 
1395 void makeMatrixRenderable(TransformationMatrix&amp;, bool has3DRendering);
1396 
1397 bool compositedWithOwnBackingStore(const RenderLayer&amp;);
1398 
1399 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ClipRectsType);
1400 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer&amp;);
1401 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayer::ClipRectsContext&amp;);
1402 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, IndirectCompositingReason);
1403 
1404 } // namespace WebCore
1405 
1406 #if ENABLE(TREE_DEBUGGING)
1407 // Outside the WebCore namespace for ease of invocation from lldb.
1408 void showLayerTree(const WebCore::RenderLayer*);
1409 void showPaintOrderTree(const WebCore::RenderLayer*);
1410 void showLayerTree(const WebCore::RenderObject*);
1411 #endif
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Igalia S.L.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 28 
 29 #if USE(COORDINATED_GRAPHICS)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;NotImplemented.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(RefPtr&lt;BitmapTexture&gt;&amp;&amp; texture, TextureMapperGL::Flags flags)
 37     : m_texture(WTFMove(texture))
<a name="1" id="anc1"></a><span class="line-modified"> 38     , m_variant(RGBTexture { 0 })</span>
 39     , m_extraFlags(flags)
 40     , m_hasManagedTexture(true)
 41 {
 42 }
 43 
 44 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)
<a name="2" id="anc2"></a><span class="line-modified"> 45     : TextureMapperPlatformLayerBuffer({ RGBTexture { textureID } }, size, flags, internalFormat)</span>
<span class="line-added"> 46 {</span>
<span class="line-added"> 47 }</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(TextureVariant&amp;&amp; variant, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)</span>
<span class="line-added"> 50     : m_variant(WTFMove(variant))</span>
 51     , m_size(size)
 52     , m_internalFormat(internalFormat)
 53     , m_extraFlags(flags)
 54     , m_hasManagedTexture(false)
 55 {
 56 }
 57 
<a name="3" id="anc3"></a><span class="line-added"> 58 TextureMapperPlatformLayerBuffer::~TextureMapperPlatformLayerBuffer()</span>
<span class="line-added"> 59 {</span>
<span class="line-added"> 60 }</span>
<span class="line-added"> 61 </span>
 62 bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize&amp; size, GLint internalFormat)
 63 {
 64     return m_texture &amp;&amp; (m_texture-&gt;size() == size) &amp;&amp; (static_cast&lt;BitmapTextureGL*&gt;(m_texture.get())-&gt;internalFormat() == internalFormat || internalFormat == GL_DONT_CARE);
 65 }
 66 
 67 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerBuffer::clone()
 68 {
<a name="4" id="anc4"></a><span class="line-modified"> 69     if (m_hasManagedTexture) {</span>
 70         notImplemented();
 71         return nullptr;
 72     }
<a name="5" id="anc5"></a><span class="line-modified"> 73 </span>
<span class="line-modified"> 74     return WTF::switchOn(m_variant,</span>
<span class="line-modified"> 75         [&amp;](const RGBTexture&amp; texture) mutable -&gt; std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; {</span>
<span class="line-modified"> 76             if (!texture.id) {</span>
<span class="line-added"> 77                 notImplemented();</span>
<span class="line-added"> 78                 return nullptr;</span>
<span class="line-added"> 79             }</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81             auto clonedTexture = BitmapTextureGL::create(TextureMapperContextAttributes::get(), m_internalFormat);</span>
<span class="line-added"> 82             clonedTexture-&gt;reset(m_size);</span>
<span class="line-added"> 83             static_cast&lt;BitmapTextureGL&amp;&gt;(clonedTexture.get()).copyFromExternalTexture(texture.id);</span>
<span class="line-added"> 84             return makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(WTFMove(clonedTexture), m_extraFlags);</span>
<span class="line-added"> 85         },</span>
<span class="line-added"> 86         [](const YUVTexture&amp;)</span>
<span class="line-added"> 87         {</span>
<span class="line-added"> 88             notImplemented();</span>
<span class="line-added"> 89             return nullptr;</span>
<span class="line-added"> 90         },</span>
<span class="line-added"> 91         [](const ExternalOESTexture&amp;)</span>
<span class="line-added"> 92         {</span>
<span class="line-added"> 93             notImplemented();</span>
<span class="line-added"> 94             return nullptr;</span>
<span class="line-added"> 95         });</span>
 96 }
 97 
 98 void TextureMapperPlatformLayerBuffer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)
 99 {
100     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
101 
102     if (m_hasManagedTexture) {
103         ASSERT(m_texture);
104         BitmapTextureGL* textureGL = static_cast&lt;BitmapTextureGL*&gt;(m_texture.get());
<a name="6" id="anc6"></a><span class="line-added">105 #if USE(ANGLE)</span>
<span class="line-added">106         textureGL-&gt;updatePendingContents(IntRect(IntPoint(), textureGL-&gt;contentSize()), IntPoint());</span>
<span class="line-added">107 #endif</span>
108         texmapGL.drawTexture(textureGL-&gt;id(), m_extraFlags | textureGL-&gt;colorConvertFlags(), textureGL-&gt;size(), targetRect, modelViewMatrix, opacity);
109         return;
110     }
111 
112     if (m_extraFlags &amp; TextureMapperGL::ShouldNotBlend) {
113         ASSERT(!m_texture);
114         if (m_holePunchClient)
115             m_holePunchClient-&gt;setVideoRectangle(enclosingIntRect(modelViewMatrix.mapRect(targetRect)));
116         texmapGL.drawSolidColor(targetRect, modelViewMatrix, Color(0, 0, 0, 0), false);
117         return;
118     }
119 
<a name="7" id="anc7"></a><span class="line-modified">120 #if USE(GSTREAMER_GL)</span>
<span class="line-modified">121     if (m_unmanagedBufferDataHolder)</span>
<span class="line-added">122         m_unmanagedBufferDataHolder-&gt;waitForCPUSync();</span>
<span class="line-added">123 #endif // USE(GSTREAMER_GL)</span>
<span class="line-added">124 </span>
<span class="line-added">125     WTF::switchOn(m_variant,</span>
<span class="line-added">126         [&amp;](const RGBTexture&amp; texture) {</span>
<span class="line-added">127             ASSERT(texture.id);</span>
<span class="line-added">128             texmapGL.drawTexture(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">129         },</span>
<span class="line-added">130         [&amp;](const YUVTexture&amp; texture) {</span>
<span class="line-added">131             switch (texture.numberOfPlanes) {</span>
<span class="line-added">132             case 1:</span>
<span class="line-added">133                 ASSERT(texture.yuvPlane[0] == texture.yuvPlane[1] &amp;&amp; texture.yuvPlane[1] == texture.yuvPlane[2]);</span>
<span class="line-added">134                 ASSERT(texture.yuvPlaneOffset[0] == 2 &amp;&amp; texture.yuvPlaneOffset[1] == 1 &amp;&amp; !texture.yuvPlaneOffset[2]);</span>
<span class="line-added">135                 texmapGL.drawTexturePackedYUV(texture.planes[texture.yuvPlane[0]],</span>
<span class="line-added">136                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">137                 break;</span>
<span class="line-added">138             case 2:</span>
<span class="line-added">139                 ASSERT(!texture.yuvPlaneOffset[0]);</span>
<span class="line-added">140                 texmapGL.drawTextureSemiPlanarYUV(std::array&lt;GLuint, 2&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]] }, !!texture.yuvPlaneOffset[1],</span>
<span class="line-added">141                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">142                 break;</span>
<span class="line-added">143             case 3:</span>
<span class="line-added">144                 ASSERT(!texture.yuvPlaneOffset[0] &amp;&amp; !texture.yuvPlaneOffset[1] &amp;&amp; !texture.yuvPlaneOffset[2]);</span>
<span class="line-added">145                 texmapGL.drawTexturePlanarYUV(std::array&lt;GLuint, 3&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]], texture.planes[texture.yuvPlane[2]] },</span>
<span class="line-added">146                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">147                 break;</span>
<span class="line-added">148             }</span>
<span class="line-added">149         },</span>
<span class="line-added">150         [&amp;](const ExternalOESTexture&amp; texture) {</span>
<span class="line-added">151             ASSERT(texture.id);</span>
<span class="line-added">152             texmapGL.drawTextureExternalOES(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);</span>
<span class="line-added">153         });</span>
154 }
155 
156 } // namespace WebCore
157 
158 #endif // USE(COORDINATED_GRAPHICS)
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
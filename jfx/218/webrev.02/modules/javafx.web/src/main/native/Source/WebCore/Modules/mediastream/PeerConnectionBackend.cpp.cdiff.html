<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OverconstrainedErrorEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PeerConnectionBackend.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/PeerConnectionBackend.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;PeerConnectionBackend.h&quot;
  
  #if ENABLE(WEB_RTC)
  
  #include &quot;EventNames.h&quot;
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;JSRTCSessionDescription.h&quot;
  #include &quot;LibWebRTCCertificateGenerator.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;RTCIceCandidate.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,78 ***</span>
      , m_logIdentifier(peerConnection.logIdentifier())
  #endif
  {
  }
  
  void PeerConnectionBackend::createOffer(RTCOfferOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
  {
      ASSERT(!m_offerAnswerPromise);
      ASSERT(!m_peerConnection.isClosed());
  
<span class="line-modified">!     m_offerAnswerPromise = WTFMove(promise);</span>
      doCreateOffer(WTFMove(options));
  }
  
  void PeerConnectionBackend::createOfferSucceeded(String&amp;&amp; sdp)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer succeeded:\n&quot;, sdp);
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_offerAnswerPromise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Offer, filterSDP(WTFMove(sdp)) });</span>
<span class="line-modified">!     m_offerAnswerPromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::createOfferFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer failed:&quot;, exception.message());
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_offerAnswerPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     m_offerAnswerPromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::createAnswer(RTCAnswerOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
  {
      ASSERT(!m_offerAnswerPromise);
      ASSERT(!m_peerConnection.isClosed());
  
<span class="line-modified">!     m_offerAnswerPromise = WTFMove(promise);</span>
      doCreateAnswer(WTFMove(options));
  }
  
  void PeerConnectionBackend::createAnswerSucceeded(String&amp;&amp; sdp)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer succeeded:\n&quot;, sdp);
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_offerAnswerPromise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Answer, WTFMove(sdp) });</span>
<span class="line-modified">!     m_offerAnswerPromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::createAnswerFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer failed:&quot;, exception.message());
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_offerAnswerPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     m_offerAnswerPromise = WTF::nullopt;</span>
  }
  
  static inline bool isLocalDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
  {
      switch (state) {
<span class="line-new-header">--- 81,84 ---</span>
      , m_logIdentifier(peerConnection.logIdentifier())
  #endif
  {
  }
  
<span class="line-added">+ PeerConnectionBackend::~PeerConnectionBackend() = default;</span>
<span class="line-added">+ </span>
  void PeerConnectionBackend::createOffer(RTCOfferOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
  {
      ASSERT(!m_offerAnswerPromise);
      ASSERT(!m_peerConnection.isClosed());
  
<span class="line-modified">!     m_offerAnswerPromise = WTF::makeUnique&lt;PeerConnection::SessionDescriptionPromise&gt;(WTFMove(promise));</span>
      doCreateOffer(WTFMove(options));
  }
  
  void PeerConnectionBackend::createOfferSucceeded(String&amp;&amp; sdp)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer succeeded:\n&quot;, sdp);
  
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = filterSDP(WTFMove(sdp))]() mutable {</span>
<span class="line-modified">!         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         promise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Offer, sdp });</span>
<span class="line-added">+     });</span>
  }
  
  void PeerConnectionBackend::createOfferFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create offer failed:&quot;, exception.message());
  
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-modified">!         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-added">+     });</span>
  }
  
  void PeerConnectionBackend::createAnswer(RTCAnswerOptions&amp;&amp; options, PeerConnection::SessionDescriptionPromise&amp;&amp; promise)
  {
      ASSERT(!m_offerAnswerPromise);
      ASSERT(!m_peerConnection.isClosed());
  
<span class="line-modified">!     m_offerAnswerPromise = WTF::makeUnique&lt;PeerConnection::SessionDescriptionPromise&gt;(WTFMove(promise));</span>
      doCreateAnswer(WTFMove(options));
  }
  
  void PeerConnectionBackend::createAnswerSucceeded(String&amp;&amp; sdp)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer succeeded:\n&quot;, sdp);
  
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), sdp = WTFMove(sdp)]() mutable {</span>
<span class="line-modified">!         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         promise-&gt;resolve(RTCSessionDescription::Init { RTCSdpType::Answer, sdp });</span>
<span class="line-added">+     });</span>
  }
  
  void PeerConnectionBackend::createAnswerFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Create answer failed:&quot;, exception.message());
  
      ASSERT(m_offerAnswerPromise);
<span class="line-modified">!     m_peerConnection.doTask([this, promise = WTFMove(m_offerAnswerPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-modified">!         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-added">+     });</span>
  }
  
  static inline bool isLocalDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
  {
      switch (state) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 178,40 ***</span>
      if (!isLocalDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
          promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
          return;
      }
  
<span class="line-modified">!     m_setDescriptionPromise = WTFMove(promise);</span>
      doSetLocalDescription(sessionDescription);
  }
  
  void PeerConnectionBackend::setLocalDescriptionSucceeded()
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER);
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_setDescriptionPromise);
  
<span class="line-modified">!     m_setDescriptionPromise-&gt;resolve();</span>
<span class="line-modified">!     m_setDescriptionPromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::setLocalDescriptionFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Set local description failed:&quot;, exception.message());
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_setDescriptionPromise);
  
<span class="line-modified">!     m_setDescriptionPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     m_setDescriptionPromise = WTF::nullopt;</span>
  }
  
  static inline bool isRemoteDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
  {
      switch (state) {
<span class="line-new-header">--- 185,40 ---</span>
      if (!isLocalDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
          promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
          return;
      }
  
<span class="line-modified">!     m_setDescriptionPromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
      doSetLocalDescription(sessionDescription);
  }
  
  void PeerConnectionBackend::setLocalDescriptionSucceeded()
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER);
  
      ASSERT(m_setDescriptionPromise);
<span class="line-added">+     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise)]() mutable {</span>
<span class="line-added">+         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         promise-&gt;resolve();</span>
<span class="line-modified">!     });</span>
  }
  
  void PeerConnectionBackend::setLocalDescriptionFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Set local description failed:&quot;, exception.message());
  
      ASSERT(m_setDescriptionPromise);
<span class="line-added">+     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">+         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     });</span>
  }
  
  static inline bool isRemoteDescriptionTypeValidForState(RTCSdpType type, RTCSignalingState state)
  {
      switch (state) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,56 ***</span>
      if (!isRemoteDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
          promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
          return;
      }
  
<span class="line-modified">!     m_setDescriptionPromise = WTFMove(promise);</span>
      doSetRemoteDescription(sessionDescription);
  }
  
  void PeerConnectionBackend::setRemoteDescriptionSucceeded()
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description succeeded&quot;);
  
<span class="line-modified">!     ASSERT(!m_peerConnection.isClosed());</span>
<span class="line-removed">- </span>
      auto events = WTFMove(m_pendingTrackEvents);
      for (auto&amp; event : events) {
          auto&amp; track = event.track.get();
  
<span class="line-modified">!         m_peerConnection.fireEvent(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));</span>
  
          if (m_peerConnection.isClosed())
              return;
  
          // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.
          track.source().setMuted(false);
      }
  
<span class="line-modified">!     if (m_peerConnection.isClosed())</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">! </span>
<span class="line-removed">-     ASSERT(m_setDescriptionPromise);</span>
  
<span class="line-modified">!     m_setDescriptionPromise-&gt;resolve();</span>
<span class="line-modified">!     m_setDescriptionPromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::setRemoteDescriptionFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description failed:&quot;, exception.message());
  
      ASSERT(m_pendingTrackEvents.isEmpty());
      m_pendingTrackEvents.clear();
  
<span class="line-removed">-     ASSERT(!m_peerConnection.isClosed());</span>
      ASSERT(m_setDescriptionPromise);
  
<span class="line-modified">!     m_setDescriptionPromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     m_setDescriptionPromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::addPendingTrackEvent(PendingTrackEvent&amp;&amp; event)
  {
      ASSERT(!m_peerConnection.isClosed());
<span class="line-new-header">--- 245,57 ---</span>
      if (!isRemoteDescriptionTypeValidForState(sessionDescription.type(), m_peerConnection.signalingState())) {
          promise.reject(InvalidStateError, &quot;Description type incompatible with current signaling state&quot;);
          return;
      }
  
<span class="line-modified">!     m_setDescriptionPromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
      doSetRemoteDescription(sessionDescription);
  }
  
  void PeerConnectionBackend::setRemoteDescriptionSucceeded()
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description succeeded&quot;);
<span class="line-added">+     ASSERT(m_setDescriptionPromise);</span>
  
<span class="line-modified">!     auto promise = WTFMove(m_setDescriptionPromise);</span>
      auto events = WTFMove(m_pendingTrackEvents);
      for (auto&amp; event : events) {
          auto&amp; track = event.track.get();
  
<span class="line-modified">!         m_peerConnection.dispatchEventWhenFeasible(RTCTrackEvent::create(eventNames().trackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(event.receiver), WTFMove(event.track), WTFMove(event.streams), WTFMove(event.transceiver)));</span>
  
          if (m_peerConnection.isClosed())
              return;
  
          // FIXME: As per spec, we should set muted to &#39;false&#39; when starting to receive the content from network.
          track.source().setMuted(false);
      }
  
<span class="line-modified">!     m_peerConnection.doTask([this, promise = WTFMove(promise)]() mutable {</span>
<span class="line-modified">!         if (m_peerConnection.isClosed())</span>
<span class="line-modified">!             return;</span>
  
<span class="line-modified">!         promise-&gt;resolve();</span>
<span class="line-modified">!     });</span>
  }
  
  void PeerConnectionBackend::setRemoteDescriptionFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Set remote description failed:&quot;, exception.message());
  
      ASSERT(m_pendingTrackEvents.isEmpty());
      m_pendingTrackEvents.clear();
  
      ASSERT(m_setDescriptionPromise);
<span class="line-added">+     m_peerConnection.doTask([this, promise = WTFMove(m_setDescriptionPromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">+         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     });</span>
  }
  
  void PeerConnectionBackend::addPendingTrackEvent(PendingTrackEvent&amp;&amp; event)
  {
      ASSERT(!m_peerConnection.isClosed());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 317,47 ***</span>
      // FIXME: As per https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addicecandidate(), this check should be done before enqueuing the task.
      if (iceCandidate-&gt;sdpMid().isNull() &amp;&amp; !iceCandidate-&gt;sdpMLineIndex()) {
          promise.reject(Exception { TypeError, &quot;Trying to add a candidate that is missing both sdpMid and sdpMLineIndex&quot;_s });
          return;
      }
<span class="line-modified">!     m_addIceCandidatePromise = WTFMove(promise);</span>
      doAddIceCandidate(*iceCandidate);
  }
  
  void PeerConnectionBackend::addIceCandidateSucceeded()
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate succeeded&quot;);
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_addIceCandidatePromise);
  
<span class="line-modified">!     m_addIceCandidatePromise-&gt;resolve();</span>
<span class="line-modified">!     m_addIceCandidatePromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::addIceCandidateFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate failed:&quot;, exception.message());
  
<span class="line-removed">-     if (m_peerConnection.isClosed())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      ASSERT(m_addIceCandidatePromise);
  
<span class="line-modified">!     m_addIceCandidatePromise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     m_addIceCandidatePromise = WTF::nullopt;</span>
  }
  
  void PeerConnectionBackend::fireICECandidateEvent(RefPtr&lt;RTCIceCandidate&gt;&amp;&amp; candidate, String&amp;&amp; serverURL)
  {
      ASSERT(isMainThread());
  
<span class="line-modified">!     m_peerConnection.fireEvent(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));</span>
  }
  
  void PeerConnectionBackend::enableICECandidateFiltering()
  {
      m_shouldFilterICECandidates = true;
<span class="line-new-header">--- 325,47 ---</span>
      // FIXME: As per https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addicecandidate(), this check should be done before enqueuing the task.
      if (iceCandidate-&gt;sdpMid().isNull() &amp;&amp; !iceCandidate-&gt;sdpMLineIndex()) {
          promise.reject(Exception { TypeError, &quot;Trying to add a candidate that is missing both sdpMid and sdpMLineIndex&quot;_s });
          return;
      }
<span class="line-modified">!     m_addIceCandidatePromise = WTF::makeUnique&lt;DOMPromiseDeferred&lt;void&gt;&gt;(WTFMove(promise));</span>
      doAddIceCandidate(*iceCandidate);
  }
  
  void PeerConnectionBackend::addIceCandidateSucceeded()
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate succeeded&quot;);
  
      ASSERT(m_addIceCandidatePromise);
<span class="line-added">+     m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise)]() mutable {</span>
<span class="line-added">+         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         promise-&gt;resolve();</span>
<span class="line-modified">!     });</span>
  }
  
  void PeerConnectionBackend::addIceCandidateFailed(Exception&amp;&amp; exception)
  {
      ASSERT(isMainThread());
      ALWAYS_LOG(LOGIDENTIFIER, &quot;Adding ice candidate failed:&quot;, exception.message());
  
      ASSERT(m_addIceCandidatePromise);
<span class="line-added">+     m_peerConnection.doTask([this, promise = WTFMove(m_addIceCandidatePromise), exception = WTFMove(exception)]() mutable {</span>
<span class="line-added">+         if (m_peerConnection.isClosed())</span>
<span class="line-added">+             return;</span>
  
<span class="line-modified">!         promise-&gt;reject(WTFMove(exception));</span>
<span class="line-modified">!     });</span>
  }
  
  void PeerConnectionBackend::fireICECandidateEvent(RefPtr&lt;RTCIceCandidate&gt;&amp;&amp; candidate, String&amp;&amp; serverURL)
  {
      ASSERT(isMainThread());
  
<span class="line-modified">!     m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, WTFMove(candidate), WTFMove(serverURL)));</span>
  }
  
  void PeerConnectionBackend::enableICECandidateFiltering()
  {
      m_shouldFilterICECandidates = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,13 ***</span>
          return WTFMove(sdp);
  
      StringBuilder filteredSDP;
      sdp.split(&#39;\n&#39;, [&amp;filteredSDP](StringView line) {
          if (line.startsWith(&quot;c=IN IP4&quot;))
<span class="line-modified">!             filteredSDP.append(&quot;c=IN IP4 0.0.0.0&quot;);</span>
          else if (line.startsWith(&quot;c=IN IP6&quot;))
<span class="line-modified">!             filteredSDP.append(&quot;c=IN IP6 ::&quot;);</span>
          else if (!line.startsWith(&quot;a=candidate&quot;))
              filteredSDP.append(line);
          else if (line.find(&quot; host &quot;, 11) == notFound)
              filteredSDP.append(filterICECandidate(line.toString()));
          else
<span class="line-new-header">--- 419,13 ---</span>
          return WTFMove(sdp);
  
      StringBuilder filteredSDP;
      sdp.split(&#39;\n&#39;, [&amp;filteredSDP](StringView line) {
          if (line.startsWith(&quot;c=IN IP4&quot;))
<span class="line-modified">!             filteredSDP.append(&quot;c=IN IP4 0.0.0.0\r&quot;);</span>
          else if (line.startsWith(&quot;c=IN IP6&quot;))
<span class="line-modified">!             filteredSDP.append(&quot;c=IN IP6 ::\r&quot;);</span>
          else if (!line.startsWith(&quot;a=candidate&quot;))
              filteredSDP.append(line);
          else if (line.find(&quot; host &quot;, 11) == notFound)
              filteredSDP.append(filterICECandidate(line.toString()));
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,27 ***</span>
      m_finishedGatheringCandidates = true;
  
      if (m_waitingForMDNSRegistration)
          return;
  
<span class="line-modified">!     m_peerConnection.fireEvent(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));</span>
      m_peerConnection.updateIceGatheringState(RTCIceGatheringState::Complete);
      m_pendingICECandidates.clear();
  }
  
  void PeerConnectionBackend::registerMDNSName(const String&amp; ipAddress)
  {
      ++m_waitingForMDNSRegistration;
      auto&amp; document = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext());
      auto&amp; provider = document.page()-&gt;libWebRTCProvider();
<span class="line-modified">!     provider.registerMDNSName(document.sessionID(), document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&amp;&amp; result) {</span>
          if (peerConnection-&gt;isStopped())
              return;
  
          --m_waitingForMDNSRegistration;
          if (!result.has_value()) {
<span class="line-modified">!             m_peerConnection.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString(&quot;MDNS registration of a host candidate failed with error&quot;, (unsigned)result.error()));</span>
              return;
          }
  
          this-&gt;finishedRegisteringMDNSName(ipAddress, result.value());
      });
<span class="line-new-header">--- 465,32 ---</span>
      m_finishedGatheringCandidates = true;
  
      if (m_waitingForMDNSRegistration)
          return;
  
<span class="line-modified">!     m_peerConnection.dispatchEventWhenFeasible(RTCPeerConnectionIceEvent::create(Event::CanBubble::No, Event::IsCancelable::No, nullptr, { }));</span>
      m_peerConnection.updateIceGatheringState(RTCIceGatheringState::Complete);
      m_pendingICECandidates.clear();
  }
  
<span class="line-added">+ void PeerConnectionBackend::endOfIceCandidates(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     promise.resolve();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void PeerConnectionBackend::registerMDNSName(const String&amp; ipAddress)
  {
      ++m_waitingForMDNSRegistration;
      auto&amp; document = downcast&lt;Document&gt;(*m_peerConnection.scriptExecutionContext());
      auto&amp; provider = document.page()-&gt;libWebRTCProvider();
<span class="line-modified">!     provider.registerMDNSName(document.identifier().toUInt64(), ipAddress, [peerConnection = makeRef(m_peerConnection), this, ipAddress] (LibWebRTCProvider::MDNSNameOrError&amp;&amp; result) {</span>
          if (peerConnection-&gt;isStopped())
              return;
  
          --m_waitingForMDNSRegistration;
          if (!result.has_value()) {
<span class="line-modified">!             m_peerConnection.scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Warning, makeString(&quot;MDNS registration of a host candidate failed with error &quot;, (unsigned)result.error()));</span>
              return;
          }
  
          this-&gt;finishedRegisteringMDNSName(ipAddress, result.value());
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,19 ***</span>
  {
      ASSERT(isMainThread());
  
      if (newSignalingState != m_peerConnection.signalingState()) {
          m_peerConnection.setSignalingState(newSignalingState);
<span class="line-modified">!         m_peerConnection.fireEvent(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
      }
  }
  
  void PeerConnectionBackend::stop()
  {
<span class="line-modified">!     m_offerAnswerPromise = WTF::nullopt;</span>
<span class="line-modified">!     m_setDescriptionPromise = WTF::nullopt;</span>
<span class="line-modified">!     m_addIceCandidatePromise = WTF::nullopt;</span>
  
      m_pendingTrackEvents.clear();
  
      doStop();
  }
<span class="line-new-header">--- 519,19 ---</span>
  {
      ASSERT(isMainThread());
  
      if (newSignalingState != m_peerConnection.signalingState()) {
          m_peerConnection.setSignalingState(newSignalingState);
<span class="line-modified">!         m_peerConnection.dispatchEventWhenFeasible(Event::create(eventNames().signalingstatechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
      }
  }
  
  void PeerConnectionBackend::stop()
  {
<span class="line-modified">!     m_offerAnswerPromise = nullptr;</span>
<span class="line-modified">!     m_setDescriptionPromise = nullptr;</span>
<span class="line-modified">!     m_addIceCandidatePromise = nullptr;</span>
  
      m_pendingTrackEvents.clear();
  
      doStop();
  }
</pre>
<center><a href="OverconstrainedErrorEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PeerConnectionBackend.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
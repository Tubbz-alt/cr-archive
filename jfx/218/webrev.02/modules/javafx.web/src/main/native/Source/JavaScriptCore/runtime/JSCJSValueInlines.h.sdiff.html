<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValueInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCJSValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCPtrTag.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCJSValueInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  26 #pragma once
  27 
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;ExceptionHelpers.h&quot;
  31 #include &quot;Identifier.h&quot;
  32 #include &quot;InternalFunction.h&quot;
  33 #include &quot;JSBigInt.h&quot;
  34 #include &quot;JSCJSValue.h&quot;
  35 #include &quot;JSCellInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSObject.h&quot;
  38 #include &quot;JSProxy.h&quot;
  39 #include &quot;JSStringInlines.h&quot;
  40 #include &quot;MathCommon.h&quot;
  41 #include &lt;wtf/Variant.h&gt;
  42 #include &lt;wtf/text/StringImpl.h&gt;
  43 
  44 namespace JSC {
  45 
<span class="line-modified">  46 ALWAYS_INLINE int32_t JSValue::toInt32(ExecState* exec) const</span>
  47 {
  48     if (isInt32())
  49         return asInt32();
<span class="line-modified">  50     return JSC::toInt32(toNumber(exec));</span>
  51 }
  52 
<span class="line-modified">  53 inline uint32_t JSValue::toUInt32(ExecState* exec) const</span>
  54 {
  55     // See comment on JSC::toUInt32, in JSCJSValue.h.
<span class="line-modified">  56     return toInt32(exec);</span>
  57 }
  58 
<span class="line-modified">  59 inline uint32_t JSValue::toIndex(ExecState* exec, const char* errorName) const</span>
  60 {
<span class="line-modified">  61     VM&amp; vm = exec-&gt;vm();</span>
  62     auto scope = DECLARE_THROW_SCOPE(vm);
  63 
<span class="line-modified">  64     double d = toNumber(exec);</span>
  65     RETURN_IF_EXCEPTION(scope, 0);
  66     if (d &lt;= -1) {
<span class="line-modified">  67         throwException(exec, scope, createRangeError(exec, makeString(errorName, &quot; cannot be negative&quot;)));</span>
  68         return 0;
  69     }
  70     if (d &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
<span class="line-modified">  71         throwException(exec, scope, createRangeError(exec, makeString(errorName, &quot; too large&quot;)));</span>
  72         return 0;
  73     }
  74 
  75     if (isInt32())
  76         return asInt32();
  77     RELEASE_AND_RETURN(scope, JSC::toInt32(d));
  78 }
  79 
  80 inline bool JSValue::isUInt32() const
  81 {
  82     return isInt32() &amp;&amp; asInt32() &gt;= 0;
  83 }
  84 
  85 inline uint32_t JSValue::asUInt32() const
  86 {
  87     ASSERT(isUInt32());
  88     return asInt32();
  89 }
  90 
  91 inline double JSValue::asNumber() const
</pre>
<hr />
<pre>
 450 }
 451 
 452 inline JSValue::JSValue(JSUndefinedTag)
 453 {
 454     u.asInt64 = ValueUndefined;
 455 }
 456 
 457 inline JSValue::JSValue(JSTrueTag)
 458 {
 459     u.asInt64 = ValueTrue;
 460 }
 461 
 462 inline JSValue::JSValue(JSFalseTag)
 463 {
 464     u.asInt64 = ValueFalse;
 465 }
 466 
 467 inline bool JSValue::isUndefinedOrNull() const
 468 {
 469     // Undefined and null share the same value, bar the &#39;undefined&#39; bit in the extended tag.
<span class="line-modified"> 470     return (u.asInt64 &amp; ~TagBitUndefined) == ValueNull;</span>
 471 }
 472 
 473 inline bool JSValue::isBoolean() const
 474 {
 475     return (u.asInt64 &amp; ~1) == ValueFalse;
 476 }
 477 
 478 inline bool JSValue::isCell() const
 479 {
<span class="line-modified"> 480     return !(u.asInt64 &amp; TagMask);</span>
 481 }
 482 
 483 inline bool JSValue::isInt32() const
 484 {
<span class="line-modified"> 485     return (u.asInt64 &amp; TagTypeNumber) == TagTypeNumber;</span>
 486 }
 487 
 488 inline int64_t reinterpretDoubleToInt64(double value)
 489 {
 490     return bitwise_cast&lt;int64_t&gt;(value);
 491 }
 492 inline double reinterpretInt64ToDouble(int64_t value)
 493 {
 494     return bitwise_cast&lt;double&gt;(value);
 495 }
 496 
 497 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 498 {
 499     ASSERT(!isImpureNaN(d));
<span class="line-modified"> 500     u.asInt64 = reinterpretDoubleToInt64(d) + DoubleEncodeOffset;</span>
 501 }
 502 
 503 inline JSValue::JSValue(int i)
 504 {
<span class="line-modified"> 505     u.asInt64 = TagTypeNumber | static_cast&lt;uint32_t&gt;(i);</span>
 506 }
 507 
 508 inline double JSValue::asDouble() const
 509 {
 510     ASSERT(isDouble());
<span class="line-modified"> 511     return reinterpretInt64ToDouble(u.asInt64 - DoubleEncodeOffset);</span>
 512 }
 513 
 514 inline bool JSValue::isNumber() const
 515 {
<span class="line-modified"> 516     return u.asInt64 &amp; TagTypeNumber;</span>
 517 }
 518 
 519 ALWAYS_INLINE JSCell* JSValue::asCell() const
 520 {
 521     ASSERT(isCell());
 522     return u.ptr;
 523 }
 524 
 525 #endif // USE(JSVALUE64)
 526 
 527 inline int64_t tryConvertToInt52(double number)
 528 {
 529     if (number != number)
 530         return JSValue::notInt52;
 531 #if OS(WINDOWS) &amp;&amp; CPU(X86)
 532     // The VS Compiler for 32-bit builds generates a floating point error when attempting to cast
 533     // from an infinity to a 64-bit integer. We leave this routine with the floating point error
 534     // left in a register, causing undefined behavior in later floating point operations.
 535     //
 536     // To avoid this issue, we check for infinity here, and return false in that case.
</pre>
<hr />
<pre>
 621 inline bool JSValue::isPrimitive() const
 622 {
 623     return !isCell() || asCell()-&gt;isString() || asCell()-&gt;isSymbol() || asCell()-&gt;isBigInt();
 624 }
 625 
 626 inline bool JSValue::isGetterSetter() const
 627 {
 628     return isCell() &amp;&amp; asCell()-&gt;isGetterSetter();
 629 }
 630 
 631 inline bool JSValue::isCustomGetterSetter() const
 632 {
 633     return isCell() &amp;&amp; asCell()-&gt;isCustomGetterSetter();
 634 }
 635 
 636 inline bool JSValue::isObject() const
 637 {
 638     return isCell() &amp;&amp; asCell()-&gt;isObject();
 639 }
 640 
<span class="line-modified"> 641 inline bool JSValue::getString(ExecState* exec, String&amp; s) const</span>
 642 {
<span class="line-modified"> 643     return isCell() &amp;&amp; asCell()-&gt;getString(exec, s);</span>
 644 }
 645 
<span class="line-modified"> 646 inline String JSValue::getString(ExecState* exec) const</span>
 647 {
<span class="line-modified"> 648     return isCell() ? asCell()-&gt;getString(exec) : String();</span>
 649 }
 650 
<span class="line-modified"> 651 template &lt;typename Base&gt; String HandleConverter&lt;Base, Unknown&gt;::getString(ExecState* exec) const</span>
 652 {
<span class="line-modified"> 653     return jsValue().getString(exec);</span>
 654 }
 655 
 656 inline JSObject* JSValue::getObject() const
 657 {
 658     return isCell() ? asCell()-&gt;getObject() : 0;
 659 }
 660 
 661 ALWAYS_INLINE bool JSValue::getUInt32(uint32_t&amp; v) const
 662 {
 663     if (isInt32()) {
 664         int32_t i = asInt32();
 665         v = static_cast&lt;uint32_t&gt;(i);
 666         return i &gt;= 0;
 667     }
 668     if (isDouble()) {
 669         double d = asDouble();
 670         v = static_cast&lt;uint32_t&gt;(d);
 671         return v == d;
 672     }
 673     return false;
 674 }
 675 
<span class="line-modified"> 676 ALWAYS_INLINE Identifier JSValue::toPropertyKey(ExecState* exec) const</span>
 677 {
<span class="line-modified"> 678     VM&amp; vm = exec-&gt;vm();</span>
 679     auto scope = DECLARE_THROW_SCOPE(vm);
 680 
 681     if (isString())
<span class="line-modified"> 682         RELEASE_AND_RETURN(scope, asString(*this)-&gt;toIdentifier(exec));</span>
 683 
<span class="line-modified"> 684     JSValue primitive = toPrimitive(exec, PreferString);</span>
 685     RETURN_IF_EXCEPTION(scope, vm.propertyNames-&gt;emptyIdentifier);
 686     if (primitive.isSymbol())
 687         RELEASE_AND_RETURN(scope, Identifier::fromUid(asSymbol(primitive)-&gt;privateName()));
 688 
<span class="line-modified"> 689     auto string = primitive.toString(exec);</span>
 690     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified"> 691     RELEASE_AND_RETURN(scope, string-&gt;toIdentifier(exec));</span>
 692 }
 693 
<span class="line-modified"> 694 inline JSValue JSValue::toPrimitive(ExecState* exec, PreferredPrimitiveType preferredType) const</span>
 695 {
<span class="line-modified"> 696     return isCell() ? asCell()-&gt;toPrimitive(exec, preferredType) : asValue();</span>











 697 }
 698 
<span class="line-modified"> 699 inline PreferredPrimitiveType toPreferredPrimitiveType(ExecState* exec, JSValue value)</span>
 700 {
<span class="line-modified"> 701     VM&amp; vm = exec-&gt;vm();</span>





 702     auto scope = DECLARE_THROW_SCOPE(vm);
 703 
 704     if (!value.isString()) {
<span class="line-modified"> 705         throwTypeError(exec, scope, &quot;Primitive hint is not a string.&quot;_s);</span>
 706         return NoPreference;
 707     }
 708 
<span class="line-modified"> 709     StringImpl* hintString = asString(value)-&gt;value(exec).impl();</span>
 710     RETURN_IF_EXCEPTION(scope, NoPreference);
 711 
 712     if (WTF::equal(hintString, &quot;default&quot;))
 713         return NoPreference;
 714     if (WTF::equal(hintString, &quot;number&quot;))
 715         return PreferNumber;
 716     if (WTF::equal(hintString, &quot;string&quot;))
 717         return PreferString;
 718 
<span class="line-modified"> 719     throwTypeError(exec, scope, &quot;Expected primitive hint to match one of &#39;default&#39;, &#39;number&#39;, &#39;string&#39;.&quot;_s);</span>
 720     return NoPreference;
 721 }
 722 
<span class="line-modified"> 723 inline bool JSValue::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; value)</span>
 724 {
 725     if (isInt32()) {
 726         number = asInt32();
 727         value = *this;
 728         return true;
 729     }
 730     if (isDouble()) {
 731         number = asDouble();
 732         value = *this;
 733         return true;
 734     }
 735     if (isCell())
<span class="line-modified"> 736         return asCell()-&gt;getPrimitiveNumber(exec, number, value);</span>
 737     if (isTrue()) {
 738         number = 1.0;
 739         value = *this;
 740         return true;
 741     }
 742     if (isFalse() || isNull()) {
 743         number = 0.0;
 744         value = *this;
 745         return true;
 746     }
 747     ASSERT(isUndefined());
 748     number = PNaN;
 749     value = *this;
 750     return true;
 751 }
 752 
<span class="line-modified"> 753 ALWAYS_INLINE double JSValue::toNumber(ExecState* exec) const</span>
 754 {
 755     if (isInt32())
 756         return asInt32();
 757     if (isDouble())
 758         return asDouble();
<span class="line-modified"> 759     return toNumberSlowCase(exec);</span>
 760 }
 761 
<span class="line-modified"> 762 ALWAYS_INLINE Variant&lt;JSBigInt*, double&gt; JSValue::toNumeric(ExecState* exec) const</span>
 763 {
 764     if (isInt32())
 765         return asInt32();
 766     if (isDouble())
 767         return asDouble();
 768     if (isBigInt())
 769         return asBigInt(*this);
 770 
<span class="line-modified"> 771     VM&amp; vm = exec-&gt;vm();</span>
 772     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 773     JSValue primValue = this-&gt;toPrimitive(exec, PreferNumber);</span>
 774     RETURN_IF_EXCEPTION(scope, 0);
 775     if (primValue.isBigInt())
 776         return asBigInt(primValue);
<span class="line-modified"> 777     double value = primValue.toNumber(exec);</span>
 778     RETURN_IF_EXCEPTION(scope, 0);
 779     return value;
 780 }
 781 
<span class="line-modified"> 782 ALWAYS_INLINE Variant&lt;JSBigInt*, int32_t&gt; JSValue::toBigIntOrInt32(ExecState* exec) const</span>
 783 {
 784     if (isInt32())
 785         return asInt32();
 786     if (isDouble() &amp;&amp; canBeInt32(asDouble()))
 787         return static_cast&lt;int32_t&gt;(asDouble());
 788     if (isBigInt())
 789         return asBigInt(*this);
 790 
<span class="line-modified"> 791     VM&amp; vm = exec-&gt;vm();</span>
 792     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 793     JSValue primValue = this-&gt;toPrimitive(exec, PreferNumber);</span>
 794     RETURN_IF_EXCEPTION(scope, 0);
 795     if (primValue.isBigInt())
 796         return asBigInt(primValue);
<span class="line-modified"> 797     int32_t value = primValue.toInt32(exec);</span>
 798     RETURN_IF_EXCEPTION(scope, 0);
 799     return value;
 800 }
 801 
<span class="line-modified"> 802 inline JSObject* JSValue::toObject(ExecState* exec) const</span>
<span class="line-removed"> 803 {</span>
<span class="line-removed"> 804     return isCell() ? asCell()-&gt;toObject(exec, exec-&gt;lexicalGlobalObject()) : toObjectSlowCase(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed"> 805 }</span>
<span class="line-removed"> 806 </span>
<span class="line-removed"> 807 inline JSObject* JSValue::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
 808 {
<span class="line-modified"> 809     return isCell() ? asCell()-&gt;toObject(exec, globalObject) : toObjectSlowCase(exec, globalObject);</span>
 810 }
 811 
 812 inline bool JSValue::isFunction(VM&amp; vm) const
 813 {
 814     if (!isCell())
 815         return false;
 816     return asCell()-&gt;isFunction(vm);
 817 }
 818 
 819 inline bool JSValue::isCallable(VM&amp; vm, CallType&amp; callType, CallData&amp; callData) const
 820 {
 821     if (!isCell())
 822         return false;
 823     return asCell()-&gt;isCallable(vm, callType, callData);
 824 }
 825 
 826 inline bool JSValue::isConstructor(VM&amp; vm) const
 827 {
 828     if (!isCell())
 829         return false;
</pre>
<hr />
<pre>
 837     return asCell()-&gt;isConstructor(vm, constructType, constructData);
 838 }
 839 
 840 // this method is here to be after the inline declaration of JSCell::inherits
 841 inline bool JSValue::inherits(VM&amp; vm, const ClassInfo* classInfo) const
 842 {
 843     return isCell() &amp;&amp; asCell()-&gt;inherits(vm, classInfo);
 844 }
 845 
 846 template&lt;typename Target&gt;
 847 inline bool JSValue::inherits(VM&amp; vm) const
 848 {
 849     return isCell() &amp;&amp; asCell()-&gt;inherits&lt;Target&gt;(vm);
 850 }
 851 
 852 inline const ClassInfo* JSValue::classInfoOrNull(VM&amp; vm) const
 853 {
 854     return isCell() ? asCell()-&gt;classInfo(vm) : nullptr;
 855 }
 856 
<span class="line-modified"> 857 inline JSValue JSValue::toThis(ExecState* exec, ECMAMode ecmaMode) const</span>
 858 {
<span class="line-modified"> 859     return isCell() ? asCell()-&gt;methodTable(exec-&gt;vm())-&gt;toThis(asCell(), exec, ecmaMode) : toThisSlowCase(exec, ecmaMode);</span>
 860 }
 861 
<span class="line-modified"> 862 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, PropertyName propertyName) const</span>
 863 {
 864     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 865     return get(exec, propertyName, slot);</span>
 866 }
 867 
<span class="line-modified"> 868 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const</span>
 869 {
<span class="line-modified"> 870     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified"> 871     bool hasSlot = getPropertySlot(exec, propertyName, slot);</span>
 872     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 873     if (!hasSlot)
 874         return jsUndefined();
<span class="line-modified"> 875     RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
 876 }
 877 
 878 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified"> 879 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, CallbackWhenNoException callback) const</span>
 880 {
 881     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 882     return getPropertySlot(exec, propertyName, slot, callback);</span>
 883 }
 884 
 885 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified"> 886 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
 887 {
<span class="line-modified"> 888     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified"> 889     bool found = getPropertySlot(exec, propertyName, slot);</span>
 890     RETURN_IF_EXCEPTION(scope, { });
 891     RELEASE_AND_RETURN(scope, callback(found, slot));
 892 }
 893 
<span class="line-modified"> 894 ALWAYS_INLINE bool JSValue::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const</span>
 895 {
<span class="line-modified"> 896     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
 897     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 898     // and if it&#39;s a string there are special properties to check first.
 899     JSObject* object;
 900     if (UNLIKELY(!isObject())) {
 901         if (isString()) {
<span class="line-modified"> 902             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot);</span>
 903             RETURN_IF_EXCEPTION(scope, false);
 904             if (hasProperty)
 905                 return true;
 906         }
<span class="line-modified"> 907         object = synthesizePrototype(exec);</span>
 908         EXCEPTION_ASSERT(!!scope.exception() == !object);
 909         if (UNLIKELY(!object))
 910             return false;
 911     } else
 912         object = asObject(asCell());
 913 
<span class="line-modified"> 914     RELEASE_AND_RETURN(scope, object-&gt;getPropertySlot(exec, propertyName, slot));</span>
 915 }
 916 
<span class="line-modified"> 917 ALWAYS_INLINE bool JSValue::getOwnPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot) const</span>
 918 {
 919     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 920     // and if it&#39;s a string there are special properties to check first.
<span class="line-modified"> 921     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
 922     if (UNLIKELY(!isObject())) {
 923         if (isString())
<span class="line-modified"> 924             RELEASE_AND_RETURN(scope, asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot));</span>
 925 
 926         if (isUndefinedOrNull())
<span class="line-modified"> 927             throwException(exec, scope, createNotAnObjectError(exec, *this));</span>
 928         return false;
 929     }
<span class="line-modified"> 930     RELEASE_AND_RETURN(scope, asObject(asCell())-&gt;getOwnPropertySlotInline(exec, propertyName, slot));</span>
 931 }
 932 
<span class="line-modified"> 933 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, unsigned propertyName) const</span>
 934 {
 935     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 936     return get(exec, propertyName, slot);</span>
 937 }
 938 
<span class="line-modified"> 939 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot) const</span>
 940 {
<span class="line-modified"> 941     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
 942     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 943     // and if it&#39;s a string there are special properties to check first.
 944     JSObject* object;
 945     if (UNLIKELY(!isObject())) {
 946         if (isString()) {
<span class="line-modified"> 947             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(exec, propertyName, slot);</span>
 948             RETURN_IF_EXCEPTION(scope, { });
 949             if (hasProperty)
<span class="line-modified"> 950                 RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
 951         }
<span class="line-modified"> 952         object = synthesizePrototype(exec);</span>
 953         EXCEPTION_ASSERT(!!scope.exception() == !object);
 954         if (UNLIKELY(!object))
 955             return JSValue();
 956     } else
 957         object = asObject(asCell());
 958 
<span class="line-modified"> 959     bool hasSlot = object-&gt;getPropertySlot(exec, propertyName, slot);</span>
 960     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 961     if (!hasSlot)
 962         return jsUndefined();
<span class="line-modified"> 963     RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
 964 }
 965 
<span class="line-modified"> 966 ALWAYS_INLINE JSValue JSValue::get(ExecState* exec, uint64_t propertyName) const</span>
 967 {
 968     if (LIKELY(propertyName &lt;= std::numeric_limits&lt;unsigned&gt;::max()))
<span class="line-modified"> 969         return get(exec, static_cast&lt;unsigned&gt;(propertyName));</span>
<span class="line-modified"> 970     return get(exec, Identifier::from(exec-&gt;vm(), static_cast&lt;double&gt;(propertyName)));</span>
 971 }
 972 
<span class="line-modified"> 973 inline bool JSValue::put(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 974 {
 975     if (UNLIKELY(!isCell()))
<span class="line-modified"> 976         return putToPrimitive(exec, propertyName, value, slot);</span>
 977 
<span class="line-modified"> 978     return asCell()-&gt;methodTable(exec-&gt;vm())-&gt;put(asCell(), exec, propertyName, value, slot);</span>
 979 }
 980 
<span class="line-modified"> 981 ALWAYS_INLINE bool JSValue::putInline(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 982 {
 983     if (UNLIKELY(!isCell()))
<span class="line-modified"> 984         return putToPrimitive(exec, propertyName, value, slot);</span>
<span class="line-modified"> 985     return asCell()-&gt;putInline(exec, propertyName, value, slot);</span>
 986 }
 987 
<span class="line-modified"> 988 inline bool JSValue::putByIndex(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 989 {
 990     if (UNLIKELY(!isCell()))
<span class="line-modified"> 991         return putToPrimitiveByIndex(exec, propertyName, value, shouldThrow);</span>
 992 
<span class="line-modified"> 993     return asCell()-&gt;methodTable(exec-&gt;vm())-&gt;putByIndex(asCell(), exec, propertyName, value, shouldThrow);</span>
 994 }
 995 
 996 inline Structure* JSValue::structureOrNull() const
 997 {
 998     if (isCell())
 999         return asCell()-&gt;structure();
1000     return nullptr;
1001 }
1002 
1003 inline JSValue JSValue::structureOrUndefined() const
1004 {
1005     if (isCell())
1006         return JSValue(asCell()-&gt;structure());
1007     return jsUndefined();
1008 }
1009 
1010 // ECMA 11.9.3
<span class="line-modified">1011 inline bool JSValue::equal(ExecState* exec, JSValue v1, JSValue v2)</span>
1012 {
1013     if (v1.isInt32() &amp;&amp; v2.isInt32())
1014         return v1 == v2;
1015 
<span class="line-modified">1016     return equalSlowCase(exec, v1, v2);</span>
1017 }
1018 
<span class="line-modified">1019 ALWAYS_INLINE bool JSValue::equalSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)</span>
1020 {
<span class="line-modified">1021     VM&amp; vm = exec-&gt;vm();</span>
1022     auto scope = DECLARE_THROW_SCOPE(vm);
1023     do {
1024         if (v1.isNumber() &amp;&amp; v2.isNumber())
1025             return v1.asNumber() == v2.asNumber();
1026 
1027         bool s1 = v1.isString();
1028         bool s2 = v2.isString();
1029         if (s1 &amp;&amp; s2)
<span class="line-modified">1030             RELEASE_AND_RETURN(scope, asString(v1)-&gt;equal(exec, asString(v2)));</span>
1031 
1032         if (v1.isBigInt() &amp;&amp; s2) {
<span class="line-modified">1033             JSBigInt* n = JSBigInt::stringToBigInt(exec, asString(v2)-&gt;value(exec));</span>


1034             RETURN_IF_EXCEPTION(scope, false);
1035             if (!n)
1036                 return false;
1037 
1038             v2 = JSValue(n);
1039             continue;
1040         }
1041 
1042         if (s1 &amp;&amp; v2.isBigInt()) {
<span class="line-modified">1043             JSBigInt* n = JSBigInt::stringToBigInt(exec, asString(v1)-&gt;value(exec));</span>


1044             RETURN_IF_EXCEPTION(scope, false);
1045             if (!n)
1046                 return false;
1047 
1048             v1 = JSValue(n);
1049             continue;
1050         }
1051 
1052         if (v1.isUndefinedOrNull()) {
1053             if (v2.isUndefinedOrNull())
1054                 return true;
1055             if (!v2.isCell())
1056                 return false;
<span class="line-modified">1057             return v2.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());</span>
1058         }
1059 
1060         if (v2.isUndefinedOrNull()) {
1061             if (!v1.isCell())
1062                 return false;
<span class="line-modified">1063             return v1.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(exec-&gt;lexicalGlobalObject());</span>
1064         }
1065 
1066         if (v1.isObject()) {
1067             if (v2.isObject())
1068                 return v1 == v2;
<span class="line-modified">1069             JSValue p1 = v1.toPrimitive(exec);</span>
1070             RETURN_IF_EXCEPTION(scope, false);
1071             v1 = p1;
1072             if (v1.isInt32() &amp;&amp; v2.isInt32())
1073                 return v1 == v2;
1074             continue;
1075         }
1076 
1077         if (v2.isObject()) {
<span class="line-modified">1078             JSValue p2 = v2.toPrimitive(exec);</span>
1079             RETURN_IF_EXCEPTION(scope, false);
1080             v2 = p2;
1081             if (v1.isInt32() &amp;&amp; v2.isInt32())
1082                 return v1 == v2;
1083             continue;
1084         }
1085 
1086         bool sym1 = v1.isSymbol();
1087         bool sym2 = v2.isSymbol();
1088         if (sym1 || sym2) {
1089             if (sym1 &amp;&amp; sym2)
1090                 return asSymbol(v1) == asSymbol(v2);
1091             return false;
1092         }
1093 
1094         if (s1 || s2) {
<span class="line-modified">1095             double d1 = v1.toNumber(exec);</span>
1096             RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">1097             double d2 = v2.toNumber(exec);</span>
1098             RETURN_IF_EXCEPTION(scope, false);
1099             return d1 == d2;
1100         }
1101 
1102         if (v1.isBoolean()) {
1103             if (v2.isNumber())
1104                 return static_cast&lt;double&gt;(v1.asBoolean()) == v2.asNumber();
1105             else if (v2.isBigInt()) {
<span class="line-modified">1106                 v1 = JSValue(v1.toNumber(exec));</span>
1107                 continue;
1108             }
1109         } else if (v2.isBoolean()) {
1110             if (v1.isNumber())
1111                 return v1.asNumber() == static_cast&lt;double&gt;(v2.asBoolean());
1112             else if (v1.isBigInt()) {
<span class="line-modified">1113                 v2 = JSValue(v2.toNumber(exec));</span>
1114                 continue;
1115             }
1116         }
1117 
1118         if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1119             return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1120 
1121         if (v1.isBigInt() &amp;&amp; v2.isNumber())
1122             return asBigInt(v1)-&gt;equalsToNumber(v2);
1123 
1124         if (v2.isBigInt() &amp;&amp; v1.isNumber())
1125             return asBigInt(v2)-&gt;equalsToNumber(v1);
1126 
1127         return v1 == v2;
1128     } while (true);
1129 }
1130 
1131 // ECMA 11.9.3
<span class="line-modified">1132 ALWAYS_INLINE bool JSValue::strictEqualSlowCaseInline(ExecState* exec, JSValue v1, JSValue v2)</span>
1133 {
1134     ASSERT(v1.isCell() &amp;&amp; v2.isCell());
1135 
1136     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString())
<span class="line-modified">1137         return asString(v1)-&gt;equal(exec, asString(v2));</span>
1138     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1139         return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1140     return v1 == v2;
1141 }
1142 
<span class="line-modified">1143 inline bool JSValue::strictEqual(ExecState* exec, JSValue v1, JSValue v2)</span>
1144 {
1145     if (v1.isInt32() &amp;&amp; v2.isInt32())
1146         return v1 == v2;
1147 
1148     if (v1.isNumber() &amp;&amp; v2.isNumber())
1149         return v1.asNumber() == v2.asNumber();
1150 
1151     if (!v1.isCell() || !v2.isCell())
1152         return v1 == v2;
1153 
<span class="line-modified">1154     return strictEqualSlowCaseInline(exec, v1, v2);</span>
1155 }
1156 
1157 inline int32_t JSValue::asInt32ForArithmetic() const
1158 {
1159     if (isBoolean())
1160         return asBoolean();
1161     return asInt32();
1162 }
1163 
1164 inline TriState JSValue::pureStrictEqual(JSValue v1, JSValue v2)
1165 {
1166     if (v1.isInt32() &amp;&amp; v2.isInt32())
1167         return triState(v1 == v2);
1168 
1169     if (v1.isNumber() &amp;&amp; v2.isNumber())
1170         return triState(v1.asNumber() == v2.asNumber());
1171 
1172     if (!v1.isCell() || !v2.isCell())
1173         return triState(v1 == v2);
1174 
</pre>
<hr />
<pre>
1177         const StringImpl* v2String = asString(v2)-&gt;tryGetValueImpl();
1178         if (!v1String || !v2String)
1179             return MixedTriState;
1180         return triState(WTF::equal(*v1String, *v2String));
1181     }
1182 
1183     return triState(v1 == v2);
1184 }
1185 
1186 inline TriState JSValue::pureToBoolean() const
1187 {
1188     if (isInt32())
1189         return asInt32() ? TrueTriState : FalseTriState;
1190     if (isDouble())
1191         return isNotZeroAndOrdered(asDouble()) ? TrueTriState : FalseTriState; // false for NaN
1192     if (isCell())
1193         return asCell()-&gt;pureToBoolean();
1194     return isTrue() ? TrueTriState : FalseTriState;
1195 }
1196 
<span class="line-modified">1197 ALWAYS_INLINE bool JSValue::requireObjectCoercible(ExecState* exec) const</span>
1198 {
<span class="line-modified">1199     VM&amp; vm = exec-&gt;vm();</span>
1200     auto scope = DECLARE_THROW_SCOPE(vm);
1201 
1202     if (!isUndefinedOrNull())
1203         return true;
<span class="line-modified">1204     throwException(exec, scope, createNotAnObjectError(exec, *this));</span>
1205     return false;
1206 }
1207 
1208 ALWAYS_INLINE bool isThisValueAltered(const PutPropertySlot&amp; slot, JSObject* baseObject)
1209 {
1210     JSValue thisValue = slot.thisValue();
1211     if (LIKELY(thisValue == baseObject))
1212         return false;
1213 
1214     if (!thisValue.isObject())
1215         return true;
1216     JSObject* thisObject = asObject(thisValue);
1217     // Only PureForwardingProxyType can be seen as the same to the original target object.
1218     if (thisObject-&gt;type() == PureForwardingProxyType &amp;&amp; jsCast&lt;JSProxy*&gt;(thisObject)-&gt;target() == baseObject)
1219         return false;
1220     return true;
1221 }
1222 
1223 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
<span class="line-modified">1224 ALWAYS_INLINE bool sameValue(ExecState* exec, JSValue a, JSValue b)</span>
1225 {
1226     if (!a.isNumber())
<span class="line-modified">1227         return JSValue::strictEqual(exec, a, b);</span>
1228     if (!b.isNumber())
1229         return false;
1230     double x = a.asNumber();
1231     double y = b.asNumber();
1232     bool xIsNaN = std::isnan(x);
1233     bool yIsNaN = std::isnan(y);
1234     if (xIsNaN || yIsNaN)
1235         return xIsNaN &amp;&amp; yIsNaN;
1236     return bitwise_cast&lt;uint64_t&gt;(x) == bitwise_cast&lt;uint64_t&gt;(y);
1237 }
1238 
1239 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  26 #pragma once
  27 
  28 #include &quot;CatchScope.h&quot;
  29 #include &quot;Error.h&quot;
  30 #include &quot;ExceptionHelpers.h&quot;
  31 #include &quot;Identifier.h&quot;
  32 #include &quot;InternalFunction.h&quot;
  33 #include &quot;JSBigInt.h&quot;
  34 #include &quot;JSCJSValue.h&quot;
  35 #include &quot;JSCellInlines.h&quot;
  36 #include &quot;JSFunction.h&quot;
  37 #include &quot;JSObject.h&quot;
  38 #include &quot;JSProxy.h&quot;
  39 #include &quot;JSStringInlines.h&quot;
  40 #include &quot;MathCommon.h&quot;
  41 #include &lt;wtf/Variant.h&gt;
  42 #include &lt;wtf/text/StringImpl.h&gt;
  43 
  44 namespace JSC {
  45 
<span class="line-modified">  46 ALWAYS_INLINE int32_t JSValue::toInt32(JSGlobalObject* globalObject) const</span>
  47 {
  48     if (isInt32())
  49         return asInt32();
<span class="line-modified">  50     return JSC::toInt32(toNumber(globalObject));</span>
  51 }
  52 
<span class="line-modified">  53 inline uint32_t JSValue::toUInt32(JSGlobalObject* globalObject) const</span>
  54 {
  55     // See comment on JSC::toUInt32, in JSCJSValue.h.
<span class="line-modified">  56     return toInt32(globalObject);</span>
  57 }
  58 
<span class="line-modified">  59 inline uint32_t JSValue::toIndex(JSGlobalObject* globalObject, const char* errorName) const</span>
  60 {
<span class="line-modified">  61     VM&amp; vm = getVM(globalObject);</span>
  62     auto scope = DECLARE_THROW_SCOPE(vm);
  63 
<span class="line-modified">  64     double d = toNumber(globalObject);</span>
  65     RETURN_IF_EXCEPTION(scope, 0);
  66     if (d &lt;= -1) {
<span class="line-modified">  67         throwException(globalObject, scope, createRangeError(globalObject, makeString(errorName, &quot; cannot be negative&quot;)));</span>
  68         return 0;
  69     }
  70     if (d &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
<span class="line-modified">  71         throwException(globalObject, scope, createRangeError(globalObject, makeString(errorName, &quot; too large&quot;)));</span>
  72         return 0;
  73     }
  74 
  75     if (isInt32())
  76         return asInt32();
  77     RELEASE_AND_RETURN(scope, JSC::toInt32(d));
  78 }
  79 
  80 inline bool JSValue::isUInt32() const
  81 {
  82     return isInt32() &amp;&amp; asInt32() &gt;= 0;
  83 }
  84 
  85 inline uint32_t JSValue::asUInt32() const
  86 {
  87     ASSERT(isUInt32());
  88     return asInt32();
  89 }
  90 
  91 inline double JSValue::asNumber() const
</pre>
<hr />
<pre>
 450 }
 451 
 452 inline JSValue::JSValue(JSUndefinedTag)
 453 {
 454     u.asInt64 = ValueUndefined;
 455 }
 456 
 457 inline JSValue::JSValue(JSTrueTag)
 458 {
 459     u.asInt64 = ValueTrue;
 460 }
 461 
 462 inline JSValue::JSValue(JSFalseTag)
 463 {
 464     u.asInt64 = ValueFalse;
 465 }
 466 
 467 inline bool JSValue::isUndefinedOrNull() const
 468 {
 469     // Undefined and null share the same value, bar the &#39;undefined&#39; bit in the extended tag.
<span class="line-modified"> 470     return (u.asInt64 &amp; ~UndefinedTag) == ValueNull;</span>
 471 }
 472 
 473 inline bool JSValue::isBoolean() const
 474 {
 475     return (u.asInt64 &amp; ~1) == ValueFalse;
 476 }
 477 
 478 inline bool JSValue::isCell() const
 479 {
<span class="line-modified"> 480     return !(u.asInt64 &amp; NotCellMask);</span>
 481 }
 482 
 483 inline bool JSValue::isInt32() const
 484 {
<span class="line-modified"> 485     return (u.asInt64 &amp; NumberTag) == NumberTag;</span>
 486 }
 487 
 488 inline int64_t reinterpretDoubleToInt64(double value)
 489 {
 490     return bitwise_cast&lt;int64_t&gt;(value);
 491 }
 492 inline double reinterpretInt64ToDouble(int64_t value)
 493 {
 494     return bitwise_cast&lt;double&gt;(value);
 495 }
 496 
 497 ALWAYS_INLINE JSValue::JSValue(EncodeAsDoubleTag, double d)
 498 {
 499     ASSERT(!isImpureNaN(d));
<span class="line-modified"> 500     u.asInt64 = reinterpretDoubleToInt64(d) + JSValue::DoubleEncodeOffset;</span>
 501 }
 502 
 503 inline JSValue::JSValue(int i)
 504 {
<span class="line-modified"> 505     u.asInt64 = JSValue::NumberTag | static_cast&lt;uint32_t&gt;(i);</span>
 506 }
 507 
 508 inline double JSValue::asDouble() const
 509 {
 510     ASSERT(isDouble());
<span class="line-modified"> 511     return reinterpretInt64ToDouble(u.asInt64 - JSValue::DoubleEncodeOffset);</span>
 512 }
 513 
 514 inline bool JSValue::isNumber() const
 515 {
<span class="line-modified"> 516     return u.asInt64 &amp; JSValue::NumberTag;</span>
 517 }
 518 
 519 ALWAYS_INLINE JSCell* JSValue::asCell() const
 520 {
 521     ASSERT(isCell());
 522     return u.ptr;
 523 }
 524 
 525 #endif // USE(JSVALUE64)
 526 
 527 inline int64_t tryConvertToInt52(double number)
 528 {
 529     if (number != number)
 530         return JSValue::notInt52;
 531 #if OS(WINDOWS) &amp;&amp; CPU(X86)
 532     // The VS Compiler for 32-bit builds generates a floating point error when attempting to cast
 533     // from an infinity to a 64-bit integer. We leave this routine with the floating point error
 534     // left in a register, causing undefined behavior in later floating point operations.
 535     //
 536     // To avoid this issue, we check for infinity here, and return false in that case.
</pre>
<hr />
<pre>
 621 inline bool JSValue::isPrimitive() const
 622 {
 623     return !isCell() || asCell()-&gt;isString() || asCell()-&gt;isSymbol() || asCell()-&gt;isBigInt();
 624 }
 625 
 626 inline bool JSValue::isGetterSetter() const
 627 {
 628     return isCell() &amp;&amp; asCell()-&gt;isGetterSetter();
 629 }
 630 
 631 inline bool JSValue::isCustomGetterSetter() const
 632 {
 633     return isCell() &amp;&amp; asCell()-&gt;isCustomGetterSetter();
 634 }
 635 
 636 inline bool JSValue::isObject() const
 637 {
 638     return isCell() &amp;&amp; asCell()-&gt;isObject();
 639 }
 640 
<span class="line-modified"> 641 inline bool JSValue::getString(JSGlobalObject* globalObject, String&amp; s) const</span>
 642 {
<span class="line-modified"> 643     return isCell() &amp;&amp; asCell()-&gt;getString(globalObject, s);</span>
 644 }
 645 
<span class="line-modified"> 646 inline String JSValue::getString(JSGlobalObject* globalObject) const</span>
 647 {
<span class="line-modified"> 648     return isCell() ? asCell()-&gt;getString(globalObject) : String();</span>
 649 }
 650 
<span class="line-modified"> 651 template &lt;typename Base&gt; String HandleConverter&lt;Base, Unknown&gt;::getString(JSGlobalObject* globalObject) const</span>
 652 {
<span class="line-modified"> 653     return jsValue().getString(globalObject);</span>
 654 }
 655 
 656 inline JSObject* JSValue::getObject() const
 657 {
 658     return isCell() ? asCell()-&gt;getObject() : 0;
 659 }
 660 
 661 ALWAYS_INLINE bool JSValue::getUInt32(uint32_t&amp; v) const
 662 {
 663     if (isInt32()) {
 664         int32_t i = asInt32();
 665         v = static_cast&lt;uint32_t&gt;(i);
 666         return i &gt;= 0;
 667     }
 668     if (isDouble()) {
 669         double d = asDouble();
 670         v = static_cast&lt;uint32_t&gt;(d);
 671         return v == d;
 672     }
 673     return false;
 674 }
 675 
<span class="line-modified"> 676 ALWAYS_INLINE Identifier JSValue::toPropertyKey(JSGlobalObject* globalObject) const</span>
 677 {
<span class="line-modified"> 678     VM&amp; vm = getVM(globalObject);</span>
 679     auto scope = DECLARE_THROW_SCOPE(vm);
 680 
 681     if (isString())
<span class="line-modified"> 682         RELEASE_AND_RETURN(scope, asString(*this)-&gt;toIdentifier(globalObject));</span>
 683 
<span class="line-modified"> 684     JSValue primitive = toPrimitive(globalObject, PreferString);</span>
 685     RETURN_IF_EXCEPTION(scope, vm.propertyNames-&gt;emptyIdentifier);
 686     if (primitive.isSymbol())
 687         RELEASE_AND_RETURN(scope, Identifier::fromUid(asSymbol(primitive)-&gt;privateName()));
 688 
<span class="line-modified"> 689     auto string = primitive.toString(globalObject);</span>
 690     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified"> 691     RELEASE_AND_RETURN(scope, string-&gt;toIdentifier(globalObject));</span>
 692 }
 693 
<span class="line-modified"> 694 ALWAYS_INLINE JSValue JSValue::toPropertyKeyValue(JSGlobalObject* globalObject) const</span>
 695 {
<span class="line-modified"> 696     VM&amp; vm = getVM(globalObject);</span>
<span class="line-added"> 697     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 698 </span>
<span class="line-added"> 699     if (isString() || isSymbol())</span>
<span class="line-added"> 700         return *this;</span>
<span class="line-added"> 701 </span>
<span class="line-added"> 702     JSValue primitive = toPrimitive(globalObject, PreferString);</span>
<span class="line-added"> 703     RETURN_IF_EXCEPTION(scope, JSValue());</span>
<span class="line-added"> 704     if (primitive.isSymbol())</span>
<span class="line-added"> 705         return primitive;</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707     RELEASE_AND_RETURN(scope, primitive.toString(globalObject));</span>
 708 }
 709 
<span class="line-modified"> 710 inline JSValue JSValue::toPrimitive(JSGlobalObject* globalObject, PreferredPrimitiveType preferredType) const</span>
 711 {
<span class="line-modified"> 712     return isCell() ? asCell()-&gt;toPrimitive(globalObject, preferredType) : asValue();</span>
<span class="line-added"> 713 }</span>
<span class="line-added"> 714 </span>
<span class="line-added"> 715 inline PreferredPrimitiveType toPreferredPrimitiveType(JSGlobalObject* globalObject, JSValue value)</span>
<span class="line-added"> 716 {</span>
<span class="line-added"> 717     VM&amp; vm = getVM(globalObject);</span>
 718     auto scope = DECLARE_THROW_SCOPE(vm);
 719 
 720     if (!value.isString()) {
<span class="line-modified"> 721         throwTypeError(globalObject, scope, &quot;Primitive hint is not a string.&quot;_s);</span>
 722         return NoPreference;
 723     }
 724 
<span class="line-modified"> 725     StringImpl* hintString = asString(value)-&gt;value(globalObject).impl();</span>
 726     RETURN_IF_EXCEPTION(scope, NoPreference);
 727 
 728     if (WTF::equal(hintString, &quot;default&quot;))
 729         return NoPreference;
 730     if (WTF::equal(hintString, &quot;number&quot;))
 731         return PreferNumber;
 732     if (WTF::equal(hintString, &quot;string&quot;))
 733         return PreferString;
 734 
<span class="line-modified"> 735     throwTypeError(globalObject, scope, &quot;Expected primitive hint to match one of &#39;default&#39;, &#39;number&#39;, &#39;string&#39;.&quot;_s);</span>
 736     return NoPreference;
 737 }
 738 
<span class="line-modified"> 739 inline bool JSValue::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; value)</span>
 740 {
 741     if (isInt32()) {
 742         number = asInt32();
 743         value = *this;
 744         return true;
 745     }
 746     if (isDouble()) {
 747         number = asDouble();
 748         value = *this;
 749         return true;
 750     }
 751     if (isCell())
<span class="line-modified"> 752         return asCell()-&gt;getPrimitiveNumber(globalObject, number, value);</span>
 753     if (isTrue()) {
 754         number = 1.0;
 755         value = *this;
 756         return true;
 757     }
 758     if (isFalse() || isNull()) {
 759         number = 0.0;
 760         value = *this;
 761         return true;
 762     }
 763     ASSERT(isUndefined());
 764     number = PNaN;
 765     value = *this;
 766     return true;
 767 }
 768 
<span class="line-modified"> 769 ALWAYS_INLINE double JSValue::toNumber(JSGlobalObject* globalObject) const</span>
 770 {
 771     if (isInt32())
 772         return asInt32();
 773     if (isDouble())
 774         return asDouble();
<span class="line-modified"> 775     return toNumberSlowCase(globalObject);</span>
 776 }
 777 
<span class="line-modified"> 778 ALWAYS_INLINE Variant&lt;JSBigInt*, double&gt; JSValue::toNumeric(JSGlobalObject* globalObject) const</span>
 779 {
 780     if (isInt32())
 781         return asInt32();
 782     if (isDouble())
 783         return asDouble();
 784     if (isBigInt())
 785         return asBigInt(*this);
 786 
<span class="line-modified"> 787     VM&amp; vm = getVM(globalObject);</span>
 788     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 789     JSValue primValue = this-&gt;toPrimitive(globalObject, PreferNumber);</span>
 790     RETURN_IF_EXCEPTION(scope, 0);
 791     if (primValue.isBigInt())
 792         return asBigInt(primValue);
<span class="line-modified"> 793     double value = primValue.toNumber(globalObject);</span>
 794     RETURN_IF_EXCEPTION(scope, 0);
 795     return value;
 796 }
 797 
<span class="line-modified"> 798 ALWAYS_INLINE Variant&lt;JSBigInt*, int32_t&gt; JSValue::toBigIntOrInt32(JSGlobalObject* globalObject) const</span>
 799 {
 800     if (isInt32())
 801         return asInt32();
 802     if (isDouble() &amp;&amp; canBeInt32(asDouble()))
 803         return static_cast&lt;int32_t&gt;(asDouble());
 804     if (isBigInt())
 805         return asBigInt(*this);
 806 
<span class="line-modified"> 807     VM&amp; vm = getVM(globalObject);</span>
 808     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 809     JSValue primValue = this-&gt;toPrimitive(globalObject, PreferNumber);</span>
 810     RETURN_IF_EXCEPTION(scope, 0);
 811     if (primValue.isBigInt())
 812         return asBigInt(primValue);
<span class="line-modified"> 813     int32_t value = primValue.toInt32(globalObject);</span>
 814     RETURN_IF_EXCEPTION(scope, 0);
 815     return value;
 816 }
 817 
<span class="line-modified"> 818 inline JSObject* JSValue::toObject(JSGlobalObject* globalObject) const</span>





 819 {
<span class="line-modified"> 820     return isCell() ? asCell()-&gt;toObject(globalObject) : toObjectSlowCase(globalObject);</span>
 821 }
 822 
 823 inline bool JSValue::isFunction(VM&amp; vm) const
 824 {
 825     if (!isCell())
 826         return false;
 827     return asCell()-&gt;isFunction(vm);
 828 }
 829 
 830 inline bool JSValue::isCallable(VM&amp; vm, CallType&amp; callType, CallData&amp; callData) const
 831 {
 832     if (!isCell())
 833         return false;
 834     return asCell()-&gt;isCallable(vm, callType, callData);
 835 }
 836 
 837 inline bool JSValue::isConstructor(VM&amp; vm) const
 838 {
 839     if (!isCell())
 840         return false;
</pre>
<hr />
<pre>
 848     return asCell()-&gt;isConstructor(vm, constructType, constructData);
 849 }
 850 
 851 // this method is here to be after the inline declaration of JSCell::inherits
 852 inline bool JSValue::inherits(VM&amp; vm, const ClassInfo* classInfo) const
 853 {
 854     return isCell() &amp;&amp; asCell()-&gt;inherits(vm, classInfo);
 855 }
 856 
 857 template&lt;typename Target&gt;
 858 inline bool JSValue::inherits(VM&amp; vm) const
 859 {
 860     return isCell() &amp;&amp; asCell()-&gt;inherits&lt;Target&gt;(vm);
 861 }
 862 
 863 inline const ClassInfo* JSValue::classInfoOrNull(VM&amp; vm) const
 864 {
 865     return isCell() ? asCell()-&gt;classInfo(vm) : nullptr;
 866 }
 867 
<span class="line-modified"> 868 inline JSValue JSValue::toThis(JSGlobalObject* globalObject, ECMAMode ecmaMode) const</span>
 869 {
<span class="line-modified"> 870     return isCell() ? asCell()-&gt;methodTable(getVM(globalObject))-&gt;toThis(asCell(), globalObject, ecmaMode) : toThisSlowCase(globalObject, ecmaMode);</span>
 871 }
 872 
<span class="line-modified"> 873 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
 874 {
 875     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 876     return get(globalObject, propertyName, slot);</span>
 877 }
 878 
<span class="line-modified"> 879 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const</span>
 880 {
<span class="line-modified"> 881     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));</span>
<span class="line-modified"> 882     bool hasSlot = getPropertySlot(globalObject, propertyName, slot);</span>
 883     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 884     if (!hasSlot)
 885         return jsUndefined();
<span class="line-modified"> 886     RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
 887 }
 888 
 889 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified"> 890 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, CallbackWhenNoException callback) const</span>
 891 {
 892     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 893     return getPropertySlot(globalObject, propertyName, slot, callback);</span>
 894 }
 895 
 896 template&lt;typename CallbackWhenNoException&gt;
<span class="line-modified"> 897 ALWAYS_INLINE typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type JSValue::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot, CallbackWhenNoException callback) const</span>
 898 {
<span class="line-modified"> 899     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));</span>
<span class="line-modified"> 900     bool found = getPropertySlot(globalObject, propertyName, slot);</span>
 901     RETURN_IF_EXCEPTION(scope, { });
 902     RELEASE_AND_RETURN(scope, callback(found, slot));
 903 }
 904 
<span class="line-modified"> 905 ALWAYS_INLINE bool JSValue::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const</span>
 906 {
<span class="line-modified"> 907     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));</span>
 908     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 909     // and if it&#39;s a string there are special properties to check first.
 910     JSObject* object;
 911     if (UNLIKELY(!isObject())) {
 912         if (isString()) {
<span class="line-modified"> 913             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(globalObject, propertyName, slot);</span>
 914             RETURN_IF_EXCEPTION(scope, false);
 915             if (hasProperty)
 916                 return true;
 917         }
<span class="line-modified"> 918         object = synthesizePrototype(globalObject);</span>
 919         EXCEPTION_ASSERT(!!scope.exception() == !object);
 920         if (UNLIKELY(!object))
 921             return false;
 922     } else
 923         object = asObject(asCell());
 924 
<span class="line-modified"> 925     RELEASE_AND_RETURN(scope, object-&gt;getPropertySlot(globalObject, propertyName, slot));</span>
 926 }
 927 
<span class="line-modified"> 928 ALWAYS_INLINE bool JSValue::getOwnPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot) const</span>
 929 {
 930     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 931     // and if it&#39;s a string there are special properties to check first.
<span class="line-modified"> 932     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));</span>
 933     if (UNLIKELY(!isObject())) {
 934         if (isString())
<span class="line-modified"> 935             RELEASE_AND_RETURN(scope, asString(*this)-&gt;getStringPropertySlot(globalObject, propertyName, slot));</span>
 936 
 937         if (isUndefinedOrNull())
<span class="line-modified"> 938             throwException(globalObject, scope, createNotAnObjectError(globalObject, *this));</span>
 939         return false;
 940     }
<span class="line-modified"> 941     RELEASE_AND_RETURN(scope, asObject(asCell())-&gt;getOwnPropertySlotInline(globalObject, propertyName, slot));</span>
 942 }
 943 
<span class="line-modified"> 944 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, unsigned propertyName) const</span>
 945 {
 946     PropertySlot slot(asValue(), PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 947     return get(globalObject, propertyName, slot);</span>
 948 }
 949 
<span class="line-modified"> 950 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot) const</span>
 951 {
<span class="line-modified"> 952     auto scope = DECLARE_THROW_SCOPE(getVM(globalObject));</span>
 953     // If this is a primitive, we&#39;ll need to synthesize the prototype -
 954     // and if it&#39;s a string there are special properties to check first.
 955     JSObject* object;
 956     if (UNLIKELY(!isObject())) {
 957         if (isString()) {
<span class="line-modified"> 958             bool hasProperty = asString(*this)-&gt;getStringPropertySlot(globalObject, propertyName, slot);</span>
 959             RETURN_IF_EXCEPTION(scope, { });
 960             if (hasProperty)
<span class="line-modified"> 961                 RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
 962         }
<span class="line-modified"> 963         object = synthesizePrototype(globalObject);</span>
 964         EXCEPTION_ASSERT(!!scope.exception() == !object);
 965         if (UNLIKELY(!object))
 966             return JSValue();
 967     } else
 968         object = asObject(asCell());
 969 
<span class="line-modified"> 970     bool hasSlot = object-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
 971     EXCEPTION_ASSERT(!scope.exception() || !hasSlot);
 972     if (!hasSlot)
 973         return jsUndefined();
<span class="line-modified"> 974     RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
 975 }
 976 
<span class="line-modified"> 977 ALWAYS_INLINE JSValue JSValue::get(JSGlobalObject* globalObject, uint64_t propertyName) const</span>
 978 {
 979     if (LIKELY(propertyName &lt;= std::numeric_limits&lt;unsigned&gt;::max()))
<span class="line-modified"> 980         return get(globalObject, static_cast&lt;unsigned&gt;(propertyName));</span>
<span class="line-modified"> 981     return get(globalObject, Identifier::from(getVM(globalObject), static_cast&lt;double&gt;(propertyName)));</span>
 982 }
 983 
<span class="line-modified"> 984 inline bool JSValue::put(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 985 {
 986     if (UNLIKELY(!isCell()))
<span class="line-modified"> 987         return putToPrimitive(globalObject, propertyName, value, slot);</span>
 988 
<span class="line-modified"> 989     return asCell()-&gt;methodTable(getVM(globalObject))-&gt;put(asCell(), globalObject, propertyName, value, slot);</span>
 990 }
 991 
<span class="line-modified"> 992 ALWAYS_INLINE bool JSValue::putInline(JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
 993 {
 994     if (UNLIKELY(!isCell()))
<span class="line-modified"> 995         return putToPrimitive(globalObject, propertyName, value, slot);</span>
<span class="line-modified"> 996     return asCell()-&gt;putInline(globalObject, propertyName, value, slot);</span>
 997 }
 998 
<span class="line-modified"> 999 inline bool JSValue::putByIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
1000 {
1001     if (UNLIKELY(!isCell()))
<span class="line-modified">1002         return putToPrimitiveByIndex(globalObject, propertyName, value, shouldThrow);</span>
1003 
<span class="line-modified">1004     return asCell()-&gt;methodTable(getVM(globalObject))-&gt;putByIndex(asCell(), globalObject, propertyName, value, shouldThrow);</span>
1005 }
1006 
1007 inline Structure* JSValue::structureOrNull() const
1008 {
1009     if (isCell())
1010         return asCell()-&gt;structure();
1011     return nullptr;
1012 }
1013 
1014 inline JSValue JSValue::structureOrUndefined() const
1015 {
1016     if (isCell())
1017         return JSValue(asCell()-&gt;structure());
1018     return jsUndefined();
1019 }
1020 
1021 // ECMA 11.9.3
<span class="line-modified">1022 inline bool JSValue::equal(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
1023 {
1024     if (v1.isInt32() &amp;&amp; v2.isInt32())
1025         return v1 == v2;
1026 
<span class="line-modified">1027     return equalSlowCase(globalObject, v1, v2);</span>
1028 }
1029 
<span class="line-modified">1030 ALWAYS_INLINE bool JSValue::equalSlowCaseInline(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
1031 {
<span class="line-modified">1032     VM&amp; vm = getVM(globalObject);</span>
1033     auto scope = DECLARE_THROW_SCOPE(vm);
1034     do {
1035         if (v1.isNumber() &amp;&amp; v2.isNumber())
1036             return v1.asNumber() == v2.asNumber();
1037 
1038         bool s1 = v1.isString();
1039         bool s2 = v2.isString();
1040         if (s1 &amp;&amp; s2)
<span class="line-modified">1041             RELEASE_AND_RETURN(scope, asString(v1)-&gt;equal(globalObject, asString(v2)));</span>
1042 
1043         if (v1.isBigInt() &amp;&amp; s2) {
<span class="line-modified">1044             String v2String = asString(v2)-&gt;value(globalObject);</span>
<span class="line-added">1045             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">1046             JSBigInt* n = JSBigInt::stringToBigInt(globalObject, v2String);</span>
1047             RETURN_IF_EXCEPTION(scope, false);
1048             if (!n)
1049                 return false;
1050 
1051             v2 = JSValue(n);
1052             continue;
1053         }
1054 
1055         if (s1 &amp;&amp; v2.isBigInt()) {
<span class="line-modified">1056             String v1String = asString(v1)-&gt;value(globalObject);</span>
<span class="line-added">1057             RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">1058             JSBigInt* n = JSBigInt::stringToBigInt(globalObject, v1String);</span>
1059             RETURN_IF_EXCEPTION(scope, false);
1060             if (!n)
1061                 return false;
1062 
1063             v1 = JSValue(n);
1064             continue;
1065         }
1066 
1067         if (v1.isUndefinedOrNull()) {
1068             if (v2.isUndefinedOrNull())
1069                 return true;
1070             if (!v2.isCell())
1071                 return false;
<span class="line-modified">1072             return v2.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject);</span>
1073         }
1074 
1075         if (v2.isUndefinedOrNull()) {
1076             if (!v1.isCell())
1077                 return false;
<span class="line-modified">1078             return v1.asCell()-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject);</span>
1079         }
1080 
1081         if (v1.isObject()) {
1082             if (v2.isObject())
1083                 return v1 == v2;
<span class="line-modified">1084             JSValue p1 = v1.toPrimitive(globalObject);</span>
1085             RETURN_IF_EXCEPTION(scope, false);
1086             v1 = p1;
1087             if (v1.isInt32() &amp;&amp; v2.isInt32())
1088                 return v1 == v2;
1089             continue;
1090         }
1091 
1092         if (v2.isObject()) {
<span class="line-modified">1093             JSValue p2 = v2.toPrimitive(globalObject);</span>
1094             RETURN_IF_EXCEPTION(scope, false);
1095             v2 = p2;
1096             if (v1.isInt32() &amp;&amp; v2.isInt32())
1097                 return v1 == v2;
1098             continue;
1099         }
1100 
1101         bool sym1 = v1.isSymbol();
1102         bool sym2 = v2.isSymbol();
1103         if (sym1 || sym2) {
1104             if (sym1 &amp;&amp; sym2)
1105                 return asSymbol(v1) == asSymbol(v2);
1106             return false;
1107         }
1108 
1109         if (s1 || s2) {
<span class="line-modified">1110             double d1 = v1.toNumber(globalObject);</span>
1111             RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">1112             double d2 = v2.toNumber(globalObject);</span>
1113             RETURN_IF_EXCEPTION(scope, false);
1114             return d1 == d2;
1115         }
1116 
1117         if (v1.isBoolean()) {
1118             if (v2.isNumber())
1119                 return static_cast&lt;double&gt;(v1.asBoolean()) == v2.asNumber();
1120             else if (v2.isBigInt()) {
<span class="line-modified">1121                 v1 = JSValue(v1.toNumber(globalObject));</span>
1122                 continue;
1123             }
1124         } else if (v2.isBoolean()) {
1125             if (v1.isNumber())
1126                 return v1.asNumber() == static_cast&lt;double&gt;(v2.asBoolean());
1127             else if (v1.isBigInt()) {
<span class="line-modified">1128                 v2 = JSValue(v2.toNumber(globalObject));</span>
1129                 continue;
1130             }
1131         }
1132 
1133         if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1134             return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1135 
1136         if (v1.isBigInt() &amp;&amp; v2.isNumber())
1137             return asBigInt(v1)-&gt;equalsToNumber(v2);
1138 
1139         if (v2.isBigInt() &amp;&amp; v1.isNumber())
1140             return asBigInt(v2)-&gt;equalsToNumber(v1);
1141 
1142         return v1 == v2;
1143     } while (true);
1144 }
1145 
1146 // ECMA 11.9.3
<span class="line-modified">1147 ALWAYS_INLINE bool JSValue::strictEqualSlowCaseInline(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
1148 {
1149     ASSERT(v1.isCell() &amp;&amp; v2.isCell());
1150 
1151     if (v1.asCell()-&gt;isString() &amp;&amp; v2.asCell()-&gt;isString())
<span class="line-modified">1152         return asString(v1)-&gt;equal(globalObject, asString(v2));</span>
1153     if (v1.isBigInt() &amp;&amp; v2.isBigInt())
1154         return JSBigInt::equals(asBigInt(v1), asBigInt(v2));
1155     return v1 == v2;
1156 }
1157 
<span class="line-modified">1158 inline bool JSValue::strictEqual(JSGlobalObject* globalObject, JSValue v1, JSValue v2)</span>
1159 {
1160     if (v1.isInt32() &amp;&amp; v2.isInt32())
1161         return v1 == v2;
1162 
1163     if (v1.isNumber() &amp;&amp; v2.isNumber())
1164         return v1.asNumber() == v2.asNumber();
1165 
1166     if (!v1.isCell() || !v2.isCell())
1167         return v1 == v2;
1168 
<span class="line-modified">1169     return strictEqualSlowCaseInline(globalObject, v1, v2);</span>
1170 }
1171 
1172 inline int32_t JSValue::asInt32ForArithmetic() const
1173 {
1174     if (isBoolean())
1175         return asBoolean();
1176     return asInt32();
1177 }
1178 
1179 inline TriState JSValue::pureStrictEqual(JSValue v1, JSValue v2)
1180 {
1181     if (v1.isInt32() &amp;&amp; v2.isInt32())
1182         return triState(v1 == v2);
1183 
1184     if (v1.isNumber() &amp;&amp; v2.isNumber())
1185         return triState(v1.asNumber() == v2.asNumber());
1186 
1187     if (!v1.isCell() || !v2.isCell())
1188         return triState(v1 == v2);
1189 
</pre>
<hr />
<pre>
1192         const StringImpl* v2String = asString(v2)-&gt;tryGetValueImpl();
1193         if (!v1String || !v2String)
1194             return MixedTriState;
1195         return triState(WTF::equal(*v1String, *v2String));
1196     }
1197 
1198     return triState(v1 == v2);
1199 }
1200 
1201 inline TriState JSValue::pureToBoolean() const
1202 {
1203     if (isInt32())
1204         return asInt32() ? TrueTriState : FalseTriState;
1205     if (isDouble())
1206         return isNotZeroAndOrdered(asDouble()) ? TrueTriState : FalseTriState; // false for NaN
1207     if (isCell())
1208         return asCell()-&gt;pureToBoolean();
1209     return isTrue() ? TrueTriState : FalseTriState;
1210 }
1211 
<span class="line-modified">1212 ALWAYS_INLINE bool JSValue::requireObjectCoercible(JSGlobalObject* globalObject) const</span>
1213 {
<span class="line-modified">1214     VM&amp; vm = getVM(globalObject);</span>
1215     auto scope = DECLARE_THROW_SCOPE(vm);
1216 
1217     if (!isUndefinedOrNull())
1218         return true;
<span class="line-modified">1219     throwException(globalObject, scope, createNotAnObjectError(globalObject, *this));</span>
1220     return false;
1221 }
1222 
1223 ALWAYS_INLINE bool isThisValueAltered(const PutPropertySlot&amp; slot, JSObject* baseObject)
1224 {
1225     JSValue thisValue = slot.thisValue();
1226     if (LIKELY(thisValue == baseObject))
1227         return false;
1228 
1229     if (!thisValue.isObject())
1230         return true;
1231     JSObject* thisObject = asObject(thisValue);
1232     // Only PureForwardingProxyType can be seen as the same to the original target object.
1233     if (thisObject-&gt;type() == PureForwardingProxyType &amp;&amp; jsCast&lt;JSProxy*&gt;(thisObject)-&gt;target() == baseObject)
1234         return false;
1235     return true;
1236 }
1237 
1238 // See section 7.2.9: https://tc39.github.io/ecma262/#sec-samevalue
<span class="line-modified">1239 ALWAYS_INLINE bool sameValue(JSGlobalObject* globalObject, JSValue a, JSValue b)</span>
1240 {
1241     if (!a.isNumber())
<span class="line-modified">1242         return JSValue::strictEqual(globalObject, a, b);</span>
1243     if (!b.isNumber())
1244         return false;
1245     double x = a.asNumber();
1246     double y = b.asNumber();
1247     bool xIsNaN = std::isnan(x);
1248     bool yIsNaN = std::isnan(y);
1249     if (xIsNaN || yIsNaN)
1250         return xIsNaN &amp;&amp; yIsNaN;
1251     return bitwise_cast&lt;uint64_t&gt;(x) == bitwise_cast&lt;uint64_t&gt;(y);
1252 }
1253 
1254 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSCJSValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCPtrTag.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
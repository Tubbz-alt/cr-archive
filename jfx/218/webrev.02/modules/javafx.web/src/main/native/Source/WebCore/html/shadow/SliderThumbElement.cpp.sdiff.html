<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/shadow/SliderThumbElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ProgressShadowElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SliderThumbElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/shadow/SliderThumbElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
229 {
230     auto input = hostInput();
231     return !input || input-&gt;isDisabledFormControl();
232 }
233 
234 bool SliderThumbElement::matchesReadWritePseudoClass() const
235 {
236     auto input = hostInput();
237     return input &amp;&amp; input-&gt;matchesReadWritePseudoClass();
238 }
239 
240 RefPtr&lt;Element&gt; SliderThumbElement::focusDelegate()
241 {
242     return hostInput();
243 }
244 
245 void SliderThumbElement::dragFrom(const LayoutPoint&amp; point)
246 {
247     Ref&lt;SliderThumbElement&gt; protectedThis(*this);
248     setPositionFromPoint(point);
<span class="line-removed">249 #if !PLATFORM(IOS_FAMILY)</span>
250     startDragging();
<span class="line-removed">251 #endif</span>
252 }
253 
254 void SliderThumbElement::setPositionFromPoint(const LayoutPoint&amp; absolutePoint)
255 {
256     auto input = hostInput();
257     if (!input)
258         return;
259 
260     auto* inputRenderer = input-&gt;renderBox();
261     if (!inputRenderer)
262         return;
263 
264     auto* thumbRenderer = renderBox();
265     if (!thumbRenderer)
266         return;
267 
268     ASSERT(input-&gt;sliderTrackElement());
269     auto* trackRenderer = input-&gt;sliderTrackElement()-&gt;renderBox();
270     if (!trackRenderer)
271         return;
</pre>
<hr />
<pre>
321 void SliderThumbElement::startDragging()
322 {
323     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
324         frame-&gt;eventHandler().setCapturingMouseEventsElement(this);
325         m_inDragMode = true;
326     }
327 }
328 
329 void SliderThumbElement::stopDragging()
330 {
331     if (!m_inDragMode)
332         return;
333 
334     if (RefPtr&lt;Frame&gt; frame = document().frame())
335         frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
336     m_inDragMode = false;
337     if (renderer())
338         renderer()-&gt;setNeedsLayout();
339 }
340 
<span class="line-removed">341 #if !PLATFORM(IOS_FAMILY)</span>
342 void SliderThumbElement::defaultEventHandler(Event&amp; event)
343 {
344     if (!is&lt;MouseEvent&gt;(event)) {
345         HTMLDivElement::defaultEventHandler(event);
346         return;
347     }
348 
349     // FIXME: Should handle this readonly/disabled check in more general way.
350     // Missing this kind of check is likely to occur elsewhere if adding it in each shadow element.
351     auto input = hostInput();
352     if (!input || input-&gt;isDisabledFormControl()) {
353         HTMLDivElement::defaultEventHandler(event);
354         return;
355     }
356 
357     MouseEvent&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
358     bool isLeftButton = mouseEvent.button() == LeftButton;
359     const AtomString&amp; eventType = mouseEvent.type();
360 
361     // We intentionally do not call event-&gt;setDefaultHandled() here because
362     // MediaControlTimelineElement::defaultEventHandler() wants to handle these
363     // mouse events.
364     if (eventType == eventNames().mousedownEvent &amp;&amp; isLeftButton) {
365         startDragging();
366         return;
367     } else if (eventType == eventNames().mouseupEvent &amp;&amp; isLeftButton) {
368         input-&gt;dispatchFormControlChangeEvent();
369         stopDragging();
370         return;
371     } else if (eventType == eventNames().mousemoveEvent) {
372         if (m_inDragMode)
373             setPositionFromPoint(mouseEvent.absoluteLocation());
374         return;
375     }
376 
377     HTMLDivElement::defaultEventHandler(mouseEvent);
378 }
<span class="line-removed">379 #endif</span>
<span class="line-removed">380 </span>
<span class="line-removed">381 #if !PLATFORM(IOS_FAMILY)</span>
382 
383 bool SliderThumbElement::willRespondToMouseMoveEvents()
384 {
385     const auto input = hostInput();
386     if (input &amp;&amp; !input-&gt;isDisabledFormControl() &amp;&amp; m_inDragMode)
387         return true;
388 
389     return HTMLDivElement::willRespondToMouseMoveEvents();
390 }
391 
392 bool SliderThumbElement::willRespondToMouseClickEvents()
393 {
394     const auto input = hostInput();
395     if (input &amp;&amp; !input-&gt;isDisabledFormControl())
396         return true;
397 
398     return HTMLDivElement::willRespondToMouseClickEvents();
399 }
400 
<span class="line-removed">401 #endif // !PLATFORM(IOS_FAMILY)</span>
402 
403 void SliderThumbElement::willDetachRenderers()
404 {
405     if (m_inDragMode) {
406         if (RefPtr&lt;Frame&gt; frame = document().frame())
407             frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
408     }
409 #if ENABLE(IOS_TOUCH_EVENTS)
410     unregisterForTouchEvents();
411 #endif
412 }
413 
414 #if ENABLE(IOS_TOUCH_EVENTS)
415 
416 unsigned SliderThumbElement::exclusiveTouchIdentifier() const
417 {
418     return m_exclusiveTouchIdentifier;
419 }
420 
421 void SliderThumbElement::setExclusiveTouchIdentifier(unsigned identifier)
</pre>
<hr />
<pre>
573 void SliderThumbElement::hostDisabledStateChanged()
574 {
575     if (isDisabledFormControl())
576         stopDragging();
577 
578 #if ENABLE(IOS_TOUCH_EVENTS)
579     if (shouldAcceptTouchEvents())
580         registerForTouchEvents();
581     else
582         unregisterForTouchEvents();
583 #endif
584 }
585 
586 RefPtr&lt;HTMLInputElement&gt; SliderThumbElement::hostInput() const
587 {
588     // Only HTMLInputElement creates SliderThumbElement instances as its shadow nodes.
589     // So, shadowHost() must be an HTMLInputElement.
590     return downcast&lt;HTMLInputElement&gt;(shadowHost());
591 }
592 
<span class="line-modified">593 Optional&lt;ElementStyle&gt; SliderThumbElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* hostStyle)</span>
594 {
595     // This doesn&#39;t actually compute style. This is just a hack to pick shadow pseudo id when host style is known.
596 
597     static NeverDestroyed&lt;const AtomString&gt; sliderThumbShadowPseudoId(&quot;-webkit-slider-thumb&quot;, AtomString::ConstructFromLiteral);
598     static NeverDestroyed&lt;const AtomString&gt; mediaSliderThumbShadowPseudoId(&quot;-webkit-media-slider-thumb&quot;, AtomString::ConstructFromLiteral);
599 
600     if (!hostStyle)
601         return WTF::nullopt;
602 
603     switch (hostStyle-&gt;appearance()) {
604     case MediaSliderPart:
605     case MediaSliderThumbPart:
606     case MediaVolumeSliderPart:
607     case MediaVolumeSliderThumbPart:
608     case MediaFullScreenVolumeSliderPart:
609     case MediaFullScreenVolumeSliderThumbPart:
610         m_shadowPseudoId = mediaSliderThumbShadowPseudoId;
611         break;
612     default:
613         m_shadowPseudoId = sliderThumbShadowPseudoId;
</pre>
<hr />
<pre>
627 }
628 
629 // --------------------------------
630 
631 inline SliderContainerElement::SliderContainerElement(Document&amp; document)
632     : HTMLDivElement(HTMLNames::divTag, document)
633 {
634     setHasCustomStyleResolveCallbacks();
635 }
636 
637 Ref&lt;SliderContainerElement&gt; SliderContainerElement::create(Document&amp; document)
638 {
639     return adoptRef(*new SliderContainerElement(document));
640 }
641 
642 RenderPtr&lt;RenderElement&gt; SliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
643 {
644     return createRenderer&lt;RenderSliderContainer&gt;(*this, WTFMove(style));
645 }
646 
<span class="line-modified">647 Optional&lt;ElementStyle&gt; SliderContainerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* hostStyle)</span>
648 {
649     // This doesn&#39;t actually compute style. This is just a hack to pick shadow pseudo id when host style is known.
650 
651     static NeverDestroyed&lt;const AtomString&gt; mediaSliderContainer(&quot;-webkit-media-slider-container&quot;, AtomString::ConstructFromLiteral);
652     static NeverDestroyed&lt;const AtomString&gt; sliderContainer(&quot;-webkit-slider-container&quot;, AtomString::ConstructFromLiteral);
653 
654     if (!hostStyle)
655         return WTF::nullopt;
656 
657     switch (hostStyle-&gt;appearance()) {
658     case MediaSliderPart:
659     case MediaSliderThumbPart:
660     case MediaVolumeSliderPart:
661     case MediaVolumeSliderThumbPart:
662     case MediaFullScreenVolumeSliderPart:
663     case MediaFullScreenVolumeSliderThumbPart:
664         m_shadowPseudoId = mediaSliderContainer;
665         break;
666     default:
667         m_shadowPseudoId = sliderContainer;
</pre>
</td>
<td>
<hr />
<pre>
229 {
230     auto input = hostInput();
231     return !input || input-&gt;isDisabledFormControl();
232 }
233 
234 bool SliderThumbElement::matchesReadWritePseudoClass() const
235 {
236     auto input = hostInput();
237     return input &amp;&amp; input-&gt;matchesReadWritePseudoClass();
238 }
239 
240 RefPtr&lt;Element&gt; SliderThumbElement::focusDelegate()
241 {
242     return hostInput();
243 }
244 
245 void SliderThumbElement::dragFrom(const LayoutPoint&amp; point)
246 {
247     Ref&lt;SliderThumbElement&gt; protectedThis(*this);
248     setPositionFromPoint(point);

249     startDragging();

250 }
251 
252 void SliderThumbElement::setPositionFromPoint(const LayoutPoint&amp; absolutePoint)
253 {
254     auto input = hostInput();
255     if (!input)
256         return;
257 
258     auto* inputRenderer = input-&gt;renderBox();
259     if (!inputRenderer)
260         return;
261 
262     auto* thumbRenderer = renderBox();
263     if (!thumbRenderer)
264         return;
265 
266     ASSERT(input-&gt;sliderTrackElement());
267     auto* trackRenderer = input-&gt;sliderTrackElement()-&gt;renderBox();
268     if (!trackRenderer)
269         return;
</pre>
<hr />
<pre>
319 void SliderThumbElement::startDragging()
320 {
321     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
322         frame-&gt;eventHandler().setCapturingMouseEventsElement(this);
323         m_inDragMode = true;
324     }
325 }
326 
327 void SliderThumbElement::stopDragging()
328 {
329     if (!m_inDragMode)
330         return;
331 
332     if (RefPtr&lt;Frame&gt; frame = document().frame())
333         frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
334     m_inDragMode = false;
335     if (renderer())
336         renderer()-&gt;setNeedsLayout();
337 }
338 

339 void SliderThumbElement::defaultEventHandler(Event&amp; event)
340 {
341     if (!is&lt;MouseEvent&gt;(event)) {
342         HTMLDivElement::defaultEventHandler(event);
343         return;
344     }
345 
346     // FIXME: Should handle this readonly/disabled check in more general way.
347     // Missing this kind of check is likely to occur elsewhere if adding it in each shadow element.
348     auto input = hostInput();
349     if (!input || input-&gt;isDisabledFormControl()) {
350         HTMLDivElement::defaultEventHandler(event);
351         return;
352     }
353 
354     MouseEvent&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
355     bool isLeftButton = mouseEvent.button() == LeftButton;
356     const AtomString&amp; eventType = mouseEvent.type();
357 
358     // We intentionally do not call event-&gt;setDefaultHandled() here because
359     // MediaControlTimelineElement::defaultEventHandler() wants to handle these
360     // mouse events.
361     if (eventType == eventNames().mousedownEvent &amp;&amp; isLeftButton) {
362         startDragging();
363         return;
364     } else if (eventType == eventNames().mouseupEvent &amp;&amp; isLeftButton) {
365         input-&gt;dispatchFormControlChangeEvent();
366         stopDragging();
367         return;
368     } else if (eventType == eventNames().mousemoveEvent) {
369         if (m_inDragMode)
370             setPositionFromPoint(mouseEvent.absoluteLocation());
371         return;
372     }
373 
374     HTMLDivElement::defaultEventHandler(mouseEvent);
375 }



376 
377 bool SliderThumbElement::willRespondToMouseMoveEvents()
378 {
379     const auto input = hostInput();
380     if (input &amp;&amp; !input-&gt;isDisabledFormControl() &amp;&amp; m_inDragMode)
381         return true;
382 
383     return HTMLDivElement::willRespondToMouseMoveEvents();
384 }
385 
386 bool SliderThumbElement::willRespondToMouseClickEvents()
387 {
388     const auto input = hostInput();
389     if (input &amp;&amp; !input-&gt;isDisabledFormControl())
390         return true;
391 
392     return HTMLDivElement::willRespondToMouseClickEvents();
393 }
394 

395 
396 void SliderThumbElement::willDetachRenderers()
397 {
398     if (m_inDragMode) {
399         if (RefPtr&lt;Frame&gt; frame = document().frame())
400             frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
401     }
402 #if ENABLE(IOS_TOUCH_EVENTS)
403     unregisterForTouchEvents();
404 #endif
405 }
406 
407 #if ENABLE(IOS_TOUCH_EVENTS)
408 
409 unsigned SliderThumbElement::exclusiveTouchIdentifier() const
410 {
411     return m_exclusiveTouchIdentifier;
412 }
413 
414 void SliderThumbElement::setExclusiveTouchIdentifier(unsigned identifier)
</pre>
<hr />
<pre>
566 void SliderThumbElement::hostDisabledStateChanged()
567 {
568     if (isDisabledFormControl())
569         stopDragging();
570 
571 #if ENABLE(IOS_TOUCH_EVENTS)
572     if (shouldAcceptTouchEvents())
573         registerForTouchEvents();
574     else
575         unregisterForTouchEvents();
576 #endif
577 }
578 
579 RefPtr&lt;HTMLInputElement&gt; SliderThumbElement::hostInput() const
580 {
581     // Only HTMLInputElement creates SliderThumbElement instances as its shadow nodes.
582     // So, shadowHost() must be an HTMLInputElement.
583     return downcast&lt;HTMLInputElement&gt;(shadowHost());
584 }
585 
<span class="line-modified">586 Optional&lt;Style::ElementStyle&gt; SliderThumbElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* hostStyle)</span>
587 {
588     // This doesn&#39;t actually compute style. This is just a hack to pick shadow pseudo id when host style is known.
589 
590     static NeverDestroyed&lt;const AtomString&gt; sliderThumbShadowPseudoId(&quot;-webkit-slider-thumb&quot;, AtomString::ConstructFromLiteral);
591     static NeverDestroyed&lt;const AtomString&gt; mediaSliderThumbShadowPseudoId(&quot;-webkit-media-slider-thumb&quot;, AtomString::ConstructFromLiteral);
592 
593     if (!hostStyle)
594         return WTF::nullopt;
595 
596     switch (hostStyle-&gt;appearance()) {
597     case MediaSliderPart:
598     case MediaSliderThumbPart:
599     case MediaVolumeSliderPart:
600     case MediaVolumeSliderThumbPart:
601     case MediaFullScreenVolumeSliderPart:
602     case MediaFullScreenVolumeSliderThumbPart:
603         m_shadowPseudoId = mediaSliderThumbShadowPseudoId;
604         break;
605     default:
606         m_shadowPseudoId = sliderThumbShadowPseudoId;
</pre>
<hr />
<pre>
620 }
621 
622 // --------------------------------
623 
624 inline SliderContainerElement::SliderContainerElement(Document&amp; document)
625     : HTMLDivElement(HTMLNames::divTag, document)
626 {
627     setHasCustomStyleResolveCallbacks();
628 }
629 
630 Ref&lt;SliderContainerElement&gt; SliderContainerElement::create(Document&amp; document)
631 {
632     return adoptRef(*new SliderContainerElement(document));
633 }
634 
635 RenderPtr&lt;RenderElement&gt; SliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
636 {
637     return createRenderer&lt;RenderSliderContainer&gt;(*this, WTFMove(style));
638 }
639 
<span class="line-modified">640 Optional&lt;Style::ElementStyle&gt; SliderContainerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* hostStyle)</span>
641 {
642     // This doesn&#39;t actually compute style. This is just a hack to pick shadow pseudo id when host style is known.
643 
644     static NeverDestroyed&lt;const AtomString&gt; mediaSliderContainer(&quot;-webkit-media-slider-container&quot;, AtomString::ConstructFromLiteral);
645     static NeverDestroyed&lt;const AtomString&gt; sliderContainer(&quot;-webkit-slider-container&quot;, AtomString::ConstructFromLiteral);
646 
647     if (!hostStyle)
648         return WTF::nullopt;
649 
650     switch (hostStyle-&gt;appearance()) {
651     case MediaSliderPart:
652     case MediaSliderThumbPart:
653     case MediaVolumeSliderPart:
654     case MediaVolumeSliderThumbPart:
655     case MediaFullScreenVolumeSliderPart:
656     case MediaFullScreenVolumeSliderThumbPart:
657         m_shadowPseudoId = mediaSliderContainer;
658         break;
659     default:
660         m_shadowPseudoId = sliderContainer;
</pre>
</td>
</tr>
</table>
<center><a href="ProgressShadowElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SliderThumbElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
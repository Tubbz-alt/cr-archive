<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/StochasticSpaceTimeMutatorScheduler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;StochasticSpaceTimeMutatorScheduler.h&quot;
 28 
 29 #include &quot;JSCInlines.h&quot;
 30 
 31 namespace JSC {
 32 
 33 // The scheduler will often make decisions based on state that is in flux. It will be fine so
 34 // long as multiple uses of the same value all see the same value. We wouldn&#39;t get this for free,
 35 // since our need to modularize the calculation results in a tendency to access the same mutable
 36 // field in Heap multiple times, and to access the current time multiple times.
 37 class StochasticSpaceTimeMutatorScheduler::Snapshot {
 38 public:
 39     Snapshot(StochasticSpaceTimeMutatorScheduler&amp; scheduler)
 40     {
 41         m_now = MonotonicTime::now();
 42         m_bytesAllocatedThisCycle = scheduler.bytesAllocatedThisCycleImpl();
 43     }
 44 
 45     MonotonicTime now() const { return m_now; }
 46 
 47     double bytesAllocatedThisCycle() const { return m_bytesAllocatedThisCycle; }
 48 
 49 private:
 50     MonotonicTime m_now;
 51     double m_bytesAllocatedThisCycle;
 52 };
 53 
 54 StochasticSpaceTimeMutatorScheduler::StochasticSpaceTimeMutatorScheduler(Heap&amp; heap)
 55     : m_heap(heap)
 56     , m_minimumPause(Seconds::fromMilliseconds(Options::minimumGCPauseMS()))
 57     , m_pauseScale(Options::gcPauseScale())
 58 {
 59 }
 60 
 61 StochasticSpaceTimeMutatorScheduler::~StochasticSpaceTimeMutatorScheduler()
 62 {
 63 }
 64 
 65 MutatorScheduler::State StochasticSpaceTimeMutatorScheduler::state() const
 66 {
 67     return m_state;
 68 }
 69 
 70 void StochasticSpaceTimeMutatorScheduler::beginCollection()
 71 {
 72     RELEASE_ASSERT(m_state == Normal);
 73     m_state = Stopped;
 74 
 75     m_bytesAllocatedThisCycleAtTheBeginning = m_heap.m_bytesAllocatedThisCycle;
 76     m_bytesAllocatedThisCycleAtTheEnd =
 77         Options::concurrentGCMaxHeadroom() *
 78         std::max&lt;double&gt;(m_bytesAllocatedThisCycleAtTheBeginning, m_heap.m_maxEdenSize);
 79 
 80     dataLogIf(Options::logGC(), &quot;ca=&quot;, m_bytesAllocatedThisCycleAtTheBeginning / 1024, &quot;kb h=&quot;, (m_bytesAllocatedThisCycleAtTheEnd - m_bytesAllocatedThisCycleAtTheBeginning) / 1024, &quot;kb &quot;);
 81 
 82     m_beforeConstraints = MonotonicTime::now();
 83 }
 84 
 85 void StochasticSpaceTimeMutatorScheduler::didStop()
 86 {
 87     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 88     m_state = Stopped;
 89 }
 90 
 91 void StochasticSpaceTimeMutatorScheduler::willResume()
 92 {
 93     RELEASE_ASSERT(m_state == Stopped || m_state == Resumed);
 94     m_state = Resumed;
 95 }
 96 
 97 void StochasticSpaceTimeMutatorScheduler::didReachTermination()
 98 {
 99     m_beforeConstraints = MonotonicTime::now();
100 }
101 
102 void StochasticSpaceTimeMutatorScheduler::didExecuteConstraints()
103 {
104     Snapshot snapshot(*this);
105 
106     Seconds constraintExecutionDuration = snapshot.now() - m_beforeConstraints;
107 
108     m_targetPause = std::max(
109         constraintExecutionDuration * m_pauseScale,
110         m_minimumPause);
111 
112     dataLogIf(Options::logGC(), &quot;tp=&quot;, m_targetPause.milliseconds(), &quot;ms &quot;);
113 
114     m_plannedResumeTime = snapshot.now() + m_targetPause;
115 }
116 
117 void StochasticSpaceTimeMutatorScheduler::synchronousDrainingDidStall()
118 {
119     Snapshot snapshot(*this);
120 
121     double resumeProbability = mutatorUtilization(snapshot);
122     if (resumeProbability &lt; Options::epsilonMutatorUtilization()) {
123         m_plannedResumeTime = MonotonicTime::infinity();
124         return;
125     }
126 
127     bool shouldResume = m_random.get() &lt; resumeProbability;
128 
129     if (shouldResume) {
130         m_plannedResumeTime = snapshot.now();
131         return;
132     }
133 
134     m_plannedResumeTime = snapshot.now() + m_targetPause;
135 }
136 
137 MonotonicTime StochasticSpaceTimeMutatorScheduler::timeToStop()
138 {
139     switch (m_state) {
140     case Normal:
141         return MonotonicTime::infinity();
142     case Stopped:
143         return MonotonicTime::now();
144     case Resumed: {
145         // Once we&#39;re running, we keep going unless we run out of headroom.
146         Snapshot snapshot(*this);
147         if (mutatorUtilization(snapshot) &lt; Options::epsilonMutatorUtilization())
148             return MonotonicTime::now();
149         return MonotonicTime::infinity();
150     } }
151 
152     RELEASE_ASSERT_NOT_REACHED();
153     return MonotonicTime();
154 }
155 
156 MonotonicTime StochasticSpaceTimeMutatorScheduler::timeToResume()
157 {
158     switch (m_state) {
159     case Normal:
160     case Resumed:
161         return MonotonicTime::now();
162     case Stopped:
163         return m_plannedResumeTime;
164     }
165 
166     RELEASE_ASSERT_NOT_REACHED();
167     return MonotonicTime();
168 }
169 
170 void StochasticSpaceTimeMutatorScheduler::log()
171 {
172     ASSERT(Options::logGC());
173     Snapshot snapshot(*this);
174     dataLog(
175         &quot;a=&quot;, format(&quot;%.0lf&quot;, bytesSinceBeginningOfCycle(snapshot) / 1024), &quot;kb &quot;,
176         &quot;hf=&quot;, format(&quot;%.3lf&quot;, headroomFullness(snapshot)), &quot; &quot;,
177         &quot;mu=&quot;, format(&quot;%.3lf&quot;, mutatorUtilization(snapshot)), &quot; &quot;);
178 }
179 
180 void StochasticSpaceTimeMutatorScheduler::endCollection()
181 {
182     m_state = Normal;
183 }
184 
185 double StochasticSpaceTimeMutatorScheduler::bytesAllocatedThisCycleImpl()
186 {
187     return m_heap.m_bytesAllocatedThisCycle;
188 }
189 
190 double StochasticSpaceTimeMutatorScheduler::bytesSinceBeginningOfCycle(const Snapshot&amp; snapshot)
191 {
192     return snapshot.bytesAllocatedThisCycle() - m_bytesAllocatedThisCycleAtTheBeginning;
193 }
194 
195 double StochasticSpaceTimeMutatorScheduler::maxHeadroom()
196 {
197     return m_bytesAllocatedThisCycleAtTheEnd - m_bytesAllocatedThisCycleAtTheBeginning;
198 }
199 
200 double StochasticSpaceTimeMutatorScheduler::headroomFullness(const Snapshot&amp; snapshot)
201 {
202     double result = bytesSinceBeginningOfCycle(snapshot) / maxHeadroom();
203 
204     // headroomFullness can be NaN and other interesting things if
205     // bytesAllocatedThisCycleAtTheBeginning is zero. We see that in debug tests. This code
206     // defends against all floating point dragons.
207 
208     if (!(result &gt;= 0))
209         result = 0;
210     if (!(result &lt;= 1))
211         result = 1;
212 
213     return result;
214 }
215 
216 double StochasticSpaceTimeMutatorScheduler::mutatorUtilization(const Snapshot&amp; snapshot)
217 {
218     double mutatorUtilization = 1 - headroomFullness(snapshot);
219 
220     // Scale the mutator utilization into the permitted window.
221     mutatorUtilization =
222         Options::minimumMutatorUtilization() +
223         mutatorUtilization * (
224             Options::maximumMutatorUtilization() -
225             Options::minimumMutatorUtilization());
226 
227     return mutatorUtilization;
228 }
229 
230 } // namespace JSC
231 
    </pre>
  </body>
</html>
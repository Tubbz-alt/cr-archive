<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Interpreter.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InterpreterInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 65,11 ***</span>
  
      enum DebugHookType {
          WillExecuteProgram,
          DidExecuteProgram,
          DidEnterCallFrame,
<span class="line-modified">!         DidReachBreakpoint,</span>
          WillLeaveCallFrame,
          WillExecuteStatement,
          WillExecuteExpression,
      };
  
<span class="line-new-header">--- 65,11 ---</span>
  
      enum DebugHookType {
          WillExecuteProgram,
          DidExecuteProgram,
          DidEnterCallFrame,
<span class="line-modified">!         DidReachDebuggerStatement,</span>
          WillLeaveCallFrame,
          WillExecuteStatement,
          WillExecuteExpression,
      };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,24 ***</span>
  
          static inline Opcode getOpcode(OpcodeID);
  
          static inline OpcodeID getOpcodeID(Opcode);
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          static bool isOpcode(Opcode);
  #endif
  
<span class="line-modified">!         JSValue executeProgram(const SourceCode&amp;, CallFrame*, JSObject* thisObj);</span>
<span class="line-modified">!         JSValue executeModuleProgram(ModuleProgramExecutable*, CallFrame*, JSModuleEnvironment*);</span>
<span class="line-modified">!         JSValue executeCall(CallFrame*, JSObject* function, CallType, const CallData&amp;, JSValue thisValue, const ArgList&amp;);</span>
<span class="line-modified">!         JSObject* executeConstruct(CallFrame*, JSObject* function, ConstructType, const ConstructData&amp;, const ArgList&amp;, JSValue newTarget);</span>
<span class="line-modified">!         JSValue execute(EvalExecutable*, CallFrame*, JSValue thisValue, JSScope*);</span>
  
          void getArgumentsData(CallFrame*, JSFunction*&amp;, ptrdiff_t&amp; firstParameterIndex, Register*&amp; argv, int&amp; argc);
  
          NEVER_INLINE HandlerInfo* unwind(VM&amp;, CallFrame*&amp;, Exception*);
<span class="line-modified">!         void notifyDebuggerOfExceptionToBeThrown(VM&amp;, CallFrame*, Exception*);</span>
          NEVER_INLINE void debug(CallFrame*, DebugHookType);
          static String stackTraceAsString(VM&amp;, const Vector&lt;StackFrame&gt;&amp;);
  
          void getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip = 0, size_t maxStackSize = std::numeric_limits&lt;size_t&gt;::max());
  
<span class="line-new-header">--- 98,24 ---</span>
  
          static inline Opcode getOpcode(OpcodeID);
  
          static inline OpcodeID getOpcodeID(Opcode);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
          static bool isOpcode(Opcode);
  #endif
  
<span class="line-modified">!         JSValue executeProgram(const SourceCode&amp;, JSGlobalObject*, JSObject* thisObj);</span>
<span class="line-modified">!         JSValue executeModuleProgram(ModuleProgramExecutable*, JSGlobalObject*, JSModuleEnvironment*);</span>
<span class="line-modified">!         JSValue executeCall(JSGlobalObject*, JSObject* function, CallType, const CallData&amp;, JSValue thisValue, const ArgList&amp;);</span>
<span class="line-modified">!         JSObject* executeConstruct(JSGlobalObject*, JSObject* function, ConstructType, const ConstructData&amp;, const ArgList&amp;, JSValue newTarget);</span>
<span class="line-modified">!         JSValue execute(EvalExecutable*, JSGlobalObject*, JSValue thisValue, JSScope*);</span>
  
          void getArgumentsData(CallFrame*, JSFunction*&amp;, ptrdiff_t&amp; firstParameterIndex, Register*&amp; argv, int&amp; argc);
  
          NEVER_INLINE HandlerInfo* unwind(VM&amp;, CallFrame*&amp;, Exception*);
<span class="line-modified">!         void notifyDebuggerOfExceptionToBeThrown(VM&amp;, JSGlobalObject*, CallFrame*, Exception*);</span>
          NEVER_INLINE void debug(CallFrame*, DebugHookType);
          static String stackTraceAsString(VM&amp;, const Vector&lt;StackFrame&gt;&amp;);
  
          void getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip = 0, size_t maxStackSize = std::numeric_limits&lt;size_t&gt;::max());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,17 ***</span>
  #if ENABLE(C_LOOP)
          CLoopStack m_cloopStack;
  #endif
  
  #if ENABLE(COMPUTED_GOTO_OPCODES)
<span class="line-modified">! #if !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED</span>
          static HashMap&lt;Opcode, OpcodeID&gt;&amp; opcodeIDTable(); // Maps Opcode =&gt; OpcodeID.
<span class="line-modified">! #endif // !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED</span>
  #endif // ENABLE(COMPUTED_GOTO_OPCODES)
      };
  
<span class="line-modified">!     JSValue eval(CallFrame*);</span>
  
      inline CallFrame* calleeFrameForVarargs(CallFrame* callFrame, unsigned numUsedStackSlots, unsigned argumentCountIncludingThis)
      {
          // We want the new frame to be allocated on a stack aligned offset with a stack
          // aligned size. Align the size here.
<span class="line-new-header">--- 142,17 ---</span>
  #if ENABLE(C_LOOP)
          CLoopStack m_cloopStack;
  #endif
  
  #if ENABLE(COMPUTED_GOTO_OPCODES)
<span class="line-modified">! #if !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
          static HashMap&lt;Opcode, OpcodeID&gt;&amp; opcodeIDTable(); // Maps Opcode =&gt; OpcodeID.
<span class="line-modified">! #endif // !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
  #endif // ENABLE(COMPUTED_GOTO_OPCODES)
      };
  
<span class="line-modified">!     JSValue eval(JSGlobalObject*, CallFrame*);</span>
  
      inline CallFrame* calleeFrameForVarargs(CallFrame* callFrame, unsigned numUsedStackSlots, unsigned argumentCountIncludingThis)
      {
          // We want the new frame to be allocated on a stack aligned offset with a stack
          // aligned size. Align the size here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,19 ***</span>
              stackAlignmentRegisters(),
              numUsedStackSlots + argumentCountIncludingThis + CallFrame::headerSizeInRegisters);
          return CallFrame::create(callFrame-&gt;registers() - paddedCalleeFrameOffset);
      }
  
<span class="line-modified">!     unsigned sizeOfVarargs(CallFrame* exec, JSValue arguments, uint32_t firstVarArgOffset);</span>
<span class="line-modified">!     static const unsigned maxArguments = 0x10000;</span>
<span class="line-modified">!     unsigned sizeFrameForVarargs(CallFrame* exec, VM&amp;, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset);</span>
<span class="line-modified">!     unsigned sizeFrameForForwardArguments(CallFrame* exec, VM&amp;, unsigned numUsedStackSlots);</span>
<span class="line-modified">!     void loadVarargs(CallFrame* execCaller, VirtualRegister firstElementDest, JSValue source, uint32_t offset, uint32_t length);</span>
<span class="line-modified">!     void setupVarargsFrame(CallFrame* execCaller, CallFrame* execCallee, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length);</span>
<span class="line-modified">!     void setupVarargsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length);</span>
<span class="line-modified">!     void setupForwardArgumentsFrame(CallFrame* execCaller, CallFrame* execCallee, uint32_t length);</span>
<span class="line-modified">!     void setupForwardArgumentsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length);</span>
  
  } // namespace JSC
  
  namespace WTF {
  
<span class="line-new-header">--- 165,19 ---</span>
              stackAlignmentRegisters(),
              numUsedStackSlots + argumentCountIncludingThis + CallFrame::headerSizeInRegisters);
          return CallFrame::create(callFrame-&gt;registers() - paddedCalleeFrameOffset);
      }
  
<span class="line-modified">!     unsigned sizeOfVarargs(JSGlobalObject*, JSValue arguments, uint32_t firstVarArgOffset);</span>
<span class="line-modified">!     static constexpr unsigned maxArguments = 0x10000;</span>
<span class="line-modified">!     unsigned sizeFrameForVarargs(JSGlobalObject*, CallFrame*, VM&amp;, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset);</span>
<span class="line-modified">!     unsigned sizeFrameForForwardArguments(JSGlobalObject*, CallFrame*, VM&amp;, unsigned numUsedStackSlots);</span>
<span class="line-modified">!     void loadVarargs(JSGlobalObject*, JSValue* firstElementDest, JSValue source, uint32_t offset, uint32_t length);</span>
<span class="line-modified">!     void setupVarargsFrame(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length);</span>
<span class="line-modified">!     void setupVarargsFrameAndSetThis(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length);</span>
<span class="line-modified">!     void setupForwardArgumentsFrame(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, uint32_t length);</span>
<span class="line-modified">!     void setupForwardArgumentsFrameAndSetThis(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length);</span>
  
  } // namespace JSC
  
  namespace WTF {
  
</pre>
<center><a href="Interpreter.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InterpreterInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
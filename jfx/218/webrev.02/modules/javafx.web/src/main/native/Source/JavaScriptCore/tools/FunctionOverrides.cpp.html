<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/FunctionOverrides.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FunctionOverrides.h&quot;
 28 
 29 #include &quot;Options.h&quot;
 30 #include &lt;stdio.h&gt;
 31 #include &lt;string.h&gt;
 32 #include &lt;wtf/DataLog.h&gt;
 33 #include &lt;wtf/NeverDestroyed.h&gt;
 34 #include &lt;wtf/text/CString.h&gt;
 35 #include &lt;wtf/text/StringBuilder.h&gt;
 36 #include &lt;wtf/text/StringHash.h&gt;
 37 
 38 namespace JSC {
 39 
 40 /*
 41   The overrides file defines function bodies that we will want to override with
 42   a replacement for debugging purposes. The overrides file may contain
 43   &#39;override&#39; and &#39;with&#39; clauses like these:
 44 
 45      // Example 1: function foo1(a)
 46      override !@#$%{ print(&quot;In foo1&quot;); }!@#$%
 47      with abc{
 48          print(&quot;I am overridden&quot;);
 49      }abc
 50 
 51      // Example 2: function foo2(a)
 52      override %%%{
 53          print(&quot;foo2&#39;s body has a string with }%% in it.&quot;);
 54          // Because }%% appears in the function body here, we cannot use
 55          // %% or % as the delimiter. %%% is ok though.
 56      }%%%
 57      with %%%{
 58          print(&quot;Overridden foo2&quot;);
 59      }%%%
 60 
 61   1. Comments are lines starting with //.  All comments will be ignored.
 62 
 63   2. An &#39;override&#39; clause is used to specify the original function body we
 64      want to override. The with clause is used to specify the overriding
 65      function body.
 66 
 67      An &#39;override&#39; clause must be followed immediately by a &#39;with&#39; clause.
 68 
 69   3. An &#39;override&#39; clause must be of the form:
 70          override &lt;delimiter&gt;{...function body...}&lt;delimiter&gt;
 71 
 72      The override keyword must be at the start of the line.
 73 
 74      &lt;delimiter&gt; may be any string of any ASCII characters (except for &#39;{&#39;,
 75      &#39;}&#39;, and whitespace characters) as long as the pattern of &quot;}&lt;delimiter&gt;&quot;
 76      does not appear in the function body e.g. the override clause of Example 2
 77      above illustrates this.
 78 
 79      The start and end &lt;delimiter&gt; must be identical.
 80 
 81      The space between the override keyword and the start &lt;delimiter&gt; is
 82      required.
 83 
 84      All characters between the pair of delimiters will be considered to
 85      be part of the function body string. This allows us to also work
 86      with script source that are multi-lined i.e. newlines are allowed.
 87 
 88   4. A &#39;with&#39; clause is identical in form to an &#39;override&#39; clause except that
 89      it uses the &#39;with&#39; keyword instead of the &#39;override&#39; keyword.
 90  */
 91 
 92 struct FunctionOverridesAssertScope {
 93     FunctionOverridesAssertScope() { RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled); }
 94     ~FunctionOverridesAssertScope() { RELEASE_ASSERT(g_jscConfig.restrictedOptionsEnabled); }
 95 };
 96 
 97 FunctionOverrides&amp; FunctionOverrides::overrides()
 98 {
 99     FunctionOverridesAssertScope assertScope;
100     static LazyNeverDestroyed&lt;FunctionOverrides&gt; overrides;
101     static std::once_flag initializeListFlag;
102     std::call_once(initializeListFlag, [] {
103         FunctionOverridesAssertScope assertScope;
104         const char* overridesFileName = Options::functionOverrides();
105         overrides.construct(overridesFileName);
106     });
107     return overrides;
108 }
109 
110 FunctionOverrides::FunctionOverrides(const char* overridesFileName)
111 {
112     FunctionOverridesAssertScope assertScope;
113     parseOverridesInFile(holdLock(m_lock), overridesFileName);
114 }
115 
116 void FunctionOverrides::reinstallOverrides()
117 {
118     FunctionOverridesAssertScope assertScope;
119     FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
120     auto locker = holdLock(overrides.m_lock);
121     const char* overridesFileName = Options::functionOverrides();
122     overrides.clear(locker);
123     overrides.parseOverridesInFile(locker, overridesFileName);
124 }
125 
126 static void initializeOverrideInfo(const SourceCode&amp; origCode, const String&amp; newBody, FunctionOverrides::OverrideInfo&amp; info)
127 {
128     FunctionOverridesAssertScope assertScope;
129     String origProviderStr = origCode.provider()-&gt;source().toString();
130     unsigned origStart = origCode.startOffset();
131     unsigned origFunctionStart = origProviderStr.reverseFind(&quot;function&quot;, origStart);
132     unsigned origBraceStart = origProviderStr.find(&quot;{&quot;, origStart);
133     unsigned headerLength = origBraceStart - origFunctionStart;
134     String origHeader = origProviderStr.substring(origFunctionStart, headerLength);
135 
136     String newProviderStr;
137     newProviderStr.append(origHeader);
138     newProviderStr.append(newBody);
139 
140     Ref&lt;SourceProvider&gt; newProvider = StringSourceProvider::create(newProviderStr, SourceOrigin { &quot;&lt;overridden&gt;&quot; }, URL({ }, &quot;&lt;overridden&gt;&quot;));
141 
142     info.firstLine = 1;
143     info.lineCount = 1; // Faking it. This doesn&#39;t really matter for now.
144     info.startColumn = 1;
145     info.endColumn = 1; // Faking it. This doesn&#39;t really matter for now.
146     info.parametersStartOffset = newProviderStr.find(&quot;(&quot;);
147     info.typeProfilingStartOffset = newProviderStr.find(&quot;{&quot;);
148     info.typeProfilingEndOffset = newProviderStr.length() - 1;
149 
150     info.sourceCode =
151         SourceCode(WTFMove(newProvider), info.parametersStartOffset, info.typeProfilingEndOffset + 1, 1, 1);
152 }
153 
154 bool FunctionOverrides::initializeOverrideFor(const SourceCode&amp; origCode, FunctionOverrides::OverrideInfo&amp; result)
155 {
156     FunctionOverridesAssertScope assertScope;
157     RELEASE_ASSERT(Options::functionOverrides());
158     FunctionOverrides&amp; overrides = FunctionOverrides::overrides();
159 
160     String sourceString = origCode.view().toString();
161     size_t sourceBodyStart = sourceString.find(&#39;{&#39;);
162     if (sourceBodyStart == notFound)
163         return false;
164     String sourceBodyString = sourceString.substring(sourceBodyStart);
165 
166     String newBody;
167     {
168         auto locker = holdLock(overrides.m_lock);
169         auto it = overrides.m_entries.find(sourceBodyString.isolatedCopy());
170         if (it == overrides.m_entries.end())
171             return false;
172         newBody = it-&gt;value.isolatedCopy();
173     }
174 
175     initializeOverrideInfo(origCode, newBody, result);
176     RELEASE_ASSERT(Options::functionOverrides());
177     return true;
178 }
179 
180 #define SYNTAX_ERROR &quot;SYNTAX ERROR&quot;
181 #define IO_ERROR &quot;IO ERROR&quot;
182 #define FAIL_WITH_ERROR(error, errorMessageInBrackets) \
183     do { \
184         dataLog(&quot;functionOverrides &quot;, error, &quot;: &quot;); \
185         dataLog errorMessageInBrackets; \
186         exit(EXIT_FAILURE); \
187     } while (false)
188 
189 static bool hasDisallowedCharacters(const char* str, size_t length)
190 {
191     while (length--) {
192         char c = *str++;
193         // &#39;{&#39; is also disallowed, but we don&#39;t need to check for it because
194         // parseClause() searches for &#39;{&#39; as the end of the start delimiter.
195         // As a result, the parsed delimiter string will never include &#39;{&#39;.
196         if (c == &#39;}&#39; || isASCIISpace(c))
197             return true;
198     }
199     return false;
200 }
201 
202 static String parseClause(const char* keyword, size_t keywordLength, FILE* file, const char* line, char* buffer, size_t bufferSize)
203 {
204     FunctionOverridesAssertScope assertScope;
205     const char* keywordPos = strstr(line, keyword);
206     if (!keywordPos)
207         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Expecting &#39;&quot;, keyword, &quot;&#39; clause:\n&quot;, line, &quot;\n&quot;));
208     if (keywordPos != line)
209         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Cannot have any characters before &#39;&quot;, keyword, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
210     if (line[keywordLength] != &#39; &#39;)
211         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; must be followed by a &#39; &#39;:\n&quot;, line, &quot;\n&quot;));
212 
213     const char* delimiterStart = &amp;line[keywordLength + 1];
214     const char* delimiterEnd = strstr(delimiterStart, &quot;{&quot;);
215     if (!delimiterEnd)
216         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Missing { after &#39;&quot;, keyword, &quot;&#39; clause start delimiter:\n&quot;, line, &quot;\n&quot;));
217 
218     size_t delimiterLength = delimiterEnd - delimiterStart;
219     String delimiter(delimiterStart, delimiterLength);
220 
221     if (hasDisallowedCharacters(delimiterStart, delimiterLength))
222         FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Delimiter &#39;&quot;, delimiter, &quot;&#39; cannot have &#39;{&#39;, &#39;}&#39;, or whitespace:\n&quot;, line, &quot;\n&quot;));
223 
224     String terminatorString;
225     terminatorString.append(&#39;}&#39;);
226     terminatorString.append(delimiter);
227 
228     CString terminatorCString = terminatorString.ascii();
229     const char* terminator = terminatorCString.data();
230     line = delimiterEnd; // Start from the {.
231 
232     StringBuilder builder;
233     do {
234         const char* p = strstr(line, terminator);
235         if (p) {
236             if (p[strlen(terminator)] != &#39;\n&#39;)
237                 FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;Unexpected characters after &#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39;:\n&quot;, line, &quot;\n&quot;));
238 
239             builder.appendCharacters(line, p - line + 1);
240             return builder.toString();
241         }
242         builder.append(line);
243 
244     } while ((line = fgets(buffer, bufferSize, file)));
245 
246     FAIL_WITH_ERROR(SYNTAX_ERROR, (&quot;&#39;&quot;, keyword, &quot;&#39; clause end delimiter &#39;&quot;, delimiter, &quot;&#39; not found:\n&quot;, builder.toString(), &quot;\n&quot;, &quot;Are you missing a &#39;}&#39; before the delimiter?\n&quot;));
247 }
248 
249 void FunctionOverrides::parseOverridesInFile(const AbstractLocker&amp;, const char* fileName)
250 {
251     FunctionOverridesAssertScope assertScope;
252     if (!fileName)
253         return;
254 
255     FILE* file = fopen(fileName, &quot;r&quot;);
256     if (!file)
257         FAIL_WITH_ERROR(IO_ERROR, (&quot;Failed to open file &quot;, fileName, &quot;. Did you add the file-read-data entitlement to WebProcess.sb?\n&quot;));
258 
259     char* line;
260     char buffer[BUFSIZ];
261     while ((line = fgets(buffer, sizeof(buffer), file))) {
262         if (strstr(line, &quot;//&quot;) == line)
263             continue;
264 
265         if (line[0] == &#39;\n&#39; || line[0] == &#39;\0&#39;)
266             continue;
267 
268         size_t keywordLength;
269 
270         keywordLength = sizeof(&quot;override&quot;) - 1;
271         String keyStr = parseClause(&quot;override&quot;, keywordLength, file, line, buffer, sizeof(buffer));
272 
273         line = fgets(buffer, sizeof(buffer), file);
274 
275         keywordLength = sizeof(&quot;with&quot;) - 1;
276         String valueStr = parseClause(&quot;with&quot;, keywordLength, file, line, buffer, sizeof(buffer));
277 
278         m_entries.add(keyStr, valueStr);
279     }
280 
281     int result = fclose(file);
282     if (result)
283         dataLogF(&quot;Failed to close file %s: %s\n&quot;, fileName, strerror(errno));
284 }
285 
286 } // namespace JSC
287 
    </pre>
  </body>
</html>
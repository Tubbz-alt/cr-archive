diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/ComplexLineLayout.cpp
@@ -56,11 +56,17 @@
 ComplexLineLayout::ComplexLineLayout(RenderBlockFlow& flow)
     : m_flow(flow)
 {
 }
 
-ComplexLineLayout::~ComplexLineLayout() = default;
+ComplexLineLayout::~ComplexLineLayout()
+{
+    if (m_flow.containsFloats())
+        m_flow.floatingObjects()->clearLineBoxTreePointers();
+
+    lineBoxes().deleteLineBoxTree();
+};
 
 static void determineDirectionality(TextDirection& dir, InlineIterator iter)
 {
     while (!iter.atEnd()) {
         if (iter.atParagraphSeparator())
@@ -568,11 +574,11 @@
     auto& rubyBase = *rubyRun.rubyBase();
     auto& rootBox = *rubyBase.firstRootBox();
 
     float totalExpansion = 0;
     unsigned totalOpportunitiesInRun = 0;
-    for (auto* leafChild = rootBox.firstLeafChild(); leafChild; leafChild = leafChild->nextLeafChild()) {
+    for (auto* leafChild = rootBox.firstLeafDescendant(); leafChild; leafChild = leafChild->nextLeafOnLine()) {
         if (!leafChild->isInlineTextBox())
             continue;
 
         unsigned opportunitiesInRun = expansionOpportunities[i++];
         ASSERT(opportunitiesInRun <= expansionOpportunityCount);
@@ -733,11 +739,11 @@
     if (textAlign == TextAlignMode::Justify) {
         // If the next box is ruby, and we're justifying, and the first box in the ruby base has a leading expansion, and we are a text box, then force a trailing expansion.
         if (nextRun && is<RenderRubyRun>(nextRun->renderer()) && downcast<RenderRubyRun>(nextRun->renderer()).rubyBase() && nextRun->renderer().style().collapseWhiteSpace()) {
             auto& rubyBase = *downcast<RenderRubyRun>(nextRun->renderer()).rubyBase();
             if (rubyBase.firstRootBox() && !rubyBase.firstRootBox()->nextRootBox()) {
-                if (auto* leafChild = rubyBase.firstRootBox()->firstLeafChild()) {
+                if (auto* leafChild = rubyBase.firstRootBox()->firstLeafDescendant()) {
                     if (is<InlineTextBox>(*leafChild)) {
                         // FIXME: This leadingExpansionOpportunity doesn't actually work because it doesn't perform the UBA
                         if (FontCascade::leadingExpansionOpportunity(downcast<RenderText>(leafChild->renderer()).stringView(), leafChild->direction())) {
                             setTrailingExpansion = true;
                             result |= ForceTrailingExpansion;
@@ -748,11 +754,11 @@
         }
         // Same thing, except if we're following a ruby
         if (previousRun && is<RenderRubyRun>(previousRun->renderer()) && downcast<RenderRubyRun>(previousRun->renderer()).rubyBase() && previousRun->renderer().style().collapseWhiteSpace()) {
             auto& rubyBase = *downcast<RenderRubyRun>(previousRun->renderer()).rubyBase();
             if (rubyBase.firstRootBox() && !rubyBase.firstRootBox()->nextRootBox()) {
-                if (auto* leafChild = rubyBase.firstRootBox()->lastLeafChild()) {
+                if (auto* leafChild = rubyBase.firstRootBox()->lastLeafDescendant()) {
                     if (is<InlineTextBox>(*leafChild)) {
                         // FIXME: This leadingExpansionOpportunity doesn't actually work because it doesn't perform the UBA
                         if (FontCascade::trailingExpansionOpportunity(downcast<RenderText>(leafChild->renderer()).stringView(), leafChild->direction())) {
                             setLeadingExpansion = true;
                             result |= ForceLeadingExpansion;
@@ -762,14 +768,14 @@
             }
         }
         // If we're the first box inside a ruby base, forbid a leading expansion, and vice-versa
         if (is<RenderRubyBase>(block)) {
             RenderRubyBase& rubyBase = downcast<RenderRubyBase>(block);
-            if (&textBox == rubyBase.firstRootBox()->firstLeafChild()) {
+            if (&textBox == rubyBase.firstRootBox()->firstLeafDescendant()) {
                 setLeadingExpansion = true;
                 result |= ForbidLeadingExpansion;
-            } if (&textBox == rubyBase.firstRootBox()->lastLeafChild()) {
+            } if (&textBox == rubyBase.firstRootBox()->lastLeafDescendant()) {
                 setTrailingExpansion = true;
                 result |= ForbidTrailingExpansion;
             }
         }
     }
@@ -918,11 +924,11 @@
             bool encounteredJustifiedRuby = false;
             if (is<RenderRubyRun>(run->renderer()) && textAlign == TextAlignMode::Justify && run != trailingSpaceRun && downcast<RenderRubyRun>(run->renderer()).rubyBase()) {
                 auto* rubyBase = downcast<RenderRubyRun>(run->renderer()).rubyBase();
                 if (rubyBase->firstRootBox() && !rubyBase->firstRootBox()->nextRootBox() && run->renderer().style().collapseWhiteSpace()) {
                     rubyBase->setIsAfterExpansion(isAfterExpansion);
-                    for (auto* leafChild = rubyBase->firstRootBox()->firstLeafChild(); leafChild; leafChild = leafChild->nextLeafChild()) {
+                    for (auto* leafChild = rubyBase->firstRootBox()->firstLeafDescendant(); leafChild; leafChild = leafChild->nextLeafOnLine()) {
                         if (!is<InlineTextBox>(*leafChild))
                             continue;
                         encounteredJustifiedRuby = true;
                         computeExpansionOpportunities(*rubyBase, downcast<InlineTextBox>(*leafChild), nullptr, nullptr,
                             downcast<RenderText>(leafChild->renderer()).stringView(), leafChild->direction());
@@ -969,11 +975,11 @@
 }
 
 void ComplexLineLayout::removeInlineBox(BidiRun& run, const RootInlineBox& rootLineBox) const
 {
     auto* inlineBox = run.box();
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     auto* inlineParent = inlineBox->parent();
     while (inlineParent && inlineParent != &rootLineBox) {
         ASSERT(!inlineParent->isDirty());
         inlineParent = inlineParent->parent();
     }
@@ -1315,14 +1321,14 @@
 
     if (!layoutState.isFullLayout() && lastRootBox() && lastRootBox()->endsWithBreak()) {
         // If the last line before the start line ends with a line break that clear floats,
         // adjust the height accordingly.
         // A line break can be either the first or the last object on a line, depending on its direction.
-        if (InlineBox* lastLeafChild = lastRootBox()->lastLeafChild()) {
-            RenderObject* lastObject = &lastLeafChild->renderer();
+        if (InlineBox* lastLeafDescendant = lastRootBox()->lastLeafDescendant()) {
+            RenderObject* lastObject = &lastLeafDescendant->renderer();
             if (!lastObject->isBR())
-                lastObject = &lastRootBox()->firstLeafChild()->renderer();
+                lastObject = &lastRootBox()->firstLeafDescendant()->renderer();
             if (lastObject->isBR()) {
                 Clear clear = lastObject->style().clear();
                 if (clear != Clear::None)
                     m_flow.clearFloats(clear);
             }
@@ -1548,11 +1554,11 @@
             lineBox = currentFirstLineOfNewPage;
             for (int i = 0; i < numLinesToTake; ++i)
                 lineBox = lineBox->prevRootBox();
 
             // We now want to break at this line. Remember for next layout and trigger relayout.
-            m_flow.setBreakAtLineToAvoidWidow(m_flow.lineCount(lineBox));
+            m_flow.setBreakAtLineToAvoidWidow(lineCountUntil(lineBox));
             m_flow.markLinesDirtyInBlockRange(lastRootBox()->lineBottomWithLeading(), lineBox->lineBottomWithLeading(), lineBox);
         }
     }
     m_flow.clearDidBreakAtLineToAvoidWidow();
 }
@@ -2100,10 +2106,31 @@
                 fragment->addVisualOverflowForBox(&m_flow, childVisualOverflowRect);
         }
     }
 }
 
+size_t ComplexLineLayout::lineCount() const
+{
+    size_t count = 0;
+    for (auto* box = firstRootBox(); box; box = box->nextRootBox())
+        ++count;
+
+    return count;
+}
+
+size_t ComplexLineLayout::lineCountUntil(const RootInlineBox* stopRootInlineBox) const
+{
+    size_t count = 0;
+    for (auto* box = firstRootBox(); box; box = box->nextRootBox()) {
+        ++count;
+        if (box == stopRootInlineBox)
+            break;
+    }
+
+    return count;
+}
+
 void ComplexLineLayout::deleteEllipsisLineBoxes()
 {
     TextAlignMode textAlign = style().textAlign();
     bool ltr = style().isLeftToRightDirection();
     IndentTextOrNot shouldIndentText = IndentText;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedBytecode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CachedTypes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
  29 #include &quot;BytecodeCacheError.h&quot;
<span class="line-removed">  30 #include &quot;BytecodeCacheVersion.h&quot;</span>
  31 #include &quot;BytecodeLivenessAnalysis.h&quot;
  32 #include &quot;JSCInlines.h&quot;
  33 #include &quot;JSImmutableButterfly.h&quot;
  34 #include &quot;JSTemplateObjectDescriptor.h&quot;
  35 #include &quot;ScopedArgumentsTable.h&quot;
  36 #include &quot;SourceCodeKey.h&quot;
  37 #include &quot;SourceProvider.h&quot;
  38 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  39 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  40 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  41 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  42 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  43 #include &lt;wtf/FastMalloc.h&gt;

  44 #include &lt;wtf/Optional.h&gt;

  45 #include &lt;wtf/UUID.h&gt;
  46 #include &lt;wtf/text/AtomStringImpl.h&gt;
  47 
  48 namespace JSC {
  49 
  50 namespace Yarr {
  51 enum class Flags : uint8_t;
  52 }
  53 
  54 template &lt;typename T, typename = void&gt;
  55 struct SourceTypeImpl {
  56     using type = T;
  57 };
  58 
  59 template&lt;typename T&gt;
  60 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  61     using type = typename T::SourceType_;
  62 
  63 };
  64 
  65 template&lt;typename T&gt;
  66 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  67 





  68 class Encoder {
  69     WTF_MAKE_NONCOPYABLE(Encoder);
  70     WTF_FORBID_HEAP_ALLOCATION;
  71 
  72 public:
  73     class Allocation {
  74         friend class Encoder;
  75 
  76     public:
  77         uint8_t* buffer() const { return m_buffer; }
  78         ptrdiff_t offset() const { return m_offset; }
  79 
  80     private:
  81         Allocation(uint8_t* buffer, ptrdiff_t offset)
  82             : m_buffer(buffer)
  83             , m_offset(offset)
  84         {
  85         }
  86 
  87         uint8_t* m_buffer;
</pre>
<hr />
<pre>
 140             return WTF::nullopt;
 141         return { it-&gt;value };
 142     }
 143 
 144     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)
 145     {
 146         m_leafExecutables.add(executable, offset);
 147     }
 148 
 149     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)
 150     {
 151         if (!m_currentPage)
 152             return nullptr;
 153         m_currentPage-&gt;alignEnd();
 154 
 155         if (FileSystem::isHandleValid(m_fd)) {
 156             return releaseMapped(error);
 157         }
 158 
 159         size_t size = m_baseOffset + m_currentPage-&gt;size();
<span class="line-modified"> 160         MallocPtr&lt;uint8_t&gt; buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);</span>
 161         unsigned offset = 0;
 162         for (const auto&amp; page : m_pages) {
 163             memcpy(buffer.get() + offset, page.buffer(), page.size());
 164             offset += page.size();
 165         }
 166         RELEASE_ASSERT(offset == size);
 167         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));
 168     }
 169 
 170 private:
 171     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)
 172     {
 173         size_t size = m_baseOffset + m_currentPage-&gt;size();
 174         if (!FileSystem::truncateFile(m_fd, size)) {
 175             error = BytecodeCacheError::StandardError(errno);
 176             return nullptr;
 177         }
 178 
 179         for (const auto&amp; page : m_pages) {
 180             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());
</pre>
<hr />
<pre>
 185 
 186             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {
 187                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());
 188                 return nullptr;
 189             }
 190         }
 191 
 192         bool success;
 193         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);
 194         if (!success) {
 195             error = BytecodeCacheError::StandardError(errno);
 196             return nullptr;
 197         }
 198 
 199         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));
 200     }
 201 
 202     class Page {
 203     public:
 204         Page(size_t size)
<span class="line-modified"> 205             : m_offset(0)</span>
 206             , m_capacity(size)
 207         {
<span class="line-removed"> 208             m_buffer = MallocPtr&lt;uint8_t&gt;::malloc(size);</span>
 209         }
 210 
 211         bool malloc(size_t size, ptrdiff_t&amp; result)
 212         {
 213             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
 214             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);
 215             size = roundUpToMultipleOf(alignment, size);
 216             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 217                 return false;
 218 
 219             result = offset;
 220             m_offset = offset + size;
 221             return true;
 222         }
 223 
 224         uint8_t* buffer() const { return m_buffer.get(); }
 225         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 226 
 227         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 228         {
 229             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 230             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 231                 result = addr - m_buffer.get();
 232                 return true;
 233             }
 234             return false;
 235         }
 236 
 237         void alignEnd()
 238         {
 239             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);
 240             if (size == m_offset)
 241                 return;
 242             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);
 243             m_offset = size;
 244         }
 245 
 246     private:
<span class="line-modified"> 247         MallocPtr&lt;uint8_t&gt; m_buffer;</span>
<span class="line-modified"> 248         ptrdiff_t m_offset;</span>
 249         size_t m_capacity;
 250     };
 251 
 252     void allocateNewPage(size_t size = 0)
 253     {
 254         static size_t minPageSize = pageSize();
 255         if (m_currentPage) {
 256             m_currentPage-&gt;alignEnd();
 257             m_baseOffset += m_currentPage-&gt;size();
 258         }
 259         if (size &lt; minPageSize)
 260             size = minPageSize;
 261         else
 262             size = roundUpToMultipleOf(minPageSize, size);
 263         m_pages.append(Page { size });
 264         m_currentPage = &amp;m_pages.last();
 265     }
 266 
 267     VM&amp; m_vm;
 268     FileSystem::PlatformFileHandle m_fd;
</pre>
<hr />
<pre>
 448 
 449     template&lt;typename T&gt;
 450 #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)
 451     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:
 452     // &lt;rdar://problem/49792205&gt;
 453     __attribute__((optnone))
 454 #endif
 455     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 456     {
 457         uint8_t* result = allocate(encoder, sizeof(T) * size);
 458         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));
 459         return new (result) T[size];
 460     }
 461 
 462 private:
 463     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
 464 };
 465 
 466 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 467 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
<span class="line-modified"> 468     template&lt;typename, typename&gt;</span>
 469     friend class CachedRefPtr;
 470 
 471     friend struct CachedPtrOffsets;
 472 
 473 public:
 474     void encode(Encoder&amp; encoder, const Source* src)
 475     {
 476         if (!src)
 477             return;
 478 
 479         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {
 480             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 481             return;
 482         }
 483 
 484         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 485         cachedObject-&gt;encode(encoder, *src);
 486         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 487     }
 488 
</pre>
<hr />
<pre>
 511     {
 512         bool unusedIsNewAllocation;
 513         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);
 514     }
 515 
 516     const T* operator-&gt;() const { return get(); }
 517 
 518 private:
 519     const T* get() const
 520     {
 521         RELEASE_ASSERT(!this-&gt;isEmpty());
 522         return this-&gt;template buffer&lt;T&gt;();
 523     }
 524 };
 525 
 526 ptrdiff_t CachedPtrOffsets::offsetOffset()
 527 {
 528     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);
 529 }
 530 
<span class="line-modified"> 531 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;</span>
<span class="line-modified"> 532 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source&gt;&gt; {</span>
 533 public:
 534     void encode(Encoder&amp; encoder, const Source* src)
 535     {
 536         m_ptr.encode(encoder, src);
 537     }
 538 
<span class="line-modified"> 539     void encode(Encoder&amp; encoder, const RefPtr&lt;Source&gt; src)</span>
 540     {
 541         encode(encoder, src.get());
 542     }
 543 
<span class="line-modified"> 544     RefPtr&lt;Source&gt; decode(Decoder&amp; decoder) const</span>
 545     {
 546         bool isNewAllocation;
 547         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);
 548         if (!decodedPtr)
 549             return nullptr;
 550         if (isNewAllocation) {
 551             decoder.addFinalizer([=] {
 552                 derefIfNotNull(decodedPtr);
 553             });
 554         }
 555         refIfNotNull(decodedPtr);
 556         return adoptRef(decodedPtr);
 557     }
 558 
<span class="line-modified"> 559     void decode(Decoder&amp; decoder, RefPtr&lt;Source&gt;&amp; src) const</span>
 560     {
 561         src = decode(decoder);
 562     }
 563 
 564 private:
 565     CachedPtr&lt;T, Source&gt; m_ptr;
 566 };
 567 
 568 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 569 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
 570     friend struct CachedWriteBarrierOffsets;
 571 
 572 public:
 573     bool isEmpty() const { return m_ptr.isEmpty(); }
 574 
 575     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 576     {
 577         m_ptr.encode(encoder, src.get());
 578     }
 579 
 580     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 581     {
 582         Source* decodedPtr = m_ptr.decode(decoder);
 583         if (decodedPtr)
 584             src.set(decoder.vm(), owner, decodedPtr);
 585     }
 586 
 587 private:
 588     CachedPtr&lt;T, Source&gt; m_ptr;
 589 };
 590 
 591 ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()
 592 {
 593     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);
 594 }
 595 
<span class="line-modified"> 596 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow&gt;</span>
<span class="line-modified"> 597 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&gt; {</span>
 598 public:
<span class="line-modified"> 599     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector)</span>










 600     {
 601         m_size = vector.size();
 602         if (!m_size)
 603             return;
 604         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 605         for (unsigned i = 0; i &lt; m_size; ++i)
 606             ::JSC::encode(encoder, buffer[i], vector[i]);
 607     }
 608 
 609     template&lt;typename... Args&gt;
<span class="line-modified"> 610     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler&gt;&amp; vector, Args... args) const</span>
 611     {
 612         if (!m_size)
 613             return;
 614         vector.resizeToFit(m_size);
 615         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 616         for (unsigned i = 0; i &lt; m_size; ++i)
 617             ::JSC::decode(decoder, buffer[i], vector[i], args...);
 618     }
 619 












 620 private:
 621     unsigned m_size;
 622 };
 623 
 624 template&lt;typename First, typename Second&gt;
 625 class CachedPair : public CachedObject&lt;std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&gt; {
 626 public:
 627     void encode(Encoder&amp; encoder, const std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair)
 628     {
 629         ::JSC::encode(encoder, m_first, pair.first);
 630         ::JSC::encode(encoder, m_second, pair.second);
 631     }
 632 
 633     void decode(Decoder&amp; decoder, std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair) const
 634     {
 635         ::JSC::decode(decoder, m_first, pair.first);
 636         ::JSC::decode(decoder, m_second, pair.second);
 637     }
 638 
 639 private:
</pre>
<hr />
<pre>
 916         m_set.decode(decoder, entry.first);
 917     }
 918 
 919 private:
 920     unsigned m_constant;
 921     CachedHashSet&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, IdentifierRepHash&gt; m_set;
 922 };
 923 
 924 class CachedCodeBlockRareData : public CachedObject&lt;UnlinkedCodeBlock::RareData&gt; {
 925 public:
 926     void encode(Encoder&amp; encoder, const UnlinkedCodeBlock::RareData&amp; rareData)
 927     {
 928         m_exceptionHandlers.encode(encoder, rareData.m_exceptionHandlers);
 929         m_switchJumpTables.encode(encoder, rareData.m_switchJumpTables);
 930         m_stringSwitchJumpTables.encode(encoder, rareData.m_stringSwitchJumpTables);
 931         m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
 932         m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
 933         m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
 934         m_bitVectors.encode(encoder, rareData.m_bitVectors);
 935         m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);

 936     }
 937 
 938     UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
 939     {
 940         UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
 941         m_exceptionHandlers.decode(decoder, rareData-&gt;m_exceptionHandlers);
 942         m_switchJumpTables.decode(decoder, rareData-&gt;m_switchJumpTables);
 943         m_stringSwitchJumpTables.decode(decoder, rareData-&gt;m_stringSwitchJumpTables);
 944         m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
 945         m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
 946         m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
 947         m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
 948         m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);

 949         return rareData;
 950     }
 951 
 952 private:
 953     CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
 954     CachedVector&lt;CachedSimpleJumpTable&gt; m_switchJumpTables;
 955     CachedVector&lt;CachedStringJumpTable&gt; m_stringSwitchJumpTables;
 956     CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
 957     CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
 958     CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
 959     CachedVector&lt;CachedBitVector&gt; m_bitVectors;
 960     CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;

 961 };
 962 
 963 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 964 public:
 965     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 966     {
 967         m_isEverythingCaptured = env.m_isEverythingCaptured;
 968         m_map.encode(encoder, env.m_map);
 969     }
 970 
 971     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
 972     {
 973         env.m_isEverythingCaptured = m_isEverythingCaptured;
 974         m_map.decode(decoder, env.m_map);
 975     }
 976 
 977 private:
 978     bool m_isEverythingCaptured;
<span class="line-modified"> 979     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;</span>
 980 };
 981 
 982 class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {
 983 public:
 984     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)
 985     {
 986         m_variables.encode(encoder, env.m_variables);
 987         m_variableMetadata.encode(encoder, env.m_variableMetadata);
 988         m_hash = env.m_hash;
 989         m_isEverythingCaptured = env.m_isEverythingCaptured;
 990     }
 991 
 992     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const
 993     {
 994         m_variables.decode(decoder, env.m_variables);
 995         m_variableMetadata.decode(decoder, env.m_variableMetadata);
 996         env.m_hash = m_hash;
 997         env.m_isEverythingCaptured = m_isEverythingCaptured;
 998     }
 999 
1000     CompactVariableEnvironment* decode(Decoder&amp; decoder) const
1001     {
1002         CompactVariableEnvironment* env = new CompactVariableEnvironment;
1003         decode(decoder, *env);
1004         return env;
1005     }
1006 
1007 private:
<span class="line-modified">1008     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;&gt; m_variables;</span>
1009     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
1010     unsigned m_hash;
1011     bool m_isEverythingCaptured;
1012 };
1013 
1014 class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {
1015 public:
1016     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)
1017     {
1018         m_environment.encode(encoder, handle.m_environment);
1019     }
1020 
1021     CompactVariableMap::Handle decode(Decoder&amp; decoder) const
1022     {
1023         bool isNewAllocation;
1024         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);
1025         if (!environment) {
1026             ASSERT(!isNewAllocation);
1027             return CompactVariableMap::Handle();
1028         }
</pre>
<hr />
<pre>
1341         SymbolTable,
1342         String,
1343         ImmutableButterfly,
1344         RegExp,
1345         TemplateObjectDescriptor,
1346         BigInt,
1347     };
1348 
1349     EncodedType m_type;
1350 };
1351 
1352 class CachedInstructionStream : public CachedObject&lt;InstructionStream&gt; {
1353 public:
1354     void encode(Encoder&amp; encoder, const InstructionStream&amp; stream)
1355     {
1356         m_instructions.encode(encoder, stream.m_instructions);
1357     }
1358 
1359     InstructionStream* decode(Decoder&amp; decoder) const
1360     {
<span class="line-modified">1361         Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; instructionsVector;</span>
1362         m_instructions.decode(decoder, instructionsVector);
1363         return new InstructionStream(WTFMove(instructionsVector));
1364     }
1365 
1366 private:
<span class="line-modified">1367     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow&gt; m_instructions;</span>
1368 };
1369 
1370 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1371 public:
1372     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1373     {
1374         ASSERT(metadataTable.m_isFinalized);
1375         m_hasMetadata = metadataTable.m_hasMetadata;
1376         if (!m_hasMetadata)
1377             return;
1378         m_is32Bit = metadataTable.m_is32Bit;
1379         if (m_is32Bit) {
1380             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1381                 m_metadata[i] = metadataTable.offsetTable32()[i];
1382         } else {
1383             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1384                 m_metadata[i] = metadataTable.offsetTable16()[i];
1385         }
1386     }
1387 
</pre>
<hr />
<pre>
1680     unsigned startOffset() const { return m_startOffset; }
1681     unsigned sourceLength() const { return m_sourceLength; }
1682     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1683     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1684     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1685     unsigned parameterCount() const { return m_parameterCount; }
1686 
1687     CodeFeatures features() const { return m_mutableMetadata.m_features; }
1688     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1689 
1690     unsigned isInStrictContext() const { return m_isInStrictContext; }
1691     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }
1692     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1693     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1694     unsigned constructAbility() const { return m_constructAbility; }
1695     unsigned constructorKind() const { return m_constructorKind; }
1696     unsigned functionMode() const { return m_functionMode; }
1697     unsigned scriptMode() const { return m_scriptMode; }
1698     unsigned superBinding() const { return m_superBinding; }
1699     unsigned derivedContextType() const { return m_derivedContextType; }

1700 
1701     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1702     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
1703 
1704     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1705 
1706     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }
1707     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }
1708 
1709 private:
1710     CachedFunctionExecutableMetadata m_mutableMetadata;
1711 
1712     unsigned m_firstLineOffset : 31;
1713     unsigned m_isInStrictContext : 1;
1714     unsigned m_lineCount : 31;
1715     unsigned m_isBuiltinFunction : 1;
1716     unsigned m_unlinkedFunctionNameStart : 31;
1717     unsigned m_isBuiltinDefaultClassConstructor : 1;
1718     unsigned m_unlinkedBodyStartColumn : 31;
1719     unsigned m_constructAbility: 1;
1720     unsigned m_unlinkedBodyEndColumn : 31;
1721     unsigned m_startOffset : 31;
1722     unsigned m_scriptMode: 1; // JSParserScriptMode
1723     unsigned m_sourceLength : 31;
1724     unsigned m_superBinding : 1;
1725     unsigned m_parametersStartOffset : 31;
1726     unsigned m_typeProfilingStartOffset;
1727     unsigned m_typeProfilingEndOffset;
1728     unsigned m_parameterCount;
1729     SourceParseMode m_sourceParseMode;
1730     unsigned m_constructorKind : 2;
1731     unsigned m_functionMode : 2; // FunctionMode
1732     unsigned m_derivedContextType: 2;

1733 
1734     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;
1735 
1736     CachedIdentifier m_name;
1737     CachedIdentifier m_ecmaName;
1738 
1739     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1740     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1741 };
1742 
1743 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()
1744 {
1745     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);
1746 }
1747 
1748 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()
1749 {
1750     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);
1751 }
1752 
1753 ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()
1754 {
1755     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);
1756 }
1757 
1758 template&lt;typename CodeBlockType&gt;
1759 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1760 public:
1761     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1762     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1763 
1764     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1765 
1766     VirtualRegister thisRegister() const { return m_thisRegister; }
1767     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1768 
<span class="line-modified">1769     String sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }</span>
<span class="line-modified">1770     String sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }</span>
1771 
1772     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1773 
1774     unsigned usesEval() const { return m_usesEval; }
1775     unsigned isStrictMode() const { return m_isStrictMode; }
1776     unsigned isConstructor() const { return m_isConstructor; }
1777     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1778     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1779     unsigned superBinding() const { return m_superBinding; }
1780     unsigned scriptMode() const { return m_scriptMode; }
1781     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1782     unsigned isClassContext() const { return m_isClassContext; }
1783     unsigned constructorKind() const { return m_constructorKind; }
1784     unsigned derivedContextType() const { return m_derivedContextType; }

1785     unsigned evalContextType() const { return m_evalContextType; }
1786     unsigned hasTailCalls() const { return m_hasTailCalls; }

1787     unsigned lineCount() const { return m_lineCount; }
1788     unsigned endColumn() const { return m_endColumn; }
1789 
1790     int numVars() const { return m_numVars; }
1791     int numCalleeLocals() const { return m_numCalleeLocals; }
1792     int numParameters() const { return m_numParameters; }
1793 
1794     CodeFeatures features() const { return m_features; }
1795     SourceParseMode parseMode() const { return m_parseMode; }
1796     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
1797     unsigned codeType() const { return m_codeType; }
1798 
1799     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1800 
1801 private:
1802     VirtualRegister m_thisRegister;
1803     VirtualRegister m_scopeRegister;
<span class="line-removed">1804     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;</span>
1805 
1806     unsigned m_usesEval : 1;
1807     unsigned m_isStrictMode : 1;
1808     unsigned m_isConstructor : 1;
1809     unsigned m_hasCapturedVariables : 1;
1810     unsigned m_isBuiltinFunction : 1;
1811     unsigned m_superBinding : 1;
1812     unsigned m_scriptMode: 1;
1813     unsigned m_isArrowFunctionContext : 1;
1814     unsigned m_isClassContext : 1;
1815     unsigned m_constructorKind : 2;
1816     unsigned m_derivedContextType : 2;

1817     unsigned m_evalContextType : 2;
1818     unsigned m_hasTailCalls : 1;
1819     unsigned m_codeType : 2;

1820 
1821     CodeFeatures m_features;
1822     SourceParseMode m_parseMode;
1823     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
1824 
1825     unsigned m_lineCount;
1826     unsigned m_endColumn;
1827 
1828     int m_numVars;
1829     int m_numCalleeLocals;
1830     int m_numParameters;
1831 
1832     CachedMetadataTable m_metadata;
1833 
1834     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;
1835 
<span class="line-modified">1836     CachedString m_sourceURLDirective;</span>
<span class="line-modified">1837     CachedString m_sourceMappingURLDirective;</span>
1838 
1839     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1840     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;
<span class="line-removed">1841     CachedVector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;</span>
1842     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1843     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1844     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1845     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1846 
1847     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1848     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1849     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1850 };
1851 
1852 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1853     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1854 
1855 public:
1856     void encode(Encoder&amp; encoder, const UnlinkedProgramCodeBlock&amp; codeBlock)
1857     {
1858         Base::encode(encoder, codeBlock);
1859         m_varDeclarations.encode(encoder, codeBlock.m_varDeclarations);
1860         m_lexicalDeclarations.encode(encoder, codeBlock.m_lexicalDeclarations);
1861     }
</pre>
<hr />
<pre>
1999     , m_thisRegister(cachedCodeBlock.thisRegister())
2000     , m_scopeRegister(cachedCodeBlock.scopeRegister())
2001 
2002     , m_usesEval(cachedCodeBlock.usesEval())
2003     , m_isStrictMode(cachedCodeBlock.isStrictMode())
2004     , m_isConstructor(cachedCodeBlock.isConstructor())
2005     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
2006     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
2007     , m_superBinding(cachedCodeBlock.superBinding())
2008     , m_scriptMode(cachedCodeBlock.scriptMode())
2009     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
2010     , m_isClassContext(cachedCodeBlock.isClassContext())
2011     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())
2012     , m_constructorKind(cachedCodeBlock.constructorKind())
2013     , m_derivedContextType(cachedCodeBlock.derivedContextType())
2014     , m_evalContextType(cachedCodeBlock.evalContextType())
2015     , m_codeType(cachedCodeBlock.codeType())
2016 
2017     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
2018     , m_age(0)

2019 
2020     , m_features(cachedCodeBlock.features())
2021     , m_parseMode(cachedCodeBlock.parseMode())
2022     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())
2023 
2024     , m_lineCount(cachedCodeBlock.lineCount())
2025     , m_endColumn(cachedCodeBlock.endColumn())
2026     , m_numVars(cachedCodeBlock.numVars())
2027     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
2028     , m_numParameters(cachedCodeBlock.numParameters())
2029 
2030     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
2031     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
2032 
2033     , m_metadata(cachedCodeBlock.metadata(decoder))
2034     , m_instructions(cachedCodeBlock.instructions(decoder))
2035 
2036     , m_rareData(cachedCodeBlock.rareData(decoder))
2037 {
2038 }
2039 
2040 template&lt;typename CodeBlockType&gt;
2041 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
2042 {
<span class="line-removed">2043     for (unsigned i = LinkTimeConstantCount; i--;)</span>
<span class="line-removed">2044         codeBlock.m_linkTimeConstants[i] = m_linkTimeConstants[i];</span>
<span class="line-removed">2045 </span>
<span class="line-removed">2046     m_propertyAccessInstructions.decode(decoder, codeBlock.m_propertyAccessInstructions);</span>
2047     m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
2048     m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
2049     m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
2050     m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
2051     m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
2052     m_identifiers.decode(decoder, codeBlock.m_identifiers);
2053     m_functionDecls.decode(decoder, codeBlock.m_functionDecls, &amp;codeBlock);
2054     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
2055 }
2056 
2057 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
2058     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
2059 {
2060 }
2061 
2062 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
2063     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
2064 {
2065 }
2066 
</pre>
<hr />
<pre>
2080     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
2081     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
2082     m_startOffset = executable.m_startOffset;
2083     m_sourceLength = executable.m_sourceLength;
2084     m_parametersStartOffset = executable.m_parametersStartOffset;
2085     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
2086     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
2087     m_parameterCount = executable.m_parameterCount;
2088 
2089     m_sourceParseMode = executable.m_sourceParseMode;
2090 
2091     m_isInStrictContext = executable.m_isInStrictContext;
2092     m_isBuiltinFunction = executable.m_isBuiltinFunction;
2093     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
2094     m_constructAbility = executable.m_constructAbility;
2095     m_constructorKind = executable.m_constructorKind;
2096     m_functionMode = executable.m_functionMode;
2097     m_scriptMode = executable.m_scriptMode;
2098     m_superBinding = executable.m_superBinding;
2099     m_derivedContextType = executable.m_derivedContextType;

2100 
2101     m_rareData.encode(encoder, executable.m_rareData.get());
2102 
2103     m_name.encode(encoder, executable.name());
2104     m_ecmaName.encode(encoder, executable.ecmaName());
2105 
2106     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
2107     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
2108 
2109     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)
2110         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));
2111 }
2112 
2113 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
2114 {
2115     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);
2116     executable-&gt;finishCreation(decoder.vm());
2117     return executable;
2118 }
2119 
</pre>
<hr />
<pre>
2127     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())
2128     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
2129     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())
2130     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
2131     , m_constructAbility(cachedExecutable.constructAbility())
2132     , m_startOffset(cachedExecutable.startOffset())
2133     , m_scriptMode(cachedExecutable.scriptMode())
2134     , m_sourceLength(cachedExecutable.sourceLength())
2135     , m_superBinding(cachedExecutable.superBinding())
2136     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
2137     , m_isCached(false)
2138     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
2139     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
2140     , m_parameterCount(cachedExecutable.parameterCount())
2141     , m_features(cachedExecutable.features())
2142     , m_sourceParseMode(cachedExecutable.sourceParseMode())
2143     , m_constructorKind(cachedExecutable.constructorKind())
2144     , m_functionMode(cachedExecutable.functionMode())
2145     , m_derivedContextType(cachedExecutable.derivedContextType())
2146     , m_isGeneratedFromCache(true)

2147     , m_unlinkedCodeBlockForCall()
2148     , m_unlinkedCodeBlockForConstruct()
2149 
2150     , m_name(cachedExecutable.name(decoder))
2151     , m_ecmaName(cachedExecutable.ecmaName(decoder))
2152 
2153     , m_rareData(cachedExecutable.rareData(decoder))
2154 {
2155 
2156     uint32_t leafExecutables = 2;
2157     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {
2158         if (!cachedPtr.isEmpty()) {
2159             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);
2160             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {
2161                 codeBlockOffset = offset;
2162                 m_isCached = true;
2163                 leafExecutables--;
2164                 return;
2165             }
2166         }
</pre>
<hr />
<pre>
2191     m_isConstructor = codeBlock.m_isConstructor;
2192     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
2193     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
2194     m_superBinding = codeBlock.m_superBinding;
2195     m_scriptMode = codeBlock.m_scriptMode;
2196     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
2197     m_isClassContext = codeBlock.m_isClassContext;
2198     m_hasTailCalls = codeBlock.m_hasTailCalls;
2199     m_constructorKind = codeBlock.m_constructorKind;
2200     m_derivedContextType = codeBlock.m_derivedContextType;
2201     m_evalContextType = codeBlock.m_evalContextType;
2202     m_lineCount = codeBlock.m_lineCount;
2203     m_endColumn = codeBlock.m_endColumn;
2204     m_numVars = codeBlock.m_numVars;
2205     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
2206     m_numParameters = codeBlock.m_numParameters;
2207     m_features = codeBlock.m_features;
2208     m_parseMode = codeBlock.m_parseMode;
2209     m_codeGenerationMode = codeBlock.m_codeGenerationMode;
2210     m_codeType = codeBlock.m_codeType;
<span class="line-modified">2211 </span>
<span class="line-removed">2212     for (unsigned i = LinkTimeConstantCount; i--;)</span>
<span class="line-removed">2213         m_linkTimeConstants[i] = codeBlock.m_linkTimeConstants[i];</span>
2214 
2215     m_metadata.encode(encoder, codeBlock.m_metadata.get());
2216     m_rareData.encode(encoder, codeBlock.m_rareData.get());
2217 
<span class="line-modified">2218     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());</span>
<span class="line-modified">2219     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.impl());</span>
2220 
2221     m_instructions.encode(encoder, codeBlock.m_instructions.get());
<span class="line-removed">2222     m_propertyAccessInstructions.encode(encoder, codeBlock.m_propertyAccessInstructions);</span>
2223     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
2224     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
2225     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
2226     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
2227     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
2228 
2229     m_identifiers.encode(encoder, codeBlock.m_identifiers);
2230     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
2231     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
2232 }
2233 
2234 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
2235 public:
2236     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
2237     {
2238         m_sourceCode.encode(encoder, key.m_sourceCode);
2239         m_name.encode(encoder, key.m_name);
2240         m_flags = key.m_flags.m_flags;
2241         m_hash = key.hash();
2242         m_functionConstructorParametersEndPosition = key.m_functionConstructorParametersEndPosition;
</pre>
<hr />
<pre>
2258     unsigned m_hash;
2259     int m_functionConstructorParametersEndPosition;
2260 };
2261 
2262 class GenericCacheEntry {
2263 public:
2264     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
2265     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;
2266 
2267 protected:
2268     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
2269         : m_tag(tag)
2270     {
2271         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
2272     }
2273 
2274     CachedCodeBlockTag tag() const { return m_tag; }
2275 
2276     bool isUpToDate(Decoder&amp; decoder) const
2277     {
<span class="line-modified">2278         if (m_cacheVersion != JSC_BYTECODE_CACHE_VERSION)</span>
2279             return false;
2280         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())
2281             return false;
2282         return true;
2283     }
2284 
2285 private:
<span class="line-modified">2286     uint32_t m_cacheVersion { JSC_BYTECODE_CACHE_VERSION };</span>
2287     CachedString m_bootSessionUUID;
2288     CachedCodeBlockTag m_tag;
2289 };
2290 
2291 template&lt;typename UnlinkedCodeBlockType&gt;
2292 class CacheEntry : public GenericCacheEntry {
2293 public:
2294     CacheEntry(Encoder&amp; encoder)
2295         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2296     {
2297     }
2298 
2299     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2300     {
2301         m_key.encode(encoder, pair.first);
2302         m_codeBlock.encode(encoder, pair.second);
2303     }
2304 
2305 private:
2306     friend GenericCacheEntry;
</pre>
</td>
<td>
<hr />
<pre>
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CachedTypes.h&quot;
  28 
  29 #include &quot;BytecodeCacheError.h&quot;

  30 #include &quot;BytecodeLivenessAnalysis.h&quot;
  31 #include &quot;JSCInlines.h&quot;
  32 #include &quot;JSImmutableButterfly.h&quot;
  33 #include &quot;JSTemplateObjectDescriptor.h&quot;
  34 #include &quot;ScopedArgumentsTable.h&quot;
  35 #include &quot;SourceCodeKey.h&quot;
  36 #include &quot;SourceProvider.h&quot;
  37 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  38 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  39 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  40 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  41 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  42 #include &lt;wtf/FastMalloc.h&gt;
<span class="line-added">  43 #include &lt;wtf/MallocPtr.h&gt;</span>
  44 #include &lt;wtf/Optional.h&gt;
<span class="line-added">  45 #include &lt;wtf/Packed.h&gt;</span>
  46 #include &lt;wtf/UUID.h&gt;
  47 #include &lt;wtf/text/AtomStringImpl.h&gt;
  48 
  49 namespace JSC {
  50 
  51 namespace Yarr {
  52 enum class Flags : uint8_t;
  53 }
  54 
  55 template &lt;typename T, typename = void&gt;
  56 struct SourceTypeImpl {
  57     using type = T;
  58 };
  59 
  60 template&lt;typename T&gt;
  61 struct SourceTypeImpl&lt;T, std::enable_if_t&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_same&lt;typename T::SourceType_, void&gt;::value&gt;&gt; {
  62     using type = typename T::SourceType_;
  63 
  64 };
  65 
  66 template&lt;typename T&gt;
  67 using SourceType = typename SourceTypeImpl&lt;T&gt;::type;
  68 
<span class="line-added">  69 static constexpr unsigned jscBytecodeCacheVersion()</span>
<span class="line-added">  70 {</span>
<span class="line-added">  71     return StringHasher::computeHash(__TIMESTAMP__);</span>
<span class="line-added">  72 }</span>
<span class="line-added">  73 </span>
  74 class Encoder {
  75     WTF_MAKE_NONCOPYABLE(Encoder);
  76     WTF_FORBID_HEAP_ALLOCATION;
  77 
  78 public:
  79     class Allocation {
  80         friend class Encoder;
  81 
  82     public:
  83         uint8_t* buffer() const { return m_buffer; }
  84         ptrdiff_t offset() const { return m_offset; }
  85 
  86     private:
  87         Allocation(uint8_t* buffer, ptrdiff_t offset)
  88             : m_buffer(buffer)
  89             , m_offset(offset)
  90         {
  91         }
  92 
  93         uint8_t* m_buffer;
</pre>
<hr />
<pre>
 146             return WTF::nullopt;
 147         return { it-&gt;value };
 148     }
 149 
 150     void addLeafExecutable(const UnlinkedFunctionExecutable* executable, ptrdiff_t offset)
 151     {
 152         m_leafExecutables.add(executable, offset);
 153     }
 154 
 155     RefPtr&lt;CachedBytecode&gt; release(BytecodeCacheError&amp; error)
 156     {
 157         if (!m_currentPage)
 158             return nullptr;
 159         m_currentPage-&gt;alignEnd();
 160 
 161         if (FileSystem::isHandleValid(m_fd)) {
 162             return releaseMapped(error);
 163         }
 164 
 165         size_t size = m_baseOffset + m_currentPage-&gt;size();
<span class="line-modified"> 166         MallocPtr&lt;uint8_t, VMMalloc&gt; buffer = MallocPtr&lt;uint8_t, VMMalloc&gt;::malloc(size);</span>
 167         unsigned offset = 0;
 168         for (const auto&amp; page : m_pages) {
 169             memcpy(buffer.get() + offset, page.buffer(), page.size());
 170             offset += page.size();
 171         }
 172         RELEASE_ASSERT(offset == size);
 173         return CachedBytecode::create(WTFMove(buffer), size, WTFMove(m_leafExecutables));
 174     }
 175 
 176 private:
 177     RefPtr&lt;CachedBytecode&gt; releaseMapped(BytecodeCacheError&amp; error)
 178     {
 179         size_t size = m_baseOffset + m_currentPage-&gt;size();
 180         if (!FileSystem::truncateFile(m_fd, size)) {
 181             error = BytecodeCacheError::StandardError(errno);
 182             return nullptr;
 183         }
 184 
 185         for (const auto&amp; page : m_pages) {
 186             int bytesWritten = FileSystem::writeToFile(m_fd, reinterpret_cast&lt;char*&gt;(page.buffer()), page.size());
</pre>
<hr />
<pre>
 191 
 192             if (static_cast&lt;size_t&gt;(bytesWritten) != page.size()) {
 193                 error = BytecodeCacheError::WriteError(bytesWritten, page.size());
 194                 return nullptr;
 195             }
 196         }
 197 
 198         bool success;
 199         FileSystem::MappedFileData mappedFileData(m_fd, FileSystem::MappedFileMode::Private, success);
 200         if (!success) {
 201             error = BytecodeCacheError::StandardError(errno);
 202             return nullptr;
 203         }
 204 
 205         return CachedBytecode::create(WTFMove(mappedFileData), WTFMove(m_leafExecutables));
 206     }
 207 
 208     class Page {
 209     public:
 210         Page(size_t size)
<span class="line-modified"> 211             : m_buffer(MallocPtr&lt;uint8_t, VMMalloc&gt;::malloc(size))</span>
 212             , m_capacity(size)
 213         {

 214         }
 215 
 216         bool malloc(size_t size, ptrdiff_t&amp; result)
 217         {
 218             size_t alignment = std::min(alignof(std::max_align_t), static_cast&lt;size_t&gt;(WTF::roundUpToPowerOfTwo(size)));
 219             ptrdiff_t offset = roundUpToMultipleOf(alignment, m_offset);
 220             size = roundUpToMultipleOf(alignment, size);
 221             if (static_cast&lt;size_t&gt;(offset + size) &gt; m_capacity)
 222                 return false;
 223 
 224             result = offset;
 225             m_offset = offset + size;
 226             return true;
 227         }
 228 
 229         uint8_t* buffer() const { return m_buffer.get(); }
 230         size_t size() const { return static_cast&lt;size_t&gt;(m_offset); }
 231 
 232         bool getOffset(const void* address, ptrdiff_t&amp; result) const
 233         {
 234             const uint8_t* addr = static_cast&lt;const uint8_t*&gt;(address);
 235             if (addr &gt;= m_buffer.get() &amp;&amp; addr &lt; m_buffer.get() + m_offset) {
 236                 result = addr - m_buffer.get();
 237                 return true;
 238             }
 239             return false;
 240         }
 241 
 242         void alignEnd()
 243         {
 244             ptrdiff_t size = roundUpToMultipleOf(alignof(std::max_align_t), m_offset);
 245             if (size == m_offset)
 246                 return;
 247             RELEASE_ASSERT(static_cast&lt;size_t&gt;(size) &lt;= m_capacity);
 248             m_offset = size;
 249         }
 250 
 251     private:
<span class="line-modified"> 252         MallocPtr&lt;uint8_t, VMMalloc&gt; m_buffer;</span>
<span class="line-modified"> 253         ptrdiff_t m_offset { 0 };</span>
 254         size_t m_capacity;
 255     };
 256 
 257     void allocateNewPage(size_t size = 0)
 258     {
 259         static size_t minPageSize = pageSize();
 260         if (m_currentPage) {
 261             m_currentPage-&gt;alignEnd();
 262             m_baseOffset += m_currentPage-&gt;size();
 263         }
 264         if (size &lt; minPageSize)
 265             size = minPageSize;
 266         else
 267             size = roundUpToMultipleOf(minPageSize, size);
 268         m_pages.append(Page { size });
 269         m_currentPage = &amp;m_pages.last();
 270     }
 271 
 272     VM&amp; m_vm;
 273     FileSystem::PlatformFileHandle m_fd;
</pre>
<hr />
<pre>
 453 
 454     template&lt;typename T&gt;
 455 #if CPU(ARM64) &amp;&amp; CPU(ADDRESS32)
 456     // FIXME: Remove this once it&#39;s no longer needed and LLVM doesn&#39;t miscompile us:
 457     // &lt;rdar://problem/49792205&gt;
 458     __attribute__((optnone))
 459 #endif
 460     T* allocate(Encoder&amp; encoder, unsigned size = 1)
 461     {
 462         uint8_t* result = allocate(encoder, sizeof(T) * size);
 463         ASSERT(!(bitwise_cast&lt;uintptr_t&gt;(result) % alignof(T)));
 464         return new (result) T[size];
 465     }
 466 
 467 private:
 468     constexpr static ptrdiff_t s_invalidOffset = std::numeric_limits&lt;ptrdiff_t&gt;::max();
 469 };
 470 
 471 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 472 class CachedPtr : public VariableLengthObject&lt;Source*&gt; {
<span class="line-modified"> 473     template&lt;typename, typename, typename&gt;</span>
 474     friend class CachedRefPtr;
 475 
 476     friend struct CachedPtrOffsets;
 477 
 478 public:
 479     void encode(Encoder&amp; encoder, const Source* src)
 480     {
 481         if (!src)
 482             return;
 483 
 484         if (Optional&lt;ptrdiff_t&gt; offset = encoder.cachedOffsetForPtr(src)) {
 485             this-&gt;m_offset = *offset - encoder.offsetOf(&amp;this-&gt;m_offset);
 486             return;
 487         }
 488 
 489         T* cachedObject = this-&gt;template allocate&lt;T&gt;(encoder);
 490         cachedObject-&gt;encode(encoder, *src);
 491         encoder.cachePtr(src, encoder.offsetOf(cachedObject));
 492     }
 493 
</pre>
<hr />
<pre>
 516     {
 517         bool unusedIsNewAllocation;
 518         return decode(decoder, unusedIsNewAllocation, std::forward&lt;Args&gt;(args)...);
 519     }
 520 
 521     const T* operator-&gt;() const { return get(); }
 522 
 523 private:
 524     const T* get() const
 525     {
 526         RELEASE_ASSERT(!this-&gt;isEmpty());
 527         return this-&gt;template buffer&lt;T&gt;();
 528     }
 529 };
 530 
 531 ptrdiff_t CachedPtrOffsets::offsetOffset()
 532 {
 533     return OBJECT_OFFSETOF(CachedPtr&lt;void&gt;, m_offset);
 534 }
 535 
<span class="line-modified"> 536 template&lt;typename T, typename Source = SourceType&lt;T&gt;, typename PtrTraits = DumbPtrTraits&lt;Source&gt;&gt;</span>
<span class="line-modified"> 537 class CachedRefPtr : public CachedObject&lt;RefPtr&lt;Source, PtrTraits&gt;&gt; {</span>
 538 public:
 539     void encode(Encoder&amp; encoder, const Source* src)
 540     {
 541         m_ptr.encode(encoder, src);
 542     }
 543 
<span class="line-modified"> 544     void encode(Encoder&amp; encoder, const RefPtr&lt;Source, PtrTraits&gt; src)</span>
 545     {
 546         encode(encoder, src.get());
 547     }
 548 
<span class="line-modified"> 549     RefPtr&lt;Source, PtrTraits&gt; decode(Decoder&amp; decoder) const</span>
 550     {
 551         bool isNewAllocation;
 552         Source* decodedPtr = m_ptr.decode(decoder, isNewAllocation);
 553         if (!decodedPtr)
 554             return nullptr;
 555         if (isNewAllocation) {
 556             decoder.addFinalizer([=] {
 557                 derefIfNotNull(decodedPtr);
 558             });
 559         }
 560         refIfNotNull(decodedPtr);
 561         return adoptRef(decodedPtr);
 562     }
 563 
<span class="line-modified"> 564     void decode(Decoder&amp; decoder, RefPtr&lt;Source, PtrTraits&gt;&amp; src) const</span>
 565     {
 566         src = decode(decoder);
 567     }
 568 
 569 private:
 570     CachedPtr&lt;T, Source&gt; m_ptr;
 571 };
 572 
 573 template&lt;typename T, typename Source = SourceType&lt;T&gt;&gt;
 574 class CachedWriteBarrier : public CachedObject&lt;WriteBarrier&lt;Source&gt;&gt; {
 575     friend struct CachedWriteBarrierOffsets;
 576 
 577 public:
 578     bool isEmpty() const { return m_ptr.isEmpty(); }
 579 
 580     void encode(Encoder&amp; encoder, const WriteBarrier&lt;Source&gt; src)
 581     {
 582         m_ptr.encode(encoder, src.get());
 583     }
 584 
 585     void decode(Decoder&amp; decoder, WriteBarrier&lt;Source&gt;&amp; src, const JSCell* owner) const
 586     {
 587         Source* decodedPtr = m_ptr.decode(decoder);
 588         if (decodedPtr)
 589             src.set(decoder.vm(), owner, decodedPtr);
 590     }
 591 
 592 private:
 593     CachedPtr&lt;T, Source&gt; m_ptr;
 594 };
 595 
 596 ptrdiff_t CachedWriteBarrierOffsets::ptrOffset()
 597 {
 598     return OBJECT_OFFSETOF(CachedWriteBarrier&lt;void&gt;, m_ptr);
 599 }
 600 
<span class="line-modified"> 601 template&lt;typename T, size_t InlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, typename Malloc = WTF::VectorMalloc&gt;</span>
<span class="line-modified"> 602 class CachedVector : public VariableLengthObject&lt;Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&gt; {</span>
 603 public:
<span class="line-modified"> 604     void encode(Encoder&amp; encoder, const Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&amp; vector)</span>
<span class="line-added"> 605     {</span>
<span class="line-added"> 606         m_size = vector.size();</span>
<span class="line-added"> 607         if (!m_size)</span>
<span class="line-added"> 608             return;</span>
<span class="line-added"> 609         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);</span>
<span class="line-added"> 610         for (unsigned i = 0; i &lt; m_size; ++i)</span>
<span class="line-added"> 611             ::JSC::encode(encoder, buffer[i], vector[i]);</span>
<span class="line-added"> 612     }</span>
<span class="line-added"> 613 </span>
<span class="line-added"> 614     void encode(Encoder&amp; encoder, const RefCountedArray&lt;SourceType&lt;T&gt;&gt;&amp; vector)</span>
 615     {
 616         m_size = vector.size();
 617         if (!m_size)
 618             return;
 619         T* buffer = this-&gt;template allocate&lt;T&gt;(encoder, m_size);
 620         for (unsigned i = 0; i &lt; m_size; ++i)
 621             ::JSC::encode(encoder, buffer[i], vector[i]);
 622     }
 623 
 624     template&lt;typename... Args&gt;
<span class="line-modified"> 625     void decode(Decoder&amp; decoder, Vector&lt;SourceType&lt;T&gt;, InlineCapacity, OverflowHandler, 16, Malloc&gt;&amp; vector, Args... args) const</span>
 626     {
 627         if (!m_size)
 628             return;
 629         vector.resizeToFit(m_size);
 630         const T* buffer = this-&gt;template buffer&lt;T&gt;();
 631         for (unsigned i = 0; i &lt; m_size; ++i)
 632             ::JSC::decode(decoder, buffer[i], vector[i], args...);
 633     }
 634 
<span class="line-added"> 635     template&lt;typename... Args&gt;</span>
<span class="line-added"> 636     void decode(Decoder&amp; decoder, RefCountedArray&lt;SourceType&lt;T&gt;&gt;&amp; vector, Args... args) const</span>
<span class="line-added"> 637     {</span>
<span class="line-added"> 638         if (!m_size)</span>
<span class="line-added"> 639             return;</span>
<span class="line-added"> 640         vector = RefCountedArray&lt;SourceType&lt;T&gt;&gt;(m_size);</span>
<span class="line-added"> 641         const T* buffer = this-&gt;template buffer&lt;T&gt;();</span>
<span class="line-added"> 642         for (unsigned i = 0; i &lt; m_size; ++i)</span>
<span class="line-added"> 643             ::JSC::decode(decoder, buffer[i], vector[i], args...);</span>
<span class="line-added"> 644     }</span>
<span class="line-added"> 645 </span>
<span class="line-added"> 646 </span>
 647 private:
 648     unsigned m_size;
 649 };
 650 
 651 template&lt;typename First, typename Second&gt;
 652 class CachedPair : public CachedObject&lt;std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&gt; {
 653 public:
 654     void encode(Encoder&amp; encoder, const std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair)
 655     {
 656         ::JSC::encode(encoder, m_first, pair.first);
 657         ::JSC::encode(encoder, m_second, pair.second);
 658     }
 659 
 660     void decode(Decoder&amp; decoder, std::pair&lt;SourceType&lt;First&gt;, SourceType&lt;Second&gt;&gt;&amp; pair) const
 661     {
 662         ::JSC::decode(decoder, m_first, pair.first);
 663         ::JSC::decode(decoder, m_second, pair.second);
 664     }
 665 
 666 private:
</pre>
<hr />
<pre>
 943         m_set.decode(decoder, entry.first);
 944     }
 945 
 946 private:
 947     unsigned m_constant;
 948     CachedHashSet&lt;CachedRefPtr&lt;CachedUniquedStringImpl&gt;, IdentifierRepHash&gt; m_set;
 949 };
 950 
 951 class CachedCodeBlockRareData : public CachedObject&lt;UnlinkedCodeBlock::RareData&gt; {
 952 public:
 953     void encode(Encoder&amp; encoder, const UnlinkedCodeBlock::RareData&amp; rareData)
 954     {
 955         m_exceptionHandlers.encode(encoder, rareData.m_exceptionHandlers);
 956         m_switchJumpTables.encode(encoder, rareData.m_switchJumpTables);
 957         m_stringSwitchJumpTables.encode(encoder, rareData.m_stringSwitchJumpTables);
 958         m_expressionInfoFatPositions.encode(encoder, rareData.m_expressionInfoFatPositions);
 959         m_typeProfilerInfoMap.encode(encoder, rareData.m_typeProfilerInfoMap);
 960         m_opProfileControlFlowBytecodeOffsets.encode(encoder, rareData.m_opProfileControlFlowBytecodeOffsets);
 961         m_bitVectors.encode(encoder, rareData.m_bitVectors);
 962         m_constantIdentifierSets.encode(encoder, rareData.m_constantIdentifierSets);
<span class="line-added"> 963         m_needsClassFieldInitializer = rareData.m_needsClassFieldInitializer;</span>
 964     }
 965 
 966     UnlinkedCodeBlock::RareData* decode(Decoder&amp; decoder) const
 967     {
 968         UnlinkedCodeBlock::RareData* rareData = new UnlinkedCodeBlock::RareData { };
 969         m_exceptionHandlers.decode(decoder, rareData-&gt;m_exceptionHandlers);
 970         m_switchJumpTables.decode(decoder, rareData-&gt;m_switchJumpTables);
 971         m_stringSwitchJumpTables.decode(decoder, rareData-&gt;m_stringSwitchJumpTables);
 972         m_expressionInfoFatPositions.decode(decoder, rareData-&gt;m_expressionInfoFatPositions);
 973         m_typeProfilerInfoMap.decode(decoder, rareData-&gt;m_typeProfilerInfoMap);
 974         m_opProfileControlFlowBytecodeOffsets.decode(decoder, rareData-&gt;m_opProfileControlFlowBytecodeOffsets);
 975         m_bitVectors.decode(decoder, rareData-&gt;m_bitVectors);
 976         m_constantIdentifierSets.decode(decoder, rareData-&gt;m_constantIdentifierSets);
<span class="line-added"> 977         rareData-&gt;m_needsClassFieldInitializer = m_needsClassFieldInitializer;</span>
 978         return rareData;
 979     }
 980 
 981 private:
 982     CachedVector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
 983     CachedVector&lt;CachedSimpleJumpTable&gt; m_switchJumpTables;
 984     CachedVector&lt;CachedStringJumpTable&gt; m_stringSwitchJumpTables;
 985     CachedVector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
 986     CachedHashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
 987     CachedVector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
 988     CachedVector&lt;CachedBitVector&gt; m_bitVectors;
 989     CachedVector&lt;CachedConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
<span class="line-added"> 990     unsigned m_needsClassFieldInitializer : 1;</span>
 991 };
 992 
 993 class CachedVariableEnvironment : public CachedObject&lt;VariableEnvironment&gt; {
 994 public:
 995     void encode(Encoder&amp; encoder, const VariableEnvironment&amp; env)
 996     {
 997         m_isEverythingCaptured = env.m_isEverythingCaptured;
 998         m_map.encode(encoder, env.m_map);
 999     }
1000 
1001     void decode(Decoder&amp; decoder, VariableEnvironment&amp; env) const
1002     {
1003         env.m_isEverythingCaptured = m_isEverythingCaptured;
1004         m_map.decode(decoder, env.m_map);
1005     }
1006 
1007 private:
1008     bool m_isEverythingCaptured;
<span class="line-modified">1009     CachedHashMap&lt;CachedRefPtr&lt;CachedUniquedStringImpl, UniquedStringImpl, WTF::PackedPtrTraits&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntry, IdentifierRepHash, HashTraits&lt;RefPtr&lt;UniquedStringImpl&gt;&gt;, VariableEnvironmentEntryHashTraits&gt; m_map;</span>
1010 };
1011 
1012 class CachedCompactVariableEnvironment : public CachedObject&lt;CompactVariableEnvironment&gt; {
1013 public:
1014     void encode(Encoder&amp; encoder, const CompactVariableEnvironment&amp; env)
1015     {
1016         m_variables.encode(encoder, env.m_variables);
1017         m_variableMetadata.encode(encoder, env.m_variableMetadata);
1018         m_hash = env.m_hash;
1019         m_isEverythingCaptured = env.m_isEverythingCaptured;
1020     }
1021 
1022     void decode(Decoder&amp; decoder, CompactVariableEnvironment&amp; env) const
1023     {
1024         m_variables.decode(decoder, env.m_variables);
1025         m_variableMetadata.decode(decoder, env.m_variableMetadata);
1026         env.m_hash = m_hash;
1027         env.m_isEverythingCaptured = m_isEverythingCaptured;
1028     }
1029 
1030     CompactVariableEnvironment* decode(Decoder&amp; decoder) const
1031     {
1032         CompactVariableEnvironment* env = new CompactVariableEnvironment;
1033         decode(decoder, *env);
1034         return env;
1035     }
1036 
1037 private:
<span class="line-modified">1038     CachedVector&lt;CachedRefPtr&lt;CachedUniquedStringImpl, UniquedStringImpl, WTF::PackedPtrTraits&lt;UniquedStringImpl&gt;&gt;&gt; m_variables;</span>
1039     CachedVector&lt;VariableEnvironmentEntry&gt; m_variableMetadata;
1040     unsigned m_hash;
1041     bool m_isEverythingCaptured;
1042 };
1043 
1044 class CachedCompactVariableMapHandle : public CachedObject&lt;CompactVariableMap::Handle&gt; {
1045 public:
1046     void encode(Encoder&amp; encoder, const CompactVariableMap::Handle&amp; handle)
1047     {
1048         m_environment.encode(encoder, handle.m_environment);
1049     }
1050 
1051     CompactVariableMap::Handle decode(Decoder&amp; decoder) const
1052     {
1053         bool isNewAllocation;
1054         CompactVariableEnvironment* environment = m_environment.decode(decoder, isNewAllocation);
1055         if (!environment) {
1056             ASSERT(!isNewAllocation);
1057             return CompactVariableMap::Handle();
1058         }
</pre>
<hr />
<pre>
1371         SymbolTable,
1372         String,
1373         ImmutableButterfly,
1374         RegExp,
1375         TemplateObjectDescriptor,
1376         BigInt,
1377     };
1378 
1379     EncodedType m_type;
1380 };
1381 
1382 class CachedInstructionStream : public CachedObject&lt;InstructionStream&gt; {
1383 public:
1384     void encode(Encoder&amp; encoder, const InstructionStream&amp; stream)
1385     {
1386         m_instructions.encode(encoder, stream.m_instructions);
1387     }
1388 
1389     InstructionStream* decode(Decoder&amp; decoder) const
1390     {
<span class="line-modified">1391         Vector&lt;uint8_t, 0, UnsafeVectorOverflow, 16, InstructionStreamMalloc&gt; instructionsVector;</span>
1392         m_instructions.decode(decoder, instructionsVector);
1393         return new InstructionStream(WTFMove(instructionsVector));
1394     }
1395 
1396 private:
<span class="line-modified">1397     CachedVector&lt;uint8_t, 0, UnsafeVectorOverflow, InstructionStreamMalloc&gt; m_instructions;</span>
1398 };
1399 
1400 class CachedMetadataTable : public CachedObject&lt;UnlinkedMetadataTable&gt; {
1401 public:
1402     void encode(Encoder&amp;, const UnlinkedMetadataTable&amp; metadataTable)
1403     {
1404         ASSERT(metadataTable.m_isFinalized);
1405         m_hasMetadata = metadataTable.m_hasMetadata;
1406         if (!m_hasMetadata)
1407             return;
1408         m_is32Bit = metadataTable.m_is32Bit;
1409         if (m_is32Bit) {
1410             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1411                 m_metadata[i] = metadataTable.offsetTable32()[i];
1412         } else {
1413             for (unsigned i = UnlinkedMetadataTable::s_offsetTableEntries; i--;)
1414                 m_metadata[i] = metadataTable.offsetTable16()[i];
1415         }
1416     }
1417 
</pre>
<hr />
<pre>
1710     unsigned startOffset() const { return m_startOffset; }
1711     unsigned sourceLength() const { return m_sourceLength; }
1712     unsigned parametersStartOffset() const { return m_parametersStartOffset; }
1713     unsigned typeProfilingStartOffset() const { return m_typeProfilingStartOffset; }
1714     unsigned typeProfilingEndOffset() const { return m_typeProfilingEndOffset; }
1715     unsigned parameterCount() const { return m_parameterCount; }
1716 
1717     CodeFeatures features() const { return m_mutableMetadata.m_features; }
1718     SourceParseMode sourceParseMode() const { return m_sourceParseMode; }
1719 
1720     unsigned isInStrictContext() const { return m_isInStrictContext; }
1721     unsigned hasCapturedVariables() const { return m_mutableMetadata.m_hasCapturedVariables; }
1722     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1723     unsigned isBuiltinDefaultClassConstructor() const { return m_isBuiltinDefaultClassConstructor; }
1724     unsigned constructAbility() const { return m_constructAbility; }
1725     unsigned constructorKind() const { return m_constructorKind; }
1726     unsigned functionMode() const { return m_functionMode; }
1727     unsigned scriptMode() const { return m_scriptMode; }
1728     unsigned superBinding() const { return m_superBinding; }
1729     unsigned derivedContextType() const { return m_derivedContextType; }
<span class="line-added">1730     unsigned needsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
1731 
1732     Identifier name(Decoder&amp; decoder) const { return m_name.decode(decoder); }
1733     Identifier ecmaName(Decoder&amp; decoder) const { return m_ecmaName.decode(decoder); }
1734 
1735     UnlinkedFunctionExecutable::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1736 
1737     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForCall() const { return m_unlinkedCodeBlockForCall; }
1738     const CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt;&amp; unlinkedCodeBlockForConstruct() const { return m_unlinkedCodeBlockForConstruct; }
1739 
1740 private:
1741     CachedFunctionExecutableMetadata m_mutableMetadata;
1742 
1743     unsigned m_firstLineOffset : 31;
1744     unsigned m_isInStrictContext : 1;
1745     unsigned m_lineCount : 31;
1746     unsigned m_isBuiltinFunction : 1;
1747     unsigned m_unlinkedFunctionNameStart : 31;
1748     unsigned m_isBuiltinDefaultClassConstructor : 1;
1749     unsigned m_unlinkedBodyStartColumn : 31;
1750     unsigned m_constructAbility: 1;
1751     unsigned m_unlinkedBodyEndColumn : 31;
1752     unsigned m_startOffset : 31;
1753     unsigned m_scriptMode: 1; // JSParserScriptMode
1754     unsigned m_sourceLength : 31;
1755     unsigned m_superBinding : 1;
1756     unsigned m_parametersStartOffset : 31;
1757     unsigned m_typeProfilingStartOffset;
1758     unsigned m_typeProfilingEndOffset;
1759     unsigned m_parameterCount;
1760     SourceParseMode m_sourceParseMode;
1761     unsigned m_constructorKind : 2;
1762     unsigned m_functionMode : 2; // FunctionMode
1763     unsigned m_derivedContextType: 2;
<span class="line-added">1764     unsigned m_needsClassFieldInitializer : 1;</span>
1765 
1766     CachedPtr&lt;CachedFunctionExecutableRareData&gt; m_rareData;
1767 
1768     CachedIdentifier m_name;
1769     CachedIdentifier m_ecmaName;
1770 
1771     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForCall;
1772     CachedWriteBarrier&lt;CachedFunctionCodeBlock, UnlinkedFunctionCodeBlock&gt; m_unlinkedCodeBlockForConstruct;
1773 };
1774 
1775 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForCallOffset()
1776 {
1777     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForCall);
1778 }
1779 
1780 ptrdiff_t CachedFunctionExecutableOffsets::codeBlockForConstructOffset()
1781 {
1782     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_unlinkedCodeBlockForConstruct);
1783 }
1784 
1785 ptrdiff_t CachedFunctionExecutableOffsets::metadataOffset()
1786 {
1787     return OBJECT_OFFSETOF(CachedFunctionExecutable, m_mutableMetadata);
1788 }
1789 
1790 template&lt;typename CodeBlockType&gt;
1791 class CachedCodeBlock : public CachedObject&lt;CodeBlockType&gt; {
1792 public:
1793     void encode(Encoder&amp;, const UnlinkedCodeBlock&amp;);
1794     void decode(Decoder&amp;, UnlinkedCodeBlock&amp;) const;
1795 
1796     InstructionStream* instructions(Decoder&amp; decoder) const { return m_instructions.decode(decoder); }
1797 
1798     VirtualRegister thisRegister() const { return m_thisRegister; }
1799     VirtualRegister scopeRegister() const { return m_scopeRegister; }
1800 
<span class="line-modified">1801     RefPtr&lt;StringImpl&gt; sourceURLDirective(Decoder&amp; decoder) const { return m_sourceURLDirective.decode(decoder); }</span>
<span class="line-modified">1802     RefPtr&lt;StringImpl&gt; sourceMappingURLDirective(Decoder&amp; decoder) const { return m_sourceMappingURLDirective.decode(decoder); }</span>
1803 
1804     Ref&lt;UnlinkedMetadataTable&gt; metadata(Decoder&amp; decoder) const { return m_metadata.decode(decoder); }
1805 
1806     unsigned usesEval() const { return m_usesEval; }
1807     unsigned isStrictMode() const { return m_isStrictMode; }
1808     unsigned isConstructor() const { return m_isConstructor; }
1809     unsigned hasCapturedVariables() const { return m_hasCapturedVariables; }
1810     unsigned isBuiltinFunction() const { return m_isBuiltinFunction; }
1811     unsigned superBinding() const { return m_superBinding; }
1812     unsigned scriptMode() const { return m_scriptMode; }
1813     unsigned isArrowFunctionContext() const { return m_isArrowFunctionContext; }
1814     unsigned isClassContext() const { return m_isClassContext; }
1815     unsigned constructorKind() const { return m_constructorKind; }
1816     unsigned derivedContextType() const { return m_derivedContextType; }
<span class="line-added">1817     unsigned needsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
1818     unsigned evalContextType() const { return m_evalContextType; }
1819     unsigned hasTailCalls() const { return m_hasTailCalls; }
<span class="line-added">1820     unsigned hasCheckpoints() const { return m_hasCheckpoints; }</span>
1821     unsigned lineCount() const { return m_lineCount; }
1822     unsigned endColumn() const { return m_endColumn; }
1823 
1824     int numVars() const { return m_numVars; }
1825     int numCalleeLocals() const { return m_numCalleeLocals; }
1826     int numParameters() const { return m_numParameters; }
1827 
1828     CodeFeatures features() const { return m_features; }
1829     SourceParseMode parseMode() const { return m_parseMode; }
1830     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
1831     unsigned codeType() const { return m_codeType; }
1832 
1833     UnlinkedCodeBlock::RareData* rareData(Decoder&amp; decoder) const { return m_rareData.decode(decoder); }
1834 
1835 private:
1836     VirtualRegister m_thisRegister;
1837     VirtualRegister m_scopeRegister;

1838 
1839     unsigned m_usesEval : 1;
1840     unsigned m_isStrictMode : 1;
1841     unsigned m_isConstructor : 1;
1842     unsigned m_hasCapturedVariables : 1;
1843     unsigned m_isBuiltinFunction : 1;
1844     unsigned m_superBinding : 1;
1845     unsigned m_scriptMode: 1;
1846     unsigned m_isArrowFunctionContext : 1;
1847     unsigned m_isClassContext : 1;
1848     unsigned m_constructorKind : 2;
1849     unsigned m_derivedContextType : 2;
<span class="line-added">1850     unsigned m_needsClassFieldInitializer : 1;</span>
1851     unsigned m_evalContextType : 2;
1852     unsigned m_hasTailCalls : 1;
1853     unsigned m_codeType : 2;
<span class="line-added">1854     unsigned m_hasCheckpoints : 1;</span>
1855 
1856     CodeFeatures m_features;
1857     SourceParseMode m_parseMode;
1858     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
1859 
1860     unsigned m_lineCount;
1861     unsigned m_endColumn;
1862 
1863     int m_numVars;
1864     int m_numCalleeLocals;
1865     int m_numParameters;
1866 
1867     CachedMetadataTable m_metadata;
1868 
1869     CachedPtr&lt;CachedCodeBlockRareData&gt; m_rareData;
1870 
<span class="line-modified">1871     CachedRefPtr&lt;CachedStringImpl&gt; m_sourceURLDirective;</span>
<span class="line-modified">1872     CachedRefPtr&lt;CachedStringImpl&gt; m_sourceMappingURLDirective;</span>
1873 
1874     CachedPtr&lt;CachedInstructionStream&gt; m_instructions;
1875     CachedVector&lt;InstructionStream::Offset&gt; m_jumpTargets;

1876     CachedVector&lt;CachedJSValue&gt; m_constantRegisters;
1877     CachedVector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
1878     CachedVector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
1879     CachedHashMap&lt;InstructionStream::Offset, int&gt; m_outOfLineJumpTargets;
1880 
1881     CachedVector&lt;CachedIdentifier&gt; m_identifiers;
1882     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionDecls;
1883     CachedVector&lt;CachedWriteBarrier&lt;CachedFunctionExecutable&gt;&gt; m_functionExprs;
1884 };
1885 
1886 class CachedProgramCodeBlock : public CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt; {
1887     using Base = CachedCodeBlock&lt;UnlinkedProgramCodeBlock&gt;;
1888 
1889 public:
1890     void encode(Encoder&amp; encoder, const UnlinkedProgramCodeBlock&amp; codeBlock)
1891     {
1892         Base::encode(encoder, codeBlock);
1893         m_varDeclarations.encode(encoder, codeBlock.m_varDeclarations);
1894         m_lexicalDeclarations.encode(encoder, codeBlock.m_lexicalDeclarations);
1895     }
</pre>
<hr />
<pre>
2033     , m_thisRegister(cachedCodeBlock.thisRegister())
2034     , m_scopeRegister(cachedCodeBlock.scopeRegister())
2035 
2036     , m_usesEval(cachedCodeBlock.usesEval())
2037     , m_isStrictMode(cachedCodeBlock.isStrictMode())
2038     , m_isConstructor(cachedCodeBlock.isConstructor())
2039     , m_hasCapturedVariables(cachedCodeBlock.hasCapturedVariables())
2040     , m_isBuiltinFunction(cachedCodeBlock.isBuiltinFunction())
2041     , m_superBinding(cachedCodeBlock.superBinding())
2042     , m_scriptMode(cachedCodeBlock.scriptMode())
2043     , m_isArrowFunctionContext(cachedCodeBlock.isArrowFunctionContext())
2044     , m_isClassContext(cachedCodeBlock.isClassContext())
2045     , m_hasTailCalls(cachedCodeBlock.hasTailCalls())
2046     , m_constructorKind(cachedCodeBlock.constructorKind())
2047     , m_derivedContextType(cachedCodeBlock.derivedContextType())
2048     , m_evalContextType(cachedCodeBlock.evalContextType())
2049     , m_codeType(cachedCodeBlock.codeType())
2050 
2051     , m_didOptimize(static_cast&lt;unsigned&gt;(MixedTriState))
2052     , m_age(0)
<span class="line-added">2053     , m_hasCheckpoints(cachedCodeBlock.hasCheckpoints())</span>
2054 
2055     , m_features(cachedCodeBlock.features())
2056     , m_parseMode(cachedCodeBlock.parseMode())
2057     , m_codeGenerationMode(cachedCodeBlock.codeGenerationMode())
2058 
2059     , m_lineCount(cachedCodeBlock.lineCount())
2060     , m_endColumn(cachedCodeBlock.endColumn())
2061     , m_numVars(cachedCodeBlock.numVars())
2062     , m_numCalleeLocals(cachedCodeBlock.numCalleeLocals())
2063     , m_numParameters(cachedCodeBlock.numParameters())
2064 
2065     , m_sourceURLDirective(cachedCodeBlock.sourceURLDirective(decoder))
2066     , m_sourceMappingURLDirective(cachedCodeBlock.sourceMappingURLDirective(decoder))
2067 
2068     , m_metadata(cachedCodeBlock.metadata(decoder))
2069     , m_instructions(cachedCodeBlock.instructions(decoder))
2070 
2071     , m_rareData(cachedCodeBlock.rareData(decoder))
2072 {
2073 }
2074 
2075 template&lt;typename CodeBlockType&gt;
2076 ALWAYS_INLINE void CachedCodeBlock&lt;CodeBlockType&gt;::decode(Decoder&amp; decoder, UnlinkedCodeBlock&amp; codeBlock) const
2077 {




2078     m_constantRegisters.decode(decoder, codeBlock.m_constantRegisters, &amp;codeBlock);
2079     m_constantsSourceCodeRepresentation.decode(decoder, codeBlock.m_constantsSourceCodeRepresentation);
2080     m_expressionInfo.decode(decoder, codeBlock.m_expressionInfo);
2081     m_outOfLineJumpTargets.decode(decoder, codeBlock.m_outOfLineJumpTargets);
2082     m_jumpTargets.decode(decoder, codeBlock.m_jumpTargets);
2083     m_identifiers.decode(decoder, codeBlock.m_identifiers);
2084     m_functionDecls.decode(decoder, codeBlock.m_functionDecls, &amp;codeBlock);
2085     m_functionExprs.decode(decoder, codeBlock.m_functionExprs, &amp;codeBlock);
2086 }
2087 
2088 ALWAYS_INLINE UnlinkedProgramCodeBlock::UnlinkedProgramCodeBlock(Decoder&amp; decoder, const CachedProgramCodeBlock&amp; cachedCodeBlock)
2089     : Base(decoder, decoder.vm().unlinkedProgramCodeBlockStructure.get(), cachedCodeBlock)
2090 {
2091 }
2092 
2093 ALWAYS_INLINE UnlinkedModuleProgramCodeBlock::UnlinkedModuleProgramCodeBlock(Decoder&amp; decoder, const CachedModuleCodeBlock&amp; cachedCodeBlock)
2094     : Base(decoder, decoder.vm().unlinkedModuleProgramCodeBlockStructure.get(), cachedCodeBlock)
2095 {
2096 }
2097 
</pre>
<hr />
<pre>
2111     m_unlinkedBodyStartColumn = executable.m_unlinkedBodyStartColumn;
2112     m_unlinkedBodyEndColumn = executable.m_unlinkedBodyEndColumn;
2113     m_startOffset = executable.m_startOffset;
2114     m_sourceLength = executable.m_sourceLength;
2115     m_parametersStartOffset = executable.m_parametersStartOffset;
2116     m_typeProfilingStartOffset = executable.m_typeProfilingStartOffset;
2117     m_typeProfilingEndOffset = executable.m_typeProfilingEndOffset;
2118     m_parameterCount = executable.m_parameterCount;
2119 
2120     m_sourceParseMode = executable.m_sourceParseMode;
2121 
2122     m_isInStrictContext = executable.m_isInStrictContext;
2123     m_isBuiltinFunction = executable.m_isBuiltinFunction;
2124     m_isBuiltinDefaultClassConstructor = executable.m_isBuiltinDefaultClassConstructor;
2125     m_constructAbility = executable.m_constructAbility;
2126     m_constructorKind = executable.m_constructorKind;
2127     m_functionMode = executable.m_functionMode;
2128     m_scriptMode = executable.m_scriptMode;
2129     m_superBinding = executable.m_superBinding;
2130     m_derivedContextType = executable.m_derivedContextType;
<span class="line-added">2131     m_needsClassFieldInitializer = executable.m_needsClassFieldInitializer;</span>
2132 
2133     m_rareData.encode(encoder, executable.m_rareData.get());
2134 
2135     m_name.encode(encoder, executable.name());
2136     m_ecmaName.encode(encoder, executable.ecmaName());
2137 
2138     m_unlinkedCodeBlockForCall.encode(encoder, executable.m_unlinkedCodeBlockForCall);
2139     m_unlinkedCodeBlockForConstruct.encode(encoder, executable.m_unlinkedCodeBlockForConstruct);
2140 
2141     if (!executable.m_unlinkedCodeBlockForCall || !executable.m_unlinkedCodeBlockForConstruct)
2142         encoder.addLeafExecutable(&amp;executable, encoder.offsetOf(this));
2143 }
2144 
2145 ALWAYS_INLINE UnlinkedFunctionExecutable* CachedFunctionExecutable::decode(Decoder&amp; decoder) const
2146 {
2147     UnlinkedFunctionExecutable* executable = new (NotNull, allocateCell&lt;UnlinkedFunctionExecutable&gt;(decoder.vm().heap)) UnlinkedFunctionExecutable(decoder, *this);
2148     executable-&gt;finishCreation(decoder.vm());
2149     return executable;
2150 }
2151 
</pre>
<hr />
<pre>
2159     , m_isBuiltinFunction(cachedExecutable.isBuiltinFunction())
2160     , m_unlinkedBodyStartColumn(cachedExecutable.unlinkedBodyStartColumn())
2161     , m_isBuiltinDefaultClassConstructor(cachedExecutable.isBuiltinDefaultClassConstructor())
2162     , m_unlinkedBodyEndColumn(cachedExecutable.unlinkedBodyEndColumn())
2163     , m_constructAbility(cachedExecutable.constructAbility())
2164     , m_startOffset(cachedExecutable.startOffset())
2165     , m_scriptMode(cachedExecutable.scriptMode())
2166     , m_sourceLength(cachedExecutable.sourceLength())
2167     , m_superBinding(cachedExecutable.superBinding())
2168     , m_parametersStartOffset(cachedExecutable.parametersStartOffset())
2169     , m_isCached(false)
2170     , m_typeProfilingStartOffset(cachedExecutable.typeProfilingStartOffset())
2171     , m_typeProfilingEndOffset(cachedExecutable.typeProfilingEndOffset())
2172     , m_parameterCount(cachedExecutable.parameterCount())
2173     , m_features(cachedExecutable.features())
2174     , m_sourceParseMode(cachedExecutable.sourceParseMode())
2175     , m_constructorKind(cachedExecutable.constructorKind())
2176     , m_functionMode(cachedExecutable.functionMode())
2177     , m_derivedContextType(cachedExecutable.derivedContextType())
2178     , m_isGeneratedFromCache(true)
<span class="line-added">2179     , m_needsClassFieldInitializer(cachedExecutable.needsClassFieldInitializer())</span>
2180     , m_unlinkedCodeBlockForCall()
2181     , m_unlinkedCodeBlockForConstruct()
2182 
2183     , m_name(cachedExecutable.name(decoder))
2184     , m_ecmaName(cachedExecutable.ecmaName(decoder))
2185 
2186     , m_rareData(cachedExecutable.rareData(decoder))
2187 {
2188 
2189     uint32_t leafExecutables = 2;
2190     auto checkBounds = [&amp;](int32_t&amp; codeBlockOffset, auto&amp; cachedPtr) {
2191         if (!cachedPtr.isEmpty()) {
2192             ptrdiff_t offset = decoder.offsetOf(&amp;cachedPtr);
2193             if (static_cast&lt;size_t&gt;(offset) &lt; decoder.size()) {
2194                 codeBlockOffset = offset;
2195                 m_isCached = true;
2196                 leafExecutables--;
2197                 return;
2198             }
2199         }
</pre>
<hr />
<pre>
2224     m_isConstructor = codeBlock.m_isConstructor;
2225     m_hasCapturedVariables = codeBlock.m_hasCapturedVariables;
2226     m_isBuiltinFunction = codeBlock.m_isBuiltinFunction;
2227     m_superBinding = codeBlock.m_superBinding;
2228     m_scriptMode = codeBlock.m_scriptMode;
2229     m_isArrowFunctionContext = codeBlock.m_isArrowFunctionContext;
2230     m_isClassContext = codeBlock.m_isClassContext;
2231     m_hasTailCalls = codeBlock.m_hasTailCalls;
2232     m_constructorKind = codeBlock.m_constructorKind;
2233     m_derivedContextType = codeBlock.m_derivedContextType;
2234     m_evalContextType = codeBlock.m_evalContextType;
2235     m_lineCount = codeBlock.m_lineCount;
2236     m_endColumn = codeBlock.m_endColumn;
2237     m_numVars = codeBlock.m_numVars;
2238     m_numCalleeLocals = codeBlock.m_numCalleeLocals;
2239     m_numParameters = codeBlock.m_numParameters;
2240     m_features = codeBlock.m_features;
2241     m_parseMode = codeBlock.m_parseMode;
2242     m_codeGenerationMode = codeBlock.m_codeGenerationMode;
2243     m_codeType = codeBlock.m_codeType;
<span class="line-modified">2244     m_hasCheckpoints = codeBlock.m_hasCheckpoints;</span>


2245 
2246     m_metadata.encode(encoder, codeBlock.m_metadata.get());
2247     m_rareData.encode(encoder, codeBlock.m_rareData.get());
2248 
<span class="line-modified">2249     m_sourceURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.get());</span>
<span class="line-modified">2250     m_sourceMappingURLDirective.encode(encoder, codeBlock.m_sourceURLDirective.get());</span>
2251 
2252     m_instructions.encode(encoder, codeBlock.m_instructions.get());

2253     m_constantRegisters.encode(encoder, codeBlock.m_constantRegisters);
2254     m_constantsSourceCodeRepresentation.encode(encoder, codeBlock.m_constantsSourceCodeRepresentation);
2255     m_expressionInfo.encode(encoder, codeBlock.m_expressionInfo);
2256     m_jumpTargets.encode(encoder, codeBlock.m_jumpTargets);
2257     m_outOfLineJumpTargets.encode(encoder, codeBlock.m_outOfLineJumpTargets);
2258 
2259     m_identifiers.encode(encoder, codeBlock.m_identifiers);
2260     m_functionDecls.encode(encoder, codeBlock.m_functionDecls);
2261     m_functionExprs.encode(encoder, codeBlock.m_functionExprs);
2262 }
2263 
2264 class CachedSourceCodeKey : public CachedObject&lt;SourceCodeKey&gt; {
2265 public:
2266     void encode(Encoder&amp; encoder, const SourceCodeKey&amp; key)
2267     {
2268         m_sourceCode.encode(encoder, key.m_sourceCode);
2269         m_name.encode(encoder, key.m_name);
2270         m_flags = key.m_flags.m_flags;
2271         m_hash = key.hash();
2272         m_functionConstructorParametersEndPosition = key.m_functionConstructorParametersEndPosition;
</pre>
<hr />
<pre>
2288     unsigned m_hash;
2289     int m_functionConstructorParametersEndPosition;
2290 };
2291 
2292 class GenericCacheEntry {
2293 public:
2294     bool decode(Decoder&amp;, std::pair&lt;SourceCodeKey, UnlinkedCodeBlock*&gt;&amp;) const;
2295     bool isStillValid(Decoder&amp;, const SourceCodeKey&amp;, CachedCodeBlockTag) const;
2296 
2297 protected:
2298     GenericCacheEntry(Encoder&amp; encoder, CachedCodeBlockTag tag)
2299         : m_tag(tag)
2300     {
2301         m_bootSessionUUID.encode(encoder, bootSessionUUIDString());
2302     }
2303 
2304     CachedCodeBlockTag tag() const { return m_tag; }
2305 
2306     bool isUpToDate(Decoder&amp; decoder) const
2307     {
<span class="line-modified">2308         if (m_cacheVersion != jscBytecodeCacheVersion())</span>
2309             return false;
2310         if (m_bootSessionUUID.decode(decoder) != bootSessionUUIDString())
2311             return false;
2312         return true;
2313     }
2314 
2315 private:
<span class="line-modified">2316     uint32_t m_cacheVersion { jscBytecodeCacheVersion() };</span>
2317     CachedString m_bootSessionUUID;
2318     CachedCodeBlockTag m_tag;
2319 };
2320 
2321 template&lt;typename UnlinkedCodeBlockType&gt;
2322 class CacheEntry : public GenericCacheEntry {
2323 public:
2324     CacheEntry(Encoder&amp; encoder)
2325         : GenericCacheEntry(encoder, CachedCodeBlockTypeImpl&lt;UnlinkedCodeBlockType&gt;::tag)
2326     {
2327     }
2328 
2329     void encode(Encoder&amp; encoder, std::pair&lt;SourceCodeKey, const UnlinkedCodeBlockType*&gt; pair)
2330     {
2331         m_key.encode(encoder, pair.first);
2332         m_codeBlock.encode(encoder, pair.second);
2333     }
2334 
2335 private:
2336     friend GenericCacheEntry;
</pre>
</td>
</tr>
</table>
<center><a href="CachedBytecode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
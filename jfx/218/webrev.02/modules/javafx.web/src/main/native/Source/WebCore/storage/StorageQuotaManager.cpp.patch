diff a/modules/javafx.web/src/main/native/Source/WebCore/storage/StorageQuotaManager.cpp b/modules/javafx.web/src/main/native/Source/WebCore/storage/StorageQuotaManager.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/storage/StorageQuotaManager.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/storage/StorageQuotaManager.cpp
@@ -25,187 +25,122 @@
 
 #include "config.h"
 #include "StorageQuotaManager.h"
 
 #include "Logging.h"
-#include "StorageQuotaUser.h"
+#include <wtf/Ref.h>
+#include <wtf/RefCounted.h>
+#include <wtf/threads/BinarySemaphore.h>
 
 namespace WebCore {
 
-StorageQuotaManager::~StorageQuotaManager()
+Ref<StorageQuotaManager> StorageQuotaManager::create(uint64_t quota, UsageGetter&& usageGetter, QuotaIncreaseRequester&& quotaIncreaseRequester)
 {
-    while (!m_pendingRequests.isEmpty())
-        m_pendingRequests.takeFirst().callback(Decision::Deny);
+    return adoptRef(*new StorageQuotaManager(quota, WTFMove(usageGetter), WTFMove(quotaIncreaseRequester)));
 }
 
-uint64_t StorageQuotaManager::spaceUsage() const
+StorageQuotaManager::StorageQuotaManager(uint64_t quota, UsageGetter&& usageGetter, QuotaIncreaseRequester&& quotaIncreaseRequester)
+    : m_quota(quota)
+    , m_usageGetter(WTFMove(usageGetter))
+    , m_quotaIncreaseRequester(WTFMove(quotaIncreaseRequester))
+    , m_workQueue(WorkQueue::create("StorageQuotaManager Background Queue", WorkQueue::Type::Serial))
+    , m_initialQuota(quota)
 {
-    uint64_t usage = 0;
-    for (auto& user : m_users)
-        usage += user->spaceUsed();
-    return usage;
 }
 
-void StorageQuotaManager::updateQuotaBasedOnSpaceUsage()
+void StorageQuotaManager::requestSpaceOnMainThread(uint64_t spaceRequested, RequestCallback&& callback)
 {
-    if (!m_quota)
-        return;
+    ASSERT(isMainThread());
 
-    auto defaultQuotaStep = m_quota / 10;
-    m_quota = std::max(m_quota, defaultQuotaStep * ((spaceUsage() / defaultQuotaStep) + 1));
-}
-
-void StorageQuotaManager::initializeUsersIfNeeded()
-{
-    if (m_pendingInitializationUsers.isEmpty())
-        return;
-
-    Vector<StorageQuotaUser*> usersToInitialize;
-    for (auto& keyValue : m_pendingInitializationUsers) {
-        if (keyValue.value == WhenInitializedCalled::No) {
-            keyValue.value = WhenInitializedCalled::Yes;
-            usersToInitialize.append(keyValue.key);
+    // Fast path.
+    if (m_quotaCountDownLock.tryLock()) {
+        if (tryGrantRequest(spaceRequested)) {
+            m_quotaCountDownLock.unlock();
+            callback(Decision::Grant);
+            return;
         }
+        m_quotaCountDownLock.unlock();
     }
-    for (auto* user : usersToInitialize) {
-        if (m_pendingInitializationUsers.contains(user))
-            askUserToInitialize(*user);
-    }
+
+    m_workQueue->dispatch([this, protectedThis = makeRef(*this), spaceRequested, callback = WTFMove(callback)]() mutable {
+        auto decision = requestSpaceOnBackgroundThread(spaceRequested);
+        callOnMainThread([callback = WTFMove(callback), decision]() mutable {
+            callback(decision);
+        });
+    });
 }
 
-void StorageQuotaManager::askUserToInitialize(StorageQuotaUser& user)
+StorageQuotaManager::Decision StorageQuotaManager::requestSpaceOnBackgroundThread(uint64_t spaceRequested)
 {
-    user.whenInitialized([this, &user, weakThis = makeWeakPtr(this)]() {
-        if (!weakThis)
-            return;
+    ASSERT(!isMainThread());
 
-        if (m_pendingInitializationUsers.remove(&user))
-            m_users.add(&user);
+    LockHolder locker(m_quotaCountDownLock);
 
-        if (!m_pendingInitializationUsers.isEmpty())
-            return;
+    if (tryGrantRequest(spaceRequested))
+        return Decision::Grant;
 
-        updateQuotaBasedOnSpaceUsage();
-        processPendingRequests({ }, ShouldDequeueFirstPendingRequest::No);
-    });
-}
+    m_usage = m_usageGetter();
+    updateQuotaBasedOnUsage();
+    m_quotaCountDown = m_usage < m_quota ? m_quota - m_usage : 0;
+    if (tryGrantRequest(spaceRequested))
+        return Decision::Grant;
 
-void StorageQuotaManager::addUser(StorageQuotaUser& user)
-{
-    ASSERT(!m_pendingInitializationUsers.contains(&user));
-    ASSERT(!m_users.contains(&user));
-    m_pendingInitializationUsers.add(&user, WhenInitializedCalled::No);
+    // Block this thread until getting decsion for quota increase.
+    BinarySemaphore semaphore;
+    callOnMainThread([this, protectedThis = makeRef(*this), spaceRequested, &semaphore]() mutable {
+        RELEASE_LOG(Storage, "%p - StorageQuotaManager asks for quota increase %" PRIu64, this, spaceRequested);
+        m_quotaIncreaseRequester(m_quota, m_usage, spaceRequested, [this, protectedThis = WTFMove(protectedThis), &semaphore](Optional<uint64_t> newQuota) mutable {
+            RELEASE_LOG(Storage, "%p - StorageQuotaManager receives quota increase response %" PRIu64, this, newQuota ? *newQuota : 0);
+            ASSERT(isMainThread());
 
-    if (!m_pendingRequests.isEmpty())
-        askUserToInitialize(user);
-}
+            if (newQuota)
+                m_quota = *newQuota;
 
-bool StorageQuotaManager::shouldAskForMoreSpace(uint64_t spaceIncrease) const
-{
-    if (!spaceIncrease)
-        return false;
+            semaphore.signal();
+        });
+    });
+
+    semaphore.wait();
 
-    return spaceUsage() + spaceIncrease > m_quota;
+    m_usage = m_usageGetter();
+    m_quotaCountDown = m_usage < m_quota ? m_quota - m_usage : 0;
+    return tryGrantRequest(spaceRequested) ? Decision::Grant : Decision::Deny;
 }
 
-void StorageQuotaManager::removeUser(StorageQuotaUser& user)
+bool StorageQuotaManager::tryGrantRequest(uint64_t spaceRequested)
 {
-    ASSERT(m_users.contains(&user) || m_pendingInitializationUsers.contains(&user));
-    m_users.remove(&user);
-    if (m_pendingInitializationUsers.remove(&user) && m_pendingInitializationUsers.isEmpty()) {
-        // When being cleared, quota users may remove themselves and add themselves to trigger reinitialization.
-        // Let's wait for addUser to be called before processing pending requests.
-        callOnMainThread([this, weakThis = makeWeakPtr(this)] {
-            if (!weakThis)
-                return;
-
-            if (m_pendingInitializationUsers.isEmpty())
-                this->processPendingRequests({ }, ShouldDequeueFirstPendingRequest::No);
-        });
+    ASSERT(m_quotaCountDownLock.isLocked());
+    if (spaceRequested <= m_quotaCountDown) {
+        m_quotaCountDown -= spaceRequested;
+        return true;
     }
+    return false;
 }
 
-void StorageQuotaManager::requestSpace(uint64_t spaceIncrease, RequestCallback&& callback)
+void StorageQuotaManager::updateQuotaBasedOnUsage()
 {
-    if (!m_pendingRequests.isEmpty()) {
-        m_pendingRequests.append({ spaceIncrease, WTFMove(callback) });
-        return;
-    }
-
-    if (!spaceIncrease) {
-        callback(Decision::Grant);
-        return;
+    // When StorageQuotaManager is used for the first time, we want to make sure its initial quota is bigger than current disk usage,
+    // based on the assumption that the quota was increased to at least the disk usage under user's permission before.
+    ASSERT(m_quotaCountDownLock.isLocked());
+    if (!m_quotaUpdatedBasedOnUsage) {
+        m_quotaUpdatedBasedOnUsage = true;
+        auto defaultQuotaStep = m_quota / 10;
+        m_quota = std::max(m_quota, defaultQuotaStep * ((m_usage / defaultQuotaStep) + 1));
     }
-
-    initializeUsersIfNeeded();
-
-    if (!m_pendingInitializationUsers.isEmpty()) {
-        m_pendingRequests.append({ spaceIncrease, WTFMove(callback) });
-        return;
-    }
-
-    if (shouldAskForMoreSpace(spaceIncrease)) {
-        m_pendingRequests.append({ spaceIncrease, WTFMove(callback) });
-        askForMoreSpace(spaceIncrease);
-        return;
-    }
-
-    callback(Decision::Grant);
 }
 
-void StorageQuotaManager::askForMoreSpace(uint64_t spaceIncrease)
+void StorageQuotaManager::resetQuotaUpdatedBasedOnUsageForTesting()
 {
-    ASSERT(shouldAskForMoreSpace(spaceIncrease));
-    ASSERT(!m_isWaitingForSpaceIncreaseResponse);
-
-    RELEASE_LOG(Storage, "%p - StorageQuotaManager::askForMoreSpace %" PRIu64, this, spaceIncrease);
-    m_isWaitingForSpaceIncreaseResponse = true;
-    m_spaceIncreaseRequester(m_quota, spaceUsage(), spaceIncrease, [this, weakThis = makeWeakPtr(*this)](Optional<uint64_t> newQuota) {
-        if (!weakThis)
-            return;
-
-        RELEASE_LOG(Storage, "%p - StorageQuotaManager::askForMoreSpace received response %" PRIu64, this, newQuota ? *newQuota : 0);
-
-        m_isWaitingForSpaceIncreaseResponse = false;
-        processPendingRequests(newQuota, ShouldDequeueFirstPendingRequest::Yes);
-    });
+    LockHolder locker(m_quotaCountDownLock);
+    m_quota = m_initialQuota;
+    m_quotaCountDown = 0;
+    m_quotaUpdatedBasedOnUsage = false;
 }
 
-void StorageQuotaManager::processPendingRequests(Optional<uint64_t> newQuota, ShouldDequeueFirstPendingRequest shouldDequeueFirstPendingRequest)
+void StorageQuotaManager::resetQuotaForTesting()
 {
-    if (m_pendingRequests.isEmpty())
-        return;
-
-    if (newQuota)
-        m_quota = *newQuota;
-
-    if (m_isWaitingForSpaceIncreaseResponse)
-        return;
-
-    if (!m_pendingInitializationUsers.isEmpty())
-        return;
-
-    if (shouldDequeueFirstPendingRequest == ShouldDequeueFirstPendingRequest::Yes) {
-        auto request = m_pendingRequests.takeFirst();
-        bool shouldAllowRequest = !shouldAskForMoreSpace(request.spaceIncrease);
-
-        RELEASE_LOG(Storage, "%p - StorageQuotaManager::processPendingRequests first request decision is %d", this, shouldAllowRequest);
-
-        request.callback(shouldAllowRequest ? Decision::Grant : Decision::Deny);
-    }
-
-    while (!m_pendingRequests.isEmpty()) {
-        auto& request = m_pendingRequests.first();
-
-        if (shouldAskForMoreSpace(request.spaceIncrease)) {
-            uint64_t spaceIncrease = 0;
-            for (auto& request : m_pendingRequests)
-                spaceIncrease += request.spaceIncrease;
-            askForMoreSpace(spaceIncrease);
-            return;
-        }
-
-        m_pendingRequests.takeFirst().callback(Decision::Grant);
-    }
+    LockHolder locker(m_quotaCountDownLock);
+    m_quota = m_initialQuota;
+    m_quotaCountDown = 0;
 }
 
 } // namespace WebCore

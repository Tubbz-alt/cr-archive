diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSMicrotask.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSMicrotask.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSMicrotask.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSMicrotask.cpp
@@ -38,61 +38,63 @@
 
 namespace JSC {
 
 class JSMicrotask final : public Microtask {
 public:
-    JSMicrotask(VM& vm, JSValue job, JSArray* arguments)
+    static constexpr unsigned maxArguments = 3;
+    JSMicrotask(VM& vm, JSValue job, JSValue argument0, JSValue argument1, JSValue argument2)
     {
         m_job.set(vm, job);
-        m_arguments.set(vm, arguments);
+        m_arguments[0].set(vm, argument0);
+        m_arguments[1].set(vm, argument1);
+        m_arguments[2].set(vm, argument2);
     }
 
     JSMicrotask(VM& vm, JSValue job)
     {
         m_job.set(vm, job);
     }
 
 private:
-    void run(ExecState*) override;
+    void run(JSGlobalObject*) override;
 
     Strong<Unknown> m_job;
-    Strong<JSArray> m_arguments;
+    Strong<Unknown> m_arguments[maxArguments];
 };
 
 Ref<Microtask> createJSMicrotask(VM& vm, JSValue job)
 {
     return adoptRef(*new JSMicrotask(vm, job));
 }
 
-Ref<Microtask> createJSMicrotask(VM& vm, JSValue job, JSArray* arguments)
+Ref<Microtask> createJSMicrotask(VM& vm, JSValue job, JSValue argument0, JSValue argument1, JSValue argument2)
 {
-    return adoptRef(*new JSMicrotask(vm, job, arguments));
+    return adoptRef(*new JSMicrotask(vm, job, argument0, argument1, argument2));
 }
 
-void JSMicrotask::run(ExecState* exec)
+void JSMicrotask::run(JSGlobalObject* globalObject)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
     CallData handlerCallData;
     CallType handlerCallType = getCallData(vm, m_job.get(), handlerCallData);
     ASSERT(handlerCallType != CallType::None);
 
     MarkedArgumentBuffer handlerArguments;
-    if (m_arguments) {
-        for (unsigned index = 0, length = m_arguments->length(); index < length; ++index) {
-            JSValue arg = m_arguments->JSArray::get(exec, index);
-            CLEAR_AND_RETURN_IF_EXCEPTION(scope, handlerArguments.overflowCheckNotNeeded());
-            handlerArguments.append(arg);
-        }
-        if (UNLIKELY(handlerArguments.hasOverflowed()))
-            return;
+    for (unsigned index = 0; index < maxArguments; ++index) {
+        JSValue arg = m_arguments[index].get();
+        if (!arg)
+            break;
+        handlerArguments.append(arg);
     }
+    if (UNLIKELY(handlerArguments.hasOverflowed()))
+        return;
 
-    if (UNLIKELY(exec->lexicalGlobalObject()->hasDebugger()))
-        exec->lexicalGlobalObject()->debugger()->willRunMicrotask();
+    if (UNLIKELY(globalObject->hasDebugger()))
+        globalObject->debugger()->willRunMicrotask();
 
-    profiledCall(exec, ProfilingReason::Microtask, m_job.get(), handlerCallType, handlerCallData, jsUndefined(), handlerArguments);
+    profiledCall(globalObject, ProfilingReason::Microtask, m_job.get(), handlerCallType, handlerCallData, jsUndefined(), handlerArguments);
     scope.clearException();
 }
 
 } // namespace JSC

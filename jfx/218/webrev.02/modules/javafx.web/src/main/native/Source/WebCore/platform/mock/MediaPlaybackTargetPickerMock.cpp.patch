diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MediaPlaybackTargetPickerMock.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MediaPlaybackTargetPickerMock.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MediaPlaybackTargetPickerMock.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MediaPlaybackTargetPickerMock.cpp
@@ -37,11 +37,10 @@
 
 static const Seconds timerInterval { 100_ms };
 
 MediaPlaybackTargetPickerMock::MediaPlaybackTargetPickerMock(MediaPlaybackTargetPicker::Client& client)
     : MediaPlaybackTargetPicker(client)
-    , m_timer(RunLoop::main(), this, &MediaPlaybackTargetPickerMock::timerFired)
 {
     LOG(Media, "MediaPlaybackTargetPickerMock::MediaPlaybackTargetPickerMock");
 }
 
 MediaPlaybackTargetPickerMock::~MediaPlaybackTargetPickerMock()
@@ -60,40 +59,40 @@
 {
     LOG(Media, "MediaPlaybackTargetPickerMock::playbackTarget");
     return WebCore::MediaPlaybackTargetMock::create(m_deviceName, m_state);
 }
 
-void MediaPlaybackTargetPickerMock::timerFired()
-{
-    m_showingMenu = false;
-    currentDeviceDidChange();
-}
-
 void MediaPlaybackTargetPickerMock::showPlaybackTargetPicker(const FloatRect&, bool checkActiveRoute, bool useDarkAppearance)
 {
     if (!client() || m_showingMenu)
         return;
 
 #if LOG_DISABLED
     UNUSED_PARAM(checkActiveRoute);
     UNUSED_PARAM(useDarkAppearance);
 #endif
+
     LOG(Media, "MediaPlaybackTargetPickerMock::showPlaybackTargetPicker - checkActiveRoute = %i, useDarkAppearance = %i", (int)checkActiveRoute, (int)useDarkAppearance);
 
     m_showingMenu = true;
-    m_timer.startOneShot(timerInterval);
+    m_taskQueue.enqueueTask([this] {
+        m_showingMenu = false;
+        currentDeviceDidChange();
+    });
 }
 
 void MediaPlaybackTargetPickerMock::startingMonitoringPlaybackTargets()
 {
     LOG(Media, "MediaPlaybackTargetPickerMock::startingMonitoringPlaybackTargets");
 
-    if (m_state == MediaPlaybackTargetContext::OutputDeviceAvailable)
-        availableDevicesDidChange();
+    m_taskQueue.enqueueTask([this] {
+        if (m_state == MediaPlaybackTargetContext::OutputDeviceAvailable)
+            availableDevicesDidChange();
 
-    if (!m_deviceName.isEmpty() && m_state != MediaPlaybackTargetContext::Unknown)
-        currentDeviceDidChange();
+        if (!m_deviceName.isEmpty() && m_state != MediaPlaybackTargetContext::Unknown)
+            currentDeviceDidChange();
+    });
 }
 
 void MediaPlaybackTargetPickerMock::stopMonitoringPlaybackTargets()
 {
     LOG(Media, "MediaPlaybackTargetPickerMock::stopMonitoringPlaybackTargets");
@@ -107,19 +106,30 @@
 
 void MediaPlaybackTargetPickerMock::setState(const String& deviceName, MediaPlaybackTargetContext::State state)
 {
     LOG(Media, "MediaPlaybackTargetPickerMock::setState - name = %s, state = 0x%x", deviceName.utf8().data(), (unsigned)state);
 
-    if (deviceName != m_deviceName && state != MediaPlaybackTargetContext::Unknown) {
-        m_deviceName = deviceName;
-        currentDeviceDidChange();
-    }
+    m_taskQueue.enqueueTask([this, state, deviceName] {
+        if (deviceName != m_deviceName && state != MediaPlaybackTargetContext::Unknown) {
+            m_deviceName = deviceName;
+            currentDeviceDidChange();
+        }
+
+        if (m_state != state) {
+            m_state = state;
+            availableDevicesDidChange();
+        }
+    });
+}
 
-    if (m_state != state) {
-        m_state = state;
-        availableDevicesDidChange();
-    }
+void MediaPlaybackTargetPickerMock::dismissPopup()
+{
+    if (!m_showingMenu)
+        return;
+
+    m_showingMenu = false;
+    currentDeviceDidChange();
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET) && !PLATFORM(IOS_FAMILY)

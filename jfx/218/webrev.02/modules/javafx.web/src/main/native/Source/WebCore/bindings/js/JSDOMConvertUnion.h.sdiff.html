<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertStrings.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertVariadic.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertUnion.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45     static Optional&lt;ReturnType&gt; get(T&amp;&amp; value)
 46     {
 47         return ReturnType(std::forward&lt;T&gt;(value));
 48     }
 49 };
 50 
 51 template&lt;typename ReturnType&gt;
 52 struct ConditionalReturner&lt;ReturnType, false&gt; {
 53     template&lt;typename T&gt;
 54     static Optional&lt;ReturnType&gt; get(T&amp;&amp;)
 55     {
 56         return WTF::nullopt;
 57     }
 58 };
 59 
 60 template&lt;typename ReturnType, typename T, bool enabled&gt;
 61 struct ConditionalConverter;
 62 
 63 template&lt;typename ReturnType, typename T&gt;
 64 struct ConditionalConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified"> 65     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
 66     {
<span class="line-modified"> 67         return ReturnType(Converter&lt;T&gt;::convert(state, value));</span>
 68     }
 69 };
 70 
 71 template&lt;typename ReturnType, typename T&gt;
 72 struct ConditionalConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified"> 73     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp;, JSC::JSValue)</span>
 74     {
 75         return WTF::nullopt;
 76     }
 77 };
 78 
 79 template&lt;typename ReturnType, typename T, bool enabled&gt;
 80 struct ConditionalSequenceConverter;
 81 
 82 template&lt;typename ReturnType, typename T&gt;
 83 struct ConditionalSequenceConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified"> 84     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp; state, JSC::JSObject* object, JSC::JSValue method)</span>
 85     {
<span class="line-modified"> 86         return ReturnType(Converter&lt;T&gt;::convert(state, object, method));</span>
 87     }
 88 };
 89 
 90 template&lt;typename ReturnType, typename T&gt;
 91 struct ConditionalSequenceConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified"> 92     static Optional&lt;ReturnType&gt; convert(JSC::ExecState&amp;, JSC::JSObject*, JSC::JSValue)</span>
 93     {
 94         return WTF::nullopt;
 95     }
 96 };
 97 
 98 namespace Detail {
 99 
100 template&lt;typename List, bool condition&gt;
101 struct ConditionalFront;
102 
103 template&lt;typename List&gt;
104 struct ConditionalFront&lt;List, true&gt; {
105     using type = brigand::front&lt;List&gt;;
106 };
107 
108 template&lt;typename List&gt;
109 struct ConditionalFront&lt;List, false&gt; {
110     using type = void;
111 };
112 
</pre>
<hr />
<pre>
146     static constexpr bool hasDictionaryType = numberOfDictionaryTypes != 0;
147     using DictionaryType = ConditionalFront&lt;DictionaryTypeList, hasDictionaryType&gt;;
148 
149     using RecordTypeList = brigand::filter&lt;TypeList, IsIDLRecord&lt;brigand::_1&gt;&gt;;
150     static constexpr size_t numberOfRecordTypes = brigand::size&lt;RecordTypeList&gt;::value;
151     static_assert(numberOfRecordTypes == 0 || numberOfRecordTypes == 1, &quot;There can be 0 or 1 record types in an IDLUnion.&quot;);
152     static constexpr bool hasRecordType = numberOfRecordTypes != 0;
153     using RecordType = ConditionalFront&lt;RecordTypeList, hasRecordType&gt;;
154 
155     using ObjectTypeList = brigand::filter&lt;TypeList, std::is_same&lt;IDLObject, brigand::_1&gt;&gt;;
156     static constexpr size_t numberOfObjectTypes = brigand::size&lt;ObjectTypeList&gt;::value;
157     static_assert(numberOfObjectTypes == 0 || numberOfObjectTypes == 1, &quot;There can be 0 or 1 object types in an IDLUnion.&quot;);
158     static constexpr bool hasObjectType = numberOfObjectTypes != 0;
159     using ObjectType = ConditionalFront&lt;ObjectTypeList, hasObjectType&gt;;
160 
161     static constexpr bool hasAnyObjectType = (numberOfSequenceTypes + numberOfFrozenArrayTypes + numberOfDictionaryTypes + numberOfRecordTypes + numberOfObjectTypes) &gt; 0;
162 
163     using InterfaceTypeList = brigand::filter&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;;
164     using TypedArrayTypeList = brigand::filter&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;;
165 
<span class="line-modified">166     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
167     {
<span class="line-modified">168         JSC::VM&amp; vm = state.vm();</span>
169         auto scope = DECLARE_THROW_SCOPE(vm);
170 
171         // 1. If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
172         constexpr bool hasNullType = brigand::any&lt;TypeList, std::is_same&lt;IDLNull, brigand::_1&gt;&gt;::value;
173         if (hasNullType) {
174             if (value.isUndefinedOrNull())
<span class="line-modified">175                 return ConditionalConverter&lt;ReturnType, IDLNull, hasNullType&gt;::convert(state, value).value();</span>
176         }
177 
178         // 2. Let types be the flattened member types of the union type.
179         // NOTE: Union is expected to be pre-flattented.
180 
181         // 3. If V is null or undefined then:
182         if (hasDictionaryType) {
183             if (value.isUndefinedOrNull()) {
184                 //     1. If types includes a dictionary type, then return the result of converting V to that dictionary type.
<span class="line-modified">185                 return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(state, value).value();</span>
186             }
187         }
188 
189         // 4. If V is a platform object, then:
190         //     1. If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
191         //     2. If types includes object, then return the IDL value that is a reference to the object V.
192         //         (FIXME: Add support for object and step 4.2)
193         if (brigand::any&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;::value) {
194             Optional&lt;ReturnType&gt; returnValue;
195             brigand::for_each&lt;InterfaceTypeList&gt;([&amp;](auto&amp;&amp; type) {
196                 if (returnValue)
197                     return;
198 
199                 using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
200                 using ImplementationType = typename Type::ImplementationType;
201                 using RawType = typename Type::RawType;
202 
<span class="line-modified">203                 auto castedValue = JSToWrappedOverloader&lt;RawType&gt;::toWrapped(state, value);</span>
204                 if (!castedValue)
205                     return;
206 
207                 returnValue = ReturnType(ImplementationType(castedValue));
208             });
209 
210             if (returnValue)
211                 return WTFMove(returnValue.value());
212         }
213 
214         // FIXME: Add support for steps 5 &amp; 6.
215         //
216         // 5. If V is a DOMException platform object, then:
217         //     1. If types includes DOMException or Error, then return the result of converting V to that type.
218         //     2 If types includes object, then return the IDL value that is a reference to the object V.
219         //
220         // 6. If Type(V) is Object and V has an [[ErrorData]] internal slot), then:
221         //     1. If types includes Error, then return the result of converting V to Error.
222         //     2. If types includes object, then return the IDL value that is a reference to the object V.
223 
224 
225         // 7. If Type(V) is Object and V has an [[ArrayBufferData]] internal slot, then:
226         //     1. If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
227         //     2. If types includes object, then return the IDL value that is a reference to the object V.
228         constexpr bool hasArrayBufferType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBuffer, brigand::_1&gt;&gt;::value;
229         if (hasArrayBufferType || hasObjectType) {
230             auto arrayBuffer = JSC::JSArrayBuffer::toWrapped(vm, value);
231             if (arrayBuffer) {
232                 if (hasArrayBufferType)
233                     return ConditionalReturner&lt;ReturnType, hasArrayBufferType&gt;::get(WTFMove(arrayBuffer)).value();
<span class="line-modified">234                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
235             }
236         }
237 
238         constexpr bool hasArrayBufferViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBufferView, brigand::_1&gt;&gt;::value;
239         if (hasArrayBufferViewType || hasObjectType) {
240             auto arrayBufferView = JSC::JSArrayBufferView::toWrapped(vm, value);
241             if (arrayBufferView) {
242                 if (hasArrayBufferViewType)
243                     return ConditionalReturner&lt;ReturnType, hasArrayBufferViewType&gt;::get(WTFMove(arrayBufferView)).value();
<span class="line-modified">244                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
245             }
246         }
247 
248         // 8. If Type(V) is Object and V has a [[DataView]] internal slot, then:
249         //     1. If types includes DataView, then return the result of converting V to DataView.
250         //     2. If types includes object, then return the IDL value that is a reference to the object V.
251         constexpr bool hasDataViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLDataView, brigand::_1&gt;&gt;::value;
252         if (hasDataViewType || hasObjectType) {
253             auto dataView = JSC::JSDataView::toWrapped(vm, value);
254             if (dataView) {
255                 if (hasDataViewType)
256                     return ConditionalReturner&lt;ReturnType, hasDataViewType&gt;::get(WTFMove(dataView)).value();
<span class="line-modified">257                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
258             }
259         }
260 
261         // 9. If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
262         //     1. If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
263         //     2. If types includes object, then return the IDL value that is a reference to the object V.
264         //         (FIXME: Add support for object and step 9.2)
265         constexpr bool hasTypedArrayType = brigand::any&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;::value;
266         if (hasTypedArrayType) {
267             Optional&lt;ReturnType&gt; returnValue;
268             brigand::for_each&lt;TypedArrayTypeList&gt;([&amp;](auto&amp;&amp; type) {
269                 if (returnValue)
270                     return;
271 
272                 using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
273                 using ImplementationType = typename Type::ImplementationType;
274                 using WrapperType = typename Converter&lt;Type&gt;::WrapperType;
275 
276                 auto castedValue = WrapperType::toWrapped(vm, value);
277                 if (!castedValue)
</pre>
<hr />
<pre>
287         // FIXME: Add support for step 10.
288         //
289         // 10. If IsCallable(V) is true, then:
290         //     1. If types includes a callback function type, then return the result of converting V to that callback function type.
291         //     2. If types includes object, then return the IDL value that is a reference to the object V.
292 
293         // 11. If V is any kind of object, then:
294         if (hasAnyObjectType) {
295             if (value.isCell()) {
296                 JSC::JSCell* cell = value.asCell();
297                 if (cell-&gt;isObject()) {
298                     auto object = asObject(value);
299 
300                     //     1. If types includes a sequence type, then:
301                     //         1. Let method be the result of GetMethod(V, @@iterator).
302                     //         2. ReturnIfAbrupt(method).
303                     //         3. If method is not undefined, return the result of creating a
304                     //            sequence of that type from V and method.
305                     constexpr bool hasSequenceType = numberOfSequenceTypes != 0;
306                     if (hasSequenceType) {
<span class="line-modified">307                         auto method = JSC::iteratorMethod(state, object);</span>
308                         RETURN_IF_EXCEPTION(scope, ReturnType());
309                         if (!method.isUndefined())
<span class="line-modified">310                             return ConditionalSequenceConverter&lt;ReturnType, SequenceType, hasSequenceType&gt;::convert(state, object, method).value();</span>
311                     }
312 
313                     //     2. If types includes a frozen array type, then:
314                     //         1. Let method be the result of GetMethod(V, @@iterator).
315                     //         2. ReturnIfAbrupt(method).
316                     //         3. If method is not undefined, return the result of creating a
317                     //            frozen array of that type from V and method.
318                     constexpr bool hasFrozenArrayType = numberOfFrozenArrayTypes != 0;
319                     if (hasFrozenArrayType) {
<span class="line-modified">320                         auto method = JSC::iteratorMethod(state, object);</span>
321                         RETURN_IF_EXCEPTION(scope, ReturnType());
322                         if (!method.isUndefined())
<span class="line-modified">323                             return ConditionalSequenceConverter&lt;ReturnType, FrozenArrayType, hasFrozenArrayType&gt;::convert(state, object, method).value();</span>
324                     }
325 
326                     //     3. If types includes a dictionary type, then return the result of
327                     //        converting V to that dictionary type.
328                     if (hasDictionaryType)
<span class="line-modified">329                         return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(state, value).value();</span>
330 
331                     //     4. If types includes a record type, then return the result of converting V to that record type.
332                     if (hasRecordType)
<span class="line-modified">333                         return ConditionalConverter&lt;ReturnType, RecordType, hasRecordType&gt;::convert(state, value).value();</span>
334 
335                     //     5. If types includes a callback interface type, then return the result of converting V to that interface type.
336                     //         (FIXME: Add support for callback interface type and step 12.5)
337 
338                     //     6. If types includes object, then return the IDL value that is a reference to the object V.
339                     if (hasObjectType)
<span class="line-modified">340                         return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(state, value).value();</span>
341                 }
342             }
343         }
344 
345         // 12. If V is a Boolean value, then:
346         //     1. If types includes a boolean, then return the result of converting V to boolean.
347         constexpr bool hasBooleanType = brigand::any&lt;TypeList, std::is_same&lt;IDLBoolean, brigand::_1&gt;&gt;::value;
348         if (hasBooleanType) {
349             if (value.isBoolean())
<span class="line-modified">350                 return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(state, value).value();</span>
351         }
352 
353         // 13. If V is a Number value, then:
354         //     1. If types includes a numeric type, then return the result of converting V to that numeric type.
355         constexpr bool hasNumericType = brigand::size&lt;NumericTypeList&gt;::value != 0;
356         if (hasNumericType) {
357             if (value.isNumber())
<span class="line-modified">358                 return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(state, value).value();</span>
359         }
360 
361         // 14. If types includes a string type, then return the result of converting V to that type.
362         constexpr bool hasStringType = brigand::size&lt;StringTypeList&gt;::value != 0;
363         if (hasStringType)
<span class="line-modified">364             return ConditionalConverter&lt;ReturnType, StringType, hasStringType&gt;::convert(state, value).value();</span>
365 
366         // 15. If types includes a numeric type, then return the result of converting V to that numeric type.
367         if (hasNumericType)
<span class="line-modified">368             return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(state, value).value();</span>
369 
370         // 16. If types includes a boolean, then return the result of converting V to boolean.
371         if (hasBooleanType)
<span class="line-modified">372             return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(state, value).value();</span>
373 
374         // 17. Throw a TypeError.
<span class="line-modified">375         throwTypeError(&amp;state, scope);</span>
376         return ReturnType();
377     }
378 };
379 
380 template&lt;typename... T&gt; struct JSConverter&lt;IDLUnion&lt;T...&gt;&gt; {
381     using Type = IDLUnion&lt;T...&gt;;
382     using TypeList = typename Type::TypeList;
383     using ImplementationType = typename Type::ImplementationType;
384 
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     using Sequence = brigand::make_sequence&lt;brigand::ptrdiff_t&lt;0&gt;, WTF::variant_size&lt;ImplementationType&gt;::value&gt;;
389 
<span class="line-modified">390     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ImplementationType&amp; variant)</span>
391     {
392         auto index = variant.index();
393 
394         Optional&lt;JSC::JSValue&gt; returnValue;
395         brigand::for_each&lt;Sequence&gt;([&amp;](auto&amp;&amp; type) {
396             using I = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
397             if (I::value == index) {
398                 ASSERT(!returnValue);
<span class="line-modified">399                 returnValue = toJS&lt;brigand::at&lt;TypeList, I&gt;&gt;(state, globalObject, WTF::get&lt;I::value&gt;(variant));</span>
400             }
401         });
402 
403         ASSERT(returnValue);
404         return returnValue.value();
405     }
406 };
407 
408 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 45     static Optional&lt;ReturnType&gt; get(T&amp;&amp; value)
 46     {
 47         return ReturnType(std::forward&lt;T&gt;(value));
 48     }
 49 };
 50 
 51 template&lt;typename ReturnType&gt;
 52 struct ConditionalReturner&lt;ReturnType, false&gt; {
 53     template&lt;typename T&gt;
 54     static Optional&lt;ReturnType&gt; get(T&amp;&amp;)
 55     {
 56         return WTF::nullopt;
 57     }
 58 };
 59 
 60 template&lt;typename ReturnType, typename T, bool enabled&gt;
 61 struct ConditionalConverter;
 62 
 63 template&lt;typename ReturnType, typename T&gt;
 64 struct ConditionalConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified"> 65     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
 66     {
<span class="line-modified"> 67         return ReturnType(Converter&lt;T&gt;::convert(lexicalGlobalObject, value));</span>
 68     }
 69 };
 70 
 71 template&lt;typename ReturnType, typename T&gt;
 72 struct ConditionalConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified"> 73     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp;, JSC::JSValue)</span>
 74     {
 75         return WTF::nullopt;
 76     }
 77 };
 78 
 79 template&lt;typename ReturnType, typename T, bool enabled&gt;
 80 struct ConditionalSequenceConverter;
 81 
 82 template&lt;typename ReturnType, typename T&gt;
 83 struct ConditionalSequenceConverter&lt;ReturnType, T, true&gt; {
<span class="line-modified"> 84     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject* object, JSC::JSValue method)</span>
 85     {
<span class="line-modified"> 86         return ReturnType(Converter&lt;T&gt;::convert(lexicalGlobalObject, object, method));</span>
 87     }
 88 };
 89 
 90 template&lt;typename ReturnType, typename T&gt;
 91 struct ConditionalSequenceConverter&lt;ReturnType, T, false&gt; {
<span class="line-modified"> 92     static Optional&lt;ReturnType&gt; convert(JSC::JSGlobalObject&amp;, JSC::JSObject*, JSC::JSValue)</span>
 93     {
 94         return WTF::nullopt;
 95     }
 96 };
 97 
 98 namespace Detail {
 99 
100 template&lt;typename List, bool condition&gt;
101 struct ConditionalFront;
102 
103 template&lt;typename List&gt;
104 struct ConditionalFront&lt;List, true&gt; {
105     using type = brigand::front&lt;List&gt;;
106 };
107 
108 template&lt;typename List&gt;
109 struct ConditionalFront&lt;List, false&gt; {
110     using type = void;
111 };
112 
</pre>
<hr />
<pre>
146     static constexpr bool hasDictionaryType = numberOfDictionaryTypes != 0;
147     using DictionaryType = ConditionalFront&lt;DictionaryTypeList, hasDictionaryType&gt;;
148 
149     using RecordTypeList = brigand::filter&lt;TypeList, IsIDLRecord&lt;brigand::_1&gt;&gt;;
150     static constexpr size_t numberOfRecordTypes = brigand::size&lt;RecordTypeList&gt;::value;
151     static_assert(numberOfRecordTypes == 0 || numberOfRecordTypes == 1, &quot;There can be 0 or 1 record types in an IDLUnion.&quot;);
152     static constexpr bool hasRecordType = numberOfRecordTypes != 0;
153     using RecordType = ConditionalFront&lt;RecordTypeList, hasRecordType&gt;;
154 
155     using ObjectTypeList = brigand::filter&lt;TypeList, std::is_same&lt;IDLObject, brigand::_1&gt;&gt;;
156     static constexpr size_t numberOfObjectTypes = brigand::size&lt;ObjectTypeList&gt;::value;
157     static_assert(numberOfObjectTypes == 0 || numberOfObjectTypes == 1, &quot;There can be 0 or 1 object types in an IDLUnion.&quot;);
158     static constexpr bool hasObjectType = numberOfObjectTypes != 0;
159     using ObjectType = ConditionalFront&lt;ObjectTypeList, hasObjectType&gt;;
160 
161     static constexpr bool hasAnyObjectType = (numberOfSequenceTypes + numberOfFrozenArrayTypes + numberOfDictionaryTypes + numberOfRecordTypes + numberOfObjectTypes) &gt; 0;
162 
163     using InterfaceTypeList = brigand::filter&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;;
164     using TypedArrayTypeList = brigand::filter&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;;
165 
<span class="line-modified">166     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
167     {
<span class="line-modified">168         JSC::VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
169         auto scope = DECLARE_THROW_SCOPE(vm);
170 
171         // 1. If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
172         constexpr bool hasNullType = brigand::any&lt;TypeList, std::is_same&lt;IDLNull, brigand::_1&gt;&gt;::value;
173         if (hasNullType) {
174             if (value.isUndefinedOrNull())
<span class="line-modified">175                 return ConditionalConverter&lt;ReturnType, IDLNull, hasNullType&gt;::convert(lexicalGlobalObject, value).value();</span>
176         }
177 
178         // 2. Let types be the flattened member types of the union type.
179         // NOTE: Union is expected to be pre-flattented.
180 
181         // 3. If V is null or undefined then:
182         if (hasDictionaryType) {
183             if (value.isUndefinedOrNull()) {
184                 //     1. If types includes a dictionary type, then return the result of converting V to that dictionary type.
<span class="line-modified">185                 return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(lexicalGlobalObject, value).value();</span>
186             }
187         }
188 
189         // 4. If V is a platform object, then:
190         //     1. If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
191         //     2. If types includes object, then return the IDL value that is a reference to the object V.
192         //         (FIXME: Add support for object and step 4.2)
193         if (brigand::any&lt;TypeList, IsIDLInterface&lt;brigand::_1&gt;&gt;::value) {
194             Optional&lt;ReturnType&gt; returnValue;
195             brigand::for_each&lt;InterfaceTypeList&gt;([&amp;](auto&amp;&amp; type) {
196                 if (returnValue)
197                     return;
198 
199                 using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
200                 using ImplementationType = typename Type::ImplementationType;
201                 using RawType = typename Type::RawType;
202 
<span class="line-modified">203                 auto castedValue = JSToWrappedOverloader&lt;RawType&gt;::toWrapped(lexicalGlobalObject, value);</span>
204                 if (!castedValue)
205                     return;
206 
207                 returnValue = ReturnType(ImplementationType(castedValue));
208             });
209 
210             if (returnValue)
211                 return WTFMove(returnValue.value());
212         }
213 
214         // FIXME: Add support for steps 5 &amp; 6.
215         //
216         // 5. If V is a DOMException platform object, then:
217         //     1. If types includes DOMException or Error, then return the result of converting V to that type.
218         //     2 If types includes object, then return the IDL value that is a reference to the object V.
219         //
220         // 6. If Type(V) is Object and V has an [[ErrorData]] internal slot), then:
221         //     1. If types includes Error, then return the result of converting V to Error.
222         //     2. If types includes object, then return the IDL value that is a reference to the object V.
223 
224 
225         // 7. If Type(V) is Object and V has an [[ArrayBufferData]] internal slot, then:
226         //     1. If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
227         //     2. If types includes object, then return the IDL value that is a reference to the object V.
228         constexpr bool hasArrayBufferType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBuffer, brigand::_1&gt;&gt;::value;
229         if (hasArrayBufferType || hasObjectType) {
230             auto arrayBuffer = JSC::JSArrayBuffer::toWrapped(vm, value);
231             if (arrayBuffer) {
232                 if (hasArrayBufferType)
233                     return ConditionalReturner&lt;ReturnType, hasArrayBufferType&gt;::get(WTFMove(arrayBuffer)).value();
<span class="line-modified">234                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
235             }
236         }
237 
238         constexpr bool hasArrayBufferViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLArrayBufferView, brigand::_1&gt;&gt;::value;
239         if (hasArrayBufferViewType || hasObjectType) {
240             auto arrayBufferView = JSC::JSArrayBufferView::toWrapped(vm, value);
241             if (arrayBufferView) {
242                 if (hasArrayBufferViewType)
243                     return ConditionalReturner&lt;ReturnType, hasArrayBufferViewType&gt;::get(WTFMove(arrayBufferView)).value();
<span class="line-modified">244                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
245             }
246         }
247 
248         // 8. If Type(V) is Object and V has a [[DataView]] internal slot, then:
249         //     1. If types includes DataView, then return the result of converting V to DataView.
250         //     2. If types includes object, then return the IDL value that is a reference to the object V.
251         constexpr bool hasDataViewType = brigand::any&lt;TypeList, std::is_same&lt;IDLDataView, brigand::_1&gt;&gt;::value;
252         if (hasDataViewType || hasObjectType) {
253             auto dataView = JSC::JSDataView::toWrapped(vm, value);
254             if (dataView) {
255                 if (hasDataViewType)
256                     return ConditionalReturner&lt;ReturnType, hasDataViewType&gt;::get(WTFMove(dataView)).value();
<span class="line-modified">257                 return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
258             }
259         }
260 
261         // 9. If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
262         //     1. If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
263         //     2. If types includes object, then return the IDL value that is a reference to the object V.
264         //         (FIXME: Add support for object and step 9.2)
265         constexpr bool hasTypedArrayType = brigand::any&lt;TypeList, IsIDLTypedArray&lt;brigand::_1&gt;&gt;::value;
266         if (hasTypedArrayType) {
267             Optional&lt;ReturnType&gt; returnValue;
268             brigand::for_each&lt;TypedArrayTypeList&gt;([&amp;](auto&amp;&amp; type) {
269                 if (returnValue)
270                     return;
271 
272                 using Type = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
273                 using ImplementationType = typename Type::ImplementationType;
274                 using WrapperType = typename Converter&lt;Type&gt;::WrapperType;
275 
276                 auto castedValue = WrapperType::toWrapped(vm, value);
277                 if (!castedValue)
</pre>
<hr />
<pre>
287         // FIXME: Add support for step 10.
288         //
289         // 10. If IsCallable(V) is true, then:
290         //     1. If types includes a callback function type, then return the result of converting V to that callback function type.
291         //     2. If types includes object, then return the IDL value that is a reference to the object V.
292 
293         // 11. If V is any kind of object, then:
294         if (hasAnyObjectType) {
295             if (value.isCell()) {
296                 JSC::JSCell* cell = value.asCell();
297                 if (cell-&gt;isObject()) {
298                     auto object = asObject(value);
299 
300                     //     1. If types includes a sequence type, then:
301                     //         1. Let method be the result of GetMethod(V, @@iterator).
302                     //         2. ReturnIfAbrupt(method).
303                     //         3. If method is not undefined, return the result of creating a
304                     //            sequence of that type from V and method.
305                     constexpr bool hasSequenceType = numberOfSequenceTypes != 0;
306                     if (hasSequenceType) {
<span class="line-modified">307                         auto method = JSC::iteratorMethod(&amp;lexicalGlobalObject, object);</span>
308                         RETURN_IF_EXCEPTION(scope, ReturnType());
309                         if (!method.isUndefined())
<span class="line-modified">310                             return ConditionalSequenceConverter&lt;ReturnType, SequenceType, hasSequenceType&gt;::convert(lexicalGlobalObject, object, method).value();</span>
311                     }
312 
313                     //     2. If types includes a frozen array type, then:
314                     //         1. Let method be the result of GetMethod(V, @@iterator).
315                     //         2. ReturnIfAbrupt(method).
316                     //         3. If method is not undefined, return the result of creating a
317                     //            frozen array of that type from V and method.
318                     constexpr bool hasFrozenArrayType = numberOfFrozenArrayTypes != 0;
319                     if (hasFrozenArrayType) {
<span class="line-modified">320                         auto method = JSC::iteratorMethod(&amp;lexicalGlobalObject, object);</span>
321                         RETURN_IF_EXCEPTION(scope, ReturnType());
322                         if (!method.isUndefined())
<span class="line-modified">323                             return ConditionalSequenceConverter&lt;ReturnType, FrozenArrayType, hasFrozenArrayType&gt;::convert(lexicalGlobalObject, object, method).value();</span>
324                     }
325 
326                     //     3. If types includes a dictionary type, then return the result of
327                     //        converting V to that dictionary type.
328                     if (hasDictionaryType)
<span class="line-modified">329                         return ConditionalConverter&lt;ReturnType, DictionaryType, hasDictionaryType&gt;::convert(lexicalGlobalObject, value).value();</span>
330 
331                     //     4. If types includes a record type, then return the result of converting V to that record type.
332                     if (hasRecordType)
<span class="line-modified">333                         return ConditionalConverter&lt;ReturnType, RecordType, hasRecordType&gt;::convert(lexicalGlobalObject, value).value();</span>
334 
335                     //     5. If types includes a callback interface type, then return the result of converting V to that interface type.
336                     //         (FIXME: Add support for callback interface type and step 12.5)
337 
338                     //     6. If types includes object, then return the IDL value that is a reference to the object V.
339                     if (hasObjectType)
<span class="line-modified">340                         return ConditionalConverter&lt;ReturnType, ObjectType, hasObjectType&gt;::convert(lexicalGlobalObject, value).value();</span>
341                 }
342             }
343         }
344 
345         // 12. If V is a Boolean value, then:
346         //     1. If types includes a boolean, then return the result of converting V to boolean.
347         constexpr bool hasBooleanType = brigand::any&lt;TypeList, std::is_same&lt;IDLBoolean, brigand::_1&gt;&gt;::value;
348         if (hasBooleanType) {
349             if (value.isBoolean())
<span class="line-modified">350                 return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(lexicalGlobalObject, value).value();</span>
351         }
352 
353         // 13. If V is a Number value, then:
354         //     1. If types includes a numeric type, then return the result of converting V to that numeric type.
355         constexpr bool hasNumericType = brigand::size&lt;NumericTypeList&gt;::value != 0;
356         if (hasNumericType) {
357             if (value.isNumber())
<span class="line-modified">358                 return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(lexicalGlobalObject, value).value();</span>
359         }
360 
361         // 14. If types includes a string type, then return the result of converting V to that type.
362         constexpr bool hasStringType = brigand::size&lt;StringTypeList&gt;::value != 0;
363         if (hasStringType)
<span class="line-modified">364             return ConditionalConverter&lt;ReturnType, StringType, hasStringType&gt;::convert(lexicalGlobalObject, value).value();</span>
365 
366         // 15. If types includes a numeric type, then return the result of converting V to that numeric type.
367         if (hasNumericType)
<span class="line-modified">368             return ConditionalConverter&lt;ReturnType, NumericType, hasNumericType&gt;::convert(lexicalGlobalObject, value).value();</span>
369 
370         // 16. If types includes a boolean, then return the result of converting V to boolean.
371         if (hasBooleanType)
<span class="line-modified">372             return ConditionalConverter&lt;ReturnType, IDLBoolean, hasBooleanType&gt;::convert(lexicalGlobalObject, value).value();</span>
373 
374         // 17. Throw a TypeError.
<span class="line-modified">375         throwTypeError(&amp;lexicalGlobalObject, scope);</span>
376         return ReturnType();
377     }
378 };
379 
380 template&lt;typename... T&gt; struct JSConverter&lt;IDLUnion&lt;T...&gt;&gt; {
381     using Type = IDLUnion&lt;T...&gt;;
382     using TypeList = typename Type::TypeList;
383     using ImplementationType = typename Type::ImplementationType;
384 
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     using Sequence = brigand::make_sequence&lt;brigand::ptrdiff_t&lt;0&gt;, WTF::variant_size&lt;ImplementationType&gt;::value&gt;;
389 
<span class="line-modified">390     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const ImplementationType&amp; variant)</span>
391     {
392         auto index = variant.index();
393 
394         Optional&lt;JSC::JSValue&gt; returnValue;
395         brigand::for_each&lt;Sequence&gt;([&amp;](auto&amp;&amp; type) {
396             using I = typename WTF::RemoveCVAndReference&lt;decltype(type)&gt;::type::type;
397             if (I::value == index) {
398                 ASSERT(!returnValue);
<span class="line-modified">399                 returnValue = toJS&lt;brigand::at&lt;TypeList, I&gt;&gt;(lexicalGlobalObject, globalObject, WTF::get&lt;I::value&gt;(variant));</span>
400             }
401         });
402 
403         ASSERT(returnValue);
404         return returnValue.value();
405     }
406 };
407 
408 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMConvertStrings.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertVariadic.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
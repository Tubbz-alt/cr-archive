<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InjectedScriptModule.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorEnvironment.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 213         if (typeof object !== &quot;function&quot;)
 214             return &quot;Cannot resolve function by id.&quot;;
 215         return this.functionDetails(object);
 216     }
 217 
 218     functionDetails(func)
 219     {
 220         let details = InjectedScriptHost.functionDetails(func);
 221         if (!details)
 222             return &quot;Cannot resolve function details.&quot;;
 223         return details;
 224     }
 225 
 226     getPreview(objectId)
 227     {
 228         let parsedObjectId = this._parseObjectId(objectId);
 229         let object = this._objectForId(parsedObjectId);
 230         return RemoteObject.createObjectPreviewForValue(object, true);
 231     }
 232 
<span class="line-modified"> 233     getProperties(objectId, ownProperties, generatePreview)</span>
 234     {
<span class="line-removed"> 235         let nativeGettersAsValues = false;</span>
 236         let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
<span class="line-modified"> 237         return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);</span>
 238     }
 239 
<span class="line-modified"> 240     getDisplayableProperties(objectId, generatePreview)</span>
 241     {
<span class="line-removed"> 242         let nativeGettersAsValues = true;</span>
 243         let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
<span class="line-modified"> 244         return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);</span>
 245     }
 246 
 247     getInternalProperties(objectId, generatePreview)
 248     {
 249         let parsedObjectId = this._parseObjectId(objectId);
 250         let object = this._objectForId(parsedObjectId);
 251         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 252 
 253         if (!isDefined(object))
 254             return false;
 255 
 256         if (isSymbol(object))
 257             return false;
 258 
 259         let descriptors = this._internalPropertyDescriptors(object);
 260         if (!descriptors)
 261             return [];
 262 
 263         for (let i = 0; i &lt; descriptors.length; ++i) {
 264             let descriptor = descriptors[i];
 265             if (&quot;value&quot; in descriptor)
 266                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
 267         }
 268 
 269         return descriptors;
 270     }
 271 
<span class="line-modified"> 272     getCollectionEntries(objectId, objectGroupName, startIndex, numberToFetch)</span>
 273     {
 274         let parsedObjectId = this._parseObjectId(objectId);
 275         let object = this._objectForId(parsedObjectId);
 276         objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
 277 
 278         if (!isDefined(object))
 279             return;
 280 
 281         if (typeof object !== &quot;object&quot;)
 282             return;
 283 
<span class="line-modified"> 284         let entries = this._entries(object, InjectedScriptHost.subtype(object), startIndex, numberToFetch);</span>
 285         return entries.map(function(entry) {
 286             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
 287             if (&quot;key&quot; in entry)
 288                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
 289             return entry;
 290         });
 291     }
 292 
 293     saveResult(callArgumentJSON)
 294     {
 295         this._savedResultIndex = 0;
 296 
 297         try {
 298             let callArgument = InjectedScriptHost.evaluate(&quot;(&quot; + callArgumentJSON + &quot;)&quot;);
 299             let value = this._resolveCallArgument(callArgument);
 300             this._saveResult(value);
 301         } catch { }
 302 
 303         return this._savedResultIndex;
 304     }
</pre>
<hr />
<pre>
 564     }
 565 
 566     _evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI)
 567     {
 568         let commandLineAPI = null;
 569         if (includeCommandLineAPI)
 570             commandLineAPI = new CommandLineAPI(isEvalOnCallFrame ? object : null);
 571         return evalFunction.call(object, expression, commandLineAPI);
 572     }
 573 
 574     _callFrameForId(topCallFrame, callFrameId)
 575     {
 576         let parsedCallFrameId = InjectedScriptHost.evaluate(&quot;(&quot; + callFrameId + &quot;)&quot;);
 577         let ordinal = parsedCallFrameId[&quot;ordinal&quot;];
 578         let callFrame = topCallFrame;
 579         while (--ordinal &gt;= 0 &amp;&amp; callFrame)
 580             callFrame = callFrame.caller;
 581         return callFrame;
 582     }
 583 
<span class="line-modified"> 584     _getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues)</span>
 585     {
 586         let parsedObjectId = this._parseObjectId(objectId);
 587         let object = this._objectForId(parsedObjectId);
 588         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 589 
 590         if (!isDefined(object))
 591             return false;
 592 
 593         if (isSymbol(object))
 594             return false;
 595 
<span class="line-modified"> 596         let descriptors = this._propertyDescriptors(object, collectionMode, nativeGettersAsValues);</span>
















 597 
<span class="line-removed"> 598         for (let i = 0; i &lt; descriptors.length; ++i) {</span>
<span class="line-removed"> 599             let descriptor = descriptors[i];</span>
 600             if (&quot;get&quot; in descriptor)
 601                 descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
 602             if (&quot;set&quot; in descriptor)
 603                 descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
 604             if (&quot;value&quot; in descriptor)
 605                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
<span class="line-removed"> 606             if (!(&quot;configurable&quot; in descriptor))</span>
<span class="line-removed"> 607                 descriptor.configurable = false;</span>
<span class="line-removed"> 608             if (!(&quot;enumerable&quot; in descriptor))</span>
<span class="line-removed"> 609                 descriptor.enumerable = false;</span>
 610             if (&quot;symbol&quot; in descriptor)
 611                 descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
<span class="line-modified"> 612         }</span>



 613 


 614         return descriptors;
 615     }
 616 
 617     _internalPropertyDescriptors(object, completeDescriptor)
 618     {
 619         let internalProperties = InjectedScriptHost.getInternalProperties(object);
 620         if (!internalProperties)
 621             return null;
 622 
 623         let descriptors = [];
 624         for (let i = 0; i &lt; internalProperties.length; i++) {
 625             let property = internalProperties[i];
 626             let descriptor = {name: property.name, value: property.value};
<span class="line-modified"> 627             if (completeDescriptor) {</span>
<span class="line-removed"> 628                 descriptor.writable = false;</span>
<span class="line-removed"> 629                 descriptor.configurable = false;</span>
<span class="line-removed"> 630                 descriptor.enumerable = false;</span>
 631                 descriptor.isOwn = true;
<span class="line-removed"> 632             }</span>
 633             descriptors.push(descriptor);
 634         }
 635         return descriptors;
 636     }
 637 
<span class="line-modified"> 638     _propertyDescriptors(object, collectionMode, nativeGettersAsValues)</span>
 639     {
 640         if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
<span class="line-modified"> 641             return [];</span>
 642 
<span class="line-removed"> 643         let descriptors = [];</span>
 644         let nameProcessed = new Set;
 645 



 646         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
 647         {
 648             try {
<span class="line-modified"> 649                 let fakeDescriptor = {name, value: object[name], writable: descriptor.writable || false, configurable: descriptor.configurable || false, enumerable: descriptor.enumerable || false};</span>








 650                 if (possibleNativeBindingGetter)
 651                     fakeDescriptor.nativeGetter = true;
 652                 if (isOwnProperty)
 653                     fakeDescriptor.isOwn = true;
 654                 if (symbol)
 655                     fakeDescriptor.symbol = symbol;
 656                 // Silence any possible unhandledrejection exceptions created from accessing a native accessor with a wrong this object.
 657                 if (fakeDescriptor.value instanceof Promise &amp;&amp; InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError(fakeDescriptor.value))
 658                     fakeDescriptor.value.catch(function(){});
 659                 return fakeDescriptor;
 660             } catch (e) {
 661                 let errorDescriptor = {name, value: e, wasThrown: true};
 662                 if (isOwnProperty)
 663                     errorDescriptor.isOwn = true;
 664                 if (symbol)
 665                     errorDescriptor.symbol = symbol;
 666                 return errorDescriptor;
 667             }
 668         }
 669 
 670         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
 671         {
 672             // All properties.
<span class="line-modified"> 673             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties) {</span>
<span class="line-modified"> 674                 descriptors.push(descriptor);</span>
<span class="line-removed"> 675                 return;</span>
<span class="line-removed"> 676             }</span>
 677 
 678             // Own properties.
<span class="line-modified"> 679             if (collectionMode &amp; InjectedScript.CollectionMode.OwnProperties &amp;&amp; isOwnProperty) {</span>
<span class="line-modified"> 680                 descriptors.push(descriptor);</span>
<span class="line-removed"> 681                 return;</span>
<span class="line-removed"> 682             }</span>
 683 
 684             // Native Getter properties.
 685             if (collectionMode &amp; InjectedScript.CollectionMode.NativeGetterProperties) {
<span class="line-modified"> 686                 if (possibleNativeBindingGetter) {</span>
<span class="line-modified"> 687                     descriptors.push(descriptor);</span>
<span class="line-removed"> 688                     return;</span>
<span class="line-removed"> 689                 }</span>
 690             }
 691         }
 692 
<span class="line-modified"> 693         function processProperties(o, properties, isOwnProperty)</span>
 694         {
<span class="line-modified"> 695             for (let i = 0; i &lt; properties.length; ++i) {</span>
<span class="line-modified"> 696                 let property = properties[i];</span>
<span class="line-removed"> 697                 if (nameProcessed.has(property) || property === &quot;__proto__&quot;)</span>
<span class="line-removed"> 698                     continue;</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700                 nameProcessed.add(property);</span>
<span class="line-removed"> 701 </span>
<span class="line-removed"> 702                 let name = toString(property);</span>
<span class="line-removed"> 703                 let symbol = isSymbol(property) ? property : null;</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705                 let descriptor = Object.getOwnPropertyDescriptor(o, property);</span>
<span class="line-removed"> 706                 if (!descriptor) {</span>
<span class="line-removed"> 707                     // FIXME: Bad descriptor. Can we get here?</span>
<span class="line-removed"> 708                     // Fall back to very restrictive settings.</span>
<span class="line-removed"> 709                     let fakeDescriptor = createFakeValueDescriptor(name, symbol, {writable: false, configurable: false, enumerable: false}, isOwnProperty);</span>
<span class="line-removed"> 710                     processDescriptor(fakeDescriptor, isOwnProperty);</span>
<span class="line-removed"> 711                     continue;</span>
<span class="line-removed"> 712                 }</span>
 713 
<span class="line-modified"> 714                 if (nativeGettersAsValues) {</span>
<span class="line-removed"> 715                     if (String(descriptor.get).endsWith(&quot;[native code]\n}&quot;) || (!descriptor.get &amp;&amp; descriptor.hasOwnProperty(&quot;get&quot;) &amp;&amp; !descriptor.set &amp;&amp; descriptor.hasOwnProperty(&quot;set&quot;))) {</span>
<span class="line-removed"> 716                         // Developers may create such a descriptor, so we should be resilient:</span>
<span class="line-removed"> 717                         // let x = {}; Object.defineProperty(x, &quot;p&quot;, {get:undefined}); Object.getOwnPropertyDescriptor(x, &quot;p&quot;)</span>
<span class="line-removed"> 718                         let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);</span>
<span class="line-removed"> 719                         processDescriptor(fakeDescriptor, isOwnProperty, true);</span>
<span class="line-removed"> 720                         continue;</span>
<span class="line-removed"> 721                     }</span>
<span class="line-removed"> 722                 }</span>
 723 
<span class="line-modified"> 724                 descriptor.name = name;</span>
<span class="line-modified"> 725                 if (isOwnProperty)</span>
<span class="line-modified"> 726                     descriptor.isOwn = true;</span>
<span class="line-modified"> 727                 if (symbol)</span>
<span class="line-modified"> 728                     descriptor.symbol = symbol;</span>
<span class="line-modified"> 729                 processDescriptor(descriptor, isOwnProperty);</span>



 730             }
<span class="line-removed"> 731         }</span>
 732 
<span class="line-modified"> 733         function arrayIndexPropertyNames(o, length)</span>
<span class="line-modified"> 734         {</span>
<span class="line-modified"> 735             let array = [];</span>
<span class="line-modified"> 736             for (let i = 0; i &lt; length; ++i) {</span>
<span class="line-modified"> 737                 if (i in o)</span>
<span class="line-modified"> 738                     array.push(&quot;&quot; + i);</span>

 739             }
<span class="line-modified"> 740             return array;</span>






 741         }
 742 
<span class="line-removed"> 743         // FIXME: &lt;https://webkit.org/b/143589&gt; Web Inspector: Better handling for large collections in Object Trees</span>
<span class="line-removed"> 744         // For array types with a large length we attempt to skip getOwnPropertyNames and instead just sublist of indexes.</span>
 745         let isArrayLike = false;
 746         try {
 747             isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
 748         } catch { }
 749 
 750         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
 751             let isOwnProperty = o === object;






















 752 
<span class="line-modified"> 753             if (isArrayLike &amp;&amp; isOwnProperty)</span>
<span class="line-modified"> 754                 processProperties(o, arrayIndexPropertyNames(o, Math.min(object.length, 100)), isOwnProperty);</span>
<span class="line-modified"> 755             else {</span>
<span class="line-modified"> 756                 processProperties(o, Object.getOwnPropertyNames(o), isOwnProperty);</span>
<span class="line-modified"> 757                 if (Object.getOwnPropertySymbols)</span>
<span class="line-modified"> 758                     processProperties(o, Object.getOwnPropertySymbols(o), isOwnProperty);</span>





 759             }
 760 



 761             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
 762                 break;
 763         }
 764 
<span class="line-modified"> 765         // Always include __proto__ at the end.</span>
<span class="line-modified"> 766         try {</span>
<span class="line-modified"> 767             if (object.__proto__)</span>
<span class="line-modified"> 768                 descriptors.push({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true});</span>
<span class="line-modified"> 769         } catch { }</span>
<span class="line-modified"> 770 </span>
<span class="line-removed"> 771         return descriptors;</span>
 772     }
 773 
<span class="line-modified"> 774     _getSetEntries(object, skip, numberToFetch)</span>
 775     {
 776         let entries = [];
 777 
 778         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
 779         for (let value of object) {
<span class="line-modified"> 780             if (skip &gt; 0) {</span>
<span class="line-modified"> 781                 skip--;</span>
 782                 continue;
 783             }
 784 
 785             entries.push({value});
 786 
<span class="line-modified"> 787             if (numberToFetch &amp;&amp; entries.length === numberToFetch)</span>
 788                 break;
 789         }
 790 
 791         return entries;
 792     }
 793 
<span class="line-modified"> 794     _getMapEntries(object, skip, numberToFetch)</span>
 795     {
 796         let entries = [];
 797 
 798         // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
 799         for (let [key, value] of object) {
<span class="line-modified"> 800             if (skip &gt; 0) {</span>
<span class="line-modified"> 801                 skip--;</span>
 802                 continue;
 803             }
 804 
 805             entries.push({key, value});
 806 
<span class="line-modified"> 807             if (numberToFetch &amp;&amp; entries.length === numberToFetch)</span>
 808                 break;
 809         }
 810 
 811         return entries;
 812     }
 813 
<span class="line-modified"> 814     _getWeakMapEntries(object, numberToFetch)</span>
 815     {
<span class="line-modified"> 816         return InjectedScriptHost.weakMapEntries(object, numberToFetch);</span>
 817     }
 818 
<span class="line-modified"> 819     _getWeakSetEntries(object, numberToFetch)</span>
 820     {
<span class="line-modified"> 821         return InjectedScriptHost.weakSetEntries(object, numberToFetch);</span>
 822     }
 823 
<span class="line-modified"> 824     _getIteratorEntries(object, numberToFetch)</span>
 825     {
<span class="line-modified"> 826         return InjectedScriptHost.iteratorEntries(object, numberToFetch);</span>
 827     }
 828 
<span class="line-modified"> 829     _entries(object, subtype, startIndex, numberToFetch)</span>
 830     {
 831         if (subtype === &quot;set&quot;)
<span class="line-modified"> 832             return this._getSetEntries(object, startIndex, numberToFetch);</span>
 833         if (subtype === &quot;map&quot;)
<span class="line-modified"> 834             return this._getMapEntries(object, startIndex, numberToFetch);</span>
 835         if (subtype === &quot;weakmap&quot;)
<span class="line-modified"> 836             return this._getWeakMapEntries(object, numberToFetch);</span>
 837         if (subtype === &quot;weakset&quot;)
<span class="line-modified"> 838             return this._getWeakSetEntries(object, numberToFetch);</span>
 839         if (subtype === &quot;iterator&quot;)
<span class="line-modified"> 840             return this._getIteratorEntries(object, numberToFetch);</span>
 841 
 842         throw &quot;unexpected type&quot;;
 843     }
 844 
 845     _saveResult(result)
 846     {
 847         this._lastResult = result;
 848 
 849         if (result === undefined || result === null)
 850             return;
 851 
 852         let existingIndex = this._savedResults.indexOf(result);
 853         if (existingIndex !== -1) {
 854             this._savedResultIndex = existingIndex;
 855             return;
 856         }
 857 
 858         this._savedResultIndex = this._nextSavedResultIndex;
 859         this._savedResults[this._nextSavedResultIndex++] = result;
 860 
 861         // $n is limited from $1-$99. $0 is special.
 862         if (this._nextSavedResultIndex &gt;= 100)
 863             this._nextSavedResultIndex = 1;
 864     }
 865 };
 866 
 867 InjectedScript.CollectionMode = {
 868     OwnProperties: 1 &lt;&lt; 0,          // own properties.
 869     NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
 870     AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
 871 };
 872 





 873 var injectedScript = new InjectedScript;
 874 
 875 // -------
 876 
 877 let RemoteObject = class RemoteObject
 878 {
 879     constructor(object, objectGroupName, forceValueType, generatePreview, columnNames)
 880     {
 881         this.type = typeof object;
 882 
 883         if (this.type === &quot;undefined&quot; &amp;&amp; InjectedScriptHost.isHTMLAllCollection(object))
 884             this.type = &quot;object&quot;;
 885 
 886         if (isPrimitiveValue(object) || isBigInt(object) || object === null || forceValueType) {
 887             // We don&#39;t send undefined values over JSON.
 888             // BigInt values are not JSON serializable.
 889             if (this.type !== &quot;undefined&quot; &amp;&amp; this.type !== &quot;bigint&quot;)
 890                 this.value = object;
 891 
 892             // Null object is object with &#39;null&#39; subtype.
</pre>
<hr />
<pre>
1104     {
1105         let preview = this._initialPreview();
1106         let isTableRowsRequest = secondLevelKeys === null || secondLevelKeys;
1107         let firstLevelKeysCount = firstLevelKeys ? firstLevelKeys.length : 0;
1108 
1109         let propertiesThreshold = {
1110             properties: isTableRowsRequest ? 1000 : Math.max(5, firstLevelKeysCount),
1111             indexes: isTableRowsRequest ? 1000 : Math.max(10, firstLevelKeysCount)
1112         };
1113 
1114         try {
1115             // Maps, Sets, and Iterators have entries.
1116             if (this.subtype === &quot;map&quot; || this.subtype === &quot;set&quot; || this.subtype === &quot;weakmap&quot; || this.subtype === &quot;weakset&quot; || this.subtype === &quot;iterator&quot;)
1117                 this._appendEntryPreviews(object, preview);
1118 
1119             preview.properties = [];
1120 
1121             // Internal Properties.
1122             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
1123             if (internalPropertyDescriptors) {
<span class="line-modified">1124                 this._appendPropertyPreviews(object, preview, internalPropertyDescriptors, true, propertiesThreshold, firstLevelKeys, secondLevelKeys);</span>
<span class="line-modified">1125                 if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)</span>
<span class="line-modified">1126                     return preview;</span>


1127             }
1128 
1129             if (preview.entries)
1130                 return preview;
1131 
1132             // Properties.
<span class="line-modified">1133             let nativeGettersAsValues = true;</span>
<span class="line-modified">1134             let descriptors = injectedScript._propertyDescriptors(object, InjectedScript.CollectionMode.AllProperties, nativeGettersAsValues);</span>
<span class="line-modified">1135             this._appendPropertyPreviews(object, preview, descriptors, false, propertiesThreshold, firstLevelKeys, secondLevelKeys);</span>
<span class="line-removed">1136             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)</span>
<span class="line-removed">1137                 return preview;</span>
1138         } catch {
1139             preview.lossless = false;
1140         }
1141 
1142         return preview;
1143     }
1144 
<span class="line-modified">1145     _appendPropertyPreviews(object, preview, descriptors, internal, propertiesThreshold, firstLevelKeys, secondLevelKeys)</span>
1146     {
<span class="line-modified">1147         for (let i = 0; i &lt; descriptors.length; ++i) {</span>
<span class="line-modified">1148             let descriptor = descriptors[i];</span>
<span class="line-modified">1149 </span>
<span class="line-modified">1150             // Seen enough.</span>
<span class="line-modified">1151             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0)</span>
<span class="line-removed">1152                 break;</span>
1153 
<span class="line-modified">1154             // Error in descriptor.</span>
<span class="line-modified">1155             if (descriptor.wasThrown) {</span>






1156                 preview.lossless = false;
<span class="line-modified">1157                 continue;</span>
<span class="line-modified">1158             }</span>
1159 
<span class="line-modified">1160             // Do not show &quot;__proto__&quot; in preview.</span>
<span class="line-modified">1161             let name = descriptor.name;</span>
<span class="line-modified">1162             if (name === &quot;__proto__&quot;) {</span>
<span class="line-removed">1163                 // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.</span>
<span class="line-removed">1164                 if (descriptor.value &amp;&amp; descriptor.value.constructor</span>
<span class="line-removed">1165                     &amp;&amp; descriptor.value.constructor !== Object</span>
<span class="line-removed">1166                     &amp;&amp; descriptor.value.constructor !== Array</span>
<span class="line-removed">1167                     &amp;&amp; descriptor.value.constructor !== RegExp)</span>
<span class="line-removed">1168                     preview.lossless = false;</span>
<span class="line-removed">1169                 continue;</span>
<span class="line-removed">1170             }</span>
1171 
<span class="line-modified">1172             // For arrays, only allow indexes.</span>
<span class="line-modified">1173             if (this.subtype === &quot;array&quot; &amp;&amp; !isUInt32(name))</span>
<span class="line-modified">1174                 continue;</span>


1175 
<span class="line-modified">1176             // Do not show non-enumerable non-own properties.</span>
<span class="line-modified">1177             // Special case to allow array indexes that may be on the prototype.</span>
<span class="line-modified">1178             // Special case to allow native getters on non-RegExp objects.</span>
<span class="line-modified">1179             if (!descriptor.enumerable &amp;&amp; !descriptor.isOwn &amp;&amp; !(this.subtype === &quot;array&quot; || (this.subtype !== &quot;regexp&quot; &amp;&amp; descriptor.nativeGetter)))</span>
<span class="line-removed">1180                 continue;</span>
1181 
<span class="line-modified">1182             // If we have a filter, only show properties in the filter.</span>
<span class="line-modified">1183             // FIXME: Currently these filters do nothing on the backend.</span>
<span class="line-modified">1184             if (firstLevelKeys &amp;&amp; !firstLevelKeys.includes(name))</span>
<span class="line-modified">1185                 continue;</span>

1186 
<span class="line-modified">1187             // Getter/setter.</span>
<span class="line-modified">1188             if (!(&quot;value&quot; in descriptor)) {</span>
1189                 preview.lossless = false;
<span class="line-modified">1190                 this._appendPropertyPreview(preview, internal, {name, type: &quot;accessor&quot;}, propertiesThreshold);</span>
<span class="line-removed">1191                 continue;</span>
1192             }
1193 
<span class="line-modified">1194             // Null value.</span>
<span class="line-modified">1195             let value = descriptor.value;</span>
<span class="line-removed">1196             if (value === null) {</span>
<span class="line-removed">1197                 this._appendPropertyPreview(preview, internal, {name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;}, propertiesThreshold);</span>
<span class="line-removed">1198                 continue;</span>
<span class="line-removed">1199             }</span>
1200 
<span class="line-modified">1201             // Ignore non-enumerable functions.</span>
<span class="line-modified">1202             let type = typeof value;</span>
<span class="line-modified">1203             if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)</span>
<span class="line-removed">1204                 continue;</span>
1205 
<span class="line-modified">1206             // Fix type of document.all.</span>
<span class="line-modified">1207             if (InjectedScriptHost.isHTMLAllCollection(value))</span>
<span class="line-modified">1208                 type = &quot;object&quot;;</span>


1209 
<span class="line-modified">1210             // Primitive.</span>
<span class="line-modified">1211             const maxLength = 100;</span>
<span class="line-modified">1212             if (isPrimitiveValue(value) || isBigInt(value)) {</span>
<span class="line-modified">1213                 if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {</span>
<span class="line-removed">1214                     value = this._abbreviateString(value, maxLength, true);</span>
<span class="line-removed">1215                     preview.lossless = false;</span>
<span class="line-removed">1216                 }</span>
<span class="line-removed">1217                 this._appendPropertyPreview(preview, internal, {name, type, value: toStringDescription(value)}, propertiesThreshold);</span>
<span class="line-removed">1218                 continue;</span>
<span class="line-removed">1219             }</span>
1220 
<span class="line-modified">1221             // Symbol.</span>
<span class="line-modified">1222             if (isSymbol(value)) {</span>
<span class="line-modified">1223                 let symbolString = toString(value);</span>
<span class="line-modified">1224                 if (symbolString.length &gt; maxLength) {</span>
<span class="line-removed">1225                     symbolString = this._abbreviateString(symbolString, maxLength, true);</span>
<span class="line-removed">1226                     preview.lossless = false;</span>
<span class="line-removed">1227                 }</span>
<span class="line-removed">1228                 this._appendPropertyPreview(preview, internal, {name, type, value: symbolString}, propertiesThreshold);</span>
<span class="line-removed">1229                 continue;</span>
<span class="line-removed">1230             }</span>
1231 
<span class="line-modified">1232             // Object.</span>
<span class="line-modified">1233             let property = {name, type};</span>
<span class="line-modified">1234             let subtype = RemoteObject.subtype(value);</span>
<span class="line-modified">1235             if (subtype)</span>
<span class="line-modified">1236                 property.subtype = subtype;</span>
<span class="line-modified">1237 </span>
<span class="line-modified">1238             // Second level.</span>
<span class="line-modified">1239             if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {</span>
<span class="line-modified">1240                 // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.</span>
<span class="line-removed">1241                 let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);</span>
<span class="line-removed">1242                 property.valuePreview = subPreview;</span>
<span class="line-removed">1243                 if (!subPreview.lossless)</span>
<span class="line-removed">1244                     preview.lossless = false;</span>
<span class="line-removed">1245                 if (subPreview.overflow)</span>
<span class="line-removed">1246                     preview.overflow = true;</span>
<span class="line-removed">1247             } else {</span>
<span class="line-removed">1248                 let description = &quot;&quot;;</span>
<span class="line-removed">1249                 if (type !== &quot;function&quot; || subtype === &quot;class&quot;) {</span>
<span class="line-removed">1250                     let fullDescription;</span>
<span class="line-removed">1251                     if (subtype === &quot;class&quot;)</span>
<span class="line-removed">1252                         fullDescription = &quot;class &quot; + value.name;</span>
<span class="line-removed">1253                     else if (subtype === &quot;node&quot;)</span>
<span class="line-removed">1254                         fullDescription = RemoteObject.nodePreview(value);</span>
<span class="line-removed">1255                     else</span>
<span class="line-removed">1256                         fullDescription = RemoteObject.describe(value);</span>
<span class="line-removed">1257                     description = this._abbreviateString(fullDescription, maxLength, subtype === &quot;regexp&quot;);</span>
<span class="line-removed">1258                 }</span>
<span class="line-removed">1259                 property.value = description;</span>
1260                 preview.lossless = false;
1261             }


1262 
<span class="line-modified">1263             this._appendPropertyPreview(preview, internal, property, propertiesThreshold);</span>







1264         }
<span class="line-removed">1265     }</span>
1266 
<span class="line-modified">1267     _appendPropertyPreview(preview, internal, property, propertiesThreshold)</span>
<span class="line-modified">1268     {</span>
<span class="line-modified">1269         if (toString(property.name &gt;&gt;&gt; 0) === property.name)</span>
<span class="line-modified">1270             propertiesThreshold.indexes--;</span>
<span class="line-modified">1271         else</span>
<span class="line-removed">1272             propertiesThreshold.properties--;</span>
1273 
<span class="line-modified">1274         if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0) {</span>
<span class="line-modified">1275             preview.overflow = true;</span>




















1276             preview.lossless = false;
<span class="line-removed">1277             return;</span>
1278         }
1279 
<span class="line-modified">1280         if (internal)</span>
<span class="line-removed">1281             property.internal = true;</span>
<span class="line-removed">1282 </span>
<span class="line-removed">1283         preview.properties.push(property);</span>
1284     }
1285 
1286     _appendEntryPreviews(object, preview)
1287     {
1288         // Fetch 6, but only return 5, so we can tell if we overflowed.
1289         let entries = injectedScript._entries(object, this.subtype, 0, 6);
1290         if (!entries)
1291             return;
1292 
1293         if (entries.length &gt; 5) {
1294             entries.pop();
1295             preview.overflow = true;
1296             preview.lossless = false;
1297         }
1298 
1299         function updateMainPreview(subPreview) {
1300             if (!subPreview.lossless)
1301                 preview.lossless = false;
1302         }
1303 
</pre>
<hr />
<pre>
1432     };
1433 
1434     if (name)
1435         scope.name = name;
1436 
1437     if (location)
1438         scope.location = location;
1439 
1440     if (isEmptyObject(object))
1441         scope.empty = true;
1442 
1443     return scope;
1444 }
1445 
1446 // -------
1447 
1448 function CommandLineAPI(callFrame)
1449 {
1450     let savedResultAlias = InjectedScriptHost.savedResultAlias;
1451 
<span class="line-modified">1452     let defineGetter = (key, value) =&gt; {</span>
<span class="line-modified">1453         if (typeof value !== &quot;function&quot;) {</span>
1454             let originalValue = value;
1455             value = function() { return originalValue; };
1456         }
1457 
1458         this.__defineGetter__(&quot;$&quot; + key, value);
1459         if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)
1460             this.__defineGetter__(savedResultAlias + key, value);
1461     };
1462 
1463     if (&quot;_lastResult&quot; in injectedScript)
<span class="line-modified">1464         defineGetter(&quot;_&quot;, injectedScript._lastResult);</span>
1465 
1466     if (&quot;_exceptionValue&quot; in injectedScript)
<span class="line-modified">1467         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue);</span>
1468 
1469     if (&quot;_eventValue&quot; in injectedScript)
<span class="line-modified">1470         defineGetter(&quot;event&quot;, injectedScript._eventValue);</span>
1471 
1472     // $1-$99
1473     for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)
<span class="line-modified">1474         defineGetter(i, injectedScript._savedResults[i]);</span>
1475 
1476     for (let name in CommandLineAPI.getters)
1477         defineGetter(name, CommandLineAPI.getters[name]);
1478 
1479     for (let name in CommandLineAPI.methods)
1480         this[name] = CommandLineAPI.methods[name];
1481 }
1482 
1483 CommandLineAPI.getters = {};
1484 
1485 CommandLineAPI.methods = {};
1486 
1487 CommandLineAPI.methods[&quot;keys&quot;] = function(object) { return Object.keys(object); };
1488 CommandLineAPI.methods[&quot;values&quot;] = function(object) { return Object.values(object); };
1489 
1490 CommandLineAPI.methods[&quot;queryInstances&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1491 CommandLineAPI.methods[&quot;queryObjects&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1492 CommandLineAPI.methods[&quot;queryHolders&quot;] = function() { return InjectedScriptHost.queryHolders(...arguments); };
1493 
1494 CommandLineAPI.methods[&quot;inspect&quot;] = function(object) { return injectedScript.inspectObject(object); };
</pre>
</td>
<td>
<hr />
<pre>
 213         if (typeof object !== &quot;function&quot;)
 214             return &quot;Cannot resolve function by id.&quot;;
 215         return this.functionDetails(object);
 216     }
 217 
 218     functionDetails(func)
 219     {
 220         let details = InjectedScriptHost.functionDetails(func);
 221         if (!details)
 222             return &quot;Cannot resolve function details.&quot;;
 223         return details;
 224     }
 225 
 226     getPreview(objectId)
 227     {
 228         let parsedObjectId = this._parseObjectId(objectId);
 229         let object = this._objectForId(parsedObjectId);
 230         return RemoteObject.createObjectPreviewForValue(object, true);
 231     }
 232 
<span class="line-modified"> 233     getProperties(objectId, ownProperties, fetchStart, fetchCount, generatePreview)</span>
 234     {

 235         let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
<span class="line-modified"> 236         return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview});</span>
 237     }
 238 
<span class="line-modified"> 239     getDisplayableProperties(objectId, fetchStart, fetchCount, generatePreview)</span>
 240     {

 241         let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
<span class="line-modified"> 242         return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues: true});</span>
 243     }
 244 
 245     getInternalProperties(objectId, generatePreview)
 246     {
 247         let parsedObjectId = this._parseObjectId(objectId);
 248         let object = this._objectForId(parsedObjectId);
 249         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 250 
 251         if (!isDefined(object))
 252             return false;
 253 
 254         if (isSymbol(object))
 255             return false;
 256 
 257         let descriptors = this._internalPropertyDescriptors(object);
 258         if (!descriptors)
 259             return [];
 260 
 261         for (let i = 0; i &lt; descriptors.length; ++i) {
 262             let descriptor = descriptors[i];
 263             if (&quot;value&quot; in descriptor)
 264                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
 265         }
 266 
 267         return descriptors;
 268     }
 269 
<span class="line-modified"> 270     getCollectionEntries(objectId, objectGroupName, fetchStart, fetchCount)</span>
 271     {
 272         let parsedObjectId = this._parseObjectId(objectId);
 273         let object = this._objectForId(parsedObjectId);
 274         objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
 275 
 276         if (!isDefined(object))
 277             return;
 278 
 279         if (typeof object !== &quot;object&quot;)
 280             return;
 281 
<span class="line-modified"> 282         let entries = this._entries(object, InjectedScriptHost.subtype(object), fetchStart, fetchCount);</span>
 283         return entries.map(function(entry) {
 284             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
 285             if (&quot;key&quot; in entry)
 286                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
 287             return entry;
 288         });
 289     }
 290 
 291     saveResult(callArgumentJSON)
 292     {
 293         this._savedResultIndex = 0;
 294 
 295         try {
 296             let callArgument = InjectedScriptHost.evaluate(&quot;(&quot; + callArgumentJSON + &quot;)&quot;);
 297             let value = this._resolveCallArgument(callArgument);
 298             this._saveResult(value);
 299         } catch { }
 300 
 301         return this._savedResultIndex;
 302     }
</pre>
<hr />
<pre>
 562     }
 563 
 564     _evaluateOn(evalFunction, object, expression, isEvalOnCallFrame, includeCommandLineAPI)
 565     {
 566         let commandLineAPI = null;
 567         if (includeCommandLineAPI)
 568             commandLineAPI = new CommandLineAPI(isEvalOnCallFrame ? object : null);
 569         return evalFunction.call(object, expression, commandLineAPI);
 570     }
 571 
 572     _callFrameForId(topCallFrame, callFrameId)
 573     {
 574         let parsedCallFrameId = InjectedScriptHost.evaluate(&quot;(&quot; + callFrameId + &quot;)&quot;);
 575         let ordinal = parsedCallFrameId[&quot;ordinal&quot;];
 576         let callFrame = topCallFrame;
 577         while (--ordinal &gt;= 0 &amp;&amp; callFrame)
 578             callFrame = callFrame.caller;
 579         return callFrame;
 580     }
 581 
<span class="line-modified"> 582     _getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues})</span>
 583     {
 584         let parsedObjectId = this._parseObjectId(objectId);
 585         let object = this._objectForId(parsedObjectId);
 586         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 587 
 588         if (!isDefined(object))
 589             return false;
 590 
 591         if (isSymbol(object))
 592             return false;
 593 
<span class="line-modified"> 594         let start = fetchStart || 0;</span>
<span class="line-added"> 595         if (start &lt; 0)</span>
<span class="line-added"> 596             start = 0;</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598         let count = fetchCount || 0;</span>
<span class="line-added"> 599         if (count &lt; 0)</span>
<span class="line-added"> 600             count = 0;</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602         // Always include __proto__ at the end, but only for the first fetch.</span>
<span class="line-added"> 603         let includeProto = !start;</span>
<span class="line-added"> 604 </span>
<span class="line-added"> 605         let descriptors = [];</span>
<span class="line-added"> 606         this._forEachPropertyDescriptor(object, collectionMode, (descriptor) =&gt; {</span>
<span class="line-added"> 607             if (start &gt; 0) {</span>
<span class="line-added"> 608                 --start;</span>
<span class="line-added"> 609                 return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-added"> 610             }</span>
 611 


 612             if (&quot;get&quot; in descriptor)
 613                 descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
 614             if (&quot;set&quot; in descriptor)
 615                 descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
 616             if (&quot;value&quot; in descriptor)
 617                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);




 618             if (&quot;symbol&quot; in descriptor)
 619                 descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
<span class="line-modified"> 620             descriptors.push(descriptor);</span>
<span class="line-added"> 621 </span>
<span class="line-added"> 622             if (includeProto &amp;&amp; count &amp;&amp; descriptors.length &gt;= count &amp;&amp; descriptor.name !== &quot;__proto__&quot;)</span>
<span class="line-added"> 623                 return InjectedScript.PropertyFetchAction.Stop;</span>
 624 
<span class="line-added"> 625             return (count &amp;&amp; descriptors.length &gt;= count) ? InjectedScript.PropertyFetchAction.Stop : InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-added"> 626         }, {nativeGettersAsValues, includeProto});</span>
 627         return descriptors;
 628     }
 629 
 630     _internalPropertyDescriptors(object, completeDescriptor)
 631     {
 632         let internalProperties = InjectedScriptHost.getInternalProperties(object);
 633         if (!internalProperties)
 634             return null;
 635 
 636         let descriptors = [];
 637         for (let i = 0; i &lt; internalProperties.length; i++) {
 638             let property = internalProperties[i];
 639             let descriptor = {name: property.name, value: property.value};
<span class="line-modified"> 640             if (completeDescriptor)</span>



 641                 descriptor.isOwn = true;

 642             descriptors.push(descriptor);
 643         }
 644         return descriptors;
 645     }
 646 
<span class="line-modified"> 647     _forEachPropertyDescriptor(object, collectionMode, callback, {nativeGettersAsValues, includeProto})</span>
 648     {
 649         if (InjectedScriptHost.subtype(object) === &quot;proxy&quot;)
<span class="line-modified"> 650             return;</span>
 651 

 652         let nameProcessed = new Set;
 653 
<span class="line-added"> 654         // Handled below when `includeProto`.</span>
<span class="line-added"> 655         nameProcessed.add(&quot;__proto__&quot;);</span>
<span class="line-added"> 656 </span>
 657         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
 658         {
 659             try {
<span class="line-modified"> 660                 let fakeDescriptor = {name, value: object[name]};</span>
<span class="line-added"> 661                 if (descriptor) {</span>
<span class="line-added"> 662                     if (descriptor.writable)</span>
<span class="line-added"> 663                         fakeDescriptor.writable = true;</span>
<span class="line-added"> 664                     if (descriptor.configurable)</span>
<span class="line-added"> 665                         fakeDescriptor.configurable = true;</span>
<span class="line-added"> 666                     if (descriptor.enumerable)</span>
<span class="line-added"> 667                         fakeDescriptor.enumerable = true;</span>
<span class="line-added"> 668                 }</span>
 669                 if (possibleNativeBindingGetter)
 670                     fakeDescriptor.nativeGetter = true;
 671                 if (isOwnProperty)
 672                     fakeDescriptor.isOwn = true;
 673                 if (symbol)
 674                     fakeDescriptor.symbol = symbol;
 675                 // Silence any possible unhandledrejection exceptions created from accessing a native accessor with a wrong this object.
 676                 if (fakeDescriptor.value instanceof Promise &amp;&amp; InjectedScriptHost.isPromiseRejectedWithNativeGetterTypeError(fakeDescriptor.value))
 677                     fakeDescriptor.value.catch(function(){});
 678                 return fakeDescriptor;
 679             } catch (e) {
 680                 let errorDescriptor = {name, value: e, wasThrown: true};
 681                 if (isOwnProperty)
 682                     errorDescriptor.isOwn = true;
 683                 if (symbol)
 684                     errorDescriptor.symbol = symbol;
 685                 return errorDescriptor;
 686             }
 687         }
 688 
 689         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
 690         {
 691             // All properties.
<span class="line-modified"> 692             if (collectionMode &amp; InjectedScript.CollectionMode.AllProperties)</span>
<span class="line-modified"> 693                 return callback(descriptor);</span>


 694 
 695             // Own properties.
<span class="line-modified"> 696             if (collectionMode &amp; InjectedScript.CollectionMode.OwnProperties &amp;&amp; isOwnProperty)</span>
<span class="line-modified"> 697                 return callback(descriptor);</span>


 698 
 699             // Native Getter properties.
 700             if (collectionMode &amp; InjectedScript.CollectionMode.NativeGetterProperties) {
<span class="line-modified"> 701                 if (possibleNativeBindingGetter)</span>
<span class="line-modified"> 702                     return callback(descriptor);</span>


 703             }
 704         }
 705 
<span class="line-modified"> 706         function processProperty(o, propertyName, isOwnProperty)</span>
 707         {
<span class="line-modified"> 708             if (nameProcessed.has(propertyName))</span>
<span class="line-modified"> 709                 return InjectedScript.PropertyFetchAction.Continue;</span>
















 710 
<span class="line-modified"> 711             nameProcessed.add(propertyName);</span>








 712 
<span class="line-modified"> 713             let name = toString(propertyName);</span>
<span class="line-modified"> 714             let symbol = isSymbol(propertyName) ? propertyName : null;</span>
<span class="line-modified"> 715 </span>
<span class="line-modified"> 716             let descriptor = Object.getOwnPropertyDescriptor(o, propertyName);</span>
<span class="line-modified"> 717             if (!descriptor) {</span>
<span class="line-modified"> 718                 // FIXME: Bad descriptor. Can we get here?</span>
<span class="line-added"> 719                 // Fall back to very restrictive settings.</span>
<span class="line-added"> 720                 let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty);</span>
<span class="line-added"> 721                 return processDescriptor(fakeDescriptor, isOwnProperty);</span>
 722             }

 723 
<span class="line-modified"> 724             if (nativeGettersAsValues) {</span>
<span class="line-modified"> 725                 if (String(descriptor.get).endsWith(&quot;[native code]\n}&quot;) || (!descriptor.get &amp;&amp; descriptor.hasOwnProperty(&quot;get&quot;) &amp;&amp; !descriptor.set &amp;&amp; descriptor.hasOwnProperty(&quot;set&quot;))) {</span>
<span class="line-modified"> 726                     // Developers may create such a descriptor, so we should be resilient:</span>
<span class="line-modified"> 727                     // let x = {}; Object.defineProperty(x, &quot;p&quot;, {get:undefined}); Object.getOwnPropertyDescriptor(x, &quot;p&quot;)</span>
<span class="line-modified"> 728                     let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);</span>
<span class="line-modified"> 729                     return processDescriptor(fakeDescriptor, isOwnProperty, true);</span>
<span class="line-added"> 730                 }</span>
 731             }
<span class="line-modified"> 732 </span>
<span class="line-added"> 733             descriptor.name = name;</span>
<span class="line-added"> 734             if (isOwnProperty)</span>
<span class="line-added"> 735                 descriptor.isOwn = true;</span>
<span class="line-added"> 736             if (symbol)</span>
<span class="line-added"> 737                 descriptor.symbol = symbol;</span>
<span class="line-added"> 738             return processDescriptor(descriptor, isOwnProperty);</span>
 739         }
 740 


 741         let isArrayLike = false;
 742         try {
 743             isArrayLike = RemoteObject.subtype(object) === &quot;array&quot; &amp;&amp; isFinite(object.length) &amp;&amp; object.length &gt; 0;
 744         } catch { }
 745 
 746         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
 747             let isOwnProperty = o === object;
<span class="line-added"> 748             let shouldBreak = false;</span>
<span class="line-added"> 749 </span>
<span class="line-added"> 750             // FIXME: &lt;https://webkit.org/b/201861&gt; Web Inspector: show autocomplete entries for non-index properties on arrays</span>
<span class="line-added"> 751             if (isArrayLike &amp;&amp; isOwnProperty) {</span>
<span class="line-added"> 752                 for (let i = 0; i &lt; o.length; ++i) {</span>
<span class="line-added"> 753                     if (!(i in o))</span>
<span class="line-added"> 754                         continue;</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756                     let result = processProperty(o, toString(i), isOwnProperty);</span>
<span class="line-added"> 757                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;</span>
<span class="line-added"> 758                     if (shouldBreak)</span>
<span class="line-added"> 759                         break;</span>
<span class="line-added"> 760                 }</span>
<span class="line-added"> 761             } else {</span>
<span class="line-added"> 762                 let propertyNames = Object.getOwnPropertyNames(o);</span>
<span class="line-added"> 763                 for (let i = 0; i &lt; propertyNames.length; ++i) {</span>
<span class="line-added"> 764                     let result = processProperty(o, propertyNames[i], isOwnProperty);</span>
<span class="line-added"> 765                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;</span>
<span class="line-added"> 766                     if (shouldBreak)</span>
<span class="line-added"> 767                         break;</span>
<span class="line-added"> 768                 }</span>
<span class="line-added"> 769             }</span>
 770 
<span class="line-modified"> 771             if (shouldBreak)</span>
<span class="line-modified"> 772                 break;</span>
<span class="line-modified"> 773 </span>
<span class="line-modified"> 774             if (Object.getOwnPropertySymbols) {</span>
<span class="line-modified"> 775                 let propertySymbols = Object.getOwnPropertySymbols(o);</span>
<span class="line-modified"> 776                 for (let i = 0; i &lt; propertySymbols.length; ++i) {</span>
<span class="line-added"> 777                     let result = processProperty(o, propertySymbols[i], isOwnProperty);</span>
<span class="line-added"> 778                     shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;</span>
<span class="line-added"> 779                     if (shouldBreak)</span>
<span class="line-added"> 780                         break;</span>
<span class="line-added"> 781                 }</span>
 782             }
 783 
<span class="line-added"> 784             if (shouldBreak)</span>
<span class="line-added"> 785                 break;</span>
<span class="line-added"> 786 </span>
 787             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
 788                 break;
 789         }
 790 
<span class="line-modified"> 791         if (includeProto) {</span>
<span class="line-modified"> 792             try {</span>
<span class="line-modified"> 793                 if (object.__proto__)</span>
<span class="line-modified"> 794                     callback({name: &quot;__proto__&quot;, value: object.__proto__, writable: true, configurable: true, isOwn: true});</span>
<span class="line-modified"> 795             } catch { }</span>
<span class="line-modified"> 796         }</span>

 797     }
 798 
<span class="line-modified"> 799     _getSetEntries(object, fetchStart, fetchCount)</span>
 800     {
 801         let entries = [];
 802 
 803         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
 804         for (let value of object) {
<span class="line-modified"> 805             if (fetchStart &gt; 0) {</span>
<span class="line-modified"> 806                 fetchStart--;</span>
 807                 continue;
 808             }
 809 
 810             entries.push({value});
 811 
<span class="line-modified"> 812             if (fetchCount &amp;&amp; entries.length === fetchCount)</span>
 813                 break;
 814         }
 815 
 816         return entries;
 817     }
 818 
<span class="line-modified"> 819     _getMapEntries(object, fetchStart, fetchCount)</span>
 820     {
 821         let entries = [];
 822 
 823         // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
 824         for (let [key, value] of object) {
<span class="line-modified"> 825             if (fetchStart &gt; 0) {</span>
<span class="line-modified"> 826                 fetchStart--;</span>
 827                 continue;
 828             }
 829 
 830             entries.push({key, value});
 831 
<span class="line-modified"> 832             if (fetchCount &amp;&amp; entries.length === fetchCount)</span>
 833                 break;
 834         }
 835 
 836         return entries;
 837     }
 838 
<span class="line-modified"> 839     _getWeakMapEntries(object, fetchCount)</span>
 840     {
<span class="line-modified"> 841         return InjectedScriptHost.weakMapEntries(object, fetchCount);</span>
 842     }
 843 
<span class="line-modified"> 844     _getWeakSetEntries(object, fetchCount)</span>
 845     {
<span class="line-modified"> 846         return InjectedScriptHost.weakSetEntries(object, fetchCount);</span>
 847     }
 848 
<span class="line-modified"> 849     _getIteratorEntries(object, fetchCount)</span>
 850     {
<span class="line-modified"> 851         return InjectedScriptHost.iteratorEntries(object, fetchCount);</span>
 852     }
 853 
<span class="line-modified"> 854     _entries(object, subtype, fetchStart, fetchCount)</span>
 855     {
 856         if (subtype === &quot;set&quot;)
<span class="line-modified"> 857             return this._getSetEntries(object, fetchStart, fetchCount);</span>
 858         if (subtype === &quot;map&quot;)
<span class="line-modified"> 859             return this._getMapEntries(object, fetchStart, fetchCount);</span>
 860         if (subtype === &quot;weakmap&quot;)
<span class="line-modified"> 861             return this._getWeakMapEntries(object, fetchCount);</span>
 862         if (subtype === &quot;weakset&quot;)
<span class="line-modified"> 863             return this._getWeakSetEntries(object, fetchCount);</span>
 864         if (subtype === &quot;iterator&quot;)
<span class="line-modified"> 865             return this._getIteratorEntries(object, fetchCount);</span>
 866 
 867         throw &quot;unexpected type&quot;;
 868     }
 869 
 870     _saveResult(result)
 871     {
 872         this._lastResult = result;
 873 
 874         if (result === undefined || result === null)
 875             return;
 876 
 877         let existingIndex = this._savedResults.indexOf(result);
 878         if (existingIndex !== -1) {
 879             this._savedResultIndex = existingIndex;
 880             return;
 881         }
 882 
 883         this._savedResultIndex = this._nextSavedResultIndex;
 884         this._savedResults[this._nextSavedResultIndex++] = result;
 885 
 886         // $n is limited from $1-$99. $0 is special.
 887         if (this._nextSavedResultIndex &gt;= 100)
 888             this._nextSavedResultIndex = 1;
 889     }
 890 };
 891 
 892 InjectedScript.CollectionMode = {
 893     OwnProperties: 1 &lt;&lt; 0,          // own properties.
 894     NativeGetterProperties: 1 &lt;&lt; 1, // native getter properties in the prototype chain.
 895     AllProperties: 1 &lt;&lt; 2,          // all properties in the prototype chain.
 896 };
 897 
<span class="line-added"> 898 InjectedScript.PropertyFetchAction = {</span>
<span class="line-added"> 899     Continue: Symbol(&quot;continue&quot;),</span>
<span class="line-added"> 900     Stop: Symbol(&quot;stop&quot;),</span>
<span class="line-added"> 901 }</span>
<span class="line-added"> 902 </span>
 903 var injectedScript = new InjectedScript;
 904 
 905 // -------
 906 
 907 let RemoteObject = class RemoteObject
 908 {
 909     constructor(object, objectGroupName, forceValueType, generatePreview, columnNames)
 910     {
 911         this.type = typeof object;
 912 
 913         if (this.type === &quot;undefined&quot; &amp;&amp; InjectedScriptHost.isHTMLAllCollection(object))
 914             this.type = &quot;object&quot;;
 915 
 916         if (isPrimitiveValue(object) || isBigInt(object) || object === null || forceValueType) {
 917             // We don&#39;t send undefined values over JSON.
 918             // BigInt values are not JSON serializable.
 919             if (this.type !== &quot;undefined&quot; &amp;&amp; this.type !== &quot;bigint&quot;)
 920                 this.value = object;
 921 
 922             // Null object is object with &#39;null&#39; subtype.
</pre>
<hr />
<pre>
1134     {
1135         let preview = this._initialPreview();
1136         let isTableRowsRequest = secondLevelKeys === null || secondLevelKeys;
1137         let firstLevelKeysCount = firstLevelKeys ? firstLevelKeys.length : 0;
1138 
1139         let propertiesThreshold = {
1140             properties: isTableRowsRequest ? 1000 : Math.max(5, firstLevelKeysCount),
1141             indexes: isTableRowsRequest ? 1000 : Math.max(10, firstLevelKeysCount)
1142         };
1143 
1144         try {
1145             // Maps, Sets, and Iterators have entries.
1146             if (this.subtype === &quot;map&quot; || this.subtype === &quot;set&quot; || this.subtype === &quot;weakmap&quot; || this.subtype === &quot;weakset&quot; || this.subtype === &quot;iterator&quot;)
1147                 this._appendEntryPreviews(object, preview);
1148 
1149             preview.properties = [];
1150 
1151             // Internal Properties.
1152             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
1153             if (internalPropertyDescriptors) {
<span class="line-modified">1154                 for (let i = 0; i &lt; internalPropertyDescriptors.length; ++i) {</span>
<span class="line-modified">1155                     let result = this._appendPropertyPreview(object, preview, internalPropertyDescriptors[i], propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal: true});</span>
<span class="line-modified">1156                     if (result === InjectedScript.PropertyFetchAction.Stop)</span>
<span class="line-added">1157                         return preview;</span>
<span class="line-added">1158                 }</span>
1159             }
1160 
1161             if (preview.entries)
1162                 return preview;
1163 
1164             // Properties.
<span class="line-modified">1165             injectedScript._forEachPropertyDescriptor(object, InjectedScript.CollectionMode.AllProperties, (descriptor) =&gt; {</span>
<span class="line-modified">1166                 return this._appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys);</span>
<span class="line-modified">1167             }, {nativeGettersAsValues: true, includeProto: true})</span>


1168         } catch {
1169             preview.lossless = false;
1170         }
1171 
1172         return preview;
1173     }
1174 
<span class="line-modified">1175     _appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal} = {})</span>
1176     {
<span class="line-modified">1177         // Error in descriptor.</span>
<span class="line-modified">1178         if (descriptor.wasThrown) {</span>
<span class="line-modified">1179             preview.lossless = false;</span>
<span class="line-modified">1180             return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-modified">1181         }</span>

1182 
<span class="line-modified">1183         // Do not show &quot;__proto__&quot; in preview.</span>
<span class="line-modified">1184         let name = descriptor.name;</span>
<span class="line-added">1185         if (name === &quot;__proto__&quot;) {</span>
<span class="line-added">1186             // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.</span>
<span class="line-added">1187             if (descriptor.value &amp;&amp; descriptor.value.constructor</span>
<span class="line-added">1188                 &amp;&amp; descriptor.value.constructor !== Object</span>
<span class="line-added">1189                 &amp;&amp; descriptor.value.constructor !== Array</span>
<span class="line-added">1190                 &amp;&amp; descriptor.value.constructor !== RegExp)</span>
1191                 preview.lossless = false;
<span class="line-modified">1192             return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-modified">1193         }</span>
1194 
<span class="line-modified">1195         // For arrays, only allow indexes.</span>
<span class="line-modified">1196         if (this.subtype === &quot;array&quot; &amp;&amp; !isUInt32(name))</span>
<span class="line-modified">1197             return InjectedScript.PropertyFetchAction.Continue;</span>








1198 
<span class="line-modified">1199         // Do not show non-enumerable non-own properties.</span>
<span class="line-modified">1200         // Special case to allow array indexes that may be on the prototype.</span>
<span class="line-modified">1201         // Special case to allow native getters on non-RegExp objects.</span>
<span class="line-added">1202         if (!descriptor.enumerable &amp;&amp; !descriptor.isOwn &amp;&amp; !(this.subtype === &quot;array&quot; || (this.subtype !== &quot;regexp&quot; &amp;&amp; descriptor.nativeGetter)))</span>
<span class="line-added">1203             return InjectedScript.PropertyFetchAction.Continue;</span>
1204 
<span class="line-modified">1205         // If we have a filter, only show properties in the filter.</span>
<span class="line-modified">1206         // FIXME: Currently these filters do nothing on the backend.</span>
<span class="line-modified">1207         if (firstLevelKeys &amp;&amp; !firstLevelKeys.includes(name))</span>
<span class="line-modified">1208             return InjectedScript.PropertyFetchAction.Continue;</span>

1209 
<span class="line-modified">1210         function appendPreview(property) {</span>
<span class="line-modified">1211             if (toString(property.name &gt;&gt;&gt; 0) === property.name)</span>
<span class="line-modified">1212                 propertiesThreshold.indexes--;</span>
<span class="line-modified">1213             else</span>
<span class="line-added">1214                 propertiesThreshold.properties--;</span>
1215 
<span class="line-modified">1216             if (propertiesThreshold.indexes &lt; 0 || propertiesThreshold.properties &lt; 0) {</span>
<span class="line-modified">1217                 preview.overflow = true;</span>
1218                 preview.lossless = false;
<span class="line-modified">1219                 return InjectedScript.PropertyFetchAction.Stop;</span>

1220             }
1221 
<span class="line-modified">1222             if (internal)</span>
<span class="line-modified">1223                 property.internal = true;</span>




1224 
<span class="line-modified">1225             preview.properties.push(property);</span>
<span class="line-modified">1226             return InjectedScript.PropertyFetchAction.Continue;</span>
<span class="line-modified">1227         }</span>

1228 
<span class="line-modified">1229         // Getter/setter.</span>
<span class="line-modified">1230         if (!(&quot;value&quot; in descriptor)) {</span>
<span class="line-modified">1231             preview.lossless = false;</span>
<span class="line-added">1232             return appendPreview({name, type: &quot;accessor&quot;});</span>
<span class="line-added">1233         }</span>
1234 
<span class="line-modified">1235         // Null value.</span>
<span class="line-modified">1236         let value = descriptor.value;</span>
<span class="line-modified">1237         if (value === null)</span>
<span class="line-modified">1238             return appendPreview({name, type: &quot;object&quot;, subtype: &quot;null&quot;, value: &quot;null&quot;});</span>






1239 
<span class="line-modified">1240         // Ignore non-enumerable functions.</span>
<span class="line-modified">1241         let type = typeof value;</span>
<span class="line-modified">1242         if (!descriptor.enumerable &amp;&amp; type === &quot;function&quot;)</span>
<span class="line-modified">1243             return InjectedScript.PropertyFetchAction.Continue;</span>






1244 
<span class="line-modified">1245         // Fix type of document.all.</span>
<span class="line-modified">1246         if (InjectedScriptHost.isHTMLAllCollection(value))</span>
<span class="line-modified">1247             type = &quot;object&quot;;</span>
<span class="line-modified">1248 </span>
<span class="line-modified">1249         // Primitive.</span>
<span class="line-modified">1250         const maxLength = 100;</span>
<span class="line-modified">1251         if (isPrimitiveValue(value) || isBigInt(value)) {</span>
<span class="line-modified">1252             if (type === &quot;string&quot; &amp;&amp; value.length &gt; maxLength) {</span>
<span class="line-modified">1253                 value = this._abbreviateString(value, maxLength, true);</span>



















1254                 preview.lossless = false;
1255             }
<span class="line-added">1256             return appendPreview({name, type, value: toStringDescription(value)});</span>
<span class="line-added">1257         }</span>
1258 
<span class="line-modified">1259         // Symbol.</span>
<span class="line-added">1260         if (isSymbol(value)) {</span>
<span class="line-added">1261             let symbolString = toString(value);</span>
<span class="line-added">1262             if (symbolString.length &gt; maxLength) {</span>
<span class="line-added">1263                 symbolString = this._abbreviateString(symbolString, maxLength, true);</span>
<span class="line-added">1264                 preview.lossless = false;</span>
<span class="line-added">1265             }</span>
<span class="line-added">1266             return appendPreview({name, type, value: symbolString});</span>
1267         }

1268 
<span class="line-modified">1269         // Object.</span>
<span class="line-modified">1270         let property = {name, type};</span>
<span class="line-modified">1271         let subtype = RemoteObject.subtype(value);</span>
<span class="line-modified">1272         if (subtype)</span>
<span class="line-modified">1273             property.subtype = subtype;</span>

1274 
<span class="line-modified">1275         // Second level.</span>
<span class="line-modified">1276         if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {</span>
<span class="line-added">1277             // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.</span>
<span class="line-added">1278             let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);</span>
<span class="line-added">1279             property.valuePreview = subPreview;</span>
<span class="line-added">1280             if (!subPreview.lossless)</span>
<span class="line-added">1281                 preview.lossless = false;</span>
<span class="line-added">1282             if (subPreview.overflow)</span>
<span class="line-added">1283                 preview.overflow = true;</span>
<span class="line-added">1284         } else {</span>
<span class="line-added">1285             let description = &quot;&quot;;</span>
<span class="line-added">1286             if (type !== &quot;function&quot; || subtype === &quot;class&quot;) {</span>
<span class="line-added">1287                 let fullDescription;</span>
<span class="line-added">1288                 if (subtype === &quot;class&quot;)</span>
<span class="line-added">1289                     fullDescription = &quot;class &quot; + value.name;</span>
<span class="line-added">1290                 else if (subtype === &quot;node&quot;)</span>
<span class="line-added">1291                     fullDescription = RemoteObject.nodePreview(value);</span>
<span class="line-added">1292                 else</span>
<span class="line-added">1293                     fullDescription = RemoteObject.describe(value);</span>
<span class="line-added">1294                 description = this._abbreviateString(fullDescription, maxLength, subtype === &quot;regexp&quot;);</span>
<span class="line-added">1295             }</span>
<span class="line-added">1296             property.value = description;</span>
1297             preview.lossless = false;

1298         }
1299 
<span class="line-modified">1300         return appendPreview(property);</span>



1301     }
1302 
1303     _appendEntryPreviews(object, preview)
1304     {
1305         // Fetch 6, but only return 5, so we can tell if we overflowed.
1306         let entries = injectedScript._entries(object, this.subtype, 0, 6);
1307         if (!entries)
1308             return;
1309 
1310         if (entries.length &gt; 5) {
1311             entries.pop();
1312             preview.overflow = true;
1313             preview.lossless = false;
1314         }
1315 
1316         function updateMainPreview(subPreview) {
1317             if (!subPreview.lossless)
1318                 preview.lossless = false;
1319         }
1320 
</pre>
<hr />
<pre>
1449     };
1450 
1451     if (name)
1452         scope.name = name;
1453 
1454     if (location)
1455         scope.location = location;
1456 
1457     if (isEmptyObject(object))
1458         scope.empty = true;
1459 
1460     return scope;
1461 }
1462 
1463 // -------
1464 
1465 function CommandLineAPI(callFrame)
1466 {
1467     let savedResultAlias = InjectedScriptHost.savedResultAlias;
1468 
<span class="line-modified">1469     let defineGetter = (key, value, wrap) =&gt; {</span>
<span class="line-modified">1470         if (wrap) {</span>
1471             let originalValue = value;
1472             value = function() { return originalValue; };
1473         }
1474 
1475         this.__defineGetter__(&quot;$&quot; + key, value);
1476         if (savedResultAlias &amp;&amp; savedResultAlias !== &quot;$&quot;)
1477             this.__defineGetter__(savedResultAlias + key, value);
1478     };
1479 
1480     if (&quot;_lastResult&quot; in injectedScript)
<span class="line-modified">1481         defineGetter(&quot;_&quot;, injectedScript._lastResult, true);</span>
1482 
1483     if (&quot;_exceptionValue&quot; in injectedScript)
<span class="line-modified">1484         defineGetter(&quot;exception&quot;, injectedScript._exceptionValue, true);</span>
1485 
1486     if (&quot;_eventValue&quot; in injectedScript)
<span class="line-modified">1487         defineGetter(&quot;event&quot;, injectedScript._eventValue, true);</span>
1488 
1489     // $1-$99
1490     for (let i = 1; i &lt; injectedScript._savedResults.length; ++i)
<span class="line-modified">1491         defineGetter(i, injectedScript._savedResults[i], true);</span>
1492 
1493     for (let name in CommandLineAPI.getters)
1494         defineGetter(name, CommandLineAPI.getters[name]);
1495 
1496     for (let name in CommandLineAPI.methods)
1497         this[name] = CommandLineAPI.methods[name];
1498 }
1499 
1500 CommandLineAPI.getters = {};
1501 
1502 CommandLineAPI.methods = {};
1503 
1504 CommandLineAPI.methods[&quot;keys&quot;] = function(object) { return Object.keys(object); };
1505 CommandLineAPI.methods[&quot;values&quot;] = function(object) { return Object.values(object); };
1506 
1507 CommandLineAPI.methods[&quot;queryInstances&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1508 CommandLineAPI.methods[&quot;queryObjects&quot;] = function() { return InjectedScriptHost.queryInstances(...arguments); };
1509 CommandLineAPI.methods[&quot;queryHolders&quot;] = function() { return InjectedScriptHost.queryHolders(...arguments); };
1510 
1511 CommandLineAPI.methods[&quot;inspect&quot;] = function(object) { return injectedScript.inspectObject(object); };
</pre>
</td>
</tr>
</table>
<center><a href="InjectedScriptModule.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorEnvironment.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/FastMalloc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2005, 2007, Google Inc. All rights reserved.
  3  * Copyright (C) 2005-2018 Apple Inc. All rights reserved.
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/FastMalloc.h&gt;
 28 
 29 #include &lt;limits&gt;
 30 #include &lt;string.h&gt;
 31 #include &lt;wtf/CheckedArithmetic.h&gt;
 32 #include &lt;wtf/DataLog.h&gt;
 33 
 34 #if OS(WINDOWS)
 35 #include &lt;windows.h&gt;
 36 #else
 37 #include &lt;pthread.h&gt;
 38 #if HAVE(RESOURCE_H)
 39 #include &lt;sys/resource.h&gt;
 40 #endif // HAVE(RESOURCE_H)
 41 #endif
 42 
 43 #if OS(DARWIN)
 44 #include &lt;mach/mach_init.h&gt;
 45 #include &lt;malloc/malloc.h&gt;
 46 #endif
 47 
<a name="1" id="anc1"></a><span class="line-added"> 48 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 49 #include &lt;wtf/Atomics.h&gt;</span>
<span class="line-added"> 50 #include &lt;wtf/HashMap.h&gt;</span>
<span class="line-added"> 51 #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added"> 52 #include &lt;wtf/NeverDestroyed.h&gt;</span>
<span class="line-added"> 53 #include &lt;wtf/SetForScope.h&gt;</span>
<span class="line-added"> 54 #include &lt;wtf/StackShot.h&gt;</span>
<span class="line-added"> 55 </span>
<span class="line-added"> 56 #if PLATFORM(COCOA)</span>
<span class="line-added"> 57 #include &lt;notify.h&gt;</span>
<span class="line-added"> 58 #endif</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60 #endif</span>
<span class="line-added"> 61 </span>
 62 namespace WTF {
 63 
 64 #if !defined(NDEBUG)
 65 namespace {
 66 // We do not use std::numeric_limits&lt;size_t&gt;::max() here due to the edge case in VC++.
 67 // https://bugs.webkit.org/show_bug.cgi?id=173720
 68 static size_t maxSingleAllocationSize = SIZE_MAX;
 69 };
 70 
 71 void fastSetMaxSingleAllocationSize(size_t size)
 72 {
 73     maxSingleAllocationSize = size;
 74 }
 75 
 76 #define ASSERT_IS_WITHIN_LIMIT(size) do { \
 77         size_t size__ = (size); \
 78         ASSERT_WITH_MESSAGE((size__) &lt;= maxSingleAllocationSize, &quot;Requested size (%zu) exceeds max single allocation size set for testing (%zu)&quot;, (size__), maxSingleAllocationSize); \
 79     } while (false)
 80 
 81 #define FAIL_IF_EXCEEDS_LIMIT(size) do { \
 82         if (UNLIKELY((size) &gt; maxSingleAllocationSize)) \
 83             return nullptr; \
 84     } while (false)
 85 
 86 #else // !defined(NDEBUG)
 87 
 88 #define ASSERT_IS_WITHIN_LIMIT(size)
 89 #define FAIL_IF_EXCEEDS_LIMIT(size)
 90 
 91 #endif // !defined(NDEBUG)
 92 
 93 void* fastZeroedMalloc(size_t n)
 94 {
 95     void* result = fastMalloc(n);
 96     memset(result, 0, n);
 97     return result;
 98 }
 99 
100 char* fastStrDup(const char* src)
101 {
102     size_t len = strlen(src) + 1;
103     char* dup = static_cast&lt;char*&gt;(fastMalloc(len));
104     memcpy(dup, src, len);
105     return dup;
106 }
107 
108 TryMallocReturnValue tryFastZeroedMalloc(size_t n)
109 {
110     void* result;
111     if (!tryFastMalloc(n).getValue(result))
112         return 0;
113     memset(result, 0, n);
114     return result;
115 }
116 
117 } // namespace WTF
118 
119 #if defined(USE_SYSTEM_MALLOC) &amp;&amp; USE_SYSTEM_MALLOC
120 
121 #include &lt;wtf/OSAllocator.h&gt;
122 
123 #if OS(WINDOWS)
124 #include &lt;malloc.h&gt;
125 #endif
126 
127 namespace WTF {
128 
129 bool isFastMallocEnabled()
130 {
131     return false;
132 }
133 
134 size_t fastMallocGoodSize(size_t bytes)
135 {
136 #if OS(DARWIN)
137     return malloc_good_size(bytes);
138 #else
139     return bytes;
140 #endif
141 }
142 
143 #if OS(WINDOWS)
144 
145 void* fastAlignedMalloc(size_t alignment, size_t size)
146 {
147     ASSERT_IS_WITHIN_LIMIT(size);
148     void* p = _aligned_malloc(size, alignment);
149     if (UNLIKELY(!p))
150         CRASH();
151     return p;
152 }
153 
154 void* tryFastAlignedMalloc(size_t alignment, size_t size)
155 {
156     FAIL_IF_EXCEEDS_LIMIT(size);
157     return _aligned_malloc(size, alignment);
158 }
159 
160 void fastAlignedFree(void* p)
161 {
162     _aligned_free(p);
163 }
164 
165 #else
166 
167 void* fastAlignedMalloc(size_t alignment, size_t size)
168 {
169     ASSERT_IS_WITHIN_LIMIT(size);
170     void* p = nullptr;
171     posix_memalign(&amp;p, alignment, size);
172     if (UNLIKELY(!p))
173         CRASH();
174     return p;
175 }
176 
177 void* tryFastAlignedMalloc(size_t alignment, size_t size)
178 {
179     FAIL_IF_EXCEEDS_LIMIT(size);
180     void* p = nullptr;
181     posix_memalign(&amp;p, alignment, size);
182     return p;
183 }
184 
185 void fastAlignedFree(void* p)
186 {
187     free(p);
188 }
189 
190 #endif // OS(WINDOWS)
191 
192 TryMallocReturnValue tryFastMalloc(size_t n)
193 {
194     FAIL_IF_EXCEEDS_LIMIT(n);
195     return malloc(n);
196 }
197 
198 void* fastMalloc(size_t n)
199 {
200     ASSERT_IS_WITHIN_LIMIT(n);
201     void* result = malloc(n);
202     if (!result)
203         CRASH();
204 
205     return result;
206 }
207 
208 TryMallocReturnValue tryFastCalloc(size_t n_elements, size_t element_size)
209 {
210     FAIL_IF_EXCEEDS_LIMIT(n_elements * element_size);
211     return calloc(n_elements, element_size);
212 }
213 
214 void* fastCalloc(size_t n_elements, size_t element_size)
215 {
216     ASSERT_IS_WITHIN_LIMIT(n_elements * element_size);
217     void* result = calloc(n_elements, element_size);
218     if (!result)
219         CRASH();
220 
221     return result;
222 }
223 
224 void fastFree(void* p)
225 {
226     free(p);
227 }
228 
229 void* fastRealloc(void* p, size_t n)
230 {
231     ASSERT_IS_WITHIN_LIMIT(n);
232     void* result = realloc(p, n);
233     if (!result)
234         CRASH();
235     return result;
236 }
237 
238 TryMallocReturnValue tryFastRealloc(void* p, size_t n)
239 {
240     FAIL_IF_EXCEEDS_LIMIT(n);
241     return realloc(p, n);
242 }
243 
244 void releaseFastMallocFreeMemory() { }
245 void releaseFastMallocFreeMemoryForThisThread() { }
246 
247 FastMallocStatistics fastMallocStatistics()
248 {
249     FastMallocStatistics statistics = { 0, 0, 0 };
250     return statistics;
251 }
252 
253 size_t fastMallocSize(const void* p)
254 {
255 #if OS(DARWIN)
256     return malloc_size(p);
257 #elif OS(WINDOWS)
258     return _msize(const_cast&lt;void*&gt;(p));
259 #else
260     UNUSED_PARAM(p);
261     return 1;
262 #endif
263 }
264 
265 void fastCommitAlignedMemory(void* ptr, size_t size)
266 {
267     OSAllocator::commit(ptr, size, true, false);
268 }
269 
270 void fastDecommitAlignedMemory(void* ptr, size_t size)
271 {
272     OSAllocator::decommit(ptr, size);
273 }
274 
275 void fastEnableMiniMode() { }
276 
<a name="2" id="anc2"></a><span class="line-added">277 void fastMallocDumpMallocStats() { }</span>
<span class="line-added">278 </span>
279 } // namespace WTF
280 
281 #else // defined(USE_SYSTEM_MALLOC) &amp;&amp; USE_SYSTEM_MALLOC
282 
283 #include &lt;bmalloc/bmalloc.h&gt;
284 
285 namespace WTF {
286 
<a name="3" id="anc3"></a><span class="line-added">287 #define TRACK_MALLOC_CALLSTACK 0</span>
<span class="line-added">288 </span>
<span class="line-added">289 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">290 </span>
<span class="line-added">291 static ThreadSpecificKey avoidRecordingCountKey { InvalidThreadSpecificKey };</span>
<span class="line-added">292 class AvoidRecordingScope {</span>
<span class="line-added">293 public:</span>
<span class="line-added">294     AvoidRecordingScope();</span>
<span class="line-added">295     ~AvoidRecordingScope();</span>
<span class="line-added">296 </span>
<span class="line-added">297     static uintptr_t avoidRecordingCount()</span>
<span class="line-added">298     {</span>
<span class="line-added">299         return bitwise_cast&lt;uintptr_t&gt;(threadSpecificGet(avoidRecordingCountKey));</span>
<span class="line-added">300     }</span>
<span class="line-added">301 };</span>
<span class="line-added">302 </span>
<span class="line-added">303 AvoidRecordingScope::AvoidRecordingScope()</span>
<span class="line-added">304 {</span>
<span class="line-added">305     static std::once_flag onceKey;</span>
<span class="line-added">306     std::call_once(onceKey, [] {</span>
<span class="line-added">307         // The value stored in TLS is initially 0.</span>
<span class="line-added">308         threadSpecificKeyCreate(&amp;avoidRecordingCountKey, [](void*) { });</span>
<span class="line-added">309     });</span>
<span class="line-added">310     threadSpecificSet(avoidRecordingCountKey, bitwise_cast&lt;void*&gt;(avoidRecordingCount() + 1));</span>
<span class="line-added">311 }</span>
<span class="line-added">312 </span>
<span class="line-added">313 AvoidRecordingScope::~AvoidRecordingScope()</span>
<span class="line-added">314 {</span>
<span class="line-added">315     threadSpecificSet(avoidRecordingCountKey, bitwise_cast&lt;void*&gt;(avoidRecordingCount() - 1));</span>
<span class="line-added">316 }</span>
<span class="line-added">317 </span>
<span class="line-added">318 class MallocCallTracker {</span>
<span class="line-added">319 public:</span>
<span class="line-added">320     MallocCallTracker();</span>
<span class="line-added">321 </span>
<span class="line-added">322     void recordMalloc(void*, size_t);</span>
<span class="line-added">323     void recordRealloc(void* oldAddress, void* newAddress, size_t);</span>
<span class="line-added">324     void recordFree(void*);</span>
<span class="line-added">325 </span>
<span class="line-added">326     void dumpStats();</span>
<span class="line-added">327 </span>
<span class="line-added">328     static MallocCallTracker&amp; singleton();</span>
<span class="line-added">329 </span>
<span class="line-added">330 private:</span>
<span class="line-added">331     struct MallocSiteData {</span>
<span class="line-added">332         StackShot stack;</span>
<span class="line-added">333         size_t size;</span>
<span class="line-added">334 </span>
<span class="line-added">335         MallocSiteData(size_t stackSize, size_t allocationSize)</span>
<span class="line-added">336             : stack(stackSize)</span>
<span class="line-added">337             , size(allocationSize)</span>
<span class="line-added">338         {</span>
<span class="line-added">339         }</span>
<span class="line-added">340     };</span>
<span class="line-added">341 </span>
<span class="line-added">342     HashMap&lt;void*, std::unique_ptr&lt;MallocSiteData&gt;&gt; m_addressMallocSiteData;</span>
<span class="line-added">343     Lock m_mutex;</span>
<span class="line-added">344 };</span>
<span class="line-added">345 </span>
<span class="line-added">346 MallocCallTracker&amp; MallocCallTracker::singleton()</span>
<span class="line-added">347 {</span>
<span class="line-added">348     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">349     static NeverDestroyed&lt;MallocCallTracker&gt; tracker;</span>
<span class="line-added">350     return tracker;</span>
<span class="line-added">351 }</span>
<span class="line-added">352 </span>
<span class="line-added">353 </span>
<span class="line-added">354 MallocCallTracker::MallocCallTracker()</span>
<span class="line-added">355 {</span>
<span class="line-added">356     int token;</span>
<span class="line-added">357     notify_register_dispatch(&quot;com.apple.WebKit.dumpUntrackedMallocs&quot;, &amp;token, dispatch_get_main_queue(), ^(int) {</span>
<span class="line-added">358         MallocCallTracker::singleton().dumpStats();</span>
<span class="line-added">359     });</span>
<span class="line-added">360 }</span>
<span class="line-added">361 </span>
<span class="line-added">362 void MallocCallTracker::recordMalloc(void* address, size_t allocationSize)</span>
<span class="line-added">363 {</span>
<span class="line-added">364     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">365 </span>
<span class="line-added">366     // Intentionally using std::make_unique not to use FastMalloc for data structure tracking FastMalloc.</span>
<span class="line-added">367     const size_t stackSize = 10;</span>
<span class="line-added">368     auto siteData = std::make_unique&lt;MallocSiteData&gt;(stackSize, allocationSize);</span>
<span class="line-added">369 </span>
<span class="line-added">370     auto locker = holdLock(m_mutex);</span>
<span class="line-added">371     auto addResult = m_addressMallocSiteData.add(address, WTFMove(siteData));</span>
<span class="line-added">372     UNUSED_PARAM(addResult);</span>
<span class="line-added">373 }</span>
<span class="line-added">374 </span>
<span class="line-added">375 void MallocCallTracker::recordRealloc(void* oldAddress, void* newAddress, size_t newSize)</span>
<span class="line-added">376 {</span>
<span class="line-added">377     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">378 </span>
<span class="line-added">379     auto locker = holdLock(m_mutex);</span>
<span class="line-added">380 </span>
<span class="line-added">381     auto it = m_addressMallocSiteData.find(oldAddress);</span>
<span class="line-added">382     if (it == m_addressMallocSiteData.end()) {</span>
<span class="line-added">383         ASSERT_NOT_REACHED();</span>
<span class="line-added">384         return;</span>
<span class="line-added">385     }</span>
<span class="line-added">386 </span>
<span class="line-added">387     it-&gt;value-&gt;size = newSize;</span>
<span class="line-added">388     if (oldAddress != newAddress) {</span>
<span class="line-added">389         auto value = WTFMove(it-&gt;value);</span>
<span class="line-added">390         m_addressMallocSiteData.remove(it);</span>
<span class="line-added">391         auto addResult = m_addressMallocSiteData.add(newAddress, WTFMove(value));</span>
<span class="line-added">392         ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
<span class="line-added">393     }</span>
<span class="line-added">394 }</span>
<span class="line-added">395 </span>
<span class="line-added">396 void MallocCallTracker::recordFree(void* address)</span>
<span class="line-added">397 {</span>
<span class="line-added">398     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">399 </span>
<span class="line-added">400     auto locker = holdLock(m_mutex);</span>
<span class="line-added">401     bool removed = m_addressMallocSiteData.remove(address);</span>
<span class="line-added">402     UNUSED_PARAM(removed);</span>
<span class="line-added">403 }</span>
<span class="line-added">404 </span>
<span class="line-added">405 void MallocCallTracker::dumpStats()</span>
<span class="line-added">406 {</span>
<span class="line-added">407     AvoidRecordingScope avoidRecording;</span>
<span class="line-added">408 </span>
<span class="line-added">409     {</span>
<span class="line-added">410         auto locker = holdLock(m_mutex);</span>
<span class="line-added">411 </span>
<span class="line-added">412         // Build a hash of stack to address vector</span>
<span class="line-added">413         struct MallocSiteTotals {</span>
<span class="line-added">414             Vector&lt;MallocSiteData*&gt; siteData;</span>
<span class="line-added">415             size_t count { 0 };</span>
<span class="line-added">416             size_t totalSize { 0 };</span>
<span class="line-added">417         };</span>
<span class="line-added">418 </span>
<span class="line-added">419         size_t totalUntrackedSize = 0;</span>
<span class="line-added">420         size_t totalUntrackedCount = 0;</span>
<span class="line-added">421 </span>
<span class="line-added">422         HashMap&lt;unsigned, std::unique_ptr&lt;MallocSiteTotals&gt;&gt; callSiteToMallocData;</span>
<span class="line-added">423         for (const auto&amp; it : m_addressMallocSiteData) {</span>
<span class="line-added">424             auto result = callSiteToMallocData.ensure(it.value-&gt;stack.hash(), [] () {</span>
<span class="line-added">425                 // Intentionally using std::make_unique not to use FastMalloc for data structure tracking FastMalloc.</span>
<span class="line-added">426                 return std::make_unique&lt;MallocSiteTotals&gt;();</span>
<span class="line-added">427             });</span>
<span class="line-added">428             auto&amp; siteTotal = result.iterator-&gt;value;</span>
<span class="line-added">429             siteTotal-&gt;siteData.append(it.value.get());</span>
<span class="line-added">430             ++siteTotal-&gt;count;</span>
<span class="line-added">431             siteTotal-&gt;totalSize += it.value-&gt;size;</span>
<span class="line-added">432             totalUntrackedSize += it.value-&gt;size;</span>
<span class="line-added">433             ++totalUntrackedCount;</span>
<span class="line-added">434         }</span>
<span class="line-added">435 </span>
<span class="line-added">436         Vector&lt;unsigned&gt; stackHashes;</span>
<span class="line-added">437         auto stackKeys = callSiteToMallocData.keys();</span>
<span class="line-added">438         for (auto key : stackKeys)</span>
<span class="line-added">439             stackHashes.append(key);</span>
<span class="line-added">440 </span>
<span class="line-added">441         // Sort by reverse total size.</span>
<span class="line-added">442         std::sort(stackHashes.begin(), stackHashes.end(), [&amp;] (unsigned a, unsigned b) {</span>
<span class="line-added">443             const auto&amp; aSiteTotals = callSiteToMallocData.get(a);</span>
<span class="line-added">444             const auto&amp; bSiteTotals = callSiteToMallocData.get(b);</span>
<span class="line-added">445 </span>
<span class="line-added">446             return aSiteTotals-&gt;totalSize &gt; bSiteTotals-&gt;totalSize;</span>
<span class="line-added">447         });</span>
<span class="line-added">448 </span>
<span class="line-added">449         WTFLogAlways(&quot;Total untracked bytes: %lu (%lu allocations)\n&quot;, totalUntrackedSize, totalUntrackedCount);</span>
<span class="line-added">450 </span>
<span class="line-added">451         const size_t numStacksToDump = 100;</span>
<span class="line-added">452         for (size_t i = 0; i &lt; std::min(numStacksToDump, stackHashes.size()); ++i) {</span>
<span class="line-added">453             const auto&amp; mallocDataForStack = callSiteToMallocData.get(stackHashes[i]);</span>
<span class="line-added">454 </span>
<span class="line-added">455             WTFLogAlways(&quot;Total allocation size: %lu (%lu allocations)\n&quot;, mallocDataForStack-&gt;totalSize, mallocDataForStack-&gt;count);</span>
<span class="line-added">456             // FIXME: Add a way to remove some entries in StackShot in a programable way.</span>
<span class="line-added">457             // https://bugs.webkit.org/show_bug.cgi?id=205701</span>
<span class="line-added">458             const size_t framesToSkip = 6;</span>
<span class="line-added">459             WTFPrintBacktrace(mallocDataForStack-&gt;siteData[0]-&gt;stack.array() + framesToSkip, mallocDataForStack-&gt;siteData[0]-&gt;stack.size() - framesToSkip);</span>
<span class="line-added">460             WTFLogAlways(&quot;\n&quot;);</span>
<span class="line-added">461         }</span>
<span class="line-added">462     }</span>
<span class="line-added">463 }</span>
<span class="line-added">464 void fastMallocDumpMallocStats()</span>
<span class="line-added">465 {</span>
<span class="line-added">466     MallocCallTracker::singleton().dumpStats();</span>
<span class="line-added">467 }</span>
<span class="line-added">468 #else</span>
<span class="line-added">469 void fastMallocDumpMallocStats()</span>
<span class="line-added">470 {</span>
<span class="line-added">471 }</span>
<span class="line-added">472 #endif</span>
<span class="line-added">473 </span>
<span class="line-added">474 </span>
475 bool isFastMallocEnabled()
476 {
477     return bmalloc::api::isEnabled();
478 }
479 
480 void* fastMalloc(size_t size)
481 {
482     ASSERT_IS_WITHIN_LIMIT(size);
<a name="4" id="anc4"></a><span class="line-modified">483     void* result = bmalloc::api::malloc(size);</span>
<span class="line-added">484 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">485     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">486         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="line-added">487 #endif</span>
<span class="line-added">488     return result;</span>
489 }
490 
491 void* fastCalloc(size_t numElements, size_t elementSize)
492 {
493     ASSERT_IS_WITHIN_LIMIT(numElements * elementSize);
494     Checked&lt;size_t&gt; checkedSize = elementSize;
495     checkedSize *= numElements;
496     void* result = fastZeroedMalloc(checkedSize.unsafeGet());
497     if (!result)
498         CRASH();
499     return result;
500 }
501 
502 void* fastRealloc(void* object, size_t size)
503 {
504     ASSERT_IS_WITHIN_LIMIT(size);
<a name="5" id="anc5"></a><span class="line-modified">505     void* result = bmalloc::api::realloc(object, size);</span>
<span class="line-added">506 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">507     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">508         MallocCallTracker::singleton().recordRealloc(object, result, size);</span>
<span class="line-added">509 #endif</span>
<span class="line-added">510     return result;</span>
511 }
512 
513 void fastFree(void* object)
514 {
515     bmalloc::api::free(object);
<a name="6" id="anc6"></a><span class="line-added">516 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">517     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">518         MallocCallTracker::singleton().recordFree(object);</span>
<span class="line-added">519 #endif</span>
520 }
521 
522 size_t fastMallocSize(const void*)
523 {
524     // FIXME: This is incorrect; best fix is probably to remove this function.
525     // Caller currently are all using this for assertion, not to actually check
526     // the size of the allocation, so maybe we can come up with something for that.
527     return 1;
528 }
529 
530 size_t fastMallocGoodSize(size_t size)
531 {
532     return size;
533 }
534 
535 void* fastAlignedMalloc(size_t alignment, size_t size)
536 {
537     ASSERT_IS_WITHIN_LIMIT(size);
<a name="7" id="anc7"></a><span class="line-modified">538     void* result = bmalloc::api::memalign(alignment, size);</span>
<span class="line-added">539 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">540     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">541         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="line-added">542 #endif</span>
<span class="line-added">543     return result;</span>
544 }
545 
546 void* tryFastAlignedMalloc(size_t alignment, size_t size)
547 {
548     FAIL_IF_EXCEEDS_LIMIT(size);
<a name="8" id="anc8"></a><span class="line-modified">549     void* result = bmalloc::api::tryMemalign(alignment, size);</span>
<span class="line-added">550 #if ENABLE(MALLOC_HEAP_BREAKDOWN) &amp;&amp; TRACK_MALLOC_CALLSTACK</span>
<span class="line-added">551     if (!AvoidRecordingScope::avoidRecordingCount())</span>
<span class="line-added">552         MallocCallTracker::singleton().recordMalloc(result, size);</span>
<span class="line-added">553 #endif</span>
<span class="line-added">554     return result;</span>
555 }
556 
557 void fastAlignedFree(void* p)
558 {
559     bmalloc::api::free(p);
560 }
561 
562 TryMallocReturnValue tryFastMalloc(size_t size)
563 {
564     FAIL_IF_EXCEEDS_LIMIT(size);
565     return bmalloc::api::tryMalloc(size);
566 }
567 
568 TryMallocReturnValue tryFastCalloc(size_t numElements, size_t elementSize)
569 {
570     FAIL_IF_EXCEEDS_LIMIT(numElements * elementSize);
571     Checked&lt;size_t, RecordOverflow&gt; checkedSize = elementSize;
572     checkedSize *= numElements;
573     if (checkedSize.hasOverflowed())
574         return nullptr;
575     return tryFastZeroedMalloc(checkedSize.unsafeGet());
576 }
577 
578 TryMallocReturnValue tryFastRealloc(void* object, size_t newSize)
579 {
580     FAIL_IF_EXCEEDS_LIMIT(newSize);
581     return bmalloc::api::tryRealloc(object, newSize);
582 }
583 
584 void releaseFastMallocFreeMemoryForThisThread()
585 {
586     bmalloc::api::scavengeThisThread();
587 }
588 
589 void releaseFastMallocFreeMemory()
590 {
591     bmalloc::api::scavenge();
592 }
593 
594 FastMallocStatistics fastMallocStatistics()
595 {
596 
597     // FIXME: Can bmalloc itself report the stats instead of relying on the OS?
598     FastMallocStatistics statistics;
599     statistics.freeListBytes = 0;
600     statistics.reservedVMBytes = 0;
601 
602 #if OS(WINDOWS)
603     PROCESS_MEMORY_COUNTERS resourceUsage;
604     GetProcessMemoryInfo(GetCurrentProcess(), &amp;resourceUsage, sizeof(resourceUsage));
605     statistics.committedVMBytes = resourceUsage.PeakWorkingSetSize;
606 #elif HAVE(RESOURCE_H)
607     struct rusage resourceUsage;
608     getrusage(RUSAGE_SELF, &amp;resourceUsage);
609 
610 #if OS(DARWIN)
611     statistics.committedVMBytes = resourceUsage.ru_maxrss;
612 #else
613     statistics.committedVMBytes = resourceUsage.ru_maxrss * 1024;
614 #endif // OS(DARWIN)
615 
616 #endif // OS(WINDOWS)
617     return statistics;
618 }
619 
620 void fastCommitAlignedMemory(void* ptr, size_t size)
621 {
622     bmalloc::api::commitAlignedPhysical(ptr, size);
623 }
624 
625 void fastDecommitAlignedMemory(void* ptr, size_t size)
626 {
627     bmalloc::api::decommitAlignedPhysical(ptr, size);
628 }
629 
630 void fastEnableMiniMode()
631 {
632     bmalloc::api::enableMiniMode();
633 }
634 
635 } // namespace WTF
636 
637 #endif // defined(USE_SYSTEM_MALLOC) &amp;&amp; USE_SYSTEM_MALLOC
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
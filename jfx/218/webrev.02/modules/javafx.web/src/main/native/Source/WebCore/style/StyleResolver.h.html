<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleResolver.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSSelector.h&quot;
 25 #include &quot;ElementRuleCollector.h&quot;
 26 #include &quot;InspectorCSSOMWrappers.h&quot;
 27 #include &quot;MatchedDeclarationsCache.h&quot;
 28 #include &quot;MediaQueryEvaluator.h&quot;
 29 #include &quot;RenderStyle.h&quot;
 30 #include &quot;RuleSet.h&quot;
 31 #include &quot;StyleBuilderState.h&quot;
 32 #include &quot;StyleScopeRuleSets.h&quot;
 33 #include &lt;memory&gt;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/RefPtr.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/AtomStringHash.h&gt;
 38 #include &lt;wtf/text/StringHash.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 class CSSStyleSheet;
 43 class Document;
 44 class Element;
 45 class KeyframeList;
 46 class KeyframeValue;
 47 class RuleData;
 48 class RuleSet;
 49 class SelectorFilter;
 50 class Settings;
 51 class StyleRuleKeyframe;
 52 class StyleProperties;
 53 class StyleRule;
 54 class StyleRuleKeyframes;
 55 class StyleRulePage;
 56 class StyleSheet;
 57 class StyleSheetList;
 58 class ViewportStyleResolver;
 59 
 60 // MatchOnlyUserAgentRules is used in media queries, where relative units
 61 // are interpreted according to the document root element style, and styled only
 62 // from the User Agent Stylesheet rules.
 63 
 64 enum class RuleMatchingBehavior: uint8_t {
 65     MatchAllRules,
 66     MatchAllRulesExcludingSMIL,
 67     MatchOnlyUserAgentRules,
 68 };
 69 
 70 namespace Style {
 71 
 72 struct ElementStyle {
 73     ElementStyle(std::unique_ptr&lt;RenderStyle&gt; renderStyle, std::unique_ptr&lt;Relations&gt; relations = { })
 74         : renderStyle(WTFMove(renderStyle))
 75         , relations(WTFMove(relations))
 76     { }
 77 
 78     std::unique_ptr&lt;RenderStyle&gt; renderStyle;
 79     std::unique_ptr&lt;Relations&gt; relations;
 80 };
 81 
 82 class Resolver {
 83     WTF_MAKE_NONCOPYABLE(Resolver); WTF_MAKE_FAST_ALLOCATED;
 84 public:
 85     Resolver(Document&amp;);
 86     ~Resolver();
 87 
 88     ElementStyle styleForElement(const Element&amp;, const RenderStyle* parentStyle, const RenderStyle* parentBoxStyle = nullptr, RuleMatchingBehavior = RuleMatchingBehavior::MatchAllRules, const SelectorFilter* = nullptr);
 89 
 90     void keyframeStylesForAnimation(const Element&amp;, const RenderStyle*, KeyframeList&amp;);
 91 
 92     WEBCORE_EXPORT std::unique_ptr&lt;RenderStyle&gt; pseudoStyleForElement(const Element&amp;, const PseudoElementRequest&amp;, const RenderStyle&amp; parentStyle, const RenderStyle* parentBoxStyle = nullptr, const SelectorFilter* = nullptr);
 93 
 94     std::unique_ptr&lt;RenderStyle&gt; styleForPage(int pageIndex);
 95     std::unique_ptr&lt;RenderStyle&gt; defaultStyleForElement(const Element*);
 96 
 97     Document&amp; document() { return m_document; }
 98     const Document&amp; document() const { return m_document; }
 99     const Settings&amp; settings() const { return m_document.settings(); }
100 
101     void appendAuthorStyleSheets(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;);
102 
103     ScopeRuleSets&amp; ruleSets() { return m_ruleSets; }
104     const ScopeRuleSets&amp; ruleSets() const { return m_ruleSets; }
105 
106     const MediaQueryEvaluator&amp; mediaQueryEvaluator() const { return m_mediaQueryEvaluator; }
107 
108     RenderStyle* overrideDocumentElementStyle() const { return m_overrideDocumentElementStyle; }
109     void setOverrideDocumentElementStyle(RenderStyle* style) { m_overrideDocumentElementStyle = style; }
110 
111     void addCurrentSVGFontFaceRules();
112 
113     std::unique_ptr&lt;RenderStyle&gt; styleForKeyframe(const Element&amp;, const RenderStyle*, const StyleRuleKeyframe*, KeyframeValue&amp;);
114     bool isAnimationNameValid(const String&amp;);
115 
116     // These methods will give back the set of rules that matched for a given element (or a pseudo-element).
117     enum CSSRuleFilter {
118         UAAndUserCSSRules   = 1 &lt;&lt; 1,
119         AuthorCSSRules      = 1 &lt;&lt; 2,
120         EmptyCSSRules       = 1 &lt;&lt; 3,
121         AllButEmptyCSSRules = UAAndUserCSSRules | AuthorCSSRules,
122         AllCSSRules         = AllButEmptyCSSRules | EmptyCSSRules,
123     };
124     Vector&lt;RefPtr&lt;const StyleRule&gt;&gt; styleRulesForElement(const Element*, unsigned rulesToInclude = AllButEmptyCSSRules);
125     Vector&lt;RefPtr&lt;const StyleRule&gt;&gt; pseudoStyleRulesForElement(const Element*, PseudoId, unsigned rulesToInclude = AllButEmptyCSSRules);
126 
127     bool hasSelectorForId(const AtomString&amp;) const;
128     bool hasSelectorForAttribute(const Element&amp;, const AtomString&amp;) const;
129 
130 #if ENABLE(CSS_DEVICE_ADAPTATION)
131     ViewportStyleResolver* viewportStyleResolver() { return m_viewportStyleResolver.get(); }
132 #endif
133 
134     bool hasViewportDependentMediaQueries() const;
135     Optional&lt;DynamicMediaQueryEvaluationChanges&gt; evaluateDynamicMediaQueries();
136 
137     void addKeyframeStyle(Ref&lt;StyleRuleKeyframes&gt;&amp;&amp;);
138 
139     bool usesFirstLineRules() const { return m_ruleSets.features().usesFirstLineRules; }
140     bool usesFirstLetterRules() const { return m_ruleSets.features().usesFirstLetterRules; }
141 
142     void invalidateMatchedDeclarationsCache();
143     void clearCachedDeclarationsAffectedByViewportUnits();
144 
145     InspectorCSSOMWrappers&amp; inspectorCSSOMWrappers() { return m_inspectorCSSOMWrappers; }
146 
147 private:
148     friend class PageRuleCollector;
149 
150     class State {
151     public:
152         State() { }
153         State(const Element&amp;, const RenderStyle* parentStyle, const RenderStyle* documentElementStyle = nullptr);
154 
155     public:
156         const Element* element() const { return m_element; }
157 
158         void setStyle(std::unique_ptr&lt;RenderStyle&gt;);
159         RenderStyle* style() const { return m_style.get(); }
160         std::unique_ptr&lt;RenderStyle&gt; takeStyle() { return WTFMove(m_style); }
161 
162         void setParentStyle(std::unique_ptr&lt;RenderStyle&gt;);
163         const RenderStyle* parentStyle() const { return m_parentStyle; }
164         const RenderStyle* rootElementStyle() const { return m_rootElementStyle; }
165 
166         const RenderStyle* userAgentAppearanceStyle() const { return m_userAgentAppearanceStyle.get(); }
167         void setUserAgentAppearanceStyle(std::unique_ptr&lt;RenderStyle&gt; style) { m_userAgentAppearanceStyle = WTFMove(style); }
168 
169     private:
170         const Element* m_element { nullptr };
171         std::unique_ptr&lt;RenderStyle&gt; m_style;
172         const RenderStyle* m_parentStyle { nullptr };
173         std::unique_ptr&lt;const RenderStyle&gt; m_ownedParentStyle;
174         const RenderStyle* m_rootElementStyle { nullptr };
175 
176         std::unique_ptr&lt;RenderStyle&gt; m_userAgentAppearanceStyle;
177     };
178 
179     BuilderContext builderContext(const State&amp;);
180 
181     enum class UseMatchedDeclarationsCache { Yes, No };
182     void applyMatchedProperties(State&amp;, const MatchResult&amp;, UseMatchedDeclarationsCache = UseMatchedDeclarationsCache::Yes);
183 
184     ScopeRuleSets m_ruleSets;
185 
186     typedef HashMap&lt;AtomStringImpl*, RefPtr&lt;StyleRuleKeyframes&gt;&gt; KeyframesRuleMap;
187     KeyframesRuleMap m_keyframesRuleMap;
188 
189     MediaQueryEvaluator m_mediaQueryEvaluator;
190     std::unique_ptr&lt;RenderStyle&gt; m_rootDefaultStyle;
191 
192     Document&amp; m_document;
193 
194     RenderStyle* m_overrideDocumentElementStyle { nullptr };
195 
196 #if ENABLE(CSS_DEVICE_ADAPTATION)
197     RefPtr&lt;ViewportStyleResolver&gt; m_viewportStyleResolver;
198 #endif
199 
200     InspectorCSSOMWrappers m_inspectorCSSOMWrappers;
201 
202     MatchedDeclarationsCache m_matchedDeclarationsCache;
203 
204     bool m_matchAuthorAndUserStyles { true };
205     // See if we still have crashes where Resolver gets deleted early.
206     bool m_isDeleted { false };
207 };
208 
209 inline bool Resolver::hasSelectorForAttribute(const Element&amp; element, const AtomString &amp;attributeName) const
210 {
211     ASSERT(!attributeName.isEmpty());
212     if (element.isHTMLElement())
213         return m_ruleSets.features().attributeCanonicalLocalNamesInRules.contains(attributeName);
214     return m_ruleSets.features().attributeLocalNamesInRules.contains(attributeName);
215 }
216 
217 inline bool Resolver::hasSelectorForId(const AtomString&amp; idValue) const
218 {
219     ASSERT(!idValue.isEmpty());
220     return m_ruleSets.features().idsInRules.contains(idValue);
221 }
222 
223 } // namespace Style
224 } // namespace WebCore
    </pre>
  </body>
</html>
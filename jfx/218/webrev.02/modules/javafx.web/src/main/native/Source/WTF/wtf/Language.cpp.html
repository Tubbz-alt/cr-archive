<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/Language.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010, 2013, 2016, 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/Language.h&gt;
 28 
 29 #include &lt;wtf/HashMap.h&gt;
 30 #include &lt;wtf/NeverDestroyed.h&gt;
 31 #include &lt;wtf/RetainPtr.h&gt;
 32 #include &lt;wtf/text/WTFString.h&gt;
 33 
 34 #if USE(CF) &amp;&amp; !PLATFORM(WIN)
 35 #include &lt;CoreFoundation/CoreFoundation.h&gt;
 36 #endif
 37 
 38 namespace WTF {
 39 
 40 static Lock userPreferredLanguagesMutex;
 41 
 42 typedef HashMap&lt;void*, LanguageChangeObserverFunction&gt; ObserverMap;
 43 static ObserverMap&amp; observerMap()
 44 {
 45     static NeverDestroyed&lt;ObserverMap&gt; map;
 46     return map.get();
 47 }
 48 
 49 void addLanguageChangeObserver(void* context, LanguageChangeObserverFunction customObserver)
 50 {
 51     observerMap().set(context, customObserver);
 52 }
 53 
 54 void removeLanguageChangeObserver(void* context)
 55 {
 56     ASSERT(observerMap().contains(context));
 57     observerMap().remove(context);
 58 }
 59 
 60 void languageDidChange()
 61 {
 62     for (auto&amp; observer : copyToVector(observerMap())) {
 63         if (observerMap().contains(observer.key))
 64             observer.value(observer.key);
 65     }
 66 }
 67 
 68 String defaultLanguage()
 69 {
 70     Vector&lt;String&gt; languages = userPreferredLanguages();
 71     if (languages.size())
 72         return languages[0];
 73 
 74     return emptyString();
 75 }
 76 
 77 static Vector&lt;String&gt;&amp; preferredLanguagesOverride()
 78 {
 79     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; override;
 80     return override;
 81 }
 82 
 83 Vector&lt;String&gt; userPreferredLanguagesOverride()
 84 {
 85     return preferredLanguagesOverride();
 86 }
 87 
 88 void overrideUserPreferredLanguages(const Vector&lt;String&gt;&amp; override)
 89 {
 90     preferredLanguagesOverride() = override;
 91     languageDidChange();
 92 }
 93 
 94 static Vector&lt;String&gt; isolatedCopy(const Vector&lt;String&gt;&amp; strings)
 95 {
 96     Vector&lt;String&gt; copy;
 97     copy.reserveInitialCapacity(strings.size());
 98     for (auto&amp; language : strings)
 99         copy.uncheckedAppend(language.isolatedCopy());
100     return copy;
101 }
102 
103 Vector&lt;String&gt; userPreferredLanguages()
104 {
105     {
106         std::lock_guard&lt;Lock&gt; lock(userPreferredLanguagesMutex);
107         Vector&lt;String&gt;&amp; override = preferredLanguagesOverride();
108         if (!override.isEmpty())
109             return isolatedCopy(override);
110     }
111 
112     return platformUserPreferredLanguages();
113 }
114 
115 static String canonicalLanguageIdentifier(const String&amp; languageCode)
116 {
117     String lowercaseLanguageCode = languageCode.convertToASCIILowercase();
118 
119     if (lowercaseLanguageCode.length() &gt;= 3 &amp;&amp; lowercaseLanguageCode[2] == &#39;_&#39;)
120         lowercaseLanguageCode.replace(2, 1, &quot;-&quot;);
121 
122     return lowercaseLanguageCode;
123 }
124 
125 size_t indexOfBestMatchingLanguageInList(const String&amp; language, const Vector&lt;String&gt;&amp; languageList, bool&amp; exactMatch)
126 {
127     String lowercaseLanguage = language.convertToASCIILowercase();
128     String languageWithoutLocaleMatch;
129     String languageMatchButNotLocale;
130     size_t languageWithoutLocaleMatchIndex = 0;
131     size_t languageMatchButNotLocaleMatchIndex = 0;
132     bool canMatchLanguageOnly = (lowercaseLanguage.length() == 2 || (lowercaseLanguage.length() &gt;= 3 &amp;&amp; lowercaseLanguage[2] == &#39;-&#39;));
133 
134     for (size_t i = 0; i &lt; languageList.size(); ++i) {
135         String canonicalizedLanguageFromList = canonicalLanguageIdentifier(languageList[i]);
136 
137         if (lowercaseLanguage == canonicalizedLanguageFromList) {
138             exactMatch = true;
139             return i;
140         }
141 
142         if (canMatchLanguageOnly &amp;&amp; canonicalizedLanguageFromList.length() &gt;= 2) {
143             if (lowercaseLanguage[0] == canonicalizedLanguageFromList[0] &amp;&amp; lowercaseLanguage[1] == canonicalizedLanguageFromList[1]) {
144                 if (!languageWithoutLocaleMatch.length() &amp;&amp; canonicalizedLanguageFromList.length() == 2) {
145                     languageWithoutLocaleMatch = languageList[i];
146                     languageWithoutLocaleMatchIndex = i;
147                 }
148                 if (!languageMatchButNotLocale.length() &amp;&amp; canonicalizedLanguageFromList.length() &gt;= 3) {
149                     languageMatchButNotLocale = languageList[i];
150                     languageMatchButNotLocaleMatchIndex = i;
151                 }
152             }
153         }
154     }
155 
156     exactMatch = false;
157 
158     // If we have both a language-only match and a languge-but-not-locale match, return the
159     // languge-only match as is considered a &quot;better&quot; match. For example, if the list
160     // provided has both &quot;en-GB&quot; and &quot;en&quot; and the user prefers &quot;en-US&quot; we will return &quot;en&quot;.
161     if (languageWithoutLocaleMatch.length())
162         return languageWithoutLocaleMatchIndex;
163 
164     if (languageMatchButNotLocale.length())
165         return languageMatchButNotLocaleMatchIndex;
166 
167     return languageList.size();
168 }
169 
170 String displayNameForLanguageLocale(const String&amp; localeName)
171 {
172 #if USE(CF) &amp;&amp; !PLATFORM(WIN)
173     if (!localeName.isEmpty())
174         return adoptCF(CFLocaleCopyDisplayNameForPropertyValue(adoptCF(CFLocaleCopyCurrent()).get(), kCFLocaleIdentifier, localeName.createCFString().get())).get();
175 #endif
176     return localeName;
177 }
178 
179 }
    </pre>
  </body>
</html>
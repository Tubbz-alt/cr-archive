<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeUpdater.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTreePosition.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeUpdaterGeneratedContent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeUpdater.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;CSSAnimationController.h&quot;
 31 #include &quot;ComposedTreeAncestorIterator.h&quot;
 32 #include &quot;ComposedTreeIterator.h&quot;
 33 #include &quot;Document.h&quot;
 34 #include &quot;DocumentTimeline.h&quot;
 35 #include &quot;Element.h&quot;
 36 #include &quot;FullscreenManager.h&quot;
 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;
 40 #include &quot;NodeRenderStyle.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderDescendantIterator.h&quot;
 43 #include &quot;RenderFullScreen.h&quot;
 44 #include &quot;RenderInline.h&quot;
 45 #include &quot;RenderMultiColumnFlow.h&quot;
 46 #include &quot;RenderMultiColumnSet.h&quot;
 47 #include &quot;RenderTreeUpdaterGeneratedContent.h&quot;

 48 #include &quot;RuntimeEnabledFeatures.h&quot;
 49 #include &quot;StyleResolver.h&quot;
 50 #include &quot;StyleTreeResolver.h&quot;

 51 #include &lt;wtf/SystemTracing.h&gt;
 52 







 53 #if PLATFORM(IOS_FAMILY)
 54 #include &quot;ContentChangeObserver.h&quot;
 55 #endif
 56 
 57 namespace WebCore {
 58 
 59 RenderTreeUpdater::Parent::Parent(ContainerNode&amp; root)
 60     : element(is&lt;Document&gt;(root) ? nullptr : downcast&lt;Element&gt;(&amp;root))
 61     , renderTreePosition(RenderTreePosition(*root.renderer()))
 62 {
 63 }
 64 
 65 RenderTreeUpdater::Parent::Parent(Element&amp; element, const Style::ElementUpdates* updates)
 66     : element(&amp;element)
 67     , updates(updates)
 68     , renderTreePosition(element.renderer() ? makeOptional(RenderTreePosition(*element.renderer())) : WTF::nullopt)
 69 {
 70 }
 71 
 72 RenderTreeUpdater::RenderTreeUpdater(Document&amp; document)
</pre>
<hr />
<pre>
256     auto* renderer = element.renderer();
257     if (!renderer)
258         return;
259 
260     m_builder.updateAfterDescendants(*renderer);
261 
262     if (element.hasCustomStyleResolveCallbacks() &amp;&amp; updates &amp;&amp; updates-&gt;update.change == Style::Detach)
263         element.didAttachRenderers();
264 }
265 
266 static bool pseudoStyleCacheIsInvalid(RenderElement* renderer, RenderStyle* newStyle)
267 {
268     const RenderStyle&amp; currentStyle = renderer-&gt;style();
269 
270     const PseudoStyleCache* pseudoStyleCache = currentStyle.cachedPseudoStyles();
271     if (!pseudoStyleCache)
272         return false;
273 
274     for (auto&amp; cache : *pseudoStyleCache) {
275         PseudoId pseudoId = cache-&gt;styleType();
<span class="line-modified">276         std::unique_ptr&lt;RenderStyle&gt; newPseudoStyle = renderer-&gt;getUncachedPseudoStyle(PseudoStyleRequest(pseudoId), newStyle, newStyle);</span>
277         if (!newPseudoStyle)
278             return true;
279         if (*newPseudoStyle != *cache) {
280             newStyle-&gt;addCachedPseudoStyle(WTFMove(newPseudoStyle));
281             return true;
282         }
283     }
284     return false;
285 }
286 
287 void RenderTreeUpdater::updateRendererStyle(RenderElement&amp; renderer, RenderStyle&amp;&amp; newStyle, StyleDifference minimalStyleDifference)
288 {
289     auto oldStyle = RenderStyle::clone(renderer.style());
290     renderer.setStyle(WTFMove(newStyle), minimalStyleDifference);
291     m_builder.normalizeTreeAfterStyleChange(renderer, oldStyle);








292 }
293 
294 void RenderTreeUpdater::updateElementRenderer(Element&amp; element, const Style::ElementUpdate&amp; update)
295 {
296 #if PLATFORM(IOS_FAMILY)
297     ContentChangeObserver::StyleChangeScope observingScope(m_document, element);
298 #endif
299 
300     bool shouldTearDownRenderers = update.change == Style::Detach &amp;&amp; (element.renderer() || element.hasDisplayContents());
301     if (shouldTearDownRenderers) {
302         if (!element.renderer()) {
303             // We may be tearing down a descendant renderer cached in renderTreePosition.
304             renderTreePosition().invalidateNextSibling();
305         }
306 
307         // display:none cancels animations.
308         auto teardownType = update.style-&gt;display() == DisplayType::None ? TeardownType::RendererUpdateCancelingAnimations : TeardownType::RendererUpdate;
309         tearDownRenderers(element, teardownType, m_builder);
310 
311         renderingParent().didCreateOrDestroyChildRenderer = true;
</pre>
<hr />
<pre>
365     if (!newRenderer)
366         return;
367 
368     if (!insertionPosition.parent().isChildAllowed(*newRenderer, newRenderer-&gt;style()))
369         return;
370 
371     element.setRenderer(newRenderer.get());
372 
373     newRenderer-&gt;initializeStyle();
374 
375 #if ENABLE(FULLSCREEN_API)
376     if (m_document.fullscreenManager().isFullscreen() &amp;&amp; m_document.fullscreenManager().currentFullscreenElement() == &amp;element) {
377         newRenderer = RenderFullScreen::wrapNewRenderer(m_builder, WTFMove(newRenderer), insertionPosition.parent(), m_document);
378         if (!newRenderer)
379             return;
380     }
381 #endif
382 
383     m_builder.attach(insertionPosition, WTFMove(newRenderer));
384 




385     if (AXObjectCache* cache = m_document.axObjectCache())
386         cache-&gt;updateCacheAfterNodeIsAttached(&amp;element);
387 }
388 
389 bool RenderTreeUpdater::textRendererIsNeeded(const Text&amp; textNode)
390 {
391     auto&amp; renderingParent = this-&gt;renderingParent();
392     auto&amp; parentRenderer = renderingParent.renderTreePosition-&gt;parent();
393     if (!parentRenderer.canHaveChildren())
394         return false;
395     if (parentRenderer.element() &amp;&amp; !parentRenderer.element()-&gt;childShouldCreateRenderer(textNode))
396         return false;
397     if (textNode.isEditingText())
398         return true;
399     if (!textNode.length())
400         return false;
401     if (!textNode.data().isAllSpecialCharacters&lt;isHTMLSpace&gt;())
402         return true;
403     if (is&lt;RenderText&gt;(renderingParent.previousChildRenderer))
404         return true;
</pre>
<hr />
<pre>
523 void RenderTreeUpdater::tearDownRenderers(Element&amp; root, TeardownType teardownType, RenderTreeBuilder&amp; builder)
524 {
525     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
526 
527     Vector&lt;Element*, 30&gt; teardownStack;
528 
529     auto push = [&amp;] (Element&amp; element) {
530         if (element.hasCustomStyleResolveCallbacks())
531             element.willDetachRenderers();
532         teardownStack.append(&amp;element);
533     };
534 
535     auto&amp; document = root.document();
536     auto* timeline = document.existingTimeline();
537     auto&amp; animationController = document.frame()-&gt;animation();
538 
539     auto pop = [&amp;] (unsigned depth) {
540         while (teardownStack.size() &gt; depth) {
541             auto&amp; element = *teardownStack.takeLast();
542 
<span class="line-modified">543             if (teardownType == TeardownType::Full || teardownType == TeardownType::RendererUpdateCancelingAnimations) {</span>






544                 if (timeline) {
545                     if (document.renderTreeBeingDestroyed())
<span class="line-modified">546                         timeline-&gt;elementWasRemoved(element);</span>
547                     else if (teardownType == TeardownType::RendererUpdateCancelingAnimations)
548                         timeline-&gt;cancelDeclarativeAnimationsForElement(element);
549                 }
550                 animationController.cancelAnimations(element);





551             }
552 
553             if (teardownType == TeardownType::Full)
554                 element.clearHoverAndActiveStatusBeforeDetachingRenderer();
555 
556             GeneratedContent::removeBeforePseudoElement(element, builder);
557             GeneratedContent::removeAfterPseudoElement(element, builder);
558 
559             if (auto* renderer = element.renderer()) {
560                 builder.destroyAndCleanUpAnonymousWrappers(*renderer);
561                 element.setRenderer(nullptr);
562             }
563 
<span class="line-removed">564             // Make sure we don&#39;t leave any renderers behind in nodes outside the composed tree.</span>
<span class="line-removed">565             if (element.shadowRoot())</span>
<span class="line-removed">566                 tearDownLeftoverShadowHostChildren(element, builder);</span>
<span class="line-removed">567 </span>
568             if (element.hasCustomStyleResolveCallbacks())
569                 element.didDetachRenderers();
570         }
571     };
572 
573     push(root);
574 
575     auto descendants = composedTreeDescendants(root);
576     for (auto it = descendants.begin(), end = descendants.end(); it != end; ++it) {
577         pop(it.depth());
578 
579         if (is&lt;Text&gt;(*it)) {
580             tearDownTextRenderer(downcast&lt;Text&gt;(*it), builder);
581             continue;
582         }
583 
584         push(downcast&lt;Element&gt;(*it));
585     }
586 
587     pop(0);
</pre>
</td>
<td>
<hr />
<pre>
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;CSSAnimationController.h&quot;
 31 #include &quot;ComposedTreeAncestorIterator.h&quot;
 32 #include &quot;ComposedTreeIterator.h&quot;
 33 #include &quot;Document.h&quot;
 34 #include &quot;DocumentTimeline.h&quot;
 35 #include &quot;Element.h&quot;
 36 #include &quot;FullscreenManager.h&quot;
 37 #include &quot;HTMLParserIdioms.h&quot;
 38 #include &quot;HTMLSlotElement.h&quot;
 39 #include &quot;InspectorInstrumentation.h&quot;
 40 #include &quot;NodeRenderStyle.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderDescendantIterator.h&quot;
 43 #include &quot;RenderFullScreen.h&quot;
 44 #include &quot;RenderInline.h&quot;
 45 #include &quot;RenderMultiColumnFlow.h&quot;
 46 #include &quot;RenderMultiColumnSet.h&quot;
 47 #include &quot;RenderTreeUpdaterGeneratedContent.h&quot;
<span class="line-added"> 48 #include &quot;RenderView.h&quot;</span>
 49 #include &quot;RuntimeEnabledFeatures.h&quot;
 50 #include &quot;StyleResolver.h&quot;
 51 #include &quot;StyleTreeResolver.h&quot;
<span class="line-added"> 52 #include &quot;TextManipulationController.h&quot;</span>
 53 #include &lt;wtf/SystemTracing.h&gt;
 54 
<span class="line-added"> 55 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 56 #include &quot;FrameView.h&quot;</span>
<span class="line-added"> 57 #include &quot;FrameViewLayoutContext.h&quot;</span>
<span class="line-added"> 58 #include &quot;LayoutState.h&quot;</span>
<span class="line-added"> 59 #include &quot;LayoutTreeBuilder.h&quot;</span>
<span class="line-added"> 60 #endif</span>
<span class="line-added"> 61 </span>
 62 #if PLATFORM(IOS_FAMILY)
 63 #include &quot;ContentChangeObserver.h&quot;
 64 #endif
 65 
 66 namespace WebCore {
 67 
 68 RenderTreeUpdater::Parent::Parent(ContainerNode&amp; root)
 69     : element(is&lt;Document&gt;(root) ? nullptr : downcast&lt;Element&gt;(&amp;root))
 70     , renderTreePosition(RenderTreePosition(*root.renderer()))
 71 {
 72 }
 73 
 74 RenderTreeUpdater::Parent::Parent(Element&amp; element, const Style::ElementUpdates* updates)
 75     : element(&amp;element)
 76     , updates(updates)
 77     , renderTreePosition(element.renderer() ? makeOptional(RenderTreePosition(*element.renderer())) : WTF::nullopt)
 78 {
 79 }
 80 
 81 RenderTreeUpdater::RenderTreeUpdater(Document&amp; document)
</pre>
<hr />
<pre>
265     auto* renderer = element.renderer();
266     if (!renderer)
267         return;
268 
269     m_builder.updateAfterDescendants(*renderer);
270 
271     if (element.hasCustomStyleResolveCallbacks() &amp;&amp; updates &amp;&amp; updates-&gt;update.change == Style::Detach)
272         element.didAttachRenderers();
273 }
274 
275 static bool pseudoStyleCacheIsInvalid(RenderElement* renderer, RenderStyle* newStyle)
276 {
277     const RenderStyle&amp; currentStyle = renderer-&gt;style();
278 
279     const PseudoStyleCache* pseudoStyleCache = currentStyle.cachedPseudoStyles();
280     if (!pseudoStyleCache)
281         return false;
282 
283     for (auto&amp; cache : *pseudoStyleCache) {
284         PseudoId pseudoId = cache-&gt;styleType();
<span class="line-modified">285         std::unique_ptr&lt;RenderStyle&gt; newPseudoStyle = renderer-&gt;getUncachedPseudoStyle({ pseudoId }, newStyle, newStyle);</span>
286         if (!newPseudoStyle)
287             return true;
288         if (*newPseudoStyle != *cache) {
289             newStyle-&gt;addCachedPseudoStyle(WTFMove(newPseudoStyle));
290             return true;
291         }
292     }
293     return false;
294 }
295 
296 void RenderTreeUpdater::updateRendererStyle(RenderElement&amp; renderer, RenderStyle&amp;&amp; newStyle, StyleDifference minimalStyleDifference)
297 {
298     auto oldStyle = RenderStyle::clone(renderer.style());
299     renderer.setStyle(WTFMove(newStyle), minimalStyleDifference);
300     m_builder.normalizeTreeAfterStyleChange(renderer, oldStyle);
<span class="line-added">301 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">302     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">303         if (!m_document.view() || !m_document.view()-&gt;layoutContext().layoutTreeContent())</span>
<span class="line-added">304             return;</span>
<span class="line-added">305         if (auto* layoutBox = m_document.view()-&gt;layoutContext().layoutTreeContent()-&gt;layoutBoxForRenderer(renderer))</span>
<span class="line-added">306             layoutBox-&gt;updateStyle(renderer.style());</span>
<span class="line-added">307     }</span>
<span class="line-added">308 #endif</span>
309 }
310 
311 void RenderTreeUpdater::updateElementRenderer(Element&amp; element, const Style::ElementUpdate&amp; update)
312 {
313 #if PLATFORM(IOS_FAMILY)
314     ContentChangeObserver::StyleChangeScope observingScope(m_document, element);
315 #endif
316 
317     bool shouldTearDownRenderers = update.change == Style::Detach &amp;&amp; (element.renderer() || element.hasDisplayContents());
318     if (shouldTearDownRenderers) {
319         if (!element.renderer()) {
320             // We may be tearing down a descendant renderer cached in renderTreePosition.
321             renderTreePosition().invalidateNextSibling();
322         }
323 
324         // display:none cancels animations.
325         auto teardownType = update.style-&gt;display() == DisplayType::None ? TeardownType::RendererUpdateCancelingAnimations : TeardownType::RendererUpdate;
326         tearDownRenderers(element, teardownType, m_builder);
327 
328         renderingParent().didCreateOrDestroyChildRenderer = true;
</pre>
<hr />
<pre>
382     if (!newRenderer)
383         return;
384 
385     if (!insertionPosition.parent().isChildAllowed(*newRenderer, newRenderer-&gt;style()))
386         return;
387 
388     element.setRenderer(newRenderer.get());
389 
390     newRenderer-&gt;initializeStyle();
391 
392 #if ENABLE(FULLSCREEN_API)
393     if (m_document.fullscreenManager().isFullscreen() &amp;&amp; m_document.fullscreenManager().currentFullscreenElement() == &amp;element) {
394         newRenderer = RenderFullScreen::wrapNewRenderer(m_builder, WTFMove(newRenderer), insertionPosition.parent(), m_document);
395         if (!newRenderer)
396             return;
397     }
398 #endif
399 
400     m_builder.attach(insertionPosition, WTFMove(newRenderer));
401 
<span class="line-added">402     auto* textManipulationController = m_document.textManipulationControllerIfExists();</span>
<span class="line-added">403     if (UNLIKELY(textManipulationController))</span>
<span class="line-added">404         textManipulationController-&gt;didCreateRendererForElement(element);</span>
<span class="line-added">405 </span>
406     if (AXObjectCache* cache = m_document.axObjectCache())
407         cache-&gt;updateCacheAfterNodeIsAttached(&amp;element);
408 }
409 
410 bool RenderTreeUpdater::textRendererIsNeeded(const Text&amp; textNode)
411 {
412     auto&amp; renderingParent = this-&gt;renderingParent();
413     auto&amp; parentRenderer = renderingParent.renderTreePosition-&gt;parent();
414     if (!parentRenderer.canHaveChildren())
415         return false;
416     if (parentRenderer.element() &amp;&amp; !parentRenderer.element()-&gt;childShouldCreateRenderer(textNode))
417         return false;
418     if (textNode.isEditingText())
419         return true;
420     if (!textNode.length())
421         return false;
422     if (!textNode.data().isAllSpecialCharacters&lt;isHTMLSpace&gt;())
423         return true;
424     if (is&lt;RenderText&gt;(renderingParent.previousChildRenderer))
425         return true;
</pre>
<hr />
<pre>
544 void RenderTreeUpdater::tearDownRenderers(Element&amp; root, TeardownType teardownType, RenderTreeBuilder&amp; builder)
545 {
546     WidgetHierarchyUpdatesSuspensionScope suspendWidgetHierarchyUpdates;
547 
548     Vector&lt;Element*, 30&gt; teardownStack;
549 
550     auto push = [&amp;] (Element&amp; element) {
551         if (element.hasCustomStyleResolveCallbacks())
552             element.willDetachRenderers();
553         teardownStack.append(&amp;element);
554     };
555 
556     auto&amp; document = root.document();
557     auto* timeline = document.existingTimeline();
558     auto&amp; animationController = document.frame()-&gt;animation();
559 
560     auto pop = [&amp;] (unsigned depth) {
561         while (teardownStack.size() &gt; depth) {
562             auto&amp; element = *teardownStack.takeLast();
563 
<span class="line-modified">564             // Make sure we don&#39;t leave any renderers behind in nodes outside the composed tree.</span>
<span class="line-added">565             if (element.shadowRoot())</span>
<span class="line-added">566                 tearDownLeftoverShadowHostChildren(element, builder);</span>
<span class="line-added">567 </span>
<span class="line-added">568             switch (teardownType) {</span>
<span class="line-added">569             case TeardownType::Full:</span>
<span class="line-added">570             case TeardownType::RendererUpdateCancelingAnimations:</span>
571                 if (timeline) {
572                     if (document.renderTreeBeingDestroyed())
<span class="line-modified">573                         timeline-&gt;willDestroyRendererForElement(element);</span>
574                     else if (teardownType == TeardownType::RendererUpdateCancelingAnimations)
575                         timeline-&gt;cancelDeclarativeAnimationsForElement(element);
576                 }
577                 animationController.cancelAnimations(element);
<span class="line-added">578                 break;</span>
<span class="line-added">579             case TeardownType::RendererUpdate:</span>
<span class="line-added">580                 if (timeline)</span>
<span class="line-added">581                     timeline-&gt;willChangeRendererForElement(element);</span>
<span class="line-added">582                 break;</span>
583             }
584 
585             if (teardownType == TeardownType::Full)
586                 element.clearHoverAndActiveStatusBeforeDetachingRenderer();
587 
588             GeneratedContent::removeBeforePseudoElement(element, builder);
589             GeneratedContent::removeAfterPseudoElement(element, builder);
590 
591             if (auto* renderer = element.renderer()) {
592                 builder.destroyAndCleanUpAnonymousWrappers(*renderer);
593                 element.setRenderer(nullptr);
594             }
595 




596             if (element.hasCustomStyleResolveCallbacks())
597                 element.didDetachRenderers();
598         }
599     };
600 
601     push(root);
602 
603     auto descendants = composedTreeDescendants(root);
604     for (auto it = descendants.begin(), end = descendants.end(); it != end; ++it) {
605         pop(it.depth());
606 
607         if (is&lt;Text&gt;(*it)) {
608             tearDownTextRenderer(downcast&lt;Text&gt;(*it), builder);
609             continue;
610         }
611 
612         push(downcast&lt;Element&gt;(*it));
613     }
614 
615     pop(0);
</pre>
</td>
</tr>
</table>
<center><a href="RenderTreePosition.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeUpdaterGeneratedContent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
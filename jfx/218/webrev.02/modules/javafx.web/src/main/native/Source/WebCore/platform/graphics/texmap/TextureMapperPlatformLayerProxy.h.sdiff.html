<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerProxy.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextureMapperPlatformLayerProxy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperShaderProgram.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerProxy.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45 class TextureMapperGL;
 46 class TextureMapperLayer;
 47 class TextureMapperPlatformLayerBuffer;
 48 
 49 class TextureMapperPlatformLayerProxy : public ThreadSafeRefCounted&lt;TextureMapperPlatformLayerProxy&gt; {
 50     WTF_MAKE_FAST_ALLOCATED();
 51 public:
 52     class Compositor {
 53     public:
 54         virtual void onNewBufferAvailable() = 0;
 55     };
 56 
 57     TextureMapperPlatformLayerProxy();
 58     virtual ~TextureMapperPlatformLayerProxy();
 59 
 60     // To avoid multiple lock/release situation to update a single frame,
 61     // the implementation of TextureMapperPlatformLayerProxyProvider should
 62     // aquire / release the lock explicitly to use below methods.
 63     Lock&amp; lock() { return m_lock; }
 64     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; getAvailableBuffer(const IntSize&amp;, GLint internalFormat);
<span class="line-modified"> 65     void pushNextBuffer(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt;);</span>
 66     bool isActive();
 67 
 68     WEBCORE_EXPORT void activateOnCompositingThread(Compositor*, TextureMapperLayer*);
 69     WEBCORE_EXPORT void invalidate();
 70 
 71     WEBCORE_EXPORT void swapBuffer();
 72     void dropCurrentBufferWhilePreservingTexture(bool shouldWait = false);
 73 
 74     bool scheduleUpdateOnCompositorThread(Function&lt;void()&gt;&amp;&amp;);
 75 
 76 private:
 77     void appendToUnusedBuffers(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt;);
 78     void scheduleReleaseUnusedBuffers();
 79     void releaseUnusedBuffersTimerFired();
 80 
 81     Compositor* m_compositor;
 82     TextureMapperLayer* m_targetLayer;
 83 
 84     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; m_currentBuffer;
 85     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; m_pendingBuffer;
</pre>
</td>
<td>
<hr />
<pre>
 45 class TextureMapperGL;
 46 class TextureMapperLayer;
 47 class TextureMapperPlatformLayerBuffer;
 48 
 49 class TextureMapperPlatformLayerProxy : public ThreadSafeRefCounted&lt;TextureMapperPlatformLayerProxy&gt; {
 50     WTF_MAKE_FAST_ALLOCATED();
 51 public:
 52     class Compositor {
 53     public:
 54         virtual void onNewBufferAvailable() = 0;
 55     };
 56 
 57     TextureMapperPlatformLayerProxy();
 58     virtual ~TextureMapperPlatformLayerProxy();
 59 
 60     // To avoid multiple lock/release situation to update a single frame,
 61     // the implementation of TextureMapperPlatformLayerProxyProvider should
 62     // aquire / release the lock explicitly to use below methods.
 63     Lock&amp; lock() { return m_lock; }
 64     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; getAvailableBuffer(const IntSize&amp;, GLint internalFormat);
<span class="line-modified"> 65     void pushNextBuffer(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt;&amp;&amp;);</span>
 66     bool isActive();
 67 
 68     WEBCORE_EXPORT void activateOnCompositingThread(Compositor*, TextureMapperLayer*);
 69     WEBCORE_EXPORT void invalidate();
 70 
 71     WEBCORE_EXPORT void swapBuffer();
 72     void dropCurrentBufferWhilePreservingTexture(bool shouldWait = false);
 73 
 74     bool scheduleUpdateOnCompositorThread(Function&lt;void()&gt;&amp;&amp;);
 75 
 76 private:
 77     void appendToUnusedBuffers(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt;);
 78     void scheduleReleaseUnusedBuffers();
 79     void releaseUnusedBuffersTimerFired();
 80 
 81     Compositor* m_compositor;
 82     TextureMapperLayer* m_targetLayer;
 83 
 84     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; m_currentBuffer;
 85     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; m_pendingBuffer;
</pre>
</td>
</tr>
</table>
<center><a href="TextureMapperPlatformLayerProxy.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapperShaderProgram.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBASSEMBLY)
 29 
 30 #include &quot;AirCode.h&quot;
 31 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
 32 #include &quot;B3ArgumentRegValue.h&quot;
 33 #include &quot;B3BasicBlock.h&quot;
 34 #include &quot;B3Const64Value.h&quot;
 35 #include &quot;B3ConstrainedValue.h&quot;
 36 #include &quot;B3MemoryValue.h&quot;
 37 #include &quot;B3PatchpointValue.h&quot;
 38 #include &quot;B3Procedure.h&quot;
 39 #include &quot;B3StackmapGenerationParams.h&quot;
 40 #include &quot;CallFrame.h&quot;
 41 #include &quot;LinkBuffer.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 42 #include &quot;RegisterAtOffsetList.h&quot;</span>
 43 #include &quot;RegisterSet.h&quot;
 44 #include &quot;WasmFormat.h&quot;
 45 #include &quot;WasmSignature.h&quot;
 46 
 47 namespace JSC { namespace Wasm {
 48 
<a name="2" id="anc2"></a><span class="line-modified"> 49 constexpr unsigned numberOfLLIntCalleeSaveRegisters = 2;</span>
 50 
<a name="3" id="anc3"></a><span class="line-modified"> 51 using ArgumentLocation = B3::ValueRep;</span>
<span class="line-modified"> 52 enum class CallRole : uint8_t {</span>
<span class="line-modified"> 53     Caller,</span>
<span class="line-modified"> 54     Callee,</span>
<span class="line-modified"> 55 };</span>
<span class="line-modified"> 56 </span>
<span class="line-modified"> 57 struct CallInformation {</span>
<span class="line-added"> 58     CallInformation(Vector&lt;ArgumentLocation&gt;&amp;&amp; parameters, Vector&lt;ArgumentLocation, 1&gt;&amp;&amp; returnValues, size_t stackOffset)</span>
<span class="line-added"> 59         : params(WTFMove(parameters))</span>
<span class="line-added"> 60         , results(WTFMove(returnValues))</span>
<span class="line-added"> 61         , headerAndArgumentStackSizeInBytes(stackOffset)</span>
<span class="line-added"> 62     { }</span>
<span class="line-added"> 63 </span>
<span class="line-added"> 64     RegisterAtOffsetList computeResultsOffsetList()</span>
 65     {
<a name="4" id="anc4"></a><span class="line-added"> 66         RegisterSet usedResultRegisters;</span>
<span class="line-added"> 67         for (B3::ValueRep rep : results) {</span>
<span class="line-added"> 68             if (rep.isReg())</span>
<span class="line-added"> 69                 usedResultRegisters.set(rep.reg());</span>
<span class="line-added"> 70         }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72         RegisterAtOffsetList savedRegs(usedResultRegisters, RegisterAtOffsetList::ZeroBased);</span>
<span class="line-added"> 73         return savedRegs;</span>
 74     }
 75 
<a name="5" id="anc5"></a><span class="line-added"> 76     bool argumentsIncludeI64 { false };</span>
<span class="line-added"> 77     bool resultsIncludeI64 { false };</span>
<span class="line-added"> 78     Vector&lt;ArgumentLocation&gt; params;</span>
<span class="line-added"> 79     Vector&lt;ArgumentLocation, 1&gt; results;</span>
<span class="line-added"> 80     // As a callee this includes CallerFrameAndPC as a caller it does not.</span>
<span class="line-added"> 81     size_t headerAndArgumentStackSizeInBytes;</span>
<span class="line-added"> 82 };</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 class WasmCallingConvention {</span>
<span class="line-added"> 85 public:</span>
<span class="line-added"> 86     static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88     WasmCallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprs, Vector&lt;Reg&gt;&amp;&amp; fprs, Vector&lt;GPRReg&gt;&amp;&amp; scratches, RegisterSet&amp;&amp; calleeSaves, RegisterSet&amp;&amp; callerSaves)</span>
<span class="line-added"> 89         : gprArgs(WTFMove(gprs))</span>
<span class="line-added"> 90         , fprArgs(WTFMove(fprs))</span>
<span class="line-added"> 91         , prologueScratchGPRs(WTFMove(scratches))</span>
<span class="line-added"> 92         , calleeSaveRegisters(WTFMove(calleeSaves))</span>
<span class="line-added"> 93         , callerSaveRegisters(WTFMove(callerSaves))</span>
<span class="line-added"> 94     { }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     WTF_MAKE_NONCOPYABLE(WasmCallingConvention);</span>
<span class="line-added"> 97 </span>
 98 private:
<a name="6" id="anc6"></a><span class="line-modified"> 99     ArgumentLocation marshallLocationImpl(CallRole role, const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>
100     {
101         if (count &lt; regArgs.size())
<a name="7" id="anc7"></a><span class="line-modified">102             return ArgumentLocation::reg(regArgs[count++]);</span>
103 
104         count++;
<a name="8" id="anc8"></a><span class="line-modified">105         ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);</span>
<span class="line-modified">106         stackOffset += sizeof(Register);</span>
107         return result;
108     }
109 
<a name="9" id="anc9"></a><span class="line-modified">110     ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>
111     {
<a name="10" id="anc10"></a><span class="line-modified">112         ASSERT(isValueType(valueType));</span>
<span class="line-modified">113         switch (valueType) {</span>
<span class="line-modified">114         case I32:</span>
<span class="line-modified">115         case I64:</span>
<span class="line-modified">116         case Funcref:</span>
<span class="line-modified">117         case Anyref:</span>
<span class="line-modified">118             return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">119         case F32:</span>
<span class="line-modified">120         case F64:</span>
<span class="line-added">121             return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);</span>
<span class="line-added">122         default:</span>
123             break;
<a name="11" id="anc11"></a>
124         }
125         RELEASE_ASSERT_NOT_REACHED();
126     }
127 
128 public:
<a name="12" id="anc12"></a><span class="line-modified">129     CallInformation callInformationFor(const Signature&amp; signature, CallRole role = CallRole::Caller) const</span>




































130     {
<a name="13" id="anc13"></a><span class="line-modified">131         bool argumentsIncludeI64 = false;</span>
<span class="line-modified">132         bool resultsIncludeI64 = false;</span>
133         size_t gpArgumentCount = 0;
134         size_t fpArgumentCount = 0;
<a name="14" id="anc14"></a><span class="line-modified">135         size_t argStackOffset = headerSizeInBytes;</span>
<span class="line-added">136         if (role == CallRole::Caller)</span>
<span class="line-added">137             argStackOffset -= sizeof(CallerFrameAndPC);</span>
138 
<a name="15" id="anc15"></a><span class="line-added">139         Vector&lt;ArgumentLocation&gt; params(signature.argumentCount());</span>
140         for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {
<a name="16" id="anc16"></a><span class="line-modified">141             argumentsIncludeI64 |= signature.argument(i) == I64;</span>
<span class="line-modified">142             params[i] = marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, argStackOffset);</span>












143         }
<a name="17" id="anc17"></a><span class="line-modified">144         gpArgumentCount = 0;</span>
<span class="line-modified">145         fpArgumentCount = 0;</span>
<span class="line-modified">146         size_t resultStackOffset = headerSizeInBytes;</span>
<span class="line-modified">147         if (role == CallRole::Caller)</span>
<span class="line-modified">148             resultStackOffset -= sizeof(CallerFrameAndPC);</span>
<span class="line-modified">149 </span>
<span class="line-modified">150         Vector&lt;ArgumentLocation, 1&gt; results(signature.returnCount());</span>
<span class="line-modified">151         for (size_t i = 0; i &lt; signature.returnCount(); ++i) {</span>
<span class="line-modified">152             resultsIncludeI64 |= signature.returnType(i) == I64;</span>
<span class="line-modified">153             results[i] = marshallLocation(role, signature.returnType(i), gpArgumentCount, fpArgumentCount, resultStackOffset);</span>




154         }
155 
<a name="18" id="anc18"></a><span class="line-modified">156         CallInformation result(WTFMove(params), WTFMove(results), std::max(argStackOffset, resultStackOffset));</span>
<span class="line-modified">157         result.argumentsIncludeI64 = argumentsIncludeI64;</span>
<span class="line-modified">158         result.resultsIncludeI64 = resultsIncludeI64;</span>
<span class="line-modified">159         return result;</span>




















160     }
161 
<a name="19" id="anc19"></a><span class="line-modified">162     const Vector&lt;Reg&gt; gprArgs;</span>
<span class="line-modified">163     const Vector&lt;Reg&gt; fprArgs;</span>
<span class="line-modified">164     const Vector&lt;GPRReg&gt; prologueScratchGPRs;</span>
<span class="line-modified">165     const RegisterSet calleeSaveRegisters;</span>
<span class="line-added">166     const RegisterSet callerSaveRegisters;</span>
167 };
168 
<a name="20" id="anc20"></a><span class="line-modified">169 class JSCallingConvention {</span>



170 public:
<a name="21" id="anc21"></a><span class="line-modified">171     static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);</span>
<span class="line-modified">172 </span>
<span class="line-modified">173     // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s</span>
<span class="line-modified">174     // instance as the first JS argument when we&#39;re not using fast TLS to hold the</span>
<span class="line-modified">175     // Wasm::Context*&#39;s instance.</span>
<span class="line-modified">176     static constexpr ptrdiff_t instanceStackOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);</span>











177 
<a name="22" id="anc22"></a><span class="line-modified">178     JSCallingConvention(Vector&lt;Reg&gt;&amp;&amp; gprs, Vector&lt;Reg&gt;&amp;&amp; fprs, RegisterSet&amp;&amp; calleeSaves, RegisterSet&amp;&amp; callerSaves)</span>
<span class="line-added">179         : gprArgs(WTFMove(gprs))</span>
<span class="line-added">180         , fprArgs(WTFMove(fprs))</span>
<span class="line-added">181         , calleeSaveRegisters(WTFMove(calleeSaves))</span>
<span class="line-added">182         , callerSaveRegisters(WTFMove(callerSaves))</span>
<span class="line-added">183     { }</span>
184 
<a name="23" id="anc23"></a><span class="line-added">185     WTF_MAKE_NONCOPYABLE(JSCallingConvention);</span>
186 private:
<a name="24" id="anc24"></a><span class="line-modified">187     ArgumentLocation marshallLocationImpl(CallRole role, const Vector&lt;Reg&gt;&amp; regArgs, size_t&amp; count, size_t&amp; stackOffset) const</span>

188     {
<a name="25" id="anc25"></a><span class="line-modified">189         if (count &lt; regArgs.size())</span>
<span class="line-modified">190             return ArgumentLocation::reg(regArgs[count++]);</span>


191 
192         count++;
<a name="26" id="anc26"></a><span class="line-modified">193         ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);</span>
<span class="line-modified">194         stackOffset += sizeof(Register);</span>
<span class="line-added">195         return result;</span>
196     }
197 
<a name="27" id="anc27"></a><span class="line-modified">198     ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t&amp; gpArgumentCount, size_t&amp; fpArgumentCount, size_t&amp; stackOffset) const</span>

199     {
<a name="28" id="anc28"></a><span class="line-modified">200         ASSERT(isValueType(valueType));</span>
<span class="line-modified">201         switch (valueType) {</span>
<span class="line-modified">202         case I32:</span>
<span class="line-modified">203         case I64:</span>
<span class="line-modified">204         case Funcref:</span>
<span class="line-modified">205         case Anyref:</span>
<span class="line-modified">206             return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);</span>
<span class="line-modified">207         case F32:</span>
<span class="line-modified">208         case F64:</span>
<span class="line-modified">209             return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);</span>

210         default:
<a name="29" id="anc29"></a><span class="line-modified">211             break;</span>
212         }
<a name="30" id="anc30"></a><span class="line-added">213         RELEASE_ASSERT_NOT_REACHED();</span>
214     }
215 
216 public:
<a name="31" id="anc31"></a><span class="line-modified">217     CallInformation callInformationFor(const Signature&amp; signature, CallRole role = CallRole::Callee) const</span>






















218     {
219         size_t gpArgumentCount = 0;
220         size_t fpArgumentCount = 0;
<a name="32" id="anc32"></a><span class="line-modified">221         size_t stackOffset = headerSizeInBytes + sizeof(Register); // Skip the this value since wasm doesn&#39;t use it and we sometimes put the context there.</span>
<span class="line-modified">222         if (role == CallRole::Caller)</span>
<span class="line-modified">223             stackOffset -= sizeof(CallerFrameAndPC);</span>








224 
<a name="33" id="anc33"></a><span class="line-modified">225         Vector&lt;ArgumentLocation&gt; params;</span>
<span class="line-added">226         for (size_t i = 0; i &lt; signature.argumentCount(); ++i)</span>
<span class="line-added">227             params.append(marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset));</span>
228 
<a name="34" id="anc34"></a><span class="line-modified">229         Vector&lt;ArgumentLocation, 1&gt; results { ArgumentLocation::reg(GPRInfo::returnValueGPR) };</span>
<span class="line-modified">230         return CallInformation(WTFMove(params), WTFMove(results), stackOffset);</span>

















231     }
232 
<a name="35" id="anc35"></a><span class="line-modified">233     const Vector&lt;Reg&gt; gprArgs;</span>
<span class="line-modified">234     const Vector&lt;Reg&gt; fprArgs;</span>
<span class="line-modified">235     const RegisterSet calleeSaveRegisters;</span>
<span class="line-modified">236     const RegisterSet callerSaveRegisters;</span>

237 };
238 
<a name="36" id="anc36"></a><span class="line-modified">239 const JSCallingConvention&amp; jsCallingConvention();</span>









240 const WasmCallingConvention&amp; wasmCallingConvention();
241 
<a name="37" id="anc37"></a>




242 } } // namespace JSC::Wasm
243 
244 #endif // ENABLE(WEBASSEMBLY)
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
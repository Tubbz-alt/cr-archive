<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaPlatformLayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NicosiaPaintingEngineThreaded.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NicosiaSceneIntegration.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaPlatformLayer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 95     };
 96 
 97     static Ref&lt;CompositionLayer&gt; create(uint64_t id, const Impl::Factory&amp; factory)
 98     {
 99         return adoptRef(*new CompositionLayer(id, factory));
100     }
101     virtual ~CompositionLayer();
102     bool isCompositionLayer() const override { return true; }
103 
104     Impl&amp; impl() const { return *m_impl; }
105 
106     struct LayerState {
107         struct Delta {
108             Delta() = default;
109 
110             union {
111                 struct {
112                     bool positionChanged : 1;
113                     bool anchorPointChanged : 1;
114                     bool sizeChanged : 1;

115                     bool transformChanged : 1;
116                     bool childrenTransformChanged : 1;
117                     bool contentsRectChanged : 1;
118                     bool contentsTilingChanged : 1;
119                     bool opacityChanged : 1;
120                     bool solidColorChanged : 1;
121                     bool filtersChanged : 1;
122                     bool animationsChanged : 1;
123                     bool childrenChanged : 1;
124                     bool maskChanged : 1;
125                     bool replicaChanged : 1;
126                     bool flagsChanged : 1;
127                     bool contentLayerChanged : 1;
128                     bool backingStoreChanged : 1;
129                     bool imageBackingChanged : 1;
130                     bool animatedBackingStoreClientChanged : 1;
131                     bool repaintCounterChanged : 1;
132                     bool debugBorderChanged : 1;
133                 };
134                 uint32_t value { 0 };
</pre>
<hr />
<pre>
140                 : contentsVisible(true)
141                 , backfaceVisible(true)
142             { }
143 
144             union {
145                 struct {
146                     bool contentsOpaque : 1;
147                     bool drawsContent : 1;
148                     bool contentsVisible : 1;
149                     bool backfaceVisible : 1;
150                     bool masksToBounds : 1;
151                     bool preserves3D : 1;
152                 };
153                 uint32_t value { 0 };
154             };
155         } flags;
156 
157         WebCore::FloatPoint position;
158         WebCore::FloatPoint3D anchorPoint;
159         WebCore::FloatSize size;

160 
161         WebCore::TransformationMatrix transform;
162         WebCore::TransformationMatrix childrenTransform;
163 
164         WebCore::FloatRect contentsRect;
165         WebCore::FloatSize contentsTilePhase;
166         WebCore::FloatSize contentsTileSize;
167 
168         float opacity { 0 };
169         WebCore::Color solidColor;
170 
171         WebCore::FilterOperations filters;
172         // FIXME: Despite the name, this implementation is not
173         // TextureMapper-specific. Should be renamed when necessary.
174         Animations animations;
175 
176         Vector&lt;RefPtr&lt;CompositionLayer&gt;&gt; children;
177         RefPtr&lt;CompositionLayer&gt; replica;
178         RefPtr&lt;CompositionLayer&gt; mask;
179 
</pre>
<hr />
<pre>
198     {
199         LockHolder locker(PlatformLayer::m_state.lock);
200         functor(m_state.pending);
201     }
202 
203     template&lt;typename T&gt;
204     void flushState(const T&amp; functor)
205     {
206         LockHolder locker(PlatformLayer::m_state.lock);
207         auto&amp; pending = m_state.pending;
208         auto&amp; staging = m_state.staging;
209 
210         staging.delta.value |= pending.delta.value;
211 
212         if (pending.delta.positionChanged)
213             staging.position = pending.position;
214         if (pending.delta.anchorPointChanged)
215             staging.anchorPoint = pending.anchorPoint;
216         if (pending.delta.sizeChanged)
217             staging.size = pending.size;


218 
219         if (pending.delta.transformChanged)
220             staging.transform = pending.transform;
221         if (pending.delta.childrenTransformChanged)
222             staging.childrenTransform = pending.childrenTransform;
223 
224         if (pending.delta.contentsRectChanged)
225             staging.contentsRect = pending.contentsRect;
226         if (pending.delta.contentsTilingChanged) {
227             staging.contentsTilePhase = pending.contentsTilePhase;
228             staging.contentsTileSize = pending.contentsTileSize;
229         }
230 
231         if (pending.delta.opacityChanged)
232             staging.opacity = pending.opacity;
233         if (pending.delta.solidColorChanged)
234             staging.solidColor = pending.solidColor;
235 
236         if (pending.delta.filtersChanged)
237             staging.filters = pending.filters;
</pre>
</td>
<td>
<hr />
<pre>
 95     };
 96 
 97     static Ref&lt;CompositionLayer&gt; create(uint64_t id, const Impl::Factory&amp; factory)
 98     {
 99         return adoptRef(*new CompositionLayer(id, factory));
100     }
101     virtual ~CompositionLayer();
102     bool isCompositionLayer() const override { return true; }
103 
104     Impl&amp; impl() const { return *m_impl; }
105 
106     struct LayerState {
107         struct Delta {
108             Delta() = default;
109 
110             union {
111                 struct {
112                     bool positionChanged : 1;
113                     bool anchorPointChanged : 1;
114                     bool sizeChanged : 1;
<span class="line-added">115                     bool boundsOriginChanged : 1;</span>
116                     bool transformChanged : 1;
117                     bool childrenTransformChanged : 1;
118                     bool contentsRectChanged : 1;
119                     bool contentsTilingChanged : 1;
120                     bool opacityChanged : 1;
121                     bool solidColorChanged : 1;
122                     bool filtersChanged : 1;
123                     bool animationsChanged : 1;
124                     bool childrenChanged : 1;
125                     bool maskChanged : 1;
126                     bool replicaChanged : 1;
127                     bool flagsChanged : 1;
128                     bool contentLayerChanged : 1;
129                     bool backingStoreChanged : 1;
130                     bool imageBackingChanged : 1;
131                     bool animatedBackingStoreClientChanged : 1;
132                     bool repaintCounterChanged : 1;
133                     bool debugBorderChanged : 1;
134                 };
135                 uint32_t value { 0 };
</pre>
<hr />
<pre>
141                 : contentsVisible(true)
142                 , backfaceVisible(true)
143             { }
144 
145             union {
146                 struct {
147                     bool contentsOpaque : 1;
148                     bool drawsContent : 1;
149                     bool contentsVisible : 1;
150                     bool backfaceVisible : 1;
151                     bool masksToBounds : 1;
152                     bool preserves3D : 1;
153                 };
154                 uint32_t value { 0 };
155             };
156         } flags;
157 
158         WebCore::FloatPoint position;
159         WebCore::FloatPoint3D anchorPoint;
160         WebCore::FloatSize size;
<span class="line-added">161         WebCore::FloatPoint boundsOrigin;</span>
162 
163         WebCore::TransformationMatrix transform;
164         WebCore::TransformationMatrix childrenTransform;
165 
166         WebCore::FloatRect contentsRect;
167         WebCore::FloatSize contentsTilePhase;
168         WebCore::FloatSize contentsTileSize;
169 
170         float opacity { 0 };
171         WebCore::Color solidColor;
172 
173         WebCore::FilterOperations filters;
174         // FIXME: Despite the name, this implementation is not
175         // TextureMapper-specific. Should be renamed when necessary.
176         Animations animations;
177 
178         Vector&lt;RefPtr&lt;CompositionLayer&gt;&gt; children;
179         RefPtr&lt;CompositionLayer&gt; replica;
180         RefPtr&lt;CompositionLayer&gt; mask;
181 
</pre>
<hr />
<pre>
200     {
201         LockHolder locker(PlatformLayer::m_state.lock);
202         functor(m_state.pending);
203     }
204 
205     template&lt;typename T&gt;
206     void flushState(const T&amp; functor)
207     {
208         LockHolder locker(PlatformLayer::m_state.lock);
209         auto&amp; pending = m_state.pending;
210         auto&amp; staging = m_state.staging;
211 
212         staging.delta.value |= pending.delta.value;
213 
214         if (pending.delta.positionChanged)
215             staging.position = pending.position;
216         if (pending.delta.anchorPointChanged)
217             staging.anchorPoint = pending.anchorPoint;
218         if (pending.delta.sizeChanged)
219             staging.size = pending.size;
<span class="line-added">220         if (pending.delta.boundsOriginChanged)</span>
<span class="line-added">221             staging.boundsOrigin = pending.boundsOrigin;</span>
222 
223         if (pending.delta.transformChanged)
224             staging.transform = pending.transform;
225         if (pending.delta.childrenTransformChanged)
226             staging.childrenTransform = pending.childrenTransform;
227 
228         if (pending.delta.contentsRectChanged)
229             staging.contentsRect = pending.contentsRect;
230         if (pending.delta.contentsTilingChanged) {
231             staging.contentsTilePhase = pending.contentsTilePhase;
232             staging.contentsTileSize = pending.contentsTileSize;
233         }
234 
235         if (pending.delta.opacityChanged)
236             staging.opacity = pending.opacity;
237         if (pending.delta.solidColorChanged)
238             staging.solidColor = pending.solidColor;
239 
240         if (pending.delta.filtersChanged)
241             staging.filters = pending.filters;
</pre>
</td>
</tr>
</table>
<center><a href="NicosiaPaintingEngineThreaded.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NicosiaSceneIntegration.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
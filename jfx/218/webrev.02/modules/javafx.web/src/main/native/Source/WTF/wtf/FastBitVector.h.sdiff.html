<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/FastBitVector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FastBitVector.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/FastBitVector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;string.h&gt;
 29 #include &lt;wtf/Atomics.h&gt;
 30 #include &lt;wtf/FastMalloc.h&gt;
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 
 34 namespace WTF {
 35 
 36 class PrintStream;
 37 
<span class="line-modified"> 38 inline size_t fastBitVectorArrayLength(size_t numBits) { return (numBits + 31) / 32; }</span>


 39 
 40 class FastBitVectorWordView {
 41     WTF_MAKE_FAST_ALLOCATED;
 42 public:
 43     typedef FastBitVectorWordView ViewType;
 44 
 45     FastBitVectorWordView() { }
 46 
 47     FastBitVectorWordView(const uint32_t* array, size_t numBits)
 48         : m_words(array)
 49         , m_numBits(numBits)
 50     {
 51     }
 52 
 53     size_t numBits() const
 54     {
 55         return m_numBits;
 56     }
 57 
 58     uint32_t word(size_t index) const
</pre>
<hr />
<pre>
 70     WTF_MAKE_FAST_ALLOCATED;
 71 public:
 72     typedef FastBitVectorWordView ViewType;
 73 
 74     FastBitVectorWordOwner() = default;
 75 
 76     FastBitVectorWordOwner(FastBitVectorWordOwner&amp;&amp; other)
 77         : m_words(std::exchange(other.m_words, nullptr))
 78         , m_numBits(std::exchange(other.m_numBits, 0))
 79     {
 80     }
 81 
 82     FastBitVectorWordOwner(const FastBitVectorWordOwner&amp; other)
 83     {
 84         *this = other;
 85     }
 86 
 87     ~FastBitVectorWordOwner()
 88     {
 89         if (m_words)
<span class="line-modified"> 90             fastFree(m_words);</span>
 91     }
 92 
 93     FastBitVectorWordView view() const { return FastBitVectorWordView(m_words, m_numBits); }
 94 
 95     FastBitVectorWordOwner&amp; operator=(const FastBitVectorWordOwner&amp; other)
 96     {
 97         if (arrayLength() != other.arrayLength())
 98             setEqualsSlow(other);
 99         else {
100             memcpy(m_words, other.m_words, arrayLength() * sizeof(uint32_t));
101             m_numBits = other.m_numBits;
102         }
103         return *this;
104     }
105 
106     FastBitVectorWordOwner&amp; operator=(FastBitVectorWordOwner&amp;&amp; other)
107     {
108         std::swap(m_words, other.m_words);
109         std::swap(m_numBits, other.m_numBits);
110         return *this;
</pre>
<hr />
<pre>
405     }
406 
407     ALWAYS_INLINE size_t findSetBit(size_t index) const
408     {
409         return findBit(index, true);
410     }
411 
412     ALWAYS_INLINE size_t findClearBit(size_t index) const
413     {
414         return findBit(index, false);
415     }
416 
417     void dump(PrintStream&amp; out) const
418     {
419         for (size_t i = 0; i &lt; numBits(); ++i)
420             out.print((*this)[i] ? &quot;1&quot; : &quot;-&quot;);
421     }
422 
423     typename Words::ViewType wordView() const { return m_words.view(); }
424 



425 private:
426     // You&#39;d think that we could remove this friend if we used protected, but you&#39;d be wrong,
427     // because templates.
428     friend class FastBitVector;
429 
430     bool atImpl(size_t index) const
431     {
432         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
433         return !!(m_words.word(index &gt;&gt; 5) &amp; (1 &lt;&lt; (index &amp; 31)));
434     }
435 
436     Words m_words;
437 };
438 



































439 class FastBitVector : public FastBitVectorImpl&lt;FastBitVectorWordOwner&gt; {
440 public:
441     FastBitVector() { }
442 
443     FastBitVector(const FastBitVector&amp;) = default;
444     FastBitVector&amp; operator=(const FastBitVector&amp;) = default;
445 
446     template&lt;typename OtherWords&gt;
447     FastBitVector(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
448     {
449         *this = other;
450     }
451 
452     template&lt;typename OtherWords&gt;
453     FastBitVector&amp; operator=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
454     {
455         if (UNLIKELY(numBits() != other.numBits()))
456             resize(other.numBits());
457 
458         for (unsigned i = arrayLength(); i--;)
459             m_words.word(i) = other.m_words.word(i);
460         return *this;
461     }
462 
463     void resize(size_t numBits)
464     {
465         m_words.resize(numBits);
466     }
467 
468     void setAll()
469     {
470         m_words.setAll();
471     }
472 
473     void clearAll()
474     {
475         m_words.clearAll();
476     }
477 




478     WTF_EXPORT_PRIVATE void clearRange(size_t begin, size_t end);
479 
480     // Returns true if the contents of this bitvector changed.
481     template&lt;typename OtherWords&gt;
482     bool setAndCheck(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
483     {
484         bool changed = false;
485         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
486         for (unsigned i = arrayLength(); i--;) {
487             changed |= m_words.word(i) != other.m_words.word(i);
488             m_words.word(i) = other.m_words.word(i);
489         }
490         return changed;
491     }
492 
493     template&lt;typename OtherWords&gt;
494     FastBitVector&amp; operator|=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
495     {
496         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
497         for (unsigned i = arrayLength(); i--;)
</pre>
<hr />
<pre>
501 
502     template&lt;typename OtherWords&gt;
503     FastBitVector&amp; operator&amp;=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
504     {
505         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
506         for (unsigned i = arrayLength(); i--;)
507             m_words.word(i) &amp;= other.m_words.word(i);
508         return *this;
509     }
510 
511     bool at(size_t index) const
512     {
513         return atImpl(index);
514     }
515 
516     bool operator[](size_t index) const
517     {
518         return atImpl(index);
519     }
520 
<span class="line-modified">521     class BitReference {</span>
<span class="line-removed">522     public:</span>
<span class="line-removed">523         BitReference() { }</span>
<span class="line-removed">524 </span>
<span class="line-removed">525         BitReference(uint32_t* word, uint32_t mask)</span>
<span class="line-removed">526             : m_word(word)</span>
<span class="line-removed">527             , m_mask(mask)</span>
<span class="line-removed">528         {</span>
<span class="line-removed">529         }</span>
<span class="line-removed">530 </span>
<span class="line-removed">531         explicit operator bool() const</span>
<span class="line-removed">532         {</span>
<span class="line-removed">533             return !!(*m_word &amp; m_mask);</span>
<span class="line-removed">534         }</span>
<span class="line-removed">535 </span>
<span class="line-removed">536         BitReference&amp; operator=(bool value)</span>
<span class="line-removed">537         {</span>
<span class="line-removed">538             if (value)</span>
<span class="line-removed">539                 *m_word |= m_mask;</span>
<span class="line-removed">540             else</span>
<span class="line-removed">541                 *m_word &amp;= ~m_mask;</span>
<span class="line-removed">542             return *this;</span>
<span class="line-removed">543         }</span>
<span class="line-removed">544 </span>
<span class="line-removed">545     private:</span>
<span class="line-removed">546         uint32_t* m_word { nullptr };</span>
<span class="line-removed">547         uint32_t m_mask { 0 };</span>
<span class="line-removed">548     };</span>
<span class="line-removed">549 </span>
<span class="line-removed">550     BitReference at(size_t index)</span>
551     {
552         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
<span class="line-modified">553         return BitReference(&amp;m_words.word(index &gt;&gt; 5), 1 &lt;&lt; (index &amp; 31));</span>
554     }
555 
<span class="line-modified">556     BitReference operator[](size_t index)</span>
557     {
558         return at(index);
559     }
560 
561     // Returns true if the contents changed.
562     ALWAYS_INLINE bool atomicSetAndCheck(size_t index, bool value)
563     {
564         uint32_t* pointer = &amp;m_words.word(index &gt;&gt; 5);
565         uint32_t mask = 1 &lt;&lt; (index &amp; 31);
566         for (;;) {
567             uint32_t oldValue = *pointer;
568             uint32_t newValue;
569             if (value) {
570                 if (oldValue &amp; mask)
571                     return false;
572                 newValue = oldValue | mask;
573             } else {
574                 if (!(oldValue &amp; mask))
575                     return false;
576                 newValue = oldValue &amp; ~mask;
577             }
578             if (atomicCompareExchangeWeakRelaxed(pointer, oldValue, newValue))
579                 return true;
580         }
581     }
582 };
583 
584 } // namespace WTF
585 

586 using WTF::FastBitVector;
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;string.h&gt;
 29 #include &lt;wtf/Atomics.h&gt;
 30 #include &lt;wtf/FastMalloc.h&gt;
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/StdLibExtras.h&gt;
 33 
 34 namespace WTF {
 35 
 36 class PrintStream;
 37 
<span class="line-modified"> 38 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(FastBitVector);</span>
<span class="line-added"> 39 </span>
<span class="line-added"> 40 inline constexpr size_t fastBitVectorArrayLength(size_t numBits) { return (numBits + 31) / 32; }</span>
 41 
 42 class FastBitVectorWordView {
 43     WTF_MAKE_FAST_ALLOCATED;
 44 public:
 45     typedef FastBitVectorWordView ViewType;
 46 
 47     FastBitVectorWordView() { }
 48 
 49     FastBitVectorWordView(const uint32_t* array, size_t numBits)
 50         : m_words(array)
 51         , m_numBits(numBits)
 52     {
 53     }
 54 
 55     size_t numBits() const
 56     {
 57         return m_numBits;
 58     }
 59 
 60     uint32_t word(size_t index) const
</pre>
<hr />
<pre>
 72     WTF_MAKE_FAST_ALLOCATED;
 73 public:
 74     typedef FastBitVectorWordView ViewType;
 75 
 76     FastBitVectorWordOwner() = default;
 77 
 78     FastBitVectorWordOwner(FastBitVectorWordOwner&amp;&amp; other)
 79         : m_words(std::exchange(other.m_words, nullptr))
 80         , m_numBits(std::exchange(other.m_numBits, 0))
 81     {
 82     }
 83 
 84     FastBitVectorWordOwner(const FastBitVectorWordOwner&amp; other)
 85     {
 86         *this = other;
 87     }
 88 
 89     ~FastBitVectorWordOwner()
 90     {
 91         if (m_words)
<span class="line-modified"> 92             FastBitVectorMalloc::free(m_words);</span>
 93     }
 94 
 95     FastBitVectorWordView view() const { return FastBitVectorWordView(m_words, m_numBits); }
 96 
 97     FastBitVectorWordOwner&amp; operator=(const FastBitVectorWordOwner&amp; other)
 98     {
 99         if (arrayLength() != other.arrayLength())
100             setEqualsSlow(other);
101         else {
102             memcpy(m_words, other.m_words, arrayLength() * sizeof(uint32_t));
103             m_numBits = other.m_numBits;
104         }
105         return *this;
106     }
107 
108     FastBitVectorWordOwner&amp; operator=(FastBitVectorWordOwner&amp;&amp; other)
109     {
110         std::swap(m_words, other.m_words);
111         std::swap(m_numBits, other.m_numBits);
112         return *this;
</pre>
<hr />
<pre>
407     }
408 
409     ALWAYS_INLINE size_t findSetBit(size_t index) const
410     {
411         return findBit(index, true);
412     }
413 
414     ALWAYS_INLINE size_t findClearBit(size_t index) const
415     {
416         return findBit(index, false);
417     }
418 
419     void dump(PrintStream&amp; out) const
420     {
421         for (size_t i = 0; i &lt; numBits(); ++i)
422             out.print((*this)[i] ? &quot;1&quot; : &quot;-&quot;);
423     }
424 
425     typename Words::ViewType wordView() const { return m_words.view(); }
426 
<span class="line-added">427     Words&amp; unsafeWords() { return m_words; }</span>
<span class="line-added">428     const Words&amp; unsafeWords() const { return m_words; }</span>
<span class="line-added">429 </span>
430 private:
431     // You&#39;d think that we could remove this friend if we used protected, but you&#39;d be wrong,
432     // because templates.
433     friend class FastBitVector;
434 
435     bool atImpl(size_t index) const
436     {
437         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
438         return !!(m_words.word(index &gt;&gt; 5) &amp; (1 &lt;&lt; (index &amp; 31)));
439     }
440 
441     Words m_words;
442 };
443 
<span class="line-added">444 class FastBitReference {</span>
<span class="line-added">445     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">446 public:</span>
<span class="line-added">447     FastBitReference() = default;</span>
<span class="line-added">448 </span>
<span class="line-added">449     FastBitReference(uint32_t* word, uint32_t mask)</span>
<span class="line-added">450         : m_word(word)</span>
<span class="line-added">451         , m_mask(mask)</span>
<span class="line-added">452     {</span>
<span class="line-added">453     }</span>
<span class="line-added">454 </span>
<span class="line-added">455     operator bool() const</span>
<span class="line-added">456     {</span>
<span class="line-added">457         return !!(*m_word &amp; m_mask);</span>
<span class="line-added">458     }</span>
<span class="line-added">459 </span>
<span class="line-added">460     FastBitReference&amp; operator=(bool value)</span>
<span class="line-added">461     {</span>
<span class="line-added">462         if (value)</span>
<span class="line-added">463             *m_word |= m_mask;</span>
<span class="line-added">464         else</span>
<span class="line-added">465             *m_word &amp;= ~m_mask;</span>
<span class="line-added">466         return *this;</span>
<span class="line-added">467     }</span>
<span class="line-added">468 </span>
<span class="line-added">469     FastBitReference&amp; operator|=(bool value) { return value ? *this = value : *this; }</span>
<span class="line-added">470     FastBitReference&amp; operator&amp;=(bool value) { return value ? *this : *this = value; }</span>
<span class="line-added">471 </span>
<span class="line-added">472 private:</span>
<span class="line-added">473     uint32_t* m_word { nullptr };</span>
<span class="line-added">474     uint32_t m_mask { 0 };</span>
<span class="line-added">475 };</span>
<span class="line-added">476 </span>
<span class="line-added">477 </span>
<span class="line-added">478 </span>
479 class FastBitVector : public FastBitVectorImpl&lt;FastBitVectorWordOwner&gt; {
480 public:
481     FastBitVector() { }
482 
483     FastBitVector(const FastBitVector&amp;) = default;
484     FastBitVector&amp; operator=(const FastBitVector&amp;) = default;
485 
486     template&lt;typename OtherWords&gt;
487     FastBitVector(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
488     {
489         *this = other;
490     }
491 
492     template&lt;typename OtherWords&gt;
493     FastBitVector&amp; operator=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
494     {
495         if (UNLIKELY(numBits() != other.numBits()))
496             resize(other.numBits());
497 
498         for (unsigned i = arrayLength(); i--;)
499             m_words.word(i) = other.m_words.word(i);
500         return *this;
501     }
502 
503     void resize(size_t numBits)
504     {
505         m_words.resize(numBits);
506     }
507 
508     void setAll()
509     {
510         m_words.setAll();
511     }
512 
513     void clearAll()
514     {
515         m_words.clearAll();
516     }
517 
<span class="line-added">518     // For templating as Vector&lt;bool&gt;</span>
<span class="line-added">519     void fill(bool value) { value ? setAll() : clearAll(); }</span>
<span class="line-added">520     void grow(size_t newSize) { resize(newSize); }</span>
<span class="line-added">521 </span>
522     WTF_EXPORT_PRIVATE void clearRange(size_t begin, size_t end);
523 
524     // Returns true if the contents of this bitvector changed.
525     template&lt;typename OtherWords&gt;
526     bool setAndCheck(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
527     {
528         bool changed = false;
529         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
530         for (unsigned i = arrayLength(); i--;) {
531             changed |= m_words.word(i) != other.m_words.word(i);
532             m_words.word(i) = other.m_words.word(i);
533         }
534         return changed;
535     }
536 
537     template&lt;typename OtherWords&gt;
538     FastBitVector&amp; operator|=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
539     {
540         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
541         for (unsigned i = arrayLength(); i--;)
</pre>
<hr />
<pre>
545 
546     template&lt;typename OtherWords&gt;
547     FastBitVector&amp; operator&amp;=(const FastBitVectorImpl&lt;OtherWords&gt;&amp; other)
548     {
549         ASSERT_WITH_SECURITY_IMPLICATION(numBits() == other.numBits());
550         for (unsigned i = arrayLength(); i--;)
551             m_words.word(i) &amp;= other.m_words.word(i);
552         return *this;
553     }
554 
555     bool at(size_t index) const
556     {
557         return atImpl(index);
558     }
559 
560     bool operator[](size_t index) const
561     {
562         return atImpl(index);
563     }
564 
<span class="line-modified">565     FastBitReference at(size_t index)</span>





























566     {
567         ASSERT_WITH_SECURITY_IMPLICATION(index &lt; numBits());
<span class="line-modified">568         return FastBitReference(&amp;m_words.word(index &gt;&gt; 5), 1 &lt;&lt; (index &amp; 31));</span>
569     }
570 
<span class="line-modified">571     FastBitReference operator[](size_t index)</span>
572     {
573         return at(index);
574     }
575 
576     // Returns true if the contents changed.
577     ALWAYS_INLINE bool atomicSetAndCheck(size_t index, bool value)
578     {
579         uint32_t* pointer = &amp;m_words.word(index &gt;&gt; 5);
580         uint32_t mask = 1 &lt;&lt; (index &amp; 31);
581         for (;;) {
582             uint32_t oldValue = *pointer;
583             uint32_t newValue;
584             if (value) {
585                 if (oldValue &amp; mask)
586                     return false;
587                 newValue = oldValue | mask;
588             } else {
589                 if (!(oldValue &amp; mask))
590                     return false;
591                 newValue = oldValue &amp; ~mask;
592             }
593             if (atomicCompareExchangeWeakRelaxed(pointer, oldValue, newValue))
594                 return true;
595         }
596     }
597 };
598 
599 } // namespace WTF
600 
<span class="line-added">601 using WTF::FastBitReference;</span>
602 using WTF::FastBitVector;
</pre>
</td>
</tr>
</table>
<center><a href="FastBitVector.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FastMalloc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryIDBBackingStore.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 58,10 ***</span>
<span class="line-new-header">--- 58,16 ---</span>
  
  namespace WebCore {
  using namespace JSC;
  namespace IDBServer {
  
<span class="line-added">+ constexpr auto objectStoreInfoTableName = &quot;ObjectStoreInfo&quot;_s;</span>
<span class="line-added">+ constexpr auto objectStoreInfoTableNameAlternate = &quot;\&quot;ObjectStoreInfo\&quot;&quot;_s;</span>
<span class="line-added">+ constexpr auto v2ObjectStoreInfoSchema = &quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)&quot;_s;</span>
<span class="line-added">+ constexpr auto v1IndexRecordsRecordIndexSchema = &quot;CREATE INDEX IndexRecordsRecordIndex ON IndexRecords (objectStoreID, objectStoreRecordID)&quot;_s;</span>
<span class="line-added">+ constexpr auto IndexRecordsIndexSchema = &quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (indexID, key, value)&quot;_s;</span>
<span class="line-added">+ </span>
  // Current version of the metadata schema being used in the metadata database.
  static const int currentMetadataVersion = 1;
  
  // The IndexedDatabase spec defines the max key generator value as 2^53.
  static const uint64_t maxGeneratorValue = 0x20000000000000;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,16 ***</span>
  {
      static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;);
      return indexRecordsTableSchemaString;
  }
  
<span class="line-removed">- static const String&amp; v1IndexRecordsIndexSchema()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static NeverDestroyed&lt;WTF::String&gt; indexRecordsIndexSchemaString(&quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (key)&quot;);</span>
<span class="line-removed">-     return indexRecordsIndexSchemaString;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static const String blobRecordsTableSchema(const String&amp; tableName)
  {
      return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)&quot;);
  }
  
<span class="line-new-header">--- 193,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,15 ***</span>
  {
      static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
      return blobFilesTableSchemaString;
  }
  
<span class="line-modified">! SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>
      : m_sessionID(sessionID)
      , m_identifier(identifier)
      , m_databaseRootDirectory(databaseRootDirectory)
<span class="line-removed">-     , m_temporaryFileHandler(fileHandler)</span>
      , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
  {
      m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
  }
  
<span class="line-new-header">--- 227,24 ---</span>
  {
      static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
      return blobFilesTableSchemaString;
  }
  
<span class="line-modified">! static String createV1ObjectStoreInfoSchema(ASCIILiteral tableName)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static String createV2ObjectStoreInfoSchema(ASCIILiteral tableName)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory)</span>
      : m_sessionID(sessionID)
      , m_identifier(identifier)
      , m_databaseRootDirectory(databaseRootDirectory)
      , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
  {
      m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 498,11 ***</span>
  
          int sqliteResult = statement.step();
  
          // If there is no IndexRecordsIndex index at all, create it and then bail.
          if (sqliteResult == SQLITE_DONE) {
<span class="line-modified">!             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsIndexSchema())) {</span>
                  LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
                  return false;
              }
  
              return true;
<span class="line-new-header">--- 507,11 ---</span>
  
          int sqliteResult = statement.step();
  
          // If there is no IndexRecordsIndex index at all, create it and then bail.
          if (sqliteResult == SQLITE_DONE) {
<span class="line-modified">!             if (!m_sqliteDB-&gt;executeCommand(IndexRecordsIndexSchema)) {</span>
                  LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
                  return false;
              }
  
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,14 ***</span>
      }
  
      ASSERT(!currentSchema.isEmpty());
  
      // If the schema in the backing store is the current schema, we&#39;re done.
<span class="line-modified">!     if (currentSchema == v1IndexRecordsIndexSchema())</span>
          return true;
  
<span class="line-removed">-     // There is currently no outdated schema for the IndexRecordsIndex, so any other existing schema means this database is invalid.</span>
      return false;
  }
  
  std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
  {
<span class="line-new-header">--- 526,69 ---</span>
      }
  
      ASSERT(!currentSchema.isEmpty());
  
      // If the schema in the backing store is the current schema, we&#39;re done.
<span class="line-modified">!     if (currentSchema == IndexRecordsIndexSchema)</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Otherwise, update the schema.</span>
<span class="line-added">+     SQLiteTransaction transaction(*m_sqliteDB);</span>
<span class="line-added">+     transaction.begin();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP INDEX IndexRecordsIndex&quot;)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not drop index IndexRecordsIndex in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_sqliteDB-&gt;executeCommand(IndexRecordsIndexSchema)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     transaction.commit();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SQLiteIDBBackingStore::ensureValidIndexRecordsRecordIndex()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(m_sqliteDB);</span>
<span class="line-added">+     ASSERT(m_sqliteDB-&gt;isOpen());</span>
<span class="line-added">+ </span>
<span class="line-added">+     String currentSchema;</span>
<span class="line-added">+     {</span>
<span class="line-added">+         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsRecordIndex&#39;&quot;);</span>
<span class="line-added">+         if (statement.prepare() != SQLITE_OK) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsRecordIndex index.&quot;);</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         int sqliteResult = statement.step();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (sqliteResult == SQLITE_DONE) {</span>
<span class="line-added">+             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsRecordIndexSchema)) {</span>
<span class="line-added">+                 LOG_ERROR(&quot;Could not create IndexRecordsRecordIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+                 return false;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (sqliteResult != SQLITE_ROW) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsRecordIndex index.&quot;);</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         currentSchema = statement.getColumnText(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!currentSchema.isEmpty());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (currentSchema == v1IndexRecordsRecordIndexSchema)</span>
          return true;
  
      return false;
  }
  
  std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 535,11 ***</span>
          LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          closeSQLiteDB();
          return nullptr;
      }
  
<span class="line-modified">!     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {</span>
          LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          closeSQLiteDB();
          return nullptr;
      }
  
<span class="line-new-header">--- 599,11 ---</span>
          LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          closeSQLiteDB();
          return nullptr;
      }
  
<span class="line-modified">!     if (!m_sqliteDB-&gt;executeCommand(v2ObjectStoreInfoSchema)) {</span>
          LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          closeSQLiteDB();
          return nullptr;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,11 ***</span>
          closeSQLiteDB();
          return nullptr;
      }
  
      // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified">!     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>
  }
  
  std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
  {
      ASSERT(m_sqliteDB);
<span class="line-new-header">--- 657,72 ---</span>
          closeSQLiteDB();
          return nullptr;
      }
  
      // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified">!     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0, 0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Optional&lt;IsSchemaUpgraded&gt; SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(m_sqliteDB);</span>
<span class="line-added">+     ASSERT(m_sqliteDB-&gt;isOpen());</span>
<span class="line-added">+ </span>
<span class="line-added">+     String currentSchema;</span>
<span class="line-added">+     {</span>
<span class="line-added">+         // Fetch the schema for ObjectStoreInfo table.</span>
<span class="line-added">+         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE tbl_name=&#39;ObjectStoreInfo&#39;&quot;);</span>
<span class="line-added">+         if (statement.prepare() != SQLITE_OK) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the ObjectStoreInfo table.&quot;);</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         int sqliteResult = statement.step();</span>
<span class="line-added">+         if (sqliteResult != SQLITE_ROW) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Error executing statement to fetch schema for the ObjectStoreInfo table.&quot;);</span>
<span class="line-added">+             return WTF::nullopt;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         currentSchema = statement.getColumnText(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!currentSchema.isEmpty());</span>
<span class="line-added">+     if (currentSchema == v2ObjectStoreInfoSchema || currentSchema == createV2ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate))</span>
<span class="line-added">+         return { IsSchemaUpgraded::No };</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableName) &amp;&amp; currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate)) {</span>
<span class="line-added">+         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable: schema is invalid - %s&quot;, this, currentSchema.utf8().data());</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Drop column maxIndexID from table.</span>
<span class="line-added">+     SQLiteTransaction transaction(*m_sqliteDB);</span>
<span class="line-added">+     transaction.begin();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_sqliteDB-&gt;executeCommand(createV2ObjectStoreInfoSchema(&quot;_Temp_ObjectStoreInfo&quot;_s))) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not create temporary ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO _Temp_ObjectStoreInfo (id, name, keyPath, autoInc) SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo&quot;)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not migrate existing ObjectStoreInfo content (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP TABLE ObjectStoreInfo&quot;)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not drop existing ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_sqliteDB-&gt;executeCommand(&quot;ALTER TABLE _Temp_ObjectStoreInfo RENAME TO ObjectStoreInfo&quot;)) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not rename temporary ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+         return WTF::nullopt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     transaction.commit();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return { IsSchemaUpgraded::Yes };</span>
  }
  
  std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
  {
      ASSERT(m_sqliteDB);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 628,14 ***</span>
              LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
              return nullptr;
          }
      }
  
<span class="line-modified">!     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>
  
      {
<span class="line-modified">!         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);</span>
          if (sql.prepare() != SQLITE_OK)
              return nullptr;
  
          int result = sql.step();
          while (result == SQLITE_ROW) {
<span class="line-new-header">--- 753,20 ---</span>
              LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
              return nullptr;
          }
      }
  
<span class="line-modified">!     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion, 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto result = ensureValidObjectStoreInfoTable();</span>
<span class="line-added">+     if (!result)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool shouldUpdateIndexID = (result.value() == IsSchemaUpgraded::Yes);</span>
  
      {
<span class="line-modified">!         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo;&quot;_s);</span>
          if (sql.prepare() != SQLITE_OK)
              return nullptr;
  
          int result = sql.step();
          while (result == SQLITE_ROW) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,14 ***</span>
              LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
              return nullptr;
          }
      }
  
      {
          SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
<span class="line-modified">!         if (sql.prepare() != SQLITE_OK)</span>
              return nullptr;
  
          int result = sql.step();
          while (result == SQLITE_ROW) {
              uint64_t indexID = sql.getColumnInt64(0);
              String indexName = sql.getColumnText(1);
<span class="line-new-header">--- 793,18 ---</span>
              LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
              return nullptr;
          }
      }
  
<span class="line-added">+     uint64_t maxIndexID = 0;</span>
<span class="line-added">+     HashMap&lt;std::pair&lt;uint64_t, uint64_t&gt;, uint64_t&gt; indexIDMap;</span>
      {
          SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
<span class="line-modified">!         if (sql.prepare() != SQLITE_OK) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Unable to prepare statement to fetch records from the IndexInfo table.&quot;);</span>
              return nullptr;
<span class="line-added">+         }</span>
  
          int result = sql.step();
          while (result == SQLITE_ROW) {
              uint64_t indexID = sql.getColumnInt64(0);
              String indexName = sql.getColumnText(1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 695,19 ***</span>
<span class="line-new-header">--- 830,51 ---</span>
              if (!objectStore) {
                  LOG_ERROR(&quot;Found index referring to a non-existant object store&quot;);
                  return nullptr;
              }
  
<span class="line-added">+             if (shouldUpdateIndexID) {</span>
<span class="line-added">+                 indexIDMap.set({ objectStoreID, indexID }, ++maxIndexID);</span>
<span class="line-added">+                 indexID = maxIndexID;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              objectStore-&gt;addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });
<span class="line-added">+             maxIndexID = maxIndexID &lt; indexID ? indexID : maxIndexID;</span>
  
              result = sql.step();
          }
  
          if (result != SQLITE_DONE) {
              LOG_ERROR(&quot;Error fetching index info from database on disk&quot;);
              return nullptr;
          }
<span class="line-added">+         databaseInfo-&gt;setMaxIndexID(maxIndexID);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!shouldUpdateIndexID)</span>
<span class="line-added">+             return databaseInfo;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (auto&amp; entry : indexIDMap) {</span>
<span class="line-added">+             SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IndexInfo SET id = ? WHERE id = ? AND objectStoreID = ?;&quot;_s);</span>
<span class="line-added">+             if (sql.prepare() != SQLITE_OK</span>
<span class="line-added">+                 || sql.bindInt64(1, entry.value) != SQLITE_OK</span>
<span class="line-added">+                 || sql.bindInt64(2, entry.key.second) != SQLITE_OK</span>
<span class="line-added">+                 || sql.bindInt64(3, entry.key.first) != SQLITE_OK</span>
<span class="line-added">+                 || sql.step() != SQLITE_DONE) {</span>
<span class="line-added">+                 LOG_ERROR(&quot;Unable to update id of IndexInfo table&quot;);</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             SQLiteStatement recordSql(*m_sqliteDB, &quot;UPDATE IndexRecords SET indexID = ? WHERE indexID = ? AND objectStoreID = ?;&quot;_s);</span>
<span class="line-added">+             if (recordSql.prepare() != SQLITE_OK</span>
<span class="line-added">+                 || recordSql.bindInt64(1, entry.value) != SQLITE_OK</span>
<span class="line-added">+                 || recordSql.bindInt64(2, entry.key.second) != SQLITE_OK</span>
<span class="line-added">+                 || recordSql.bindInt64(3, entry.key.first) != SQLITE_OK</span>
<span class="line-added">+                 || recordSql.step() != SQLITE_DONE) {</span>
<span class="line-added">+                 LOG_ERROR(&quot;Unable to update indexID of IndexRecords table&quot;);</span>
<span class="line-added">+                 return nullptr;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
      return databaseInfo;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 822,10 ***</span>
<span class="line-new-header">--- 989,16 ---</span>
          LOG_ERROR(&quot;Error creating or migrating Index Records index in database&quot;);
          closeSQLiteDB();
          return IDBError { UnknownError, &quot;Error creating or migrating Index Records index in database&quot;_s };
      }
  
<span class="line-added">+     if (!ensureValidIndexRecordsRecordIndex()) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Error creating or migrating Index Records second index for in database&quot;);</span>
<span class="line-added">+         closeSQLiteDB();</span>
<span class="line-added">+         return IDBError { UnknownError, &quot;Error creating or migrating Index Records second index in database&quot;_s };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (!ensureValidBlobTables()) {
          LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
          closeSQLiteDB();
          return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 853,16 ***</span>
              diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
      }
      return diskUsage;
  }
  
<span class="line-removed">- uint64_t SQLiteIDBBackingStore::databaseSize() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!isMainThread());</span>
<span class="line-removed">-     return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
  
      ASSERT(m_sqliteDB);
<span class="line-new-header">--- 1026,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 957,17 ***</span>
          LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
      }
  
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);&quot;_s);</span>
          if (!sql
              || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
              || sql-&gt;bindText(2, info.name()) != SQLITE_OK
              || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
              || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
<span class="line-removed">-             || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK</span>
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
          }
      }
<span class="line-new-header">--- 1124,16 ---</span>
          LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
      }
  
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?);&quot;_s);</span>
          if (!sql
              || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
              || sql-&gt;bindText(2, info.name()) != SQLITE_OK
              || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
              || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1194,12 ***</span>
          return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
      }
  
      while (!cursor-&gt;currentKey().isNull()) {
          auto&amp; key = cursor-&gt;currentKey();
<span class="line-modified">!         auto* value = cursor-&gt;currentValue();</span>
<span class="line-modified">!         ThreadSafeDataBuffer valueBuffer = value ? value-&gt;data() : ThreadSafeDataBuffer();</span>
  
          ASSERT(cursor-&gt;currentRecordRowID());
  
          IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
          if (!error.isNull()) {
<span class="line-new-header">--- 1360,12 ---</span>
          return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
      }
  
      while (!cursor-&gt;currentKey().isNull()) {
          auto&amp; key = cursor-&gt;currentKey();
<span class="line-modified">!         auto value = cursor-&gt;currentValue();</span>
<span class="line-modified">!         ThreadSafeDataBuffer valueBuffer = value.data();</span>
  
          ASSERT(cursor-&gt;currentRecordRowID());
  
          IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
          if (!error.isNull()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1228,10 ***</span>
<span class="line-new-header">--- 1394,11 ---</span>
      }
  
      auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
      ASSERT(objectStore);
      objectStore-&gt;addExistingIndex(info);
<span class="line-added">+     m_databaseInfo-&gt;setMaxIndexID(info.identifier());</span>
  
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1242,15 ***</span>
      if (!indexKeyBuffer) {
          LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
      }
  
<span class="line-modified">!     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
      if (!sql
          || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">!         || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK</span>
<span class="line-removed">-         || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {</span>
          LOG_ERROR(&quot;Error checking for index record in database&quot;);
          return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
      }
  
      int sqlResult = sql-&gt;step();
<span class="line-new-header">--- 1409,14 ---</span>
      if (!indexKeyBuffer) {
          LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
      }
  
<span class="line-modified">!     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
      if (!sql
          || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">!         || sql-&gt;bindBlob(2, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {</span>
          LOG_ERROR(&quot;Error checking for index record in database&quot;);
          return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
      }
  
      int sqlResult = sql-&gt;step();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1364,14 ***</span>
              return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
          }
      }
  
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;&quot;_s);</span>
          if (!sql
              || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
<span class="line-removed">-             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK</span>
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
          }
      }
<span class="line-new-header">--- 1530,13 ---</span>
              return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
          }
      }
  
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ?;&quot;_s);</span>
          if (!sql
              || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1521,14 ***</span>
      if (!keyBuffer) {
          LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
      }
  
<span class="line-modified">!     // Get the record ID</span>
      int64_t recordID;
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::GetObjectStoreRecordID, &quot;SELECT recordID FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
  
          if (!sql
              || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
              || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
              LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
<span class="line-new-header">--- 1686,15 ---</span>
      if (!keyBuffer) {
          LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
      }
  
<span class="line-modified">!     // Get the record ID and value.</span>
      int64_t recordID;
<span class="line-added">+     ThreadSafeDataBuffer value;</span>
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::GetObjectStoreRecord, &quot;SELECT recordID, value FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
  
          if (!sql
              || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
              || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
              LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1545,10 ***</span>
<span class="line-new-header">--- 1711,14 ---</span>
              LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (unable to fetch record ID) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
          }
  
          recordID = sql-&gt;getColumnInt64(0);
<span class="line-added">+ </span>
<span class="line-added">+         Vector&lt;uint8_t&gt; valueBuffer;</span>
<span class="line-added">+         sql-&gt;getColumnBlobAsVector(1, valueBuffer);</span>
<span class="line-added">+         value = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));</span>
      }
  
      if (recordID &lt; 1) {
          LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (record ID is invalid) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
          return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1583,15 ***</span>
          }
      }
  
      // Delete record from indexes store
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);</span>
  
          if (!sql
              || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
<span class="line-modified">!             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK</span>
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
          }
      }
<span class="line-new-header">--- 1753,15 ---</span>
          }
      }
  
      // Delete record from indexes store
      {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;&quot;_s);</span>
  
          if (!sql
              || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
<span class="line-modified">!             || sql-&gt;bindInt64(2, recordID) != SQLITE_OK</span>
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
              return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1701,17 ***</span>
  
          anyRecordsSucceeded = true;
      }
  
      if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
<span class="line-modified">!         RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(key);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);</span>
  
          if (!sql
              || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">!             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK</span>
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
              return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
          }
      }
<span class="line-new-header">--- 1871,15 ---</span>
  
          anyRecordsSucceeded = true;
      }
  
      if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
<span class="line-modified">!         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;&quot;_s);</span>
  
          if (!sql
              || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">!             || sql-&gt;bindInt64(2, recordID) != SQLITE_OK</span>
              || sql-&gt;step() != SQLITE_DONE) {
              LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
              return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2180,11 ***</span>
          targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
      while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
          IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();
          result.addKey(WTFMove(keyCopy));
          if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
<span class="line-modified">!             result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());</span>
  
          ++currentCount;
          cursor-&gt;advance(1);
      }
  
<span class="line-new-header">--- 2348,11 ---</span>
          targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
      while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
          IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();
          result.addKey(WTFMove(keyCopy));
          if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
<span class="line-modified">!             result.addValue(IDBValue(cursor-&gt;currentValue()));</span>
  
          ++currentCount;
          cursor-&gt;advance(1);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2227,11 ***</span>
          if (type == IndexedDB::IndexRecordType::Key)
              getResult = { cursor-&gt;currentPrimaryKey() };
          else {
              auto* objectStoreInfo = infoForObjectStore(objectStoreID);
              ASSERT(objectStoreInfo);
<span class="line-modified">!             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), objectStoreInfo-&gt;keyPath() };</span>
          }
      }
  
      return IDBError { };
  }
<span class="line-new-header">--- 2395,11 ---</span>
          if (type == IndexedDB::IndexRecordType::Key)
              getResult = { cursor-&gt;currentPrimaryKey() };
          else {
              auto* objectStoreInfo = infoForObjectStore(objectStoreID);
              ASSERT(objectStoreInfo);
<span class="line-modified">!             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), IDBValue(cursor-&gt;currentValue()), objectStoreInfo-&gt;keyPath() };</span>
          }
      }
  
      return IDBError { };
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2246,16 ***</span>
      if (!buffer) {
          LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
      }
  
<span class="line-modified">!     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);</span>
  
      if (!sql
          || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
<span class="line-modified">!         || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK</span>
<span class="line-removed">-         || sql-&gt;bindBlob(3, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
          LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
          return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
      }
  
      int result = sql-&gt;step();
<span class="line-new-header">--- 2414,15 ---</span>
      if (!buffer) {
          LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
          return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
      }
  
<span class="line-modified">!     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.objectStoreID = IndexRecords.objectStoreID AND Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);</span>
  
      if (!sql
          || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
<span class="line-modified">!         || sql-&gt;bindBlob(2, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
          LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
          return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
      }
  
      int result = sql-&gt;step();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2302,25 ***</span>
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
<span class="line-removed">-     outCount = 0;</span>
<span class="line-removed">- </span>
      auto* transaction = m_transactions.get(transactionIdentifier);
      if (!transaction || !transaction-&gt;inProgress())
          return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
  
<span class="line-modified">!     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);</span>
<span class="line-modified">!     if (!cursor) {</span>
<span class="line-modified">!         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);</span>
<span class="line-modified">!         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };</span>
      }
  
<span class="line-modified">!     while (cursor-&gt;advance(1))</span>
<span class="line-modified">!         ++outCount;</span>
  
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
  {
<span class="line-new-header">--- 2469,82 ---</span>
  {
      LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
      ASSERT(m_sqliteDB);
      ASSERT(m_sqliteDB-&gt;isOpen());
  
      auto* transaction = m_transactions.get(transactionIdentifier);
      if (!transaction || !transaction-&gt;inProgress())
          return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
  
<span class="line-modified">!     outCount = 0;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto lowerKey = range.lowerKey.isNull() ? IDBKeyData::minimum() : range.lowerKey;</span>
<span class="line-modified">!     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(lowerKey);</span>
<span class="line-added">+     if (!lowerBuffer) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);</span>
<span class="line-added">+         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range for count operation&quot;_s };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto upperKey = range.upperKey.isNull() ? IDBKeyData::maximum() : range.upperKey;</span>
<span class="line-added">+     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(upperKey);</span>
<span class="line-added">+     if (!upperBuffer) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);</span>
<span class="line-added">+         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range for count operation&quot;_s };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     SQLiteStatement* statement = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!indexIdentifier) {</span>
<span class="line-added">+         static const char* const countLowerOpenUpperOpenRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+         static const char* const countLowerOpenUpperClosedRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+         static const char* const countLowerClosedUpperOpenRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+         static const char* const countLowerClosedUpperClosedRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenRecords);</span>
<span class="line-added">+         else if (range.lowerOpen &amp;&amp; !range.upperOpen)</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedRecords);</span>
<span class="line-added">+         else if (!range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenRecords);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedRecords);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!statement</span>
<span class="line-added">+             || statement-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK</span>
<span class="line-added">+             || statement-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK</span>
<span class="line-added">+             || statement-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Could not count records in object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+             return IDBError { UnknownError, &quot;Unable to count records in object store due to binding failure&quot;_s };</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         static const char* const countLowerOpenUpperOpenIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+         static const char* const countLowerOpenUpperClosedIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+         static const char* const countLowerClosedUpperOpenIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+         static const char* const countLowerClosedUpperClosedIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenIndexRecords);</span>
<span class="line-added">+         else if (range.lowerOpen &amp;&amp; !range.upperOpen)</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedIndexRecords);</span>
<span class="line-added">+         else if (!range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenIndexRecords);</span>
<span class="line-added">+         else</span>
<span class="line-added">+             statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedIndexRecords);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (!statement</span>
<span class="line-added">+             || statement-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK</span>
<span class="line-added">+             || statement-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK</span>
<span class="line-added">+             || statement-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Could not count records with index %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">+             return IDBError { UnknownError, &quot;Unable to count records for index due to binding failure&quot;_s };</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     if (statement-&gt;step() != SQLITE_ROW)</span>
<span class="line-modified">!         return IDBError { UnknownError, &quot;Unable to count records&quot;_s };</span>
  
<span class="line-added">+     outCount = statement-&gt;getColumnInt(0);</span>
      return IDBError { };
  }
  
  IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2491,30 ***</span>
              LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
              return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
          }
      }
  
<span class="line-modified">!     auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());</span>
<span class="line-modified">!     ASSERT(objectStoreInfo);</span>
<span class="line-modified">!     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());</span>
<span class="line-removed">-     return IDBError { };</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::prefetchCursor&quot;);</span>
  
<span class="line-modified">!     ASSERT(m_sqliteDB);</span>
<span class="line-modified">!     ASSERT(m_sqliteDB-&gt;isOpen());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto* cursor = m_cursors.get(cursorIdentifier);</span>
<span class="line-removed">-     if (!cursor || !cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);</span>
  
<span class="line-modified">!     return cursor-&gt;prefetch();</span>
  }
  
  IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
  {
      ASSERT(m_databaseInfo);
<span class="line-new-header">--- 2715,22 ---</span>
              LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
              return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
          }
      }
  
<span class="line-modified">!     if (data.option == IndexedDB::CursorIterateOption::Reply) {</span>
<span class="line-modified">!         auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());</span>
<span class="line-modified">!         ASSERT(objectStoreInfo);</span>
  
<span class="line-modified">!         bool shouldPrefetch = key.isNull() &amp;&amp; primaryKey.isNull();</span>
<span class="line-modified">!         if (shouldPrefetch)</span>
<span class="line-modified">!             cursor-&gt;prefetch();</span>
  
<span class="line-modified">!         cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath(), shouldPrefetch ? SQLiteIDBCursor::ShouldIncludePrefetchedRecords::Yes : SQLiteIDBCursor::ShouldIncludePrefetchedRecords::No);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     return IDBError { };</span>
  }
  
  IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
  {
      ASSERT(m_databaseInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2569,11 ***</span>
      m_cursors.remove(cursor.identifier());
  }
  
  SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
  {
<span class="line-modified">!     if (sql &gt;= SQL::Count) {</span>
          LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
          return nullptr;
      }
  
      if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
<span class="line-new-header">--- 2785,11 ---</span>
      m_cursors.remove(cursor.identifier());
  }
  
  SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
  {
<span class="line-modified">!     if (sql &gt;= SQL::Invalid) {</span>
          LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
          return nullptr;
      }
  
      if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2596,11 ***</span>
      closeSQLiteDB();
  }
  
  void SQLiteIDBBackingStore::closeSQLiteDB()
  {
<span class="line-modified">!     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)</span>
          m_cachedStatements[i] = nullptr;
  
      if (m_sqliteDB)
          m_sqliteDB-&gt;close();
  
<span class="line-new-header">--- 2812,11 ---</span>
      closeSQLiteDB();
  }
  
  void SQLiteIDBBackingStore::closeSQLiteDB()
  {
<span class="line-modified">!     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Invalid); ++i)</span>
          m_cachedStatements[i] = nullptr;
  
      if (m_sqliteDB)
          m_sqliteDB-&gt;close();
  
</pre>
<center><a href="MemoryIDBBackingStore.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGL2RenderingContext.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGL2RenderingContext.idl.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,195 ***</span>
  class WebGLVertexArrayObject;
  
  class WebGL2RenderingContext final : public WebGLRenderingContextBase {
      WTF_MAKE_ISO_ALLOCATED(WebGL2RenderingContext);
  public:
<span class="line-modified">!     static std::unique_ptr&lt;WebGL2RenderingContext&gt; create(CanvasBase&amp;, GraphicsContext3DAttributes);</span>
<span class="line-modified">!     static std::unique_ptr&lt;WebGL2RenderingContext&gt; create(CanvasBase&amp;, Ref&lt;GraphicsContext3D&gt;&amp;&amp;, GraphicsContext3DAttributes);</span>
  
      // Buffer objects
      using WebGLRenderingContextBase::bufferData;
      using WebGLRenderingContextBase::bufferSubData;
<span class="line-modified">!     void bufferData(GC3Denum target, const ArrayBufferView&amp; data, GC3Denum usage, GC3Duint srcOffset, GC3Duint length);</span>
<span class="line-modified">!     void bufferSubData(GC3Denum target, long long offset, const ArrayBufferView&amp; data, GC3Duint srcOffset, GC3Duint length);</span>
<span class="line-modified">!     void copyBufferSubData(GC3Denum readTarget, GC3Denum writeTarget, GC3Dint64 readOffset, GC3Dint64 writeOffset, GC3Dint64 size);</span>
<span class="line-modified">!     void getBufferSubData(GC3Denum target, long long srcByteOffset, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; dstData, GC3Duint dstOffset = 0, GC3Duint length = 0);</span>
  
      // Framebuffer objects
<span class="line-modified">!     WebGLAny getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname) final;</span>
<span class="line-modified">!     void blitFramebuffer(GC3Dint srcX0, GC3Dint srcY0, GC3Dint srcX1, GC3Dint srcY1, GC3Dint dstX0, GC3Dint dstY0, GC3Dint dstX1, GC3Dint dstY1, GC3Dbitfield mask, GC3Denum filter);</span>
<span class="line-modified">!     void framebufferTextureLayer(GC3Denum target, GC3Denum attachment, WebGLTexture*, GC3Dint level, GC3Dint layer);</span>
<span class="line-modified">!     WebGLAny getInternalformatParameter(GC3Denum target, GC3Denum internalformat, GC3Denum pname);</span>
<span class="line-modified">!     void invalidateFramebuffer(GC3Denum target, const Vector&lt;GC3Denum&gt;&amp; attachments);</span>
<span class="line-modified">!     void invalidateSubFramebuffer(GC3Denum target, const Vector&lt;GC3Denum&gt;&amp; attachments, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
<span class="line-modified">!     void readBuffer(GC3Denum src);</span>
  
      // Renderbuffer objects
<span class="line-modified">!     void renderbufferStorageMultisample(GC3Denum target, GC3Dsizei samples, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height);</span>
  
      // Texture objects
<span class="line-modified">!     void texStorage2D(GC3Denum target, GC3Dsizei levels, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height);</span>
<span class="line-modified">!     void texStorage3D(GC3Denum target, GC3Dsizei levels, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth);</span>
  
  #if ENABLE(VIDEO)
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
  #else
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
  #endif
  
      using WebGLRenderingContextBase::texImage2D;
<span class="line-modified">!     void texImage2D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint64 pboOffset);</span>
<span class="line-modified">!     void texImage2D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, TexImageSource&amp;&amp;);</span>
<span class="line-modified">!     void texImage2D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GC3Duint srcOffset);</span>
  
<span class="line-modified">!     void texImage3D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint64 pboOffset);</span>
<span class="line-modified">!     void texImage3D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Dint border, GC3Denum format, GC3Denum type, TexImageSource&amp;&amp;);</span>
<span class="line-modified">!     void texImage3D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels);</span>
<span class="line-modified">!     void texImage3D(GC3Denum target, GC3Dint level, GC3Dint internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GC3Duint srcOffset);</span>
  
      using WebGLRenderingContextBase::texSubImage2D;
<span class="line-modified">!     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, GC3Dint64 pboOffset);</span>
<span class="line-modified">!     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, TexImageSource&amp;&amp;);</span>
<span class="line-modified">!     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GC3Duint srcOffset);</span>
  
<span class="line-modified">!     void texSubImage3D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint zoffset, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Denum format, GC3Denum type, GC3Dint64 pboOffset);</span>
<span class="line-removed">-     void texSubImage3D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint zoffset, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels, GC3Duint srcOffset);</span>
<span class="line-removed">-     void texSubImage3D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint zoffset, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Denum format, GC3Denum type, TexImageSource&amp;&amp;);</span>
  
<span class="line-modified">!     void copyTexSubImage3D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint zoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
  
<span class="line-modified">!     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Dsizei imageSize, GC3Dint64 offset);</span>
<span class="line-modified">!     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data, GC3Duint, GC3Duint);</span>
<span class="line-modified">!     void compressedTexImage3D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Dint border, GC3Dsizei imageSize, GC3Dint64 offset);</span>
<span class="line-removed">-     void compressedTexImage3D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Dint border, ArrayBufferView&amp; srcData, GC3Duint srcOffset, GC3Duint srcLengthOverride);</span>
  
<span class="line-modified">!     void compressedTexSubImage3D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint zoffset, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Denum format, GC3Dsizei imageSize, GC3Dint64 offset);</span>
<span class="line-modified">!     void compressedTexSubImage3D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint zoffset, GC3Dsizei width, GC3Dsizei height, GC3Dsizei depth, GC3Denum format, ArrayBufferView&amp; data, GC3Duint srcOffset, GC3Duint srcLengthOverride);</span>
  
      // Programs and shaders
<span class="line-modified">!     GC3Dint getFragDataLocation(WebGLProgram&amp;, const String&amp; name);</span>
  
      // Uniforms and attributes
      using Uint32List = TypedList&lt;Uint32Array, uint32_t&gt;;
      using Float32List = TypedList&lt;Float32Array, float&gt;;
<span class="line-modified">!     void uniform1ui(WebGLUniformLocation*, GC3Duint v0);</span>
<span class="line-modified">!     void uniform2ui(WebGLUniformLocation*, GC3Duint v0, GC3Duint v1);</span>
<span class="line-modified">!     void uniform3ui(WebGLUniformLocation*, GC3Duint v0, GC3Duint v1, GC3Duint v2);</span>
<span class="line-modified">!     void uniform4ui(WebGLUniformLocation*, GC3Duint v0, GC3Duint v1, GC3Duint v2, GC3Duint v3);</span>
<span class="line-modified">!     void uniform1uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniform2uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniform3uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniform4uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniformMatrix2x3fv(WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp; value, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniformMatrix3x2fv(WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp; value, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniformMatrix2x4fv(WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp; value, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniformMatrix4x2fv(WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp; value, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniformMatrix3x4fv(WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp; value, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void uniformMatrix4x3fv(WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp; value, GC3Duint srcOffset, GC3Duint srcLength);</span>
<span class="line-modified">!     void vertexAttribI4i(GC3Duint index, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);</span>
<span class="line-modified">!     void vertexAttribI4iv(GC3Duint index, Int32List&amp;&amp; v);</span>
<span class="line-modified">!     void vertexAttribI4ui(GC3Duint index, GC3Duint x, GC3Duint y, GC3Duint z, GC3Duint w);</span>
<span class="line-modified">!     void vertexAttribI4uiv(GC3Duint index, Uint32List&amp;&amp; v);</span>
<span class="line-modified">!     void vertexAttribIPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dsizei stride, GC3Dint64 offset);</span>
  
      // Writing to the drawing buffer
<span class="line-modified">!     void clear(GC3Dbitfield mask) final;</span>
<span class="line-modified">!     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);</span>
<span class="line-modified">!     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei instanceCount);</span>
<span class="line-modified">!     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, GC3Dint64 offset, GC3Dsizei instanceCount);</span>
<span class="line-modified">!     void drawRangeElements(GC3Denum mode, GC3Duint start, GC3Duint end, GC3Dsizei count, GC3Denum type, GC3Dint64 offset);</span>
  
      // Multiple render targets
<span class="line-modified">!     void drawBuffers(const Vector&lt;GC3Denum&gt;&amp; buffers);</span>
<span class="line-modified">!     void clearBufferiv(GC3Denum buffer, GC3Dint drawbuffer, Int32List&amp;&amp; values, GC3Duint srcOffset);</span>
<span class="line-modified">!     void clearBufferuiv(GC3Denum buffer, GC3Dint drawbuffer, Uint32List&amp;&amp; values, GC3Duint srcOffset);</span>
<span class="line-modified">!     void clearBufferfv(GC3Denum buffer, GC3Dint drawbuffer, Float32List&amp;&amp; values, GC3Duint srcOffset);</span>
<span class="line-modified">!     void clearBufferfi(GC3Denum buffer, GC3Dint drawbuffer, GC3Dfloat depth, GC3Dint stencil);</span>
  
      // Query objects
      RefPtr&lt;WebGLQuery&gt; createQuery();
      void deleteQuery(WebGLQuery*);
<span class="line-modified">!     GC3Dboolean isQuery(WebGLQuery*);</span>
<span class="line-modified">!     void beginQuery(GC3Denum target, WebGLQuery&amp;);</span>
<span class="line-modified">!     void endQuery(GC3Denum target);</span>
<span class="line-modified">!     RefPtr&lt;WebGLQuery&gt; getQuery(GC3Denum target, GC3Denum pname);</span>
<span class="line-modified">!     WebGLAny getQueryParameter(WebGLQuery&amp;, GC3Denum pname);</span>
  
      // Sampler objects
      RefPtr&lt;WebGLSampler&gt; createSampler();
      void deleteSampler(WebGLSampler*);
<span class="line-modified">!     GC3Dboolean isSampler(WebGLSampler*);</span>
<span class="line-modified">!     void bindSampler(GC3Duint unit, WebGLSampler*);</span>
<span class="line-modified">!     void samplerParameteri(WebGLSampler&amp;, GC3Denum pname, GC3Dint param);</span>
<span class="line-modified">!     void samplerParameterf(WebGLSampler&amp;, GC3Denum pname, GC3Dfloat param);</span>
<span class="line-modified">!     WebGLAny getSamplerParameter(WebGLSampler&amp;, GC3Denum pname);</span>
  
      // Sync objects
<span class="line-modified">!     RefPtr&lt;WebGLSync&gt; fenceSync(GC3Denum condition, GC3Dbitfield flags);</span>
<span class="line-modified">!     GC3Dboolean isSync(WebGLSync*);</span>
      void deleteSync(WebGLSync*);
<span class="line-modified">!     GC3Denum clientWaitSync(WebGLSync&amp;, GC3Dbitfield flags, GC3Duint64 timeout);</span>
<span class="line-modified">!     void waitSync(WebGLSync&amp;, GC3Dbitfield flags, GC3Dint64 timeout);</span>
<span class="line-modified">!     WebGLAny getSyncParameter(WebGLSync&amp;, GC3Denum pname);</span>
  
      // Transform feedback
      RefPtr&lt;WebGLTransformFeedback&gt; createTransformFeedback();
      void deleteTransformFeedback(WebGLTransformFeedback* id);
<span class="line-modified">!     GC3Dboolean isTransformFeedback(WebGLTransformFeedback* id);</span>
<span class="line-modified">!     void bindTransformFeedback(GC3Denum target, WebGLTransformFeedback* id);</span>
<span class="line-modified">!     void beginTransformFeedback(GC3Denum primitiveMode);</span>
      void endTransformFeedback();
<span class="line-modified">!     void transformFeedbackVaryings(WebGLProgram&amp;, const Vector&lt;String&gt;&amp; varyings, GC3Denum bufferMode);</span>
<span class="line-modified">!     RefPtr&lt;WebGLActiveInfo&gt; getTransformFeedbackVarying(WebGLProgram&amp;, GC3Duint index);</span>
      void pauseTransformFeedback();
      void resumeTransformFeedback();
  
      // Uniform buffer objects and transform feedback buffers
<span class="line-modified">!     void bindBufferBase(GC3Denum target, GC3Duint index, WebGLBuffer*);</span>
<span class="line-modified">!     void bindBufferRange(GC3Denum target, GC3Duint index, WebGLBuffer*, GC3Dint64 offset, GC3Dint64 size);</span>
<span class="line-modified">!     WebGLAny getIndexedParameter(GC3Denum target, GC3Duint index);</span>
<span class="line-modified">!     Optional&lt;Vector&lt;GC3Duint&gt;&gt; getUniformIndices(WebGLProgram&amp;, const Vector&lt;String&gt;&amp; uniformNames);</span>
<span class="line-modified">!     WebGLAny getActiveUniforms(WebGLProgram&amp;, const Vector&lt;GC3Duint&gt;&amp; uniformIndices, GC3Denum pname);</span>
<span class="line-modified">!     GC3Duint getUniformBlockIndex(WebGLProgram&amp;, const String&amp; uniformBlockName);</span>
<span class="line-modified">!     WebGLAny getActiveUniformBlockParameter(WebGLProgram&amp;, GC3Duint uniformBlockIndex, GC3Denum pname);</span>
<span class="line-modified">!     WebGLAny getActiveUniformBlockName(WebGLProgram&amp;, GC3Duint uniformBlockIndex);</span>
<span class="line-modified">!     void uniformBlockBinding(WebGLProgram&amp;, GC3Duint uniformBlockIndex, GC3Duint uniformBlockBinding);</span>
  
      // Vertex array objects
      RefPtr&lt;WebGLVertexArrayObject&gt; createVertexArray();
      void deleteVertexArray(WebGLVertexArrayObject* vertexArray);
<span class="line-modified">!     GC3Dboolean isVertexArray(WebGLVertexArrayObject* vertexArray);</span>
      void bindVertexArray(WebGLVertexArrayObject* vertexArray);
  
      WebGLExtension* getExtension(const String&amp;) final;
      Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() final;
<span class="line-modified">!     WebGLAny getParameter(GC3Denum pname) final;</span>
  
<span class="line-modified">!     void renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height) final;</span>
<span class="line-modified">!     void hint(GC3Denum target, GC3Denum mode) final;</span>
  
  private:
<span class="line-modified">!     WebGL2RenderingContext(CanvasBase&amp;, GraphicsContext3DAttributes);</span>
<span class="line-modified">!     WebGL2RenderingContext(CanvasBase&amp;, Ref&lt;GraphicsContext3D&gt;&amp;&amp;, GraphicsContext3DAttributes);</span>
  
      bool isWebGL2() const final { return true; }
  
      void initializeVertexArrayObjects() final;
<span class="line-modified">!     GC3Dint getMaxDrawBuffers() final;</span>
<span class="line-modified">!     GC3Dint getMaxColorAttachments() final;</span>
<span class="line-modified">!     bool validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired) final;</span>
<span class="line-modified">!     bool validateBlendEquation(const char* functionName, GC3Denum mode) final;</span>
<span class="line-modified">!     bool validateCapability(const char* functionName, GC3Denum cap) final;</span>
<span class="line-modified">!     bool validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment) final;</span>
<span class="line-modified">!     bool validateFramebufferTarget(const char* functionName, GC3Denum target);</span>
<span class="line-modified">!     bool validateNonDefaultFramebufferAttachment(const char* functionName, GC3Denum attachment);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GC3Denum baseInternalFormatFromInternalFormat(GC3Denum internalformat);</span>
<span class="line-modified">!     bool isIntegerFormat(GC3Denum internalformat);</span>
      void initializeShaderExtensions();
  
<span class="line-modified">!     bool validateTexStorageFuncParameters(GC3Denum target, GC3Dsizei levels, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, const char* functionName);</span>
  };
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_CANVASRENDERINGCONTEXT(WebCore::WebGL2RenderingContext, isWebGL2())
<span class="line-new-header">--- 39,246 ---</span>
  class WebGLVertexArrayObject;
  
  class WebGL2RenderingContext final : public WebGLRenderingContextBase {
      WTF_MAKE_ISO_ALLOCATED(WebGL2RenderingContext);
  public:
<span class="line-modified">!     static std::unique_ptr&lt;WebGL2RenderingContext&gt; create(CanvasBase&amp;, GraphicsContextGLAttributes);</span>
<span class="line-modified">!     static std::unique_ptr&lt;WebGL2RenderingContext&gt; create(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, GraphicsContextGLAttributes);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ~WebGL2RenderingContext();</span>
  
      // Buffer objects
      using WebGLRenderingContextBase::bufferData;
      using WebGLRenderingContextBase::bufferSubData;
<span class="line-modified">!     void bufferData(GCGLenum target, const ArrayBufferView&amp; data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length);</span>
<span class="line-modified">!     void bufferSubData(GCGLenum target, long long offset, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length);</span>
<span class="line-modified">!     void copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLint64 readOffset, GCGLint64 writeOffset, GCGLint64 size);</span>
<span class="line-modified">!     void getBufferSubData(GCGLenum target, long long srcByteOffset, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; dstData, GCGLuint dstOffset = 0, GCGLuint length = 0);</span>
  
      // Framebuffer objects
<span class="line-modified">!     WebGLAny getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname) final;</span>
<span class="line-modified">!     void blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter);</span>
<span class="line-modified">!     void framebufferTextureLayer(GCGLenum target, GCGLenum attachment, WebGLTexture*, GCGLint level, GCGLint layer);</span>
<span class="line-modified">!     WebGLAny getInternalformatParameter(GCGLenum target, GCGLenum internalformat, GCGLenum pname);</span>
<span class="line-modified">!     void invalidateFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments);</span>
<span class="line-modified">!     void invalidateSubFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
<span class="line-modified">!     void readBuffer(GCGLenum src);</span>
  
      // Renderbuffer objects
<span class="line-modified">!     void renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height);</span>
  
      // Texture objects
<span class="line-modified">!     void texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height);</span>
<span class="line-modified">!     void texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLsizei depth);</span>
  
  #if ENABLE(VIDEO)
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
  #else
      using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
  #endif
  
      using WebGLRenderingContextBase::texImage2D;
<span class="line-modified">!     void texImage2D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr offset);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; texImage2D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);</span>
<span class="line-modified">!     void texImage2D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset);</span>
  
<span class="line-modified">!     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLint64 pboOffset);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);</span>
<span class="line-modified">!     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels);</span>
<span class="line-modified">!     void texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset);</span>
  
      using WebGLRenderingContextBase::texSubImage2D;
<span class="line-modified">!     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr pboOffset);</span>
<span class="line-modified">!     ExceptionOr&lt;void&gt; texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);</span>
<span class="line-modified">!     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; srcData, GCGLuint srcOffset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLint64 pboOffset);</span>
<span class="line-added">+     void texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels, GCGLuint srcOffset);</span>
<span class="line-added">+     ExceptionOr&lt;void&gt; texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, TexImageSource&amp;&amp;);</span>
  
<span class="line-modified">!     void copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
  
<span class="line-modified">!     using WebGLRenderingContextBase::compressedTexImage2D;</span>
<span class="line-added">+     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLint64 offset);</span>
<span class="line-added">+     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint srcLengthOverride);</span>
<span class="line-added">+     void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLint64 offset);</span>
<span class="line-added">+     void compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, ArrayBufferView&amp; srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride);</span>
  
<span class="line-modified">!     using WebGLRenderingContextBase::compressedTexSubImage2D;</span>
<span class="line-modified">!     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset);</span>
<span class="line-modified">!     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView&amp; srcData, GLuint srcOffset, GLuint srcLengthOverride);</span>
  
<span class="line-modified">!     void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLint64 offset);</span>
<span class="line-modified">!     void compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint srcLengthOverride);</span>
  
      // Programs and shaders
<span class="line-modified">!     GCGLint getFragDataLocation(WebGLProgram&amp;, const String&amp; name);</span>
  
      // Uniforms and attributes
      using Uint32List = TypedList&lt;Uint32Array, uint32_t&gt;;
      using Float32List = TypedList&lt;Float32Array, float&gt;;
<span class="line-modified">!     void uniform1ui(WebGLUniformLocation*, GCGLuint v0);</span>
<span class="line-modified">!     void uniform2ui(WebGLUniformLocation*, GCGLuint v0, GCGLuint v1);</span>
<span class="line-modified">!     void uniform3ui(WebGLUniformLocation*, GCGLuint v0, GCGLuint v1, GCGLuint v2);</span>
<span class="line-modified">!     void uniform4ui(WebGLUniformLocation*, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3);</span>
<span class="line-modified">!     void uniform1uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniform2uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniform3uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniform4uiv(WebGLUniformLocation*, Uint32List&amp;&amp; data, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniformMatrix2x3fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniformMatrix3x2fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniformMatrix2x4fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniformMatrix4x2fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniformMatrix3x4fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void uniformMatrix4x3fv(WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp; value, GCGLuint srcOffset, GCGLuint srcLength);</span>
<span class="line-modified">!     void vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w);</span>
<span class="line-modified">!     void vertexAttribI4iv(GCGLuint index, Int32List&amp;&amp; v);</span>
<span class="line-modified">!     void vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w);</span>
<span class="line-modified">!     void vertexAttribI4uiv(GCGLuint index, Uint32List&amp;&amp; v);</span>
<span class="line-modified">!     void vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLint64 offset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform1fv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform2fv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform3fv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform4fv;</span>
<span class="line-added">+     void uniform1fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniform2fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniform3fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniform4fv(WebGLUniformLocation* location, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+ </span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform1iv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform2iv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform3iv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniform4iv;</span>
<span class="line-added">+     void uniform1iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniform2iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniform3iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniform4iv(WebGLUniformLocation* location, Int32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+ </span>
<span class="line-added">+     using WebGLRenderingContextBase::uniformMatrix2fv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniformMatrix3fv;</span>
<span class="line-added">+     using WebGLRenderingContextBase::uniformMatrix4fv;</span>
<span class="line-added">+     void uniformMatrix2fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniformMatrix3fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
<span class="line-added">+     void uniformMatrix4fv(WebGLUniformLocation* location, GLboolean transpose, Float32List data, GLuint srcOffset, GLuint srcLength);</span>
  
      // Writing to the drawing buffer
<span class="line-modified">!     void clear(GCGLbitfield mask) final;</span>
<span class="line-modified">!     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor);</span>
<span class="line-modified">!     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei instanceCount);</span>
<span class="line-modified">!     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLint64 offset, GCGLsizei instanceCount);</span>
<span class="line-modified">!     void drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLint64 offset);</span>
  
      // Multiple render targets
<span class="line-modified">!     void drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers);</span>
<span class="line-modified">!     void clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, Int32List&amp;&amp; values, GCGLuint srcOffset);</span>
<span class="line-modified">!     void clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, Uint32List&amp;&amp; values, GCGLuint srcOffset);</span>
<span class="line-modified">!     void clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, Float32List&amp;&amp; values, GCGLuint srcOffset);</span>
<span class="line-modified">!     void clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil);</span>
  
      // Query objects
      RefPtr&lt;WebGLQuery&gt; createQuery();
      void deleteQuery(WebGLQuery*);
<span class="line-modified">!     GCGLboolean isQuery(WebGLQuery*);</span>
<span class="line-modified">!     void beginQuery(GCGLenum target, WebGLQuery&amp;);</span>
<span class="line-modified">!     void endQuery(GCGLenum target);</span>
<span class="line-modified">!     RefPtr&lt;WebGLQuery&gt; getQuery(GCGLenum target, GCGLenum pname);</span>
<span class="line-modified">!     WebGLAny getQueryParameter(WebGLQuery&amp;, GCGLenum pname);</span>
  
      // Sampler objects
      RefPtr&lt;WebGLSampler&gt; createSampler();
      void deleteSampler(WebGLSampler*);
<span class="line-modified">!     GCGLboolean isSampler(WebGLSampler*);</span>
<span class="line-modified">!     void bindSampler(GCGLuint unit, WebGLSampler*);</span>
<span class="line-modified">!     void samplerParameteri(WebGLSampler&amp;, GCGLenum pname, GCGLint param);</span>
<span class="line-modified">!     void samplerParameterf(WebGLSampler&amp;, GCGLenum pname, GCGLfloat param);</span>
<span class="line-modified">!     WebGLAny getSamplerParameter(WebGLSampler&amp;, GCGLenum pname);</span>
  
      // Sync objects
<span class="line-modified">!     RefPtr&lt;WebGLSync&gt; fenceSync(GCGLenum condition, GCGLbitfield flags);</span>
<span class="line-modified">!     GCGLboolean isSync(WebGLSync*);</span>
      void deleteSync(WebGLSync*);
<span class="line-modified">!     GCGLenum clientWaitSync(WebGLSync&amp;, GCGLbitfield flags, GCGLuint64 timeout);</span>
<span class="line-modified">!     void waitSync(WebGLSync&amp;, GCGLbitfield flags, GCGLint64 timeout);</span>
<span class="line-modified">!     WebGLAny getSyncParameter(WebGLSync&amp;, GCGLenum pname);</span>
  
      // Transform feedback
      RefPtr&lt;WebGLTransformFeedback&gt; createTransformFeedback();
      void deleteTransformFeedback(WebGLTransformFeedback* id);
<span class="line-modified">!     GCGLboolean isTransformFeedback(WebGLTransformFeedback* id);</span>
<span class="line-modified">!     void bindTransformFeedback(GCGLenum target, WebGLTransformFeedback* id);</span>
<span class="line-modified">!     void beginTransformFeedback(GCGLenum primitiveMode);</span>
      void endTransformFeedback();
<span class="line-modified">!     void transformFeedbackVaryings(WebGLProgram&amp;, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode);</span>
<span class="line-modified">!     RefPtr&lt;WebGLActiveInfo&gt; getTransformFeedbackVarying(WebGLProgram&amp;, GCGLuint index);</span>
      void pauseTransformFeedback();
      void resumeTransformFeedback();
  
      // Uniform buffer objects and transform feedback buffers
<span class="line-modified">!     void bindBufferBase(GCGLenum target, GCGLuint index, WebGLBuffer*);</span>
<span class="line-modified">!     void bindBufferRange(GCGLenum target, GCGLuint index, WebGLBuffer*, GCGLint64 offset, GCGLint64 size);</span>
<span class="line-modified">!     WebGLAny getIndexedParameter(GCGLenum target, GCGLuint index);</span>
<span class="line-modified">!     Optional&lt;Vector&lt;GCGLuint&gt;&gt; getUniformIndices(WebGLProgram&amp;, const Vector&lt;String&gt;&amp; uniformNames);</span>
<span class="line-modified">!     WebGLAny getActiveUniforms(WebGLProgram&amp;, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname);</span>
<span class="line-modified">!     GCGLuint getUniformBlockIndex(WebGLProgram&amp;, const String&amp; uniformBlockName);</span>
<span class="line-modified">!     WebGLAny getActiveUniformBlockParameter(WebGLProgram&amp;, GCGLuint uniformBlockIndex, GCGLenum pname);</span>
<span class="line-modified">!     WebGLAny getActiveUniformBlockName(WebGLProgram&amp;, GCGLuint uniformBlockIndex);</span>
<span class="line-modified">!     void uniformBlockBinding(WebGLProgram&amp;, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding);</span>
  
      // Vertex array objects
      RefPtr&lt;WebGLVertexArrayObject&gt; createVertexArray();
      void deleteVertexArray(WebGLVertexArrayObject* vertexArray);
<span class="line-modified">!     GCGLboolean isVertexArray(WebGLVertexArrayObject* vertexArray);</span>
      void bindVertexArray(WebGLVertexArrayObject* vertexArray);
  
      WebGLExtension* getExtension(const String&amp;) final;
      Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() final;
<span class="line-modified">!     WebGLAny getParameter(GCGLenum pname) final;</span>
  
<span class="line-modified">!     using WebGLRenderingContextBase::readPixels;</span>
<span class="line-modified">!     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset);</span>
<span class="line-added">+     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView&amp; dstData, GLuint dstOffset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) final;</span>
<span class="line-added">+     void hint(GCGLenum target, GCGLenum mode) final;</span>
  
  private:
<span class="line-modified">!     WebGL2RenderingContext(CanvasBase&amp;, GraphicsContextGLAttributes);</span>
<span class="line-modified">!     WebGL2RenderingContext(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, GraphicsContextGLAttributes);</span>
  
      bool isWebGL2() const final { return true; }
  
<span class="line-added">+     RefPtr&lt;ArrayBufferView&gt; arrayBufferViewSliceFactory(const char* const functionName, const ArrayBufferView&amp; data, unsigned startByte, unsigned bytelength);</span>
<span class="line-added">+     RefPtr&lt;ArrayBufferView&gt; sliceArrayBufferView(const char* const functionName, const ArrayBufferView&amp; data, GCGLuint srcOffset, GCGLuint length);</span>
<span class="line-added">+     RefPtr&lt;ArrayBufferView&gt; sliceTypedArrayBufferView(const char* const functionName, RefPtr&lt;ArrayBufferView&gt;&amp;, GCGLuint);</span>
<span class="line-added">+ </span>
      void initializeVertexArrayObjects() final;
<span class="line-modified">!     GCGLint getMaxDrawBuffers() final;</span>
<span class="line-modified">!     GCGLint getMaxColorAttachments() final;</span>
<span class="line-modified">!     bool validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired) final;</span>
<span class="line-modified">!     bool validateBlendEquation(const char* functionName, GCGLenum mode) final;</span>
<span class="line-modified">!     bool validateCapability(const char* functionName, GCGLenum cap) final;</span>
<span class="line-modified">!     bool validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment) final;</span>
<span class="line-modified">!     bool validateFramebufferTarget(const char* functionName, GCGLenum target);</span>
<span class="line-modified">!     bool validateNonDefaultFramebufferAttachment(const char* functionName, GCGLenum attachment);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     GCGLenum baseInternalFormatFromInternalFormat(GCGLenum internalformat);</span>
<span class="line-modified">!     bool isIntegerFormat(GCGLenum internalformat);</span>
      void initializeShaderExtensions();
<span class="line-added">+     void initializeTransformFeedbackBufferCache();</span>
<span class="line-added">+     void initializeSamplerCache();</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool validateTexStorageFuncParameters(GCGLenum target, GCGLsizei levels, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, const char* functionName);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void uncacheDeletedBuffer(WebGLBuffer*) final;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;WebGLTransformFeedback&gt; m_boundTransformFeedback;</span>
<span class="line-added">+     Vector&lt;RefPtr&lt;WebGLBuffer&gt;&gt; m_boundTransformFeedbackBuffers;</span>
<span class="line-added">+ </span>
<span class="line-added">+     HashMap&lt;GCGLenum, RefPtr&lt;WebGLQuery&gt;&gt; m_activeQueries;</span>
  
<span class="line-modified">!     Vector&lt;RefPtr&lt;WebGLSampler&gt;&gt; m_boundSamplers;</span>
  };
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_CANVASRENDERINGCONTEXT(WebCore::WebGL2RenderingContext, isWebGL2())
</pre>
<center><a href="WebGL2RenderingContext.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGL2RenderingContext.idl.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
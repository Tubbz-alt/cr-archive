<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSSelector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999-2003 Lars Knoll (knoll@kde.org)
  3  *               1999 Waldo Bastian (bastian@kde.org)
  4  * Copyright (C) 2004, 2006, 2007, 2008, 2009, 2010, 2013, 2014 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;QualifiedName.h&quot;
 25 #include &quot;RenderStyleConstants.h&quot;
 26 
 27 namespace WebCore {
 28     class CSSSelectorList;
 29 
 30     enum class SelectorSpecificityIncrement {
 31         ClassA = 0x10000,
 32         ClassB = 0x100,
 33         ClassC = 1
 34     };
 35 
 36     // this class represents a selector for a StyleRule
 37     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSSelectorRareData);
 38     class CSSSelector {
 39         WTF_MAKE_FAST_ALLOCATED;
 40     public:
 41         CSSSelector();
 42         CSSSelector(const CSSSelector&amp;);
 43         explicit CSSSelector(const QualifiedName&amp;, bool tagIsForNamespaceRule = false);
 44 
 45         ~CSSSelector();
 46 
 47         /**
 48          * Re-create selector text from selector&#39;s data
 49          */
 50         String selectorText(const String&amp; = emptyString()) const;
 51 
 52         // checks if the 2 selectors (including sub selectors) agree.
 53         bool operator==(const CSSSelector&amp;) const;
 54 
 55         static const unsigned maxValueMask = 0xffffff;
 56         static const unsigned idMask = 0xff0000;
 57         static const unsigned classMask = 0xff00;
 58         static const unsigned elementMask = 0xff;
 59 
 60         unsigned staticSpecificity(bool&amp; ok) const;
 61         unsigned specificityForPage() const;
 62         unsigned simpleSelectorSpecificity() const;
 63         static unsigned addSpecificities(unsigned, unsigned);
 64 
 65         /* how the attribute value has to match.... Default is Exact */
 66         enum Match {
 67             Unknown = 0,
 68             Tag,
 69             Id,
 70             Class,
 71             Exact,
 72             Set,
 73             List,
 74             Hyphen,
 75             PseudoClass,
 76             PseudoElement,
 77             Contain, // css3: E[foo*=&quot;bar&quot;]
 78             Begin, // css3: E[foo^=&quot;bar&quot;]
 79             End, // css3: E[foo$=&quot;bar&quot;]
 80             PagePseudoClass
 81         };
 82 
 83         enum RelationType {
 84             Subselector,
 85             DescendantSpace,
 86             Child,
 87             DirectAdjacent,
 88             IndirectAdjacent,
 89             ShadowDescendant
 90         };
 91 
 92         enum PseudoClassType {
 93             PseudoClassUnknown = 0,
 94             PseudoClassEmpty,
 95             PseudoClassFirstChild,
 96             PseudoClassFirstOfType,
 97             PseudoClassLastChild,
 98             PseudoClassLastOfType,
 99             PseudoClassOnlyChild,
100             PseudoClassOnlyOfType,
101             PseudoClassNthChild,
102             PseudoClassNthOfType,
103             PseudoClassNthLastChild,
104             PseudoClassNthLastOfType,
105             PseudoClassLink,
106             PseudoClassVisited,
107             PseudoClassAny,
108             PseudoClassAnyLink,
109             PseudoClassAnyLinkDeprecated,
110             PseudoClassAutofill,
111             PseudoClassAutofillStrongPassword,
112             PseudoClassAutofillStrongPasswordViewable,
113             PseudoClassHover,
114             PseudoClassDirectFocus,
115             PseudoClassDrag,
116             PseudoClassFocus,
117             PseudoClassFocusWithin,
118             PseudoClassActive,
119             PseudoClassChecked,
120             PseudoClassEnabled,
121             PseudoClassFullPageMedia,
122             PseudoClassDefault,
123             PseudoClassDisabled,
124             PseudoClassMatches,
125             PseudoClassOptional,
126             PseudoClassPlaceholderShown,
127             PseudoClassRequired,
128             PseudoClassReadOnly,
129             PseudoClassReadWrite,
130             PseudoClassValid,
131             PseudoClassInvalid,
132             PseudoClassIndeterminate,
133             PseudoClassTarget,
134             PseudoClassLang,
135             PseudoClassNot,
136             PseudoClassRoot,
137             PseudoClassScope,
138             PseudoClassWindowInactive,
139             PseudoClassCornerPresent,
140             PseudoClassDecrement,
141             PseudoClassIncrement,
142             PseudoClassHorizontal,
143             PseudoClassVertical,
144             PseudoClassStart,
145             PseudoClassEnd,
146             PseudoClassDoubleButton,
147             PseudoClassSingleButton,
148             PseudoClassNoButton,
149 #if ENABLE(FULLSCREEN_API)
150             PseudoClassFullScreen,
151             PseudoClassFullScreenDocument,
152             PseudoClassFullScreenAncestor,
153             PseudoClassAnimatingFullScreenTransition,
154             PseudoClassFullScreenControlsHidden,
155 #endif
156 #if ENABLE(PICTURE_IN_PICTURE_API)
157             PseudoClassPictureInPicture,
158 #endif
159             PseudoClassInRange,
160             PseudoClassOutOfRange,
161 #if ENABLE(VIDEO_TRACK)
162             PseudoClassFuture,
163             PseudoClassPast,
164 #endif
165 #if ENABLE(CSS_SELECTORS_LEVEL4)
166             PseudoClassDir,
167             PseudoClassRole,
168 #endif
169             PseudoClassHost,
170             PseudoClassDefined,
171 #if ENABLE(ATTACHMENT_ELEMENT)
172             PseudoClassHasAttachment,
173 #endif
174         };
175 
176         enum PseudoElementType {
177             PseudoElementUnknown = 0,
178             PseudoElementAfter,
179             PseudoElementBefore,
180 #if ENABLE(VIDEO_TRACK)
181             PseudoElementCue,
182 #endif
183             PseudoElementFirstLetter,
184             PseudoElementFirstLine,
185             PseudoElementHighlight,
186             PseudoElementMarker,
187             PseudoElementPart,
188             PseudoElementResizer,
189             PseudoElementScrollbar,
190             PseudoElementScrollbarButton,
191             PseudoElementScrollbarCorner,
192             PseudoElementScrollbarThumb,
193             PseudoElementScrollbarTrack,
194             PseudoElementScrollbarTrackPiece,
195             PseudoElementSelection,
196             PseudoElementSlotted,
197             PseudoElementWebKitCustom,
198 
199             // WebKitCustom that appeared in an old prefixed form
200             // and need special handling.
201             PseudoElementWebKitCustomLegacyPrefixed,
202         };
203 
204         enum PagePseudoClassType {
205             PagePseudoClassFirst = 1,
206             PagePseudoClassLeft,
207             PagePseudoClassRight,
208         };
209 
210         enum MarginBoxType {
211             TopLeftCornerMarginBox,
212             TopLeftMarginBox,
213             TopCenterMarginBox,
214             TopRightMarginBox,
215             TopRightCornerMarginBox,
216             BottomLeftCornerMarginBox,
217             BottomLeftMarginBox,
218             BottomCenterMarginBox,
219             BottomRightMarginBox,
220             BottomRightCornerMarginBox,
221             LeftTopMarginBox,
222             LeftMiddleMarginBox,
223             LeftBottomMarginBox,
224             RightTopMarginBox,
225             RightMiddleMarginBox,
226             RightBottomMarginBox,
227         };
228 
229         enum AttributeMatchType {
230             CaseSensitive,
231             CaseInsensitive,
232         };
233 
234         static PseudoElementType parsePseudoElementType(StringView);
235         static PseudoId pseudoId(PseudoElementType);
236 
237         // Selectors are kept in an array by CSSSelectorList. The next component of the selector is
238         // the next item in the array.
239         const CSSSelector* tagHistory() const { return m_isLastInTagHistory ? 0 : const_cast&lt;CSSSelector*&gt;(this + 1); }
240 
241         const QualifiedName&amp; tagQName() const;
242         const AtomString&amp; tagLowercaseLocalName() const;
243 
244         const AtomString&amp; value() const;
245         const AtomString&amp; serializingValue() const;
246         const QualifiedName&amp; attribute() const;
247         const AtomString&amp; attributeCanonicalLocalName() const;
248         const AtomString&amp; argument() const { return m_hasRareData ? m_data.m_rareData-&gt;m_argument : nullAtom(); }
249         bool attributeValueMatchingIsCaseInsensitive() const;
250         const Vector&lt;AtomString&gt;* argumentList() const { return m_hasRareData ? m_data.m_rareData-&gt;m_argumentList.get() : nullptr; }
251         const CSSSelectorList* selectorList() const { return m_hasRareData ? m_data.m_rareData-&gt;m_selectorList.get() : nullptr; }
252 
253         void setValue(const AtomString&amp;, bool matchLowerCase = false);
254 
255         void setAttribute(const QualifiedName&amp;, bool convertToLowercase, AttributeMatchType);
256         void setNth(int a, int b);
257         void setArgument(const AtomString&amp;);
258         void setArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt;);
259         void setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt;);
260 
261         bool matchNth(int count) const;
262         int nthA() const;
263         int nthB() const;
264 
265         bool hasDescendantRelation() const { return relation() == DescendantSpace; }
266 
267         bool hasDescendantOrChildRelation() const { return relation() == Child || hasDescendantRelation(); }
268 
269         PseudoClassType pseudoClassType() const
270         {
271             ASSERT(match() == PseudoClass);
272             return static_cast&lt;PseudoClassType&gt;(m_pseudoType);
273         }
274         void setPseudoClassType(PseudoClassType pseudoType)
275         {
276             m_pseudoType = pseudoType;
277             ASSERT(m_pseudoType == pseudoType);
278         }
279 
280         PseudoElementType pseudoElementType() const
281         {
282             ASSERT(match() == PseudoElement);
283             return static_cast&lt;PseudoElementType&gt;(m_pseudoType);
284         }
285         void setPseudoElementType(PseudoElementType pseudoElementType)
286         {
287             m_pseudoType = pseudoElementType;
288             ASSERT(m_pseudoType == pseudoElementType);
289         }
290 
291         PagePseudoClassType pagePseudoClassType() const
292         {
293             ASSERT(match() == PagePseudoClass);
294             return static_cast&lt;PagePseudoClassType&gt;(m_pseudoType);
295         }
296         void setPagePseudoType(PagePseudoClassType pagePseudoType)
297         {
298             m_pseudoType = pagePseudoType;
299             ASSERT(m_pseudoType == pagePseudoType);
300         }
301 
302         bool matchesPseudoElement() const;
303         bool isUnknownPseudoElement() const;
304         bool isCustomPseudoElement() const;
305         bool isWebKitCustomPseudoElement() const;
306         bool isSiblingSelector() const;
307         bool isAttributeSelector() const;
308 
309         RelationType relation() const { return static_cast&lt;RelationType&gt;(m_relation); }
310         void setRelation(RelationType relation)
311         {
312             m_relation = relation;
313             ASSERT(m_relation == relation);
314         }
315 
316         Match match() const { return static_cast&lt;Match&gt;(m_match); }
317         void setMatch(Match match)
318         {
319             m_match = match;
320             ASSERT(m_match == match);
321         }
322 
323         bool isLastInSelectorList() const { return m_isLastInSelectorList; }
324         void setLastInSelectorList() { m_isLastInSelectorList = true; }
325         bool isLastInTagHistory() const { return m_isLastInTagHistory; }
326         void setNotLastInTagHistory() { m_isLastInTagHistory = false; }
327 
328         bool isForPage() const { return m_isForPage; }
329         void setForPage() { m_isForPage = true; }
330 
331     private:
332         unsigned m_relation              : 4; // enum RelationType.
333         mutable unsigned m_match         : 4; // enum Match.
334         mutable unsigned m_pseudoType    : 8; // PseudoType.
335         unsigned m_isLastInSelectorList  : 1;
336         unsigned m_isLastInTagHistory    : 1;
337         unsigned m_hasRareData           : 1;
338         unsigned m_hasNameWithCase       : 1;
339         unsigned m_isForPage             : 1;
340         unsigned m_tagIsForNamespaceRule : 1;
341         unsigned m_caseInsensitiveAttributeValueMatching : 1;
342 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
343         unsigned m_destructorHasBeenCalled : 1;
344 #endif
345 
346         unsigned simpleSelectorSpecificityForPage() const;
347 
348         // Hide.
349         CSSSelector&amp; operator=(const CSSSelector&amp;);
350 
351         struct RareData : public RefCounted&lt;RareData&gt; {
352             WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(CSSSelectorRareData);
353             static Ref&lt;RareData&gt; create(AtomString&amp;&amp; value) { return adoptRef(*new RareData(WTFMove(value))); }
354             ~RareData();
355 
356             bool matchNth(int count);
357 
358             // For quirks mode, class and id are case-insensitive. In the case where uppercase
359             // letters are used in quirks mode, |m_matchingValue| holds the lowercase class/id
360             // and |m_serializingValue| holds the original string.
361             AtomString m_matchingValue;
362             AtomString m_serializingValue;
363 
364             int m_a; // Used for :nth-*
365             int m_b; // Used for :nth-*
366             QualifiedName m_attribute; // used for attribute selector
367             AtomString m_attributeCanonicalLocalName;
368             AtomString m_argument; // Used for :contains and :nth-*
369             std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; m_argumentList; // Used for :lang and ::part arguments.
370             std::unique_ptr&lt;CSSSelectorList&gt; m_selectorList; // Used for :matches() and :not().
371 
372         private:
373             RareData(AtomString&amp;&amp; value);
374         };
375         void createRareData();
376 
377         struct NameWithCase : public RefCounted&lt;NameWithCase&gt; {
378             NameWithCase(const QualifiedName&amp; originalName, const AtomString&amp; lowercaseName)
379                 : m_originalName(originalName)
380                 , m_lowercaseLocalName(lowercaseName)
381             {
382                 ASSERT(originalName.localName() != lowercaseName);
383             }
384 
385             const QualifiedName m_originalName;
386             const AtomString m_lowercaseLocalName;
387         };
388 
389         union DataUnion {
390             DataUnion() : m_value(0) { }
391             AtomStringImpl* m_value;
392             QualifiedName::QualifiedNameImpl* m_tagQName;
393             RareData* m_rareData;
394             NameWithCase* m_nameWithCase;
395         } m_data;
396     };
397 
398 inline const QualifiedName&amp; CSSSelector::attribute() const
399 {
400     ASSERT(isAttributeSelector());
401     ASSERT(m_hasRareData);
402     return m_data.m_rareData-&gt;m_attribute;
403 }
404 
405 inline const AtomString&amp; CSSSelector::attributeCanonicalLocalName() const
406 {
407     ASSERT(isAttributeSelector());
408     ASSERT(m_hasRareData);
409     return m_data.m_rareData-&gt;m_attributeCanonicalLocalName;
410 }
411 
412 inline bool CSSSelector::matchesPseudoElement() const
413 {
414     return match() == PseudoElement;
415 }
416 
417 inline bool CSSSelector::isUnknownPseudoElement() const
418 {
419     return match() == PseudoElement &amp;&amp; pseudoElementType() == PseudoElementUnknown;
420 }
421 
422 inline bool CSSSelector::isCustomPseudoElement() const
423 {
424     return match() == PseudoElement
425         &amp;&amp; (pseudoElementType() == PseudoElementWebKitCustom
426             || pseudoElementType() == PseudoElementWebKitCustomLegacyPrefixed);
427 }
428 
429 inline bool CSSSelector::isWebKitCustomPseudoElement() const
430 {
431     return pseudoElementType() == PseudoElementWebKitCustom || pseudoElementType() == PseudoElementWebKitCustomLegacyPrefixed;
432 }
433 
434 static inline bool pseudoClassIsRelativeToSiblings(CSSSelector::PseudoClassType type)
435 {
436     return type == CSSSelector::PseudoClassEmpty
437         || type == CSSSelector::PseudoClassFirstChild
438         || type == CSSSelector::PseudoClassFirstOfType
439         || type == CSSSelector::PseudoClassLastChild
440         || type == CSSSelector::PseudoClassLastOfType
441         || type == CSSSelector::PseudoClassOnlyChild
442         || type == CSSSelector::PseudoClassOnlyOfType
443         || type == CSSSelector::PseudoClassNthChild
444         || type == CSSSelector::PseudoClassNthOfType
445         || type == CSSSelector::PseudoClassNthLastChild
446         || type == CSSSelector::PseudoClassNthLastOfType;
447 }
448 
449 static inline bool isTreeStructuralPseudoClass(CSSSelector::PseudoClassType type)
450 {
451     return pseudoClassIsRelativeToSiblings(type) || type == CSSSelector::PseudoClassRoot;
452 }
453 
454 inline bool CSSSelector::isSiblingSelector() const
455 {
456     return relation() == DirectAdjacent
457         || relation() == IndirectAdjacent
458         || (match() == CSSSelector::PseudoClass &amp;&amp; pseudoClassIsRelativeToSiblings(pseudoClassType()));
459 }
460 
461 inline bool CSSSelector::isAttributeSelector() const
462 {
463     return match() == CSSSelector::Exact
464         || match() ==  CSSSelector::Set
465         || match() == CSSSelector::List
466         || match() == CSSSelector::Hyphen
467         || match() == CSSSelector::Contain
468         || match() == CSSSelector::Begin
469         || match() == CSSSelector::End;
470 }
471 
472 inline void CSSSelector::setValue(const AtomString&amp; value, bool matchLowerCase)
473 {
474     ASSERT(match() != Tag);
475     AtomString matchingValue = matchLowerCase ? value.convertToASCIILowercase() : value;
476     if (!m_hasRareData &amp;&amp; matchingValue != value)
477         createRareData();
478 
479     // Need to do ref counting manually for the union.
480     if (!m_hasRareData) {
481         if (m_data.m_value)
482             m_data.m_value-&gt;deref();
483         m_data.m_value = value.impl();
484         m_data.m_value-&gt;ref();
485         return;
486     }
487 
488     m_data.m_rareData-&gt;m_matchingValue = WTFMove(matchingValue);
489     m_data.m_rareData-&gt;m_serializingValue = value;
490 }
491 
492 inline CSSSelector::CSSSelector()
493     : m_relation(DescendantSpace)
494     , m_match(Unknown)
495     , m_pseudoType(0)
496     , m_isLastInSelectorList(false)
497     , m_isLastInTagHistory(true)
498     , m_hasRareData(false)
499     , m_hasNameWithCase(false)
500     , m_isForPage(false)
501     , m_tagIsForNamespaceRule(false)
502     , m_caseInsensitiveAttributeValueMatching(false)
503 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
504     , m_destructorHasBeenCalled(false)
505 #endif
506 {
507 }
508 
509 inline CSSSelector::CSSSelector(const CSSSelector&amp; o)
510     : m_relation(o.m_relation)
511     , m_match(o.m_match)
512     , m_pseudoType(o.m_pseudoType)
513     , m_isLastInSelectorList(o.m_isLastInSelectorList)
514     , m_isLastInTagHistory(o.m_isLastInTagHistory)
515     , m_hasRareData(o.m_hasRareData)
516     , m_hasNameWithCase(o.m_hasNameWithCase)
517     , m_isForPage(o.m_isForPage)
518     , m_tagIsForNamespaceRule(o.m_tagIsForNamespaceRule)
519     , m_caseInsensitiveAttributeValueMatching(o.m_caseInsensitiveAttributeValueMatching)
520 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
521     , m_destructorHasBeenCalled(false)
522 #endif
523 {
524     if (o.m_hasRareData) {
525         m_data.m_rareData = o.m_data.m_rareData;
526         m_data.m_rareData-&gt;ref();
527     } else if (o.m_hasNameWithCase) {
528         m_data.m_nameWithCase = o.m_data.m_nameWithCase;
529         m_data.m_nameWithCase-&gt;ref();
530     } if (o.match() == Tag) {
531         m_data.m_tagQName = o.m_data.m_tagQName;
532         m_data.m_tagQName-&gt;ref();
533     } else if (o.m_data.m_value) {
534         m_data.m_value = o.m_data.m_value;
535         m_data.m_value-&gt;ref();
536     }
537 }
538 
539 inline CSSSelector::~CSSSelector()
540 {
541     ASSERT_WITH_SECURITY_IMPLICATION(!m_destructorHasBeenCalled);
542 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
543     m_destructorHasBeenCalled = true;
544 #endif
545     if (m_hasRareData) {
546         m_data.m_rareData-&gt;deref();
547         m_data.m_rareData = nullptr;
548         m_hasRareData = false;
549     } else if (m_hasNameWithCase) {
550         m_data.m_nameWithCase-&gt;deref();
551         m_data.m_nameWithCase = nullptr;
552         m_hasNameWithCase = false;
553     } else if (match() == Tag) {
554         m_data.m_tagQName-&gt;deref();
555         m_data.m_tagQName = nullptr;
556         m_match = Unknown;
557     } else if (m_data.m_value) {
558         m_data.m_value-&gt;deref();
559         m_data.m_value = nullptr;
560     }
561 }
562 
563 inline const QualifiedName&amp; CSSSelector::tagQName() const
564 {
565     ASSERT(match() == Tag);
566     if (m_hasNameWithCase)
567         return m_data.m_nameWithCase-&gt;m_originalName;
568     return *reinterpret_cast&lt;const QualifiedName*&gt;(&amp;m_data.m_tagQName);
569 }
570 
571 inline const AtomString&amp; CSSSelector::tagLowercaseLocalName() const
572 {
573     if (m_hasNameWithCase)
574         return m_data.m_nameWithCase-&gt;m_lowercaseLocalName;
575     return m_data.m_tagQName-&gt;m_localName;
576 }
577 
578 inline const AtomString&amp; CSSSelector::value() const
579 {
580     ASSERT(match() != Tag);
581     if (m_hasRareData)
582         return m_data.m_rareData-&gt;m_matchingValue;
583 
584     // AtomString is really just an AtomStringImpl* so the cast below is safe.
585     return *reinterpret_cast&lt;const AtomString*&gt;(&amp;m_data.m_value);
586 }
587 
588 inline const AtomString&amp; CSSSelector::serializingValue() const
589 {
590     ASSERT(match() != Tag);
591     if (m_hasRareData)
592         return m_data.m_rareData-&gt;m_serializingValue;
593 
594     // AtomString is really just an AtomStringImpl* so the cast below is safe.
595     return *reinterpret_cast&lt;const AtomString*&gt;(&amp;m_data.m_value);
596 }
597 
598 inline bool CSSSelector::attributeValueMatchingIsCaseInsensitive() const
599 {
600     return m_caseInsensitiveAttributeValueMatching;
601 }
602 
603 } // namespace WebCore
    </pre>
  </body>
</html>
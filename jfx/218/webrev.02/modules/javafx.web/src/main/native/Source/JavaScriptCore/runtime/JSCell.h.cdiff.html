<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCell.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCell.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCellInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCell.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,9 ***</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2017 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
<span class="line-new-header">--- 1,9 ---</span>
  /*
   *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">!  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,14 ***</span>
  #include &quot;TypedArrayType.h&quot;
  #include &quot;WriteBarrier.h&quot;
  
  namespace JSC {
  
  class CompleteSubspace;
  class CopyVisitor;
  class GCDeferralContext;
<span class="line-removed">- class ExecState;</span>
  class Identifier;
  class JSArrayBufferView;
  class JSDestructibleObject;
  class JSGlobalObject;
  class LLIntOffsetsExtractor;
<span class="line-new-header">--- 36,14 ---</span>
  #include &quot;TypedArrayType.h&quot;
  #include &quot;WriteBarrier.h&quot;
  
  namespace JSC {
  
<span class="line-added">+ class CallFrame;</span>
  class CompleteSubspace;
  class CopyVisitor;
  class GCDeferralContext;
  class Identifier;
  class JSArrayBufferView;
  class JSDestructibleObject;
  class JSGlobalObject;
  class LLIntOffsetsExtractor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,28 ***</span>
      friend class MarkedBlock;
      template&lt;typename T&gt;
      friend void* tryAllocateCellHelper(Heap&amp;, size_t, GCDeferralContext*, AllocationFailureMode);
  
  public:
<span class="line-modified">!     static const unsigned StructureFlags = 0;</span>
  
<span class="line-modified">!     static const bool needsDestruction = false;</span>
  
<span class="line-modified">!     // Don&#39;t call this directly. Call JSC::subspaceFor&lt;Type&gt;(vm) instead.</span>
<span class="line-removed">-     // FIXME: Refer to Subspace by reference.</span>
<span class="line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=166988</span>
<span class="line-removed">-     template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-removed">-     static CompleteSubspace* subspaceFor(VM&amp;);</span>
  
      static JSCell* seenMultipleCalleeObjects() { return bitwise_cast&lt;JSCell*&gt;(static_cast&lt;uintptr_t&gt;(1)); }
  
      enum CreatingEarlyCellTag { CreatingEarlyCell };
      JSCell(CreatingEarlyCellTag);
  
  protected:
      JSCell(VM&amp;, Structure*);
<span class="line-removed">-     JS_EXPORT_PRIVATE static void destroy(JSCell*);</span>
  
  public:
      // Querying the type.
      bool isString() const;
      bool isBigInt() const;
<span class="line-new-header">--- 80,25 ---</span>
      friend class MarkedBlock;
      template&lt;typename T&gt;
      friend void* tryAllocateCellHelper(Heap&amp;, size_t, GCDeferralContext*, AllocationFailureMode);
  
  public:
<span class="line-modified">!     static constexpr unsigned StructureFlags = 0;</span>
  
<span class="line-modified">!     static constexpr bool needsDestruction = false;</span>
  
<span class="line-modified">!     static constexpr uint8_t numberOfLowerTierCells = 8;</span>
  
      static JSCell* seenMultipleCalleeObjects() { return bitwise_cast&lt;JSCell*&gt;(static_cast&lt;uintptr_t&gt;(1)); }
  
      enum CreatingEarlyCellTag { CreatingEarlyCell };
      JSCell(CreatingEarlyCellTag);
  
<span class="line-added">+     JS_EXPORT_PRIVATE static void destroy(JSCell*);</span>
<span class="line-added">+ </span>
  protected:
      JSCell(VM&amp;, Structure*);
  
  public:
      // Querying the type.
      bool isString() const;
      bool isBigInt() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,12 ***</span>
      TypeInfo::InlineTypeFlags inlineTypeFlags() const { return m_flags; }
  
      const char* className(VM&amp;) const;
  
      // Extracting the value.
<span class="line-modified">!     JS_EXPORT_PRIVATE bool getString(ExecState*, String&amp;) const;</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE String getString(ExecState*) const; // null string if not a string</span>
      JS_EXPORT_PRIVATE JSObject* getObject(); // NULL if not an object
      const JSObject* getObject() const; // NULL if not an object
  
      // Returns information about how to call/construct this cell as a function/constructor. May tell
      // you that the cell is not callable or constructor (default is that it&#39;s not either). If it
<span class="line-new-header">--- 138,12 ---</span>
      TypeInfo::InlineTypeFlags inlineTypeFlags() const { return m_flags; }
  
      const char* className(VM&amp;) const;
  
      // Extracting the value.
<span class="line-modified">!     JS_EXPORT_PRIVATE bool getString(JSGlobalObject*, String&amp;) const;</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE String getString(JSGlobalObject*) const; // null string if not a string</span>
      JS_EXPORT_PRIVATE JSObject* getObject(); // NULL if not an object
      const JSObject* getObject() const; // NULL if not an object
  
      // Returns information about how to call/construct this cell as a function/constructor. May tell
      // you that the cell is not callable or constructor (default is that it&#39;s not either). If it
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,16 ***</span>
      // threads.
      JS_EXPORT_PRIVATE static CallType getCallData(JSCell*, CallData&amp;);
      JS_EXPORT_PRIVATE static ConstructType getConstructData(JSCell*, ConstructData&amp;);
  
      // Basic conversions.
<span class="line-modified">!     JS_EXPORT_PRIVATE JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;</span>
<span class="line-modified">!     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;</span>
<span class="line-modified">!     bool toBoolean(ExecState*) const;</span>
      TriState pureToBoolean() const;
<span class="line-modified">!     JS_EXPORT_PRIVATE double toNumber(ExecState*) const;</span>
<span class="line-modified">!     JSObject* toObject(ExecState*, JSGlobalObject*) const;</span>
  
      void dump(PrintStream&amp;) const;
      JS_EXPORT_PRIVATE static void dumpToStream(const JSCell*, PrintStream&amp;);
  
      size_t estimatedSizeInBytes(VM&amp;) const;
<span class="line-new-header">--- 153,16 ---</span>
      // threads.
      JS_EXPORT_PRIVATE static CallType getCallData(JSCell*, CallData&amp;);
      JS_EXPORT_PRIVATE static ConstructType getConstructData(JSCell*, ConstructData&amp;);
  
      // Basic conversions.
<span class="line-modified">!     JS_EXPORT_PRIVATE JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;</span>
<span class="line-modified">!     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;) const;</span>
<span class="line-modified">!     bool toBoolean(JSGlobalObject*) const;</span>
      TriState pureToBoolean() const;
<span class="line-modified">!     JS_EXPORT_PRIVATE double toNumber(JSGlobalObject*) const;</span>
<span class="line-modified">!     JSObject* toObject(JSGlobalObject*) const;</span>
  
      void dump(PrintStream&amp;) const;
      JS_EXPORT_PRIVATE static void dumpToStream(const JSCell*, PrintStream&amp;);
  
      size_t estimatedSizeInBytes(VM&amp;) const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,18 ***</span>
      JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
  
      // Object operations, with the toObject operation included.
      const ClassInfo* classInfo(VM&amp;) const;
      const MethodTable* methodTable(VM&amp;) const;
<span class="line-modified">!     static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">!     static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">!     bool putInline(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="line-modified">!     static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
<span class="line-modified">!     static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);</span>
  
<span class="line-modified">!     static JSValue toThis(JSCell*, ExecState*, ECMAMode);</span>
  
      static bool canUseFastGetOwnProperty(const Structure&amp;);
      JSValue fastGetOwnProperty(VM&amp;, Structure&amp;, PropertyName);
  
      // The recommended idiom for using cellState() is to switch on it or perform an == comparison on it
<span class="line-new-header">--- 174,18 ---</span>
      JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
  
      // Object operations, with the toObject operation included.
      const ClassInfo* classInfo(VM&amp;) const;
      const MethodTable* methodTable(VM&amp;) const;
<span class="line-modified">!     static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">!     static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">!     bool putInline(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="line-modified">!     static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
<span class="line-modified">!     static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);</span>
  
<span class="line-modified">!     static JSValue toThis(JSCell*, JSGlobalObject*, ECMAMode);</span>
  
      static bool canUseFastGetOwnProperty(const Structure&amp;);
      JSValue fastGetOwnProperty(VM&amp;, Structure&amp;, PropertyName);
  
      // The recommended idiom for using cellState() is to switch on it or perform an == comparison on it
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,36 ***</span>
  
      void finishCreation(VM&amp;);
      void finishCreation(VM&amp;, Structure*, CreatingEarlyCellTag);
  
      // Dummy implementations of override-able static functions for classes to put in their MethodTable
<span class="line-modified">!     static JSValue defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     static uint32_t getEnumerableLength(ExecState*, JSObject*);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool preventExtensions(JSObject*, ExecState*);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool isExtensible(JSObject*, ExecState*);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool setPrototype(JSObject*, ExecState*, JSValue, bool);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH JSValue getPrototype(JSObject*, ExecState*);</span>
  
      static String className(const JSObject*, VM&amp;);
<span class="line-modified">!     static String toStringName(const JSObject*, ExecState*);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool customHasInstance(JSObject*, ExecState*, JSValue);</span>
<span class="line-modified">!     static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;);</span>
  
  private:
      friend class LLIntOffsetsExtractor;
      friend class JSCellLock;
  
<span class="line-modified">!     JS_EXPORT_PRIVATE JSObject* toObjectSlow(ExecState*, JSGlobalObject*) const;</span>
  
      StructureID m_structureID;
      IndexingType m_indexingTypeAndMisc; // DO NOT store to this field. Always CAS.
      JSType m_type;
      TypeInfo::InlineTypeFlags m_flags;
<span class="line-new-header">--- 241,36 ---</span>
  
      void finishCreation(VM&amp;);
      void finishCreation(VM&amp;, Structure*, CreatingEarlyCellTag);
  
      // Dummy implementations of override-able static functions for classes to put in their MethodTable
<span class="line-modified">!     static JSValue defaultValue(const JSObject*, JSGlobalObject*, PreferredPrimitiveType);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     static uint32_t getEnumerableLength(JSGlobalObject*, JSObject*);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool preventExtensions(JSObject*, JSGlobalObject*);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool isExtensible(JSObject*, JSGlobalObject*);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool setPrototype(JSObject*, JSGlobalObject*, JSValue, bool);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH JSValue getPrototype(JSObject*, JSGlobalObject*);</span>
  
      static String className(const JSObject*, VM&amp;);
<span class="line-modified">!     static String toStringName(const JSObject*, JSGlobalObject*);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool customHasInstance(JSObject*, JSGlobalObject*, JSValue);</span>
<span class="line-modified">!     static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH void doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;);</span>
  
  private:
      friend class LLIntOffsetsExtractor;
      friend class JSCellLock;
  
<span class="line-modified">!     JS_EXPORT_PRIVATE JSObject* toObjectSlow(JSGlobalObject*) const;</span>
  
      StructureID m_structureID;
      IndexingType m_indexingTypeAndMisc; // DO NOT store to this field. Always CAS.
      JSType m_type;
      TypeInfo::InlineTypeFlags m_flags;
</pre>
<center><a href="JSCell.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCellInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
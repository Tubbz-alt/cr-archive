diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.h
@@ -26,17 +26,19 @@
  */
 
 #pragma once
 
 #include "AffineTransform.h"
+#include "AlphaPremultiplication.h"
 #include "ColorSpace.h"
 #include "GraphicsTypes.h"
-#include "GraphicsTypes3D.h"
+#include "GraphicsTypesGL.h"
 #include "ImageBufferData.h"
 #include "ImagePaintingOptions.h"
 #include "IntSize.h"
 #include "PlatformLayer.h"
+#include "RenderingMode.h"
 #include <JavaScriptCore/Uint8ClampedArray.h>
 #include <memory>
 #include <wtf/Forward.h>
 #include <wtf/IsoMalloc.h>
 #include <wtf/RefPtr.h>
@@ -44,11 +46,11 @@
 
 namespace WebCore {
 
 class FloatRect;
 class GraphicsContext;
-class GraphicsContext3D;
+class GraphicsContextGLOpenGL;
 class Image;
 class ImageData;
 class IntPoint;
 class IntRect;
 class HostWindow;
@@ -67,13 +69,13 @@
     WTF_MAKE_ISO_ALLOCATED_EXPORT(ImageBuffer, WEBCORE_EXPORT);
     WTF_MAKE_NONCOPYABLE(ImageBuffer);
     friend class IOSurface;
 public:
     // Will return a null pointer on allocation failure.
-    WEBCORE_EXPORT static std::unique_ptr<ImageBuffer> create(const FloatSize&, RenderingMode, float resolutionScale = 1, ColorSpace = ColorSpaceSRGB, const HostWindow* = nullptr);
+    WEBCORE_EXPORT static std::unique_ptr<ImageBuffer> create(const FloatSize&, RenderingMode, float resolutionScale = 1, ColorSpace = ColorSpace::SRGB, const HostWindow* = nullptr);
 #if USE(DIRECT2D)
-    WEBCORE_EXPORT static std::unique_ptr<ImageBuffer> create(const FloatSize&, RenderingMode, const GraphicsContext*, float resolutionScale = 1, ColorSpace = ColorSpaceSRGB, const HostWindow* = nullptr);
+    WEBCORE_EXPORT static std::unique_ptr<ImageBuffer> create(const FloatSize&, RenderingMode, const GraphicsContext*, float resolutionScale = 1, ColorSpace = ColorSpace::SRGB, const HostWindow* = nullptr);
 #endif
 
     // Create an image buffer compatible with the context and copy rect from this buffer into this new one.
     std::unique_ptr<ImageBuffer> copyRectToBuffer(const FloatRect&, ColorSpace, const GraphicsContext&);
 
@@ -81,29 +83,22 @@
     static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, const GraphicsContext&);
     static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, ColorSpace, const GraphicsContext&);
     static std::unique_ptr<ImageBuffer> createCompatibleBuffer(const FloatSize&, float resolutionScale, ColorSpace, const GraphicsContext&);
 
     static IntSize compatibleBufferSize(const FloatSize&, const GraphicsContext&);
-    bool isCompatibleWithContext(const GraphicsContext&) const;
 
     WEBCORE_EXPORT ~ImageBuffer();
 
     // The actual resolution of the backing store
     const IntSize& internalSize() const { return m_size; }
     const IntSize& logicalSize() const { return m_logicalSize; }
-
-    FloatSize sizeForDestinationSize(FloatSize) const;
-
     float resolutionScale() const { return m_resolutionScale; }
 
     WEBCORE_EXPORT GraphicsContext& context() const;
 
     WEBCORE_EXPORT RefPtr<Image> copyImage(BackingStoreCopy = CopyBackingStore, PreserveResolution = PreserveResolution::No) const;
     WEBCORE_EXPORT static RefPtr<Image> sinkIntoImage(std::unique_ptr<ImageBuffer>, PreserveResolution = PreserveResolution::No);
-    // Give hints on the faster copyImage Mode, return DontCopyBackingStore if it supports the DontCopyBackingStore behavior
-    // or return CopyBackingStore if it doesn't.
-    static BackingStoreCopy fastCopyImageMode();
 
     enum CoordinateSystem { LogicalCoordinateSystem, BackingStoreCoordinateSystem };
 
     RefPtr<Uint8ClampedArray> getUnmultipliedImageData(const IntRect&, IntSize* pixelArrayDimensions = nullptr, CoordinateSystem = LogicalCoordinateSystem) const;
     RefPtr<Uint8ClampedArray> getPremultipliedImageData(const IntRect&, IntSize* pixelArrayDimensions = nullptr, CoordinateSystem = LogicalCoordinateSystem) const;
@@ -114,10 +109,14 @@
 
     String toDataURL(const String& mimeType, Optional<double> quality = WTF::nullopt, PreserveResolution = PreserveResolution::No) const;
     Vector<uint8_t> toData(const String& mimeType, Optional<double> quality = WTF::nullopt) const;
     Vector<uint8_t> toBGRAData() const;
 
+#if USE(CAIRO)
+    NativeImagePtr nativeImage() const;
+#endif
+
 #if !USE(CG)
     AffineTransform baseTransform() const { return AffineTransform(); }
     void transformColorSpace(ColorSpace srcColorSpace, ColorSpace dstColorSpace);
     void platformTransformColorSpace(const std::array<uint8_t, 256>&);
 #else
@@ -128,11 +127,11 @@
     size_t memoryCost() const;
     size_t externalMemoryCost() const;
 
     // FIXME: current implementations of this method have the restriction that they only work
     // with textures that are RGB or RGBA format, and UNSIGNED_BYTE type.
-    bool copyToPlatformTexture(GraphicsContext3D&, GC3Denum, Platform3DObject, GC3Denum, bool, bool);
+    bool copyToPlatformTexture(GraphicsContextGLOpenGL&, GCGLenum, PlatformGLObject, GCGLenum, bool, bool);
 
     // These functions are used when clamping the ImageBuffer which is created for filter, masker or clipper.
     static bool sizeNeedsClamping(const FloatSize&);
     static bool sizeNeedsClamping(const FloatSize&, FloatSize& scale);
     static FloatSize clampedSize(const FloatSize&);
@@ -163,10 +162,11 @@
     friend class GeneratedImage;
     friend class CrossfadeGeneratedImage;
     friend class NamedImageGeneratedImage;
     friend class GradientImage;
     friend class CustomPaintImage;
+    friend class BitmapImage;
 
 private:
     ImageBufferData m_data;
     IntSize m_size;
     IntSize m_logicalSize;
@@ -181,12 +181,6 @@
 #elif USE(DIRECT2D)
     ImageBuffer(const FloatSize&, float resolutionScale, ColorSpace, RenderingMode, const HostWindow*, const GraphicsContext*, bool& success);
 #endif
 };
 
-#if USE(CG)
-String dataURL(const ImageData&, const String& mimeType, Optional<double> quality);
-Vector<uint8_t> data(const ImageData&, const String& mimeType, Optional<double> quality);
-#endif
-
 } // namespace WebCore
-

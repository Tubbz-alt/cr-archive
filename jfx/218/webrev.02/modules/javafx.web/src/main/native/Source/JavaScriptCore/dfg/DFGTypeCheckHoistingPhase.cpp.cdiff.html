<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGToFTLForOSREntryDeferredCompilationCallback.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGUseKind.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 141,37 ***</span>
                      RELEASE_ASSERT(origin.exitOK);
  
                      Node* getLocal = insertionSet.insertNode(
                          indexInBlock + 1, variable-&gt;prediction(), GetLocal, origin,
                          OpInfo(variable), Edge(node));
<span class="line-modified">!                     if (iter-&gt;value.m_structure) {</span>
<span class="line-modified">!                         auto checkOp = CheckStructure;</span>
<span class="line-modified">!                         if (SpecCellCheck &amp; SpecEmpty) {</span>
<span class="line-modified">!                             VirtualRegister local = node-&gt;variableAccessData()-&gt;local();</span>
<span class="line-modified">!                             auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified">!                             if ((local - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0)) == virtualRegisterForArgument(0)) {</span>
<span class="line-modified">!                                 // |this| can be the TDZ value. The call entrypoint won&#39;t have |this| as TDZ,</span>
<span class="line-modified">!                                 // but a catch or a loop OSR entry may have |this| be TDZ.</span>
<span class="line-modified">!                                 checkOp = CheckStructureOrEmpty;</span>
<span class="line-modified">!                             }</span>
                          }
  
                          insertionSet.insertNode(
                              indexInBlock + 1, SpecNone, checkOp, origin,
                              OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
                              Edge(getLocal, CellUse));
                      } else if (iter-&gt;value.m_arrayModeIsValid) {
                          ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
                          insertionSet.insertNode(
<span class="line-modified">!                             indexInBlock + 1, SpecNone, CheckArray, origin,</span>
                              OpInfo(iter-&gt;value.m_arrayMode.asWord()),
                              Edge(getLocal, CellUse));
                      } else
                          RELEASE_ASSERT_NOT_REACHED();
  
<span class="line-modified">!                     if (block-&gt;variablesAtTail.operand(variable-&gt;local()) == node)</span>
<span class="line-modified">!                         block-&gt;variablesAtTail.operand(variable-&gt;local()) = getLocal;</span>
  
                      m_graph.substituteGetLocal(*block, indexInBlock, variable, getLocal);
  
                      changed = true;
                      break;
<span class="line-new-header">--- 141,46 ---</span>
                      RELEASE_ASSERT(origin.exitOK);
  
                      Node* getLocal = insertionSet.insertNode(
                          indexInBlock + 1, variable-&gt;prediction(), GetLocal, origin,
                          OpInfo(variable), Edge(node));
<span class="line-modified">! </span>
<span class="line-modified">!                     auto needsEmptyCheck = [](Node* node) -&gt; bool {</span>
<span class="line-modified">!                         if (!(SpecCellCheck &amp; SpecEmpty))</span>
<span class="line-modified">!                             return false;</span>
<span class="line-modified">!                         VirtualRegister local = node-&gt;variableAccessData()-&gt;operand().virtualRegister();</span>
<span class="line-modified">!                         auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified">!                         if ((local - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0)) == virtualRegisterForArgumentIncludingThis(0)) {</span>
<span class="line-modified">!                             // |this| can be the TDZ value. The call entrypoint won&#39;t have |this| as TDZ,</span>
<span class="line-modified">!                             // but a catch or a loop OSR entry may have |this| be TDZ.</span>
<span class="line-modified">!                             return true;</span>
                          }
<span class="line-added">+                         return false;</span>
<span class="line-added">+                     };</span>
  
<span class="line-added">+                     if (iter-&gt;value.m_structure) {</span>
<span class="line-added">+                         auto checkOp = CheckStructure;</span>
<span class="line-added">+                         if (needsEmptyCheck(node))</span>
<span class="line-added">+                             checkOp = CheckStructureOrEmpty;</span>
                          insertionSet.insertNode(
                              indexInBlock + 1, SpecNone, checkOp, origin,
                              OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
                              Edge(getLocal, CellUse));
                      } else if (iter-&gt;value.m_arrayModeIsValid) {
                          ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
<span class="line-added">+                         auto checkOp = CheckArray;</span>
<span class="line-added">+                         if (needsEmptyCheck(node))</span>
<span class="line-added">+                             checkOp = CheckArrayOrEmpty;</span>
                          insertionSet.insertNode(
<span class="line-modified">!                             indexInBlock + 1, SpecNone, checkOp, origin,</span>
                              OpInfo(iter-&gt;value.m_arrayMode.asWord()),
                              Edge(getLocal, CellUse));
                      } else
                          RELEASE_ASSERT_NOT_REACHED();
  
<span class="line-modified">!                     if (block-&gt;variablesAtTail.operand(variable-&gt;operand()) == node)</span>
<span class="line-modified">!                         block-&gt;variablesAtTail.operand(variable-&gt;operand()) = getLocal;</span>
  
                      m_graph.substituteGetLocal(*block, indexInBlock, variable, getLocal);
  
                      changed = true;
                      break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,25 ***</span>
                          break;
  
                      NodeOrigin origin = node-&gt;origin;
                      Edge child1 = node-&gt;child1();
  
                      if (iter-&gt;value.m_structure) {
<span class="line-removed">-                         // Note: On 64-bit platforms, cell checks allow the empty value to flow through.</span>
<span class="line-removed">-                         // This means that this structure check may see the empty value as input. We need</span>
<span class="line-removed">-                         // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty</span>
<span class="line-removed">-                         // will be folded to CheckStructure because AI proves that the incoming value is</span>
<span class="line-removed">-                         // definitely not empty.</span>
                          insertionSet.insertNode(
                              indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckStructureOrEmpty : CheckStructure,
                              originForChecks.withSemantic(origin.semantic),
                              OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
                              Edge(child1.node(), CellUse));
                      } else if (iter-&gt;value.m_arrayModeIsValid) {
                          ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
                          insertionSet.insertNode(
<span class="line-modified">!                             indexForChecks, SpecNone, CheckArray,</span>
                              originForChecks.withSemantic(origin.semantic),
                              OpInfo(iter-&gt;value.m_arrayMode.asWord()),
                              Edge(child1.node(), CellUse));
                      } else
                          RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 195,25 ---</span>
                          break;
  
                      NodeOrigin origin = node-&gt;origin;
                      Edge child1 = node-&gt;child1();
  
<span class="line-added">+                     // Note: On 64-bit platforms, cell checks allow the empty value to flow through.</span>
<span class="line-added">+                     // This means that this structure/array check may see the empty value as input. We need</span>
<span class="line-added">+                     // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty/CheckArrayOrEmpty</span>
<span class="line-added">+                     // will be folded to CheckStructure/CheckArray because AI proves that the incoming value is</span>
<span class="line-added">+                     // definitely not empty.</span>
                      if (iter-&gt;value.m_structure) {
                          insertionSet.insertNode(
                              indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckStructureOrEmpty : CheckStructure,
                              originForChecks.withSemantic(origin.semantic),
                              OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
                              Edge(child1.node(), CellUse));
                      } else if (iter-&gt;value.m_arrayModeIsValid) {
                          ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
                          insertionSet.insertNode(
<span class="line-modified">!                             indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckArrayOrEmpty : CheckArray,</span>
                              originForChecks.withSemantic(origin.semantic),
                              OpInfo(iter-&gt;value.m_arrayMode.asWord()),
                              Edge(child1.node(), CellUse));
                      } else
                          RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,10 ***</span>
<span class="line-new-header">--- 278,11 ---</span>
                  case PutByValDirect:
                  case PutByVal:
                  case PutByValAlias:
                  case GetArrayLength:
                  case CheckArray:
<span class="line-added">+                 case CheckNeutered:</span>
                  case GetIndexedPropertyStorage:
                  case GetTypedArrayByteOffset:
                  case Phantom:
                  case MovHint:
                  case MultiGetByOffset:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,10 ***</span>
<span class="line-new-header">--- 344,11 ---</span>
                      noticeCheckArray(variable, node-&gt;arrayMode());
                      break;
                  }
  
                  case CheckStructure:
<span class="line-added">+                 case CheckNeutered:</span>
                  case GetByOffset:
                  case PutByOffset:
                  case PutStructure:
                  case ReallocatePropertyStorage:
                  case GetButterfly:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,11 ***</span>
                  continue;
              if (block-&gt;bytecodeBegin != m_graph.m_plan.osrEntryBytecodeIndex())
                  continue;
              const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
              for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<span class="line-modified">!                 int operand = mustHandleValues.operandForIndex(i);</span>
                  Node* node = block-&gt;variablesAtHead.operand(operand);
                  if (!node)
                      continue;
                  VariableAccessData* variable = node-&gt;variableAccessData();
                  HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
<span class="line-new-header">--- 455,11 ---</span>
                  continue;
              if (block-&gt;bytecodeBegin != m_graph.m_plan.osrEntryBytecodeIndex())
                  continue;
              const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
              for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<span class="line-modified">!                 Operand operand = mustHandleValues.operandForIndex(i);</span>
                  Node* node = block-&gt;variablesAtHead.operand(operand);
                  if (!node)
                      continue;
                  VariableAccessData* variable = node-&gt;variableAccessData();
                  HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
</pre>
<center><a href="DFGToFTLForOSREntryDeferredCompilationCallback.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGUseKind.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
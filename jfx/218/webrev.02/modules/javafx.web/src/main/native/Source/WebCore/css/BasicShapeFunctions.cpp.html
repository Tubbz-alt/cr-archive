<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/BasicShapeFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;BasicShapeFunctions.h&quot;
 32 
 33 #include &quot;BasicShapes.h&quot;
 34 #include &quot;CSSBasicShapes.h&quot;
 35 #include &quot;CSSPrimitiveValueMappings.h&quot;
 36 #include &quot;CSSValuePool.h&quot;
 37 #include &quot;Pair.h&quot;
 38 #include &quot;RenderStyle.h&quot;
 39 #include &quot;SVGPathByteStream.h&quot;
 40 
 41 namespace WebCore {
 42 
 43 static Ref&lt;CSSPrimitiveValue&gt; valueForCenterCoordinate(CSSValuePool&amp; pool, const RenderStyle&amp; style, const BasicShapeCenterCoordinate&amp; center, BoxOrient orientation)
 44 {
 45     if (center.direction() == BasicShapeCenterCoordinate::TopLeft)
 46         return pool.createValue(center.length(), style);
 47 
 48     CSSValueID keyword = orientation == BoxOrient::Horizontal ? CSSValueRight : CSSValueBottom;
 49 
 50     return pool.createValue(Pair::create(pool.createIdentifierValue(keyword), pool.createValue(center.length(), style)));
 51 }
 52 
 53 static Ref&lt;CSSPrimitiveValue&gt; basicShapeRadiusToCSSValue(const RenderStyle&amp; style, CSSValuePool&amp; pool, const BasicShapeRadius&amp; radius)
 54 {
 55     switch (radius.type()) {
 56     case BasicShapeRadius::Value:
 57         return pool.createValue(radius.value(), style);
 58     case BasicShapeRadius::ClosestSide:
 59         return pool.createIdentifierValue(CSSValueClosestSide);
 60     case BasicShapeRadius::FarthestSide:
 61         return pool.createIdentifierValue(CSSValueFarthestSide);
 62     }
 63 
 64     ASSERT_NOT_REACHED();
 65     return pool.createIdentifierValue(CSSValueClosestSide);
 66 }
 67 
 68 Ref&lt;CSSPrimitiveValue&gt; valueForBasicShape(const RenderStyle&amp; style, const BasicShape&amp; basicShape)
 69 {
 70     auto&amp; cssValuePool = CSSValuePool::singleton();
 71 
 72     RefPtr&lt;CSSBasicShape&gt; basicShapeValue;
 73     switch (basicShape.type()) {
 74     case BasicShape::Type::Circle: {
 75         auto&amp; circle = downcast&lt;BasicShapeCircle&gt;(basicShape);
 76         auto circleValue = CSSBasicShapeCircle::create();
 77 
 78         circleValue-&gt;setCenterX(valueForCenterCoordinate(cssValuePool, style, circle.centerX(), BoxOrient::Horizontal));
 79         circleValue-&gt;setCenterY(valueForCenterCoordinate(cssValuePool, style, circle.centerY(), BoxOrient::Vertical));
 80         circleValue-&gt;setRadius(basicShapeRadiusToCSSValue(style, cssValuePool, circle.radius()));
 81 
 82         basicShapeValue = WTFMove(circleValue);
 83         break;
 84     }
 85     case BasicShape::Type::Ellipse: {
 86         auto&amp; ellipse = downcast&lt;BasicShapeEllipse&gt;(basicShape);
 87         auto ellipseValue = CSSBasicShapeEllipse::create();
 88 
 89         ellipseValue-&gt;setCenterX(valueForCenterCoordinate(cssValuePool, style, ellipse.centerX(), BoxOrient::Horizontal));
 90         ellipseValue-&gt;setCenterY(valueForCenterCoordinate(cssValuePool, style, ellipse.centerY(), BoxOrient::Vertical));
 91         ellipseValue-&gt;setRadiusX(basicShapeRadiusToCSSValue(style, cssValuePool, ellipse.radiusX()));
 92         ellipseValue-&gt;setRadiusY(basicShapeRadiusToCSSValue(style, cssValuePool, ellipse.radiusY()));
 93 
 94         basicShapeValue = WTFMove(ellipseValue);
 95         break;
 96     }
 97     case BasicShape::Type::Polygon: {
 98         auto&amp; polygon = downcast&lt;BasicShapePolygon&gt;(basicShape);
 99         auto polygonValue = CSSBasicShapePolygon::create();
100 
101         polygonValue-&gt;setWindRule(polygon.windRule());
102         const Vector&lt;Length&gt;&amp; values = polygon.values();
103         for (unsigned i = 0; i &lt; values.size(); i += 2)
104             polygonValue-&gt;appendPoint(cssValuePool.createValue(values.at(i), style), cssValuePool.createValue(values.at(i + 1), style));
105 
106         basicShapeValue = WTFMove(polygonValue);
107         break;
108     }
109     case BasicShape::Type::Path: {
110         auto&amp; pathShape = downcast&lt;BasicShapePath&gt;(basicShape);
111         auto pathShapeValue = CSSBasicShapePath::create(pathShape.pathData()-&gt;copy());
112         pathShapeValue-&gt;setWindRule(pathShape.windRule());
113 
114         basicShapeValue = WTFMove(pathShapeValue);
115         break;
116     }
117     case BasicShape::Type::Inset: {
118         auto&amp; inset = downcast&lt;BasicShapeInset&gt;(basicShape);
119         auto insetValue = CSSBasicShapeInset::create();
120 
121         insetValue-&gt;setTop(cssValuePool.createValue(inset.top(), style));
122         insetValue-&gt;setRight(cssValuePool.createValue(inset.right(), style));
123         insetValue-&gt;setBottom(cssValuePool.createValue(inset.bottom(), style));
124         insetValue-&gt;setLeft(cssValuePool.createValue(inset.left(), style));
125 
126         insetValue-&gt;setTopLeftRadius(cssValuePool.createValue(inset.topLeftRadius(), style));
127         insetValue-&gt;setTopRightRadius(cssValuePool.createValue(inset.topRightRadius(), style));
128         insetValue-&gt;setBottomRightRadius(cssValuePool.createValue(inset.bottomRightRadius(), style));
129         insetValue-&gt;setBottomLeftRadius(cssValuePool.createValue(inset.bottomLeftRadius(), style));
130 
131         basicShapeValue = WTFMove(insetValue);
132         break;
133     }
134     }
135 
136     return cssValuePool.createValue(basicShapeValue.releaseNonNull());
137 }
138 
139 static Length convertToLength(const CSSToLengthConversionData&amp; conversionData, const CSSPrimitiveValue* value)
140 {
141     return value-&gt;convertToLength&lt;FixedIntegerConversion | FixedFloatConversion | PercentConversion | CalculatedConversion&gt;(conversionData);
142 }
143 
144 static LengthSize convertToLengthSize(const CSSToLengthConversionData&amp; conversionData, const CSSPrimitiveValue* value)
145 {
146     if (!value)
147         return { { 0, Fixed }, { 0, Fixed } };
148 
149     auto&amp; pair = *value-&gt;pairValue();
150     return { convertToLength(conversionData, pair.first()), convertToLength(conversionData, pair.second()) };
151 }
152 
153 static BasicShapeCenterCoordinate convertToCenterCoordinate(const CSSToLengthConversionData&amp; conversionData, CSSPrimitiveValue* value)
154 {
155     CSSValueID keyword = CSSValueTop;
156     Length offset { 0, Fixed };
157     if (!value)
158         keyword = CSSValueCenter;
159     else if (value-&gt;isValueID())
160         keyword = value-&gt;valueID();
161     else if (Pair* pair = value-&gt;pairValue()) {
162         keyword = pair-&gt;first()-&gt;valueID();
163         offset = convertToLength(conversionData, pair-&gt;second());
164     } else
165         offset = convertToLength(conversionData, value);
166 
167     BasicShapeCenterCoordinate::Direction direction;
168     switch (keyword) {
169     case CSSValueTop:
170     case CSSValueLeft:
171         direction = BasicShapeCenterCoordinate::TopLeft;
172         break;
173     case CSSValueRight:
174     case CSSValueBottom:
175         direction = BasicShapeCenterCoordinate::BottomRight;
176         break;
177     case CSSValueCenter:
178         direction = BasicShapeCenterCoordinate::TopLeft;
179         offset = Length(50, Percent);
180         break;
181     default:
182         ASSERT_NOT_REACHED();
183         direction = BasicShapeCenterCoordinate::TopLeft;
184         break;
185     }
186 
187     return BasicShapeCenterCoordinate(direction, offset);
188 }
189 
190 static BasicShapeRadius cssValueToBasicShapeRadius(const CSSToLengthConversionData&amp; conversionData, CSSPrimitiveValue* radius)
191 {
192     if (!radius)
193         return BasicShapeRadius(BasicShapeRadius::ClosestSide);
194 
195     if (radius-&gt;isValueID()) {
196         switch (radius-&gt;valueID()) {
197         case CSSValueClosestSide:
198             return BasicShapeRadius(BasicShapeRadius::ClosestSide);
199         case CSSValueFarthestSide:
200             return BasicShapeRadius(BasicShapeRadius::FarthestSide);
201         default:
202             ASSERT_NOT_REACHED();
203             break;
204         }
205     }
206 
207     return BasicShapeRadius(convertToLength(conversionData, radius));
208 }
209 
210 Ref&lt;BasicShape&gt; basicShapeForValue(const CSSToLengthConversionData&amp; conversionData, const CSSBasicShape&amp; basicShapeValue)
211 {
212     RefPtr&lt;BasicShape&gt; basicShape;
213 
214     switch (basicShapeValue.type()) {
215     case CSSBasicShape::CSSBasicShapeCircleType: {
216         auto&amp; circleValue = downcast&lt;CSSBasicShapeCircle&gt;(basicShapeValue);
217         auto circle = BasicShapeCircle::create();
218 
219         circle-&gt;setCenterX(convertToCenterCoordinate(conversionData, circleValue.centerX()));
220         circle-&gt;setCenterY(convertToCenterCoordinate(conversionData, circleValue.centerY()));
221         circle-&gt;setRadius(cssValueToBasicShapeRadius(conversionData, circleValue.radius()));
222 
223         basicShape = WTFMove(circle);
224         break;
225     }
226     case CSSBasicShape::CSSBasicShapeEllipseType: {
227         auto&amp; ellipseValue = downcast&lt;CSSBasicShapeEllipse&gt;(basicShapeValue);
228         auto ellipse = BasicShapeEllipse::create();
229 
230         ellipse-&gt;setCenterX(convertToCenterCoordinate(conversionData, ellipseValue.centerX()));
231         ellipse-&gt;setCenterY(convertToCenterCoordinate(conversionData, ellipseValue.centerY()));
232 
233         ellipse-&gt;setRadiusX(cssValueToBasicShapeRadius(conversionData, ellipseValue.radiusX()));
234         ellipse-&gt;setRadiusY(cssValueToBasicShapeRadius(conversionData, ellipseValue.radiusY()));
235 
236         basicShape = WTFMove(ellipse);
237         break;
238     }
239     case CSSBasicShape::CSSBasicShapePolygonType: {
240         auto&amp; polygonValue = downcast&lt;CSSBasicShapePolygon&gt;(basicShapeValue);
241         auto polygon = BasicShapePolygon::create();
242 
243         polygon-&gt;setWindRule(polygonValue.windRule());
244         auto&amp; values = polygonValue.values();
245         for (unsigned i = 0; i &lt; values.size(); i += 2)
246             polygon-&gt;appendPoint(convertToLength(conversionData, values[i].ptr()), convertToLength(conversionData, values[i + 1].ptr()));
247 
248         basicShape = WTFMove(polygon);
249         break;
250     }
251     case CSSBasicShape::CSSBasicShapeInsetType: {
252         auto&amp; rectValue = downcast&lt;CSSBasicShapeInset&gt;(basicShapeValue);
253         auto rect = BasicShapeInset::create();
254 
255         rect-&gt;setTop(convertToLength(conversionData, rectValue.top()));
256         rect-&gt;setRight(convertToLength(conversionData, rectValue.right()));
257         rect-&gt;setBottom(convertToLength(conversionData, rectValue.bottom()));
258         rect-&gt;setLeft(convertToLength(conversionData, rectValue.left()));
259 
260         rect-&gt;setTopLeftRadius(convertToLengthSize(conversionData, rectValue.topLeftRadius()));
261         rect-&gt;setTopRightRadius(convertToLengthSize(conversionData, rectValue.topRightRadius()));
262         rect-&gt;setBottomRightRadius(convertToLengthSize(conversionData, rectValue.bottomRightRadius()));
263         rect-&gt;setBottomLeftRadius(convertToLengthSize(conversionData, rectValue.bottomLeftRadius()));
264 
265         basicShape = WTFMove(rect);
266         break;
267     }
268     case CSSBasicShape::CSSBasicShapePathType: {
269         auto&amp; pathValue = downcast&lt;CSSBasicShapePath&gt;(basicShapeValue);
270         auto path = BasicShapePath::create(pathValue.pathData().copy());
271         path-&gt;setWindRule(pathValue.windRule());
272 
273         basicShape = WTFMove(path);
274         break;
275     }
276     }
277 
278     return basicShape.releaseNonNull();
279 }
280 
281 float floatValueForCenterCoordinate(const BasicShapeCenterCoordinate&amp; center, float boxDimension)
282 {
283     float offset = floatValueForLength(center.length(), boxDimension);
284     if (center.direction() == BasicShapeCenterCoordinate::TopLeft)
285         return offset;
286     return boxDimension - offset;
287 }
288 
289 }
    </pre>
  </body>
</html>
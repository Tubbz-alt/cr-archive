<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AssemblerBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblerCommon.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 87     using AssemblerBuffer::putIntegral;
 88     using AssemblerBuffer::putIntegralUnchecked;
 89 public:
 90     typedef struct {
 91         short high;
 92         short low;
 93     } TwoShorts;
 94 
 95     enum {
 96         UniqueConst,
 97         ReusableConst,
 98         UnusedEntry,
 99     };
100 
101     AssemblerBufferWithConstantPool()
102         : AssemblerBuffer()
103         , m_numConsts(0)
104         , m_maxDistance(maxPoolSize)
105         , m_lastConstDelta(0)
106     {
<span class="line-modified">107         m_pool = static_cast&lt;uint32_t*&gt;(fastMalloc(maxPoolSize));</span>
<span class="line-modified">108         m_mask = static_cast&lt;char*&gt;(fastMalloc(maxPoolSize / sizeof(uint32_t)));</span>
109     }
110 
111     ~AssemblerBufferWithConstantPool()
112     {
<span class="line-modified">113         fastFree(m_mask);</span>
<span class="line-modified">114         fastFree(m_pool);</span>
115     }
116 
117     void ensureSpace(int space)
118     {
119         flushIfNoSpaceFor(space);
120         AssemblerBuffer::ensureSpace(space);
121     }
122 
123     void ensureSpace(int insnSpace, int constSpace)
124     {
125         flushIfNoSpaceFor(insnSpace, constSpace);
126         AssemblerBuffer::ensureSpace(insnSpace);
127     }
128 
129     void ensureSpaceForAnyInstruction(int amount = 1)
130     {
131         flushIfNoSpaceFor(amount * maxInstructionSize, amount * sizeof(uint64_t));
132     }
133 
134     bool isAligned(int alignment)
</pre>
</td>
<td>
<hr />
<pre>
 87     using AssemblerBuffer::putIntegral;
 88     using AssemblerBuffer::putIntegralUnchecked;
 89 public:
 90     typedef struct {
 91         short high;
 92         short low;
 93     } TwoShorts;
 94 
 95     enum {
 96         UniqueConst,
 97         ReusableConst,
 98         UnusedEntry,
 99     };
100 
101     AssemblerBufferWithConstantPool()
102         : AssemblerBuffer()
103         , m_numConsts(0)
104         , m_maxDistance(maxPoolSize)
105         , m_lastConstDelta(0)
106     {
<span class="line-modified">107         m_pool = static_cast&lt;uint32_t*&gt;(AssemblerDataMalloc::malloc(maxPoolSize));</span>
<span class="line-modified">108         m_mask = static_cast&lt;char*&gt;(AssemblerDataMalloc::malloc(maxPoolSize / sizeof(uint32_t)));</span>
109     }
110 
111     ~AssemblerBufferWithConstantPool()
112     {
<span class="line-modified">113         AssemblerDataMalloc::free(m_mask);</span>
<span class="line-modified">114         AssemblerDataMalloc::free(m_pool);</span>
115     }
116 
117     void ensureSpace(int space)
118     {
119         flushIfNoSpaceFor(space);
120         AssemblerBuffer::ensureSpace(space);
121     }
122 
123     void ensureSpace(int insnSpace, int constSpace)
124     {
125         flushIfNoSpaceFor(insnSpace, constSpace);
126         AssemblerBuffer::ensureSpace(insnSpace);
127     }
128 
129     void ensureSpaceForAnyInstruction(int amount = 1)
130     {
131         flushIfNoSpaceFor(amount * maxInstructionSize, amount * sizeof(uint64_t));
132     }
133 
134     bool isAligned(int alignment)
</pre>
</td>
</tr>
</table>
<center><a href="AssemblerBuffer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblerCommon.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
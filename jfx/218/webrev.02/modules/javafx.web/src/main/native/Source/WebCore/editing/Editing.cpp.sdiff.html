<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editing.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/Editing.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Editing.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;

  30 #include &quot;Document.h&quot;
  31 #include &quot;Editor.h&quot;
  32 #include &quot;Frame.h&quot;
  33 #include &quot;HTMLBodyElement.h&quot;
  34 #include &quot;HTMLDListElement.h&quot;
  35 #include &quot;HTMLDivElement.h&quot;
  36 #include &quot;HTMLElementFactory.h&quot;

  37 #include &quot;HTMLInterchange.h&quot;
  38 #include &quot;HTMLLIElement.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;HTMLOListElement.h&quot;
  41 #include &quot;HTMLParagraphElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLTableElement.h&quot;
  44 #include &quot;HTMLTextFormControlElement.h&quot;
  45 #include &quot;HTMLUListElement.h&quot;
  46 #include &quot;NodeTraversal.h&quot;
  47 #include &quot;PositionIterator.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderElement.h&quot;
  50 #include &quot;RenderTableCell.h&quot;
  51 #include &quot;ShadowRoot.h&quot;
  52 #include &quot;Text.h&quot;
  53 #include &quot;TextIterator.h&quot;
  54 #include &quot;VisibleUnits.h&quot;
  55 #include &lt;wtf/Assertions.h&gt;
  56 #include &lt;wtf/StdLibExtras.h&gt;
</pre>
<hr />
<pre>
1105 VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope)
1106 {
1107     auto range = TextIterator::rangeFromLocationAndLength(scope, index, 0, true);
1108     // Check for an invalid index. Certain editing operations invalidate indices because
1109     // of problems with TextIteratorEmitsCharactersBetweenAllVisiblePositions.
1110     if (!range)
1111         return { };
1112     return { range-&gt;startPosition() };
1113 }
1114 
1115 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp; node, int index)
1116 {
1117     if (index &lt;= 0)
1118         return { firstPositionInOrBeforeNode(&amp;node), DOWNSTREAM };
1119 
1120     auto range = Range::create(node.document());
1121     range-&gt;selectNodeContents(node);
1122     CharacterIterator it(range.get());
1123     it.advance(index - 1);
1124 
<span class="line-modified">1125     if (!it.atEnd() &amp;&amp; it.text()[0] == &#39;\n&#39;) {</span>
1126         // FIXME: workaround for collapsed range (where only start position is correct) emitted for some emitted newlines.
<span class="line-modified">1127         auto iteratorRange = it.range();</span>
<span class="line-modified">1128         if (iteratorRange-&gt;startPosition() == iteratorRange-&gt;endPosition()) {</span>
<span class="line-modified">1129             it.advance(1);</span>
<span class="line-removed">1130             if (!it.atEnd())</span>
<span class="line-removed">1131                 return VisiblePosition(it.range()-&gt;startPosition());</span>
<span class="line-removed">1132         }</span>
1133     }
1134 
1135     return { it.atEnd() ? range-&gt;endPosition() : it.range()-&gt;endPosition(), UPSTREAM };
1136 }
1137 
1138 // Determines whether two positions are visibly next to each other (first then second)
1139 // while ignoring whitespaces and unrendered nodes
1140 static bool isVisiblyAdjacent(const Position&amp; first, const Position&amp; second)
1141 {
1142     return VisiblePosition(first) == VisiblePosition(second.upstream());
1143 }
1144 
1145 // Determines whether a node is inside a range or visibly starts and ends at the boundaries of the range.
1146 // Call this function to determine whether a node is visibly fit inside selectedRange
1147 bool isNodeVisiblyContainedWithin(Node&amp; node, const Range&amp; range)
1148 {
1149     // If the node is inside the range, then it surely is contained within.
1150     auto comparisonResult = range.compareNode(node);
1151     if (!comparisonResult.hasException() &amp;&amp; comparisonResult.releaseReturnValue() == Range::NODE_INSIDE)
1152         return true;
</pre>
<hr />
<pre>
1288         localRect.move(renderer-&gt;offsetFromContainer(*containerObject, localRect.location()));
1289         renderer = containerObject;
1290     }
1291 
1292     return localRect;
1293 }
1294 
1295 IntRect absoluteBoundsForLocalCaretRect(RenderBlock* rendererForCaretPainting, const LayoutRect&amp; rect, bool* insideFixed)
1296 {
1297     if (insideFixed)
1298         *insideFixed = false;
1299 
1300     if (!rendererForCaretPainting || rect.isEmpty())
1301         return IntRect();
1302 
1303     LayoutRect localRect(rect);
1304     rendererForCaretPainting-&gt;flipForWritingMode(localRect);
1305     return rendererForCaretPainting-&gt;localToAbsoluteQuad(FloatRect(localRect), UseTransforms, insideFixed).enclosingBoundingBox();
1306 }
1307 















1308 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Editing.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
<span class="line-added">  30 #include &quot;CachedImage.h&quot;</span>
  31 #include &quot;Document.h&quot;
  32 #include &quot;Editor.h&quot;
  33 #include &quot;Frame.h&quot;
  34 #include &quot;HTMLBodyElement.h&quot;
  35 #include &quot;HTMLDListElement.h&quot;
  36 #include &quot;HTMLDivElement.h&quot;
  37 #include &quot;HTMLElementFactory.h&quot;
<span class="line-added">  38 #include &quot;HTMLImageElement.h&quot;</span>
  39 #include &quot;HTMLInterchange.h&quot;
  40 #include &quot;HTMLLIElement.h&quot;
  41 #include &quot;HTMLNames.h&quot;
  42 #include &quot;HTMLOListElement.h&quot;
  43 #include &quot;HTMLParagraphElement.h&quot;
  44 #include &quot;HTMLSpanElement.h&quot;
  45 #include &quot;HTMLTableElement.h&quot;
  46 #include &quot;HTMLTextFormControlElement.h&quot;
  47 #include &quot;HTMLUListElement.h&quot;
  48 #include &quot;NodeTraversal.h&quot;
  49 #include &quot;PositionIterator.h&quot;
  50 #include &quot;RenderBlock.h&quot;
  51 #include &quot;RenderElement.h&quot;
  52 #include &quot;RenderTableCell.h&quot;
  53 #include &quot;ShadowRoot.h&quot;
  54 #include &quot;Text.h&quot;
  55 #include &quot;TextIterator.h&quot;
  56 #include &quot;VisibleUnits.h&quot;
  57 #include &lt;wtf/Assertions.h&gt;
  58 #include &lt;wtf/StdLibExtras.h&gt;
</pre>
<hr />
<pre>
1107 VisiblePosition visiblePositionForIndex(int index, ContainerNode* scope)
1108 {
1109     auto range = TextIterator::rangeFromLocationAndLength(scope, index, 0, true);
1110     // Check for an invalid index. Certain editing operations invalidate indices because
1111     // of problems with TextIteratorEmitsCharactersBetweenAllVisiblePositions.
1112     if (!range)
1113         return { };
1114     return { range-&gt;startPosition() };
1115 }
1116 
1117 VisiblePosition visiblePositionForIndexUsingCharacterIterator(Node&amp; node, int index)
1118 {
1119     if (index &lt;= 0)
1120         return { firstPositionInOrBeforeNode(&amp;node), DOWNSTREAM };
1121 
1122     auto range = Range::create(node.document());
1123     range-&gt;selectNodeContents(node);
1124     CharacterIterator it(range.get());
1125     it.advance(index - 1);
1126 
<span class="line-modified">1127     if (!it.atEnd() &amp;&amp; it.text().length() == 1 &amp;&amp; it.text()[0] == &#39;\n&#39;) {</span>
1128         // FIXME: workaround for collapsed range (where only start position is correct) emitted for some emitted newlines.
<span class="line-modified">1129         it.advance(1);</span>
<span class="line-modified">1130         if (!it.atEnd())</span>
<span class="line-modified">1131             return VisiblePosition(it.range()-&gt;startPosition());</span>



1132     }
1133 
1134     return { it.atEnd() ? range-&gt;endPosition() : it.range()-&gt;endPosition(), UPSTREAM };
1135 }
1136 
1137 // Determines whether two positions are visibly next to each other (first then second)
1138 // while ignoring whitespaces and unrendered nodes
1139 static bool isVisiblyAdjacent(const Position&amp; first, const Position&amp; second)
1140 {
1141     return VisiblePosition(first) == VisiblePosition(second.upstream());
1142 }
1143 
1144 // Determines whether a node is inside a range or visibly starts and ends at the boundaries of the range.
1145 // Call this function to determine whether a node is visibly fit inside selectedRange
1146 bool isNodeVisiblyContainedWithin(Node&amp; node, const Range&amp; range)
1147 {
1148     // If the node is inside the range, then it surely is contained within.
1149     auto comparisonResult = range.compareNode(node);
1150     if (!comparisonResult.hasException() &amp;&amp; comparisonResult.releaseReturnValue() == Range::NODE_INSIDE)
1151         return true;
</pre>
<hr />
<pre>
1287         localRect.move(renderer-&gt;offsetFromContainer(*containerObject, localRect.location()));
1288         renderer = containerObject;
1289     }
1290 
1291     return localRect;
1292 }
1293 
1294 IntRect absoluteBoundsForLocalCaretRect(RenderBlock* rendererForCaretPainting, const LayoutRect&amp; rect, bool* insideFixed)
1295 {
1296     if (insideFixed)
1297         *insideFixed = false;
1298 
1299     if (!rendererForCaretPainting || rect.isEmpty())
1300         return IntRect();
1301 
1302     LayoutRect localRect(rect);
1303     rendererForCaretPainting-&gt;flipForWritingMode(localRect);
1304     return rendererForCaretPainting-&gt;localToAbsoluteQuad(FloatRect(localRect), UseTransforms, insideFixed).enclosingBoundingBox();
1305 }
1306 
<span class="line-added">1307 HashSet&lt;RefPtr&lt;HTMLImageElement&gt;&gt; visibleImageElementsInRangeWithNonLoadedImages(const Range&amp; range)</span>
<span class="line-added">1308 {</span>
<span class="line-added">1309     HashSet&lt;RefPtr&lt;HTMLImageElement&gt;&gt; result;</span>
<span class="line-added">1310     for (TextIterator iterator(&amp;range); !iterator.atEnd(); iterator.advance()) {</span>
<span class="line-added">1311         if (!is&lt;HTMLImageElement&gt;(iterator.node()))</span>
<span class="line-added">1312             continue;</span>
<span class="line-added">1313 </span>
<span class="line-added">1314         auto&amp; imageElement = downcast&lt;HTMLImageElement&gt;(*iterator.node());</span>
<span class="line-added">1315         auto* cachedImage = imageElement.cachedImage();</span>
<span class="line-added">1316         if (cachedImage &amp;&amp; cachedImage-&gt;isLoading())</span>
<span class="line-added">1317             result.add(&amp;imageElement);</span>
<span class="line-added">1318     }</span>
<span class="line-added">1319     return result;</span>
<span class="line-added">1320 }</span>
<span class="line-added">1321 </span>
1322 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="EditCommand.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editing.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetByIdVariant.h&quot;
 28 
 29 #include &quot;CacheableIdentifierInlines.h&quot;
 30 #include &quot;CallLinkStatus.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &lt;wtf/ListDump.h&gt;
 33 
 34 namespace JSC {
 35 
 36 GetByIdVariant::GetByIdVariant(
 37     CacheableIdentifier identifier,
 38     const StructureSet&amp; structureSet, PropertyOffset offset,
 39     const ObjectPropertyConditionSet&amp; conditionSet,
 40     std::unique_ptr&lt;CallLinkStatus&gt; callLinkStatus,
 41     JSFunction* intrinsicFunction,
 42     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter,
 43     std::unique_ptr&lt;DOMAttributeAnnotation&gt; domAttribute)
 44     : m_structureSet(structureSet)
 45     , m_conditionSet(conditionSet)
 46     , m_offset(offset)
 47     , m_callLinkStatus(WTFMove(callLinkStatus))
 48     , m_intrinsicFunction(intrinsicFunction)
 49     , m_customAccessorGetter(customAccessorGetter)
 50     , m_domAttribute(WTFMove(domAttribute))
 51     , m_identifier(WTFMove(identifier))
 52 {
 53     if (!structureSet.size()) {
 54         ASSERT(offset == invalidOffset);
 55         ASSERT(conditionSet.isEmpty());
 56     }
 57     if (intrinsicFunction)
 58         ASSERT(intrinsic() != NoIntrinsic);
 59 }
 60 
 61 GetByIdVariant::~GetByIdVariant() { }
 62 
 63 GetByIdVariant::GetByIdVariant(const GetByIdVariant&amp; other)
 64     : GetByIdVariant(other.m_identifier)
 65 {
 66     *this = other;
 67 }
 68 
 69 GetByIdVariant&amp; GetByIdVariant::operator=(const GetByIdVariant&amp; other)
 70 {
 71     m_identifier = other.m_identifier;
 72     m_structureSet = other.m_structureSet;
 73     m_conditionSet = other.m_conditionSet;
 74     m_offset = other.m_offset;
 75     m_intrinsicFunction = other.m_intrinsicFunction;
 76     m_customAccessorGetter = other.m_customAccessorGetter;
 77     if (other.m_domAttribute)
 78         m_domAttribute = WTF::makeUnique&lt;DOMAttributeAnnotation&gt;(*other.m_domAttribute);
 79     else
 80         m_domAttribute = nullptr;
 81     if (other.m_callLinkStatus)
 82         m_callLinkStatus = makeUnique&lt;CallLinkStatus&gt;(*other.m_callLinkStatus);
 83     else
 84         m_callLinkStatus = nullptr;
 85     return *this;
 86 }
 87 
 88 inline bool GetByIdVariant::canMergeIntrinsicStructures(const GetByIdVariant&amp; other) const
 89 {
 90     if (m_intrinsicFunction != other.m_intrinsicFunction)
 91         return false;
 92     switch (intrinsic()) {
 93     case TypedArrayByteLengthIntrinsic: {
 94         // We can merge these sets as long as the element size of the two sets is the same.
 95         TypedArrayType thisType = (*m_structureSet.begin())-&gt;classInfo()-&gt;typedArrayStorageType;
 96         TypedArrayType otherType = (*other.m_structureSet.begin())-&gt;classInfo()-&gt;typedArrayStorageType;
 97 
 98         ASSERT(isTypedView(thisType) &amp;&amp; isTypedView(otherType));
 99 
100         return logElementSize(thisType) == logElementSize(otherType);
101     }
102 
103     default:
104         return true;
105     }
106     RELEASE_ASSERT_NOT_REACHED();
107 }
108 
109 bool GetByIdVariant::attemptToMerge(const GetByIdVariant&amp; other)
110 {
111     if (!!m_identifier != !!other.m_identifier)
112         return false;
113 
114     if (m_identifier &amp;&amp; (m_identifier != other.m_identifier))
115         return false;
116 
117     if (m_offset != other.m_offset)
118         return false;
119 
120     if (m_callLinkStatus || other.m_callLinkStatus) {
121         if (!(m_callLinkStatus &amp;&amp; other.m_callLinkStatus))
122             return false;
123     }
124 
125     if (!canMergeIntrinsicStructures(other))
126         return false;
127 
128     if (m_customAccessorGetter != other.m_customAccessorGetter)
129         return false;
130 
131     if (m_domAttribute || other.m_domAttribute) {
132         if (!(m_domAttribute &amp;&amp; other.m_domAttribute))
133             return false;
134         if (*m_domAttribute != *other.m_domAttribute)
135             return false;
136     }
137 
138     if (m_conditionSet.isEmpty() != other.m_conditionSet.isEmpty())
139         return false;
140 
141     ObjectPropertyConditionSet mergedConditionSet;
142     if (!m_conditionSet.isEmpty()) {
143         mergedConditionSet = m_conditionSet.mergedWith(other.m_conditionSet);
144         if (!mergedConditionSet.isValid())
145             return false;
146         // If this is a hit variant, one slot base should exist. If this is not a hit variant, the slot base is not necessary.
147         if (!isPropertyUnset() &amp;&amp; !mergedConditionSet.hasOneSlotBaseCondition())
148             return false;
149     }
150     m_conditionSet = mergedConditionSet;
151 
152     m_structureSet.merge(other.m_structureSet);
153 
154     if (m_callLinkStatus)
155         m_callLinkStatus-&gt;merge(*other.m_callLinkStatus);
156 
157     return true;
158 }
159 
160 void GetByIdVariant::visitAggregate(SlotVisitor&amp; visitor)
161 {
162     m_identifier.visitAggregate(visitor);
163 }
164 
165 void GetByIdVariant::markIfCheap(SlotVisitor&amp; visitor)
166 {
167     m_structureSet.markIfCheap(visitor);
168 }
169 
170 bool GetByIdVariant::finalize(VM&amp; vm)
171 {
172     if (!m_structureSet.isStillAlive(vm))
173         return false;
174     if (!m_conditionSet.areStillLive(vm))
175         return false;
176     if (m_callLinkStatus &amp;&amp; !m_callLinkStatus-&gt;finalize(vm))
177         return false;
178     if (m_intrinsicFunction &amp;&amp; !vm.heap.isMarked(m_intrinsicFunction))
179         return false;
180     return true;
181 }
182 
183 void GetByIdVariant::dump(PrintStream&amp; out) const
184 {
185     dumpInContext(out, 0);
186 }
187 
188 void GetByIdVariant::dumpInContext(PrintStream&amp; out, DumpContext* context) const
189 {
190     out.print(&quot;&lt;&quot;);
191     out.print(&quot;id=&#39;&quot;, m_identifier, &quot;&#39;, &quot;);
192     if (!isSet()) {
193         out.print(&quot;empty&gt;&quot;);
194         return;
195     }
196     out.print(inContext(structureSet(), context), &quot;, &quot;, inContext(m_conditionSet, context));
197     out.print(&quot;, offset = &quot;, offset());
198     if (m_callLinkStatus)
199         out.print(&quot;, call = &quot;, *m_callLinkStatus);
200     if (m_intrinsicFunction)
201         out.print(&quot;, intrinsic = &quot;, *m_intrinsicFunction);
202     if (m_customAccessorGetter)
203         out.print(&quot;, customaccessorgetter = &quot;, RawPointer(m_customAccessorGetter.executableAddress()));
204     if (m_domAttribute) {
205         out.print(&quot;, domclass = &quot;, RawPointer(m_domAttribute-&gt;classInfo));
206         if (m_domAttribute-&gt;domJIT)
207             out.print(&quot;, domjit = &quot;, RawPointer(m_domAttribute-&gt;domJIT));
208     }
209     out.print(&quot;&gt;&quot;);
210 }
211 
212 } // namespace JSC
213 
    </pre>
  </body>
</html>
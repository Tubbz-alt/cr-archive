<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLFormElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004-2010, 2012-2016 Apple Inc. All rights reserved.
  6  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;HTMLFormElement.h&quot;
 27 
 28 #include &quot;DOMFormData.h&quot;
 29 #include &quot;DOMWindow.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;ElementIterator.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;FormController.h&quot;
 35 #include &quot;FormData.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;FrameLoader.h&quot;
 38 #include &quot;FrameLoaderClient.h&quot;
 39 #include &quot;HTMLFieldSetElement.h&quot;
 40 #include &quot;HTMLFormControlsCollection.h&quot;
 41 #include &quot;HTMLImageElement.h&quot;
 42 #include &quot;HTMLInputElement.h&quot;
 43 #include &quot;HTMLNames.h&quot;
 44 #include &quot;HTMLObjectElement.h&quot;
 45 #include &quot;HTMLTableElement.h&quot;
 46 #include &quot;NodeRareData.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;RadioNodeList.h&quot;
 49 #include &quot;RenderTextControl.h&quot;
 50 #include &quot;ScriptDisallowedScope.h&quot;
 51 #include &quot;Settings.h&quot;
 52 #include &quot;UserGestureIndicator.h&quot;
 53 #include &lt;limits&gt;
 54 #include &lt;wtf/IsoMallocInlines.h&gt;
 55 #include &lt;wtf/Ref.h&gt;
 56 #include &lt;wtf/SetForScope.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLFormElement);
 61 
 62 using namespace HTMLNames;
 63 
 64 HTMLFormElement::HTMLFormElement(const QualifiedName&amp; tagName, Document&amp; document)
 65     : HTMLElement(tagName, document)
 66 {
 67     ASSERT(hasTagName(formTag));
 68 }
 69 
 70 Ref&lt;HTMLFormElement&gt; HTMLFormElement::create(Document&amp; document)
 71 {
 72     return adoptRef(*new HTMLFormElement(formTag, document));
 73 }
 74 
 75 Ref&lt;HTMLFormElement&gt; HTMLFormElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 76 {
 77     return adoptRef(*new HTMLFormElement(tagName, document));
 78 }
 79 
 80 HTMLFormElement::~HTMLFormElement()
 81 {
 82     document().formController().willDeleteForm(*this);
 83     if (!shouldAutocomplete())
 84         document().unregisterForDocumentSuspensionCallbacks(*this);
 85 
 86     m_defaultButton = nullptr;
 87     for (auto&amp; associatedElement : m_associatedElements)
 88         associatedElement-&gt;formWillBeDestroyed();
 89     for (auto&amp; imageElement : m_imageElements)
 90         imageElement-&gt;m_form = nullptr;
 91 }
 92 
 93 bool HTMLFormElement::formWouldHaveSecureSubmission(const String&amp; url)
 94 {
 95     return document().completeURL(url).protocolIs(&quot;https&quot;);
 96 }
 97 
 98 bool HTMLFormElement::rendererIsNeeded(const RenderStyle&amp; style)
 99 {
100     if (!m_wasDemoted)
101         return HTMLElement::rendererIsNeeded(style);
102 
103     auto parent = parentNode();
104     auto parentRenderer = parent-&gt;renderer();
105 
106     if (!parentRenderer)
107         return false;
108 
109     // FIXME: Shouldn&#39;t we also check for table caption (see |formIsTablePart| below).
110     bool parentIsTableElementPart = (parentRenderer-&gt;isTable() &amp;&amp; is&lt;HTMLTableElement&gt;(*parent))
111         || (parentRenderer-&gt;isTableRow() &amp;&amp; parent-&gt;hasTagName(trTag))
112         || (parentRenderer-&gt;isTableSection() &amp;&amp; parent-&gt;hasTagName(tbodyTag))
113         || (parentRenderer-&gt;isRenderTableCol() &amp;&amp; parent-&gt;hasTagName(colTag))
114         || (parentRenderer-&gt;isTableCell() &amp;&amp; parent-&gt;hasTagName(trTag));
115 
116     if (!parentIsTableElementPart)
117         return true;
118 
119     DisplayType display = style.display();
120     bool formIsTablePart = display == DisplayType::Table || display == DisplayType::InlineTable || display == DisplayType::TableRowGroup
121         || display == DisplayType::TableHeaderGroup || display == DisplayType::TableFooterGroup || display == DisplayType::TableRow
122         || display == DisplayType::TableColumnGroup || display == DisplayType::TableColumn || display == DisplayType::TableCell
123         || display == DisplayType::TableCaption;
124 
125     return formIsTablePart;
126 }
127 
128 Node::InsertedIntoAncestorResult HTMLFormElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
129 {
130     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
131     if (insertionType.connectedToDocument)
132         document().didAssociateFormControl(*this);
133     return InsertedIntoAncestorResult::Done;
134 }
135 
136 void HTMLFormElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
137 {
138     Node&amp; root = traverseToRootNode(); // Do not rely on rootNode() because our IsInTreeScope is outdated.
139     Vector&lt;FormAssociatedElement*&gt; associatedElements(m_associatedElements);
140     for (auto&amp; associatedElement : associatedElements)
141         associatedElement-&gt;formOwnerRemovedFromTree(root);
142     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
143 }
144 
145 void HTMLFormElement::handleLocalEvents(Event&amp; event, EventInvokePhase phase)
146 {
147     if (event.eventPhase() != Event::CAPTURING_PHASE &amp;&amp; is&lt;Node&gt;(event.target()) &amp;&amp; event.target() != this &amp;&amp; (event.type() == eventNames().submitEvent || event.type() == eventNames().resetEvent)) {
148         event.stopPropagation();
149         return;
150     }
151     HTMLElement::handleLocalEvents(event, phase);
152 }
153 
154 unsigned HTMLFormElement::length() const
155 {
156     unsigned length = 0;
157     for (auto&amp; associatedElement : m_associatedElements) {
158         if (associatedElement-&gt;isEnumeratable())
159             ++length;
160     }
161     return length;
162 }
163 
164 HTMLElement* HTMLFormElement::item(unsigned index)
165 {
166     return elements()-&gt;item(index);
167 }
168 
169 Optional&lt;Variant&lt;RefPtr&lt;RadioNodeList&gt;, RefPtr&lt;Element&gt;&gt;&gt; HTMLFormElement::namedItem(const AtomString&amp; name)
170 {
171     auto namedItems = namedElements(name);
172 
173     if (namedItems.isEmpty())
174         return WTF::nullopt;
175     if (namedItems.size() == 1)
176         return Variant&lt;RefPtr&lt;RadioNodeList&gt;, RefPtr&lt;Element&gt;&gt; { RefPtr&lt;Element&gt; { WTFMove(namedItems[0]) } };
177 
178     return Variant&lt;RefPtr&lt;RadioNodeList&gt;, RefPtr&lt;Element&gt;&gt; { RefPtr&lt;RadioNodeList&gt; { radioNodeList(name) } };
179 }
180 
181 Vector&lt;AtomString&gt; HTMLFormElement::supportedPropertyNames() const
182 {
183     // FIXME: Should be implemented (only needed for enumeration with includeDontEnumProperties mode
184     // since this class is annotated with LegacyUnenumerableNamedProperties).
185     return { };
186 }
187 
188 void HTMLFormElement::submitImplicitly(Event&amp; event, bool fromImplicitSubmissionTrigger)
189 {
190     unsigned submissionTriggerCount = 0;
191     for (auto&amp; formAssociatedElement : m_associatedElements) {
192         if (!is&lt;HTMLFormControlElement&gt;(*formAssociatedElement))
193             continue;
194         HTMLFormControlElement&amp; formElement = downcast&lt;HTMLFormControlElement&gt;(*formAssociatedElement);
195         if (formElement.isSuccessfulSubmitButton()) {
196             if (formElement.renderer()) {
197                 formElement.dispatchSimulatedClick(&amp;event);
198                 return;
199             }
200         } else if (formElement.canTriggerImplicitSubmission())
201             ++submissionTriggerCount;
202     }
203 
204     if (!submissionTriggerCount)
205         return;
206 
207     // Older iOS apps using WebViews expect the behavior of auto submitting multi-input forms.
208     if (fromImplicitSubmissionTrigger &amp;&amp; (submissionTriggerCount == 1 || document().settings().allowMultiElementImplicitSubmission()))
209         prepareForSubmission(event);
210 }
211 
212 bool HTMLFormElement::validateInteractively()
213 {
214     for (auto&amp; associatedElement : m_associatedElements) {
215         if (is&lt;HTMLFormControlElement&gt;(*associatedElement))
216             downcast&lt;HTMLFormControlElement&gt;(*associatedElement).hideVisibleValidationMessage();
217     }
218 
219     Vector&lt;RefPtr&lt;HTMLFormControlElement&gt;&gt; unhandledInvalidControls;
220     if (!checkInvalidControlsAndCollectUnhandled(unhandledInvalidControls))
221         return true;
222     // Because the form has invalid controls, we abort the form submission and
223     // show a validation message on a focusable form control.
224 
225     // Make sure layout is up-to-date in case we call isFocusable() (which
226     // has !renderer()-&gt;needsLayout() assertion).
227     ASSERT(!document().view() || !document().view()-&gt;needsLayout());
228 
229     Ref&lt;HTMLFormElement&gt; protectedThis(*this);
230 
231     // Focus on the first focusable control and show a validation message.
232     for (auto&amp; control : unhandledInvalidControls) {
233         if (control-&gt;isConnected() &amp;&amp; control-&gt;isFocusable()) {
234             control-&gt;focusAndShowValidationMessage();
235             break;
236         }
237     }
238 
239     // Warn about all of unfocusable controls.
240     if (document().frame()) {
241         for (auto&amp; control : unhandledInvalidControls) {
242             if (control-&gt;isConnected() &amp;&amp; control-&gt;isFocusable())
243                 continue;
244             String message = makeString(&quot;An invalid form control with name=&#39;&quot;, control-&gt;name(), &quot;&#39; is not focusable.&quot;);
245             document().addConsoleMessage(MessageSource::Rendering, MessageLevel::Error, message);
246         }
247     }
248 
249     return false;
250 }
251 
252 void HTMLFormElement::prepareForSubmission(Event&amp; event)
253 {
254     if (!isConnected())
255         return;
256 
257     RefPtr&lt;Frame&gt; frame = document().frame();
258     if (m_isSubmittingOrPreparingForSubmission || !frame)
259         return;
260 
261     m_isSubmittingOrPreparingForSubmission = true;
262     m_shouldSubmit = false;
263 
264     bool shouldValidate = document().page() &amp;&amp; document().page()-&gt;settings().interactiveFormValidationEnabled() &amp;&amp; !noValidate();
265 
266     if (shouldValidate) {
267         auto submitElement = findSubmitButton(&amp;event);
268         if (submitElement &amp;&amp; submitElement-&gt;formNoValidate())
269             shouldValidate = false;
270     }
271 
272     // Interactive validation must be done before dispatching the submit event.
273     if (shouldValidate &amp;&amp; !validateInteractively()) {
274         m_isSubmittingOrPreparingForSubmission = false;
275         return;
276     }
277 
278     auto targetFrame = frame-&gt;loader().findFrameForNavigation(effectiveTarget(&amp;event), &amp;document());
279     if (!targetFrame)
280         targetFrame = frame.get();
281     auto formState = FormState::create(*this, textFieldValues(), document(), NotSubmittedByJavaScript);
282     targetFrame-&gt;loader().client().dispatchWillSendSubmitEvent(WTFMove(formState));
283 
284     auto protectedThis = makeRef(*this);
285 
286     auto submitEvent = Event::create(eventNames().submitEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
287     dispatchEvent(submitEvent);
288 
289     // Event handling could have resulted in m_shouldSubmit becoming true as a side effect, too.
290     if (!submitEvent-&gt;defaultPrevented())
291         m_shouldSubmit = true;
292 
293     m_isSubmittingOrPreparingForSubmission = false;
294 
295     if (m_shouldSubmit)
296         submit(&amp;event, true, true, NotSubmittedByJavaScript);
297 }
298 
299 void HTMLFormElement::submit()
300 {
301     submit(nullptr, false, true, NotSubmittedByJavaScript);
302 }
303 
304 void HTMLFormElement::submitFromJavaScript()
305 {
306     submit(nullptr, false, UserGestureIndicator::processingUserGesture(), SubmittedByJavaScript);
307 }
308 
309 StringPairVector HTMLFormElement::textFieldValues() const
310 {
311     StringPairVector result;
312     result.reserveInitialCapacity(m_associatedElements.size());
313     for (auto&amp; associatedElement : m_associatedElements) {
314         auto&amp; element = associatedElement-&gt;asHTMLElement();
315         if (!is&lt;HTMLInputElement&gt;(element))
316             continue;
317         auto&amp; input = downcast&lt;HTMLInputElement&gt;(element);
318         if (!input.isTextField())
319             continue;
320         result.uncheckedAppend({ input.name().string(), input.value() });
321     }
322     return result;
323 }
324 
325 void HTMLFormElement::submit(Event* event, bool activateSubmitButton, bool processingUserGesture, FormSubmissionTrigger formSubmissionTrigger)
326 {
327     RefPtr&lt;FrameView&gt; view = document().view();
328     RefPtr&lt;Frame&gt; frame = document().frame();
329     if (!view || !frame)
330         return;
331 
332     if (m_isSubmittingOrPreparingForSubmission) {
333         m_shouldSubmit = true;
334         return;
335     }
336 
337     m_isSubmittingOrPreparingForSubmission = true;
338     m_wasUserSubmitted = processingUserGesture;
339 
340     RefPtr&lt;HTMLFormControlElement&gt; firstSuccessfulSubmitButton;
341     bool needButtonActivation = activateSubmitButton; // do we need to activate a submit button?
342 
343     for (auto&amp; associatedElement : m_associatedElements) {
344         if (!is&lt;HTMLFormControlElement&gt;(*associatedElement))
345             continue;
346         if (needButtonActivation) {
347             HTMLFormControlElement&amp; control = downcast&lt;HTMLFormControlElement&gt;(*associatedElement);
348             if (control.isActivatedSubmit())
349                 needButtonActivation = false;
350             else if (!firstSuccessfulSubmitButton &amp;&amp; control.isSuccessfulSubmitButton())
351                 firstSuccessfulSubmitButton = &amp;control;
352         }
353     }
354 
355     if (needButtonActivation &amp;&amp; firstSuccessfulSubmitButton)
356         firstSuccessfulSubmitButton-&gt;setActivatedSubmit(true);
357 
358     auto protectedThis = makeRef(*this); // Form submission can execute arbitary JavaScript.
359 
360     auto shouldLockHistory = processingUserGesture ? LockHistory::No : LockHistory::Yes;
<a name="1" id="anc1"></a><span class="line-modified">361     auto formSubmission = FormSubmission::create(*this, m_attributes, event, shouldLockHistory, formSubmissionTrigger);</span>
<span class="line-added">362     if (m_plannedFormSubmission)</span>
<span class="line-added">363         m_plannedFormSubmission-&gt;cancel();</span>
<span class="line-added">364     m_plannedFormSubmission = makeWeakPtr(formSubmission.get());</span>
<span class="line-added">365     frame-&gt;loader().submitForm(WTFMove(formSubmission));</span>
366 
367     if (needButtonActivation &amp;&amp; firstSuccessfulSubmitButton)
368         firstSuccessfulSubmitButton-&gt;setActivatedSubmit(false);
369 
370     m_shouldSubmit = false;
371     m_isSubmittingOrPreparingForSubmission = false;
372 }
373 
374 void HTMLFormElement::reset()
375 {
376     if (m_isInResetFunction)
377         return;
378 
379     RefPtr&lt;Frame&gt; protectedFrame = document().frame();
380     if (!protectedFrame)
381         return;
382 
383     Ref&lt;HTMLFormElement&gt; protectedThis(*this);
384 
385     SetForScope&lt;bool&gt; isInResetFunctionRestorer(m_isInResetFunction, true);
386 
387     auto event = Event::create(eventNames().resetEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
388     dispatchEvent(event);
389     if (!event-&gt;defaultPrevented())
390         resetAssociatedFormControlElements();
391 }
392 
393 void HTMLFormElement::resetAssociatedFormControlElements()
394 {
395     // Event handling can cause associated elements to be added or deleted while iterating
396     // over this collection. Protect these elements until we are done notifying them of
397     // the reset operation.
398     Vector&lt;Ref&lt;HTMLFormControlElement&gt;&gt; associatedFormControlElements;
399     associatedFormControlElements.reserveInitialCapacity(m_associatedElements.size());
400     for (auto* element : m_associatedElements) {
401         if (is&lt;HTMLFormControlElement&gt;(element))
402             associatedFormControlElements.uncheckedAppend(*downcast&lt;HTMLFormControlElement&gt;(element));
403     }
404 
405     for (auto&amp; associatedFormControlElement : associatedFormControlElements)
406         associatedFormControlElement-&gt;reset();
407 }
408 
<a name="2" id="anc2"></a><span class="line-modified">409 #if ENABLE(AUTOCORRECT)</span>
410 
411 // FIXME: We should look to share this code with class HTMLFormControlElement instead of duplicating the logic.
412 
413 bool HTMLFormElement::shouldAutocorrect() const
414 {
415     const AtomString&amp; autocorrectValue = attributeWithoutSynchronization(autocorrectAttr);
416     if (!autocorrectValue.isEmpty())
417         return !equalLettersIgnoringASCIICase(autocorrectValue, &quot;off&quot;);
418     if (RefPtr&lt;HTMLFormElement&gt; form = this-&gt;form())
419         return form-&gt;shouldAutocorrect();
420     return true;
421 }
422 
423 #endif
424 
425 void HTMLFormElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
426 {
427     if (name == actionAttr) {
428         m_attributes.parseAction(value);
429 
430         if (!m_attributes.action().isEmpty()) {
431             if (RefPtr&lt;Frame&gt; f = document().frame()) {
432                 Frame&amp; topFrame = f-&gt;tree().top();
433                 topFrame.loader().mixedContentChecker().checkFormForMixedContent(topFrame.document()-&gt;securityOrigin(), document().completeURL(m_attributes.action()));
434             }
435         }
436     } else if (name == targetAttr)
437         m_attributes.setTarget(value);
438     else if (name == methodAttr)
439         m_attributes.updateMethodType(value);
440     else if (name == enctypeAttr)
441         m_attributes.updateEncodingType(value);
442     else if (name == accept_charsetAttr)
443         m_attributes.setAcceptCharset(value);
444     else if (name == autocompleteAttr) {
445         if (!shouldAutocomplete())
446             document().registerForDocumentSuspensionCallbacks(*this);
447         else
448             document().unregisterForDocumentSuspensionCallbacks(*this);
449     } else
450         HTMLElement::parseAttribute(name, value);
451 }
452 
453 unsigned HTMLFormElement::formElementIndexWithFormAttribute(Element* element, unsigned rangeStart, unsigned rangeEnd)
454 {
455     if (m_associatedElements.isEmpty())
456         return 0;
457 
458     ASSERT(rangeStart &lt;= rangeEnd);
459 
460     if (rangeStart == rangeEnd)
461         return rangeStart;
462 
463     unsigned left = rangeStart;
464     unsigned right = rangeEnd - 1;
465     unsigned short position;
466 
467     // Does binary search on m_associatedElements in order to find the index
468     // to be inserted.
469     while (left != right) {
470         unsigned middle = left + ((right - left) / 2);
471         ASSERT(middle &lt; m_associatedElementsBeforeIndex || middle &gt;= m_associatedElementsAfterIndex);
472         position = element-&gt;compareDocumentPosition(m_associatedElements[middle]-&gt;asHTMLElement());
473         if (position &amp; DOCUMENT_POSITION_FOLLOWING)
474             right = middle;
475         else
476             left = middle + 1;
477     }
478 
479     ASSERT(left &lt; m_associatedElementsBeforeIndex || left &gt;= m_associatedElementsAfterIndex);
480     position = element-&gt;compareDocumentPosition(m_associatedElements[left]-&gt;asHTMLElement());
481     if (position &amp; DOCUMENT_POSITION_FOLLOWING)
482         return left;
483     return left + 1;
484 }
485 
486 unsigned HTMLFormElement::formElementIndex(FormAssociatedElement* associatedElement)
487 {
488     ASSERT(associatedElement);
489 
490     HTMLElement&amp; associatedHTMLElement = associatedElement-&gt;asHTMLElement();
491 
492     // Treats separately the case where this element has the form attribute
493     // for performance consideration.
494     if (associatedHTMLElement.hasAttributeWithoutSynchronization(formAttr) &amp;&amp; associatedHTMLElement.isConnected()) {
495         unsigned short position = compareDocumentPosition(associatedHTMLElement);
496         ASSERT_WITH_SECURITY_IMPLICATION(!(position &amp; DOCUMENT_POSITION_DISCONNECTED));
497         if (position &amp; DOCUMENT_POSITION_PRECEDING) {
498             ++m_associatedElementsBeforeIndex;
499             ++m_associatedElementsAfterIndex;
500             return HTMLFormElement::formElementIndexWithFormAttribute(&amp;associatedHTMLElement, 0, m_associatedElementsBeforeIndex - 1);
501         }
502         if (position &amp; DOCUMENT_POSITION_FOLLOWING &amp;&amp; !(position &amp; DOCUMENT_POSITION_CONTAINED_BY))
503             return HTMLFormElement::formElementIndexWithFormAttribute(&amp;associatedHTMLElement, m_associatedElementsAfterIndex, m_associatedElements.size());
504     }
505 
506     unsigned currentAssociatedElementsAfterIndex = m_associatedElementsAfterIndex;
507     ++m_associatedElementsAfterIndex;
508 
509     if (!associatedHTMLElement.isDescendantOf(*this))
510         return currentAssociatedElementsAfterIndex;
511 
512     // Check for the special case where this element is the very last thing in
513     // the form&#39;s tree of children; we don&#39;t want to walk the entire tree in that
514     // common case that occurs during parsing; instead we&#39;ll just return a value
515     // that says &quot;add this form element to the end of the array&quot;.
516     auto descendants = descendantsOfType&lt;HTMLElement&gt;(*this);
517     auto it = descendants.beginAt(associatedHTMLElement);
518     auto end = descendants.end();
519     if (++it == end)
520         return currentAssociatedElementsAfterIndex;
521 
522     unsigned i = m_associatedElementsBeforeIndex;
523     for (auto&amp; element : descendants) {
524         if (&amp;element == &amp;associatedHTMLElement)
525             return i;
526         if (!is&lt;HTMLFormControlElement&gt;(element) &amp;&amp; !is&lt;HTMLObjectElement&gt;(element))
527             continue;
528         if (element.form() != this)
529             continue;
530         ++i;
531     }
532     return currentAssociatedElementsAfterIndex;
533 }
534 
535 void HTMLFormElement::registerFormElement(FormAssociatedElement* e)
536 {
537     m_associatedElements.insert(formElementIndex(e), e);
538 
539     if (is&lt;HTMLFormControlElement&gt;(e)) {
540         HTMLFormControlElement&amp; control = downcast&lt;HTMLFormControlElement&gt;(*e);
541         if (control.isSuccessfulSubmitButton()) {
542             if (!m_defaultButton)
543                 control.invalidateStyleForSubtree();
544             else
545                 resetDefaultButton();
546         }
547     }
548 }
549 
550 void HTMLFormElement::removeFormElement(FormAssociatedElement* e)
551 {
552     unsigned index = m_associatedElements.find(e);
553     ASSERT_WITH_SECURITY_IMPLICATION(index &lt; m_associatedElements.size());
554     if (index &lt; m_associatedElementsBeforeIndex)
555         --m_associatedElementsBeforeIndex;
556     if (index &lt; m_associatedElementsAfterIndex)
557         --m_associatedElementsAfterIndex;
558     removeFromPastNamesMap(e);
559     m_associatedElements.remove(index);
560 
561     if (auto* nodeLists = this-&gt;nodeLists())
562         nodeLists-&gt;invalidateCaches();
563 
564     if (e == m_defaultButton)
565         resetDefaultButton();
566 }
567 
568 void HTMLFormElement::registerInvalidAssociatedFormControl(const HTMLFormControlElement&amp; formControlElement)
569 {
570     ASSERT_WITH_MESSAGE(!is&lt;HTMLFieldSetElement&gt;(formControlElement), &quot;FieldSet are never candidates for constraint validation.&quot;);
571     ASSERT(static_cast&lt;const Element&amp;&gt;(formControlElement).matchesInvalidPseudoClass());
572 
573     if (m_invalidAssociatedFormControls.computesEmpty())
574         invalidateStyleForSubtree();
575     m_invalidAssociatedFormControls.add(const_cast&lt;HTMLFormControlElement&amp;&gt;(formControlElement));
576 }
577 
578 void HTMLFormElement::removeInvalidAssociatedFormControlIfNeeded(const HTMLFormControlElement&amp; formControlElement)
579 {
580     if (m_invalidAssociatedFormControls.remove(formControlElement)) {
581         if (m_invalidAssociatedFormControls.computesEmpty())
582             invalidateStyleForSubtree();
583     }
584 }
585 
586 bool HTMLFormElement::isURLAttribute(const Attribute&amp; attribute) const
587 {
588     return attribute.name() == actionAttr || HTMLElement::isURLAttribute(attribute);
589 }
590 
591 void HTMLFormElement::registerImgElement(HTMLImageElement* e)
592 {
593     ASSERT(m_imageElements.find(e) == notFound);
594     m_imageElements.append(makeWeakPtr(e));
595 }
596 
597 void HTMLFormElement::removeImgElement(HTMLImageElement* e)
598 {
599     removeFromPastNamesMap(e);
600     bool removed = m_imageElements.removeFirst(e);
601     ASSERT_UNUSED(removed, removed);
602 }
603 
604 Ref&lt;HTMLFormControlsCollection&gt; HTMLFormElement::elements()
605 {
606     return ensureRareData().ensureNodeLists().addCachedCollection&lt;HTMLFormControlsCollection&gt;(*this, FormControls);
607 }
608 
609 Ref&lt;HTMLCollection&gt; HTMLFormElement::elementsForNativeBindings()
610 {
611     return elements();
612 }
613 
614 String HTMLFormElement::name() const
615 {
616     return getNameAttribute();
617 }
618 
619 bool HTMLFormElement::noValidate() const
620 {
621     return hasAttributeWithoutSynchronization(novalidateAttr);
622 }
623 
624 // FIXME: This function should be removed because it does not do the same thing as the
625 // JavaScript binding for action, which treats action as a URL attribute. Last time I
626 // (Darin Adler) removed this, someone added it back, so I am leaving it in for now.
627 String HTMLFormElement::action() const
628 {
629     return attributeWithoutSynchronization(actionAttr);
630 }
631 
632 void HTMLFormElement::setAction(const String &amp;value)
633 {
634     setAttributeWithoutSynchronization(actionAttr, value);
635 }
636 
637 void HTMLFormElement::setEnctype(const String &amp;value)
638 {
639     setAttributeWithoutSynchronization(enctypeAttr, value);
640 }
641 
642 String HTMLFormElement::method() const
643 {
644     return FormSubmission::Attributes::methodString(m_attributes.method());
645 }
646 
647 void HTMLFormElement::setMethod(const String &amp;value)
648 {
649     setAttributeWithoutSynchronization(methodAttr, value);
650 }
651 
652 String HTMLFormElement::target() const
653 {
654     return attributeWithoutSynchronization(targetAttr);
655 }
656 
657 String HTMLFormElement::effectiveTarget(const Event* event) const
658 {
659     if (auto* submitButton = findSubmitButton(event)) {
660         auto targetValue = submitButton-&gt;attributeWithoutSynchronization(formtargetAttr);
661         if (!targetValue.isNull())
662             return targetValue;
663     }
664 
665     auto targetValue = target();
666     if (!targetValue.isNull())
667         return targetValue;
668 
669     return document().baseTarget();
670 }
671 
672 bool HTMLFormElement::wasUserSubmitted() const
673 {
674     return m_wasUserSubmitted;
675 }
676 
677 HTMLFormControlElement* HTMLFormElement::findSubmitButton(const Event* event) const
678 {
679     if (!event || !is&lt;Node&gt;(event-&gt;target()))
680         return nullptr;
681     auto&amp; node = downcast&lt;Node&gt;(*event-&gt;target());
682     auto* element = is&lt;Element&gt;(node) ? &amp;downcast&lt;Element&gt;(node) : node.parentElement();
683     return element ? lineageOfType&lt;HTMLFormControlElement&gt;(*element).first() : nullptr;
684 }
685 
686 HTMLFormControlElement* HTMLFormElement::defaultButton() const
687 {
688     if (m_defaultButton)
689         return m_defaultButton.get();
690     for (auto&amp; associatedElement : m_associatedElements) {
691         if (!is&lt;HTMLFormControlElement&gt;(*associatedElement))
692             continue;
693         HTMLFormControlElement&amp; control = downcast&lt;HTMLFormControlElement&gt;(*associatedElement);
694         if (control.isSuccessfulSubmitButton()) {
695             m_defaultButton = makeWeakPtr(control);
696             return &amp;control;
697         }
698     }
699     return nullptr;
700 }
701 
702 void HTMLFormElement::resetDefaultButton()
703 {
704     if (!m_defaultButton) {
705         // Computing the default button is not cheap, we don&#39;t want to do it unless needed.
706         // If there was no default button set, the only style to invalidate is the element
707         // being added to the form. This is done explicitely in registerFormElement().
708         return;
709     }
710 
711     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
712 
713     auto oldDefault = WTFMove(m_defaultButton);
714     defaultButton();
715     if (m_defaultButton != oldDefault) {
716         if (oldDefault)
717             oldDefault-&gt;invalidateStyleForSubtree();
718         if (m_defaultButton)
719             m_defaultButton-&gt;invalidateStyleForSubtree();
720     }
721 }
722 
723 bool HTMLFormElement::checkValidity()
724 {
725     Vector&lt;RefPtr&lt;HTMLFormControlElement&gt;&gt; controls;
726     return !checkInvalidControlsAndCollectUnhandled(controls);
727 }
728 
729 bool HTMLFormElement::checkInvalidControlsAndCollectUnhandled(Vector&lt;RefPtr&lt;HTMLFormControlElement&gt;&gt;&amp; unhandledInvalidControls)
730 {
731     Ref&lt;HTMLFormElement&gt; protectedThis(*this);
732     // Copy m_associatedElements because event handlers called from
733     // HTMLFormControlElement::checkValidity() might change m_associatedElements.
734     Vector&lt;RefPtr&lt;FormAssociatedElement&gt;&gt; elements;
735     elements.reserveCapacity(m_associatedElements.size());
736     for (auto&amp; associatedElement : m_associatedElements)
737         elements.append(associatedElement);
738     bool hasInvalidControls = false;
739     for (auto&amp; element : elements) {
740         if (element-&gt;form() == this &amp;&amp; is&lt;HTMLFormControlElement&gt;(*element)) {
741             HTMLFormControlElement&amp; control = downcast&lt;HTMLFormControlElement&gt;(*element);
742             if (!control.checkValidity(&amp;unhandledInvalidControls) &amp;&amp; control.form() == this)
743                 hasInvalidControls = true;
744         }
745     }
746     return hasInvalidControls;
747 }
748 
749 bool HTMLFormElement::reportValidity()
750 {
751     Ref&lt;HTMLFormElement&gt; protectedThis(*this);
752 
753     // Update layout before processing form actions in case the style changes
754     // the Form or button relationships.
755     document().updateLayoutIgnorePendingStylesheets();
756 
757     return validateInteractively();
758 }
759 
760 #ifndef NDEBUG
761 void HTMLFormElement::assertItemCanBeInPastNamesMap(FormNamedItem* item) const
762 {
763     ASSERT_WITH_SECURITY_IMPLICATION(item);
764     HTMLElement&amp; element = item-&gt;asHTMLElement();
765     ASSERT_WITH_SECURITY_IMPLICATION(element.form() == this);
766 
767     if (item-&gt;isFormAssociatedElement()) {
768         ASSERT_WITH_SECURITY_IMPLICATION(m_associatedElements.find(static_cast&lt;FormAssociatedElement*&gt;(item)) != notFound);
769         return;
770     }
771 
772     ASSERT_WITH_SECURITY_IMPLICATION(element.hasTagName(imgTag));
773     ASSERT_WITH_SECURITY_IMPLICATION(m_imageElements.find(&amp;downcast&lt;HTMLImageElement&gt;(element)) != notFound);
774 }
775 #else
776 inline void HTMLFormElement::assertItemCanBeInPastNamesMap(FormNamedItem*) const
777 {
778 }
779 #endif
780 
781 RefPtr&lt;HTMLElement&gt; HTMLFormElement::elementFromPastNamesMap(const AtomString&amp; pastName) const
782 {
783     if (pastName.isEmpty() || !m_pastNamesMap)
784         return nullptr;
785     FormNamedItem* item = m_pastNamesMap-&gt;get(pastName.impl());
786     if (!item)
787         return nullptr;
788     assertItemCanBeInPastNamesMap(item);
789     return &amp;item-&gt;asHTMLElement();
790 }
791 
792 void HTMLFormElement::addToPastNamesMap(FormNamedItem* item, const AtomString&amp; pastName)
793 {
794     assertItemCanBeInPastNamesMap(item);
795     if (pastName.isEmpty())
796         return;
797     if (!m_pastNamesMap)
798         m_pastNamesMap = makeUnique&lt;PastNamesMap&gt;();
799     m_pastNamesMap-&gt;set(pastName.impl(), item);
800 }
801 
802 void HTMLFormElement::removeFromPastNamesMap(FormNamedItem* item)
803 {
804     ASSERT(item);
805     if (!m_pastNamesMap)
806         return;
807 
808     for (auto&amp; pastName : m_pastNamesMap-&gt;values()) {
809         if (pastName == item)
810             pastName = nullptr; // Keep looping. Single element can have multiple names.
811     }
812 }
813 
814 bool HTMLFormElement::matchesValidPseudoClass() const
815 {
816     return m_invalidAssociatedFormControls.computesEmpty();
817 }
818 
819 bool HTMLFormElement::matchesInvalidPseudoClass() const
820 {
821     return !matchesValidPseudoClass();
822 }
823 
824 // FIXME: Use Ref&lt;HTMLElement&gt; for the function result since there are no non-HTML elements returned here.
825 Vector&lt;Ref&lt;Element&gt;&gt; HTMLFormElement::namedElements(const AtomString&amp; name)
826 {
827     // http://www.whatwg.org/specs/web-apps/current-work/multipage/forms.html#dom-form-nameditem
828     Vector&lt;Ref&lt;Element&gt;&gt; namedItems = elements()-&gt;namedItems(name);
829 
830     auto elementFromPast = elementFromPastNamesMap(name);
831     if (namedItems.size() == 1 &amp;&amp; namedItems.first().ptr() != elementFromPast)
832         addToPastNamesMap(downcast&lt;HTMLElement&gt;(namedItems.first().get()).asFormNamedItem(), name);
833     else if (elementFromPast &amp;&amp; namedItems.isEmpty())
834         namedItems.append(*elementFromPast);
835 
836     return namedItems;
837 }
838 
839 void HTMLFormElement::resumeFromDocumentSuspension()
840 {
841     ASSERT(!shouldAutocomplete());
842 
843     document().postTask([formElement = makeRef(*this)] (ScriptExecutionContext&amp;) {
844         formElement-&gt;resetAssociatedFormControlElements();
845     });
846 }
847 
848 void HTMLFormElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
849 {
850     if (!shouldAutocomplete()) {
851         oldDocument.unregisterForDocumentSuspensionCallbacks(*this);
852         newDocument.registerForDocumentSuspensionCallbacks(*this);
853     }
854 
855     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
856 }
857 
858 bool HTMLFormElement::shouldAutocomplete() const
859 {
860     return !equalLettersIgnoringASCIICase(attributeWithoutSynchronization(autocompleteAttr), &quot;off&quot;);
861 }
862 
863 void HTMLFormElement::finishParsingChildren()
864 {
865     HTMLElement::finishParsingChildren();
866     document().formController().restoreControlStateIn(*this);
867 }
868 
869 const Vector&lt;FormAssociatedElement*&gt;&amp; HTMLFormElement::unsafeAssociatedElements() const
870 {
871     ASSERT(ScriptDisallowedScope::InMainThread::hasDisallowedScope());
872     return m_associatedElements;
873 }
874 
875 Vector&lt;Ref&lt;FormAssociatedElement&gt;&gt; HTMLFormElement::copyAssociatedElementsVector() const
876 {
877     return WTF::map(m_associatedElements, [] (auto* rawElement) {
878         return Ref&lt;FormAssociatedElement&gt;(*rawElement);
879     });
880 }
881 
882 void HTMLFormElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
883 {
884     m_wasDemoted = static_cast&lt;const HTMLFormElement&amp;&gt;(source).m_wasDemoted;
885     HTMLElement::copyNonAttributePropertiesFromElement(source);
886 }
887 
888 HTMLFormElement* HTMLFormElement::findClosestFormAncestor(const Element&amp; startElement)
889 {
890     return const_cast&lt;HTMLFormElement*&gt;(ancestorsOfType&lt;HTMLFormElement&gt;(startElement).first());
891 }
892 
893 void HTMLFormElement::setAutocomplete(const AtomString&amp; value)
894 {
895     setAttributeWithoutSynchronization(autocompleteAttr, value);
896 }
897 
898 const AtomString&amp; HTMLFormElement::autocomplete() const
899 {
900     static NeverDestroyed&lt;AtomString&gt; on(&quot;on&quot;, AtomString::ConstructFromLiteral);
901     static NeverDestroyed&lt;AtomString&gt; off(&quot;off&quot;, AtomString::ConstructFromLiteral);
902 
903     return equalIgnoringASCIICase(attributeWithoutSynchronization(autocompleteAttr), &quot;off&quot;) ? off : on;
904 }
905 
906 } // namespace
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
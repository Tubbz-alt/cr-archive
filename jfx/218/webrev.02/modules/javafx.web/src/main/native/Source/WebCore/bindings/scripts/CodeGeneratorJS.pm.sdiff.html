<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CodeGenerator.pm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDLAttributes.json.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 #
   2 # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3 # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
   4 # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   5 # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
<span class="line-modified">   6 # Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10 # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  11 # Copyright (C) 2012 Ericsson AB. All rights reserved.
  12 # Copyright (C) 2007, 2008, 2009, 2012 Google Inc.
  13 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  14 # Copyright (C) 2015, 2016 Canon Inc. All rights reserved.
  15 #
  16 # This library is free software; you can redistribute it and/or
  17 # modify it under the terms of the GNU Library General Public
  18 # License as published by the Free Software Foundation; either
  19 # version 2 of the License, or (at your option) any later version.
  20 #
  21 # This library is distributed in the hope that it will be useful,
  22 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  23 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24 # Library General Public License for more details.
  25 #
  26 # You should have received a copy of the GNU Library General Public License
</pre>
<hr />
<pre>
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
 624     my ($outputArray, $interface, $className) = @_;
 625     
 626     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 627     
<span class="line-modified"> 628     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);</span>
 629     push(@$outputArray, &quot;{\n&quot;);
 630     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 631     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 632     
 633     my $namedGetterOperation = GetNamedGetterOperation($interface);
 634     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 635     
 636     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="line-modified"> 637         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
 638     }
 639     
 640     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 641     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 642     
 643     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 644     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 645     
 646     # 1. If O supports indexed properties and P is an array index property name, then:
 647     if ($indexedGetterOperation) {
 648         # 1.1. Let index be the result of calling ToUint32(P).
 649         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 650         
 651         # 1.2. If index is a supported property index, then:
 652         # FIXME: This should support non-contiguous indices.
 653         push(@$outputArray, &quot;        if (index.value() &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 654         
 655         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 656         
 657         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index.value()&quot;);
 658         
 659         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 660         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 661         
 662         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 663         push(@$outputArray, &quot;            return true;\n&quot;);
 664         
 665         push(@$outputArray, &quot;        }\n&quot;);
 666         
 667         # 1.3. Set ignoreNamedProps to true.
 668         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 669         #       rather than going through the paces of having an actual ignoreNamedProps update.
 670         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="line-modified"> 671             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);</span>
 672         }
 673         push(@$outputArray, &quot;    }\n&quot;);
 674     }
 675     
 676     # 2. If O supports named properties, the result of running the named property visibility
 677     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 678     if ($namedGetterOperation) {
 679         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 680         #       to true, due to the early return in step 1.3
 681         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 682                 
 683         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 684         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 685         
 686         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 687         
 688         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 689         
 690         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="line-modified"> 691         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
 692         
 693         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 694         
 695         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 696         
 697         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 698         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 699         
 700         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 701         push(@$outputArray, &quot;        return true;\n&quot;);
 702         push(@$outputArray, &quot;    }\n&quot;);
 703     }
 704 
 705     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 706         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="line-modified"> 707         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);</span>
 708         push(@$outputArray, &quot;        return true;\n&quot;);
 709     }
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
<span class="line-modified"> 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, state, propertyName, slot);\n&quot;);</span>
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
 731         $didGeneratePropertyName = 1;
 732     };
 733     
 734     my $namedGetterOperation = GetNamedGetterOperation($interface);
 735     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 736     
<span class="line-modified"> 737     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)\n&quot;);</span>
 738     push(@$outputArray, &quot;{\n&quot;);
 739     if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="line-modified"> 740         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
 741     }
 742     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 743     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 744     
 745     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 746         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
 747     }
 748     
 749     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 750     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 751     
 752     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 753     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 754     
 755     # 1. If O supports indexed properties and P is an array index property name, then:
 756     if ($indexedGetterOperation) {
 757         # 1.1. Let index be the result of calling ToUint32(P).
 758         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 759         
 760         # 1.2. If index is a supported property index, then:
 761         # FIXME: This should support non-contiguous indices.
 762         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 763         
 764         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 765         
 766         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
 767         
 768         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 769         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 770         
 771         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 772         push(@$outputArray, &quot;            return true;\n&quot;);
 773         
 774         push(@$outputArray, &quot;        }\n&quot;);
 775         
 776         # 1.3. Set ignoreNamedProps to true.
 777         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 778         #       rather than going through the paces of having an actual ignoreNamedProps update.
 779         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="line-modified"> 780             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);</span>
 781         }
 782         push(@$outputArray, &quot;    }\n&quot;);
 783     }
 784     
 785     # 2. If O supports named properties, the result of running the named property visibility
 786     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 787     if ($namedGetterOperation) {
 788         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 789         #       to true, due to the early return in step 1.3
 790         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 791                 
 792         &amp;$propertyNameGeneration();
 793         
 794         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 795         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 796         
 797         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 798         
 799         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 800         
 801         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="line-modified"> 802         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
 803         
 804         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 805         
 806         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 807 
 808         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 809         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 810         
 811         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 812         push(@$outputArray, &quot;        return true;\n&quot;);
 813         push(@$outputArray, &quot;    }\n&quot;);
 814     }
 815     
 816     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 817         &amp;$propertyNameGeneration();
 818 
 819         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="line-modified"> 820         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, state, propertyName, slot))\n&quot;);</span>
 821         push(@$outputArray, &quot;        return true;\n&quot;);
 822     }
 823 
 824     # 3. Return OrdinaryGetOwnProperty(O, P).
<span class="line-modified"> 825     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, state, index, slot);\n&quot;);</span>
 826     
 827     push(@$outputArray, &quot;}\n\n&quot;);
 828 }
 829 
 830 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 831 sub GenerateGetOwnPropertyNames
 832 {
 833     my ($outputArray, $interface, $className) = @_;
 834     
 835     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 836     
 837     my $namedGetterOperation = GetNamedGetterOperation($interface);
 838     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 839     
<span class="line-modified"> 840     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, ExecState* state, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);</span>
 841     push(@$outputArray, &quot;{\n&quot;);
 842     if ($indexedGetterOperation || $namedGetterOperation) {
<span class="line-modified"> 843         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
 844     }
 845     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 846     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 847     
 848     # 1. If the object supports indexed properties, then the object’s supported
 849     #    property indices are enumerated first, in numerical order.
 850     # FIXME: This should support non-contiguous indices.
 851     if ($indexedGetterOperation) {
 852         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
 853         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(vm, i));\n&quot;);
 854     }
 855 
 856     # 2. If the object supports named properties and doesn’t implement an interface
 857     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 858     #    object’s supported property names that are visible according to the named
 859     #    property visibility algorithm are enumerated next, in the order given in
 860     #    the definition of the set of supported property names.
 861     if ($namedGetterOperation) {
 862         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 863             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 864             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 865         } else {
 866             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 867             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 868             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 869             push(@$outputArray, &quot;    }\n&quot;);
 870         }
 871     }
 872     
 873     # 3. Finally, any enumerable own properties or properties from the object’s
 874     #    prototype chain are then enumerated, in no defined order.
<span class="line-modified"> 875     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, state, propertyNames, mode);\n&quot;);</span>
 876     push(@$outputArray, &quot;}\n\n&quot;);
 877 }
 878 
 879 # https://heycam.github.io/webidl/#invoke-indexed-setter
 880 sub GenerateInvokeIndexedPropertySetter
 881 {
 882     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 883     
 884     # The second argument of the indexed setter operation is the argument being converted.
 885     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
<span class="line-modified"> 886     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
 887     
<span class="line-modified"> 888     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
 889     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 890     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 891     
 892     my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
 893     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 894     my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
<span class="line-modified"> 895     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);</span>
 896     
 897     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 898 }
 899 
 900 # https://heycam.github.io/webidl/#invoke-named-setter
 901 sub GenerateInvokeNamedPropertySetter
 902 {
 903     my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
 904     
 905     my $argument = @{$namedSetterOperation-&gt;arguments}[1];
<span class="line-modified"> 906     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;state&quot;, &quot;*state&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
 907     
<span class="line-modified"> 908     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
 909     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 910     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 911 
 912     push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 913 
 914     my $namedSetterFunctionName = $namedSetterOperation-&gt;name || &quot;setNamedItem&quot;;
 915     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 916 
 917     my @arguments = ();
 918     push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
 919     push(@arguments, $nativeValuePassExpression);
 920     push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 921 
 922     my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified"> 923     $functionString = &quot;propagateException(*state, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);</span>
 924 
 925     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 926 }
 927 
 928 sub GeneratePut
 929 {
 930     my ($outputArray, $interface, $className) = @_;
 931     
 932     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
 933     
 934     my $namedSetterOperation = GetNamedSetterOperation($interface);
 935     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
 936     
<span class="line-modified"> 937     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);</span>
 938     push(@$outputArray, &quot;{\n&quot;);
 939     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
 940     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
 941 
 942     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
 943         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
 944     if ($namedSetterOperation) {
<span class="line-modified"> 945         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);</span>
 946     }
 947     if ($indexedSetterOperation) {
<span class="line-modified"> 948         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);</span>
 949     }
 950     
 951     if ($indexedSetterOperation) {
 952         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 953         
 954         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;value&quot;);
 955         
 956         push(@$outputArray, &quot;        return true;\n&quot;);
 957         push(@$outputArray, &quot;    }\n\n&quot;);
 958     }
 959     
 960     if ($namedSetterOperation) {
 961         # FIMXE: We need a more comprehensive story for Symbols.
 962         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
 963         
 964         my $additionalIndent = &quot;&quot;;
 965         
 966         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
 967         if (!$overrideBuiltins) {
 968             push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="line-modified"> 969             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(state-&gt;vm());\n&quot;);</span>
<span class="line-modified"> 970             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);</span>
 971             $additionalIndent .= &quot;    &quot;;
 972         }
 973 
 974         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
 975         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
 976             push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
<span class="line-modified"> 977             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);</span>
 978         }
 979         push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
 980 
 981         if (!$overrideBuiltins) {
 982             push(@$outputArray, &quot;        }\n&quot;);
 983         }
 984         
 985         push(@$outputArray, &quot;    }\n\n&quot;);
 986     }
 987     
 988     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
 989     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 990         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 991 
 992         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
<span class="line-modified"> 993         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
 994         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
 995     }
 996 
<span class="line-modified"> 997     push(@$outputArray, &quot;    return JSObject::put(thisObject, state, propertyName, value, putPropertySlot);\n&quot;);</span>
 998     push(@$outputArray, &quot;}\n\n&quot;);
 999 }
1000 
1001 sub GeneratePutByIndex
1002 {
1003     my ($outputArray, $interface, $className) = @_;
1004     
1005     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1006 
1007     my $namedSetterOperation = GetNamedSetterOperation($interface);
1008     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1009     
1010     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1011     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1012     
<span class="line-modified">1013     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);</span>
1014     push(@$outputArray, &quot;{\n&quot;);
1015     if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="line-modified">1016         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
1017     }
1018     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1019     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1020 
1021     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1022         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1023     if ($namedSetterOperation) {
<span class="line-modified">1024         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);</span>
1025     }
1026     if ($indexedSetterOperation) {
<span class="line-modified">1027         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);</span>
1028     }
1029     
1030     if ($indexedSetterOperation) {
1031         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1032         
1033         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1034         
1035         push(@$outputArray, &quot;        return true;\n&quot;);
1036         push(@$outputArray, &quot;    }\n\n&quot;);
1037     }
1038     
1039     if ($namedSetterOperation) {
1040         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1041                 
1042         my $additionalIndent = &quot;&quot;;
1043         if (!$overrideBuiltins) {
1044             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1045             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);
<span class="line-modified">1046             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(state, propertyName, slot))) {\n&quot;);</span>
1047             $additionalIndent .= &quot;    &quot;;
1048         }
1049         
1050         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1051         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1052             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
<span class="line-modified">1053             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);</span>
1054         }
1055         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1056         
1057         if (!$overrideBuiltins) {
1058             push(@$outputArray, &quot;    }\n\n&quot;);
1059         }
1060     }
1061 
1062     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1063     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1064         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
1065         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1066         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1067         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
<span class="line-modified">1068         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, state, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
1069         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1070     }
1071 
1072     if (!$ellidesCallsToBase) {
<span class="line-modified">1073         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, state, index, value, shouldThrow);\n&quot;);</span>
1074     }
1075     
1076     push(@$outputArray, &quot;}\n\n&quot;);
1077 }
1078 
1079 sub GenerateIsUnforgeablePropertyName
1080 {
1081     my ($outputArray, $interface) = @_;
1082     
1083     my @unforgeablePropertyNames = ();
1084     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1085         next if $property-&gt;isStatic;
1086         
1087         if (IsUnforgeable($interface, $property)) {
1088             push(@unforgeablePropertyNames, $property-&gt;name);
1089         }
1090     }
1091     
1092     return 0 if (scalar(@unforgeablePropertyNames) == 0);
1093     
</pre>
<hr />
<pre>
1096     push(@$outputArray, &quot;static bool isUnforgeablePropertyName(PropertyName propertyName)\n&quot;);
1097     push(@$outputArray, &quot;{\n&quot;);
1098     push(@$outputArray, &quot;    return ${condition};\n&quot;);
1099     push(@$outputArray, &quot;}\n\n&quot;);
1100     
1101     return 1;
1102 }
1103 
1104 # https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
1105 sub GenerateDefineOwnProperty
1106 {
1107     my ($outputArray, $interface, $className) = @_;
1108     
1109     return if $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty};
1110     
1111     my $namedSetterOperation = GetNamedSetterOperation($interface);
1112     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1113     
1114     return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
1115     
<span class="line-modified">1116     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, ExecState* state, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);</span>
1117     push(@$outputArray, &quot;{\n&quot;);
1118     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
1119     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1120 
1121     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1122         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1123     if ($namedSetterOperation) {
<span class="line-modified">1124         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*state&quot;);</span>
1125     }
1126     if ($indexedSetterOperation) {
<span class="line-modified">1127         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*state&quot;);</span>
1128     }
1129     
1130     # 1. If O supports indexed properties and P is an array index property name, then:
1131     if (GetIndexedGetterOperation($interface)) {
1132         # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
1133         # is no indexed property setter.
1134 
1135         if (!$indexedSetterOperation) {
1136             # 2. If O does not implement an interface with an indexed property setter, then return false.
1137             push(@$outputArray, &quot;    if (parseIndex(propertyName))\n&quot;);
1138             push(@$outputArray, &quot;        return false;\n\n&quot;);
1139         } else {
1140             push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
1141 
1142             # 1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1143             push(@$outputArray, &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1144             push(@$outputArray, &quot;            return false;\n&quot;);
1145             
1146             # 3. Invoke the indexed property setter with P and Desc.[[Value]].
1147             GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;propertyDescriptor.value()&quot;);
1148             
1149             # 4. Return true.
1150             push(@$outputArray, &quot;        return true;\n&quot;);
1151             push(@$outputArray, &quot;    }\n\n&quot;);
1152         }
1153     }
1154     
<span class="line-modified">1155     # 2. If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal]</span>
1156     #    extended attribute and P is not an unforgeable property name of O, then:
<span class="line-modified">1157     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
1158         # FIMXE: We need a more comprehensive story for Symbols.
1159         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
1160         
1161         my $additionalIndent = &quot;&quot;;
1162         
1163         my $hasUnforgableProperties = GenerateIsUnforgeablePropertyName($outputArray, $interface);
1164         if ($hasUnforgableProperties) {
1165             push(@$outputArray, &quot;        if (!isUnforgeablePropertyName(propertyName)) {\n&quot;);
1166             $additionalIndent .= &quot;    &quot;;
1167         }
1168         
1169         # 1. Let creating be true if P is not a supported property name, and false otherwise.
1170         # NOTE: This step is strength reduced into the only use of &#39;creating&#39; in step 2.2.1
1171         
1172         # 2. If O implements an interface with the [OverrideBuiltins] extended attribute or O
1173         #    does not have an own property named P, then:
1174         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1175         if (!$overrideBuiltins) {
1176             # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
1177             #        only look at the actual properties, and not call into our implementation of the
1178             #        [[GetOwnProperty]] hook?
1179             push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="line-modified">1180             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, state, propertyName, slot)) {\n&quot;);</span>
1181             $additionalIndent .= &quot;    &quot;;
1182         }
1183         if (!$namedSetterOperation) {
1184             # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
1185             push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
1186             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1187         } else {
1188             # 2.2. If O implements an interface with a named property setter, then:
1189             
1190             # 2.2.1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1191             push(@$outputArray, $additionalIndent . &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1192             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1193             
1194             # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
1195             GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
1196             if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1197                 push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
<span class="line-modified">1198                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, state, propertyName, propertyDescriptor, shouldThrow);\n&quot;);</span>
1199             }
1200             # 2.2.3. Return true.
1201             push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
1202         }
1203         
1204         if (!$overrideBuiltins) {
1205             push(@$outputArray, $additionalIndent . &quot;    }\n&quot;);
1206         }
1207         
1208         if ($hasUnforgableProperties) {
1209             push(@$outputArray, &quot;        }\n&quot;);
1210         }
1211         
1212         # Close the !propertyName.isSymbol() condition.
1213         push(@$outputArray, &quot;    }\n\n&quot;);
1214     }
1215     
1216     push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
1217         
<span class="line-modified">1218     # 3. If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute,</span>
1219     #    then set Desc.[[Configurable]] to true.
<span class="line-modified">1220     if (!IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
1221         push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
1222     }
1223     
1224     # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
1225     # FIXME: Does this do the same thing?
<span class="line-modified">1226     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, state, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);</span>
1227     
1228     push(@$outputArray, &quot;}\n\n&quot;);
1229 }
1230 
1231 sub GenerateDeletePropertyCommon
1232 {
1233     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1234     
1235     # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
1236     # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
1237 
1238     # 2. If O supports named properties, O does not implement an interface with the
<span class="line-modified">1239     #    [Global] or [PrimaryGlobal] extended attribute and the result of calling the</span>
<span class="line-modified">1240     #    named property visibility algorithm with property name P and object O is true,</span>
<span class="line-removed">1241     #    then:</span>
1242     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
<span class="line-modified">1243     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);</span>
1244 
1245     AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
1246     my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="line-modified">1247     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*state, thisObject, propertyName)) {\n&quot;);</span>
1248 
<span class="line-modified">1249     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);</span>
1250 
1251     # 2.1. If O does not implement an interface with a named property deleter, then return false.
1252     # 2.2. Let operation be the operation used to declare the named property deleter.
1253     # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
1254 
1255     # 2.3. If operation was defined without an identifier, then:
1256     #      1. Perform the steps listed in the interface description to delete an existing named
1257     #         property with P as the name.
1258     #      2. If the steps indicated that the deletion failed, then return false.
1259     # 2.4. Otherwise, operation was defined with an identifier:
1260     #      1. Perform the steps listed in the description of operation with P as the only argument
1261     #         value.
1262     #      2. If operation was declared with a return type of boolean and the steps returned false,
1263     #         then return false.
1264 
1265     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;deleteNamedProperty&quot;;
1266     my $functionCall = &quot;impl.&quot; . $functionImplementationName . &quot;(propertyNameToString(propertyName))&quot;;
1267 
1268     # NOTE: We expect the implementation function of named deleters without an identifier to
1269     #       return either bool or ExceptionOr&lt;bool&gt;. the implementation function of named deleters
1270     #       with an identifier have no restriction, but if the return value of the operation is
1271     #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
1272 
1273     if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
1274         push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
1275         push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
<span class="line-modified">1276         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(state-&gt;vm());\n&quot;);</span>
<span class="line-modified">1277         push(@$outputArray, &quot;            propagateException(*state, throwScope, result.releaseException());\n&quot;);</span>
1278         push(@$outputArray, &quot;            return true;\n&quot;);
1279         push(@$outputArray, &quot;        }\n\n&quot;);
1280 
1281         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1282             push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
1283         } else {
1284             push(@$outputArray, &quot;        return true;\n&quot;);
1285         }
1286     } else {
1287         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1288             push(@$outputArray, &quot;        return ${functionCall};\n&quot;);
1289         } else {
1290             push(@$outputArray, &quot;        ${functionCall};\n&quot;);
1291             push(@$outputArray, &quot;        return true;\n&quot;);
1292         }
1293     }
1294 
1295     push(@$outputArray, &quot;    }\n&quot;);
1296 }
1297 
1298 sub GenerateDeleteProperty
1299 {
1300     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1301 
1302     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1303     # for the deleteProperty override hook.
1304 
<span class="line-modified">1305     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, ExecState* state, PropertyName propertyName)\n&quot;);</span>
1306     push(@$outputArray, &quot;{\n&quot;);
1307 
1308     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1309     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1310 
1311     # 1. If O supports indexed properties and P is an array index property name, then:
1312     #    1. Let index be the result of calling ToUint32(P).
1313     #    2. If index is not a supported property index, then return true.
1314     #    3. Return false.
1315     if (GetIndexedGetterOperation($interface)) {
1316         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName))\n&quot;);
1317         push(@$outputArray, &quot;        return !impl.isSupportedPropertyIndex(index.value());\n&quot;);
1318     }
1319 
1320     # GenerateDeletePropertyCommon implements step 2.
1321     GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1322 
1323     # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
1324     # the remained of the algorithm ourselves.
<span class="line-modified">1325     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, state, propertyName);\n&quot;);</span>
1326     push(@$outputArray, &quot;}\n\n&quot;);
1327 }
1328 
1329 sub GenerateDeletePropertyByIndex
1330 {
1331     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1332 
1333     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1334     # for the deletePropertyByIndex override hook.
1335 
<span class="line-modified">1336     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, ExecState* state, unsigned index)\n&quot;);</span>
1337     push(@$outputArray, &quot;{\n&quot;);
1338 
1339     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1340     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1341 
1342     # 1. If O supports indexed properties and P is an array index property name, then:
1343     #    1. Let index be the result of calling ToUint32(P).
1344     #    2. If index is not a supported property index, then return true.
1345     #    3. Return false.
1346 
1347     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1348     #       is all that needs to be done, no need to generate the .
1349 
1350     if (GetIndexedGetterOperation($interface)) {
1351         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1352     } else {
<span class="line-modified">1353         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
1354         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1355 
1356         # GenerateDeletePropertyCommon implements step 2.
1357         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1358 
1359         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1360         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1361         
1362         # 3. If O has an own property with name P, then:
1363         #    1. If the property is not configurable, then return false.
1364         #    2. Otherwise, remove the property from O.
1365         # 3. Return true.
1366         
<span class="line-modified">1367         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, state, index);\n&quot;);</span>
1368     }
1369 
1370     push(@$outputArray, &quot;}\n\n&quot;);
1371 }
1372 
1373 
1374 sub GenerateNamedDeleterDefinition
1375 {
1376     my ($outputArray, $interface, $className) = @_;
1377     
1378     return if $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty};
1379 
1380     my $namedDeleterOperation = GetNamedDeleterOperation($interface);
1381     
1382     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
1383     # the deleteProperty and deletePropertyByIndex override hooks.
1384 
1385     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
<span class="line-modified">1386     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalOrPrimaryGlobalInterface($interface);</span>
1387 
1388     my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
1389     if ($conditional) {
1390         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1391         push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
1392     }
1393 
1394     GenerateDeleteProperty($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1395     GenerateDeletePropertyByIndex($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1396 
1397     push(@implContent, &quot;#endif\n\n&quot;) if $conditional;
1398 }
1399 
1400 sub GenerateHeaderContentHeader
1401 {
1402     my $interface = shift;
1403     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1404 
1405     my @headerContentHeader;
1406     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
</pre>
<hr />
<pre>
1490 
1491 sub GetTypeNameForDisplayInException
1492 {
1493     my ($type) = @_;
1494 
1495     # FIXME: Add more type specializations.
1496     return &quot;(&quot; . join(&quot; or &quot;, map { $_-&gt;name } GetFlattenedMemberTypes($type)) . &quot;)&quot; if $type-&gt;isUnion;
1497     return $type-&gt;name;
1498 }
1499 
1500 sub GetArgumentExceptionFunction
1501 {
1502     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1503 
1504     my $name = $argument-&gt;name;
1505     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1506     my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
1507 
1508     if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
1509         # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
<span class="line-modified">1510         return &quot;throwArgumentMustBeFunctionError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;</span>
1511     }
1512 
1513     if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
<span class="line-modified">1514         return &quot;throwArgumentTypeError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;</span>
1515     }
1516 
1517     if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
1518         my $className = GetEnumerationClassName($argument-&gt;type, $interface);
<span class="line-modified">1519         return &quot;throwArgumentMustBeEnumError(state, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;</span>
1520     }
1521 
1522     return undef;
1523 }
1524 
1525 sub GetArgumentExceptionThrower
1526 {
1527     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1528 
1529     my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
<span class="line-modified">1530     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
1531 }
1532 
1533 sub GetAttributeExceptionFunction
1534 {
1535     my ($interface, $attribute) = @_;
1536     
1537     my $name = $attribute-&gt;name;
1538     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1539     my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
1540 
1541     if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
<span class="line-modified">1542         return &quot;throwAttributeTypeError(state, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;</span>
1543     }
1544 }
1545 
1546 sub GetAttributeExceptionThrower
1547 {
1548     my ($interface, $attribute) = @_;
1549 
1550     my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
<span class="line-modified">1551     return &quot;[](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
1552 
1553 }
1554 
1555 sub PassArgumentExpression
1556 {
1557     my ($name, $context) = @_;
1558 
1559     my $type = $context-&gt;type;
1560 
1561     return &quot;WTFMove(${name})&quot; if $type-&gt;isNullable;
1562 
1563     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
1564         return &quot;*${name}&quot; if $type-&gt;name eq &quot;ArrayBuffer&quot;;
1565         return &quot;${name}.releaseNonNull()&quot;;
1566     }
1567 
1568     return &quot;${name}.releaseNonNull()&quot; if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type) || ($codeGenerator-&gt;IsPromiseType($type) &amp;&amp; (ref($context) ne &quot;IDLArgument&quot; || !$context-&gt;isOptional));
1569     return &quot;*${name}&quot; if $codeGenerator-&gt;IsWrapperType($type);
1570     return &quot;WTFMove(${name})&quot;;
1571 }
</pre>
<hr />
<pre>
1602 }
1603 
1604 sub GetFullyQualifiedImplementationCallName
1605 {
1606     my ($interface, $property, $implementationName, $implExpression, $conditional) = @_;
1607     
1608     my $implementedBy = $property-&gt;extendedAttributes-&gt;{ImplementedBy};
1609     if ($implementedBy) {
1610         AddToImplIncludes(&quot;${implementedBy}.h&quot;, $conditional);
1611         return &quot;WebCore::${implementedBy}::${implementationName}&quot;;
1612     }
1613     
1614     if ($property-&gt;isStatic || $property-&gt;extendedAttributes-&gt;{Constructor} || $property-&gt;extendedAttributes-&gt;{NamedConstructor}) {
1615         return $interface-&gt;type-&gt;name . &quot;::${implementationName}&quot;;
1616     }
1617     
1618     if ($property-&gt;isMapLike) {
1619         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
1620     }
1621     




1622     return &quot;${implExpression}.${implementationName}&quot;;
1623 }
1624 
1625 sub AddAdditionalArgumentsForImplementationCall
1626 {
<span class="line-modified">1627     my ($arguments, $interface, $property, $implExpression, $stateExpression, $thisObjectExpression) = @_;</span>
1628     
1629     if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
1630         unshift(@$arguments, $implExpression);
1631     }
1632     
<span class="line-modified">1633     if ($property-&gt;isMapLike) {</span>
<span class="line-modified">1634         push(@$arguments, $stateExpression);</span>



1635         push(@$arguments, $thisObjectExpression);
1636     }
1637 }
1638 
1639 sub GetSpecialAccessorOperationForType
1640 {
1641     my ($interface, $special, $firstParameterType, $numberOfParameters) = @_;
1642 
1643     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
1644         my $specials = $operation-&gt;specials;
1645         my $specialExists = grep { $_ eq $special } @$specials;
1646         my $arguments = $operation-&gt;arguments;
1647         if ($specialExists and scalar(@$arguments) == $numberOfParameters and $arguments-&gt;[0]-&gt;type-&gt;name eq $firstParameterType) {
1648             return $operation;
1649         }
1650     }
1651 
1652     return 0;
1653 }
1654 
<span class="line-modified">1655 sub IsGlobalOrPrimaryGlobalInterface</span>
1656 {
1657     my $interface = shift;
1658 
<span class="line-modified">1659     return $interface-&gt;extendedAttributes-&gt;{Global} || $interface-&gt;extendedAttributes-&gt;{PrimaryGlobal};</span>
1660 }
1661 
1662 sub AttributeShouldBeOnInstance
1663 {
1664     my $interface = shift;
1665     my $attribute = shift;
1666 
<span class="line-modified">1667     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);</span>
1668     return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1669 
1670     # [Unforgeable] attributes should be on the instance.
1671     # https://heycam.github.io/webidl/#Unforgeable
1672     return 1 if IsUnforgeable($interface, $attribute);
1673 
1674     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
1675         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity};
1676         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter};
1677         return 1;
1678     }
1679 
1680     return 0;
1681 }
1682 
1683 sub IsAlwaysExposedOnInterface
1684 {
1685     my ($interfaceExposures, $contextExposures) = @_;
1686 
1687     my %contextExposureSet = ();
</pre>
<hr />
<pre>
1712     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1713         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1714         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1715     }
1716 
1717     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
1718         || $context-&gt;extendedAttributes-&gt;{EnabledForContext}
1719         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1720         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1721         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1722         || $context-&gt;extendedAttributes-&gt;{SecureContext}
1723         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}
1724         || $context-&gt;extendedAttributes-&gt;{CustomEnabled};
1725 }
1726 
1727 # https://heycam.github.io/webidl/#es-operations
1728 sub OperationShouldBeOnInstance
1729 {
1730     my ($interface, $operation) = @_;
1731 
<span class="line-modified">1732     return 1 if IsGlobalOrPrimaryGlobalInterface($interface);</span>
1733 
1734     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1735     if (IsUnforgeable($interface, $operation)) {
1736         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1737         return 1;
1738     }
1739 
1740     return 0;
1741 }
1742 
1743 sub OperationHasForcedReturnValue
1744 {
1745     my ($operation) = @_;
1746 
1747     foreach my $argument (@{$operation-&gt;arguments}) {
1748         return 1 if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
1749     }
1750     return 0;
1751 }
1752 
1753 sub IsAcceleratedDOMAttribute
1754 {
1755     my ($interface, $attribute) = @_;
1756 
1757     # If we use CustomGetterSetter in IDL code generator we cannot skip type check.
1758     return 0 if NeedsRuntimeCheck($interface, $attribute) and AttributeShouldBeOnInstance($interface, $attribute);
1759     return 0 if $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and AttributeShouldBeOnInstance($interface, $attribute);
1760 
1761     # If the interface has special logic for casting we cannot hoist type check to JSC.
1762     return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
1763     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1764 
1765     return 0 if $attribute-&gt;isStatic;
1766     return 0 if $attribute-&gt;isMapLike;

1767     return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1768     return 0 if IsJSBuiltin($interface, $attribute);
1769     return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
1770     return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
1771     return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1772     return 1;
1773 }
1774 
1775 sub GetJSCAttributesForAttribute
1776 {
1777     my $interface = shift;
1778     my $attribute = shift;
1779 
1780     my @specials = ();
1781     push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
1782 
1783     # As per Web IDL specification, constructor properties on the ECMAScript global object should not be enumerable.
1784     my $isGlobalConstructor = $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1785     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if ($attribute-&gt;extendedAttributes-&gt;{NotEnumerable} || $isGlobalConstructor);
1786     push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
</pre>
<hr />
<pre>
1827     my $count = 0;
1828 
1829     foreach my $operation (@{$interface-&gt;operations}) {
1830         $count++ if OperationShouldBeOnInstance($interface, $operation);
1831     }
1832 
1833     return $count;
1834 }
1835 
1836 sub PrototypeOperationCount
1837 {
1838     my $interface = shift;
1839     my $count = 0;
1840 
1841     foreach my $operation (@{$interface-&gt;operations}) {
1842         $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
1843     }
1844 
1845     $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
1846     $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;

1847     $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
1848 
1849     return $count;
1850 }
1851 
1852 sub InstancePropertyCount
1853 {
1854     my $interface = shift;
1855     my $count = 0;
1856     foreach my $attribute (@{$interface-&gt;attributes}) {
1857         $count++ if AttributeShouldBeOnInstance($interface, $attribute);
1858     }
1859     $count += InstanceOperationCount($interface);
1860     return $count;
1861 }
1862 
1863 sub PrototypePropertyCount
1864 {
1865     my $interface = shift;
1866     my $count = 0;
</pre>
<hr />
<pre>
2076     $result .= &quot;    static const NeverDestroyed&lt;String&gt; values[] = {\n&quot;;
2077     foreach my $value (@{$enumeration-&gt;values}) {
2078         if ($value eq &quot;&quot;) {
2079             $result .= &quot;        emptyString(),\n&quot;;
2080         } else {
2081             $result .= &quot;        MAKE_STATIC_STRING_IMPL(\&quot;$value\&quot;),\n&quot;;
2082         }
2083     }
2084     $result .= &quot;    };\n&quot;;
2085     my $index = 0;
2086     foreach my $value (@{$enumeration-&gt;values}) {
2087         my $enumerationValueName = GetEnumerationValueName($value);
2088         $result .= &quot;    static_assert(static_cast&lt;size_t&gt;(${className}::$enumerationValueName) == $index, \&quot;${className}::$enumerationValueName is not $index as expected\&quot;);\n&quot;;
2089         $index++;
2090     }
2091     $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
2092     $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
2093     $result .= &quot;}\n\n&quot;;
2094 
2095 
<span class="line-modified">2096     # FIXME: Change to take VM&amp; instead of ExecState*.</span>
<span class="line-modified">2097     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(ExecState&amp; state, $className enumerationValue)\n&quot;;</span>
2098     $result .= &quot;{\n&quot;;
<span class="line-modified">2099     $result .= &quot;    return jsStringWithCache(&amp;state, convertEnumerationToString(enumerationValue));\n&quot;;</span>
2100     $result .= &quot;}\n\n&quot;;
2101 
<span class="line-modified">2102     # FIXME: Change to take VM&amp; instead of ExecState&amp;.</span>
2103     # FIXME: Consider using toStringOrNull to make exception checking faster.
2104     # FIXME: Consider finding a more efficient way to match against all the strings quickly.
<span class="line-modified">2105     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;</span>
2106     $result .= &quot;{\n&quot;;
<span class="line-modified">2107     $result .= &quot;    auto stringValue = value.toWTFString(&amp;state);\n&quot;;</span>
2108     foreach my $value (@{$enumeration-&gt;values}) {
2109         my $enumerationValueName = GetEnumerationValueName($value);
2110         if ($value eq &quot;&quot;) {
2111             $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
2112         } else {
2113             $result .= &quot;    if (stringValue == \&quot;$value\&quot;)\n&quot;;
2114         }
2115         $result .= &quot;        return ${className}::${enumerationValueName};\n&quot;;
2116     }
2117     $result .= &quot;    return WTF::nullopt;\n&quot;;
2118     $result .= &quot;}\n\n&quot;;
2119 
2120     $result .= &quot;template&lt;&gt; const char* expectedEnumerationValues&lt;$className&gt;()\n&quot;;
2121     $result .= &quot;{\n&quot;;
2122     $result .= &quot;    return \&quot;\\\&quot;&quot; . join (&quot;\\\&quot;, \\\&quot;&quot;, @{$enumeration-&gt;values}) . &quot;\\\&quot;\&quot;;\n&quot;;
2123     $result .= &quot;}\n\n&quot;;
2124 
2125     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2126 
2127     return $result;
</pre>
<hr />
<pre>
2137     foreach my $enumeration (@$enumerations) {
2138         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2139         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2140         $result .= GenerateEnumerationImplementationContent($enumeration, $className, $interface, $conditionalString);
2141     }
2142     return $result;
2143 }
2144 
2145 sub GenerateEnumerationHeaderContent
2146 {
2147     my ($enumeration, $className, $conditionalString) = @_;
2148 
2149     $headerIncludes{&quot;JSDOMConvertEnumeration.h&quot;} = 1;
2150 
2151     my $result = &quot;&quot;;
2152     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2153 
2154     my $exportMacro = GetExportMacroForJSClass($enumeration);
2155 
2156     $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
<span class="line-modified">2157     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::ExecState&amp;, $className);\n\n&quot;;</span>
<span class="line-modified">2158     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;;</span>
2159     $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
2160     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2161     
2162     return $result;
2163 }
2164 
2165 sub GenerateEnumerationsHeaderContent
2166 {
2167     my ($interface, $enumerations) = @_;
2168 
2169     return &quot;&quot; unless @$enumerations;
2170 
2171     # FIXME: Could optimize this to only generate the parts of each enumeration that are actually
2172     # used, which would require iterating over everything in the interface.
2173 
2174     my $result = &quot;&quot;;
2175     foreach my $enumeration (@$enumerations) {
2176         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2177         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2178         $result .= GenerateEnumerationHeaderContent($enumeration, $className, $conditionalString);
</pre>
<hr />
<pre>
2208             return $useAtomString ? &quot;AtomString(${defaultValue}, AtomString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;
2209         }
2210     }
2211 
2212     if ($codeGenerator-&gt;IsEnumType($type)) {
2213         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2214         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2215         if ($defaultValue eq &quot;null&quot;) {
2216             die if !$type-&gt;isNullable;
2217             return &quot;WTF::nullopt&quot;;
2218         }
2219         my $className = GetEnumerationClassName($type, $typeScope);
2220         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2221         return $className . &quot;::&quot; . $enumerationValueName;
2222     }
2223     if ($defaultValue eq &quot;null&quot;) {
2224         if ($type-&gt;isUnion) {
2225             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2226 
2227             my $IDLType = GetIDLType($typeScope, $type);
<span class="line-modified">2228             return &quot;convert&lt;${IDLType}&gt;(state, jsNull());&quot;;</span>
2229         }
2230 
2231         return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
2232         return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
2233         return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
2234         return &quot;WTF::nullopt&quot;;
2235     }
2236 
2237     if ($defaultValue eq &quot;[]&quot;) {
2238         my $IDLType = GetIDLType($typeScope, $type);
2239         return &quot;Converter&lt;${IDLType}&gt;::ReturnType{ }&quot;;
2240     }
2241 
2242     return &quot;jsUndefined()&quot; if $defaultValue eq &quot;undefined&quot;;
2243     return &quot;PNaN&quot; if $defaultValue eq &quot;NaN&quot;;
2244 
2245     return $defaultValue;
2246 }
2247 
2248 sub GenerateDictionaryHeaderContent
2249 {
2250     my ($dictionary, $className, $conditionalString) = @_;
2251 
2252     $headerIncludes{&quot;JSDOMConvertDictionary.h&quot;} = 1;
2253 
2254     my $exportMacro = GetExportMacroForJSClass($dictionary);
2255 
2256     my $result = &quot;&quot;;
2257     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
<span class="line-modified">2258     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::ExecState&amp;, JSC::JSValue);\n\n&quot;;</span>
2259 
2260     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
<span class="line-modified">2261         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;</span>
2262     }
2263 
2264     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2265     return $result;
2266 }
2267 
2268 sub GenerateDictionariesHeaderContent
2269 {
2270     my ($typeScope, $allDictionaries) = @_;
2271 
2272     return &quot;&quot; unless @$allDictionaries;
2273 
2274     my $result = &quot;&quot;;
2275     foreach my $dictionary (@$allDictionaries) {
2276         $headerIncludes{$typeScope-&gt;type-&gt;name . &quot;.h&quot;} = 1 if $typeScope;
2277         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2278         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
2279         $result .= GenerateDictionaryHeaderContent($dictionary, $className, $conditionalString);
2280     }
2281     return $result;
</pre>
<hr />
<pre>
2284 sub GenerateDictionaryImplementationContent
2285 {
2286     my ($dictionary, $className, $interface) = @_;
2287 
2288     my $result = &quot;&quot;;
2289 
2290     my $name = $dictionary-&gt;type-&gt;name;
2291     my $typeScope = $interface || $dictionary;
2292 
2293     my $conditional = $dictionary-&gt;extendedAttributes-&gt;{Conditional};
2294     if ($conditional) {
2295         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2296         $result .= &quot;#if ${conditionalString}\n\n&quot;;
2297     }
2298 
2299     # FIXME: A little ugly to have this be a side effect instead of a return value.
2300     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2301     AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
2302 
2303     # https://heycam.github.io/webidl/#es-dictionary
<span class="line-modified">2304     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(ExecState&amp; state, JSValue value)\n&quot;;</span>
2305     $result .= &quot;{\n&quot;;
<span class="line-modified">2306     $result .= &quot;    VM&amp; vm = state.vm();\n&quot;;</span>
2307     $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
2308     $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
2309     $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
2310 
2311     # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
2312     $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
<span class="line-modified">2313     $result .= &quot;        throwTypeError(&amp;state, throwScope);\n&quot;;</span>
2314     $result .= &quot;        return { };\n&quot;;
2315     $result .= &quot;    }\n&quot;;
2316 
2317     # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
2318 
2319     # 3. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
2320     my @dictionaries;
2321     push(@dictionaries, $dictionary);
2322     my $parentType = $dictionary-&gt;parentType;
2323     while (defined($parentType)) {
2324         my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
2325         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2326         unshift(@dictionaries, $parentDictionary);
2327         $parentType = $parentDictionary-&gt;parentType;
2328     }
2329 
2330     my $arguments = &quot;&quot;;
2331     my $comma = &quot;&quot;;
2332 
2333     $result .= &quot;    $className result;\n&quot;;
</pre>
<hr />
<pre>
2340             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2341 
2342             my $type = $member-&gt;type;
2343             AddToImplIncludesForIDLType($type);
2344 
2345             my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2346             if ($conditional) {
2347                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2348                 $result .= &quot;#if ${conditionalString}\n&quot;;
2349             }
2350 
2351             # 4.1. Let key be the identifier of member.
2352             my $key = $member-&gt;name;
2353             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2354 
2355             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2356             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2357             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2358             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2359             $result .= &quot;    else {\n&quot;;
<span class="line-modified">2360             $result .= &quot;        ${key}Value = object-&gt;get(&amp;state, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;</span>
2361             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2362             $result .= &quot;    }\n&quot;;
2363 
2364             my $IDLType = GetIDLType($typeScope, $type);
2365 
2366             # 4.3. If value is not undefined, then:
2367             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2368 
<span class="line-modified">2369             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;);</span>
2370             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2371             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2372 
2373             # Value is undefined.
2374             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2375             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2376                 $result .= &quot;    } else\n&quot;;
2377                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2378             } elsif ($member-&gt;isRequired) {
2379                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2380                 $result .= &quot;    } else {\n&quot;;
<span class="line-modified">2381                 $result .= &quot;        throwRequiredMemberTypeError(state, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;</span>
2382                 $result .= &quot;        return { };\n&quot;;
2383                 $result .= &quot;    }\n&quot;;
2384             } else {
2385                 $result .= &quot;    }\n&quot;;
2386             }
2387 
2388             $result .= &quot;#endif\n&quot; if $conditional;
2389         }
2390     }
2391 
2392     # 5. Return dict.
2393     $result .= &quot;    return result;\n&quot;;
2394     $result .= &quot;}\n\n&quot;;
2395 
2396     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2397         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2398         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2399 
<span class="line-modified">2400         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;</span>
2401         $result .= &quot;{\n&quot;;
<span class="line-modified">2402         $result .= &quot;    auto&amp; vm = state.vm();\n\n&quot;;</span>
2403 
2404         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
<span class="line-modified">2405         $result .= &quot;    auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n\n&quot;;</span>
2406 
2407         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2408         #    in order from least to most derived.
2409         #    NOTE: This was done above.
2410 
2411         # 3. For each dictionary dictionary in dictionaries, in order:
2412         foreach my $dictionary (@dictionaries) {
2413             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2414             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2415             foreach my $member (@sortedMembers) {
2416                 my $key = $member-&gt;name;
2417                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2418                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2419 
2420                 my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2421                 if ($conditional) {
2422                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2423                     $result .= &quot;#if ${conditionalString}\n&quot;;
2424                 }
2425 
2426                 # 1. Let key be the identifier of member.
2427                 # 2. If the dictionary member named key is present in V, then:
2428                     # 1. Let idlValue be the value of member on V.
2429                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2430                     # 3. Perform ! CreateDataProperty(O, key, value).
2431 
2432                 my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);
2433                 my $indent = &quot;&quot;;
2434                 if ($needsRuntimeCheck) {
<span class="line-modified">2435                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;true&quot;);</span>
2436                     $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;
2437                     $indent = &quot;    &quot;;
2438                 }
2439 
2440                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2441                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2442                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2443 
2444                     $result .= &quot;${indent}    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;
2445                     $result .= &quot;${indent}        auto ${key}Value = ${conversionExpression};\n&quot;;
2446                     $result .= &quot;${indent}        result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2447                     $result .= &quot;${indent}    }\n&quot;;
2448                 } else {
2449                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2450 
2451                     $result .= &quot;${indent}    auto ${key}Value = ${conversionExpression};\n&quot;;
2452                     $result .= &quot;${indent}    result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2453                 }
2454                 if ($needsRuntimeCheck) {
2455                     $result .= &quot;    }\n&quot;;
</pre>
<hr />
<pre>
2597         push(@headerContent, &quot;    }\n\n&quot;);
2598     } elsif (!NeedsImplementationClass($interface)) {
2599         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2600         push(@headerContent, &quot;    {\n&quot;);
2601         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2602         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2603         push(@headerContent, &quot;        return ptr;\n&quot;);
2604         push(@headerContent, &quot;    }\n\n&quot;);  
2605     } else {
2606         if (!$codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type) &amp;&amp; !$codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {
2607             AddIncludesForImplementationTypeInHeader($implType);
2608         }
2609         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2610         push(@headerContent, &quot;    {\n&quot;);
2611         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2612         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2613         push(@headerContent, &quot;        return ptr;\n&quot;);
2614         push(@headerContent, &quot;    }\n\n&quot;);
2615     }
2616 
<span class="line-removed">2617     push(@headerContent, &quot;    static const bool needsDestruction = false;\n\n&quot;) if IsDOMGlobalObject($interface);</span>
<span class="line-removed">2618 </span>
2619     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2620     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2621     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2622     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2623     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2624         
2625     # Prototype
2626     unless (ShouldUseGlobalObjectPrototype($interface)) {
2627         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2628         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2629     }
2630 
2631     # JSValue to implementation type
2632     if (ShouldGenerateToWrapped($hasParent, $interface)) {
2633         # FIXME: Add extended attribute for this.
2634         my @toWrappedArguments = ();
2635         push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
<span class="line-modified">2636         push(@toWrappedArguments, &quot;JSC::ExecState&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;</span>
2637         push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
2638 
2639         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2640 
2641         my $export = &quot;&quot;;
2642         $export = &quot;WEBCORE_EXPORT &quot; if $interface-&gt;extendedAttributes-&gt;{ExportToWrappedFunction};
2643         push(@headerContent, &quot;    static ${export}${toWrappedType} toWrapped(&quot; . join(&quot;, &quot;, @toWrappedArguments) . &quot;);\n&quot;);
2644     }
2645 
2646     $headerTrailingIncludes{&quot;${className}Custom.h&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomHeader};
2647 
2648     my $namedGetterOperation = GetNamedGetterOperation($interface);
2649     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2650 
2651     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2652     if ($namedGetterOperation) {
2653         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2654             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2655         } else {
2656             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2657         }
2658     }
2659     
2660     # ClassInfo MethodTable declarations.
2661     
2662     if (InstanceOverridesGetOwnPropertySlot($interface)) {
<span class="line-modified">2663         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
2664         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
<span class="line-modified">2665         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::ExecState*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
2666         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2667     }
2668 
2669     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
<span class="line-modified">2670         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);</span>
2671         $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;
2672     }




2673     
2674     if (InstanceOverridesGetOwnPropertyNames($interface)) {
<span class="line-modified">2675         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::ExecState*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);</span>
2676         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2677     }
2678     
2679     if (InstanceOverridesPut($interface)) {
<span class="line-modified">2680         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="line-modified">2681         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::ExecState*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);</span>
2682     }
2683     
2684     if (InstanceOverridesDefineOwnProperty($interface)) {
<span class="line-modified">2685         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
2686     }
2687 
2688     if (InstanceOverridesDeleteProperty($interface)) {
<span class="line-modified">2689         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName);\n&quot;);</span>
<span class="line-modified">2690         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::ExecState*, unsigned);\n&quot;);</span>
2691     }
2692 
2693     if (InstanceOverridesGetCallData($interface)) {
2694         push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
2695         $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
2696         $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
2697     }
2698     
2699     if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
<span class="line-modified">2700         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::ExecState*);\n&quot;);</span>
2701     }
2702     
2703     if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
<span class="line-modified">2704         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::ExecState*);\n&quot;);</span>
2705     }
2706     
2707     if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
<span class="line-modified">2708         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::ExecState*);\n&quot;);</span>
2709     }
2710 
2711     if (InstanceNeedsEstimatedSize($interface)) {
2712         push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
2713     }
2714     
2715     if (!$hasParent) {
2716         push(@headerContent, &quot;    static void destroy(JSC::JSCell*);\n&quot;);
2717     }
2718 
2719     # Class info
2720     if ($interfaceName eq &quot;Node&quot;) {
2721         push(@headerContent, &quot;\n&quot;);
2722         push(@headerContent, &quot;protected:\n&quot;);
2723         push(@headerContent, &quot;    static const JSC::ClassInfo s_info;\n&quot;);
2724         push(@headerContent, &quot;public:\n&quot;);
2725         push(@headerContent, &quot;    static constexpr const JSC::ClassInfo* info() { return &amp;s_info; }\n\n&quot;);
2726     } else {
2727         push(@headerContent, &quot;\n&quot;);
2728         push(@headerContent, &quot;    DECLARE_INFO;\n\n&quot;);
2729     }
2730 
2731     # Structure ID
2732     push(@headerContent, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
2733     push(@headerContent, &quot;    {\n&quot;);
2734     if (IsDOMGlobalObject($interface)) {
2735         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());\n&quot;);
2736     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2737         my $type = GetJSTypeForNode($interface);
2738         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info());\n&quot;);
2739     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Event&quot;)) {
2740         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info());\n&quot;);
2741     } else {
2742         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
2743     }
2744     push(@headerContent, &quot;    }\n\n&quot;);
2745 
2746     # Custom pushEventHandlerScope function
2747     if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
<span class="line-modified">2748         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::ExecState*, JSC::JSScope*) const;\n\n&quot;);</span>
2749     }
2750     
2751     # Constructor object getter
2752     unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
2753         push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
2754         push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
2755     }
2756 
2757     # Serializer function.
2758     if ($interface-&gt;serializable) {
<span class="line-modified">2759         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::ExecState&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);</span>
2760     }
2761     
2762     my $numCustomOperations = 0;
2763     my $numCustomAttributes = 0;
2764 
2765     my $hasForwardDeclaringOperations = 0;
2766     my $hasForwardDeclaringAttributes = 0;
2767 
2768     my $hasDOMJITAttributes = 0;
2769 
2770     # Attribute and function enums
2771     if ($numAttributes &gt; 0) {
2772         foreach my $attribute (@{$interface-&gt;attributes}) {
2773             $numCustomAttributes++ if HasCustomGetter($attribute);
2774             $numCustomAttributes++ if HasCustomSetter($attribute);
2775             if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
2776                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2777                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2778                 push(@headerContent, &quot;    mutable JSC::WriteBarrier&lt;JSC::Unknown&gt; m_&quot; . $attribute-&gt;name . &quot;;\n&quot;);
2779                 $numCachedAttributes++;
2780                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2781             }
2782             $hasDOMJITAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2783 
2784             $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2785         }
2786     }
2787 







2788     # visit function
2789     if ($needsVisitChildren) {
2790         push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2791         push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
2792         push(@headerContent, &quot;\n&quot;);
2793 
2794         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2795             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2796             # concurrent GC or in between eden GCs something may happen that would lead to this
2797             # logic behaving differently. Since this could mark objects or add opaque roots, this
2798             # means that after any increment of mutator resumption in a concurrent GC and at least
2799             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2800             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2801             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2802             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2803             # that the GC calls to ask an object is it would like to mark anything else after the
2804             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2805             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2806             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
<span class="line-modified">2807             my $subspaceFunc = IsDOMGlobalObject($interface) ? &quot;globalObjectOutputConstraintSubspaceFor&quot; : &quot;outputConstraintSubspaceFor&quot;;</span>
<span class="line-modified">2808             push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return $subspaceFunc(vm); }\n&quot;);</span>

2809         }
2810     }
2811 
2812     if (NeedsImplementationClass($interface)) {
2813         push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);
2814     }
2815     
2816     if ($numCustomAttributes &gt; 0) {
2817         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2818 
2819         foreach my $attribute (@{$interface-&gt;attributes}) {
2820             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2821             if (HasCustomGetter($attribute)) {
2822                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2823                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
<span class="line-modified">2824                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::ExecState&amp;) const;\n&quot;);</span>
2825                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2826             }
2827             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2828                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
<span class="line-modified">2829                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::ExecState&amp;, JSC::JSValue);\n&quot;);</span>
2830                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2831             }
2832         }
2833     }
2834 
2835     foreach my $operation (@{$interface-&gt;operations}) {
2836         $numCustomOperations++ if HasCustomMethod($operation);
2837         $hasForwardDeclaringOperations = 1 if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2838     }
2839 
2840     if ($numCustomOperations &gt; 0) {
2841         my $inAppleCopyright = 0;
2842         push(@headerContent, &quot;\n    // Custom functions\n&quot;);
2843         foreach my $operation (@{$interface-&gt;operations}) {
2844             next unless HasCustomMethod($operation);
2845             next if $operation-&gt;{overloads} &amp;&amp; $operation-&gt;{overloadIndex} != 1;
2846 
2847             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2848                 if (!$inAppleCopyright) {
2849                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2850                     $inAppleCopyright = 1;
2851                 }
2852             } elsif ($inAppleCopyright) {
2853                 push(@headerContent, $endAppleCopyright);
2854                 $inAppleCopyright = 0;
2855             }
2856 
2857             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
2858             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2859 
2860             my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
2861 
2862             my @functionArguments = ();
<span class="line-modified">2863             push(@functionArguments, &quot;JSC::ExecState&amp;&quot;);</span>

2864             push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
2865 
2866             push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
2867 
2868             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2869         }
2870         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2871     }
2872 
2873     if (NeedsImplementationClass($interface)) {
2874         if ($hasParent) {
2875             push(@headerContent, &quot;    $interfaceName&amp; wrapped() const\n&quot;);
2876             push(@headerContent, &quot;    {\n&quot;);
2877             push(@headerContent, &quot;        return static_cast&lt;$interfaceName&amp;&gt;(Base::wrapped());\n&quot;);
2878             push(@headerContent, &quot;    }\n&quot;);
2879         }
2880     }
2881 
2882     # structure flags
2883     if (%structureFlags) {
2884         push(@headerContent, &quot;public:\n&quot;);
<span class="line-modified">2885         push(@headerContent, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);</span>
2886         foreach my $structureFlag (sort (keys %structureFlags)) {
2887             push(@headerContent, &quot; | &quot; . $structureFlag);
2888         }
2889         push(@headerContent, &quot;;\n&quot;);
2890     }
2891 
2892     push(@headerContent, &quot;protected:\n&quot;);
2893 
2894     # Constructor
2895     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2896         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;, JSWindowProxy*);\n&quot;);
2897     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2898         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2899     } elsif (!NeedsImplementationClass($interface)) {
2900         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;);\n\n&quot;);
2901      } else {
2902         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;, Ref&lt;$implType&gt;&amp;&amp;);\n\n&quot;);
2903     }
2904 
2905     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
</pre>
<hr />
<pre>
2924         push(@headerContent, &quot;    virtual bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt;, void* context, JSC::SlotVisitor&amp;, const char**);\n&quot;);
2925         push(@headerContent, &quot;    virtual void finalize(JSC::Handle&lt;JSC::Unknown&gt;, void* context);\n&quot;);
2926         push(@headerContent, &quot;};\n&quot;);
2927         push(@headerContent, &quot;\n&quot;);
2928         push(@headerContent, &quot;inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, $implType*)\n&quot;);
2929         push(@headerContent, &quot;{\n&quot;);
2930         push(@headerContent, &quot;    static NeverDestroyed&lt;JS${interfaceName}Owner&gt; owner;\n&quot;);
2931         push(@headerContent, &quot;    return &amp;owner.get();\n&quot;);
2932         push(@headerContent, &quot;}\n&quot;);
2933         push(@headerContent, &quot;\n&quot;);
2934         push(@headerContent, &quot;inline void* wrapperKey($implType* wrappableObject)\n&quot;);
2935         push(@headerContent, &quot;{\n&quot;);
2936         push(@headerContent, &quot;    return wrappableObject;\n&quot;);
2937         push(@headerContent, &quot;}\n&quot;);
2938         push(@headerContent, &quot;\n&quot;);
2939     }
2940     if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
2941         # Node and NodeList have custom inline implementations which thus cannot be exported.
2942         # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
2943         if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
<span class="line-modified">2944             push(@headerContent, &quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
2945         } else {
<span class="line-modified">2946             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
2947         }
<span class="line-modified">2948         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(state, globalObject, *impl) : JSC::jsNull(); }\n&quot;);</span>
2949 
<span class="line-modified">2950         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);</span>
<span class="line-modified">2951         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::ExecState* state, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(state, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);</span>
2952    }
2953 
2954     push(@headerContent, &quot;\n&quot;);
2955 
2956     GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
2957 
2958     if ($hasForwardDeclaringOperations) {
2959         my $inAppleCopyright = 0;
2960         push(@headerContent,&quot;// Functions\n\n&quot;);
2961         foreach my $operation (@{$interface-&gt;operations}) {
2962             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
2963             next unless $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2964 
2965             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2966                 if (!$inAppleCopyright) {
2967                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2968                     $inAppleCopyright = 1;
2969                 }
2970             } elsif ($inAppleCopyright) {
2971                 push(@headerContent, $endAppleCopyright);
2972                 $inAppleCopyright = 0;
2973             }
2974 
2975             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
2976             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
2977             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2978             my $functionName = GetFunctionName($interface, $className, $operation);
<span class="line-modified">2979             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);</span>
2980             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2981         }
2982 
2983         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2984         push(@headerContent,&quot;\n&quot;);
2985     }
2986 
2987     if ($hasForwardDeclaringAttributes) {
2988         push(@headerContent,&quot;// Attributes\n\n&quot;);
2989         foreach my $attribute (@{$interface-&gt;attributes}) {
2990             next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2991 
2992             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2993             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2994             my $getter = GetAttributeGetterName($interface, $className, $attribute);
<span class="line-modified">2995             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
2996             if (!IsReadonly($attribute)) {
2997                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
<span class="line-modified">2998                 push(@headerContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
2999             }
3000             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3001         }
3002     }
3003 
3004     # CheckSubClass Snippet function.
3005     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
3006         $headerIncludes{&quot;&lt;JavaScriptCore/Snippet.h&gt;&quot;} = 1;
3007         push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3008         push(@headerContent, &quot;Ref&lt;JSC::Snippet&gt; checkSubClassSnippetFor${className}();\n&quot;);
3009         push(@headerContent, &quot;#endif\n&quot;);
3010     }
3011 
3012     if ($hasDOMJITAttributes) {
3013         $headerIncludes{&quot;&lt;JavaScriptCore/DOMJITGetterSetter.h&gt;&quot;} = 1;
3014         push(@headerContent,&quot;// DOM JIT Attributes\n\n&quot;);
3015         foreach my $attribute (@{$interface-&gt;attributes}) {
3016             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3017             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
3018 
3019             my $interfaceName = $interface-&gt;type-&gt;name;
3020             my $className = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
3021             my $domJITClassName = $className . &quot;Attribute&quot;;
3022 
3023             push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3024             push(@headerContent, &quot;Ref&lt;JSC::DOMJIT::CallDOMGetterSnippet&gt; compile${domJITClassName}();\n&quot;);
3025             push(@headerContent, &quot;#endif\n\n&quot;);
3026         }
3027     }
3028 
3029     if (HasCustomConstructor($interface)) {
3030         push(@headerContent, &quot;// Custom constructor\n&quot;);
<span class="line-modified">3031         push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL construct${className}(JSC::ExecState&amp;);\n\n&quot;);</span>
3032     }
3033 
3034     if (NeedsImplementationClass($interface)) {
3035         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
3036         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
3037 
3038         push(@headerContent, &quot;template&lt;&gt; struct JSDOMWrapperConverterTraits&lt;${implType}&gt; {\n&quot;);
3039         push(@headerContent, &quot;    using WrapperClass = ${className};\n&quot;);
3040         push(@headerContent, &quot;    using ToWrappedReturnType = ${toWrappedType};\n&quot;);
3041         push(@headerContent, &quot;};\n&quot;);
3042     }
3043 
3044     push(@headerContent, GenerateEnumerationsHeaderContent($interface, $enumerations));
3045     push(@headerContent, GenerateDictionariesHeaderContent($interface, $dictionaries));
3046 
3047     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
3048     push(@headerContent, &quot;\n} // namespace WebCore\n&quot;);
3049     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
3050 
3051     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
</pre>
<hr />
<pre>
3083     my $className = &quot;JS$interfaceName&quot;;
3084     
3085     # - Add all properties in a hashtable definition
3086     my $propertyCount = $isInstance ? InstancePropertyCount($interface) : PrototypePropertyCount($interface);
3087 
3088     if (!$isInstance &amp;&amp; NeedsConstructorProperty($interface)) {
3089         die if !$propertyCount;
3090         push(@$hashKeys, &quot;constructor&quot;);
3091         my $getter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3092         push(@$hashValue1, $getter);
3093 
3094         my $setter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3095         push(@$hashValue2, $setter);
3096         push(@$hashSpecials, &quot;static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum)&quot;);
3097     }
3098 
3099     return 0 if !$propertyCount;
3100 
3101     my @attributes = @{$interface-&gt;attributes};
3102     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;

3103 
3104     foreach my $attribute (@attributes) {
3105         next if ($attribute-&gt;isStatic);
3106         next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
3107         next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
3108 
3109         # Global objects add RuntimeEnabled attributes after creation so do not add them to the static table.
3110         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $attribute)) {
3111             $propertyCount -= 1;
3112             next;
3113         }
3114 
3115         my $name = $attribute-&gt;name;
3116         push(@$hashKeys, $name);
3117 
3118         my $special = GetJSCAttributesForAttribute($interface, $attribute);
3119         push(@$hashSpecials, $special);
3120 
3121         if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
3122             push(@$hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
3123         } else {
3124             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3125             push(@$hashValue1, $getter);
3126         }
3127 
3128         if (IsReadonly($attribute)) {
3129             push(@$hashValue2, &quot;0&quot;);
3130         } else {
3131             my $setter = GetAttributeSetterName($interface, $className, $attribute);
3132             push(@$hashValue2, $setter);
3133         }
3134 
3135         my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
3136         $conditionals-&gt;{$name} = $conditional if $conditional;
3137         my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3138         $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
3139 
<span class="line-modified">3140         if (NeedsRuntimeCheck($interface, $attribute)) {</span>







3141             push(@$runtimeEnabledAttributes, $attribute);
3142         }
3143     }
3144 
3145     my @operations = @{$interface-&gt;operations};
3146     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3147     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;

3148     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3149     foreach my $operation (@operations) {
3150         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
3151         next if ($operation-&gt;isStatic);
3152         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3153         next if OperationShouldBeOnInstance($interface, $operation) != $isInstance;
3154         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
3155 
3156         # Global objects add RuntimeEnabled operations after creation so do not add them to the static table.
3157         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $operation)) {
3158             $propertyCount -= 1;
3159             next;
3160         }
3161 
3162         my $name = $operation-&gt;name;
3163         push(@$hashKeys, $name);
3164 
3165         my $functionName = GetFunctionName($interface, $className, $operation);
3166         push(@$hashValue1, $functionName);
3167 
</pre>
<hr />
<pre>
3423     };
3424     my $isBooleanParameter = sub {
3425         my ($type, $optionality) = @_;
3426         return $type-&gt;name eq &quot;boolean&quot;;
3427     };
3428     my $isNumericParameter = sub {
3429         my ($type, $optionality) = @_;
3430         return $codeGenerator-&gt;IsNumericType($type);
3431     };
3432     my $isStringOrEnumParameter = sub {
3433         my ($type, $optionality) = @_;
3434         return $codeGenerator-&gt;IsStringOrEnumType($type);
3435     };
3436     my $isAnyParameter = sub {
3437         my ($type, $optionality) = @_;
3438         return $type-&gt;name eq &quot;any&quot;;
3439     };
3440 
3441     my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
3442 
<span class="line-modified">3443     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, state-&gt;argumentCount());\n&quot;);</span>
3444 
3445     for my $length ( sort keys %allSets ) {
3446         push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
3447 
3448         my $S = $allSets{$length};
3449         if (scalar(@$S) &gt; 1) {
3450             my $d = GetDistinguishingArgumentIndex($operation, $S);
<span class="line-modified">3451             push(@implContent, &quot;        JSValue distinguishingArg = state-&gt;uncheckedArgument($d);\n&quot;);</span>
3452 
3453             my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
3454             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
3455 
3456             $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
3457             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefinedOrNull()&quot;);
3458 
3459             for my $tuple (@{$S}) {
3460                 my $overload = @{$tuple}[0];
3461                 my $type = @{@{$tuple}[1]}[$d];
3462 
3463                 my @subtypes = $type-&gt;isUnion ? GetFlattenedMemberTypes($type) : ( $type );
3464                 for my $subtype (@subtypes) {
3465                     if ($codeGenerator-&gt;IsWrapperType($subtype) || $codeGenerator-&gt;IsBufferSourceType($subtype)) {
3466                         if ($subtype-&gt;name eq &quot;DOMWindow&quot;) {
3467                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3468                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSDOMWindow&gt;(vm))&quot;);
3469                         } elsif ($subtype-&gt;name eq &quot;RemoteDOMWindow&quot;) {
3470                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3471                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSRemoteDOMWindow&gt;(vm))&quot;);
3472                         } else {
3473                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JS&quot; . $subtype-&gt;name . &quot;&gt;(vm)&quot;);
3474                         }
3475                     }
3476                 }
3477             }
3478 
3479             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorOrDOMExceptionParameter);
3480             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JSDOMException&gt;(vm)&quot;);
3481 
3482             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorParameter);
3483             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;type() == ErrorInstanceType&quot;);
3484 
3485             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
3486             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
3487 
3488             # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
3489             $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
<span class="line-modified">3490             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(*state, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);</span>
3491 
3492             $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
3493             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
3494 
3495             my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
3496             &amp;$generateOverloadCallIfNecessary($booleanOverload, &quot;distinguishingArg.isBoolean()&quot;);
3497 
3498             my $numericOverload = GetOverloadThatMatches($S, $d, \&amp;$isNumericParameter);
3499             &amp;$generateOverloadCallIfNecessary($numericOverload, &quot;distinguishingArg.isNumber()&quot;);
3500 
3501             # Fallbacks.
3502             $overload = GetOverloadThatMatches($S, $d, \&amp;$isStringOrEnumParameter);
3503             if ($overload) {
3504                 &amp;$generateOverloadCallIfNecessary($overload);
3505             } elsif ($numericOverload) {
3506                 &amp;$generateOverloadCallIfNecessary($numericOverload);
3507             } elsif ($booleanOverload) {
3508                 &amp;$generateOverloadCallIfNecessary($booleanOverload);
3509             } else {
3510                 $overload = GetOverloadThatMatches($S, $d, \&amp;$isAnyParameter);
3511                 &amp;$generateOverloadCallIfNecessary($overload);
3512             }
3513         } else {
3514             # Only 1 overload with this number of parameters.
3515             my $overload = @{@{$S}[0]}[0];
3516             &amp;$generateOverloadCallIfNecessary($overload);
3517         }
3518         push(@implContent, &lt;&lt;END);
3519     }
3520 END
3521     }
3522     my $minArgCount = GetFunctionLength($operation);
3523     if ($minArgCount &gt; 0) {
<span class="line-modified">3524         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(state, throwScope, createNotEnoughArgumentsError(state)) : throwVMTypeError(state, throwScope);\n&quot;)</span>
3525     } else {
<span class="line-modified">3526         push(@implContent, &quot;    return throwVMTypeError(state, throwScope);\n&quot;)</span>
3527     }
3528 }
3529 
3530 # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
3531 sub GetFunctionLength
3532 {
3533     my $operation = shift;
3534 
3535     my $getOverloadLength = sub {
3536         my $operation = shift;
3537 
3538         my $length = 0;
3539         foreach my $argument (@{$operation-&gt;arguments}) {
3540             last if $argument-&gt;isOptional || $argument-&gt;isVariadic;
3541             $length++;
3542         }
3543         return $length;
3544     };
3545 
3546     my $length = &amp;$getOverloadLength($operation);
</pre>
<hr />
<pre>
3660 sub GetImplementationLacksVTableForInterface
3661 {
3662     my $interface = shift;
3663     return $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
3664 }
3665 
3666 sub GetSkipVTableValidationForInterface
3667 {
3668     my $interface = shift;
3669     return $interface-&gt;extendedAttributes-&gt;{SkipVTableValidation};
3670 }
3671 
3672 # URL becomes url, but SetURL becomes setURL.
3673 sub ToMethodName
3674 {
3675     my $param = shift;
3676     my $ret = lcfirst($param);
3677     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
3678     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
3679     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;

3680     $ret =~ s/jS/js/ if $ret =~ /^jS/;
3681     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
3682     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
3683     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
3684 
3685     # For HTML5 FileSystem API Flags attributes.
3686     # (create is widely used to instantiate an object and must be avoided.)
3687     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
3688     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
3689 
3690     return $ret;
3691 }
3692 
3693 sub GenerateRuntimeEnableConditionalStringForExposed
3694 {
3695     my ($interface, $context, $conjuncts, $globalObjectIsParam) = @_;
3696 
3697     assert(&quot;Must specify value for Exposed.&quot;) if $context-&gt;extendedAttributes-&gt;{Exposed} eq &quot;VALUE_IS_MISSING&quot;;
3698 
3699     AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
</pre>
<hr />
<pre>
3712         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isDocument()&quot;);
3713     } elsif ($exposed eq &quot;Worker&quot;) {
3714         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkerGlobalScope()&quot;);
3715     } elsif ($exposed eq &quot;Worklet&quot;) {
3716         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkletGlobalScope()&quot;);
3717     } else {
3718         assert(&quot;Unrecognized value &#39;&quot; . Dumper($context-&gt;extendedAttributes-&gt;{Exposed}) . &quot;&#39; for the Exposed extended attribute on &#39;&quot; . ref($context) . &quot;&#39;.&quot;);
3719     }
3720 }
3721 
3722 # Returns the conditional string that determines whether a method/attribute is enabled at runtime.
3723 # A method/attribute is enabled at runtime if either its RuntimeEnabledFeatures function returns
3724 # true or its EnabledForWorld function returns true (or both).
3725 # NOTE: Parameter passed in must have an &#39;extendedAttributes&#39; property.
3726 # (e.g. IDLInterface, IDLAttribute, IDLOperation, IDLIterable, etc.)
3727 sub GenerateRuntimeEnableConditionalString
3728 {
3729     my ($interface, $context, $globalObjectIsParam) = @_;
3730 
3731     my @conjuncts;
<span class="line-modified">3732     my $globalObjectPtr = $globalObjectIsParam ? &quot;&amp;globalObject&quot; : &quot;globalObject()&quot;;</span>
3733     
3734     if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
3735         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3736 
3737         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3738             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3739                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme())&quot;);
3740         } elsif ($context-&gt;extendedAttributes-&gt;{ContextAllowsMediaDevices}) {
3741             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3742                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;allowsMediaDevices())&quot;);
3743         } else {
3744             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(globalObject())-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;);
3745         }
3746     } else {
3747         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3748             AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3749 
3750             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme()&quot;);
3751         }
3752     }
</pre>
<hr />
<pre>
3792 
3793         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3794 
3795         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3796         foreach my $flag (@flags) {
3797             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3798         }
3799     }
3800 
3801     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3802         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3803 
3804         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3805 
3806         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3807         foreach my $flag (@flags) {
3808             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3809         }
3810     }
3811 











3812     if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {
3813         assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;
3814         assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);
3815 
3816         my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;
3817         my $name = $context-&gt;name;
3818         push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);
3819     }
3820 









3821     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3822     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3823     return $result;
3824 }
3825 
3826 sub GetCastingHelperForThisObject
3827 {
3828     my $interface = shift;
3829     my $interfaceName = $interface-&gt;type-&gt;name;
3830     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3831 }
3832 
3833 # http://heycam.github.io/webidl/#Unscopable
3834 sub addUnscopableProperties
3835 {
3836     my $interface = shift;
3837 
3838     my @unscopables;
3839     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3840         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3841     }
3842     return if scalar(@unscopables) == 0;
3843 
3844     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
<span class="line-modified">3845     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;globalExec(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);</span>
3846     foreach my $unscopable (@unscopables) {
3847         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);
3848     }
3849     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3850 }
3851 
3852 sub GetArgumentTypeForFunctionWithoutTypeCheck
3853 {
3854     my ($interface, $type) = @_;
3855 
3856     my $IDLType = GetIDLType($interface, $type);
3857     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3858 }
3859 
3860 sub GetArgumentTypeFilter
3861 {
3862     my ($interface, $type) = @_;
3863 
3864     my $IDLType = GetIDLType($interface, $type);
3865     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
</pre>
<hr />
<pre>
3870     my ($interface, $type) = @_;
3871 
3872     my $IDLType = GetIDLType($interface, $type);
3873     return &quot;DOMJIT::IDLResultTypeFilter&lt;${IDLType}&gt;::value&quot;;
3874 }
3875 
3876 sub GetAttributeWithName
3877 {
3878     my ($interface, $attributeName) = @_;
3879     
3880     foreach my $attribute (@{$interface-&gt;attributes}) {
3881         return $attribute if $attribute-&gt;name eq $attributeName;
3882     }
3883 }
3884 
3885 # https://heycam.github.io/webidl/#es-iterator
3886 sub InterfaceNeedsIterator
3887 {
3888     my ($interface) = @_;
3889 
<span class="line-modified">3890     # FIXME: This should return 1 for setlike once we support it.</span>
3891     return 1 if $interface-&gt;mapLike;
3892     return 1 if $interface-&gt;iterable;
3893 
3894     if (GetIndexedGetterOperation($interface)) {
3895         my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
3896         return 1 if $lengthAttribute and $codeGenerator-&gt;IsIntegerType($lengthAttribute-&gt;type);
3897     }
3898     return 0;
3899 }
3900 
3901 sub GenerateImplementation
3902 {
3903     my ($object, $interface, $enumerations, $dictionaries) = @_;
3904 
3905     my $interfaceName = $interface-&gt;type-&gt;name;
3906     my $className = &quot;JS$interfaceName&quot;;
3907 
3908     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
3909     my $parentClassName = GetParentClassName($interface);
3910     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
3911     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
3912 
3913     my $namedGetterOperation = GetNamedGetterOperation($interface);
3914     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
3915 
3916     # - Add default header template
3917     push(@implContentHeader, GenerateImplementationContentHeader($interface));
3918 
3919     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
3920     AddToImplIncludes(&quot;JSDOMBinding.h&quot;);
3921     AddToImplIncludes(&quot;JSDOMExceptionHandling.h&quot;);
3922     AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
3923     AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
3924     AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
3925     AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
3926     AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;

3927     AddJSBuiltinIncludesIfNeeded($interface);
3928 
3929     my $implType = GetImplClassName($interface);
3930 
3931     @implContent = ();
3932 
3933     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
3934     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
3935 
3936     push(@implContent, GenerateEnumerationsImplementationContent($interface, $enumerations));
3937     push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
3938 
3939     my @operations = @{$interface-&gt;operations};
3940     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3941     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;

3942     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3943 
3944     my @attributes = @{$interface-&gt;attributes};
3945     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;

3946 
3947     my $numConstants = @{$interface-&gt;constants};
3948     my $numOperations = @operations;
3949     my $numAttributes = @attributes;
3950 
3951     if ($numOperations &gt; 0) {
3952         my $inAppleCopyright = 0;
3953         push(@implContent,&quot;// Functions\n\n&quot;);
3954         foreach my $operation (@operations) {
3955             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3956             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3957             next if IsJSBuiltin($interface, $operation);
3958 
3959             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
3960                 if (!$inAppleCopyright) {
3961                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
3962                     $inAppleCopyright = 1;
3963                 }
3964             } elsif ($inAppleCopyright) {
3965                 push(@implContent, $endAppleCopyright);
3966                 $inAppleCopyright = 0;
3967             }
3968 
3969             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
3970             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
3971             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3972             my $functionName = GetFunctionName($interface, $className, $operation);
<span class="line-modified">3973             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState*);\n&quot;);</span>
3974             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
3975                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
3976                 my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
<span class="line-modified">3977                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState*, $className*&quot;;</span>
3978                 foreach my $argument (@{$operation-&gt;arguments}) {
3979                     my $type = $argument-&gt;type;
3980                     my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
3981                     $functionSignature .= &quot;, ${argumentType}&quot;;
3982                 }
3983                 push(@implContent, $functionSignature . &quot;);\n&quot;);
3984             }
3985             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
3986         }
3987 
3988         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
3989         push(@implContent, &quot;\n&quot;);
3990     }
3991 
3992     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
3993         push(@implContent, &quot;// Attributes\n\n&quot;);
3994 
3995         if (NeedsConstructorProperty($interface)) {
3996             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
<span class="line-modified">3997             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
3998 
3999             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
<span class="line-modified">4000             push(@implContent, &quot;bool ${constructorSetter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
4001         }
4002 
4003         foreach my $attribute (@attributes) {
4004             next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4005             next if IsJSBuiltin($interface, $attribute);
4006 
4007             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4008             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4009             my $getter = GetAttributeGetterName($interface, $className, $attribute);
<span class="line-modified">4010             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
4011             if (!IsReadonly($attribute)) {
4012                 my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4013                 if ($readWriteConditional) {
4014                     my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
4015                     push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
4016                 }
4017                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
<span class="line-modified">4018                 push(@implContent, &quot;bool ${setter}(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
4019                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
4020             }
4021             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4022         }
4023 
4024         push(@implContent, &quot;\n&quot;);
4025     }
4026 
4027     if ($numOperations &gt; 0) {
4028         foreach my $operation (@operations) {
4029             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
4030             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
4031             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
4032 
4033             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
4034             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
4035             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
4036 
4037             my $interfaceName = $interface-&gt;type-&gt;name;
4038             my $functionName = GetFunctionName($interface, $className, $operation);
</pre>
<hr />
<pre>
4233         push(@hashValue1, $constant-&gt;value);
4234         push(@hashValue2, &quot;0&quot;);
4235         push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4236 
4237         my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4238         $conditionals{$name} = $conditional if $conditional;
4239 
4240         $hashSize++;
4241     }
4242 
4243     my $justGenerateValueArray = !IsDOMGlobalObject($interface);
4244 
4245     $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, $justGenerateValueArray);
4246 
4247     if ($justGenerateValueArray) {
4248         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4249     } else {
4250         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4251     }
4252 
<span class="line-modified">4253     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
4254         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4255         push(@implContent, &quot;{\n&quot;);
4256         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4257         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4258 
4259         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4260         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4261 
4262         if (@runtimeEnabledProperties) {
4263             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4264         }
4265 
4266         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4267             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4268             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4269             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4270             my $name = $operationOrAttribute-&gt;name;
4271             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4272             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
4273             push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
4274             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
<span class="line-modified">4275             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject()-&gt;globalExec(), propertyName);\n&quot;);</span>
4276             push(@implContent, &quot;    }\n&quot;);
4277             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4278         }
4279 



















4280         if (@runtimeEnabledProperties) {
4281             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4282             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4283         }
4284 
4285         foreach my $operation (@{$interface-&gt;operations}) {
4286             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4287             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4288             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4289             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4290             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4291             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4292         }
4293 
4294         if (InterfaceNeedsIterator($interface)) {
4295             AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
<span class="line-modified">4296             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike) {</span>
4297                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4298             } else {
4299                 AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
4300                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4301             }
4302         }
4303         push(@implContent, &quot;    addValueIterableMethods(*globalObject(), *this);\n&quot;) if $interface-&gt;iterable and !IsKeyValueIterableInterface($interface);
4304 
4305         addUnscopableProperties($interface);
4306 
4307         push(@implContent, &quot;}\n\n&quot;);
4308     }
4309 
4310     # - Initialize static ClassInfo object
4311     push(@implContent, &quot;const ClassInfo $className&quot; . &quot;::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, &quot;);
4312 
4313     if ($numInstanceProperties &gt; 0) {
4314         push(@implContent, &quot;&amp;${className}Table&quot;);
4315     } else {
4316         push(@implContent, &quot;nullptr&quot;);
</pre>
<hr />
<pre>
4349         push(@implContent, &quot;{\n&quot;);
4350         push(@implContent, &quot;}\n\n&quot;);
4351     }
4352 
4353     # Finish Creation
4354     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4355         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSWindowProxy* proxy)\n&quot;);
4356         push(@implContent, &quot;{\n&quot;);
4357         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4358     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4359         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSProxy* proxy)\n&quot;);
4360         push(@implContent, &quot;{\n&quot;);
4361         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4362     } else {
4363         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm)\n&quot;);
4364         push(@implContent, &quot;{\n&quot;);
4365         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4366         push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
4367     }
4368 









4369     if ($interfaceName eq &quot;Location&quot;) {
4370         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4371         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4372     }
4373 
<span class="line-removed">4374     if ($interface-&gt;mapLike) {</span>
<span class="line-removed">4375         push(@implContent, &quot;    synchronizeBackingMap(*globalObject()-&gt;globalExec(), *globalObject(), *this);\n&quot;);</span>
<span class="line-removed">4376     }</span>
<span class="line-removed">4377 </span>
4378     # Support for RuntimeEnabled attributes on instances.
4379     foreach my $attribute (@{$interface-&gt;attributes}) {
4380         next unless NeedsRuntimeCheck($interface, $attribute);
4381         next unless AttributeShouldBeOnInstance($interface, $attribute);
4382 
4383         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4384         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4385         my $attributeName = $attribute-&gt;name;
4386         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4387         my $setter = IsReadonly($attribute) ? &quot;nullptr&quot; : GetAttributeSetterName($interface, $className, $attribute);
4388         my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4389 
4390         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4391         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4392         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4393         push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4394         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4395     }
4396 
4397     # Support PrivateIdentifier attributes on instances.
</pre>
<hr />
<pre>
4490     }
4491     
4492     if (InstanceOverridesDefineOwnProperty($interface)) {
4493         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4494     }
4495 
4496     if (InstanceOverridesDeleteProperty($interface)) {
4497         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4498     }
4499     
4500     if (InstanceOverridesGetCallData($interface)) {
4501         GenerateGetCallData(\@implContent, $interface, $className);
4502     }
4503     
4504     if ($numAttributes &gt; 0) {
4505         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4506 
4507         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4508         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4509         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
<span class="line-modified">4510             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);</span>
4511             push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4512             push(@implContent, &quot;    VM&amp; vm = state.vm();\n&quot;);</span>
4513             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4514             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
<span class="line-modified">4515             push(@implContent, &quot;        decodedThisValue = state.thisValue().toThis(&amp;state, NotStrictMode);\n&quot;);</span>
<span class="line-modified">4516             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);&quot;);</span>
4517             push(@implContent, &quot;}\n\n&quot;);
4518         } else {
<span class="line-modified">4519             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(ExecState&amp; state, EncodedJSValue thisValue)\n&quot;);</span>
4520             push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4521             push(@implContent, &quot;    return $castingFunction(state.vm(), JSValue::decode(thisValue));\n&quot;);</span>
4522             push(@implContent, &quot;}\n\n&quot;);
4523         }
4524     }
4525 
4526     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4527         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4528 
4529         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4530         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
<span class="line-modified">4531         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;state.thisValue().toThis(&amp;state, NotStrictMode)&quot; : &quot;state.thisValue()&quot;;</span>
<span class="line-modified">4532         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(ExecState&amp; state)\n&quot;);</span>
4533         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4534         push(@implContent, &quot;    return $castingFunction(state.vm(), $thisValue);\n&quot;);</span>
4535         push(@implContent, &quot;}\n\n&quot;);
4536     }
4537 
4538     if (NeedsConstructorProperty($interface)) {
4539         my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4540 
<span class="line-modified">4541         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
4542         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4543         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
4544         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4545         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4546         push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
<span class="line-modified">4547         push(@implContent, &quot;        return throwVMTypeError(state, throwScope);\n&quot;);</span>
4548 
4549         if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
<span class="line-modified">4550             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(state-&gt;vm(), prototype-&gt;globalObject()));\n&quot;);</span>
4551         } else {
<span class="line-modified">4552             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(state-&gt;vm(), ${className}Constructor::createStructure(state-&gt;vm(), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);</span>
4553             push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
4554             push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4555             push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
4556         }
4557         push(@implContent, &quot;}\n\n&quot;);
4558 
4559         my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4560 
<span class="line-modified">4561         push(@implContent, &quot;bool ${constructorSetter}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
4562         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4563         push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
4564         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4565         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4566         push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
<span class="line-modified">4567         push(@implContent, &quot;        throwVMTypeError(state, throwScope);\n&quot;);</span>
4568         push(@implContent, &quot;        return false;\n&quot;);
4569         push(@implContent, &quot;    }\n&quot;);
4570         push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
4571         push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
4572         push(@implContent, &quot;}\n\n&quot;);
4573 
4574     }
4575 
4576     foreach my $attribute (@attributes) {
4577         GenerateAttributeGetterDefinition(\@implContent, $interface, $className, $attribute);
4578         GenerateAttributeSetterDefinition(\@implContent, $interface, $className, $attribute);
4579     }
4580 
4581     foreach my $operation (@operations) {
4582         GenerateOperationDefinition(\@implContent, $interface, $className, $operation);
4583     }
4584     
4585     GenerateIterableDefinition($interface) if $interface-&gt;iterable;
4586     GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
4587 








4588     if ($needsVisitChildren) {
4589         push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4590         push(@implContent, &quot;{\n&quot;);
4591         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4592         push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4593         push(@implContent, &quot;    Base::visitChildren(thisObject, visitor);\n&quot;);
4594         push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
4595         if ($interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost}) {
4596             push(@implContent, &quot;    visitor.reportExtraMemoryVisited(thisObject-&gt;wrapped().memoryCost());\n&quot;);
4597             if ($interface-&gt;extendedAttributes-&gt;{ReportExternalMemoryCost}) {;
4598                 push(@implContent, &quot;#if ENABLE(RESOURCE_USAGE)\n&quot;);
4599                 push(@implContent, &quot;    visitor.reportExternalMemoryVisited(thisObject-&gt;wrapped().externalMemoryCost());\n&quot;);
4600                 push(@implContent, &quot;#endif\n&quot;);
4601             }
4602         }
4603         if ($numCachedAttributes &gt; 0) {
4604             foreach my $attribute (@{$interface-&gt;attributes}) {
4605                 if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4606                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4607                     push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
</pre>
<hr />
<pre>
4775         push(@implContent, &quot;}\n\n&quot;);
4776     }
4777 
4778     if (ShouldGenerateToJSImplementation($hasParent, $interface)) {
4779         my $vtableNameGnu = GetGnuVTableNameForInterface($interface);
4780         my $vtableRefGnu = GetGnuVTableRefForInterface($interface);
4781         my $vtableRefWin = GetWinVTableRefForInterface($interface);
4782 
4783         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4784 #if ENABLE(BINDING_INTEGRITY)
4785 #if PLATFORM(WIN)
4786 #pragma warning(disable: 4483)
4787 extern &quot;C&quot; { extern void (*const ${vtableRefWin}[])(); }
4788 #else
4789 extern &quot;C&quot; { extern void* ${vtableNameGnu}[]; }
4790 #endif
4791 #endif
4792 
4793 END
4794 
<span class="line-modified">4795         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);</span>
4796         push(@implContent, &quot;{\n&quot;);
4797         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4798 
4799 #if ENABLE(BINDING_INTEGRITY)
<span class="line-modified">4800     void* actualVTablePointer = *(reinterpret_cast&lt;void**&gt;(impl.ptr()));</span>
4801 #if PLATFORM(WIN)
<span class="line-modified">4802     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefWin});</span>
4803 #else
<span class="line-modified">4804     void* expectedVTablePointer = WTF_PREPARE_VTBL_POINTER_FOR_INSPECTION(${vtableRefGnu});</span>
4805 #endif
4806 
4807     // If this fails ${implType} does not have a vtable, so you need to add the
4808     // ImplementationLacksVTable attribute to the interface definition
4809     static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
4810 
4811     // If you hit this assertion you either have a use after free bug, or
4812     // ${implType} has subclasses. If ${implType} has subclasses that get passed
4813     // to toJS() we currently require $interfaceName you to opt out of binding hardening
4814     // by adding the SkipVTableValidation attribute to the interface IDL definition
4815     RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
4816 #endif
4817 END
4818         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
4819     // If you hit this failure the interface definition has the ImplementationLacksVTable
4820     // attribute. You should remove that attribute. If the class has subclasses
4821     // that may be passed through this toJS() function you should use the SkipVTableValidation
4822     // attribute to $interfaceName.
4823     static_assert(!std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is polymorphic but the IDL claims it is not&quot;);
4824 END
4825         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
4826     globalObject-&gt;vm().heap.reportExtraMemoryAllocated(impl-&gt;memoryCost());
4827 END
4828 
4829         push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
4830         push(@implContent, &quot;}\n\n&quot;);
4831 
<span class="line-modified">4832         push(@implContent, &quot;JSC::JSValue toJS(JSC::ExecState* state, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);</span>
4833         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4834         push(@implContent, &quot;    return wrap(state, globalObject, impl);\n&quot;);</span>
4835         push(@implContent, &quot;}\n\n&quot;);
4836     }
4837 
4838     if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
4839         push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
4840         push(@implContent, &quot;{\n&quot;);
4841         push(@implContent, &quot;    if (auto* wrapper = &quot; . GetCastingHelperForThisObject($interface) . &quot;(vm, value))\n&quot;);
4842         push(@implContent, &quot;        return &amp;wrapper-&gt;wrapped();\n&quot;);
4843         push(@implContent, &quot;    return nullptr;\n&quot;);
4844         push(@implContent, &quot;}\n&quot;);
4845     }
4846 
4847     push(@implContent, &quot;\n}\n&quot;);
4848 
4849     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
4850     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
4851 }
4852 
4853 sub GenerateAttributeGetterBodyDefinition
4854 {
4855     my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
4856     
4857     my @signatureArguments = ();
<span class="line-modified">4858     push(@signatureArguments, &quot;ExecState&amp; state&quot;);</span>
4859     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4860     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4861     
4862     push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4863     push(@$outputArray, &quot;{\n&quot;);
4864     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
<span class="line-modified">4865     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
4866 
4867     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
4868         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
4869         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
4870         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4871         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="line-modified">4872             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
4873         } else {
<span class="line-modified">4874             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
4875         }
4876         push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
4877     }
4878     
4879     if (HasCustomGetter($attribute)) {
4880         my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
<span class="line-modified">4881         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(state);\n&quot;);</span>
4882     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4883         $implIncludes{&quot;EventNames.h&quot;} = 1;
4884         my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
4885             : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
4886             : &quot;eventHandlerAttribute&quot;;
4887         my $eventName = EventHandlerAttributeEventName($attribute);
4888         push(@$outputArray, &quot;    return $getter(thisObject.wrapped(), $eventName, worldForDOMObject(thisObject));\n&quot;);
4889     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4890         my $constructorType = $attribute-&gt;type-&gt;name;
4891         $constructorType =~ s/Constructor$//;
4892         # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
4893         # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
4894         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4895             my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
4896             $constructorType =~ s/Named$//;
<span class="line-modified">4897             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(state.vm(), &amp;thisObject);\n&quot;);</span>
4898         } else {
4899             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
<span class="line-modified">4900             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(state.vm(), thisObject.globalObject());\n&quot;);</span>
4901         }
4902     } else {
4903         if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4904             push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
4905             push(@$outputArray, &quot;        return cachedValue;\n&quot;);
4906         }
4907         
4908         my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
4909         
4910         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
4911         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
<span class="line-modified">4912         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);</span>
4913         
4914         unshift(@arguments, @callWithArgs);
4915 
<span class="line-modified">4916         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;</span>
4917         my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
<span class="line-modified">4918         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike;</span>
4919 
4920         if (!IsReadonly($attribute)) {
4921             my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
4922             if ($callTracingCallback) {
4923                 my @callTracerArguments = ();
4924                 GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
4925             }
4926         }
4927 
4928         push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
<span class="line-modified">4929         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(state.vm(), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};</span>
4930         push(@$outputArray, &quot;    return result;\n&quot;);
4931     }
4932     push(@$outputArray, &quot;}\n\n&quot;);
4933 }
4934 
4935 sub GenerateAttributeGetterTrampolineDefinition
4936 {
4937     my ($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional) = @_;
4938     
4939     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
4940     
4941     my $callAttributeGetterName = &quot;get&quot;;
4942     $callAttributeGetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
4943     
4944     my @templateParameters = ();
4945     push(@templateParameters, $attributeGetterBodyName);
4946     if ($attribute-&gt;extendedAttributes-&gt;{LenientThis}) {
4947         push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;)
4948     } elsif ($codeGenerator-&gt;IsPromiseType($attribute-&gt;type)) {
4949         push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
4950     } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
4951         push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
4952     }
4953     
<span class="line-modified">4954     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(ExecState* state, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
4955     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">4956     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);</span>
4957     push(@$outputArray, &quot;}\n\n&quot;);
4958 }
4959 
4960 sub GenerateAttributeGetterDefinition
4961 {
4962     my ($outputArray, $interface, $className, $attribute) = @_;
4963 
4964     return if IsJSBuiltin($interface, $attribute);
4965 
4966     my $attributeGetterName = GetAttributeGetterName($interface, $className, $attribute);
4967     my $attributeGetterBodyName = $attributeGetterName . &quot;Getter&quot;;
4968     
4969     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
4970     if ($conditional) {
4971         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
4972         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
4973     }
4974     
4975     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
4976     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
4977     
4978     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
4979 }
4980 
4981 sub GenerateAttributeSetterBodyDefinition
4982 {
4983     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
4984 
4985     my @signatureArguments = ();
<span class="line-modified">4986     push(@signatureArguments, &quot;ExecState&amp; state&quot;);</span>
4987     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4988     push(@signatureArguments, &quot;JSValue value&quot;);
4989     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4990     
4991     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4992     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">4993     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
4994     if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
4995         push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);
4996     } else {
4997         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
4998     }
4999 
<span class="line-modified">5000     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;state&quot;);</span>
5001 
5002     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
5003         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5004         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="line-modified">5005             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
5006         } else {
<span class="line-modified">5007             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
5008         }
5009         push(@$outputArray, &quot;        return false;\n&quot;);
5010     }
5011     
5012     if (HasCustomSetter($attribute)) {
5013         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
<span class="line-modified">5014         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(state, value);\n&quot;);</span>
5015         push(@$outputArray, &quot;    return true;\n&quot;);
5016     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
5017         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5018         my $eventName = EventHandlerAttributeEventName($attribute);
5019         # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
5020         if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
5021             AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
<span class="line-modified">5022             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(state, value, thisObject), worldForDOMObject(thisObject));\n&quot;);</span>
5023         } else {
5024             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5025             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
5026                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
5027                 : &quot;setEventHandlerAttribute&quot;;
<span class="line-modified">5028             push(@$outputArray, &quot;    $setter(state, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);</span>
5029         }
5030         push(@$outputArray, &quot;    return true;\n&quot;);
5031     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
5032         my $constructorType = $attribute-&gt;type-&gt;name;
5033         $constructorType =~ s/Constructor$//;
5034         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
5035         # We do not generate the header file for NamedConstructor of class XXXX,
5036         # since we generate the NamedConstructor declaration into the header file of class XXXX.
5037         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
5038             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
5039         }
5040         my $id = $attribute-&gt;name;
5041         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
5042         push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5043     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
5044         my $id = $attribute-&gt;name;
5045         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
5046         if (AttributeShouldBeOnInstance($interface, $attribute)) {
5047             push(@$outputArray, &quot;    return replaceStaticPropertySlot(vm, &amp;thisObject, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5048         } else {
5049             push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5050         }
5051     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5052         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
5053         
5054         # 3.5.9.1. Let Q be ? Get(O, id).
5055         my $id = $attribute-&gt;name;
5056         push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);
<span class="line-modified">5057         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;state, id);\n&quot;);</span>
5058         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5059         
5060         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
5061         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
<span class="line-modified">5062         push(@$outputArray, &quot;        throwTypeError(&amp;state, throwScope);\n&quot;);</span>
5063         push(@$outputArray, &quot;        return false;\n&quot;);
5064         push(@$outputArray, &quot;    }\n&quot;);
5065         
5066         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
5067         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
5068         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);
5069         
5070         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
5071         # FIXME: What should the second value to the PutPropertySlot be?
5072         # (https://github.com/heycam/webidl/issues/368)
5073         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
<span class="line-modified">5074         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;state, forwardId, value, slot);\n&quot;);</span>
5075         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5076         
5077         push(@$outputArray, &quot;    return true;\n&quot;);
5078     } else {
5079         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5080        
5081         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5082             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5083             # the standard conversion, but rather silently fail on invalid enumeration values.
<span class="line-modified">5084             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(state, value);\n&quot;);</span>
5085             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5086             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5087             push(@$outputArray, &quot;        return false;\n&quot;);
5088             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5089         } else {
<span class="line-modified">5090             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*thisObject.globalObject()&quot;;</span>
5091             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5092 
<span class="line-modified">5093             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;state&quot;, &quot;state&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);</span>
5094             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5095             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5096         }
5097 
5098         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5099 
5100         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5101 
5102         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
<span class="line-modified">5103         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;state&quot;, &quot;thisObject&quot;);</span>
5104 
5105         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5106         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5107 
5108         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5109         if ($callTracingCallback) {
5110             my $indent = &quot;    &quot;;
5111             my @callTracerArguments = (&quot;nativeValue&quot;);
5112             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5113         }
5114 
5115         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified">5116         push(@$outputArray, &quot;    AttributeSetter::call(state, throwScope, [&amp;] {\n&quot;);</span>
5117         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5118         push(@$outputArray, &quot;    });\n&quot;);
5119         push(@$outputArray, &quot;    return true;\n&quot;);
5120     }
5121     push(@$outputArray, &quot;}\n\n&quot;);
5122 }
5123 
5124 sub GenerateAttributeSetterTrampolineDefinition
5125 {
5126     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5127     
5128     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5129     
5130     my $callAttributeSetterName = &quot;set&quot;;
5131     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5132     
5133     my @templateParameters = ();
5134     push(@templateParameters, $attributeSetterBodyName);
5135     push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
5136     
<span class="line-modified">5137     push(@$outputArray, &quot;bool ${attributeSetterName}(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
5138     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5139     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*state, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);</span>
5140     push(@$outputArray, &quot;}\n\n&quot;);
5141 }
5142 
5143 sub GenerateAttributeSetterDefinition
5144 {
5145     my ($outputArray, $interface, $className, $attribute) = @_;
5146     
5147     return if IsReadonly($attribute);
5148     return if IsJSBuiltin($interface, $attribute);
5149     
5150     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5151     if ($conditional) {
5152         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5153         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5154     }
5155 
5156     my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
5157     if ($readWriteConditional) {
5158         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
5159         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
</pre>
<hr />
<pre>
5166     GenerateAttributeSetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional);
5167 
5168     push(@$outputArray, &quot;#endif\n\n&quot;) if $readWriteConditional;
5169     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5170 }
5171 
5172 sub GenerateOperationTrampolineDefinition
5173 {
5174     my ($outputArray, $interface, $className, $operation, $functionName, $functionBodyName) = @_;
5175 
5176     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5177     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5178     my $exposureScope = $interface-&gt;extendedAttributes-&gt;{Exposed} ? &quot;WindowOrWorker&quot; : &quot;WindowOnly&quot;;
5179 
5180     my $callFunctionName = &quot;call&quot;;
5181     $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
5182     $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5183 
5184     my @callFunctionTemplateArguments = ();
5185     push(@callFunctionTemplateArguments, $functionBodyName);
<span class="line-removed">5186     push(@callFunctionTemplateArguments, &quot;PromiseExecutionScope::${exposureScope}&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};</span>
5187     push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
5188 
<span class="line-modified">5189     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(ExecState* state)\n&quot;);</span>
5190     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5191     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*state, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);</span>
5192     push(@$outputArray, &quot;}\n\n&quot;);
5193 }
5194 
5195 sub GenerateOperationBodyDefinition
5196 {
<span class="line-modified">5197     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $generatingOverloadDispatcher) = @_;</span>
5198 
5199     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5200     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5201     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5202 
5203     my @signatureArguments = ();
<span class="line-modified">5204     push(@signatureArguments, &quot;JSC::ExecState* state&quot;);</span>

5205     push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
5206     push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5207     push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
5208 
5209     push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5210     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5211     push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>

5212     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5213 
<span class="line-modified">5214     if (!$generatingOverloadDispatcher) {</span>
<span class="line-removed">5215         GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*state&quot;);</span>
5216 



5217         if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
5218             assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
5219             
5220             AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5221             if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="line-modified">5222                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);</span>
5223                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5224             } else {
<span class="line-modified">5225                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);</span>
5226                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5227             }
5228         }
5229     }
5230 
5231     my $indent = &quot;    &quot;;
5232 
5233     if ($generatingOverloadDispatcher) {
<span class="line-modified">5234         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
5235         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
5236 
5237         my @argumentsToForward = ();
<span class="line-modified">5238         push(@argumentsToForward, &quot;state&quot;);</span>

5239         push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
5240         push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5241         push(@argumentsToForward, &quot;throwScope&quot;);
5242 
5243         GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
5244     } elsif (HasCustomMethod($operation)) {
5245         GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
5246     } else {
<span class="line-modified">5247         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isStatic) {</span>
5248             push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5249         }
5250 
5251         GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5252         my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5253 
5254         if ($operation-&gt;extendedAttributes-&gt;{ResultField}) {
5255             my $resultName = $operation-&gt;extendedAttributes-&gt;{ResultField};
5256             push(@$outputArray, &quot;    auto implResult = $functionString;\n&quot;);
5257             GenerateImplementationFunctionCall($outputArray, $operation, $interface, &quot;WTFMove(implResult.$resultName)&quot;, $indent);
5258         } else {
5259             GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5260         }
5261     }
5262 
5263     push(@$outputArray, &quot;}\n\n&quot;);
5264 }
5265 
5266 sub GenerateOperationDefinition
5267 {
</pre>
<hr />
<pre>
5287         push(@$outputArray, $endAppleCopyright);
5288         $inAppleCopyright = 0;
5289     }
5290 
5291     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5292     if ($conditional) {
5293         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5294         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5295     }
5296 
5297     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5298 
5299     AddToImplIncludesForIDLType($operation-&gt;type, $conditional) unless $isCustom or $hasPromiseReturnType;
5300     AddToImplIncludes(&quot;JSDOMOperation.h&quot;, $conditional) if !$hasPromiseReturnType;
5301     AddToImplIncludes(&quot;JSDOMOperationReturningPromise.h&quot;, $conditional) if $hasPromiseReturnType;
5302 
5303     my $functionName = GetFunctionName($interface, $className, $operation);
5304     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
5305     my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
5306 
<span class="line-modified">5307     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName);</span>
5308 
5309     # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
5310     # that gets generated after the last overload body has been generated.
5311     unless ($isOverloaded) {
5312         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
5313     }
5314 
5315     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5316 
5317     # Generate a function dispatching call to the rest of the overloads.
5318     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5319         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5320         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5321         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5322 
5323         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
<span class="line-modified">5324         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, 1);</span>
5325         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5326     
5327         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5328     }
5329 
5330 
5331     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5332         if ($conditional) {
5333             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5334             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5335         }
5336 
5337         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
5338         my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
<span class="line-modified">5339         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::ExecState* state, $className* castedThis&quot;);</span>
5340         foreach my $argument (@{$operation-&gt;arguments}) {
5341             my $type = $argument-&gt;type;
5342             my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
5343             my $name = $argument-&gt;name;
5344             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5345             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5346         }
5347         push(@$outputArray, &quot;)\n&quot;);
5348         push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5349         push(@$outputArray, &quot;    UNUSED_PARAM(state);\n&quot;);</span>
<span class="line-modified">5350         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
<span class="line-modified">5351         push(@$outputArray, &quot;    JSC::NativeCallFrameTracer tracer(vm, state);\n&quot;);</span>



5352         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5353         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5354         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5355         
5356         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5357         
5358         my @arguments = ();
<span class="line-modified">5359         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);</span>
5360         
5361         foreach my $argument (@{$operation-&gt;arguments}) {
5362             my $value = &quot;&quot;;
5363             my $type = $argument-&gt;type;
5364             my $name = $argument-&gt;name;
5365             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5366             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5367 
5368             my ($nativeValue, $mayThrowException) = ToNativeForFunctionWithoutTypeCheck($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});
5369             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5370             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5371             $value = &quot;WTFMove($name)&quot;;
5372 
5373             if ($shouldPassByReference) {
5374                 $value = &quot;*$name&quot;;
5375             }
5376             push(@arguments, $value);
5377         }
5378         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified">5379         $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
5380         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5381         push(@$outputArray, &quot;}\n\n&quot;);
5382 
5383         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5384     }
5385 
5386     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5387 }
5388 
5389 sub GenerateSerializerDefinition
5390 {
5391     my ($interface, $className) = @_;
5392 
5393     my $interfaceName = $interface-&gt;type-&gt;name;
5394 
5395     my $parentSerializerInterface = 0;
5396     if ($interface-&gt;serializable-&gt;hasInherit) {
5397         $codeGenerator-&gt;ForAllParents($interface, sub {
5398             my $parentInterface = shift;
5399             if ($parentInterface-&gt;serializable &amp;&amp; !$parentSerializerInterface) {
</pre>
<hr />
<pre>
5409         my $foundAttribute = 0;
5410         foreach my $attribute (@{$interface-&gt;attributes}) {
5411             if ($attributeName eq $attribute-&gt;name) {
5412                 $foundAttribute = 1;
5413                 if ($codeGenerator-&gt;IsSerializableAttribute($interface, $attribute)) {
5414                     push(@serializedAttributes, $attribute);                
5415                     last;
5416                 }                    
5417                 die &quot;Explicit \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; is not serializable\n&quot; if !$interface-&gt;serializable-&gt;hasAttribute;
5418                 last;
5419             }
5420         }
5421         die &quot;Failed to find \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; in $interfaceName\n&quot; if !$foundAttribute;
5422     }
5423 
5424     my $serializerFunctionName = &quot;toJSON&quot;;
5425     my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
5426 
5427     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
5428 
<span class="line-modified">5429     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(ExecState&amp; state, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);</span>
5430     push(@implContent, &quot;{\n&quot;);
<span class="line-modified">5431     push(@implContent, &quot;    auto&amp; vm = state.vm();\n&quot;);</span>
5432 
5433     if ($interface-&gt;serializable-&gt;hasInherit) {
5434         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
<span class="line-modified">5435         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(state, thisObject, globalObject, throwScope);\n&quot;);</span>
5436     } else {
<span class="line-modified">5437         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;state, globalObject.objectPrototype());\n&quot;);</span>
5438     }
5439     push(@implContent, &quot;\n&quot;);
5440 
5441     foreach my $attribute (@serializedAttributes) {
5442         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5443 
5444         my $name = $attribute-&gt;name;
5445         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
<span class="line-modified">5446         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(state, thisObject, throwScope);\n&quot;);</span>
5447         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5448 
5449         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5450             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5451             if ($attribute-&gt;type-&gt;isNullable) {
5452                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
<span class="line-modified">5453                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
5454                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5455                 push(@implContent, &quot;    } else\n&quot;);
5456                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5457             } else {
<span class="line-modified">5458                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(state, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
5459                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5460             }
5461         } else {
5462             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5463         }
5464 
5465         push(@implContent, &quot;\n&quot;);
5466     }
5467 
5468     push(@implContent, &quot;    return result;\n&quot;);
5469     push(@implContent, &quot;}\n&quot;);
5470     push(@implContent, &quot;\n&quot;);
5471 
<span class="line-modified">5472     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(ExecState* state, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);</span>
5473     push(@implContent, &quot;{\n&quot;);
<span class="line-modified">5474     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*state, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);</span>
5475     push(@implContent, &quot;}\n&quot;);
5476     push(@implContent, &quot;\n&quot;);
<span class="line-modified">5477     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(ExecState* state)\n&quot;);</span>
5478     push(@implContent, &quot;{\n&quot;);
<span class="line-modified">5479     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*state, \&quot;${serializerFunctionName}\&quot;);\n&quot;);</span>
5480     push(@implContent, &quot;}\n&quot;);
5481     push(@implContent, &quot;\n&quot;);
5482 }
5483 
5484 sub GenerateGetCallData
5485 {
5486     my ($outputArray, $interface, $className) = @_;
5487 
5488     return if $interface-&gt;extendedAttributes-&gt;{CustomGetCallData};
5489 
5490     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
5491         GeneratePluginCall($outputArray, $interface, $className);
5492     } else {
5493         GenerateLegacyCallerDefinitions($outputArray, $interface, $className);
5494     }
5495 }
5496 
5497 sub GeneratePluginCall
5498 {
5499     my ($outputArray, $interface, $className) = @_;
</pre>
<hr />
<pre>
5505     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
5506     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
5507 
5508     push(@$outputArray, &quot;    return pluginElementCustomGetCallData(thisObject, callData);\n&quot;);
5509     push(@$outputArray, &quot;}\n&quot;);
5510     push(@$outputArray, &quot;\n&quot;);
5511 }
5512 
5513 sub GenerateLegacyCallerDefinitions
5514 {
5515     my ($outputArray, $interface, $className) = @_;
5516 
5517     my @legacyCallers = @{$interface-&gt;{LegacyCallers}};
5518     if (@legacyCallers &gt; 1) {
5519         foreach my $legacyCaller (@legacyCallers) {
5520             GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
5521         }
5522 
5523         my $overloadFunctionPrefix = &quot;call${className}&quot;;
5524 
<span class="line-modified">5525         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(ExecState* state)\n&quot;);</span>
5526         push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5527         push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
5528         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5529         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5530 
<span class="line-modified">5531         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);</span>
5532 
5533         push(@$outputArray, &quot;}\n\n&quot;);
5534     } else {
5535         GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
5536     }
5537 
5538     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell*, CallData&amp; callData)\n&quot;);
5539     push(@$outputArray, &quot;{\n&quot;);
5540     push(@$outputArray, &quot;    callData.native.function = call${className};\n&quot;);
5541     push(@$outputArray, &quot;    return CallType::Host;\n&quot;);
5542     push(@$outputArray, &quot;}\n&quot;);
5543     push(@$outputArray, &quot;\n&quot;);
5544 }
5545 
5546 sub GenerateLegacyCallerDefinition
5547 {
5548     my ($outputArray, $interface, $className, $operation) = @_;
5549 
5550     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5551     if ($isOverloaded) {
<span class="line-modified">5552         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);</span>
5553     } else {
<span class="line-modified">5554         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(ExecState* state)\n&quot;);</span>
5555     }
5556 
5557     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5558     push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
5559     push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5560     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5561 
5562     my $indent = &quot;    &quot;;
5563     GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5564 
<span class="line-modified">5565     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(state-&gt;jsCallee());\n&quot;);</span>
5566     push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
5567     push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5568 
5569     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
5570     my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5571 
5572     GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5573 
5574     push(@$outputArray, &quot;}\n\n&quot;);
5575 }
5576 
5577 sub GenerateCallWithUsingReferences
5578 {
5579     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5580 
<span class="line-modified">5581     my $statePointer = &quot;&amp;state&quot;;</span>
<span class="line-modified">5582     my $stateReference = &quot;state&quot;;</span>
<span class="line-modified">5583     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state.lexicalGlobalObject())&quot;;</span>
5584 
<span class="line-modified">5585     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);</span>
5586 }
5587 
5588 # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
5589 sub GenerateCallWithUsingPointers
5590 {
5591     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5592 
<span class="line-modified">5593     my $statePointer = &quot;state&quot;;</span>
<span class="line-modified">5594     my $stateReference = &quot;*state&quot;;</span>
<span class="line-modified">5595     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot;;</span>
5596 
<span class="line-modified">5597     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $statePointer, $stateReference, $globalObject, $globalObject, $thisReference, $indent);</span>
5598 }
5599 
5600 sub GenerateConstructorCallWithUsingPointers
5601 {
5602     my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
5603 
<span class="line-modified">5604     my $statePointer = &quot;state&quot;;</span>
<span class="line-modified">5605     my $stateReference = &quot;*state&quot;;</span>
5606     my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
<span class="line-modified">5607     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*state, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;</span>
5608     my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
5609 
<span class="line-modified">5610     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);</span>
5611 }
5612 
5613 sub GenerateCallWith
5614 {
<span class="line-modified">5615     my ($callWith, $outputArray, $returnValue, $contextMissing, $statePointer, $stateReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;</span>
5616 
5617     return () unless $callWith;
5618 
5619     $indent ||= &quot;    &quot;;
5620 
5621     my @callWithArgs;
<span class="line-modified">5622     push(@callWithArgs, $stateReference) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;);</span>
<span class="line-modified">5623     push(@callWithArgs, &quot;*${globalObject}&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;);</span>





5624     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
5625         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5626         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5627         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5628         push(@callWithArgs, &quot;*context&quot;);
5629     }
5630     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;Document&quot;)) {
5631         AddToImplIncludes(&quot;Document.h&quot;);
5632         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5633         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5634         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5635         push(@$outputArray, $indent . &quot;ASSERT(context-&gt;isDocument());\n&quot;);
5636         push(@$outputArray, $indent . &quot;auto&amp; document = downcast&lt;Document&gt;(*context);\n&quot;);
5637         push(@callWithArgs, &quot;document&quot;);
5638     }
5639     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
5640         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5641         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5642         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow($stateReference).document();\n&quot;);</span>
5643         push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
5644         push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
5645         push(@callWithArgs, &quot;*incumbentDocument&quot;);
5646     }
5647     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
5648         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5649         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5650         push(@callWithArgs, &quot;responsibleDocument($stateReference)&quot;);</span>
5651     }
5652     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
5653         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5654         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5655         push(@callWithArgs, &quot;activeDOMWindow($stateReference)&quot;);</span>
5656     }
5657     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
5658         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5659         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5660         push(@callWithArgs, &quot;firstDOMWindow($stateReference)&quot;);</span>
5661     }
5662     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
5663         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5664         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5665         push(@callWithArgs, &quot;incumbentDOMWindow($stateReference)&quot;);</span>
5666     }
5667     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
5668         push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
5669     }
5670     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
5671         push(@callWithArgs, &quot;worldForDOMObject(${thisReference})&quot;);
5672     }
5673 
5674     return @callWithArgs;
5675 }
5676 
5677 sub GenerateArgumentsCountCheck
5678 {
5679     my ($outputArray, $operation, $interface, $indent) = @_;
5680 
5681     # Overloaded operations don&#39;t need to check the argument count since the 
5682     # dispatch function does for them.
5683     return if $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5684 
5685     my $numMandatoryArguments = @{$operation-&gt;arguments};
5686     foreach my $argument (reverse(@{$operation-&gt;arguments})) {
5687         if ($argument-&gt;isOptional or $argument-&gt;isVariadic) {
5688             $numMandatoryArguments--;
5689         } else {
5690             last;
5691         }
5692     }
5693     if ($numMandatoryArguments &gt;= 1) {
<span class="line-modified">5694         push(@$outputArray, $indent . &quot;if (UNLIKELY(state-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);</span>
<span class="line-modified">5695         push(@$outputArray, $indent . &quot;    return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));\n&quot;);</span>
5696     }
5697 }
5698 
5699 my %automaticallyGeneratedDefaultValues = (
5700     &quot;any&quot; =&gt; &quot;undefined&quot;,
5701 
5702     # toString() will convert undefined to the string &quot;undefined&quot;;
5703     # (note that this optimizes a behavior that is almost never useful)
5704     &quot;DOMString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5705     &quot;USVString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5706 
5707     # JSValue::toBoolean() will convert undefined to false.
5708     &quot;boolean&quot; =&gt; &quot;false&quot;,
5709 
5710     # JSValue::toInt*() / JSValue::toUint*() will convert undefined to 0.
5711     &quot;byte&quot; =&gt; &quot;0&quot;,
5712     &quot;long long&quot; =&gt; &quot;0&quot;,
5713     &quot;long&quot; =&gt; &quot;0&quot;,
5714     &quot;octet&quot; =&gt; &quot;0&quot;,
5715     &quot;short&quot; =&gt; &quot;0&quot;,
</pre>
<hr />
<pre>
5742     my ($operation) = @_;
5743 
5744     return 0 unless $operation-&gt;extendedAttributes-&gt;{MayThrowException};
5745 
5746     return $operation-&gt;type &amp;&amp; ($operation-&gt;type-&gt;name eq &quot;void&quot; || $codeGenerator-&gt;IsPromiseType($operation-&gt;type) || OperationHasForcedReturnValue($operation));
5747 }
5748 
5749 sub GenerateParametersCheck
5750 {
5751     my ($outputArray, $operation, $interface, $functionImplementationName, $indent) = @_;
5752 
5753     my $interfaceName = $interface-&gt;type-&gt;name;
5754     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
5755     my $numArguments = @{$operation-&gt;arguments};
5756     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5757     my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
5758 
5759     my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5760     
5761     my @arguments = ();
<span class="line-modified">5762     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*state&quot;, &quot;*castedThis&quot;);</span>
5763     
5764     my $quotedFunctionName;
5765     if (!$isConstructor) {
5766         my $name = $operation-&gt;name;
5767         $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
5768         push(@arguments, GenerateCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{CallWith}, \@$outputArray, &quot;JSValue::encode(jsUndefined())&quot;, &quot;*castedThis&quot;));
5769     } else {
5770         $quotedFunctionName = &quot;nullptr&quot;;
5771         push(@arguments, GenerateConstructorCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{ConstructorCallWith}, \@$outputArray, $visibleInterfaceName, &quot;*castedThis&quot;));
5772     }
5773 
5774     my $argumentIndex = 0;
5775     foreach my $argument (@{$operation-&gt;arguments}) {
5776         my $type = $argument-&gt;type;
5777 
5778         assert &quot;Optional arguments of non-nullable wrapper types are not supported (&quot; . $operation-&gt;name . &quot;)&quot; if $argument-&gt;isOptional &amp;&amp; !$type-&gt;isNullable &amp;&amp; $codeGenerator-&gt;IsWrapperType($type);
5779 
5780         if ($argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default)) {
5781             # As per Web IDL, optional dictionary arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
5782             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsDictionaryType($type);
</pre>
<hr />
<pre>
5790             # We use the null string as default value for arguments of type DOMString unless specified otherwise.
5791             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsStringType($type);
5792 
5793             # As per Web IDL, passing undefined for a nullable argument is treated as null. Therefore, use null as
5794             # default value for nullable arguments unless otherwise specified.
5795             $argument-&gt;default(&quot;null&quot;) if $type-&gt;isNullable;
5796 
5797             # For callback arguments, the generated bindings treat undefined as null, so use null as implicit default value.
5798             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type);
5799         }
5800 
5801         my $name = $argument-&gt;name;
5802         my $value = $name;
5803 
5804         if ($argument-&gt;isVariadic) {
5805             AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
5806             AddToImplIncludesForIDLType($type, $conditional);
5807         
5808             my $IDLType = GetIDLType($interface, $type);
5809 
<span class="line-modified">5810             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*state, ${argumentIndex});\n&quot;);</span>
5811             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5812 
5813             $value = &quot;WTFMove(${name})&quot;;
5814         } else {
5815             my $argumentLookupForConversion;
5816             my $optionalCheck;
5817             my $nativeValueCastFunction;
5818 
5819             if ($argument-&gt;isOptional) {
5820                 assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
5821 
5822                 if (defined($argument-&gt;default)) {
5823                     if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
<span class="line-modified">5824                         $argumentLookupForConversion = &quot;state-&gt;argument($argumentIndex)&quot;;</span>
5825                     } else {
5826                         my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
<span class="line-modified">5827                         $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="line-modified">5828                         $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;</span>
5829                     }
5830                 } else {
5831                     my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
5832 
5833                     my $defaultValue;
5834                     if ($codeGenerator-&gt;IsPromiseType($argument-&gt;type)) {
5835                         $defaultValue = &quot;nullptr&quot;;
5836                     } else {
5837                         $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
5838                         $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
5839                     }
5840 
<span class="line-modified">5841                     $optionalCheck = &quot;state-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="line-modified">5842                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
5843                 }
5844             } else {
5845                 if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
<span class="line-modified">5846                     push(@$outputArray, $indent . &quot;auto returnValue = state-&gt;uncheckedArgument($argumentIndex);\n&quot;);</span>
5847                     $argumentLookupForConversion = &quot;returnValue&quot;;
5848                 } else {
<span class="line-modified">5849                     $argumentLookupForConversion = &quot;state-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
5850                 }
5851             }
5852 
<span class="line-modified">5853             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
5854             my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
5855 
<span class="line-modified">5856             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;state&quot;, &quot;*state&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);</span>
5857 
5858             $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
5859             $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
5860 
5861             push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
5862             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5863 
5864             $value = PassArgumentExpression($name, $argument);
5865         }
5866 
5867         push(@arguments, $value);
5868         $argumentIndex++;
5869     }
5870 
5871     push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
5872 
5873     my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified">5874     $functionString = &quot;propagateException(*state, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
5875 
5876     return $functionString;
5877 }
5878 
5879 sub GenerateDictionaryHeader
5880 {
5881     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5882 
5883     # - Add default header template and header protection.
5884     push(@headerContentHeader, GenerateHeaderContentHeader($dictionary));
5885 
5886     $headerIncludes{&quot;${className}.h&quot;} = 1;
5887 
5888     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5889     push(@headerContent, GenerateDictionaryHeaderContent($dictionary, $className));
5890     push(@headerContent, GenerateEnumerationsHeaderContent($dictionary, $enumerations));
5891     push(@headerContent, GenerateDictionariesHeaderContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5892     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5893 
5894     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
</pre>
<hr />
<pre>
6216                 AddToIncludesForIDLType($argument-&gt;type, $includesRef, 1);
6217                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6218                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6219             }
6220             
6221             push(@$contentRef, &quot;${nativeReturnType} ${className}::${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)\n&quot;);
6222             push(@$contentRef, &quot;{\n&quot;);
6223 
6224             # FIXME: This is needed for NodeFilter, which works even for disconnected iframes. We should investigate
6225             # if that behavior is needed for other callbacks.
6226             if (!$operation-&gt;extendedAttributes-&gt;{SkipCallbackInvokeCheck}) {
6227                 push(@$contentRef, &quot;    if (!canInvokeCallback())\n&quot;);
6228                 push(@$contentRef, &quot;        return CallbackResultType::UnableToExecute;\n\n&quot;);
6229             }
6230 
6231             push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
6232             push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
6233             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6234             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6235 
<span class="line-modified">6236             push(@$contentRef, &quot;    auto&amp; state = *globalObject.globalExec();\n&quot;);</span>
6237 
6238             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6239             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6240 
6241             foreach my $argument (@{$operation-&gt;arguments}) {
6242                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6243             }
6244             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6245 
6246             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6247 
6248             my $callbackInvocation;
6249             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6250                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6251             } else {
6252                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
6253                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(vm, \&quot;${functionName}\&quot;), returnedException)&quot;;
6254             }
6255 
6256             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6257                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6258             } else {
6259                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6260             }
6261 
6262             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6263             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6264             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6265                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
<span class="line-modified">6266                 push(@$contentRef, &quot;        throwException(&amp;state, throwScope, returnedException);\n&quot;);</span>
6267             } else {
<span class="line-modified">6268                 push(@$contentRef, &quot;        reportException(&amp;state, returnedException);\n&quot;);</span>
6269             }
6270             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6271             push(@$contentRef, &quot;     }\n\n&quot;);
6272 
6273             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6274                 push(@$contentRef, &quot;    return { };\n&quot;);
6275             } else {
<span class="line-modified">6276                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;state&quot;, &quot;state&quot;);</span>
6277             
6278                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6279                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6280                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
6281                 push(@$contentRef, &quot;    return returnValue;\n&quot;);
6282             }
6283 
6284             push(@$contentRef, &quot;}\n\n&quot;);
6285         }
6286     }
6287 
6288     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6289         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6290         push(@$contentRef, &quot;{\n&quot;);
6291         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6292         push(@$contentRef, &quot;}\n\n&quot;);
6293     }
6294 
6295     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6296     push(@$contentRef, &quot;{\n&quot;);
</pre>
<hr />
<pre>
6300     push(@$contentRef, &quot;}\n\n&quot;);
6301 }
6302 
6303 sub GenerateImplementationFunctionCall
6304 {
6305     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6306 
6307     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6308     if ($callTracingCallback) {
6309         my @callTracerArguments = map { $_-&gt;name } @{$operation-&gt;arguments};
6310         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6311     }
6312 
6313     if (OperationHasForcedReturnValue($operation)) {
6314         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6315         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6316     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6317         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6318         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6319     } else {
<span class="line-modified">6320         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(state-&gt;lexicalGlobalObject())&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
6321         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6322     }
6323 }
6324 
6325 sub GenerateImplementationCustomFunctionCall
6326 {
6327     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6328 
6329     my @customFunctionArguments = ();
<span class="line-modified">6330     push(@customFunctionArguments, &quot;*state&quot;);</span>

6331     push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
6332 
6333     if ($operation-&gt;isStatic) {
6334         push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6335     } else {
6336         push(@$outputArray, $indent . &quot;return JSValue::encode(castedThis-&gt;&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6337     }
6338 }
6339 
6340 sub IsValueIterableInterface
6341 {
6342     my $interface = shift;
6343     return 0 unless $interface-&gt;iterable;
6344     return 0 if length $interface-&gt;iterable-&gt;keyType;
6345     # FIXME: See https://webkit.org/b/159140, we should die if the next check is false.
6346     return 0 unless GetIndexedGetterOperation($interface);
6347     return 1;
6348 }
6349 
6350 sub IsKeyValueIterableInterface
</pre>
<hr />
<pre>
6358 sub GenerateIterableDefinition
6359 {
6360     my $interface = shift;
6361 
6362     my $interfaceName = $interface-&gt;type-&gt;name;
6363     my $className = &quot;JS$interfaceName&quot;;
6364     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
6365 
6366     AddToImplIncludes(&quot;JSDOMIterator.h&quot;);
6367 
6368     return unless IsKeyValueIterableInterface($interface);
6369 
6370     my $iteratorName = &quot;${interfaceName}Iterator&quot;;
6371     my $iteratorPrototypeName = &quot;${interfaceName}IteratorPrototype&quot;;
6372 
6373     my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
6374     my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
6375     my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
6376     my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
6377 



6378     push(@implContent,  &lt;&lt;END);
6379 struct ${iteratorTraitsName} {
6380     static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
6381     using KeyType = ${iteratorTraitsKeyType};
6382     using ValueType = ${iteratorTraitsValueType};
6383 };
6384 
6385 using ${iteratorName} = JSDOMIterator&lt;${className}, ${iteratorTraitsName}&gt;;
6386 using ${iteratorPrototypeName} = JSDOMIteratorPrototype&lt;${className}, ${iteratorTraitsName}&gt;;
6387 
6388 template&lt;&gt;
6389 const JSC::ClassInfo ${iteratorName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorName}) };
6390 
6391 template&lt;&gt;
6392 const JSC::ClassInfo ${iteratorPrototypeName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorPrototypeName}) };
6393 
6394 END
6395 
6396     foreach my $operation (@{$interface-&gt;iterable-&gt;operations}) {
6397         my $propertyName = $operation-&gt;name;
6398         my $functionName = GetFunctionName($interface, $className, $operation);
6399 
6400         next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
6401 
6402         if ($propertyName eq &quot;forEach&quot;) {
6403             push(@implContent,  &lt;&lt;END);
<span class="line-modified">6404 static inline EncodedJSValue ${functionName}Caller(ExecState* state, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)</span>
6405 {
<span class="line-modified">6406     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*state, *thisObject, throwScope));</span>
6407 }
6408 
6409 END
6410         } else {
<span class="line-modified">6411             my $iterationKind = &quot;KeyValue&quot;;</span>
<span class="line-modified">6412             $iterationKind = &quot;Key&quot; if $propertyName eq &quot;keys&quot;;</span>
<span class="line-modified">6413             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;values&quot;;</span>
<span class="line-modified">6414             $iterationKind = &quot;Value&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;</span>
6415 
6416             push(@implContent,  &lt;&lt;END);
<span class="line-modified">6417 static inline EncodedJSValue ${functionName}Caller(ExecState*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)</span>
6418 {
6419     return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
6420 }
6421 
6422 END
6423         }
6424 
6425         push(@implContent,  &lt;&lt;END);
<span class="line-modified">6426 JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::ExecState* state)</span>
6427 {
<span class="line-modified">6428     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*state, &quot;${propertyName}&quot;);</span>
6429 }
6430 
6431 END
6432     }
6433 }
6434 
6435 # http://heycam.github.io/webidl/#dfn-flattened-union-member-types
6436 sub GetFlattenedMemberTypes
6437 {
6438     my ($idlUnionType) = @_;
6439 
6440     my @flattenedMemberTypes = ();
6441 
6442     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6443         if ($memberType-&gt;isUnion) {
6444             push(@flattenedMemberTypes, GetFlattenedMemberTypes($memberType));
6445         } else {
6446             push(@flattenedMemberTypes, $memberType);
6447         }
6448     }
</pre>
<hr />
<pre>
6599     return 0 if $codeGenerator-&gt;IsCallbackFunction($type);
6600     return 0 if !$codeGenerator-&gt;IsWrapperType($type) &amp;&amp; !$codeGenerator-&gt;IsBufferSourceType($type);
6601 
6602     return 1;
6603 }
6604 
6605 sub JSValueToNativeDOMConvertNeedsThisObject
6606 {
6607     my $type = shift;
6608 
6609     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
6610     return 0;
6611 }
6612 
6613 sub JSValueToNativeDOMConvertNeedsGlobalObject
6614 {
6615     my $type = shift;
6616 
6617     return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
6618     return 1 if $codeGenerator-&gt;IsCallbackFunction($type);

6619     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
6620     return 0;
6621 }
6622 
6623 sub IsValidContextForJSValueToNative
6624 {
6625     my $context = shift;
6626     return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6627 }
6628 
6629 sub JSValueToNative
6630 {
<span class="line-modified">6631     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;</span>
6632 
6633     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6634 
6635     my $type = $context-&gt;type;
6636 
6637     # FIXME: Remove these 3 variables when all JSValueToNative use references.
<span class="line-modified">6638     $statePointer = &quot;state&quot; unless $statePointer;</span>
<span class="line-modified">6639     $stateReference = &quot;*state&quot; unless $stateReference;</span>
6640     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6641 
6642     AddToImplIncludesForIDLType($type, $conditional);
6643     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6644 
6645     my $IDLType = GetIDLType($interface, $type);
6646 
6647     my @conversionArguments = ();
<span class="line-modified">6648     push(@conversionArguments, $stateReference);</span>
6649     push(@conversionArguments, $value);
6650     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6651     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6652     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6653 
6654     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6655 }
6656 
6657 sub ToNativeForFunctionWithoutTypeCheck
6658 {
<span class="line-modified">6659     my ($interface, $context, $value, $conditional, $statePointer, $stateReference, $thisObjectReference) = @_;</span>
6660 
6661     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6662 
6663     my $type = $context-&gt;type;
6664 
6665     # FIXME: Remove these 3 variables when all JSValueToNative use references.
<span class="line-modified">6666     $statePointer = &quot;state&quot; unless $statePointer;</span>
<span class="line-modified">6667     $stateReference = &quot;*state&quot; unless $stateReference;</span>
6668     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6669 
6670     AddToImplIncludesForIDLType($type, $conditional);
6671 
6672     # FIXME: Support more types.
6673 
6674     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6675 
6676     my $IDLType = GetIDLType($interface, $type);
6677 
6678     my @conversionArguments = ();
<span class="line-modified">6679     push(@conversionArguments, &quot;$stateReference&quot;);</span>
6680     push(@conversionArguments, &quot;$value&quot;);
6681 
6682     return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
6683 }
6684 
6685 sub NativeToJSValueDOMConvertNeedsState
6686 {
6687     my ($type) = @_;
6688 
6689     # FIXME: We need a more robust way to specify this requirement so as not
6690     # to require specializing each type. Perhaps just requiring all override
<span class="line-modified">6691     # types to take both state and the global object would work?</span>
6692     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6693         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6694         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6695         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6696         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6697 
6698         return 0;
6699     }
6700 
<span class="line-modified">6701     # FIXME: This should actually check if all the sub-objects of the union need the state.</span>
6702     return 1 if $type-&gt;isUnion;
6703     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6704     return 1 if $codeGenerator-&gt;IsRecordType($type);
6705     return 1 if $codeGenerator-&gt;IsStringType($type);
6706     return 1 if $codeGenerator-&gt;IsEnumType($type);
6707     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6708     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6709     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6710     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6711     return 1 if $type-&gt;name eq &quot;Date&quot;;
6712     return 1 if $type-&gt;name eq &quot;JSON&quot;;
6713     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6714     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6715     
6716     return 0;
6717 }
6718 
6719 sub NativeToJSValueDOMConvertNeedsGlobalObject
6720 {
6721     my ($type) = @_;
6722     
6723     # FIXME: We need a more robust way to specify this requirement so as not
6724     # to require specializing each type. Perhaps just requiring all override
<span class="line-modified">6725     # types to take both state and the global object would work?</span>
6726     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6727         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6728         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6729         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6730         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6731 
6732         return 0;
6733     }
6734 
6735     # FIXME: This should actually check if all the sub-objects of the union need the global object.
6736     return 1 if $type-&gt;isUnion;
6737     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6738     return 1 if $codeGenerator-&gt;IsRecordType($type);
6739     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6740     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6741     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6742     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6743     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6744     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6745 
6746     return 0;
6747 }
6748 
6749 sub NativeToJSValueUsingReferences
6750 {
6751     my ($context, $interface, $value, $globalObjectReference) = @_;
6752 
<span class="line-modified">6753     return NativeToJSValue($context, $interface, $value, &quot;state&quot;, $globalObjectReference);</span>
6754 }
6755 
6756 # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
6757 sub NativeToJSValueUsingPointers
6758 {
6759     my ($context, $interface, $value, $globalObjectReference) = @_;
6760 
<span class="line-modified">6761     return NativeToJSValue($context, $interface, $value, &quot;*state&quot;, $globalObjectReference);</span>
6762 }
6763 
6764 sub IsValidContextForNativeToJSValue
6765 {
6766     my $context = shift;
6767     
6768     return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6769 }
6770 
6771 sub NativeToJSValue
6772 {
<span class="line-modified">6773     my ($context, $interface, $value, $stateReference, $globalObjectReference) = @_;</span>
6774 
6775     assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
6776 
6777     my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
6778     my $type = $context-&gt;type;
6779     my $mayThrowException = ref($context) eq &quot;IDLAttribute&quot; || $context-&gt;extendedAttributes-&gt;{MayThrowException};
6780 
6781     # We could instead overload a function to work with optional as well as non-optional numbers, but this
6782     # is slightly better because it guarantees we will fail to compile if the IDL file doesn&#39;t match the C++.
6783     if ($context-&gt;extendedAttributes-&gt;{Reflect} and ($type-&gt;name eq &quot;unsigned long&quot; or $type-&gt;name eq &quot;unsigned short&quot;)) {
6784         $value =~ s/getUnsignedIntegralAttribute/getIntegralAttribute/g;
6785         $value = &quot;std::max(0, $value)&quot;;
6786     }
6787 
6788     AddToImplIncludesForIDLType($type, $conditional);
6789     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6790 
6791     if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
6792         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
<span class="line-modified">6793         $value = &quot;BindingSecurity::checkSecurityForNode($stateReference, $value)&quot;;</span>
6794     }
6795 
6796     my $IDLType = GetIDLType($interface, $type);
6797 
6798     my @conversionArguments = ();
<span class="line-modified">6799     push(@conversionArguments, $stateReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;</span>
6800     push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6801     push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
6802     push(@conversionArguments, $value);
6803 
6804     my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
6805 
6806     return &quot;${functionName}&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6807 }
6808 
6809 sub ceilingToPowerOf2
6810 {
6811     my ($size) = @_;
6812 
6813     my $powerOf2 = 1;
6814     while ($size &gt; $powerOf2) {
6815         $powerOf2 &lt;&lt;= 1;
6816     }
6817 
6818     return $powerOf2;
6819 }
</pre>
<hr />
<pre>
7096     push(@$outputArray, &quot;    {\n&quot;);
7097     push(@$outputArray, &quot;        ${className}Prototype* ptr = new (NotNull, JSC::allocateCell&lt;${className}Prototype&gt;(vm.heap)) ${className}Prototype(vm, globalObject, structure);\n&quot;);
7098     push(@$outputArray, &quot;        ptr-&gt;finishCreation(vm);\n&quot;);
7099     push(@$outputArray, &quot;        return ptr;\n&quot;);
7100     push(@$outputArray, &quot;    }\n\n&quot;);
7101 
7102     push(@$outputArray, &quot;    DECLARE_INFO;\n&quot;);
7103 
7104     push(@$outputArray, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
7105     push(@$outputArray, &quot;    {\n&quot;);
7106     push(@$outputArray, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
7107     push(@$outputArray, &quot;    }\n&quot;);
7108 
7109     push(@$outputArray, &quot;\nprivate:\n&quot;);
7110     push(@$outputArray, &quot;    ${prototypeClassName}(JSC::VM&amp; vm, JSC::JSGlobalObject*, JSC::Structure* structure)\n&quot;);
7111     push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
7112     push(@$outputArray, &quot;    {\n&quot;);
7113     push(@$outputArray, &quot;    }\n&quot;);
7114 
7115     if (PrototypeHasStaticPropertyTable($interface)) {
<span class="line-modified">7116         if (IsGlobalOrPrimaryGlobalInterface($interface)) {</span>
7117             $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
7118         } else {
7119             push(@$outputArray, &quot;\n&quot;);
7120             push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
7121         }
7122     }
7123 
7124     # FIXME: Should this override putByIndex as well?
7125     if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
7126         push(@$outputArray, &quot;\n&quot;);
<span class="line-modified">7127         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::ExecState*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
7128     }
7129 
7130     if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
7131         push(@$outputArray, &quot;\n&quot;);
<span class="line-modified">7132         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::ExecState*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
7133     }
7134 
7135     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
7136 
7137     # structure flags
7138     if (%structureFlags) {
7139         push(@$outputArray, &quot;public:\n&quot;);
<span class="line-modified">7140         push(@$outputArray, &quot;    static const unsigned StructureFlags = Base::StructureFlags&quot;);</span>
7141         foreach my $structureFlag (sort (keys %structureFlags)) {
7142             push(@$outputArray, &quot; | &quot; . $structureFlag);
7143         }
7144         push(@$outputArray, &quot;;\n&quot;);
7145     }
7146 
<span class="line-modified">7147     push(@$outputArray, &quot;};\n\n&quot;);</span>

7148 }
7149 
7150 sub GetConstructorTemplateClassName
7151 {
7152     my $interface = shift;
7153     return &quot;JSDOMConstructorNotConstructable&quot; if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7154     return &quot;JSDOMConstructorNotConstructable&quot; unless IsConstructable($interface);
7155     return &quot;JSDOMBuiltinConstructor&quot; if IsJSBuiltinConstructor($interface);
7156     return &quot;JSDOMConstructor&quot;;
7157 }
7158 
7159 sub GenerateConstructorDeclaration
7160 {
7161     my ($outputArray, $className, $interface) = @_;
7162 
7163     my $interfaceName = $interface-&gt;type-&gt;name;
7164     my $constructorClassName = &quot;${className}Constructor&quot;;
7165     my $templateClassName = GetConstructorTemplateClassName($interface);
7166 
7167     AddToImplIncludes(&quot;${templateClassName}.h&quot;);
7168     AddToImplIncludes(&quot;JSDOMNamedConstructor.h&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7169 
7170     push(@$outputArray, &quot;using $constructorClassName = $templateClassName&lt;$className&gt;;\n&quot;);
7171     push(@$outputArray, &quot;using JS${interfaceName}NamedConstructor = JSDOMNamedConstructor&lt;$className&gt;;\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7172     push(@$outputArray, &quot;\n&quot;);
7173 }
7174 
7175 sub GenerateConstructorDefinitions
7176 {
7177     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7178 
7179     if (IsConstructable($interface)) {
7180         my @constructors = @{$interface-&gt;constructors};
7181         if (@constructors &gt; 1) {
7182             foreach my $constructor (@constructors) {
7183                 GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
7184             }
7185 
7186             my $overloadFunctionPrefix = &quot;construct${className}&quot;;
7187 
<span class="line-modified">7188             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(ExecState* state)\n&quot;);</span>
7189             push(@implContent, &quot;{\n&quot;);
<span class="line-modified">7190             push(@implContent, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
7191             push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7192             push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7193 
<span class="line-modified">7194             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;state&quot;);</span>
7195 
7196             push(@implContent, &quot;}\n\n&quot;);
7197         } elsif (@constructors == 1) {
7198             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
7199         } else {
7200             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7201         }
7202     }
7203 
7204     GenerateConstructorHelperMethods($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7205 }
7206 
7207 sub GenerateConstructorDefinition
7208 {
7209     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $operation) = @_;
7210 
7211     return if IsJSBuiltinConstructor($interface);
7212 
7213     my $interfaceName = $interface-&gt;type-&gt;name;
7214     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7215 
7216     if (IsConstructable($interface)) {
7217         if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
<span class="line-modified">7218             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::ExecState* exec)\n&quot;);</span>
7219             push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">7220             push(@$outputArray, &quot;    ASSERT(exec);\n&quot;);</span>
<span class="line-modified">7221             push(@$outputArray, &quot;    return construct${className}(*exec);\n&quot;);</span>
7222             push(@$outputArray, &quot;}\n\n&quot;);
7223          } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
7224             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
7225             if ($isOverloaded) {
<span class="line-modified">7226                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(ExecState* state)\n&quot;);</span>
7227             } else {
<span class="line-modified">7228                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(ExecState* state)\n&quot;);</span>
7229             }
7230 
7231             push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">7232             push(@$outputArray, &quot;    VM&amp; vm = state-&gt;vm();\n&quot;);</span>
7233             push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7234             push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
<span class="line-modified">7235             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(state-&gt;jsCallee());\n&quot;);</span>
7236             push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
7237 








7238             GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
7239 
7240             my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
7241             my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
7242 
7243             push(@$outputArray, &quot;    auto object = ${functionString};\n&quot;);
7244             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($interface-&gt;extendedAttributes-&gt;{ConstructorCallWith}, &quot;ExecState&quot;);
7245 
7246             my $IDLType = GetIDLType($interface, $interface-&gt;type);
7247 
7248             AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
7249 
7250             my @constructionConversionArguments = ();
<span class="line-modified">7251             push(@constructionConversionArguments, &quot;*state&quot;);</span>
7252             push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
7253             push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
7254             push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
7255 
7256             push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
7257             push(@$outputArray, &quot;}\n\n&quot;);
7258         }
7259     }
7260 }
7261 
7262 sub ConstructorHasProperties
7263 {
7264     my $interface = shift;
7265 
7266     foreach my $constant (@{$interface-&gt;constants}) {
7267         return 1;
7268     }
7269 
7270     foreach my $attribute (@{$interface-&gt;attributes}) {
7271         next unless ($attribute-&gt;isStatic);
7272         return 1;
7273     }
7274 
7275     foreach my $operation (@{$interface-&gt;operations}) {
7276         next unless ($operation-&gt;isStatic);
7277         return 1;
7278     }
7279 
7280     return 0;
7281 }
7282 
7283 sub GetRuntimeEnabledStaticProperties
7284 {
7285     my ($interface) = @_;
7286 
7287     my @runtimeEnabledProperties = ();
7288 
7289     my @attributes = @{$interface-&gt;attributes};
7290     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;

7291 
7292     foreach my $attribute (@attributes) {
7293         next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
7294         next if not $attribute-&gt;isStatic;
7295 
7296         if (NeedsRuntimeCheck($interface, $attribute)) {
7297             push(@runtimeEnabledProperties, $attribute);
7298         }
7299     }
7300 
7301     my @operations = @{$interface-&gt;operations};
7302     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
7303     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;

7304     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
7305     foreach my $operation (@operations) {
7306         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
7307         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
7308         next if OperationShouldBeOnInstance($interface, $operation) != 0;
7309         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
7310         next if not $operation-&gt;isStatic;
7311 
7312         if (NeedsRuntimeCheck($interface, $operation)) {
7313             push(@runtimeEnabledProperties, $operation);
7314         }
7315     }
7316 
7317     return @runtimeEnabledProperties;
7318 }
7319 
7320 sub GenerateConstructorHelperMethods
7321 {
7322     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7323 
</pre>
<hr />
<pre>
7351         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7352     }
7353     push(@$outputArray, &quot;}\n\n&quot;);
7354 
7355 
7356     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7357     push(@$outputArray, &quot;{\n&quot;);
7358 
7359     # There must exist an interface prototype object for every non-callback interface defined, regardless
7360     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7361     # https://heycam.github.io/webidl/#interface-prototype-object
7362     if (ShouldUseGlobalObjectPrototype($interface)) {
7363         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7364     } elsif ($interface-&gt;isCallback) {
7365         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7366     } else {
7367         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7368     }
7369 
7370     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
<span class="line-modified">7371     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;) if defined $leastConstructorLength;</span>









7372 
7373     my $classForThis = &quot;${className}::info()&quot;;
7374     if ($interface-&gt;isCallback) {
7375         $classForThis = &quot;nullptr&quot;;
7376     }
7377     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7378 
7379     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7380 
7381     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7382         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7383         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
<span class="line-modified">7384         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;true&quot;);</span>
7385         my $name = $operationOrAttribute-&gt;name;
7386         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7387         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
7388         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
<span class="line-modified">7389         push(@$outputArray, &quot;        JSObject::deleteProperty(this, globalObject.globalExec(), propertyName);\n&quot;);</span>
7390         push(@$outputArray, &quot;    }\n&quot;);
7391         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7392     }
7393 
7394     push(@$outputArray, &quot;}\n\n&quot;);
7395 
7396     if (IsJSBuiltinConstructor($interface)) {
7397         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7398         push(@$outputArray, &quot;{\n&quot;);
7399         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7400         push(@$outputArray, &quot;}\n&quot;);
7401         push(@$outputArray, &quot;\n&quot;);
7402     }
7403     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7404 }
7405 
7406 sub HasCustomConstructor
7407 {
7408     my $interface = shift;
7409     return $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
</pre>
</td>
<td>
<hr />
<pre>
   1 #
   2 # Copyright (C) 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
   3 # Copyright (C) 2006 Anders Carlsson &lt;andersca@mac.com&gt;
   4 # Copyright (C) 2006, 2007 Samuel Weinig &lt;sam@webkit.org&gt;
   5 # Copyright (C) 2006 Alexey Proskuryakov &lt;ap@webkit.org&gt;
<span class="line-modified">   6 # Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   7 # Copyright (C) 2009 Cameron McCormack &lt;cam@mcc.id.au&gt;
   8 # Copyright (C) Research In Motion Limited 2010. All rights reserved.
   9 # Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  10 # Copyright (C) 2011 Patrick Gansterer &lt;paroga@webkit.org&gt;
  11 # Copyright (C) 2012 Ericsson AB. All rights reserved.
  12 # Copyright (C) 2007, 2008, 2009, 2012 Google Inc.
  13 # Copyright (C) 2013 Samsung Electronics. All rights reserved.
  14 # Copyright (C) 2015, 2016 Canon Inc. All rights reserved.
  15 #
  16 # This library is free software; you can redistribute it and/or
  17 # modify it under the terms of the GNU Library General Public
  18 # License as published by the Free Software Foundation; either
  19 # version 2 of the License, or (at your option) any later version.
  20 #
  21 # This library is distributed in the hope that it will be useful,
  22 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  23 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24 # Library General Public License for more details.
  25 #
  26 # You should have received a copy of the GNU Library General Public License
</pre>
<hr />
<pre>
 608         push(@$outputArray, &quot;        if (result.hasException())\n&quot;);
 609         push(@$outputArray, &quot;            return ${resultType} { result.releaseException() };\n&quot;);
 610         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result.returnValue()))\n&quot;);
 611         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result.releaseReturnValue()) };\n&quot;);
 612         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 613     } else {
 614         push(@$outputArray, &quot;        if (!${IDLType}::isNullValue(result))\n&quot;);
 615         push(@$outputArray, &quot;            return ${resultType} { ${IDLType}::extractValueFromNullable(result) };\n&quot;);
 616         push(@$outputArray, &quot;        return WTF::nullopt;\n&quot;);
 617     }
 618     push(@$outputArray, &quot;    };\n&quot;);
 619 }
 620 
 621 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 622 sub GenerateGetOwnPropertySlot
 623 {
 624     my ($outputArray, $interface, $className) = @_;
 625     
 626     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 627     
<span class="line-modified"> 628     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)\n&quot;);</span>
 629     push(@$outputArray, &quot;{\n&quot;);
 630     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 631     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 632     
 633     my $namedGetterOperation = GetNamedGetterOperation($interface);
 634     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 635     
 636     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="line-modified"> 637         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
 638     }
 639     
 640     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 641     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 642     
 643     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 644     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 645     
 646     # 1. If O supports indexed properties and P is an array index property name, then:
 647     if ($indexedGetterOperation) {
 648         # 1.1. Let index be the result of calling ToUint32(P).
 649         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 650         
 651         # 1.2. If index is a supported property index, then:
 652         # FIXME: This should support non-contiguous indices.
 653         push(@$outputArray, &quot;        if (index.value() &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 654         
 655         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 656         
 657         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index.value()&quot;);
 658         
 659         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 660         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 661         
 662         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 663         push(@$outputArray, &quot;            return true;\n&quot;);
 664         
 665         push(@$outputArray, &quot;        }\n&quot;);
 666         
 667         # 1.3. Set ignoreNamedProps to true.
 668         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 669         #       rather than going through the paces of having an actual ignoreNamedProps update.
 670         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="line-modified"> 671             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);</span>
 672         }
 673         push(@$outputArray, &quot;    }\n&quot;);
 674     }
 675     
 676     # 2. If O supports named properties, the result of running the named property visibility
 677     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 678     if ($namedGetterOperation) {
 679         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 680         #       to true, due to the early return in step 1.3
 681         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 682                 
 683         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 684         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 685         
 686         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 687         
 688         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 689         
 690         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="line-modified"> 691         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
 692         
 693         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 694         
 695         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 696         
 697         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 698         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 699         
 700         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 701         push(@$outputArray, &quot;        return true;\n&quot;);
 702         push(@$outputArray, &quot;    }\n&quot;);
 703     }
 704 
 705     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 706         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="line-modified"> 707         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);</span>
 708         push(@$outputArray, &quot;        return true;\n&quot;);
 709     }
 710 
 711     # 3. Return OrdinaryGetOwnProperty(O, P).
<span class="line-modified"> 712     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlot(object, lexicalGlobalObject, propertyName, slot);\n&quot;);</span>
 713     
 714     push(@$outputArray, &quot;}\n\n&quot;);
 715 }
 716 
 717 # https://heycam.github.io/webidl/#legacy-platform-object-getownproperty
 718 sub GenerateGetOwnPropertySlotByIndex
 719 {
 720     my ($outputArray, $interface, $className) = @_;
 721     
 722     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertySlot};
 723 
 724     # Sink the int-to-string conversion that happens when we create a PropertyName
 725     # to the point where we actually need it.
 726     my $didGeneratePropertyName = 0;
 727     my $propertyNameGeneration = sub {
 728         return if $didGeneratePropertyName;
 729         
 730         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
 731         $didGeneratePropertyName = 1;
 732     };
 733     
 734     my $namedGetterOperation = GetNamedGetterOperation($interface);
 735     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 736     
<span class="line-modified"> 737     push(@$outputArray, &quot;bool ${className}::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* lexicalGlobalObject, unsigned index, PropertySlot&amp; slot)\n&quot;);</span>
 738     push(@$outputArray, &quot;{\n&quot;);
 739     if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin} || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
<span class="line-modified"> 740         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
 741     }
 742     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 743     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
 744     
 745     if (($namedGetterOperation &amp;&amp; $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException}) || ($indexedGetterOperation &amp;&amp; $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException})) {
 746         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
 747     }
 748     
 749     # NOTE: The alogithm for [[GetOwnProperty]] contains only the following step:
 750     # 1. Return LegacyPlatformObjectGetOwnProperty(O, P, false).
 751     
 752     # Therefore, the following steps are from the LegacyPlatformObjectGetOwnProperty algorithm
 753     # https://heycam.github.io/webidl/#LegacyPlatformObjectGetOwnProperty
 754     
 755     # 1. If O supports indexed properties and P is an array index property name, then:
 756     if ($indexedGetterOperation) {
 757         # 1.1. Let index be the result of calling ToUint32(P).
 758         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
 759         
 760         # 1.2. If index is a supported property index, then:
 761         # FIXME: This should support non-contiguous indices.
 762         push(@$outputArray, &quot;        if (index &lt; thisObject-&gt;wrapped().length()) {\n&quot;);
 763         
 764         # NOTE: GenerateIndexedGetter implements steps 1.2.1 - 1.2.8.
 765         
 766         my ($nativeToJSConversion, $attributeString) = GenerateIndexedGetter($interface, $indexedGetterOperation, &quot;index&quot;);
 767         
 768         push(@$outputArray, &quot;            auto value = ${nativeToJSConversion};\n&quot;);
 769         push(@$outputArray, &quot;            RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $indexedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 770         
 771         push(@$outputArray, &quot;            slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 772         push(@$outputArray, &quot;            return true;\n&quot;);
 773         
 774         push(@$outputArray, &quot;        }\n&quot;);
 775         
 776         # 1.3. Set ignoreNamedProps to true.
 777         # NOTE: Setting ignoreNamedProps has the effect of skipping step 2, so we can early return here
 778         #       rather than going through the paces of having an actual ignoreNamedProps update.
 779         if ($namedGetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="line-modified"> 780             push(@$outputArray, &quot;        return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);</span>
 781         }
 782         push(@$outputArray, &quot;    }\n&quot;);
 783     }
 784     
 785     # 2. If O supports named properties, the result of running the named property visibility
 786     #    algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
 787     if ($namedGetterOperation) {
 788         # NOTE: ignoreNamedProps is guarenteed to be false here, as it is initially false, and never set
 789         #       to true, due to the early return in step 1.3
 790         AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;);
 791                 
 792         &amp;$propertyNameGeneration();
 793         
 794         my $namedGetterFunctionName = $namedGetterOperation-&gt;extendedAttributes-&gt;{ImplementedAs} || $namedGetterOperation-&gt;name || &quot;namedItem&quot;;
 795         my $IDLType = GetIDLTypeExcludingNullability($interface, $namedGetterOperation-&gt;type);
 796         
 797         push(@$outputArray, &quot;    using GetterIDLType = ${IDLType};\n&quot;);
 798         
 799         GenerateNamedGetterLambda($outputArray, $interface, $namedGetterOperation, $namedGetterFunctionName, &quot;GetterIDLType&quot;);
 800         
 801         my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="line-modified"> 802         push(@$outputArray, &quot;    if (auto namedProperty = accessVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, *thisObject, propertyName, getterFunctor)) {\n&quot;);</span>
 803         
 804         # NOTE: GenerateNamedGetter implements steps 2.1 - 2.10.
 805         
 806         my ($nativeToJSConversion, $attributeString) = GenerateNamedGetter($interface, $namedGetterOperation, &quot;WTFMove(namedProperty.value())&quot;);
 807 
 808         push(@$outputArray, &quot;        auto value = ${nativeToJSConversion};\n&quot;);
 809         push(@$outputArray, &quot;        RETURN_IF_EXCEPTION(throwScope, false);\n&quot;) if $namedGetterOperation-&gt;extendedAttributes-&gt;{MayThrowException};
 810         
 811         push(@$outputArray, &quot;        slot.setValue(thisObject, ${attributeString}, value);\n&quot;);
 812         push(@$outputArray, &quot;        return true;\n&quot;);
 813         push(@$outputArray, &quot;    }\n&quot;);
 814     }
 815     
 816     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 817         &amp;$propertyNameGeneration();
 818 
 819         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
<span class="line-modified"> 820         push(@$outputArray, &quot;    if (pluginElementCustomGetOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot))\n&quot;);</span>
 821         push(@$outputArray, &quot;        return true;\n&quot;);
 822     }
 823 
 824     # 3. Return OrdinaryGetOwnProperty(O, P).
<span class="line-modified"> 825     push(@$outputArray, &quot;    return JSObject::getOwnPropertySlotByIndex(object, lexicalGlobalObject, index, slot);\n&quot;);</span>
 826     
 827     push(@$outputArray, &quot;}\n\n&quot;);
 828 }
 829 
 830 # https://heycam.github.io/webidl/#legacy-platform-object-property-enumeration
 831 sub GenerateGetOwnPropertyNames
 832 {
 833     my ($outputArray, $interface, $className) = @_;
 834     
 835     return if $interface-&gt;extendedAttributes-&gt;{CustomGetOwnPropertyNames};
 836     
 837     my $namedGetterOperation = GetNamedGetterOperation($interface);
 838     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
 839     
<span class="line-modified"> 840     push(@$outputArray, &quot;void ${className}::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)\n&quot;);</span>
 841     push(@$outputArray, &quot;{\n&quot;);
 842     if ($indexedGetterOperation || $namedGetterOperation) {
<span class="line-modified"> 843         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
 844     }
 845     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
 846     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(object, info());\n&quot;);
 847     
 848     # 1. If the object supports indexed properties, then the object’s supported
 849     #    property indices are enumerated first, in numerical order.
 850     # FIXME: This should support non-contiguous indices.
 851     if ($indexedGetterOperation) {
 852         push(@$outputArray, &quot;    for (unsigned i = 0, count = thisObject-&gt;wrapped().length(); i &lt; count; ++i)\n&quot;);
 853         push(@$outputArray, &quot;        propertyNames.add(Identifier::from(vm, i));\n&quot;);
 854     }
 855 
 856     # 2. If the object supports named properties and doesn’t implement an interface
 857     #    with the [LegacyUnenumerableNamedProperties] extended attribute, then the
 858     #    object’s supported property names that are visible according to the named
 859     #    property visibility algorithm are enumerated next, in the order given in
 860     #    the definition of the set of supported property names.
 861     if ($namedGetterOperation) {
 862         if (!$interface-&gt;extendedAttributes-&gt;{LegacyUnenumerableNamedProperties}) {
 863             push(@$outputArray, &quot;    for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 864             push(@$outputArray, &quot;        propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 865         } else {
 866             push(@$outputArray, &quot;    if (mode.includeDontEnumProperties()) {\n&quot;);
 867             push(@$outputArray, &quot;        for (auto&amp; propertyName : thisObject-&gt;wrapped().supportedPropertyNames())\n&quot;);
 868             push(@$outputArray, &quot;            propertyNames.add(Identifier::fromString(vm, propertyName));\n&quot;);
 869             push(@$outputArray, &quot;    }\n&quot;);
 870         }
 871     }
 872     
 873     # 3. Finally, any enumerable own properties or properties from the object’s
 874     #    prototype chain are then enumerated, in no defined order.
<span class="line-modified"> 875     push(@$outputArray, &quot;    JSObject::getOwnPropertyNames(object, lexicalGlobalObject, propertyNames, mode);\n&quot;);</span>
 876     push(@$outputArray, &quot;}\n\n&quot;);
 877 }
 878 
 879 # https://heycam.github.io/webidl/#invoke-indexed-setter
 880 sub GenerateInvokeIndexedPropertySetter
 881 {
 882     my ($outputArray, $indent, $interface, $indexedSetterOperation, $indexExpression, $value) = @_;
 883     
 884     # The second argument of the indexed setter operation is the argument being converted.
 885     my $argument = @{$indexedSetterOperation-&gt;arguments}[1];
<span class="line-modified"> 886     my $nativeValue = JSValueToNative($interface, $argument, $value, $indexedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
 887     
<span class="line-modified"> 888     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
 889     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 890     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 891     
 892     my $indexedSetterFunctionName = $indexedSetterOperation-&gt;name || &quot;setItem&quot;;
 893     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 894     my $functionString = &quot;thisObject-&gt;wrapped().${indexedSetterFunctionName}(${indexExpression}, ${nativeValuePassExpression})&quot;;
<span class="line-modified"> 895     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($indexedSetterOperation);</span>
 896     
 897     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 898 }
 899 
 900 # https://heycam.github.io/webidl/#invoke-named-setter
 901 sub GenerateInvokeNamedPropertySetter
 902 {
 903     my ($outputArray, $indent, $interface, $namedSetterOperation, $value) = @_;
 904     
 905     my $argument = @{$namedSetterOperation-&gt;arguments}[1];
<span class="line-modified"> 906     my $nativeValue = JSValueToNative($interface, $argument, $value, $namedSetterOperation-&gt;extendedAttributes-&gt;{Conditional}, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;thisObject&quot;, &quot;&quot;, &quot;&quot;);</span>
 907     
<span class="line-modified"> 908     push(@$outputArray, $indent . &quot;auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
 909     push(@$outputArray, $indent . &quot;auto nativeValue = ${nativeValue};\n&quot;);
 910     push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, true);\n&quot;);
 911 
 912     push(@$outputArray, $indent . &quot;bool isPropertySupported = true;\n&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 913 
 914     my $namedSetterFunctionName = $namedSetterOperation-&gt;name || &quot;setNamedItem&quot;;
 915     my $nativeValuePassExpression = PassArgumentExpression(&quot;nativeValue&quot;, $argument);
 916 
 917     my @arguments = ();
 918     push(@arguments, &quot;propertyNameToString(propertyName)&quot;);
 919     push(@arguments, $nativeValuePassExpression);
 920     push(@arguments, &quot;isPropertySupported&quot;) if $namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
 921 
 922     my $functionString = &quot;thisObject-&gt;wrapped().${namedSetterFunctionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified"> 923     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, ${functionString})&quot; if NeedsExplicitPropagateExceptionCall($namedSetterOperation);</span>
 924 
 925     push(@$outputArray, $indent . $functionString . &quot;;\n&quot;);
 926 }
 927 
 928 sub GeneratePut
 929 {
 930     my ($outputArray, $interface, $className) = @_;
 931     
 932     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
 933     
 934     my $namedSetterOperation = GetNamedSetterOperation($interface);
 935     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
 936     
<span class="line-modified"> 937     push(@$outputArray, &quot;bool ${className}::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; putPropertySlot)\n&quot;);</span>
 938     push(@$outputArray, &quot;{\n&quot;);
 939     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
 940     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
 941 
 942     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
 943         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
 944     if ($namedSetterOperation) {
<span class="line-modified"> 945         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
 946     }
 947     if ($indexedSetterOperation) {
<span class="line-modified"> 948         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
 949     }
 950     
 951     if ($indexedSetterOperation) {
 952         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
 953         
 954         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;value&quot;);
 955         
 956         push(@$outputArray, &quot;        return true;\n&quot;);
 957         push(@$outputArray, &quot;    }\n\n&quot;);
 958     }
 959     
 960     if ($namedSetterOperation) {
 961         # FIMXE: We need a more comprehensive story for Symbols.
 962         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
 963         
 964         my $additionalIndent = &quot;&quot;;
 965         
 966         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
 967         if (!$overrideBuiltins) {
 968             push(@$outputArray, &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="line-modified"> 969             push(@$outputArray, &quot;        JSValue prototype = thisObject-&gt;getPrototypeDirect(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
<span class="line-modified"> 970             push(@$outputArray, &quot;        if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);</span>
 971             $additionalIndent .= &quot;    &quot;;
 972         }
 973 
 974         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
 975         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
 976             push(@$outputArray, $additionalIndent . &quot;        if (!isPropertySupported)\n&quot;);
<span class="line-modified"> 977             push(@$outputArray, $additionalIndent . &quot;            return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);</span>
 978         }
 979         push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
 980 
 981         if (!$overrideBuiltins) {
 982             push(@$outputArray, &quot;        }\n&quot;);
 983         }
 984         
 985         push(@$outputArray, &quot;    }\n\n&quot;);
 986     }
 987     
 988     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
 989     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
 990         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
 991 
 992         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
<span class="line-modified"> 993         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
 994         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
 995     }
 996 
<span class="line-modified"> 997     push(@$outputArray, &quot;    return JSObject::put(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot);\n&quot;);</span>
 998     push(@$outputArray, &quot;}\n\n&quot;);
 999 }
1000 
1001 sub GeneratePutByIndex
1002 {
1003     my ($outputArray, $interface, $className) = @_;
1004     
1005     return if $interface-&gt;extendedAttributes-&gt;{CustomPut};
1006 
1007     my $namedSetterOperation = GetNamedSetterOperation($interface);
1008     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1009     
1010     my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1011     my $ellidesCallsToBase = ($namedSetterOperation &amp;&amp; $overrideBuiltins) &amp;&amp; !$interface-&gt;extendedAttributes-&gt;{Plugin} &amp;&amp; !$namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties};
1012     
<span class="line-modified">1013     push(@$outputArray, &quot;bool ${className}::putByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index, JSValue value, bool&quot; . (!$ellidesCallsToBase ? &quot; shouldThrow&quot; : &quot;&quot;) . &quot;)\n&quot;);</span>
1014     push(@$outputArray, &quot;{\n&quot;);
1015     if ($namedSetterOperation || $interface-&gt;extendedAttributes-&gt;{Plugin}) {
<span class="line-modified">1016         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
1017     }
1018     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
1019     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1020 
1021     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1022         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1023     if ($namedSetterOperation) {
<span class="line-modified">1024         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
1025     }
1026     if ($indexedSetterOperation) {
<span class="line-modified">1027         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
1028     }
1029     
1030     if ($indexedSetterOperation) {
1031         push(@$outputArray, &quot;    if (LIKELY(index &lt;= MAX_ARRAY_INDEX)) {\n&quot;);
1032         
1033         GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index&quot;, &quot;value&quot;);
1034         
1035         push(@$outputArray, &quot;        return true;\n&quot;);
1036         push(@$outputArray, &quot;    }\n\n&quot;);
1037     }
1038     
1039     if ($namedSetterOperation) {
1040         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1041                 
1042         my $additionalIndent = &quot;&quot;;
1043         if (!$overrideBuiltins) {
1044             push(@$outputArray, &quot;    PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
1045             push(@$outputArray, &quot;    JSValue prototype = thisObject-&gt;getPrototypeDirect(vm);\n&quot;);
<span class="line-modified">1046             push(@$outputArray, &quot;    if (!(prototype.isObject() &amp;&amp; asObject(prototype)-&gt;getPropertySlot(lexicalGlobalObject, propertyName, slot))) {\n&quot;);</span>
1047             $additionalIndent .= &quot;    &quot;;
1048         }
1049         
1050         GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;    &quot;, $interface, $namedSetterOperation, &quot;value&quot;);
1051         if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1052             push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
<span class="line-modified">1053             push(@$outputArray, $additionalIndent . &quot;        return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);</span>
1054         }
1055         push(@$outputArray, $additionalIndent . &quot;    return true;\n&quot;);
1056         
1057         if (!$overrideBuiltins) {
1058             push(@$outputArray, &quot;    }\n\n&quot;);
1059         }
1060     }
1061 
1062     assert(&quot;Using both a named property setter and [Plugin] together is not supported.&quot;) if $namedSetterOperation &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Plugin};
1063     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
1064         AddToImplIncludes(&quot;JSPluginElementFunctions.h&quot;);
1065         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1066         push(@$outputArray, &quot;    PutPropertySlot putPropertySlot(thisObject, shouldThrow);\n&quot;);
1067         push(@$outputArray, &quot;    bool putResult = false;\n&quot;);
<span class="line-modified">1068         push(@$outputArray, &quot;    if (pluginElementCustomPut(thisObject, lexicalGlobalObject, propertyName, value, putPropertySlot, putResult))\n&quot;);</span>
1069         push(@$outputArray, &quot;        return putResult;\n\n&quot;);
1070     }
1071 
1072     if (!$ellidesCallsToBase) {
<span class="line-modified">1073         push(@$outputArray, &quot;    return JSObject::putByIndex(cell, lexicalGlobalObject, index, value, shouldThrow);\n&quot;);</span>
1074     }
1075     
1076     push(@$outputArray, &quot;}\n\n&quot;);
1077 }
1078 
1079 sub GenerateIsUnforgeablePropertyName
1080 {
1081     my ($outputArray, $interface) = @_;
1082     
1083     my @unforgeablePropertyNames = ();
1084     foreach my $property (@{$interface-&gt;attributes}, @{$interface-&gt;operations}) {
1085         next if $property-&gt;isStatic;
1086         
1087         if (IsUnforgeable($interface, $property)) {
1088             push(@unforgeablePropertyNames, $property-&gt;name);
1089         }
1090     }
1091     
1092     return 0 if (scalar(@unforgeablePropertyNames) == 0);
1093     
</pre>
<hr />
<pre>
1096     push(@$outputArray, &quot;static bool isUnforgeablePropertyName(PropertyName propertyName)\n&quot;);
1097     push(@$outputArray, &quot;{\n&quot;);
1098     push(@$outputArray, &quot;    return ${condition};\n&quot;);
1099     push(@$outputArray, &quot;}\n\n&quot;);
1100     
1101     return 1;
1102 }
1103 
1104 # https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
1105 sub GenerateDefineOwnProperty
1106 {
1107     my ($outputArray, $interface, $className) = @_;
1108     
1109     return if $interface-&gt;extendedAttributes-&gt;{CustomDefineOwnProperty};
1110     
1111     my $namedSetterOperation = GetNamedSetterOperation($interface);
1112     my $indexedSetterOperation = GetIndexedSetterOperation($interface);
1113     
1114     return if !$namedSetterOperation &amp;&amp; !$indexedSetterOperation;
1115     
<span class="line-modified">1116     push(@$outputArray, &quot;bool ${className}::defineOwnProperty(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, const PropertyDescriptor&amp; propertyDescriptor, bool shouldThrow)\n&quot;);</span>
1117     push(@$outputArray, &quot;{\n&quot;);
1118     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(object);\n&quot;);
1119     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
1120 
1121     assert(&quot;CEReactions is not supported on having both named setters and indexed setters&quot;) if $namedSetterOperation &amp;&amp; $namedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions}
1122         &amp;&amp; $indexedSetterOperation &amp;&amp; $indexedSetterOperation-&gt;extendedAttributes-&gt;{CEReactions};
1123     if ($namedSetterOperation) {
<span class="line-modified">1124         GenerateCustomElementReactionsStackIfNeeded($outputArray, $namedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
1125     }
1126     if ($indexedSetterOperation) {
<span class="line-modified">1127         GenerateCustomElementReactionsStackIfNeeded($outputArray, $indexedSetterOperation, &quot;*lexicalGlobalObject&quot;);</span>
1128     }
1129     
1130     # 1. If O supports indexed properties and P is an array index property name, then:
1131     if (GetIndexedGetterOperation($interface)) {
1132         # NOTE: The numbers are out of order because there is no reason doing steps 1, 3, and 4 if there
1133         # is no indexed property setter.
1134 
1135         if (!$indexedSetterOperation) {
1136             # 2. If O does not implement an interface with an indexed property setter, then return false.
1137             push(@$outputArray, &quot;    if (parseIndex(propertyName))\n&quot;);
1138             push(@$outputArray, &quot;        return false;\n\n&quot;);
1139         } else {
1140             push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName)) {\n&quot;);
1141 
1142             # 1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1143             push(@$outputArray, &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1144             push(@$outputArray, &quot;            return false;\n&quot;);
1145             
1146             # 3. Invoke the indexed property setter with P and Desc.[[Value]].
1147             GenerateInvokeIndexedPropertySetter($outputArray, &quot;        &quot;, $interface, $indexedSetterOperation, &quot;index.value()&quot;, &quot;propertyDescriptor.value()&quot;);
1148             
1149             # 4. Return true.
1150             push(@$outputArray, &quot;        return true;\n&quot;);
1151             push(@$outputArray, &quot;    }\n\n&quot;);
1152         }
1153     }
1154     
<span class="line-modified">1155     # 2. If O supports named properties, O does not implement an interface with the [Global]</span>
1156     #    extended attribute and P is not an unforgeable property name of O, then:
<span class="line-modified">1157     if (GetNamedGetterOperation($interface) &amp;&amp; !IsGlobalInterface($interface)) {</span>
1158         # FIMXE: We need a more comprehensive story for Symbols.
1159         push(@$outputArray, &quot;    if (!propertyName.isSymbol()) {\n&quot;);
1160         
1161         my $additionalIndent = &quot;&quot;;
1162         
1163         my $hasUnforgableProperties = GenerateIsUnforgeablePropertyName($outputArray, $interface);
1164         if ($hasUnforgableProperties) {
1165             push(@$outputArray, &quot;        if (!isUnforgeablePropertyName(propertyName)) {\n&quot;);
1166             $additionalIndent .= &quot;    &quot;;
1167         }
1168         
1169         # 1. Let creating be true if P is not a supported property name, and false otherwise.
1170         # NOTE: This step is strength reduced into the only use of &#39;creating&#39; in step 2.2.1
1171         
1172         # 2. If O implements an interface with the [OverrideBuiltins] extended attribute or O
1173         #    does not have an own property named P, then:
1174         my $overrideBuiltins = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;);
1175         if (!$overrideBuiltins) {
1176             # FIXME: Is JSObject::getOwnPropertySlot the right function to call? Is there a function that will
1177             #        only look at the actual properties, and not call into our implementation of the
1178             #        [[GetOwnProperty]] hook?
1179             push(@$outputArray, $additionalIndent. &quot;        PropertySlot slot { thisObject, PropertySlot::InternalMethodType::VMInquiry };\n&quot;);
<span class="line-modified">1180             push(@$outputArray, $additionalIndent. &quot;        if (!JSObject::getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot)) {\n&quot;);</span>
1181             $additionalIndent .= &quot;    &quot;;
1182         }
1183         if (!$namedSetterOperation) {
1184             # 2.1. If creating is false and O does not implement an interface with a named property setter, then return false.
1185             push(@$outputArray, $additionalIndent . &quot;        if (thisObject-&gt;wrapped().isSupportedPropertyName(propertyNameToString(propertyName)))\n&quot;);
1186             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1187         } else {
1188             # 2.2. If O implements an interface with a named property setter, then:
1189             
1190             # 2.2.1. If the result of calling IsDataDescriptor(Desc) is false, then return false.
1191             push(@$outputArray, $additionalIndent . &quot;        if (!propertyDescriptor.isDataDescriptor())\n&quot;);
1192             push(@$outputArray, $additionalIndent . &quot;            return false;\n&quot;);
1193             
1194             # 2.2.2. Invoke the named property setter with P and Desc.[[Value]].
1195             GenerateInvokeNamedPropertySetter($outputArray, $additionalIndent . &quot;        &quot;, $interface, $namedSetterOperation, &quot;propertyDescriptor.value()&quot;);
1196             if ($namedSetterOperation-&gt;extendedAttributes-&gt;{CallNamedSetterOnlyForSupportedProperties}) {
1197                 push(@$outputArray, $additionalIndent . &quot;    if (!isPropertySupported)\n&quot;);
<span class="line-modified">1198                 push(@$outputArray, $additionalIndent . &quot;        return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, propertyDescriptor, shouldThrow);\n&quot;);</span>
1199             }
1200             # 2.2.3. Return true.
1201             push(@$outputArray, $additionalIndent . &quot;        return true;\n&quot;);
1202         }
1203         
1204         if (!$overrideBuiltins) {
1205             push(@$outputArray, $additionalIndent . &quot;    }\n&quot;);
1206         }
1207         
1208         if ($hasUnforgableProperties) {
1209             push(@$outputArray, &quot;        }\n&quot;);
1210         }
1211         
1212         # Close the !propertyName.isSymbol() condition.
1213         push(@$outputArray, &quot;    }\n\n&quot;);
1214     }
1215     
1216     push(@$outputArray, &quot;    PropertyDescriptor newPropertyDescriptor = propertyDescriptor;\n&quot;);
1217         
<span class="line-modified">1218     # 3. If O does not implement an interface with the [Global] extended attribute,</span>
1219     #    then set Desc.[[Configurable]] to true.
<span class="line-modified">1220     if (!IsGlobalInterface($interface)) {</span>
1221         push(@$outputArray, &quot;    newPropertyDescriptor.setConfigurable(true);\n&quot;);
1222     }
1223     
1224     # 4. Return OrdinaryDefineOwnProperty(O, P, Desc).
1225     # FIXME: Does this do the same thing?
<span class="line-modified">1226     push(@$outputArray, &quot;    return JSObject::defineOwnProperty(object, lexicalGlobalObject, propertyName, newPropertyDescriptor, shouldThrow);\n&quot;);</span>
1227     
1228     push(@$outputArray, &quot;}\n\n&quot;);
1229 }
1230 
1231 sub GenerateDeletePropertyCommon
1232 {
1233     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1234     
1235     # This implements step 2 of https://heycam.github.io/webidl/#legacy-platform-object-delete
1236     # so it can be shared between the generation of deleteProperty and deletePropertyByIndex.
1237 
1238     # 2. If O supports named properties, O does not implement an interface with the
<span class="line-modified">1239     #    [Global] extended attribute and the result of calling the named</span>
<span class="line-modified">1240     #    property visibility algorithm with property name P and object O is true, then:</span>

1241     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
<span class="line-modified">1242     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);</span>
1243 
1244     AddToImplIncludes(&quot;JSDOMAbstractOperations.h&quot;, $conditional);
1245     my $overrideBuiltin = $codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;) ? &quot;OverrideBuiltins::Yes&quot; : &quot;OverrideBuiltins::No&quot;;
<span class="line-modified">1246     push(@$outputArray, &quot;    if (isVisibleNamedProperty&lt;${overrideBuiltin}&gt;(*lexicalGlobalObject, thisObject, propertyName)) {\n&quot;);</span>
1247 
<span class="line-modified">1248     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;);</span>
1249 
1250     # 2.1. If O does not implement an interface with a named property deleter, then return false.
1251     # 2.2. Let operation be the operation used to declare the named property deleter.
1252     # NOTE: We only add a deleteProperty implementation of we have a named property deleter.
1253 
1254     # 2.3. If operation was defined without an identifier, then:
1255     #      1. Perform the steps listed in the interface description to delete an existing named
1256     #         property with P as the name.
1257     #      2. If the steps indicated that the deletion failed, then return false.
1258     # 2.4. Otherwise, operation was defined with an identifier:
1259     #      1. Perform the steps listed in the description of operation with P as the only argument
1260     #         value.
1261     #      2. If operation was declared with a return type of boolean and the steps returned false,
1262     #         then return false.
1263 
1264     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;deleteNamedProperty&quot;;
1265     my $functionCall = &quot;impl.&quot; . $functionImplementationName . &quot;(propertyNameToString(propertyName))&quot;;
1266 
1267     # NOTE: We expect the implementation function of named deleters without an identifier to
1268     #       return either bool or ExceptionOr&lt;bool&gt;. the implementation function of named deleters
1269     #       with an identifier have no restriction, but if the return value of the operation is
1270     #       boolean, we return that value, otherwise it is ignored (as per section 4.2).
1271 
1272     if ($operation-&gt;extendedAttributes-&gt;{MayThrowException}) {
1273         push(@$outputArray, &quot;        auto result = ${functionCall};\n&quot;);
1274         push(@$outputArray, &quot;        if (result.hasException()) {\n&quot;);
<span class="line-modified">1275         push(@$outputArray, &quot;            auto throwScope = DECLARE_THROW_SCOPE(JSC::getVM(lexicalGlobalObject));\n&quot;);</span>
<span class="line-modified">1276         push(@$outputArray, &quot;            propagateException(*lexicalGlobalObject, throwScope, result.releaseException());\n&quot;);</span>
1277         push(@$outputArray, &quot;            return true;\n&quot;);
1278         push(@$outputArray, &quot;        }\n\n&quot;);
1279 
1280         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1281             push(@$outputArray, &quot;        return result.releaseReturnValue();\n&quot;);
1282         } else {
1283             push(@$outputArray, &quot;        return true;\n&quot;);
1284         }
1285     } else {
1286         if (!$operation-&gt;name || $operation-&gt;name &amp;&amp; $operation-&gt;type-&gt;name eq &quot;boolean&quot;) {
1287             push(@$outputArray, &quot;        return ${functionCall};\n&quot;);
1288         } else {
1289             push(@$outputArray, &quot;        ${functionCall};\n&quot;);
1290             push(@$outputArray, &quot;        return true;\n&quot;);
1291         }
1292     }
1293 
1294     push(@$outputArray, &quot;    }\n&quot;);
1295 }
1296 
1297 sub GenerateDeleteProperty
1298 {
1299     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1300 
1301     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1302     # for the deleteProperty override hook.
1303 
<span class="line-modified">1304     push(@$outputArray, &quot;bool ${className}::deleteProperty(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)\n&quot;);</span>
1305     push(@$outputArray, &quot;{\n&quot;);
1306 
1307     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1308     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1309 
1310     # 1. If O supports indexed properties and P is an array index property name, then:
1311     #    1. Let index be the result of calling ToUint32(P).
1312     #    2. If index is not a supported property index, then return true.
1313     #    3. Return false.
1314     if (GetIndexedGetterOperation($interface)) {
1315         push(@$outputArray, &quot;    if (auto index = parseIndex(propertyName))\n&quot;);
1316         push(@$outputArray, &quot;        return !impl.isSupportedPropertyIndex(index.value());\n&quot;);
1317     }
1318 
1319     # GenerateDeletePropertyCommon implements step 2.
1320     GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1321 
1322     # FIXME: Instead of calling down JSObject::deleteProperty, perhaps we should implement
1323     # the remained of the algorithm ourselves.
<span class="line-modified">1324     push(@$outputArray, &quot;    return JSObject::deleteProperty(cell, lexicalGlobalObject, propertyName);\n&quot;);</span>
1325     push(@$outputArray, &quot;}\n\n&quot;);
1326 }
1327 
1328 sub GenerateDeletePropertyByIndex
1329 {
1330     my ($outputArray, $interface, $className, $operation, $conditional) = @_;
1331 
1332     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete for the
1333     # for the deletePropertyByIndex override hook.
1334 
<span class="line-modified">1335     push(@$outputArray, &quot;bool ${className}::deletePropertyByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index)\n&quot;);</span>
1336     push(@$outputArray, &quot;{\n&quot;);
1337 
1338     push(@$outputArray, &quot;    auto&amp; thisObject = *jsCast&lt;${className}*&gt;(cell);\n&quot;);
1339     push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;);
1340 
1341     # 1. If O supports indexed properties and P is an array index property name, then:
1342     #    1. Let index be the result of calling ToUint32(P).
1343     #    2. If index is not a supported property index, then return true.
1344     #    3. Return false.
1345 
1346     # NOTE: For deletePropertyByIndex, if there is an indexed getter, checking isSupportedPropertyIndex()
1347     #       is all that needs to be done, no need to generate the .
1348 
1349     if (GetIndexedGetterOperation($interface)) {
1350         push(@$outputArray, &quot;    return !impl.isSupportedPropertyIndex(index);\n&quot;);
1351     } else {
<span class="line-modified">1352         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
1353         push(@$outputArray, &quot;    auto propertyName = Identifier::from(vm, index);\n&quot;);
1354 
1355         # GenerateDeletePropertyCommon implements step 2.
1356         GenerateDeletePropertyCommon($outputArray, $interface, $className, $operation, $conditional);
1357 
1358         # FIXME: Instead of calling down JSObject::deletePropertyByIndex, perhaps we should implement
1359         # the remaineder of the algoritm (steps 3 and 4) ourselves.
1360         
1361         # 3. If O has an own property with name P, then:
1362         #    1. If the property is not configurable, then return false.
1363         #    2. Otherwise, remove the property from O.
1364         # 3. Return true.
1365         
<span class="line-modified">1366         push(@$outputArray, &quot;    return JSObject::deletePropertyByIndex(cell, lexicalGlobalObject, index);\n&quot;);</span>
1367     }
1368 
1369     push(@$outputArray, &quot;}\n\n&quot;);
1370 }
1371 
1372 
1373 sub GenerateNamedDeleterDefinition
1374 {
1375     my ($outputArray, $interface, $className) = @_;
1376     
1377     return if $interface-&gt;extendedAttributes-&gt;{CustomDeleteProperty};
1378 
1379     my $namedDeleterOperation = GetNamedDeleterOperation($interface);
1380     
1381     # This implements https://heycam.github.io/webidl/#legacy-platform-object-delete using
1382     # the deleteProperty and deletePropertyByIndex override hooks.
1383 
1384     assert(&quot;Named property deleters are not allowed without a corresponding named property getter.&quot;) if !GetNamedGetterOperation($interface);
<span class="line-modified">1385     assert(&quot;Named property deleters are not allowed on global object interfaces.&quot;) if IsGlobalInterface($interface);</span>
1386 
1387     my $conditional = $namedDeleterOperation-&gt;extendedAttributes-&gt;{Conditional};
1388     if ($conditional) {
1389         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
1390         push(@$outputArray, &quot;#if ${conditionalString}\n\n&quot;);;
1391     }
1392 
1393     GenerateDeleteProperty($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1394     GenerateDeletePropertyByIndex($outputArray, $interface, $className, $namedDeleterOperation, $conditional);
1395 
1396     push(@implContent, &quot;#endif\n\n&quot;) if $conditional;
1397 }
1398 
1399 sub GenerateHeaderContentHeader
1400 {
1401     my $interface = shift;
1402     my $className = &quot;JS&quot; . $interface-&gt;type-&gt;name;
1403 
1404     my @headerContentHeader;
1405     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
</pre>
<hr />
<pre>
1489 
1490 sub GetTypeNameForDisplayInException
1491 {
1492     my ($type) = @_;
1493 
1494     # FIXME: Add more type specializations.
1495     return &quot;(&quot; . join(&quot; or &quot;, map { $_-&gt;name } GetFlattenedMemberTypes($type)) . &quot;)&quot; if $type-&gt;isUnion;
1496     return $type-&gt;name;
1497 }
1498 
1499 sub GetArgumentExceptionFunction
1500 {
1501     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1502 
1503     my $name = $argument-&gt;name;
1504     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1505     my $typeName = GetTypeNameForDisplayInException($argument-&gt;type);
1506 
1507     if ($codeGenerator-&gt;IsCallbackInterface($argument-&gt;type) || $codeGenerator-&gt;IsCallbackFunction($argument-&gt;type)) {
1508         # FIXME: We should have specialized messages for callback interfaces vs. callback functions.
<span class="line-modified">1509         return &quot;throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName});&quot;;</span>
1510     }
1511 
1512     if ($codeGenerator-&gt;IsWrapperType($argument-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($argument-&gt;type)) {
<span class="line-modified">1513         return &quot;throwArgumentTypeError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, \&quot;${typeName}\&quot;);&quot;;</span>
1514     }
1515 
1516     if ($codeGenerator-&gt;IsEnumType($argument-&gt;type)) {
1517         my $className = GetEnumerationClassName($argument-&gt;type, $interface);
<span class="line-modified">1518         return &quot;throwArgumentMustBeEnumError(lexicalGlobalObject, scope, ${argumentIndex}, \&quot;${name}\&quot;, \&quot;${visibleInterfaceName}\&quot;, ${quotedFunctionName}, expectedEnumerationValues&lt;${className}&gt;());&quot;;</span>
1519     }
1520 
1521     return undef;
1522 }
1523 
1524 sub GetArgumentExceptionThrower
1525 {
1526     my ($interface, $argument, $argumentIndex, $quotedFunctionName) = @_;
1527 
1528     my $functionCall = GetArgumentExceptionFunction($interface, $argument, $argumentIndex, $quotedFunctionName);
<span class="line-modified">1529     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
1530 }
1531 
1532 sub GetAttributeExceptionFunction
1533 {
1534     my ($interface, $attribute) = @_;
1535     
1536     my $name = $attribute-&gt;name;
1537     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
1538     my $typeName = GetTypeNameForDisplayInException($attribute-&gt;type);
1539 
1540     if ($codeGenerator-&gt;IsWrapperType($attribute-&gt;type) || $codeGenerator-&gt;IsBufferSourceType($attribute-&gt;type)) {
<span class="line-modified">1541         return &quot;throwAttributeTypeError(lexicalGlobalObject, scope, \&quot;${visibleInterfaceName}\&quot;, \&quot;${name}\&quot;, \&quot;${typeName}\&quot;);&quot;;</span>
1542     }
1543 }
1544 
1545 sub GetAttributeExceptionThrower
1546 {
1547     my ($interface, $attribute) = @_;
1548 
1549     my $functionCall = GetAttributeExceptionFunction($interface, $attribute);
<span class="line-modified">1550     return &quot;[](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) { &quot; . $functionCall . &quot; }&quot; if $functionCall;</span>
1551 
1552 }
1553 
1554 sub PassArgumentExpression
1555 {
1556     my ($name, $context) = @_;
1557 
1558     my $type = $context-&gt;type;
1559 
1560     return &quot;WTFMove(${name})&quot; if $type-&gt;isNullable;
1561 
1562     if ($codeGenerator-&gt;IsBufferSourceType($type)) {
1563         return &quot;*${name}&quot; if $type-&gt;name eq &quot;ArrayBuffer&quot;;
1564         return &quot;${name}.releaseNonNull()&quot;;
1565     }
1566 
1567     return &quot;${name}.releaseNonNull()&quot; if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type) || ($codeGenerator-&gt;IsPromiseType($type) &amp;&amp; (ref($context) ne &quot;IDLArgument&quot; || !$context-&gt;isOptional));
1568     return &quot;*${name}&quot; if $codeGenerator-&gt;IsWrapperType($type);
1569     return &quot;WTFMove(${name})&quot;;
1570 }
</pre>
<hr />
<pre>
1601 }
1602 
1603 sub GetFullyQualifiedImplementationCallName
1604 {
1605     my ($interface, $property, $implementationName, $implExpression, $conditional) = @_;
1606     
1607     my $implementedBy = $property-&gt;extendedAttributes-&gt;{ImplementedBy};
1608     if ($implementedBy) {
1609         AddToImplIncludes(&quot;${implementedBy}.h&quot;, $conditional);
1610         return &quot;WebCore::${implementedBy}::${implementationName}&quot;;
1611     }
1612     
1613     if ($property-&gt;isStatic || $property-&gt;extendedAttributes-&gt;{Constructor} || $property-&gt;extendedAttributes-&gt;{NamedConstructor}) {
1614         return $interface-&gt;type-&gt;name . &quot;::${implementationName}&quot;;
1615     }
1616     
1617     if ($property-&gt;isMapLike) {
1618         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToMapLike&quot;;
1619     }
1620     
<span class="line-added">1621     if ($property-&gt;isSetLike) {</span>
<span class="line-added">1622         return &quot;forward&quot; . $codeGenerator-&gt;WK_ucfirst($property-&gt;name) . &quot;ToSetLike&quot;;</span>
<span class="line-added">1623     }</span>
<span class="line-added">1624 </span>
1625     return &quot;${implExpression}.${implementationName}&quot;;
1626 }
1627 
1628 sub AddAdditionalArgumentsForImplementationCall
1629 {
<span class="line-modified">1630     my ($arguments, $interface, $property, $implExpression, $globalObject, $callFrame, $thisObjectExpression) = @_;</span>
1631     
1632     if ($property-&gt;extendedAttributes-&gt;{ImplementedBy} &amp;&amp; !$property-&gt;isStatic) {
1633         unshift(@$arguments, $implExpression);
1634     }
1635     
<span class="line-modified">1636     if ($property-&gt;isMapLike or $property-&gt;isSetLike) {</span>
<span class="line-modified">1637         push(@$arguments, $globalObject);</span>
<span class="line-added">1638         if (ref($property) eq &quot;IDLOperation&quot;) {</span>
<span class="line-added">1639             push(@$arguments, $callFrame);</span>
<span class="line-added">1640         }</span>
1641         push(@$arguments, $thisObjectExpression);
1642     }
1643 }
1644 
1645 sub GetSpecialAccessorOperationForType
1646 {
1647     my ($interface, $special, $firstParameterType, $numberOfParameters) = @_;
1648 
1649     foreach my $operation (@{$interface-&gt;operations}, @{$interface-&gt;anonymousOperations}) {
1650         my $specials = $operation-&gt;specials;
1651         my $specialExists = grep { $_ eq $special } @$specials;
1652         my $arguments = $operation-&gt;arguments;
1653         if ($specialExists and scalar(@$arguments) == $numberOfParameters and $arguments-&gt;[0]-&gt;type-&gt;name eq $firstParameterType) {
1654             return $operation;
1655         }
1656     }
1657 
1658     return 0;
1659 }
1660 
<span class="line-modified">1661 sub IsGlobalInterface</span>
1662 {
1663     my $interface = shift;
1664 
<span class="line-modified">1665     return $interface-&gt;extendedAttributes-&gt;{Global};</span>
1666 }
1667 
1668 sub AttributeShouldBeOnInstance
1669 {
1670     my $interface = shift;
1671     my $attribute = shift;
1672 
<span class="line-modified">1673     return 1 if IsGlobalInterface($interface);</span>
1674     return 1 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1675 
1676     # [Unforgeable] attributes should be on the instance.
1677     # https://heycam.github.io/webidl/#Unforgeable
1678     return 1 if IsUnforgeable($interface, $attribute);
1679 
1680     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
1681         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity};
1682         return 0 if $attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter};
1683         return 1;
1684     }
1685 
1686     return 0;
1687 }
1688 
1689 sub IsAlwaysExposedOnInterface
1690 {
1691     my ($interfaceExposures, $contextExposures) = @_;
1692 
1693     my %contextExposureSet = ();
</pre>
<hr />
<pre>
1718     if ($context-&gt;extendedAttributes-&gt;{Exposed}) {
1719         my $interfaceExposures = $interface-&gt;extendedAttributes-&gt;{Exposed} || &quot;Window&quot;;
1720         return 1 if !IsAlwaysExposedOnInterface($interfaceExposures, $context-&gt;extendedAttributes-&gt;{Exposed});
1721     }
1722 
1723     return $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}
1724         || $context-&gt;extendedAttributes-&gt;{EnabledForContext}
1725         || $context-&gt;extendedAttributes-&gt;{EnabledForWorld}
1726         || $context-&gt;extendedAttributes-&gt;{EnabledBySetting}
1727         || $context-&gt;extendedAttributes-&gt;{DisabledByQuirk}
1728         || $context-&gt;extendedAttributes-&gt;{SecureContext}
1729         || $context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}
1730         || $context-&gt;extendedAttributes-&gt;{CustomEnabled};
1731 }
1732 
1733 # https://heycam.github.io/webidl/#es-operations
1734 sub OperationShouldBeOnInstance
1735 {
1736     my ($interface, $operation) = @_;
1737 
<span class="line-modified">1738     return 1 if IsGlobalInterface($interface);</span>
1739 
1740     # [Unforgeable] operations should be on the instance. https://heycam.github.io/webidl/#Unforgeable
1741     if (IsUnforgeable($interface, $operation)) {
1742         assert(&quot;The bindings generator does not support putting runtime-enabled operations on the instance yet (except for global objects):[&quot; . $interface-&gt;type-&gt;name . &quot;::&quot; . $operation-&gt;name . &quot;]&quot;) if NeedsRuntimeCheck($interface, $operation);
1743         return 1;
1744     }
1745 
1746     return 0;
1747 }
1748 
1749 sub OperationHasForcedReturnValue
1750 {
1751     my ($operation) = @_;
1752 
1753     foreach my $argument (@{$operation-&gt;arguments}) {
1754         return 1 if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
1755     }
1756     return 0;
1757 }
1758 
1759 sub IsAcceleratedDOMAttribute
1760 {
1761     my ($interface, $attribute) = @_;
1762 
1763     # If we use CustomGetterSetter in IDL code generator we cannot skip type check.
1764     return 0 if NeedsRuntimeCheck($interface, $attribute) and AttributeShouldBeOnInstance($interface, $attribute);
1765     return 0 if $attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and AttributeShouldBeOnInstance($interface, $attribute);
1766 
1767     # If the interface has special logic for casting we cannot hoist type check to JSC.
1768     return 0 if $interface-&gt;extendedAttributes-&gt;{ImplicitThis};
1769     return 0 if $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject};
1770 
1771     return 0 if $attribute-&gt;isStatic;
1772     return 0 if $attribute-&gt;isMapLike;
<span class="line-added">1773     return 0 if $attribute-&gt;isSetLike;</span>
1774     return 0 if $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1775     return 0 if IsJSBuiltin($interface, $attribute);
1776     return 0 if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
1777     return 0 if $codeGenerator-&gt;IsPromiseType($attribute-&gt;type);
1778     return 0 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
1779     return 1;
1780 }
1781 
1782 sub GetJSCAttributesForAttribute
1783 {
1784     my $interface = shift;
1785     my $attribute = shift;
1786 
1787     my @specials = ();
1788     push(@specials, &quot;JSC::PropertyAttribute::DontDelete&quot;) if IsUnforgeable($interface, $attribute);
1789 
1790     # As per Web IDL specification, constructor properties on the ECMAScript global object should not be enumerable.
1791     my $isGlobalConstructor = $codeGenerator-&gt;IsConstructorType($attribute-&gt;type);
1792     push(@specials, &quot;JSC::PropertyAttribute::DontEnum&quot;) if ($attribute-&gt;extendedAttributes-&gt;{NotEnumerable} || $isGlobalConstructor);
1793     push(@specials, &quot;JSC::PropertyAttribute::ReadOnly&quot;) if IsReadonly($attribute);
</pre>
<hr />
<pre>
1834     my $count = 0;
1835 
1836     foreach my $operation (@{$interface-&gt;operations}) {
1837         $count++ if OperationShouldBeOnInstance($interface, $operation);
1838     }
1839 
1840     return $count;
1841 }
1842 
1843 sub PrototypeOperationCount
1844 {
1845     my $interface = shift;
1846     my $count = 0;
1847 
1848     foreach my $operation (@{$interface-&gt;operations}) {
1849         $count++ if !$operation-&gt;isStatic &amp;&amp; !OperationShouldBeOnInstance($interface, $operation);
1850     }
1851 
1852     $count += scalar @{$interface-&gt;iterable-&gt;operations} if $interface-&gt;iterable;
1853     $count += scalar @{$interface-&gt;mapLike-&gt;operations} if $interface-&gt;mapLike;
<span class="line-added">1854     $count += scalar @{$interface-&gt;setLike-&gt;operations} if $interface-&gt;setLike;</span>
1855     $count += scalar @{$interface-&gt;serializable-&gt;operations} if $interface-&gt;serializable;
1856 
1857     return $count;
1858 }
1859 
1860 sub InstancePropertyCount
1861 {
1862     my $interface = shift;
1863     my $count = 0;
1864     foreach my $attribute (@{$interface-&gt;attributes}) {
1865         $count++ if AttributeShouldBeOnInstance($interface, $attribute);
1866     }
1867     $count += InstanceOperationCount($interface);
1868     return $count;
1869 }
1870 
1871 sub PrototypePropertyCount
1872 {
1873     my $interface = shift;
1874     my $count = 0;
</pre>
<hr />
<pre>
2084     $result .= &quot;    static const NeverDestroyed&lt;String&gt; values[] = {\n&quot;;
2085     foreach my $value (@{$enumeration-&gt;values}) {
2086         if ($value eq &quot;&quot;) {
2087             $result .= &quot;        emptyString(),\n&quot;;
2088         } else {
2089             $result .= &quot;        MAKE_STATIC_STRING_IMPL(\&quot;$value\&quot;),\n&quot;;
2090         }
2091     }
2092     $result .= &quot;    };\n&quot;;
2093     my $index = 0;
2094     foreach my $value (@{$enumeration-&gt;values}) {
2095         my $enumerationValueName = GetEnumerationValueName($value);
2096         $result .= &quot;    static_assert(static_cast&lt;size_t&gt;(${className}::$enumerationValueName) == $index, \&quot;${className}::$enumerationValueName is not $index as expected\&quot;);\n&quot;;
2097         $index++;
2098     }
2099     $result .= &quot;    ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));\n&quot;;
2100     $result .= &quot;    return values[static_cast&lt;size_t&gt;(enumerationValue)];\n&quot;;
2101     $result .= &quot;}\n\n&quot;;
2102 
2103 
<span class="line-modified">2104     # FIXME: Change to take VM&amp; instead of JSGlobalObject*.</span>
<span class="line-modified">2105     $result .= &quot;template&lt;&gt; JSString* convertEnumerationToJS(JSGlobalObject&amp; lexicalGlobalObject, $className enumerationValue)\n&quot;;</span>
2106     $result .= &quot;{\n&quot;;
<span class="line-modified">2107     $result .= &quot;    return jsStringWithCache(&amp;lexicalGlobalObject, convertEnumerationToString(enumerationValue));\n&quot;;</span>
2108     $result .= &quot;}\n\n&quot;;
2109 
<span class="line-modified">2110     # FIXME: Change to take VM&amp; instead of JSGlobalObject&amp;.</span>
2111     # FIXME: Consider using toStringOrNull to make exception checking faster.
2112     # FIXME: Consider finding a more efficient way to match against all the strings quickly.
<span class="line-modified">2113     $result .= &quot;template&lt;&gt; Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;</span>
2114     $result .= &quot;{\n&quot;;
<span class="line-modified">2115     $result .= &quot;    auto stringValue = value.toWTFString(&amp;lexicalGlobalObject);\n&quot;;</span>
2116     foreach my $value (@{$enumeration-&gt;values}) {
2117         my $enumerationValueName = GetEnumerationValueName($value);
2118         if ($value eq &quot;&quot;) {
2119             $result .= &quot;    if (stringValue.isEmpty())\n&quot;;
2120         } else {
2121             $result .= &quot;    if (stringValue == \&quot;$value\&quot;)\n&quot;;
2122         }
2123         $result .= &quot;        return ${className}::${enumerationValueName};\n&quot;;
2124     }
2125     $result .= &quot;    return WTF::nullopt;\n&quot;;
2126     $result .= &quot;}\n\n&quot;;
2127 
2128     $result .= &quot;template&lt;&gt; const char* expectedEnumerationValues&lt;$className&gt;()\n&quot;;
2129     $result .= &quot;{\n&quot;;
2130     $result .= &quot;    return \&quot;\\\&quot;&quot; . join (&quot;\\\&quot;, \\\&quot;&quot;, @{$enumeration-&gt;values}) . &quot;\\\&quot;\&quot;;\n&quot;;
2131     $result .= &quot;}\n\n&quot;;
2132 
2133     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2134 
2135     return $result;
</pre>
<hr />
<pre>
2145     foreach my $enumeration (@$enumerations) {
2146         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2147         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2148         $result .= GenerateEnumerationImplementationContent($enumeration, $className, $interface, $conditionalString);
2149     }
2150     return $result;
2151 }
2152 
2153 sub GenerateEnumerationHeaderContent
2154 {
2155     my ($enumeration, $className, $conditionalString) = @_;
2156 
2157     $headerIncludes{&quot;JSDOMConvertEnumeration.h&quot;} = 1;
2158 
2159     my $result = &quot;&quot;;
2160     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
2161 
2162     my $exportMacro = GetExportMacroForJSClass($enumeration);
2163 
2164     $result .= &quot;${exportMacro}String convertEnumerationToString($className);\n&quot;;
<span class="line-modified">2165     $result .= &quot;template&lt;&gt; ${exportMacro}JSC::JSString* convertEnumerationToJS(JSC::JSGlobalObject&amp;, $className);\n\n&quot;;</span>
<span class="line-modified">2166     $result .= &quot;template&lt;&gt; ${exportMacro}Optional&lt;$className&gt; parseEnumeration&lt;$className&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;;</span>
2167     $result .= &quot;template&lt;&gt; ${exportMacro}const char* expectedEnumerationValues&lt;$className&gt;();\n\n&quot;;
2168     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2169     
2170     return $result;
2171 }
2172 
2173 sub GenerateEnumerationsHeaderContent
2174 {
2175     my ($interface, $enumerations) = @_;
2176 
2177     return &quot;&quot; unless @$enumerations;
2178 
2179     # FIXME: Could optimize this to only generate the parts of each enumeration that are actually
2180     # used, which would require iterating over everything in the interface.
2181 
2182     my $result = &quot;&quot;;
2183     foreach my $enumeration (@$enumerations) {
2184         my $className = GetEnumerationClassName($enumeration-&gt;type, $interface);
2185         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($enumeration);
2186         $result .= GenerateEnumerationHeaderContent($enumeration, $className, $conditionalString);
</pre>
<hr />
<pre>
2216             return $useAtomString ? &quot;AtomString(${defaultValue}, AtomString::ConstructFromLiteral)&quot; : &quot;${defaultValue}_s&quot;;
2217         }
2218     }
2219 
2220     if ($codeGenerator-&gt;IsEnumType($type)) {
2221         # FIXME: Would be nice to report an error if the value does not have quote marks around it.
2222         # FIXME: Would be nice to report an error if the value is not one of the enumeration values.
2223         if ($defaultValue eq &quot;null&quot;) {
2224             die if !$type-&gt;isNullable;
2225             return &quot;WTF::nullopt&quot;;
2226         }
2227         my $className = GetEnumerationClassName($type, $typeScope);
2228         my $enumerationValueName = GetEnumerationValueName(substr($defaultValue, 1, -1));
2229         return $className . &quot;::&quot; . $enumerationValueName;
2230     }
2231     if ($defaultValue eq &quot;null&quot;) {
2232         if ($type-&gt;isUnion) {
2233             return &quot;WTF::nullopt&quot; if $type-&gt;isNullable;
2234 
2235             my $IDLType = GetIDLType($typeScope, $type);
<span class="line-modified">2236             return &quot;convert&lt;${IDLType}&gt;(lexicalGlobalObject, jsNull());&quot;;</span>
2237         }
2238 
2239         return &quot;jsNull()&quot; if $type-&gt;name eq &quot;any&quot;;
2240         return &quot;nullptr&quot; if $codeGenerator-&gt;IsWrapperType($type) || $codeGenerator-&gt;IsBufferSourceType($type);
2241         return &quot;String()&quot; if $codeGenerator-&gt;IsStringType($type);
2242         return &quot;WTF::nullopt&quot;;
2243     }
2244 
2245     if ($defaultValue eq &quot;[]&quot;) {
2246         my $IDLType = GetIDLType($typeScope, $type);
2247         return &quot;Converter&lt;${IDLType}&gt;::ReturnType{ }&quot;;
2248     }
2249 
2250     return &quot;jsUndefined()&quot; if $defaultValue eq &quot;undefined&quot;;
2251     return &quot;PNaN&quot; if $defaultValue eq &quot;NaN&quot;;
2252 
2253     return $defaultValue;
2254 }
2255 
2256 sub GenerateDictionaryHeaderContent
2257 {
2258     my ($dictionary, $className, $conditionalString) = @_;
2259 
2260     $headerIncludes{&quot;JSDOMConvertDictionary.h&quot;} = 1;
2261 
2262     my $exportMacro = GetExportMacroForJSClass($dictionary);
2263 
2264     my $result = &quot;&quot;;
2265     $result .= &quot;#if ${conditionalString}\n\n&quot; if $conditionalString;
<span class="line-modified">2266     $result .= &quot;template&lt;&gt; ${exportMacro}${className} convertDictionary&lt;${className}&gt;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n\n&quot;;</span>
2267 
2268     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
<span class="line-modified">2269         $result .= &quot;${exportMacro}JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp;, const ${className}&amp;);\n\n&quot;;</span>
2270     }
2271 
2272     $result .= &quot;#endif\n\n&quot; if $conditionalString;
2273     return $result;
2274 }
2275 
2276 sub GenerateDictionariesHeaderContent
2277 {
2278     my ($typeScope, $allDictionaries) = @_;
2279 
2280     return &quot;&quot; unless @$allDictionaries;
2281 
2282     my $result = &quot;&quot;;
2283     foreach my $dictionary (@$allDictionaries) {
2284         $headerIncludes{$typeScope-&gt;type-&gt;name . &quot;.h&quot;} = 1 if $typeScope;
2285         my $className = GetDictionaryClassName($dictionary-&gt;type, $typeScope);
2286         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
2287         $result .= GenerateDictionaryHeaderContent($dictionary, $className, $conditionalString);
2288     }
2289     return $result;
</pre>
<hr />
<pre>
2292 sub GenerateDictionaryImplementationContent
2293 {
2294     my ($dictionary, $className, $interface) = @_;
2295 
2296     my $result = &quot;&quot;;
2297 
2298     my $name = $dictionary-&gt;type-&gt;name;
2299     my $typeScope = $interface || $dictionary;
2300 
2301     my $conditional = $dictionary-&gt;extendedAttributes-&gt;{Conditional};
2302     if ($conditional) {
2303         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2304         $result .= &quot;#if ${conditionalString}\n\n&quot;;
2305     }
2306 
2307     # FIXME: A little ugly to have this be a side effect instead of a return value.
2308     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
2309     AddToImplIncludes(&quot;JSDOMConvertDictionary.h&quot;);
2310 
2311     # https://heycam.github.io/webidl/#es-dictionary
<span class="line-modified">2312     $result .= &quot;template&lt;&gt; $className convertDictionary&lt;$className&gt;(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)\n&quot;;</span>
2313     $result .= &quot;{\n&quot;;
<span class="line-modified">2314     $result .= &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;;</span>
2315     $result .= &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;;
2316     $result .= &quot;    bool isNullOrUndefined = value.isUndefinedOrNull();\n&quot;;
2317     $result .= &quot;    auto* object = isNullOrUndefined ? nullptr : value.getObject();\n&quot;;
2318 
2319     # 1. If Type(V) is not Undefined, Null or Object, then throw a TypeError.
2320     $result .= &quot;    if (UNLIKELY(!isNullOrUndefined &amp;&amp; !object)) {\n&quot;;
<span class="line-modified">2321     $result .= &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;;</span>
2322     $result .= &quot;        return { };\n&quot;;
2323     $result .= &quot;    }\n&quot;;
2324 
2325     # 2. Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
2326 
2327     # 3. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
2328     my @dictionaries;
2329     push(@dictionaries, $dictionary);
2330     my $parentType = $dictionary-&gt;parentType;
2331     while (defined($parentType)) {
2332         my $parentDictionary = $codeGenerator-&gt;GetDictionaryByType($parentType);
2333         assert(&quot;Unable to find definition for dictionary named &#39;&quot; . $parentType-&gt;name . &quot;&#39;!&quot;) unless defined($parentDictionary);
2334         unshift(@dictionaries, $parentDictionary);
2335         $parentType = $parentDictionary-&gt;parentType;
2336     }
2337 
2338     my $arguments = &quot;&quot;;
2339     my $comma = &quot;&quot;;
2340 
2341     $result .= &quot;    $className result;\n&quot;;
</pre>
<hr />
<pre>
2348             $member-&gt;default(&quot;undefined&quot;) if $member-&gt;type-&gt;name eq &quot;any&quot; and !defined($member-&gt;default); # Use undefined as default value for member of type &#39;any&#39; unless specified otherwise.
2349 
2350             my $type = $member-&gt;type;
2351             AddToImplIncludesForIDLType($type);
2352 
2353             my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2354             if ($conditional) {
2355                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2356                 $result .= &quot;#if ${conditionalString}\n&quot;;
2357             }
2358 
2359             # 4.1. Let key be the identifier of member.
2360             my $key = $member-&gt;name;
2361             my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2362 
2363             # 4.2. Let value be an ECMAScript value, depending on Type(V):
2364             $result .= &quot;    JSValue ${key}Value;\n&quot;;
2365             $result .= &quot;    if (isNullOrUndefined)\n&quot;;
2366             $result .= &quot;        ${key}Value = jsUndefined();\n&quot;;
2367             $result .= &quot;    else {\n&quot;;
<span class="line-modified">2368             $result .= &quot;        ${key}Value = object-&gt;get(&amp;lexicalGlobalObject, Identifier::fromString(vm, \&quot;${key}\&quot;));\n&quot;;</span>
2369             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2370             $result .= &quot;    }\n&quot;;
2371 
2372             my $IDLType = GetIDLType($typeScope, $type);
2373 
2374             # 4.3. If value is not undefined, then:
2375             $result .= &quot;    if (!${key}Value.isUndefined()) {\n&quot;;
2376 
<span class="line-modified">2377             my $nativeValue = JSValueToNative($typeScope, $member, &quot;${key}Value&quot;, $member-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;);</span>
2378             $result .= &quot;        result.$implementedAsKey = $nativeValue;\n&quot;;
2379             $result .= &quot;        RETURN_IF_EXCEPTION(throwScope, { });\n&quot;;
2380 
2381             # Value is undefined.
2382             # 4.4. Otherwise, if value is undefined but the dictionary member has a default value, then:
2383             if (!$member-&gt;isRequired &amp;&amp; defined $member-&gt;default) {
2384                 $result .= &quot;    } else\n&quot;;
2385                 $result .= &quot;        result.$implementedAsKey = &quot; . GenerateDefaultValue($typeScope, $member, $member-&gt;type, $member-&gt;default) . &quot;;\n&quot;;
2386             } elsif ($member-&gt;isRequired) {
2387                 # 4.5. Otherwise, if value is undefined and the dictionary member is a required dictionary member, then throw a TypeError.
2388                 $result .= &quot;    } else {\n&quot;;
<span class="line-modified">2389                 $result .= &quot;        throwRequiredMemberTypeError(lexicalGlobalObject, throwScope, \&quot;&quot;. $member-&gt;name .&quot;\&quot;, \&quot;$name\&quot;, \&quot;&quot;. GetTypeNameForDisplayInException($type) .&quot;\&quot;);\n&quot;;</span>
2390                 $result .= &quot;        return { };\n&quot;;
2391                 $result .= &quot;    }\n&quot;;
2392             } else {
2393                 $result .= &quot;    }\n&quot;;
2394             }
2395 
2396             $result .= &quot;#endif\n&quot; if $conditional;
2397         }
2398     }
2399 
2400     # 5. Return dict.
2401     $result .= &quot;    return result;\n&quot;;
2402     $result .= &quot;}\n\n&quot;;
2403 
2404     if ($dictionary-&gt;extendedAttributes-&gt;{JSGenerateToJSObject}) {
2405         AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;);
2406         AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
2407 
<span class="line-modified">2408         $result .= &quot;JSC::JSObject* convertDictionaryToJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const ${className}&amp; dictionary)\n&quot;;</span>
2409         $result .= &quot;{\n&quot;;
<span class="line-modified">2410         $result .= &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n\n&quot;;</span>
2411 
2412         # 1. Let O be ! ObjectCreate(%ObjectPrototype%).
<span class="line-modified">2413         $result .= &quot;    auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n\n&quot;;</span>
2414 
2415         # 2. Let dictionaries be a list consisting of D and all of D’s inherited dictionaries,
2416         #    in order from least to most derived.
2417         #    NOTE: This was done above.
2418 
2419         # 3. For each dictionary dictionary in dictionaries, in order:
2420         foreach my $dictionary (@dictionaries) {
2421             # 3.1. For each dictionary member member declared on dictionary, in lexicographical order:
2422             my @sortedMembers = sort { $a-&gt;name cmp $b-&gt;name } @{$dictionary-&gt;members};
2423             foreach my $member (@sortedMembers) {
2424                 my $key = $member-&gt;name;
2425                 my $implementedAsKey = $member-&gt;extendedAttributes-&gt;{ImplementedAs} || $key;
2426                 my $valueExpression = &quot;dictionary.${implementedAsKey}&quot;;
2427 
2428                 my $conditional = $member-&gt;extendedAttributes-&gt;{Conditional};
2429                 if ($conditional) {
2430                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
2431                     $result .= &quot;#if ${conditionalString}\n&quot;;
2432                 }
2433 
2434                 # 1. Let key be the identifier of member.
2435                 # 2. If the dictionary member named key is present in V, then:
2436                     # 1. Let idlValue be the value of member on V.
2437                     # 2. Let value be the result of converting idlValue to an ECMAScript value.
2438                     # 3. Perform ! CreateDataProperty(O, key, value).
2439 
2440                 my $needsRuntimeCheck = NeedsRuntimeCheck($dictionary, $member);
2441                 my $indent = &quot;&quot;;
2442                 if ($needsRuntimeCheck) {
<span class="line-modified">2443                     my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($dictionary, $member, &quot;&amp;globalObject&quot;);</span>
2444                     $result .= &quot;    if (${runtimeEnableConditionalString}) {\n&quot;;
2445                     $indent = &quot;    &quot;;
2446                 }
2447 
2448                 if (!$member-&gt;isRequired &amp;&amp; not defined $member-&gt;default) {
2449                     my $IDLType = GetIDLType($typeScope, $member-&gt;type);
2450                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, &quot;${IDLType}::extractValueFromNullable(${valueExpression})&quot;, &quot;globalObject&quot;);
2451 
2452                     $result .= &quot;${indent}    if (!${IDLType}::isNullValue(${valueExpression})) {\n&quot;;
2453                     $result .= &quot;${indent}        auto ${key}Value = ${conversionExpression};\n&quot;;
2454                     $result .= &quot;${indent}        result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2455                     $result .= &quot;${indent}    }\n&quot;;
2456                 } else {
2457                     my $conversionExpression = NativeToJSValueUsingReferences($member, $typeScope, $valueExpression, &quot;globalObject&quot;);
2458 
2459                     $result .= &quot;${indent}    auto ${key}Value = ${conversionExpression};\n&quot;;
2460                     $result .= &quot;${indent}    result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, \&quot;${key}\&quot;), ${key}Value);\n&quot;;
2461                 }
2462                 if ($needsRuntimeCheck) {
2463                     $result .= &quot;    }\n&quot;;
</pre>
<hr />
<pre>
2605         push(@headerContent, &quot;    }\n\n&quot;);
2606     } elsif (!NeedsImplementationClass($interface)) {
2607         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject)\n&quot;);
2608         push(@headerContent, &quot;    {\n&quot;);
2609         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject);\n&quot;);
2610         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2611         push(@headerContent, &quot;        return ptr;\n&quot;);
2612         push(@headerContent, &quot;    }\n\n&quot;);  
2613     } else {
2614         if (!$codeGenerator-&gt;IsSVGAnimatedType($interface-&gt;type) &amp;&amp; !$codeGenerator-&gt;IsSVGPathSegType($interface-&gt;type)) {
2615             AddIncludesForImplementationTypeInHeader($implType);
2616         }
2617         push(@headerContent, &quot;    static $className* create(JSC::Structure* structure, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);
2618         push(@headerContent, &quot;    {\n&quot;);
2619         push(@headerContent, &quot;        $className* ptr = new (NotNull, JSC::allocateCell&lt;$className&gt;(globalObject-&gt;vm().heap)) $className(structure, *globalObject, WTFMove(impl));\n&quot;);
2620         push(@headerContent, &quot;        ptr-&gt;finishCreation(globalObject-&gt;vm());\n&quot;);
2621         push(@headerContent, &quot;        return ptr;\n&quot;);
2622         push(@headerContent, &quot;    }\n\n&quot;);
2623     }
2624 


2625     $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1 if InstancePropertyCount($interface) &gt; 0;
2626     $structureFlags{&quot;JSC::NewImpurePropertyFiresWatchpoints&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{NewImpurePropertyFiresWatchpoints};
2627     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObject};
2628     $structureFlags{&quot;JSC::MasqueradesAsUndefined&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{MasqueradesAsUndefined};
2629     $structureFlags{&quot;JSC::ImplementsHasInstance | JSC::ImplementsDefaultHasInstance&quot;} = 1 if $interfaceName eq &quot;DOMWindow&quot;;
2630         
2631     # Prototype
2632     unless (ShouldUseGlobalObjectPrototype($interface)) {
2633         push(@headerContent, &quot;    static JSC::JSObject* createPrototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2634         push(@headerContent, &quot;    static JSC::JSObject* prototype(JSC::VM&amp;, JSDOMGlobalObject&amp;);\n&quot;);
2635     }
2636 
2637     # JSValue to implementation type
2638     if (ShouldGenerateToWrapped($hasParent, $interface)) {
2639         # FIXME: Add extended attribute for this.
2640         my @toWrappedArguments = ();
2641         push(@toWrappedArguments, &quot;JSC::VM&amp;&quot;);
<span class="line-modified">2642         push(@toWrappedArguments, &quot;JSC::JSGlobalObject&amp;&quot;) if $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot;;</span>
2643         push(@toWrappedArguments, &quot;JSC::JSValue&quot;);
2644 
2645         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
2646 
2647         my $export = &quot;&quot;;
2648         $export = &quot;WEBCORE_EXPORT &quot; if $interface-&gt;extendedAttributes-&gt;{ExportToWrappedFunction};
2649         push(@headerContent, &quot;    static ${export}${toWrappedType} toWrapped(&quot; . join(&quot;, &quot;, @toWrappedArguments) . &quot;);\n&quot;);
2650     }
2651 
2652     $headerTrailingIncludes{&quot;${className}Custom.h&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{JSCustomHeader};
2653 
2654     my $namedGetterOperation = GetNamedGetterOperation($interface);
2655     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
2656 
2657     # FIXME: Why doesn&#39;t this also include Indexed Getters and [CustomGetOwnPropertySlot]
2658     if ($namedGetterOperation) {
2659         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;OverrideBuiltins&quot;)) {
2660             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpure&quot;} = 1;
2661         } else {
2662             $structureFlags{&quot;JSC::GetOwnPropertySlotIsImpureForPropertyAbsence&quot;} = 1;
2663         }
2664     }
2665     
2666     # ClassInfo MethodTable declarations.
2667     
2668     if (InstanceOverridesGetOwnPropertySlot($interface)) {
<span class="line-modified">2669         push(@headerContent, &quot;    static bool getOwnPropertySlot(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
2670         $structureFlags{&quot;JSC::OverridesGetOwnPropertySlot&quot;} = 1;
<span class="line-modified">2671         push(@headerContent, &quot;    static bool getOwnPropertySlotByIndex(JSC::JSObject*, JSC::JSGlobalObject*, unsigned propertyName, JSC::PropertySlot&amp;);\n&quot;);</span>
2672         $structureFlags{&quot;JSC::InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero&quot;} = 1;
2673     }
2674 
2675     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity}) {
<span class="line-modified">2676         push(@headerContent, &quot;    static void doPutPropertySecurityCheck(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::PutPropertySlot&amp;);\n&quot;);</span>
2677         $structureFlags{&quot;JSC::HasPutPropertySecurityCheck&quot;} = 1;
2678     }
<span class="line-added">2679 </span>
<span class="line-added">2680     if ($interface-&gt;extendedAttributes-&gt;{Plugin} || GetNamedSetterOperation($interface)) {</span>
<span class="line-added">2681         $structureFlags{&quot;JSC::ProhibitsPropertyCaching&quot;} = 1;</span>
<span class="line-added">2682     }</span>
2683     
2684     if (InstanceOverridesGetOwnPropertyNames($interface)) {
<span class="line-modified">2685         push(@headerContent, &quot;    static void getOwnPropertyNames(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyNameArray&amp;, JSC::EnumerationMode = JSC::EnumerationMode());\n&quot;);</span>
2686         $structureFlags{&quot;JSC::OverridesGetPropertyNames&quot;} = 1;
2687     }
2688     
2689     if (InstanceOverridesPut($interface)) {
<span class="line-modified">2690         push(@headerContent, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
<span class="line-modified">2691         push(@headerContent, &quot;    static bool putByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned propertyName, JSC::JSValue, bool shouldThrow);\n&quot;);</span>
2692     }
2693     
2694     if (InstanceOverridesDefineOwnProperty($interface)) {
<span class="line-modified">2695         push(@headerContent, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
2696     }
2697 
2698     if (InstanceOverridesDeleteProperty($interface)) {
<span class="line-modified">2699         push(@headerContent, &quot;    static bool deleteProperty(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName);\n&quot;);</span>
<span class="line-modified">2700         push(@headerContent, &quot;    static bool deletePropertyByIndex(JSC::JSCell*, JSC::JSGlobalObject*, unsigned);\n&quot;);</span>
2701     }
2702 
2703     if (InstanceOverridesGetCallData($interface)) {
2704         push(@headerContent, &quot;    static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&amp;);\n\n&quot;);
2705         $headerIncludes{&quot;&lt;JavaScriptCore/CallData.h&gt;&quot;} = 1;
2706         $structureFlags{&quot;JSC::OverridesGetCallData&quot;} = 1;
2707     }
2708     
2709     if ($interface-&gt;extendedAttributes-&gt;{CustomGetPrototype}) {
<span class="line-modified">2710         push(@headerContent, &quot;    static JSC::JSValue getPrototype(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);</span>
2711     }
2712     
2713     if ($interface-&gt;extendedAttributes-&gt;{CustomToStringName}) {
<span class="line-modified">2714         push(@headerContent, &quot;    static String toStringName(const JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);</span>
2715     }
2716     
2717     if ($interface-&gt;extendedAttributes-&gt;{CustomPreventExtensions}) {
<span class="line-modified">2718         push(@headerContent, &quot;    static bool preventExtensions(JSC::JSObject*, JSC::JSGlobalObject*);\n&quot;);</span>
2719     }
2720 
2721     if (InstanceNeedsEstimatedSize($interface)) {
2722         push(@headerContent, &quot;    static size_t estimatedSize(JSCell*, JSC::VM&amp;);\n&quot;);
2723     }
2724     
2725     if (!$hasParent) {
2726         push(@headerContent, &quot;    static void destroy(JSC::JSCell*);\n&quot;);
2727     }
2728 
2729     # Class info
2730     if ($interfaceName eq &quot;Node&quot;) {
2731         push(@headerContent, &quot;\n&quot;);
2732         push(@headerContent, &quot;protected:\n&quot;);
2733         push(@headerContent, &quot;    static const JSC::ClassInfo s_info;\n&quot;);
2734         push(@headerContent, &quot;public:\n&quot;);
2735         push(@headerContent, &quot;    static constexpr const JSC::ClassInfo* info() { return &amp;s_info; }\n\n&quot;);
2736     } else {
2737         push(@headerContent, &quot;\n&quot;);
2738         push(@headerContent, &quot;    DECLARE_INFO;\n\n&quot;);
2739     }
2740 
2741     # Structure ID
2742     push(@headerContent, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
2743     push(@headerContent, &quot;    {\n&quot;);
2744     if (IsDOMGlobalObject($interface)) {
2745         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::GlobalObjectType, StructureFlags), info());\n&quot;);
2746     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Node&quot;)) {
2747         my $type = GetJSTypeForNode($interface);
2748         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType($type), StructureFlags), info());\n&quot;);
2749     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;Event&quot;)) {
2750         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::JSType(JSEventType), StructureFlags), info());\n&quot;);
2751     } else {
2752         push(@headerContent, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
2753     }
2754     push(@headerContent, &quot;    }\n\n&quot;);
2755 
2756     # Custom pushEventHandlerScope function
2757     if ($interface-&gt;extendedAttributes-&gt;{CustomPushEventHandlerScope}) {
<span class="line-modified">2758         push(@headerContent, &quot;    JSC::JSScope* pushEventHandlerScope(JSC::JSGlobalObject*, JSC::JSScope*) const;\n\n&quot;);</span>
2759     }
2760     
2761     # Constructor object getter
2762     unless ($interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
2763         push(@headerContent, &quot;    static JSC::JSValue getConstructor(JSC::VM&amp;, const JSC::JSGlobalObject*);\n&quot;);
2764         push(@headerContent, &quot;    static JSC::JSValue getNamedConstructor(JSC::VM&amp;, JSC::JSGlobalObject*);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
2765     }
2766 
2767     # Serializer function.
2768     if ($interface-&gt;serializable) {
<span class="line-modified">2769         push(@headerContent, &quot;    static JSC::JSObject* serialize(JSC::JSGlobalObject&amp;, ${className}&amp; thisObject, JSDOMGlobalObject&amp;, JSC::ThrowScope&amp;);\n&quot;);</span>
2770     }
2771     
2772     my $numCustomOperations = 0;
2773     my $numCustomAttributes = 0;
2774 
2775     my $hasForwardDeclaringOperations = 0;
2776     my $hasForwardDeclaringAttributes = 0;
2777 
2778     my $hasDOMJITAttributes = 0;
2779 
2780     # Attribute and function enums
2781     if ($numAttributes &gt; 0) {
2782         foreach my $attribute (@{$interface-&gt;attributes}) {
2783             $numCustomAttributes++ if HasCustomGetter($attribute);
2784             $numCustomAttributes++ if HasCustomSetter($attribute);
2785             if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
2786                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2787                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2788                 push(@headerContent, &quot;    mutable JSC::WriteBarrier&lt;JSC::Unknown&gt; m_&quot; . $attribute-&gt;name . &quot;;\n&quot;);
2789                 $numCachedAttributes++;
2790                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2791             }
2792             $hasDOMJITAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
2793 
2794             $hasForwardDeclaringAttributes = 1 if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2795         }
2796     }
2797 
<span class="line-added">2798     # FIXME: We put this unconditionally to put all the WebCore JS wrappers in each IsoSubspace.</span>
<span class="line-added">2799     # https://bugs.webkit.org/show_bug.cgi?id=205107</span>
<span class="line-added">2800     if (IsDOMGlobalObject($interface)) {</span>
<span class="line-added">2801         push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::IsoSubspace* subspaceFor(JSC::VM&amp; vm) { return subspaceForImpl(vm); }\n&quot;);</span>
<span class="line-added">2802         push(@headerContent, &quot;    static JSC::IsoSubspace* subspaceForImpl(JSC::VM&amp; vm);\n&quot;);</span>
<span class="line-added">2803     }</span>
<span class="line-added">2804 </span>
2805     # visit function
2806     if ($needsVisitChildren) {
2807         push(@headerContent, &quot;    static void visitChildren(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
2808         push(@headerContent, &quot;    void visitAdditionalChildren(JSC::SlotVisitor&amp;);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
2809         push(@headerContent, &quot;\n&quot;);
2810 
2811         if ($interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction}) {
2812             # We assume that the logic in visitAdditionalChildren is highly volatile, and during a
2813             # concurrent GC or in between eden GCs something may happen that would lead to this
2814             # logic behaving differently. Since this could mark objects or add opaque roots, this
2815             # means that after any increment of mutator resumption in a concurrent GC and at least
2816             # once during any eden GC we need to re-execute visitAdditionalChildren on any objects
2817             # that we had executed it on before. We do this using the DOM&#39;s own MarkingConstraint,
2818             # which will call visitOutputConstraints on all objects in the DOM&#39;s own
2819             # outputConstraintSubspace. visitOutputConstraints is the name JSC uses for the method
2820             # that the GC calls to ask an object is it would like to mark anything else after the
2821             # program resumed since the last call to visitChildren or visitOutputConstraints. Since
2822             # this just calls visitAdditionalChildren, you usually don&#39;t have to worry about this.
2823             push(@headerContent, &quot;    static void visitOutputConstraints(JSCell*, JSC::SlotVisitor&amp;);\n&quot;);
<span class="line-modified">2824             if (!IsDOMGlobalObject($interface)) {</span>
<span class="line-modified">2825                 push(@headerContent, &quot;    template&lt;typename, JSC::SubspaceAccess&gt; static JSC::CompleteSubspace* subspaceFor(JSC::VM&amp; vm) { return outputConstraintSubspaceFor(vm); }\n&quot;);</span>
<span class="line-added">2826             }</span>
2827         }
2828     }
2829 
2830     if (NeedsImplementationClass($interface)) {
2831         push(@headerContent, &quot;    static void analyzeHeap(JSCell*, JSC::HeapAnalyzer&amp;);\n&quot;);
2832     }
2833     
2834     if ($numCustomAttributes &gt; 0) {
2835         push(@headerContent, &quot;\n    // Custom attributes\n&quot;);
2836 
2837         foreach my $attribute (@{$interface-&gt;attributes}) {
2838             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
2839             if (HasCustomGetter($attribute)) {
2840                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2841                 my $methodName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;name);
<span class="line-modified">2842                 push(@headerContent, &quot;    JSC::JSValue &quot; . $methodName . &quot;(JSC::JSGlobalObject&amp;) const;\n&quot;);</span>
2843                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2844             }
2845             if (HasCustomSetter($attribute) &amp;&amp; !IsReadonly($attribute)) {
2846                 push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
<span class="line-modified">2847                 push(@headerContent, &quot;    void set&quot; . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name) . &quot;(JSC::JSGlobalObject&amp;, JSC::JSValue);\n&quot;);</span>
2848                 push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2849             }
2850         }
2851     }
2852 
2853     foreach my $operation (@{$interface-&gt;operations}) {
2854         $numCustomOperations++ if HasCustomMethod($operation);
2855         $hasForwardDeclaringOperations = 1 if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2856     }
2857 
2858     if ($numCustomOperations &gt; 0) {
2859         my $inAppleCopyright = 0;
2860         push(@headerContent, &quot;\n    // Custom functions\n&quot;);
2861         foreach my $operation (@{$interface-&gt;operations}) {
2862             next unless HasCustomMethod($operation);
2863             next if $operation-&gt;{overloads} &amp;&amp; $operation-&gt;{overloadIndex} != 1;
2864 
2865             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2866                 if (!$inAppleCopyright) {
2867                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2868                     $inAppleCopyright = 1;
2869                 }
2870             } elsif ($inAppleCopyright) {
2871                 push(@headerContent, $endAppleCopyright);
2872                 $inAppleCopyright = 0;
2873             }
2874 
2875             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
2876             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2877 
2878             my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
2879 
2880             my @functionArguments = ();
<span class="line-modified">2881             push(@functionArguments, &quot;JSC::JSGlobalObject&amp;&quot;);</span>
<span class="line-added">2882             push(@functionArguments, &quot;JSC::CallFrame&amp;&quot;);</span>
2883             push(@functionArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp;&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
2884 
2885             push(@headerContent, &quot;    &quot; . ($operation-&gt;isStatic ? &quot;static &quot; : &quot;&quot;) . &quot;JSC::JSValue &quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @functionArguments) . &quot;);\n&quot;);
2886 
2887             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
2888         }
2889         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
2890     }
2891 
2892     if (NeedsImplementationClass($interface)) {
2893         if ($hasParent) {
2894             push(@headerContent, &quot;    $interfaceName&amp; wrapped() const\n&quot;);
2895             push(@headerContent, &quot;    {\n&quot;);
2896             push(@headerContent, &quot;        return static_cast&lt;$interfaceName&amp;&gt;(Base::wrapped());\n&quot;);
2897             push(@headerContent, &quot;    }\n&quot;);
2898         }
2899     }
2900 
2901     # structure flags
2902     if (%structureFlags) {
2903         push(@headerContent, &quot;public:\n&quot;);
<span class="line-modified">2904         push(@headerContent, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);</span>
2905         foreach my $structureFlag (sort (keys %structureFlags)) {
2906             push(@headerContent, &quot; | &quot; . $structureFlag);
2907         }
2908         push(@headerContent, &quot;;\n&quot;);
2909     }
2910 
2911     push(@headerContent, &quot;protected:\n&quot;);
2912 
2913     # Constructor
2914     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
2915         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;, JSWindowProxy*);\n&quot;);
2916     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
2917         push(@headerContent, &quot;    $className(JSC::VM&amp;, JSC::Structure*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);
2918     } elsif (!NeedsImplementationClass($interface)) {
2919         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;);\n\n&quot;);
2920      } else {
2921         push(@headerContent, &quot;    $className(JSC::Structure*, JSDOMGlobalObject&amp;, Ref&lt;$implType&gt;&amp;&amp;);\n\n&quot;);
2922     }
2923 
2924     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
</pre>
<hr />
<pre>
2943         push(@headerContent, &quot;    virtual bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt;, void* context, JSC::SlotVisitor&amp;, const char**);\n&quot;);
2944         push(@headerContent, &quot;    virtual void finalize(JSC::Handle&lt;JSC::Unknown&gt;, void* context);\n&quot;);
2945         push(@headerContent, &quot;};\n&quot;);
2946         push(@headerContent, &quot;\n&quot;);
2947         push(@headerContent, &quot;inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, $implType*)\n&quot;);
2948         push(@headerContent, &quot;{\n&quot;);
2949         push(@headerContent, &quot;    static NeverDestroyed&lt;JS${interfaceName}Owner&gt; owner;\n&quot;);
2950         push(@headerContent, &quot;    return &amp;owner.get();\n&quot;);
2951         push(@headerContent, &quot;}\n&quot;);
2952         push(@headerContent, &quot;\n&quot;);
2953         push(@headerContent, &quot;inline void* wrapperKey($implType* wrappableObject)\n&quot;);
2954         push(@headerContent, &quot;{\n&quot;);
2955         push(@headerContent, &quot;    return wrappableObject;\n&quot;);
2956         push(@headerContent, &quot;}\n&quot;);
2957         push(@headerContent, &quot;\n&quot;);
2958     }
2959     if (ShouldGenerateToJSDeclaration($hasParent, $interface)) {
2960         # Node and NodeList have custom inline implementations which thus cannot be exported.
2961         # FIXME: The special case for Node and NodeList should probably be implemented via an IDL attribute.
2962         if ($implType eq &quot;Node&quot; or $implType eq &quot;NodeList&quot;) {
<span class="line-modified">2963             push(@headerContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
2964         } else {
<span class="line-modified">2965             push(@headerContent, $exportMacro.&quot;JSC::JSValue toJS(JSC::JSGlobalObject*, JSDOMGlobalObject*, $implType&amp;);\n&quot;);</span>
2966         }
<span class="line-modified">2967         push(@headerContent, &quot;inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, $implType* impl) { return impl ? toJS(lexicalGlobalObject, globalObject, *impl) : JSC::jsNull(); }\n&quot;);</span>
2968 
<span class="line-modified">2969         push(@headerContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject*, Ref&lt;$implType&gt;&amp;&amp;);\n&quot;);</span>
<span class="line-modified">2970         push(@headerContent, &quot;inline JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, RefPtr&lt;$implType&gt;&amp;&amp; impl) { return impl ? toJSNewlyCreated(lexicalGlobalObject, globalObject, impl.releaseNonNull()) : JSC::jsNull(); }\n&quot;);</span>
2971    }
2972 
2973     push(@headerContent, &quot;\n&quot;);
2974 
2975     GeneratePrototypeDeclaration(\@headerContent, $className, $interface) if HeaderNeedsPrototypeDeclaration($interface);
2976 
2977     if ($hasForwardDeclaringOperations) {
2978         my $inAppleCopyright = 0;
2979         push(@headerContent,&quot;// Functions\n\n&quot;);
2980         foreach my $operation (@{$interface-&gt;operations}) {
2981             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
2982             next unless $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
2983 
2984             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
2985                 if (!$inAppleCopyright) {
2986                     push(@headerContent, $beginAppleCopyrightForHeaderFiles);
2987                     $inAppleCopyright = 1;
2988                 }
2989             } elsif ($inAppleCopyright) {
2990                 push(@headerContent, $endAppleCopyright);
2991                 $inAppleCopyright = 0;
2992             }
2993 
2994             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
2995             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
2996             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
2997             my $functionName = GetFunctionName($interface, $className, $operation);
<span class="line-modified">2998             push(@headerContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);</span>
2999             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3000         }
3001 
3002         push(@headerContent, $endAppleCopyright) if $inAppleCopyright;
3003         push(@headerContent,&quot;\n&quot;);
3004     }
3005 
3006     if ($hasForwardDeclaringAttributes) {
3007         push(@headerContent,&quot;// Attributes\n\n&quot;);
3008         foreach my $attribute (@{$interface-&gt;attributes}) {
3009             next unless $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
3010 
3011             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
3012             push(@headerContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
3013             my $getter = GetAttributeGetterName($interface, $className, $attribute);
<span class="line-modified">3014             push(@headerContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
3015             if (!IsReadonly($attribute)) {
3016                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
<span class="line-modified">3017                 push(@headerContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
3018             }
3019             push(@headerContent, &quot;#endif\n&quot;) if $conditionalString;
3020         }
3021     }
3022 
3023     # CheckSubClass Snippet function.
3024     if ($interface-&gt;extendedAttributes-&gt;{DOMJIT}) {
3025         $headerIncludes{&quot;&lt;JavaScriptCore/Snippet.h&gt;&quot;} = 1;
3026         push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3027         push(@headerContent, &quot;Ref&lt;JSC::Snippet&gt; checkSubClassSnippetFor${className}();\n&quot;);
3028         push(@headerContent, &quot;#endif\n&quot;);
3029     }
3030 
3031     if ($hasDOMJITAttributes) {
3032         $headerIncludes{&quot;&lt;JavaScriptCore/DOMJITGetterSetter.h&gt;&quot;} = 1;
3033         push(@headerContent,&quot;// DOM JIT Attributes\n\n&quot;);
3034         foreach my $attribute (@{$interface-&gt;attributes}) {
3035             next unless $attribute-&gt;extendedAttributes-&gt;{DOMJIT};
3036             assert(&quot;Only DOMJIT=Getter is supported for attributes&quot;) unless $codeGenerator-&gt;ExtendedAttributeContains($attribute-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;Getter&quot;);
3037 
3038             my $interfaceName = $interface-&gt;type-&gt;name;
3039             my $className = $interfaceName . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
3040             my $domJITClassName = $className . &quot;Attribute&quot;;
3041 
3042             push(@headerContent, &quot;#if ENABLE(JIT)\n&quot;);
3043             push(@headerContent, &quot;Ref&lt;JSC::DOMJIT::CallDOMGetterSnippet&gt; compile${domJITClassName}();\n&quot;);
3044             push(@headerContent, &quot;#endif\n\n&quot;);
3045         }
3046     }
3047 
3048     if (HasCustomConstructor($interface)) {
3049         push(@headerContent, &quot;// Custom constructor\n&quot;);
<span class="line-modified">3050         push(@headerContent, &quot;JSC::EncodedJSValue construct${className}(JSC::JSGlobalObject*, JSC::CallFrame&amp;);\n\n&quot;);</span>
3051     }
3052 
3053     if (NeedsImplementationClass($interface)) {
3054         my $toWrappedType = $interface-&gt;type-&gt;name eq &quot;XPathNSResolver&quot; ? &quot;RefPtr&lt;${implType}&gt;&quot; : &quot;${implType}*&quot;;
3055         $headerIncludes{&quot;JSDOMWrapper.h&quot;} = 1;
3056 
3057         push(@headerContent, &quot;template&lt;&gt; struct JSDOMWrapperConverterTraits&lt;${implType}&gt; {\n&quot;);
3058         push(@headerContent, &quot;    using WrapperClass = ${className};\n&quot;);
3059         push(@headerContent, &quot;    using ToWrappedReturnType = ${toWrappedType};\n&quot;);
3060         push(@headerContent, &quot;};\n&quot;);
3061     }
3062 
3063     push(@headerContent, GenerateEnumerationsHeaderContent($interface, $enumerations));
3064     push(@headerContent, GenerateDictionariesHeaderContent($interface, $dictionaries));
3065 
3066     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
3067     push(@headerContent, &quot;\n} // namespace WebCore\n&quot;);
3068     push(@headerContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
3069 
3070     if ($interface-&gt;extendedAttributes-&gt;{AppleCopyright}) {
</pre>
<hr />
<pre>
3102     my $className = &quot;JS$interfaceName&quot;;
3103     
3104     # - Add all properties in a hashtable definition
3105     my $propertyCount = $isInstance ? InstancePropertyCount($interface) : PrototypePropertyCount($interface);
3106 
3107     if (!$isInstance &amp;&amp; NeedsConstructorProperty($interface)) {
3108         die if !$propertyCount;
3109         push(@$hashKeys, &quot;constructor&quot;);
3110         my $getter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
3111         push(@$hashValue1, $getter);
3112 
3113         my $setter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
3114         push(@$hashValue2, $setter);
3115         push(@$hashSpecials, &quot;static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum)&quot;);
3116     }
3117 
3118     return 0 if !$propertyCount;
3119 
3120     my @attributes = @{$interface-&gt;attributes};
3121     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
<span class="line-added">3122     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;</span>
3123 
3124     foreach my $attribute (@attributes) {
3125         next if ($attribute-&gt;isStatic);
3126         next if AttributeShouldBeOnInstance($interface, $attribute) != $isInstance;
3127         next if ($attribute-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $attribute-&gt;extendedAttributes-&gt;{PublicIdentifier});
3128 
3129         # Global objects add RuntimeEnabled attributes after creation so do not add them to the static table.
3130         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $attribute)) {
3131             $propertyCount -= 1;
3132             next;
3133         }
3134 
3135         my $name = $attribute-&gt;name;
3136         push(@$hashKeys, $name);
3137 
3138         my $special = GetJSCAttributesForAttribute($interface, $attribute);
3139         push(@$hashSpecials, $special);
3140 
3141         if ($attribute-&gt;extendedAttributes-&gt;{DOMJIT}) {
3142             push(@$hashValue1, &quot;&amp;DOMJITAttributeFor&quot; . $interface-&gt;type-&gt;name . $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name));
3143         } else {
3144             my $getter = GetAttributeGetterName($interface, $className, $attribute);
3145             push(@$hashValue1, $getter);
3146         }
3147 
3148         if (IsReadonly($attribute)) {
3149             push(@$hashValue2, &quot;0&quot;);
3150         } else {
3151             my $setter = GetAttributeSetterName($interface, $className, $attribute);
3152             push(@$hashValue2, $setter);
3153         }
3154 
3155         my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
3156         $conditionals-&gt;{$name} = $conditional if $conditional;
3157         my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
3158         $readWriteConditionals-&gt;{$name} = $readWriteConditional if $readWriteConditional;
3159 
<span class="line-modified">3160         my $needsRuntimeCheck = NeedsRuntimeCheck($interface, $attribute);</span>
<span class="line-added">3161         my $needsRuntimeReadWriteCheck = $attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite};</span>
<span class="line-added">3162 </span>
<span class="line-added">3163         if ($needsRuntimeCheck &amp;&amp; $needsRuntimeReadWriteCheck) {</span>
<span class="line-added">3164             die &quot;Being both runtime enabled and runtime conditionally read-write is not yet supported (used on the &#39;${name}&#39; attribute of &#39;${interfaceName}&#39;).\n&quot;;</span>
<span class="line-added">3165         }</span>
<span class="line-added">3166 </span>
<span class="line-added">3167         if ($needsRuntimeCheck || $needsRuntimeReadWriteCheck) {</span>
3168             push(@$runtimeEnabledAttributes, $attribute);
3169         }
3170     }
3171 
3172     my @operations = @{$interface-&gt;operations};
3173     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3174     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
<span class="line-added">3175     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;</span>
3176     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3177     foreach my $operation (@operations) {
3178         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
3179         next if ($operation-&gt;isStatic);
3180         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
3181         next if OperationShouldBeOnInstance($interface, $operation) != $isInstance;
3182         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
3183 
3184         # Global objects add RuntimeEnabled operations after creation so do not add them to the static table.
3185         if ($isInstance &amp;&amp; NeedsRuntimeCheck($interface, $operation)) {
3186             $propertyCount -= 1;
3187             next;
3188         }
3189 
3190         my $name = $operation-&gt;name;
3191         push(@$hashKeys, $name);
3192 
3193         my $functionName = GetFunctionName($interface, $className, $operation);
3194         push(@$hashValue1, $functionName);
3195 
</pre>
<hr />
<pre>
3451     };
3452     my $isBooleanParameter = sub {
3453         my ($type, $optionality) = @_;
3454         return $type-&gt;name eq &quot;boolean&quot;;
3455     };
3456     my $isNumericParameter = sub {
3457         my ($type, $optionality) = @_;
3458         return $codeGenerator-&gt;IsNumericType($type);
3459     };
3460     my $isStringOrEnumParameter = sub {
3461         my ($type, $optionality) = @_;
3462         return $codeGenerator-&gt;IsStringOrEnumType($type);
3463     };
3464     my $isAnyParameter = sub {
3465         my ($type, $optionality) = @_;
3466         return $type-&gt;name eq &quot;any&quot;;
3467     };
3468 
3469     my $maxArgCount = LengthOfLongestOperationParameterList($operation-&gt;{overloads});
3470 
<span class="line-modified">3471     push(@implContent, &quot;    size_t argsCount = std::min&lt;size_t&gt;(${maxArgCount}, callFrame-&gt;argumentCount());\n&quot;);</span>
3472 
3473     for my $length ( sort keys %allSets ) {
3474         push(@implContent, &quot;    if (argsCount == ${length}) {\n&quot;);
3475 
3476         my $S = $allSets{$length};
3477         if (scalar(@$S) &gt; 1) {
3478             my $d = GetDistinguishingArgumentIndex($operation, $S);
<span class="line-modified">3479             push(@implContent, &quot;        JSValue distinguishingArg = callFrame-&gt;uncheckedArgument($d);\n&quot;);</span>
3480 
3481             my $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isOptionalParameter);
3482             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefined()&quot;);
3483 
3484             $overload = GetOverloadThatMatchesIgnoringUnionSubtypes($S, $d, \&amp;$isNullableOrDictionaryOrRecordOrUnionContainingOne);
3485             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isUndefinedOrNull()&quot;);
3486 
3487             for my $tuple (@{$S}) {
3488                 my $overload = @{$tuple}[0];
3489                 my $type = @{@{$tuple}[1]}[$d];
3490 
3491                 my @subtypes = $type-&gt;isUnion ? GetFlattenedMemberTypes($type) : ( $type );
3492                 for my $subtype (@subtypes) {
3493                     if ($codeGenerator-&gt;IsWrapperType($subtype) || $codeGenerator-&gt;IsBufferSourceType($subtype)) {
3494                         if ($subtype-&gt;name eq &quot;DOMWindow&quot;) {
3495                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3496                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSDOMWindow&gt;(vm))&quot;);
3497                         } elsif ($subtype-&gt;name eq &quot;RemoteDOMWindow&quot;) {
3498                             AddToImplIncludes(&quot;JSWindowProxy.h&quot;);
3499                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; (asObject(distinguishingArg)-&gt;inherits&lt;JSWindowProxy&gt;(vm) || asObject(distinguishingArg)-&gt;inherits&lt;JSRemoteDOMWindow&gt;(vm))&quot;);
3500                         } else {
3501                             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JS&quot; . $subtype-&gt;name . &quot;&gt;(vm)&quot;);
3502                         }
3503                     }
3504                 }
3505             }
3506 
3507             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorOrDOMExceptionParameter);
3508             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;inherits&lt;JSDOMException&gt;(vm)&quot;);
3509 
3510             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrErrorParameter);
3511             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject() &amp;&amp; asObject(distinguishingArg)-&gt;type() == ErrorInstanceType&quot;);
3512 
3513             $overload = GetOverloadThatMatches($S, $d, \&amp;$isObjectOrCallbackFunctionParameter);
3514             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isFunction(vm)&quot;);
3515 
3516             # FIXME: Avoid invoking GetMethod(object, Symbol.iterator) again in convert&lt;IDLSequence&lt;T&gt;&gt;(...).
3517             $overload = GetOverloadThatMatches($S, $d, \&amp;$isSequenceOrFrozenArrayParameter);
<span class="line-modified">3518             &amp;$generateOverloadCallIfNecessary($overload, &quot;hasIteratorMethod(lexicalGlobalObject, distinguishingArg)&quot;, &quot;&lt;JavaScriptCore/IteratorOperations.h&gt;&quot;);</span>
3519 
3520             $overload = GetOverloadThatMatches($S, $d, \&amp;$isDictionaryOrRecordOrObjectOrCallbackInterfaceParameter);
3521             &amp;$generateOverloadCallIfNecessary($overload, &quot;distinguishingArg.isObject()&quot;);
3522 
3523             my $booleanOverload = GetOverloadThatMatches($S, $d, \&amp;$isBooleanParameter);
3524             &amp;$generateOverloadCallIfNecessary($booleanOverload, &quot;distinguishingArg.isBoolean()&quot;);
3525 
3526             my $numericOverload = GetOverloadThatMatches($S, $d, \&amp;$isNumericParameter);
3527             &amp;$generateOverloadCallIfNecessary($numericOverload, &quot;distinguishingArg.isNumber()&quot;);
3528 
3529             # Fallbacks.
3530             $overload = GetOverloadThatMatches($S, $d, \&amp;$isStringOrEnumParameter);
3531             if ($overload) {
3532                 &amp;$generateOverloadCallIfNecessary($overload);
3533             } elsif ($numericOverload) {
3534                 &amp;$generateOverloadCallIfNecessary($numericOverload);
3535             } elsif ($booleanOverload) {
3536                 &amp;$generateOverloadCallIfNecessary($booleanOverload);
3537             } else {
3538                 $overload = GetOverloadThatMatches($S, $d, \&amp;$isAnyParameter);
3539                 &amp;$generateOverloadCallIfNecessary($overload);
3540             }
3541         } else {
3542             # Only 1 overload with this number of parameters.
3543             my $overload = @{@{$S}[0]}[0];
3544             &amp;$generateOverloadCallIfNecessary($overload);
3545         }
3546         push(@implContent, &lt;&lt;END);
3547     }
3548 END
3549     }
3550     my $minArgCount = GetFunctionLength($operation);
3551     if ($minArgCount &gt; 0) {
<span class="line-modified">3552         push(@implContent, &quot;    return argsCount &lt; $minArgCount ? throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject)) : throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)</span>
3553     } else {
<span class="line-modified">3554         push(@implContent, &quot;    return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;)</span>
3555     }
3556 }
3557 
3558 # As per Web IDL specification, the length of a function Object is its number of mandatory parameters.
3559 sub GetFunctionLength
3560 {
3561     my $operation = shift;
3562 
3563     my $getOverloadLength = sub {
3564         my $operation = shift;
3565 
3566         my $length = 0;
3567         foreach my $argument (@{$operation-&gt;arguments}) {
3568             last if $argument-&gt;isOptional || $argument-&gt;isVariadic;
3569             $length++;
3570         }
3571         return $length;
3572     };
3573 
3574     my $length = &amp;$getOverloadLength($operation);
</pre>
<hr />
<pre>
3688 sub GetImplementationLacksVTableForInterface
3689 {
3690     my $interface = shift;
3691     return $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
3692 }
3693 
3694 sub GetSkipVTableValidationForInterface
3695 {
3696     my $interface = shift;
3697     return $interface-&gt;extendedAttributes-&gt;{SkipVTableValidation};
3698 }
3699 
3700 # URL becomes url, but SetURL becomes setURL.
3701 sub ToMethodName
3702 {
3703     my $param = shift;
3704     my $ret = lcfirst($param);
3705     $ret =~ s/cSS/css/ if $ret =~ /^cSS/;
3706     $ret =~ s/dOM/dom/ if $ret =~ /^dOM/;
3707     $ret =~ s/hTML/html/ if $ret =~ /^hTML/;
<span class="line-added">3708     $ret =~ s/hDR/hdr/ if $ret =~ /^hDR/;</span>
3709     $ret =~ s/jS/js/ if $ret =~ /^jS/;
3710     $ret =~ s/uRL/url/ if $ret =~ /^uRL/;
3711     $ret =~ s/xML/xml/ if $ret =~ /^xML/;
3712     $ret =~ s/xSLT/xslt/ if $ret =~ /^xSLT/;
3713 
3714     # For HTML5 FileSystem API Flags attributes.
3715     # (create is widely used to instantiate an object and must be avoided.)
3716     $ret =~ s/^create/isCreate/ if $ret =~ /^create$/;
3717     $ret =~ s/^exclusive/isExclusive/ if $ret =~ /^exclusive$/;
3718 
3719     return $ret;
3720 }
3721 
3722 sub GenerateRuntimeEnableConditionalStringForExposed
3723 {
3724     my ($interface, $context, $conjuncts, $globalObjectIsParam) = @_;
3725 
3726     assert(&quot;Must specify value for Exposed.&quot;) if $context-&gt;extendedAttributes-&gt;{Exposed} eq &quot;VALUE_IS_MISSING&quot;;
3727 
3728     AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
</pre>
<hr />
<pre>
3741         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isDocument()&quot;);
3742     } elsif ($exposed eq &quot;Worker&quot;) {
3743         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkerGlobalScope()&quot;);
3744     } elsif ($exposed eq &quot;Worklet&quot;) {
3745         push(@$conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isWorkletGlobalScope()&quot;);
3746     } else {
3747         assert(&quot;Unrecognized value &#39;&quot; . Dumper($context-&gt;extendedAttributes-&gt;{Exposed}) . &quot;&#39; for the Exposed extended attribute on &#39;&quot; . ref($context) . &quot;&#39;.&quot;);
3748     }
3749 }
3750 
3751 # Returns the conditional string that determines whether a method/attribute is enabled at runtime.
3752 # A method/attribute is enabled at runtime if either its RuntimeEnabledFeatures function returns
3753 # true or its EnabledForWorld function returns true (or both).
3754 # NOTE: Parameter passed in must have an &#39;extendedAttributes&#39; property.
3755 # (e.g. IDLInterface, IDLAttribute, IDLOperation, IDLIterable, etc.)
3756 sub GenerateRuntimeEnableConditionalString
3757 {
3758     my ($interface, $context, $globalObjectIsParam) = @_;
3759 
3760     my @conjuncts;
<span class="line-modified">3761     my $globalObjectPtr = $globalObjectIsParam ? $globalObjectIsParam : &quot;globalObject()&quot;;</span>
3762     
3763     if ($context-&gt;extendedAttributes-&gt;{SecureContext}) {
3764         AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3765 
3766         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3767             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3768                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme())&quot;);
3769         } elsif ($context-&gt;extendedAttributes-&gt;{ContextAllowsMediaDevices}) {
3770             push(@conjuncts, &quot;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;
3771                 . &quot;|| jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;allowsMediaDevices())&quot;);
3772         } else {
3773             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(globalObject())-&gt;scriptExecutionContext()-&gt;isSecureContext()&quot;);
3774         }
3775     } else {
3776         if ($context-&gt;extendedAttributes-&gt;{ContextHasServiceWorkerScheme}) {
3777             AddToImplIncludes(&quot;ScriptExecutionContext.h&quot;);
3778 
3779             push(@conjuncts, &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()-&gt;hasServiceWorkerScheme()&quot;);
3780         }
3781     }
</pre>
<hr />
<pre>
3821 
3822         assert(&quot;DisabledByQuirk can only be used by interfaces only exposed to the Window&quot;) if $interface-&gt;extendedAttributes-&gt;{Exposed} &amp;&amp; $interface-&gt;extendedAttributes-&gt;{Exposed} ne &quot;Window&quot;;
3823 
3824         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{DisabledByQuirk});
3825         foreach my $flag (@flags) {
3826             push(@conjuncts, &quot;!downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;quirks().&quot; . ToMethodName($flag) . &quot;Quirk()&quot;);
3827         }
3828     }
3829 
3830     if ($context-&gt;extendedAttributes-&gt;{EnabledAtRuntime}) {
3831         assert(&quot;Must specify value for EnabledAtRuntime.&quot;) if $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime} eq &quot;VALUE_IS_MISSING&quot;;
3832 
3833         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);
3834 
3835         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{EnabledAtRuntime});
3836         foreach my $flag (@flags) {
3837             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);
3838         }
3839     }
3840 
<span class="line-added">3841     if ($context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {</span>
<span class="line-added">3842         assert(&quot;Must specify value for RuntimeConditionallyReadWrite.&quot;) if $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite} eq &quot;VALUE_IS_MISSING&quot;;</span>
<span class="line-added">3843 </span>
<span class="line-added">3844         AddToImplIncludes(&quot;RuntimeEnabledFeatures.h&quot;);</span>
<span class="line-added">3845 </span>
<span class="line-added">3846         my @flags = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite});</span>
<span class="line-added">3847         foreach my $flag (@flags) {</span>
<span class="line-added">3848             push(@conjuncts, &quot;RuntimeEnabledFeatures::sharedFeatures().&quot; . ToMethodName($flag) . &quot;Enabled()&quot;);</span>
<span class="line-added">3849         }</span>
<span class="line-added">3850     }</span>
<span class="line-added">3851 </span>
3852     if ($context-&gt;extendedAttributes-&gt;{EnabledForContext}) {
3853         assert(&quot;Must not specify value for EnabledForContext.&quot;) unless $context-&gt;extendedAttributes-&gt;{EnabledForContext} eq &quot;VALUE_IS_MISSING&quot;;
3854         assert(&quot;EnabledForContext must be an interface or constructor attribute.&quot;) unless $codeGenerator-&gt;IsConstructorType($context-&gt;type);
3855 
3856         my $contextRef = &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext()&quot;;
3857         my $name = $context-&gt;name;
3858         push(@conjuncts,  &quot;${name}::enabledForContext(&quot; . $contextRef . &quot;)&quot;);
3859     }
3860 
<span class="line-added">3861     if ($context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {</span>
<span class="line-added">3862         assert(&quot;Must specify value for ConstructorEnabledBySetting.&quot;) if $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting} eq &quot;VALUE_IS_MISSING&quot;;</span>
<span class="line-added">3863 </span>
<span class="line-added">3864         my @settings = split(/&amp;/, $context-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting});</span>
<span class="line-added">3865         foreach my $setting (@settings) {</span>
<span class="line-added">3866             push(@conjuncts, &quot;downcast&lt;Document&gt;(jsCast&lt;JSDOMGlobalObject*&gt;(&quot; . $globalObjectPtr . &quot;)-&gt;scriptExecutionContext())-&gt;settings().&quot; . ToMethodName($setting) . &quot;Enabled()&quot;);</span>
<span class="line-added">3867         }</span>
<span class="line-added">3868     }</span>
<span class="line-added">3869 </span>
3870     my $result = join(&quot; &amp;&amp; &quot;, @conjuncts);
3871     $result = &quot;($result)&quot; if @conjuncts &gt; 1;
3872     return $result;
3873 }
3874 
3875 sub GetCastingHelperForThisObject
3876 {
3877     my $interface = shift;
3878     my $interfaceName = $interface-&gt;type-&gt;name;
3879     return &quot;jsDynamicCast&lt;JS$interfaceName*&gt;&quot;;
3880 }
3881 
3882 # http://heycam.github.io/webidl/#Unscopable
3883 sub addUnscopableProperties
3884 {
3885     my $interface = shift;
3886 
3887     my @unscopables;
3888     foreach my $operationOrAttribute (@{$interface-&gt;operations}, @{$interface-&gt;attributes}) {
3889         push(@unscopables, $operationOrAttribute-&gt;name) if $operationOrAttribute-&gt;extendedAttributes-&gt;{Unscopable};
3890     }
3891     return if scalar(@unscopables) == 0;
3892 
3893     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
<span class="line-modified">3894     push(@implContent, &quot;    JSObject&amp; unscopables = *constructEmptyObject(globalObject()-&gt;vm(), globalObject()-&gt;nullPrototypeObjectStructure());\n&quot;);</span>
3895     foreach my $unscopable (@unscopables) {
3896         push(@implContent, &quot;    unscopables.putDirect(vm, Identifier::fromString(vm, \&quot;$unscopable\&quot;), jsBoolean(true));\n&quot;);
3897     }
3898     push(@implContent, &quot;    putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, &amp;unscopables, JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);\n&quot;);
3899 }
3900 
3901 sub GetArgumentTypeForFunctionWithoutTypeCheck
3902 {
3903     my ($interface, $type) = @_;
3904 
3905     my $IDLType = GetIDLType($interface, $type);
3906     return &quot;DOMJIT::IDLJSArgumentType&lt;${IDLType}&gt;&quot;;
3907 }
3908 
3909 sub GetArgumentTypeFilter
3910 {
3911     my ($interface, $type) = @_;
3912 
3913     my $IDLType = GetIDLType($interface, $type);
3914     return &quot;DOMJIT::IDLArgumentTypeFilter&lt;${IDLType}&gt;::value&quot;;
</pre>
<hr />
<pre>
3919     my ($interface, $type) = @_;
3920 
3921     my $IDLType = GetIDLType($interface, $type);
3922     return &quot;DOMJIT::IDLResultTypeFilter&lt;${IDLType}&gt;::value&quot;;
3923 }
3924 
3925 sub GetAttributeWithName
3926 {
3927     my ($interface, $attributeName) = @_;
3928     
3929     foreach my $attribute (@{$interface-&gt;attributes}) {
3930         return $attribute if $attribute-&gt;name eq $attributeName;
3931     }
3932 }
3933 
3934 # https://heycam.github.io/webidl/#es-iterator
3935 sub InterfaceNeedsIterator
3936 {
3937     my ($interface) = @_;
3938 
<span class="line-modified">3939     return 1 if $interface-&gt;setLike;</span>
3940     return 1 if $interface-&gt;mapLike;
3941     return 1 if $interface-&gt;iterable;
3942 
3943     if (GetIndexedGetterOperation($interface)) {
3944         my $lengthAttribute = GetAttributeWithName($interface, &quot;length&quot;);
3945         return 1 if $lengthAttribute and $codeGenerator-&gt;IsIntegerType($lengthAttribute-&gt;type);
3946     }
3947     return 0;
3948 }
3949 
3950 sub GenerateImplementation
3951 {
3952     my ($object, $interface, $enumerations, $dictionaries) = @_;
3953 
3954     my $interfaceName = $interface-&gt;type-&gt;name;
3955     my $className = &quot;JS$interfaceName&quot;;
3956 
3957     my $hasParent = $interface-&gt;parentType || $interface-&gt;extendedAttributes-&gt;{JSLegacyParent};
3958     my $parentClassName = GetParentClassName($interface);
3959     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
3960     my $needsVisitChildren = InstanceNeedsVisitChildren($interface);
3961 
3962     my $namedGetterOperation = GetNamedGetterOperation($interface);
3963     my $indexedGetterOperation = GetIndexedGetterOperation($interface);
3964 
3965     # - Add default header template
3966     push(@implContentHeader, GenerateImplementationContentHeader($interface));
3967 
3968     AddToImplIncludes(&quot;&lt;JavaScriptCore/JSCInlines.h&gt;&quot;);
3969     AddToImplIncludes(&quot;JSDOMBinding.h&quot;);
3970     AddToImplIncludes(&quot;JSDOMExceptionHandling.h&quot;);
3971     AddToImplIncludes(&quot;JSDOMWrapperCache.h&quot;);
3972     AddToImplIncludes(&quot;&lt;wtf/GetPtr.h&gt;&quot;);
3973     AddToImplIncludes(&quot;&lt;wtf/PointerPreparations.h&gt;&quot;);
3974     AddToImplIncludes(&quot;&lt;JavaScriptCore/PropertyNameArray.h&gt;&quot;) if $indexedGetterOperation;
3975     AddToImplIncludes(&quot;JSDOMMapLike.h&quot;) if $interface-&gt;mapLike;
<span class="line-added">3976     AddToImplIncludes(&quot;JSDOMSetLike.h&quot;) if $interface-&gt;setLike;</span>
3977     AddJSBuiltinIncludesIfNeeded($interface);
3978 
3979     my $implType = GetImplClassName($interface);
3980 
3981     @implContent = ();
3982 
3983     push(@implContent, &quot;\n\nnamespace WebCore {\n&quot;);
3984     push(@implContent, &quot;using namespace JSC;\n\n&quot;);
3985 
3986     push(@implContent, GenerateEnumerationsImplementationContent($interface, $enumerations));
3987     push(@implContent, GenerateDictionariesImplementationContent($interface, $dictionaries));
3988 
3989     my @operations = @{$interface-&gt;operations};
3990     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
3991     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
<span class="line-added">3992     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;</span>
3993     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
3994 
3995     my @attributes = @{$interface-&gt;attributes};
3996     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
<span class="line-added">3997     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;</span>
3998 
3999     my $numConstants = @{$interface-&gt;constants};
4000     my $numOperations = @operations;
4001     my $numAttributes = @attributes;
4002 
4003     if ($numOperations &gt; 0) {
4004         my $inAppleCopyright = 0;
4005         push(@implContent,&quot;// Functions\n\n&quot;);
4006         foreach my $operation (@operations) {
4007             next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
4008             next if $operation-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4009             next if IsJSBuiltin($interface, $operation);
4010 
4011             if ($operation-&gt;extendedAttributes-&gt;{AppleCopyright}) {
4012                 if (!$inAppleCopyright) {
4013                     push(@implContent, $beginAppleCopyrightForHeaderFiles);
4014                     $inAppleCopyright = 1;
4015                 }
4016             } elsif ($inAppleCopyright) {
4017                 push(@implContent, $endAppleCopyright);
4018                 $inAppleCopyright = 0;
4019             }
4020 
4021             my $conditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
4022             my $conditionalString = $conditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditionalAttribute) : undef;
4023             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4024             my $functionName = GetFunctionName($interface, $className, $operation);
<span class="line-modified">4025             push(@implContent, &quot;JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject*, JSC::CallFrame*);\n&quot;);</span>
4026             if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
4027                 $implIncludes{&quot;DOMJITIDLType.h&quot;} = 1;
4028                 my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
<span class="line-modified">4029                 my $functionSignature = &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject*, $className*&quot;;</span>
4030                 foreach my $argument (@{$operation-&gt;arguments}) {
4031                     my $type = $argument-&gt;type;
4032                     my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
4033                     $functionSignature .= &quot;, ${argumentType}&quot;;
4034                 }
4035                 push(@implContent, $functionSignature . &quot;);\n&quot;);
4036             }
4037             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4038         }
4039 
4040         push(@implContent, $endAppleCopyright) if $inAppleCopyright;
4041         push(@implContent, &quot;\n&quot;);
4042     }
4043 
4044     if ($numAttributes &gt; 0 || NeedsConstructorProperty($interface)) {
4045         push(@implContent, &quot;// Attributes\n\n&quot;);
4046 
4047         if (NeedsConstructorProperty($interface)) {
4048             my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
<span class="line-modified">4049             push(@implContent, &quot;JSC::EncodedJSValue ${constructorGetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
4050 
4051             my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
<span class="line-modified">4052             push(@implContent, &quot;bool ${constructorSetter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
4053         }
4054 
4055         foreach my $attribute (@attributes) {
4056             next if $attribute-&gt;extendedAttributes-&gt;{ForwardDeclareInHeader};
4057             next if IsJSBuiltin($interface, $attribute);
4058 
4059             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4060             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4061             my $getter = GetAttributeGetterName($interface, $className, $attribute);
<span class="line-modified">4062             push(@implContent, &quot;JSC::EncodedJSValue ${getter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::PropertyName);\n&quot;);</span>
4063             if (!IsReadonly($attribute)) {
4064                 my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
4065                 if ($readWriteConditional) {
4066                     my $readWriteConditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
4067                     push(@implContent, &quot;#if ${readWriteConditionalString}\n&quot;);
4068                 }
4069                 my $setter = GetAttributeSetterName($interface, $className, $attribute);
<span class="line-modified">4070                 push(@implContent, &quot;bool ${setter}(JSC::JSGlobalObject*, JSC::EncodedJSValue, JSC::EncodedJSValue);\n&quot;);</span>
4071                 push(@implContent, &quot;#endif\n&quot;) if $readWriteConditional;
4072             }
4073             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4074         }
4075 
4076         push(@implContent, &quot;\n&quot;);
4077     }
4078 
4079     if ($numOperations &gt; 0) {
4080         foreach my $operation (@operations) {
4081             next unless $operation-&gt;extendedAttributes-&gt;{DOMJIT};
4082             $implIncludes{&quot;DOMJITIDLTypeFilter.h&quot;} = 1;
4083             $implIncludes{&quot;DOMJITAbstractHeapRepository.h&quot;} = 1;
4084 
4085             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
4086             die &quot;Overloads is not supported in DOMJIT&quot; if $isOverloaded;
4087             die &quot;Currently ReadDOM value is only allowed&quot; unless $codeGenerator-&gt;ExtendedAttributeContains($operation-&gt;extendedAttributes-&gt;{DOMJIT}, &quot;ReadDOM&quot;);
4088 
4089             my $interfaceName = $interface-&gt;type-&gt;name;
4090             my $functionName = GetFunctionName($interface, $className, $operation);
</pre>
<hr />
<pre>
4285         push(@hashValue1, $constant-&gt;value);
4286         push(@hashValue2, &quot;0&quot;);
4287         push(@hashSpecials, &quot;JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::ConstantInteger&quot;);
4288 
4289         my $conditional = $constant-&gt;extendedAttributes-&gt;{Conditional};
4290         $conditionals{$name} = $conditional if $conditional;
4291 
4292         $hashSize++;
4293     }
4294 
4295     my $justGenerateValueArray = !IsDOMGlobalObject($interface);
4296 
4297     $object-&gt;GenerateHashTable($className, $hashName, $hashSize, \@hashKeys, \@hashSpecials, \@hashValue1, \@hashValue2, \%conditionals, \%readWriteConditionals, $justGenerateValueArray);
4298 
4299     if ($justGenerateValueArray) {
4300         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4301     } else {
4302         push(@implContent, &quot;const ClassInfo ${className}Prototype::s_info = { \&quot;${visibleInterfaceName}Prototype\&quot;, &amp;Base::s_info, &amp;${className}PrototypeTable, nullptr, CREATE_METHOD_TABLE(${className}Prototype) };\n\n&quot;);
4303     }
4304 
<span class="line-modified">4305     if (PrototypeHasStaticPropertyTable($interface) &amp;&amp; !IsGlobalInterface($interface)) {</span>
4306         push(@implContent, &quot;void ${className}Prototype::finishCreation(VM&amp; vm)\n&quot;);
4307         push(@implContent, &quot;{\n&quot;);
4308         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4309         push(@implContent, &quot;    reifyStaticProperties(vm, ${className}::info(), ${className}PrototypeTableValues, *this);\n&quot;);
4310 
4311         my @runtimeEnabledProperties = @runtimeEnabledOperations;
4312         push(@runtimeEnabledProperties, @runtimeEnabledAttributes);
4313 
4314         if (@runtimeEnabledProperties) {
4315             push(@implContent, &quot;    bool hasDisabledRuntimeProperties = false;\n&quot;);
4316         }
4317 
4318         foreach my $operationOrAttribute (@runtimeEnabledProperties) {
4319             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
4320             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4321             my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute);
4322             my $name = $operationOrAttribute-&gt;name;
4323             push(@implContent, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
4324             push(@implContent, &quot;        hasDisabledRuntimeProperties = true;\n&quot;);
4325             push(@implContent, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
4326             push(@implContent, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
<span class="line-modified">4327             push(@implContent, &quot;        JSObject::deleteProperty(this, globalObject(), propertyName);\n&quot;);</span>
4328             push(@implContent, &quot;    }\n&quot;);
4329             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4330         }
4331 
<span class="line-added">4332         foreach my $attribute (@runtimeEnabledAttributes) {</span>
<span class="line-added">4333             if ($attribute-&gt;extendedAttributes-&gt;{RuntimeConditionallyReadWrite}) {</span>
<span class="line-added">4334                 AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);</span>
<span class="line-added">4335                 my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);</span>
<span class="line-added">4336 </span>
<span class="line-added">4337                 my $attributeName = $attribute-&gt;name;</span>
<span class="line-added">4338                 my $getter = GetAttributeGetterName($interface, $className, $attribute);</span>
<span class="line-added">4339                 my $setter = &quot;nullptr&quot;;</span>
<span class="line-added">4340                 my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);</span>
<span class="line-added">4341 </span>
<span class="line-added">4342                 my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);</span>
<span class="line-added">4343                 push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;</span>
<span class="line-added">4344                 push(@implContent, &quot;    // Adding back attribute, but as readonly, after removing the read-write variant above. \n&quot;);</span>
<span class="line-added">4345                 push(@implContent, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);</span>
<span class="line-added">4346                 push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);</span>
<span class="line-added">4347                 push(@implContent, &quot;#endif\n&quot;) if $conditionalString;</span>
<span class="line-added">4348             }</span>
<span class="line-added">4349         }</span>
<span class="line-added">4350 </span>
4351         if (@runtimeEnabledProperties) {
4352             push(@implContent, &quot;    if (hasDisabledRuntimeProperties &amp;&amp; structure()-&gt;isDictionary())\n&quot;);
4353             push(@implContent, &quot;        flattenDictionaryObject(vm);\n&quot;);
4354         }
4355 
4356         foreach my $operation (@{$interface-&gt;operations}) {
4357             next unless ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier});
4358             AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4359             my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operation);
4360             push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4361             push(@implContent, &quot;    putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $operation-&gt;name . &quot;PrivateName(), JSFunction::create(vm, globalObject(), 0, String(), &quot; . GetFunctionName($interface, $className, $operation) . &quot;), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4362             push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4363         }
4364 
4365         if (InterfaceNeedsIterator($interface)) {
4366             AddToImplIncludes(&quot;&lt;JavaScriptCore/BuiltinNames.h&gt;&quot;);
<span class="line-modified">4367             if (IsKeyValueIterableInterface($interface) or $interface-&gt;mapLike or $interface-&gt;setLike) {</span>
4368                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4369             } else {
4370                 AddToImplIncludes(&quot;&lt;JavaScriptCore/ArrayPrototype.h&gt;&quot;);
4371                 push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;iteratorSymbol, globalObject()-&gt;arrayPrototype()-&gt;getDirect(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName()), static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4372             }
4373         }
4374         push(@implContent, &quot;    addValueIterableMethods(*globalObject(), *this);\n&quot;) if $interface-&gt;iterable and !IsKeyValueIterableInterface($interface);
4375 
4376         addUnscopableProperties($interface);
4377 
4378         push(@implContent, &quot;}\n\n&quot;);
4379     }
4380 
4381     # - Initialize static ClassInfo object
4382     push(@implContent, &quot;const ClassInfo $className&quot; . &quot;::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, &quot;);
4383 
4384     if ($numInstanceProperties &gt; 0) {
4385         push(@implContent, &quot;&amp;${className}Table&quot;);
4386     } else {
4387         push(@implContent, &quot;nullptr&quot;);
</pre>
<hr />
<pre>
4420         push(@implContent, &quot;{\n&quot;);
4421         push(@implContent, &quot;}\n\n&quot;);
4422     }
4423 
4424     # Finish Creation
4425     if ($interfaceName eq &quot;DOMWindow&quot; || $interfaceName eq &quot;RemoteDOMWindow&quot;) {
4426         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSWindowProxy* proxy)\n&quot;);
4427         push(@implContent, &quot;{\n&quot;);
4428         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4429     } elsif ($codeGenerator-&gt;InheritsInterface($interface, &quot;WorkerGlobalScope&quot;) || $codeGenerator-&gt;InheritsInterface($interface, &quot;WorkletGlobalScope&quot;)) {
4430         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm, JSProxy* proxy)\n&quot;);
4431         push(@implContent, &quot;{\n&quot;);
4432         push(@implContent, &quot;    Base::finishCreation(vm, proxy);\n\n&quot;);
4433     } else {
4434         push(@implContent, &quot;void ${className}::finishCreation(VM&amp; vm)\n&quot;);
4435         push(@implContent, &quot;{\n&quot;);
4436         push(@implContent, &quot;    Base::finishCreation(vm);\n&quot;);
4437         push(@implContent, &quot;    ASSERT(inherits(vm, info()));\n\n&quot;);
4438     }
4439 
<span class="line-added">4440     if (!$codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;JSBuiltin&quot;)) {</span>
<span class="line-added">4441         AddToImplIncludes(&quot;ActiveDOMObject.h&quot;);</span>
<span class="line-added">4442         if ($codeGenerator-&gt;InheritsExtendedAttribute($interface, &quot;ActiveDOMObject&quot;)) {</span>
<span class="line-added">4443             push(@implContent, &quot;    static_assert(std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is marked as [ActiveDOMObject] but implementation class does not subclass ActiveDOMObject.\&quot;);\n\n&quot;);</span>
<span class="line-added">4444         } else {</span>
<span class="line-added">4445             push(@implContent, &quot;    static_assert(!std::is_base_of&lt;ActiveDOMObject, ${implType}&gt;::value, \&quot;Interface is not marked as [ActiveDOMObject] even though implementation class subclasses ActiveDOMObject.\&quot;);\n\n&quot;);</span>
<span class="line-added">4446         }</span>
<span class="line-added">4447     }</span>
<span class="line-added">4448 </span>
4449     if ($interfaceName eq &quot;Location&quot;) {
4450         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;valueOf, globalObject()-&gt;objectProtoValueOfFunction(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4451         push(@implContent, &quot;    putDirect(vm, vm.propertyNames-&gt;toPrimitiveSymbol, jsUndefined(), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
4452     }
4453 




4454     # Support for RuntimeEnabled attributes on instances.
4455     foreach my $attribute (@{$interface-&gt;attributes}) {
4456         next unless NeedsRuntimeCheck($interface, $attribute);
4457         next unless AttributeShouldBeOnInstance($interface, $attribute);
4458 
4459         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);
4460         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $attribute);
4461         my $attributeName = $attribute-&gt;name;
4462         my $getter = GetAttributeGetterName($interface, $className, $attribute);
4463         my $setter = IsReadonly($attribute) ? &quot;nullptr&quot; : GetAttributeSetterName($interface, $className, $attribute);
4464         my $jscAttributes = GetJSCAttributesForAttribute($interface, $attribute);
4465 
4466         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4467         push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
4468         push(@implContent, &quot;    if (${runtimeEnableConditionalString})\n&quot;);
4469         push(@implContent, &quot;        putDirectCustomAccessor(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().&quot; . $attributeName . &quot;PublicName(), CustomGetterSetter::create(vm, $getter, $setter), attributesForStructure($jscAttributes));\n&quot;);
4470         push(@implContent, &quot;#endif\n&quot;) if $conditionalString;
4471     }
4472 
4473     # Support PrivateIdentifier attributes on instances.
</pre>
<hr />
<pre>
4566     }
4567     
4568     if (InstanceOverridesDefineOwnProperty($interface)) {
4569         GenerateDefineOwnProperty(\@implContent, $interface, $className);
4570     }
4571 
4572     if (InstanceOverridesDeleteProperty($interface)) {
4573         GenerateNamedDeleterDefinition(\@implContent, $interface, $className);
4574     }
4575     
4576     if (InstanceOverridesGetCallData($interface)) {
4577         GenerateGetCallData(\@implContent, $interface, $className);
4578     }
4579     
4580     if ($numAttributes &gt; 0) {
4581         AddToImplIncludes(&quot;JSDOMAttribute.h&quot;);
4582 
4583         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
4584         # FIXME: Remove ImplicitThis keyword as it is no longer defined by WebIDL spec and is only used in DOMWindow.
4585         if ($interface-&gt;extendedAttributes-&gt;{ImplicitThis}) {
<span class="line-modified">4586             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);</span>
4587             push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4588             push(@implContent, &quot;    VM&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);</span>
4589             push(@implContent, &quot;    auto decodedThisValue = JSValue::decode(thisValue);\n&quot;);
4590             push(@implContent, &quot;    if (decodedThisValue.isUndefinedOrNull())\n&quot;);
<span class="line-modified">4591             push(@implContent, &quot;        decodedThisValue = JSValue(&amp;lexicalGlobalObject).toThis(&amp;lexicalGlobalObject, NotStrictMode);\n&quot;);</span>
<span class="line-modified">4592             push(@implContent, &quot;    return $castingFunction(vm, decodedThisValue);\n&quot;);</span>
4593             push(@implContent, &quot;}\n\n&quot;);
4594         } else {
<span class="line-modified">4595             push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLAttribute&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, EncodedJSValue thisValue)\n&quot;);</span>
4596             push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4597             push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), JSValue::decode(thisValue));\n&quot;);</span>
4598             push(@implContent, &quot;}\n\n&quot;);
4599         }
4600     }
4601 
4602     if ($numOperations &gt; 0 &amp;&amp; $interfaceName ne &quot;EventTarget&quot;) {
4603         AddToImplIncludes(&quot;JSDOMOperation.h&quot;);
4604 
4605         # FIXME: Make consistent IDLAttribute&lt;&gt;::cast and IDLOperation&lt;&gt;::cast in case of CustomProxyToJSObject.
4606         my $castingFunction = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;to${className}&quot; : GetCastingHelperForThisObject($interface);
<span class="line-modified">4607         my $thisValue = $interface-&gt;extendedAttributes-&gt;{CustomProxyToJSObject} ? &quot;callFrame.thisValue().toThis(&amp;lexicalGlobalObject, NotStrictMode)&quot; : &quot;callFrame.thisValue()&quot;;</span>
<span class="line-modified">4608         push(@implContent, &quot;template&lt;&gt; inline ${className}* IDLOperation&lt;${className}&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)\n&quot;);</span>
4609         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4610         push(@implContent, &quot;    return $castingFunction(JSC::getVM(&amp;lexicalGlobalObject), $thisValue);\n&quot;);</span>
4611         push(@implContent, &quot;}\n\n&quot;);
4612     }
4613 
4614     if (NeedsConstructorProperty($interface)) {
4615         my $constructorGetter = &quot;js&quot; . $interfaceName . &quot;Constructor&quot;;
4616 
<span class="line-modified">4617         push(@implContent, &quot;EncodedJSValue ${constructorGetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
4618         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4619         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
4620         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4621         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4622         push(@implContent, &quot;    if (UNLIKELY(!prototype))\n&quot;);
<span class="line-modified">4623         push(@implContent, &quot;        return throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);</span>
4624 
4625         if (!$interface-&gt;extendedAttributes-&gt;{NoInterfaceObject}) {
<span class="line-modified">4626             push(@implContent, &quot;    return JSValue::encode(${className}::getConstructor(JSC::getVM(lexicalGlobalObject), prototype-&gt;globalObject()));\n&quot;);</span>
4627         } else {
<span class="line-modified">4628             push(@implContent, &quot;    JSValue constructor = ${className}Constructor::create(JSC::getVM(lexicalGlobalObject), ${className}Constructor::createStructure(JSC::getVM(lexicalGlobalObject), *prototype-&gt;globalObject(), prototype-&gt;globalObject()-&gt;objectPrototype()), *jsCast&lt;JSDOMGlobalObject*&gt;(prototype-&gt;globalObject()));\n&quot;);</span>
4629             push(@implContent, &quot;    // Shadowing constructor property to ensure reusing the same constructor object\n&quot;);
4630             push(@implContent, &quot;    prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, constructor, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));\n&quot;);
4631             push(@implContent, &quot;    return JSValue::encode(constructor);\n&quot;);
4632         }
4633         push(@implContent, &quot;}\n\n&quot;);
4634 
4635         my $constructorSetter = &quot;setJS&quot; . $interfaceName . &quot;Constructor&quot;;
4636 
<span class="line-modified">4637         push(@implContent, &quot;bool ${constructorSetter}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
4638         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4639         push(@implContent, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
4640         push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
4641         push(@implContent, &quot;    auto* prototype = jsDynamicCast&lt;${className}Prototype*&gt;(vm, JSValue::decode(thisValue));\n&quot;);
4642         push(@implContent, &quot;    if (UNLIKELY(!prototype)) {\n&quot;);
<span class="line-modified">4643         push(@implContent, &quot;        throwVMTypeError(lexicalGlobalObject, throwScope);\n&quot;);</span>
4644         push(@implContent, &quot;        return false;\n&quot;);
4645         push(@implContent, &quot;    }\n&quot;);
4646         push(@implContent, &quot;    // Shadowing a built-in constructor\n&quot;);
4647         push(@implContent, &quot;    return prototype-&gt;putDirect(vm, vm.propertyNames-&gt;constructor, JSValue::decode(encodedValue));\n&quot;);
4648         push(@implContent, &quot;}\n\n&quot;);
4649 
4650     }
4651 
4652     foreach my $attribute (@attributes) {
4653         GenerateAttributeGetterDefinition(\@implContent, $interface, $className, $attribute);
4654         GenerateAttributeSetterDefinition(\@implContent, $interface, $className, $attribute);
4655     }
4656 
4657     foreach my $operation (@operations) {
4658         GenerateOperationDefinition(\@implContent, $interface, $className, $operation);
4659     }
4660     
4661     GenerateIterableDefinition($interface) if $interface-&gt;iterable;
4662     GenerateSerializerDefinition($interface, $className) if $interface-&gt;serializable;
4663 
<span class="line-added">4664     if (IsDOMGlobalObject($interface)) {</span>
<span class="line-added">4665         AddToImplIncludes(&quot;WebCoreJSClientData.h&quot;);</span>
<span class="line-added">4666         push(@implContent, &quot;JSC::IsoSubspace* ${className}::subspaceForImpl(JSC::VM&amp; vm)\n&quot;);</span>
<span class="line-added">4667         push(@implContent, &quot;{\n&quot;);</span>
<span class="line-added">4668         push(@implContent, &quot;    return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;subspaceFor${className}();\n&quot;);</span>
<span class="line-added">4669         push(@implContent, &quot;}\n\n&quot;);</span>
<span class="line-added">4670     }</span>
<span class="line-added">4671 </span>
4672     if ($needsVisitChildren) {
4673         push(@implContent, &quot;void ${className}::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)\n&quot;);
4674         push(@implContent, &quot;{\n&quot;);
4675         push(@implContent, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
4676         push(@implContent, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n&quot;);
4677         push(@implContent, &quot;    Base::visitChildren(thisObject, visitor);\n&quot;);
4678         push(@implContent, &quot;    thisObject-&gt;visitAdditionalChildren(visitor);\n&quot;) if $interface-&gt;extendedAttributes-&gt;{JSCustomMarkFunction};
4679         if ($interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost}) {
4680             push(@implContent, &quot;    visitor.reportExtraMemoryVisited(thisObject-&gt;wrapped().memoryCost());\n&quot;);
4681             if ($interface-&gt;extendedAttributes-&gt;{ReportExternalMemoryCost}) {;
4682                 push(@implContent, &quot;#if ENABLE(RESOURCE_USAGE)\n&quot;);
4683                 push(@implContent, &quot;    visitor.reportExternalMemoryVisited(thisObject-&gt;wrapped().externalMemoryCost());\n&quot;);
4684                 push(@implContent, &quot;#endif\n&quot;);
4685             }
4686         }
4687         if ($numCachedAttributes &gt; 0) {
4688             foreach my $attribute (@{$interface-&gt;attributes}) {
4689                 if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4690                     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($attribute);
4691                     push(@implContent, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
</pre>
<hr />
<pre>
4859         push(@implContent, &quot;}\n\n&quot;);
4860     }
4861 
4862     if (ShouldGenerateToJSImplementation($hasParent, $interface)) {
4863         my $vtableNameGnu = GetGnuVTableNameForInterface($interface);
4864         my $vtableRefGnu = GetGnuVTableRefForInterface($interface);
4865         my $vtableRefWin = GetWinVTableRefForInterface($interface);
4866 
4867         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4868 #if ENABLE(BINDING_INTEGRITY)
4869 #if PLATFORM(WIN)
4870 #pragma warning(disable: 4483)
4871 extern &quot;C&quot; { extern void (*const ${vtableRefWin}[])(); }
4872 #else
4873 extern &quot;C&quot; { extern void* ${vtableNameGnu}[]; }
4874 #endif
4875 #endif
4876 
4877 END
4878 
<span class="line-modified">4879         push(@implContent, &quot;JSC::JSValue toJSNewlyCreated(JSC::JSGlobalObject*, JSDOMGlobalObject* globalObject, Ref&lt;$implType&gt;&amp;&amp; impl)\n&quot;);</span>
4880         push(@implContent, &quot;{\n&quot;);
4881         push(@implContent, &lt;&lt;END) if $vtableNameGnu;
4882 
4883 #if ENABLE(BINDING_INTEGRITY)
<span class="line-modified">4884     void* actualVTablePointer = getVTablePointer(impl.ptr());</span>
4885 #if PLATFORM(WIN)
<span class="line-modified">4886     void* expectedVTablePointer = ${vtableRefWin};</span>
4887 #else
<span class="line-modified">4888     void* expectedVTablePointer = ${vtableRefGnu};</span>
4889 #endif
4890 
4891     // If this fails ${implType} does not have a vtable, so you need to add the
4892     // ImplementationLacksVTable attribute to the interface definition
4893     static_assert(std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is not polymorphic&quot;);
4894 
4895     // If you hit this assertion you either have a use after free bug, or
4896     // ${implType} has subclasses. If ${implType} has subclasses that get passed
4897     // to toJS() we currently require $interfaceName you to opt out of binding hardening
4898     // by adding the SkipVTableValidation attribute to the interface IDL definition
4899     RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
4900 #endif
4901 END
4902         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ImplementationLacksVTable};
4903     // If you hit this failure the interface definition has the ImplementationLacksVTable
4904     // attribute. You should remove that attribute. If the class has subclasses
4905     // that may be passed through this toJS() function you should use the SkipVTableValidation
4906     // attribute to $interfaceName.
4907     static_assert(!std::is_polymorphic&lt;${implType}&gt;::value, &quot;${implType} is polymorphic but the IDL claims it is not&quot;);
4908 END
4909         push(@implContent, &lt;&lt;END) if $interface-&gt;extendedAttributes-&gt;{ReportExtraMemoryCost};
4910     globalObject-&gt;vm().heap.reportExtraMemoryAllocated(impl-&gt;memoryCost());
4911 END
4912 
4913         push(@implContent, &quot;    return createWrapper&lt;${implType}&gt;(globalObject, WTFMove(impl));\n&quot;);
4914         push(@implContent, &quot;}\n\n&quot;);
4915 
<span class="line-modified">4916         push(@implContent, &quot;JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, ${implType}&amp; impl)\n&quot;);</span>
4917         push(@implContent, &quot;{\n&quot;);
<span class="line-modified">4918         push(@implContent, &quot;    return wrap(lexicalGlobalObject, globalObject, impl);\n&quot;);</span>
4919         push(@implContent, &quot;}\n\n&quot;);
4920     }
4921 
4922     if (ShouldGenerateToWrapped($hasParent, $interface) and !$interface-&gt;extendedAttributes-&gt;{JSCustomToNativeObject}) {
4923         push(@implContent, &quot;${implType}* ${className}::toWrapped(JSC::VM&amp; vm, JSC::JSValue value)\n&quot;);
4924         push(@implContent, &quot;{\n&quot;);
4925         push(@implContent, &quot;    if (auto* wrapper = &quot; . GetCastingHelperForThisObject($interface) . &quot;(vm, value))\n&quot;);
4926         push(@implContent, &quot;        return &amp;wrapper-&gt;wrapped();\n&quot;);
4927         push(@implContent, &quot;    return nullptr;\n&quot;);
4928         push(@implContent, &quot;}\n&quot;);
4929     }
4930 
4931     push(@implContent, &quot;\n}\n&quot;);
4932 
4933     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($interface);
4934     push(@implContent, &quot;\n#endif // ${conditionalString}\n&quot;) if $conditionalString;
4935 }
4936 
4937 sub GenerateAttributeGetterBodyDefinition
4938 {
4939     my ($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional) = @_;
4940     
4941     my @signatureArguments = ();
<span class="line-modified">4942     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);</span>
4943     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
4944     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
4945     
4946     push(@$outputArray, &quot;static inline JSValue ${attributeGetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
4947     push(@$outputArray, &quot;{\n&quot;);
4948     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
<span class="line-modified">4949     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
4950 
4951     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp;
4952         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp;
4953         !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnGetter}) {
4954         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
4955         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="line-modified">4956             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
4957         } else {
<span class="line-modified">4958             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
4959         }
4960         push(@$outputArray, &quot;        return jsUndefined();\n&quot;);
4961     }
4962     
4963     if (HasCustomGetter($attribute)) {
4964         my $implGetterFunctionName = $codeGenerator-&gt;WK_lcfirst($attribute-&gt;extendedAttributes-&gt;{ImplementedAs} || $attribute-&gt;name);
<span class="line-modified">4965         push(@$outputArray, &quot;    return thisObject.${implGetterFunctionName}(lexicalGlobalObject);\n&quot;);</span>
4966     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
4967         $implIncludes{&quot;EventNames.h&quot;} = 1;
4968         my $getter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;windowEventHandlerAttribute&quot;
4969             : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;documentEventHandlerAttribute&quot;
4970             : &quot;eventHandlerAttribute&quot;;
4971         my $eventName = EventHandlerAttributeEventName($attribute);
4972         push(@$outputArray, &quot;    return $getter(thisObject.wrapped(), $eventName, worldForDOMObject(thisObject));\n&quot;);
4973     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
4974         my $constructorType = $attribute-&gt;type-&gt;name;
4975         $constructorType =~ s/Constructor$//;
4976         # When Constructor attribute is used by DOMWindow.idl, it&#39;s correct to pass thisObject as the global object
4977         # When JSDOMWrappers have a back-pointer to the globalObject we can pass thisObject-&gt;globalObject()
4978         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
4979             my $named = ($constructorType =~ /Named$/) ? &quot;Named&quot; : &quot;&quot;;
4980             $constructorType =~ s/Named$//;
<span class="line-modified">4981             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::get${named}Constructor(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject);\n&quot;);</span>
4982         } else {
4983             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
<span class="line-modified">4984             push(@$outputArray, &quot;    return JS&quot; . $constructorType . &quot;::getConstructor(JSC::getVM(&amp;lexicalGlobalObject), thisObject.globalObject());\n&quot;);</span>
4985         }
4986     } else {
4987         if ($attribute-&gt;extendedAttributes-&gt;{CachedAttribute}) {
4988             push(@$outputArray, &quot;    if (JSValue cachedValue = thisObject.m_&quot; . $attribute-&gt;name . &quot;.get())\n&quot;);
4989             push(@$outputArray, &quot;        return cachedValue;\n&quot;);
4990         }
4991         
4992         my @callWithArgs = GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;jsUndefined()&quot;, &quot;thisObject&quot;);
4993         
4994         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;GetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
4995         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
<span class="line-modified">4996         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);</span>
4997         
4998         unshift(@arguments, @callWithArgs);
4999 
<span class="line-modified">5000         my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;</span>
5001         my $toJSExpression = NativeToJSValueUsingReferences($attribute, $interface, &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;, $globalObjectReference);
<span class="line-modified">5002         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) unless $attribute-&gt;isStatic or $attribute-&gt;isMapLike or $attribute-&gt;isSetLike;</span>
5003 
5004         if (!IsReadonly($attribute)) {
5005             my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5006             if ($callTracingCallback) {
5007                 my @callTracerArguments = ();
5008                 GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, &quot;    &quot;);
5009             }
5010         }
5011 
5012         push(@$outputArray, &quot;    JSValue result = ${toJSExpression};\n&quot;);
<span class="line-modified">5013         push(@$outputArray, &quot;    thisObject.m_&quot; . $attribute-&gt;name . &quot;.set(JSC::getVM(&amp;lexicalGlobalObject), &amp;thisObject, result);\n&quot;) if $attribute-&gt;extendedAttributes-&gt;{CachedAttribute};</span>
5014         push(@$outputArray, &quot;    return result;\n&quot;);
5015     }
5016     push(@$outputArray, &quot;}\n\n&quot;);
5017 }
5018 
5019 sub GenerateAttributeGetterTrampolineDefinition
5020 {
5021     my ($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional) = @_;
5022     
5023     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5024     
5025     my $callAttributeGetterName = &quot;get&quot;;
5026     $callAttributeGetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5027     
5028     my @templateParameters = ();
5029     push(@templateParameters, $attributeGetterBodyName);
5030     if ($attribute-&gt;extendedAttributes-&gt;{LenientThis}) {
5031         push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;)
5032     } elsif ($codeGenerator-&gt;IsPromiseType($attribute-&gt;type)) {
5033         push(@templateParameters, &quot;CastedThisErrorBehavior::RejectPromise&quot;)
5034     } elsif (IsAcceleratedDOMAttribute($interface, $attribute)) {
5035         push(@templateParameters, &quot;CastedThisErrorBehavior::Assert&quot;);
5036     }
5037     
<span class="line-modified">5038     push(@$outputArray, &quot;EncodedJSValue ${attributeGetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)\n&quot;);</span>
5039     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5040     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeGetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, \&quot;&quot; . $attribute-&gt;name .  &quot;\&quot;);\n&quot;);</span>
5041     push(@$outputArray, &quot;}\n\n&quot;);
5042 }
5043 
5044 sub GenerateAttributeGetterDefinition
5045 {
5046     my ($outputArray, $interface, $className, $attribute) = @_;
5047 
5048     return if IsJSBuiltin($interface, $attribute);
5049 
5050     my $attributeGetterName = GetAttributeGetterName($interface, $className, $attribute);
5051     my $attributeGetterBodyName = $attributeGetterName . &quot;Getter&quot;;
5052     
5053     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5054     if ($conditional) {
5055         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5056         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5057     }
5058     
5059     GenerateAttributeGetterBodyDefinition($outputArray, $interface, $className, $attribute, $attributeGetterBodyName, $conditional);
5060     GenerateAttributeGetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeGetterName, $attributeGetterBodyName, $conditional);
5061     
5062     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5063 }
5064 
5065 sub GenerateAttributeSetterBodyDefinition
5066 {
5067     my ($outputArray, $interface, $className, $attribute, $attributeSetterBodyName, $conditional) = @_;
5068 
5069     my @signatureArguments = ();
<span class="line-modified">5070     push(@signatureArguments, &quot;JSGlobalObject&amp; lexicalGlobalObject&quot;);</span>
5071     push(@signatureArguments, &quot;${className}&amp; thisObject&quot;) if !$attribute-&gt;isStatic;
5072     push(@signatureArguments, &quot;JSValue value&quot;);
5073     push(@signatureArguments, &quot;ThrowScope&amp; throwScope&quot;);
5074     
5075     push(@$outputArray, &quot;static inline bool ${attributeSetterBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5076     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5077     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
5078     if ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type) || $attribute-&gt;extendedAttributes-&gt;{Replaceable} || $attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5079         push(@$outputArray, &quot;    VM&amp; vm = throwScope.vm();\n&quot;);
5080     } else {
5081         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5082     }
5083 
<span class="line-modified">5084     GenerateCustomElementReactionsStackIfNeeded($outputArray, $attribute, &quot;lexicalGlobalObject&quot;);</span>
5085 
5086     if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurity} &amp;&amp; !$attribute-&gt;extendedAttributes-&gt;{DoNotCheckSecurityOnSetter}) {
5087         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5088         if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="line-modified">5089             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped(), ThrowSecurityError))\n&quot;);</span>
5090         } else {
<span class="line-modified">5091             push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, thisObject.wrapped().window(), ThrowSecurityError))\n&quot;);</span>
5092         }
5093         push(@$outputArray, &quot;        return false;\n&quot;);
5094     }
5095     
5096     if (HasCustomSetter($attribute)) {
5097         my $implSetterFunctionName = $codeGenerator-&gt;WK_ucfirst($attribute-&gt;name);
<span class="line-modified">5098         push(@$outputArray, &quot;    thisObject.set${implSetterFunctionName}(lexicalGlobalObject, value);\n&quot;);</span>
5099         push(@$outputArray, &quot;    return true;\n&quot;);
5100     } elsif ($attribute-&gt;type-&gt;name eq &quot;EventHandler&quot;) {
5101         AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5102         my $eventName = EventHandlerAttributeEventName($attribute);
5103         # FIXME: Find a way to do this special case without hardcoding the class and attribute names here.
5104         if (($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot; or $interface-&gt;type-&gt;name eq &quot;WorkerGlobalScope&quot;) and $attribute-&gt;name eq &quot;onerror&quot;) {
5105             AddToImplIncludes(&quot;JSErrorHandler.h&quot;, $conditional);
<span class="line-modified">5106             push(@$outputArray, &quot;    thisObject.wrapped().setAttributeEventListener($eventName, createJSErrorHandler(lexicalGlobalObject, value, thisObject), worldForDOMObject(thisObject));\n&quot;);</span>
5107         } else {
5108             AddToImplIncludes(&quot;JSEventListener.h&quot;, $conditional);
5109             my $setter = $attribute-&gt;extendedAttributes-&gt;{WindowEventHandler} ? &quot;setWindowEventHandlerAttribute&quot;
5110                 : $attribute-&gt;extendedAttributes-&gt;{DocumentEventHandler} ? &quot;setDocumentEventHandlerAttribute&quot;
5111                 : &quot;setEventHandlerAttribute&quot;;
<span class="line-modified">5112             push(@$outputArray, &quot;    $setter(lexicalGlobalObject, thisObject, thisObject.wrapped(), ${eventName}, value);\n&quot;);</span>
5113         }
5114         push(@$outputArray, &quot;    return true;\n&quot;);
5115     } elsif ($codeGenerator-&gt;IsConstructorType($attribute-&gt;type)) {
5116         my $constructorType = $attribute-&gt;type-&gt;name;
5117         $constructorType =~ s/Constructor$//;
5118         # $constructorType ~= /Constructor$/ indicates that it is NamedConstructor.
5119         # We do not generate the header file for NamedConstructor of class XXXX,
5120         # since we generate the NamedConstructor declaration into the header file of class XXXX.
5121         if ($constructorType ne &quot;any&quot; and $constructorType !~ /Named$/) {
5122             AddToImplIncludes(&quot;JS&quot; . $constructorType . &quot;.h&quot;, $conditional);
5123         }
5124         my $id = $attribute-&gt;name;
5125         push(@$outputArray, &quot;    // Shadowing a built-in constructor.\n&quot;);
5126         push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5127     } elsif ($attribute-&gt;extendedAttributes-&gt;{Replaceable}) {
5128         my $id = $attribute-&gt;name;
5129         push(@$outputArray, &quot;    // Shadowing a built-in property.\n&quot;);
5130         if (AttributeShouldBeOnInstance($interface, $attribute)) {
5131             push(@$outputArray, &quot;    return replaceStaticPropertySlot(vm, &amp;thisObject, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5132         } else {
5133             push(@$outputArray, &quot;    return thisObject.putDirect(vm, Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;)), value);\n&quot;);
5134         }
5135     } elsif ($attribute-&gt;extendedAttributes-&gt;{PutForwards}) {
5136         assert(&quot;[PutForwards] is not compatible with static attributes&quot;) if $attribute-&gt;isStatic;
5137         
5138         # 3.5.9.1. Let Q be ? Get(O, id).
5139         my $id = $attribute-&gt;name;
5140         push(@$outputArray, &quot;    auto id = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${id}\&quot;), strlen(\&quot;${id}\&quot;));\n&quot;);
<span class="line-modified">5141         push(@$outputArray, &quot;    auto valueToForwardTo = thisObject.get(&amp;lexicalGlobalObject, id);\n&quot;);</span>
5142         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5143         
5144         # 3.5.9.2. If Type(Q) is not Object, then throw a TypeError.
5145         push(@$outputArray, &quot;    if (UNLIKELY(!valueToForwardTo.isObject())) {\n&quot;);
<span class="line-modified">5146         push(@$outputArray, &quot;        throwTypeError(&amp;lexicalGlobalObject, throwScope);\n&quot;);</span>
5147         push(@$outputArray, &quot;        return false;\n&quot;);
5148         push(@$outputArray, &quot;    }\n&quot;);
5149         
5150         # 3.5.9.3. Let forwardId be the identifier argument of the [PutForwards] extended attribute.
5151         my $forwardId = $attribute-&gt;extendedAttributes-&gt;{PutForwards};
5152         push(@$outputArray, &quot;    auto forwardId = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;${forwardId}\&quot;), strlen(\&quot;${forwardId}\&quot;));\n&quot;);
5153         
5154         # 3.5.9.4. Perform ? Set(Q, forwardId, V).
5155         # FIXME: What should the second value to the PutPropertySlot be?
5156         # (https://github.com/heycam/webidl/issues/368)
5157         push(@$outputArray, &quot;    PutPropertySlot slot(valueToForwardTo, false);\n&quot;);
<span class="line-modified">5158         push(@$outputArray, &quot;    asObject(valueToForwardTo)-&gt;methodTable(vm)-&gt;put(asObject(valueToForwardTo), &amp;lexicalGlobalObject, forwardId, value, slot);\n&quot;);</span>
5159         push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5160         
5161         push(@$outputArray, &quot;    return true;\n&quot;);
5162     } else {
5163         push(@$outputArray, &quot;    auto&amp; impl = thisObject.wrapped();\n&quot;) if !$attribute-&gt;isStatic;
5164        
5165         if ($codeGenerator-&gt;IsEnumType($attribute-&gt;type)) {
5166             # As per section 3.5.6 of https://heycam.github.io/webidl/#dfn-attribute-setter, enumerations do not use
5167             # the standard conversion, but rather silently fail on invalid enumeration values.
<span class="line-modified">5168             push(@$outputArray, &quot;    auto optionalNativeValue = parseEnumeration&lt;&quot; . GetEnumerationClassName($attribute-&gt;type, $interface) . &quot;&gt;(lexicalGlobalObject, value);\n&quot;);</span>
5169             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5170             push(@$outputArray, &quot;    if (UNLIKELY(!optionalNativeValue))\n&quot;);
5171             push(@$outputArray, &quot;        return false;\n&quot;);
5172             push(@$outputArray, &quot;    auto nativeValue = optionalNativeValue.value();\n&quot;);
5173         } else {
<span class="line-modified">5174             my $globalObjectReference = $attribute-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*thisObject.globalObject()&quot;;</span>
5175             my $exceptionThrower = GetAttributeExceptionThrower($interface, $attribute);
5176 
<span class="line-modified">5177             my $toNativeExpression = JSValueToNative($interface, $attribute, &quot;value&quot;, $attribute-&gt;extendedAttributes-&gt;{Conditional}, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;, &quot;thisObject&quot;, $globalObjectReference, $exceptionThrower);</span>
5178             push(@$outputArray, &quot;    auto nativeValue = ${toNativeExpression};\n&quot;);
5179             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, false);\n&quot;);
5180         }
5181 
5182         my ($baseFunctionName, @arguments) = $codeGenerator-&gt;SetterExpression(\%implIncludes, $interface-&gt;type-&gt;name, $attribute);
5183 
5184         push(@arguments, PassArgumentExpression(&quot;nativeValue&quot;, $attribute));
5185 
5186         my $functionName = GetFullyQualifiedImplementationCallName($interface, $attribute, $baseFunctionName, &quot;impl&quot;, $conditional);
<span class="line-modified">5187         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $attribute, &quot;impl&quot;, &quot;lexicalGlobalObject&quot;, &quot;&quot;, &quot;thisObject&quot;);</span>
5188 
5189         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{SetterCallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5190         unshift(@arguments, GenerateCallWithUsingReferences($attribute-&gt;extendedAttributes-&gt;{CallWith}, $outputArray, &quot;false&quot;, &quot;thisObject&quot;));
5191 
5192         my $callTracingCallback = $attribute-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
5193         if ($callTracingCallback) {
5194             my $indent = &quot;    &quot;;
5195             my @callTracerArguments = (&quot;nativeValue&quot;);
5196             GenerateCallTracer($outputArray, $callTracingCallback, $attribute-&gt;name, \@callTracerArguments, $indent);
5197         }
5198 
5199         my $functionString = &quot;${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified">5200         push(@$outputArray, &quot;    AttributeSetter::call(lexicalGlobalObject, throwScope, [&amp;] {\n&quot;);</span>
5201         push(@$outputArray, &quot;        return $functionString;\n&quot;);
5202         push(@$outputArray, &quot;    });\n&quot;);
5203         push(@$outputArray, &quot;    return true;\n&quot;);
5204     }
5205     push(@$outputArray, &quot;}\n\n&quot;);
5206 }
5207 
5208 sub GenerateAttributeSetterTrampolineDefinition
5209 {
5210     my ($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional) = @_;
5211     
5212     AddToImplIncludes(&quot;JSDOMAttribute.h&quot;, $conditional);
5213     
5214     my $callAttributeSetterName = &quot;set&quot;;
5215     $callAttributeSetterName .= &quot;Static&quot; if $attribute-&gt;isStatic;
5216     
5217     my @templateParameters = ();
5218     push(@templateParameters, $attributeSetterBodyName);
5219     push(@templateParameters, &quot;CastedThisErrorBehavior::ReturnEarly&quot;) if $attribute-&gt;extendedAttributes-&gt;{LenientThis};
5220     
<span class="line-modified">5221     push(@$outputArray, &quot;bool ${attributeSetterName}(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, EncodedJSValue encodedValue)\n&quot;);</span>
5222     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5223     push(@$outputArray, &quot;    return IDLAttribute&lt;${className}&gt;::${callAttributeSetterName}&lt;&quot; . join(&quot;, &quot;, @templateParameters) . &quot;&gt;(*lexicalGlobalObject, thisValue, encodedValue, \&quot;&quot; . $attribute-&gt;name . &quot;\&quot;);\n&quot;);</span>
5224     push(@$outputArray, &quot;}\n\n&quot;);
5225 }
5226 
5227 sub GenerateAttributeSetterDefinition
5228 {
5229     my ($outputArray, $interface, $className, $attribute) = @_;
5230     
5231     return if IsReadonly($attribute);
5232     return if IsJSBuiltin($interface, $attribute);
5233     
5234     my $conditional = $attribute-&gt;extendedAttributes-&gt;{Conditional};
5235     if ($conditional) {
5236         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5237         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
5238     }
5239 
5240     my $readWriteConditional = $attribute-&gt;extendedAttributes-&gt;{ConditionallyReadWrite};
5241     if ($readWriteConditional) {
5242         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($readWriteConditional);
5243         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);;
</pre>
<hr />
<pre>
5250     GenerateAttributeSetterTrampolineDefinition($outputArray, $interface, $className, $attribute, $attributeSetterName, $attributeSetterBodyName, $conditional);
5251 
5252     push(@$outputArray, &quot;#endif\n\n&quot;) if $readWriteConditional;
5253     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5254 }
5255 
5256 sub GenerateOperationTrampolineDefinition
5257 {
5258     my ($outputArray, $interface, $className, $operation, $functionName, $functionBodyName) = @_;
5259 
5260     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5261     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5262     my $exposureScope = $interface-&gt;extendedAttributes-&gt;{Exposed} ? &quot;WindowOrWorker&quot; : &quot;WindowOnly&quot;;
5263 
5264     my $callFunctionName = &quot;call&quot;;
5265     $callFunctionName .= &quot;Static&quot; if $operation-&gt;isStatic;
5266     $callFunctionName .= &quot;ReturningOwnPromise&quot; if $hasPromiseReturnType &amp;&amp; $operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5267 
5268     my @callFunctionTemplateArguments = ();
5269     push(@callFunctionTemplateArguments, $functionBodyName);

5270     push(@callFunctionTemplateArguments, &quot;CastedThisErrorBehavior::Assert&quot;) if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
5271 
<span class="line-modified">5272     push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${functionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
5273     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5274     push(@$outputArray, &quot;    return ${idlOperationType}&lt;${className}&gt;::${callFunctionName}&lt;&quot; . join(&quot;, &quot;, @callFunctionTemplateArguments) . &quot;&gt;(*lexicalGlobalObject, *callFrame, \&quot;&quot; . $operation-&gt;name . &quot;\&quot;);\n&quot;);</span>
5275     push(@$outputArray, &quot;}\n\n&quot;);
5276 }
5277 
5278 sub GenerateOperationBodyDefinition
5279 {
<span class="line-modified">5280     my ($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded, $generatingOverloadDispatcher) = @_;</span>
5281 
5282     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5283     my $idlOperationType = $hasPromiseReturnType ? &quot;IDLOperationReturningPromise&quot; : &quot;IDLOperation&quot;;
5284     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5285 
5286     my @signatureArguments = ();
<span class="line-modified">5287     push(@signatureArguments, &quot;JSC::JSGlobalObject* lexicalGlobalObject&quot;);</span>
<span class="line-added">5288     push(@signatureArguments, &quot;JSC::CallFrame* callFrame&quot;);</span>
5289     push(@signatureArguments, &quot;typename ${idlOperationType}&lt;${className}&gt;::ClassParameter castedThis&quot;) if !$operation-&gt;isStatic;
5290     push(@signatureArguments, &quot;Ref&lt;DeferredPromise&gt;&amp;&amp; promise&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5291     push(@signatureArguments, &quot;JSC::ThrowScope&amp; throwScope&quot;);
5292 
5293     push(@$outputArray, &quot;static inline JSC::EncodedJSValue ${functionBodyName}(&quot; . join(&quot;, &quot;, @signatureArguments) . &quot;)\n&quot;);
5294     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5295     push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
<span class="line-added">5296     push(@$outputArray, &quot;    UNUSED_PARAM(callFrame);\n&quot;);</span>
5297     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5298 
<span class="line-modified">5299     GenerateCustomElementReactionsStackIfNeeded($outputArray, $operation, &quot;*lexicalGlobalObject&quot;) unless $generatingOverloadDispatcher;</span>

5300 
<span class="line-added">5301     # For overloads, we generate the security check in the overload dispatcher, instead of the body of each overload, as per specification:</span>
<span class="line-added">5302     # https://heycam.github.io/webidl/#dfn-create-operation-function</span>
<span class="line-added">5303     if (!$isOverloaded || $generatingOverloadDispatcher) {</span>
5304         if ($interface-&gt;extendedAttributes-&gt;{CheckSecurity} and !$operation-&gt;extendedAttributes-&gt;{DoNotCheckSecurity}) {
5305             assert(&quot;Security checks are not supported for static operations.&quot;) if $operation-&gt;isStatic;
5306             
5307             AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
5308             if ($interface-&gt;type-&gt;name eq &quot;DOMWindow&quot;) {
<span class="line-modified">5309                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped(), ThrowSecurityError))\n&quot;);</span>
5310                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5311             } else {
<span class="line-modified">5312                 push(@$outputArray, &quot;    if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped().window(), ThrowSecurityError))\n&quot;);</span>
5313                 push(@$outputArray, &quot;        return JSValue::encode(jsUndefined());\n&quot;);
5314             }
5315         }
5316     }
5317 
5318     my $indent = &quot;    &quot;;
5319 
5320     if ($generatingOverloadDispatcher) {
<span class="line-modified">5321         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
5322         push(@$outputArray, &quot;    UNUSED_PARAM(vm);\n&quot;);
5323 
5324         my @argumentsToForward = ();
<span class="line-modified">5325         push(@argumentsToForward, &quot;lexicalGlobalObject&quot;);</span>
<span class="line-added">5326         push(@argumentsToForward, &quot;callFrame&quot;);</span>
5327         push(@argumentsToForward, &quot;castedThis&quot;) if !$operation-&gt;isStatic;
5328         push(@argumentsToForward, &quot;WTFMove(promise)&quot;) if $hasPromiseReturnType &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
5329         push(@argumentsToForward, &quot;throwScope&quot;);
5330 
5331         GenerateOverloadDispatcher($operation, $interface, $functionName, &quot;Body&quot;, join(&quot;, &quot;, @argumentsToForward));
5332     } elsif (HasCustomMethod($operation)) {
5333         GenerateImplementationCustomFunctionCall($outputArray, $operation, $interface, $className, $functionImplementationName, $indent);
5334     } else {
<span class="line-modified">5335         if (!$operation-&gt;isMapLike &amp;&amp; !$operation-&gt;isSetLike &amp;&amp; !$operation-&gt;isStatic) {</span>
5336             push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5337         }
5338 
5339         GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5340         my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5341 
5342         if ($operation-&gt;extendedAttributes-&gt;{ResultField}) {
5343             my $resultName = $operation-&gt;extendedAttributes-&gt;{ResultField};
5344             push(@$outputArray, &quot;    auto implResult = $functionString;\n&quot;);
5345             GenerateImplementationFunctionCall($outputArray, $operation, $interface, &quot;WTFMove(implResult.$resultName)&quot;, $indent);
5346         } else {
5347             GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5348         }
5349     }
5350 
5351     push(@$outputArray, &quot;}\n\n&quot;);
5352 }
5353 
5354 sub GenerateOperationDefinition
5355 {
</pre>
<hr />
<pre>
5375         push(@$outputArray, $endAppleCopyright);
5376         $inAppleCopyright = 0;
5377     }
5378 
5379     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5380     if ($conditional) {
5381         my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5382         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5383     }
5384 
5385     my $hasPromiseReturnType = $codeGenerator-&gt;IsPromiseType($operation-&gt;type);
5386 
5387     AddToImplIncludesForIDLType($operation-&gt;type, $conditional) unless $isCustom or $hasPromiseReturnType;
5388     AddToImplIncludes(&quot;JSDOMOperation.h&quot;, $conditional) if !$hasPromiseReturnType;
5389     AddToImplIncludes(&quot;JSDOMOperationReturningPromise.h&quot;, $conditional) if $hasPromiseReturnType;
5390 
5391     my $functionName = GetFunctionName($interface, $className, $operation);
5392     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name);
5393     my $functionBodyName = ($isOverloaded ? $functionName . $operation-&gt;{overloadIndex} : $functionName) . &quot;Body&quot;;
5394 
<span class="line-modified">5395     GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $functionBodyName, $isOverloaded);</span>
5396 
5397     # Overloaded operations don&#39;t generate a trampoline for each overload, and instead have a single dispatch trampoline
5398     # that gets generated after the last overload body has been generated.
5399     unless ($isOverloaded) {
5400         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $functionBodyName);
5401     }
5402 
5403     push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5404 
5405     # Generate a function dispatching call to the rest of the overloads.
5406     if ($isOverloaded &amp;&amp; $operation-&gt;{overloadIndex} == @{$operation-&gt;{overloads}}) {
5407         my $overloadsConditionalAttribute = GetConditionalForOperationConsideringOverloads($operation);
5408         my $overloadsConditionalString = $overloadsConditionalAttribute ? $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($overloadsConditionalAttribute) : undef;
5409         push(@$outputArray, &quot;#if ${overloadsConditionalString}\n\n&quot;) if $overloadsConditionalString;
5410 
5411         my $overloadDispatcherFunctionBodyName = $functionName . &quot;OverloadDispatcher&quot;;
<span class="line-modified">5412         GenerateOperationBodyDefinition($outputArray, $interface, $className, $operation, $functionName, $functionImplementationName, $overloadDispatcherFunctionBodyName, $isOverloaded, 1);</span>
5413         GenerateOperationTrampolineDefinition($outputArray, $interface, $className, $operation, $functionName, $overloadDispatcherFunctionBodyName);
5414     
5415         push(@$outputArray, &quot;#endif\n\n&quot;) if $overloadsConditionalString;
5416     }
5417 
5418 
5419     if ($operation-&gt;extendedAttributes-&gt;{DOMJIT}) {
5420         if ($conditional) {
5421             my $conditionalString = $codeGenerator-&gt;GenerateConditionalStringFromAttributeValue($conditional);
5422             push(@$outputArray, &quot;#if ${conditionalString}\n&quot;);
5423         }
5424 
5425         AddToImplIncludes(&quot;&lt;JavaScriptCore/FrameTracers.h&gt;&quot;, $conditional);
5426         my $nameOfFunctionWithoutTypeCheck = $codeGenerator-&gt;WK_lcfirst($functionName) . &quot;WithoutTypeCheck&quot;;
<span class="line-modified">5427         push(@$outputArray, &quot;JSC::EncodedJSValue JIT_OPERATION ${nameOfFunctionWithoutTypeCheck}(JSC::JSGlobalObject* lexicalGlobalObject, $className* castedThis&quot;);</span>
5428         foreach my $argument (@{$operation-&gt;arguments}) {
5429             my $type = $argument-&gt;type;
5430             my $argumentType = GetArgumentTypeForFunctionWithoutTypeCheck($interface, $type);
5431             my $name = $argument-&gt;name;
5432             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5433             push(@$outputArray, &quot;, ${argumentType} ${encodedName}&quot;);
5434         }
5435         push(@$outputArray, &quot;)\n&quot;);
5436         push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5437         push(@$outputArray, &quot;    UNUSED_PARAM(lexicalGlobalObject);\n&quot;);</span>
<span class="line-modified">5438         push(@$outputArray, &quot;    VM&amp; vm = JSC::getVM(lexicalGlobalObject);\n&quot;);</span>
<span class="line-modified">5439         push(@$outputArray, &quot;    IGNORE_WARNINGS_BEGIN(\&quot;frame-address\&quot;)\n&quot;);</span>
<span class="line-added">5440         push(@$outputArray, &quot;    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);\n&quot;);</span>
<span class="line-added">5441         push(@$outputArray, &quot;    IGNORE_WARNINGS_END\n&quot;);</span>
<span class="line-added">5442         push(@$outputArray, &quot;    JSC::JITOperationPrologueCallFrameTracer tracer(vm, callFrame);\n&quot;);</span>
5443         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5444         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5445         push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5446         
5447         my $implFunctionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5448         
5449         my @arguments = ();
<span class="line-modified">5450         AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);</span>
5451         
5452         foreach my $argument (@{$operation-&gt;arguments}) {
5453             my $value = &quot;&quot;;
5454             my $type = $argument-&gt;type;
5455             my $name = $argument-&gt;name;
5456             my $encodedName = &quot;encoded&quot; . $codeGenerator-&gt;WK_ucfirst($name);
5457             my $shouldPassByReference = ShouldPassArgumentByReference($argument);
5458 
5459             my ($nativeValue, $mayThrowException) = ToNativeForFunctionWithoutTypeCheck($interface, $argument, $encodedName, $operation-&gt;extendedAttributes-&gt;{Conditional});
5460             push(@$outputArray, &quot;    auto $name = ${nativeValue};\n&quot;);
5461             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $mayThrowException;
5462             $value = &quot;WTFMove($name)&quot;;
5463 
5464             if ($shouldPassByReference) {
5465                 $value = &quot;*$name&quot;;
5466             }
5467             push(@arguments, $value);
5468         }
5469         my $functionString = &quot;$implFunctionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified">5470         $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
5471         push(@$outputArray, &quot;    return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, &quot;*castedThis-&gt;globalObject()&quot;) . &quot;);\n&quot;);
5472         push(@$outputArray, &quot;}\n\n&quot;);
5473 
5474         push(@$outputArray, &quot;#endif\n\n&quot;) if $conditional;
5475     }
5476 
5477     push(@$outputArray, $endAppleCopyright) if $inAppleCopyright;
5478 }
5479 
5480 sub GenerateSerializerDefinition
5481 {
5482     my ($interface, $className) = @_;
5483 
5484     my $interfaceName = $interface-&gt;type-&gt;name;
5485 
5486     my $parentSerializerInterface = 0;
5487     if ($interface-&gt;serializable-&gt;hasInherit) {
5488         $codeGenerator-&gt;ForAllParents($interface, sub {
5489             my $parentInterface = shift;
5490             if ($parentInterface-&gt;serializable &amp;&amp; !$parentSerializerInterface) {
</pre>
<hr />
<pre>
5500         my $foundAttribute = 0;
5501         foreach my $attribute (@{$interface-&gt;attributes}) {
5502             if ($attributeName eq $attribute-&gt;name) {
5503                 $foundAttribute = 1;
5504                 if ($codeGenerator-&gt;IsSerializableAttribute($interface, $attribute)) {
5505                     push(@serializedAttributes, $attribute);                
5506                     last;
5507                 }                    
5508                 die &quot;Explicit \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; is not serializable\n&quot; if !$interface-&gt;serializable-&gt;hasAttribute;
5509                 last;
5510             }
5511         }
5512         die &quot;Failed to find \&quot;serializer\&quot; attribute \&quot;$attributeName\&quot; in $interfaceName\n&quot; if !$foundAttribute;
5513     }
5514 
5515     my $serializerFunctionName = &quot;toJSON&quot;;
5516     my $serializerNativeFunctionName = $codeGenerator-&gt;WK_lcfirst($className) . &quot;PrototypeFunction&quot; . $codeGenerator-&gt;WK_ucfirst($serializerFunctionName);
5517 
5518     AddToImplIncludes(&quot;&lt;JavaScriptCore/ObjectConstructor.h&gt;&quot;);
5519 
<span class="line-modified">5520     push(@implContent, &quot;JSC::JSObject* JS${interfaceName}::serialize(JSGlobalObject&amp; lexicalGlobalObject, ${className}&amp; thisObject, JSDOMGlobalObject&amp; globalObject, ThrowScope&amp; throwScope)\n&quot;);</span>
5521     push(@implContent, &quot;{\n&quot;);
<span class="line-modified">5522     push(@implContent, &quot;    auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);\n&quot;);</span>
5523 
5524     if ($interface-&gt;serializable-&gt;hasInherit) {
5525         my $parentSerializerInterfaceName = $parentSerializerInterface-&gt;type-&gt;name;
<span class="line-modified">5526         push(@implContent, &quot;    auto* result = JS${parentSerializerInterfaceName}::serialize(lexicalGlobalObject, thisObject, globalObject, throwScope);\n&quot;);</span>
5527     } else {
<span class="line-modified">5528         push(@implContent, &quot;    auto* result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());\n&quot;);</span>
5529     }
5530     push(@implContent, &quot;\n&quot;);
5531 
5532     foreach my $attribute (@serializedAttributes) {
5533         # FIXME: Attributes that throw exceptions are not supported with serializers yet.
5534 
5535         my $name = $attribute-&gt;name;
5536         my $getFunctionName = GetAttributeGetterName($interface, $className, $attribute);
<span class="line-modified">5537         push(@implContent, &quot;    auto ${name}Value = ${getFunctionName}Getter(lexicalGlobalObject, thisObject, throwScope);\n&quot;);</span>
5538         push(@implContent, &quot;    throwScope.assertNoException();\n&quot;);
5539 
5540         if ($codeGenerator-&gt;IsInterfaceType($attribute-&gt;type)) {
5541             my $attributeInterfaceName = $attribute-&gt;type-&gt;name;
5542             if ($attribute-&gt;type-&gt;isNullable) {
5543                 push(@implContent, &quot;    if (!${name}Value.isNull()) {\n&quot;);
<span class="line-modified">5544                 push(@implContent, &quot;        auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
5545                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5546                 push(@implContent, &quot;    } else\n&quot;);
5547                 push(@implContent, &quot;        result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5548             } else {
<span class="line-modified">5549                 push(@implContent, &quot;    auto* ${name}SerializedValue = JS${attributeInterfaceName}::serialize(lexicalGlobalObject, *jsCast&lt;JS${attributeInterfaceName}*&gt;(${name}Value), globalObject, throwScope);\n&quot;);</span>
5550                 push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}SerializedValue);\n&quot;);
5551             }
5552         } else {
5553             push(@implContent, &quot;    result-&gt;putDirect(vm, Identifier::fromString(vm, \&quot;${name}\&quot;), ${name}Value);\n&quot;);
5554         }
5555 
5556         push(@implContent, &quot;\n&quot;);
5557     }
5558 
5559     push(@implContent, &quot;    return result;\n&quot;);
5560     push(@implContent, &quot;}\n&quot;);
5561     push(@implContent, &quot;\n&quot;);
5562 
<span class="line-modified">5563     push(@implContent, &quot;static inline EncodedJSValue ${serializerNativeFunctionName}Body(JSGlobalObject* lexicalGlobalObject, CallFrame*, ${className}* thisObject, JSC::ThrowScope&amp; throwScope)\n&quot;);</span>
5564     push(@implContent, &quot;{\n&quot;);
<span class="line-modified">5565     push(@implContent, &quot;    return JSValue::encode(JS${interfaceName}::serialize(*lexicalGlobalObject, *thisObject, *thisObject-&gt;globalObject(), throwScope));\n&quot;);</span>
5566     push(@implContent, &quot;}\n&quot;);
5567     push(@implContent, &quot;\n&quot;);
<span class="line-modified">5568     push(@implContent, &quot;EncodedJSValue JSC_HOST_CALL ${serializerNativeFunctionName}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
5569     push(@implContent, &quot;{\n&quot;);
<span class="line-modified">5570     push(@implContent, &quot;    return IDLOperation&lt;JS${interfaceName}&gt;::call&lt;${serializerNativeFunctionName}Body&gt;(*lexicalGlobalObject, *callFrame, \&quot;${serializerFunctionName}\&quot;);\n&quot;);</span>
5571     push(@implContent, &quot;}\n&quot;);
5572     push(@implContent, &quot;\n&quot;);
5573 }
5574 
5575 sub GenerateGetCallData
5576 {
5577     my ($outputArray, $interface, $className) = @_;
5578 
5579     return if $interface-&gt;extendedAttributes-&gt;{CustomGetCallData};
5580 
5581     if ($interface-&gt;extendedAttributes-&gt;{Plugin}) {
5582         GeneratePluginCall($outputArray, $interface, $className);
5583     } else {
5584         GenerateLegacyCallerDefinitions($outputArray, $interface, $className);
5585     }
5586 }
5587 
5588 sub GeneratePluginCall
5589 {
5590     my ($outputArray, $interface, $className) = @_;
</pre>
<hr />
<pre>
5596     push(@$outputArray, &quot;    auto* thisObject = jsCast&lt;${className}*&gt;(cell);\n&quot;);
5597     push(@$outputArray, &quot;    ASSERT_GC_OBJECT_INHERITS(thisObject, info());\n\n&quot;);
5598 
5599     push(@$outputArray, &quot;    return pluginElementCustomGetCallData(thisObject, callData);\n&quot;);
5600     push(@$outputArray, &quot;}\n&quot;);
5601     push(@$outputArray, &quot;\n&quot;);
5602 }
5603 
5604 sub GenerateLegacyCallerDefinitions
5605 {
5606     my ($outputArray, $interface, $className) = @_;
5607 
5608     my @legacyCallers = @{$interface-&gt;{LegacyCallers}};
5609     if (@legacyCallers &gt; 1) {
5610         foreach my $legacyCaller (@legacyCallers) {
5611             GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCaller);
5612         }
5613 
5614         my $overloadFunctionPrefix = &quot;call${className}&quot;;
5615 
<span class="line-modified">5616         push(@$outputArray, &quot;EncodedJSValue JSC_HOST_CALL ${overloadFunctionPrefix}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
5617         push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5618         push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
5619         push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5620         push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5621 
<span class="line-modified">5622         GenerateOverloadDispatcher($legacyCallers[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);</span>
5623 
5624         push(@$outputArray, &quot;}\n\n&quot;);
5625     } else {
5626         GenerateLegacyCallerDefinition($outputArray, $interface, $className, $legacyCallers[0]);
5627     }
5628 
5629     push(@$outputArray, &quot;CallType ${className}::getCallData(JSCell*, CallData&amp; callData)\n&quot;);
5630     push(@$outputArray, &quot;{\n&quot;);
5631     push(@$outputArray, &quot;    callData.native.function = call${className};\n&quot;);
5632     push(@$outputArray, &quot;    return CallType::Host;\n&quot;);
5633     push(@$outputArray, &quot;}\n&quot;);
5634     push(@$outputArray, &quot;\n&quot;);
5635 }
5636 
5637 sub GenerateLegacyCallerDefinition
5638 {
5639     my ($outputArray, $interface, $className, $operation) = @_;
5640 
5641     my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5642     if ($isOverloaded) {
<span class="line-modified">5643         push(@$outputArray, &quot;static inline EncodedJSValue call${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
5644     } else {
<span class="line-modified">5645         push(@$outputArray, &quot;static EncodedJSValue JSC_HOST_CALL call${className}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
5646     }
5647 
5648     push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">5649     push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
5650     push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
5651     push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
5652 
5653     my $indent = &quot;    &quot;;
5654     GenerateArgumentsCountCheck($outputArray, $operation, $interface, $indent);
5655 
<span class="line-modified">5656     push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${className}*&gt;(callFrame-&gt;jsCallee());\n&quot;);</span>
5657     push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
5658     push(@$outputArray, &quot;    auto&amp; impl = castedThis-&gt;wrapped();\n&quot;);
5659 
5660     my $functionImplementationName = $operation-&gt;extendedAttributes-&gt;{ImplementedAs} || $codeGenerator-&gt;WK_lcfirst($operation-&gt;name) || &quot;legacyCallerOperationFromBindings&quot;;
5661     my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, $indent);
5662 
5663     GenerateImplementationFunctionCall($outputArray, $operation, $interface, $functionString, $indent);
5664 
5665     push(@$outputArray, &quot;}\n\n&quot;);
5666 }
5667 
5668 sub GenerateCallWithUsingReferences
5669 {
5670     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5671 
<span class="line-modified">5672     my $callFramePointer = &quot;callFrame&quot;;</span>
<span class="line-modified">5673     my $callFrameReference = &quot;*callFrame&quot;;</span>
<span class="line-modified">5674     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject)&quot;;</span>
5675 
<span class="line-modified">5676     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);</span>
5677 }
5678 
5679 # FIXME: We should remove GenerateCallWithUsingPointers and combine GenerateCallWithUsingReferences and GenerateCallWith
5680 sub GenerateCallWithUsingPointers
5681 {
5682     my ($callWith, $outputArray, $returnValue, $thisReference, $indent) = @_;
5683 
<span class="line-modified">5684     my $callFramePointer = &quot;callFrame&quot;;</span>
<span class="line-modified">5685     my $callFrameReference = &quot;*callFrame&quot;;</span>
<span class="line-modified">5686     my $globalObject = &quot;jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot;;</span>
5687 
<span class="line-modified">5688     return GenerateCallWith($callWith, $outputArray, $returnValue, $returnValue, $callFramePointer, $callFrameReference, $globalObject, $globalObject, $thisReference, $indent);</span>
5689 }
5690 
5691 sub GenerateConstructorCallWithUsingPointers
5692 {
5693     my ($callWith, $outputArray, $visibleInterfaceName, $thisReference, $indent) = @_;
5694 
<span class="line-modified">5695     my $callFramePointer = &quot;callFrame&quot;;</span>
<span class="line-modified">5696     my $callFrameReference = &quot;*callFrame&quot;;</span>
5697     my $globalObject = &quot;castedThis-&gt;globalObject()&quot;;
<span class="line-modified">5698     my $contextMissing = &quot;throwConstructorScriptExecutionContextUnavailableError(*lexicalGlobalObject, throwScope, \&quot;${visibleInterfaceName}\&quot;)&quot;;</span>
5699     my $scriptExecutionContextAccessor = &quot;castedThis&quot;;
5700 
<span class="line-modified">5701     return GenerateCallWith($callWith, $outputArray, &quot;&quot;, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent);</span>
5702 }
5703 
5704 sub GenerateCallWith
5705 {
<span class="line-modified">5706     my ($callWith, $outputArray, $returnValue, $contextMissing, $callFramePointer, $callFrameReference, $globalObject, $scriptExecutionContextAccessor, $thisReference, $indent) = @_;</span>
5707 
5708     return () unless $callWith;
5709 
5710     $indent ||= &quot;    &quot;;
5711 
5712     my @callWithArgs;
<span class="line-modified">5713     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ExecState&quot;)) {</span>
<span class="line-modified">5714         push(@callWithArgs, &quot;*${globalObject}&quot;);</span>
<span class="line-added">5715         push(@callWithArgs, $callFrameReference);</span>
<span class="line-added">5716     }</span>
<span class="line-added">5717     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;GlobalObject&quot;)) {</span>
<span class="line-added">5718         push(@callWithArgs, &quot;*${globalObject}&quot;);</span>
<span class="line-added">5719     }</span>
5720     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ScriptExecutionContext&quot;)) {
5721         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5722         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5723         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5724         push(@callWithArgs, &quot;*context&quot;);
5725     }
5726     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;Document&quot;)) {
5727         AddToImplIncludes(&quot;Document.h&quot;);
5728         push(@$outputArray, $indent . &quot;auto* context = ${scriptExecutionContextAccessor}-&gt;scriptExecutionContext();\n&quot;);
5729         push(@$outputArray, $indent . &quot;if (UNLIKELY(!context))\n&quot;);
5730         push(@$outputArray, $indent . &quot;    return&quot; . ($contextMissing ? &quot; &quot; . $contextMissing : &quot;&quot;) . &quot;;\n&quot;);
5731         push(@$outputArray, $indent . &quot;ASSERT(context-&gt;isDocument());\n&quot;);
5732         push(@$outputArray, $indent . &quot;auto&amp; document = downcast&lt;Document&gt;(*context);\n&quot;);
5733         push(@callWithArgs, &quot;document&quot;);
5734     }
5735     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentDocument&quot;)) {
5736         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5737         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5738         push(@$outputArray, $indent . &quot;auto* incumbentDocument = incumbentDOMWindow(*$globalObject, $callFrameReference).document();\n&quot;);</span>
5739         push(@$outputArray, $indent . &quot;if (!incumbentDocument)\n&quot;);
5740         push(@$outputArray, $indent . &quot;    return&quot; . ($returnValue ? &quot; &quot; . $returnValue : &quot;&quot;) . &quot;;\n&quot;);
5741         push(@callWithArgs, &quot;*incumbentDocument&quot;);
5742     }
5743     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ResponsibleDocument&quot;)) {
5744         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5745         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5746         push(@callWithArgs, &quot;responsibleDocument(${globalObject}-&gt;vm(), $callFrameReference)&quot;);</span>
5747     }
5748     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;ActiveWindow&quot;)) {
5749         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5750         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5751         push(@callWithArgs, &quot;activeDOMWindow(*$globalObject)&quot;);</span>
5752     }
5753     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;FirstWindow&quot;)) {
5754         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5755         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5756         push(@callWithArgs, &quot;firstDOMWindow(*$globalObject)&quot;);</span>
5757     }
5758     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;IncumbentWindow&quot;)) {
5759         AddToImplIncludes(&quot;DOMWindow.h&quot;);
5760         AddToImplIncludes(&quot;JSDOMWindowBase.h&quot;);
<span class="line-modified">5761         push(@callWithArgs, &quot;incumbentDOMWindow(*$globalObject, $callFrameReference)&quot;);</span>
5762     }
5763     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;RuntimeFlags&quot;)) {
5764         push(@callWithArgs, &quot;${globalObject}-&gt;runtimeFlags()&quot;);
5765     }
5766     if ($codeGenerator-&gt;ExtendedAttributeContains($callWith, &quot;World&quot;)) {
5767         push(@callWithArgs, &quot;worldForDOMObject(${thisReference})&quot;);
5768     }
5769 
5770     return @callWithArgs;
5771 }
5772 
5773 sub GenerateArgumentsCountCheck
5774 {
5775     my ($outputArray, $operation, $interface, $indent) = @_;
5776 
5777     # Overloaded operations don&#39;t need to check the argument count since the 
5778     # dispatch function does for them.
5779     return if $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
5780 
5781     my $numMandatoryArguments = @{$operation-&gt;arguments};
5782     foreach my $argument (reverse(@{$operation-&gt;arguments})) {
5783         if ($argument-&gt;isOptional or $argument-&gt;isVariadic) {
5784             $numMandatoryArguments--;
5785         } else {
5786             last;
5787         }
5788     }
5789     if ($numMandatoryArguments &gt;= 1) {
<span class="line-modified">5790         push(@$outputArray, $indent . &quot;if (UNLIKELY(callFrame-&gt;argumentCount() &lt; $numMandatoryArguments))\n&quot;);</span>
<span class="line-modified">5791         push(@$outputArray, $indent . &quot;    return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));\n&quot;);</span>
5792     }
5793 }
5794 
5795 my %automaticallyGeneratedDefaultValues = (
5796     &quot;any&quot; =&gt; &quot;undefined&quot;,
5797 
5798     # toString() will convert undefined to the string &quot;undefined&quot;;
5799     # (note that this optimizes a behavior that is almost never useful)
5800     &quot;DOMString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5801     &quot;USVString&quot; =&gt; &quot;\&quot;undefined\&quot;&quot;,
5802 
5803     # JSValue::toBoolean() will convert undefined to false.
5804     &quot;boolean&quot; =&gt; &quot;false&quot;,
5805 
5806     # JSValue::toInt*() / JSValue::toUint*() will convert undefined to 0.
5807     &quot;byte&quot; =&gt; &quot;0&quot;,
5808     &quot;long long&quot; =&gt; &quot;0&quot;,
5809     &quot;long&quot; =&gt; &quot;0&quot;,
5810     &quot;octet&quot; =&gt; &quot;0&quot;,
5811     &quot;short&quot; =&gt; &quot;0&quot;,
</pre>
<hr />
<pre>
5838     my ($operation) = @_;
5839 
5840     return 0 unless $operation-&gt;extendedAttributes-&gt;{MayThrowException};
5841 
5842     return $operation-&gt;type &amp;&amp; ($operation-&gt;type-&gt;name eq &quot;void&quot; || $codeGenerator-&gt;IsPromiseType($operation-&gt;type) || OperationHasForcedReturnValue($operation));
5843 }
5844 
5845 sub GenerateParametersCheck
5846 {
5847     my ($outputArray, $operation, $interface, $functionImplementationName, $indent) = @_;
5848 
5849     my $interfaceName = $interface-&gt;type-&gt;name;
5850     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
5851     my $numArguments = @{$operation-&gt;arguments};
5852     my $conditional = $operation-&gt;extendedAttributes-&gt;{Conditional};
5853     my $isConstructor = $operation-&gt;extendedAttributes-&gt;{Constructor} || $operation-&gt;extendedAttributes-&gt;{NamedConstructor};
5854 
5855     my $functionName = GetFullyQualifiedImplementationCallName($interface, $operation, $functionImplementationName, &quot;impl&quot;, $conditional);
5856     
5857     my @arguments = ();
<span class="line-modified">5858     AddAdditionalArgumentsForImplementationCall(\@arguments, $interface, $operation, &quot;impl&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*callFrame&quot;, &quot;*castedThis&quot;);</span>
5859     
5860     my $quotedFunctionName;
5861     if (!$isConstructor) {
5862         my $name = $operation-&gt;name;
5863         $quotedFunctionName = &quot;\&quot;$name\&quot;&quot;;
5864         push(@arguments, GenerateCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{CallWith}, \@$outputArray, &quot;JSValue::encode(jsUndefined())&quot;, &quot;*castedThis&quot;));
5865     } else {
5866         $quotedFunctionName = &quot;nullptr&quot;;
5867         push(@arguments, GenerateConstructorCallWithUsingPointers($operation-&gt;extendedAttributes-&gt;{ConstructorCallWith}, \@$outputArray, $visibleInterfaceName, &quot;*castedThis&quot;));
5868     }
5869 
5870     my $argumentIndex = 0;
5871     foreach my $argument (@{$operation-&gt;arguments}) {
5872         my $type = $argument-&gt;type;
5873 
5874         assert &quot;Optional arguments of non-nullable wrapper types are not supported (&quot; . $operation-&gt;name . &quot;)&quot; if $argument-&gt;isOptional &amp;&amp; !$type-&gt;isNullable &amp;&amp; $codeGenerator-&gt;IsWrapperType($type);
5875 
5876         if ($argument-&gt;isOptional &amp;&amp; !defined($argument-&gt;default)) {
5877             # As per Web IDL, optional dictionary arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
5878             $argument-&gt;default(&quot;[]&quot;) if $codeGenerator-&gt;IsDictionaryType($type);
</pre>
<hr />
<pre>
5886             # We use the null string as default value for arguments of type DOMString unless specified otherwise.
5887             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsStringType($type);
5888 
5889             # As per Web IDL, passing undefined for a nullable argument is treated as null. Therefore, use null as
5890             # default value for nullable arguments unless otherwise specified.
5891             $argument-&gt;default(&quot;null&quot;) if $type-&gt;isNullable;
5892 
5893             # For callback arguments, the generated bindings treat undefined as null, so use null as implicit default value.
5894             $argument-&gt;default(&quot;null&quot;) if $codeGenerator-&gt;IsCallbackInterface($type) || $codeGenerator-&gt;IsCallbackFunction($type);
5895         }
5896 
5897         my $name = $argument-&gt;name;
5898         my $value = $name;
5899 
5900         if ($argument-&gt;isVariadic) {
5901             AddToImplIncludes(&quot;JSDOMConvertVariadic.h&quot;, $conditional);
5902             AddToImplIncludesForIDLType($type, $conditional);
5903         
5904             my $IDLType = GetIDLType($interface, $type);
5905 
<span class="line-modified">5906             push(@$outputArray, $indent . &quot;auto ${name} = convertVariadicArguments&lt;${IDLType}&gt;(*lexicalGlobalObject, *callFrame, ${argumentIndex});\n&quot;);</span>
5907             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5908 
5909             $value = &quot;WTFMove(${name})&quot;;
5910         } else {
5911             my $argumentLookupForConversion;
5912             my $optionalCheck;
5913             my $nativeValueCastFunction;
5914 
5915             if ($argument-&gt;isOptional) {
5916                 assert(&quot;[ReturnValue] is not supported for optional arguments&quot;) if $argument-&gt;extendedAttributes-&gt;{ReturnValue};
5917 
5918                 if (defined($argument-&gt;default)) {
5919                     if (WillConvertUndefinedToDefaultParameterValue($type, $argument-&gt;default)) {
<span class="line-modified">5920                         $argumentLookupForConversion = &quot;callFrame-&gt;argument($argumentIndex)&quot;;</span>
5921                     } else {
5922                         my $defaultValue = GenerateDefaultValue($interface, $argument, $argument-&gt;type, $argument-&gt;default);
<span class="line-modified">5923                         $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="line-modified">5924                         $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;</span>
5925                     }
5926                 } else {
5927                     my $argumentIDLType = GetIDLType($interface, $argument-&gt;type);
5928 
5929                     my $defaultValue;
5930                     if ($codeGenerator-&gt;IsPromiseType($argument-&gt;type)) {
5931                         $defaultValue = &quot;nullptr&quot;;
5932                     } else {
5933                         $defaultValue = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;()&quot;;
5934                         $nativeValueCastFunction = &quot;Optional&lt;Converter&lt;$argumentIDLType&gt;::ReturnType&gt;&quot;;
5935                     }
5936 
<span class="line-modified">5937                     $optionalCheck = &quot;callFrame-&gt;argument($argumentIndex).isUndefined() ? $defaultValue : &quot;;</span>
<span class="line-modified">5938                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
5939                 }
5940             } else {
5941                 if ($argument-&gt;extendedAttributes-&gt;{ReturnValue}) {
<span class="line-modified">5942                     push(@$outputArray, $indent . &quot;auto returnValue = callFrame-&gt;uncheckedArgument($argumentIndex);\n&quot;);</span>
5943                     $argumentLookupForConversion = &quot;returnValue&quot;;
5944                 } else {
<span class="line-modified">5945                     $argumentLookupForConversion = &quot;callFrame-&gt;uncheckedArgument($argumentIndex)&quot;;</span>
5946                 }
5947             }
5948 
<span class="line-modified">5949             my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
5950             my $argumentExceptionThrower = GetArgumentExceptionThrower($interface, $argument, $argumentIndex, $quotedFunctionName);
5951 
<span class="line-modified">5952             my $nativeValue = JSValueToNative($interface, $argument, $argumentLookupForConversion, $conditional, &quot;lexicalGlobalObject&quot;, &quot;*lexicalGlobalObject&quot;, &quot;*castedThis&quot;, $globalObjectReference, $argumentExceptionThrower);</span>
5953 
5954             $nativeValue = &quot;${nativeValueCastFunction}(&quot; . $nativeValue . &quot;)&quot; if defined $nativeValueCastFunction;
5955             $nativeValue = $optionalCheck . $nativeValue if defined $optionalCheck;
5956 
5957             push(@$outputArray, $indent . &quot;auto $name = ${nativeValue};\n&quot;);
5958             push(@$outputArray, $indent . &quot;RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;);
5959 
5960             $value = PassArgumentExpression($name, $argument);
5961         }
5962 
5963         push(@arguments, $value);
5964         $argumentIndex++;
5965     }
5966 
5967     push(@arguments, &quot;WTFMove(promise)&quot;) if $operation-&gt;type &amp;&amp; $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy};
5968 
5969     my $functionString = &quot;$functionName(&quot; . join(&quot;, &quot;, @arguments) . &quot;)&quot;;
<span class="line-modified">5970     $functionString = &quot;propagateException(*lexicalGlobalObject, throwScope, $functionString)&quot; if NeedsExplicitPropagateExceptionCall($operation);</span>
5971 
5972     return $functionString;
5973 }
5974 
5975 sub GenerateDictionaryHeader
5976 {
5977     my ($object, $dictionary, $className, $enumerations, $otherDictionaries) = @_;
5978 
5979     # - Add default header template and header protection.
5980     push(@headerContentHeader, GenerateHeaderContentHeader($dictionary));
5981 
5982     $headerIncludes{&quot;${className}.h&quot;} = 1;
5983 
5984     push(@headerContent, &quot;\nnamespace WebCore {\n\n&quot;);
5985     push(@headerContent, GenerateDictionaryHeaderContent($dictionary, $className));
5986     push(@headerContent, GenerateEnumerationsHeaderContent($dictionary, $enumerations));
5987     push(@headerContent, GenerateDictionariesHeaderContent($dictionary, $otherDictionaries)) if $otherDictionaries;
5988     push(@headerContent, &quot;} // namespace WebCore\n&quot;);
5989 
5990     my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($dictionary);
</pre>
<hr />
<pre>
6312                 AddToIncludesForIDLType($argument-&gt;type, $includesRef, 1);
6313                 my $IDLType = GetIDLType($interfaceOrCallback, $argument-&gt;type);
6314                 push(@arguments, &quot;typename ${IDLType}::ParameterType &quot; . $argument-&gt;name);
6315             }
6316             
6317             push(@$contentRef, &quot;${nativeReturnType} ${className}::${functionName}(&quot; . join(&quot;, &quot;, @arguments) . &quot;)\n&quot;);
6318             push(@$contentRef, &quot;{\n&quot;);
6319 
6320             # FIXME: This is needed for NodeFilter, which works even for disconnected iframes. We should investigate
6321             # if that behavior is needed for other callbacks.
6322             if (!$operation-&gt;extendedAttributes-&gt;{SkipCallbackInvokeCheck}) {
6323                 push(@$contentRef, &quot;    if (!canInvokeCallback())\n&quot;);
6324                 push(@$contentRef, &quot;        return CallbackResultType::UnableToExecute;\n\n&quot;);
6325             }
6326 
6327             push(@$contentRef, &quot;    Ref&lt;$className&gt; protectedThis(*this);\n\n&quot;);
6328             push(@$contentRef, &quot;    auto&amp; globalObject = *m_data-&gt;globalObject();\n&quot;);
6329             push(@$contentRef, &quot;    auto&amp; vm = globalObject.vm();\n\n&quot;);
6330             push(@$contentRef, &quot;    JSLockHolder lock(vm);\n&quot;);
6331 
<span class="line-modified">6332             push(@$contentRef, &quot;    auto&amp; lexicalGlobalObject = globalObject;\n&quot;);</span>
6333 
6334             push(@$contentRef, &quot;    JSValue thisValue = ${thisValue};\n&quot;);
6335             push(@$contentRef, &quot;    MarkedArgumentBuffer args;\n&quot;);
6336 
6337             foreach my $argument (@{$operation-&gt;arguments}) {
6338                 push(@$contentRef, &quot;    args.append(&quot; . NativeToJSValueUsingReferences($argument, $interfaceOrCallback, $argument-&gt;name, &quot;globalObject&quot;) . &quot;);\n&quot;);
6339             }
6340             push(@$contentRef, &quot;    ASSERT(!args.hasOverflowed());\n&quot;);
6341 
6342             push(@$contentRef, &quot;\n    NakedPtr&lt;JSC::Exception&gt; returnedException;\n&quot;);
6343 
6344             my $callbackInvocation;
6345             if (ref($interfaceOrCallback) eq &quot;IDLCallbackFunction&quot;) {
6346                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::Function, Identifier(), returnedException)&quot;;
6347             } else {
6348                 my $callbackType = $numOperations &gt; 1 ? &quot;Object&quot; : &quot;FunctionOrObject&quot;;
6349                 $callbackInvocation = &quot;m_data-&gt;invokeCallback(thisValue, args, JSCallbackData::CallbackType::${callbackType}, Identifier::fromString(vm, \&quot;${functionName}\&quot;), returnedException)&quot;;
6350             }
6351 
6352             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6353                 push(@$contentRef, &quot;    ${callbackInvocation};\n&quot;);
6354             } else {
6355                 push(@$contentRef, &quot;    auto jsResult = ${callbackInvocation};\n&quot;);
6356             }
6357 
6358             $includesRef-&gt;{&quot;JSDOMExceptionHandling.h&quot;} = 1;
6359             push(@$contentRef, &quot;    if (returnedException) {\n&quot;);
6360             if ($operation-&gt;extendedAttributes-&gt;{RethrowException}) {
6361                 push(@$contentRef, &quot;        auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
<span class="line-modified">6362                 push(@$contentRef, &quot;        throwException(&amp;lexicalGlobalObject, throwScope, returnedException);\n&quot;);</span>
6363             } else {
<span class="line-modified">6364                 push(@$contentRef, &quot;        reportException(&amp;lexicalGlobalObject, returnedException);\n&quot;);</span>
6365             }
6366             push(@$contentRef, &quot;        return CallbackResultType::ExceptionThrown;\n&quot;);
6367             push(@$contentRef, &quot;     }\n\n&quot;);
6368 
6369             if ($operation-&gt;type-&gt;name eq &quot;void&quot;) {
6370                 push(@$contentRef, &quot;    return { };\n&quot;);
6371             } else {
<span class="line-modified">6372                 my $nativeValue = JSValueToNative($interfaceOrCallback, $operation, &quot;jsResult&quot;, &quot;&quot;, &quot;&amp;lexicalGlobalObject&quot;, &quot;lexicalGlobalObject&quot;);</span>
6373             
6374                 push(@$contentRef, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
6375                 push(@$contentRef, &quot;    auto returnValue = ${nativeValue};\n&quot;);
6376                 push(@$contentRef, &quot;    RETURN_IF_EXCEPTION(throwScope, CallbackResultType::ExceptionThrown);\n&quot;);
6377                 push(@$contentRef, &quot;    return returnValue;\n&quot;);
6378             }
6379 
6380             push(@$contentRef, &quot;}\n\n&quot;);
6381         }
6382     }
6383 
6384     if ($interfaceOrCallback-&gt;extendedAttributes-&gt;{IsWeakCallback}) {
6385         push(@$contentRef, &quot;void ${className}::visitJSFunction(JSC::SlotVisitor&amp; visitor)\n&quot;);
6386         push(@$contentRef, &quot;{\n&quot;);
6387         push(@$contentRef, &quot;    m_data-&gt;visitJSFunction(visitor);\n&quot;);
6388         push(@$contentRef, &quot;}\n\n&quot;);
6389     }
6390 
6391     push(@$contentRef, &quot;JSC::JSValue toJS(${name}&amp; impl)\n&quot;);
6392     push(@$contentRef, &quot;{\n&quot;);
</pre>
<hr />
<pre>
6396     push(@$contentRef, &quot;}\n\n&quot;);
6397 }
6398 
6399 sub GenerateImplementationFunctionCall
6400 {
6401     my ($outputArray, $operation, $interface, $functionString, $indent) = @_;
6402 
6403     my $callTracingCallback = $operation-&gt;extendedAttributes-&gt;{CallTracingCallback} || $interface-&gt;extendedAttributes-&gt;{CallTracingCallback};
6404     if ($callTracingCallback) {
6405         my @callTracerArguments = map { $_-&gt;name } @{$operation-&gt;arguments};
6406         GenerateCallTracer($outputArray, $callTracingCallback, $operation-&gt;name, \@callTracerArguments, $indent);
6407     }
6408 
6409     if (OperationHasForcedReturnValue($operation)) {
6410         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6411         push(@$outputArray, $indent . &quot;return JSValue::encode(returnValue);\n&quot;);
6412     } elsif ($operation-&gt;type-&gt;name eq &quot;void&quot; || ($codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{PromiseProxy})) {
6413         push(@$outputArray, $indent . &quot;$functionString;\n&quot;);
6414         push(@$outputArray, $indent . &quot;return JSValue::encode(jsUndefined());\n&quot;);
6415     } else {
<span class="line-modified">6416         my $globalObjectReference = $operation-&gt;isStatic ? &quot;*jsCast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject)&quot; : &quot;*castedThis-&gt;globalObject()&quot;;</span>
6417         push(@$outputArray, $indent . &quot;return JSValue::encode(&quot; . NativeToJSValueUsingPointers($operation, $interface, $functionString, $globalObjectReference) . &quot;);\n&quot;);
6418     }
6419 }
6420 
6421 sub GenerateImplementationCustomFunctionCall
6422 {
6423     my ($outputArray, $operation, $interface, $className, $functionImplementationName, $indent) = @_;
6424 
6425     my @customFunctionArguments = ();
<span class="line-modified">6426     push(@customFunctionArguments, &quot;*lexicalGlobalObject&quot;);</span>
<span class="line-added">6427     push(@customFunctionArguments, &quot;*callFrame&quot;);</span>
6428     push(@customFunctionArguments, &quot;WTFMove(promise)&quot;) if $codeGenerator-&gt;IsPromiseType($operation-&gt;type) &amp;&amp; !$operation-&gt;extendedAttributes-&gt;{ReturnsOwnPromise};
6429 
6430     if ($operation-&gt;isStatic) {
6431         push(@$outputArray, $indent . &quot;return JSValue::encode(${className}::&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6432     } else {
6433         push(@$outputArray, $indent . &quot;return JSValue::encode(castedThis-&gt;&quot; . $functionImplementationName . &quot;(&quot; . join(&quot;, &quot;, @customFunctionArguments) . &quot;));\n&quot;);
6434     }
6435 }
6436 
6437 sub IsValueIterableInterface
6438 {
6439     my $interface = shift;
6440     return 0 unless $interface-&gt;iterable;
6441     return 0 if length $interface-&gt;iterable-&gt;keyType;
6442     # FIXME: See https://webkit.org/b/159140, we should die if the next check is false.
6443     return 0 unless GetIndexedGetterOperation($interface);
6444     return 1;
6445 }
6446 
6447 sub IsKeyValueIterableInterface
</pre>
<hr />
<pre>
6455 sub GenerateIterableDefinition
6456 {
6457     my $interface = shift;
6458 
6459     my $interfaceName = $interface-&gt;type-&gt;name;
6460     my $className = &quot;JS$interfaceName&quot;;
6461     my $visibleInterfaceName = $codeGenerator-&gt;GetVisibleInterfaceName($interface);
6462 
6463     AddToImplIncludes(&quot;JSDOMIterator.h&quot;);
6464 
6465     return unless IsKeyValueIterableInterface($interface);
6466 
6467     my $iteratorName = &quot;${interfaceName}Iterator&quot;;
6468     my $iteratorPrototypeName = &quot;${interfaceName}IteratorPrototype&quot;;
6469 
6470     my $iteratorTraitsName = &quot;${interfaceName}IteratorTraits&quot;;
6471     my $iteratorTraitsType = $interface-&gt;iterable-&gt;isKeyValue ? &quot;JSDOMIteratorType::Map&quot; : &quot;JSDOMIteratorType::Set&quot;;
6472     my $iteratorTraitsKeyType = $interface-&gt;iterable-&gt;isKeyValue ? GetIDLType($interface, $interface-&gt;iterable-&gt;keyType) : &quot;void&quot;;
6473     my $iteratorTraitsValueType = GetIDLType($interface, $interface-&gt;iterable-&gt;valueType);
6474 
<span class="line-added">6475     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;keyType) if $interface-&gt;iterable-&gt;isKeyValue;</span>
<span class="line-added">6476     AddToImplIncludesForIDLType($interface-&gt;iterable-&gt;valueType);</span>
<span class="line-added">6477 </span>
6478     push(@implContent,  &lt;&lt;END);
6479 struct ${iteratorTraitsName} {
6480     static constexpr JSDOMIteratorType type = ${iteratorTraitsType};
6481     using KeyType = ${iteratorTraitsKeyType};
6482     using ValueType = ${iteratorTraitsValueType};
6483 };
6484 
6485 using ${iteratorName} = JSDOMIterator&lt;${className}, ${iteratorTraitsName}&gt;;
6486 using ${iteratorPrototypeName} = JSDOMIteratorPrototype&lt;${className}, ${iteratorTraitsName}&gt;;
6487 
6488 template&lt;&gt;
6489 const JSC::ClassInfo ${iteratorName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorName}) };
6490 
6491 template&lt;&gt;
6492 const JSC::ClassInfo ${iteratorPrototypeName}::s_info = { &quot;${visibleInterfaceName} Iterator&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(${iteratorPrototypeName}) };
6493 
6494 END
6495 
6496     foreach my $operation (@{$interface-&gt;iterable-&gt;operations}) {
6497         my $propertyName = $operation-&gt;name;
6498         my $functionName = GetFunctionName($interface, $className, $operation);
6499 
6500         next if $propertyName eq &quot;[Symbol.Iterator]&quot;;
6501 
6502         if ($propertyName eq &quot;forEach&quot;) {
6503             push(@implContent,  &lt;&lt;END);
<span class="line-modified">6504 static inline EncodedJSValue ${functionName}Caller(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, JS$interfaceName* thisObject, JSC::ThrowScope&amp; throwScope)</span>
6505 {
<span class="line-modified">6506     return JSValue::encode(iteratorForEach&lt;${iteratorName}&gt;(*lexicalGlobalObject, *callFrame, *thisObject, throwScope));</span>
6507 }
6508 
6509 END
6510         } else {
<span class="line-modified">6511             my $iterationKind = &quot;Entries&quot;;</span>
<span class="line-modified">6512             $iterationKind = &quot;Keys&quot; if $propertyName eq &quot;keys&quot;;</span>
<span class="line-modified">6513             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;values&quot;;</span>
<span class="line-modified">6514             $iterationKind = &quot;Values&quot; if $propertyName eq &quot;entries&quot; and not $interface-&gt;iterable-&gt;isKeyValue;</span>
6515 
6516             push(@implContent,  &lt;&lt;END);
<span class="line-modified">6517 static inline EncodedJSValue ${functionName}Caller(JSGlobalObject*, CallFrame*, JS$interfaceName* thisObject, JSC::ThrowScope&amp;)</span>
6518 {
6519     return JSValue::encode(iteratorCreate&lt;${iteratorName}&gt;(*thisObject, IterationKind::${iterationKind}));
6520 }
6521 
6522 END
6523         }
6524 
6525         push(@implContent,  &lt;&lt;END);
<span class="line-modified">6526 JSC::EncodedJSValue JSC_HOST_CALL ${functionName}(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)</span>
6527 {
<span class="line-modified">6528     return IDLOperation&lt;${className}&gt;::call&lt;${functionName}Caller&gt;(*lexicalGlobalObject, *callFrame, &quot;${propertyName}&quot;);</span>
6529 }
6530 
6531 END
6532     }
6533 }
6534 
6535 # http://heycam.github.io/webidl/#dfn-flattened-union-member-types
6536 sub GetFlattenedMemberTypes
6537 {
6538     my ($idlUnionType) = @_;
6539 
6540     my @flattenedMemberTypes = ();
6541 
6542     foreach my $memberType (@{$idlUnionType-&gt;subtypes}) {
6543         if ($memberType-&gt;isUnion) {
6544             push(@flattenedMemberTypes, GetFlattenedMemberTypes($memberType));
6545         } else {
6546             push(@flattenedMemberTypes, $memberType);
6547         }
6548     }
</pre>
<hr />
<pre>
6699     return 0 if $codeGenerator-&gt;IsCallbackFunction($type);
6700     return 0 if !$codeGenerator-&gt;IsWrapperType($type) &amp;&amp; !$codeGenerator-&gt;IsBufferSourceType($type);
6701 
6702     return 1;
6703 }
6704 
6705 sub JSValueToNativeDOMConvertNeedsThisObject
6706 {
6707     my $type = shift;
6708 
6709     return 1 if $type-&gt;name eq &quot;EventListener&quot;;
6710     return 0;
6711 }
6712 
6713 sub JSValueToNativeDOMConvertNeedsGlobalObject
6714 {
6715     my $type = shift;
6716 
6717     return 1 if $codeGenerator-&gt;IsCallbackInterface($type);
6718     return 1 if $codeGenerator-&gt;IsCallbackFunction($type);
<span class="line-added">6719     return JSValueToNativeDOMConvertNeedsGlobalObject(@{$type-&gt;subtypes}[1]) if $codeGenerator-&gt;IsRecordType($type);</span>
6720     return 1 if $type-&gt;name eq &quot;ScheduledAction&quot;;
6721     return 0;
6722 }
6723 
6724 sub IsValidContextForJSValueToNative
6725 {
6726     my $context = shift;
6727     return (ref($context) eq &quot;IDLAttribute&quot; &amp;&amp; !$codeGenerator-&gt;IsEnumType($context-&gt;type)) || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6728 }
6729 
6730 sub JSValueToNative
6731 {
<span class="line-modified">6732     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference, $globalObjectReference, $exceptionThrower) = @_;</span>
6733 
6734     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6735 
6736     my $type = $context-&gt;type;
6737 
6738     # FIXME: Remove these 3 variables when all JSValueToNative use references.
<span class="line-modified">6739     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;</span>
<span class="line-modified">6740     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;</span>
6741     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6742 
6743     AddToImplIncludesForIDLType($type, $conditional);
6744     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6745 
6746     my $IDLType = GetIDLType($interface, $type);
6747 
6748     my @conversionArguments = ();
<span class="line-modified">6749     push(@conversionArguments, $lexicalGlobalObjectReference);</span>
6750     push(@conversionArguments, $value);
6751     push(@conversionArguments, $thisObjectReference) if JSValueToNativeDOMConvertNeedsThisObject($type);
6752     push(@conversionArguments, $globalObjectReference) if JSValueToNativeDOMConvertNeedsGlobalObject($type);
6753     push(@conversionArguments, $exceptionThrower) if $exceptionThrower;
6754 
6755     return &quot;convert&lt;$IDLType&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6756 }
6757 
6758 sub ToNativeForFunctionWithoutTypeCheck
6759 {
<span class="line-modified">6760     my ($interface, $context, $value, $conditional, $lexicalGlobalObjectPointer, $lexicalGlobalObjectReference, $thisObjectReference) = @_;</span>
6761 
6762     assert(&quot;Invalid context type&quot;) if !IsValidContextForJSValueToNative($context);
6763 
6764     my $type = $context-&gt;type;
6765 
6766     # FIXME: Remove these 3 variables when all JSValueToNative use references.
<span class="line-modified">6767     $lexicalGlobalObjectPointer = &quot;lexicalGlobalObject&quot; unless $lexicalGlobalObjectPointer;</span>
<span class="line-modified">6768     $lexicalGlobalObjectReference = &quot;*lexicalGlobalObject&quot; unless $lexicalGlobalObjectReference;</span>
6769     $thisObjectReference = &quot;*castedThis&quot; unless $thisObjectReference;
6770 
6771     AddToImplIncludesForIDLType($type, $conditional);
6772 
6773     # FIXME: Support more types.
6774 
6775     AddToImplIncludes(&quot;DOMJITIDLConvert.h&quot;);
6776 
6777     my $IDLType = GetIDLType($interface, $type);
6778 
6779     my @conversionArguments = ();
<span class="line-modified">6780     push(@conversionArguments, &quot;$lexicalGlobalObjectReference&quot;);</span>
6781     push(@conversionArguments, &quot;$value&quot;);
6782 
6783     return (&quot;DOMJIT::DirectConverter&lt;$IDLType&gt;::directConvert(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;, 1);
6784 }
6785 
6786 sub NativeToJSValueDOMConvertNeedsState
6787 {
6788     my ($type) = @_;
6789 
6790     # FIXME: We need a more robust way to specify this requirement so as not
6791     # to require specializing each type. Perhaps just requiring all override
<span class="line-modified">6792     # types to take both lexicalGlobalObject and the global object would work?</span>
6793     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6794         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6795         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6796         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6797         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6798 
6799         return 0;
6800     }
6801 
<span class="line-modified">6802     # FIXME: This should actually check if all the sub-objects of the union need the lexicalGlobalObject.</span>
6803     return 1 if $type-&gt;isUnion;
6804     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6805     return 1 if $codeGenerator-&gt;IsRecordType($type);
6806     return 1 if $codeGenerator-&gt;IsStringType($type);
6807     return 1 if $codeGenerator-&gt;IsEnumType($type);
6808     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6809     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6810     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6811     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6812     return 1 if $type-&gt;name eq &quot;Date&quot;;
6813     return 1 if $type-&gt;name eq &quot;JSON&quot;;
6814     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6815     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6816     
6817     return 0;
6818 }
6819 
6820 sub NativeToJSValueDOMConvertNeedsGlobalObject
6821 {
6822     my ($type) = @_;
6823     
6824     # FIXME: We need a more robust way to specify this requirement so as not
6825     # to require specializing each type. Perhaps just requiring all override
<span class="line-modified">6826     # types to take both lexicalGlobalObject and the global object would work?</span>
6827     if ($type-&gt;extendedAttributes-&gt;{OverrideIDLType}) {
6828         my $overrideTypeName = $type-&gt;extendedAttributes-&gt;{OverrideIDLType};
6829         return 1 if $overrideTypeName eq &quot;IDLIDBKey&quot;;
6830         return 1 if $overrideTypeName eq &quot;IDLWebGLAny&quot;;
6831         return 1 if $overrideTypeName eq &quot;IDLWebGLExtension&quot;;
6832 
6833         return 0;
6834     }
6835 
6836     # FIXME: This should actually check if all the sub-objects of the union need the global object.
6837     return 1 if $type-&gt;isUnion;
6838     return 1 if $codeGenerator-&gt;IsSequenceOrFrozenArrayType($type);
6839     return 1 if $codeGenerator-&gt;IsRecordType($type);
6840     return 1 if $codeGenerator-&gt;IsDictionaryType($type);
6841     return 1 if $codeGenerator-&gt;IsInterfaceType($type);
6842     return 1 if $codeGenerator-&gt;IsBufferSourceType($type);
6843     return 1 if $codeGenerator-&gt;IsPromiseType($type);
6844     return 1 if $type-&gt;name eq &quot;SerializedScriptValue&quot;;
6845     return 1 if $type-&gt;name eq &quot;XPathNSResolver&quot;;
6846 
6847     return 0;
6848 }
6849 
6850 sub NativeToJSValueUsingReferences
6851 {
6852     my ($context, $interface, $value, $globalObjectReference) = @_;
6853 
<span class="line-modified">6854     return NativeToJSValue($context, $interface, $value, &quot;lexicalGlobalObject&quot;, $globalObjectReference);</span>
6855 }
6856 
6857 # FIXME: We should remove NativeToJSValueUsingPointers and combine NativeToJSValueUsingReferences and NativeToJSValue
6858 sub NativeToJSValueUsingPointers
6859 {
6860     my ($context, $interface, $value, $globalObjectReference) = @_;
6861 
<span class="line-modified">6862     return NativeToJSValue($context, $interface, $value, &quot;*lexicalGlobalObject&quot;, $globalObjectReference);</span>
6863 }
6864 
6865 sub IsValidContextForNativeToJSValue
6866 {
6867     my $context = shift;
6868     
6869     return ref($context) eq &quot;IDLAttribute&quot; || ref($context) eq &quot;IDLArgument&quot; || ref($context) eq &quot;IDLDictionaryMember&quot; || ref($context) eq &quot;IDLOperation&quot;;
6870 }
6871 
6872 sub NativeToJSValue
6873 {
<span class="line-modified">6874     my ($context, $interface, $value, $lexicalGlobalObjectReference, $globalObjectReference) = @_;</span>
6875 
6876     assert(&quot;Invalid context type&quot;) if !IsValidContextForNativeToJSValue($context);
6877 
6878     my $conditional = $context-&gt;extendedAttributes-&gt;{Conditional};
6879     my $type = $context-&gt;type;
6880     my $mayThrowException = ref($context) eq &quot;IDLAttribute&quot; || $context-&gt;extendedAttributes-&gt;{MayThrowException};
6881 
6882     # We could instead overload a function to work with optional as well as non-optional numbers, but this
6883     # is slightly better because it guarantees we will fail to compile if the IDL file doesn&#39;t match the C++.
6884     if ($context-&gt;extendedAttributes-&gt;{Reflect} and ($type-&gt;name eq &quot;unsigned long&quot; or $type-&gt;name eq &quot;unsigned short&quot;)) {
6885         $value =~ s/getUnsignedIntegralAttribute/getIntegralAttribute/g;
6886         $value = &quot;std::max(0, $value)&quot;;
6887     }
6888 
6889     AddToImplIncludesForIDLType($type, $conditional);
6890     AddToImplIncludes(&quot;JSDOMGlobalObject.h&quot;, $conditional) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6891 
6892     if ($context-&gt;extendedAttributes-&gt;{CheckSecurityForNode}) {
6893         AddToImplIncludes(&quot;JSDOMBindingSecurity.h&quot;, $conditional);
<span class="line-modified">6894         $value = &quot;BindingSecurity::checkSecurityForNode($lexicalGlobalObjectReference, $value)&quot;;</span>
6895     }
6896 
6897     my $IDLType = GetIDLType($interface, $type);
6898 
6899     my @conversionArguments = ();
<span class="line-modified">6900     push(@conversionArguments, $lexicalGlobalObjectReference) if NativeToJSValueDOMConvertNeedsState($type) || $mayThrowException;</span>
6901     push(@conversionArguments, $globalObjectReference) if NativeToJSValueDOMConvertNeedsGlobalObject($type);
6902     push(@conversionArguments, &quot;throwScope&quot;) if $mayThrowException;
6903     push(@conversionArguments, $value);
6904 
6905     my $functionName = $context-&gt;extendedAttributes-&gt;{NewObject} ? &quot;toJSNewlyCreated&quot; : &quot;toJS&quot;;
6906 
6907     return &quot;${functionName}&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @conversionArguments) . &quot;)&quot;;
6908 }
6909 
6910 sub ceilingToPowerOf2
6911 {
6912     my ($size) = @_;
6913 
6914     my $powerOf2 = 1;
6915     while ($size &gt; $powerOf2) {
6916         $powerOf2 &lt;&lt;= 1;
6917     }
6918 
6919     return $powerOf2;
6920 }
</pre>
<hr />
<pre>
7197     push(@$outputArray, &quot;    {\n&quot;);
7198     push(@$outputArray, &quot;        ${className}Prototype* ptr = new (NotNull, JSC::allocateCell&lt;${className}Prototype&gt;(vm.heap)) ${className}Prototype(vm, globalObject, structure);\n&quot;);
7199     push(@$outputArray, &quot;        ptr-&gt;finishCreation(vm);\n&quot;);
7200     push(@$outputArray, &quot;        return ptr;\n&quot;);
7201     push(@$outputArray, &quot;    }\n\n&quot;);
7202 
7203     push(@$outputArray, &quot;    DECLARE_INFO;\n&quot;);
7204 
7205     push(@$outputArray, &quot;    static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)\n&quot;);
7206     push(@$outputArray, &quot;    {\n&quot;);
7207     push(@$outputArray, &quot;        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());\n&quot;);
7208     push(@$outputArray, &quot;    }\n&quot;);
7209 
7210     push(@$outputArray, &quot;\nprivate:\n&quot;);
7211     push(@$outputArray, &quot;    ${prototypeClassName}(JSC::VM&amp; vm, JSC::JSGlobalObject*, JSC::Structure* structure)\n&quot;);
7212     push(@$outputArray, &quot;        : JSC::JSNonFinalObject(vm, structure)\n&quot;);
7213     push(@$outputArray, &quot;    {\n&quot;);
7214     push(@$outputArray, &quot;    }\n&quot;);
7215 
7216     if (PrototypeHasStaticPropertyTable($interface)) {
<span class="line-modified">7217         if (IsGlobalInterface($interface)) {</span>
7218             $structureFlags{&quot;JSC::HasStaticPropertyTable&quot;} = 1;
7219         } else {
7220             push(@$outputArray, &quot;\n&quot;);
7221             push(@$outputArray, &quot;    void finishCreation(JSC::VM&amp;);\n&quot;);
7222         }
7223     }
7224 
7225     # FIXME: Should this override putByIndex as well?
7226     if ($interface-&gt;extendedAttributes-&gt;{CustomPutOnPrototype}) {
7227         push(@$outputArray, &quot;\n&quot;);
<span class="line-modified">7228         push(@$outputArray, &quot;    static bool put(JSC::JSCell*, JSC::JSGlobalObject*, JSC::PropertyName, JSC::JSValue, JSC::PutPropertySlot&amp;);\n&quot;);</span>
7229     }
7230 
7231     if ($interface-&gt;extendedAttributes-&gt;{CustomDefineOwnPropertyOnPrototype}) {
7232         push(@$outputArray, &quot;\n&quot;);
<span class="line-modified">7233         push(@$outputArray, &quot;    static bool defineOwnProperty(JSC::JSObject*, JSC::JSGlobalObject*, JSC::PropertyName, const JSC::PropertyDescriptor&amp;, bool shouldThrow);\n&quot;);</span>
7234     }
7235 
7236     $structureFlags{&quot;JSC::IsImmutablePrototypeExoticObject&quot;} = 1 if $interface-&gt;extendedAttributes-&gt;{IsImmutablePrototypeExoticObjectOnPrototype};
7237 
7238     # structure flags
7239     if (%structureFlags) {
7240         push(@$outputArray, &quot;public:\n&quot;);
<span class="line-modified">7241         push(@$outputArray, &quot;    static constexpr unsigned StructureFlags = Base::StructureFlags&quot;);</span>
7242         foreach my $structureFlag (sort (keys %structureFlags)) {
7243             push(@$outputArray, &quot; | &quot; . $structureFlag);
7244         }
7245         push(@$outputArray, &quot;;\n&quot;);
7246     }
7247 
<span class="line-modified">7248     push(@$outputArray, &quot;};\n&quot;);</span>
<span class="line-added">7249     push(@$outputArray, &quot;STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(${prototypeClassName}, ${prototypeClassName}::Base);\n\n&quot;);</span>
7250 }
7251 
7252 sub GetConstructorTemplateClassName
7253 {
7254     my $interface = shift;
7255     return &quot;JSDOMConstructorNotConstructable&quot; if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7256     return &quot;JSDOMConstructorNotConstructable&quot; unless IsConstructable($interface);
7257     return &quot;JSDOMBuiltinConstructor&quot; if IsJSBuiltinConstructor($interface);
7258     return &quot;JSDOMConstructor&quot;;
7259 }
7260 
7261 sub GenerateConstructorDeclaration
7262 {
7263     my ($outputArray, $className, $interface) = @_;
7264 
7265     my $interfaceName = $interface-&gt;type-&gt;name;
7266     my $constructorClassName = &quot;${className}Constructor&quot;;
7267     my $templateClassName = GetConstructorTemplateClassName($interface);
7268 
7269     AddToImplIncludes(&quot;${templateClassName}.h&quot;);
7270     AddToImplIncludes(&quot;JSDOMNamedConstructor.h&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7271 
7272     push(@$outputArray, &quot;using $constructorClassName = $templateClassName&lt;$className&gt;;\n&quot;);
7273     push(@$outputArray, &quot;using JS${interfaceName}NamedConstructor = JSDOMNamedConstructor&lt;$className&gt;;\n&quot;) if $interface-&gt;extendedAttributes-&gt;{NamedConstructor};
7274     push(@$outputArray, &quot;\n&quot;);
7275 }
7276 
7277 sub GenerateConstructorDefinitions
7278 {
7279     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7280 
7281     if (IsConstructable($interface)) {
7282         my @constructors = @{$interface-&gt;constructors};
7283         if (@constructors &gt; 1) {
7284             foreach my $constructor (@constructors) {
7285                 GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructor);
7286             }
7287 
7288             my $overloadFunctionPrefix = &quot;construct${className}&quot;;
7289 
<span class="line-modified">7290             push(@implContent, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${className}Constructor::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
7291             push(@implContent, &quot;{\n&quot;);
<span class="line-modified">7292             push(@implContent, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
7293             push(@implContent, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7294             push(@implContent, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
7295 
<span class="line-modified">7296             GenerateOverloadDispatcher(@{$interface-&gt;constructors}[0], $interface, $overloadFunctionPrefix, &quot;&quot;, &quot;lexicalGlobalObject, callFrame&quot;);</span>
7297 
7298             push(@implContent, &quot;}\n\n&quot;);
7299         } elsif (@constructors == 1) {
7300             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $constructors[0]);
7301         } else {
7302             GenerateConstructorDefinition($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7303         }
7304     }
7305 
7306     GenerateConstructorHelperMethods($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor);
7307 }
7308 
7309 sub GenerateConstructorDefinition
7310 {
7311     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor, $operation) = @_;
7312 
7313     return if IsJSBuiltinConstructor($interface);
7314 
7315     my $interfaceName = $interface-&gt;type-&gt;name;
7316     my $constructorClassName = $generatingNamedConstructor ? &quot;${className}NamedConstructor&quot; : &quot;${className}Constructor&quot;;
7317 
7318     if (IsConstructable($interface)) {
7319         if ($interface-&gt;extendedAttributes-&gt;{CustomConstructor}) {
<span class="line-modified">7320             push(@$outputArray, &quot;template&lt;&gt; JSC::EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSC::JSGlobalObject* lexicalGlobalObject, JSC::CallFrame* callFrame)\n&quot;);</span>
7321             push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">7322             push(@$outputArray, &quot;    ASSERT(callFrame);\n&quot;);</span>
<span class="line-modified">7323             push(@$outputArray, &quot;    return construct${className}(lexicalGlobalObject, *callFrame);\n&quot;);</span>
7324             push(@$outputArray, &quot;}\n\n&quot;);
7325          } elsif (!HasCustomConstructor($interface) &amp;&amp; (!$interface-&gt;extendedAttributes-&gt;{NamedConstructor} || $generatingNamedConstructor)) {
7326             my $isOverloaded = $operation-&gt;{overloads} &amp;&amp; @{$operation-&gt;{overloads}} &gt; 1;
7327             if ($isOverloaded) {
<span class="line-modified">7328                 push(@$outputArray, &quot;static inline EncodedJSValue construct${className}$operation-&gt;{overloadIndex}(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
7329             } else {
<span class="line-modified">7330                 push(@$outputArray, &quot;template&lt;&gt; EncodedJSValue JSC_HOST_CALL ${constructorClassName}::construct(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)\n&quot;);</span>
7331             }
7332 
7333             push(@$outputArray, &quot;{\n&quot;);
<span class="line-modified">7334             push(@$outputArray, &quot;    VM&amp; vm = lexicalGlobalObject-&gt;vm();\n&quot;);</span>
7335             push(@$outputArray, &quot;    auto throwScope = DECLARE_THROW_SCOPE(vm);\n&quot;);
7336             push(@$outputArray, &quot;    UNUSED_PARAM(throwScope);\n&quot;);
<span class="line-modified">7337             push(@$outputArray, &quot;    auto* castedThis = jsCast&lt;${constructorClassName}*&gt;(callFrame-&gt;jsCallee());\n&quot;);</span>
7338             push(@$outputArray, &quot;    ASSERT(castedThis);\n&quot;);
7339 
<span class="line-added">7340              if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {</span>
<span class="line-added">7341                  my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operation, &quot;lexicalGlobalObject&quot;);</span>
<span class="line-added">7342                  push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);</span>
<span class="line-added">7343                  push(@$outputArray, &quot;        throwTypeError(lexicalGlobalObject, throwScope, \&quot;Illegal constructor\&quot;_s);\n&quot;);</span>
<span class="line-added">7344                  push(@$outputArray, &quot;        return JSValue::encode(jsNull());\n&quot;);</span>
<span class="line-added">7345                  push(@$outputArray, &quot;    }\n&quot;);</span>
<span class="line-added">7346              }</span>
<span class="line-added">7347 </span>
7348             GenerateArgumentsCountCheck($outputArray, $operation, $interface, &quot;    &quot;);
7349 
7350             my $functionImplementationName = $generatingNamedConstructor ? &quot;createForJSConstructor&quot; : &quot;create&quot;;
7351             my $functionString = GenerateParametersCheck($outputArray, $operation, $interface, $functionImplementationName, &quot;    &quot;);
7352 
7353             push(@$outputArray, &quot;    auto object = ${functionString};\n&quot;);
7354             push(@$outputArray, &quot;    RETURN_IF_EXCEPTION(throwScope, encodedJSValue());\n&quot;) if $codeGenerator-&gt;ExtendedAttributeContains($interface-&gt;extendedAttributes-&gt;{ConstructorCallWith}, &quot;ExecState&quot;);
7355 
7356             my $IDLType = GetIDLType($interface, $interface-&gt;type);
7357 
7358             AddToImplIncludes(&quot;JSDOMConvertInterface.h&quot;);
7359 
7360             my @constructionConversionArguments = ();
<span class="line-modified">7361             push(@constructionConversionArguments, &quot;*lexicalGlobalObject&quot;);</span>
7362             push(@constructionConversionArguments, &quot;*castedThis-&gt;globalObject()&quot;);
7363             push(@constructionConversionArguments, &quot;throwScope&quot;) if $interface-&gt;extendedAttributes-&gt;{ConstructorMayThrowException};
7364             push(@constructionConversionArguments, &quot;WTFMove(object)&quot;);
7365 
7366             push(@$outputArray, &quot;    return JSValue::encode(toJSNewlyCreated&lt;${IDLType}&gt;(&quot; . join(&quot;, &quot;, @constructionConversionArguments) . &quot;));\n&quot;);
7367             push(@$outputArray, &quot;}\n\n&quot;);
7368         }
7369     }
7370 }
7371 
7372 sub ConstructorHasProperties
7373 {
7374     my $interface = shift;
7375 
7376     foreach my $constant (@{$interface-&gt;constants}) {
7377         return 1;
7378     }
7379 
7380     foreach my $attribute (@{$interface-&gt;attributes}) {
7381         next unless ($attribute-&gt;isStatic);
7382         return 1;
7383     }
7384 
7385     foreach my $operation (@{$interface-&gt;operations}) {
7386         next unless ($operation-&gt;isStatic);
7387         return 1;
7388     }
7389 
7390     return 0;
7391 }
7392 
7393 sub GetRuntimeEnabledStaticProperties
7394 {
7395     my ($interface) = @_;
7396 
7397     my @runtimeEnabledProperties = ();
7398 
7399     my @attributes = @{$interface-&gt;attributes};
7400     push(@attributes, @{$interface-&gt;mapLike-&gt;attributes}) if $interface-&gt;mapLike;
<span class="line-added">7401     push(@attributes, @{$interface-&gt;setLike-&gt;attributes}) if $interface-&gt;setLike;</span>
7402 
7403     foreach my $attribute (@attributes) {
7404         next if AttributeShouldBeOnInstance($interface, $attribute) != 0;
7405         next if not $attribute-&gt;isStatic;
7406 
7407         if (NeedsRuntimeCheck($interface, $attribute)) {
7408             push(@runtimeEnabledProperties, $attribute);
7409         }
7410     }
7411 
7412     my @operations = @{$interface-&gt;operations};
7413     push(@operations, @{$interface-&gt;iterable-&gt;operations}) if IsKeyValueIterableInterface($interface);
7414     push(@operations, @{$interface-&gt;mapLike-&gt;operations}) if $interface-&gt;mapLike;
<span class="line-added">7415     push(@operations, @{$interface-&gt;setLike-&gt;operations}) if $interface-&gt;setLike;</span>
7416     push(@operations, @{$interface-&gt;serializable-&gt;operations}) if $interface-&gt;serializable;
7417     foreach my $operation (@operations) {
7418         next if ($operation-&gt;extendedAttributes-&gt;{PrivateIdentifier} and not $operation-&gt;extendedAttributes-&gt;{PublicIdentifier});
7419         next if $operation-&gt;{overloadIndex} &amp;&amp; $operation-&gt;{overloadIndex} &gt; 1;
7420         next if OperationShouldBeOnInstance($interface, $operation) != 0;
7421         next if $operation-&gt;name eq &quot;[Symbol.Iterator]&quot;;
7422         next if not $operation-&gt;isStatic;
7423 
7424         if (NeedsRuntimeCheck($interface, $operation)) {
7425             push(@runtimeEnabledProperties, $operation);
7426         }
7427     }
7428 
7429     return @runtimeEnabledProperties;
7430 }
7431 
7432 sub GenerateConstructorHelperMethods
7433 {
7434     my ($outputArray, $className, $protoClassName, $visibleInterfaceName, $interface, $generatingNamedConstructor) = @_;
7435 
</pre>
<hr />
<pre>
7463         push(@$outputArray, &quot;    return globalObject.functionPrototype();\n&quot;);
7464     }
7465     push(@$outputArray, &quot;}\n\n&quot;);
7466 
7467 
7468     push(@$outputArray, &quot;template&lt;&gt; void ${constructorClassName}::initializeProperties(VM&amp; vm, JSDOMGlobalObject&amp; globalObject)\n&quot;);
7469     push(@$outputArray, &quot;{\n&quot;);
7470 
7471     # There must exist an interface prototype object for every non-callback interface defined, regardless
7472     # of whether the interface was declared with the [NoInterfaceObject] extended attribute.
7473     # https://heycam.github.io/webidl/#interface-prototype-object
7474     if (ShouldUseGlobalObjectPrototype($interface)) {
7475         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, globalObject.getPrototypeDirect(vm), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7476     } elsif ($interface-&gt;isCallback) {
7477         push(@$outputArray, &quot;    UNUSED_PARAM(globalObject);\n&quot;);
7478     } else {
7479         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;prototype, ${className}::prototype(vm, globalObject), JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
7480     }
7481 
7482     push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;name, jsNontrivialString(vm, String(\&quot;$visibleInterfaceName\&quot;_s)), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);
<span class="line-modified">7483 </span>
<span class="line-added">7484     if ($interface-&gt;extendedAttributes-&gt;{ConstructorEnabledBySetting}) {</span>
<span class="line-added">7485         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $interface, &quot;&amp;globalObject&quot;);</span>
<span class="line-added">7486         push(@$outputArray, &quot;    int constructorLength = ${leastConstructorLength};\n&quot;);</span>
<span class="line-added">7487         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString})\n&quot;);</span>
<span class="line-added">7488         push(@$outputArray, &quot;        constructorLength = 0;\n&quot;);</span>
<span class="line-added">7489         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(constructorLength), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
<span class="line-added">7490     } else {</span>
<span class="line-added">7491         push(@$outputArray, &quot;    putDirect(vm, vm.propertyNames-&gt;length, jsNumber(${leastConstructorLength}), JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontEnum);\n&quot;);</span>
<span class="line-added">7492     }</span>
7493 
7494     my $classForThis = &quot;${className}::info()&quot;;
7495     if ($interface-&gt;isCallback) {
7496         $classForThis = &quot;nullptr&quot;;
7497     }
7498     push(@$outputArray, &quot;    reifyStaticProperties(vm, ${classForThis}, ${className}ConstructorTableValues, *this);\n&quot;) if ConstructorHasProperties($interface);
7499 
7500     my @runtimeEnabledProperties = GetRuntimeEnabledStaticProperties($interface);
7501 
7502     foreach my $operationOrAttribute (@runtimeEnabledProperties) {
7503         my $conditionalString = $codeGenerator-&gt;GenerateConditionalString($operationOrAttribute);
7504         push(@$outputArray, &quot;#if ${conditionalString}\n&quot;) if $conditionalString;
<span class="line-modified">7505         my $runtimeEnableConditionalString = GenerateRuntimeEnableConditionalString($interface, $operationOrAttribute, &quot;&amp;globalObject&quot;);</span>
7506         my $name = $operationOrAttribute-&gt;name;
7507         push(@$outputArray, &quot;    if (!${runtimeEnableConditionalString}) {\n&quot;);
7508         push(@$outputArray, &quot;        auto propertyName = Identifier::fromString(vm, reinterpret_cast&lt;const LChar*&gt;(\&quot;$name\&quot;), strlen(\&quot;$name\&quot;));\n&quot;);
7509         push(@$outputArray, &quot;        VM::DeletePropertyModeScope scope(vm, VM::DeletePropertyMode::IgnoreConfigurable);\n&quot;);
<span class="line-modified">7510         push(@$outputArray, &quot;        JSObject::deleteProperty(this, &amp;globalObject, propertyName);\n&quot;);</span>
7511         push(@$outputArray, &quot;    }\n&quot;);
7512         push(@$outputArray, &quot;#endif\n&quot;) if $conditionalString;
7513     }
7514 
7515     push(@$outputArray, &quot;}\n\n&quot;);
7516 
7517     if (IsJSBuiltinConstructor($interface)) {
7518         push(@$outputArray, &quot;template&lt;&gt; FunctionExecutable* ${constructorClassName}::initializeExecutable(VM&amp; vm)\n&quot;);
7519         push(@$outputArray, &quot;{\n&quot;);
7520         push(@$outputArray, &quot;    return &quot; . GetJSBuiltinFunctionNameFromString($interface-&gt;type-&gt;name, &quot;initialize&quot; . $interface-&gt;type-&gt;name) . &quot;(vm);\n&quot;);
7521         push(@$outputArray, &quot;}\n&quot;);
7522         push(@$outputArray, &quot;\n&quot;);
7523     }
7524     push(@$outputArray, &quot;template&lt;&gt; const ClassInfo ${constructorClassName}::s_info = { \&quot;${visibleInterfaceName}\&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE($constructorClassName) };\n\n&quot;);
7525 }
7526 
7527 sub HasCustomConstructor
7528 {
7529     my $interface = shift;
7530     return $interface-&gt;extendedAttributes-&gt;{CustomConstructor};
</pre>
</td>
</tr>
</table>
<center><a href="CodeGenerator.pm.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDLAttributes.json.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
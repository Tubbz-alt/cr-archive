<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTextContentElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGSymbolElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGTextContentElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/SVGTextContentElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;DOMPoint.h&quot;
 28 #include &quot;Frame.h&quot;
 29 #include &quot;FrameSelection.h&quot;
 30 #include &quot;RenderObject.h&quot;
 31 #include &quot;RenderSVGResource.h&quot;
 32 #include &quot;RenderSVGText.h&quot;
 33 #include &quot;SVGNames.h&quot;
 34 #include &quot;SVGPoint.h&quot;
 35 #include &quot;SVGRect.h&quot;
 36 #include &quot;SVGTextQuery.h&quot;
 37 #include &quot;XMLNames.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGTextContentElement);
 44 
 45 SVGTextContentElement::SVGTextContentElement(const QualifiedName&amp; tagName, Document&amp; document)
 46     : SVGGraphicsElement(tagName, document)
<span class="line-removed"> 47     , SVGExternalResourcesRequired(this)</span>
 48 {
 49     static std::once_flag onceFlag;
 50     std::call_once(onceFlag, [] {
 51         PropertyRegistry::registerProperty&lt;SVGNames::textLengthAttr, &amp;SVGTextContentElement::m_textLength&gt;();
 52         PropertyRegistry::registerProperty&lt;SVGNames::lengthAdjustAttr, SVGLengthAdjustType, &amp;SVGTextContentElement::m_lengthAdjust&gt;();
 53     });
 54 }
 55 
 56 unsigned SVGTextContentElement::getNumberOfChars()
 57 {
 58     document().updateLayoutIgnorePendingStylesheets();
 59     return SVGTextQuery(renderer()).numberOfCharacters();
 60 }
 61 
 62 float SVGTextContentElement::getComputedTextLength()
 63 {
 64     document().updateLayoutIgnorePendingStylesheets();
 65     return SVGTextQuery(renderer()).textLength();
 66 }
 67 
</pre>
<hr />
<pre>
153     if (name.matches(XMLNames::spaceAttr)) {
154         if (value == &quot;preserve&quot;)
155             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValuePre);
156         else
157             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValueNowrap);
158         return;
159     }
160 
161     SVGGraphicsElement::collectStyleForPresentationAttribute(name, value, style);
162 }
163 
164 void SVGTextContentElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
165 {
166     SVGParsingError parseError = NoError;
167 
168     if (name == SVGNames::lengthAdjustAttr) {
169         auto propertyValue = SVGPropertyTraits&lt;SVGLengthAdjustType&gt;::fromString(value);
170         if (propertyValue &gt; 0)
171             m_lengthAdjust-&gt;setBaseValInternal&lt;SVGLengthAdjustType&gt;(propertyValue);
172     } else if (name == SVGNames::textLengthAttr)
<span class="line-modified">173         m_textLength-&gt;setBaseValInternal(SVGLengthValue::construct(LengthModeOther, value, parseError, ForbidNegativeLengths));</span>
174 
175     reportAttributeParsingError(parseError, name, value);
176 
177     SVGGraphicsElement::parseAttribute(name, value);
<span class="line-removed">178     SVGExternalResourcesRequired::parseAttribute(name, value);</span>
179 }
180 
181 void SVGTextContentElement::svgAttributeChanged(const QualifiedName&amp; attrName)
182 {
183     if (PropertyRegistry::isKnownAttribute(attrName)) {
184         if (attrName == SVGNames::textLengthAttr)
185             m_specifiedTextLength = m_textLength-&gt;baseVal()-&gt;value();
186 
187         if (auto renderer = this-&gt;renderer()) {
188             InstanceInvalidationGuard guard(*this);
189             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
190         }
191         return;
192     }
193 
194     SVGGraphicsElement::svgAttributeChanged(attrName);
<span class="line-removed">195     SVGExternalResourcesRequired::svgAttributeChanged(attrName);</span>
196 }
197 
198 SVGAnimatedLength&amp; SVGTextContentElement::textLengthAnimated()
199 {
<span class="line-modified">200     static NeverDestroyed&lt;SVGLengthValue&gt; defaultTextLength(LengthModeOther);</span>
201     if (m_textLength-&gt;baseVal()-&gt;value() == defaultTextLength)
<span class="line-modified">202         m_textLength-&gt;baseVal()-&gt;value().newValueSpecifiedUnits(LengthTypeNumber, getComputedTextLength());</span>
203     return m_textLength;
204 }
205 
206 bool SVGTextContentElement::selfHasRelativeLengths() const
207 {
208     // Any element of the &lt;text&gt; subtree is advertized as using relative lengths.
209     // On any window size change, we have to relayout the text subtree, as the
210     // effective &#39;on-screen&#39; font size may change.
211     return true;
212 }
213 
214 SVGTextContentElement* SVGTextContentElement::elementFromRenderer(RenderObject* renderer)
215 {
216     if (!renderer)
217         return nullptr;
218 
219     if (!renderer-&gt;isSVGText() &amp;&amp; !renderer-&gt;isSVGInline())
220         return nullptr;
221 
222     SVGElement* element = downcast&lt;SVGElement&gt;(renderer-&gt;node());
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;DOMPoint.h&quot;
 28 #include &quot;Frame.h&quot;
 29 #include &quot;FrameSelection.h&quot;
 30 #include &quot;RenderObject.h&quot;
 31 #include &quot;RenderSVGResource.h&quot;
 32 #include &quot;RenderSVGText.h&quot;
 33 #include &quot;SVGNames.h&quot;
 34 #include &quot;SVGPoint.h&quot;
 35 #include &quot;SVGRect.h&quot;
 36 #include &quot;SVGTextQuery.h&quot;
 37 #include &quot;XMLNames.h&quot;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 #include &lt;wtf/NeverDestroyed.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGTextContentElement);
 44 
 45 SVGTextContentElement::SVGTextContentElement(const QualifiedName&amp; tagName, Document&amp; document)
 46     : SVGGraphicsElement(tagName, document)

 47 {
 48     static std::once_flag onceFlag;
 49     std::call_once(onceFlag, [] {
 50         PropertyRegistry::registerProperty&lt;SVGNames::textLengthAttr, &amp;SVGTextContentElement::m_textLength&gt;();
 51         PropertyRegistry::registerProperty&lt;SVGNames::lengthAdjustAttr, SVGLengthAdjustType, &amp;SVGTextContentElement::m_lengthAdjust&gt;();
 52     });
 53 }
 54 
 55 unsigned SVGTextContentElement::getNumberOfChars()
 56 {
 57     document().updateLayoutIgnorePendingStylesheets();
 58     return SVGTextQuery(renderer()).numberOfCharacters();
 59 }
 60 
 61 float SVGTextContentElement::getComputedTextLength()
 62 {
 63     document().updateLayoutIgnorePendingStylesheets();
 64     return SVGTextQuery(renderer()).textLength();
 65 }
 66 
</pre>
<hr />
<pre>
152     if (name.matches(XMLNames::spaceAttr)) {
153         if (value == &quot;preserve&quot;)
154             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValuePre);
155         else
156             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValueNowrap);
157         return;
158     }
159 
160     SVGGraphicsElement::collectStyleForPresentationAttribute(name, value, style);
161 }
162 
163 void SVGTextContentElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
164 {
165     SVGParsingError parseError = NoError;
166 
167     if (name == SVGNames::lengthAdjustAttr) {
168         auto propertyValue = SVGPropertyTraits&lt;SVGLengthAdjustType&gt;::fromString(value);
169         if (propertyValue &gt; 0)
170             m_lengthAdjust-&gt;setBaseValInternal&lt;SVGLengthAdjustType&gt;(propertyValue);
171     } else if (name == SVGNames::textLengthAttr)
<span class="line-modified">172         m_textLength-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Other, value, parseError, SVGLengthNegativeValuesMode::Forbid));</span>
173 
174     reportAttributeParsingError(parseError, name, value);
175 
176     SVGGraphicsElement::parseAttribute(name, value);

177 }
178 
179 void SVGTextContentElement::svgAttributeChanged(const QualifiedName&amp; attrName)
180 {
181     if (PropertyRegistry::isKnownAttribute(attrName)) {
182         if (attrName == SVGNames::textLengthAttr)
183             m_specifiedTextLength = m_textLength-&gt;baseVal()-&gt;value();
184 
185         if (auto renderer = this-&gt;renderer()) {
186             InstanceInvalidationGuard guard(*this);
187             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
188         }
189         return;
190     }
191 
192     SVGGraphicsElement::svgAttributeChanged(attrName);

193 }
194 
195 SVGAnimatedLength&amp; SVGTextContentElement::textLengthAnimated()
196 {
<span class="line-modified">197     static NeverDestroyed&lt;SVGLengthValue&gt; defaultTextLength(SVGLengthMode::Other);</span>
198     if (m_textLength-&gt;baseVal()-&gt;value() == defaultTextLength)
<span class="line-modified">199         m_textLength-&gt;baseVal()-&gt;value() = { getComputedTextLength(), SVGLengthType::Number };</span>
200     return m_textLength;
201 }
202 
203 bool SVGTextContentElement::selfHasRelativeLengths() const
204 {
205     // Any element of the &lt;text&gt; subtree is advertized as using relative lengths.
206     // On any window size change, we have to relayout the text subtree, as the
207     // effective &#39;on-screen&#39; font size may change.
208     return true;
209 }
210 
211 SVGTextContentElement* SVGTextContentElement::elementFromRenderer(RenderObject* renderer)
212 {
213     if (!renderer)
214         return nullptr;
215 
216     if (!renderer-&gt;isSVGText() &amp;&amp; !renderer-&gt;isSVGInline())
217         return nullptr;
218 
219     SVGElement* element = downcast&lt;SVGElement&gt;(renderer-&gt;node());
</pre>
</td>
</tr>
</table>
<center><a href="SVGSymbolElement.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SVGTextContentElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
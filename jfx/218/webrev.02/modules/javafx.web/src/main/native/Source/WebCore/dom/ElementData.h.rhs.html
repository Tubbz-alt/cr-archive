<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ElementData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Attribute.h&quot;
 29 #include &quot;SpaceSplitString.h&quot;
 30 #include &lt;wtf/RefCounted.h&gt;
 31 #include &lt;wtf/TypeCasts.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 class Attr;
 36 class ShareableElementData;
 37 class StyleProperties;
 38 class UniqueElementData;
 39 
 40 class AttributeConstIterator {
 41 public:
 42     AttributeConstIterator(const Attribute* array, unsigned offset)
 43         : m_array(array)
 44         , m_offset(offset)
 45     {
 46     }
 47 
 48     const Attribute&amp; operator*() const { return m_array[m_offset]; }
 49     const Attribute* operator-&gt;() const { return &amp;m_array[m_offset]; }
 50     AttributeConstIterator&amp; operator++() { ++m_offset; return *this; }
 51 
 52     bool operator==(const AttributeConstIterator&amp; other) const { return m_offset == other.m_offset; }
 53     bool operator!=(const AttributeConstIterator&amp; other) const { return !(*this == other); }
 54 
 55 private:
 56     const Attribute* m_array;
 57     unsigned m_offset;
 58 };
 59 
 60 class AttributeIteratorAccessor {
 61 public:
 62     AttributeIteratorAccessor(const Attribute* array, unsigned size)
 63         : m_array(array)
 64         , m_size(size)
 65     {
 66     }
 67 
 68     AttributeConstIterator begin() const { return AttributeConstIterator(m_array, 0); }
 69     AttributeConstIterator end() const { return AttributeConstIterator(m_array, m_size); }
 70 
 71     unsigned attributeCount() const { return m_size; }
 72 
 73 private:
 74     const Attribute* m_array;
 75     unsigned m_size;
 76 };
 77 
<a name="1" id="anc1"></a><span class="line-added"> 78 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ElementData);</span>
 79 class ElementData : public RefCounted&lt;ElementData&gt; {
<a name="2" id="anc2"></a><span class="line-modified"> 80     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ElementData);</span>
 81 public:
 82     // Override RefCounted&#39;s deref() to ensure operator delete is called on
 83     // the appropriate subclass type.
 84     void deref();
 85 
 86     static const unsigned attributeNotFound = static_cast&lt;unsigned&gt;(-1);
 87 
 88     void setClassNames(const SpaceSplitString&amp; classNames) const { m_classNames = classNames; }
 89     const SpaceSplitString&amp; classNames() const { return m_classNames; }
 90     static ptrdiff_t classNamesMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_classNames); }
 91 
 92     const AtomString&amp; idForStyleResolution() const { return m_idForStyleResolution; }
 93     static ptrdiff_t idForStyleResolutionMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_idForStyleResolution); }
 94     void setIdForStyleResolution(const AtomString&amp; newId) const { m_idForStyleResolution = newId; }
 95 
 96     const StyleProperties* inlineStyle() const { return m_inlineStyle.get(); }
 97     const StyleProperties* presentationAttributeStyle() const;
 98 
 99     unsigned length() const;
100     bool isEmpty() const { return !length(); }
101 
102     AttributeIteratorAccessor attributesIterator() const;
103     const Attribute&amp; attributeAt(unsigned index) const;
104     const Attribute* findAttributeByName(const QualifiedName&amp;) const;
105     unsigned findAttributeIndexByName(const QualifiedName&amp;) const;
106     unsigned findAttributeIndexByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const;
107     const Attribute* findLanguageAttribute() const;
108 
109     bool hasID() const { return !m_idForStyleResolution.isNull(); }
110     bool hasClass() const { return !m_classNames.isEmpty(); }
111     bool hasName() const { return m_arraySizeAndFlags &amp; s_flagHasNameAttribute; }
112 
113     bool isEquivalent(const ElementData* other) const;
114 
115     bool isUnique() const { return m_arraySizeAndFlags &amp; s_flagIsUnique; }
116     static uint32_t isUniqueFlag() { return s_flagIsUnique; }
117 
118     static ptrdiff_t arraySizeAndFlagsMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_arraySizeAndFlags); }
119     static inline uint32_t styleAttributeIsDirtyFlag() { return s_flagStyleAttributeIsDirty; }
120     static uint32_t animatedSVGAttributesAreDirtyFlag() { return s_flagAnimatedSVGAttributesAreDirty; }
121 
122     static uint32_t arraySizeOffset() { return s_flagCount; }
123 
124 private:
125     mutable uint32_t m_arraySizeAndFlags;
126 
127     static const uint32_t s_arraySize = 27;
128     static const uint32_t s_flagCount = 5;
129     static const uint32_t s_flagIsUnique = 1;
130     static const uint32_t s_flagHasNameAttribute = 1 &lt;&lt; 1;
131     static const uint32_t s_flagPresentationAttributeStyleIsDirty = 1 &lt;&lt; 2;
132     static const uint32_t s_flagStyleAttributeIsDirty = 1 &lt;&lt; 3;
133     static const uint32_t s_flagAnimatedSVGAttributesAreDirty = 1 &lt;&lt; 4;
134     static const uint32_t s_flagsMask = (1 &lt;&lt; s_flagCount) - 1;
135 
136     inline void updateFlag(uint32_t flag, bool set) const
137     {
138         if (set)
139             m_arraySizeAndFlags |= flag;
140         else
141             m_arraySizeAndFlags &amp;= ~flag;
142     }
143     static inline uint32_t arraySizeAndFlagsFromOther(const ElementData&amp; other, bool isUnique);
144 
145 protected:
146     ElementData();
147     explicit ElementData(unsigned arraySize);
148     ElementData(const ElementData&amp;, bool isUnique);
149 
150     unsigned arraySize() const { return m_arraySizeAndFlags &gt;&gt; s_flagCount; }
151 
152     void setHasNameAttribute(bool hasName) const { updateFlag(s_flagHasNameAttribute, hasName); }
153 
154     bool styleAttributeIsDirty() const { return m_arraySizeAndFlags &amp; s_flagStyleAttributeIsDirty; }
155     void setStyleAttributeIsDirty(bool isDirty) const { updateFlag(s_flagStyleAttributeIsDirty, isDirty); }
156 
157     bool presentationAttributeStyleIsDirty() const { return m_arraySizeAndFlags &amp; s_flagPresentationAttributeStyleIsDirty; }
158     void setPresentationAttributeStyleIsDirty(bool isDirty) const { updateFlag(s_flagPresentationAttributeStyleIsDirty, isDirty); }
159 
160     bool animatedSVGAttributesAreDirty() const { return m_arraySizeAndFlags &amp; s_flagAnimatedSVGAttributesAreDirty; }
161     void setAnimatedSVGAttributesAreDirty(bool dirty) const { updateFlag(s_flagAnimatedSVGAttributesAreDirty, dirty); }
162 
163     mutable RefPtr&lt;StyleProperties&gt; m_inlineStyle;
164     mutable SpaceSplitString m_classNames;
165     mutable AtomString m_idForStyleResolution;
166 
167 private:
168     friend class Element;
169     friend class StyledElement;
170     friend class ShareableElementData;
171     friend class UniqueElementData;
172     friend class SVGElement;
173 
174     void destroy();
175 
176     const Attribute* attributeBase() const;
177     const Attribute* findAttributeByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const;
178 
179     Ref&lt;UniqueElementData&gt; makeUniqueCopy() const;
180 };
181 
182 #if COMPILER(MSVC)
183 #pragma warning(push)
184 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
185 #endif
186 
<a name="3" id="anc3"></a><span class="line-added">187 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ShareableElementData);</span>
188 class ShareableElementData : public ElementData {
<a name="4" id="anc4"></a><span class="line-added">189     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ShareableElementData);</span>
190 public:
191     static Ref&lt;ShareableElementData&gt; createWithAttributes(const Vector&lt;Attribute&gt;&amp;);
192 
193     explicit ShareableElementData(const Vector&lt;Attribute&gt;&amp;);
194     explicit ShareableElementData(const UniqueElementData&amp;);
195     ~ShareableElementData();
196 
197     static ptrdiff_t attributeArrayMemoryOffset() { return OBJECT_OFFSETOF(ShareableElementData, m_attributeArray); }
198 
199     Attribute m_attributeArray[0];
200 };
201 
202 #if COMPILER(MSVC)
203 #pragma warning(pop)
204 #endif
205 
206 class UniqueElementData : public ElementData {
207 public:
208     static Ref&lt;UniqueElementData&gt; create();
209     Ref&lt;ShareableElementData&gt; makeShareableCopy() const;
210 
211     // These functions do no error/duplicate checking.
212     void addAttribute(const QualifiedName&amp;, const AtomString&amp;);
213     void removeAttribute(unsigned index);
214 
215     Attribute&amp; attributeAt(unsigned index);
216     Attribute* findAttributeByName(const QualifiedName&amp;);
217 
218     UniqueElementData();
219     explicit UniqueElementData(const ShareableElementData&amp;);
220     explicit UniqueElementData(const UniqueElementData&amp;);
221 
222     static ptrdiff_t attributeVectorMemoryOffset() { return OBJECT_OFFSETOF(UniqueElementData, m_attributeVector); }
223 
224     mutable RefPtr&lt;StyleProperties&gt; m_presentationAttributeStyle;
225     typedef Vector&lt;Attribute, 4&gt; AttributeVector;
226     AttributeVector m_attributeVector;
227 };
228 
229 inline void ElementData::deref()
230 {
231     if (!derefBase())
232         return;
233     destroy();
234 }
235 
236 inline unsigned ElementData::length() const
237 {
238     if (is&lt;UniqueElementData&gt;(*this))
239         return downcast&lt;UniqueElementData&gt;(*this).m_attributeVector.size();
240     return arraySize();
241 }
242 
243 inline const Attribute* ElementData::attributeBase() const
244 {
245     if (is&lt;UniqueElementData&gt;(*this))
246         return downcast&lt;UniqueElementData&gt;(*this).m_attributeVector.data();
247     return downcast&lt;ShareableElementData&gt;(*this).m_attributeArray;
248 }
249 
250 inline const StyleProperties* ElementData::presentationAttributeStyle() const
251 {
252     if (!is&lt;UniqueElementData&gt;(*this))
253         return nullptr;
254     return downcast&lt;UniqueElementData&gt;(*this).m_presentationAttributeStyle.get();
255 }
256 
257 inline AttributeIteratorAccessor ElementData::attributesIterator() const
258 {
259     if (is&lt;UniqueElementData&gt;(*this)) {
260         const Vector&lt;Attribute, 4&gt;&amp; attributeVector = downcast&lt;UniqueElementData&gt;(*this).m_attributeVector;
261         return AttributeIteratorAccessor(attributeVector.data(), attributeVector.size());
262     }
263     return AttributeIteratorAccessor(downcast&lt;ShareableElementData&gt;(*this).m_attributeArray, arraySize());
264 }
265 
266 ALWAYS_INLINE const Attribute* ElementData::findAttributeByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const
267 {
268     unsigned index = findAttributeIndexByName(name, shouldIgnoreAttributeCase);
269     if (index != attributeNotFound)
270         return &amp;attributeAt(index);
271     return nullptr;
272 }
273 
274 ALWAYS_INLINE unsigned ElementData::findAttributeIndexByName(const QualifiedName&amp; name) const
275 {
276     const Attribute* attributes = attributeBase();
277     for (unsigned i = 0, count = length(); i &lt; count; ++i) {
278         if (attributes[i].name().matches(name))
279             return i;
280     }
281     return attributeNotFound;
282 }
283 
284 // We use a boolean parameter instead of calling shouldIgnoreAttributeCase so that the caller
285 // can tune the behavior (hasAttribute is case sensitive whereas getAttribute is not).
286 ALWAYS_INLINE unsigned ElementData::findAttributeIndexByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const
287 {
288     unsigned attributeCount = length();
289     if (!attributeCount)
290         return attributeNotFound;
291 
292     const Attribute* attributes = attributeBase();
293     const AtomString&amp; caseAdjustedName = shouldIgnoreAttributeCase ? name.convertToASCIILowercase() : name;
294 
295     unsigned attributeIndex = 0;
296     do {
297         const Attribute&amp; attribute = attributes[attributeIndex];
298         if (!attribute.name().hasPrefix()) {
299             if (attribute.localName() == caseAdjustedName)
300                 return attributeIndex;
301         } else {
302             if (attribute.name().toString() == caseAdjustedName)
303                 return attributeIndex;
304         }
305 
306         ++attributeIndex;
307     } while (attributeIndex &lt; attributeCount);
308 
309     return attributeNotFound;
310 }
311 
312 ALWAYS_INLINE const Attribute* ElementData::findAttributeByName(const QualifiedName&amp; name) const
313 {
314     const Attribute* attributes = attributeBase();
315     for (unsigned i = 0, count = length(); i &lt; count; ++i) {
316         if (attributes[i].name().matches(name))
317             return &amp;attributes[i];
318     }
319     return 0;
320 }
321 
322 inline const Attribute&amp; ElementData::attributeAt(unsigned index) const
323 {
324     RELEASE_ASSERT(index &lt; length());
325     return attributeBase()[index];
326 }
327 
328 inline void UniqueElementData::addAttribute(const QualifiedName&amp; attributeName, const AtomString&amp; value)
329 {
330     m_attributeVector.append(Attribute(attributeName, value));
331 }
332 
333 inline void UniqueElementData::removeAttribute(unsigned index)
334 {
335     m_attributeVector.remove(index);
336 }
337 
338 inline Attribute&amp; UniqueElementData::attributeAt(unsigned index)
339 {
340     return m_attributeVector.at(index);
341 }
342 
343 } // namespace WebCore
344 
345 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ShareableElementData)
346     static bool isType(const WebCore::ElementData&amp; elementData) { return !elementData.isUnique(); }
347 SPECIALIZE_TYPE_TRAITS_END()
348 
349 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::UniqueElementData)
350     static bool isType(const WebCore::ElementData&amp; elementData) { return elementData.isUnique(); }
351 SPECIALIZE_TYPE_TRAITS_END()
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
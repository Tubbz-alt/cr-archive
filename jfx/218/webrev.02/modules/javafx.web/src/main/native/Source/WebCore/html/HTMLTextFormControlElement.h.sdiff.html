<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTextFormControlElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTrackElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 45 
 46     virtual ~HTMLTextFormControlElement();
 47 
 48     void didEditInnerTextValue();
 49     void forwardEvent(Event&amp;);
 50 
 51     int maxLength() const { return m_maxLength; }
 52     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setMaxLength(int);
 53     int minLength() const { return m_minLength; }
 54     ExceptionOr&lt;void&gt; setMinLength(int);
 55 
 56     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 57 
 58     // The derived class should return true if placeholder processing is needed.
 59     bool isPlaceholderVisible() const { return m_isPlaceholderVisible; }
 60     virtual bool supportsPlaceholder() const = 0;
 61     String strippedPlaceholder() const;
 62     virtual HTMLElement* placeholderElement() const = 0;
 63     void updatePlaceholderVisibility();
 64 



 65     int indexForVisiblePosition(const VisiblePosition&amp;) const;
 66     WEBCORE_EXPORT VisiblePosition visiblePositionForIndex(int index) const;
 67     WEBCORE_EXPORT int selectionStart() const;
 68     WEBCORE_EXPORT int selectionEnd() const;
 69     WEBCORE_EXPORT const AtomString&amp; selectionDirection() const;
 70     WEBCORE_EXPORT void setSelectionStart(int);
 71     WEBCORE_EXPORT void setSelectionEnd(int);
 72     WEBCORE_EXPORT void setSelectionDirection(const String&amp;);
 73     WEBCORE_EXPORT void select(SelectionRevealMode = SelectionRevealMode::DoNotReveal, const AXTextStateChangeIntent&amp; = AXTextStateChangeIntent());
 74     WEBCORE_EXPORT virtual ExceptionOr&lt;void&gt; setRangeText(const String&amp; replacement);
 75     WEBCORE_EXPORT virtual ExceptionOr&lt;void&gt; setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode);
 76     void setSelectionRange(int start, int end, const String&amp; direction, const AXTextStateChangeIntent&amp; = AXTextStateChangeIntent());
 77     WEBCORE_EXPORT void setSelectionRange(int start, int end, TextFieldSelectionDirection = SelectionHasNoDirection, SelectionRevealMode = SelectionRevealMode::DoNotReveal, const AXTextStateChangeIntent&amp; = AXTextStateChangeIntent());
 78     RefPtr&lt;Range&gt; selection() const;
 79     String selectedText() const;
 80 
 81     void dispatchFormControlChangeEvent() final;
 82 
 83     virtual String value() const = 0;
 84 
</pre>
<hr />
<pre>
143     TextFieldSelectionDirection computeSelectionDirection() const;
144 
145     void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection) final;
146     void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement) final;
147     bool childShouldCreateRenderer(const Node&amp;) const override;
148 
149     unsigned indexForPosition(const Position&amp;) const;
150 
151     // Returns true if user-editable value is empty. Used to check placeholder visibility.
152     virtual bool isEmptyValue() const = 0;
153     // Called in dispatchFocusEvent(), after placeholder process, before calling parent&#39;s dispatchFocusEvent().
154     virtual void handleFocusEvent(Node* /* oldFocusedNode */, FocusDirection) { }
155     // Called in dispatchBlurEvent(), after placeholder process, before calling parent&#39;s dispatchBlurEvent().
156     virtual void handleBlurEvent() { }
157 
158     bool placeholderShouldBeVisible() const;
159 
160     unsigned m_cachedSelectionDirection : 2;
161     unsigned m_lastChangeWasUserEdit : 1;
162     unsigned m_isPlaceholderVisible : 1;

163 
164     String m_textAsOfLastFormControlChangeEvent;
165 
166     int m_cachedSelectionStart;
167     int m_cachedSelectionEnd;
168 
169     int m_maxLength { -1 };
170     int m_minLength { -1 };
171 };
172 
173 HTMLTextFormControlElement* enclosingTextFormControl(const Position&amp;);
174 
175 } // namespace WebCore
176 
177 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLTextFormControlElement)
178     static bool isType(const WebCore::Element&amp; element) { return element.isTextFormControlElement(); }
179     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
180     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
181 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
<td>
<hr />
<pre>
 45 
 46     virtual ~HTMLTextFormControlElement();
 47 
 48     void didEditInnerTextValue();
 49     void forwardEvent(Event&amp;);
 50 
 51     int maxLength() const { return m_maxLength; }
 52     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setMaxLength(int);
 53     int minLength() const { return m_minLength; }
 54     ExceptionOr&lt;void&gt; setMinLength(int);
 55 
 56     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 57 
 58     // The derived class should return true if placeholder processing is needed.
 59     bool isPlaceholderVisible() const { return m_isPlaceholderVisible; }
 60     virtual bool supportsPlaceholder() const = 0;
 61     String strippedPlaceholder() const;
 62     virtual HTMLElement* placeholderElement() const = 0;
 63     void updatePlaceholderVisibility();
 64 
<span class="line-added"> 65     WEBCORE_EXPORT void setCanShowPlaceholder(bool);</span>
<span class="line-added"> 66     bool canShowPlaceholder() const { return m_canShowPlaceholder; }</span>
<span class="line-added"> 67 </span>
 68     int indexForVisiblePosition(const VisiblePosition&amp;) const;
 69     WEBCORE_EXPORT VisiblePosition visiblePositionForIndex(int index) const;
 70     WEBCORE_EXPORT int selectionStart() const;
 71     WEBCORE_EXPORT int selectionEnd() const;
 72     WEBCORE_EXPORT const AtomString&amp; selectionDirection() const;
 73     WEBCORE_EXPORT void setSelectionStart(int);
 74     WEBCORE_EXPORT void setSelectionEnd(int);
 75     WEBCORE_EXPORT void setSelectionDirection(const String&amp;);
 76     WEBCORE_EXPORT void select(SelectionRevealMode = SelectionRevealMode::DoNotReveal, const AXTextStateChangeIntent&amp; = AXTextStateChangeIntent());
 77     WEBCORE_EXPORT virtual ExceptionOr&lt;void&gt; setRangeText(const String&amp; replacement);
 78     WEBCORE_EXPORT virtual ExceptionOr&lt;void&gt; setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode);
 79     void setSelectionRange(int start, int end, const String&amp; direction, const AXTextStateChangeIntent&amp; = AXTextStateChangeIntent());
 80     WEBCORE_EXPORT void setSelectionRange(int start, int end, TextFieldSelectionDirection = SelectionHasNoDirection, SelectionRevealMode = SelectionRevealMode::DoNotReveal, const AXTextStateChangeIntent&amp; = AXTextStateChangeIntent());
 81     RefPtr&lt;Range&gt; selection() const;
 82     String selectedText() const;
 83 
 84     void dispatchFormControlChangeEvent() final;
 85 
 86     virtual String value() const = 0;
 87 
</pre>
<hr />
<pre>
146     TextFieldSelectionDirection computeSelectionDirection() const;
147 
148     void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection) final;
149     void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement) final;
150     bool childShouldCreateRenderer(const Node&amp;) const override;
151 
152     unsigned indexForPosition(const Position&amp;) const;
153 
154     // Returns true if user-editable value is empty. Used to check placeholder visibility.
155     virtual bool isEmptyValue() const = 0;
156     // Called in dispatchFocusEvent(), after placeholder process, before calling parent&#39;s dispatchFocusEvent().
157     virtual void handleFocusEvent(Node* /* oldFocusedNode */, FocusDirection) { }
158     // Called in dispatchBlurEvent(), after placeholder process, before calling parent&#39;s dispatchBlurEvent().
159     virtual void handleBlurEvent() { }
160 
161     bool placeholderShouldBeVisible() const;
162 
163     unsigned m_cachedSelectionDirection : 2;
164     unsigned m_lastChangeWasUserEdit : 1;
165     unsigned m_isPlaceholderVisible : 1;
<span class="line-added">166     unsigned m_canShowPlaceholder : 1;</span>
167 
168     String m_textAsOfLastFormControlChangeEvent;
169 
170     int m_cachedSelectionStart;
171     int m_cachedSelectionEnd;
172 
173     int m_maxLength { -1 };
174     int m_minLength { -1 };
175 };
176 
177 HTMLTextFormControlElement* enclosingTextFormControl(const Position&amp;);
178 
179 } // namespace WebCore
180 
181 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLTextFormControlElement)
182     static bool isType(const WebCore::Element&amp; element) { return element.isTextFormControlElement(); }
183     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
184     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
185 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
</tr>
</table>
<center><a href="HTMLTextFormControlElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTrackElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
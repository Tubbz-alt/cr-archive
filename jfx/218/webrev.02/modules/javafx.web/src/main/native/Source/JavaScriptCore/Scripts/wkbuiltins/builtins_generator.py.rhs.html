<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/Scripts/wkbuiltins/builtins_generator.py</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014, 2015 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 import logging
 28 import os.path
 29 import re
 30 from string import Template
 31 import json
 32 
 33 from builtins_model import BuiltinFunction, BuiltinObject
 34 from builtins_templates import BuiltinsGeneratorTemplates as Templates
 35 
 36 log = logging.getLogger(&#39;global&#39;)
 37 
 38 # These match WK_lcfirst and WK_ucfirst defined in CodeGenerator.pm.
 39 def WK_lcfirst(str):
 40     str = str[:1].lower() + str[1:]
 41     str = str.replace(&#39;dOM&#39;, &#39;dom&#39;)
 42     str = str.replace(&#39;uRL&#39;, &#39;url&#39;)
 43     str = str.replace(&#39;jS&#39;, &#39;js&#39;)
 44     str = str.replace(&#39;xML&#39;, &#39;xml&#39;)
 45     str = str.replace(&#39;xSLT&#39;, &#39;xslt&#39;)
 46     str = str.replace(&#39;cSS&#39;, &#39;css&#39;)
 47     str = str.replace(&#39;rTC&#39;, &#39;rtc&#39;)
 48     return str
 49 
 50 def WK_ucfirst(str):
 51     str = str[:1].upper() + str[1:]
 52     str = str.replace(&#39;Xml&#39;, &#39;XML&#39;)
 53     str = str.replace(&#39;Svg&#39;, &#39;SVG&#39;)
 54     return str
 55 
 56 class BuiltinsGenerator:
 57     def __init__(self, model):
 58         self._model = model
 59 
 60     def model(self):
 61         return self._model
 62 
 63     # These methods are overridden by subclasses.
 64 
 65     def generate_output(self):
 66         pass
 67 
 68     def output_filename(self):
 69         pass
 70 
 71 
 72     # Shared code generation methods.
 73     def generate_license(self):
 74         raw_license = Template(Templates.LicenseText).substitute(None)
 75         copyrights = self._model.copyrights()
 76         copyrights.sort()
 77 
 78         license_block = []
 79         license_block.append(&quot;/*&quot;)
 80         for copyright in copyrights:
 81             license_block.append(&quot; * Copyright (c) %s&quot; % copyright)
 82         if len(copyrights) &gt; 0:
 83             license_block.append(&quot; * &quot;)
 84 
 85         for line in raw_license.split(&#39;\n&#39;):
 86             license_block.append(&quot; * &quot; + line)
 87 
 88         license_block.append(&quot; */&quot;)
 89 
 90         return &#39;\n&#39;.join(license_block)
 91 
 92     def generate_includes_from_entries(self, entries):
 93         includes = set()
 94         for entry in entries:
 95             (allowed_framework_names, data) = entry
 96             (framework_name, header_path) = data
 97 
 98             if self.model().framework.name not in allowed_framework_names:
 99                 continue
100             if self.model().framework.name != framework_name:
101                 includes.add(&quot;#include &lt;%s/%s&gt;&quot; % (framework_name, os.path.basename(header_path)))
102             else:
103                 includes.add(&quot;#include \&quot;%s\&quot;&quot; % os.path.basename(header_path))
104 
105         return sorted(list(includes))
106 
107     def generate_primary_header_includes(self):
108         name, _ = os.path.splitext(self.output_filename())
109         return &#39;\n&#39;.join([
110             &quot;#include \&quot;config.h\&quot;&quot;,
111             &quot;#include \&quot;%s.h\&quot;&quot; % name,
112         ])
113 
114     def generate_embedded_code_data_for_function(self, function):
115         text = function.function_source
116         # Wrap it in parens to avoid adding to global scope.
117         function_type_string = &quot;function &quot;
118         if function.is_async:
119             function_type_string = &quot;async &quot; + function_type_string
120 
121         text = &quot;(&quot; + function_type_string + text[text.index(&quot;(&quot;):] + &quot;)&quot;
122         embeddedSourceLength = len(text) + 1  # For extra \n.
123         # Lazy way to escape quotes, I think?
124         textLines = json.dumps(text)[1:-1].split(&quot;\\n&quot;)
125         # This looks scary because we need the JS source itself to have newlines.
126         embeddedSource = &#39;\n&#39;.join([&#39;    &quot;%s\\n&quot; \\&#39; % line for line in textLines])
127 
128         constructAbility = &quot;CannotConstruct&quot;
129         if function.is_constructor:
130             constructAbility = &quot;CanConstruct&quot;
131 
<a name="1" id="anc1"></a><span class="line-added">132         constructorKind = &quot;None&quot;</span>
<span class="line-added">133         if function.is_naked_constructor:</span>
<span class="line-added">134             constructorKind = &quot;Naked&quot;</span>
<span class="line-added">135 </span>
136         return {
137             &#39;codeName&#39;: BuiltinsGenerator.mangledNameForFunction(function) + &#39;Code&#39;,
138             &#39;embeddedSource&#39;: embeddedSource,
139             &#39;embeddedSourceLength&#39;: embeddedSourceLength,
140             &#39;originalSource&#39;: text + &quot;\n&quot;,
<a name="2" id="anc2"></a><span class="line-modified">141             &#39;constructAbility&#39;: constructAbility,</span>
<span class="line-added">142             &#39;constructorKind&#39;: constructorKind,</span>
143             &#39;intrinsic&#39;: function.intrinsic
144         }
145 
146     def generate_embedded_code_string_section_for_data(self, data):
147         lines = []
<a name="3" id="anc3"></a><span class="line-modified">148         lines.append(&quot;const JSC::ConstructAbility s_%(codeName)sConstructAbility = JSC::ConstructAbility::%(constructAbility)s;&quot; % data);</span>
<span class="line-added">149         lines.append(&quot;const JSC::ConstructorKind s_%(codeName)sConstructorKind = JSC::ConstructorKind::%(constructorKind)s;&quot; % data);</span>
150         lines.append(&quot;const int s_%(codeName)sLength = %(embeddedSourceLength)d;&quot; % data);
151         lines.append(&quot;static const JSC::Intrinsic s_%(codeName)sIntrinsic = JSC::%(intrinsic)s;&quot; % data);
152         lines.append(&quot;const char* const s_%(codeName)s =\n%(embeddedSource)s\n;&quot; % data);
153         return &#39;\n&#39;.join(lines)
154 
155     # Helper methods.
156 
157     @staticmethod
158     def wrap_with_guard(guard, text):
159         if not guard:
160             return text
161         return &#39;\n&#39;.join([
162             &#39;#if %s&#39; % guard,
163             text,
164             &#39;#endif // %s&#39; % guard,
165         ])
166 
167     @staticmethod
168     def mangledNameForObject(object):
169         if not isinstance(object, BuiltinObject):
170             raise Exception(&quot;Invalid argument passed to mangledNameForObject()&quot;)
171 
172         def toCamel(match):
173             str = match.group(0)
174             return str[1].upper()
175         return re.sub(r&#39;\.[a-z]&#39;, toCamel, object.object_name, flags=re.IGNORECASE)
176 
177 
178     @staticmethod
179     def mangledNameForFunction(function):
180         if not isinstance(function, BuiltinFunction):
181             raise Exception(&quot;Invalid argument passed to mangledNameForFunction()&quot;)
182 
183         function_name = WK_ucfirst(function.function_name)
184 
185         def toCamel(match):
186             str = match.group(0)
187             return str[1].upper()
188         function_name = re.sub(r&#39;\.[a-z]&#39;, toCamel, function_name, flags=re.IGNORECASE)
189         if function.is_constructor:
190             function_name = function_name + &quot;Constructor&quot;
191 
192         object_name = BuiltinsGenerator.mangledNameForObject(function.object)
193         return WK_lcfirst(object_name + function_name)
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
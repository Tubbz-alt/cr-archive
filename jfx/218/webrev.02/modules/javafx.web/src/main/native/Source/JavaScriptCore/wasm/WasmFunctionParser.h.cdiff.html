<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmFormat.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmInstance.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmFunctionParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,74 ***</span>
      Block,
      Loop,
      TopLevel
  };
  
  template&lt;typename Context&gt;
  class FunctionParser : public Parser&lt;void&gt; {
  public:
<span class="line-modified">!     using ExpressionType = typename Context::ExpressionType;</span>
      using ControlType = typename Context::ControlType;
<span class="line-modified">!     using ExpressionList = typename Context::ExpressionList;</span>
<span class="line-removed">-     using Stack = typename Context::Stack;</span>
  
<span class="line-modified">!     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);</span>
  
<span class="line-modified">!     Result WARN_UNUSED_RETURN parse();</span>
  
      struct ControlEntry {
          Stack enclosedExpressionStack;
          ControlType controlData;
      };
  
      OpType currentOpcode() const { return m_currentOpcode; }
      size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
  
  private:
<span class="line-modified">!     static const bool verbose = false;</span>
  
      PartialResult WARN_UNUSED_RETURN parseBody();
      PartialResult WARN_UNUSED_RETURN parseExpression();
      PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
      PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
  
  #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
          WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
          result = m_expressionStack.takeLast();                                              \
<span class="line-modified">!         m_toKillAfterExpression.append(result);                                             \</span>
      } while (0)
  
      template&lt;OpType&gt;
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN unaryCase();</span>
  
      template&lt;OpType&gt;
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN binaryCase();</span>
  
  #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
  
      // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
  
      Context&amp; m_context;
      Stack m_expressionStack;
<span class="line-modified">!     Vector&lt;ControlEntry&gt; m_controlStack;</span>
      const Signature&amp; m_signature;
      const ModuleInformation&amp; m_info;
  
      OpType m_currentOpcode;
      size_t m_currentOpcodeStartingOffset { 0 };
  
<span class="line-removed">-     Vector&lt;ExpressionType, 8&gt; m_toKillAfterExpression;</span>
<span class="line-removed">- </span>
      unsigned m_unreachableBlocks { 0 };
      unsigned m_loopIndex { 0 };
  };
  
  template&lt;typename Context&gt;
  FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
      : Parser(functionStart, functionLength)
      , m_context(context)
<span class="line-removed">-     , m_expressionStack(context.createStack())</span>
      , m_signature(signature)
      , m_info(info)
  {
      if (verbose)
          dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);
<span class="line-new-header">--- 38,136 ---</span>
      Block,
      Loop,
      TopLevel
  };
  
<span class="line-added">+ template&lt;typename EnclosingStack, typename NewStack&gt;</span>
<span class="line-added">+ void splitStack(BlockSignature signature, EnclosingStack&amp; enclosingStack, NewStack&amp; newStack)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     newStack.reserveInitialCapacity(signature-&gt;argumentCount());</span>
<span class="line-added">+     ASSERT(enclosingStack.size() &gt;= signature-&gt;argumentCount());</span>
<span class="line-added">+     unsigned offset = enclosingStack.size() - signature-&gt;argumentCount();</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; signature-&gt;argumentCount(); ++i)</span>
<span class="line-added">+         newStack.uncheckedAppend(enclosingStack.at(i + offset));</span>
<span class="line-added">+     enclosingStack.shrink(offset);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template&lt;typename Context&gt;
  class FunctionParser : public Parser&lt;void&gt; {
  public:
<span class="line-modified">!     struct ControlEntry;</span>
<span class="line-added">+ </span>
      using ControlType = typename Context::ControlType;
<span class="line-modified">!     using ExpressionType = typename Context::ExpressionType;</span>
  
<span class="line-modified">!     class TypedExpression {</span>
<span class="line-added">+     public:</span>
<span class="line-added">+         TypedExpression() = default;</span>
  
<span class="line-modified">!         TypedExpression(Type type, ExpressionType value)</span>
<span class="line-added">+             : m_type(type)</span>
<span class="line-added">+             , m_value(value)</span>
<span class="line-added">+         {</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Type type() const { return m_type; }</span>
<span class="line-added">+ </span>
<span class="line-added">+         ExpressionType value() const { return m_value; }</span>
<span class="line-added">+         operator ExpressionType() const { return m_value; }</span>
<span class="line-added">+ </span>
<span class="line-added">+         ExpressionType operator-&gt;() const { return m_value; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private:</span>
<span class="line-added">+         Type m_type;</span>
<span class="line-added">+         ExpressionType m_value;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
<span class="line-added">+     using ControlStack = Vector&lt;ControlEntry, 16&gt;;</span>
<span class="line-added">+     using ResultList = Vector&lt;ExpressionType, 8&gt;;</span>
<span class="line-added">+     using Stack = Vector&lt;TypedExpression, 16, UnsafeVectorOverflow&gt;;</span>
  
      struct ControlEntry {
          Stack enclosedExpressionStack;
<span class="line-added">+         Stack elseBlockStack;</span>
          ControlType controlData;
      };
  
<span class="line-added">+     FunctionParser(Context&amp;, const uint8_t* functionStart, size_t functionLength, const Signature&amp;, const ModuleInformation&amp;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Result WARN_UNUSED_RETURN parse();</span>
<span class="line-added">+ </span>
      OpType currentOpcode() const { return m_currentOpcode; }
      size_t currentOpcodeStartingOffset() const { return m_currentOpcodeStartingOffset; }
<span class="line-added">+     const Signature&amp; signature() const { return m_signature; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     ControlStack&amp; controlStack() { return m_controlStack; }</span>
<span class="line-added">+     Stack&amp; expressionStack() { return m_expressionStack; }</span>
  
  private:
<span class="line-modified">!     static constexpr bool verbose = false;</span>
  
      PartialResult WARN_UNUSED_RETURN parseBody();
      PartialResult WARN_UNUSED_RETURN parseExpression();
      PartialResult WARN_UNUSED_RETURN parseUnreachableExpression();
      PartialResult WARN_UNUSED_RETURN unifyControl(Vector&lt;ExpressionType&gt;&amp;, unsigned level);
<span class="line-added">+     PartialResult WARN_UNUSED_RETURN checkBranchTarget(const ControlType&amp;);</span>
<span class="line-added">+     PartialResult WARN_UNUSED_RETURN unify(const ControlType&amp;);</span>
  
  #define WASM_TRY_POP_EXPRESSION_STACK_INTO(result, what) do {                               \
          WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t pop empty stack in &quot; what); \
          result = m_expressionStack.takeLast();                                              \
<span class="line-modified">!         m_context.didPopValueFromStack();                                                   \</span>
      } while (0)
  
      template&lt;OpType&gt;
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN unaryCase(Type returnType, Type operandType);</span>
  
      template&lt;OpType&gt;
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN binaryCase(Type returnType, Type lhsType, Type rhsType);</span>
<span class="line-added">+ </span>
<span class="line-added">+     PartialResult WARN_UNUSED_RETURN store(Type memoryType);</span>
<span class="line-added">+     PartialResult WARN_UNUSED_RETURN load(Type memoryType);</span>
  
  #define WASM_TRY_ADD_TO_CONTEXT(add_expression) WASM_FAIL_IF_HELPER_FAILS(m_context.add_expression)
  
<span class="line-added">+     template &lt;typename ...Args&gt;</span>
<span class="line-added">+     NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN validationFail(const Args&amp;... args) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         using namespace FailureHelper; // See ADL comment in WasmParser.h.</span>
<span class="line-added">+         if (UNLIKELY(ASSERT_ENABLED &amp;&amp; Options::crashOnFailedWebAssemblyValidate()))</span>
<span class="line-added">+             WTFBreakpointTrap();</span>
<span class="line-added">+ </span>
<span class="line-added">+         StringPrintStream out;</span>
<span class="line-added">+         out.print(&quot;WebAssembly.Module doesn&#39;t validate: &quot;_s, args...);</span>
<span class="line-added">+         return UnexpectedResult(out.toString());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define WASM_VALIDATOR_FAIL_IF(condition, ...) do { \</span>
<span class="line-added">+         if (UNLIKELY(condition)) \</span>
<span class="line-added">+             return validationFail(__VA_ARGS__); \</span>
<span class="line-added">+     } while (0) \</span>
<span class="line-added">+ </span>
      // FIXME add a macro as above for WASM_TRY_APPEND_TO_CONTROL_STACK https://bugs.webkit.org/show_bug.cgi?id=165862
  
      Context&amp; m_context;
      Stack m_expressionStack;
<span class="line-modified">!     ControlStack m_controlStack;</span>
<span class="line-added">+     Vector&lt;Type, 16&gt; m_locals;</span>
      const Signature&amp; m_signature;
      const ModuleInformation&amp; m_info;
  
      OpType m_currentOpcode;
      size_t m_currentOpcodeStartingOffset { 0 };
  
      unsigned m_unreachableBlocks { 0 };
      unsigned m_loopIndex { 0 };
  };
  
  template&lt;typename Context&gt;
  FunctionParser&lt;Context&gt;::FunctionParser(Context&amp; context, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, const ModuleInformation&amp; info)
      : Parser(functionStart, functionLength)
      , m_context(context)
      , m_signature(signature)
      , m_info(info)
  {
      if (verbose)
          dataLogLn(&quot;Parsing function starting at: &quot;, (uintptr_t)functionStart, &quot; of length: &quot;, functionLength, &quot; with signature: &quot;, signature);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,35 ***</span>
      uint32_t localGroupsCount;
  
      WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
      WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);
  
      uint64_t totalNumberOfLocals = m_signature.argumentCount();
      for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {
          uint32_t numberOfLocals;
          Type typeOfLocal;
  
          WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
          totalNumberOfLocals += numberOfLocals;
          WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);
          WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
          WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
      }
  
      WASM_FAIL_IF_HELPER_FAILS(parseBody());
  
      return { };
  }
  
  template&lt;typename Context&gt;
  auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
  {
<span class="line-modified">!     m_controlStack.append({ m_context.createStack(), m_context.addTopLevel(m_signature.returnType()) });</span>
<span class="line-modified">!     uint8_t op;</span>
      while (m_controlStack.size()) {
<span class="line-removed">-         ASSERT(m_toKillAfterExpression.isEmpty());</span>
<span class="line-removed">- </span>
          m_currentOpcodeStartingOffset = m_offset;
          WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
          WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
  
          m_currentOpcode = static_cast&lt;OpType&gt;(op);
<span class="line-new-header">--- 180,44 ---</span>
      uint32_t localGroupsCount;
  
      WASM_PARSER_FAIL_IF(!m_context.addArguments(m_signature), &quot;can&#39;t add &quot;, m_signature.argumentCount(), &quot; arguments to Function&quot;);
      WASM_PARSER_FAIL_IF(!parseVarUInt32(localGroupsCount), &quot;can&#39;t get local groups count&quot;);
  
<span class="line-added">+     WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(m_signature.argumentCount()), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, m_signature.argumentCount(), &quot; arguments&quot;);</span>
<span class="line-added">+     for (uint32_t i = 0; i &lt; m_signature.argumentCount(); ++i)</span>
<span class="line-added">+         m_locals.uncheckedAppend(m_signature.argument(i));</span>
<span class="line-added">+ </span>
      uint64_t totalNumberOfLocals = m_signature.argumentCount();
      for (uint32_t i = 0; i &lt; localGroupsCount; ++i) {
          uint32_t numberOfLocals;
          Type typeOfLocal;
  
          WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfLocals), &quot;can&#39;t get Function&#39;s number of locals in group &quot;, i);
          totalNumberOfLocals += numberOfLocals;
          WASM_PARSER_FAIL_IF(totalNumberOfLocals &gt; maxFunctionLocals, &quot;Function&#39;s number of locals is too big &quot;, totalNumberOfLocals, &quot; maximum &quot;, maxFunctionLocals);
          WASM_PARSER_FAIL_IF(!parseValueType(typeOfLocal), &quot;can&#39;t get Function local&#39;s type in group &quot;, i);
<span class="line-added">+ </span>
<span class="line-added">+         WASM_PARSER_FAIL_IF(!m_locals.tryReserveCapacity(totalNumberOfLocals), &quot;can&#39;t allocate enough memory for function&#39;s &quot;, totalNumberOfLocals, &quot; locals&quot;);</span>
<span class="line-added">+         for (uint32_t i = 0; i &lt; numberOfLocals; ++i)</span>
<span class="line-added">+             m_locals.uncheckedAppend(typeOfLocal);</span>
<span class="line-added">+ </span>
          WASM_TRY_ADD_TO_CONTEXT(addLocal(typeOfLocal, numberOfLocals));
      }
  
<span class="line-added">+     m_context.didFinishParsingLocals();</span>
<span class="line-added">+ </span>
      WASM_FAIL_IF_HELPER_FAILS(parseBody());
  
      return { };
  }
  
  template&lt;typename Context&gt;
  auto FunctionParser&lt;Context&gt;::parseBody() -&gt; PartialResult
  {
<span class="line-modified">!     m_controlStack.append({ { }, { }, m_context.addTopLevel(&amp;m_signature) });</span>
<span class="line-modified">!     uint8_t op = 0;</span>
      while (m_controlStack.size()) {
          m_currentOpcodeStartingOffset = m_offset;
          WASM_PARSER_FAIL_IF(!parseUInt8(op), &quot;can&#39;t decode opcode&quot;);
          WASM_PARSER_FAIL_IF(!isValidOpType(op), &quot;invalid opcode &quot;, op);
  
          m_currentOpcode = static_cast&lt;OpType&gt;(op);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,184 ***</span>
  
          if (m_unreachableBlocks)
              WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
          else {
              WASM_FAIL_IF_HELPER_FAILS(parseExpression());
<span class="line-removed">-             while (m_toKillAfterExpression.size())</span>
<span class="line-removed">-                 m_context.didKill(m_toKillAfterExpression.takeLast());</span>
          }
      }
  
      ASSERT(op == OpType::End);
      return { };
  }
  
  template&lt;typename Context&gt;
  template&lt;OpType op&gt;
<span class="line-modified">! auto FunctionParser&lt;Context&gt;::binaryCase() -&gt; PartialResult</span>
  {
<span class="line-modified">!     ExpressionType right;</span>
<span class="line-modified">!     ExpressionType left;</span>
<span class="line-removed">-     ExpressionType result;</span>
  
      WASM_TRY_POP_EXPRESSION_STACK_INTO(right, &quot;binary right&quot;);
      WASM_TRY_POP_EXPRESSION_STACK_INTO(left, &quot;binary left&quot;);
<span class="line-removed">-     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(left, right, result));</span>
  
<span class="line-modified">!     m_expressionStack.append(result);</span>
      return { };
  }
  
  template&lt;typename Context&gt;
  template&lt;OpType op&gt;
<span class="line-modified">! auto FunctionParser&lt;Context&gt;::unaryCase() -&gt; PartialResult</span>
  {
<span class="line-modified">!     ExpressionType value;</span>
<span class="line-removed">-     ExpressionType result;</span>
<span class="line-removed">- </span>
      WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;unary&quot;);
      WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(value, result));
  
<span class="line-removed">-     m_expressionStack.append(result);</span>
      return { };
  }
  
  template&lt;typename Context&gt;
  auto FunctionParser&lt;Context&gt;::parseExpression() -&gt; PartialResult
  {
      switch (m_currentOpcode) {
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc) case OpType::name: return binaryCase&lt;OpType::name&gt;();</span>
      FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
  #undef CREATE_CASE
  
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc) case OpType::name: return unaryCase&lt;OpType::name&gt;();</span>
      FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
  #undef CREATE_CASE
  
      case Select: {
<span class="line-modified">!         ExpressionType condition;</span>
<span class="line-modified">!         ExpressionType zero;</span>
<span class="line-modified">!         ExpressionType nonZero;</span>
  
          WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;select condition&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(zero, &quot;select zero&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(nonZero, &quot;select non-zero&quot;);
  
          ExpressionType result;
          WASM_TRY_ADD_TO_CONTEXT(addSelect(condition, nonZero, zero, result));
  
<span class="line-modified">!         m_expressionStack.append(result);</span>
          return { };
      }
  
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc) case OpType::name:</span>
<span class="line-modified">!     FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE) {</span>
<span class="line-modified">!         uint32_t alignment;</span>
<span class="line-removed">-         uint32_t offset;</span>
<span class="line-removed">-         ExpressionType pointer;</span>
<span class="line-removed">-         ExpressionType result;</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get load alignment&quot;);</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds load&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get load offset&quot;);</span>
<span class="line-removed">-         WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;load pointer&quot;);</span>
<span class="line-removed">-         WASM_TRY_ADD_TO_CONTEXT(load(static_cast&lt;LoadOpType&gt;(m_currentOpcode), pointer, result, offset));</span>
<span class="line-removed">-         m_expressionStack.append(result);</span>
<span class="line-removed">-         return { };</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE) {</span>
<span class="line-modified">!         uint32_t alignment;</span>
<span class="line-removed">-         uint32_t offset;</span>
<span class="line-removed">-         ExpressionType value;</span>
<span class="line-removed">-         ExpressionType pointer;</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get store alignment&quot;);</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds store&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get store offset&quot;);</span>
<span class="line-removed">-         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;store value&quot;);</span>
<span class="line-removed">-         WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;store pointer&quot;);</span>
<span class="line-removed">-         WASM_TRY_ADD_TO_CONTEXT(store(static_cast&lt;StoreOpType&gt;(m_currentOpcode), pointer, value, offset));</span>
<span class="line-removed">-         return { };</span>
<span class="line-removed">-     }</span>
  #undef CREATE_CASE
  
      case F32Const: {
          uint32_t constant;
          WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
<span class="line-modified">!         m_expressionStack.append(m_context.addConstant(F32, constant));</span>
          return { };
      }
  
      case I32Const: {
          int32_t constant;
          WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
<span class="line-modified">!         m_expressionStack.append(m_context.addConstant(I32, constant));</span>
          return { };
      }
  
      case F64Const: {
          uint64_t constant;
          WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
<span class="line-modified">!         m_expressionStack.append(m_context.addConstant(F64, constant));</span>
          return { };
      }
  
      case I64Const: {
          int64_t constant;
          WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
<span class="line-modified">!         m_expressionStack.append(m_context.addConstant(I64, constant));</span>
          return { };
      }
  
      case TableGet: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          unsigned tableIndex;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified">!         ExpressionType result, index;</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);
          WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
          return { };
      }
  
      case TableSet: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          unsigned tableIndex;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified">!         ExpressionType val, index;</span>
<span class="line-modified">!         WASM_TRY_POP_EXPRESSION_STACK_INTO(val, &quot;table.set&quot;);</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, val));</span>
          return { };
      }
  
      case ExtTable: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          uint8_t extOp;
          WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);
          unsigned tableIndex;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
  
          switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {
          case ExtTableOpType::TableSize: {
              ExpressionType result;
              WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));
<span class="line-modified">!             m_expressionStack.append(result);</span>
              break;
          }
          case ExtTableOpType::TableGrow: {
<span class="line-modified">!             ExpressionType fill, delta, result;</span>
              WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);
              WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);
              WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));
<span class="line-modified">!             m_expressionStack.append(result);</span>
              break;
          }
          case ExtTableOpType::TableFill: {
<span class="line-modified">!             ExpressionType offset, fill, count;</span>
              WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);
              WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);
              WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);
              WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));
              break;
          }
          default:
              WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);
<span class="line-new-header">--- 229,260 ---</span>
  
          if (m_unreachableBlocks)
              WASM_FAIL_IF_HELPER_FAILS(parseUnreachableExpression());
          else {
              WASM_FAIL_IF_HELPER_FAILS(parseExpression());
          }
      }
<span class="line-added">+     WASM_FAIL_IF_HELPER_FAILS(m_context.endTopLevel(&amp;m_signature, m_expressionStack));</span>
  
      ASSERT(op == OpType::End);
      return { };
  }
  
  template&lt;typename Context&gt;
  template&lt;OpType op&gt;
<span class="line-modified">! auto FunctionParser&lt;Context&gt;::binaryCase(Type returnType, Type lhsType, Type rhsType) -&gt; PartialResult</span>
  {
<span class="line-modified">!     TypedExpression right;</span>
<span class="line-modified">!     TypedExpression left;</span>
  
      WASM_TRY_POP_EXPRESSION_STACK_INTO(right, &quot;binary right&quot;);
      WASM_TRY_POP_EXPRESSION_STACK_INTO(left, &quot;binary left&quot;);
  
<span class="line-modified">!     WASM_VALIDATOR_FAIL_IF(left.type() != lhsType, op, &quot; left value type mismatch&quot;);</span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(right.type() != rhsType, op, &quot; right value type mismatch&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ExpressionType result;</span>
<span class="line-added">+     WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(left, right, result));</span>
<span class="line-added">+     m_expressionStack.constructAndAppend(returnType, result);</span>
      return { };
  }
  
  template&lt;typename Context&gt;
  template&lt;OpType op&gt;
<span class="line-modified">! auto FunctionParser&lt;Context&gt;::unaryCase(Type returnType, Type operandType) -&gt; PartialResult</span>
  {
<span class="line-modified">!     TypedExpression value;</span>
      WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;unary&quot;);
<span class="line-added">+ </span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(value.type() != operandType, op, &quot; value type mismatch&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ExpressionType result;</span>
      WASM_TRY_ADD_TO_CONTEXT(template addOp&lt;op&gt;(value, result));
<span class="line-added">+     m_expressionStack.constructAndAppend(returnType, result);</span>
<span class="line-added">+     return { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename Context&gt;</span>
<span class="line-added">+ auto FunctionParser&lt;Context&gt;::load(Type memoryType) -&gt; PartialResult</span>
<span class="line-added">+ {</span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;load instruction without memory&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     uint32_t alignment;</span>
<span class="line-added">+     uint32_t offset;</span>
<span class="line-added">+     TypedExpression pointer;</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get load alignment&quot;);</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds load&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get load offset&quot;);</span>
<span class="line-added">+     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;load pointer&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ExpressionType result;</span>
<span class="line-added">+     WASM_TRY_ADD_TO_CONTEXT(load(static_cast&lt;LoadOpType&gt;(m_currentOpcode), pointer, result, offset));</span>
<span class="line-added">+     m_expressionStack.constructAndAppend(memoryType, result);</span>
<span class="line-added">+     return { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename Context&gt;</span>
<span class="line-added">+ auto FunctionParser&lt;Context&gt;::store(Type memoryType) -&gt; PartialResult</span>
<span class="line-added">+ {</span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(!m_info.memory, &quot;store instruction without memory&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     uint32_t alignment;</span>
<span class="line-added">+     uint32_t offset;</span>
<span class="line-added">+     TypedExpression value;</span>
<span class="line-added">+     TypedExpression pointer;</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(!parseVarUInt32(alignment), &quot;can&#39;t get store alignment&quot;);</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(alignment &gt; memoryLog2Alignment(m_currentOpcode), &quot;byte alignment &quot;, 1ull &lt;&lt; alignment, &quot; exceeds store&#39;s natural alignment &quot;, 1ull &lt;&lt; memoryLog2Alignment(m_currentOpcode));</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(!parseVarUInt32(offset), &quot;can&#39;t get store offset&quot;);</span>
<span class="line-added">+     WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;store value&quot;);</span>
<span class="line-added">+     WASM_TRY_POP_EXPRESSION_STACK_INTO(pointer, &quot;store pointer&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(pointer.type() != I32, m_currentOpcode, &quot; pointer type mismatch&quot;);</span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(value.type() != memoryType, m_currentOpcode, &quot; value type mismatch&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     WASM_TRY_ADD_TO_CONTEXT(store(static_cast&lt;StoreOpType&gt;(m_currentOpcode), pointer, value, offset));</span>
<span class="line-added">+     return { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename Context&gt;</span>
<span class="line-added">+ auto FunctionParser&lt;Context&gt;::checkBranchTarget(const ControlType&amp; target) -&gt; PartialResult</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!target.branchTargetArity())</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; target.branchTargetArity(), ControlType::isTopLevel(target) ? &quot;branch out of function&quot; : &quot;branch to block&quot;, &quot; on expression stack of size &quot;, m_expressionStack.size(), &quot;, but block, &quot;, target.signature()-&gt;toString() , &quot; expects &quot;, target.branchTargetArity(), &quot; values&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned offset = m_expressionStack.size() - target.branchTargetArity();</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; target.branchTargetArity(); ++i)</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!isSubtype(target.branchTargetType(i), m_expressionStack[offset + i].type()), &quot;branch&#39;s stack type is not a subtype of block&#39;s type branch target type. Stack value has type&quot;, m_expressionStack[offset + i].type(), &quot; but branch target expects a value with subtype of &quot;, target.branchTargetType(i), &quot; at index &quot;, i);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return { };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename Context&gt;</span>
<span class="line-added">+ auto FunctionParser&lt;Context&gt;::unify(const ControlType&amp; controlData) -&gt; PartialResult</span>
<span class="line-added">+ {</span>
<span class="line-added">+     WASM_VALIDATOR_FAIL_IF(controlData.signature()-&gt;returnCount() != m_expressionStack.size(), &quot; block with type: &quot;, controlData.signature()-&gt;toString(), &quot; returns: &quot;, controlData.signature()-&gt;returnCount(), &quot; but stack has: &quot;, m_expressionStack.size(), &quot; values&quot;);</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; controlData.signature()-&gt;returnCount(); ++i)</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[i].type(), controlData.signature()-&gt;returnType(i)), &quot;control flow returns with unexpected type. &quot;, m_expressionStack[i].type(), &quot; is not a subtype of &quot;, controlData.signature()-&gt;returnType(i));</span>
  
      return { };
  }
  
  template&lt;typename Context&gt;
  auto FunctionParser&lt;Context&gt;::parseExpression() -&gt; PartialResult
  {
      switch (m_currentOpcode) {
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc, lhsType, rhsType, returnType) case OpType::name: return binaryCase&lt;OpType::name&gt;(returnType, lhsType, rhsType);</span>
      FOR_EACH_WASM_BINARY_OP(CREATE_CASE)
  #undef CREATE_CASE
  
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc, operandType, returnType) case OpType::name: return unaryCase&lt;OpType::name&gt;(returnType, operandType);</span>
      FOR_EACH_WASM_UNARY_OP(CREATE_CASE)
  #undef CREATE_CASE
  
      case Select: {
<span class="line-modified">!         TypedExpression condition;</span>
<span class="line-modified">!         TypedExpression zero;</span>
<span class="line-modified">!         TypedExpression nonZero;</span>
  
          WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;select condition&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(zero, &quot;select zero&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(nonZero, &quot;select non-zero&quot;);
  
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;select condition must be i32, got &quot;, condition.type());</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(nonZero.type() != zero.type(), &quot;select result types must match, got &quot;, nonZero.type(), &quot; and &quot;, zero.type());</span>
<span class="line-added">+ </span>
          ExpressionType result;
          WASM_TRY_ADD_TO_CONTEXT(addSelect(condition, nonZero, zero, result));
  
<span class="line-modified">!         m_expressionStack.constructAndAppend(zero.type(), result);</span>
          return { };
      }
  
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return load(memoryType);</span>
<span class="line-modified">! FOR_EACH_WASM_MEMORY_LOAD_OP(CREATE_CASE)</span>
<span class="line-modified">! #undef CREATE_CASE</span>
  
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc, memoryType) case OpType::name: return store(memoryType);</span>
<span class="line-modified">! FOR_EACH_WASM_MEMORY_STORE_OP(CREATE_CASE)</span>
  #undef CREATE_CASE
  
      case F32Const: {
          uint32_t constant;
          WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t parse 32-bit floating-point constant&quot;);
<span class="line-modified">!         m_expressionStack.constructAndAppend(F32, m_context.addConstant(F32, constant));</span>
          return { };
      }
  
      case I32Const: {
          int32_t constant;
          WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t parse 32-bit constant&quot;);
<span class="line-modified">!         m_expressionStack.constructAndAppend(I32, m_context.addConstant(I32, constant));</span>
          return { };
      }
  
      case F64Const: {
          uint64_t constant;
          WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t parse 64-bit floating-point constant&quot;);
<span class="line-modified">!         m_expressionStack.constructAndAppend(F64, m_context.addConstant(F64, constant));</span>
          return { };
      }
  
      case I64Const: {
          int64_t constant;
          WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t parse 64-bit constant&quot;);
<span class="line-modified">!         m_expressionStack.constructAndAppend(I64, m_context.addConstant(I64, constant));</span>
          return { };
      }
  
      case TableGet: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          unsigned tableIndex;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
<span class="line-added">+ </span>
<span class="line-added">+         TypedExpression index;</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.get&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.get index to type &quot;, index.type(), &quot; expected &quot;, I32);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ExpressionType result;</span>
          WASM_TRY_ADD_TO_CONTEXT(addTableGet(tableIndex, index, result));
<span class="line-modified">!         Type resultType = m_info.tables[tableIndex].wasmType();</span>
<span class="line-added">+         m_expressionStack.constructAndAppend(resultType, result);</span>
          return { };
      }
  
      case TableSet: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          unsigned tableIndex;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
<span class="line-modified">!         TypedExpression value, index;</span>
<span class="line-added">+         WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;table.set&quot;);</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(index, &quot;table.set&quot;);
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(I32 != index.type(), &quot;table.set index to type &quot;, index.type(), &quot; expected &quot;, I32);</span>
<span class="line-added">+         Type type = m_info.tables[tableIndex].wasmType();</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), type), &quot;table.set value to type &quot;, value.type(), &quot; expected &quot;, type);</span>
<span class="line-added">+         RELEASE_ASSERT(m_info.tables[tableIndex].type() == TableElementType::Anyref || m_info.tables[tableIndex].type() == TableElementType::Funcref);</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addTableSet(tableIndex, index, value));</span>
          return { };
      }
  
      case ExtTable: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          uint8_t extOp;
          WASM_PARSER_FAIL_IF(!parseUInt8(extOp), &quot;can&#39;t parse table extended opcode&quot;);
          unsigned tableIndex;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t parse table index&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(tableIndex &gt;= m_info.tableCount(), &quot;table index &quot;, tableIndex, &quot; is invalid, limit is &quot;, m_info.tableCount());</span>
  
          switch (static_cast&lt;ExtTableOpType&gt;(extOp)) {
          case ExtTableOpType::TableSize: {
              ExpressionType result;
              WASM_TRY_ADD_TO_CONTEXT(addTableSize(tableIndex, result));
<span class="line-modified">!             m_expressionStack.constructAndAppend(I32, result);</span>
              break;
          }
          case ExtTableOpType::TableGrow: {
<span class="line-modified">!             TypedExpression fill;</span>
<span class="line-added">+             TypedExpression delta;</span>
              WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;table.grow&quot;);
              WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.grow&quot;);
<span class="line-added">+ </span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.grow expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(I32 != delta.type(), &quot;table.grow expects an i32 delta value, got &quot;, delta.type());</span>
<span class="line-added">+ </span>
<span class="line-added">+             ExpressionType result;</span>
              WASM_TRY_ADD_TO_CONTEXT(addTableGrow(tableIndex, fill, delta, result));
<span class="line-modified">!             m_expressionStack.constructAndAppend(I32, result);</span>
              break;
          }
          case ExtTableOpType::TableFill: {
<span class="line-modified">!             TypedExpression offset, fill, count;</span>
              WASM_TRY_POP_EXPRESSION_STACK_INTO(count, &quot;table.fill&quot;);
              WASM_TRY_POP_EXPRESSION_STACK_INTO(fill, &quot;table.fill&quot;);
              WASM_TRY_POP_EXPRESSION_STACK_INTO(offset, &quot;table.fill&quot;);
<span class="line-added">+ </span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(!isSubtype(fill.type(), m_info.tables[tableIndex].wasmType()), &quot;table.fill expects fill value of type &quot;, m_info.tables[tableIndex].wasmType(), &quot; got &quot;, fill.type());</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(I32 != offset.type(), &quot;table.fill expects an i32 offset value, got &quot;, offset.type());</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(I32 != count.type(), &quot;table.fill expects an i32 count value, got &quot;, count.type());</span>
<span class="line-added">+ </span>
              WASM_TRY_ADD_TO_CONTEXT(addTableFill(tableIndex, offset, fill, count));
              break;
          }
          default:
              WASM_PARSER_FAIL_IF(true, &quot;invalid extended table op &quot;, extOp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 344,74 ***</span>
          return { };
      }
  
      case RefNull: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified">!         m_expressionStack.append(m_context.addConstant(Funcref, JSValue::encode(jsNull())));</span>
          return { };
      }
  
      case RefIsNull: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified">!         ExpressionType result, value;</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);
          WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
          return { };
      }
  
      case RefFunc: {
          uint32_t index;
          ExpressionType result;
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);
  
          WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
          return { };
      }
  
      case GetLocal: {
          uint32_t index;
          ExpressionType result;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
          WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
          return { };
      }
  
      case SetLocal: {
          uint32_t index;
<span class="line-modified">!         ExpressionType value;</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
          WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
          return { };
      }
  
      case TeeLocal: {
          uint32_t index;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for tee_local&quot;);
          WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t tee_local on empty expression stack&quot;);
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, m_expressionStack.last()));</span>
          return { };
      }
  
      case GetGlobal: {
          uint32_t index;
          ExpressionType result;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
          WASM_TRY_ADD_TO_CONTEXT(getGlobal(index, result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
          return { };
      }
  
      case SetGlobal: {
          uint32_t index;
<span class="line-modified">!         ExpressionType value;</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
          WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
          return { };
      }
  
      case Call: {
<span class="line-new-header">--- 491,95 ---</span>
          return { };
      }
  
      case RefNull: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified">!         m_expressionStack.constructAndAppend(Funcref, m_context.addConstant(Funcref, JSValue::encode(jsNull())));</span>
          return { };
      }
  
      case RefIsNull: {
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
<span class="line-modified">!         TypedExpression value;</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;ref.is_null&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), Anyref), &quot;ref.is_null to type &quot;, value.type(), &quot; expected &quot;, Anyref);</span>
<span class="line-added">+         ExpressionType result;</span>
          WASM_TRY_ADD_TO_CONTEXT(addRefIsNull(value, result));
<span class="line-modified">!         m_expressionStack.constructAndAppend(I32, result);</span>
          return { };
      }
  
      case RefFunc: {
          uint32_t index;
          ExpressionType result;
          WASM_PARSER_FAIL_IF(!Options::useWebAssemblyReferences(), &quot;references are not enabled&quot;);
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for ref.func&quot;);
  
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.functionIndexSpaceSize(), &quot;ref.func index &quot;, index, &quot; is too large, max is &quot;, m_info.functionIndexSpaceSize());</span>
<span class="line-added">+         m_info.addReferencedFunction(index);</span>
          WASM_TRY_ADD_TO_CONTEXT(addRefFunc(index, result));
<span class="line-modified">!         m_expressionStack.constructAndAppend(Funcref, result);</span>
          return { };
      }
  
      case GetLocal: {
          uint32_t index;
          ExpressionType result;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for get_local&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to use unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
          WASM_TRY_ADD_TO_CONTEXT(getLocal(index, result));
<span class="line-modified">!         m_expressionStack.constructAndAppend(m_locals[index], result);</span>
          return { };
      }
  
      case SetLocal: {
          uint32_t index;
<span class="line-modified">!         TypedExpression value;</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for set_local&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_local&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to set unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);</span>
          WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));
          return { };
      }
  
      case TeeLocal: {
          uint32_t index;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get index for tee_local&quot;);
          WASM_PARSER_FAIL_IF(m_expressionStack.isEmpty(), &quot;can&#39;t tee_local on empty expression stack&quot;);
<span class="line-modified">!         TypedExpression value = m_expressionStack.last();</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(index &gt;= m_locals.size(), &quot;attempt to tee unknown local &quot;, index, &quot; last one is &quot;, m_locals.size());</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!isSubtype(value.type(), m_locals[index]), &quot;set_local to type &quot;, value.type(), &quot; expected &quot;, m_locals[index]);</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(setLocal(index, value));</span>
          return { };
      }
  
      case GetGlobal: {
          uint32_t index;
          ExpressionType result;
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;get_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());</span>
<span class="line-added">+         Type resultType = m_info.globals[index].type;</span>
<span class="line-added">+         ASSERT(isValueType(resultType));</span>
          WASM_TRY_ADD_TO_CONTEXT(getGlobal(index, result));
<span class="line-modified">!         m_expressionStack.constructAndAppend(resultType, result);</span>
          return { };
      }
  
      case SetGlobal: {
          uint32_t index;
<span class="line-modified">!         TypedExpression value;</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get set_global&#39;s index&quot;);
          WASM_TRY_POP_EXPRESSION_STACK_INTO(value, &quot;set_global value&quot;);
<span class="line-added">+ </span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(index &gt;= m_info.globals.size(), &quot;set_global &quot;, index, &quot; of unknown global, limit is &quot;, m_info.globals.size());</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(m_info.globals[index].mutability == GlobalInformation::Immutable, &quot;set_global &quot;, index, &quot; is immutable&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         Type globalType = m_info.globals[index].type;</span>
<span class="line-added">+         ASSERT(isValueType(globalType));</span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(globalType != value.type(), &quot;set_global &quot;, index, &quot; with type &quot;, globalType, &quot; with a variable of type &quot;, value.type());</span>
<span class="line-added">+ </span>
          WASM_TRY_ADD_TO_CONTEXT(setGlobal(index, value));
          return { };
      }
  
      case Call: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,19 ***</span>
          WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
  
          size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
          Vector&lt;ExpressionType&gt; args;
          WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
<span class="line-modified">!         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)</span>
<span class="line-modified">!             args.uncheckedAppend(m_expressionStack.at(i));</span>
          m_expressionStack.shrink(firstArgumentIndex);
  
<span class="line-modified">!         ExpressionType result = Context::emptyExpression();</span>
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, result));</span>
  
<span class="line-modified">!         if (result != Context::emptyExpression())</span>
<span class="line-modified">!             m_expressionStack.append(result);</span>
  
          return { };
      }
  
      case CallIndirect: {
<span class="line-new-header">--- 592,27 ---</span>
          WASM_PARSER_FAIL_IF(calleeSignature.argumentCount() &gt; m_expressionStack.size(), &quot;call function index &quot;, functionIndex, &quot; has &quot;, calleeSignature.argumentCount(), &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
  
          size_t firstArgumentIndex = m_expressionStack.size() - calleeSignature.argumentCount();
          Vector&lt;ExpressionType&gt; args;
          WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(calleeSignature.argumentCount()), &quot;can&#39;t allocate enough memory for call&#39;s &quot;, calleeSignature.argumentCount(), &quot; arguments&quot;);
<span class="line-modified">!         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {</span>
<span class="line-modified">!             TypedExpression arg = m_expressionStack.at(i);</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));</span>
<span class="line-added">+             args.uncheckedAppend(arg);</span>
<span class="line-added">+             m_context.didPopValueFromStack();</span>
<span class="line-added">+         }</span>
          m_expressionStack.shrink(firstArgumentIndex);
  
<span class="line-modified">!         RELEASE_ASSERT(calleeSignature.argumentCount() == args.size());</span>
<span class="line-modified">! </span>
<span class="line-added">+         ResultList results;</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addCall(functionIndex, calleeSignature, args, results));</span>
  
<span class="line-modified">!         RELEASE_ASSERT(calleeSignature.returnCount() == results.size());</span>
<span class="line-modified">! </span>
<span class="line-added">+         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)</span>
<span class="line-added">+             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);</span>
  
          return { };
      }
  
      case CallIndirect: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,84 ***</span>
  
          const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
          size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
          WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
  
          Vector&lt;ExpressionType&gt; args;
          WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
          size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
<span class="line-modified">!         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i)</span>
<span class="line-modified">!             args.uncheckedAppend(m_expressionStack.at(i));</span>
          m_expressionStack.shrink(firstArgumentIndex);
  
<span class="line-removed">-         ExpressionType result = Context::emptyExpression();</span>
<span class="line-removed">-         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, result));</span>
  
<span class="line-modified">!         if (result != Context::emptyExpression())</span>
<span class="line-modified">!             m_expressionStack.append(result);</span>
  
          return { };
      }
  
      case Block: {
<span class="line-modified">!         Type inlineSignature;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get block&#39;s inline signature&quot;);</span>
<span class="line-modified">!         m_controlStack.append({ WTFMove(m_expressionStack), m_context.addBlock(inlineSignature) });</span>
<span class="line-modified">!         m_expressionStack = m_context.createStack();</span>
          return { };
      }
  
      case Loop: {
<span class="line-modified">!         Type inlineSignature;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get loop&#39;s inline signature&quot;);</span>
<span class="line-modified">!         auto expressionStack = WTFMove(m_expressionStack);</span>
<span class="line-modified">!         auto loop = m_context.addLoop(inlineSignature, expressionStack, m_loopIndex++);</span>
<span class="line-modified">!         m_controlStack.append({ expressionStack, loop });</span>
<span class="line-modified">!         m_expressionStack = m_context.createStack();</span>
          return { };
      }
  
      case If: {
<span class="line-modified">!         Type inlineSignature;</span>
<span class="line-modified">!         ExpressionType condition;</span>
<span class="line-modified">!         ControlType control;</span>
<span class="line-removed">-         WASM_PARSER_FAIL_IF(!parseResultType(inlineSignature), &quot;can&#39;t get if&#39;s inline signature&quot;);</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, control));</span>
<span class="line-modified">!         m_controlStack.append({ WTFMove(m_expressionStack), control });</span>
<span class="line-modified">!         m_expressionStack = m_context.createStack();</span>
          return { };
      }
  
      case Else: {
          WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(addElse(m_controlStack.last().controlData, m_expressionStack));</span>
<span class="line-modified">!         m_expressionStack.shrink(0);</span>
          return { };
      }
  
      case Br:
      case BrIf: {
          uint32_t target;
<span class="line-modified">!         ExpressionType condition = Context::emptyExpression();</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
          WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
<span class="line-modified">!         if (m_currentOpcode == BrIf)</span>
              WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
<span class="line-modified">!         else</span>
              m_unreachableBlocks = 1;
  
          ControlType&amp; data = m_controlStack[m_controlStack.size() - 1 - target].controlData;
<span class="line-modified">! </span>
          WASM_TRY_ADD_TO_CONTEXT(addBranch(data, condition, m_expressionStack));
          return { };
      }
  
      case BrTable: {
          uint32_t numberOfTargets;
<span class="line-modified">!         uint32_t defaultTarget;</span>
<span class="line-modified">!         ExpressionType condition;</span>
          Vector&lt;ControlType*&gt; targets;
  
          WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table&quot;);
          WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
  
<span class="line-new-header">--- 627,141 ---</span>
  
          const Signature&amp; calleeSignature = m_info.usedSignatures[signatureIndex].get();
          size_t argumentCount = calleeSignature.argumentCount() + 1; // Add the callee&#39;s index.
          WASM_PARSER_FAIL_IF(argumentCount &gt; m_expressionStack.size(), &quot;call_indirect expects &quot;, argumentCount, &quot; arguments, but the expression stack currently holds &quot;, m_expressionStack.size(), &quot; values&quot;);
  
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(m_expressionStack.last().type() != I32, &quot;non-i32 call_indirect index &quot;, m_expressionStack.last().type());</span>
<span class="line-added">+ </span>
          Vector&lt;ExpressionType&gt; args;
          WASM_PARSER_FAIL_IF(!args.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for &quot;, argumentCount, &quot; call_indirect arguments&quot;);
          size_t firstArgumentIndex = m_expressionStack.size() - argumentCount;
<span class="line-modified">!         for (size_t i = firstArgumentIndex; i &lt; m_expressionStack.size(); ++i) {</span>
<span class="line-modified">!             TypedExpression arg = m_expressionStack.at(i);</span>
<span class="line-added">+             if (i &lt; calleeSignature.argumentCount())</span>
<span class="line-added">+                 WASM_VALIDATOR_FAIL_IF(!isSubtype(arg.type(), calleeSignature.argument(i - firstArgumentIndex)), &quot;argument type mismatch in call_indirect, got &quot;, arg.type(), &quot;, expected &quot;, calleeSignature.argument(i - firstArgumentIndex));</span>
<span class="line-added">+             args.uncheckedAppend(arg);</span>
<span class="line-added">+             m_context.didPopValueFromStack();</span>
<span class="line-added">+         }</span>
          m_expressionStack.shrink(firstArgumentIndex);
  
  
<span class="line-modified">! </span>
<span class="line-modified">!         ResultList results;</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addCallIndirect(tableIndex, calleeSignature, args, results));</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (unsigned i = 0; i &lt; calleeSignature.returnCount(); ++i)</span>
<span class="line-added">+             m_expressionStack.constructAndAppend(calleeSignature.returnType(i), results[i]);</span>
  
          return { };
      }
  
      case Block: {
<span class="line-modified">!         BlockSignature inlineSignature;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get block&#39;s signature&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for block. Block expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Block has inlineSignature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-added">+         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {</span>
<span class="line-added">+             Type type = m_expressionStack.at(offset + i).type();</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Block expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added">+         Stack newStack;</span>
<span class="line-added">+         ControlType block;</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addBlock(inlineSignature, m_expressionStack, block, newStack));</span>
<span class="line-added">+         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added">+         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_controlStack.append({ WTFMove(m_expressionStack), { },  WTFMove(block) });</span>
<span class="line-added">+         m_expressionStack = WTFMove(newStack);</span>
          return { };
      }
  
      case Loop: {
<span class="line-modified">!         BlockSignature inlineSignature;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get loop&#39;s signature&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few values on stack for loop block. Loop expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. Loop has inlineSignature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-modified">!         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-modified">!         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i) {</span>
<span class="line-added">+             Type type = m_expressionStack.at(offset + i).type();</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(!isSubtype(type, inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, type);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added">+         Stack newStack;</span>
<span class="line-added">+         ControlType loop;</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addLoop(inlineSignature, m_expressionStack, loop, newStack, m_loopIndex++));</span>
<span class="line-added">+         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added">+         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_controlStack.append({ WTFMove(m_expressionStack), { }, WTFMove(loop) });</span>
<span class="line-added">+         m_expressionStack = WTFMove(newStack);</span>
          return { };
      }
  
      case If: {
<span class="line-modified">!         BlockSignature inlineSignature;</span>
<span class="line-modified">!         TypedExpression condition;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, inlineSignature), &quot;can&#39;t get if&#39;s signature&quot;);</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;if condition&quot;);
<span class="line-modified">! </span>
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;if condition must be i32, got &quot;, condition.type());</span>
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(m_expressionStack.size() &lt; inlineSignature-&gt;argumentCount(), &quot;Too few arguments on stack for if block. If expects &quot;, inlineSignature-&gt;argumentCount(), &quot;, but only &quot;, m_expressionStack.size(), &quot; were present. If block has signature: &quot;, inlineSignature-&gt;toString());</span>
<span class="line-added">+         unsigned offset = m_expressionStack.size() - inlineSignature-&gt;argumentCount();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; inlineSignature-&gt;argumentCount(); ++i)</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(!isSubtype(m_expressionStack[offset + i].type(), inlineSignature-&gt;argument(i)), &quot;Loop expects the argument at index&quot;, i, &quot; to be a subtype of &quot;, inlineSignature-&gt;argument(i), &quot; but argument has type &quot;, m_expressionStack[i].type());</span>
<span class="line-added">+ </span>
<span class="line-added">+         int64_t oldSize = m_expressionStack.size();</span>
<span class="line-added">+         Stack newStack;</span>
<span class="line-added">+         ControlType control;</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addIf(condition, inlineSignature, m_expressionStack, control, newStack));</span>
<span class="line-added">+         ASSERT_UNUSED(oldSize, oldSize - m_expressionStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added">+         ASSERT(newStack.size() == inlineSignature-&gt;argumentCount());</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_controlStack.append({ WTFMove(m_expressionStack), newStack, WTFMove(control) });</span>
<span class="line-added">+         m_expressionStack = WTFMove(newStack);</span>
          return { };
      }
  
      case Else: {
          WASM_PARSER_FAIL_IF(m_controlStack.size() == 1, &quot;can&#39;t use else block at the top-level of a function&quot;);
<span class="line-modified">! </span>
<span class="line-modified">!         ControlEntry&amp; controlEntry = m_controlStack.last();</span>
<span class="line-added">+ </span>
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(controlEntry.controlData), &quot;else block isn&#39;t associated to an if&quot;);</span>
<span class="line-added">+         WASM_FAIL_IF_HELPER_FAILS(unify(controlEntry.controlData));</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addElse(controlEntry.controlData, m_expressionStack));</span>
<span class="line-added">+         m_expressionStack = WTFMove(controlEntry.elseBlockStack);</span>
          return { };
      }
  
      case Br:
      case BrIf: {
          uint32_t target;
<span class="line-modified">!         TypedExpression condition;</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get br / br_if&#39;s target&quot;);
          WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br / br_if&#39;s target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
<span class="line-modified">!         if (m_currentOpcode == BrIf) {</span>
              WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br / br_if condition&quot;);
<span class="line-modified">!             WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;conditional branch with non-i32 condition &quot;, condition.type());</span>
<span class="line-added">+         } else {</span>
              m_unreachableBlocks = 1;
<span class="line-added">+             condition = TypedExpression { Void, Context::emptyExpression() };</span>
<span class="line-added">+         }</span>
  
          ControlType&amp; data = m_controlStack[m_controlStack.size() - 1 - target].controlData;
<span class="line-modified">!         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(data));</span>
          WASM_TRY_ADD_TO_CONTEXT(addBranch(data, condition, m_expressionStack));
          return { };
      }
  
      case BrTable: {
          uint32_t numberOfTargets;
<span class="line-modified">!         uint32_t defaultTargetIndex;</span>
<span class="line-modified">!         TypedExpression condition;</span>
          Vector&lt;ControlType*&gt; targets;
  
          WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfTargets), &quot;can&#39;t get the number of targets for br_table&quot;);
          WASM_PARSER_FAIL_IF(numberOfTargets == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;br_table&#39;s number of targets is too big &quot;, numberOfTargets);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,38 ***</span>
              WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get &quot;, i, &quot;th target for br_table&quot;);
              WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br_table&#39;s &quot;, i, &quot;th target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
              targets.uncheckedAppend(&amp;m_controlStack[m_controlStack.size() - 1 - target].controlData);
          }
  
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseVarUInt32(defaultTarget), &quot;can&#39;t get default target for br_table&quot;);</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(defaultTarget &gt;= m_controlStack.size(), &quot;br_table&#39;s default target &quot;, defaultTarget, &quot; exceeds control stack size &quot;, m_controlStack.size());</span>
  
          WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br_table condition&quot;);
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(addSwitch(condition, targets, m_controlStack[m_controlStack.size() - 1 - defaultTarget].controlData, m_expressionStack));</span>
  
          m_unreachableBlocks = 1;
          return { };
      }
  
      case Return: {
<span class="line-modified">!         ExpressionList returnValues;</span>
<span class="line-modified">!         if (m_signature.returnType() != Void) {</span>
<span class="line-removed">-             ExpressionType returnValue;</span>
<span class="line-removed">-             WASM_TRY_POP_EXPRESSION_STACK_INTO(returnValue, &quot;return&quot;);</span>
<span class="line-removed">-             returnValues.append(returnValue);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         WASM_TRY_ADD_TO_CONTEXT(addReturn(m_controlStack[0].controlData, returnValues));</span>
          m_unreachableBlocks = 1;
          return { };
      }
  
      case End: {
          ControlEntry data = m_controlStack.takeLast();
          // FIXME: This is a little weird in that it will modify the expressionStack for the result of the block.
          // That&#39;s a little too effectful for me but I don&#39;t have a better API right now.
          // see: https://bugs.webkit.org/show_bug.cgi?id=164353
          WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
          m_expressionStack.swap(data.enclosedExpressionStack);
          return { };
      }
  
<span class="line-new-header">--- 771,49 ---</span>
              WASM_PARSER_FAIL_IF(!parseVarUInt32(target), &quot;can&#39;t get &quot;, i, &quot;th target for br_table&quot;);
              WASM_PARSER_FAIL_IF(target &gt;= m_controlStack.size(), &quot;br_table&#39;s &quot;, i, &quot;th target &quot;, target, &quot; exceeds control stack size &quot;, m_controlStack.size());
              targets.uncheckedAppend(&amp;m_controlStack[m_controlStack.size() - 1 - target].controlData);
          }
  
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseVarUInt32(defaultTargetIndex), &quot;can&#39;t get default target for br_table&quot;);</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(defaultTargetIndex &gt;= m_controlStack.size(), &quot;br_table&#39;s default target &quot;, defaultTargetIndex, &quot; exceeds control stack size &quot;, m_controlStack.size());</span>
<span class="line-added">+         ControlType&amp; defaultTarget = m_controlStack[m_controlStack.size() - 1 - defaultTargetIndex].controlData;</span>
  
          WASM_TRY_POP_EXPRESSION_STACK_INTO(condition, &quot;br_table condition&quot;);
<span class="line-modified">!         WASM_VALIDATOR_FAIL_IF(condition.type() != I32, &quot;br_table with non-i32 condition &quot;, condition.type());</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (unsigned i = 0; i &lt; targets.size(); ++i) {</span>
<span class="line-added">+             ControlType* target = targets[i];</span>
<span class="line-added">+             WASM_VALIDATOR_FAIL_IF(defaultTarget.branchTargetArity() != target-&gt;branchTargetArity(), &quot;br_table target type size mismatch. Default has size: &quot;, defaultTarget.branchTargetArity(), &quot;but target: &quot;, i, &quot; has size: &quot;, target-&gt;branchTargetArity());</span>
<span class="line-added">+             for (unsigned type = 0; type &lt; defaultTarget.branchTargetArity(); ++type)</span>
<span class="line-added">+                 WASM_VALIDATOR_FAIL_IF(!isSubtype(defaultTarget.branchTargetType(type), target-&gt;branchTargetType(type)), &quot;br_table target type mismatch at offset &quot;, type, &quot; expected: &quot;, defaultTarget.branchTargetType(type), &quot; but saw: &quot;, target-&gt;branchTargetType(type), &quot; when targeting block: &quot;, target-&gt;signature()-&gt;toString());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(defaultTarget));</span>
<span class="line-added">+         WASM_TRY_ADD_TO_CONTEXT(addSwitch(condition, targets, defaultTarget, m_expressionStack));</span>
  
          m_unreachableBlocks = 1;
          return { };
      }
  
      case Return: {
<span class="line-modified">!         WASM_FAIL_IF_HELPER_FAILS(checkBranchTarget(m_controlStack[0].controlData));</span>
<span class="line-modified">!         WASM_TRY_ADD_TO_CONTEXT(addReturn(m_controlStack[0].controlData, m_expressionStack));</span>
          m_unreachableBlocks = 1;
          return { };
      }
  
      case End: {
          ControlEntry data = m_controlStack.takeLast();
<span class="line-added">+         if (ControlType::isIf(data.controlData)) {</span>
<span class="line-added">+             WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
<span class="line-added">+             WASM_TRY_ADD_TO_CONTEXT(addElse(data.controlData, m_expressionStack));</span>
<span class="line-added">+             m_expressionStack = WTFMove(data.elseBlockStack);</span>
<span class="line-added">+         }</span>
          // FIXME: This is a little weird in that it will modify the expressionStack for the result of the block.
          // That&#39;s a little too effectful for me but I don&#39;t have a better API right now.
          // see: https://bugs.webkit.org/show_bug.cgi?id=164353
<span class="line-added">+         WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
          WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));
          m_expressionStack.swap(data.enclosedExpressionStack);
          return { };
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 579,12 ***</span>
          return { };
      }
  
      case Drop: {
          WASM_PARSER_FAIL_IF(!m_expressionStack.size(), &quot;can&#39;t drop on empty stack&quot;);
<span class="line-modified">!         auto expression = m_expressionStack.takeLast();</span>
<span class="line-modified">!         m_toKillAfterExpression.append(expression);</span>
          return { };
      }
  
      case Nop: {
          return { };
<span class="line-new-header">--- 823,12 ---</span>
          return { };
      }
  
      case Drop: {
          WASM_PARSER_FAIL_IF(!m_expressionStack.size(), &quot;can&#39;t drop on empty stack&quot;);
<span class="line-modified">!         m_expressionStack.takeLast();</span>
<span class="line-modified">!         m_context.didPopValueFromStack();</span>
          return { };
      }
  
      case Nop: {
          return { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 595,16 ***</span>
  
          uint8_t reserved;
          WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory&quot;);
          WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for grow_memory must be zero&quot;);
  
<span class="line-modified">!         ExpressionType delta;</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;expect an i32 argument to grow_memory on the stack&quot;);
  
          ExpressionType result;
          WASM_TRY_ADD_TO_CONTEXT(addGrowMemory(delta, result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
  
          return { };
      }
  
      case CurrentMemory: {
<span class="line-new-header">--- 839,17 ---</span>
  
          uint8_t reserved;
          WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for grow_memory&quot;);
          WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for grow_memory must be zero&quot;);
  
<span class="line-modified">!         TypedExpression delta;</span>
          WASM_TRY_POP_EXPRESSION_STACK_INTO(delta, &quot;expect an i32 argument to grow_memory on the stack&quot;);
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(delta.type() != I32, &quot;grow_memory with non-i32 delta argument has type: &quot;, delta.type());</span>
  
          ExpressionType result;
          WASM_TRY_ADD_TO_CONTEXT(addGrowMemory(delta, result));
<span class="line-modified">!         m_expressionStack.constructAndAppend(I32, result);</span>
  
          return { };
      }
  
      case CurrentMemory: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 614,11 ***</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for current_memory&quot;);
          WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for current_memory must be zero&quot;);
  
          ExpressionType result;
          WASM_TRY_ADD_TO_CONTEXT(addCurrentMemory(result));
<span class="line-modified">!         m_expressionStack.append(result);</span>
  
          return { };
      }
      }
  
<span class="line-new-header">--- 859,11 ---</span>
          WASM_PARSER_FAIL_IF(!parseVarUInt1(reserved), &quot;can&#39;t parse reserved varUint1 for current_memory&quot;);
          WASM_PARSER_FAIL_IF(reserved != 0, &quot;reserved varUint1 for current_memory must be zero&quot;);
  
          ExpressionType result;
          WASM_TRY_ADD_TO_CONTEXT(addCurrentMemory(result));
<span class="line-modified">!         m_expressionStack.constructAndAppend(I32, result);</span>
  
          return { };
      }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 629,39 ***</span>
  // FIXME: We should try to use the same decoder function for both unreachable and reachable code. https://bugs.webkit.org/show_bug.cgi?id=165965
  template&lt;typename Context&gt;
  auto FunctionParser&lt;Context&gt;::parseUnreachableExpression() -&gt; PartialResult
  {
      ASSERT(m_unreachableBlocks);
<span class="line-modified">! #define CREATE_CASE(name, id, b3op, inc) case OpType::name:</span>
      switch (m_currentOpcode) {
      case Else: {
          if (m_unreachableBlocks &gt; 1)
              return { };
  
          ControlEntry&amp; data = m_controlStack.last();
          m_unreachableBlocks = 0;
          WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
<span class="line-modified">!         m_expressionStack.shrink(0);</span>
          return { };
      }
  
      case End: {
          if (m_unreachableBlocks == 1) {
              ControlEntry data = m_controlStack.takeLast();
<span class="line-modified">!             WASM_TRY_ADD_TO_CONTEXT(addEndToUnreachable(data));</span>
              m_expressionStack.swap(data.enclosedExpressionStack);
          }
          m_unreachableBlocks--;
          return { };
      }
  
      case Loop:
      case If:
      case Block: {
          m_unreachableBlocks++;
<span class="line-modified">!         Type unused;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseResultType(unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);</span>
          return { };
      }
  
      case BrTable: {
          uint32_t numberOfTargets;
<span class="line-new-header">--- 874,47 ---</span>
  // FIXME: We should try to use the same decoder function for both unreachable and reachable code. https://bugs.webkit.org/show_bug.cgi?id=165965
  template&lt;typename Context&gt;
  auto FunctionParser&lt;Context&gt;::parseUnreachableExpression() -&gt; PartialResult
  {
      ASSERT(m_unreachableBlocks);
<span class="line-modified">! #define CREATE_CASE(name, ...) case OpType::name:</span>
      switch (m_currentOpcode) {
      case Else: {
          if (m_unreachableBlocks &gt; 1)
              return { };
  
          ControlEntry&amp; data = m_controlStack.last();
          m_unreachableBlocks = 0;
<span class="line-added">+         WASM_VALIDATOR_FAIL_IF(!ControlType::isIf(data.controlData), &quot;else block isn&#39;t associated to an if&quot;);</span>
          WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));
<span class="line-modified">!         m_expressionStack = WTFMove(data.elseBlockStack);</span>
          return { };
      }
  
      case End: {
          if (m_unreachableBlocks == 1) {
              ControlEntry data = m_controlStack.takeLast();
<span class="line-modified">!             if (ControlType::isIf(data.controlData)) {</span>
<span class="line-added">+                 WASM_TRY_ADD_TO_CONTEXT(addElseToUnreachable(data.controlData));</span>
<span class="line-added">+                 m_expressionStack = WTFMove(data.elseBlockStack);</span>
<span class="line-added">+                 WASM_FAIL_IF_HELPER_FAILS(unify(data.controlData));</span>
<span class="line-added">+                 WASM_TRY_ADD_TO_CONTEXT(endBlock(data, m_expressionStack));</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 WASM_TRY_ADD_TO_CONTEXT(addEndToUnreachable(data));</span>
<span class="line-added">+ </span>
              m_expressionStack.swap(data.enclosedExpressionStack);
          }
          m_unreachableBlocks--;
          return { };
      }
  
      case Loop:
      case If:
      case Block: {
          m_unreachableBlocks++;
<span class="line-modified">!         BlockSignature unused;</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!parseBlockSignature(m_info, unused), &quot;can&#39;t get inline type for &quot;, m_currentOpcode, &quot; in unreachable context&quot;);</span>
          return { };
      }
  
      case BrTable: {
          uint32_t numberOfTargets;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 773,6 ***</span>
<span class="line-new-header">--- 1026,10 ---</span>
      RELEASE_ASSERT_NOT_REACHED();
  }
  
  } } // namespace JSC::Wasm
  
<span class="line-added">+ #undef WASM_TRY_POP_EXPRESSION_STACK_INTO</span>
<span class="line-added">+ #undef WASM_TRY_ADD_TO_CONTEXT</span>
<span class="line-added">+ #undef WASM_VALIDATOR_FAIL_IF</span>
<span class="line-added">+ </span>
  #endif // ENABLE(WEBASSEMBLY)
</pre>
<center><a href="WasmFormat.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmInstance.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
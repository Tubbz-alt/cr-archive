<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/LineLayoutContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LineLayoutContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;InlineFormattingContext.h&quot;
 32 #include &quot;LayoutBox.h&quot;
 33 #include &quot;TextUtil.h&quot;
 34 
 35 namespace WebCore {
 36 namespace Layout {
 37 
 38 static inline bool endsWithSoftWrapOpportunity(const InlineTextItem&amp; currentTextItem, const InlineTextItem&amp; nextInlineTextItem)
 39 {
 40     ASSERT(!nextInlineTextItem.isWhitespace());
 41     // We are at the position after a whitespace.
 42     if (currentTextItem.isWhitespace())
 43         return true;
 44     // When both these non-whitespace runs belong to the same layout box, it&#39;s guaranteed that
 45     // they are split at a soft breaking opportunity. See InlineTextItem::moveToNextBreakablePosition.
 46     if (&amp;currentTextItem.layoutBox() == &amp;nextInlineTextItem.layoutBox())
 47         return true;
 48     // Now we need to collect at least 3 adjacent characters to be able to make a decision whether the previous text item ends with breaking opportunity.
 49     // [ex-][ample] &lt;- second to last[x] last[-] current[a]
 50     // We need at least 1 character in the current inline text item and 2 more from previous inline items.
 51     auto previousContent = currentTextItem.layoutBox().textContext()-&gt;content;
 52     auto lineBreakIterator = LazyLineBreakIterator { nextInlineTextItem.layoutBox().textContext()-&gt;content };
 53     auto previousContentLength = previousContent.length();
 54     // FIXME: We should look into the entire uncommitted content for more text context.
 55     UChar lastCharacter = previousContentLength ? previousContent[previousContentLength - 1] : 0;
 56     UChar secondToLastCharacter = previousContentLength &gt; 1 ? previousContent[previousContentLength - 2] : 0;
 57     lineBreakIterator.setPriorContext(lastCharacter, secondToLastCharacter);
 58     // Now check if we can break right at the inline item boundary.
 59     // With the [ex-ample], findNextBreakablePosition should return the startPosition (0).
 60     // FIXME: Check if there&#39;s a more correct way of finding breaking opportunities.
 61     return !TextUtil::findNextBreakablePosition(lineBreakIterator, 0, nextInlineTextItem.style());
 62 }
 63 
 64 static inline bool isAtSoftWrapOpportunity(const InlineItem&amp; current, const InlineItem&amp; next)
 65 {
 66     // &quot;is at&quot; simple means that there&#39;s a soft wrap opportunity right after the [current].
 67     // [text][ ][text][container start]... (&lt;div&gt;text content&lt;span&gt;..&lt;/div&gt;)
 68     // soft wrap indexes: 0 and 1 definitely, 2 depends on the content after the [container start].
 69 
 70     // https://drafts.csswg.org/css-text-3/#line-break-details
 71     // Figure out if the new incoming content puts the uncommitted content on a soft wrap opportunity.
 72     // e.g. [container start][prior_continuous_content][container end] (&lt;span&gt;prior_continuous_content&lt;/span&gt;)
 73     // An incoming &lt;img&gt; box would enable us to commit the &quot;&lt;span&gt;prior_continuous_content&lt;/span&gt;&quot; content
 74     // but an incoming text content would not necessarily.
 75     ASSERT(current.isText() || current.isBox());
 76     ASSERT(next.isText() || next.isBox());
 77     if (current.isText() &amp;&amp; next.isText()) {
 78         auto&amp; currentInlineTextItem = downcast&lt;InlineTextItem&gt;(current);
 79         auto&amp; nextInlineTextItem = downcast&lt;InlineTextItem&gt;(next);
 80         if (currentInlineTextItem.isWhitespace()) {
 81             // [ ][text] : after [whitespace] position is a soft wrap opportunity.
 82             return true;
 83         }
 84         if (nextInlineTextItem.isWhitespace()) {
 85             // [text][ ] (&lt;span&gt;text&lt;/span&gt; )
 86             // white-space: break-spaces: line breaking opportunity exists after every preserved white space character, but not before.
 87             return nextInlineTextItem.style().whiteSpace() != WhiteSpace::BreakSpaces;
 88         }
 89         if (current.style().lineBreak() == LineBreak::Anywhere || next.style().lineBreak() == LineBreak::Anywhere) {
 90             // There is a soft wrap opportunity around every typographic character unit, including around any punctuation character
 91             // or preserved white spaces, or in the middle of words.
 92             return true;
 93         }
 94         // Both current and next items are non-whitespace text.
 95         // [text][text] : is a continuous content.
 96         // [text-][text] : after [hyphen] position is a soft wrap opportunity.
 97         return endsWithSoftWrapOpportunity(currentInlineTextItem, nextInlineTextItem);
 98     }
 99     if (current.isBox() || next.isBox()) {
100         // [text][container start][container end][inline box] (text&lt;span&gt;&lt;/span&gt;&lt;img&gt;) : there&#39;s a soft wrap opportunity between the [text] and [img].
101         // The line breaking behavior of a replaced element or other atomic inline is equivalent to an ideographic character.
102         return true;
103     }
104     ASSERT_NOT_REACHED();
105     return true;
106 }
107 
108 static inline size_t nextWrapOpportunity(const InlineItems&amp; inlineContent, size_t startIndex, const LineLayoutContext::InlineItemRange layoutRange)
109 {
110     // 1. Find the start candidate by skipping leading non-content items e.g &lt;span&gt;&lt;span&gt;start : skip &quot;&lt;span&gt;&lt;span&gt;&quot;
111     // 2. Find the end candidate by skipping non-content items inbetween e.g. &lt;span&gt;&lt;span&gt;start&lt;/span&gt;end: skip &quot;&lt;/span&gt;&quot;
112     // 3. Check if there&#39;s a soft wrap opportunity between the 2 candidate inline items and repeat.
113     // 4. Any force line break inbetween is considered as a wrap opportunity.
114 
115     // [ex-][container start][container end][float][ample] (ex-&lt;span&gt;&lt;/span&gt;&lt;div style=&quot;float:left&quot;&gt;&lt;/div&gt;ample) : wrap index is at [ex-].
116     // [ex][container start][amp-][container start][le] (ex&lt;span&gt;amp-&lt;span&gt;ample) : wrap index is at [amp-].
117     // [ex-][container start][line break][ample] (ex-&lt;span&gt;&lt;br&gt;ample) : wrap index is after [br].
118     auto isAtLineBreak = false;
119 
120     auto inlineItemIndexWithContent = [&amp;] (auto index) {
121         // Break at the first text/box/line break inline item.
122         for (; index &lt; layoutRange.end; ++index) {
123             auto&amp; inlineItem = inlineContent[index];
124             if (inlineItem.isText() || inlineItem.isBox())
125                 return index;
126             if (inlineItem.isLineBreak()) {
127                 isAtLineBreak = true;
128                 return index;
129             }
130         }
131         return layoutRange.end;
132     };
133 
134     // Start at the first inline item with content.
135     // [container start][ex-] : start at [ex-]
136     auto startContentIndex = inlineItemIndexWithContent(startIndex);
137     if (isAtLineBreak) {
138         // Content starts with a line break. The wrap position is after the line break.
139         return startContentIndex + 1;
140     }
141 
142     while (startContentIndex &lt; layoutRange.end) {
143         // 1. Find the next inline item with content.
144         // 2. Check if there&#39;s a soft wrap opportunity between the start and the next inline item.
145         auto nextContentIndex = inlineItemIndexWithContent(startContentIndex + 1);
146         if (nextContentIndex == layoutRange.end)
147             return nextContentIndex;
148         if (isAtLineBreak) {
149             // We always stop at line breaks. The wrap position is after the line break.
150             return nextContentIndex + 1;
151         }
152         if (isAtSoftWrapOpportunity(inlineContent[startContentIndex], inlineContent[nextContentIndex])) {
153             // There&#39;s a soft wrap opportunity between the start and the nextContent.
154             // Now forward-find from the start position to see where we can actually wrap.
155             // [ex-][ample] vs. [ex-][container start][container end][ample]
156             // where [ex-] is startContent and [ample] is the nextContent.
157             for (auto candidateIndex = startContentIndex + 1; candidateIndex &lt; nextContentIndex; ++candidateIndex) {
158                 if (inlineContent[candidateIndex].isContainerStart()) {
159                     // inline content and [container start] and [container end] form unbreakable content.
160                     // ex-&lt;span&gt;&lt;/span&gt;ample  : wrap opportunity is after &quot;ex-&quot;.
161                     // ex-&lt;/span&gt;&lt;/span&gt;ample : wrap opportunity is after &quot;ex-&lt;/span&gt;&lt;/span&gt;&quot;.
162                     // ex-&lt;/span&gt;&lt;span&gt;ample&lt;/span&gt; : wrap opportunity is after &quot;ex-&lt;/span&gt;&quot;.
163                     // ex-&lt;span&gt;&lt;span&gt;ample&lt;/span&gt;&lt;/span&gt; : wrap opportunity is after &quot;ex-&quot;.
164                     return candidateIndex;
165                 }
166             }
167             return nextContentIndex;
168         }
169         startContentIndex = nextContentIndex;
170     }
171     return layoutRange.end;
172 }
173 
174 struct LineCandidateContent {
175     void appendInlineContent(const InlineItem&amp;, InlineLayoutUnit logicalWidth);
176     void appendLineBreak(const InlineItem&amp; inlineItem) { setTrailingLineBreak(inlineItem); }
177     void appendFloat(const InlineItem&amp; inlineItem) { m_floats.append(&amp;inlineItem); }
178 
179     bool hasIntrusiveFloats() const { return !m_floats.isEmpty(); }
180     const LineBreaker::RunList&amp; inlineRuns() const { return m_inlineRuns; }
181     InlineLayoutUnit inlineContentLogicalWidth() const { return m_inlineContentLogicalWidth; }
182     const LineLayoutContext::FloatList&amp; floats() const { return m_floats; }
183 
184     const InlineItem* trailingLineBreak() const { return m_trailingLineBreak; }
185 
186     void reset();
187 
188 private:
189     void setTrailingLineBreak(const InlineItem&amp; lineBreakItem) { m_trailingLineBreak = &amp;lineBreakItem; }
190 
191     InlineLayoutUnit m_inlineContentLogicalWidth { 0 };
192     LineBreaker::RunList m_inlineRuns;
193     LineLayoutContext::FloatList m_floats;
194     const InlineItem* m_trailingLineBreak { nullptr };
195 };
196 
197 inline void LineCandidateContent::appendInlineContent(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
198 {
199     m_inlineContentLogicalWidth += logicalWidth;
200     m_inlineRuns.append({ inlineItem, logicalWidth });
201 }
202 
203 inline void LineCandidateContent::reset()
204 {
205     m_inlineContentLogicalWidth = 0;
206     m_inlineRuns.clear();
207     m_floats.clear();
208     m_trailingLineBreak = nullptr;
209 }
210 
211 InlineLayoutUnit LineLayoutContext::inlineItemWidth(const InlineItem&amp; inlineItem, InlineLayoutUnit contentLogicalLeft) const
212 {
213     if (is&lt;InlineTextItem&gt;(inlineItem)) {
214         auto&amp; inlineTextItem = downcast&lt;InlineTextItem&gt;(inlineItem);
215         if (auto contentWidth = inlineTextItem.width())
216             return *contentWidth;
217         auto end = inlineTextItem.isCollapsible() ? inlineTextItem.start() + 1 : inlineTextItem.end();
218         return TextUtil::width(inlineTextItem, inlineTextItem.start(), end, contentLogicalLeft);
219     }
220 
221     if (inlineItem.isLineBreak())
222         return 0;
223 
224     auto&amp; layoutBox = inlineItem.layoutBox();
225     auto&amp; boxGeometry = m_inlineFormattingContext.geometryForBox(layoutBox);
226 
227     if (layoutBox.isFloatingPositioned())
228         return boxGeometry.marginBoxWidth();
229 
230     if (layoutBox.replaced())
231         return boxGeometry.width();
232 
233     if (inlineItem.isContainerStart())
234         return boxGeometry.marginStart() + boxGeometry.borderLeft() + boxGeometry.paddingLeft().valueOr(0);
235 
236     if (inlineItem.isContainerEnd())
237         return boxGeometry.marginEnd() + boxGeometry.borderRight() + boxGeometry.paddingRight().valueOr(0);
238 
239     // Non-replaced inline box (e.g. inline-block)
240     return boxGeometry.width();
241 }
242 
243 static inline bool isLineConsideredEmpty(const LineBuilder&amp; line)
244 {
245     return line.isVisuallyEmpty() &amp;&amp; !line.hasIntrusiveFloat();
246 }
247 
248 LineLayoutContext::LineLayoutContext(const InlineFormattingContext&amp; inlineFormattingContext, const Container&amp; formattingContextRoot, const InlineItems&amp; inlineItems)
249     : m_inlineFormattingContext(inlineFormattingContext)
250     , m_formattingContextRoot(formattingContextRoot)
251     , m_inlineItems(inlineItems)
252 {
253 }
254 
255 LineLayoutContext::LineContent LineLayoutContext::layoutLine(LineBuilder&amp; line, const InlineItemRange layoutRange, Optional&lt;unsigned&gt; partialLeadingContentLength)
256 {
257     auto reset = [&amp;] {
258         ASSERT(m_floats.isEmpty());
259         m_partialTrailingTextItem = { };
260         m_partialLeadingTextItem = { };
261     };
262     reset();
263     auto lineBreaker = LineBreaker { };
264     auto currentItemIndex = layoutRange.start;
265     unsigned committedInlineItemCount = 0;
266     auto candidateContent = LineCandidateContent { };
267     while (currentItemIndex &lt; layoutRange.end) {
268         // 1. Collect the set of runs that we can commit to the line as one entity e.g. &lt;span&gt;text_and_span_start_span_end&lt;/span&gt;.
269         // 2. Apply floats and shrink the available horizontal space e.g. &lt;span&gt;intru_&lt;div style=&quot;float: left&quot;&gt;&lt;/div&gt;sive_float&lt;/span&gt;.
270         // 3. Check if the content fits the line and commit the content accordingly (full, partial or not commit at all).
271         // 4. Return if we are at the end of the line either by not being able to fit more content or because of an explicit line break.
272         nextContentForLine(candidateContent, currentItemIndex, layoutRange, partialLeadingContentLength, line.lineBox().logicalWidth());
273         if (candidateContent.hasIntrusiveFloats()) {
274             // Add floats first because they shrink the available horizontal space for the rest of the content.
275             auto result = tryAddingFloatItems(line, candidateContent.floats());
276             committedInlineItemCount += result.committedCount;
277             if (result.isEndOfLine == LineBreaker::IsEndOfLine::Yes) {
278                 // Floats take up all the horizontal space.
279                 return close(line, layoutRange, committedInlineItemCount, { });
280             }
281         }
282         if (!candidateContent.inlineRuns().isEmpty()) {
283             // Now check if we can put this content on the current line.
284             auto result = tryAddingInlineItems(lineBreaker, line, candidateContent);
285             if (result.revertTo) {
286                 ASSERT(!result.committedCount);
287                 ASSERT(result.isEndOfLine == LineBreaker::IsEndOfLine::Yes);
288                 // An earlier line wrapping opportunity turned out to be the final breaking position.
289                 rebuildLineForRevert(line, *result.revertTo, layoutRange);
290             }
291             committedInlineItemCount += result.committedCount;
292             if (result.isEndOfLine == LineBreaker::IsEndOfLine::Yes) {
293                 // We can&#39;t place any more items on the current line.
294                 return close(line, layoutRange, committedInlineItemCount, result.partialContent);
295             }
296         } else if (auto* trailingLineBreak = candidateContent.trailingLineBreak()) {
297             line.append(*trailingLineBreak, 0);
298             return close(line, layoutRange, ++committedInlineItemCount, { });
299         }
300         currentItemIndex = layoutRange.start + committedInlineItemCount;
301         partialLeadingContentLength = { };
302     }
303     // Looks like we&#39;ve run out of runs.
304     return close(line, layoutRange, committedInlineItemCount, { });
305 }
306 
307 LineLayoutContext::LineContent LineLayoutContext::close(LineBuilder&amp; line, const InlineItemRange layoutRange, unsigned committedInlineItemCount, Optional&lt;LineContent::PartialContent&gt; partialContent)
308 {
309     ASSERT(committedInlineItemCount || line.hasIntrusiveFloat());
310     if (!committedInlineItemCount)
311         return LineContent { { }, { }, WTFMove(m_floats), line.close(), line.lineBox() };
312 
313     // Adjust hyphenated line count.
314     if (partialContent &amp;&amp; partialContent-&gt;trailingContentNeedsHyphen)
315         ++m_successiveHyphenatedLineCount;
316     else
317         m_successiveHyphenatedLineCount = 0;
318 
319     unsigned trailingInlineItemIndex = layoutRange.start + committedInlineItemCount - 1;
320     ASSERT(trailingInlineItemIndex &lt; layoutRange.end);
321     auto isLastLineWithInlineContent = [&amp;] {
322         if (trailingInlineItemIndex == layoutRange.end - 1)
323             return LineBuilder::IsLastLineWithInlineContent::Yes;
324         if (partialContent)
325             return LineBuilder::IsLastLineWithInlineContent::No;
326         // Omit floats to see if this is the last line with inline content.
327         for (auto i = layoutRange.end; i--;) {
328             if (!m_inlineItems[i].isFloat())
329                 return i == trailingInlineItemIndex ? LineBuilder::IsLastLineWithInlineContent::Yes : LineBuilder::IsLastLineWithInlineContent::No;
330         }
331         // There has to be at least one non-float item.
332         ASSERT_NOT_REACHED();
333         return LineBuilder::IsLastLineWithInlineContent::No;
334     }();
335     return LineContent { trailingInlineItemIndex, partialContent, WTFMove(m_floats), line.close(isLastLineWithInlineContent), line.lineBox() };
336 }
337 
338 void LineLayoutContext::nextContentForLine(LineCandidateContent&amp; candidateContent, unsigned currentInlineItemIndex, const InlineItemRange layoutRange, Optional&lt;unsigned&gt; partialLeadingContentLength, InlineLayoutUnit currentLogicalRight)
339 {
340     ASSERT(currentInlineItemIndex &lt; layoutRange.end);
341     candidateContent.reset();
342     // 1. Simply add any overflow content from the previous line to the candidate content. It&#39;s always a text content.
343     // 2. Find the next soft wrap position or explicit line break.
344     // 3. Collect floats between the inline content.
345     auto softWrapOpportunityIndex = nextWrapOpportunity(m_inlineItems, currentInlineItemIndex, layoutRange);
346     // softWrapOpportunityIndex == layoutRange.end means we don&#39;t have any wrap opportunity in this content.
347     ASSERT(softWrapOpportunityIndex &lt;= layoutRange.end);
348 
349     if (partialLeadingContentLength) {
350         // Handle leading partial content first (split text from the previous line).
351         // Construct a partial leading inline item.
352         m_partialLeadingTextItem = downcast&lt;InlineTextItem&gt;(m_inlineItems[currentInlineItemIndex]).right(*partialLeadingContentLength);
353         auto itemWidth = inlineItemWidth(*m_partialLeadingTextItem, currentLogicalRight);
354         candidateContent.appendInlineContent(*m_partialLeadingTextItem, itemWidth);
355         currentLogicalRight += itemWidth;
356         ++currentInlineItemIndex;
357     }
358 
359     for (auto index = currentInlineItemIndex; index &lt; softWrapOpportunityIndex; ++index) {
360         auto&amp; inlineItem = m_inlineItems[index];
361         if (inlineItem.isText() || inlineItem.isContainerStart() || inlineItem.isContainerEnd()) {
362             auto inlineItenmWidth = inlineItemWidth(inlineItem, currentLogicalRight);
363             candidateContent.appendInlineContent(inlineItem, inlineItenmWidth);
364             currentLogicalRight += inlineItenmWidth;
365             continue;
366         }
367         if (inlineItem.isFloat()) {
368             // Floats are not part of the line context.
369             // FIXME: Check if their width should be added to currentLogicalRight.
370             candidateContent.appendFloat(inlineItem);
371             continue;
372         }
373         if (inlineItem.isLineBreak()) {
374             candidateContent.appendLineBreak(inlineItem);
375             continue;
376         }
377         ASSERT_NOT_REACHED();
378     }
379 }
380 
381 LineLayoutContext::Result LineLayoutContext::tryAddingFloatItems(LineBuilder&amp; line, const FloatList&amp; floats)
382 {
383     size_t committedFloatItemCount = 0;
384     for (auto&amp; floatItem : floats) {
385         auto logicalWidth = inlineItemWidth(*floatItem, { });
386 
387         auto lineIsConsideredEmpty = line.isVisuallyEmpty() &amp;&amp; !line.hasIntrusiveFloat();
388         if (LineBreaker().shouldWrapFloatBox(logicalWidth, line.availableWidth() + line.trimmableTrailingWidth(), lineIsConsideredEmpty))
389             return { LineBreaker::IsEndOfLine::Yes, committedFloatItemCount };
390         // This float can sit on the current line.
391         ++committedFloatItemCount;
392         auto&amp; floatBox = floatItem-&gt;layoutBox();
393         // Shrink available space for current line and move existing inline runs.
394         line.setHasIntrusiveFloat();
395         if (floatBox.isLeftFloatingPositioned())
396             line.moveLogicalLeft(logicalWidth);
397         else
398             line.moveLogicalRight(logicalWidth);
399         m_floats.append(floatItem);
400     }
401     return { LineBreaker::IsEndOfLine::No, committedFloatItemCount };
402 }
403 
404 LineLayoutContext::Result LineLayoutContext::tryAddingInlineItems(LineBreaker&amp; lineBreaker, LineBuilder&amp; line, const LineCandidateContent&amp; candidateContent)
405 {
406     auto shouldDisableHyphenation = [&amp;] {
407         auto&amp; style = root().style();
408         unsigned limitLines = style.hyphenationLimitLines() == RenderStyle::initialHyphenationLimitLines() ? std::numeric_limits&lt;unsigned&gt;::max() : style.hyphenationLimitLines();
409         return m_successiveHyphenatedLineCount &gt;= limitLines;
410     };
411     // Check if this new content fits.
412     auto lineStatus = LineBreaker::LineStatus { line.availableWidth(), line.trimmableTrailingWidth(), line.isTrailingRunFullyTrimmable(), isLineConsideredEmpty(line) };
413 
414     if (shouldDisableHyphenation())
415         lineBreaker.setHyphenationDisabled();
416 
417     auto&amp; candidateRuns = candidateContent.inlineRuns();
418     auto result = lineBreaker.shouldWrapInlineContent(candidateRuns, candidateContent.inlineContentLogicalWidth(), lineStatus);
419     if (result.action == LineBreaker::Result::Action::Keep) {
420         // This continuous content can be fully placed on the current line.
421         for (auto&amp; run : candidateRuns)
422             line.append(run.inlineItem, run.logicalWidth);
423         // Consume trailing line break as well.
424         if (auto* lineBreakItem = candidateContent.trailingLineBreak()) {
425             line.append(*lineBreakItem, 0);
426             return { LineBreaker::IsEndOfLine::Yes, candidateRuns.size() + 1 };
427         }
428         return { result.isEndOfLine, candidateRuns.size() };
429     }
430     if (result.action == LineBreaker::Result::Action::Push) {
431         // This continuous content can&#39;t be placed on the current line. Nothing to commit at this time.
432         return { result.isEndOfLine };
433     }
434     if (result.action == LineBreaker::Result::Action::Revert) {
435         // Not only this content can&#39;t be placed on the current line, but we even need to revert the line back to an earlier position.
436         return { result.isEndOfLine, 0, { }, result.revertTo };
437     }
438     if (result.action == LineBreaker::Result::Action::Split) {
439         // Commit the combination of full and partial content on the current line.
440         ASSERT(result.partialTrailingContent);
441         commitPartialContent(line, candidateRuns, *result.partialTrailingContent);
442         // When splitting multiple runs &lt;span style=&quot;word-break: break-all&quot;&gt;text&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;, we might end up splitting them at run boundary.
443         // It simply means we don&#39;t really have a partial run. Partial content yes, but not partial run.
444         auto trailingRunIndex = result.partialTrailingContent-&gt;trailingRunIndex;
445         auto committedInlineItemCount = trailingRunIndex + 1;
446         if (!result.partialTrailingContent-&gt;partialRun)
447             return { result.isEndOfLine, committedInlineItemCount };
448 
449         auto partialRun = *result.partialTrailingContent-&gt;partialRun;
450         auto&amp; trailingInlineTextItem = downcast&lt;InlineTextItem&gt;(candidateRuns[trailingRunIndex].inlineItem);
451         auto overflowLength = trailingInlineTextItem.length() - partialRun.length;
452         return { result.isEndOfLine, committedInlineItemCount, LineContent::PartialContent { partialRun.needsHyphen, overflowLength } };
453     }
454     ASSERT_NOT_REACHED();
455     return { LineBreaker::IsEndOfLine::No };
456 }
457 
458 void LineLayoutContext::commitPartialContent(LineBuilder&amp; line, const LineBreaker::RunList&amp; runs, const LineBreaker::Result::PartialTrailingContent&amp; partialTrailingContent)
459 {
460     for (size_t index = 0; index &lt; runs.size(); ++index) {
461         auto&amp; run = runs[index];
462         if (partialTrailingContent.trailingRunIndex == index) {
463             ASSERT(run.inlineItem.isText());
464             // Create and commit partial trailing item.
465             if (auto partialRun = partialTrailingContent.partialRun) {
466                 auto&amp; trailingInlineTextItem = downcast&lt;InlineTextItem&gt;(runs[partialTrailingContent.trailingRunIndex].inlineItem);
467                 // FIXME: LineBuilder should not hold on to the InlineItem.
468                 ASSERT(!m_partialTrailingTextItem);
469                 m_partialTrailingTextItem = trailingInlineTextItem.left(partialRun-&gt;length);
470                 line.append(*m_partialTrailingTextItem, partialRun-&gt;logicalWidth);
471                 return;
472             }
473             // The partial run is the last content to commit.
474             line.append(run.inlineItem, run.logicalWidth);
475             return;
476         }
477         line.append(run.inlineItem, run.logicalWidth);
478     }
479 }
480 
481 void LineLayoutContext::rebuildLineForRevert(LineBuilder&amp; line, const InlineItem&amp; revertTo, const InlineItemRange layoutRange)
482 {
483     // This is the rare case when the line needs to be reverted to an earlier position.
484     line.resetContent();
485     auto inlineItemIndex = layoutRange.start;
486     InlineLayoutUnit logicalRight = { };
487     if (m_partialLeadingTextItem) {
488         auto logicalWidth = inlineItemWidth(*m_partialLeadingTextItem, logicalRight);
489         line.append(*m_partialLeadingTextItem, logicalWidth);
490         logicalRight += logicalWidth;
491         if (&amp;revertTo == &amp;m_partialLeadingTextItem.value())
492             return;
493         ++inlineItemIndex;
494     }
495 
496     for (; inlineItemIndex &lt; layoutRange.end; ++inlineItemIndex) {
497         auto&amp; inlineItem = m_inlineItems[inlineItemIndex];
498         auto logicalWidth = inlineItemWidth(inlineItem, logicalRight);
499         line.append(inlineItem, logicalWidth);
500         logicalRight += logicalWidth;
501         if (&amp;inlineItem == &amp;revertTo)
502             break;
503     }
504 }
505 
506 }
507 }
508 
509 #endif
    </pre>
  </body>
</html>
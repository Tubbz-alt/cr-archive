<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/SharedBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006-2016 Apple Inc. All rights reserved.
  3  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  4  * Copyright (C) 2015 Canon Inc. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;SharedBuffer.h&quot;
 30 
 31 #include &lt;algorithm&gt;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &lt;wtf/HexNumber.h&gt;</span>
<span class="line-added"> 33 #include &lt;wtf/persistence/PersistentCoders.h&gt;</span>
<span class="line-added"> 34 #include &lt;wtf/text/StringBuilder.h&gt;</span>
 35 #include &lt;wtf/unicode/UTF8Conversion.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 SharedBuffer::SharedBuffer(const char* data, size_t size)
 40 {
 41     append(data, size);
 42 }
 43 
 44 SharedBuffer::SharedBuffer(const unsigned char* data, size_t size)
 45 {
 46     append(reinterpret_cast&lt;const char*&gt;(data), size);
 47 }
 48 
 49 SharedBuffer::SharedBuffer(FileSystem::MappedFileData&amp;&amp; fileData)
 50     : m_size(fileData.size())
 51 {
 52     m_segments.append({0, DataSegment::create(WTFMove(fileData))});
 53 }
 54 
 55 SharedBuffer::SharedBuffer(Vector&lt;char&gt;&amp;&amp; data)
 56 {
 57     append(WTFMove(data));
 58 }
 59 
 60 #if USE(GSTREAMER)
 61 Ref&lt;SharedBuffer&gt; SharedBuffer::create(GstMappedBuffer&amp; mappedBuffer)
 62 {
 63     ASSERT(mappedBuffer.isSharable());
 64     return adoptRef(*new SharedBuffer(mappedBuffer));
 65 }
 66 
 67 SharedBuffer::SharedBuffer(GstMappedBuffer&amp; mappedBuffer)
 68     : m_size(mappedBuffer.size())
 69 {
 70     m_segments.append({0, DataSegment::create(&amp;mappedBuffer)});
 71 }
 72 #endif
 73 
 74 RefPtr&lt;SharedBuffer&gt; SharedBuffer::createWithContentsOfFile(const String&amp; filePath)
 75 {
 76     bool mappingSuccess;
 77     FileSystem::MappedFileData mappedFileData(filePath, FileSystem::MappedFileMode::Shared, mappingSuccess);
 78 
 79     if (!mappingSuccess)
 80         return SharedBuffer::createFromReadingFile(filePath);
 81 
 82     return adoptRef(new SharedBuffer(WTFMove(mappedFileData)));
 83 }
 84 
 85 Ref&lt;SharedBuffer&gt; SharedBuffer::create(Vector&lt;char&gt;&amp;&amp; vector)
 86 {
 87     return adoptRef(*new SharedBuffer(WTFMove(vector)));
 88 }
 89 
 90 // FIXME: Move the whole class from Vector&lt;char&gt; to Vector&lt;uint8_t&gt; and make this efficient, replacing the Vector&lt;char&gt; version above.
 91 Ref&lt;SharedBuffer&gt; SharedBuffer::create(Vector&lt;uint8_t&gt;&amp;&amp; vector)
 92 {
 93     return adoptRef(*new SharedBuffer { vector.data(), vector.size() });
 94 }
 95 
 96 void SharedBuffer::combineIntoOneSegment() const
 97 {
<a name="2" id="anc2"></a><span class="line-modified"> 98 #if ASSERT_ENABLED</span>
 99     // FIXME: We ought to be able to set this to true and have no assertions fire.
100     // Remove all instances of appending after calling this, because they are all O(n^2) algorithms since r215686.
101     // m_hasBeenCombinedIntoOneSegment = true;
102 #endif
103     if (m_segments.size() &lt;= 1)
104         return;
105 
106     Vector&lt;char&gt; combinedData;
107     combinedData.reserveInitialCapacity(m_size);
108     for (const auto&amp; segment : m_segments)
109         combinedData.append(segment.segment-&gt;data(), segment.segment-&gt;size());
110     ASSERT(combinedData.size() == m_size);
111     m_segments.clear();
112     m_segments.append({0, DataSegment::create(WTFMove(combinedData))});
113     ASSERT(m_segments.size() == 1);
114     ASSERT(internallyConsistent());
115 }
116 
117 const char* SharedBuffer::data() const
118 {
119     if (!m_segments.size())
120         return nullptr;
121     combineIntoOneSegment();
122     ASSERT(internallyConsistent());
123     return m_segments[0].segment-&gt;data();
124 }
125 
126 SharedBufferDataView SharedBuffer::getSomeData(size_t position) const
127 {
128     RELEASE_ASSERT(position &lt; m_size);
129     auto comparator = [](const size_t&amp; position, const DataSegmentVectorEntry&amp; entry) {
130         return position &lt; entry.beginPosition;
131     };
132     const DataSegmentVectorEntry* element = std::upper_bound(m_segments.begin(), m_segments.end(), position, comparator);
133     element--; // std::upper_bound gives a pointer to the element that is greater than position. We want the element just before that.
134     return { element-&gt;segment.copyRef(), position - element-&gt;beginPosition };
135 }
136 
<a name="3" id="anc3"></a><span class="line-added">137 String SharedBuffer::toHexString() const</span>
<span class="line-added">138 {</span>
<span class="line-added">139     StringBuilder stringBuilder;</span>
<span class="line-added">140     for (unsigned byteOffset = 0; byteOffset &lt; size(); byteOffset++) {</span>
<span class="line-added">141         const uint8_t byte = data()[byteOffset];</span>
<span class="line-added">142         stringBuilder.append(pad(&#39;0&#39;, 2, hex(byte)));</span>
<span class="line-added">143     }</span>
<span class="line-added">144     return stringBuilder.toString();</span>
<span class="line-added">145 }</span>
<span class="line-added">146 </span>
147 RefPtr&lt;ArrayBuffer&gt; SharedBuffer::tryCreateArrayBuffer() const
148 {
149     auto arrayBuffer = ArrayBuffer::tryCreateUninitialized(static_cast&lt;unsigned&gt;(size()), sizeof(char));
150     if (!arrayBuffer) {
151         WTFLogAlways(&quot;SharedBuffer::tryCreateArrayBuffer Unable to create buffer. Requested size was %zu\n&quot;, size());
152         return nullptr;
153     }
154 
155     size_t position = 0;
156     for (const auto&amp; segment : m_segments) {
157         memcpy(static_cast&lt;char*&gt;(arrayBuffer-&gt;data()) + position, segment.segment-&gt;data(), segment.segment-&gt;size());
158         position += segment.segment-&gt;size();
159     }
160 
161     ASSERT(position == m_size);
162     ASSERT(internallyConsistent());
163     return arrayBuffer;
164 }
165 
166 void SharedBuffer::append(const SharedBuffer&amp; data)
167 {
168     ASSERT(!m_hasBeenCombinedIntoOneSegment);
169     m_segments.reserveCapacity(m_segments.size() + data.m_segments.size());
170     for (const auto&amp; element : data.m_segments) {
171         m_segments.uncheckedAppend({m_size, element.segment.copyRef()});
172         m_size += element.segment-&gt;size();
173     }
174     ASSERT(internallyConsistent());
175 }
176 
177 void SharedBuffer::append(const char* data, size_t length)
178 {
179     ASSERT(!m_hasBeenCombinedIntoOneSegment);
180     Vector&lt;char&gt; vector;
181     vector.append(data, length);
182     m_segments.append({m_size, DataSegment::create(WTFMove(vector))});
183     m_size += length;
184     ASSERT(internallyConsistent());
185 }
186 
187 void SharedBuffer::append(Vector&lt;char&gt;&amp;&amp; data)
188 {
189     ASSERT(!m_hasBeenCombinedIntoOneSegment);
190     auto dataSize = data.size();
191     m_segments.append({m_size, DataSegment::create(WTFMove(data))});
192     m_size += dataSize;
193     ASSERT(internallyConsistent());
194 }
195 
196 void SharedBuffer::clear()
197 {
198     m_size = 0;
199     m_segments.clear();
200     ASSERT(internallyConsistent());
201 }
202 
203 Ref&lt;SharedBuffer&gt; SharedBuffer::copy() const
204 {
205     Ref&lt;SharedBuffer&gt; clone = adoptRef(*new SharedBuffer);
206     clone-&gt;m_size = m_size;
207     clone-&gt;m_segments.reserveInitialCapacity(m_segments.size());
208     for (const auto&amp; element : m_segments)
209         clone-&gt;m_segments.uncheckedAppend({element.beginPosition, element.segment.copyRef()});
210     ASSERT(clone-&gt;internallyConsistent());
211     ASSERT(internallyConsistent());
212     return clone;
213 }
214 
<a name="4" id="anc4"></a><span class="line-modified">215 #if ASSERT_ENABLED</span>
216 bool SharedBuffer::internallyConsistent() const
217 {
218     size_t position = 0;
219     for (const auto&amp; element : m_segments) {
220         if (element.beginPosition != position)
221             return false;
222         position += element.segment-&gt;size();
223     }
224     return position == m_size;
225 }
<a name="5" id="anc5"></a><span class="line-modified">226 #endif // ASSERT_ENABLED</span>
227 
228 const char* SharedBuffer::DataSegment::data() const
229 {
230     auto visitor = WTF::makeVisitor(
231         [](const Vector&lt;char&gt;&amp; data) { return data.data(); },
232 #if USE(CF)
233         [](const RetainPtr&lt;CFDataRef&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(CFDataGetBytePtr(data.get())); },
234 #endif
235 #if USE(SOUP)
236         [](const GUniquePtr&lt;SoupBuffer&gt;&amp; data) { return data-&gt;data; },
237 #endif
238 #if USE(GLIB)
239         [](const GRefPtr&lt;GBytes&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(g_bytes_get_data(data.get(), nullptr)); },
240 #endif
241 #if USE(GSTREAMER)
242         [](const RefPtr&lt;GstMappedBuffer&gt;&amp; data) { return reinterpret_cast&lt;const char*&gt;(data-&gt;data()); },
243 #endif
244         [](const FileSystem::MappedFileData&amp; data) { return reinterpret_cast&lt;const char*&gt;(data.data()); }
245     );
246     return WTF::visit(visitor, m_immutableData);
247 }
248 
249 #if !USE(CF)
250 void SharedBuffer::hintMemoryNotNeededSoon() const
251 {
252 }
253 #endif
254 
<a name="6" id="anc6"></a><span class="line-added">255 WTF::Persistence::Decoder SharedBuffer::decoder() const</span>
<span class="line-added">256 {</span>
<span class="line-added">257     return { reinterpret_cast&lt;const uint8_t*&gt;(data()), size() };</span>
<span class="line-added">258 }</span>
<span class="line-added">259 </span>
260 bool SharedBuffer::operator==(const SharedBuffer&amp; other) const
261 {
262     if (this == &amp;other)
263         return true;
264 
265     if (m_size != other.m_size)
266         return false;
267 
268     auto thisIterator = begin();
269     size_t thisOffset = 0;
270     auto otherIterator = other.begin();
271     size_t otherOffset = 0;
272 
273     while (thisIterator != end() &amp;&amp; otherIterator != other.end()) {
274         auto&amp; thisSegment = thisIterator-&gt;segment.get();
275         auto&amp; otherSegment = otherIterator-&gt;segment.get();
276 
277         if (&amp;thisSegment == &amp;otherSegment &amp;&amp; !thisOffset &amp;&amp; !otherOffset) {
278             ++thisIterator;
279             ++otherIterator;
280             continue;
281         }
282 
283         ASSERT(thisOffset &lt; thisSegment.size());
284         ASSERT(otherOffset &lt; otherSegment.size());
285 
286         size_t thisRemaining = thisSegment.size() - thisOffset;
287         size_t otherRemaining = otherSegment.size() - otherOffset;
288         size_t remaining = std::min(thisRemaining, otherRemaining);
289 
290         if (memcmp(thisSegment.data() + thisOffset, otherSegment.data() + otherOffset, remaining))
291             return false;
292 
293         thisOffset += remaining;
294         otherOffset += remaining;
295 
296         if (thisOffset == thisSegment.size()) {
297             ++thisIterator;
298             thisOffset = 0;
299         }
300 
301         if (otherOffset == otherSegment.size()) {
302             ++otherIterator;
303             otherOffset = 0;
304         }
305     }
306     return true;
307 }
308 
309 size_t SharedBuffer::DataSegment::size() const
310 {
311     auto visitor = WTF::makeVisitor(
312         [](const Vector&lt;char&gt;&amp; data) { return data.size(); },
313 #if USE(CF)
314         [](const RetainPtr&lt;CFDataRef&gt;&amp; data) { return CFDataGetLength(data.get()); },
315 #endif
316 #if USE(SOUP)
317         [](const GUniquePtr&lt;SoupBuffer&gt;&amp; data) { return static_cast&lt;size_t&gt;(data-&gt;length); },
318 #endif
319 #if USE(GLIB)
320         [](const GRefPtr&lt;GBytes&gt;&amp; data) { return g_bytes_get_size(data.get()); },
321 #endif
322 #if USE(GSTREAMER)
323         [](const RefPtr&lt;GstMappedBuffer&gt;&amp; data) { return data-&gt;size(); },
324 #endif
325         [](const FileSystem::MappedFileData&amp; data) { return data.size(); }
326     );
327     return WTF::visit(visitor, m_immutableData);
328 }
329 
330 SharedBufferDataView::SharedBufferDataView(Ref&lt;SharedBuffer::DataSegment&gt;&amp;&amp; segment, size_t positionWithinSegment)
331     : m_positionWithinSegment(positionWithinSegment)
332     , m_segment(WTFMove(segment))
333 {
334     ASSERT(positionWithinSegment &lt; m_segment-&gt;size());
335 }
336 
337 size_t SharedBufferDataView::size() const
338 {
339     return m_segment-&gt;size() - m_positionWithinSegment;
340 }
341 
342 const char* SharedBufferDataView::data() const
343 {
344     return m_segment-&gt;data() + m_positionWithinSegment;
345 }
346 
347 RefPtr&lt;SharedBuffer&gt; utf8Buffer(const String&amp; string)
348 {
349     // Allocate a buffer big enough to hold all the characters.
350     const int length = string.length();
351     Vector&lt;char&gt; buffer(length * 3);
352 
353     // Convert to runs of 8-bit characters.
354     char* p = buffer.data();
355     if (length) {
356         if (string.is8Bit()) {
357             const LChar* d = string.characters8();
358             if (!WTF::Unicode::convertLatin1ToUTF8(&amp;d, d + length, &amp;p, p + buffer.size()))
359                 return nullptr;
360         } else {
361             const UChar* d = string.characters16();
362             if (WTF::Unicode::convertUTF16ToUTF8(&amp;d, d + length, &amp;p, p + buffer.size()) != WTF::Unicode::ConversionOK)
363                 return nullptr;
364         }
365     }
366 
367     buffer.shrink(p - buffer.data());
368     return SharedBuffer::create(WTFMove(buffer));
369 }
370 
371 } // namespace WebCore
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
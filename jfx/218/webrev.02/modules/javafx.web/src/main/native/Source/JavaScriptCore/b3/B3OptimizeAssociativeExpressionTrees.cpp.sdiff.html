<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3OptimizeAssociativeExpressionTrees.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="B3Opcode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3PatchpointSpecial.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3OptimizeAssociativeExpressionTrees.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
232     // Finally we can build the balanced binary tree
233     unsigned leafIndex = 0;
234     while (leafIndex + 1 &lt; optLeaves.size()) {
235         optLeaves.append(insertionSet.insert&lt;Value&gt;(indexInBlock, op, root-&gt;origin(), optLeaves[leafIndex], optLeaves[leafIndex + 1]));
236         leafIndex += 2;
237     }
238     ASSERT(leafIndex == optLeaves.size() - 1);
239     root-&gt;replaceWithIdentity(optLeaves[leafIndex]);
240     return true;
241 }
242 
243 bool OptimizeAssociativeExpressionTrees::run()
244 {
245     bool changed = false;
246 
247     // We proceed in two phases.
248     // In the first one we compute the use counts of each value (of an interesting opcode), and find potential roots of interesting expression trees.
249     // In the second one we optimize each such expression tree in turn.
250     // We need the use counts to avoid duplicating code.
251 


252     Vector&lt;unsigned&gt; useCounts(m_proc.values().size(), 0); // Mapping from Value::m_index to use counts.
253     HashSet&lt;Value*&gt; expressionTreeRoots;
254     HashSet&lt;BasicBlock*&gt; rootOwners;
255 
256     for (BasicBlock* block : m_proc) {
257         for (Value* value : *block) {
258             for (Value* child : value-&gt;children()) {
259                 if (!child-&gt;isInteger())
260                     continue;
261                 switch (child-&gt;opcode()) {
262                 case Mul:
263                 case Add:
264                 case BitAnd:
265                 case BitOr:
266                 case BitXor:
267                     useCounts[child-&gt;index()]++;
268                     if (child-&gt;opcode() != value-&gt;opcode() || useCounts[child-&gt;index()] &gt; 1) {
269                         expressionTreeRoots.add(child);
270                         rootOwners.add(child-&gt;owner);
271                     }
</pre>
</td>
<td>
<hr />
<pre>
232     // Finally we can build the balanced binary tree
233     unsigned leafIndex = 0;
234     while (leafIndex + 1 &lt; optLeaves.size()) {
235         optLeaves.append(insertionSet.insert&lt;Value&gt;(indexInBlock, op, root-&gt;origin(), optLeaves[leafIndex], optLeaves[leafIndex + 1]));
236         leafIndex += 2;
237     }
238     ASSERT(leafIndex == optLeaves.size() - 1);
239     root-&gt;replaceWithIdentity(optLeaves[leafIndex]);
240     return true;
241 }
242 
243 bool OptimizeAssociativeExpressionTrees::run()
244 {
245     bool changed = false;
246 
247     // We proceed in two phases.
248     // In the first one we compute the use counts of each value (of an interesting opcode), and find potential roots of interesting expression trees.
249     // In the second one we optimize each such expression tree in turn.
250     // We need the use counts to avoid duplicating code.
251 
<span class="line-added">252     m_proc.resetValueOwners();</span>
<span class="line-added">253 </span>
254     Vector&lt;unsigned&gt; useCounts(m_proc.values().size(), 0); // Mapping from Value::m_index to use counts.
255     HashSet&lt;Value*&gt; expressionTreeRoots;
256     HashSet&lt;BasicBlock*&gt; rootOwners;
257 
258     for (BasicBlock* block : m_proc) {
259         for (Value* value : *block) {
260             for (Value* child : value-&gt;children()) {
261                 if (!child-&gt;isInteger())
262                     continue;
263                 switch (child-&gt;opcode()) {
264                 case Mul:
265                 case Add:
266                 case BitAnd:
267                 case BitOr:
268                 case BitXor:
269                     useCounts[child-&gt;index()]++;
270                     if (child-&gt;opcode() != value-&gt;opcode() || useCounts[child-&gt;index()] &gt; 1) {
271                         expressionTreeRoots.add(child);
272                         rootOwners.add(child-&gt;owner);
273                     }
</pre>
</td>
</tr>
</table>
<center><a href="B3Opcode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="B3PatchpointSpecial.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
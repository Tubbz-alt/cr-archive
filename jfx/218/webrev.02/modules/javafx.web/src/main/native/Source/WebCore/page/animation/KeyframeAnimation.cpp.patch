diff a/modules/javafx.web/src/main/native/Source/WebCore/page/animation/KeyframeAnimation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/page/animation/KeyframeAnimation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/page/animation/KeyframeAnimation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/page/animation/KeyframeAnimation.cpp
@@ -251,11 +251,11 @@
         return true; // Non-boxes don't get transformed;
 
     auto& box = downcast<RenderBox>(*renderer());
     auto rendererBox = snapRectToDevicePixels(box.borderBoxRect(), box.document().deviceScaleFactor());
 
-    auto cumulativeBounds = bounds;
+    LayoutRect cumulativeBounds;
 
     for (auto& keyframe : m_keyframes.keyframes()) {
         const RenderStyle* keyframeStyle = keyframe.style();
 
         if (!keyframe.containsProperty(CSSPropertyTransform)) {
@@ -360,11 +360,11 @@
 
     if (shouldSendEventForListener(listenerType)) {
         // Dispatch the event
         auto element = makeRefPtr(this->element());
 
-        ASSERT(!element || element->document().pageCacheState() == Document::NotInPageCache);
+        ASSERT(!element || element->document().backForwardCacheState() == Document::NotInBackForwardCache);
         if (!element)
             return false;
 
         // Schedule event handling
         m_compositeAnimation->animationController().addEventToDispatch(*element, eventType, m_keyframes.animationName(), elapsedTime);
@@ -513,11 +513,15 @@
 
 Optional<Seconds> KeyframeAnimation::timeToNextService()
 {
     Optional<Seconds> t = AnimationBase::timeToNextService();
     if (!t || t.value() != 0_s || preActive())
+#if COMPILER(MSVC) && _MSC_VER >= 1920
+        return WTFMove(t);
+#else
         return t;
+#endif
 
     // A return value of 0 means we need service. But if we only have accelerated animations we
     // only need service at the end of the transition.
     bool acceleratedPropertiesOnly = true;
 

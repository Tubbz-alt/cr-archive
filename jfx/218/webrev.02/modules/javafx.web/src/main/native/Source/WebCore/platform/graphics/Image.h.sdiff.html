<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Image.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Image.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Image.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 94     virtual bool isSVGImage() const { return false; }
 95     virtual bool isPDFDocumentImage() const { return false; }
 96     virtual bool isCustomPaintImage() const { return false; }
 97 
 98     virtual bool currentFrameKnownToBeOpaque() const = 0;
 99     virtual bool isAnimated() const { return false; }
100 
101     // Derived classes should override this if they can assure that
102     // the image contains only resources from its own security origin.
103     virtual bool hasSingleSecurityOrigin() const { return false; }
104 
105     WEBCORE_EXPORT static Image&amp; nullImage();
106     bool isNull() const { return size().isEmpty(); }
107 
108     virtual void setContainerSize(const FloatSize&amp;) { }
109     virtual bool usesContainerSize() const { return false; }
110     virtual bool hasRelativeWidth() const { return false; }
111     virtual bool hasRelativeHeight() const { return false; }
112     virtual void computeIntrinsicDimensions(Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio);
113 
<span class="line-modified">114     virtual FloatSize size() const = 0;</span>
115     FloatRect rect() const { return FloatRect(FloatPoint(), size()); }
116     float width() const { return size().width(); }
117     float height() const { return size().height(); }
118     virtual Optional&lt;IntPoint&gt; hotSpot() const { return WTF::nullopt; }

119 
120     WEBCORE_EXPORT EncodedDataStatus setData(RefPtr&lt;SharedBuffer&gt;&amp;&amp; data, bool allDataReceived);
121     virtual EncodedDataStatus dataChanged(bool /*allDataReceived*/) { return EncodedDataStatus::Unknown; }
122 
123     virtual String uti() const { return String(); } // null string if unknown
124     virtual String filenameExtension() const { return String(); } // null string if unknown
125 
126     virtual void destroyDecodedData(bool destroyAll = true) = 0;
127 
128     SharedBuffer* data() { return m_encodedImageData.get(); }
129     const SharedBuffer* data() const { return m_encodedImageData.get(); }
130 
131     // Animation begins whenever someone draws the image, so startAnimation() is not normally called.
132     // It will automatically pause once all observers no longer want to render the image anywhere.
133     virtual void startAnimation() { }
134     void startAnimationAsynchronously();
135     virtual void stopAnimation() {}
136     virtual void resetAnimation() {}
137     virtual bool isAnimating() const { return false; }
138     bool animationPending() const { return m_animationStartTimer &amp;&amp; m_animationStartTimer-&gt;isActive(); }
139 
140     // Typically the CachedImage that owns us.
141     ImageObserver* imageObserver() const { return m_imageObserver; }
142     void setImageObserver(ImageObserver* observer) { m_imageObserver = observer; }
143     URL sourceURL() const;
144     String mimeType() const;
145     long long expectedContentLength() const;
146 
147     enum TileRule { StretchTile, RoundTile, SpaceTile, RepeatTile };
148 
149     virtual NativeImagePtr nativeImage(const GraphicsContext* = nullptr) { return nullptr; }
<span class="line-removed">150     virtual NativeImagePtr nativeImageOfSize(const IntSize&amp;, const GraphicsContext* = nullptr) { return nullptr; }</span>
151     virtual NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) { return nullptr; }


152 
153     // Accessors for native image formats.
154 
155 #if USE(APPKIT)
156     virtual NSImage *nsImage() { return nullptr; }
157     virtual RetainPtr&lt;NSImage&gt; snapshotNSImage() { return nullptr; }
158 #endif
159 
160 #if PLATFORM(COCOA)
161     virtual CFDataRef tiffRepresentation() { return nullptr; }
162 #endif
163 
164 #if PLATFORM(WIN)
165     virtual bool getHBITMAP(HBITMAP) { return false; }
166     virtual bool getHBITMAPOfSize(HBITMAP, const IntSize*) { return false; }
167 #endif
168 
169 #if PLATFORM(GTK)
170     virtual GdkPixbuf* getGdkPixbuf() { return nullptr; }
171 #endif
172 
173 #if PLATFORM(JAVA)
174     virtual NativeImagePtr javaImage() { return nativeImageForCurrentFrame(); }
175     virtual void drawImage(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, CompositeOperator, BlendMode);
176 #endif
177 
178     virtual void drawPattern(GraphicsContext&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
179 
<span class="line-modified">180 #if !ASSERT_DISABLED</span>
181     virtual bool notSolidColor() { return true; }
182 #endif
183 
184     virtual void dump(WTF::TextStream&amp;) const;
185 
186 protected:
187     Image(ImageObserver* = nullptr);
188 
189     static void fillWithSolidColor(GraphicsContext&amp;, const FloatRect&amp; dstRect, const Color&amp;, CompositeOperator);
190 
191 #if PLATFORM(WIN)
192     virtual void drawFrameMatchingSourceSize(GraphicsContext&amp;, const FloatRect&amp; dstRect, const IntSize&amp; srcSize, CompositeOperator) { }
193 #endif
194     virtual ImageDrawResult draw(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; = { }) = 0;
195     ImageDrawResult drawTiled(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatPoint&amp; srcPoint, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
196     ImageDrawResult drawTiled(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, const FloatSize&amp; tileScaleFactor, TileRule hRule, TileRule vRule, const ImagePaintingOptions&amp; = { });
197 
198     // Supporting tiled drawing
199     virtual Color singlePixelSolidColor() const { return Color(); }
200 
201 private:
202     RefPtr&lt;SharedBuffer&gt; m_encodedImageData;
203     ImageObserver* m_imageObserver;
204     std::unique_ptr&lt;Timer&gt; m_animationStartTimer;
205 };
206 





207 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Image&amp;);
208 
209 } // namespace WebCore
210 
211 #define SPECIALIZE_TYPE_TRAITS_IMAGE(ToClassName) \
212 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToClassName) \
213     static bool isType(const WebCore::Image&amp; image) { return image.is##ToClassName(); } \
214 SPECIALIZE_TYPE_TRAITS_END()
215 
</pre>
</td>
<td>
<hr />
<pre>
 94     virtual bool isSVGImage() const { return false; }
 95     virtual bool isPDFDocumentImage() const { return false; }
 96     virtual bool isCustomPaintImage() const { return false; }
 97 
 98     virtual bool currentFrameKnownToBeOpaque() const = 0;
 99     virtual bool isAnimated() const { return false; }
100 
101     // Derived classes should override this if they can assure that
102     // the image contains only resources from its own security origin.
103     virtual bool hasSingleSecurityOrigin() const { return false; }
104 
105     WEBCORE_EXPORT static Image&amp; nullImage();
106     bool isNull() const { return size().isEmpty(); }
107 
108     virtual void setContainerSize(const FloatSize&amp;) { }
109     virtual bool usesContainerSize() const { return false; }
110     virtual bool hasRelativeWidth() const { return false; }
111     virtual bool hasRelativeHeight() const { return false; }
112     virtual void computeIntrinsicDimensions(Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio);
113 
<span class="line-modified">114     virtual FloatSize size(ImageOrientation = ImageOrientation::FromImage) const = 0;</span>
115     FloatRect rect() const { return FloatRect(FloatPoint(), size()); }
116     float width() const { return size().width(); }
117     float height() const { return size().height(); }
118     virtual Optional&lt;IntPoint&gt; hotSpot() const { return WTF::nullopt; }
<span class="line-added">119     virtual ImageOrientation orientation() const { return ImageOrientation::FromImage; }</span>
120 
121     WEBCORE_EXPORT EncodedDataStatus setData(RefPtr&lt;SharedBuffer&gt;&amp;&amp; data, bool allDataReceived);
122     virtual EncodedDataStatus dataChanged(bool /*allDataReceived*/) { return EncodedDataStatus::Unknown; }
123 
124     virtual String uti() const { return String(); } // null string if unknown
125     virtual String filenameExtension() const { return String(); } // null string if unknown
126 
127     virtual void destroyDecodedData(bool destroyAll = true) = 0;
128 
129     SharedBuffer* data() { return m_encodedImageData.get(); }
130     const SharedBuffer* data() const { return m_encodedImageData.get(); }
131 
132     // Animation begins whenever someone draws the image, so startAnimation() is not normally called.
133     // It will automatically pause once all observers no longer want to render the image anywhere.
134     virtual void startAnimation() { }
135     void startAnimationAsynchronously();
136     virtual void stopAnimation() {}
137     virtual void resetAnimation() {}
138     virtual bool isAnimating() const { return false; }
139     bool animationPending() const { return m_animationStartTimer &amp;&amp; m_animationStartTimer-&gt;isActive(); }
140 
141     // Typically the CachedImage that owns us.
142     ImageObserver* imageObserver() const { return m_imageObserver; }
143     void setImageObserver(ImageObserver* observer) { m_imageObserver = observer; }
144     URL sourceURL() const;
145     String mimeType() const;
146     long long expectedContentLength() const;
147 
148     enum TileRule { StretchTile, RoundTile, SpaceTile, RepeatTile };
149 
150     virtual NativeImagePtr nativeImage(const GraphicsContext* = nullptr) { return nullptr; }

151     virtual NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) { return nullptr; }
<span class="line-added">152     virtual NativeImagePtr nativeImageForCurrentFrameRespectingOrientation(const GraphicsContext* = nullptr) { return nullptr; }</span>
<span class="line-added">153     virtual NativeImagePtr nativeImageOfSize(const IntSize&amp;, const GraphicsContext* = nullptr) { return nullptr; }</span>
154 
155     // Accessors for native image formats.
156 
157 #if USE(APPKIT)
158     virtual NSImage *nsImage() { return nullptr; }
159     virtual RetainPtr&lt;NSImage&gt; snapshotNSImage() { return nullptr; }
160 #endif
161 
162 #if PLATFORM(COCOA)
163     virtual CFDataRef tiffRepresentation() { return nullptr; }
164 #endif
165 
166 #if PLATFORM(WIN)
167     virtual bool getHBITMAP(HBITMAP) { return false; }
168     virtual bool getHBITMAPOfSize(HBITMAP, const IntSize*) { return false; }
169 #endif
170 
171 #if PLATFORM(GTK)
172     virtual GdkPixbuf* getGdkPixbuf() { return nullptr; }
173 #endif
174 
175 #if PLATFORM(JAVA)
176     virtual NativeImagePtr javaImage() { return nativeImageForCurrentFrame(); }
177     virtual void drawImage(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, CompositeOperator, BlendMode);
178 #endif
179 
180     virtual void drawPattern(GraphicsContext&amp;, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
181 
<span class="line-modified">182 #if ASSERT_ENABLED</span>
183     virtual bool notSolidColor() { return true; }
184 #endif
185 
186     virtual void dump(WTF::TextStream&amp;) const;
187 
188 protected:
189     Image(ImageObserver* = nullptr);
190 
191     static void fillWithSolidColor(GraphicsContext&amp;, const FloatRect&amp; dstRect, const Color&amp;, CompositeOperator);
192 
193 #if PLATFORM(WIN)
194     virtual void drawFrameMatchingSourceSize(GraphicsContext&amp;, const FloatRect&amp; dstRect, const IntSize&amp; srcSize, CompositeOperator) { }
195 #endif
196     virtual ImageDrawResult draw(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; = { }) = 0;
197     ImageDrawResult drawTiled(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatPoint&amp; srcPoint, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; = { });
198     ImageDrawResult drawTiled(GraphicsContext&amp;, const FloatRect&amp; dstRect, const FloatRect&amp; srcRect, const FloatSize&amp; tileScaleFactor, TileRule hRule, TileRule vRule, const ImagePaintingOptions&amp; = { });
199 
200     // Supporting tiled drawing
201     virtual Color singlePixelSolidColor() const { return Color(); }
202 
203 private:
204     RefPtr&lt;SharedBuffer&gt; m_encodedImageData;
205     ImageObserver* m_imageObserver;
206     std::unique_ptr&lt;Timer&gt; m_animationStartTimer;
207 };
208 
<span class="line-added">209 class ImageHandle {</span>
<span class="line-added">210 public:</span>
<span class="line-added">211     RefPtr&lt;Image&gt; image;</span>
<span class="line-added">212 };</span>
<span class="line-added">213 </span>
214 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Image&amp;);
215 
216 } // namespace WebCore
217 
218 #define SPECIALIZE_TYPE_TRAITS_IMAGE(ToClassName) \
219 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToClassName) \
220     static bool isType(const WebCore::Image&amp; image) { return image.is##ToClassName(); } \
221 SPECIALIZE_TYPE_TRAITS_END()
222 
</pre>
</td>
</tr>
</table>
<center><a href="Image.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
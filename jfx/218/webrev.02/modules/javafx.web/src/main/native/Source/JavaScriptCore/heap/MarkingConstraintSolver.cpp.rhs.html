<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkingConstraintSolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MarkingConstraintSolver.h&quot;
 28 
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;MarkingConstraintSet.h&quot;
 31 
 32 namespace JSC {
 33 
 34 MarkingConstraintSolver::MarkingConstraintSolver(MarkingConstraintSet&amp; set)
 35     : m_heap(set.m_heap)
 36     , m_mainVisitor(m_heap.collectorSlotVisitor())
 37     , m_set(set)
 38 {
 39     m_heap.forEachSlotVisitor(
 40         [&amp;] (SlotVisitor&amp; visitor) {
 41             m_visitCounters.append(VisitCounter(visitor));
 42         });
 43 }
 44 
 45 MarkingConstraintSolver::~MarkingConstraintSolver()
 46 {
 47 }
 48 
 49 bool MarkingConstraintSolver::didVisitSomething() const
 50 {
 51     for (const VisitCounter&amp; visitCounter : m_visitCounters) {
 52         if (visitCounter.visitCount())
 53             return true;
 54     }
 55     return false;
 56 }
 57 
 58 void MarkingConstraintSolver::execute(SchedulerPreference preference, ScopedLambda&lt;Optional&lt;unsigned&gt;()&gt; pickNext)
 59 {
 60     m_pickNextIsStillActive = true;
 61     RELEASE_ASSERT(!m_numThreadsThatMayProduceWork);
 62 
 63     if (Options::useParallelMarkingConstraintSolver()) {
<a name="1" id="anc1"></a><span class="line-modified"> 64         dataLogIf(Options::logGC(), preference == ParallelWorkFirst ? &quot;P&quot; : &quot;N&quot;, &quot;&lt;&quot;);</span>

 65 
 66         m_heap.runFunctionInParallel(
 67             [&amp;] (SlotVisitor&amp; visitor) { runExecutionThread(visitor, preference, pickNext); });
 68 
<a name="2" id="anc2"></a><span class="line-modified"> 69         dataLogIf(Options::logGC(), &quot;&gt;&quot;);</span>

 70     } else
 71         runExecutionThread(m_mainVisitor, preference, pickNext);
 72 
 73     RELEASE_ASSERT(!m_pickNextIsStillActive);
 74     RELEASE_ASSERT(!m_numThreadsThatMayProduceWork);
 75 
 76     if (!m_toExecuteSequentially.isEmpty()) {
 77         for (unsigned indexToRun : m_toExecuteSequentially)
 78             execute(*m_set.m_set[indexToRun]);
 79         m_toExecuteSequentially.clear();
 80     }
 81 
 82     RELEASE_ASSERT(m_toExecuteInParallel.isEmpty());
 83 }
 84 
 85 void MarkingConstraintSolver::drain(BitVector&amp; unexecuted)
 86 {
 87     auto iter = unexecuted.begin();
 88     auto end = unexecuted.end();
 89     if (iter == end)
 90         return;
 91     auto pickNext = scopedLambda&lt;Optional&lt;unsigned&gt;()&gt;(
 92         [&amp;] () -&gt; Optional&lt;unsigned&gt; {
 93             if (iter == end)
 94                 return WTF::nullopt;
 95             return *iter++;
 96         });
 97     execute(NextConstraintFirst, pickNext);
 98     unexecuted.clearAll();
 99 }
100 
101 void MarkingConstraintSolver::converge(const Vector&lt;MarkingConstraint*&gt;&amp; order)
102 {
103     if (didVisitSomething())
104         return;
105 
106     if (order.isEmpty())
107         return;
108 
109     size_t index = 0;
110 
111     // We want to execute the first constraint sequentially if we think it will quickly give us a
112     // result. If we ran it in parallel to other constraints, then we might end up having to wait for
113     // those other constraints to finish, which would be a waste of time since during convergence it&#39;s
114     // empirically most optimal to return to draining as soon as a constraint generates work. Most
115     // constraints don&#39;t generate any work most of the time, and when they do generate work, they tend
116     // to generate enough of it to feed a decent draining cycle. Therefore, pause times are lowest if
117     // we get the heck out of here as soon as a constraint generates work. I think that part of what
118     // makes this optimal is that we also never abort running a constraint early, so when we do run
119     // one, it has an opportunity to generate as much work as it possibly can.
120     if (order[index]-&gt;quickWorkEstimate(m_mainVisitor) &gt; 0.) {
121         execute(*order[index++]);
122 
123         if (m_toExecuteInParallel.isEmpty()
124             &amp;&amp; (order.isEmpty() || didVisitSomething()))
125             return;
126     }
127 
128     auto pickNext = scopedLambda&lt;Optional&lt;unsigned&gt;()&gt;(
129         [&amp;] () -&gt; Optional&lt;unsigned&gt; {
130             if (didVisitSomething())
131                 return WTF::nullopt;
132 
133             if (index &gt;= order.size())
134                 return WTF::nullopt;
135 
136             MarkingConstraint&amp; constraint = *order[index++];
137             return constraint.index();
138         });
139 
140     execute(ParallelWorkFirst, pickNext);
141 }
142 
143 void MarkingConstraintSolver::execute(MarkingConstraint&amp; constraint)
144 {
145     if (m_executed.get(constraint.index()))
146         return;
147 
148     constraint.prepareToExecute(NoLockingNecessary, m_mainVisitor);
149     constraint.execute(m_mainVisitor);
150     m_executed.set(constraint.index());
151 }
152 
153 void MarkingConstraintSolver::addParallelTask(RefPtr&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; task, MarkingConstraint&amp; constraint)
154 {
155     auto locker = holdLock(m_lock);
156     m_toExecuteInParallel.append(TaskWithConstraint(WTFMove(task), &amp;constraint));
157 }
158 
159 void MarkingConstraintSolver::runExecutionThread(SlotVisitor&amp; visitor, SchedulerPreference preference, ScopedLambda&lt;Optional&lt;unsigned&gt;()&gt; pickNext)
160 {
161     for (;;) {
162         bool doParallelWorkMode;
163         MarkingConstraint* constraint = nullptr;
164         unsigned indexToRun = UINT_MAX;
165         TaskWithConstraint task;
166         {
167             auto locker = holdLock(m_lock);
168 
169             for (;;) {
170                 auto tryParallelWork = [&amp;] () -&gt; bool {
171                     if (m_toExecuteInParallel.isEmpty())
172                         return false;
173 
174                     task = m_toExecuteInParallel.first();
175                     constraint = task.constraint;
176                     doParallelWorkMode = true;
177                     return true;
178                 };
179 
180                 auto tryNextConstraint = [&amp;] () -&gt; bool {
181                     if (!m_pickNextIsStillActive)
182                         return false;
183 
184                     for (;;) {
185                         Optional&lt;unsigned&gt; pickResult = pickNext();
186                         if (!pickResult) {
187                             m_pickNextIsStillActive = false;
188                             return false;
189                         }
190 
191                         if (m_executed.get(*pickResult))
192                             continue;
193 
194                         MarkingConstraint&amp; candidateConstraint = *m_set.m_set[*pickResult];
195                         if (candidateConstraint.concurrency() == ConstraintConcurrency::Sequential) {
196                             m_toExecuteSequentially.append(*pickResult);
197                             continue;
198                         }
199                         if (candidateConstraint.parallelism() == ConstraintParallelism::Parallel)
200                             m_numThreadsThatMayProduceWork++;
201                         indexToRun = *pickResult;
202                         constraint = &amp;candidateConstraint;
203                         doParallelWorkMode = false;
204                         constraint-&gt;prepareToExecute(locker, visitor);
205                         return true;
206                     }
207                 };
208 
209                 if (preference == ParallelWorkFirst) {
210                     if (tryParallelWork() || tryNextConstraint())
211                         break;
212                 } else {
213                     if (tryNextConstraint() || tryParallelWork())
214                         break;
215                 }
216 
217                 // This means that we have nothing left to run. The only way for us to have more work is
218                 // if someone is running a constraint that may produce parallel work.
219 
220                 if (!m_numThreadsThatMayProduceWork)
221                     return;
222 
223                 // FIXME: Any waiting could be replaced with just running the SlotVisitor.
224                 // I wonder if that would be profitable.
225                 m_condition.wait(m_lock);
226             }
227         }
228 
229         if (doParallelWorkMode)
230             constraint-&gt;doParallelWork(visitor, *task.task);
231         else {
232             if (constraint-&gt;parallelism() == ConstraintParallelism::Parallel) {
233                 visitor.m_currentConstraint = constraint;
234                 visitor.m_currentSolver = this;
235             }
236 
237             constraint-&gt;execute(visitor);
238 
239             visitor.m_currentConstraint = nullptr;
240             visitor.m_currentSolver = nullptr;
241         }
242 
243         {
244             auto locker = holdLock(m_lock);
245 
246             if (doParallelWorkMode) {
247                 if (!m_toExecuteInParallel.isEmpty()
248                     &amp;&amp; task == m_toExecuteInParallel.first())
249                     m_toExecuteInParallel.takeFirst();
250                 else
251                     ASSERT(!m_toExecuteInParallel.contains(task));
252             } else {
253                 if (constraint-&gt;parallelism() == ConstraintParallelism::Parallel)
254                     m_numThreadsThatMayProduceWork--;
255                 m_executed.set(indexToRun);
256             }
257 
258             m_condition.notifyAll();
259         }
260     }
261 }
262 
263 } // namespace JSC
264 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
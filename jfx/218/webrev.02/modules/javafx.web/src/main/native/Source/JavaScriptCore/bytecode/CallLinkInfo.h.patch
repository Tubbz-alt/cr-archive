diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.h
@@ -132,11 +132,11 @@
     CallMode callMode() const
     {
         return callModeFor(static_cast<CallType>(m_callType));
     }
 
-    bool isDirect()
+    bool isDirect() const
     {
         return isDirect(static_cast<CallType>(m_callType));
     }
 
     bool isTailCall() const
@@ -152,11 +152,11 @@
     bool isVarargs() const
     {
         return isVarargsCallType(static_cast<CallType>(m_callType));
     }
 
-    bool isLinked() { return m_stub || m_calleeOrCodeBlock; }
+    bool isLinked() const { return m_stub || m_calleeOrCodeBlock; }
     void unlink(VM&);
 
     void setUpCall(CallType callType, CodeOrigin codeOrigin, GPRReg calleeGPR)
     {
         m_callType = callType;
@@ -199,12 +199,12 @@
     void clearCodeBlock();
     FunctionCodeBlock* codeBlock();
 
     void setLastSeenCallee(VM&, const JSCell* owner, JSObject* callee);
     void clearLastSeenCallee();
-    JSObject* lastSeenCallee();
-    bool haveLastSeenCallee();
+    JSObject* lastSeenCallee() const;
+    bool haveLastSeenCallee() const;
 
     void setExecutableDuringCompilation(ExecutableBase*);
     ExecutableBase* executable();
 
     void setStub(Ref<PolymorphicCallStubRoutine>&& newStub)
@@ -213,11 +213,11 @@
         m_stub = WTFMove(newStub);
     }
 
     void clearStub();
 
-    PolymorphicCallStubRoutine* stub()
+    PolymorphicCallStubRoutine* stub() const
     {
         return m_stub.get();
     }
 
     void setSlowStub(Ref<JITStubRoutine>&& newSlowStub)
@@ -293,21 +293,21 @@
     CallType callType()
     {
         return static_cast<CallType>(m_callType);
     }
 
-    uint32_t* addressOfMaxNumArguments()
+    uint32_t* addressOfMaxArgumentCountIncludingThis()
     {
-        return &m_maxNumArguments;
+        return &m_maxArgumentCountIncludingThis;
     }
 
-    uint32_t maxNumArguments()
+    uint32_t maxArgumentCountIncludingThis()
     {
-        return m_maxNumArguments;
+        return m_maxArgumentCountIncludingThis;
     }
 
-    void setMaxNumArguments(unsigned);
+    void setMaxArgumentCountIncludingThis(unsigned);
 
     static ptrdiff_t offsetOfSlowPathCount()
     {
         return OBJECT_OFFSETOF(CallLinkInfo, m_slowPathCount);
     }
@@ -330,21 +330,37 @@
     CodeOrigin codeOrigin()
     {
         return m_codeOrigin;
     }
 
+    template<typename Functor>
+    void forEachDependentCell(const Functor& functor) const
+    {
+        if (isLinked()) {
+            if (stub())
+                stub()->forEachDependentCell(functor);
+            else {
+                functor(m_calleeOrCodeBlock.get());
+                if (isDirect())
+                    functor(m_lastSeenCalleeOrExecutable.get());
+            }
+        }
+        if (!isDirect() && haveLastSeenCallee())
+            functor(lastSeenCallee());
+    }
+
     void visitWeak(VM&);
 
     void setFrameShuffleData(const CallFrameShuffleData&);
 
     const CallFrameShuffleData* frameShuffleData()
     {
         return m_frameShuffleData.get();
     }
 
 private:
-    uint32_t m_maxNumArguments { 0 }; // For varargs: the profiled maximum number of arguments. For direct: the number of stack slots allocated for arguments.
+    uint32_t m_maxArgumentCountIncludingThis { 0 }; // For varargs: the profiled maximum number of arguments. For direct: the number of stack slots allocated for arguments.
     CodeLocationLabel<JSInternalPtrTag> m_callReturnLocationOrPatchableJump;
     CodeLocationLabel<JSInternalPtrTag> m_hotPathBeginOrSlowPathStart;
     CodeLocationNearCall<JSInternalPtrTag> m_hotPathOther;
     WriteBarrier<JSCell> m_calleeOrCodeBlock;
     WriteBarrier<JSCell> m_lastSeenCalleeOrExecutable;

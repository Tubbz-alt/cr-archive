<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2003, 2006 Apple Inc.  All rights reserved.
  3  *                     2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;Path.h&quot;
 31 
 32 #include &quot;FloatPoint.h&quot;
 33 #include &quot;FloatRect.h&quot;
 34 #include &quot;FloatRoundedRect.h&quot;
 35 #include &quot;PathTraversalState.h&quot;
 36 #include &quot;RoundedRect.h&quot;
 37 #include &lt;math.h&gt;
 38 #include &lt;wtf/MathExtras.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 #if !USE(DIRECT2D)
 44 float Path::length() const
 45 {
 46     PathTraversalState traversalState(PathTraversalState::Action::TotalLength);
 47 
 48     apply([&amp;traversalState](const PathElement&amp; element) {
 49         traversalState.processPathElement(element);
 50     });
 51 
 52     return traversalState.totalLength();
 53 }
 54 #endif
 55 
<a name="1" id="anc1"></a><span class="line-modified"> 56 PathTraversalState Path::traversalStateAtLength(float length) const</span>
 57 {
 58     PathTraversalState traversalState(PathTraversalState::Action::VectorAtLength, length);
 59 
 60     apply([&amp;traversalState](const PathElement&amp; element) {
 61         traversalState.processPathElement(element);
 62     });
 63 
<a name="2" id="anc2"></a>
 64     return traversalState;
 65 }
 66 
<a name="3" id="anc3"></a><span class="line-modified"> 67 FloatPoint Path::pointAtLength(float length) const</span>
 68 {
<a name="4" id="anc4"></a><span class="line-modified"> 69     return traversalStateAtLength(length).current();</span>





 70 }
 71 
 72 void Path::addRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; roundingRadii, RoundedRectStrategy strategy)
 73 {
 74     if (rect.isEmpty())
 75         return;
 76 
 77     FloatSize radius(roundingRadii);
 78     FloatSize halfSize = rect.size() / 2;
 79 
 80     // Apply the SVG corner radius constraints, per the rect section of the SVG shapes spec: if
 81     // one of rx,ry is negative, then the other corner radius value is used. If both values are
 82     // negative then rx = ry = 0. If rx is greater than half of the width of the rectangle
 83     // then set rx to half of the width; ry is handled similarly.
 84 
 85     if (radius.width() &lt; 0)
 86         radius.setWidth((radius.height() &lt; 0) ? 0 : radius.height());
 87 
 88     if (radius.height() &lt; 0)
 89         radius.setHeight(radius.width());
 90 
 91     if (radius.width() &gt; halfSize.width())
 92         radius.setWidth(halfSize.width());
 93 
 94     if (radius.height() &gt; halfSize.height())
 95         radius.setHeight(halfSize.height());
 96 
 97     addRoundedRect(FloatRoundedRect(rect, radius, radius, radius, radius), strategy);
 98 }
 99 
100 void Path::addRoundedRect(const FloatRoundedRect&amp; r, RoundedRectStrategy strategy)
101 {
102     if (r.isEmpty())
103         return;
104 
105     const FloatRoundedRect::Radii&amp; radii = r.radii();
106     const FloatRect&amp; rect = r.rect();
107 
108     if (!r.isRenderable()) {
109         // If all the radii cannot be accommodated, return a rect.
110         addRect(rect);
111         return;
112     }
113 
<a name="5" id="anc5"></a><span class="line-modified">114     if (strategy == RoundedRectStrategy::PreferNative) {</span>
115 #if USE(CG) || USE(DIRECT2D)
116         platformAddPathForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
117         return;
118 #endif
119     }
120 
121     addBeziersForRoundedRect(rect, radii.topLeft(), radii.topRight(), radii.bottomLeft(), radii.bottomRight());
122 }
123 
124 void Path::addRoundedRect(const RoundedRect&amp; r)
125 {
126     addRoundedRect(FloatRoundedRect(r));
127 }
128 
129 void Path::addBeziersForRoundedRect(const FloatRect&amp; rect, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius)
130 {
131     moveTo(FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));
132 
133     addLineTo(FloatPoint(rect.maxX() - topRightRadius.width(), rect.y()));
134     if (topRightRadius.width() &gt; 0 || topRightRadius.height() &gt; 0)
135         addBezierCurveTo(FloatPoint(rect.maxX() - topRightRadius.width() * circleControlPoint(), rect.y()),
136             FloatPoint(rect.maxX(), rect.y() + topRightRadius.height() * circleControlPoint()),
137             FloatPoint(rect.maxX(), rect.y() + topRightRadius.height()));
138     addLineTo(FloatPoint(rect.maxX(), rect.maxY() - bottomRightRadius.height()));
139     if (bottomRightRadius.width() &gt; 0 || bottomRightRadius.height() &gt; 0)
140         addBezierCurveTo(FloatPoint(rect.maxX(), rect.maxY() - bottomRightRadius.height() * circleControlPoint()),
141             FloatPoint(rect.maxX() - bottomRightRadius.width() * circleControlPoint(), rect.maxY()),
142             FloatPoint(rect.maxX() - bottomRightRadius.width(), rect.maxY()));
143     addLineTo(FloatPoint(rect.x() + bottomLeftRadius.width(), rect.maxY()));
144     if (bottomLeftRadius.width() &gt; 0 || bottomLeftRadius.height() &gt; 0)
145         addBezierCurveTo(FloatPoint(rect.x() + bottomLeftRadius.width() * circleControlPoint(), rect.maxY()),
146             FloatPoint(rect.x(), rect.maxY() - bottomLeftRadius.height() * circleControlPoint()),
147             FloatPoint(rect.x(), rect.maxY() - bottomLeftRadius.height()));
148     addLineTo(FloatPoint(rect.x(), rect.y() + topLeftRadius.height()));
149     if (topLeftRadius.width() &gt; 0 || topLeftRadius.height() &gt; 0)
150         addBezierCurveTo(FloatPoint(rect.x(), rect.y() + topLeftRadius.height() * circleControlPoint()),
151             FloatPoint(rect.x() + topLeftRadius.width() * circleControlPoint(), rect.y()),
152             FloatPoint(rect.x() + topLeftRadius.width(), rect.y()));
153 
154     closeSubpath();
155 }
156 
157 #if !USE(CG) &amp;&amp; !USE(DIRECT2D)
158 Path Path::polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp; points)
159 {
160     Path path;
161     if (points.size() &lt; 2)
162         return path;
163 
164     path.moveTo(points[0]);
165     for (size_t i = 1; i &lt; points.size(); ++i)
166         path.addLineTo(points[i]);
167 
168     path.closeSubpath();
169     return path;
170 }
171 
172 FloatRect Path::fastBoundingRect() const
173 {
174     return boundingRect();
175 }
176 #endif
177 
178 #ifndef NDEBUG
179 void Path::dump() const
180 {
181     TextStream stream;
182     stream &lt;&lt; *this;
183     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
184 }
185 #endif
186 
187 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const Path&amp; path)
188 {
189     bool isFirst = true;
190     path.apply([&amp;stream, &amp;isFirst](const PathElement&amp; element) {
191         if (!isFirst)
192             stream &lt;&lt; &quot;, &quot;;
193         isFirst = false;
194         switch (element.type) {
<a name="6" id="anc6"></a><span class="line-modified">195         case PathElement::Type::MoveToPoint: // The points member will contain 1 value.</span>
196             stream &lt;&lt; &quot;move to &quot; &lt;&lt; element.points[0];
197             break;
<a name="7" id="anc7"></a><span class="line-modified">198         case PathElement::Type::AddLineToPoint: // The points member will contain 1 value.</span>
199             stream &lt;&lt; &quot;add line to &quot; &lt;&lt; element.points[0];
200             break;
<a name="8" id="anc8"></a><span class="line-modified">201         case PathElement::Type::AddQuadCurveToPoint: // The points member will contain 2 values.</span>
202             stream &lt;&lt; &quot;add quad curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1];
203             break;
<a name="9" id="anc9"></a><span class="line-modified">204         case PathElement::Type::AddCurveToPoint: // The points member will contain 3 values.</span>
205             stream &lt;&lt; &quot;add curve to &quot; &lt;&lt; element.points[0] &lt;&lt; &quot; &quot; &lt;&lt; element.points[1] &lt;&lt; &quot; &quot; &lt;&lt; element.points[2];
206             break;
<a name="10" id="anc10"></a><span class="line-modified">207         case PathElement::Type::CloseSubpath: // The points member will contain no values.</span>
208             stream &lt;&lt; &quot;close subpath&quot;;
209             break;
210         }
211     });
212 
213     return stream;
214 }
215 
216 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/fileapi/ThreadableBlobRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileReaderLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadableBlobRegistry.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/fileapi/ThreadableBlobRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 62,104 ***</span>
      });
  
      return *map;
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerFileBlobURL(PAL::SessionID sessionID, const URL&amp; url, const String&amp; path, const String&amp; contentType)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerFileBlobURL(sessionID, url, BlobDataFileReference::create(path), contentType);</span>
          return;
      }
  
<span class="line-modified">!     callOnMainThread([sessionID, url = url.isolatedCopy(), path = path.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().registerFileBlobURL(sessionID, url, BlobDataFileReference::create(path), contentType);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURL(PAL::SessionID sessionID, const URL&amp; url, Vector&lt;BlobPart&gt;&amp;&amp; blobParts, const String&amp; contentType)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURL(sessionID, url, WTFMove(blobParts), contentType);</span>
          return;
      }
      for (auto&amp; part : blobParts)
          part.detachFromCurrentThread();
<span class="line-modified">!     callOnMainThread([sessionID, url = url.isolatedCopy(), blobParts = WTFMove(blobParts), contentType = contentType.isolatedCopy()]() mutable {</span>
<span class="line-modified">!         blobRegistry().registerBlobURL(sessionID, url, WTFMove(blobParts), contentType);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURL(PAL::SessionID sessionID, SecurityOrigin* origin, const URL&amp; url, const URL&amp; srcURL)</span>
  {
      // If the blob URL contains null origin, as in the context with unique security origin or file URL, save the mapping between url and origin so that the origin can be retrived when doing security origin check.
<span class="line-modified">!     if (origin &amp;&amp; BlobURL::getOrigin(url) == &quot;null&quot;)</span>
          originMap()-&gt;add(url.string(), origin);
  
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURL(sessionID, url, srcURL);</span>
          return;
      }
  
<span class="line-modified">!     callOnMainThread([sessionID, url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().registerBlobURL(sessionID, url, srcURL);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURLOptionallyFileBacked(PAL::SessionID sessionID, const URL&amp; url, const URL&amp; srcURL, const String&amp; fileBackedPath, const String&amp; contentType)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURLOptionallyFileBacked(sessionID, url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
          return;
      }
<span class="line-modified">!     callOnMainThread([sessionID, url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy(), fileBackedPath = fileBackedPath.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().registerBlobURLOptionallyFileBacked(sessionID, url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURLForSlice(PAL::SessionID sessionID, const URL&amp; newURL, const URL&amp; srcURL, long long start, long long end)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURLForSlice(sessionID, newURL, srcURL, start, end);</span>
          return;
      }
  
<span class="line-modified">!     callOnMainThread([sessionID, newURL = newURL.isolatedCopy(), srcURL = srcURL.isolatedCopy(), start, end] {</span>
<span class="line-modified">!         blobRegistry().registerBlobURLForSlice(sessionID, newURL, srcURL, start, end);</span>
      });
  }
  
<span class="line-modified">! unsigned long long ThreadableBlobRegistry::blobSize(PAL::SessionID sessionID, const URL&amp; url)</span>
  {
      if (isMainThread())
<span class="line-modified">!         return blobRegistry().blobSize(sessionID, url);</span>
  
      unsigned long long resultSize;
      BinarySemaphore semaphore;
<span class="line-modified">!     callOnMainThread([sessionID, url = url.isolatedCopy(), &amp;semaphore, &amp;resultSize] {</span>
<span class="line-modified">!         resultSize = blobRegistry().blobSize(sessionID, url);</span>
          semaphore.signal();
      });
      semaphore.wait();
      return resultSize;
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::unregisterBlobURL(PAL::SessionID sessionID, const URL&amp; url)</span>
  {
<span class="line-modified">!     if (BlobURL::getOrigin(url) == &quot;null&quot;)</span>
          originMap()-&gt;remove(url.string());
  
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().unregisterBlobURL(sessionID, url);</span>
          return;
      }
<span class="line-modified">!     callOnMainThread([sessionID, url = url.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().unregisterBlobURL(sessionID, url);</span>
      });
  }
  
  RefPtr&lt;SecurityOrigin&gt; ThreadableBlobRegistry::getCachedOrigin(const URL&amp; url)
  {
<span class="line-modified">!     return originMap()-&gt;get(url.string());</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 62,117 ---</span>
      });
  
      return *map;
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerFileBlobURL(const URL&amp; url, const String&amp; path, const String&amp; contentType)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerFileBlobURL(url, BlobDataFileReference::create(path), contentType);</span>
          return;
      }
  
<span class="line-modified">!     callOnMainThread([url = url.isolatedCopy(), path = path.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().registerFileBlobURL(url, BlobDataFileReference::create(path), contentType);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURL(const URL&amp; url, Vector&lt;BlobPart&gt;&amp;&amp; blobParts, const String&amp; contentType)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURL(url, WTFMove(blobParts), contentType);</span>
          return;
      }
      for (auto&amp; part : blobParts)
          part.detachFromCurrentThread();
<span class="line-modified">!     callOnMainThread([url = url.isolatedCopy(), blobParts = WTFMove(blobParts), contentType = contentType.isolatedCopy()]() mutable {</span>
<span class="line-modified">!         blobRegistry().registerBlobURL(url, WTFMove(blobParts), contentType);</span>
      });
  }
  
<span class="line-modified">! static inline bool isBlobURLContainsNullOrigin(const URL&amp; url)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(url.protocolIsBlob());</span>
<span class="line-added">+     return BlobURL::getOrigin(url) == &quot;null&quot;;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const URL&amp; url, const URL&amp; srcURL)</span>
  {
      // If the blob URL contains null origin, as in the context with unique security origin or file URL, save the mapping between url and origin so that the origin can be retrived when doing security origin check.
<span class="line-modified">!     if (origin &amp;&amp; isBlobURLContainsNullOrigin(url))</span>
          originMap()-&gt;add(url.string(), origin);
  
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURL(url, srcURL);</span>
          return;
      }
  
<span class="line-modified">!     callOnMainThread([url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().registerBlobURL(url, srcURL);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURLOptionallyFileBacked(const URL&amp; url, const URL&amp; srcURL, const String&amp; fileBackedPath, const String&amp; contentType)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURLOptionallyFileBacked(url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
          return;
      }
<span class="line-modified">!     callOnMainThread([url = url.isolatedCopy(), srcURL = srcURL.isolatedCopy(), fileBackedPath = fileBackedPath.isolatedCopy(), contentType = contentType.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().registerBlobURLOptionallyFileBacked(url, srcURL, BlobDataFileReference::create(fileBackedPath), contentType);</span>
      });
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::registerBlobURLForSlice(const URL&amp; newURL, const URL&amp; srcURL, long long start, long long end)</span>
  {
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().registerBlobURLForSlice(newURL, srcURL, start, end);</span>
          return;
      }
  
<span class="line-modified">!     callOnMainThread([newURL = newURL.isolatedCopy(), srcURL = srcURL.isolatedCopy(), start, end] {</span>
<span class="line-modified">!         blobRegistry().registerBlobURLForSlice(newURL, srcURL, start, end);</span>
      });
  }
  
<span class="line-modified">! unsigned long long ThreadableBlobRegistry::blobSize(const URL&amp; url)</span>
  {
      if (isMainThread())
<span class="line-modified">!         return blobRegistry().blobSize(url);</span>
  
      unsigned long long resultSize;
      BinarySemaphore semaphore;
<span class="line-modified">!     callOnMainThread([url = url.isolatedCopy(), &amp;semaphore, &amp;resultSize] {</span>
<span class="line-modified">!         resultSize = blobRegistry().blobSize(url);</span>
          semaphore.signal();
      });
      semaphore.wait();
      return resultSize;
  }
  
<span class="line-modified">! void ThreadableBlobRegistry::unregisterBlobURL(const URL&amp; url)</span>
  {
<span class="line-modified">!     if (isBlobURLContainsNullOrigin(url))</span>
          originMap()-&gt;remove(url.string());
  
      if (isMainThread()) {
<span class="line-modified">!         blobRegistry().unregisterBlobURL(url);</span>
          return;
      }
<span class="line-modified">!     callOnMainThread([url = url.isolatedCopy()] {</span>
<span class="line-modified">!         blobRegistry().unregisterBlobURL(url);</span>
      });
  }
  
  RefPtr&lt;SecurityOrigin&gt; ThreadableBlobRegistry::getCachedOrigin(const URL&amp; url)
  {
<span class="line-modified">!     if (auto cachedOrigin = originMap()-&gt;get(url.string()))</span>
<span class="line-added">+         return cachedOrigin;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!url.protocolIsBlob() || !isBlobURLContainsNullOrigin(url))</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If we do not have a cached origin for null blob URLs, we use a unique origin.</span>
<span class="line-added">+     return SecurityOrigin::createUnique();</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="FileReaderLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadableBlobRegistry.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
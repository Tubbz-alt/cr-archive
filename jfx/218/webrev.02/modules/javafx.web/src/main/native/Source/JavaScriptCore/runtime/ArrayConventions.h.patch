diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayConventions.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayConventions.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayConventions.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayConventions.h
@@ -52,11 +52,11 @@
 //   * Where (MAX_STORAGE_VECTOR_INDEX < i <= MAX_ARRAY_INDEX) the value will always be stored
 //     in the sparse array.
 
 // Define the maximum storage vector length to be 2^32 / sizeof(JSValue) / 2 to ensure that
 // there is no risk of overflow.
-#define MAX_STORAGE_VECTOR_LENGTH (static_cast<unsigned>(IndexingHeader::maximumLength))
+#define MAX_STORAGE_VECTOR_LENGTH IndexingHeader::maximumLength
 
 // These values have to be macros to be used in max() and min() without introducing
 // a PIC branch in Mach-O binaries, see <rdar://problem/5971391>.
 
 // If you grow an ArrayStorage array by more than this, then the array will go sparse. Note that we
@@ -89,11 +89,11 @@
 
 // Our policy for when to use a vector and when to use a sparse map.
 // For all array indices under MIN_SPARSE_ARRAY_INDEX, we always use a vector.
 // When indices greater than MIN_SPARSE_ARRAY_INDEX are involved, we use a vector
 // as long as it is 1/8 full. If more sparse than that, we use a map.
-static const unsigned minDensityMultiplier = 8;
+static constexpr unsigned minDensityMultiplier = 8;
 
 inline bool isDenseEnoughForVector(unsigned length, unsigned numValues)
 {
     return length / minDensityMultiplier <= numValues;
 }

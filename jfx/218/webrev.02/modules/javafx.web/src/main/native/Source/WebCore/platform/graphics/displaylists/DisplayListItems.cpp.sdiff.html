<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DisplayList.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListItems.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/displaylists/DisplayListItems.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DisplayListItems.h&quot;
  28 
  29 #include &quot;FontCascade.h&quot;
  30 #include &lt;wtf/text/TextStream.h&gt;
  31 




  32 namespace WebCore {
  33 namespace DisplayList {
  34 
  35 // Should match RenderTheme::platformFocusRingWidth()
  36 static const float platformFocusRingWidth = 3;
  37 
  38 #if !defined(NDEBUG) || !LOG_DISABLED
  39 WTF::CString Item::description() const
  40 {
  41     TextStream ts;
  42     ts &lt;&lt; *this;
  43     return ts.release().utf8();
  44 }
  45 #endif
  46 







  47 size_t Item::sizeInBytes(const Item&amp; item)
  48 {
  49     switch (item.type()) {
  50     case ItemType::Save:
  51         return sizeof(downcast&lt;Save&gt;(item));
  52     case ItemType::Restore:
  53         return sizeof(downcast&lt;Restore&gt;(item));
  54     case ItemType::Translate:
  55         return sizeof(downcast&lt;Translate&gt;(item));
  56     case ItemType::Rotate:
  57         return sizeof(downcast&lt;Rotate&gt;(item));
  58     case ItemType::Scale:
  59         return sizeof(downcast&lt;Scale&gt;(item));


  60     case ItemType::ConcatenateCTM:
  61         return sizeof(downcast&lt;ConcatenateCTM&gt;(item));
  62     case ItemType::SetState:
  63         return sizeof(downcast&lt;SetState&gt;(item));
  64     case ItemType::SetLineCap:
  65         return sizeof(downcast&lt;SetLineCap&gt;(item));
  66     case ItemType::SetLineDash:
  67         return sizeof(downcast&lt;SetLineDash&gt;(item));
  68     case ItemType::SetLineJoin:
  69         return sizeof(downcast&lt;SetLineJoin&gt;(item));
  70     case ItemType::SetMiterLimit:
  71         return sizeof(downcast&lt;SetMiterLimit&gt;(item));
  72     case ItemType::ClearShadow:
  73         return sizeof(downcast&lt;ClearShadow&gt;(item));
  74     case ItemType::Clip:
  75         return sizeof(downcast&lt;Clip&gt;(item));
  76     case ItemType::ClipOut:
  77         return sizeof(downcast&lt;ClipOut&gt;(item));
  78     case ItemType::ClipOutToPath:
  79         return sizeof(downcast&lt;ClipOutToPath&gt;(item));
</pre>
<hr />
<pre>
 145 #endif
 146     case ItemType::ApplyDeviceScaleFactor:
 147         return sizeof(downcast&lt;ApplyDeviceScaleFactor&gt;(item));
 148     }
 149     return 0;
 150 }
 151 
 152 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawingItem&amp; item)
 153 {
 154     ts.startGroup();
 155     ts &lt;&lt; &quot;extent &quot;;
 156     if (item.extentKnown())
 157         ts &lt;&lt; item.extent();
 158     else
 159         ts &lt;&lt; &quot;unknown&quot;;
 160 
 161     ts.endGroup();
 162     return ts;
 163 }
 164 














 165 void Save::apply(GraphicsContext&amp; context) const
 166 {
 167     context.save();
 168 }
 169 
 170 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Save&amp; item)
 171 {
 172     ts.dumpProperty(&quot;restore-index&quot;, item.restoreIndex());
 173     return ts;
 174 }
 175 







 176 void Restore::apply(GraphicsContext&amp; context) const
 177 {
 178     context.restore();
 179 }
 180 









 181 void Translate::apply(GraphicsContext&amp; context) const
 182 {
 183     context.translate(m_x, m_y);
 184 }
 185 
 186 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Translate&amp; item)
 187 {
 188     ts.dumpProperty(&quot;x&quot;, item.x());
 189     ts.dumpProperty(&quot;y&quot;, item.y());
 190 
 191     return ts;
 192 }
 193 








 194 void Rotate::apply(GraphicsContext&amp; context) const
 195 {
 196     context.rotate(m_angle);
 197 }
 198 
 199 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Rotate&amp; item)
 200 {
 201     ts.dumpProperty(&quot;angle&quot;, item.angle());
 202 
 203     return ts;
 204 }
 205 








 206 void Scale::apply(GraphicsContext&amp; context) const
 207 {
 208     context.scale(m_size);
 209 }
 210 
 211 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Scale&amp; item)
 212 {
 213     ts.dumpProperty(&quot;size&quot;, item.amount());
 214 
 215     return ts;
 216 }
 217 




















 218 ConcatenateCTM::ConcatenateCTM(const AffineTransform&amp; transform)
 219     : Item(ItemType::ConcatenateCTM)
 220     , m_transform(transform)
 221 {
 222 }
 223 


 224 void ConcatenateCTM::apply(GraphicsContext&amp; context) const
 225 {
 226     context.concatCTM(m_transform);
 227 }
 228 
 229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ConcatenateCTM&amp; item)
 230 {
 231     ts.dumpProperty(&quot;ctm&quot;, item.transform());
 232 
 233     return ts;
 234 }
 235 














 236 void SetState::apply(GraphicsContext&amp; context) const
 237 {
 238     m_state.apply(context);
 239 }
 240 
 241 void SetState::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 242 {
 243     m_state.accumulate(state, flags);
 244 }
 245 
 246 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetState&amp; state)
 247 {
 248     ts &lt;&lt; state.state();
 249     return ts;
 250 }
 251 








 252 void SetLineCap::apply(GraphicsContext&amp; context) const
 253 {
 254     context.setLineCap(m_lineCap);
 255 }
 256 
 257 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineCap&amp; lineCap)
 258 {
 259     ts.dumpProperty(&quot;line-cap&quot;, lineCap.lineCap());
 260     return ts;
 261 }
 262 









 263 void SetLineDash::apply(GraphicsContext&amp; context) const
 264 {
 265     context.setLineDash(m_dashArray, m_dashOffset);
 266 }
 267 
 268 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineDash&amp; lineDash)
 269 {
 270     ts.dumpProperty(&quot;dash-array&quot;, lineDash.dashArray());
 271     ts.dumpProperty(&quot;dash-offset&quot;, lineDash.dashOffset());
 272     return ts;
 273 }
 274 








 275 void SetLineJoin::apply(GraphicsContext&amp; context) const
 276 {
 277     context.setLineJoin(m_lineJoin);
 278 }
 279 
 280 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineJoin&amp; lineJoin)
 281 {
 282     ts.dumpProperty(&quot;line-join&quot;, lineJoin.lineJoin());
 283     return ts;
 284 }
 285 








 286 void SetMiterLimit::apply(GraphicsContext&amp; context) const
 287 {
 288     context.setMiterLimit(m_miterLimit);
 289 }
 290 
 291 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetMiterLimit&amp; miterLimit)
 292 {
 293     ts.dumpProperty(&quot;mitre-limit&quot;, miterLimit.miterLimit());
 294     return ts;
 295 }
 296 







 297 void ClearShadow::apply(GraphicsContext&amp; context) const
 298 {
 299     context.clearShadow();
 300 }
 301 








 302 void Clip::apply(GraphicsContext&amp; context) const
 303 {
 304     context.clip(m_rect);
 305 }
 306 
 307 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Clip&amp; item)
 308 {
 309     ts.dumpProperty(&quot;rect&quot;, item.rect());
 310     return ts;
 311 }
 312 








 313 void ClipOut::apply(GraphicsContext&amp; context) const
 314 {
 315     context.clipOut(m_rect);
 316 }
 317 
 318 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOut&amp; item)
 319 {
 320     ts.dumpProperty(&quot;rect&quot;, item.rect());
 321     return ts;
 322 }
 323 








 324 void ClipOutToPath::apply(GraphicsContext&amp; context) const
 325 {
 326     context.clipOut(m_path);
 327 }
 328 
 329 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOutToPath&amp; item)
 330 {
 331     ts.dumpProperty(&quot;path&quot;, item.path());
 332     return ts;
 333 }
 334 









 335 void ClipPath::apply(GraphicsContext&amp; context) const
 336 {
 337     context.clipPath(m_path, m_windRule);
 338 }
 339 
 340 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipPath&amp; item)
 341 {
 342     ts.dumpProperty(&quot;path&quot;, item.path());
 343     ts.dumpProperty(&quot;wind-rule&quot;, item.windRule());
 344     return ts;
 345 }
 346 












 347 DrawGlyphs::DrawGlyphs(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 348     : DrawingItem(ItemType::DrawGlyphs)
 349     , m_font(const_cast&lt;Font&amp;&gt;(font))
 350     , m_blockLocation(blockLocation)
 351     , m_localAnchor(localAnchor)
 352     , m_smoothingMode(smoothingMode)
 353 {
 354     m_glyphs.reserveInitialCapacity(count);
 355     m_advances.reserveInitialCapacity(count);
 356     for (unsigned i = 0; i &lt; count; ++i) {
 357         m_glyphs.uncheckedAppend(glyphs[i]);
 358         m_advances.uncheckedAppend(advances[i]);
 359     }
 360     computeBounds();
 361 }
 362 


 363 inline GlyphBuffer DrawGlyphs::generateGlyphBuffer() const
 364 {
 365     GlyphBuffer result;
 366     for (size_t i = 0; i &lt; m_glyphs.size(); ++i) {
 367         result.add(m_glyphs[i], &amp;m_font.get(), m_advances[i], GlyphBuffer::noOffset);
 368     }
 369     return result;
 370 }
 371 
 372 void DrawGlyphs::apply(GraphicsContext&amp; context) const
 373 {
 374     context.drawGlyphs(m_font, generateGlyphBuffer(), 0, m_glyphs.size(), anchorPoint(), m_smoothingMode);
 375 }
 376 
 377 void DrawGlyphs::computeBounds()
 378 {
 379     // FIXME: This code doesn&#39;t actually take the extents of the glyphs into consideration. It assumes that
 380     // the glyph lies entirely within its [(ascent + descent), advance] rect.
 381     float ascent = m_font-&gt;fontMetrics().floatAscent();
 382     float descent = m_font-&gt;fontMetrics().floatDescent();
</pre>
<hr />
<pre>
 402 {
 403     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 404     // FIXME: dump more stuff.
 405     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 406     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 407     ts.dumpProperty(&quot;anchor-point&quot;, item.anchorPoint());
 408     ts.dumpProperty(&quot;length&quot;, item.glyphs().size());
 409 
 410     return ts;
 411 }
 412 
 413 DrawImage::DrawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 414     : DrawingItem(ItemType::DrawImage)
 415     , m_image(image)
 416     , m_destination(destination)
 417     , m_source(source)
 418     , m_imagePaintingOptions(imagePaintingOptions)
 419 {
 420 }
 421 


 422 void DrawImage::apply(GraphicsContext&amp; context) const
 423 {
 424     context.drawImage(m_image.get(), m_destination, m_source, m_imagePaintingOptions);
 425 }
 426 
 427 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawImage&amp; item)
 428 {
 429     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 430     ts.dumpProperty(&quot;image&quot;, item.image());
 431     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 432     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 433     return ts;
 434 }
 435 
 436 DrawTiledImage::DrawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 437     : DrawingItem(ItemType::DrawTiledImage)
 438     , m_image(image)
 439     , m_destination(destination)
 440     , m_source(source)
 441     , m_tileSize(tileSize)
 442     , m_spacing(spacing)
 443     , m_imagePaintingOptions(imagePaintingOptions)
 444 {
 445 }
 446 


 447 void DrawTiledImage::apply(GraphicsContext&amp; context) const
 448 {
 449     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileSize, m_spacing, m_imagePaintingOptions);
 450 }
 451 
 452 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledImage&amp; item)
 453 {
 454     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 455     ts.dumpProperty(&quot;image&quot;, item.image());
 456     ts.dumpProperty(&quot;source-point&quot;, item.source());
 457     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 458     ts.dumpProperty(&quot;tile-size&quot;, item.tileSize());
 459     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 460     return ts;
 461 }
 462 
 463 DrawTiledScaledImage::DrawTiledScaledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 464     : DrawingItem(ItemType::DrawTiledScaledImage)
 465     , m_image(image)
 466     , m_destination(destination)
 467     , m_source(source)
 468     , m_tileScaleFactor(tileScaleFactor)
 469     , m_hRule(hRule)
 470     , m_vRule(vRule)
 471     , m_imagePaintingOptions(imagePaintingOptions)
 472 {
 473 }
 474 


 475 void DrawTiledScaledImage::apply(GraphicsContext&amp; context) const
 476 {
 477     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileScaleFactor, m_hRule, m_vRule, m_imagePaintingOptions);
 478 }
 479 
 480 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledScaledImage&amp; item)
 481 {
 482     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 483     ts.dumpProperty(&quot;image&quot;, item.image());
 484     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 485     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 486     return ts;
 487 }
 488 
 489 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 490 DrawNativeImage::DrawNativeImage(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
 491     : DrawingItem(ItemType::DrawNativeImage)
 492 #if USE(CG)
 493     // FIXME: Need to store an image for Cairo.
 494     , m_image(image)
 495 #endif
 496     , m_imageSize(imageSize)
<span class="line-modified"> 497     , m_destination(destRect)</span>
 498     , m_srcRect(srcRect)
 499     , m_options(options)
 500 {
 501 #if !USE(CG)
 502     UNUSED_PARAM(image);
 503 #endif
 504 }
 505 


 506 void DrawNativeImage::apply(GraphicsContext&amp; context) const
 507 {
 508 #if USE(CG)
<span class="line-modified"> 509     context.drawNativeImage(m_image, m_imageSize, m_destination, m_srcRect, m_options);</span>
 510 #else
 511     UNUSED_PARAM(context);
 512 #endif
 513 }
 514 
 515 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawNativeImage&amp; item)
 516 {
 517     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 518     // FIXME: dump more stuff.
 519     ts.dumpProperty(&quot;source-rect&quot;, item.source());
<span class="line-modified"> 520     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());</span>
 521     return ts;
 522 }
 523 #endif
 524 
 525 DrawPattern::DrawPattern(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 526     : DrawingItem(ItemType::DrawPattern)
 527     , m_image(image)
 528     , m_patternTransform(patternTransform)
 529     , m_tileRect(tileRect)
 530     , m_destination(destRect)
 531     , m_phase(phase)
 532     , m_spacing(spacing)
 533     , m_options(options)
 534 {
 535 }
 536 


 537 void DrawPattern::apply(GraphicsContext&amp; context) const
 538 {
 539     context.drawPattern(m_image.get(), m_destination, m_tileRect, m_patternTransform, m_phase, m_spacing, m_options);
 540 }
 541 
 542 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPattern&amp; item)
 543 {
 544     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 545     ts.dumpProperty(&quot;image&quot;, item.image());
 546     ts.dumpProperty(&quot;pattern-transform&quot;, item.patternTransform());
 547     ts.dumpProperty(&quot;tile-rect&quot;, item.tileRect());
 548     ts.dumpProperty(&quot;dest-rect&quot;, item.destRect());
 549     ts.dumpProperty(&quot;phase&quot;, item.phase());
 550     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 551     return ts;
 552 }
 553 









 554 void DrawRect::apply(GraphicsContext&amp; context) const
 555 {
 556     context.drawRect(m_rect, m_borderThickness);
 557 }
 558 
 559 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawRect&amp; item)
 560 {
 561     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 562     ts.dumpProperty(&quot;rect&quot;, item.rect());
 563     ts.dumpProperty(&quot;border-thickness&quot;, item.borderThickness());
 564     return ts;
 565 }
 566 









 567 Optional&lt;FloatRect&gt; DrawLine::localBounds(const GraphicsContext&amp;) const
 568 {
 569     FloatRect bounds;
 570     bounds.fitToPoints(m_point1, m_point2);
 571     return bounds;
 572 }
 573 
 574 void DrawLine::apply(GraphicsContext&amp; context) const
 575 {
 576     context.drawLine(m_point1, m_point2);
 577 }
 578 
 579 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLine&amp; item)
 580 {
 581     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 582     ts.dumpProperty(&quot;point-1&quot;, item.point1());
 583     ts.dumpProperty(&quot;point-2&quot;, item.point2());
 584     return ts;
 585 }
 586 













 587 void DrawLinesForText::apply(GraphicsContext&amp; context) const
 588 {
 589     context.drawLinesForText(point(), m_thickness, m_widths, m_printing, m_doubleLines);
 590 }
 591 
 592 Optional&lt;FloatRect&gt; DrawLinesForText::localBounds(const GraphicsContext&amp;) const
 593 {
 594     // This function needs to return a value equal to or enclosing what GraphicsContext::computeLineBoundsAndAntialiasingModeForText() returns.
 595 
 596     if (!m_widths.size())
 597         return FloatRect();
 598 
 599     FloatRect result(point(), FloatSize(m_widths.last(), m_thickness));
 600     result.inflate(1); // Account for pixel snapping. FIXME: This isn&#39;t perfect, as it doesn&#39;t take the CTM into account.
 601     return result;
 602 }
 603 
 604 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLinesForText&amp; item)
 605 {
 606     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 607     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 608     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 609     ts.dumpProperty(&quot;point&quot;, item.point());
 610     ts.dumpProperty(&quot;thickness&quot;, item.thickness());
 611     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 612     ts.dumpProperty(&quot;widths&quot;, item.widths());
 613     ts.dumpProperty(&quot;is-printing&quot;, item.isPrinting());
 614     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 615     return ts;
 616 }
 617 









 618 void DrawDotsForDocumentMarker::apply(GraphicsContext&amp; context) const
 619 {
 620     context.drawDotsForDocumentMarker(m_rect, m_style);
 621 }
 622 
 623 Optional&lt;FloatRect&gt; DrawDotsForDocumentMarker::localBounds(const GraphicsContext&amp;) const
 624 {
 625     return m_rect;
 626 }
 627 
 628 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawDotsForDocumentMarker&amp; item)
 629 {
 630     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 631     ts.dumpProperty(&quot;rect&quot;, item.rect());
 632     return ts;
 633 }
 634 








 635 void DrawEllipse::apply(GraphicsContext&amp; context) const
 636 {
 637     context.drawEllipse(m_rect);
 638 }
 639 
 640 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawEllipse&amp; item)
 641 {
 642     ts.dumpProperty(&quot;rect&quot;, item.rect());
 643     return ts;
 644 }
 645 








 646 void DrawPath::apply(GraphicsContext&amp; context) const
 647 {
 648 #if USE(CG)
 649     context.drawPath(m_path);
 650 #else
 651     UNUSED_PARAM(context);
 652 #endif
 653 }
 654 
 655 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPath&amp; item)
 656 {
 657     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 658 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 659     return ts;
 660 }
 661 











 662 void DrawFocusRingPath::apply(GraphicsContext&amp; context) const
 663 {
 664     context.drawFocusRing(m_path, m_width, m_offset, m_color);
 665 }
 666 
 667 Optional&lt;FloatRect&gt; DrawFocusRingPath::localBounds(const GraphicsContext&amp;) const
 668 {
 669     FloatRect result = m_path.fastBoundingRect();
 670     result.inflate(platformFocusRingWidth);
 671     return result;
 672 }
 673 
 674 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingPath&amp; item)
 675 {
 676     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 677 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 678     ts.dumpProperty(&quot;width&quot;, item.width());
 679     ts.dumpProperty(&quot;offset&quot;, item.offset());
 680     ts.dumpProperty(&quot;color&quot;, item.color());
 681     return ts;
 682 }
 683 











 684 void DrawFocusRingRects::apply(GraphicsContext&amp; context) const
 685 {
 686     context.drawFocusRing(m_rects, m_width, m_offset, m_color);
 687 }
 688 
 689 Optional&lt;FloatRect&gt; DrawFocusRingRects::localBounds(const GraphicsContext&amp;) const
 690 {
 691     FloatRect result;
 692     for (auto&amp; rect : m_rects)
 693         result.unite(rect);
 694     result.inflate(platformFocusRingWidth);
 695     return result;
 696 }
 697 
 698 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingRects&amp; item)
 699 {
 700     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 701     ts.dumpProperty(&quot;rects&quot;, item.rects());
 702     ts.dumpProperty(&quot;width&quot;, item.width());
 703     ts.dumpProperty(&quot;offset&quot;, item.offset());
 704     ts.dumpProperty(&quot;color&quot;, item.color());
 705     return ts;
 706 }
 707 








 708 void FillRect::apply(GraphicsContext&amp; context) const
 709 {
 710     context.fillRect(m_rect);
 711 }
 712 
 713 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRect&amp; item)
 714 {
 715     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 716     ts.dumpProperty(&quot;rect&quot;, item.rect());
 717     return ts;
 718 }
 719 









 720 void FillRectWithColor::apply(GraphicsContext&amp; context) const
 721 {
 722     context.fillRect(m_rect, m_color);
 723 }
 724 
 725 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithColor&amp; item)
 726 {
 727     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 728     ts.dumpProperty(&quot;rect&quot;, item.rect());
 729     ts.dumpProperty(&quot;color&quot;, item.color());
 730     return ts;
 731 }
 732 









 733 void FillRectWithGradient::apply(GraphicsContext&amp; context) const
 734 {
 735     context.fillRect(m_rect, m_gradient.get());
 736 }
 737 
 738 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithGradient&amp; item)
 739 {
 740     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 741     // FIXME: log gradient.
 742     ts.dumpProperty(&quot;rect&quot;, item.rect());
 743     return ts;
 744 }
 745 











 746 void FillCompositedRect::apply(GraphicsContext&amp; context) const
 747 {
 748     context.fillRect(m_rect, m_color, m_op, m_blendMode);
 749 }
 750 
 751 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillCompositedRect&amp; item)
 752 {
 753     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 754     ts.dumpProperty(&quot;rect&quot;, item.rect());
 755     ts.dumpProperty(&quot;color&quot;, item.color());
 756     ts.dumpProperty(&quot;composite-operation&quot;, item.compositeOperator());
 757     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
 758     return ts;
 759 }
 760 










 761 void FillRoundedRect::apply(GraphicsContext&amp; context) const
 762 {
 763     context.fillRoundedRect(m_rect, m_color, m_blendMode);
 764 }
 765 
 766 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRoundedRect&amp; item)
 767 {
 768     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 769     ts.dumpProperty(&quot;rect&quot;, item.roundedRect());
 770     ts.dumpProperty(&quot;color&quot;, item.color());
 771     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
 772     return ts;
 773 }
 774 










 775 void FillRectWithRoundedHole::apply(GraphicsContext&amp; context) const
 776 {
 777     context.fillRectWithRoundedHole(m_rect, m_roundedHoleRect, m_color);
 778 }
 779 
 780 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithRoundedHole&amp; item)
 781 {
 782     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 783     ts.dumpProperty(&quot;rect&quot;, item.rect());
 784     ts.dumpProperty(&quot;rounded-hole-rect&quot;, item.roundedHoleRect());
 785     ts.dumpProperty(&quot;color&quot;, item.color());
 786     return ts;
 787 }
 788 








 789 void FillPath::apply(GraphicsContext&amp; context) const
 790 {
 791     context.fillPath(m_path);
 792 }
 793 
 794 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillPath&amp; item)
 795 {
 796     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 797     ts.dumpProperty(&quot;path&quot;, item.path());
 798     return ts;
 799 }
 800 








 801 void FillEllipse::apply(GraphicsContext&amp; context) const
 802 {
 803     context.fillEllipse(m_rect);
 804 }
 805 
 806 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillEllipse&amp; item)
 807 {
 808     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 809     ts.dumpProperty(&quot;rect&quot;, item.rect());
 810     return ts;
 811 }
 812 









 813 Optional&lt;FloatRect&gt; StrokeRect::localBounds(const GraphicsContext&amp;) const
 814 {
 815     FloatRect bounds = m_rect;
 816     bounds.expand(m_lineWidth, m_lineWidth);
 817     return bounds;
 818 }
 819 
 820 void StrokeRect::apply(GraphicsContext&amp; context) const
 821 {
 822     context.strokeRect(m_rect, m_lineWidth);
 823 }
 824 
 825 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeRect&amp; item)
 826 {
 827     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 828     ts.dumpProperty(&quot;rect&quot;, item.rect());
 829     ts.dumpProperty(&quot;line-width&quot;, item.lineWidth());
 830     return ts;
 831 }
 832 
</pre>
<hr />
<pre>
 835     // FIXME: Need to take stroke thickness into account correctly, via CGPathByStrokingPath().
 836     float strokeThickness = context.strokeThickness();
 837 
 838     FloatRect bounds = m_path.boundingRect();
 839     bounds.expand(strokeThickness, strokeThickness);
 840     return bounds;
 841 }
 842 
 843 void StrokePath::apply(GraphicsContext&amp; context) const
 844 {
 845     context.strokePath(m_path);
 846 }
 847 
 848 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokePath&amp; item)
 849 {
 850     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 851     ts.dumpProperty(&quot;path&quot;, item.path());
 852     return ts;
 853 }
 854 








 855 Optional&lt;FloatRect&gt; StrokeEllipse::localBounds(const GraphicsContext&amp; context) const
 856 {
 857     float strokeThickness = context.strokeThickness();
 858 
 859     FloatRect bounds = m_rect;
 860     bounds.expand(strokeThickness, strokeThickness);
 861     return bounds;
 862 }
 863 
 864 void StrokeEllipse::apply(GraphicsContext&amp; context) const
 865 {
 866     context.strokeEllipse(m_rect);
 867 }
 868 
 869 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeEllipse&amp; item)
 870 {
 871     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 872     ts.dumpProperty(&quot;rect&quot;, item.rect());
 873     return ts;
 874 }
 875 
















 876 void ClearRect::apply(GraphicsContext&amp; context) const
 877 {
 878     context.clearRect(m_rect);
 879 }
 880 
 881 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClearRect&amp; item)
 882 {
 883     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 884     ts.dumpProperty(&quot;rect&quot;, item.rect());
 885     return ts;
 886 }
 887 








 888 void BeginTransparencyLayer::apply(GraphicsContext&amp; context) const
 889 {
 890     context.beginTransparencyLayer(m_opacity);
 891 }
 892 
 893 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BeginTransparencyLayer&amp; item)
 894 {
 895     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 896     ts.dumpProperty(&quot;opacity&quot;, item.opacity());
 897     return ts;
 898 }
 899 







 900 void EndTransparencyLayer::apply(GraphicsContext&amp; context) const
 901 {
 902     context.endTransparencyLayer();
 903 }
 904 
 905 #if USE(CG)







 906 void ApplyStrokePattern::apply(GraphicsContext&amp; context) const
 907 {
 908     context.applyStrokePattern();
 909 }
 910 







 911 void ApplyFillPattern::apply(GraphicsContext&amp; context) const
 912 {
 913     context.applyFillPattern();
 914 }
 915 #endif
 916 








 917 void ApplyDeviceScaleFactor::apply(GraphicsContext&amp; context) const
 918 {
 919     context.applyDeviceScaleFactor(m_scaleFactor);
 920 }
 921 
 922 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ApplyDeviceScaleFactor&amp; item)
 923 {
 924     ts.dumpProperty(&quot;scale-factor&quot;, item.scaleFactor());
 925     return ts;
 926 }
 927 
 928 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ItemType&amp; type)
 929 {
 930     switch (type) {
 931     case ItemType::Save: ts &lt;&lt; &quot;save&quot;; break;
 932     case ItemType::Restore: ts &lt;&lt; &quot;restore&quot;; break;
 933     case ItemType::Translate: ts &lt;&lt; &quot;translate&quot;; break;
 934     case ItemType::Rotate: ts &lt;&lt; &quot;rotate&quot;; break;
 935     case ItemType::Scale: ts &lt;&lt; &quot;scale&quot;; break;

 936     case ItemType::ConcatenateCTM: ts &lt;&lt; &quot;concatentate-ctm&quot;; break;
 937     case ItemType::SetState: ts &lt;&lt; &quot;set-state&quot;; break;
 938     case ItemType::SetLineCap: ts &lt;&lt; &quot;set-line-cap&quot;; break;
 939     case ItemType::SetLineDash: ts &lt;&lt; &quot;set-line-dash&quot;; break;
 940     case ItemType::SetLineJoin: ts &lt;&lt; &quot;set-line-join&quot;; break;
 941     case ItemType::SetMiterLimit: ts &lt;&lt; &quot;set-miter-limit&quot;; break;
 942     case ItemType::Clip: ts &lt;&lt; &quot;clip&quot;; break;
 943     case ItemType::ClipOut: ts &lt;&lt; &quot;clip-out&quot;; break;
 944     case ItemType::ClipOutToPath: ts &lt;&lt; &quot;clip-out-to-path&quot;; break;
 945     case ItemType::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;
 946     case ItemType::DrawGlyphs: ts &lt;&lt; &quot;draw-glyphs&quot;; break;
 947     case ItemType::DrawImage: ts &lt;&lt; &quot;draw-image&quot;; break;
 948     case ItemType::DrawTiledImage: ts &lt;&lt; &quot;draw-tiled-image&quot;; break;
 949     case ItemType::DrawTiledScaledImage: ts &lt;&lt; &quot;draw-tiled-scaled-image&quot;; break;
 950 #if USE(CG) || USE(CAIRO)
 951     case ItemType::DrawNativeImage: ts &lt;&lt; &quot;draw-native-image&quot;; break;
 952 #endif
 953     case ItemType::DrawPattern: ts &lt;&lt; &quot;draw-pattern&quot;; break;
 954     case ItemType::DrawRect: ts &lt;&lt; &quot;draw-rect&quot;; break;
 955     case ItemType::DrawLine: ts &lt;&lt; &quot;draw-line&quot;; break;
</pre>
<hr />
<pre>
 985 
 986 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Item&amp; item)
 987 {
 988     TextStream::GroupScope group(ts);
 989     ts &lt;&lt; item.type();
 990 
 991     // FIXME: Make a macro which takes a macro for all these enumeration switches
 992     switch (item.type()) {
 993     case ItemType::Save:
 994         ts &lt;&lt; downcast&lt;Save&gt;(item);
 995         break;
 996     case ItemType::Translate:
 997         ts &lt;&lt; downcast&lt;Translate&gt;(item);
 998         break;
 999     case ItemType::Rotate:
1000         ts &lt;&lt; downcast&lt;Rotate&gt;(item);
1001         break;
1002     case ItemType::Scale:
1003         ts &lt;&lt; downcast&lt;Scale&gt;(item);
1004         break;



1005     case ItemType::ConcatenateCTM:
1006         ts &lt;&lt; downcast&lt;ConcatenateCTM&gt;(item);
1007         break;
1008     case ItemType::SetState:
1009         ts &lt;&lt; downcast&lt;SetState&gt;(item);
1010         break;
1011     case ItemType::SetLineCap:
1012         ts &lt;&lt; downcast&lt;SetLineCap&gt;(item);
1013         break;
1014     case ItemType::SetLineDash:
1015         ts &lt;&lt; downcast&lt;SetLineDash&gt;(item);
1016         break;
1017     case ItemType::SetLineJoin:
1018         ts &lt;&lt; downcast&lt;SetLineJoin&gt;(item);
1019         break;
1020     case ItemType::SetMiterLimit:
1021         ts &lt;&lt; downcast&lt;SetMiterLimit&gt;(item);
1022         break;
1023     case ItemType::Clip:
1024         ts &lt;&lt; downcast&lt;Clip&gt;(item);
</pre>
</td>
<td>
<hr />
<pre>
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DisplayListItems.h&quot;
  28 
  29 #include &quot;FontCascade.h&quot;
  30 #include &lt;wtf/text/TextStream.h&gt;
  31 
<span class="line-added">  32 #if USE(CG)</span>
<span class="line-added">  33 #include &quot;GraphicsContextPlatformPrivateCG.h&quot;</span>
<span class="line-added">  34 #endif</span>
<span class="line-added">  35 </span>
  36 namespace WebCore {
  37 namespace DisplayList {
  38 
  39 // Should match RenderTheme::platformFocusRingWidth()
  40 static const float platformFocusRingWidth = 3;
  41 
  42 #if !defined(NDEBUG) || !LOG_DISABLED
  43 WTF::CString Item::description() const
  44 {
  45     TextStream ts;
  46     ts &lt;&lt; *this;
  47     return ts.release().utf8();
  48 }
  49 #endif
  50 
<span class="line-added">  51 Item::Item(ItemType type)</span>
<span class="line-added">  52     : m_type(type)</span>
<span class="line-added">  53 {</span>
<span class="line-added">  54 }</span>
<span class="line-added">  55 </span>
<span class="line-added">  56 Item::~Item() = default;</span>
<span class="line-added">  57 </span>
  58 size_t Item::sizeInBytes(const Item&amp; item)
  59 {
  60     switch (item.type()) {
  61     case ItemType::Save:
  62         return sizeof(downcast&lt;Save&gt;(item));
  63     case ItemType::Restore:
  64         return sizeof(downcast&lt;Restore&gt;(item));
  65     case ItemType::Translate:
  66         return sizeof(downcast&lt;Translate&gt;(item));
  67     case ItemType::Rotate:
  68         return sizeof(downcast&lt;Rotate&gt;(item));
  69     case ItemType::Scale:
  70         return sizeof(downcast&lt;Scale&gt;(item));
<span class="line-added">  71     case ItemType::SetCTM:</span>
<span class="line-added">  72         return sizeof(downcast&lt;SetCTM&gt;(item));</span>
  73     case ItemType::ConcatenateCTM:
  74         return sizeof(downcast&lt;ConcatenateCTM&gt;(item));
  75     case ItemType::SetState:
  76         return sizeof(downcast&lt;SetState&gt;(item));
  77     case ItemType::SetLineCap:
  78         return sizeof(downcast&lt;SetLineCap&gt;(item));
  79     case ItemType::SetLineDash:
  80         return sizeof(downcast&lt;SetLineDash&gt;(item));
  81     case ItemType::SetLineJoin:
  82         return sizeof(downcast&lt;SetLineJoin&gt;(item));
  83     case ItemType::SetMiterLimit:
  84         return sizeof(downcast&lt;SetMiterLimit&gt;(item));
  85     case ItemType::ClearShadow:
  86         return sizeof(downcast&lt;ClearShadow&gt;(item));
  87     case ItemType::Clip:
  88         return sizeof(downcast&lt;Clip&gt;(item));
  89     case ItemType::ClipOut:
  90         return sizeof(downcast&lt;ClipOut&gt;(item));
  91     case ItemType::ClipOutToPath:
  92         return sizeof(downcast&lt;ClipOutToPath&gt;(item));
</pre>
<hr />
<pre>
 158 #endif
 159     case ItemType::ApplyDeviceScaleFactor:
 160         return sizeof(downcast&lt;ApplyDeviceScaleFactor&gt;(item));
 161     }
 162     return 0;
 163 }
 164 
 165 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawingItem&amp; item)
 166 {
 167     ts.startGroup();
 168     ts &lt;&lt; &quot;extent &quot;;
 169     if (item.extentKnown())
 170         ts &lt;&lt; item.extent();
 171     else
 172         ts &lt;&lt; &quot;unknown&quot;;
 173 
 174     ts.endGroup();
 175     return ts;
 176 }
 177 
<span class="line-added"> 178 DrawingItem::DrawingItem(ItemType type)</span>
<span class="line-added"> 179     : Item(type)</span>
<span class="line-added"> 180 {</span>
<span class="line-added"> 181 }</span>
<span class="line-added"> 182 </span>
<span class="line-added"> 183 DrawingItem::~DrawingItem() = default;</span>
<span class="line-added"> 184 </span>
<span class="line-added"> 185 Save::Save()</span>
<span class="line-added"> 186     : Item(ItemType::Save)</span>
<span class="line-added"> 187 {</span>
<span class="line-added"> 188 }</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190 Save::~Save() = default;</span>
<span class="line-added"> 191 </span>
 192 void Save::apply(GraphicsContext&amp; context) const
 193 {
 194     context.save();
 195 }
 196 
 197 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Save&amp; item)
 198 {
 199     ts.dumpProperty(&quot;restore-index&quot;, item.restoreIndex());
 200     return ts;
 201 }
 202 
<span class="line-added"> 203 Restore::Restore()</span>
<span class="line-added"> 204     : Item(ItemType::Restore)</span>
<span class="line-added"> 205 {</span>
<span class="line-added"> 206 }</span>
<span class="line-added"> 207 </span>
<span class="line-added"> 208 Restore::~Restore() = default;</span>
<span class="line-added"> 209 </span>
 210 void Restore::apply(GraphicsContext&amp; context) const
 211 {
 212     context.restore();
 213 }
 214 
<span class="line-added"> 215 Translate::Translate(float x, float y)</span>
<span class="line-added"> 216     : Item(ItemType::Translate)</span>
<span class="line-added"> 217     , m_x(x)</span>
<span class="line-added"> 218     , m_y(y)</span>
<span class="line-added"> 219 {</span>
<span class="line-added"> 220 }</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222 Translate::~Translate() = default;</span>
<span class="line-added"> 223 </span>
 224 void Translate::apply(GraphicsContext&amp; context) const
 225 {
 226     context.translate(m_x, m_y);
 227 }
 228 
 229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Translate&amp; item)
 230 {
 231     ts.dumpProperty(&quot;x&quot;, item.x());
 232     ts.dumpProperty(&quot;y&quot;, item.y());
 233 
 234     return ts;
 235 }
 236 
<span class="line-added"> 237 Rotate::Rotate(float angle)</span>
<span class="line-added"> 238     : Item(ItemType::Rotate)</span>
<span class="line-added"> 239     , m_angle(angle)</span>
<span class="line-added"> 240 {</span>
<span class="line-added"> 241 }</span>
<span class="line-added"> 242 </span>
<span class="line-added"> 243 Rotate::~Rotate() = default;</span>
<span class="line-added"> 244 </span>
 245 void Rotate::apply(GraphicsContext&amp; context) const
 246 {
 247     context.rotate(m_angle);
 248 }
 249 
 250 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Rotate&amp; item)
 251 {
 252     ts.dumpProperty(&quot;angle&quot;, item.angle());
 253 
 254     return ts;
 255 }
 256 
<span class="line-added"> 257 Scale::Scale(const FloatSize&amp; size)</span>
<span class="line-added"> 258     : Item(ItemType::Scale)</span>
<span class="line-added"> 259     , m_size(size)</span>
<span class="line-added"> 260 {</span>
<span class="line-added"> 261 }</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263 Scale::~Scale() = default;</span>
<span class="line-added"> 264 </span>
 265 void Scale::apply(GraphicsContext&amp; context) const
 266 {
 267     context.scale(m_size);
 268 }
 269 
 270 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Scale&amp; item)
 271 {
 272     ts.dumpProperty(&quot;size&quot;, item.amount());
 273 
 274     return ts;
 275 }
 276 
<span class="line-added"> 277 SetCTM::SetCTM(const AffineTransform&amp; transform)</span>
<span class="line-added"> 278     : Item(ItemType::SetCTM)</span>
<span class="line-added"> 279     , m_transform(transform)</span>
<span class="line-added"> 280 {</span>
<span class="line-added"> 281 }</span>
<span class="line-added"> 282 </span>
<span class="line-added"> 283 SetCTM::~SetCTM() = default;</span>
<span class="line-added"> 284 </span>
<span class="line-added"> 285 void SetCTM::apply(GraphicsContext&amp; context) const</span>
<span class="line-added"> 286 {</span>
<span class="line-added"> 287     context.setCTM(m_transform);</span>
<span class="line-added"> 288 }</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetCTM&amp; item)</span>
<span class="line-added"> 291 {</span>
<span class="line-added"> 292     ts.dumpProperty(&quot;set-ctm&quot;, item.transform());</span>
<span class="line-added"> 293 </span>
<span class="line-added"> 294     return ts;</span>
<span class="line-added"> 295 }</span>
<span class="line-added"> 296 </span>
 297 ConcatenateCTM::ConcatenateCTM(const AffineTransform&amp; transform)
 298     : Item(ItemType::ConcatenateCTM)
 299     , m_transform(transform)
 300 {
 301 }
 302 
<span class="line-added"> 303 ConcatenateCTM::~ConcatenateCTM() = default;</span>
<span class="line-added"> 304 </span>
 305 void ConcatenateCTM::apply(GraphicsContext&amp; context) const
 306 {
 307     context.concatCTM(m_transform);
 308 }
 309 
 310 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ConcatenateCTM&amp; item)
 311 {
 312     ts.dumpProperty(&quot;ctm&quot;, item.transform());
 313 
 314     return ts;
 315 }
 316 
<span class="line-added"> 317 SetState::SetState(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)</span>
<span class="line-added"> 318     : Item(ItemType::SetState)</span>
<span class="line-added"> 319     , m_state(state, flags)</span>
<span class="line-added"> 320 {</span>
<span class="line-added"> 321 }</span>
<span class="line-added"> 322 </span>
<span class="line-added"> 323 SetState::SetState(const GraphicsContextStateChange&amp; stateChange)</span>
<span class="line-added"> 324     : Item(ItemType::SetState)</span>
<span class="line-added"> 325     , m_state(stateChange)</span>
<span class="line-added"> 326 {</span>
<span class="line-added"> 327 }</span>
<span class="line-added"> 328 </span>
<span class="line-added"> 329 SetState::~SetState() = default;</span>
<span class="line-added"> 330 </span>
 331 void SetState::apply(GraphicsContext&amp; context) const
 332 {
 333     m_state.apply(context);
 334 }
 335 
 336 void SetState::accumulate(const GraphicsContextState&amp; state, GraphicsContextState::StateChangeFlags flags)
 337 {
 338     m_state.accumulate(state, flags);
 339 }
 340 
 341 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetState&amp; state)
 342 {
 343     ts &lt;&lt; state.state();
 344     return ts;
 345 }
 346 
<span class="line-added"> 347 SetLineCap::SetLineCap(LineCap lineCap)</span>
<span class="line-added"> 348     : Item(ItemType::SetLineCap)</span>
<span class="line-added"> 349     , m_lineCap(lineCap)</span>
<span class="line-added"> 350 {</span>
<span class="line-added"> 351 }</span>
<span class="line-added"> 352 </span>
<span class="line-added"> 353 SetLineCap::~SetLineCap() = default;</span>
<span class="line-added"> 354 </span>
 355 void SetLineCap::apply(GraphicsContext&amp; context) const
 356 {
 357     context.setLineCap(m_lineCap);
 358 }
 359 
 360 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineCap&amp; lineCap)
 361 {
 362     ts.dumpProperty(&quot;line-cap&quot;, lineCap.lineCap());
 363     return ts;
 364 }
 365 
<span class="line-added"> 366 SetLineDash::SetLineDash(const DashArray&amp; dashArray, float dashOffset)</span>
<span class="line-added"> 367     : Item(ItemType::SetLineDash)</span>
<span class="line-added"> 368     , m_dashArray(dashArray)</span>
<span class="line-added"> 369     , m_dashOffset(dashOffset)</span>
<span class="line-added"> 370 {</span>
<span class="line-added"> 371 }</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373 SetLineDash::~SetLineDash() = default;</span>
<span class="line-added"> 374 </span>
 375 void SetLineDash::apply(GraphicsContext&amp; context) const
 376 {
 377     context.setLineDash(m_dashArray, m_dashOffset);
 378 }
 379 
 380 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineDash&amp; lineDash)
 381 {
 382     ts.dumpProperty(&quot;dash-array&quot;, lineDash.dashArray());
 383     ts.dumpProperty(&quot;dash-offset&quot;, lineDash.dashOffset());
 384     return ts;
 385 }
 386 
<span class="line-added"> 387 SetLineJoin::SetLineJoin(LineJoin lineJoin)</span>
<span class="line-added"> 388     : Item(ItemType::SetLineJoin)</span>
<span class="line-added"> 389     , m_lineJoin(lineJoin)</span>
<span class="line-added"> 390 {</span>
<span class="line-added"> 391 }</span>
<span class="line-added"> 392 </span>
<span class="line-added"> 393 SetLineJoin::~SetLineJoin() = default;</span>
<span class="line-added"> 394 </span>
 395 void SetLineJoin::apply(GraphicsContext&amp; context) const
 396 {
 397     context.setLineJoin(m_lineJoin);
 398 }
 399 
 400 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetLineJoin&amp; lineJoin)
 401 {
 402     ts.dumpProperty(&quot;line-join&quot;, lineJoin.lineJoin());
 403     return ts;
 404 }
 405 
<span class="line-added"> 406 SetMiterLimit::SetMiterLimit(float miterLimit)</span>
<span class="line-added"> 407     : Item(ItemType::SetMiterLimit)</span>
<span class="line-added"> 408     , m_miterLimit(miterLimit)</span>
<span class="line-added"> 409 {</span>
<span class="line-added"> 410 }</span>
<span class="line-added"> 411 </span>
<span class="line-added"> 412 SetMiterLimit::~SetMiterLimit() = default;</span>
<span class="line-added"> 413 </span>
 414 void SetMiterLimit::apply(GraphicsContext&amp; context) const
 415 {
 416     context.setMiterLimit(m_miterLimit);
 417 }
 418 
 419 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const SetMiterLimit&amp; miterLimit)
 420 {
 421     ts.dumpProperty(&quot;mitre-limit&quot;, miterLimit.miterLimit());
 422     return ts;
 423 }
 424 
<span class="line-added"> 425 ClearShadow::ClearShadow()</span>
<span class="line-added"> 426     : Item(ItemType::ClearShadow)</span>
<span class="line-added"> 427 {</span>
<span class="line-added"> 428 }</span>
<span class="line-added"> 429 </span>
<span class="line-added"> 430 ClearShadow::~ClearShadow() = default;</span>
<span class="line-added"> 431 </span>
 432 void ClearShadow::apply(GraphicsContext&amp; context) const
 433 {
 434     context.clearShadow();
 435 }
 436 
<span class="line-added"> 437 Clip::Clip(const FloatRect&amp; rect)</span>
<span class="line-added"> 438     : Item(ItemType::Clip)</span>
<span class="line-added"> 439     , m_rect(rect)</span>
<span class="line-added"> 440 {</span>
<span class="line-added"> 441 }</span>
<span class="line-added"> 442 </span>
<span class="line-added"> 443 Clip::~Clip() = default;</span>
<span class="line-added"> 444 </span>
 445 void Clip::apply(GraphicsContext&amp; context) const
 446 {
 447     context.clip(m_rect);
 448 }
 449 
 450 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Clip&amp; item)
 451 {
 452     ts.dumpProperty(&quot;rect&quot;, item.rect());
 453     return ts;
 454 }
 455 
<span class="line-added"> 456 ClipOut::ClipOut(const FloatRect&amp; rect)</span>
<span class="line-added"> 457     : Item(ItemType::ClipOut)</span>
<span class="line-added"> 458     , m_rect(rect)</span>
<span class="line-added"> 459 {</span>
<span class="line-added"> 460 }</span>
<span class="line-added"> 461 </span>
<span class="line-added"> 462 ClipOut::~ClipOut() = default;</span>
<span class="line-added"> 463 </span>
 464 void ClipOut::apply(GraphicsContext&amp; context) const
 465 {
 466     context.clipOut(m_rect);
 467 }
 468 
 469 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOut&amp; item)
 470 {
 471     ts.dumpProperty(&quot;rect&quot;, item.rect());
 472     return ts;
 473 }
 474 
<span class="line-added"> 475 ClipOutToPath::ClipOutToPath(const Path&amp; path)</span>
<span class="line-added"> 476     : Item(ItemType::ClipOutToPath)</span>
<span class="line-added"> 477     , m_path(path)</span>
<span class="line-added"> 478 {</span>
<span class="line-added"> 479 }</span>
<span class="line-added"> 480 </span>
<span class="line-added"> 481 ClipOutToPath::~ClipOutToPath() = default;</span>
<span class="line-added"> 482 </span>
 483 void ClipOutToPath::apply(GraphicsContext&amp; context) const
 484 {
 485     context.clipOut(m_path);
 486 }
 487 
 488 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipOutToPath&amp; item)
 489 {
 490     ts.dumpProperty(&quot;path&quot;, item.path());
 491     return ts;
 492 }
 493 
<span class="line-added"> 494 ClipPath::ClipPath(const Path&amp; path, WindRule windRule)</span>
<span class="line-added"> 495     : Item(ItemType::ClipPath)</span>
<span class="line-added"> 496     , m_path(path)</span>
<span class="line-added"> 497     , m_windRule(windRule)</span>
<span class="line-added"> 498 {</span>
<span class="line-added"> 499 }</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501 ClipPath::~ClipPath() = default;</span>
<span class="line-added"> 502 </span>
 503 void ClipPath::apply(GraphicsContext&amp; context) const
 504 {
 505     context.clipPath(m_path, m_windRule);
 506 }
 507 
 508 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClipPath&amp; item)
 509 {
 510     ts.dumpProperty(&quot;path&quot;, item.path());
 511     ts.dumpProperty(&quot;wind-rule&quot;, item.windRule());
 512     return ts;
 513 }
 514 
<span class="line-added"> 515 DrawGlyphs::DrawGlyphs(const Font&amp; font, Vector&lt;GlyphBufferGlyph, 128&gt;&amp;&amp; glyphs, Vector&lt;GlyphBufferAdvance, 128&gt;&amp;&amp; advances, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)</span>
<span class="line-added"> 516     : DrawingItem(ItemType::DrawGlyphs)</span>
<span class="line-added"> 517     , m_font(const_cast&lt;Font&amp;&gt;(font))</span>
<span class="line-added"> 518     , m_glyphs(WTFMove(glyphs))</span>
<span class="line-added"> 519     , m_advances(WTFMove(advances))</span>
<span class="line-added"> 520     , m_blockLocation(blockLocation)</span>
<span class="line-added"> 521     , m_localAnchor(localAnchor)</span>
<span class="line-added"> 522     , m_smoothingMode(smoothingMode)</span>
<span class="line-added"> 523 {</span>
<span class="line-added"> 524     computeBounds();</span>
<span class="line-added"> 525 }</span>
<span class="line-added"> 526 </span>
 527 DrawGlyphs::DrawGlyphs(const Font&amp; font, const GlyphBufferGlyph* glyphs, const GlyphBufferAdvance* advances, unsigned count, const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, FontSmoothingMode smoothingMode)
 528     : DrawingItem(ItemType::DrawGlyphs)
 529     , m_font(const_cast&lt;Font&amp;&gt;(font))
 530     , m_blockLocation(blockLocation)
 531     , m_localAnchor(localAnchor)
 532     , m_smoothingMode(smoothingMode)
 533 {
 534     m_glyphs.reserveInitialCapacity(count);
 535     m_advances.reserveInitialCapacity(count);
 536     for (unsigned i = 0; i &lt; count; ++i) {
 537         m_glyphs.uncheckedAppend(glyphs[i]);
 538         m_advances.uncheckedAppend(advances[i]);
 539     }
 540     computeBounds();
 541 }
 542 
<span class="line-added"> 543 DrawGlyphs::~DrawGlyphs() = default;</span>
<span class="line-added"> 544 </span>
 545 inline GlyphBuffer DrawGlyphs::generateGlyphBuffer() const
 546 {
 547     GlyphBuffer result;
 548     for (size_t i = 0; i &lt; m_glyphs.size(); ++i) {
 549         result.add(m_glyphs[i], &amp;m_font.get(), m_advances[i], GlyphBuffer::noOffset);
 550     }
 551     return result;
 552 }
 553 
 554 void DrawGlyphs::apply(GraphicsContext&amp; context) const
 555 {
 556     context.drawGlyphs(m_font, generateGlyphBuffer(), 0, m_glyphs.size(), anchorPoint(), m_smoothingMode);
 557 }
 558 
 559 void DrawGlyphs::computeBounds()
 560 {
 561     // FIXME: This code doesn&#39;t actually take the extents of the glyphs into consideration. It assumes that
 562     // the glyph lies entirely within its [(ascent + descent), advance] rect.
 563     float ascent = m_font-&gt;fontMetrics().floatAscent();
 564     float descent = m_font-&gt;fontMetrics().floatDescent();
</pre>
<hr />
<pre>
 584 {
 585     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 586     // FIXME: dump more stuff.
 587     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 588     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 589     ts.dumpProperty(&quot;anchor-point&quot;, item.anchorPoint());
 590     ts.dumpProperty(&quot;length&quot;, item.glyphs().size());
 591 
 592     return ts;
 593 }
 594 
 595 DrawImage::DrawImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const ImagePaintingOptions&amp; imagePaintingOptions)
 596     : DrawingItem(ItemType::DrawImage)
 597     , m_image(image)
 598     , m_destination(destination)
 599     , m_source(source)
 600     , m_imagePaintingOptions(imagePaintingOptions)
 601 {
 602 }
 603 
<span class="line-added"> 604 DrawImage::~DrawImage() = default;</span>
<span class="line-added"> 605 </span>
 606 void DrawImage::apply(GraphicsContext&amp; context) const
 607 {
 608     context.drawImage(m_image.get(), m_destination, m_source, m_imagePaintingOptions);
 609 }
 610 
 611 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawImage&amp; item)
 612 {
 613     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 614     ts.dumpProperty(&quot;image&quot;, item.image());
 615     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 616     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 617     return ts;
 618 }
 619 
 620 DrawTiledImage::DrawTiledImage(Image&amp; image, const FloatRect&amp; destination, const FloatPoint&amp; source, const FloatSize&amp; tileSize, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; imagePaintingOptions)
 621     : DrawingItem(ItemType::DrawTiledImage)
 622     , m_image(image)
 623     , m_destination(destination)
 624     , m_source(source)
 625     , m_tileSize(tileSize)
 626     , m_spacing(spacing)
 627     , m_imagePaintingOptions(imagePaintingOptions)
 628 {
 629 }
 630 
<span class="line-added"> 631 DrawTiledImage::~DrawTiledImage() = default;</span>
<span class="line-added"> 632 </span>
 633 void DrawTiledImage::apply(GraphicsContext&amp; context) const
 634 {
 635     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileSize, m_spacing, m_imagePaintingOptions);
 636 }
 637 
 638 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledImage&amp; item)
 639 {
 640     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 641     ts.dumpProperty(&quot;image&quot;, item.image());
 642     ts.dumpProperty(&quot;source-point&quot;, item.source());
 643     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 644     ts.dumpProperty(&quot;tile-size&quot;, item.tileSize());
 645     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 646     return ts;
 647 }
 648 
 649 DrawTiledScaledImage::DrawTiledScaledImage(Image&amp; image, const FloatRect&amp; destination, const FloatRect&amp; source, const FloatSize&amp; tileScaleFactor, Image::TileRule hRule, Image::TileRule vRule, const ImagePaintingOptions&amp; imagePaintingOptions)
 650     : DrawingItem(ItemType::DrawTiledScaledImage)
 651     , m_image(image)
 652     , m_destination(destination)
 653     , m_source(source)
 654     , m_tileScaleFactor(tileScaleFactor)
 655     , m_hRule(hRule)
 656     , m_vRule(vRule)
 657     , m_imagePaintingOptions(imagePaintingOptions)
 658 {
 659 }
 660 
<span class="line-added"> 661 DrawTiledScaledImage::~DrawTiledScaledImage() = default;</span>
<span class="line-added"> 662 </span>
 663 void DrawTiledScaledImage::apply(GraphicsContext&amp; context) const
 664 {
 665     context.drawTiledImage(m_image.get(), m_destination, m_source, m_tileScaleFactor, m_hRule, m_vRule, m_imagePaintingOptions);
 666 }
 667 
 668 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawTiledScaledImage&amp; item)
 669 {
 670     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 671     ts.dumpProperty(&quot;image&quot;, item.image());
 672     ts.dumpProperty(&quot;source-rect&quot;, item.source());
 673     ts.dumpProperty(&quot;dest-rect&quot;, item.destination());
 674     return ts;
 675 }
 676 
 677 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)
 678 DrawNativeImage::DrawNativeImage(const NativeImagePtr&amp; image, const FloatSize&amp; imageSize, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
 679     : DrawingItem(ItemType::DrawNativeImage)
 680 #if USE(CG)
 681     // FIXME: Need to store an image for Cairo.
 682     , m_image(image)
 683 #endif
 684     , m_imageSize(imageSize)
<span class="line-modified"> 685     , m_destinationRect(destRect)</span>
 686     , m_srcRect(srcRect)
 687     , m_options(options)
 688 {
 689 #if !USE(CG)
 690     UNUSED_PARAM(image);
 691 #endif
 692 }
 693 
<span class="line-added"> 694 DrawNativeImage::~DrawNativeImage() = default;</span>
<span class="line-added"> 695 </span>
 696 void DrawNativeImage::apply(GraphicsContext&amp; context) const
 697 {
 698 #if USE(CG)
<span class="line-modified"> 699     context.drawNativeImage(m_image, m_imageSize, m_destinationRect, m_srcRect, m_options);</span>
 700 #else
 701     UNUSED_PARAM(context);
 702 #endif
 703 }
 704 
 705 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawNativeImage&amp; item)
 706 {
 707     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 708     // FIXME: dump more stuff.
 709     ts.dumpProperty(&quot;source-rect&quot;, item.source());
<span class="line-modified"> 710     ts.dumpProperty(&quot;dest-rect&quot;, item.destinationRect());</span>
 711     return ts;
 712 }
 713 #endif
 714 
 715 DrawPattern::DrawPattern(Image&amp; image, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; patternTransform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
 716     : DrawingItem(ItemType::DrawPattern)
 717     , m_image(image)
 718     , m_patternTransform(patternTransform)
 719     , m_tileRect(tileRect)
 720     , m_destination(destRect)
 721     , m_phase(phase)
 722     , m_spacing(spacing)
 723     , m_options(options)
 724 {
 725 }
 726 
<span class="line-added"> 727 DrawPattern::~DrawPattern() = default;</span>
<span class="line-added"> 728 </span>
 729 void DrawPattern::apply(GraphicsContext&amp; context) const
 730 {
 731     context.drawPattern(m_image.get(), m_destination, m_tileRect, m_patternTransform, m_phase, m_spacing, m_options);
 732 }
 733 
 734 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPattern&amp; item)
 735 {
 736     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 737     ts.dumpProperty(&quot;image&quot;, item.image());
 738     ts.dumpProperty(&quot;pattern-transform&quot;, item.patternTransform());
 739     ts.dumpProperty(&quot;tile-rect&quot;, item.tileRect());
 740     ts.dumpProperty(&quot;dest-rect&quot;, item.destRect());
 741     ts.dumpProperty(&quot;phase&quot;, item.phase());
 742     ts.dumpProperty(&quot;spacing&quot;, item.spacing());
 743     return ts;
 744 }
 745 
<span class="line-added"> 746 DrawRect::DrawRect(const FloatRect&amp; rect, float borderThickness)</span>
<span class="line-added"> 747     : DrawingItem(ItemType::DrawRect)</span>
<span class="line-added"> 748     , m_rect(rect)</span>
<span class="line-added"> 749     , m_borderThickness(borderThickness)</span>
<span class="line-added"> 750 {</span>
<span class="line-added"> 751 }</span>
<span class="line-added"> 752 </span>
<span class="line-added"> 753 DrawRect::~DrawRect() = default;</span>
<span class="line-added"> 754 </span>
 755 void DrawRect::apply(GraphicsContext&amp; context) const
 756 {
 757     context.drawRect(m_rect, m_borderThickness);
 758 }
 759 
 760 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawRect&amp; item)
 761 {
 762     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 763     ts.dumpProperty(&quot;rect&quot;, item.rect());
 764     ts.dumpProperty(&quot;border-thickness&quot;, item.borderThickness());
 765     return ts;
 766 }
 767 
<span class="line-added"> 768 DrawLine::DrawLine(const FloatPoint&amp; point1, const FloatPoint&amp; point2)</span>
<span class="line-added"> 769     : DrawingItem(ItemType::DrawLine)</span>
<span class="line-added"> 770     , m_point1(point1)</span>
<span class="line-added"> 771     , m_point2(point2)</span>
<span class="line-added"> 772 {</span>
<span class="line-added"> 773 }</span>
<span class="line-added"> 774 </span>
<span class="line-added"> 775 DrawLine::~DrawLine() = default;</span>
<span class="line-added"> 776 </span>
 777 Optional&lt;FloatRect&gt; DrawLine::localBounds(const GraphicsContext&amp;) const
 778 {
 779     FloatRect bounds;
 780     bounds.fitToPoints(m_point1, m_point2);
 781     return bounds;
 782 }
 783 
 784 void DrawLine::apply(GraphicsContext&amp; context) const
 785 {
 786     context.drawLine(m_point1, m_point2);
 787 }
 788 
 789 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLine&amp; item)
 790 {
 791     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 792     ts.dumpProperty(&quot;point-1&quot;, item.point1());
 793     ts.dumpProperty(&quot;point-2&quot;, item.point2());
 794     return ts;
 795 }
 796 
<span class="line-added"> 797 DrawLinesForText::DrawLinesForText(const FloatPoint&amp; blockLocation, const FloatSize&amp; localAnchor, float thickness, const DashArray&amp; widths, bool printing, bool doubleLines)</span>
<span class="line-added"> 798     : DrawingItem(ItemType::DrawLinesForText)</span>
<span class="line-added"> 799     , m_blockLocation(blockLocation)</span>
<span class="line-added"> 800     , m_localAnchor(localAnchor)</span>
<span class="line-added"> 801     , m_widths(widths)</span>
<span class="line-added"> 802     , m_thickness(thickness)</span>
<span class="line-added"> 803     , m_printing(printing)</span>
<span class="line-added"> 804     , m_doubleLines(doubleLines)</span>
<span class="line-added"> 805 {</span>
<span class="line-added"> 806 }</span>
<span class="line-added"> 807 </span>
<span class="line-added"> 808 DrawLinesForText::~DrawLinesForText() = default;</span>
<span class="line-added"> 809 </span>
 810 void DrawLinesForText::apply(GraphicsContext&amp; context) const
 811 {
 812     context.drawLinesForText(point(), m_thickness, m_widths, m_printing, m_doubleLines);
 813 }
 814 
 815 Optional&lt;FloatRect&gt; DrawLinesForText::localBounds(const GraphicsContext&amp;) const
 816 {
 817     // This function needs to return a value equal to or enclosing what GraphicsContext::computeLineBoundsAndAntialiasingModeForText() returns.
 818 
 819     if (!m_widths.size())
 820         return FloatRect();
 821 
 822     FloatRect result(point(), FloatSize(m_widths.last(), m_thickness));
 823     result.inflate(1); // Account for pixel snapping. FIXME: This isn&#39;t perfect, as it doesn&#39;t take the CTM into account.
 824     return result;
 825 }
 826 
 827 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawLinesForText&amp; item)
 828 {
 829     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 830     ts.dumpProperty(&quot;block-location&quot;, item.blockLocation());
 831     ts.dumpProperty(&quot;local-anchor&quot;, item.localAnchor());
 832     ts.dumpProperty(&quot;point&quot;, item.point());
 833     ts.dumpProperty(&quot;thickness&quot;, item.thickness());
 834     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 835     ts.dumpProperty(&quot;widths&quot;, item.widths());
 836     ts.dumpProperty(&quot;is-printing&quot;, item.isPrinting());
 837     ts.dumpProperty(&quot;double&quot;, item.doubleLines());
 838     return ts;
 839 }
 840 
<span class="line-added"> 841 DrawDotsForDocumentMarker::DrawDotsForDocumentMarker(const FloatRect&amp; rect, DocumentMarkerLineStyle style)</span>
<span class="line-added"> 842     : DrawingItem(ItemType::DrawDotsForDocumentMarker)</span>
<span class="line-added"> 843     , m_rect(rect)</span>
<span class="line-added"> 844     , m_style(style)</span>
<span class="line-added"> 845 {</span>
<span class="line-added"> 846 }</span>
<span class="line-added"> 847 </span>
<span class="line-added"> 848 DrawDotsForDocumentMarker::~DrawDotsForDocumentMarker() = default;</span>
<span class="line-added"> 849 </span>
 850 void DrawDotsForDocumentMarker::apply(GraphicsContext&amp; context) const
 851 {
 852     context.drawDotsForDocumentMarker(m_rect, m_style);
 853 }
 854 
 855 Optional&lt;FloatRect&gt; DrawDotsForDocumentMarker::localBounds(const GraphicsContext&amp;) const
 856 {
 857     return m_rect;
 858 }
 859 
 860 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawDotsForDocumentMarker&amp; item)
 861 {
 862     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 863     ts.dumpProperty(&quot;rect&quot;, item.rect());
 864     return ts;
 865 }
 866 
<span class="line-added"> 867 DrawEllipse::DrawEllipse(const FloatRect&amp; rect)</span>
<span class="line-added"> 868     : DrawingItem(ItemType::DrawEllipse)</span>
<span class="line-added"> 869     , m_rect(rect)</span>
<span class="line-added"> 870 {</span>
<span class="line-added"> 871 }</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873 DrawEllipse::~DrawEllipse() = default;</span>
<span class="line-added"> 874 </span>
 875 void DrawEllipse::apply(GraphicsContext&amp; context) const
 876 {
 877     context.drawEllipse(m_rect);
 878 }
 879 
 880 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawEllipse&amp; item)
 881 {
 882     ts.dumpProperty(&quot;rect&quot;, item.rect());
 883     return ts;
 884 }
 885 
<span class="line-added"> 886 DrawPath::DrawPath(const Path&amp; path)</span>
<span class="line-added"> 887     : DrawingItem(ItemType::DrawPath)</span>
<span class="line-added"> 888     , m_path(path)</span>
<span class="line-added"> 889 {</span>
<span class="line-added"> 890 }</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892 DrawPath::~DrawPath() = default;</span>
<span class="line-added"> 893 </span>
 894 void DrawPath::apply(GraphicsContext&amp; context) const
 895 {
 896 #if USE(CG)
 897     context.drawPath(m_path);
 898 #else
 899     UNUSED_PARAM(context);
 900 #endif
 901 }
 902 
 903 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawPath&amp; item)
 904 {
 905     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 906 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 907     return ts;
 908 }
 909 
<span class="line-added"> 910 DrawFocusRingPath::DrawFocusRingPath(const Path&amp; path, float width, float offset, const Color&amp; color)</span>
<span class="line-added"> 911     : DrawingItem(ItemType::DrawFocusRingPath)</span>
<span class="line-added"> 912     , m_path(path)</span>
<span class="line-added"> 913     , m_width(width)</span>
<span class="line-added"> 914     , m_offset(offset)</span>
<span class="line-added"> 915     , m_color(color)</span>
<span class="line-added"> 916 {</span>
<span class="line-added"> 917 }</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919 DrawFocusRingPath::~DrawFocusRingPath() = default;</span>
<span class="line-added"> 920 </span>
 921 void DrawFocusRingPath::apply(GraphicsContext&amp; context) const
 922 {
 923     context.drawFocusRing(m_path, m_width, m_offset, m_color);
 924 }
 925 
 926 Optional&lt;FloatRect&gt; DrawFocusRingPath::localBounds(const GraphicsContext&amp;) const
 927 {
 928     FloatRect result = m_path.fastBoundingRect();
 929     result.inflate(platformFocusRingWidth);
 930     return result;
 931 }
 932 
 933 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingPath&amp; item)
 934 {
 935     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 936 //    ts.dumpProperty(&quot;path&quot;, item.path()); // FIXME: add logging for paths.
 937     ts.dumpProperty(&quot;width&quot;, item.width());
 938     ts.dumpProperty(&quot;offset&quot;, item.offset());
 939     ts.dumpProperty(&quot;color&quot;, item.color());
 940     return ts;
 941 }
 942 
<span class="line-added"> 943 DrawFocusRingRects::DrawFocusRingRects(const Vector&lt;FloatRect&gt;&amp; rects, float width, float offset, const Color&amp; color)</span>
<span class="line-added"> 944     : DrawingItem(ItemType::DrawFocusRingRects)</span>
<span class="line-added"> 945     , m_rects(rects)</span>
<span class="line-added"> 946     , m_width(width)</span>
<span class="line-added"> 947     , m_offset(offset)</span>
<span class="line-added"> 948     , m_color(color)</span>
<span class="line-added"> 949 {</span>
<span class="line-added"> 950 }</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952 DrawFocusRingRects::~DrawFocusRingRects() = default;</span>
<span class="line-added"> 953 </span>
 954 void DrawFocusRingRects::apply(GraphicsContext&amp; context) const
 955 {
 956     context.drawFocusRing(m_rects, m_width, m_offset, m_color);
 957 }
 958 
 959 Optional&lt;FloatRect&gt; DrawFocusRingRects::localBounds(const GraphicsContext&amp;) const
 960 {
 961     FloatRect result;
 962     for (auto&amp; rect : m_rects)
 963         result.unite(rect);
 964     result.inflate(platformFocusRingWidth);
 965     return result;
 966 }
 967 
 968 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const DrawFocusRingRects&amp; item)
 969 {
 970     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 971     ts.dumpProperty(&quot;rects&quot;, item.rects());
 972     ts.dumpProperty(&quot;width&quot;, item.width());
 973     ts.dumpProperty(&quot;offset&quot;, item.offset());
 974     ts.dumpProperty(&quot;color&quot;, item.color());
 975     return ts;
 976 }
 977 
<span class="line-added"> 978 FillRect::FillRect(const FloatRect&amp; rect)</span>
<span class="line-added"> 979     : DrawingItem(ItemType::FillRect)</span>
<span class="line-added"> 980     , m_rect(rect)</span>
<span class="line-added"> 981 {</span>
<span class="line-added"> 982 }</span>
<span class="line-added"> 983 </span>
<span class="line-added"> 984 FillRect::~FillRect() = default;</span>
<span class="line-added"> 985 </span>
 986 void FillRect::apply(GraphicsContext&amp; context) const
 987 {
 988     context.fillRect(m_rect);
 989 }
 990 
 991 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRect&amp; item)
 992 {
 993     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
 994     ts.dumpProperty(&quot;rect&quot;, item.rect());
 995     return ts;
 996 }
 997 
<span class="line-added"> 998 FillRectWithColor::FillRectWithColor(const FloatRect&amp; rect, const Color&amp; color)</span>
<span class="line-added"> 999     : DrawingItem(ItemType::FillRectWithColor)</span>
<span class="line-added">1000     , m_rect(rect)</span>
<span class="line-added">1001     , m_color(color)</span>
<span class="line-added">1002 {</span>
<span class="line-added">1003 }</span>
<span class="line-added">1004 </span>
<span class="line-added">1005 FillRectWithColor::~FillRectWithColor() = default;</span>
<span class="line-added">1006 </span>
1007 void FillRectWithColor::apply(GraphicsContext&amp; context) const
1008 {
1009     context.fillRect(m_rect, m_color);
1010 }
1011 
1012 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithColor&amp; item)
1013 {
1014     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1015     ts.dumpProperty(&quot;rect&quot;, item.rect());
1016     ts.dumpProperty(&quot;color&quot;, item.color());
1017     return ts;
1018 }
1019 
<span class="line-added">1020 FillRectWithGradient::FillRectWithGradient(const FloatRect&amp; rect, Gradient&amp; gradient)</span>
<span class="line-added">1021     : DrawingItem(ItemType::FillRectWithGradient)</span>
<span class="line-added">1022     , m_rect(rect)</span>
<span class="line-added">1023     , m_gradient(gradient)</span>
<span class="line-added">1024 {</span>
<span class="line-added">1025 }</span>
<span class="line-added">1026 </span>
<span class="line-added">1027 FillRectWithGradient::~FillRectWithGradient() = default;</span>
<span class="line-added">1028 </span>
1029 void FillRectWithGradient::apply(GraphicsContext&amp; context) const
1030 {
1031     context.fillRect(m_rect, m_gradient.get());
1032 }
1033 
1034 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithGradient&amp; item)
1035 {
1036     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1037     // FIXME: log gradient.
1038     ts.dumpProperty(&quot;rect&quot;, item.rect());
1039     return ts;
1040 }
1041 
<span class="line-added">1042 FillCompositedRect::FillCompositedRect(const FloatRect&amp; rect, const Color&amp; color, CompositeOperator op, BlendMode blendMode)</span>
<span class="line-added">1043     : DrawingItem(ItemType::FillCompositedRect)</span>
<span class="line-added">1044     , m_rect(rect)</span>
<span class="line-added">1045     , m_color(color)</span>
<span class="line-added">1046     , m_op(op)</span>
<span class="line-added">1047     , m_blendMode(blendMode)</span>
<span class="line-added">1048 {</span>
<span class="line-added">1049 }</span>
<span class="line-added">1050 </span>
<span class="line-added">1051 FillCompositedRect::~FillCompositedRect() = default;</span>
<span class="line-added">1052 </span>
1053 void FillCompositedRect::apply(GraphicsContext&amp; context) const
1054 {
1055     context.fillRect(m_rect, m_color, m_op, m_blendMode);
1056 }
1057 
1058 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillCompositedRect&amp; item)
1059 {
1060     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1061     ts.dumpProperty(&quot;rect&quot;, item.rect());
1062     ts.dumpProperty(&quot;color&quot;, item.color());
1063     ts.dumpProperty(&quot;composite-operation&quot;, item.compositeOperator());
1064     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
1065     return ts;
1066 }
1067 
<span class="line-added">1068 FillRoundedRect::FillRoundedRect(const FloatRoundedRect&amp; rect, const Color&amp; color, BlendMode blendMode)</span>
<span class="line-added">1069     : DrawingItem(ItemType::FillRoundedRect)</span>
<span class="line-added">1070     , m_rect(rect)</span>
<span class="line-added">1071     , m_color(color)</span>
<span class="line-added">1072     , m_blendMode(blendMode)</span>
<span class="line-added">1073 {</span>
<span class="line-added">1074 }</span>
<span class="line-added">1075 </span>
<span class="line-added">1076 FillRoundedRect::~FillRoundedRect() = default;</span>
<span class="line-added">1077 </span>
1078 void FillRoundedRect::apply(GraphicsContext&amp; context) const
1079 {
1080     context.fillRoundedRect(m_rect, m_color, m_blendMode);
1081 }
1082 
1083 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRoundedRect&amp; item)
1084 {
1085     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1086     ts.dumpProperty(&quot;rect&quot;, item.roundedRect());
1087     ts.dumpProperty(&quot;color&quot;, item.color());
1088     ts.dumpProperty(&quot;blend-mode&quot;, item.blendMode());
1089     return ts;
1090 }
1091 
<span class="line-added">1092 FillRectWithRoundedHole::FillRectWithRoundedHole(const FloatRect&amp; rect, const FloatRoundedRect&amp; roundedHoleRect, const Color&amp; color)</span>
<span class="line-added">1093     : DrawingItem(ItemType::FillRectWithRoundedHole)</span>
<span class="line-added">1094     , m_rect(rect)</span>
<span class="line-added">1095     , m_roundedHoleRect(roundedHoleRect)</span>
<span class="line-added">1096     , m_color(color)</span>
<span class="line-added">1097 {</span>
<span class="line-added">1098 }</span>
<span class="line-added">1099 </span>
<span class="line-added">1100 FillRectWithRoundedHole::~FillRectWithRoundedHole() = default;</span>
<span class="line-added">1101 </span>
1102 void FillRectWithRoundedHole::apply(GraphicsContext&amp; context) const
1103 {
1104     context.fillRectWithRoundedHole(m_rect, m_roundedHoleRect, m_color);
1105 }
1106 
1107 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillRectWithRoundedHole&amp; item)
1108 {
1109     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1110     ts.dumpProperty(&quot;rect&quot;, item.rect());
1111     ts.dumpProperty(&quot;rounded-hole-rect&quot;, item.roundedHoleRect());
1112     ts.dumpProperty(&quot;color&quot;, item.color());
1113     return ts;
1114 }
1115 
<span class="line-added">1116 FillPath::FillPath(const Path&amp; path)</span>
<span class="line-added">1117     : DrawingItem(ItemType::FillPath)</span>
<span class="line-added">1118     , m_path(path)</span>
<span class="line-added">1119 {</span>
<span class="line-added">1120 }</span>
<span class="line-added">1121 </span>
<span class="line-added">1122 FillPath::~FillPath() = default;</span>
<span class="line-added">1123 </span>
1124 void FillPath::apply(GraphicsContext&amp; context) const
1125 {
1126     context.fillPath(m_path);
1127 }
1128 
1129 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillPath&amp; item)
1130 {
1131     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1132     ts.dumpProperty(&quot;path&quot;, item.path());
1133     return ts;
1134 }
1135 
<span class="line-added">1136 FillEllipse::FillEllipse(const FloatRect&amp; rect)</span>
<span class="line-added">1137     : DrawingItem(ItemType::FillEllipse)</span>
<span class="line-added">1138     , m_rect(rect)</span>
<span class="line-added">1139 {</span>
<span class="line-added">1140 }</span>
<span class="line-added">1141 </span>
<span class="line-added">1142 FillEllipse::~FillEllipse() = default;</span>
<span class="line-added">1143 </span>
1144 void FillEllipse::apply(GraphicsContext&amp; context) const
1145 {
1146     context.fillEllipse(m_rect);
1147 }
1148 
1149 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FillEllipse&amp; item)
1150 {
1151     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1152     ts.dumpProperty(&quot;rect&quot;, item.rect());
1153     return ts;
1154 }
1155 
<span class="line-added">1156 StrokeRect::StrokeRect(const FloatRect&amp; rect, float lineWidth)</span>
<span class="line-added">1157     : DrawingItem(ItemType::StrokeRect)</span>
<span class="line-added">1158     , m_rect(rect)</span>
<span class="line-added">1159     , m_lineWidth(lineWidth)</span>
<span class="line-added">1160 {</span>
<span class="line-added">1161 }</span>
<span class="line-added">1162 </span>
<span class="line-added">1163 StrokeRect::~StrokeRect() = default;</span>
<span class="line-added">1164 </span>
1165 Optional&lt;FloatRect&gt; StrokeRect::localBounds(const GraphicsContext&amp;) const
1166 {
1167     FloatRect bounds = m_rect;
1168     bounds.expand(m_lineWidth, m_lineWidth);
1169     return bounds;
1170 }
1171 
1172 void StrokeRect::apply(GraphicsContext&amp; context) const
1173 {
1174     context.strokeRect(m_rect, m_lineWidth);
1175 }
1176 
1177 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeRect&amp; item)
1178 {
1179     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1180     ts.dumpProperty(&quot;rect&quot;, item.rect());
1181     ts.dumpProperty(&quot;line-width&quot;, item.lineWidth());
1182     return ts;
1183 }
1184 
</pre>
<hr />
<pre>
1187     // FIXME: Need to take stroke thickness into account correctly, via CGPathByStrokingPath().
1188     float strokeThickness = context.strokeThickness();
1189 
1190     FloatRect bounds = m_path.boundingRect();
1191     bounds.expand(strokeThickness, strokeThickness);
1192     return bounds;
1193 }
1194 
1195 void StrokePath::apply(GraphicsContext&amp; context) const
1196 {
1197     context.strokePath(m_path);
1198 }
1199 
1200 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokePath&amp; item)
1201 {
1202     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1203     ts.dumpProperty(&quot;path&quot;, item.path());
1204     return ts;
1205 }
1206 
<span class="line-added">1207 StrokeEllipse::StrokeEllipse(const FloatRect&amp; rect)</span>
<span class="line-added">1208     : DrawingItem(ItemType::StrokeEllipse)</span>
<span class="line-added">1209     , m_rect(rect)</span>
<span class="line-added">1210 {</span>
<span class="line-added">1211 }</span>
<span class="line-added">1212 </span>
<span class="line-added">1213 StrokeEllipse::~StrokeEllipse() = default;</span>
<span class="line-added">1214 </span>
1215 Optional&lt;FloatRect&gt; StrokeEllipse::localBounds(const GraphicsContext&amp; context) const
1216 {
1217     float strokeThickness = context.strokeThickness();
1218 
1219     FloatRect bounds = m_rect;
1220     bounds.expand(strokeThickness, strokeThickness);
1221     return bounds;
1222 }
1223 
1224 void StrokeEllipse::apply(GraphicsContext&amp; context) const
1225 {
1226     context.strokeEllipse(m_rect);
1227 }
1228 
1229 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const StrokeEllipse&amp; item)
1230 {
1231     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1232     ts.dumpProperty(&quot;rect&quot;, item.rect());
1233     return ts;
1234 }
1235 
<span class="line-added">1236 StrokePath::StrokePath(const Path&amp; path)</span>
<span class="line-added">1237     : DrawingItem(ItemType::StrokePath)</span>
<span class="line-added">1238     , m_path(path)</span>
<span class="line-added">1239 {</span>
<span class="line-added">1240 }</span>
<span class="line-added">1241 </span>
<span class="line-added">1242 StrokePath::~StrokePath() = default;</span>
<span class="line-added">1243 </span>
<span class="line-added">1244 ClearRect::ClearRect(const FloatRect&amp; rect)</span>
<span class="line-added">1245     : DrawingItem(ItemType::ClearRect)</span>
<span class="line-added">1246     , m_rect(rect)</span>
<span class="line-added">1247 {</span>
<span class="line-added">1248 }</span>
<span class="line-added">1249 </span>
<span class="line-added">1250 ClearRect::~ClearRect() = default;</span>
<span class="line-added">1251 </span>
1252 void ClearRect::apply(GraphicsContext&amp; context) const
1253 {
1254     context.clearRect(m_rect);
1255 }
1256 
1257 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ClearRect&amp; item)
1258 {
1259     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1260     ts.dumpProperty(&quot;rect&quot;, item.rect());
1261     return ts;
1262 }
1263 
<span class="line-added">1264 BeginTransparencyLayer::BeginTransparencyLayer(float opacity)</span>
<span class="line-added">1265     : DrawingItem(ItemType::BeginTransparencyLayer)</span>
<span class="line-added">1266     , m_opacity(opacity)</span>
<span class="line-added">1267 {</span>
<span class="line-added">1268 }</span>
<span class="line-added">1269 </span>
<span class="line-added">1270 BeginTransparencyLayer::~BeginTransparencyLayer() = default;</span>
<span class="line-added">1271 </span>
1272 void BeginTransparencyLayer::apply(GraphicsContext&amp; context) const
1273 {
1274     context.beginTransparencyLayer(m_opacity);
1275 }
1276 
1277 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BeginTransparencyLayer&amp; item)
1278 {
1279     ts &lt;&lt; static_cast&lt;const DrawingItem&amp;&gt;(item);
1280     ts.dumpProperty(&quot;opacity&quot;, item.opacity());
1281     return ts;
1282 }
1283 
<span class="line-added">1284 EndTransparencyLayer::EndTransparencyLayer()</span>
<span class="line-added">1285     : DrawingItem(ItemType::EndTransparencyLayer)</span>
<span class="line-added">1286 {</span>
<span class="line-added">1287 }</span>
<span class="line-added">1288 </span>
<span class="line-added">1289 EndTransparencyLayer::~EndTransparencyLayer() = default;</span>
<span class="line-added">1290 </span>
1291 void EndTransparencyLayer::apply(GraphicsContext&amp; context) const
1292 {
1293     context.endTransparencyLayer();
1294 }
1295 
1296 #if USE(CG)
<span class="line-added">1297 ApplyStrokePattern::ApplyStrokePattern()</span>
<span class="line-added">1298     : Item(ItemType::ApplyStrokePattern)</span>
<span class="line-added">1299 {</span>
<span class="line-added">1300 }</span>
<span class="line-added">1301 </span>
<span class="line-added">1302 ApplyStrokePattern::~ApplyStrokePattern() = default;</span>
<span class="line-added">1303 </span>
1304 void ApplyStrokePattern::apply(GraphicsContext&amp; context) const
1305 {
1306     context.applyStrokePattern();
1307 }
1308 
<span class="line-added">1309 ApplyFillPattern::ApplyFillPattern()</span>
<span class="line-added">1310     : Item(ItemType::ApplyFillPattern)</span>
<span class="line-added">1311 {</span>
<span class="line-added">1312 }</span>
<span class="line-added">1313 </span>
<span class="line-added">1314 ApplyFillPattern::~ApplyFillPattern() = default;</span>
<span class="line-added">1315 </span>
1316 void ApplyFillPattern::apply(GraphicsContext&amp; context) const
1317 {
1318     context.applyFillPattern();
1319 }
1320 #endif
1321 
<span class="line-added">1322 ApplyDeviceScaleFactor::ApplyDeviceScaleFactor(float scaleFactor)</span>
<span class="line-added">1323     : Item(ItemType::ApplyDeviceScaleFactor)</span>
<span class="line-added">1324     , m_scaleFactor(scaleFactor)</span>
<span class="line-added">1325 {</span>
<span class="line-added">1326 }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328 ApplyDeviceScaleFactor::~ApplyDeviceScaleFactor() = default;</span>
<span class="line-added">1329 </span>
1330 void ApplyDeviceScaleFactor::apply(GraphicsContext&amp; context) const
1331 {
1332     context.applyDeviceScaleFactor(m_scaleFactor);
1333 }
1334 
1335 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ApplyDeviceScaleFactor&amp; item)
1336 {
1337     ts.dumpProperty(&quot;scale-factor&quot;, item.scaleFactor());
1338     return ts;
1339 }
1340 
1341 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ItemType&amp; type)
1342 {
1343     switch (type) {
1344     case ItemType::Save: ts &lt;&lt; &quot;save&quot;; break;
1345     case ItemType::Restore: ts &lt;&lt; &quot;restore&quot;; break;
1346     case ItemType::Translate: ts &lt;&lt; &quot;translate&quot;; break;
1347     case ItemType::Rotate: ts &lt;&lt; &quot;rotate&quot;; break;
1348     case ItemType::Scale: ts &lt;&lt; &quot;scale&quot;; break;
<span class="line-added">1349     case ItemType::SetCTM: ts &lt;&lt; &quot;set-ctm&quot;; break;</span>
1350     case ItemType::ConcatenateCTM: ts &lt;&lt; &quot;concatentate-ctm&quot;; break;
1351     case ItemType::SetState: ts &lt;&lt; &quot;set-state&quot;; break;
1352     case ItemType::SetLineCap: ts &lt;&lt; &quot;set-line-cap&quot;; break;
1353     case ItemType::SetLineDash: ts &lt;&lt; &quot;set-line-dash&quot;; break;
1354     case ItemType::SetLineJoin: ts &lt;&lt; &quot;set-line-join&quot;; break;
1355     case ItemType::SetMiterLimit: ts &lt;&lt; &quot;set-miter-limit&quot;; break;
1356     case ItemType::Clip: ts &lt;&lt; &quot;clip&quot;; break;
1357     case ItemType::ClipOut: ts &lt;&lt; &quot;clip-out&quot;; break;
1358     case ItemType::ClipOutToPath: ts &lt;&lt; &quot;clip-out-to-path&quot;; break;
1359     case ItemType::ClipPath: ts &lt;&lt; &quot;clip-path&quot;; break;
1360     case ItemType::DrawGlyphs: ts &lt;&lt; &quot;draw-glyphs&quot;; break;
1361     case ItemType::DrawImage: ts &lt;&lt; &quot;draw-image&quot;; break;
1362     case ItemType::DrawTiledImage: ts &lt;&lt; &quot;draw-tiled-image&quot;; break;
1363     case ItemType::DrawTiledScaledImage: ts &lt;&lt; &quot;draw-tiled-scaled-image&quot;; break;
1364 #if USE(CG) || USE(CAIRO)
1365     case ItemType::DrawNativeImage: ts &lt;&lt; &quot;draw-native-image&quot;; break;
1366 #endif
1367     case ItemType::DrawPattern: ts &lt;&lt; &quot;draw-pattern&quot;; break;
1368     case ItemType::DrawRect: ts &lt;&lt; &quot;draw-rect&quot;; break;
1369     case ItemType::DrawLine: ts &lt;&lt; &quot;draw-line&quot;; break;
</pre>
<hr />
<pre>
1399 
1400 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Item&amp; item)
1401 {
1402     TextStream::GroupScope group(ts);
1403     ts &lt;&lt; item.type();
1404 
1405     // FIXME: Make a macro which takes a macro for all these enumeration switches
1406     switch (item.type()) {
1407     case ItemType::Save:
1408         ts &lt;&lt; downcast&lt;Save&gt;(item);
1409         break;
1410     case ItemType::Translate:
1411         ts &lt;&lt; downcast&lt;Translate&gt;(item);
1412         break;
1413     case ItemType::Rotate:
1414         ts &lt;&lt; downcast&lt;Rotate&gt;(item);
1415         break;
1416     case ItemType::Scale:
1417         ts &lt;&lt; downcast&lt;Scale&gt;(item);
1418         break;
<span class="line-added">1419     case ItemType::SetCTM:</span>
<span class="line-added">1420         ts &lt;&lt; downcast&lt;SetCTM&gt;(item);</span>
<span class="line-added">1421         break;</span>
1422     case ItemType::ConcatenateCTM:
1423         ts &lt;&lt; downcast&lt;ConcatenateCTM&gt;(item);
1424         break;
1425     case ItemType::SetState:
1426         ts &lt;&lt; downcast&lt;SetState&gt;(item);
1427         break;
1428     case ItemType::SetLineCap:
1429         ts &lt;&lt; downcast&lt;SetLineCap&gt;(item);
1430         break;
1431     case ItemType::SetLineDash:
1432         ts &lt;&lt; downcast&lt;SetLineDash&gt;(item);
1433         break;
1434     case ItemType::SetLineJoin:
1435         ts &lt;&lt; downcast&lt;SetLineJoin&gt;(item);
1436         break;
1437     case ItemType::SetMiterLimit:
1438         ts &lt;&lt; downcast&lt;SetMiterLimit&gt;(item);
1439         break;
1440     case ItemType::Clip:
1441         ts &lt;&lt; downcast&lt;Clip&gt;(item);
</pre>
</td>
</tr>
</table>
<center><a href="DisplayList.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="DisplayListItems.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
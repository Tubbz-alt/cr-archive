diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVariableEventStream.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2012-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -31,20 +31,21 @@
 #include "CodeBlock.h"
 #include "DFGJITCode.h"
 #include "DFGValueSource.h"
 #include "InlineCallFrame.h"
 #include "JSCInlines.h"
+#include "OperandsInlines.h"
 #include <wtf/DataLog.h>
 #include <wtf/HashMap.h>
 
 namespace JSC { namespace DFG {
 
 void VariableEventStream::logEvent(const VariableEvent& event)
 {
     dataLogF("seq#%u:", static_cast<unsigned>(size()));
     event.dump(WTF::dataFile());
-    dataLogF(" ");
+    dataLogLn(" ");
 }
 
 namespace {
 
 struct MinifiedGenerationInfo {
@@ -117,68 +118,76 @@
 template<VariableEventStream::ReconstructionStyle style>
 unsigned VariableEventStream::reconstruct(
     CodeBlock* codeBlock, CodeOrigin codeOrigin, MinifiedGraph& graph,
     unsigned index, Operands<ValueRecovery>& valueRecoveries, Vector<UndefinedOperandSpan>* undefinedOperandSpans) const
 {
+    constexpr bool verbose = false;
     ASSERT(codeBlock->jitType() == JITType::DFGJIT);
     CodeBlock* baselineCodeBlock = codeBlock->baselineVersion();
 
     unsigned numVariables;
-    static const unsigned invalidIndex = std::numeric_limits<unsigned>::max();
+    unsigned numTmps;
+    static constexpr unsigned invalidIndex = std::numeric_limits<unsigned>::max();
     unsigned firstUndefined = invalidIndex;
     bool firstUndefinedIsArgument = false;
 
     auto flushUndefinedOperandSpan = [&] (unsigned i) {
         if (firstUndefined == invalidIndex)
             return;
-        int firstOffset = valueRecoveries.virtualRegisterForIndex(firstUndefined).offset();
-        int lastOffset = valueRecoveries.virtualRegisterForIndex(i - 1).offset();
+        int firstOffset = valueRecoveries.operandForIndex(firstUndefined).virtualRegister().offset();
+        int lastOffset = valueRecoveries.operandForIndex(i - 1).virtualRegister().offset();
         int minOffset = std::min(firstOffset, lastOffset);
         undefinedOperandSpans->append({ firstUndefined, minOffset, i - firstUndefined });
         firstUndefined = invalidIndex;
     };
     auto recordUndefinedOperand = [&] (unsigned i) {
         // We want to separate the span of arguments from the span of locals even if they have adjacent operands indexes.
-        if (firstUndefined != invalidIndex && firstUndefinedIsArgument != valueRecoveries.isArgument(i))
+        if (firstUndefined != invalidIndex && firstUndefinedIsArgument != valueRecoveries.operandForIndex(i).isArgument())
             flushUndefinedOperandSpan(i);
 
         if (firstUndefined == invalidIndex) {
             firstUndefined = i;
-            firstUndefinedIsArgument = valueRecoveries.isArgument(i);
+            firstUndefinedIsArgument = valueRecoveries.operandForIndex(i).isArgument();
         }
     };
 
     auto* inlineCallFrame = codeOrigin.inlineCallFrame();
-    if (inlineCallFrame)
-        numVariables = baselineCodeBlockForInlineCallFrame(inlineCallFrame)->numCalleeLocals() + VirtualRegister(inlineCallFrame->stackOffset).toLocal() + 1;
-    else
+    if (inlineCallFrame) {
+        CodeBlock* codeBlock = baselineCodeBlockForInlineCallFrame(inlineCallFrame);
+        numVariables = codeBlock->numCalleeLocals() + VirtualRegister(inlineCallFrame->stackOffset).toLocal() + 1;
+        numTmps = codeBlock->numTmps() + inlineCallFrame->tmpOffset;
+    } else {
         numVariables = baselineCodeBlock->numCalleeLocals();
+        numTmps = baselineCodeBlock->numTmps();
+    }
 
     // Crazy special case: if we're at index == 0 then this must be an argument check
     // failure, in which case all variables are already set up. The recoveries should
     // reflect this.
     if (!index) {
-        valueRecoveries = Operands<ValueRecovery>(codeBlock->numParameters(), numVariables);
+        // We don't include tmps here because they can't be used yet.
+        valueRecoveries = Operands<ValueRecovery>(codeBlock->numParameters(), numVariables, 0);
         for (size_t i = 0; i < valueRecoveries.size(); ++i) {
             valueRecoveries[i] = ValueRecovery::displacedInJSStack(
-                VirtualRegister(valueRecoveries.operandForIndex(i)), DataFormatJS);
+                valueRecoveries.operandForIndex(i).virtualRegister(), DataFormatJS);
         }
         return numVariables;
     }
 
     // Step 1: Find the last checkpoint, and figure out the number of virtual registers as we go.
     unsigned startIndex = index - 1;
     while (at(startIndex).kind() != Reset)
         startIndex--;
 
     // Step 2: Create a mock-up of the DFG's state and execute the events.
-    Operands<ValueSource> operandSources(codeBlock->numParameters(), numVariables);
+    Operands<ValueSource> operandSources(codeBlock->numParameters(), numVariables, numTmps);
     for (unsigned i = operandSources.size(); i--;)
         operandSources[i] = ValueSource(SourceIsDead);
     HashMap<MinifiedID, MinifiedGenerationInfo> generationInfos;
     for (unsigned i = startIndex; i < index; ++i) {
         const VariableEvent& event = at(i);
+        dataLogLnIf(verbose, "Processing event ", event);
         switch (event.kind()) {
         case Reset:
             // nothing to do.
             break;
         case BirthToFill:
@@ -196,25 +205,27 @@
             ASSERT(iter != generationInfos.end());
             iter->value.update(event);
             break;
         }
         case MovHintEvent:
-            if (operandSources.hasOperand(event.bytecodeRegister()))
-                operandSources.setOperand(event.bytecodeRegister(), ValueSource(event.id()));
+            if (operandSources.hasOperand(event.operand()))
+                operandSources.setOperand(event.operand(), ValueSource(event.id()));
             break;
         case SetLocalEvent:
-            if (operandSources.hasOperand(event.bytecodeRegister()))
-                operandSources.setOperand(event.bytecodeRegister(), ValueSource::forDataFormat(event.machineRegister(), event.dataFormat()));
+            if (operandSources.hasOperand(event.operand()))
+                operandSources.setOperand(event.operand(), ValueSource::forDataFormat(event.machineRegister(), event.dataFormat()));
             break;
         default:
             RELEASE_ASSERT_NOT_REACHED();
             break;
         }
     }
 
+    dataLogLnIf(verbose, "Operand sources: ", operandSources);
+
     // Step 3: Compute value recoveries!
-    valueRecoveries = Operands<ValueRecovery>(codeBlock->numParameters(), numVariables);
+    valueRecoveries = Operands<ValueRecovery>(OperandsLike, operandSources);
     for (unsigned i = 0; i < operandSources.size(); ++i) {
         ValueSource& source = operandSources[i];
         if (source.isTriviallyRecoverable()) {
             valueRecoveries[i] = source.valueRecovery();
             if (style == ReconstructionStyle::Separated) {
@@ -228,17 +239,19 @@
 
         ASSERT(source.kind() == HaveNode);
         MinifiedNode* node = graph.at(source.id());
         MinifiedGenerationInfo info = generationInfos.get(source.id());
         if (!info.alive) {
+            dataLogLnIf(verbose, "Operand ", valueRecoveries.operandForIndex(i), " is dead.");
             valueRecoveries[i] = ValueRecovery::constant(jsUndefined());
             if (style == ReconstructionStyle::Separated)
                 recordUndefinedOperand(i);
             continue;
         }
 
         if (tryToSetConstantRecovery(valueRecoveries[i], node)) {
+            dataLogLnIf(verbose, "Operand ", valueRecoveries.operandForIndex(i), " is constant.");
             if (style == ReconstructionStyle::Separated) {
                 if (node->hasConstant() && node->constant() == jsUndefined())
                     recordUndefinedOperand(i);
                 else
                     flushUndefinedOperandSpan(i);
@@ -264,11 +277,11 @@
             valueRecoveries[i] = ValueRecovery::inGPR(info.u.gpr, info.format);
             continue;
         }
 
         valueRecoveries[i] =
-            ValueRecovery::displacedInJSStack(static_cast<VirtualRegister>(info.u.virtualReg), info.format);
+            ValueRecovery::displacedInJSStack(info.u.operand.virtualRegister(), info.format);
     }
     if (style == ReconstructionStyle::Separated)
         flushUndefinedOperandSpan(operandSources.size());
 
     return numVariables;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPHeaderNames.in.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPParsers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  *     documentation and/or other materials provided with the distribution.
  17  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  18  *     its contributors may be used to endorse or promote products derived
  19  *     from this software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;HTTPParsers.h&quot;
  35 

  36 #include &quot;HTTPHeaderNames.h&quot;

  37 #include &lt;wtf/DateMath.h&gt;
  38 #include &lt;wtf/Language.h&gt;
  39 #include &lt;wtf/NeverDestroyed.h&gt;
  40 #include &lt;wtf/Optional.h&gt;
  41 #include &lt;wtf/text/StringBuilder.h&gt;
  42 #include &lt;wtf/unicode/CharacterNames.h&gt;
  43 
  44 
  45 namespace WebCore {
  46 












  47 // true if there is more to parse, after incrementing pos past whitespace.
  48 // Note: Might return pos == str.length()
  49 static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  50 {
<span class="line-modified">  51     unsigned len = str.length();</span>
<span class="line-modified">  52 </span>
<span class="line-removed">  53     while (pos &lt; len &amp;&amp; (str[pos] == &#39;\t&#39; || str[pos] == &#39; &#39;))</span>
<span class="line-removed">  54         ++pos;</span>
<span class="line-removed">  55 </span>
<span class="line-removed">  56     return pos &lt; len;</span>
  57 }
  58 
  59 // Returns true if the function can match the whole token (case insensitive)
  60 // incrementing pos on match, otherwise leaving pos unchanged.
  61 // Note: Might return pos == str.length()
  62 static inline bool skipToken(const String&amp; str, unsigned&amp; pos, const char* token)
  63 {
  64     unsigned len = str.length();
  65     unsigned current = pos;
  66 
  67     while (current &lt; len &amp;&amp; *token) {
  68         if (toASCIILower(str[current]) != *token++)
  69             return false;
  70         ++current;
  71     }
  72 
  73     if (*token)
  74         return false;
  75 
  76     pos = current;
</pre>
<hr />
<pre>
  80 // True if the expected equals sign is seen and there is more to follow.
  81 static inline bool skipEquals(const String&amp; str, unsigned &amp;pos)
  82 {
  83     return skipWhiteSpace(str, pos) &amp;&amp; str[pos++] == &#39;=&#39; &amp;&amp; skipWhiteSpace(str, pos);
  84 }
  85 
  86 // True if a value present, incrementing pos to next space or semicolon, if any.
  87 // Note: might return pos == str.length().
  88 static inline bool skipValue(const String&amp; str, unsigned&amp; pos)
  89 {
  90     unsigned start = pos;
  91     unsigned len = str.length();
  92     while (pos &lt; len) {
  93         if (str[pos] == &#39; &#39; || str[pos] == &#39;\t&#39; || str[pos] == &#39;;&#39;)
  94             break;
  95         ++pos;
  96     }
  97     return pos != start;
  98 }
  99 
<span class="line-removed"> 100 // True if characters which satisfy the predicate are present, incrementing</span>
<span class="line-removed"> 101 // &quot;pos&quot; to the next character which does not satisfy the predicate.</span>
<span class="line-removed"> 102 // Note: might return pos == str.length().</span>
<span class="line-removed"> 103 static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)</span>
<span class="line-removed"> 104 {</span>
<span class="line-removed"> 105     const unsigned start = pos;</span>
<span class="line-removed"> 106     const unsigned len = str.length();</span>
<span class="line-removed"> 107     while (pos &lt; len &amp;&amp; predicate(str[pos]))</span>
<span class="line-removed"> 108         ++pos;</span>
<span class="line-removed"> 109     return pos != start;</span>
<span class="line-removed"> 110 }</span>
<span class="line-removed"> 111 </span>
 112 // See RFC 7230, Section 3.1.2.
 113 bool isValidReasonPhrase(const String&amp; value)
 114 {
 115     for (unsigned i = 0; i &lt; value.length(); ++i) {
 116         UChar c = value[i];
 117         if (c == 0x7F || !isLatin1(c) || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 118             return false;
 119     }
 120     return true;
 121 }
 122 
 123 // See https://fetch.spec.whatwg.org/#concept-header
 124 bool isValidHTTPHeaderValue(const String&amp; value)
 125 {
 126     UChar c = value[0];
 127     if (c == &#39; &#39; || c == &#39;\t&#39;)
 128         return false;
 129     c = value[value.length() - 1];
 130     if (c == &#39; &#39; || c == &#39;\t&#39;)
 131         return false;
 132     for (unsigned i = 0; i &lt; value.length(); ++i) {
 133         c = value[i];
 134         ASSERT(isLatin1(c));
 135         if (c == 0x00 || c == 0x0A || c == 0x0D)
 136             return false;
 137     }
 138     return true;
 139 }
 140 
<span class="line-removed"> 141 // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed"> 142 static bool isDelimiterCharacter(const UChar c)</span>
<span class="line-removed"> 143 {</span>
<span class="line-removed"> 144     // DQUOTE and &quot;(),/:;&lt;=&gt;?@[\]{}&quot;</span>
<span class="line-removed"> 145     return (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;:&#39; || c == &#39;;&#39;</span>
<span class="line-removed"> 146         || c == &#39;&lt;&#39; || c == &#39;=&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39; || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39;</span>
<span class="line-removed"> 147         || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39;);</span>
<span class="line-removed"> 148 }</span>
<span class="line-removed"> 149 </span>
<span class="line-removed"> 150 // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed"> 151 static inline bool isVisibleCharacter(const UChar c)</span>
<span class="line-removed"> 152 {</span>
<span class="line-removed"> 153     // VCHAR = %x21-7E</span>
<span class="line-removed"> 154     return (c &gt;= 0x21 &amp;&amp; c &lt;= 0x7E);</span>
<span class="line-removed"> 155 }</span>
<span class="line-removed"> 156 </span>
<span class="line-removed"> 157 // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed"> 158 static inline bool isOctectInFieldContentCharacter(const UChar c)</span>
<span class="line-removed"> 159 {</span>
<span class="line-removed"> 160     // obs-text = %x80-FF</span>
<span class="line-removed"> 161     return (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF);</span>
<span class="line-removed"> 162 }</span>
<span class="line-removed"> 163 </span>
<span class="line-removed"> 164 // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed"> 165 static bool isCommentTextCharacter(const UChar c)</span>
<span class="line-removed"> 166 {</span>
<span class="line-removed"> 167     // ctext = HTAB / SP</span>
<span class="line-removed"> 168     //       / %x21-27 ; &#39;!&#39;-&#39;&#39;&#39;</span>
<span class="line-removed"> 169     //       / %x2A-5B ; &#39;*&#39;-&#39;[&#39;</span>
<span class="line-removed"> 170     //       / %x5D-7E ; &#39;]&#39;-&#39;~&#39;</span>
<span class="line-removed"> 171     //       / obs-text</span>
<span class="line-removed"> 172     return (c == &#39;\t&#39; || c == &#39; &#39;</span>
<span class="line-removed"> 173         || (c &gt;= 0x21 &amp;&amp; c &lt;= 0x27)</span>
<span class="line-removed"> 174         || (c &gt;= 0x2A &amp;&amp; c &lt;= 0x5B)</span>
<span class="line-removed"> 175         || (c &gt;= 0x5D &amp;&amp; c &lt;= 0x7E)</span>
<span class="line-removed"> 176         || isOctectInFieldContentCharacter(c));</span>
<span class="line-removed"> 177 }</span>
<span class="line-removed"> 178 </span>
 179 // See RFC 7231, Section 5.3.2.
 180 bool isValidAcceptHeaderValue(const String&amp; value)
 181 {
 182     for (unsigned i = 0; i &lt; value.length(); ++i) {
 183         UChar c = value[i];
 184 
 185         // First check for alphanumeric for performance reasons then whitelist four delimiter characters.
 186         if (isASCIIAlphanumeric(c) || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 187             continue;
 188 
 189         ASSERT(isLatin1(c));
 190         if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 191             return false;
 192 
<span class="line-modified"> 193         if (isDelimiterCharacter(c))</span>
 194             return false;
 195     }
 196 
 197     return true;
 198 }
 199 













 200 // See RFC 7231, Section 5.3.5 and 3.1.3.2.
 201 bool isValidLanguageHeaderValue(const String&amp; value)
 202 {
 203     for (unsigned i = 0; i &lt; value.length(); ++i) {
 204         UChar c = value[i];
 205         if (isASCIIAlphanumeric(c) || c == &#39; &#39; || c == &#39;*&#39; || c == &#39;,&#39; || c == &#39;-&#39; || c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 206             continue;
 207         return false;
 208     }
 209 
 210     // FIXME: Validate further by splitting into language tags and optional quality
 211     // values (q=) and then check each language tag.
 212     // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
 213     // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
 214     return true;
 215 }
 216 
<span class="line-removed"> 217 // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed"> 218 static inline bool isHTTPTokenCharacter(const UChar c)</span>
<span class="line-removed"> 219 {</span>
<span class="line-removed"> 220     // Any VCHAR, except delimiters</span>
<span class="line-removed"> 221     return c &gt; 0x20 &amp;&amp; c &lt; 0x7F &amp;&amp; !isDelimiterCharacter(c);</span>
<span class="line-removed"> 222 }</span>
<span class="line-removed"> 223 </span>
 224 // See RFC 7230, Section 3.2.6.
 225 bool isValidHTTPToken(const String&amp; value)
 226 {
 227     if (value.isEmpty())
 228         return false;
 229     auto valueStringView = StringView(value);
 230     for (UChar c : valueStringView.codeUnits()) {
<span class="line-modified"> 231         if (!isHTTPTokenCharacter(c))</span>
 232             return false;
 233     }
 234     return true;
 235 }
 236 

 237 // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.
 238 // Note: Might return pos == str.length()
 239 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)
 240 {
 241     if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {
 242         ++pos;
 243         return true;
 244     }
 245     return false;
 246 }
 247 
 248 // True if the &quot;expected&quot; character is at the given position, incrementing &quot;pos&quot; by one.
 249 // Note: Might return pos == str.length()
 250 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, const UChar expected)
 251 {
 252     return skipCharacter(value, pos, [expected](const UChar c) {
 253         return c == expected;
 254     });
 255 }
 256 
 257 // True if a quoted pair is present, incrementing &quot;pos&quot; to the position after the quoted pair.
 258 // Note: Might return pos == str.length()
 259 // See RFC 7230, Section 3.2.6.
 260 static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;
 261 static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)
 262 {
 263     // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )
<span class="line-modified"> 264     if (!skipCharacter(value, pos, QuotedPairStartCharacter))</span>
<span class="line-modified"> 265         return false;</span>
<span class="line-removed"> 266 </span>
<span class="line-removed"> 267     return skipCharacter(value, pos, &#39;\t&#39;)</span>
<span class="line-removed"> 268         || skipCharacter(value, pos, &#39; &#39;)</span>
<span class="line-removed"> 269         || skipCharacter(value, pos, isVisibleCharacter)</span>
<span class="line-removed"> 270         || skipCharacter(value, pos, isOctectInFieldContentCharacter);</span>
 271 }
 272 
 273 // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.
 274 // Note: Might return pos == str.length()
 275 // See RFC 7230, Section 3.2.6.
 276 static constexpr auto CommentStartCharacter = &#39;(&#39;;
 277 static constexpr auto CommentEndCharacter = &#39;)&#39;;
 278 static bool skipComment(const String&amp; value, unsigned&amp; pos)
 279 {
 280     // comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
 281     // ctext   = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
 282     if (!skipCharacter(value, pos, CommentStartCharacter))
 283         return false;
 284 
 285     const unsigned end = value.length();
 286     while (pos &lt; end &amp;&amp; value[pos] != CommentEndCharacter) {
 287         switch (value[pos]) {
 288         case CommentStartCharacter:
 289             if (!skipComment(value, pos))
 290                 return false;
 291             break;
 292         case QuotedPairStartCharacter:
 293             if (!skipQuotedPair(value, pos))
 294                 return false;
 295             break;
 296         default:
<span class="line-modified"> 297             if (!skipWhile(value, pos, isCommentTextCharacter))</span>
 298                 return false;
 299         }
 300     }
 301     return skipCharacter(value, pos, CommentEndCharacter);
 302 }
 303 
 304 // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.
 305 // Note: Might return pos == str.length()
 306 // See RFC 7230, Section 3.2.6.
 307 static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)
 308 {
<span class="line-modified"> 309     return skipWhile(value, pos, isHTTPTokenCharacter);</span>
 310 }
 311 
 312 // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.
 313 // Note: Might return pos == str.length()
 314 // See RFC 7231, Section 5.5.3.
 315 static bool skipUserAgentProduct(const String&amp; value, unsigned&amp; pos)
 316 {
 317     // product         = token [&quot;/&quot; product-version]
 318     // product-version = token
 319     if (!skipHTTPToken(value, pos))
 320         return false;
 321     if (skipCharacter(value, pos, &#39;/&#39;))
 322         return skipHTTPToken(value, pos);
 323     return true;
 324 }
 325 
 326 // See RFC 7231, Section 5.5.3
 327 bool isValidUserAgentHeaderValue(const String&amp; value)
 328 {
 329     // User-Agent = product *( RWS ( product / comment ) )
 330     unsigned pos = 0;
 331     if (!skipUserAgentProduct(value, pos))
 332         return false;
 333 
 334     while (pos &lt; value.length()) {
 335         if (!skipWhiteSpace(value, pos))
 336             return false;
 337         if (value[pos] == CommentStartCharacter) {
 338             if (!skipComment(value, pos))
 339                 return false;
 340         } else {
 341             if (!skipUserAgentProduct(value, pos))
 342                 return false;
 343         }
 344     }
 345 
 346     return pos == value.length();
 347 }

 348 
 349 static const size_t maxInputSampleSize = 128;
 350 static String trimInputSample(const char* p, size_t length)
 351 {
 352     String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
 353     if (length &gt; maxInputSampleSize)
 354         s.append(horizontalEllipsis);
 355     return s;
 356 }
 357 
<span class="line-removed"> 358 bool parseHTTPRefresh(const String&amp; refresh, double&amp; delay, String&amp; url)</span>
<span class="line-removed"> 359 {</span>
<span class="line-removed"> 360     unsigned len = refresh.length();</span>
<span class="line-removed"> 361     unsigned pos = 0;</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     if (!skipWhiteSpace(refresh, pos))</span>
<span class="line-removed"> 364         return false;</span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366     while (pos != len &amp;&amp; refresh[pos] != &#39;,&#39; &amp;&amp; refresh[pos] != &#39;;&#39;)</span>
<span class="line-removed"> 367         ++pos;</span>
<span class="line-removed"> 368 </span>
<span class="line-removed"> 369     if (pos == len) { // no URL</span>
<span class="line-removed"> 370         url = String();</span>
<span class="line-removed"> 371         bool ok;</span>
<span class="line-removed"> 372         delay = refresh.stripWhiteSpace().toDouble(&amp;ok);</span>
<span class="line-removed"> 373         return ok;</span>
<span class="line-removed"> 374     } else {</span>
<span class="line-removed"> 375         bool ok;</span>
<span class="line-removed"> 376         delay = refresh.left(pos).stripWhiteSpace().toDouble(&amp;ok);</span>
<span class="line-removed"> 377         if (!ok)</span>
<span class="line-removed"> 378             return false;</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380         ++pos;</span>
<span class="line-removed"> 381         skipWhiteSpace(refresh, pos);</span>
<span class="line-removed"> 382         unsigned urlStartPos = pos;</span>
<span class="line-removed"> 383         if (refresh.findIgnoringASCIICase(&quot;url&quot;, urlStartPos) == urlStartPos) {</span>
<span class="line-removed"> 384             urlStartPos += 3;</span>
<span class="line-removed"> 385             skipWhiteSpace(refresh, urlStartPos);</span>
<span class="line-removed"> 386             if (refresh[urlStartPos] == &#39;=&#39;) {</span>
<span class="line-removed"> 387                 ++urlStartPos;</span>
<span class="line-removed"> 388                 skipWhiteSpace(refresh, urlStartPos);</span>
<span class="line-removed"> 389             } else</span>
<span class="line-removed"> 390                 urlStartPos = pos;  // e.g. &quot;Refresh: 0; url.html&quot;</span>
<span class="line-removed"> 391         }</span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393         unsigned urlEndPos = len;</span>
<span class="line-removed"> 394 </span>
<span class="line-removed"> 395         if (refresh[urlStartPos] == &#39;&quot;&#39; || refresh[urlStartPos] == &#39;\&#39;&#39;) {</span>
<span class="line-removed"> 396             UChar quotationMark = refresh[urlStartPos];</span>
<span class="line-removed"> 397             urlStartPos++;</span>
<span class="line-removed"> 398             while (urlEndPos &gt; urlStartPos) {</span>
<span class="line-removed"> 399                 urlEndPos--;</span>
<span class="line-removed"> 400                 if (refresh[urlEndPos] == quotationMark)</span>
<span class="line-removed"> 401                     break;</span>
<span class="line-removed"> 402             }</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404             // https://bugs.webkit.org/show_bug.cgi?id=27868</span>
<span class="line-removed"> 405             // Sometimes there is no closing quote for the end of the URL even though there was an opening quote.</span>
<span class="line-removed"> 406             // If we looped over the entire alleged URL string back to the opening quote, just use everything</span>
<span class="line-removed"> 407             // after the opening quote instead.</span>
<span class="line-removed"> 408             if (urlEndPos == urlStartPos)</span>
<span class="line-removed"> 409                 urlEndPos = len;</span>
<span class="line-removed"> 410         }</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412         url = refresh.substring(urlStartPos, urlEndPos - urlStartPos).stripWhiteSpace();</span>
<span class="line-removed"> 413         return true;</span>
<span class="line-removed"> 414     }</span>
<span class="line-removed"> 415 }</span>
<span class="line-removed"> 416 </span>
 417 Optional&lt;WallTime&gt; parseHTTPDate(const String&amp; value)
 418 {
 419     double dateInMillisecondsSinceEpoch = parseDateFromNullTerminatedCharacters(value.utf8().data());
 420     if (!std::isfinite(dateInMillisecondsSinceEpoch))
 421         return WTF::nullopt;
 422     // This assumes system_clock epoch equals Unix epoch which is true for all implementations but unspecified.
 423     // FIXME: The parsing function should be switched to WallTime too.
 424     return WallTime::fromRawSeconds(dateInMillisecondsSinceEpoch / 1000.0);
 425 }
 426 
 427 // FIXME: This function doesn&#39;t comply with RFC 6266.
 428 // For example, this function doesn&#39;t handle the interaction between &quot; and ;
 429 // that arises from quoted-string, nor does this function properly unquote
 430 // attribute values. Further this function appears to process parameter names
 431 // in a case-sensitive manner. (There are likely other bugs as well.)
 432 String filenameFromHTTPContentDisposition(const String&amp; value)
 433 {
 434     for (auto&amp; keyValuePair : value.split(&#39;;&#39;)) {
 435         size_t valueStartPos = keyValuePair.find(&#39;=&#39;);
 436         if (valueStartPos == notFound)
</pre>
<hr />
<pre>
 943         case HTTPHeaderName::Date:
 944         case HTTPHeaderName::DNT:
 945         case HTTPHeaderName::Expect:
 946         case HTTPHeaderName::Host:
 947         case HTTPHeaderName::KeepAlive:
 948         case HTTPHeaderName::Origin:
 949         case HTTPHeaderName::Referer:
 950         case HTTPHeaderName::TE:
 951         case HTTPHeaderName::Trailer:
 952         case HTTPHeaderName::TransferEncoding:
 953         case HTTPHeaderName::Upgrade:
 954         case HTTPHeaderName::Via:
 955             return true;
 956         default:
 957             break;
 958         }
 959     }
 960     return startsWithLettersIgnoringASCIICase(name, &quot;sec-&quot;) || startsWithLettersIgnoringASCIICase(name, &quot;proxy-&quot;);
 961 }
 962 
























 963 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-response-header-name&gt;.
 964 bool isForbiddenResponseHeaderName(const String&amp; name)
 965 {
 966     return equalLettersIgnoringASCIICase(name, &quot;set-cookie&quot;) || equalLettersIgnoringASCIICase(name, &quot;set-cookie2&quot;);
 967 }
 968 
 969 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-method&gt;.
 970 bool isForbiddenMethod(const String&amp; name)
 971 {
 972     return equalLettersIgnoringASCIICase(name, &quot;connect&quot;) || equalLettersIgnoringASCIICase(name, &quot;trace&quot;) || equalLettersIgnoringASCIICase(name, &quot;track&quot;);
 973 }
 974 
 975 bool isSimpleHeader(const String&amp; name, const String&amp; value)
 976 {
 977     HTTPHeaderName headerName;
 978     if (!findHTTPHeaderName(name, headerName))
 979         return false;
 980     return isCrossOriginSafeRequestHeader(headerName, value);
 981 }
 982 
</pre>
<hr />
<pre>
 986     case HTTPHeaderName::CacheControl:
 987     case HTTPHeaderName::ContentLanguage:
 988     case HTTPHeaderName::ContentLength:
 989     case HTTPHeaderName::ContentType:
 990     case HTTPHeaderName::Expires:
 991     case HTTPHeaderName::LastModified:
 992     case HTTPHeaderName::Pragma:
 993     case HTTPHeaderName::Accept:
 994         return true;
 995     case HTTPHeaderName::SetCookie:
 996     case HTTPHeaderName::SetCookie2:
 997         return false;
 998     default:
 999         break;
1000     }
1001     return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
1002 }
1003 
1004 bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
1005 {
<span class="line-modified">1006 #ifndef ASSERT_DISABLED</span>
1007     HTTPHeaderName headerName;
1008     ASSERT(!findHTTPHeaderName(name, headerName));
1009 #endif
1010     return accessControlExposeHeaderSet.contains(name);
1011 }
1012 
1013 // Implements https://fetch.spec.whatwg.org/#cors-safelisted-request-header
1014 bool isCrossOriginSafeRequestHeader(HTTPHeaderName name, const String&amp; value)
1015 {
1016     switch (name) {
1017     case HTTPHeaderName::Accept:
1018         if (!isValidAcceptHeaderValue(value))
1019             return false;
1020         break;
1021     case HTTPHeaderName::AcceptLanguage:
1022     case HTTPHeaderName::ContentLanguage:
1023         if (!isValidLanguageHeaderValue(value))
1024             return false;
1025         break;
1026     case HTTPHeaderName::ContentType: {
1027         // Preflight is required for MIME types that can not be sent via form submission.
<span class="line-modified">1028         String mimeType = extractMIMETypeFromMediaType(value);</span>





1029         if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))
1030             return false;
1031         break;
1032     }
1033     default:
1034         // FIXME: Should we also make safe other headers (DPR, Downlink, Save-Data...)? That would require validating their values.
1035         return false;
1036     }
1037     return value.length() &lt;= 128;
1038 }
1039 
1040 // Implements &lt;https://fetch.spec.whatwg.org/#concept-method-normalize&gt;.
1041 String normalizeHTTPMethod(const String&amp; method)
1042 {
1043     const ASCIILiteral methods[] = { &quot;DELETE&quot;_s, &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;POST&quot;_s, &quot;PUT&quot;_s };
1044     for (auto value : methods) {
1045         if (equalIgnoringASCIICase(method, value.characters())) {
1046             // Don&#39;t bother allocating a new string if it&#39;s already all uppercase.
1047             if (method == value)
1048                 break;
1049             return value;
1050         }
1051     }
1052     return method;
1053 }
1054 











1055 CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
1056 {
1057     auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
1058 
1059     if (strippedHeader.isEmpty())
1060         return CrossOriginResourcePolicy::None;
1061 
1062     if (strippedHeader == &quot;same-origin&quot;)
1063         return CrossOriginResourcePolicy::SameOrigin;
1064 
1065     if (strippedHeader == &quot;same-site&quot;)
1066         return CrossOriginResourcePolicy::SameSite;
1067 
1068     return CrossOriginResourcePolicy::Invalid;
1069 }
1070 
1071 }
</pre>
</td>
<td>
<hr />
<pre>
  16  *     documentation and/or other materials provided with the distribution.
  17  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  18  *     its contributors may be used to endorse or promote products derived
  19  *     from this software without specific prior written permission.
  20  *
  21  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  22  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  23  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  24  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  25  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  26  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  27  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  28  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  30  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  31  */
  32 
  33 #include &quot;config.h&quot;
  34 #include &quot;HTTPParsers.h&quot;
  35 
<span class="line-added">  36 #include &quot;HTTPHeaderField.h&quot;</span>
  37 #include &quot;HTTPHeaderNames.h&quot;
<span class="line-added">  38 #include &quot;ParsedContentType.h&quot;</span>
  39 #include &lt;wtf/DateMath.h&gt;
  40 #include &lt;wtf/Language.h&gt;
  41 #include &lt;wtf/NeverDestroyed.h&gt;
  42 #include &lt;wtf/Optional.h&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 #include &lt;wtf/unicode/CharacterNames.h&gt;
  45 
  46 
  47 namespace WebCore {
  48 
<span class="line-added">  49 // True if characters which satisfy the predicate are present, incrementing</span>
<span class="line-added">  50 // &quot;pos&quot; to the next character which does not satisfy the predicate.</span>
<span class="line-added">  51 // Note: might return pos == str.length().</span>
<span class="line-added">  52 static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)</span>
<span class="line-added">  53 {</span>
<span class="line-added">  54     const unsigned start = pos;</span>
<span class="line-added">  55     const unsigned len = str.length();</span>
<span class="line-added">  56     while (pos &lt; len &amp;&amp; predicate(str[pos]))</span>
<span class="line-added">  57         ++pos;</span>
<span class="line-added">  58     return pos != start;</span>
<span class="line-added">  59 }</span>
<span class="line-added">  60 </span>
  61 // true if there is more to parse, after incrementing pos past whitespace.
  62 // Note: Might return pos == str.length()
  63 static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  64 {
<span class="line-modified">  65     skipWhile(str, pos, RFC7230::isWhitespace);</span>
<span class="line-modified">  66     return pos &lt; str.length();</span>




  67 }
  68 
  69 // Returns true if the function can match the whole token (case insensitive)
  70 // incrementing pos on match, otherwise leaving pos unchanged.
  71 // Note: Might return pos == str.length()
  72 static inline bool skipToken(const String&amp; str, unsigned&amp; pos, const char* token)
  73 {
  74     unsigned len = str.length();
  75     unsigned current = pos;
  76 
  77     while (current &lt; len &amp;&amp; *token) {
  78         if (toASCIILower(str[current]) != *token++)
  79             return false;
  80         ++current;
  81     }
  82 
  83     if (*token)
  84         return false;
  85 
  86     pos = current;
</pre>
<hr />
<pre>
  90 // True if the expected equals sign is seen and there is more to follow.
  91 static inline bool skipEquals(const String&amp; str, unsigned &amp;pos)
  92 {
  93     return skipWhiteSpace(str, pos) &amp;&amp; str[pos++] == &#39;=&#39; &amp;&amp; skipWhiteSpace(str, pos);
  94 }
  95 
  96 // True if a value present, incrementing pos to next space or semicolon, if any.
  97 // Note: might return pos == str.length().
  98 static inline bool skipValue(const String&amp; str, unsigned&amp; pos)
  99 {
 100     unsigned start = pos;
 101     unsigned len = str.length();
 102     while (pos &lt; len) {
 103         if (str[pos] == &#39; &#39; || str[pos] == &#39;\t&#39; || str[pos] == &#39;;&#39;)
 104             break;
 105         ++pos;
 106     }
 107     return pos != start;
 108 }
 109 












 110 // See RFC 7230, Section 3.1.2.
 111 bool isValidReasonPhrase(const String&amp; value)
 112 {
 113     for (unsigned i = 0; i &lt; value.length(); ++i) {
 114         UChar c = value[i];
 115         if (c == 0x7F || !isLatin1(c) || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 116             return false;
 117     }
 118     return true;
 119 }
 120 
 121 // See https://fetch.spec.whatwg.org/#concept-header
 122 bool isValidHTTPHeaderValue(const String&amp; value)
 123 {
 124     UChar c = value[0];
 125     if (c == &#39; &#39; || c == &#39;\t&#39;)
 126         return false;
 127     c = value[value.length() - 1];
 128     if (c == &#39; &#39; || c == &#39;\t&#39;)
 129         return false;
 130     for (unsigned i = 0; i &lt; value.length(); ++i) {
 131         c = value[i];
 132         ASSERT(isLatin1(c));
 133         if (c == 0x00 || c == 0x0A || c == 0x0D)
 134             return false;
 135     }
 136     return true;
 137 }
 138 






































 139 // See RFC 7231, Section 5.3.2.
 140 bool isValidAcceptHeaderValue(const String&amp; value)
 141 {
 142     for (unsigned i = 0; i &lt; value.length(); ++i) {
 143         UChar c = value[i];
 144 
 145         // First check for alphanumeric for performance reasons then whitelist four delimiter characters.
 146         if (isASCIIAlphanumeric(c) || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 147             continue;
 148 
 149         ASSERT(isLatin1(c));
 150         if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
 151             return false;
 152 
<span class="line-modified"> 153         if (RFC7230::isDelimiter(c))</span>
 154             return false;
 155     }
 156 
 157     return true;
 158 }
 159 
<span class="line-added"> 160 static bool containsCORSUnsafeRequestHeaderBytes(const String&amp; value)</span>
<span class="line-added"> 161 {</span>
<span class="line-added"> 162     for (unsigned i = 0; i &lt; value.length(); ++i) {</span>
<span class="line-added"> 163         UChar c = value[i];</span>
<span class="line-added"> 164         // https://fetch.spec.whatwg.org/#cors-unsafe-request-header-byte</span>
<span class="line-added"> 165         if ((c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;) || (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;:&#39; || c == &#39;&lt;&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39;</span>
<span class="line-added"> 166             || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39; || c == &#39;]&#39; || c == 0x7B || c == &#39;{&#39; || c == &#39;}&#39; || c == 0x7F))</span>
<span class="line-added"> 167             return true;</span>
<span class="line-added"> 168     }</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170     return false;</span>
<span class="line-added"> 171 }</span>
<span class="line-added"> 172 </span>
 173 // See RFC 7231, Section 5.3.5 and 3.1.3.2.
 174 bool isValidLanguageHeaderValue(const String&amp; value)
 175 {
 176     for (unsigned i = 0; i &lt; value.length(); ++i) {
 177         UChar c = value[i];
 178         if (isASCIIAlphanumeric(c) || c == &#39; &#39; || c == &#39;*&#39; || c == &#39;,&#39; || c == &#39;-&#39; || c == &#39;.&#39; || c == &#39;;&#39; || c == &#39;=&#39;)
 179             continue;
 180         return false;
 181     }
 182 
 183     // FIXME: Validate further by splitting into language tags and optional quality
 184     // values (q=) and then check each language tag.
 185     // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
 186     // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
 187     return true;
 188 }
 189 







 190 // See RFC 7230, Section 3.2.6.
 191 bool isValidHTTPToken(const String&amp; value)
 192 {
 193     if (value.isEmpty())
 194         return false;
 195     auto valueStringView = StringView(value);
 196     for (UChar c : valueStringView.codeUnits()) {
<span class="line-modified"> 197         if (!RFC7230::isTokenCharacter(c))</span>
 198             return false;
 199     }
 200     return true;
 201 }
 202 
<span class="line-added"> 203 #if USE(GLIB)</span>
 204 // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.
 205 // Note: Might return pos == str.length()
 206 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)
 207 {
 208     if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {
 209         ++pos;
 210         return true;
 211     }
 212     return false;
 213 }
 214 
 215 // True if the &quot;expected&quot; character is at the given position, incrementing &quot;pos&quot; by one.
 216 // Note: Might return pos == str.length()
 217 static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, const UChar expected)
 218 {
 219     return skipCharacter(value, pos, [expected](const UChar c) {
 220         return c == expected;
 221     });
 222 }
 223 
 224 // True if a quoted pair is present, incrementing &quot;pos&quot; to the position after the quoted pair.
 225 // Note: Might return pos == str.length()
 226 // See RFC 7230, Section 3.2.6.
 227 static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;
 228 static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)
 229 {
 230     // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )
<span class="line-modified"> 231     return skipCharacter(value, pos, QuotedPairStartCharacter)</span>
<span class="line-modified"> 232         &amp;&amp; skipCharacter(value, pos, RFC7230::isQuotedPairSecondOctet);</span>





 233 }
 234 
 235 // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.
 236 // Note: Might return pos == str.length()
 237 // See RFC 7230, Section 3.2.6.
 238 static constexpr auto CommentStartCharacter = &#39;(&#39;;
 239 static constexpr auto CommentEndCharacter = &#39;)&#39;;
 240 static bool skipComment(const String&amp; value, unsigned&amp; pos)
 241 {
 242     // comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
 243     // ctext   = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text
 244     if (!skipCharacter(value, pos, CommentStartCharacter))
 245         return false;
 246 
 247     const unsigned end = value.length();
 248     while (pos &lt; end &amp;&amp; value[pos] != CommentEndCharacter) {
 249         switch (value[pos]) {
 250         case CommentStartCharacter:
 251             if (!skipComment(value, pos))
 252                 return false;
 253             break;
 254         case QuotedPairStartCharacter:
 255             if (!skipQuotedPair(value, pos))
 256                 return false;
 257             break;
 258         default:
<span class="line-modified"> 259             if (!skipWhile(value, pos, RFC7230::isCommentText))</span>
 260                 return false;
 261         }
 262     }
 263     return skipCharacter(value, pos, CommentEndCharacter);
 264 }
 265 
 266 // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.
 267 // Note: Might return pos == str.length()
 268 // See RFC 7230, Section 3.2.6.
 269 static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)
 270 {
<span class="line-modified"> 271     return skipWhile(value, pos, RFC7230::isTokenCharacter);</span>
 272 }
 273 
 274 // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.
 275 // Note: Might return pos == str.length()
 276 // See RFC 7231, Section 5.5.3.
 277 static bool skipUserAgentProduct(const String&amp; value, unsigned&amp; pos)
 278 {
 279     // product         = token [&quot;/&quot; product-version]
 280     // product-version = token
 281     if (!skipHTTPToken(value, pos))
 282         return false;
 283     if (skipCharacter(value, pos, &#39;/&#39;))
 284         return skipHTTPToken(value, pos);
 285     return true;
 286 }
 287 
 288 // See RFC 7231, Section 5.5.3
 289 bool isValidUserAgentHeaderValue(const String&amp; value)
 290 {
 291     // User-Agent = product *( RWS ( product / comment ) )
 292     unsigned pos = 0;
 293     if (!skipUserAgentProduct(value, pos))
 294         return false;
 295 
 296     while (pos &lt; value.length()) {
 297         if (!skipWhiteSpace(value, pos))
 298             return false;
 299         if (value[pos] == CommentStartCharacter) {
 300             if (!skipComment(value, pos))
 301                 return false;
 302         } else {
 303             if (!skipUserAgentProduct(value, pos))
 304                 return false;
 305         }
 306     }
 307 
 308     return pos == value.length();
 309 }
<span class="line-added"> 310 #endif</span>
 311 
 312 static const size_t maxInputSampleSize = 128;
 313 static String trimInputSample(const char* p, size_t length)
 314 {
 315     String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
 316     if (length &gt; maxInputSampleSize)
 317         s.append(horizontalEllipsis);
 318     return s;
 319 }
 320 



























































 321 Optional&lt;WallTime&gt; parseHTTPDate(const String&amp; value)
 322 {
 323     double dateInMillisecondsSinceEpoch = parseDateFromNullTerminatedCharacters(value.utf8().data());
 324     if (!std::isfinite(dateInMillisecondsSinceEpoch))
 325         return WTF::nullopt;
 326     // This assumes system_clock epoch equals Unix epoch which is true for all implementations but unspecified.
 327     // FIXME: The parsing function should be switched to WallTime too.
 328     return WallTime::fromRawSeconds(dateInMillisecondsSinceEpoch / 1000.0);
 329 }
 330 
 331 // FIXME: This function doesn&#39;t comply with RFC 6266.
 332 // For example, this function doesn&#39;t handle the interaction between &quot; and ;
 333 // that arises from quoted-string, nor does this function properly unquote
 334 // attribute values. Further this function appears to process parameter names
 335 // in a case-sensitive manner. (There are likely other bugs as well.)
 336 String filenameFromHTTPContentDisposition(const String&amp; value)
 337 {
 338     for (auto&amp; keyValuePair : value.split(&#39;;&#39;)) {
 339         size_t valueStartPos = keyValuePair.find(&#39;=&#39;);
 340         if (valueStartPos == notFound)
</pre>
<hr />
<pre>
 847         case HTTPHeaderName::Date:
 848         case HTTPHeaderName::DNT:
 849         case HTTPHeaderName::Expect:
 850         case HTTPHeaderName::Host:
 851         case HTTPHeaderName::KeepAlive:
 852         case HTTPHeaderName::Origin:
 853         case HTTPHeaderName::Referer:
 854         case HTTPHeaderName::TE:
 855         case HTTPHeaderName::Trailer:
 856         case HTTPHeaderName::TransferEncoding:
 857         case HTTPHeaderName::Upgrade:
 858         case HTTPHeaderName::Via:
 859             return true;
 860         default:
 861             break;
 862         }
 863     }
 864     return startsWithLettersIgnoringASCIICase(name, &quot;sec-&quot;) || startsWithLettersIgnoringASCIICase(name, &quot;proxy-&quot;);
 865 }
 866 
<span class="line-added"> 867 // Implements &lt;https://fetch.spec.whatwg.org/#no-cors-safelisted-request-header-name&gt;.</span>
<span class="line-added"> 868 bool isNoCORSSafelistedRequestHeaderName(const String&amp; name)</span>
<span class="line-added"> 869 {</span>
<span class="line-added"> 870     HTTPHeaderName headerName;</span>
<span class="line-added"> 871     if (findHTTPHeaderName(name, headerName)) {</span>
<span class="line-added"> 872         switch (headerName) {</span>
<span class="line-added"> 873         case HTTPHeaderName::Accept:</span>
<span class="line-added"> 874         case HTTPHeaderName::AcceptLanguage:</span>
<span class="line-added"> 875         case HTTPHeaderName::ContentLanguage:</span>
<span class="line-added"> 876         case HTTPHeaderName::ContentType:</span>
<span class="line-added"> 877             return true;</span>
<span class="line-added"> 878         default:</span>
<span class="line-added"> 879             break;</span>
<span class="line-added"> 880         }</span>
<span class="line-added"> 881     }</span>
<span class="line-added"> 882     return false;</span>
<span class="line-added"> 883 }</span>
<span class="line-added"> 884 </span>
<span class="line-added"> 885 // Implements &lt;https://fetch.spec.whatwg.org/#privileged-no-cors-request-header-name&gt;.</span>
<span class="line-added"> 886 bool isPriviledgedNoCORSRequestHeaderName(const String&amp; name)</span>
<span class="line-added"> 887 {</span>
<span class="line-added"> 888     return equalLettersIgnoringASCIICase(name, &quot;range&quot;);</span>
<span class="line-added"> 889 }</span>
<span class="line-added"> 890 </span>
 891 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-response-header-name&gt;.
 892 bool isForbiddenResponseHeaderName(const String&amp; name)
 893 {
 894     return equalLettersIgnoringASCIICase(name, &quot;set-cookie&quot;) || equalLettersIgnoringASCIICase(name, &quot;set-cookie2&quot;);
 895 }
 896 
 897 // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-method&gt;.
 898 bool isForbiddenMethod(const String&amp; name)
 899 {
 900     return equalLettersIgnoringASCIICase(name, &quot;connect&quot;) || equalLettersIgnoringASCIICase(name, &quot;trace&quot;) || equalLettersIgnoringASCIICase(name, &quot;track&quot;);
 901 }
 902 
 903 bool isSimpleHeader(const String&amp; name, const String&amp; value)
 904 {
 905     HTTPHeaderName headerName;
 906     if (!findHTTPHeaderName(name, headerName))
 907         return false;
 908     return isCrossOriginSafeRequestHeader(headerName, value);
 909 }
 910 
</pre>
<hr />
<pre>
 914     case HTTPHeaderName::CacheControl:
 915     case HTTPHeaderName::ContentLanguage:
 916     case HTTPHeaderName::ContentLength:
 917     case HTTPHeaderName::ContentType:
 918     case HTTPHeaderName::Expires:
 919     case HTTPHeaderName::LastModified:
 920     case HTTPHeaderName::Pragma:
 921     case HTTPHeaderName::Accept:
 922         return true;
 923     case HTTPHeaderName::SetCookie:
 924     case HTTPHeaderName::SetCookie2:
 925         return false;
 926     default:
 927         break;
 928     }
 929     return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
 930 }
 931 
 932 bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
 933 {
<span class="line-modified"> 934 #if ASSERT_ENABLED</span>
 935     HTTPHeaderName headerName;
 936     ASSERT(!findHTTPHeaderName(name, headerName));
 937 #endif
 938     return accessControlExposeHeaderSet.contains(name);
 939 }
 940 
 941 // Implements https://fetch.spec.whatwg.org/#cors-safelisted-request-header
 942 bool isCrossOriginSafeRequestHeader(HTTPHeaderName name, const String&amp; value)
 943 {
 944     switch (name) {
 945     case HTTPHeaderName::Accept:
 946         if (!isValidAcceptHeaderValue(value))
 947             return false;
 948         break;
 949     case HTTPHeaderName::AcceptLanguage:
 950     case HTTPHeaderName::ContentLanguage:
 951         if (!isValidLanguageHeaderValue(value))
 952             return false;
 953         break;
 954     case HTTPHeaderName::ContentType: {
 955         // Preflight is required for MIME types that can not be sent via form submission.
<span class="line-modified"> 956         if (containsCORSUnsafeRequestHeaderBytes(value))</span>
<span class="line-added"> 957             return false;</span>
<span class="line-added"> 958         auto parsedContentType = ParsedContentType::create(value);</span>
<span class="line-added"> 959         if (!parsedContentType)</span>
<span class="line-added"> 960             return false;</span>
<span class="line-added"> 961         String mimeType = parsedContentType-&gt;mimeType();</span>
 962         if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))
 963             return false;
 964         break;
 965     }
 966     default:
 967         // FIXME: Should we also make safe other headers (DPR, Downlink, Save-Data...)? That would require validating their values.
 968         return false;
 969     }
 970     return value.length() &lt;= 128;
 971 }
 972 
 973 // Implements &lt;https://fetch.spec.whatwg.org/#concept-method-normalize&gt;.
 974 String normalizeHTTPMethod(const String&amp; method)
 975 {
 976     const ASCIILiteral methods[] = { &quot;DELETE&quot;_s, &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;POST&quot;_s, &quot;PUT&quot;_s };
 977     for (auto value : methods) {
 978         if (equalIgnoringASCIICase(method, value.characters())) {
 979             // Don&#39;t bother allocating a new string if it&#39;s already all uppercase.
 980             if (method == value)
 981                 break;
 982             return value;
 983         }
 984     }
 985     return method;
 986 }
 987 
<span class="line-added"> 988 // Defined by https://tools.ietf.org/html/rfc7231#section-4.2.1</span>
<span class="line-added"> 989 bool isSafeMethod(const String&amp; method)</span>
<span class="line-added"> 990 {</span>
<span class="line-added"> 991     const ASCIILiteral safeMethods[] = { &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;TRACE&quot;_s };</span>
<span class="line-added"> 992     for (auto value : safeMethods) {</span>
<span class="line-added"> 993         if (equalIgnoringASCIICase(method, value.characters()))</span>
<span class="line-added"> 994             return true;</span>
<span class="line-added"> 995     }</span>
<span class="line-added"> 996     return false;</span>
<span class="line-added"> 997 }</span>
<span class="line-added"> 998 </span>
 999 CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
1000 {
1001     auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
1002 
1003     if (strippedHeader.isEmpty())
1004         return CrossOriginResourcePolicy::None;
1005 
1006     if (strippedHeader == &quot;same-origin&quot;)
1007         return CrossOriginResourcePolicy::SameOrigin;
1008 
1009     if (strippedHeader == &quot;same-site&quot;)
1010         return CrossOriginResourcePolicy::SameSite;
1011 
1012     return CrossOriginResourcePolicy::Invalid;
1013 }
1014 
1015 }
</pre>
</td>
</tr>
</table>
<center><a href="HTTPHeaderNames.in.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPParsers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
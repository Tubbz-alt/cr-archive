diff a/modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_method.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_method.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_method.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_method.cpp
@@ -31,46 +31,47 @@
 #include "JSPluginElementFunctions.h"
 #include "WebCoreJSClientData.h"
 #include "runtime_object.h"
 #include <JavaScriptCore/Error.h>
 #include <JavaScriptCore/FunctionPrototype.h>
+#include <JavaScriptCore/JSGlobalObjectInlines.h>
 
 using namespace WebCore;
 
 namespace JSC {
 
 using namespace Bindings;
 
 WEBCORE_EXPORT const ClassInfo RuntimeMethod::s_info = { "RuntimeMethod", &InternalFunction::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeMethod) };
 
-static EncodedJSValue JSC_HOST_CALL callRuntimeMethod(ExecState*);
+static EncodedJSValue JSC_HOST_CALL callRuntimeMethod(JSGlobalObject*, CallFrame*);
 
-RuntimeMethod::RuntimeMethod(JSGlobalObject* globalObject, Structure* structure, Method* method)
+RuntimeMethod::RuntimeMethod(VM& vm, Structure* structure, Method* method)
     // Callers will need to pass in the right global object corresponding to this native object "method".
-    : InternalFunction(globalObject->vm(), structure, callRuntimeMethod, nullptr)
+    : InternalFunction(vm, structure, callRuntimeMethod, nullptr)
     , m_method(method)
 {
 }
 
 void RuntimeMethod::finishCreation(VM& vm, const String& ident)
 {
     Base::finishCreation(vm, ident);
     ASSERT(inherits(vm, info()));
 }
 
-EncodedJSValue RuntimeMethod::lengthGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)
+EncodedJSValue RuntimeMethod::lengthGetter(JSGlobalObject* exec, EncodedJSValue thisValue, PropertyName)
 {
     VM& vm = exec->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     RuntimeMethod* thisObject = jsDynamicCast<RuntimeMethod*>(vm, JSValue::decode(thisValue));
     if (!thisObject)
         return throwVMTypeError(exec, scope);
     return JSValue::encode(jsNumber(thisObject->m_method->numParameters()));
 }
 
-bool RuntimeMethod::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot &slot)
+bool RuntimeMethod::getOwnPropertySlot(JSObject* object, JSGlobalObject* exec, PropertyName propertyName, PropertySlot &slot)
 {
     VM& vm = exec->vm();
     RuntimeMethod* thisObject = jsCast<RuntimeMethod*>(object);
     if (propertyName == vm.propertyNames->length) {
         slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject->lengthGetter);
@@ -83,39 +84,39 @@
 IsoSubspace* RuntimeMethod::subspaceForImpl(VM& vm)
 {
     return &static_cast<JSVMClientData*>(vm.clientData)->runtimeMethodSpace();
 }
 
-static EncodedJSValue JSC_HOST_CALL callRuntimeMethod(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL callRuntimeMethod(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    RuntimeMethod* method = static_cast<RuntimeMethod*>(exec->jsCallee());
+    RuntimeMethod* method = static_cast<RuntimeMethod*>(callFrame->jsCallee());
 
     if (!method->method())
         return JSValue::encode(jsUndefined());
 
     RefPtr<Instance> instance;
 
-    JSValue thisValue = exec->thisValue();
+    JSValue thisValue = callFrame->thisValue();
     if (thisValue.inherits<RuntimeObject>(vm)) {
         RuntimeObject* runtimeObject = static_cast<RuntimeObject*>(asObject(thisValue));
         instance = runtimeObject->getInternalInstance();
         if (!instance)
-            return JSValue::encode(RuntimeObject::throwInvalidAccessError(exec, scope));
+            return JSValue::encode(RuntimeObject::throwInvalidAccessError(globalObject, scope));
     } else {
         // Calling a runtime object of a plugin element?
         if (thisValue.inherits<JSHTMLElement>(vm))
             instance = pluginInstance(jsCast<JSHTMLElement*>(asObject(thisValue))->wrapped());
         if (!instance)
-            return throwVMTypeError(exec, scope);
+            return throwVMTypeError(globalObject, scope);
     }
     ASSERT(instance);
 
     instance->begin();
-    JSValue result = instance->invokeMethod(exec, method);
+    JSValue result = instance->invokeMethod(globalObject, callFrame, method);
     instance->end();
     return JSValue::encode(result);
 }
 
 }

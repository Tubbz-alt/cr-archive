<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerFetch.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThread.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,10 +28,11 @@</span>
  
  #if ENABLE(SERVICE_WORKER)
  
  #include &quot;CacheStorageProvider.h&quot;
  #include &quot;ContentSecurityPolicyResponseHeaders.h&quot;
<span class="udiff-line-added">+ #include &quot;EventLoop.h&quot;</span>
  #include &quot;EventNames.h&quot;
  #include &quot;ExtendableMessageEvent.h&quot;
  #include &quot;JSDOMPromise.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;PlatformStrategies.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -43,11 +44,10 @@</span>
  #include &quot;WorkerDebuggerProxy.h&quot;
  #include &quot;WorkerLoaderProxy.h&quot;
  #include &quot;WorkerObjectProxy.h&quot;
  #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  #include &lt;JavaScriptCore/RuntimeFlags.h&gt;
<span class="udiff-line-removed">- #include &lt;pal/SessionID.h&gt;</span>
  #include &lt;wtf/NeverDestroyed.h&gt;
  
  using namespace PAL;
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -70,41 +70,39 @@</span>
  
  // FIXME: Use a valid WorkerReportingProxy
  // FIXME: Use a valid WorkerObjectProxy
  // FIXME: Use valid runtime flags
  
<span class="udiff-line-modified-removed">- ServiceWorkerThread::ServiceWorkerThread(const ServiceWorkerContextData&amp; data, PAL::SessionID, String&amp;&amp; userAgent, WorkerLoaderProxy&amp; loaderProxy, WorkerDebuggerProxy&amp; debuggerProxy, IDBClient::IDBConnectionProxy* idbConnectionProxy, SocketProvider* socketProvider)</span>
<span class="udiff-line-modified-removed">-     : WorkerThread(data.scriptURL, emptyString(), &quot;serviceworker:&quot; + Inspector::IdentifiersFactory::createIdentifier(), WTFMove(userAgent), platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine(), data.script, loaderProxy, debuggerProxy, DummyServiceWorkerThreadProxy::shared(), WorkerThreadStartMode::Normal, data.contentSecurityPolicy, false, data.registration.key.topOrigin().securityOrigin().get(), MonotonicTime::now(), idbConnectionProxy, socketProvider, JSC::RuntimeFlags::createAllEnabled(), data.sessionID)</span>
<span class="udiff-line-modified-added">+ ServiceWorkerThread::ServiceWorkerThread(const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, WorkerLoaderProxy&amp; loaderProxy, WorkerDebuggerProxy&amp; debuggerProxy, IDBClient::IDBConnectionProxy* idbConnectionProxy, SocketProvider* socketProvider)</span>
<span class="udiff-line-modified-added">+     : WorkerThread({ data.scriptURL, emptyString(), &quot;serviceworker:&quot; + Inspector::IdentifiersFactory::createIdentifier(), WTFMove(userAgent), platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine(), data.contentSecurityPolicy, false, MonotonicTime::now(), { } }, data.script, loaderProxy, debuggerProxy, DummyServiceWorkerThreadProxy::shared(), WorkerThreadStartMode::Normal, data.registration.key.topOrigin().securityOrigin().get(), idbConnectionProxy, socketProvider, JSC::RuntimeFlags::createAllEnabled())</span>
      , m_data(data.isolatedCopy())
      , m_workerObjectProxy(DummyServiceWorkerThreadProxy::shared())
<span class="udiff-line-added">+     , m_heartBeatTimeout(SWContextManager::singleton().connection()-&gt;shouldUseShortTimeout() ? heartBeatTimeoutForTest : heartBeatTimeout)</span>
<span class="udiff-line-added">+     , m_heartBeatTimer { *this, &amp;ServiceWorkerThread::heartBeatTimerFired }</span>
  {
      AtomString::init();
  }
  
  ServiceWorkerThread::~ServiceWorkerThread() = default;
  
<span class="udiff-line-modified-removed">- Ref&lt;WorkerGlobalScope&gt; ServiceWorkerThread::createWorkerGlobalScope(const URL&amp; url, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, PAL::SessionID sessionID)</span>
<span class="udiff-line-modified-added">+ Ref&lt;WorkerGlobalScope&gt; ServiceWorkerThread::createWorkerGlobalScope(const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin)</span>
  {
<span class="udiff-line-modified-removed">-     UNUSED_PARAM(name);</span>
<span class="udiff-line-removed">-     return ServiceWorkerGlobalScope::create(m_data, url, WTFMove(origin), identifier, userAgent, isOnline, *this, contentSecurityPolicy, shouldBypassMainWorldContentSecurityPolicy, WTFMove(topOrigin), timeOrigin, idbConnectionProxy(), socketProvider(), sessionID);</span>
<span class="udiff-line-modified-added">+     return ServiceWorkerGlobalScope::create(m_data, params, WTFMove(origin), *this, WTFMove(topOrigin), idbConnectionProxy(), socketProvider());</span>
  }
  
  void ServiceWorkerThread::runEventLoop()
  {
      // FIXME: There will be ServiceWorker specific things to do here.
      WorkerThread::runEventLoop();
  }
  
<span class="udiff-line-modified-removed">- void ServiceWorkerThread::postFetchTask(Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)</span>
<span class="udiff-line-modified-added">+ void ServiceWorkerThread::queueTaskToFireFetchEvent(Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)</span>
  {
<span class="udiff-line-modified-removed">-     // FIXME: instead of directly using runLoop(), we should be using something like WorkerGlobalScopeProxy.</span>
<span class="udiff-line-modified-removed">-     // FIXME: request and options come straigth from IPC so are already isolated. We should be able to take benefit of that.</span>
<span class="udiff-line-modified-removed">-     runLoop().postTaskForMode([client = WTFMove(client), clientId, request = request.isolatedCopy(), referrer = referrer.isolatedCopy(), options = options.isolatedCopy()] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="udiff-line-modified-removed">-         context.postTask([client = WTFMove(client), clientId, request = WTFMove(request), referrer = WTFMove(referrer), options = WTFMove(options)] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="udiff-line-removed">-             ServiceWorkerFetch::dispatchFetchEvent(WTFMove(client), downcast&lt;ServiceWorkerGlobalScope&gt;(context), clientId, WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="udiff-line-removed">-         });</span>
<span class="udiff-line-removed">-     }, WorkerRunLoop::defaultMode());</span>
<span class="udiff-line-modified-added">+     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="udiff-line-modified-added">+     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), client = WTFMove(client), clientId, request = WTFMove(request), referrer = WTFMove(referrer), options = WTFMove(options)]() mutable {</span>
<span class="udiff-line-modified-added">+         ServiceWorkerFetch::dispatchFetchEvent(WTFMove(client), serviceWorkerGlobalScope, clientId, WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="udiff-line-modified-added">+     });</span>
  }
  
  static void fireMessageEvent(ServiceWorkerGlobalScope&amp; scope, MessageWithMessagePorts&amp;&amp; message, ExtendableMessageEventSource&amp;&amp; source, const URL&amp; sourceURL)
  {
      auto ports = MessagePort::entanglePorts(scope, WTFMove(message.transferredPorts));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -112,78 +110,193 @@</span>
      scope.dispatchEvent(messageEvent);
      scope.thread().workerObjectProxy().confirmMessageFromWorkerObject(scope.hasPendingActivity());
      scope.updateExtendedEventsSet(messageEvent.ptr());
  }
  
<span class="udiff-line-modified-removed">- void ServiceWorkerThread::postMessageToServiceWorker(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
<span class="udiff-line-modified-added">+ void ServiceWorkerThread::queueTaskToPostMessage(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
  {
<span class="udiff-line-modified-removed">-     runLoop().postTask([message = WTFMove(message), sourceData = WTFMove(sourceData)] (auto&amp; context) mutable {</span>
<span class="udiff-line-modified-removed">-         auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);</span>
<span class="udiff-line-modified-added">+     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="udiff-line-modified-added">+     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), message = WTFMove(message), sourceData = WTFMove(sourceData), serviceWorkerIdentifier = this-&gt;identifier()]() mutable {</span>
          URL sourceURL;
          ExtendableMessageEventSource source;
          if (WTF::holds_alternative&lt;ServiceWorkerClientData&gt;(sourceData)) {
              RefPtr&lt;ServiceWorkerClient&gt; sourceClient = ServiceWorkerClient::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerClientData&gt;(sourceData)));
  
<span class="udiff-line-modified-removed">-             RELEASE_ASSERT(!sourceClient-&gt;url().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope.url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope.url(), sourceClient-&gt;url()));</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT(!sourceClient-&gt;url().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope-&gt;url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope-&gt;url(), sourceClient-&gt;url()));</span>
  
              sourceURL = sourceClient-&gt;url();
              source = WTFMove(sourceClient);
          } else {
              RefPtr&lt;ServiceWorker&gt; sourceWorker = ServiceWorker::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerData&gt;(sourceData)));
  
<span class="udiff-line-modified-removed">-             RELEASE_ASSERT(!sourceWorker-&gt;scriptURL().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope.url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope.url(), sourceWorker-&gt;scriptURL()));</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT(!sourceWorker-&gt;scriptURL().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope-&gt;url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope-&gt;url(), sourceWorker-&gt;scriptURL()));</span>
  
              sourceURL = sourceWorker-&gt;scriptURL();
              source = WTFMove(sourceWorker);
          }
          fireMessageEvent(serviceWorkerGlobalScope, WTFMove(message), ExtendableMessageEventSource { source }, sourceURL);
<span class="udiff-line-added">+         callOnMainThread([serviceWorkerIdentifier] {</span>
<span class="udiff-line-added">+             if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))</span>
<span class="udiff-line-added">+                 serviceWorkerThreadProxy-&gt;thread().finishedFiringMessageEvent();</span>
<span class="udiff-line-added">+         });</span>
      });
  }
  
<span class="udiff-line-modified-removed">- void ServiceWorkerThread::fireInstallEvent()</span>
<span class="udiff-line-modified-added">+ void ServiceWorkerThread::queueTaskToFireInstallEvent()</span>
  {
<span class="udiff-line-modified-removed">-     ScriptExecutionContext::Task task([jobDataIdentifier = m_data.jobDataIdentifier, serviceWorkerIdentifier = this-&gt;identifier()] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="udiff-line-modified-removed">-         context.postTask([jobDataIdentifier, serviceWorkerIdentifier](ScriptExecutionContext&amp; context) {</span>
<span class="udiff-line-modified-removed">-             auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);</span>
<span class="udiff-line-modified-removed">-             auto installEvent = ExtendableEvent::create(eventNames().installEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="udiff-line-removed">-             serviceWorkerGlobalScope.dispatchEvent(installEvent);</span>
<span class="udiff-line-modified-added">+     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="udiff-line-modified-added">+     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), jobDataIdentifier = m_data.jobDataIdentifier, serviceWorkerIdentifier = this-&gt;identifier()] {</span>
<span class="udiff-line-modified-added">+         auto installEvent = ExtendableEvent::create(eventNames().installEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="udiff-line-modified-added">+         serviceWorkerGlobalScope-&gt;dispatchEvent(installEvent);</span>
  
<span class="udiff-line-modified-removed">-             installEvent-&gt;whenAllExtendLifetimePromisesAreSettled([jobDataIdentifier, serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp; extendLifetimePromises) {</span>
<span class="udiff-line-modified-removed">-                 bool hasRejectedAnyPromise = false;</span>
<span class="udiff-line-modified-removed">-                 for (auto&amp; promise : extendLifetimePromises) {</span>
<span class="udiff-line-modified-removed">-                     if (promise-&gt;status() == DOMPromise::Status::Rejected) {</span>
<span class="udiff-line-modified-removed">-                         hasRejectedAnyPromise = true;</span>
<span class="udiff-line-modified-removed">-                         break;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-modified-added">+         installEvent-&gt;whenAllExtendLifetimePromisesAreSettled([jobDataIdentifier, serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp; extendLifetimePromises) {</span>
<span class="udiff-line-modified-added">+             bool hasRejectedAnyPromise = false;</span>
<span class="udiff-line-modified-added">+             for (auto&amp; promise : extendLifetimePromises) {</span>
<span class="udiff-line-modified-added">+                 if (promise-&gt;status() == DOMPromise::Status::Rejected) {</span>
<span class="udiff-line-modified-added">+                     hasRejectedAnyPromise = true;</span>
<span class="udiff-line-modified-added">+                     break;</span>
                  }
<span class="udiff-line-modified-removed">-                 callOnMainThread([jobDataIdentifier, serviceWorkerIdentifier, hasRejectedAnyPromise] () mutable {</span>
<span class="udiff-line-modified-removed">-                     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="udiff-line-modified-removed">-                         connection-&gt;didFinishInstall(jobDataIdentifier, serviceWorkerIdentifier, !hasRejectedAnyPromise);</span>
<span class="udiff-line-modified-removed">-                 });</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-modified-added">+             callOnMainThread([serviceWorkerIdentifier, hasRejectedAnyPromise] {</span>
<span class="udiff-line-modified-added">+                 if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))</span>
<span class="udiff-line-modified-added">+                     serviceWorkerThreadProxy-&gt;thread().finishedFiringInstallEvent(hasRejectedAnyPromise);</span>
              });
          });
      });
<span class="udiff-line-removed">-     runLoop().postTask(WTFMove(task));</span>
  }
  
<span class="udiff-line-modified-removed">- void ServiceWorkerThread::fireActivateEvent()</span>
<span class="udiff-line-modified-added">+ void ServiceWorkerThread::queueTaskToFireActivateEvent()</span>
  {
<span class="udiff-line-modified-removed">-     ScriptExecutionContext::Task task([serviceWorkerIdentifier = this-&gt;identifier()] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="udiff-line-modified-removed">-         context.postTask([serviceWorkerIdentifier](ScriptExecutionContext&amp; context) {</span>
<span class="udiff-line-modified-removed">-             auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);</span>
<span class="udiff-line-modified-removed">-             auto activateEvent = ExtendableEvent::create(eventNames().activateEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="udiff-line-removed">-             serviceWorkerGlobalScope.dispatchEvent(activateEvent);</span>
<span class="udiff-line-modified-added">+     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="udiff-line-modified-added">+     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), serviceWorkerIdentifier = this-&gt;identifier()]() mutable {</span>
<span class="udiff-line-modified-added">+         auto activateEvent = ExtendableEvent::create(eventNames().activateEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="udiff-line-modified-added">+         serviceWorkerGlobalScope-&gt;dispatchEvent(activateEvent);</span>
  
<span class="udiff-line-modified-removed">-             activateEvent-&gt;whenAllExtendLifetimePromisesAreSettled([serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp;) {</span>
<span class="udiff-line-modified-removed">-                 callOnMainThread([serviceWorkerIdentifier] () mutable {</span>
<span class="udiff-line-modified-removed">-                     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="udiff-line-modified-removed">-                         connection-&gt;didFinishActivation(serviceWorkerIdentifier);</span>
<span class="udiff-line-removed">-                 });</span>
<span class="udiff-line-modified-added">+         activateEvent-&gt;whenAllExtendLifetimePromisesAreSettled([serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp;) {</span>
<span class="udiff-line-modified-added">+             callOnMainThread([serviceWorkerIdentifier] {</span>
<span class="udiff-line-modified-added">+                 if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))</span>
<span class="udiff-line-modified-added">+                     serviceWorkerThreadProxy-&gt;thread().finishedFiringActivateEvent();</span>
              });
          });
      });
<span class="udiff-line-modified-removed">-     runLoop().postTask(WTFMove(task));</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::finishedEvaluatingScript()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(!isMainThread());</span>
<span class="udiff-line-added">+     m_doesHandleFetch = workerGlobalScope()-&gt;hasEventListeners(eventNames().fetchEvent);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::start(Function&lt;void(const String&amp;, bool)&gt;&amp;&amp; callback)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_state = State::Starting;</span>
<span class="udiff-line-added">+     startHeartBeatTimer();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     WorkerThread::start([callback = WTFMove(callback), serviceWorkerIdentifier = this-&gt;identifier()](auto&amp; errorMessage) mutable {</span>
<span class="udiff-line-added">+         bool doesHandleFetch = true;</span>
<span class="udiff-line-added">+         if (auto* threadProxy = SWContextManager::singleton().workerByID(serviceWorkerIdentifier)) {</span>
<span class="udiff-line-added">+             threadProxy-&gt;thread().finishedStarting();</span>
<span class="udiff-line-added">+             doesHandleFetch = threadProxy-&gt;thread().doesHandleFetch();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         callback(errorMessage, doesHandleFetch);</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::finishedStarting()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_state = State::Idle;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::startFetchEventMonitoring()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_isHandlingFetchEvent = true;</span>
<span class="udiff-line-added">+     startHeartBeatTimer();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::startHeartBeatTimer()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (m_heartBeatTimer.isActive())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_ongoingHeartBeatCheck = true;</span>
<span class="udiff-line-added">+     runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="udiff-line-added">+         callOnMainThread([this, protectedThis = WTFMove(protectedThis)]() {</span>
<span class="udiff-line-added">+             m_ongoingHeartBeatCheck = false;</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_heartBeatTimer.startOneShot(m_heartBeatTimeout);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::heartBeatTimerFired()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!m_ongoingHeartBeatCheck) {</span>
<span class="udiff-line-added">+         if (m_state == State::Installing || m_state == State::Activating || m_isHandlingFetchEvent || m_messageEventCount)</span>
<span class="udiff-line-added">+             startHeartBeatTimer();</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(identifier());</span>
<span class="udiff-line-added">+     if (!serviceWorkerThreadProxy || serviceWorkerThreadProxy-&gt;isTerminatingOrTerminated())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* connection = SWContextManager::singleton().connection();</span>
<span class="udiff-line-added">+     if (!connection)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     switch (m_state) {</span>
<span class="udiff-line-added">+     case State::Idle:</span>
<span class="udiff-line-added">+     case State::Activating:</span>
<span class="udiff-line-added">+         connection-&gt;didFailHeartBeatCheck(identifier());</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case State::Starting:</span>
<span class="udiff-line-added">+         connection-&gt;serviceWorkerFailedToStart(m_data.jobDataIdentifier, identifier(), &quot;Service Worker script execution timed out&quot;_s);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case State::Installing:</span>
<span class="udiff-line-added">+         connection-&gt;didFinishInstall(m_data.jobDataIdentifier, identifier(), false);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::willPostTaskToFireInstallEvent()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_state = State::Installing;</span>
<span class="udiff-line-added">+     startHeartBeatTimer();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::finishedFiringInstallEvent(bool hasRejectedAnyPromise)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_state = State::Idle;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="udiff-line-added">+         connection-&gt;didFinishInstall(m_data.jobDataIdentifier, identifier(), !hasRejectedAnyPromise);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::willPostTaskToFireActivateEvent()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_state = State::Activating;</span>
<span class="udiff-line-added">+     startHeartBeatTimer();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::finishedFiringActivateEvent()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_state = State::Idle;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="udiff-line-added">+         connection-&gt;didFinishActivation(identifier());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::willPostTaskToFireMessageEvent()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!m_messageEventCount++)</span>
<span class="udiff-line-added">+         startHeartBeatTimer();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void ServiceWorkerThread::finishedFiringMessageEvent()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(m_messageEventCount);</span>
<span class="udiff-line-added">+     --m_messageEventCount;</span>
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
</pre>
<center><a href="ServiceWorkerFetch.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThread.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
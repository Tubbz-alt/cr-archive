<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef MediaPlayerPrivateJava_h
 27 #define MediaPlayerPrivateJava_h
 28 
 29 #include &quot;MediaPlayerPrivate.h&quot;
 30 #include &lt;jni.h&gt;
 31 #include &quot;RQRef.h&quot;
 32 #include &quot;TimeRanges.h&quot;
 33 
 34 namespace WebCore {
 35     class MediaPlayerPrivate : public MediaPlayerPrivateInterface {
 36     public:
 37         static void registerMediaEngine(MediaEngineRegistrar registrar);
 38     private:
 39         //typedef MediaPlayerPrivateInterface* (*CreateMediaEnginePlayer)(MediaPlayer*);
 40         //typedef void (*MediaEngineSupportedTypes)(HashSet&lt;String&gt;&amp; types);
 41         //typedef MediaPlayer::SupportsType (*MediaEngineSupportsType)(const String&amp; type, const String&amp; codecs);
 42         //typedef void (*MediaEngineRegistrar)(CreateMediaEnginePlayer, MediaEngineSupportedTypes, MediaEngineSupportsType);
 43         static void MediaEngineSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types);
 44 
 45         static MediaPlayer::SupportsType MediaEngineSupportsType(const MediaEngineSupportParameters&amp;);
 46 
 47         // the method caches the set
 48         static HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; GetSupportedTypes();
 49 
 50 
 51     private:
 52         MediaPlayerPrivate(MediaPlayer *player);
 53 
 54     public:
 55         virtual ~MediaPlayerPrivate();
 56 
 57         virtual void load(const String&amp; url);
 58         virtual void cancelLoad();
 59 
 60         virtual void prepareToPlay();
 61         //virtual PlatformMedia platformMedia() const { return NoPlatformMedia; }
 62 #if USE(ACCELERATED_COMPOSITING)
 63         //virtual PlatformLayer* platformLayer() const { return 0; }
 64 #endif
 65 
 66         virtual void play();
 67         virtual void pause();
 68 
 69         //virtual bool supportsFullscreen() const { return false; }
 70         //virtual bool supportsSave() const { return false; }
 71 
 72         virtual FloatSize naturalSize() const;
 73 
 74         virtual bool hasVideo() const;
 75         virtual bool hasAudio() const;
 76 
 77         virtual void setVisible(bool);
 78 
 79         virtual float duration() const;
 80 
 81         virtual float currentTime() const;
 82         virtual void seek(float time);
 83         virtual bool seeking() const;
 84 
 85         virtual MediaTime startTime() const;
 86 
 87         virtual void setRate(float);
 88         virtual void setPreservesPitch(bool);
 89 
 90         virtual bool paused() const;
 91 
 92         virtual void setVolume(float);
 93 
 94         virtual bool supportsMuting() const;
 95         virtual void setMuted(bool);
 96 
 97         //virtual bool hasClosedCaptions() const { return false; }
 98         //virtual void setClosedCaptionsVisible(bool) { }
 99 
100         virtual MediaPlayer::NetworkState networkState() const;
101         virtual MediaPlayer::ReadyState readyState() const;
102 
103         virtual float maxTimeSeekable() const;
104         virtual bool didLoadingProgress() const;
105         virtual std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const;
106 
107         virtual unsigned bytesLoaded() const;
108 
109         virtual void setSize(const IntSize&amp;);
110 
111         virtual void paint(GraphicsContext&amp;, const FloatRect&amp;);
112 
113         //virtual void paintCurrentFrameInContext(GraphicsContext* c, const IntRect&amp; r) { paint(c, r); }
114 
115         virtual void setPreload(MediaPlayer::Preload);
116 
117         //virtual bool hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::HaveCurrentData; }
118 
119         //virtual bool canLoadPoster() const { return false; }
120         //virtual void setPoster(const String&amp;) { }
121 
122 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
123 //        virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
124 //        virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
125 //#endif
126 
127 #if USE(ACCELERATED_COMPOSITING)
128         // whether accelerated rendering is supported by the media engine for the current media.
129         //virtual bool supportsAcceleratedRendering() const { return false; }
130         // called when the rendering system flips the into or out of accelerated rendering mode.
131         //virtual void acceleratedRenderingStateChanged() { }
132 #endif
133 
134         virtual bool hasSingleSecurityOrigin() const { return true; }
135 
136         //virtual MediaPlayer::MovieLoadType movieLoadType() const { return MediaPlayer::Unknown; }
137 
138         //virtual double maximumDurationToCacheMediaTime() const { return 0.5; }
139     // implementation
140     public:
141         static inline MediaPlayerPrivate* getPlayer(jlong ptr);
142         void notifyNetworkStateChanged(int networkState);
143         void notifyReadyStateChanged(int readyState);
144         void notifyPaused(bool paused);
145         void notifySeeking(bool seeking);
146         void notifyFinished();
147         void notifyReady(bool hasVideo, bool hasAudio);
148         void notifyDurationChanged(float duration);
149         void notifySizeChanged(int width, int height);
150         void notifyNewFrame();
151         void notifyBufferChanged(std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges, int bytesLoaded);
152 
153     private:
154         MediaPlayer* m_player;
155 
156         volatile MediaPlayer::NetworkState m_networkState;
157         volatile MediaPlayer::ReadyState m_readyState;
158 
159         bool m_isVisible;
160         bool m_hasVideo;
161         bool m_hasAudio;
162         FloatSize m_naturalSize;
163         bool m_paused;
164         bool m_seeking;
165         float m_seekTime;   // valid only when m_seeking is true
166         float m_duration;
167         std::unique_ptr&lt;PlatformTimeRanges&gt; m_buffered;
168         unsigned m_bytesLoaded;
169         mutable bool m_didLoadingProgress;  // mutable because didLoadingProgress() is declared const
170 
171         RefPtr&lt;RQRef&gt; m_jPlayer;
172 
173         void setNetworkState(MediaPlayer::NetworkState networkState);
174         void setReadyState(MediaPlayer::ReadyState readyState);
175     };
176 }
177 
178 #endif // MediaPlayerPrivateJava_h
    </pre>
  </body>
</html>
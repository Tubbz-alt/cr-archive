diff a/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp b/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp
@@ -86,19 +86,19 @@
     if (!m_styleSheetCandidateNodes.isEmpty())
         return false;
     return true;
 }
 
-StyleResolver& Scope::resolver()
+Resolver& Scope::resolver()
 {
     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
         return m_document.userAgentShadowTreeStyleResolver();
 
     if (!m_resolver) {
         SetForScope<bool> isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
 
-        m_resolver = makeUnique<StyleResolver>(m_document);
+        m_resolver = makeUnique<Resolver>(m_document);
 
         if (!m_shadowRoot) {
             m_document.fontSelector().buildStarted();
             m_resolver->ruleSets().initializeUserStyle();
         } else {
@@ -115,11 +115,11 @@
     ASSERT(!m_shadowRoot || &m_document == &m_shadowRoot->document());
     ASSERT(&m_resolver->document() == &m_document);
     return *m_resolver;
 }
 
-StyleResolver* Scope::resolverIfExists()
+Resolver* Scope::resolverIfExists()
 {
     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
         return &m_document.userAgentShadowTreeStyleResolver();
 
     return m_resolver.get();
@@ -379,64 +379,45 @@
         if (sheet)
             sheets.append(WTFMove(sheet));
     }
 }
 
-Scope::StyleResolverUpdateType Scope::analyzeStyleSheetChange(const Vector<RefPtr<CSSStyleSheet>>& newStylesheets, bool& requiresFullStyleRecalc)
+Scope::StyleSheetChange Scope::analyzeStyleSheetChange(const Vector<RefPtr<CSSStyleSheet>>& newStylesheets)
 {
-    requiresFullStyleRecalc = true;
-
     unsigned newStylesheetCount = newStylesheets.size();
 
     if (!resolverIfExists())
-        return Reconstruct;
-
-    auto& styleResolver = *resolverIfExists();
+        return { ResolverUpdateType::Reconstruct };
 
     // Find out which stylesheets are new.
     unsigned oldStylesheetCount = m_activeStyleSheets.size();
     if (newStylesheetCount < oldStylesheetCount)
-        return Reconstruct;
+        return { ResolverUpdateType::Reconstruct };
 
     Vector<StyleSheetContents*> addedSheets;
     unsigned newIndex = 0;
     for (unsigned oldIndex = 0; oldIndex < oldStylesheetCount; ++oldIndex) {
         if (newIndex >= newStylesheetCount)
-            return Reconstruct;
+            return { ResolverUpdateType::Reconstruct };
+
         while (m_activeStyleSheets[oldIndex] != newStylesheets[newIndex]) {
             addedSheets.append(&newStylesheets[newIndex]->contents());
             ++newIndex;
             if (newIndex == newStylesheetCount)
-                return Reconstruct;
+                return { ResolverUpdateType::Reconstruct };
         }
         ++newIndex;
     }
     bool hasInsertions = !addedSheets.isEmpty();
     while (newIndex < newStylesheetCount) {
         addedSheets.append(&newStylesheets[newIndex]->contents());
         ++newIndex;
     }
-    // If all new sheets were added at the end of the list we can just add them to existing StyleResolver.
-    // If there were insertions we need to re-add all the stylesheets so rules are ordered correctly.
-    auto styleResolverUpdateType = hasInsertions ? Reset : Additive;
-
-    // If we are already parsing the body and so may have significant amount of elements, put some effort into trying to avoid style recalcs.
-    if (!m_document.bodyOrFrameset() || m_document.hasNodesWithNonFinalStyle() || m_document.hasNodesWithMissingStyle())
-        return styleResolverUpdateType;
 
-    Invalidator invalidator(addedSheets, styleResolver.mediaQueryEvaluator());
-    if (invalidator.dirtiesAllStyle())
-        return styleResolverUpdateType;
-
-    if (m_shadowRoot)
-        invalidator.invalidateStyle(*m_shadowRoot);
-    else
-        invalidator.invalidateStyle(m_document);
-
-    requiresFullStyleRecalc = false;
-
-    return styleResolverUpdateType;
+    // If all new sheets were added at the end of the list we can just add them to existing Resolver.
+    // If there were insertions we need to re-add all the stylesheets so rules are ordered correctly.
+    return { hasInsertions ? ResolverUpdateType::Reset : ResolverUpdateType::Additive, WTFMove(addedSheets) };
 }
 
 static void filterEnabledNonemptyCSSStyleSheets(Vector<RefPtr<CSSStyleSheet>>& result, const Vector<RefPtr<StyleSheet>>& sheets)
 {
     for (auto& sheet : sheets) {
@@ -451,22 +432,10 @@
             continue;
         result.append(&styleSheet);
     }
 }
 
-static void invalidateHostAndSlottedStyleIfNeeded(ShadowRoot& shadowRoot, StyleResolver& resolver)
-{
-    auto& host = *shadowRoot.host();
-    if (!resolver.ruleSets().authorStyle().hostPseudoClassRules().isEmpty())
-        host.invalidateStyle();
-
-    if (!resolver.ruleSets().authorStyle().slottedPseudoElementRules().isEmpty()) {
-        for (auto& shadowChild : childrenOfType<Element>(host))
-            shadowChild.invalidateStyle();
-    }
-}
-
 void Scope::updateActiveStyleSheets(UpdateType updateType)
 {
     ASSERT(!m_pendingUpdate);
 
     if (!m_document.hasLivingRenderTree())
@@ -487,16 +456,15 @@
     Vector<RefPtr<CSSStyleSheet>> activeCSSStyleSheets;
     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
     filterEnabledNonemptyCSSStyleSheets(activeCSSStyleSheets, activeStyleSheets);
 
-    bool requiresFullStyleRecalc = true;
-    StyleResolverUpdateType styleResolverUpdateType = Reconstruct;
+    auto styleSheetChange = StyleSheetChange { ResolverUpdateType::Reconstruct };
     if (updateType == UpdateType::ActiveSet)
-        styleResolverUpdateType = analyzeStyleSheetChange(activeCSSStyleSheets, requiresFullStyleRecalc);
+        styleSheetChange = analyzeStyleSheetChange(activeCSSStyleSheets);
 
-    updateStyleResolver(activeCSSStyleSheets, styleResolverUpdateType);
+    updateResolver(activeCSSStyleSheets, styleSheetChange.resolverUpdateType);
 
     m_weakCopyOfActiveStyleSheetListForFastLookup = nullptr;
     m_activeStyleSheets.swap(activeCSSStyleSheets);
     m_styleSheetsForStyleSheetList.swap(activeStyleSheets);
 
@@ -505,35 +473,41 @@
     for (const auto& sheet : m_activeStyleSheets) {
         if (sheet->contents().usesStyleBasedEditability())
             m_usesStyleBasedEditability = true;
     }
 
-    // FIXME: Move this code somewhere else.
-    if (requiresFullStyleRecalc) {
-        if (m_shadowRoot) {
-            for (auto& shadowChild : childrenOfType<Element>(*m_shadowRoot))
-                shadowChild.invalidateStyleForSubtree();
-            invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot, resolver());
-        } else
-            m_document.scheduleFullStyleRebuild();
+    invalidateStyleAfterStyleSheetChange(styleSheetChange);
+}
+
+void Scope::invalidateStyleAfterStyleSheetChange(const StyleSheetChange& styleSheetChange)
+{
+    // If we are already parsing the body and so may have significant amount of elements, put some effort into trying to avoid style recalcs.
+    bool invalidateAll = !m_document.bodyOrFrameset() || m_document.hasNodesWithNonFinalStyle() || m_document.hasNodesWithMissingStyle();
+
+    if (styleSheetChange.resolverUpdateType == ResolverUpdateType::Reconstruct || invalidateAll) {
+        Invalidator::invalidateAllStyle(*this);
+        return;
     }
+
+    Invalidator invalidator(styleSheetChange.addedSheets, m_resolver->mediaQueryEvaluator());
+    invalidator.invalidateStyle(*this);
 }
 
-void Scope::updateStyleResolver(Vector<RefPtr<CSSStyleSheet>>& activeStyleSheets, StyleResolverUpdateType updateType)
+void Scope::updateResolver(Vector<RefPtr<CSSStyleSheet>>& activeStyleSheets, ResolverUpdateType updateType)
 {
-    if (updateType == Reconstruct) {
+    if (updateType == ResolverUpdateType::Reconstruct) {
         clearResolver();
         return;
     }
     auto& styleResolver = resolver();
 
     SetForScope<bool> isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
-    if (updateType == Reset) {
+    if (updateType == ResolverUpdateType::Reset) {
         styleResolver.ruleSets().resetAuthorStyle();
         styleResolver.appendAuthorStyleSheets(activeStyleSheets);
     } else {
-        ASSERT(updateType == Additive);
+        ASSERT(updateType == ResolverUpdateType::Additive);
         unsigned firstNewIndex = m_activeStyleSheets.size();
         Vector<RefPtr<CSSStyleSheet>> newStyleSheets;
         newStyleSheets.appendRange(activeStyleSheets.begin() + firstNewIndex, activeStyleSheets.end());
         styleResolver.appendAuthorStyleSheets(newStyleSheets);
     }
@@ -541,10 +515,14 @@
 
 const Vector<RefPtr<CSSStyleSheet>> Scope::activeStyleSheetsForInspector()
 {
     Vector<RefPtr<CSSStyleSheet>> result;
 
+    if (auto* pageUserSheet = m_document.extensionStyleSheets().pageUserSheet())
+        result.append(pageUserSheet);
+    result.appendVector(m_document.extensionStyleSheets().documentUserStyleSheets());
+    result.appendVector(m_document.extensionStyleSheets().injectedUserStyleSheets());
     result.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
     result.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
 
     for (auto& styleSheet : m_styleSheetsForStyleSheetList) {
         if (!is<CSSStyleSheet>(*styleSheet))
@@ -597,15 +575,15 @@
 
 void Scope::scheduleUpdate(UpdateType update)
 {
     if (update == UpdateType::ContentsOrInterpretation) {
         // :host and ::slotted rules might go away.
-        if (m_shadowRoot && m_resolver)
-            invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot, *m_resolver);
+        if (m_shadowRoot)
+            Invalidator::invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot);
         // FIXME: Animation code may trigger resource load in middle of style recalc and that can add a rule to a content extension stylesheet.
         //        Fix and remove isResolvingTreeStyle() test below, see https://bugs.webkit.org/show_bug.cgi?id=194335
-        // FIXME: The m_isUpdatingStyleResolver test is here because extension stylesheets can get us here from StyleResolver::appendAuthorStyleSheets.
+        // FIXME: The m_isUpdatingStyleResolver test is here because extension stylesheets can get us here from Resolver::appendAuthorStyleSheets.
         if (!m_isUpdatingStyleResolver && !m_document.isResolvingTreeStyle())
             clearResolver();
     }
 
     if (!m_pendingUpdate || *m_pendingUpdate < update) {
@@ -619,43 +597,56 @@
     m_pendingUpdateTimer.startOneShot(0_s);
 }
 
 void Scope::evaluateMediaQueriesForViewportChange()
 {
-    evaluateMediaQueries([] (StyleResolver& resolver) {
-        return resolver.hasMediaQueriesAffectedByViewportChange();
+    evaluateMediaQueries([] (Resolver& resolver) {
+        return resolver.evaluateDynamicMediaQueries();
     });
 }
 
 void Scope::evaluateMediaQueriesForAccessibilitySettingsChange()
 {
-    evaluateMediaQueries([] (StyleResolver& resolver) {
-        return resolver.hasMediaQueriesAffectedByAccessibilitySettingsChange();
+    evaluateMediaQueries([] (Resolver& resolver) {
+        return resolver.evaluateDynamicMediaQueries();
     });
 }
 
 void Scope::evaluateMediaQueriesForAppearanceChange()
 {
-    evaluateMediaQueries([] (StyleResolver& resolver) {
-        return resolver.hasMediaQueriesAffectedByAppearanceChange();
+    evaluateMediaQueries([] (Resolver& resolver) {
+        return resolver.evaluateDynamicMediaQueries();
     });
 }
 
 template <typename TestFunction>
 void Scope::evaluateMediaQueries(TestFunction&& testFunction)
 {
+    auto* resolver = resolverIfExists();
+    if (!resolver)
+        return;
+
+    auto evaluationChanges = testFunction(*resolver);
+    if (evaluationChanges) {
+        switch (evaluationChanges->type) {
+        case DynamicMediaQueryEvaluationChanges::Type::InvalidateStyle: {
+            Invalidator invalidator(evaluationChanges->invalidationRuleSets);
+            invalidator.invalidateStyle(*this);
+            break;
+        }
+        case DynamicMediaQueryEvaluationChanges::Type::ResetStyle:
+            scheduleUpdate(UpdateType::ContentsOrInterpretation);
+            break;
+        }
+
+        InspectorInstrumentation::mediaQueryResultChanged(m_document);
+    }
+
     if (!m_shadowRoot) {
         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
             descendantShadowRoot->styleScope().evaluateMediaQueries(testFunction);
     }
-    auto* resolver = resolverIfExists();
-    if (!resolver)
-        return;
-    if (!testFunction(*resolver))
-        return;
-    scheduleUpdate(UpdateType::ContentsOrInterpretation);
-    InspectorInstrumentation::mediaQueryResultChanged(m_document);
 }
 
 void Scope::didChangeActiveStyleSheetCandidates()
 {
     scheduleUpdate(UpdateType::ActiveSet);
@@ -676,10 +667,22 @@
         }
     }
     scheduleUpdate(UpdateType::ContentsOrInterpretation);
 }
 
+void Scope::invalidateMatchedDeclarationsCache()
+{
+    if (!m_shadowRoot) {
+        for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
+            descendantShadowRoot->styleScope().invalidateMatchedDeclarationsCache();
+    }
+
+    if (auto* resolver = resolverIfExists())
+        resolver->invalidateMatchedDeclarationsCache();
+}
+
+
 void Scope::pendingUpdateTimerFired()
 {
     flushPendingUpdate();
 }
 

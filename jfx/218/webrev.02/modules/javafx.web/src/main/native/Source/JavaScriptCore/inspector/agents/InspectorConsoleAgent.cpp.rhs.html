<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorConsoleAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorConsoleAgent.h&quot;
 28 
 29 #include &quot;ConsoleMessage.h&quot;
 30 #include &quot;InjectedScriptManager.h&quot;
 31 #include &quot;InspectorFrontendRouter.h&quot;
 32 #include &quot;InspectorHeapAgent.h&quot;
 33 #include &quot;ScriptArguments.h&quot;
 34 #include &quot;ScriptCallFrame.h&quot;
 35 #include &quot;ScriptCallStack.h&quot;
 36 #include &quot;ScriptCallStackFactory.h&quot;
 37 #include &quot;ScriptObject.h&quot;
 38 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 39 
 40 namespace Inspector {
 41 
<a name="2" id="anc2"></a><span class="line-modified"> 42 static constexpr unsigned maximumConsoleMessages = 100;</span>
<span class="line-modified"> 43 static constexpr int expireConsoleMessagesStep = 10;</span>
 44 
 45 InspectorConsoleAgent::InspectorConsoleAgent(AgentContext&amp; context)
 46     : InspectorAgentBase(&quot;Console&quot;_s)
 47     , m_injectedScriptManager(context.injectedScriptManager)
 48     , m_frontendDispatcher(makeUnique&lt;ConsoleFrontendDispatcher&gt;(context.frontendRouter))
 49     , m_backendDispatcher(ConsoleBackendDispatcher::create(context.backendDispatcher, this))
 50 {
 51 }
 52 
 53 InspectorConsoleAgent::~InspectorConsoleAgent() = default;
 54 
 55 void InspectorConsoleAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 56 {
 57 }
 58 
 59 void InspectorConsoleAgent::willDestroyFrontendAndBackend(DisconnectReason)
 60 {
 61     String errorString;
 62     disable(errorString);
 63 }
 64 
 65 void InspectorConsoleAgent::discardValues()
 66 {
 67     m_consoleMessages.clear();
 68     m_expiredConsoleMessageCount = 0;
 69 }
 70 
 71 void InspectorConsoleAgent::enable(ErrorString&amp;)
 72 {
 73     if (m_enabled)
 74         return;
 75 
 76     m_enabled = true;
 77 
 78     if (m_expiredConsoleMessageCount) {
 79         ConsoleMessage expiredMessage(MessageSource::Other, MessageType::Log, MessageLevel::Warning, makeString(m_expiredConsoleMessageCount, &quot; console messages are not shown.&quot;));
 80         expiredMessage.addToFrontend(*m_frontendDispatcher, m_injectedScriptManager, false);
 81     }
 82 
 83     Vector&lt;std::unique_ptr&lt;ConsoleMessage&gt;&gt; messages;
 84     m_consoleMessages.swap(messages);
 85 
 86     for (size_t i = 0; i &lt; messages.size(); ++i)
 87         messages[i]-&gt;addToFrontend(*m_frontendDispatcher, m_injectedScriptManager, false);
 88 }
 89 
 90 void InspectorConsoleAgent::disable(ErrorString&amp;)
 91 {
 92     if (!m_enabled)
 93         return;
 94 
 95     m_enabled = false;
 96 }
 97 
 98 void InspectorConsoleAgent::clearMessages(ErrorString&amp;)
 99 {
100     m_consoleMessages.clear();
101     m_expiredConsoleMessageCount = 0;
102 
103     m_injectedScriptManager.releaseObjectGroup(&quot;console&quot;_s);
104 
105     if (m_enabled)
106         m_frontendDispatcher-&gt;messagesCleared();
107 }
108 
<a name="3" id="anc3"></a><span class="line-added">109 bool InspectorConsoleAgent::developerExtrasEnabled() const</span>
<span class="line-added">110 {</span>
<span class="line-added">111     return m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled();</span>
<span class="line-added">112 }</span>
<span class="line-added">113 </span>
114 void InspectorConsoleAgent::reset()
115 {
116     ErrorString ignored;
117     clearMessages(ignored);
118 
119     m_times.clear();
120     m_counts.clear();
121 }
122 
123 void InspectorConsoleAgent::addMessageToConsole(std::unique_ptr&lt;ConsoleMessage&gt; message)
124 {
<a name="4" id="anc4"></a>


125     if (message-&gt;type() == MessageType::Clear) {
126         ErrorString ignored;
127         clearMessages(ignored);
128     }
129 
130     addConsoleMessage(WTFMove(message));
131 }
132 
<a name="5" id="anc5"></a><span class="line-modified">133 void InspectorConsoleAgent::startTiming(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
134 {
<a name="6" id="anc6"></a>


135     ASSERT(!label.isNull());
136     if (label.isNull())
137         return;
138 
139     auto result = m_times.add(label, MonotonicTime::now());
140 
141     if (!result.isNewEntry) {
142         // FIXME: Send an enum to the frontend for localization?
143         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; already exists&quot;);
<a name="7" id="anc7"></a><span class="line-modified">144         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, createScriptCallStackForConsole(globalObject, 1)));</span>
145     }
146 }
147 
<a name="8" id="anc8"></a><span class="line-modified">148 void InspectorConsoleAgent::logTiming(JSC::JSGlobalObject* globalObject, const String&amp; label, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
149 {
<a name="9" id="anc9"></a>


150     ASSERT(!label.isNull());
151     if (label.isNull())
152         return;
153 
<a name="10" id="anc10"></a><span class="line-modified">154     auto callStack = createScriptCallStackForConsole(globalObject, 1);</span>
155 
156     auto it = m_times.find(label);
157     if (it == m_times.end()) {
158         // FIXME: Send an enum to the frontend for localization?
159         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
160         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, WTFMove(callStack)));
161         return;
162     }
163 
164     MonotonicTime startTime = it-&gt;value;
165     Seconds elapsed = MonotonicTime::now() - startTime;
166     String message = makeString(label, &quot;: &quot;, FormattedNumber::fixedWidth(elapsed.milliseconds(), 3), &quot;ms&quot;);
167     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Debug, message, WTFMove(arguments), WTFMove(callStack)));
168 }
169 
<a name="11" id="anc11"></a><span class="line-modified">170 void InspectorConsoleAgent::stopTiming(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
171 {
<a name="12" id="anc12"></a>


172     ASSERT(!label.isNull());
173     if (label.isNull())
174         return;
175 
<a name="13" id="anc13"></a><span class="line-modified">176     auto callStack = createScriptCallStackForConsole(globalObject, 1);</span>
177 
178     auto it = m_times.find(label);
179     if (it == m_times.end()) {
180         // FIXME: Send an enum to the frontend for localization?
181         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
182         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, WTFMove(callStack)));
183         return;
184     }
185 
186     MonotonicTime startTime = it-&gt;value;
187     Seconds elapsed = MonotonicTime::now() - startTime;
188     String message = makeString(label, &quot;: &quot;, FormattedNumber::fixedWidth(elapsed.milliseconds(), 3), &quot;ms&quot;);
189     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Debug, message, WTFMove(callStack)));
190 
191     m_times.remove(it);
192 }
193 
194 void InspectorConsoleAgent::takeHeapSnapshot(const String&amp; title)
195 {
<a name="14" id="anc14"></a>


196     if (!m_heapAgent)
197         return;
198 
199     ErrorString ignored;
200     double timestamp;
201     String snapshotData;
202     m_heapAgent-&gt;snapshot(ignored, &amp;timestamp, &amp;snapshotData);
203 
204     m_frontendDispatcher-&gt;heapSnapshot(timestamp, snapshotData, title.isEmpty() ? nullptr : &amp;title);
205 }
206 
<a name="15" id="anc15"></a><span class="line-modified">207 void InspectorConsoleAgent::count(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
208 {
<a name="16" id="anc16"></a>


209     auto result = m_counts.add(label, 1);
210     if (!result.isNewEntry)
211         result.iterator-&gt;value += 1;
212 
213     // FIXME: Web Inspector should have a better UI for counters, but for now we just log an updated counter value.
214 
215     String message = makeString(label, &quot;: &quot;, result.iterator-&gt;value);
<a name="17" id="anc17"></a><span class="line-modified">216     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Log, MessageLevel::Debug, message, createScriptCallStackForConsole(globalObject, 1)));</span>
217 }
218 
<a name="18" id="anc18"></a><span class="line-modified">219 void InspectorConsoleAgent::countReset(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
220 {
<a name="19" id="anc19"></a>


221     auto it = m_counts.find(label);
222     if (it == m_counts.end()) {
223         // FIXME: Send an enum to the frontend for localization?
224         String warning = makeString(&quot;Counter \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
<a name="20" id="anc20"></a><span class="line-modified">225         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Log, MessageLevel::Warning, warning, createScriptCallStackForConsole(globalObject, 1)));</span>
226         return;
227     }
228 
229     it-&gt;value = 0;
230 
231     // FIXME: Web Inspector should have a better UI for counters, but for now we just log an updated counter value.
232 }
233 
234 static bool isGroupMessage(MessageType type)
235 {
236     return type == MessageType::StartGroup
237         || type == MessageType::StartGroupCollapsed
238         || type == MessageType::EndGroup;
239 }
240 
241 void InspectorConsoleAgent::addConsoleMessage(std::unique_ptr&lt;ConsoleMessage&gt; consoleMessage)
242 {
<a name="21" id="anc21"></a>


243     ASSERT_ARG(consoleMessage, consoleMessage);
244 
245     ConsoleMessage* previousMessage = m_consoleMessages.isEmpty() ? nullptr : m_consoleMessages.last().get();
246 
247     if (previousMessage &amp;&amp; !isGroupMessage(previousMessage-&gt;type()) &amp;&amp; previousMessage-&gt;isEqual(consoleMessage.get())) {
248         previousMessage-&gt;incrementCount();
249         if (m_enabled)
250             previousMessage-&gt;updateRepeatCountInConsole(*m_frontendDispatcher);
251     } else {
252         ConsoleMessage* newMessage = consoleMessage.get();
253         m_consoleMessages.append(WTFMove(consoleMessage));
254         if (m_enabled)
255             newMessage-&gt;addToFrontend(*m_frontendDispatcher, m_injectedScriptManager, true);
256 
257         if (m_consoleMessages.size() &gt;= maximumConsoleMessages) {
258             m_expiredConsoleMessageCount += expireConsoleMessagesStep;
259             m_consoleMessages.remove(0, expireConsoleMessagesStep);
260         }
261     }
262 }
263 
264 void InspectorConsoleAgent::getLoggingChannels(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Console::Channel&gt;&gt;&amp; channels)
265 {
266     // Default implementation has no logging channels.
267     channels = JSON::ArrayOf&lt;Protocol::Console::Channel&gt;::create();
268 }
269 
270 void InspectorConsoleAgent::setLoggingChannelLevel(ErrorString&amp; errorString, const String&amp;, const String&amp;)
271 {
272     errorString = &quot;Not supported&quot;_s;
273 }
274 
275 } // namespace Inspector
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp
@@ -27,31 +27,40 @@
 #include "IsoAlignedMemoryAllocator.h"
 #include "MarkedBlock.h"
 
 namespace JSC {
 
-IsoAlignedMemoryAllocator::IsoAlignedMemoryAllocator()
+IsoAlignedMemoryAllocator::IsoAlignedMemoryAllocator(CString name)
+#if ENABLE(MALLOC_HEAP_BREAKDOWN)
+    : m_debugHeap(name.data())
+#endif
 {
+    UNUSED_PARAM(name);
 }
 
 IsoAlignedMemoryAllocator::~IsoAlignedMemoryAllocator()
 {
+#if !ENABLE(MALLOC_HEAP_BREAKDOWN)
     for (unsigned i = 0; i < m_blocks.size(); ++i) {
         void* block = m_blocks[i];
         if (!m_committed[i])
             WTF::fastCommitAlignedMemory(block, MarkedBlock::blockSize);
         fastAlignedFree(block);
     }
+#endif
 }
 
 void* IsoAlignedMemoryAllocator::tryAllocateAlignedMemory(size_t alignment, size_t size)
 {
     // Since this is designed specially for IsoSubspace, we know that we will only be asked to
     // allocate MarkedBlocks.
     RELEASE_ASSERT(alignment == MarkedBlock::blockSize);
     RELEASE_ASSERT(size == MarkedBlock::blockSize);
 
+#if ENABLE(MALLOC_HEAP_BREAKDOWN)
+    return m_debugHeap.memalign(MarkedBlock::blockSize, MarkedBlock::blockSize, true);
+#else
     auto locker = holdLock(m_lock);
 
     m_firstUncommitted = m_committed.findBit(m_firstUncommitted, false);
     if (m_firstUncommitted < m_blocks.size()) {
         m_committed[m_firstUncommitted] = true;
@@ -68,41 +77,55 @@
     m_blockIndices.add(result, index);
     if (m_blocks.capacity() != m_committed.size())
         m_committed.resize(m_blocks.capacity());
     m_committed[index] = true;
     return result;
+#endif
 }
 
 void IsoAlignedMemoryAllocator::freeAlignedMemory(void* basePtr)
 {
+#if ENABLE(MALLOC_HEAP_BREAKDOWN)
+    m_debugHeap.free(basePtr);
+#else
     auto locker = holdLock(m_lock);
 
     auto iter = m_blockIndices.find(basePtr);
     RELEASE_ASSERT(iter != m_blockIndices.end());
     unsigned index = iter->value;
     m_committed[index] = false;
     m_firstUncommitted = std::min(index, m_firstUncommitted);
     WTF::fastDecommitAlignedMemory(basePtr, MarkedBlock::blockSize);
+#endif
 }
 
 void IsoAlignedMemoryAllocator::dump(PrintStream& out) const
 {
     out.print("Iso(", RawPointer(this), ")");
 }
 
-void* IsoAlignedMemoryAllocator::tryAllocateMemory(size_t)
+void* IsoAlignedMemoryAllocator::tryAllocateMemory(size_t size)
 {
-    RELEASE_ASSERT_NOT_REACHED();
+#if ENABLE(MALLOC_HEAP_BREAKDOWN)
+    return m_debugHeap.malloc(size);
+#else
+    return FastMalloc::tryMalloc(size);
+#endif
 }
 
-void IsoAlignedMemoryAllocator::freeMemory(void*)
+void IsoAlignedMemoryAllocator::freeMemory(void* pointer)
 {
-    RELEASE_ASSERT_NOT_REACHED();
+#if ENABLE(MALLOC_HEAP_BREAKDOWN)
+    m_debugHeap.free(pointer);
+#else
+    FastMalloc::free(pointer);
+#endif
 }
 
 void* IsoAlignedMemoryAllocator::tryReallocateMemory(void*, size_t)
 {
+    // In IsoSubspace-managed PreciseAllocation, we must not perform realloc.
     RELEASE_ASSERT_NOT_REACHED();
 }
 
 } // namespace JSC
 

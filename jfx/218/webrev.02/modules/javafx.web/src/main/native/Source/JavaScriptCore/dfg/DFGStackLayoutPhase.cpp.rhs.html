<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStackLayoutPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGStackLayoutPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGGraph.h&quot;
 32 #include &quot;DFGPhase.h&quot;
 33 #include &quot;DFGValueSource.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 class StackLayoutPhase : public Phase {
<a name="2" id="anc2"></a><span class="line-modified"> 39     static constexpr bool verbose = false;</span>
 40 
 41 public:
 42     StackLayoutPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;stack layout&quot;)
 44     {
 45     }
 46 
 47     bool run()
 48     {
 49         // This enumerates the locals that we actually care about and packs them. So for example
 50         // if we use local 1, 3, 4, 5, 7, then we remap them: 1-&gt;0, 3-&gt;1, 4-&gt;2, 5-&gt;3, 7-&gt;4. We
 51         // treat a variable as being &quot;used&quot; if there exists an access to it (SetLocal, GetLocal,
 52         // Flush, PhantomLocal).
 53 
<a name="3" id="anc3"></a><span class="line-modified"> 54         Operands&lt;bool&gt; usedOperands(0, graph().m_localVars, graph().m_tmps, false);</span>
 55 
 56         // Collect those variables that are used from IR.
 57         bool hasNodesThatNeedFixup = false;
 58         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 59             BasicBlock* block = m_graph.block(blockIndex);
 60             if (!block)
 61                 continue;
 62             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
 63                 Node* node = block-&gt;at(nodeIndex);
 64                 switch (node-&gt;op()) {
 65                 case GetLocal:
 66                 case SetLocal:
 67                 case Flush:
 68                 case PhantomLocal: {
 69                     VariableAccessData* variable = node-&gt;variableAccessData();
<a name="4" id="anc4"></a><span class="line-modified"> 70                     if (variable-&gt;operand().isArgument())</span>
 71                         break;
<a name="5" id="anc5"></a><span class="line-modified"> 72                     usedOperands.setOperand(variable-&gt;operand(), true);</span>
 73                     break;
 74                 }
 75 
 76                 case LoadVarargs:
 77                 case ForwardVarargs: {
 78                     LoadVarargsData* data = node-&gt;loadVarargsData();
<a name="6" id="anc6"></a><span class="line-modified"> 79                     usedOperands.setOperand(data-&gt;count, true);</span>

 80                     if (data-&gt;start.isLocal()) {
 81                         // This part really relies on the contiguity of stack layout
 82                         // assignments.
 83                         ASSERT(VirtualRegister(data-&gt;start.offset() + data-&gt;limit - 1).isLocal());
 84                         for (unsigned i = data-&gt;limit; i--;)
<a name="7" id="anc7"></a><span class="line-modified"> 85                             usedOperands.setOperand(VirtualRegister(data-&gt;start.offset() + i), true);</span>
 86                     } // the else case shouldn&#39;t happen.
 87                     hasNodesThatNeedFixup = true;
 88                     break;
 89                 }
 90 
 91                 case PutStack:
 92                 case GetStack: {
 93                     StackAccessData* stack = node-&gt;stackAccessData();
<a name="8" id="anc8"></a><span class="line-modified"> 94                     if (stack-&gt;operand.isArgument())</span>
 95                         break;
<a name="9" id="anc9"></a><span class="line-modified"> 96                     usedOperands.setOperand(stack-&gt;operand, true);</span>
 97                     break;
 98                 }
 99 
100                 default:
101                     break;
102                 }
103             }
104         }
105 
106         for (InlineCallFrameSet::iterator iter = m_graph.m_plan.inlineCallFrames()-&gt;begin(); !!iter; ++iter) {
107             InlineCallFrame* inlineCallFrame = *iter;
108 
109             if (inlineCallFrame-&gt;isVarargs()) {
<a name="10" id="anc10"></a><span class="line-modified">110                 usedOperands.setOperand(VirtualRegister(</span>
<span class="line-modified">111                     CallFrameSlot::argumentCountIncludingThis + inlineCallFrame-&gt;stackOffset), true);</span>
112             }
113 
114             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
<a name="11" id="anc11"></a><span class="line-modified">115                 usedOperands.setOperand(VirtualRegister(</span>
<span class="line-modified">116                     virtualRegisterForArgumentIncludingThis(argument).offset() +</span>
<span class="line-modified">117                     inlineCallFrame-&gt;stackOffset), true);</span>
118             }
119         }
120 
<a name="12" id="anc12"></a><span class="line-modified">121         Vector&lt;unsigned&gt; allocation(usedOperands.size());</span>
122         m_graph.m_nextMachineLocal = codeBlock()-&gt;calleeSaveSpaceAsVirtualRegisters();
<a name="13" id="anc13"></a><span class="line-modified">123         for (unsigned i = 0; i &lt; usedOperands.size(); ++i) {</span>
<span class="line-modified">124             if (!usedOperands.getForOperandIndex(i)) {</span>
125                 allocation[i] = UINT_MAX;
126                 continue;
127             }
128 
129             allocation[i] = m_graph.m_nextMachineLocal++;
130         }
131 
132         for (unsigned i = m_graph.m_variableAccessData.size(); i--;) {
133             VariableAccessData* variable = &amp;m_graph.m_variableAccessData[i];
134             if (!variable-&gt;isRoot())
135                 continue;
136 
<a name="14" id="anc14"></a><span class="line-modified">137             if (variable-&gt;operand().isArgument()) {</span>
<span class="line-modified">138                 variable-&gt;machineLocal() = variable-&gt;operand().virtualRegister();</span>
139                 continue;
140             }
141 
<a name="15" id="anc15"></a><span class="line-modified">142             Operand operand = variable-&gt;operand();</span>
<span class="line-modified">143             size_t index = usedOperands.operandIndex(operand);</span>
<span class="line-added">144             if (index &gt;= allocation.size())</span>
145                 continue;
146 
<a name="16" id="anc16"></a><span class="line-modified">147             if (allocation[index] == UINT_MAX)</span>
148                 continue;
149 
<a name="17" id="anc17"></a><span class="line-modified">150             variable-&gt;machineLocal() = assign(usedOperands, allocation, variable-&gt;operand());</span>
151         }
152 
153         for (StackAccessData* data : m_graph.m_stackAccessData) {
<a name="18" id="anc18"></a><span class="line-modified">154             if (data-&gt;operand.isArgument()) {</span>
<span class="line-modified">155                 data-&gt;machineLocal = data-&gt;operand.virtualRegister();</span>
156                 continue;
157             }
158 
<a name="19" id="anc19"></a><span class="line-modified">159             if (data-&gt;operand.isLocal()) {</span>
<span class="line-modified">160                 if (static_cast&lt;size_t&gt;(data-&gt;operand.toLocal()) &gt;= allocation.size())</span>
<span class="line-modified">161                     continue;</span>
<span class="line-modified">162                 if (allocation[data-&gt;operand.toLocal()] == UINT_MAX)</span>
<span class="line-added">163                     continue;</span>
<span class="line-added">164             }</span>
165 
<a name="20" id="anc20"></a><span class="line-modified">166             data-&gt;machineLocal = assign(usedOperands, allocation, data-&gt;operand);</span>
167         }
168 
169         if (!m_graph.needsScopeRegister())
170             codeBlock()-&gt;setScopeRegister(VirtualRegister());
171         else
<a name="21" id="anc21"></a><span class="line-modified">172             codeBlock()-&gt;setScopeRegister(assign(usedOperands, allocation, codeBlock()-&gt;scopeRegister()));</span>
173 
174         for (unsigned i = m_graph.m_inlineVariableData.size(); i--;) {
175             InlineVariableData data = m_graph.m_inlineVariableData[i];
176             InlineCallFrame* inlineCallFrame = data.inlineCallFrame;
177 
<a name="22" id="anc22"></a><span class="line-modified">178             if (inlineCallFrame-&gt;isVarargs())</span>
<span class="line-modified">179                 inlineCallFrame-&gt;argumentCountRegister = assign(usedOperands, allocation, VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>


180 
181             for (unsigned argument = inlineCallFrame-&gt;argumentsWithFixup.size(); argument--;) {
182                 ArgumentPosition&amp; position = m_graph.m_argumentPositions[
183                     data.argumentPositionStart + argument];
184                 VariableAccessData* variable = position.someVariable();
185                 ValueSource source;
186                 if (!variable)
187                     source = ValueSource(SourceIsDead);
188                 else {
189                     source = ValueSource::forFlushFormat(
190                         variable-&gt;machineLocal(), variable-&gt;flushFormat());
191                 }
192                 inlineCallFrame-&gt;argumentsWithFixup[argument] = source.valueRecovery();
193             }
194 
195             RELEASE_ASSERT(inlineCallFrame-&gt;isClosureCall == !!data.calleeVariable);
196             if (inlineCallFrame-&gt;isClosureCall) {
197                 VariableAccessData* variable = data.calleeVariable-&gt;find();
198                 ValueSource source = ValueSource::forFlushFormat(
199                     variable-&gt;machineLocal(),
200                     variable-&gt;flushFormat());
201                 inlineCallFrame-&gt;calleeRecovery = source.valueRecovery();
202             } else
203                 RELEASE_ASSERT(inlineCallFrame-&gt;calleeRecovery.isConstant());
204         }
205 
206         // Fix Varargs&#39; variable references.
207         if (hasNodesThatNeedFixup) {
208             for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
209                 BasicBlock* block = m_graph.block(blockIndex);
210                 if (!block)
211                     continue;
212                 for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
213                     Node* node = block-&gt;at(nodeIndex);
214                     switch (node-&gt;op()) {
215                     case LoadVarargs:
216                     case ForwardVarargs: {
217                         LoadVarargsData* data = node-&gt;loadVarargsData();
<a name="23" id="anc23"></a><span class="line-modified">218                         data-&gt;machineCount = assign(usedOperands, allocation, data-&gt;count);</span>
<span class="line-modified">219                         data-&gt;machineStart = assign(usedOperands, allocation, data-&gt;start);</span>
220                         break;
221                     }
222 
223                     default:
224                         break;
225                     }
226                 }
227             }
228         }
229 
230         return true;
231     }
232 
233 private:
<a name="24" id="anc24"></a><span class="line-modified">234     VirtualRegister assign(const Operands&lt;bool&gt;&amp; usedOperands, const Vector&lt;unsigned&gt;&amp; allocation, Operand operand)</span>
235     {
<a name="25" id="anc25"></a><span class="line-modified">236         if (operand.isArgument())</span>
<span class="line-modified">237             return operand.virtualRegister();</span>
<span class="line-modified">238 </span>
<span class="line-modified">239         size_t operandIndex = usedOperands.operandIndex(operand);</span>
<span class="line-modified">240         unsigned myAllocation = allocation[operandIndex];</span>
<span class="line-modified">241         if (myAllocation == UINT_MAX)</span>
<span class="line-modified">242             return VirtualRegister();</span>
<span class="line-modified">243         return virtualRegisterForLocal(myAllocation);</span>

244     }
245 };
246 
247 bool performStackLayout(Graph&amp; graph)
248 {
249     return runPhase&lt;StackLayoutPhase&gt;(graph);
250 }
251 
252 } } // namespace JSC::DFG
253 
254 #endif // ENABLE(DFG_JIT)
255 
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryConstructor.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryConstructor.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryConstructor.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryConstructor.cpp
@@ -46,80 +46,80 @@
 /* Source for WebAssemblyMemoryConstructor.lut.h
  @begin constructorTableWebAssemblyMemory
  @end
  */
 
-static EncodedJSValue JSC_HOST_CALL constructJSWebAssemblyMemory(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL constructJSWebAssemblyMemory(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
-    if (exec->argumentCount() != 1)
-        return JSValue::encode(throwException(exec, throwScope, createTypeError(exec, "WebAssembly.Memory expects exactly one argument"_s)));
+    if (callFrame->argumentCount() != 1)
+        return JSValue::encode(throwException(globalObject, throwScope, createTypeError(globalObject, "WebAssembly.Memory expects exactly one argument"_s)));
 
     JSObject* memoryDescriptor;
     {
-        JSValue argument = exec->argument(0);
+        JSValue argument = callFrame->argument(0);
         if (!argument.isObject())
-            return JSValue::encode(throwException(exec, throwScope, createTypeError(exec, "WebAssembly.Memory expects its first argument to be an object"_s)));
+            return JSValue::encode(throwException(globalObject, throwScope, createTypeError(globalObject, "WebAssembly.Memory expects its first argument to be an object"_s)));
         memoryDescriptor = jsCast<JSObject*>(argument);
     }
 
     Wasm::PageCount initialPageCount;
     {
         Identifier initial = Identifier::fromString(vm, "initial");
-        JSValue minSizeValue = memoryDescriptor->get(exec, initial);
+        JSValue minSizeValue = memoryDescriptor->get(globalObject, initial);
         RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
-        uint32_t size = toNonWrappingUint32(exec, minSizeValue);
+        uint32_t size = toNonWrappingUint32(globalObject, minSizeValue);
         RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
         if (!Wasm::PageCount::isValid(size))
-            return JSValue::encode(throwException(exec, throwScope, createRangeError(exec, "WebAssembly.Memory 'initial' page count is too large"_s)));
+            return JSValue::encode(throwException(globalObject, throwScope, createRangeError(globalObject, "WebAssembly.Memory 'initial' page count is too large"_s)));
         if (Wasm::PageCount(size).bytes() > MAX_ARRAY_BUFFER_SIZE)
-            return JSValue::encode(throwException(exec, throwScope, createOutOfMemoryError(exec)));
+            return JSValue::encode(throwException(globalObject, throwScope, createOutOfMemoryError(globalObject)));
         initialPageCount = Wasm::PageCount(size);
     }
 
     Wasm::PageCount maximumPageCount;
     {
         // In WebIDL, "present" means that [[Get]] result is undefined, not [[HasProperty]] result.
         // https://heycam.github.io/webidl/#idl-dictionaries
         Identifier maximum = Identifier::fromString(vm, "maximum");
-        JSValue maxSizeValue = memoryDescriptor->get(exec, maximum);
+        JSValue maxSizeValue = memoryDescriptor->get(globalObject, maximum);
         RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
         if (!maxSizeValue.isUndefined()) {
-            uint32_t size = toNonWrappingUint32(exec, maxSizeValue);
+            uint32_t size = toNonWrappingUint32(globalObject, maxSizeValue);
             RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
             if (!Wasm::PageCount::isValid(size))
-                return JSValue::encode(throwException(exec, throwScope, createRangeError(exec, "WebAssembly.Memory 'maximum' page count is too large"_s)));
+                return JSValue::encode(throwException(globalObject, throwScope, createRangeError(globalObject, "WebAssembly.Memory 'maximum' page count is too large"_s)));
             maximumPageCount = Wasm::PageCount(size);
 
             if (initialPageCount > maximumPageCount) {
-                return JSValue::encode(throwException(exec, throwScope,
-                    createRangeError(exec, "'maximum' page count must be than greater than or equal to the 'initial' page count"_s)));
+                return JSValue::encode(throwException(globalObject, throwScope,
+                    createRangeError(globalObject, "'maximum' page count must be than greater than or equal to the 'initial' page count"_s)));
             }
         }
     }
 
-    auto* jsMemory = JSWebAssemblyMemory::create(exec, vm, exec->lexicalGlobalObject()->webAssemblyMemoryStructure());
+    auto* jsMemory = JSWebAssemblyMemory::tryCreate(globalObject, vm, globalObject->webAssemblyMemoryStructure());
     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
 
     RefPtr<Wasm::Memory> memory = Wasm::Memory::tryCreate(initialPageCount, maximumPageCount,
         [&vm] (Wasm::Memory::NotifyPressure) { vm.heap.collectAsync(CollectionScope::Full); },
         [&vm] (Wasm::Memory::SyncTryToReclaim) { vm.heap.collectSync(CollectionScope::Full); },
         [&vm, jsMemory] (Wasm::Memory::GrowSuccess, Wasm::PageCount oldPageCount, Wasm::PageCount newPageCount) { jsMemory->growSuccessCallback(vm, oldPageCount, newPageCount); });
     if (!memory)
-        return JSValue::encode(throwException(exec, throwScope, createOutOfMemoryError(exec)));
+        return JSValue::encode(throwException(globalObject, throwScope, createOutOfMemoryError(globalObject)));
 
     jsMemory->adopt(memory.releaseNonNull());
 
     return JSValue::encode(jsMemory);
 }
 
-static EncodedJSValue JSC_HOST_CALL callJSWebAssemblyMemory(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL callJSWebAssemblyMemory(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
-    return JSValue::encode(throwConstructorCannotBeCalledAsFunctionTypeError(exec, throwScope, "WebAssembly.Memory"));
+    return JSValue::encode(throwConstructorCannotBeCalledAsFunctionTypeError(globalObject, throwScope, "WebAssembly.Memory"));
 }
 
 WebAssemblyMemoryConstructor* WebAssemblyMemoryConstructor::create(VM& vm, Structure* structure, WebAssemblyMemoryPrototype* thisPrototype)
 {
     auto* constructor = new (NotNull, allocateCell<WebAssemblyMemoryConstructor>(vm.heap)) WebAssemblyMemoryConstructor(vm, structure);
@@ -132,11 +132,11 @@
     return Structure::create(vm, globalObject, prototype, TypeInfo(InternalFunctionType, StructureFlags), info());
 }
 
 void WebAssemblyMemoryConstructor::finishCreation(VM& vm, WebAssemblyMemoryPrototype* prototype)
 {
-    Base::finishCreation(vm, "Memory"_s, NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);
+    Base::finishCreation(vm, "Memory"_s, NameAdditionMode::WithoutStructureTransition);
     putDirectWithoutTransition(vm, vm.propertyNames->prototype, prototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
     putDirectWithoutTransition(vm, vm.propertyNames->length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 }
 
 WebAssemblyMemoryConstructor::WebAssemblyMemoryConstructor(VM& vm, Structure* structure)

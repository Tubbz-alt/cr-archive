diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
- * Copyright (C) 2005-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2005-2020 Apple Inc. All rights reserved.
  * Copyright (C) 2009 Google Inc. All rights reserved.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
@@ -24,12 +24,14 @@
 
 #include <limits.h>
 #include <unicode/ustring.h>
 #include <wtf/ASCIICType.h>
 #include <wtf/CheckedArithmetic.h>
+#include <wtf/DebugHeap.h>
 #include <wtf/Expected.h>
 #include <wtf/MathExtras.h>
+#include <wtf/Packed.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/Vector.h>
 #include <wtf/text/ASCIIFastPath.h>
 #include <wtf/text/ConversionMode.h>
 #include <wtf/text/StringCommon.h>
@@ -92,11 +94,11 @@
     }
 
     void removeString(StringImpl&);
     void printStats();
 
-    static const unsigned s_printStringStatsFrequency = 5000;
+    static constexpr unsigned s_printStringStatsFrequency = 5000;
     static std::atomic<unsigned> s_stringRemovesTillPrintStats;
 
     std::atomic<unsigned> m_refCalls;
     std::atomic<unsigned> m_derefCalls;
 
@@ -158,12 +160,14 @@
 // The actual string inside a StringImpl is immutable, so you can't modify a string using a StringImpl&.
 // We could mark every member function const and always use "const StringImpl&" and "const StringImpl*".
 // Or we could say that "const" doesn't make sense at all and use "StringImpl&" and "StringImpl*" everywhere.
 // Right now we use a mix of both, which makes code more confusing and has no benefit.
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringImpl);
 class StringImpl : private StringImplShape {
-    WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;
+    WTF_MAKE_NONCOPYABLE(StringImpl);
+    WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StringImpl);
 
     friend class AtomStringImpl;
     friend class JSC::LLInt::Data;
     friend class JSC::LLIntOffsetsExtractor;
     friend class PrivateSymbolImpl;
@@ -185,10 +189,11 @@
 
     static constexpr unsigned MaxLength = StringImplShape::MaxLength;
 
     // The bottom 6 bits in the hash are flags.
     static constexpr const unsigned s_flagCount = 6;
+
 private:
     static constexpr const unsigned s_flagMask = (1u << s_flagCount) - 1;
     static_assert(s_flagCount <= StringHasher::flagCount, "StringHasher reserves enough bits for StringImpl flags");
     static constexpr const unsigned s_flagStringKindCount = 4;
 
@@ -211,12 +216,12 @@
 
     // Create a normal 16-bit string with internal storage (BufferInternal).
     explicit StringImpl(unsigned length);
 
     // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
-    StringImpl(MallocPtr<LChar>, unsigned length);
-    StringImpl(MallocPtr<UChar>, unsigned length);
+    template<typename Malloc> StringImpl(MallocPtr<LChar, Malloc>, unsigned length);
+    template<typename Malloc> StringImpl(MallocPtr<UChar, Malloc>, unsigned length);
     enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
     StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
     StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
 
     // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
@@ -248,10 +253,12 @@
     WTF_EXPORT_PRIVATE static Ref<StringImpl> createWithoutCopying(const LChar*, unsigned length);
     WTF_EXPORT_PRIVATE static Ref<StringImpl> createUninitialized(unsigned length, LChar*&);
     WTF_EXPORT_PRIVATE static Ref<StringImpl> createUninitialized(unsigned length, UChar*&);
     template<typename CharacterType> static RefPtr<StringImpl> tryCreateUninitialized(unsigned length, CharacterType*&);
 
+    WTF_EXPORT_PRIVATE static Ref<StringImpl> createStaticStringImpl(const char*, unsigned length);
+
     // Reallocate the StringImpl. The originalString must be only owned by the Ref,
     // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
     // the originalString can't be used after this function.
     static Ref<StringImpl> reallocate(Ref<StringImpl>&& originalString, unsigned length, LChar*& data);
     static Ref<StringImpl> reallocate(Ref<StringImpl>&& originalString, unsigned length, UChar*& data);
@@ -263,12 +270,12 @@
     static constexpr unsigned flagIsAtom() { return s_hashFlagStringKindIsAtom; }
     static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
     static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
     static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
 
-    template<typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity>
-    static Ref<StringImpl> adopt(Vector<CharacterType, inlineCapacity, OverflowHandler, minCapacity>&&);
+    template<typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc>
+    static Ref<StringImpl> adopt(Vector<CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc>&&);
 
     WTF_EXPORT_PRIVATE static Ref<StringImpl> adopt(StringBuffer<UChar>&&);
     WTF_EXPORT_PRIVATE static Ref<StringImpl> adopt(StringBuffer<LChar>&&);
 
     unsigned length() const { return m_length; }
@@ -368,12 +375,11 @@
 
     WTF_EXPORT_PRIVATE static StaticStringImpl s_emptyAtomString;
     ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast<StringImpl*>(&s_emptyAtomString); }
 
     // FIXME: Does this really belong in StringImpl?
-    template<typename CharacterType> static void copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters);
-    static void copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters);
+    template<typename SourceCharacterType, typename DestinationCharacterType> static void copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters);
 
     // Some string features, like reference counting and the atomicity flag, are not
     // thread-safe. We achieve thread safety by isolation, giving each thread
     // its own copy of the string.
     Ref<StringImpl> isolatedCopy() const;
@@ -517,12 +523,12 @@
     template<typename CharacterType> static Expected<Ref<StringImpl>, UTF8ConversionError> reallocateInternal(Ref<StringImpl>&&, unsigned, CharacterType*&);
     template<typename CharacterType> static Ref<StringImpl> createInternal(const CharacterType*, unsigned);
     WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;
 
     // The bottom bit in the ref count indicates a static (immortal) string.
-    static const unsigned s_refCountFlagIsStaticString = 0x1;
-    static const unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.
+    static constexpr unsigned s_refCountFlagIsStaticString = 0x1;
+    static constexpr unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.
 
 #if STRING_STATS
     WTF_EXPORT_PRIVATE static StringStats m_stringStats;
 #endif
 
@@ -532,20 +538,20 @@
 
 using StaticStringImpl = StringImpl::StaticStringImpl;
 
 static_assert(sizeof(StringImpl) == sizeof(StaticStringImpl), "");
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 
 // StringImpls created from StaticStringImpl will ASSERT in the generic ValueCheck<T>::checkConsistency
 // as they are not allocated by fastMalloc. We don't currently have any way to detect that case
 // so we ignore the consistency check for all StringImpl*.
 template<> struct ValueCheck<StringImpl*> {
     static void checkConsistency(const StringImpl*) { }
 };
 
-#endif
+#endif // ASSERT_ENABLED
 
 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);
 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);
 inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast<const LChar*>(b)); }
 WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);
@@ -593,10 +599,13 @@
     typedef StringHash Hash;
 };
 template<> struct DefaultHash<RefPtr<StringImpl>> {
     typedef StringHash Hash;
 };
+template<> struct DefaultHash<PackedPtr<StringImpl>> {
+    using Hash = StringHash;
+};
 
 #define MAKE_STATIC_STRING_IMPL(characters) ([] { \
         static StaticStringImpl impl(characters); \
         return &impl; \
     }())
@@ -856,13 +865,21 @@
     ASSERT(m_length);
 
     STRING_STATS_ADD_16BIT_STRING(m_length);
 }
 
-inline StringImpl::StringImpl(MallocPtr<LChar> characters, unsigned length)
-    : StringImplShape(s_refCountIncrement, length, characters.leakPtr(), s_hashFlag8BitBuffer | StringNormal | BufferOwned)
+template<typename Malloc>
+inline StringImpl::StringImpl(MallocPtr<LChar, Malloc> characters, unsigned length)
+    : StringImplShape(s_refCountIncrement, length, static_cast<const LChar*>(nullptr), s_hashFlag8BitBuffer | StringNormal | BufferOwned)
 {
+    if constexpr (std::is_same<Malloc, StringImplMalloc>::value)
+        m_data8 = characters.leakPtr();
+    else {
+        m_data8 = static_cast<const LChar*>(StringImplMalloc::malloc(length));
+        memcpy((void*)m_data8, characters.get(), length);
+    }
+
     ASSERT(m_data8);
     ASSERT(m_length);
 
     STRING_STATS_ADD_8BIT_STRING(m_length);
 }
@@ -883,13 +900,21 @@
     ASSERT(m_length);
 
     STRING_STATS_ADD_8BIT_STRING(m_length);
 }
 
-inline StringImpl::StringImpl(MallocPtr<UChar> characters, unsigned length)
-    : StringImplShape(s_refCountIncrement, length, characters.leakPtr(), StringNormal | BufferOwned)
+template<typename Malloc>
+inline StringImpl::StringImpl(MallocPtr<UChar, Malloc> characters, unsigned length)
+    : StringImplShape(s_refCountIncrement, length, static_cast<const UChar*>(nullptr), StringNormal | BufferOwned)
 {
+    if constexpr (std::is_same<Malloc, StringImplMalloc>::value)
+        m_data16 = characters.leakPtr();
+    else {
+        m_data16 = static_cast<const UChar*>(StringImplMalloc::malloc(length * sizeof(UChar)));
+        memcpy((void*)m_data16, characters.get(), length * sizeof(UChar));
+    }
+
     ASSERT(m_data16);
     ASSERT(m_length);
 
     STRING_STATS_ADD_16BIT_STRING(m_length);
 }
@@ -943,11 +968,11 @@
     }
 
     auto* ownerRep = ((rep.bufferOwnership() == BufferSubstring) ? rep.substringBuffer() : &rep);
 
     // We allocate a buffer that contains both the StringImpl struct as well as the pointer to the owner string.
-    auto* stringImpl = static_cast<StringImpl*>(fastMalloc(substringSize));
+    auto* stringImpl = static_cast<StringImpl*>(StringImplMalloc::malloc(substringSize));
     if (rep.is8Bit())
         return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data8 + offset, length, *ownerRep));
     return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data16 + offset, length, *ownerRep));
 }
 
@@ -969,27 +994,38 @@
     if (length > maxInternalLength<CharacterType>()) {
         output = nullptr;
         return nullptr;
     }
     StringImpl* result;
-    if (!tryFastMalloc(allocationSize<CharacterType>(length)).getValue(result)) {
+
+    result = (StringImpl*)StringImplMalloc::tryMalloc(allocationSize<CharacterType>(length));
+    if (!result) {
         output = nullptr;
         return nullptr;
     }
     output = result->tailPointer<CharacterType>();
 
     return constructInternal<CharacterType>(*result, length);
 }
 
-template<typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity>
-inline Ref<StringImpl> StringImpl::adopt(Vector<CharacterType, inlineCapacity, OverflowHandler, minCapacity>&& vector)
+template<typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc>
+inline Ref<StringImpl> StringImpl::adopt(Vector<CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc>&& vector)
 {
     if (size_t size = vector.size()) {
         ASSERT(vector.data());
         if (size > MaxLength)
             CRASH();
-        return adoptRef(*new StringImpl(vector.releaseBuffer(), size));
+
+        if constexpr (std::is_same<Malloc, StringImplMalloc>::value)
+            return adoptRef(*new StringImpl(vector.releaseBuffer(), size));
+        else {
+            // We have to copy between malloc zones.
+            auto vectorBuffer = vector.releaseBuffer();
+            auto stringImplBuffer = MallocPtr<CharacterType, StringImplMalloc>::malloc(size);
+            memcpy(stringImplBuffer.get(), vectorBuffer.get(), size);
+            return adoptRef(*new StringImpl(WTFMove(stringImplBuffer), size));
+        }
     }
     return *empty();
 }
 
 inline size_t StringImpl::cost() const
@@ -1072,23 +1108,27 @@
         return;
     }
     m_refCount = tempRefCount;
 }
 
-template<typename CharacterType> inline void StringImpl::copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters)
+template<typename SourceCharacterType, typename DestinationCharacterType>
+inline void StringImpl::copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters)
 {
-    if (numCharacters == 1) {
-        *destination = *source;
-        return;
+    static_assert(std::is_same<SourceCharacterType, LChar>::value || std::is_same<SourceCharacterType, UChar>::value);
+    static_assert(std::is_same<DestinationCharacterType, LChar>::value || std::is_same<DestinationCharacterType, UChar>::value);
+    if constexpr (std::is_same<SourceCharacterType, DestinationCharacterType>::value) {
+        if (numCharacters == 1) {
+            *destination = *source;
+            return;
+        }
+        memcpy(destination, source, numCharacters * sizeof(DestinationCharacterType));
+    } else {
+        // FIXME: We should ensure that UChar -> LChar copying happens when UChar only contains Latin-1.
+        // https://bugs.webkit.org/show_bug.cgi?id=205355
+        for (unsigned i = 0; i < numCharacters; ++i)
+            destination[i] = source[i];
     }
-    memcpy(destination, source, numCharacters * sizeof(CharacterType));
-}
-
-ALWAYS_INLINE void StringImpl::copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters)
-{
-    for (unsigned i = 0; i < numCharacters; ++i)
-        destination[i] = source[i];
 }
 
 inline UChar StringImpl::at(unsigned i) const
 {
     ASSERT_WITH_SECURITY_IMPLICATION(i < m_length);

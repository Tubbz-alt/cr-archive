<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/encryptedmedia/clearkey/CDMClearKey.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Metrological Group B.V.
  3  * Copyright (C) 2016 Igalia S.L.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials provided
 14  *    with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;CDMClearKey.h&quot;
 31 
 32 #if ENABLE(ENCRYPTED_MEDIA)
 33 
 34 #include &quot;CDMKeySystemConfiguration.h&quot;
 35 #include &quot;CDMRestrictions.h&quot;
 36 #include &quot;CDMSessionType.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;SharedBuffer.h&quot;
 39 #include &lt;wtf/JSONValues.h&gt;
 40 #include &lt;wtf/MainThread.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/text/Base64.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 // ClearKey CENC SystemID.
 47 // https://www.w3.org/TR/eme-initdata-cenc/#common-system
 48 const uint8_t clearKeyCencSystemId[] = { 0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02, 0xac, 0xe3, 0x3c, 0x1e, 0x52, 0xe2, 0xfb, 0x4b };
 49 const unsigned clearKeyCencSystemIdSize = sizeof(clearKeyCencSystemId);
 50 const unsigned keyIdSize = 16;
 51 
 52 class ClearKeyState {
 53     using KeyStore = HashMap&lt;String, Vector&lt;CDMInstanceClearKey::Key&gt;&gt;;
 54 
 55 public:
 56     static ClearKeyState&amp; singleton();
 57 
 58     KeyStore&amp; keys() { return m_keys; }
 59 
 60 private:
 61     friend class NeverDestroyed&lt;ClearKeyState&gt;;
 62     ClearKeyState();
 63     KeyStore m_keys;
 64 };
 65 
 66 ClearKeyState&amp; ClearKeyState::singleton()
 67 {
 68     static NeverDestroyed&lt;ClearKeyState&gt; s_state;
 69     return s_state;
 70 }
 71 
 72 ClearKeyState::ClearKeyState() = default;
 73 
 74 static RefPtr&lt;JSON::Object&gt; parseJSONObject(const SharedBuffer&amp; buffer)
 75 {
 76     // Fail on large buffers whose size doesn&#39;t fit into a 32-bit unsigned integer.
 77     size_t size = buffer.size();
 78     if (size &gt; std::numeric_limits&lt;unsigned&gt;::max())
 79         return nullptr;
 80 
 81     // Parse the buffer contents as JSON, returning the root object (if any).
 82     String json { buffer.data(), static_cast&lt;unsigned&gt;(size) };
 83     RefPtr&lt;JSON::Value&gt; value;
 84     RefPtr&lt;JSON::Object&gt; object;
 85     if (!JSON::Value::parseJSON(json, value) || !value-&gt;asObject(object))
 86         return nullptr;
 87 
 88     return object;
 89 }
 90 
 91 static Optional&lt;Vector&lt;CDMInstanceClearKey::Key&gt;&gt; parseLicenseFormat(const JSON::Object&amp; root)
 92 {
 93     // If the &#39;keys&#39; key is present in the root object, parse the JSON further
 94     // according to the specified &#39;license&#39; format.
 95     auto it = root.find(&quot;keys&quot;);
 96     if (it == root.end())
 97         return WTF::nullopt;
 98 
 99     // Retrieve the keys array.
100     RefPtr&lt;JSON::Array&gt; keysArray;
101     if (!it-&gt;value-&gt;asArray(keysArray))
102         return WTF::nullopt;
103 
104     Vector&lt;CDMInstanceClearKey::Key&gt; decodedKeys;
105     bool validFormat = std::all_of(keysArray-&gt;begin(), keysArray-&gt;end(),
106         [&amp;decodedKeys] (const auto&amp; value) {
107             RefPtr&lt;JSON::Object&gt; keyObject;
108             if (!value-&gt;asObject(keyObject))
109                 return false;
110 
111             String keyType;
112             if (!keyObject-&gt;getString(&quot;kty&quot;, keyType) || !equalLettersIgnoringASCIICase(keyType, &quot;oct&quot;))
113                 return false;
114 
115             String keyID, keyValue;
116             if (!keyObject-&gt;getString(&quot;kid&quot;, keyID) || !keyObject-&gt;getString(&quot;k&quot;, keyValue))
117                 return false;
118 
119             Vector&lt;char&gt; keyIDData, keyValueData;
120             if (!WTF::base64URLDecode(keyID, { keyIDData }) || !WTF::base64URLDecode(keyValue, { keyValueData }))
121                 return false;
122 
123             decodedKeys.append({ CDMInstanceSession::KeyStatus::Usable, SharedBuffer::create(WTFMove(keyIDData)), SharedBuffer::create(WTFMove(keyValueData)) });
124             return true;
125         });
126     if (!validFormat)
127         return WTF::nullopt;
128     return decodedKeys;
129 }
130 
131 static bool parseLicenseReleaseAcknowledgementFormat(const JSON::Object&amp; root)
132 {
133     // If the &#39;kids&#39; key is present in the root object, parse the JSON further
134     // according to the specified &#39;license release acknowledgement&#39; format.
135     auto it = root.find(&quot;kids&quot;);
136     if (it == root.end())
137         return false;
138 
139     // Retrieve the kids array.
140     RefPtr&lt;JSON::Array&gt; kidsArray;
141     if (!it-&gt;value-&gt;asArray(kidsArray))
142         return false;
143 
144     // FIXME: Return the key IDs and validate them.
145     return true;
146 }
147 
148 // https://www.w3.org/TR/eme-initdata-cenc/#common-system
149 // 4.1 Definition
150 // The SystemID is 1077efec-c0b2-4d02-ace3-3c1e52e2fb4b.
151 // The PSSH box format is as follows. It follows version 1 of the &#39;pssh&#39; box as defined in [CENC].
152 // pssh = [
153 // 0x00, 0x00, 0x00, 0x4c, 0x70, 0x73, 0x73, 0x68, // BMFF box header (76 bytes, &#39;pssh&#39;)
154 // 0x01, 0x00, 0x00, 0x00,                         // Full box header (version = 1, flags = 0)
155 // 0x10, 0x77, 0xef, 0xec, 0xc0, 0xb2, 0x4d, 0x02, // SystemID
156 // 0xac, 0xe3, 0x3c, 0x1e, 0x52, 0xe2, 0xfb, 0x4b,
157 // 0x00, 0x00, 0x00, 0x02,                         // KidCount (2)
158 // 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, // First KID (&quot;0123456789012345&quot;)
159 // 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
160 // 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, // Second KID (&quot;ABCDEFGHIJKLMNOP&quot;)
161 // 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
162 // 0x00, 0x00, 0x00, 0x00,                         // Size of Data (0)
163 // ];
164 
165 // This function extracts the KeyIds count and the location of the first KeyId in initData buffer.
166 static std::pair&lt;unsigned, unsigned&gt; extractKeyidsLocationFromCencInitData(const SharedBuffer&amp; initData)
167 {
168     std::pair&lt;unsigned, unsigned&gt; keyIdsMap(0, 0);
169 
170     // Check the initData size.
171     if (initData.isEmpty() || initData.size() &gt; std::numeric_limits&lt;unsigned&gt;::max())
172         return keyIdsMap;
173 
174     const char* data = initData.data();
175     unsigned initDataSize = initData.size();
176     unsigned index = 0;
177     unsigned psshSize = 0;
178 
179     // Search in the concatenated or the simple InitData, the ClearKey PSSH.
180     bool foundPssh = false;
181     while (true) {
182 
183         // Check the overflow InitData.
184         if (index + 12 + clearKeyCencSystemIdSize &gt;= initDataSize)
185             return keyIdsMap;
186 
187         psshSize = data[index + 2] * 256 + data[index + 3];
188 
189         // Check the pssh size
190         if (!psshSize)
191             return keyIdsMap;
192 
193         // 12 = BMFF box header + Full box header.
194         if (!memcmp(&amp;data[index + 12], clearKeyCencSystemId, clearKeyCencSystemIdSize)) {
195             foundPssh = true;
196             break;
197         }
198         index += psshSize;
199     }
200 
201     // Check if the InitData contains the ClearKey PSSH.
202     if (!foundPssh)
203         return keyIdsMap;
204 
205     index += (12 + clearKeyCencSystemIdSize); // 12 (BMFF box header + Full box header) + SystemID size.
206 
207     // Check the overflow.
208     if (index + 3 &gt;= initDataSize)
209         return keyIdsMap;
210 
211     keyIdsMap.first = data[index + 3]; // Read the KeyIdsCount.
212     index += 4; // KeyIdsCount size.
213 
214     // Check the overflow.
215     if ((index + (keyIdsMap.first * keyIdSize)) &gt;= initDataSize)
216         return keyIdsMap;
217 
218     keyIdsMap.second = index; // The location of the first KeyId in initData.
219 
220     return keyIdsMap;
221 }
222 
223 // This function checks if the initData sharedBuffer is a valid CENC initData.
224 static bool isCencInitData(const SharedBuffer&amp; initData)
225 {
226     std::pair&lt;unsigned, unsigned&gt; keyIdsMap = extractKeyidsLocationFromCencInitData(initData);
227     return ((keyIdsMap.first) &amp;&amp; (keyIdsMap.second));
228 }
229 
230 static Ref&lt;SharedBuffer&gt; extractKeyidsFromCencInitData(const SharedBuffer&amp; initData)
231 {
232     Ref&lt;SharedBuffer&gt; keyIds = SharedBuffer::create();
233 
234     std::pair&lt;unsigned, unsigned&gt; keyIdsMap = extractKeyidsLocationFromCencInitData(initData);
235     unsigned keyIdCount = keyIdsMap.first;
236     unsigned index = keyIdsMap.second;
237 
238     // Check if initData is a valid CENC initData.
239     if (!keyIdCount || !index)
240         return keyIds;
241 
242     const char* data = initData.data();
243 
244     auto object = JSON::Object::create();
245     auto keyIdsArray = JSON::Array::create();
246 
247     // Read the KeyId
248     // 9.1.3 License Request Format
249     // This section describes the format of the license request provided to the application via the message attribute of the message event.
250     // The format is a JSON object containing the following members:
251     // &quot;kids&quot;
252     // An array of key IDs. Each element of the array is the base64url encoding of the octet sequence containing the key ID value.
253     for (unsigned i = 0; i &lt; keyIdCount; i++) {
254         String keyId = WTF::base64URLEncode(&amp;data[index], keyIdSize);
255         keyIdsArray-&gt;pushString(keyId);
256         index += keyIdSize;
257     }
258 
259     object-&gt;setArray(&quot;kids&quot;, WTFMove(keyIdsArray));
260     CString jsonData = object-&gt;toJSONString().utf8();
261     keyIds-&gt;append(jsonData.data(), jsonData.length());
262     return keyIds;
263 }
264 
265 static Ref&lt;SharedBuffer&gt; extractKeyIdFromWebMInitData(const SharedBuffer&amp; initData)
266 {
267     Ref&lt;SharedBuffer&gt; keyIds = SharedBuffer::create();
268 
269     // Check if initData is a valid WebM initData.
270     if (initData.isEmpty() || initData.size() &gt; std::numeric_limits&lt;unsigned&gt;::max())
271         return keyIds;
272 
273     auto object = JSON::Object::create();
274     auto keyIdsArray = JSON::Array::create();
275 
276     // Read the KeyId
277     // 9.1.3 License Request Format
278     // This section describes the format of the license request provided to the application via the message attribute of the message event.
279     // The format is a JSON object containing the following members:
280     // &quot;kids&quot;
281     // An array of key IDs. Each element of the array is the base64url encoding of the octet sequence containing the key ID value.
282     String keyId = WTF::base64URLEncode(initData.data(), initData.size());
283     keyIdsArray-&gt;pushString(keyId);
284 
285     object-&gt;setArray(&quot;kids&quot;, WTFMove(keyIdsArray));
286     CString jsonData = object-&gt;toJSONString().utf8();
287     keyIds-&gt;append(jsonData.data(), jsonData.length());
288     return keyIds;
289 }
290 
291 CDMFactoryClearKey&amp; CDMFactoryClearKey::singleton()
292 {
293     static NeverDestroyed&lt;CDMFactoryClearKey&gt; s_factory;
294     return s_factory;
295 }
296 
297 CDMFactoryClearKey::CDMFactoryClearKey() = default;
298 CDMFactoryClearKey::~CDMFactoryClearKey() = default;
299 
300 std::unique_ptr&lt;CDMPrivate&gt; CDMFactoryClearKey::createCDM(const String&amp; keySystem)
301 {
302 #ifdef NDEBUG
303     UNUSED_PARAM(keySystem);
304 #else
305     ASSERT(supportsKeySystem(keySystem));
306 #endif
307     return makeUnique&lt;CDMPrivateClearKey&gt;();
308 }
309 
310 bool CDMFactoryClearKey::supportsKeySystem(const String&amp; keySystem)
311 {
312     // `org.w3.clearkey` is the only supported key system.
313     return equalLettersIgnoringASCIICase(keySystem, &quot;org.w3.clearkey&quot;);
314 }
315 
316 CDMPrivateClearKey::CDMPrivateClearKey() = default;
317 CDMPrivateClearKey::~CDMPrivateClearKey() = default;
318 
319 bool CDMPrivateClearKey::supportsInitDataType(const AtomString&amp; initDataType) const
320 {
321     // `keyids` and &#39;cenc&#39; are the only supported init data type.
322     return (equalLettersIgnoringASCIICase(initDataType, &quot;keyids&quot;) || equalLettersIgnoringASCIICase(initDataType, &quot;cenc&quot;) || equalLettersIgnoringASCIICase(initDataType, &quot;webm&quot;));
323 }
324 
325 static bool containsPersistentLicenseType(const Vector&lt;CDMSessionType&gt;&amp; types)
326 {
327     return std::any_of(types.begin(), types.end(),
328         [] (auto&amp; sessionType) { return sessionType == CDMSessionType::PersistentLicense; });
329 }
330 
331 bool CDMPrivateClearKey::supportsConfiguration(const CDMKeySystemConfiguration&amp; configuration) const
332 {
333     // Reject any configuration that marks distinctive identifier as required.
334     if (configuration.distinctiveIdentifier == CDMRequirement::Required)
335         return false;
336 
337     // Reject any configuration that marks persistent state as required, unless
338     // the &#39;persistent-license&#39; session type has to be supported.
339     if (configuration.persistentState == CDMRequirement::Required &amp;&amp; !containsPersistentLicenseType(configuration.sessionTypes))
340         return false;
341 
342     return true;
343 }
344 
345 bool CDMPrivateClearKey::supportsConfigurationWithRestrictions(const CDMKeySystemConfiguration&amp; configuration, const CDMRestrictions&amp; restrictions) const
346 {
347     // Reject any configuration that marks distincitive identifier as required, or that marks
348     // distinctive identifier as optional even when restrictions mark it as denied.
349     if ((configuration.distinctiveIdentifier == CDMRequirement::Optional &amp;&amp; restrictions.distinctiveIdentifierDenied)
350         || configuration.distinctiveIdentifier == CDMRequirement::Required)
351         return false;
352 
353     // Reject any configuration that marks persistent state as optional even when
354     // restrictions mark it as denied.
355     if (configuration.persistentState == CDMRequirement::Optional &amp;&amp; restrictions.persistentStateDenied)
356         return false;
357 
358     // Reject any configuration that marks persistent state as required, unless
359     // the &#39;persistent-license&#39; session type has to be supported.
360     if (configuration.persistentState == CDMRequirement::Required &amp;&amp; !containsPersistentLicenseType(configuration.sessionTypes))
361         return false;
362 
363     return true;
364 }
365 
366 bool CDMPrivateClearKey::supportsSessionTypeWithConfiguration(CDMSessionType&amp; sessionType, const CDMKeySystemConfiguration&amp; configuration) const
367 {
368     // Only support the &#39;temporary&#39; and &#39;persistent-license&#39; session types.
369     if (sessionType != CDMSessionType::Temporary &amp;&amp; sessionType != CDMSessionType::PersistentLicense)
370         return false;
371     return supportsConfiguration(configuration);
372 }
373 
374 bool CDMPrivateClearKey::supportsRobustness(const String&amp; robustness) const
375 {
376     // Only empty `robustness` string is supported.
377     return robustness.isEmpty();
378 }
379 
380 CDMRequirement CDMPrivateClearKey::distinctiveIdentifiersRequirement(const CDMKeySystemConfiguration&amp;, const CDMRestrictions&amp; restrictions) const
381 {
382     // Distinctive identifier is not allowed if it&#39;s been denied, otherwise it&#39;s optional.
383     if (restrictions.distinctiveIdentifierDenied)
384         return CDMRequirement::NotAllowed;
385     return CDMRequirement::Optional;
386 }
387 
388 CDMRequirement CDMPrivateClearKey::persistentStateRequirement(const CDMKeySystemConfiguration&amp;, const CDMRestrictions&amp; restrictions) const
389 {
390     // Persistent state is not allowed if it&#39;s been denied, otherwise it&#39;s optional.
391     if (restrictions.persistentStateDenied)
392         return CDMRequirement::NotAllowed;
393     return CDMRequirement::Optional;
394 }
395 
396 bool CDMPrivateClearKey::distinctiveIdentifiersAreUniquePerOriginAndClearable(const CDMKeySystemConfiguration&amp;) const
397 {
398     return false;
399 }
400 
401 RefPtr&lt;CDMInstance&gt; CDMPrivateClearKey::createInstance()
402 {
403     return adoptRef(new CDMInstanceClearKey);
404 }
405 
406 void CDMPrivateClearKey::loadAndInitialize()
407 {
408     // No-op.
409 }
410 
411 bool CDMPrivateClearKey::supportsServerCertificates() const
412 {
413     // Server certificates are not supported.
414     return false;
415 }
416 
417 bool CDMPrivateClearKey::supportsSessions() const
418 {
419     // Sessions are supported.
420     return true;
421 }
422 
423 bool CDMPrivateClearKey::supportsInitData(const AtomString&amp; initDataType, const SharedBuffer&amp; initData) const
424 {
425     // Validate the initData buffer as an JSON object in keyids case.
426     if (equalLettersIgnoringASCIICase(initDataType, &quot;keyids&quot;) &amp;&amp; parseJSONObject(initData))
427         return true;
428 
429     // Validate the initData buffer as CENC initData.
430     if (equalLettersIgnoringASCIICase(initDataType, &quot;cenc&quot;) &amp;&amp; isCencInitData(initData))
431         return true;
432 
433     // Validate the initData buffer as WebM initData.
434     if (equalLettersIgnoringASCIICase(initDataType, &quot;webm&quot;) &amp;&amp; !initData.isEmpty())
435         return true;
436 
437     return false;
438 }
439 
440 RefPtr&lt;SharedBuffer&gt; CDMPrivateClearKey::sanitizeResponse(const SharedBuffer&amp; response) const
441 {
442     // Validate the response buffer as an JSON object.
443     if (!parseJSONObject(response))
444         return nullptr;
445 
446     return response.copy();
447 }
448 
449 Optional&lt;String&gt; CDMPrivateClearKey::sanitizeSessionId(const String&amp; sessionId) const
450 {
451     // Validate the session ID string as an 32-bit integer.
452     bool ok;
453     sessionId.toUIntStrict(&amp;ok);
454     if (!ok)
455         return WTF::nullopt;
456     return sessionId;
457 }
458 
459 // This is for thread-safety during an architectural situation that is
460 // less than ideal. The GStreamer decryptors currently need to iterate
461 // all known session keys to find the key data for priming
462 // GCrypt. Ideally, all decryption would be the responsibility of
463 // ProxyCDM object like this one. What the background GStreamer
464 // thread was doing was getting copies (i.e. ref()&#39;s) of SharedBuffers
465 // created on the main-thread. With the new safety assertions in
466 // WebKit, we can no longer do this. Instead, convert the refcounted
467 // SharedBuffers into Strings which can be safely copied across
468 // threads.
469 static ProxyCDMClearKey::Key isolatedKey(const CDMInstanceClearKey::Key&amp; key)
470 {
471     return { key.status, String(key.keyIDData-&gt;data(), key.keyIDData-&gt;size()), String(key.keyValueData-&gt;data(), key.keyValueData-&gt;size()) };
472 }
473 
474 const Vector&lt;ProxyCDMClearKey::Key&gt; ProxyCDMClearKey::isolatedKeys() const
475 {
476     // Return the keys of all sessions, may be copied to background threads.
477     Vector&lt;ProxyCDMClearKey::Key&gt; allKeys { };
478     auto locker = holdLock(m_keysMutex);
479     size_t initialCapacity = 0;
480     for (auto&amp; keyVector : ClearKeyState::singleton().keys().values())
481         initialCapacity += keyVector.size();
482     allKeys.reserveInitialCapacity(initialCapacity);
483 
484     for (auto&amp; keyVector : ClearKeyState::singleton().keys().values()) {
485         for (auto&amp; key : keyVector)
486             allKeys.uncheckedAppend(isolatedKey(key));
487     }
488 
489     return allKeys;
490 }
491 
492 CDMInstanceClearKey::CDMInstanceClearKey()
493     : m_proxyCDM(adoptRef(*new ProxyCDMClearKey()))
494 {
495 }
496 
497 CDMInstanceClearKey::~CDMInstanceClearKey() = default;
498 
499 CDMInstance::SuccessValue CDMInstanceClearKey::initializeWithConfiguration(const CDMKeySystemConfiguration&amp;)
500 {
501     // No-op.
502     return Succeeded;
503 }
504 
505 CDMInstance::SuccessValue CDMInstanceClearKey::setDistinctiveIdentifiersAllowed(bool allowed)
506 {
507     // Reject setting distinctive identifiers as allowed.
508     return !allowed ? Succeeded : Failed;
509 }
510 
511 CDMInstance::SuccessValue CDMInstanceClearKey::setPersistentStateAllowed(bool allowed)
512 {
513     // Reject setting persistent state as allowed.
514     return !allowed ? Succeeded : Failed;
515 }
516 
517 CDMInstance::SuccessValue CDMInstanceClearKey::setServerCertificate(Ref&lt;SharedBuffer&gt;&amp;&amp;)
518 {
519     // Reject setting any server certificate.
520     return Failed;
521 }
522 
523 CDMInstance::SuccessValue CDMInstanceClearKey::setStorageDirectory(const String&amp; storageDirectory)
524 {
525     // Reject any persistent state storage.
526     return storageDirectory.isEmpty() ? Succeeded : Failed;
527 }
528 
529 const String&amp; CDMInstanceClearKey::keySystem() const
530 {
531     static const NeverDestroyed&lt;String&gt; s_keySystem { MAKE_STATIC_STRING_IMPL(&quot;org.w3.clearkey&quot;) };
532 
533     return s_keySystem;
534 }
535 
536 RefPtr&lt;CDMInstanceSession&gt; CDMInstanceClearKey::createSession()
537 {
538     return adoptRef(new CDMInstanceSessionClearKey());
539 }
540 
541 String CDMInstanceClearKey::Key::keyIDAsString() const
542 {
543     return makeString(&quot;[&quot;, keyIDData-&gt;toHexString(), &quot;]&quot;);
544 }
545 
546 String CDMInstanceClearKey::Key::keyValueAsString() const
547 {
548     return makeString(&quot;[&quot;, keyValueData-&gt;toHexString(), &quot;]&quot;);
549 }
550 
551 bool operator==(const CDMInstanceClearKey::Key&amp; k1, const CDMInstanceClearKey::Key&amp; k2)
552 {
553     ASSERT(k1.keyIDData);
554     ASSERT(k2.keyIDData);
555 
556     return *k1.keyIDData == *k2.keyIDData;
557 }
558 
559 bool operator&lt;(const CDMInstanceClearKey::Key&amp; k1, const CDMInstanceClearKey::Key&amp; k2)
560 {
561     ASSERT(k1.keyIDData);
562     ASSERT(k2.keyIDData);
563 
564     if (k1.keyIDData-&gt;size() != k2.keyIDData-&gt;size())
565         return k1.keyIDData-&gt;size() &lt; k2.keyIDData-&gt;size();
566 
567     return memcmp(k1.keyIDData-&gt;data(), k2.keyIDData-&gt;data(), k1.keyIDData-&gt;size());
568 }
569 
570 void CDMInstanceSessionClearKey::requestLicense(LicenseType, const AtomString&amp; initDataType, Ref&lt;SharedBuffer&gt;&amp;&amp; initData, LicenseCallback&amp;&amp; callback)
571 {
572     static uint32_t s_sessionIdValue = 0;
573     ++s_sessionIdValue;
574 
575     if (equalLettersIgnoringASCIICase(initDataType, &quot;cenc&quot;))
576         initData = extractKeyidsFromCencInitData(initData.get());
577 
578     if (equalLettersIgnoringASCIICase(initDataType, &quot;webm&quot;))
579         initData = extractKeyIdFromWebMInitData(initData.get());
580 
581     callOnMainThread(
582         [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), initData = WTFMove(initData), sessionIdValue = s_sessionIdValue]() mutable {
583             if (!weakThis)
584                 return;
585 
586             callback(WTFMove(initData), String::number(sessionIdValue), false, Succeeded);
587         });
588 }
589 
590 void CDMInstanceSessionClearKey::updateLicense(const String&amp; sessionId, LicenseType, const SharedBuffer&amp; response, LicenseUpdateCallback&amp;&amp; callback)
591 {
592     // Use a helper functor that schedules the callback dispatch, avoiding
593     // duplicated callOnMainThread() calls.
594     auto dispatchCallback =
595         [this, &amp;callback](bool sessionWasClosed, Optional&lt;KeyStatusVector&gt;&amp;&amp; changedKeys, SuccessValue succeeded) {
596             callOnMainThread(
597                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), sessionWasClosed, changedKeys = WTFMove(changedKeys), succeeded] () mutable {
598                     if (!weakThis)
599                         return;
600 
601                     callback(sessionWasClosed, WTFMove(changedKeys), WTF::nullopt, WTF::nullopt, succeeded);
602                 });
603         };
604 
605     RefPtr&lt;JSON::Object&gt; root = parseJSONObject(response);
606     if (!root) {
607         dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
608         return;
609     }
610 
611     LOG(EME, &quot;EME - ClearKey - updating license for session %s&quot;, sessionId.utf8().data());
612 
613     if (auto decodedKeys = parseLicenseFormat(*root)) {
614         // Retrieve the target Vector of Key objects for this session.
615         // FIXME: Refactor this state management code.
616         Vector&lt;CDMInstanceClearKey::Key&gt;&amp; keyVector = ClearKeyState::singleton().keys().ensure(sessionId, [] { return Vector&lt;CDMInstanceClearKey::Key&gt; { }; }).iterator-&gt;value;
617 
618         bool keysChanged = false;
619         for (auto&amp; decodedKey : *decodedKeys) {
620             LOG(EME, &quot;EME - ClearKey - Decoded a key with ID %s and key data %s&quot;, decodedKey.keyIDAsString().utf8().data(), decodedKey.keyValueAsString().utf8().data());
621             auto keyWithMatchingKeyID = std::find_if(keyVector.begin(), keyVector.end(),
622                 [&amp;decodedKey] (const CDMInstanceClearKey::Key&amp; containedKey) {
623                     return containedKey == decodedKey;
624                 });
625             if (keyWithMatchingKeyID != keyVector.end()) {
626                 LOG(EME, &quot;EME - ClearKey - Existing key found with data %s&quot;, keyWithMatchingKeyID-&gt;keyValueAsString().utf8().data());
627 
628                 if (!keyWithMatchingKeyID-&gt;hasSameKeyValue(decodedKey)) {
629                     LOG(EME, &quot;EME - ClearKey - Updating key since the data are different&quot;);
630                     *keyWithMatchingKeyID = WTFMove(decodedKey);
631                     keysChanged = true;
632                 }
633             } else {
634                 LOG(EME, &quot;EME - ClearKey - This is a new key&quot;);
635                 keyVector.append(WTFMove(decodedKey));
636                 keysChanged = true;
637             }
638         }
639 
640         LOG(EME, &quot;EME - ClearKey - Update has provided %zu keys&quot;, keyVector.size());
641 
642         Optional&lt;KeyStatusVector&gt; changedKeys;
643         if (keysChanged) {
644             // Sort by key IDs.
645             std::sort(keyVector.begin(), keyVector.end());
646 
647             KeyStatusVector keyStatusVector;
648             keyStatusVector.reserveInitialCapacity(keyVector.size());
649             for (auto&amp; key : keyVector)
650                 keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *key.keyIDData, key.status });
651 
652             changedKeys = WTFMove(keyStatusVector);
653         }
654 
655         dispatchCallback(false, WTFMove(changedKeys), SuccessValue::Succeeded);
656         return;
657     }
658 
659     if (parseLicenseReleaseAcknowledgementFormat(*root)) {
660         // FIXME: Retrieve the key ID information and use it to validate the keys for this sessionId.
661         ClearKeyState::singleton().keys().remove(sessionId);
662         dispatchCallback(true, WTF::nullopt, SuccessValue::Succeeded);
663         return;
664     }
665 
666     // Bail in case no format was recognized.
667     dispatchCallback(false, WTF::nullopt, SuccessValue::Failed);
668 }
669 
670 void CDMInstanceSessionClearKey::loadSession(LicenseType, const String&amp; sessionId, const String&amp;, LoadSessionCallback&amp;&amp; callback)
671 {
672     // Use a helper functor that schedules the callback dispatch, avoiding duplicated callOnMainThread() calls.
673     auto dispatchCallback =
674         [this, &amp;callback](Optional&lt;KeyStatusVector&gt;&amp;&amp; existingKeys, SuccessValue success, SessionLoadFailure loadFailure) {
675             callOnMainThread(
676                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), existingKeys = WTFMove(existingKeys), success, loadFailure]() mutable {
677                     if (!weakThis)
678                         return;
679 
680                     callback(WTFMove(existingKeys), WTF::nullopt, WTF::nullopt, success, loadFailure);
681                 });
682         };
683 
684     // Construct the KeyStatusVector object, representing all the known keys for this session.
685     KeyStatusVector keyStatusVector;
686     {
687         auto&amp; keys = ClearKeyState::singleton().keys();
688         auto it = keys.find(sessionId);
689         if (it == keys.end()) {
690             dispatchCallback(WTF::nullopt, Failed, SessionLoadFailure::NoSessionData);
691             return;
692         }
693 
694         auto&amp; keyVector = it-&gt;value;
695         keyStatusVector.reserveInitialCapacity(keyVector.size());
696         for (auto&amp; key : keyVector)
697             keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *key.keyIDData, key.status });
698     }
699 
700     dispatchCallback(WTFMove(keyStatusVector), Succeeded, SessionLoadFailure::None);
701 }
702 
703 void CDMInstanceSessionClearKey::closeSession(const String&amp;, CloseSessionCallback&amp;&amp; callback)
704 {
705     callOnMainThread(
706         [weakThis = makeWeakPtr(*this), callback = WTFMove(callback)] () mutable {
707             if (!weakThis)
708                 return;
709 
710             callback();
711         });
712 }
713 
714 void CDMInstanceSessionClearKey::removeSessionData(const String&amp; sessionId, LicenseType, RemoveSessionDataCallback&amp;&amp; callback)
715 {
716     // Use a helper functor that schedules the callback dispatch, avoiding duplicated callOnMainThread() calls.
717     auto dispatchCallback =
718         [this, &amp;callback](KeyStatusVector&amp;&amp; keyStatusVector, Optional&lt;Ref&lt;SharedBuffer&gt;&gt;&amp;&amp; message, SuccessValue success) {
719             callOnMainThread(
720                 [weakThis = makeWeakPtr(*this), callback = WTFMove(callback), keyStatusVector = WTFMove(keyStatusVector), message = WTFMove(message), success]() mutable {
721                     if (!weakThis)
722                         return;
723 
724                     callback(WTFMove(keyStatusVector), WTFMove(message), success);
725                 });
726         };
727 
728     // Construct the KeyStatusVector object, representing released keys, and the message in the
729     // &#39;license release&#39; format.
730     KeyStatusVector keyStatusVector;
731     RefPtr&lt;SharedBuffer&gt; message;
732     {
733         // Retrieve information for the given session ID, bailing if none is found.
734         auto&amp; keys = ClearKeyState::singleton().keys();
735         auto it = keys.find(sessionId);
736         if (it == keys.end()) {
737             dispatchCallback(KeyStatusVector { }, WTF::nullopt, SuccessValue::Failed);
738             return;
739         }
740 
741         // Retrieve the Key vector, containing all the keys for this session, and
742         // then remove the key map entry for this session.
743         auto keyVector = WTFMove(it-&gt;value);
744         keys.remove(it);
745 
746         // Construct the KeyStatusVector object, pairing key IDs with the &#39;released&#39; status.
747         keyStatusVector.reserveInitialCapacity(keyVector.size());
748         for (auto&amp; key : keyVector)
749             keyStatusVector.uncheckedAppend(std::pair&lt;Ref&lt;SharedBuffer&gt;, KeyStatus&gt; { *key.keyIDData, KeyStatus::Released });
750 
751         // Construct JSON that represents the &#39;license release&#39; format, creating a &#39;kids&#39; array
752         // of base64URL-encoded key IDs for all keys that were associated with this session.
753         auto rootObject = JSON::Object::create();
754         {
755             auto array = JSON::Array::create();
756             for (auto&amp; key : keyVector) {
757                 ASSERT(key.keyIDData-&gt;size() &lt;= std::numeric_limits&lt;unsigned&gt;::max());
758                 array-&gt;pushString(WTF::base64URLEncode(key.keyIDData-&gt;data(), static_cast&lt;unsigned&gt;(key.keyIDData-&gt;size())));
759             }
760             rootObject-&gt;setArray(&quot;kids&quot;, WTFMove(array));
761         }
762 
763         // Copy the JSON data into a SharedBuffer object.
764         String messageString = rootObject-&gt;toJSONString();
765         CString messageCString = messageString.utf8();
766         message = SharedBuffer::create(messageCString.data(), messageCString.length());
767     }
768 
769     dispatchCallback(WTFMove(keyStatusVector), Ref&lt;SharedBuffer&gt;(*message), SuccessValue::Succeeded);
770 }
771 
772 void CDMInstanceSessionClearKey::storeRecordOfKeyUsage(const String&amp;)
773 {
774 }
775 
776 } // namespace WebCore
777 
778 #endif // ENABLE(ENCRYPTED_MEDIA)
    </pre>
  </body>
</html>
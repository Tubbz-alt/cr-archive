<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysisInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeLivenessAnalysis.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeRewriter.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysisInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,39 ***</span>
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;Operations.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! inline bool operandIsAlwaysLive(int operand)</span>
  {
<span class="line-modified">!     return !VirtualRegister(operand).isLocal();</span>
  }
  
<span class="line-modified">! inline bool operandThatIsNotAlwaysLiveIsLive(const FastBitVector&amp; out, int operand)</span>
  {
<span class="line-modified">!     unsigned local = VirtualRegister(operand).toLocal();</span>
      if (local &gt;= out.numBits())
          return false;
      return out[local];
  }
  
<span class="line-modified">! inline bool operandIsLive(const FastBitVector&amp; out, int operand)</span>
  {
<span class="line-modified">!     return operandIsAlwaysLive(operand) || operandThatIsNotAlwaysLiveIsLive(out, operand);</span>
  }
  
  inline bool isValidRegisterForLiveness(VirtualRegister operand)
  {
      if (operand.isConstant())
          return false;
      return operand.isLocal();
  }
  
  // Simplified interface to bytecode use/def, which determines defs first and then uses, and includes
  // exception handlers in the uses.
  template&lt;typename CodeBlockType, typename UseFunctor, typename DefFunctor&gt;
<span class="line-modified">! inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream&amp; instructions, BytecodeGraph&amp; graph, InstructionStream::Offset bytecodeOffset, const UseFunctor&amp; use, const DefFunctor&amp; def)</span>
  {
      // This abstractly execute the instruction in reverse. Instructions logically first use operands and
      // then define operands. This logical ordering is necessary for operations that use and def the same
      // operand, like:
      //
<span class="line-new-header">--- 31,75 ---</span>
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;Operations.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! inline bool virtualRegisterIsAlwaysLive(VirtualRegister reg)</span>
  {
<span class="line-modified">!     return !reg.isLocal();</span>
  }
  
<span class="line-modified">! inline bool virtualRegisterThatIsNotAlwaysLiveIsLive(const FastBitVector&amp; out, VirtualRegister reg)</span>
  {
<span class="line-modified">!     unsigned local = reg.toLocal();</span>
      if (local &gt;= out.numBits())
          return false;
      return out[local];
  }
  
<span class="line-modified">! inline bool virtualRegisterIsLive(const FastBitVector&amp; out, VirtualRegister operand)</span>
  {
<span class="line-modified">!     return virtualRegisterIsAlwaysLive(operand) || virtualRegisterThatIsNotAlwaysLiveIsLive(out, operand);</span>
  }
  
  inline bool isValidRegisterForLiveness(VirtualRegister operand)
  {
      if (operand.isConstant())
          return false;
      return operand.isLocal();
  }
  
<span class="line-added">+ template&lt;typename CodeBlockType, typename DefFunctor&gt;</span>
<span class="line-added">+ inline void BytecodeLivenessPropagation::stepOverInstructionDef(CodeBlockType* codeBlock, const InstructionStream&amp; instructions, BytecodeGraph&amp;, BytecodeIndex bytecodeIndex, const DefFunctor&amp; def)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* instruction = instructions.at(bytecodeIndex).ptr();</span>
<span class="line-added">+     computeDefsForBytecodeIndex(</span>
<span class="line-added">+         codeBlock, instruction,</span>
<span class="line-added">+         [&amp;] (VirtualRegister operand) {</span>
<span class="line-added">+             if (isValidRegisterForLiveness(operand))</span>
<span class="line-added">+                 def(operand.toLocal());</span>
<span class="line-added">+         });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename CodeBlockType, typename UseFunctor&gt;</span>
<span class="line-added">+ inline void BytecodeLivenessPropagation::stepOverInstructionUse(CodeBlockType* codeBlock, const InstructionStream&amp; instructions, BytecodeGraph&amp;, BytecodeIndex bytecodeIndex, const UseFunctor&amp; use)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* instruction = instructions.at(bytecodeIndex).ptr();</span>
<span class="line-added">+     computeUsesForBytecodeIndex(</span>
<span class="line-added">+         codeBlock, instruction,</span>
<span class="line-added">+         [&amp;] (VirtualRegister operand) {</span>
<span class="line-added">+             if (isValidRegisterForLiveness(operand))</span>
<span class="line-added">+                 use(operand.toLocal());</span>
<span class="line-added">+         });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename CodeBlockType, typename UseFunctor&gt;</span>
<span class="line-added">+ inline void BytecodeLivenessPropagation::stepOverInstructionUseInExceptionHandler(CodeBlockType* codeBlock, const InstructionStream&amp;, BytecodeGraph&amp; graph, BytecodeIndex bytecodeIndex, const UseFunctor&amp; use)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // If we have an exception handler, we want the live-in variables of the</span>
<span class="line-added">+     // exception handler block to be included in the live-in of this particular bytecode.</span>
<span class="line-added">+     if (auto* handler = codeBlock-&gt;handlerForBytecodeIndex(bytecodeIndex)) {</span>
<span class="line-added">+         BytecodeBasicBlock* handlerBlock = graph.findBasicBlockWithLeaderOffset(handler-&gt;target);</span>
<span class="line-added">+         ASSERT(handlerBlock);</span>
<span class="line-added">+         handlerBlock-&gt;in().forEachSetBit(use);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Simplified interface to bytecode use/def, which determines defs first and then uses, and includes
  // exception handlers in the uses.
  template&lt;typename CodeBlockType, typename UseFunctor, typename DefFunctor&gt;
<span class="line-modified">! inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream&amp; instructions, BytecodeGraph&amp; graph, BytecodeIndex bytecodeIndex, const UseFunctor&amp; use, const DefFunctor&amp; def)</span>
  {
      // This abstractly execute the instruction in reverse. Instructions logically first use operands and
      // then define operands. This logical ordering is necessary for operations that use and def the same
      // operand, like:
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,41 ***</span>
      //
      // Since this is a liveness analysis, this ordering ends up being particularly important: if we did
      // uses before defs, then the add operation above would appear to not have loc1 live, since we&#39;d
      // first add it to the out set (the use), and then we&#39;d remove it (the def).
  
<span class="line-modified">!     auto* instruction = instructions.at(bytecodeOffset).ptr();</span>
<span class="line-modified">!     OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
<span class="line-modified">! </span>
<span class="line-removed">-     computeDefsForBytecodeOffset(</span>
<span class="line-removed">-         codeBlock, opcodeID, instruction,</span>
<span class="line-removed">-         [&amp;] (VirtualRegister operand) {</span>
<span class="line-removed">-             if (isValidRegisterForLiveness(operand))</span>
<span class="line-removed">-                 def(operand.toLocal());</span>
<span class="line-removed">-         });</span>
<span class="line-removed">- </span>
<span class="line-removed">-     computeUsesForBytecodeOffset(</span>
<span class="line-removed">-         codeBlock, opcodeID, instruction,</span>
<span class="line-removed">-         [&amp;] (VirtualRegister operand) {</span>
<span class="line-removed">-             if (isValidRegisterForLiveness(operand))</span>
<span class="line-removed">-                 use(operand.toLocal());</span>
<span class="line-removed">-         });</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If we have an exception handler, we want the live-in variables of the</span>
<span class="line-removed">-     // exception handler block to be included in the live-in of this particular bytecode.</span>
<span class="line-removed">-     if (auto* handler = codeBlock-&gt;handlerForBytecodeOffset(bytecodeOffset)) {</span>
<span class="line-removed">-         BytecodeBasicBlock* handlerBlock = graph.findBasicBlockWithLeaderOffset(handler-&gt;target);</span>
<span class="line-removed">-         ASSERT(handlerBlock);</span>
<span class="line-removed">-         handlerBlock-&gt;in().forEachSetBit(use);</span>
<span class="line-removed">-     }</span>
  }
  
  template&lt;typename CodeBlockType&gt;
<span class="line-modified">! inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream&amp; instructions, BytecodeGraph&amp; graph, InstructionStream::Offset bytecodeOffset, FastBitVector&amp; out)</span>
  {
      stepOverInstruction(
<span class="line-modified">!         codeBlock, instructions, graph, bytecodeOffset,</span>
          [&amp;] (unsigned bitIndex) {
              // This is the use functor, so we set the bit.
              out[bitIndex] = true;
          },
          [&amp;] (unsigned bitIndex) {
<span class="line-new-header">--- 112,20 ---</span>
      //
      // Since this is a liveness analysis, this ordering ends up being particularly important: if we did
      // uses before defs, then the add operation above would appear to not have loc1 live, since we&#39;d
      // first add it to the out set (the use), and then we&#39;d remove it (the def).
  
<span class="line-modified">!     stepOverInstructionDef(codeBlock, instructions, graph, bytecodeIndex, def);</span>
<span class="line-modified">!     stepOverInstructionUseInExceptionHandler(codeBlock, instructions, graph, bytecodeIndex, use);</span>
<span class="line-modified">!     stepOverInstructionUse(codeBlock, instructions, graph, bytecodeIndex, use);</span>
  }
  
  template&lt;typename CodeBlockType&gt;
<span class="line-modified">! inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream&amp; instructions, BytecodeGraph&amp; graph, BytecodeIndex bytecodeIndex, FastBitVector&amp; out)</span>
  {
      stepOverInstruction(
<span class="line-modified">!         codeBlock, instructions, graph, bytecodeIndex,</span>
          [&amp;] (unsigned bitIndex) {
              // This is the use functor, so we set the bit.
              out[bitIndex] = true;
          },
          [&amp;] (unsigned bitIndex) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,73 ***</span>
              out[bitIndex] = false;
          });
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
<span class="line-modified">! inline bool BytecodeLivenessPropagation::computeLocalLivenessForBytecodeOffset(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph, BytecodeBasicBlock* block, unsigned targetOffset, FastBitVector&amp; result)</span>
  {
<span class="line-modified">!     ASSERT(!block-&gt;isExitBlock());</span>
<span class="line-modified">!     ASSERT(!block-&gt;isEntryBlock());</span>
  
<span class="line-modified">!     FastBitVector out = block-&gt;out();</span>
  
<span class="line-modified">!     for (int i = block-&gt;offsets().size() - 1; i &gt;= 0; i--) {</span>
<span class="line-modified">!         unsigned bytecodeOffset = block-&gt;offsets()[i];</span>
<span class="line-modified">!         if (targetOffset &gt; bytecodeOffset)</span>
              break;
<span class="line-modified">!         stepOverInstruction(codeBlock, instructions, graph, bytecodeOffset, out);</span>
      }
  
      return result.setAndCheck(out);
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
<span class="line-modified">! inline bool BytecodeLivenessPropagation::computeLocalLivenessForBlock(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph, BytecodeBasicBlock* block)</span>
  {
<span class="line-modified">!     if (block-&gt;isExitBlock() || block-&gt;isEntryBlock())</span>
          return false;
<span class="line-modified">!     return computeLocalLivenessForBytecodeOffset(codeBlock, instructions, graph, block, block-&gt;leaderOffset(), block-&gt;in());</span>
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
<span class="line-modified">! inline FastBitVector BytecodeLivenessPropagation::getLivenessInfoAtBytecodeOffset(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph, unsigned bytecodeOffset)</span>
  {
<span class="line-modified">!     BytecodeBasicBlock* block = graph.findBasicBlockForBytecodeOffset(bytecodeOffset);</span>
      ASSERT(block);
      ASSERT(!block-&gt;isEntryBlock());
      ASSERT(!block-&gt;isExitBlock());
      FastBitVector out;
      out.resize(block-&gt;out().numBits());
<span class="line-modified">!     computeLocalLivenessForBytecodeOffset(codeBlock, instructions, graph, block, bytecodeOffset, out);</span>
      return out;
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
  inline void BytecodeLivenessPropagation::runLivenessFixpoint(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph)
  {
      unsigned numberOfVariables = codeBlock-&gt;numCalleeLocals();
<span class="line-modified">!     for (BytecodeBasicBlock* block : graph) {</span>
<span class="line-modified">!         block-&gt;in().resize(numberOfVariables);</span>
<span class="line-modified">!         block-&gt;out().resize(numberOfVariables);</span>
<span class="line-modified">!         block-&gt;in().clearAll();</span>
<span class="line-modified">!         block-&gt;out().clearAll();</span>
      }
  
      bool changed;
<span class="line-modified">!     BytecodeBasicBlock* lastBlock = graph.last();</span>
<span class="line-modified">!     lastBlock-&gt;in().clearAll();</span>
<span class="line-modified">!     lastBlock-&gt;out().clearAll();</span>
      FastBitVector newOut;
<span class="line-modified">!     newOut.resize(lastBlock-&gt;out().numBits());</span>
      do {
          changed = false;
<span class="line-modified">!         for (std::unique_ptr&lt;BytecodeBasicBlock&gt;&amp; block : graph.basicBlocksInReverseOrder()) {</span>
              newOut.clearAll();
<span class="line-modified">!             for (BytecodeBasicBlock* successor : block-&gt;successors())</span>
<span class="line-modified">!                 newOut |= successor-&gt;in();</span>
<span class="line-modified">!             block-&gt;out() = newOut;</span>
<span class="line-modified">!             changed |= computeLocalLivenessForBlock(codeBlock, instructions, graph, block.get());</span>
          }
      } while (changed);
  }
  
  } // namespace JSC
<span class="line-new-header">--- 133,77 ---</span>
              out[bitIndex] = false;
          });
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
<span class="line-modified">! inline bool BytecodeLivenessPropagation::computeLocalLivenessForBytecodeIndex(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph, BytecodeBasicBlock&amp; block, BytecodeIndex targetIndex, FastBitVector&amp; result)</span>
  {
<span class="line-modified">!     ASSERT(!block.isExitBlock());</span>
<span class="line-modified">!     ASSERT(!block.isEntryBlock());</span>
  
<span class="line-modified">!     FastBitVector out = block.out();</span>
  
<span class="line-modified">!     unsigned cursor = block.totalLength();</span>
<span class="line-modified">!     for (unsigned i = block.delta().size(); i--;) {</span>
<span class="line-modified">!         cursor -= block.delta()[i];</span>
<span class="line-added">+         BytecodeIndex bytecodeIndex = BytecodeIndex(block.leaderOffset() + cursor);</span>
<span class="line-added">+         if (targetIndex.offset() &gt; bytecodeIndex.offset())</span>
              break;
<span class="line-modified">!         stepOverInstruction(codeBlock, instructions, graph, bytecodeIndex, out);</span>
      }
  
      return result.setAndCheck(out);
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
<span class="line-modified">! inline bool BytecodeLivenessPropagation::computeLocalLivenessForBlock(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph, BytecodeBasicBlock&amp; block)</span>
  {
<span class="line-modified">!     if (block.isExitBlock() || block.isEntryBlock())</span>
          return false;
<span class="line-modified">!     return computeLocalLivenessForBytecodeIndex(codeBlock, instructions, graph, block, BytecodeIndex(block.leaderOffset()), block.in());</span>
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
<span class="line-modified">! inline FastBitVector BytecodeLivenessPropagation::getLivenessInfoAtBytecodeIndex(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph, BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     BytecodeBasicBlock* block = graph.findBasicBlockForBytecodeOffset(bytecodeIndex.offset());</span>
      ASSERT(block);
      ASSERT(!block-&gt;isEntryBlock());
      ASSERT(!block-&gt;isExitBlock());
      FastBitVector out;
      out.resize(block-&gt;out().numBits());
<span class="line-modified">!     computeLocalLivenessForBytecodeIndex(codeBlock, instructions, graph, *block, bytecodeIndex, out);</span>
      return out;
  }
  
  template&lt;typename CodeBlockType, typename Instructions&gt;
  inline void BytecodeLivenessPropagation::runLivenessFixpoint(CodeBlockType* codeBlock, const Instructions&amp; instructions, BytecodeGraph&amp; graph)
  {
      unsigned numberOfVariables = codeBlock-&gt;numCalleeLocals();
<span class="line-modified">!     for (BytecodeBasicBlock&amp; block : graph) {</span>
<span class="line-modified">!         block.in().resize(numberOfVariables);</span>
<span class="line-modified">!         block.out().resize(numberOfVariables);</span>
<span class="line-modified">!         block.in().clearAll();</span>
<span class="line-modified">!         block.out().clearAll();</span>
      }
  
      bool changed;
<span class="line-modified">!     BytecodeBasicBlock&amp; lastBlock = graph.last();</span>
<span class="line-modified">!     lastBlock.in().clearAll();</span>
<span class="line-modified">!     lastBlock.out().clearAll();</span>
      FastBitVector newOut;
<span class="line-modified">!     newOut.resize(lastBlock.out().numBits());</span>
      do {
          changed = false;
<span class="line-modified">!         for (BytecodeBasicBlock&amp; block : graph.basicBlocksInReverseOrder()) {</span>
              newOut.clearAll();
<span class="line-modified">!             for (unsigned blockIndex : block.successors()) {</span>
<span class="line-modified">!                 BytecodeBasicBlock&amp; successor = graph[blockIndex];</span>
<span class="line-modified">!                 newOut |= successor.in();</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             block.out() = newOut;</span>
<span class="line-added">+             changed |= computeLocalLivenessForBlock(codeBlock, instructions, graph, block);</span>
          }
      } while (changed);
  }
  
  } // namespace JSC
</pre>
<center><a href="BytecodeLivenessAnalysis.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeRewriter.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
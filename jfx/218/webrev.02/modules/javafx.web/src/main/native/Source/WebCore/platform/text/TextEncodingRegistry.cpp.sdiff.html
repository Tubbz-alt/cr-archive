<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextEncoding.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextEncodingRegistry.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;config.h&quot;
 28 #include &quot;TextEncodingRegistry.h&quot;
 29 
 30 #include &quot;TextCodecICU.h&quot;
 31 #include &quot;TextCodecLatin1.h&quot;
 32 #include &quot;TextCodecReplacement.h&quot;
 33 #include &quot;TextCodecUTF16.h&quot;
 34 #include &quot;TextCodecUTF8.h&quot;
 35 #include &quot;TextCodecUserDefined.h&quot;
 36 #include &quot;TextEncoding.h&quot;
 37 #include &lt;mutex&gt;
 38 #include &lt;wtf/ASCIICType.h&gt;
 39 #include &lt;wtf/CheckedArithmetic.h&gt;
 40 #include &lt;wtf/HashMap.h&gt;
 41 #include &lt;wtf/HashSet.h&gt;
 42 #include &lt;wtf/Lock.h&gt;
 43 #include &lt;wtf/MainThread.h&gt;
 44 #include &lt;wtf/StdLibExtras.h&gt;
 45 #include &lt;wtf/text/CString.h&gt;
 46 




 47 namespace WebCore {
 48 
 49 const size_t maxEncodingNameLength = 63;
 50 
 51 // Hash for all-ASCII strings that does case folding.
 52 struct TextEncodingNameHash {
 53     static bool equal(const char* s1, const char* s2)
 54     {
 55         char c1;
 56         char c2;
 57         do {
 58             c1 = *s1++;
 59             c2 = *s2++;
 60             if (toASCIILower(c1) != toASCIILower(c2))
 61                 return false;
 62         } while (c1 &amp;&amp; c2);
 63         return !c1 &amp;&amp; !c2;
 64     }
 65 
 66     // This algorithm is the one-at-a-time hash from:
</pre>
<hr />
<pre>
101 
102 static bool isUndesiredAlias(const char* alias)
103 {
104     // Reject aliases with version numbers that are supported by some back-ends (such as &quot;ISO_2022,locale=ja,version=0&quot; in ICU).
105     for (const char* p = alias; *p; ++p) {
106         if (*p == &#39;,&#39;)
107             return true;
108     }
109     // 8859_1 is known to (at least) ICU, but other browsers don&#39;t support this name - and having it caused a compatibility
110     // problem, see bug 43554.
111     if (0 == strcmp(alias, &quot;8859_1&quot;))
112         return true;
113     return false;
114 }
115 
116 static void addToTextEncodingNameMap(const char* alias, const char* name)
117 {
118     ASSERT(strlen(alias) &lt;= maxEncodingNameLength);
119     if (isUndesiredAlias(alias))
120         return;
<span class="line-modified">121     const char* atomicName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">122     ASSERT(strcmp(alias, name) == 0 || atomicName);</span>
<span class="line-modified">123     if (!atomicName)</span>
<span class="line-modified">124         atomicName = name;</span>
125 
<span class="line-modified">126     ASSERT_WITH_MESSAGE(!textEncodingNameMap-&gt;get(alias), &quot;Duplicate text encoding name %s for %s (previously registered as %s)&quot;, alias, atomicName, textEncodingNameMap-&gt;get(alias));</span>
127 
<span class="line-modified">128     textEncodingNameMap-&gt;add(alias, atomicName);</span>
129 }
130 
131 static void addToTextCodecMap(const char* name, NewTextCodecFunction&amp;&amp; function)
132 {
<span class="line-modified">133     const char* atomicName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">134     ASSERT(atomicName);</span>
<span class="line-modified">135     textCodecMap-&gt;add(atomicName, WTFMove(function));</span>
136 }
137 
138 static void pruneBlacklistedCodecs()
139 {
140     for (auto&amp; nameFromBlacklist : textEncodingNameBlacklist) {
<span class="line-modified">141         auto* atomicName = textEncodingNameMap-&gt;get(nameFromBlacklist);</span>
<span class="line-modified">142         if (!atomicName)</span>
143             continue;
144 
145         Vector&lt;const char*&gt; names;
146         for (auto&amp; entry : *textEncodingNameMap) {
<span class="line-modified">147             if (entry.value == atomicName)</span>
148                 names.append(entry.key);
149         }
150 
151         for (auto* name : names)
152             textEncodingNameMap-&gt;remove(name);
153 
<span class="line-modified">154         textCodecMap-&gt;remove(atomicName);</span>
155     }
156 }
157 
158 static void buildBaseTextCodecMaps(const std::lock_guard&lt;Lock&gt;&amp;)
159 {
160     ASSERT(!textCodecMap);
161     ASSERT(!textEncodingNameMap);
162 
163     textCodecMap = new TextCodecMap;
164     textEncodingNameMap = new TextEncodingNameMap;
165 
166     TextCodecLatin1::registerEncodingNames(addToTextEncodingNameMap);
167     TextCodecLatin1::registerCodecs(addToTextCodecMap);
168 
169     TextCodecUTF8::registerEncodingNames(addToTextEncodingNameMap);
170     TextCodecUTF8::registerCodecs(addToTextCodecMap);
171 
172     TextCodecUTF16::registerEncodingNames(addToTextEncodingNameMap);
173     TextCodecUTF16::registerCodecs(addToTextCodecMap);
174 
175     TextCodecUserDefined::registerEncodingNames(addToTextEncodingNameMap);
176     TextCodecUserDefined::registerCodecs(addToTextCodecMap);
177 }
178 
179 static void addEncodingName(HashSet&lt;const char*&gt;* set, const char* name)
180 {
<span class="line-modified">181     // We must not use atomicCanonicalTextEncodingName() because this function is called in it.</span>
<span class="line-modified">182     const char* atomicName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">183     if (atomicName)</span>
<span class="line-modified">184         set-&gt;add(atomicName);</span>
185 }
186 
187 static void buildQuirksSets()
188 {
189     // FIXME: Having isJapaneseEncoding() and shouldShowBackslashAsCurrencySymbolIn()
190     // and initializing the sets for them in TextEncodingRegistry.cpp look strange.
191 
192     ASSERT(!japaneseEncodings);
193     ASSERT(!nonBackslashEncodings);
194 
195     japaneseEncodings = new HashSet&lt;const char*&gt;;
196     addEncodingName(japaneseEncodings, &quot;EUC-JP&quot;);
197     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP&quot;);
198     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP-1&quot;);
199     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP-2&quot;);
200     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP-3&quot;);
201     addEncodingName(japaneseEncodings, &quot;JIS_C6226-1978&quot;);
202     addEncodingName(japaneseEncodings, &quot;JIS_X0201&quot;);
203     addEncodingName(japaneseEncodings, &quot;JIS_X0208-1983&quot;);
204     addEncodingName(japaneseEncodings, &quot;JIS_X0208-1990&quot;);
</pre>
<hr />
<pre>
220 }
221 
222 bool isJapaneseEncoding(const char* canonicalEncodingName)
223 {
224     return canonicalEncodingName &amp;&amp; japaneseEncodings &amp;&amp; japaneseEncodings-&gt;contains(canonicalEncodingName);
225 }
226 
227 bool shouldShowBackslashAsCurrencySymbolIn(const char* canonicalEncodingName)
228 {
229     return canonicalEncodingName &amp;&amp; nonBackslashEncodings &amp;&amp; nonBackslashEncodings-&gt;contains(canonicalEncodingName);
230 }
231 
232 static void extendTextCodecMaps()
233 {
234     TextCodecReplacement::registerEncodingNames(addToTextEncodingNameMap);
235     TextCodecReplacement::registerCodecs(addToTextCodecMap);
236 
237     TextCodecICU::registerEncodingNames(addToTextEncodingNameMap);
238     TextCodecICU::registerCodecs(addToTextCodecMap);
239 





240     pruneBlacklistedCodecs();
241     buildQuirksSets();
242 }
243 
244 std::unique_ptr&lt;TextCodec&gt; newTextCodec(const TextEncoding&amp; encoding)
245 {
246     std::lock_guard&lt;Lock&gt; lock(encodingRegistryMutex);
247 
248     ASSERT(textCodecMap);
249     auto result = textCodecMap-&gt;find(encoding.name());
250     ASSERT(result != textCodecMap-&gt;end());
251     return result-&gt;value();
252 }
253 
<span class="line-modified">254 const char* atomicCanonicalTextEncodingName(const char* name)</span>
255 {
256     if (!name || !name[0])
257         return nullptr;
258 
259     std::lock_guard&lt;Lock&gt; lock(encodingRegistryMutex);
260 
261     if (!textEncodingNameMap)
262         buildBaseTextCodecMaps(lock);
263 
<span class="line-modified">264     if (const char* atomicName = textEncodingNameMap-&gt;get(name))</span>
<span class="line-modified">265         return atomicName;</span>
266     if (didExtendTextCodecMaps)
267         return nullptr;
268 
269     extendTextCodecMaps();
270     didExtendTextCodecMaps = true;
271     return textEncodingNameMap-&gt;get(name);
272 }
273 
<span class="line-modified">274 template&lt;typename CharacterType&gt; static const char* atomicCanonicalTextEncodingName(const CharacterType* characters, size_t length)</span>
275 {
276     char buffer[maxEncodingNameLength + 1];
277     size_t j = 0;
278     for (size_t i = 0; i &lt; length; ++i) {
279         if (j == maxEncodingNameLength)
280             return nullptr;
281         buffer[j++] = characters[i];
282     }
283     buffer[j] = 0;
<span class="line-modified">284     return atomicCanonicalTextEncodingName(buffer);</span>
285 }
286 
<span class="line-modified">287 const char* atomicCanonicalTextEncodingName(const String&amp; alias)</span>
288 {
289     if (alias.isEmpty() || !alias.isAllASCII())
290         return nullptr;
291 
292     if (alias.is8Bit())
<span class="line-modified">293         return atomicCanonicalTextEncodingName(alias.characters8(), alias.length());</span>
294 
<span class="line-modified">295     return atomicCanonicalTextEncodingName(alias.characters16(), alias.length());</span>
296 }
297 
298 bool noExtendedTextEncodingNameUsed()
299 {
300     // If the calling thread did not use extended encoding names, it is fine for it to use a stale false value.
301     return !didExtendTextCodecMaps;
302 }
303 
304 String defaultTextEncodingNameForSystemLanguage()
305 {
306 #if PLATFORM(COCOA)
307     String systemEncodingName = CFStringConvertEncodingToIANACharSetName(webDefaultCFStringEncoding());
308 
309     // CFStringConvertEncodingToIANACharSetName() returns cp949 for kTextEncodingDOSKorean AKA &quot;extended EUC-KR&quot; AKA windows-949.
310     // ICU uses this name for a different encoding, so we need to change the name to a value that actually gives us windows-949.
311     // In addition, this value must match what is used in Safari, see &lt;rdar://problem/5579292&gt;.
312     // On some OS versions, the result is CP949 (uppercase).
313     if (equalLettersIgnoringASCIICase(systemEncodingName, &quot;cp949&quot;))
314         systemEncodingName = &quot;ks_c_5601-1987&quot;_s;
315 
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;config.h&quot;
 28 #include &quot;TextEncodingRegistry.h&quot;
 29 
 30 #include &quot;TextCodecICU.h&quot;
 31 #include &quot;TextCodecLatin1.h&quot;
 32 #include &quot;TextCodecReplacement.h&quot;
 33 #include &quot;TextCodecUTF16.h&quot;
 34 #include &quot;TextCodecUTF8.h&quot;
 35 #include &quot;TextCodecUserDefined.h&quot;
 36 #include &quot;TextEncoding.h&quot;
 37 #include &lt;mutex&gt;
 38 #include &lt;wtf/ASCIICType.h&gt;
 39 #include &lt;wtf/CheckedArithmetic.h&gt;
 40 #include &lt;wtf/HashMap.h&gt;
 41 #include &lt;wtf/HashSet.h&gt;
 42 #include &lt;wtf/Lock.h&gt;
 43 #include &lt;wtf/MainThread.h&gt;
 44 #include &lt;wtf/StdLibExtras.h&gt;
 45 #include &lt;wtf/text/CString.h&gt;
 46 
<span class="line-added"> 47 #if USE(JAVA_UNICODE)</span>
<span class="line-added"> 48 #include &quot;java/TextCodecJava.h&quot;</span>
<span class="line-added"> 49 #endif</span>
<span class="line-added"> 50 </span>
 51 namespace WebCore {
 52 
 53 const size_t maxEncodingNameLength = 63;
 54 
 55 // Hash for all-ASCII strings that does case folding.
 56 struct TextEncodingNameHash {
 57     static bool equal(const char* s1, const char* s2)
 58     {
 59         char c1;
 60         char c2;
 61         do {
 62             c1 = *s1++;
 63             c2 = *s2++;
 64             if (toASCIILower(c1) != toASCIILower(c2))
 65                 return false;
 66         } while (c1 &amp;&amp; c2);
 67         return !c1 &amp;&amp; !c2;
 68     }
 69 
 70     // This algorithm is the one-at-a-time hash from:
</pre>
<hr />
<pre>
105 
106 static bool isUndesiredAlias(const char* alias)
107 {
108     // Reject aliases with version numbers that are supported by some back-ends (such as &quot;ISO_2022,locale=ja,version=0&quot; in ICU).
109     for (const char* p = alias; *p; ++p) {
110         if (*p == &#39;,&#39;)
111             return true;
112     }
113     // 8859_1 is known to (at least) ICU, but other browsers don&#39;t support this name - and having it caused a compatibility
114     // problem, see bug 43554.
115     if (0 == strcmp(alias, &quot;8859_1&quot;))
116         return true;
117     return false;
118 }
119 
120 static void addToTextEncodingNameMap(const char* alias, const char* name)
121 {
122     ASSERT(strlen(alias) &lt;= maxEncodingNameLength);
123     if (isUndesiredAlias(alias))
124         return;
<span class="line-modified">125     const char* atomName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">126     ASSERT(!strcmp(alias, name) || atomName);</span>
<span class="line-modified">127     if (!atomName)</span>
<span class="line-modified">128         atomName = name;</span>
129 
<span class="line-modified">130     ASSERT_WITH_MESSAGE(!textEncodingNameMap-&gt;get(alias), &quot;Duplicate text encoding name %s for %s (previously registered as %s)&quot;, alias, atomName, textEncodingNameMap-&gt;get(alias));</span>
131 
<span class="line-modified">132     textEncodingNameMap-&gt;add(alias, atomName);</span>
133 }
134 
135 static void addToTextCodecMap(const char* name, NewTextCodecFunction&amp;&amp; function)
136 {
<span class="line-modified">137     const char* atomName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">138     ASSERT(atomName);</span>
<span class="line-modified">139     textCodecMap-&gt;add(atomName, WTFMove(function));</span>
140 }
141 
142 static void pruneBlacklistedCodecs()
143 {
144     for (auto&amp; nameFromBlacklist : textEncodingNameBlacklist) {
<span class="line-modified">145         auto* atomName = textEncodingNameMap-&gt;get(nameFromBlacklist);</span>
<span class="line-modified">146         if (!atomName)</span>
147             continue;
148 
149         Vector&lt;const char*&gt; names;
150         for (auto&amp; entry : *textEncodingNameMap) {
<span class="line-modified">151             if (entry.value == atomName)</span>
152                 names.append(entry.key);
153         }
154 
155         for (auto* name : names)
156             textEncodingNameMap-&gt;remove(name);
157 
<span class="line-modified">158         textCodecMap-&gt;remove(atomName);</span>
159     }
160 }
161 
162 static void buildBaseTextCodecMaps(const std::lock_guard&lt;Lock&gt;&amp;)
163 {
164     ASSERT(!textCodecMap);
165     ASSERT(!textEncodingNameMap);
166 
167     textCodecMap = new TextCodecMap;
168     textEncodingNameMap = new TextEncodingNameMap;
169 
170     TextCodecLatin1::registerEncodingNames(addToTextEncodingNameMap);
171     TextCodecLatin1::registerCodecs(addToTextCodecMap);
172 
173     TextCodecUTF8::registerEncodingNames(addToTextEncodingNameMap);
174     TextCodecUTF8::registerCodecs(addToTextCodecMap);
175 
176     TextCodecUTF16::registerEncodingNames(addToTextEncodingNameMap);
177     TextCodecUTF16::registerCodecs(addToTextCodecMap);
178 
179     TextCodecUserDefined::registerEncodingNames(addToTextEncodingNameMap);
180     TextCodecUserDefined::registerCodecs(addToTextCodecMap);
181 }
182 
183 static void addEncodingName(HashSet&lt;const char*&gt;* set, const char* name)
184 {
<span class="line-modified">185     // We must not use atomCanonicalTextEncodingName() because this function is called in it.</span>
<span class="line-modified">186     const char* atomName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">187     if (atomName)</span>
<span class="line-modified">188         set-&gt;add(atomName);</span>
189 }
190 
191 static void buildQuirksSets()
192 {
193     // FIXME: Having isJapaneseEncoding() and shouldShowBackslashAsCurrencySymbolIn()
194     // and initializing the sets for them in TextEncodingRegistry.cpp look strange.
195 
196     ASSERT(!japaneseEncodings);
197     ASSERT(!nonBackslashEncodings);
198 
199     japaneseEncodings = new HashSet&lt;const char*&gt;;
200     addEncodingName(japaneseEncodings, &quot;EUC-JP&quot;);
201     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP&quot;);
202     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP-1&quot;);
203     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP-2&quot;);
204     addEncodingName(japaneseEncodings, &quot;ISO-2022-JP-3&quot;);
205     addEncodingName(japaneseEncodings, &quot;JIS_C6226-1978&quot;);
206     addEncodingName(japaneseEncodings, &quot;JIS_X0201&quot;);
207     addEncodingName(japaneseEncodings, &quot;JIS_X0208-1983&quot;);
208     addEncodingName(japaneseEncodings, &quot;JIS_X0208-1990&quot;);
</pre>
<hr />
<pre>
224 }
225 
226 bool isJapaneseEncoding(const char* canonicalEncodingName)
227 {
228     return canonicalEncodingName &amp;&amp; japaneseEncodings &amp;&amp; japaneseEncodings-&gt;contains(canonicalEncodingName);
229 }
230 
231 bool shouldShowBackslashAsCurrencySymbolIn(const char* canonicalEncodingName)
232 {
233     return canonicalEncodingName &amp;&amp; nonBackslashEncodings &amp;&amp; nonBackslashEncodings-&gt;contains(canonicalEncodingName);
234 }
235 
236 static void extendTextCodecMaps()
237 {
238     TextCodecReplacement::registerEncodingNames(addToTextEncodingNameMap);
239     TextCodecReplacement::registerCodecs(addToTextCodecMap);
240 
241     TextCodecICU::registerEncodingNames(addToTextEncodingNameMap);
242     TextCodecICU::registerCodecs(addToTextCodecMap);
243 
<span class="line-added">244 #if USE(JAVA_UNICODE)</span>
<span class="line-added">245     TextCodecJava::registerEncodingNames(addToTextEncodingNameMap);</span>
<span class="line-added">246     TextCodecJava::registerCodecs(addToTextCodecMap);</span>
<span class="line-added">247 #endif</span>
<span class="line-added">248 </span>
249     pruneBlacklistedCodecs();
250     buildQuirksSets();
251 }
252 
253 std::unique_ptr&lt;TextCodec&gt; newTextCodec(const TextEncoding&amp; encoding)
254 {
255     std::lock_guard&lt;Lock&gt; lock(encodingRegistryMutex);
256 
257     ASSERT(textCodecMap);
258     auto result = textCodecMap-&gt;find(encoding.name());
259     ASSERT(result != textCodecMap-&gt;end());
260     return result-&gt;value();
261 }
262 
<span class="line-modified">263 const char* atomCanonicalTextEncodingName(const char* name)</span>
264 {
265     if (!name || !name[0])
266         return nullptr;
267 
268     std::lock_guard&lt;Lock&gt; lock(encodingRegistryMutex);
269 
270     if (!textEncodingNameMap)
271         buildBaseTextCodecMaps(lock);
272 
<span class="line-modified">273     if (const char* atomName = textEncodingNameMap-&gt;get(name))</span>
<span class="line-modified">274         return atomName;</span>
275     if (didExtendTextCodecMaps)
276         return nullptr;
277 
278     extendTextCodecMaps();
279     didExtendTextCodecMaps = true;
280     return textEncodingNameMap-&gt;get(name);
281 }
282 
<span class="line-modified">283 template&lt;typename CharacterType&gt; static const char* atomCanonicalTextEncodingName(const CharacterType* characters, size_t length)</span>
284 {
285     char buffer[maxEncodingNameLength + 1];
286     size_t j = 0;
287     for (size_t i = 0; i &lt; length; ++i) {
288         if (j == maxEncodingNameLength)
289             return nullptr;
290         buffer[j++] = characters[i];
291     }
292     buffer[j] = 0;
<span class="line-modified">293     return atomCanonicalTextEncodingName(buffer);</span>
294 }
295 
<span class="line-modified">296 const char* atomCanonicalTextEncodingName(const String&amp; alias)</span>
297 {
298     if (alias.isEmpty() || !alias.isAllASCII())
299         return nullptr;
300 
301     if (alias.is8Bit())
<span class="line-modified">302         return atomCanonicalTextEncodingName(alias.characters8(), alias.length());</span>
303 
<span class="line-modified">304     return atomCanonicalTextEncodingName(alias.characters16(), alias.length());</span>
305 }
306 
307 bool noExtendedTextEncodingNameUsed()
308 {
309     // If the calling thread did not use extended encoding names, it is fine for it to use a stale false value.
310     return !didExtendTextCodecMaps;
311 }
312 
313 String defaultTextEncodingNameForSystemLanguage()
314 {
315 #if PLATFORM(COCOA)
316     String systemEncodingName = CFStringConvertEncodingToIANACharSetName(webDefaultCFStringEncoding());
317 
318     // CFStringConvertEncodingToIANACharSetName() returns cp949 for kTextEncodingDOSKorean AKA &quot;extended EUC-KR&quot; AKA windows-949.
319     // ICU uses this name for a different encoding, so we need to change the name to a value that actually gives us windows-949.
320     // In addition, this value must match what is used in Safari, see &lt;rdar://problem/5579292&gt;.
321     // On some OS versions, the result is CP949 (uppercase).
322     if (equalLettersIgnoringASCIICase(systemEncodingName, &quot;cp949&quot;))
323         systemEncodingName = &quot;ks_c_5601-1987&quot;_s;
324 
</pre>
</td>
</tr>
</table>
<center><a href="TextEncoding.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextEncodingRegistry.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
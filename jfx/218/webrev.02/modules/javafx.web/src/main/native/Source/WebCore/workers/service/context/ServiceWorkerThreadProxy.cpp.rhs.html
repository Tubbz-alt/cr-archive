<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThreadProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThreadProxy.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;EventLoop.h&quot;</span>
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;FetchLoader.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;LoaderStrategy.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 38 #include &quot;MessageWithMessagePorts.h&quot;</span>
 39 #include &quot;PlatformStrategies.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 40 #include &quot;ServiceWorkerClientData.h&quot;</span>
 41 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &quot;WorkerGlobalScope.h&quot;
<a name="4" id="anc4"></a>
 44 #include &lt;wtf/MainThread.h&gt;
 45 #include &lt;wtf/RunLoop.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 URL static inline topOriginURL(const SecurityOrigin&amp; origin)
 50 {
 51     URL url;
 52     url.setProtocol(origin.protocol());
 53     url.setHost(origin.host());
 54     if (origin.port())
 55         url.setPort(*origin.port());
 56     return url;
 57 }
 58 
<a name="5" id="anc5"></a><span class="line-modified"> 59 static inline UniqueRef&lt;Page&gt; createPageForServiceWorker(PageConfiguration&amp;&amp; configuration, const ServiceWorkerContextData&amp; data, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
 60 {
 61     auto page = makeUniqueRef&lt;Page&gt;(WTFMove(configuration));
<a name="6" id="anc6"></a>
 62 
 63     auto&amp; mainFrame = page-&gt;mainFrame();
 64     mainFrame.loader().initForSynthesizedDocument({ });
 65     auto document = Document::createNonRenderedPlaceholder(mainFrame, data.scriptURL);
 66     document-&gt;createDOMWindow();
 67 
 68     document-&gt;mutableSettings().setStorageBlockingPolicy(storageBlockingPolicy);
 69     document-&gt;storageBlockingStateDidChange();
 70 
 71     auto origin = data.registration.key.topOrigin().securityOrigin();
 72     origin-&gt;setStorageBlockingPolicy(storageBlockingPolicy);
 73 
 74     document-&gt;setSiteForCookies(topOriginURL(origin));
<a name="7" id="anc7"></a><span class="line-modified"> 75     document-&gt;setFirstPartyForCookies(topOriginURL(origin));</span>
 76     document-&gt;setDomainForCachePartition(origin-&gt;domainForCachePartition());
 77 
 78     if (auto policy = parseReferrerPolicy(data.referrerPolicy, ReferrerPolicySource::HTTPHeader))
 79         document-&gt;setReferrerPolicy(*policy);
 80 
 81     mainFrame.setDocument(WTFMove(document));
 82     return page;
 83 }
 84 
 85 static inline IDBClient::IDBConnectionProxy* idbConnectionProxy(Document&amp; document)
 86 {
 87 #if ENABLE(INDEXED_DATABASE)
 88     return document.idbConnectionProxy();
 89 #else
 90     return nullptr;
 91 #endif
 92 }
 93 
 94 static HashSet&lt;ServiceWorkerThreadProxy*&gt;&amp; allServiceWorkerThreadProxies()
 95 {
 96     static NeverDestroyed&lt;HashSet&lt;ServiceWorkerThreadProxy*&gt;&gt; set;
 97     return set;
 98 }
 99 
<a name="8" id="anc8"></a><span class="line-modified">100 ServiceWorkerThreadProxy::ServiceWorkerThreadProxy(PageConfiguration&amp;&amp; pageConfiguration, const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, CacheStorageProvider&amp; cacheStorageProvider, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)</span>
<span class="line-modified">101     : m_page(createPageForServiceWorker(WTFMove(pageConfiguration), data, storageBlockingPolicy))</span>
102     , m_document(*m_page-&gt;mainFrame().document())
<a name="9" id="anc9"></a><span class="line-modified">103     , m_serviceWorkerThread(ServiceWorkerThread::create(data, WTFMove(userAgent), *this, *this, idbConnectionProxy(m_document), m_document-&gt;socketProvider()))</span>
104     , m_cacheStorageProvider(cacheStorageProvider)
<a name="10" id="anc10"></a>
105     , m_inspectorProxy(*this)
106 {
107     static bool addedListener;
108     if (!addedListener) {
109         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
110         addedListener = true;
111     }
112 
113     ASSERT(!allServiceWorkerThreadProxies().contains(this));
114     allServiceWorkerThreadProxies().add(this);
115 
116 #if ENABLE(REMOTE_INSPECTOR)
117     m_remoteDebuggable = makeUnique&lt;ServiceWorkerDebuggable&gt;(*this, data);
118     m_remoteDebuggable-&gt;setRemoteDebuggingAllowed(true);
119     m_remoteDebuggable-&gt;init();
120 #endif
121 }
122 
123 ServiceWorkerThreadProxy::~ServiceWorkerThreadProxy()
124 {
125     ASSERT(allServiceWorkerThreadProxies().contains(this));
126     allServiceWorkerThreadProxies().remove(this);
127 }
128 
129 bool ServiceWorkerThreadProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
130 {
131     if (m_isTerminatingOrTerminated)
132         return false;
133 
134     m_serviceWorkerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
135     return true;
136 }
137 
138 void ServiceWorkerThreadProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
139 {
140     callOnMainThread([task = WTFMove(task), this, protectedThis = makeRef(*this)] () mutable {
141         task.performTask(m_document.get());
142     });
143 }
144 
145 void ServiceWorkerThreadProxy::postMessageToDebugger(const String&amp; message)
146 {
147     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
148         // FIXME: Handle terminated case.
149         m_inspectorProxy.sendMessageFromWorkerToFrontend(message);
150     });
151 }
152 
<a name="11" id="anc11"></a><span class="line-modified">153 void ServiceWorkerThreadProxy::setResourceCachingDisabledByWebInspector(bool disabled)</span>
154 {
155     postTaskToLoader([this, protectedThis = makeRef(*this), disabled] (ScriptExecutionContext&amp;) {
156         ASSERT(isMainThread());
<a name="12" id="anc12"></a><span class="line-modified">157         m_page-&gt;setResourceCachingDisabledByWebInspector(disabled);</span>
158     });
159 }
160 
161 Ref&lt;CacheStorageConnection&gt; ServiceWorkerThreadProxy::createCacheStorageConnection()
162 {
163     ASSERT(isMainThread());
164     if (!m_cacheStorageConnection)
<a name="13" id="anc13"></a><span class="line-modified">165         m_cacheStorageConnection = m_cacheStorageProvider.createCacheStorageConnection();</span>
166     return *m_cacheStorageConnection;
167 }
168 
169 std::unique_ptr&lt;FetchLoader&gt; ServiceWorkerThreadProxy::createBlobLoader(FetchLoaderClient&amp; client, const URL&amp; blobURL)
170 {
171     auto loader = makeUnique&lt;FetchLoader&gt;(client, nullptr);
172     loader-&gt;startLoadingBlobURL(m_document, blobURL);
173     if (!loader-&gt;isStarted())
174         return nullptr;
175     return loader;
176 }
177 
178 void ServiceWorkerThreadProxy::networkStateChanged(bool isOnLine)
179 {
180     for (auto* proxy : allServiceWorkerThreadProxies())
181         proxy-&gt;notifyNetworkStateChange(isOnLine);
182 }
183 
184 void ServiceWorkerThreadProxy::notifyNetworkStateChange(bool isOnline)
185 {
186     if (m_isTerminatingOrTerminated)
187         return;
188 
189     postTaskForModeToWorkerGlobalScope([isOnline] (ScriptExecutionContext&amp; context) {
190         auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
191         globalScope.setIsOnline(isOnline);
<a name="14" id="anc14"></a><span class="line-modified">192         globalScope.eventLoop().queueTask(TaskSource::DOMManipulation, [globalScope = makeRef(globalScope), isOnline] {</span>
<span class="line-added">193             globalScope-&gt;dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
<span class="line-added">194         });</span>
195     }, WorkerRunLoop::defaultMode());
196 }
197 
198 void ServiceWorkerThreadProxy::startFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier, Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
199 {
200     auto key = std::make_pair(connectionIdentifier, fetchIdentifier);
201 
<a name="15" id="anc15"></a><span class="line-added">202     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">203         thread().startFetchEventMonitoring();</span>
<span class="line-added">204 </span>
205     ASSERT(!m_ongoingFetchTasks.contains(key));
206     m_ongoingFetchTasks.add(key, client.copyRef());
<a name="16" id="anc16"></a><span class="line-modified">207     postTaskForModeToWorkerGlobalScope([this, protectedThis = makeRef(*this), client = WTFMove(client), clientId, request = request.isolatedCopy(), referrer = referrer.isolatedCopy(), options = options.isolatedCopy()](auto&amp;) mutable {</span>
<span class="line-added">208         thread().queueTaskToFireFetchEvent(WTFMove(client), WTFMove(clientId), WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="line-added">209     }, WorkerRunLoop::defaultMode());</span>
210 }
211 
212 void ServiceWorkerThreadProxy::cancelFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
213 {
214     auto client = m_ongoingFetchTasks.take(std::make_pair(connectionIdentifier, fetchIdentifier));
215     if (!client)
216         return;
217 
<a name="17" id="anc17"></a><span class="line-added">218     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">219         thread().stopFetchEventMonitoring();</span>
<span class="line-added">220 </span>
221     postTaskForModeToWorkerGlobalScope([client = WTFMove(client.value())] (ScriptExecutionContext&amp;) {
222         client-&gt;cancel();
223     }, WorkerRunLoop::defaultMode());
224 }
225 
226 void ServiceWorkerThreadProxy::continueDidReceiveFetchResponse(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
227 {
228     auto client = m_ongoingFetchTasks.get(std::make_pair(connectionIdentifier, fetchIdentifier));
229     if (!client)
230         return;
231 
232     postTaskForModeToWorkerGlobalScope([client = makeRef(*client)] (ScriptExecutionContext&amp;) {
233         client-&gt;continueDidReceiveResponse();
234     }, WorkerRunLoop::defaultMode());
235 }
236 
237 void ServiceWorkerThreadProxy::removeFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
238 {
239     m_ongoingFetchTasks.remove(std::make_pair(connectionIdentifier, fetchIdentifier));
<a name="18" id="anc18"></a><span class="line-added">240 </span>
<span class="line-added">241     if (m_ongoingFetchTasks.isEmpty())</span>
<span class="line-added">242         thread().stopFetchEventMonitoring();</span>
<span class="line-added">243 }</span>
<span class="line-added">244 </span>
<span class="line-added">245 void ServiceWorkerThreadProxy::postMessageToServiceWorker(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
<span class="line-added">246 {</span>
<span class="line-added">247     thread().willPostTaskToFireMessageEvent();</span>
<span class="line-added">248     thread().runLoop().postTask([this, protectedThis = makeRef(*this), message = WTFMove(message), sourceData = WTFMove(sourceData)](auto&amp;) mutable {</span>
<span class="line-added">249         thread().queueTaskToPostMessage(WTFMove(message), WTFMove(sourceData));</span>
<span class="line-added">250     });</span>
<span class="line-added">251 }</span>
<span class="line-added">252 </span>
<span class="line-added">253 void ServiceWorkerThreadProxy::fireInstallEvent()</span>
<span class="line-added">254 {</span>
<span class="line-added">255     thread().willPostTaskToFireInstallEvent();</span>
<span class="line-added">256     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">257         thread().queueTaskToFireInstallEvent();</span>
<span class="line-added">258     });</span>
<span class="line-added">259 }</span>
<span class="line-added">260 </span>
<span class="line-added">261 void ServiceWorkerThreadProxy::fireActivateEvent()</span>
<span class="line-added">262 {</span>
<span class="line-added">263     thread().willPostTaskToFireActivateEvent();</span>
<span class="line-added">264     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">265         thread().queueTaskToFireActivateEvent();</span>
<span class="line-added">266     });</span>
267 }
268 
269 } // namespace WebCore
270 
271 #endif // ENABLE(SERVICE_WORKER)
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
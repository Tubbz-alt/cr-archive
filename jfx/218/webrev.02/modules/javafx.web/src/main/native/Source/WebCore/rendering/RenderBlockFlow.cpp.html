<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2007 David Smith (catfish.man@gmail.com)
   5  * Copyright (C) 2003-2015 Apple Inc. All rights reserved.
   6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlockFlow.h&quot;
  26 
  27 #include &quot;ComplexLineLayout.h&quot;
  28 #include &quot;Editor.h&quot;
  29 #include &quot;FloatingObjects.h&quot;
  30 #include &quot;Frame.h&quot;
  31 #include &quot;FrameSelection.h&quot;
  32 #include &quot;HTMLElement.h&quot;
  33 #include &quot;HTMLInputElement.h&quot;
  34 #include &quot;HTMLParserIdioms.h&quot;
  35 #include &quot;HTMLTextAreaElement.h&quot;
  36 #include &quot;HitTestLocation.h&quot;
  37 #include &quot;InlineTextBox.h&quot;
  38 #include &quot;LayoutIntegrationLineLayout.h&quot;
  39 #include &quot;LayoutRepainter.h&quot;
  40 #include &quot;Logging.h&quot;
  41 #include &quot;RenderCombineText.h&quot;
  42 #include &quot;RenderFlexibleBox.h&quot;
  43 #include &quot;RenderInline.h&quot;
  44 #include &quot;RenderIterator.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 #include &quot;RenderLayoutState.h&quot;
  47 #include &quot;RenderLineBreak.h&quot;
  48 #include &quot;RenderListItem.h&quot;
  49 #include &quot;RenderMarquee.h&quot;
  50 #include &quot;RenderMultiColumnFlow.h&quot;
  51 #include &quot;RenderMultiColumnSet.h&quot;
  52 #include &quot;RenderTableCell.h&quot;
  53 #include &quot;RenderText.h&quot;
  54 #include &quot;RenderTreeBuilder.h&quot;
  55 #include &quot;RenderView.h&quot;
  56 #include &quot;Settings.h&quot;
  57 #include &quot;SimpleLineLayoutFunctions.h&quot;
  58 #include &quot;SimpleLineLayoutPagination.h&quot;
  59 #include &quot;SimpleLineLayoutResolver.h&quot;
  60 #include &quot;TextAutoSizing.h&quot;
  61 #include &quot;VerticalPositionCache.h&quot;
  62 #include &quot;VisiblePosition.h&quot;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 
  65 namespace WebCore {
  66 
  67 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderBlockFlow);
  68 
  69 bool RenderBlock::s_canPropagateFloatIntoSibling = false;
  70 
  71 struct SameSizeAsMarginInfo {
  72     uint32_t bitfields : 16;
  73     LayoutUnit margins[2];
  74 };
  75 
  76 COMPILE_ASSERT(sizeof(RenderBlockFlow::MarginValues) == sizeof(LayoutUnit[4]), MarginValues_should_stay_small);
  77 COMPILE_ASSERT(sizeof(RenderBlockFlow::MarginInfo) == sizeof(SameSizeAsMarginInfo), MarginInfo_should_stay_small);
  78 
  79 // Our MarginInfo state used when laying out block children.
  80 RenderBlockFlow::MarginInfo::MarginInfo(const RenderBlockFlow&amp; block, LayoutUnit beforeBorderPadding, LayoutUnit afterBorderPadding)
  81     : m_atBeforeSideOfBlock(true)
  82     , m_atAfterSideOfBlock(false)
  83     , m_hasMarginBeforeQuirk(false)
  84     , m_hasMarginAfterQuirk(false)
  85     , m_determinedMarginBeforeQuirk(false)
  86     , m_discardMargin(false)
  87 {
  88     const RenderStyle&amp; blockStyle = block.style();
  89     ASSERT(block.isRenderView() || block.parent());
  90     m_canCollapseWithChildren = !block.createsNewFormattingContext() &amp;&amp; !block.isRenderView();
  91 
  92     m_canCollapseMarginBeforeWithChildren = m_canCollapseWithChildren &amp;&amp; !beforeBorderPadding &amp;&amp; blockStyle.marginBeforeCollapse() != MarginCollapse::Separate;
  93 
  94     // If any height other than auto is specified in CSS, then we don&#39;t collapse our bottom
  95     // margins with our children&#39;s margins. To do otherwise would be to risk odd visual
  96     // effects when the children overflow out of the parent block and yet still collapse
  97     // with it. We also don&#39;t collapse if we have any bottom border/padding.
  98     m_canCollapseMarginAfterWithChildren = m_canCollapseWithChildren &amp;&amp; !afterBorderPadding
  99         &amp;&amp; (blockStyle.logicalHeight().isAuto() &amp;&amp; !blockStyle.logicalHeight().value()) &amp;&amp; blockStyle.marginAfterCollapse() != MarginCollapse::Separate;
 100 
 101     m_quirkContainer = block.isTableCell() || block.isBody();
 102 
 103     m_discardMargin = m_canCollapseMarginBeforeWithChildren &amp;&amp; block.mustDiscardMarginBefore();
 104 
 105     m_positiveMargin = (m_canCollapseMarginBeforeWithChildren &amp;&amp; !block.mustDiscardMarginBefore()) ? block.maxPositiveMarginBefore() : 0_lu;
 106     m_negativeMargin = (m_canCollapseMarginBeforeWithChildren &amp;&amp; !block.mustDiscardMarginBefore()) ? block.maxNegativeMarginBefore() : 0_lu;
 107 }
 108 
 109 RenderBlockFlow::RenderBlockFlow(Element&amp; element, RenderStyle&amp;&amp; style)
 110     : RenderBlock(element, WTFMove(style), RenderBlockFlowFlag)
 111 #if ENABLE(TEXT_AUTOSIZING)
 112     , m_widthForTextAutosizing(-1)
 113     , m_lineCountForTextAutosizing(NOT_SET)
 114 #endif
 115 {
 116     setChildrenInline(true);
 117 }
 118 
 119 RenderBlockFlow::RenderBlockFlow(Document&amp; document, RenderStyle&amp;&amp; style)
 120     : RenderBlock(document, WTFMove(style), RenderBlockFlowFlag)
 121 #if ENABLE(TEXT_AUTOSIZING)
 122     , m_widthForTextAutosizing(-1)
 123     , m_lineCountForTextAutosizing(NOT_SET)
 124 #endif
 125 {
 126     setChildrenInline(true);
 127 }
 128 
 129 RenderBlockFlow::~RenderBlockFlow()
 130 {
 131     // Do not add any code here. Add it to willBeDestroyed() instead.
 132 }
 133 
 134 void RenderBlockFlow::willBeDestroyed()
 135 {
 136     if (!renderTreeBeingDestroyed()) {
 137         if (firstRootBox()) {
 138             // We can&#39;t wait for RenderBox::destroy to clear the selection,
 139             // because by then we will have nuked the line boxes.
 140             if (isSelectionBorder())
 141                 frame().selection().setNeedsSelectionUpdate();
 142 
 143             // If we are an anonymous block, then our line boxes might have children
 144             // that will outlast this block. In the non-anonymous block case those
 145             // children will be destroyed by the time we return from this function.
 146             if (isAnonymousBlock()) {
 147                 for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
 148                     while (auto childBox = box-&gt;firstChild())
 149                         childBox-&gt;removeFromParent();
 150                 }
 151             }
 152         } else if (parent())
 153             parent()-&gt;dirtyLinesFromChangedChild(*this);
 154     }
 155 
 156     if (complexLineLayout())
 157         complexLineLayout()-&gt;lineBoxes().deleteLineBoxes();
 158 
 159     blockWillBeDestroyed();
 160 
 161     // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
 162     RenderBox::willBeDestroyed();
 163 }
 164 
 165 RenderMultiColumnFlow* RenderBlockFlow::multiColumnFlowSlowCase() const
 166 {
 167     return rareBlockFlowData()-&gt;m_multiColumnFlow.get();
 168 }
 169 
 170 RenderBlockFlow* RenderBlockFlow::previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const
 171 {
 172     // Attempt to locate a previous sibling with overhanging floats. We skip any elements that are
 173     // out of flow (like floating/positioned elements), and we also skip over any objects that may have shifted
 174     // to avoid floats.
 175     parentHasFloats = false;
 176     for (RenderObject* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 177         if (is&lt;RenderBlockFlow&gt;(*sibling)) {
 178             auto&amp; siblingBlock = downcast&lt;RenderBlockFlow&gt;(*sibling);
 179             if (!siblingBlock.avoidsFloats())
 180                 return &amp;siblingBlock;
 181         }
 182         if (sibling-&gt;isFloating())
 183             parentHasFloats = true;
 184     }
 185     return nullptr;
 186 }
 187 
 188 void RenderBlockFlow::rebuildFloatingObjectSetFromIntrudingFloats()
 189 {
 190     if (m_floatingObjects)
 191         m_floatingObjects-&gt;setHorizontalWritingMode(isHorizontalWritingMode());
 192 
 193     HashSet&lt;RenderBox*&gt; oldIntrudingFloatSet;
 194     if (!childrenInline() &amp;&amp; m_floatingObjects) {
 195         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
 196         auto end = floatingObjectSet.end();
 197         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
 198             FloatingObject* floatingObject = it-&gt;get();
 199             if (!floatingObject-&gt;isDescendant())
 200                 oldIntrudingFloatSet.add(&amp;floatingObject-&gt;renderer());
 201         }
 202     }
 203 
 204     // Inline blocks are covered by the isReplaced() check in the avoidFloats method.
 205     if (avoidsFloats() || isDocumentElementRenderer() || isRenderView() || isFloatingOrOutOfFlowPositioned() || isTableCell()) {
 206         if (m_floatingObjects)
 207             m_floatingObjects-&gt;clear();
 208         if (!oldIntrudingFloatSet.isEmpty())
 209             markAllDescendantsWithFloatsForLayout();
 210         return;
 211     }
 212 
 213     RendererToFloatInfoMap floatMap;
 214 
 215     if (m_floatingObjects) {
 216         if (childrenInline())
 217             m_floatingObjects-&gt;moveAllToFloatInfoMap(floatMap);
 218         else
 219             m_floatingObjects-&gt;clear();
 220     }
 221 
 222     // We should not process floats if the parent node is not a RenderBlock. Otherwise, we will add
 223     // floats in an invalid context. This will cause a crash arising from a bad cast on the parent.
 224     // See &lt;rdar://problem/8049753&gt;, where float property is applied on a text node in a SVG.
 225     if (!is&lt;RenderBlockFlow&gt;(parent()))
 226         return;
 227 
 228     // First add in floats from the parent. Self-collapsing blocks let their parent track any floats that intrude into
 229     // them (as opposed to floats they contain themselves) so check for those here too.
 230     auto&amp; parentBlock = downcast&lt;RenderBlockFlow&gt;(*parent());
 231     bool parentHasFloats = false;
 232     RenderBlockFlow* previousBlock = previousSiblingWithOverhangingFloats(parentHasFloats);
 233     LayoutUnit logicalTopOffset = logicalTop();
 234     if (parentHasFloats || (parentBlock.lowestFloatLogicalBottom() &gt; logicalTopOffset &amp;&amp; previousBlock &amp;&amp; previousBlock-&gt;isSelfCollapsingBlock()))
 235         addIntrudingFloats(&amp;parentBlock, &amp;parentBlock, parentBlock.logicalLeftOffsetForContent(), logicalTopOffset);
 236 
 237     LayoutUnit logicalLeftOffset;
 238     if (previousBlock)
 239         logicalTopOffset -= previousBlock-&gt;logicalTop();
 240     else {
 241         previousBlock = &amp;parentBlock;
 242         logicalLeftOffset += parentBlock.logicalLeftOffsetForContent();
 243     }
 244 
 245     // Add overhanging floats from the previous RenderBlock, but only if it has a float that intrudes into our space.
 246     if (previousBlock-&gt;m_floatingObjects &amp;&amp; previousBlock-&gt;lowestFloatLogicalBottom() &gt; logicalTopOffset)
 247         addIntrudingFloats(previousBlock, &amp;parentBlock, logicalLeftOffset, logicalTopOffset);
 248 
 249     if (childrenInline()) {
 250         LayoutUnit changeLogicalTop = LayoutUnit::max();
 251         LayoutUnit changeLogicalBottom = LayoutUnit::min();
 252         if (m_floatingObjects) {
 253             const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
 254             auto end = floatingObjectSet.end();
 255             for (auto it = floatingObjectSet.begin(); it != end; ++it) {
 256                 const auto&amp; floatingObject = *it-&gt;get();
 257                 std::unique_ptr&lt;FloatingObject&gt; oldFloatingObject = floatMap.take(&amp;floatingObject.renderer());
 258                 LayoutUnit logicalBottom = logicalBottomForFloat(floatingObject);
 259                 if (oldFloatingObject) {
 260                     LayoutUnit oldLogicalBottom = logicalBottomForFloat(*oldFloatingObject);
 261                     if (logicalWidthForFloat(floatingObject) != logicalWidthForFloat(*oldFloatingObject) || logicalLeftForFloat(floatingObject) != logicalLeftForFloat(*oldFloatingObject)) {
 262                         changeLogicalTop = 0;
 263                         changeLogicalBottom = std::max(changeLogicalBottom, std::max(logicalBottom, oldLogicalBottom));
 264                     } else {
 265                         if (logicalBottom != oldLogicalBottom) {
 266                             changeLogicalTop = std::min(changeLogicalTop, std::min(logicalBottom, oldLogicalBottom));
 267                             changeLogicalBottom = std::max(changeLogicalBottom, std::max(logicalBottom, oldLogicalBottom));
 268                         }
 269                         LayoutUnit logicalTop = logicalTopForFloat(floatingObject);
 270                         LayoutUnit oldLogicalTop = logicalTopForFloat(*oldFloatingObject);
 271                         if (logicalTop != oldLogicalTop) {
 272                             changeLogicalTop = std::min(changeLogicalTop, std::min(logicalTop, oldLogicalTop));
 273                             changeLogicalBottom = std::max(changeLogicalBottom, std::max(logicalTop, oldLogicalTop));
 274                         }
 275                     }
 276 
 277                     if (oldFloatingObject-&gt;originatingLine() &amp;&amp; !selfNeedsLayout()) {
 278                         ASSERT(&amp;oldFloatingObject-&gt;originatingLine()-&gt;renderer() == this);
 279                         oldFloatingObject-&gt;originatingLine()-&gt;markDirty();
 280                     }
 281                 } else {
 282                     changeLogicalTop = 0;
 283                     changeLogicalBottom = std::max(changeLogicalBottom, logicalBottom);
 284                 }
 285             }
 286         }
 287 
 288         auto end = floatMap.end();
 289         for (auto it = floatMap.begin(); it != end; ++it) {
 290             const auto&amp; floatingObject = *it-&gt;value.get();
 291             if (!floatingObject.isDescendant()) {
 292                 changeLogicalTop = 0;
 293                 changeLogicalBottom = std::max(changeLogicalBottom, logicalBottomForFloat(floatingObject));
 294             }
 295         }
 296 
 297         markLinesDirtyInBlockRange(changeLogicalTop, changeLogicalBottom);
 298     } else if (!oldIntrudingFloatSet.isEmpty()) {
 299         // If there are previously intruding floats that no longer intrude, then children with floats
 300         // should also get layout because they might need their floating object lists cleared.
 301         if (m_floatingObjects-&gt;set().size() &lt; oldIntrudingFloatSet.size())
 302             markAllDescendantsWithFloatsForLayout();
 303         else {
 304             const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
 305             auto end = floatingObjectSet.end();
 306             for (auto it = floatingObjectSet.begin(); it != end &amp;&amp; !oldIntrudingFloatSet.isEmpty(); ++it)
 307                 oldIntrudingFloatSet.remove(&amp;(*it)-&gt;renderer());
 308             if (!oldIntrudingFloatSet.isEmpty())
 309                 markAllDescendantsWithFloatsForLayout();
 310         }
 311     }
 312 }
 313 
 314 void RenderBlockFlow::adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
 315 {
 316     if (!style().hasAutoColumnCount() || !style().hasAutoColumnWidth()) {
 317         // The min/max intrinsic widths calculated really tell how much space elements need when
 318         // laid out inside the columns. In order to eventually end up with the desired column width,
 319         // we need to convert them to values pertaining to the multicol container.
 320         int columnCount = style().hasAutoColumnCount() ? 1 : style().columnCount();
 321         LayoutUnit columnWidth;
 322         LayoutUnit colGap = columnGap();
 323         LayoutUnit gapExtra = (columnCount - 1) * colGap;
 324         if (style().hasAutoColumnWidth())
 325             minLogicalWidth = minLogicalWidth * columnCount + gapExtra;
 326         else {
 327             columnWidth = style().columnWidth();
 328             minLogicalWidth = std::min(minLogicalWidth, columnWidth);
 329         }
 330         // FIXME: If column-count is auto here, we should resolve it to calculate the maximum
 331         // intrinsic width, instead of pretending that it&#39;s 1. The only way to do that is by
 332         // performing a layout pass, but this is not an appropriate time or place for layout. The
 333         // good news is that if height is unconstrained and there are no explicit breaks, the
 334         // resolved column-count really should be 1.
 335         maxLogicalWidth = std::max(maxLogicalWidth, columnWidth) * columnCount + gapExtra;
 336     }
 337 }
 338 
 339 void RenderBlockFlow::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
 340 {
 341     if (childrenInline())
 342         computeInlinePreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
 343     else
 344         computeBlockPreferredLogicalWidths(minLogicalWidth, maxLogicalWidth);
 345 
 346     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
 347 
 348     adjustIntrinsicLogicalWidthsForColumns(minLogicalWidth, maxLogicalWidth);
 349 
 350     if (!style().autoWrap() &amp;&amp; childrenInline()) {
 351         // A horizontal marquee with inline children has no minimum width.
 352         if (layer() &amp;&amp; layer()-&gt;marquee() &amp;&amp; layer()-&gt;marquee()-&gt;isHorizontal())
 353             minLogicalWidth = 0;
 354     }
 355 
 356     if (is&lt;RenderTableCell&gt;(*this)) {
 357         Length tableCellWidth = downcast&lt;RenderTableCell&gt;(*this).styleOrColLogicalWidth();
 358         if (tableCellWidth.isFixed() &amp;&amp; tableCellWidth.value() &gt; 0)
 359             maxLogicalWidth = std::max(minLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(tableCellWidth.value()));
 360     }
 361 
 362     int scrollbarWidth = intrinsicScrollbarLogicalWidth();
 363     maxLogicalWidth += scrollbarWidth;
 364     minLogicalWidth += scrollbarWidth;
 365 }
 366 
 367 bool RenderBlockFlow::recomputeLogicalWidthAndColumnWidth()
 368 {
 369     bool changed = recomputeLogicalWidth();
 370 
 371     LayoutUnit oldColumnWidth = computedColumnWidth();
 372     computeColumnCountAndWidth();
 373 
 374     return changed || oldColumnWidth != computedColumnWidth();
 375 }
 376 
 377 LayoutUnit RenderBlockFlow::columnGap() const
 378 {
 379     if (style().columnGap().isNormal())
 380         return style().fontDescription().computedPixelSize(); // &quot;1em&quot; is recommended as the normal gap setting. Matches &lt;p&gt; margins.
 381     return valueForLength(style().columnGap().length(), availableLogicalWidth());
 382 }
 383 
 384 void RenderBlockFlow::computeColumnCountAndWidth()
 385 {
 386     // Calculate our column width and column count.
 387     // FIXME: Can overflow on fast/block/float/float-not-removed-from-next-sibling4.html, see https://bugs.webkit.org/show_bug.cgi?id=68744
 388     unsigned desiredColumnCount = 1;
 389     LayoutUnit desiredColumnWidth = contentLogicalWidth();
 390 
 391     // For now, we don&#39;t support multi-column layouts when printing, since we have to do a lot of work for proper pagination.
 392     if (document().paginated() || (style().hasAutoColumnCount() &amp;&amp; style().hasAutoColumnWidth()) || !style().hasInlineColumnAxis()) {
 393         setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 394         return;
 395     }
 396 
 397     LayoutUnit availWidth = desiredColumnWidth;
 398     LayoutUnit colGap = columnGap();
 399     LayoutUnit colWidth = std::max(1_lu, LayoutUnit(style().columnWidth()));
 400     unsigned colCount = std::max&lt;unsigned&gt;(1, style().columnCount());
 401 
 402     if (style().hasAutoColumnWidth() &amp;&amp; !style().hasAutoColumnCount()) {
 403         desiredColumnCount = colCount;
 404         desiredColumnWidth = std::max&lt;LayoutUnit&gt;(0, (availWidth - ((desiredColumnCount - 1) * colGap)) / desiredColumnCount);
 405     } else if (!style().hasAutoColumnWidth() &amp;&amp; style().hasAutoColumnCount()) {
 406         desiredColumnCount = std::max&lt;unsigned&gt;(1, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned());
 407         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 408     } else {
 409         desiredColumnCount = std::max&lt;unsigned&gt;(std::min(colCount, ((availWidth + colGap) / (colWidth + colGap)).toUnsigned()), 1);
 410         desiredColumnWidth = ((availWidth + colGap) / desiredColumnCount) - colGap;
 411     }
 412     setComputedColumnCountAndWidth(desiredColumnCount, desiredColumnWidth);
 413 }
 414 
 415 bool RenderBlockFlow::willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount) const
 416 {
 417     // The following types are not supposed to create multicol context.
 418     if (isFileUploadControl() || isTextControl() || isListBox())
 419         return false;
 420     if (isRenderSVGBlock() || isRubyRun())
 421         return false;
 422 #if ENABLE(MATHML)
 423     if (isRenderMathMLBlock())
 424         return false;
 425 #endif // ENABLE(MATHML)
 426 
 427     if (!firstChild())
 428         return false;
 429 
 430     if (style().styleType() != PseudoId::None)
 431         return false;
 432 
 433     // If overflow-y is set to paged-x or paged-y on the body or html element, we&#39;ll handle the paginating in the RenderView instead.
 434     if ((style().overflowY() == Overflow::PagedX || style().overflowY() == Overflow::PagedY) &amp;&amp; !(isDocumentElementRenderer() || isBody()))
 435         return true;
 436 
 437     if (!style().specifiesColumns())
 438         return false;
 439 
 440     // column-axis with opposite writing direction initiates MultiColumnFlow.
 441     if (!style().hasInlineColumnAxis())
 442         return true;
 443 
 444     // Non-auto column-width always initiates MultiColumnFlow.
 445     if (!style().hasAutoColumnWidth())
 446         return true;
 447 
 448     if (desiredColumnCount)
 449         return desiredColumnCount.value() &gt; 1;
 450 
 451     // column-count &gt; 1 always initiates MultiColumnFlow.
 452     if (!style().hasAutoColumnCount())
 453         return style().columnCount() &gt; 1;
 454 
 455     ASSERT_NOT_REACHED();
 456     return false;
 457 }
 458 
 459 void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)
 460 {
 461     ASSERT(needsLayout());
 462 
 463     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 464         return;
 465 
 466     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 467 
 468     if (recomputeLogicalWidthAndColumnWidth())
 469         relayoutChildren = true;
 470 
 471     rebuildFloatingObjectSetFromIntrudingFloats();
 472 
 473     LayoutUnit previousHeight = logicalHeight();
 474     // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
 475     // for consistency with other render classes?
 476     resetLogicalHeightBeforeLayoutIfNeeded();
 477 
 478     bool pageLogicalHeightChanged = false;
 479     checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);
 480 
 481     LayoutUnit repaintLogicalTop;
 482     LayoutUnit repaintLogicalBottom;
 483     LayoutUnit maxFloatLogicalBottom;
 484     const RenderStyle&amp; styleToUse = style();
 485     {
 486         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);
 487 
 488         preparePaginationBeforeBlockLayout(relayoutChildren);
 489 
 490         // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track
 491         // our current maximal positive and negative margins. These values are used when we
 492         // are collapsed with adjacent blocks, so for example, if you have block A and B
 493         // collapsing together, then you&#39;d take the maximal positive margin from both A and B
 494         // and subtract it from the maximal negative margin from both A and B to get the
 495         // true collapsed margin. This algorithm is recursive, so when we finish layout()
 496         // our block knows its current maximal positive/negative values.
 497         //
 498         // Start out by setting our margin values to our current margins. Table cells have
 499         // no margins, so we don&#39;t fill in the values for table cells.
 500         bool isCell = isTableCell();
 501         if (!isCell) {
 502             initMaxMarginValues();
 503 
 504             setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());
 505             setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());
 506             setPaginationStrut(0);
 507         }
 508         if (!firstChild() &amp;&amp; !isAnonymousBlock())
 509             setChildrenInline(true);
 510         if (childrenInline())
 511             layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 512         else
 513             layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);
 514     }
 515 
 516     // Expand our intrinsic height to encompass floats.
 517     LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight();
 518     if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())
 519         setLogicalHeight(lowestFloatLogicalBottom() + toAdd);
 520     if (relayoutForPagination() || relayoutToAvoidWidows()) {
 521         ASSERT(!shouldBreakAtLineToAvoidWidow());
 522         return;
 523     }
 524 
 525     // Calculate our new height.
 526     LayoutUnit oldHeight = logicalHeight();
 527     LayoutUnit oldClientAfterEdge = clientLogicalBottom();
 528 
 529     // Before updating the final size of the flow thread make sure a forced break is applied after the content.
 530     // This ensures the size information is correctly computed for the last auto-height fragment receiving content.
 531     if (is&lt;RenderFragmentedFlow&gt;(*this))
 532         downcast&lt;RenderFragmentedFlow&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);
 533 
 534     updateLogicalHeight();
 535     LayoutUnit newHeight = logicalHeight();
 536     {
 537         // FIXME: This could be removed once relayoutForPagination()/relayoutToAvoidWidows() either stop recursing or we manage to
 538         // re-order them.
 539         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);
 540 
 541         if (oldHeight != newHeight) {
 542             if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) {
 543                 // One of our children&#39;s floats may have become an overhanging float for us. We need to look for it.
 544                 for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
 545                     if (blockFlow.isFloatingOrOutOfFlowPositioned())
 546                         continue;
 547                     if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)
 548                         addOverhangingFloats(blockFlow, false);
 549                 }
 550             }
 551         }
 552 
 553         bool heightChanged = (previousHeight != newHeight);
 554         if (heightChanged)
 555             relayoutChildren = true;
 556         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 557     }
 558     // Add overflow from children (unless we&#39;re multi-column, since in that case all our child overflow is clipped anyway).
 559     computeOverflow(oldClientAfterEdge);
 560 
 561     fitBorderToLinesIfNeeded();
 562 
 563     auto* state = view().frameView().layoutContext().layoutState();
 564     if (state &amp;&amp; state-&gt;pageLogicalHeight())
 565         setPageLogicalOffset(state-&gt;pageLogicalOffset(this, logicalTop()));
 566 
 567     updateLayerTransform();
 568 
 569     // Update our scroll information if we&#39;re overflow:auto/scroll/hidden now that we know if
 570     // we overflow or not.
 571     updateScrollInfoAfterLayout();
 572 
 573     // FIXME: This repaint logic should be moved into a separate helper function!
 574     // Repaint with our new bounds if they are different from our old bounds.
 575     bool didFullRepaint = repainter.repaintAfterLayout();
 576     if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == Visibility::Visible || enclosingLayer()-&gt;hasVisibleContent())) {
 577         // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines
 578         // it had to lay out. We wouldn&#39;t need the hasOverflowClip() hack in that case either.
 579         LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow();
 580         LayoutUnit repaintLogicalRight = logicalRightVisualOverflow();
 581         if (hasOverflowClip()) {
 582             // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn&#39;t propagate to our block&#39;s overflow.
 583             // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.
 584             // layoutInlineChildren should be patched to compute the entire repaint rect.
 585             repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());
 586             repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow());
 587         }
 588 
 589         LayoutRect repaintRect;
 590         if (isHorizontalWritingMode())
 591             repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);
 592         else
 593             repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);
 594 
 595         if (hasOverflowClip()) {
 596             // Adjust repaint rect for scroll offset
 597             repaintRect.moveBy(-scrollPosition());
 598 
 599             // Don&#39;t allow this rect to spill out of our overflow box.
 600             repaintRect.intersect(LayoutRect(LayoutPoint(), size()));
 601         }
 602 
 603         // Make sure the rect is still non-empty after intersecting for overflow above
 604         if (!repaintRect.isEmpty()) {
 605             repaintRectangle(repaintRect); // We need to do a partial repaint of our content.
 606             if (hasReflection())
 607                 repaintRectangle(reflectedRect(repaintRect));
 608         }
 609     }
 610 
 611     clearNeedsLayout();
 612 }
 613 
 614 void RenderBlockFlow::layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom)
 615 {
 616     dirtyForLayoutFromPercentageHeightDescendants();
 617 
 618     LayoutUnit beforeEdge = borderAndPaddingBefore();
 619     LayoutUnit afterEdge = borderAndPaddingAfter() + scrollbarLogicalHeight();
 620 
 621     setLogicalHeight(beforeEdge);
 622 
 623     // Lay out our hypothetical grid line as though it occurs at the top of the block.
 624     if (view().frameView().layoutContext().layoutState()-&gt;lineGrid() == this)
 625         layoutLineGridBox();
 626 
 627     // The margin struct caches all our current margin collapsing state.
 628     MarginInfo marginInfo(*this, beforeEdge, afterEdge);
 629 
 630     // Fieldsets need to find their legend and position it inside the border of the object.
 631     // The legend then gets skipped during normal layout. The same is true for ruby text.
 632     // It doesn&#39;t get included in the normal layout process but is instead skipped.
 633     layoutExcludedChildren(relayoutChildren);
 634 
 635     LayoutUnit previousFloatLogicalBottom;
 636     maxFloatLogicalBottom = 0;
 637 
 638     RenderBox* next = firstChildBox();
 639 
 640     while (next) {
 641         RenderBox&amp; child = *next;
 642         next = child.nextSiblingBox();
 643 
 644         if (child.isExcludedFromNormalLayout())
 645             continue; // Skip this child, since it will be positioned by the specialized subclass (fieldsets and ruby runs).
 646 
 647         updateBlockChildDirtyBitsBeforeLayout(relayoutChildren, child);
 648 
 649         if (child.isOutOfFlowPositioned()) {
 650             child.containingBlock()-&gt;insertPositionedObject(child);
 651             adjustPositionedBlock(child, marginInfo);
 652             continue;
 653         }
 654         if (child.isFloating()) {
 655             insertFloatingObject(child);
 656             adjustFloatingBlock(marginInfo);
 657             continue;
 658         }
 659 
 660         // Lay out the child.
 661         layoutBlockChild(child, marginInfo, previousFloatLogicalBottom, maxFloatLogicalBottom);
 662     }
 663 
 664     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
 665     // determining the correct collapsed bottom margin information.
 666     handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
 667 }
 668 
 669 void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
 670 {
 671     auto computeLineLayoutPath = [&amp;] {
 672         bool canUseSimpleLines = SimpleLineLayout::canUseFor(*this);
 673 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 674         if (LayoutIntegration::LineLayout::canUseFor(*this, canUseSimpleLines))
 675             return LayoutFormattingContextPath;
 676 #endif
 677         if (canUseSimpleLines)
 678             return SimpleLinesPath;
 679 
 680         return LineBoxesPath;
 681     };
 682 
 683     if (lineLayoutPath() == UndeterminedPath)
 684         setLineLayoutPath(computeLineLayoutPath());
 685 
 686     if (lineLayoutPath() == SimpleLinesPath) {
 687         layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 688         return;
 689     }
 690 
 691 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 692     if (lineLayoutPath() == LayoutFormattingContextPath) {
 693         layoutLFCLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 694         return;
 695     }
 696 #endif
 697 
 698     if (!complexLineLayout())
 699         m_lineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);
 700 
 701     complexLineLayout()-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 702 }
 703 
 704 void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
 705 {
 706     LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
 707     LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();
 708 
 709     // The child is a normal flow object. Compute the margins we will use for collapsing now.
 710     child.computeAndSetBlockDirectionMargins(*this);
 711 
 712     // Try to guess our correct logical top position. In most cases this guess will
 713     // be correct. Only if we&#39;re wrong (when we compute the real logical top position)
 714     // will we have to potentially relayout.
 715     LayoutUnit estimateWithoutPagination;
 716     LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);
 717 
 718     // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
 719     LayoutRect oldRect = child.frameRect();
 720     LayoutUnit oldLogicalTop = logicalTopForChild(child);
 721 
 722 #if ASSERT_ENABLED
 723     LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
 724 #endif
 725     // Position the child as though it didn&#39;t collapse with the top.
 726     setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
 727     estimateFragmentRangeForBoxChild(child);
 728 
 729     RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 730     bool markDescendantsWithFloats = false;
 731     if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
 732         markDescendantsWithFloats = true;
 733     else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))
 734         // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for
 735         // very large elements. If it does the comparison with oldLogicalTop might yield a
 736         // false negative as adding and removing margins, borders etc from a saturated number
 737         // might yield incorrect results. If this is the case always mark for layout.
 738         markDescendantsWithFloats = true;
 739     else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) {
 740         // If an element might be affected by the presence of floats, then always mark it for
 741         // layout.
 742         LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());
 743         if (fb &gt; logicalTopEstimate)
 744             markDescendantsWithFloats = true;
 745     }
 746 
 747     if (childBlockFlow) {
 748         if (markDescendantsWithFloats)
 749             childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();
 750         if (!child.isWritingModeRoot())
 751             previousFloatLogicalBottom = std::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());
 752     }
 753 
 754     child.markForPaginationRelayoutIfNeeded();
 755 
 756     bool childHadLayout = child.everHadLayout();
 757     bool childNeededLayout = child.needsLayout();
 758     if (childNeededLayout)
 759         child.layout();
 760 
 761     // Cache if we are at the top of the block right now.
 762     bool atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock();
 763 
 764     // Now determine the correct ypos based off examination of collapsing margin
 765     // values.
 766     LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo);
 767 
 768     // Now check for clear.
 769     LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);
 770 
 771     bool paginated = view().frameView().layoutContext().layoutState()-&gt;isPaginated();
 772     if (paginated)
 773         logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear);
 774 
 775     setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);
 776 
 777     // Now we have a final top position. See if it really does end up being different from our estimate.
 778     // clearFloatsIfNeeded can also mark the child as needing a layout even though we didn&#39;t move. This happens
 779     // when collapseMargins dynamically adds overhanging floats because of a child with negative margins.
 780     if (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) {
 781         if (child.shrinkToAvoidFloats()) {
 782             // The child&#39;s width depends on the line width. When the child shifts to clear an item, its width can
 783             // change (because it has more available line width). So mark the item as dirty.
 784             child.setChildNeedsLayout(MarkOnlyThis);
 785         }
 786 
 787         if (childBlockFlow) {
 788             if (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())
 789                 childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();
 790             child.markForPaginationRelayoutIfNeeded();
 791         }
 792     }
 793 
 794     if (updateFragmentRangeForBoxChild(child))
 795         child.setNeedsLayout(MarkOnlyThis);
 796 
 797     // In case our guess was wrong, relayout the child.
 798     child.layoutIfNeeded();
 799 
 800     // We are no longer at the top of the block if we encounter a non-empty child.
 801     // This has to be done after checking for clear, so that margins can be reset if a clear occurred.
 802     if (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())
 803         marginInfo.setAtBeforeSideOfBlock(false);
 804 
 805     // Now place the child in the correct left position
 806     determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);
 807 
 808     // Update our height now that the child has been placed in the correct position.
 809     setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));
 810     if (mustSeparateMarginAfterForChild(child)) {
 811         setLogicalHeight(logicalHeight() + marginAfterForChild(child));
 812         marginInfo.clearMargin();
 813     }
 814     // If the child has overhanging floats that intrude into following siblings (or possibly out
 815     // of this block), then the parent gets notified of the floats now.
 816     if (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
 817         maxFloatLogicalBottom = std::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));
 818 
 819     LayoutSize childOffset = child.location() - oldRect.location();
 820     if (childOffset.width() || childOffset.height()) {
 821         view().frameView().layoutContext().addLayoutDelta(childOffset);
 822 
 823         // If the child moved, we have to repaint it as well as any floating/positioned
 824         // descendants. An exception is if we need a layout. In this case, we know we&#39;re going to
 825         // repaint ourselves (and the child) anyway.
 826         if (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())
 827             child.repaintDuringLayoutIfMoved(oldRect);
 828     }
 829 
 830     if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) {
 831         child.repaint();
 832         child.repaintOverhangingFloats(true);
 833     }
 834 
 835     if (paginated) {
 836         if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
 837             fragmentedFlow-&gt;fragmentedFlowDescendantBoxLaidOut(&amp;child);
 838         // Check for an after page/column break.
 839         LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo);
 840         if (newHeight != height())
 841             setLogicalHeight(newHeight);
 842     }
 843 
 844     ASSERT(view().frameView().layoutContext().layoutDeltaMatches(oldLayoutDelta));
 845 }
 846 
 847 void RenderBlockFlow::adjustPositionedBlock(RenderBox&amp; child, const MarginInfo&amp; marginInfo)
 848 {
 849     bool isHorizontal = isHorizontalWritingMode();
 850     bool hasStaticBlockPosition = child.style().hasStaticBlockPosition(isHorizontal);
 851 
 852     LayoutUnit logicalTop = logicalHeight();
 853     updateStaticInlinePositionForChild(child, logicalTop, DoNotIndentText);
 854 
 855     if (!marginInfo.canCollapseWithMarginBefore()) {
 856         // Positioned blocks don&#39;t collapse margins, so add the margin provided by
 857         // the container now. The child&#39;s own margin is added later when calculating its logical top.
 858         LayoutUnit collapsedBeforePos = marginInfo.positiveMargin();
 859         LayoutUnit collapsedBeforeNeg = marginInfo.negativeMargin();
 860         logicalTop += collapsedBeforePos - collapsedBeforeNeg;
 861     }
 862 
 863     RenderLayer* childLayer = child.layer();
 864     if (childLayer-&gt;staticBlockPosition() != logicalTop) {
 865         childLayer-&gt;setStaticBlockPosition(logicalTop);
 866         if (hasStaticBlockPosition)
 867             child.setChildNeedsLayout(MarkOnlyThis);
 868     }
 869 }
 870 
 871 LayoutUnit RenderBlockFlow::marginOffsetForSelfCollapsingBlock()
 872 {
 873     ASSERT(isSelfCollapsingBlock());
 874     RenderBlockFlow* parentBlock = downcast&lt;RenderBlockFlow&gt;(parent());
 875     if (parentBlock &amp;&amp; style().clear() != Clear::None &amp;&amp; parentBlock-&gt;getClearDelta(*this, logicalHeight()))
 876         return marginValuesForChild(*this).positiveMarginBefore();
 877     return 0_lu;
 878 }
 879 
 880 void RenderBlockFlow::determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode applyDelta)
 881 {
 882     LayoutUnit startPosition = borderStart() + paddingStart();
 883     if (shouldPlaceBlockDirectionScrollbarOnLeft())
 884         startPosition += (style().isLeftToRightDirection() ? 1 : -1) * verticalScrollbarWidth();
 885     LayoutUnit totalAvailableLogicalWidth = borderAndPaddingLogicalWidth() + availableLogicalWidth();
 886 
 887     // Add in our start margin.
 888     LayoutUnit childMarginStart = marginStartForChild(child);
 889     LayoutUnit newPosition = startPosition + childMarginStart;
 890 
 891     // Some objects (e.g., tables, horizontal rules, overflow:auto blocks) avoid floats. They need
 892     // to shift over as necessary to dodge any floats that might get in the way.
 893     if (child.avoidsFloats() &amp;&amp; containsFloats())
 894         newPosition += computeStartPositionDeltaForChildAvoidingFloats(child, marginStartForChild(child));
 895 
 896     setLogicalLeftForChild(child, style().isLeftToRightDirection() ? newPosition : totalAvailableLogicalWidth - newPosition - logicalWidthForChild(child), applyDelta);
 897 }
 898 
 899 void RenderBlockFlow::adjustFloatingBlock(const MarginInfo&amp; marginInfo)
 900 {
 901     // The float should be positioned taking into account the bottom margin
 902     // of the previous flow. We add that margin into the height, get the
 903     // float positioned properly, and then subtract the margin out of the
 904     // height again. In the case of self-collapsing blocks, we always just
 905     // use the top margins, since the self-collapsing block collapsed its
 906     // own bottom margin into its top margin.
 907     //
 908     // Note also that the previous flow may collapse its margin into the top of
 909     // our block. If this is the case, then we do not add the margin in to our
 910     // height when computing the position of the float. This condition can be tested
 911     // for by simply calling canCollapseWithMarginBefore. See
 912     // http://www.hixie.ch/tests/adhoc/css/box/block/margin-collapse/046.html for
 913     // an example of this scenario.
 914     LayoutUnit marginOffset = marginInfo.canCollapseWithMarginBefore() ? 0_lu : marginInfo.margin();
 915     setLogicalHeight(logicalHeight() + marginOffset);
 916     positionNewFloats();
 917     setLogicalHeight(logicalHeight() - marginOffset);
 918 }
 919 
 920 void RenderBlockFlow::updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText)
 921 {
 922     if (child.style().isOriginalDisplayInlineType())
 923         setStaticInlinePositionForChild(child, logicalTop, startAlignedOffsetForLine(logicalTop, shouldIndentText));
 924     else
 925         setStaticInlinePositionForChild(child, logicalTop, startOffsetForContent(logicalTop));
 926 }
 927 
 928 void RenderBlockFlow::setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition)
 929 {
 930     if (enclosingFragmentedFlow()) {
 931         // Shift the inline position to exclude the fragment offset.
 932         inlinePosition += startOffsetForContent() - startOffsetForContent(blockOffset);
 933     }
 934     child.layer()-&gt;setStaticInlinePosition(inlinePosition);
 935 }
 936 
 937 LayoutUnit RenderBlockFlow::startAlignedOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText)
 938 {
 939     TextAlignMode textAlign = style().textAlign();
 940     bool shouldApplyIndentText = false;
 941     switch (textAlign) {
 942     case TextAlignMode::Left:
 943     case TextAlignMode::WebKitLeft:
 944         shouldApplyIndentText = style().isLeftToRightDirection();
 945         break;
 946     case TextAlignMode::Right:
 947     case TextAlignMode::WebKitRight:
 948         shouldApplyIndentText = !style().isLeftToRightDirection();
 949         break;
 950     case TextAlignMode::Start:
 951         shouldApplyIndentText = true;
 952         break;
 953     default:
 954         shouldApplyIndentText = false;
 955     }
 956     // &lt;rdar://problem/15427571&gt;
 957     // https://bugs.webkit.org/show_bug.cgi?id=124522
 958     // This quirk is for legacy content that doesn&#39;t work properly with the center positioning scheme
 959     // being honored (e.g., epubs).
 960     if (shouldApplyIndentText || settings().useLegacyTextAlignPositionedElementBehavior()) // FIXME: Handle TextAlignMode::End here
 961         return startOffsetForLine(position, shouldIndentText);
 962 
 963     // updateLogicalWidthForAlignment() handles the direction of the block so no need to consider it here
 964     float totalLogicalWidth = 0;
 965     float logicalLeft = logicalLeftOffsetForLine(logicalHeight(), DoNotIndentText);
 966     float availableLogicalWidth = logicalRightOffsetForLine(logicalHeight(), DoNotIndentText) - logicalLeft;
 967 
 968     ComplexLineLayout::updateLogicalWidthForAlignment(*this, textAlign, nullptr, nullptr, logicalLeft, totalLogicalWidth, availableLogicalWidth, 0);
 969 
 970     if (!style().isLeftToRightDirection())
 971         return LayoutUnit(logicalWidth() - logicalLeft);
 972 
 973     return LayoutUnit(logicalLeft);
 974 }
 975 
 976 RenderBlockFlow::MarginValues RenderBlockFlow::marginValuesForChild(RenderBox&amp; child) const
 977 {
 978     LayoutUnit childBeforePositive;
 979     LayoutUnit childBeforeNegative;
 980     LayoutUnit childAfterPositive;
 981     LayoutUnit childAfterNegative;
 982 
 983     LayoutUnit beforeMargin;
 984     LayoutUnit afterMargin;
 985 
 986     RenderBlockFlow* childRenderBlock = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 987 
 988     // If the child has the same directionality as we do, then we can just return its
 989     // margins in the same direction.
 990     if (!child.isWritingModeRoot()) {
 991         if (childRenderBlock) {
 992             childBeforePositive = childRenderBlock-&gt;maxPositiveMarginBefore();
 993             childBeforeNegative = childRenderBlock-&gt;maxNegativeMarginBefore();
 994             childAfterPositive = childRenderBlock-&gt;maxPositiveMarginAfter();
 995             childAfterNegative = childRenderBlock-&gt;maxNegativeMarginAfter();
 996         } else {
 997             beforeMargin = child.marginBefore();
 998             afterMargin = child.marginAfter();
 999         }
1000     } else if (child.isHorizontalWritingMode() == isHorizontalWritingMode()) {
1001         // The child has a different directionality. If the child is parallel, then it&#39;s just
1002         // flipped relative to us. We can use the margins for the opposite edges.
1003         if (childRenderBlock) {
1004             childBeforePositive = childRenderBlock-&gt;maxPositiveMarginAfter();
1005             childBeforeNegative = childRenderBlock-&gt;maxNegativeMarginAfter();
1006             childAfterPositive = childRenderBlock-&gt;maxPositiveMarginBefore();
1007             childAfterNegative = childRenderBlock-&gt;maxNegativeMarginBefore();
1008         } else {
1009             beforeMargin = child.marginAfter();
1010             afterMargin = child.marginBefore();
1011         }
1012     } else {
1013         // The child is perpendicular to us, which means its margins don&#39;t collapse but are on the
1014         // &quot;logical left/right&quot; sides of the child box. We can just return the raw margin in this case.
1015         beforeMargin = marginBeforeForChild(child);
1016         afterMargin = marginAfterForChild(child);
1017     }
1018 
1019     // Resolve uncollapsing margins into their positive/negative buckets.
1020     if (beforeMargin) {
1021         if (beforeMargin &gt; 0)
1022             childBeforePositive = beforeMargin;
1023         else
1024             childBeforeNegative = -beforeMargin;
1025     }
1026     if (afterMargin) {
1027         if (afterMargin &gt; 0)
1028             childAfterPositive = afterMargin;
1029         else
1030             childAfterNegative = -afterMargin;
1031     }
1032 
1033     return MarginValues(childBeforePositive, childBeforeNegative, childAfterPositive, childAfterNegative);
1034 }
1035 
1036 bool RenderBlockFlow::childrenPreventSelfCollapsing() const
1037 {
1038     if (!childrenInline())
1039         return RenderBlock::childrenPreventSelfCollapsing();
1040 
1041     return hasLines();
1042 }
1043 
1044 LayoutUnit RenderBlockFlow::collapseMargins(RenderBox&amp; child, MarginInfo&amp; marginInfo)
1045 {
1046     return collapseMarginsWithChildInfo(&amp;child, child.previousSibling(), marginInfo);
1047 }
1048 
1049 LayoutUnit RenderBlockFlow::collapseMarginsWithChildInfo(RenderBox* child, RenderObject* prevSibling, MarginInfo&amp; marginInfo)
1050 {
1051     bool childDiscardMarginBefore = child ? mustDiscardMarginBeforeForChild(*child) : false;
1052     bool childDiscardMarginAfter = child ? mustDiscardMarginAfterForChild(*child) : false;
1053     bool childIsSelfCollapsing = child ? child-&gt;isSelfCollapsingBlock() : false;
1054     bool beforeQuirk = child ? hasMarginBeforeQuirk(*child) : false;
1055     bool afterQuirk = child ? hasMarginAfterQuirk(*child) : false;
1056 
1057     // The child discards the before margin when the after margin has discarded in the case of a self collapsing block.
1058     childDiscardMarginBefore = childDiscardMarginBefore || (childDiscardMarginAfter &amp;&amp; childIsSelfCollapsing);
1059 
1060     // Get the four margin values for the child and cache them.
1061     const MarginValues childMargins = child ? marginValuesForChild(*child) : MarginValues(0, 0, 0, 0);
1062 
1063     // Get our max pos and neg top margins.
1064     LayoutUnit posTop = childMargins.positiveMarginBefore();
1065     LayoutUnit negTop = childMargins.negativeMarginBefore();
1066 
1067     // For self-collapsing blocks, collapse our bottom margins into our
1068     // top to get new posTop and negTop values.
1069     if (childIsSelfCollapsing) {
1070         posTop = std::max(posTop, childMargins.positiveMarginAfter());
1071         negTop = std::max(negTop, childMargins.negativeMarginAfter());
1072     }
1073 
1074     if (marginInfo.canCollapseWithMarginBefore()) {
1075         if (!childDiscardMarginBefore &amp;&amp; !marginInfo.discardMargin()) {
1076             // This child is collapsing with the top of the
1077             // block. If it has larger margin values, then we need to update
1078             // our own maximal values.
1079             if (!document().inQuirksMode() || !marginInfo.quirkContainer() || !beforeQuirk)
1080                 setMaxMarginBeforeValues(std::max(posTop, maxPositiveMarginBefore()), std::max(negTop, maxNegativeMarginBefore()));
1081 
1082             // The minute any of the margins involved isn&#39;t a quirk, don&#39;t
1083             // collapse it away, even if the margin is smaller (www.webreference.com
1084             // has an example of this, a &lt;dt&gt; with 0.8em author-specified inside
1085             // a &lt;dl&gt; inside a &lt;td&gt;.
1086             if (!marginInfo.determinedMarginBeforeQuirk() &amp;&amp; !beforeQuirk &amp;&amp; (posTop - negTop)) {
1087                 setHasMarginBeforeQuirk(false);
1088                 marginInfo.setDeterminedMarginBeforeQuirk(true);
1089             }
1090 
1091             if (!marginInfo.determinedMarginBeforeQuirk() &amp;&amp; beforeQuirk &amp;&amp; !marginBefore()) {
1092                 // We have no top margin and our top child has a quirky margin.
1093                 // We will pick up this quirky margin and pass it through.
1094                 // This deals with the &lt;td&gt;&lt;div&gt;&lt;p&gt; case.
1095                 // Don&#39;t do this for a block that split two inlines though. You do
1096                 // still apply margins in this case.
1097                 setHasMarginBeforeQuirk(true);
1098             }
1099         } else
1100             // The before margin of the container will also discard all the margins it is collapsing with.
1101             setMustDiscardMarginBefore();
1102     }
1103 
1104     // Once we find a child with discardMarginBefore all the margins collapsing with us must also discard.
1105     if (childDiscardMarginBefore) {
1106         marginInfo.setDiscardMargin(true);
1107         marginInfo.clearMargin();
1108     }
1109 
1110     if (marginInfo.quirkContainer() &amp;&amp; marginInfo.atBeforeSideOfBlock() &amp;&amp; (posTop - negTop))
1111         marginInfo.setHasMarginBeforeQuirk(beforeQuirk);
1112 
1113     LayoutUnit beforeCollapseLogicalTop = logicalHeight();
1114     LayoutUnit logicalTop = beforeCollapseLogicalTop;
1115 
1116     LayoutUnit clearanceForSelfCollapsingBlock;
1117 
1118     // If the child&#39;s previous sibling is a self-collapsing block that cleared a float then its top border edge has been set at the bottom border edge
1119     // of the float. Since we want to collapse the child&#39;s top margin with the self-collapsing block&#39;s top and bottom margins we need to adjust our parent&#39;s height to match the
1120     // margin top of the self-collapsing block. If the resulting collapsed margin leaves the child still intruding into the float then we will want to clear it.
1121     if (!marginInfo.canCollapseWithMarginBefore() &amp;&amp; is&lt;RenderBlockFlow&gt;(prevSibling) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*prevSibling).isSelfCollapsingBlock()) {
1122         clearanceForSelfCollapsingBlock = downcast&lt;RenderBlockFlow&gt;(*prevSibling).marginOffsetForSelfCollapsingBlock();
1123         setLogicalHeight(logicalHeight() - clearanceForSelfCollapsingBlock);
1124     }
1125 
1126     if (childIsSelfCollapsing) {
1127         // For a self collapsing block both the before and after margins get discarded. The block doesn&#39;t contribute anything to the height of the block.
1128         // Also, the child&#39;s top position equals the logical height of the container.
1129         if (!childDiscardMarginBefore &amp;&amp; !marginInfo.discardMargin()) {
1130             // This child has no height. We need to compute our
1131             // position before we collapse the child&#39;s margins together,
1132             // so that we can get an accurate position for the zero-height block.
1133             LayoutUnit collapsedBeforePos = std::max(marginInfo.positiveMargin(), childMargins.positiveMarginBefore());
1134             LayoutUnit collapsedBeforeNeg = std::max(marginInfo.negativeMargin(), childMargins.negativeMarginBefore());
1135             marginInfo.setMargin(collapsedBeforePos, collapsedBeforeNeg);
1136 
1137             // Now collapse the child&#39;s margins together, which means examining our
1138             // bottom margin values as well.
1139             marginInfo.setPositiveMarginIfLarger(childMargins.positiveMarginAfter());
1140             marginInfo.setNegativeMarginIfLarger(childMargins.negativeMarginAfter());
1141 
1142             if (!marginInfo.canCollapseWithMarginBefore())
1143                 // We need to make sure that the position of the self-collapsing block
1144                 // is correct, since it could have overflowing content
1145                 // that needs to be positioned correctly (e.g., a block that
1146                 // had a specified height of 0 but that actually had subcontent).
1147                 logicalTop = logicalHeight() + collapsedBeforePos - collapsedBeforeNeg;
1148         }
1149     } else {
1150         if (child &amp;&amp; mustSeparateMarginBeforeForChild(*child)) {
1151             ASSERT(!marginInfo.discardMargin() || (marginInfo.discardMargin() &amp;&amp; !marginInfo.margin()));
1152             // If we are at the before side of the block and we collapse, ignore the computed margin
1153             // and just add the child margin to the container height. This will correctly position
1154             // the child inside the container.
1155             LayoutUnit separateMargin = !marginInfo.canCollapseWithMarginBefore() ? marginInfo.margin() : 0_lu;
1156             setLogicalHeight(logicalHeight() + separateMargin + marginBeforeForChild(*child));
1157             logicalTop = logicalHeight();
1158         } else if (!marginInfo.discardMargin() &amp;&amp; (!marginInfo.atBeforeSideOfBlock()
1159             || (!marginInfo.canCollapseMarginBeforeWithChildren()
1160             &amp;&amp; (!document().inQuirksMode() || !marginInfo.quirkContainer() || !marginInfo.hasMarginBeforeQuirk())))) {
1161             // We&#39;re collapsing with a previous sibling&#39;s margins and not
1162             // with the top of the block.
1163             setLogicalHeight(logicalHeight() + std::max(marginInfo.positiveMargin(), posTop) - std::max(marginInfo.negativeMargin(), negTop));
1164             logicalTop = logicalHeight();
1165         }
1166 
1167         marginInfo.setDiscardMargin(childDiscardMarginAfter);
1168 
1169         if (!marginInfo.discardMargin()) {
1170             marginInfo.setPositiveMargin(childMargins.positiveMarginAfter());
1171             marginInfo.setNegativeMargin(childMargins.negativeMarginAfter());
1172         } else
1173             marginInfo.clearMargin();
1174 
1175         if (marginInfo.margin())
1176             marginInfo.setHasMarginAfterQuirk(afterQuirk);
1177     }
1178 
1179     // If margins would pull us past the top of the next page, then we need to pull back and pretend like the margins
1180     // collapsed into the page edge.
1181     auto* layoutState = view().frameView().layoutContext().layoutState();
1182     if (layoutState-&gt;isPaginated() &amp;&amp; layoutState-&gt;pageLogicalHeight() &amp;&amp; logicalTop &gt; beforeCollapseLogicalTop
1183         &amp;&amp; hasNextPage(beforeCollapseLogicalTop)) {
1184         LayoutUnit oldLogicalTop = logicalTop;
1185         logicalTop = std::min(logicalTop, nextPageLogicalTop(beforeCollapseLogicalTop));
1186         setLogicalHeight(logicalHeight() + (logicalTop - oldLogicalTop));
1187     }
1188 
1189     if (is&lt;RenderBlockFlow&gt;(prevSibling) &amp;&amp; !prevSibling-&gt;isFloatingOrOutOfFlowPositioned()) {
1190         // If |child| is a self-collapsing block it may have collapsed into a previous sibling and although it hasn&#39;t reduced the height of the parent yet
1191         // any floats from the parent will now overhang.
1192         RenderBlockFlow&amp; block = downcast&lt;RenderBlockFlow&gt;(*prevSibling);
1193         LayoutUnit oldLogicalHeight = logicalHeight();
1194         setLogicalHeight(logicalTop);
1195         if (block.containsFloats() &amp;&amp; !block.avoidsFloats() &amp;&amp; (block.logicalTop() + block.lowestFloatLogicalBottom()) &gt; logicalTop)
1196             addOverhangingFloats(block, false);
1197         setLogicalHeight(oldLogicalHeight);
1198 
1199         // If |child|&#39;s previous sibling is a self-collapsing block that cleared a float and margin collapsing resulted in |child| moving up
1200         // into the margin area of the self-collapsing block then the float it clears is now intruding into |child|. Layout again so that we can look for
1201         // floats in the parent that overhang |child|&#39;s new logical top.
1202         bool logicalTopIntrudesIntoFloat = clearanceForSelfCollapsingBlock &gt; 0 &amp;&amp; logicalTop &lt; beforeCollapseLogicalTop;
1203         if (child &amp;&amp; logicalTopIntrudesIntoFloat &amp;&amp; containsFloats() &amp;&amp; !child-&gt;avoidsFloats() &amp;&amp; lowestFloatLogicalBottom() &gt; logicalTop)
1204             child-&gt;setNeedsLayout();
1205     }
1206 
1207     return logicalTop;
1208 }
1209 
1210 LayoutUnit RenderBlockFlow::clearFloatsIfNeeded(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit oldTopPosMargin, LayoutUnit oldTopNegMargin, LayoutUnit yPos)
1211 {
1212     LayoutUnit heightIncrease = getClearDelta(child, yPos);
1213     if (!heightIncrease)
1214         return yPos;
1215 
1216     if (child.isSelfCollapsingBlock()) {
1217         bool childDiscardMargin = mustDiscardMarginBeforeForChild(child) || mustDiscardMarginAfterForChild(child);
1218 
1219         // For self-collapsing blocks that clear, they can still collapse their
1220         // margins with following siblings. Reset the current margins to represent
1221         // the self-collapsing block&#39;s margins only.
1222         // If DISCARD is specified for -webkit-margin-collapse, reset the margin values.
1223         MarginValues childMargins = marginValuesForChild(child);
1224         if (!childDiscardMargin) {
1225             marginInfo.setPositiveMargin(std::max(childMargins.positiveMarginBefore(), childMargins.positiveMarginAfter()));
1226             marginInfo.setNegativeMargin(std::max(childMargins.negativeMarginBefore(), childMargins.negativeMarginAfter()));
1227         } else
1228             marginInfo.clearMargin();
1229         marginInfo.setDiscardMargin(childDiscardMargin);
1230 
1231         // CSS2.1 states:
1232         // &quot;If the top and bottom margins of an element with clearance are adjoining, its margins collapse with
1233         // the adjoining margins of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.&quot;
1234         // So the parent&#39;s bottom margin cannot collapse through this block or any subsequent self-collapsing blocks. Check subsequent siblings
1235         // for a block with height - if none is found then don&#39;t allow the margins to collapse with the parent.
1236         bool wouldCollapseMarginsWithParent = marginInfo.canCollapseMarginAfterWithChildren();
1237         for (RenderBox* curr = child.nextSiblingBox(); curr &amp;&amp; wouldCollapseMarginsWithParent; curr = curr-&gt;nextSiblingBox()) {
1238             if (!curr-&gt;isFloatingOrOutOfFlowPositioned() &amp;&amp; !curr-&gt;isSelfCollapsingBlock())
1239                 wouldCollapseMarginsWithParent = false;
1240         }
1241         if (wouldCollapseMarginsWithParent)
1242             marginInfo.setCanCollapseMarginAfterWithChildren(false);
1243 
1244         // For now set the border-top of |child| flush with the bottom border-edge of the float so it can layout any floating or positioned children of
1245         // its own at the correct vertical position. If subsequent siblings attempt to collapse with |child|&#39;s margins in |collapseMargins| we will
1246         // adjust the height of the parent to |child|&#39;s margin top (which if it is positive sits up &#39;inside&#39; the float it&#39;s clearing) so that all three
1247         // margins can collapse at the correct vertical position.
1248         // Per CSS2.1 we need to ensure that any negative margin-top clears |child| beyond the bottom border-edge of the float so that the top border edge of the child
1249         // (i.e. its clearance)  is at a position that satisfies the equation: &quot;the amount of clearance is set so that clearance + margin-top = [height of float],
1250         // i.e., clearance = [height of float] - margin-top&quot;.
1251         setLogicalHeight(child.logicalTop() + childMargins.negativeMarginBefore());
1252     } else
1253         // Increase our height by the amount we had to clear.
1254         setLogicalHeight(logicalHeight() + heightIncrease);
1255 
1256     if (marginInfo.canCollapseWithMarginBefore()) {
1257         // We can no longer collapse with the top of the block since a clear
1258         // occurred. The empty blocks collapse into the cleared block.
1259         // FIXME: This isn&#39;t quite correct. Need clarification for what to do
1260         // if the height the cleared block is offset by is smaller than the
1261         // margins involved.
1262         setMaxMarginBeforeValues(oldTopPosMargin, oldTopNegMargin);
1263         marginInfo.setAtBeforeSideOfBlock(false);
1264 
1265         // In case the child discarded the before margin of the block we need to reset the mustDiscardMarginBefore flag to the initial value.
1266         setMustDiscardMarginBefore(style().marginBeforeCollapse() == MarginCollapse::Discard);
1267     }
1268 
1269     return yPos + heightIncrease;
1270 }
1271 
1272 void RenderBlockFlow::marginBeforeEstimateForChild(RenderBox&amp; child, LayoutUnit&amp; positiveMarginBefore, LayoutUnit&amp; negativeMarginBefore, bool&amp; discardMarginBefore) const
1273 {
1274     // Give up if in quirks mode and we&#39;re a body/table cell and the top margin of the child box is quirky.
1275     // Give up if the child specified -webkit-margin-collapse: separate that prevents collapsing.
1276     // FIXME: Use writing mode independent accessor for marginBeforeCollapse.
1277     if ((document().inQuirksMode() &amp;&amp; hasMarginAfterQuirk(child) &amp;&amp; (isTableCell() || isBody())) || child.style().marginBeforeCollapse() == MarginCollapse::Separate)
1278         return;
1279 
1280     // The margins are discarded by a child that specified -webkit-margin-collapse: discard.
1281     // FIXME: Use writing mode independent accessor for marginBeforeCollapse.
1282     if (child.style().marginBeforeCollapse() == MarginCollapse::Discard) {
1283         positiveMarginBefore = 0;
1284         negativeMarginBefore = 0;
1285         discardMarginBefore = true;
1286         return;
1287     }
1288 
1289     LayoutUnit beforeChildMargin = marginBeforeForChild(child);
1290     positiveMarginBefore = std::max(positiveMarginBefore, beforeChildMargin);
1291     negativeMarginBefore = std::max(negativeMarginBefore, -beforeChildMargin);
1292 
1293     if (!is&lt;RenderBlockFlow&gt;(child))
1294         return;
1295 
1296     RenderBlockFlow&amp; childBlock = downcast&lt;RenderBlockFlow&gt;(child);
1297     if (childBlock.childrenInline() || childBlock.isWritingModeRoot())
1298         return;
1299 
1300     MarginInfo childMarginInfo(childBlock, childBlock.borderAndPaddingBefore(), childBlock.borderAndPaddingAfter());
1301     if (!childMarginInfo.canCollapseMarginBeforeWithChildren())
1302         return;
1303 
1304     RenderBox* grandchildBox = childBlock.firstChildBox();
1305     for (; grandchildBox; grandchildBox = grandchildBox-&gt;nextSiblingBox()) {
1306         if (!grandchildBox-&gt;isFloatingOrOutOfFlowPositioned())
1307             break;
1308     }
1309 
1310     // Give up if there is clearance on the box, since it probably won&#39;t collapse into us.
1311     if (!grandchildBox || grandchildBox-&gt;style().clear() != Clear::None)
1312         return;
1313 
1314     // Make sure to update the block margins now for the grandchild box so that we&#39;re looking at current values.
1315     if (grandchildBox-&gt;needsLayout()) {
1316         grandchildBox-&gt;computeAndSetBlockDirectionMargins(*this);
1317         if (is&lt;RenderBlock&gt;(*grandchildBox)) {
1318             RenderBlock&amp; grandchildBlock = downcast&lt;RenderBlock&gt;(*grandchildBox);
1319             grandchildBlock.setHasMarginBeforeQuirk(grandchildBox-&gt;style().hasMarginBeforeQuirk());
1320             grandchildBlock.setHasMarginAfterQuirk(grandchildBox-&gt;style().hasMarginAfterQuirk());
1321         }
1322     }
1323 
1324     // Collapse the margin of the grandchild box with our own to produce an estimate.
1325     childBlock.marginBeforeEstimateForChild(*grandchildBox, positiveMarginBefore, negativeMarginBefore, discardMarginBefore);
1326 }
1327 
1328 LayoutUnit RenderBlockFlow::estimateLogicalTopPosition(RenderBox&amp; child, const MarginInfo&amp; marginInfo, LayoutUnit&amp; estimateWithoutPagination)
1329 {
1330     // FIXME: We need to eliminate the estimation of vertical position, because when it&#39;s wrong we sometimes trigger a pathological
1331     // relayout if there are intruding floats.
1332     LayoutUnit logicalTopEstimate = logicalHeight();
1333     if (!marginInfo.canCollapseWithMarginBefore()) {
1334         LayoutUnit positiveMarginBefore;
1335         LayoutUnit negativeMarginBefore;
1336         bool discardMarginBefore = false;
1337         if (child.selfNeedsLayout()) {
1338             // Try to do a basic estimation of how the collapse is going to go.
1339             marginBeforeEstimateForChild(child, positiveMarginBefore, negativeMarginBefore, discardMarginBefore);
1340         } else {
1341             // Use the cached collapsed margin values from a previous layout. Most of the time they
1342             // will be right.
1343             MarginValues marginValues = marginValuesForChild(child);
1344             positiveMarginBefore = std::max(positiveMarginBefore, marginValues.positiveMarginBefore());
1345             negativeMarginBefore = std::max(negativeMarginBefore, marginValues.negativeMarginBefore());
1346             discardMarginBefore = mustDiscardMarginBeforeForChild(child);
1347         }
1348 
1349         // Collapse the result with our current margins.
1350         if (!discardMarginBefore)
1351             logicalTopEstimate += std::max(marginInfo.positiveMargin(), positiveMarginBefore) - std::max(marginInfo.negativeMargin(), negativeMarginBefore);
1352     }
1353 
1354     // Adjust logicalTopEstimate down to the next page if the margins are so large that we don&#39;t fit on the current
1355     // page.
1356     auto* layoutState = view().frameView().layoutContext().layoutState();
1357     if (layoutState-&gt;isPaginated() &amp;&amp; layoutState-&gt;pageLogicalHeight() &amp;&amp; logicalTopEstimate &gt; logicalHeight()
1358         &amp;&amp; hasNextPage(logicalHeight()))
1359         logicalTopEstimate = std::min(logicalTopEstimate, nextPageLogicalTop(logicalHeight()));
1360 
1361     logicalTopEstimate += getClearDelta(child, logicalTopEstimate);
1362 
1363     estimateWithoutPagination = logicalTopEstimate;
1364 
1365     if (layoutState-&gt;isPaginated()) {
1366         // If the object has a page or column break value of &quot;before&quot;, then we should shift to the top of the next page.
1367         logicalTopEstimate = applyBeforeBreak(child, logicalTopEstimate);
1368 
1369         // For replaced elements and scrolled elements, we want to shift them to the next page if they don&#39;t fit on the current one.
1370         logicalTopEstimate = adjustForUnsplittableChild(child, logicalTopEstimate);
1371 
1372         if (!child.selfNeedsLayout() &amp;&amp; is&lt;RenderBlock&gt;(child))
1373             logicalTopEstimate += downcast&lt;RenderBlock&gt;(child).paginationStrut();
1374     }
1375 
1376     return logicalTopEstimate;
1377 }
1378 
1379 void RenderBlockFlow::setCollapsedBottomMargin(const MarginInfo&amp; marginInfo)
1380 {
1381     if (marginInfo.canCollapseWithMarginAfter() &amp;&amp; !marginInfo.canCollapseWithMarginBefore()) {
1382         // Update the after side margin of the container to discard if the after margin of the last child also discards and we collapse with it.
1383         // Don&#39;t update the max margin values because we won&#39;t need them anyway.
1384         if (marginInfo.discardMargin()) {
1385             setMustDiscardMarginAfter();
1386             return;
1387         }
1388 
1389         // Update our max pos/neg bottom margins, since we collapsed our bottom margins
1390         // with our children.
1391         setMaxMarginAfterValues(std::max(maxPositiveMarginAfter(), marginInfo.positiveMargin()), std::max(maxNegativeMarginAfter(), marginInfo.negativeMargin()));
1392 
1393         if (!marginInfo.hasMarginAfterQuirk())
1394             setHasMarginAfterQuirk(false);
1395 
1396         if (marginInfo.hasMarginAfterQuirk() &amp;&amp; !marginAfter())
1397             // We have no bottom margin and our last child has a quirky margin.
1398             // We will pick up this quirky margin and pass it through.
1399             // This deals with the &lt;td&gt;&lt;div&gt;&lt;p&gt; case.
1400             setHasMarginAfterQuirk(true);
1401     }
1402 }
1403 
1404 void RenderBlockFlow::handleAfterSideOfBlock(LayoutUnit beforeSide, LayoutUnit afterSide, MarginInfo&amp; marginInfo)
1405 {
1406     marginInfo.setAtAfterSideOfBlock(true);
1407 
1408     // If our last child was a self-collapsing block with clearance then our logical height is flush with the
1409     // bottom edge of the float that the child clears. The correct vertical position for the margin-collapsing we want
1410     // to perform now is at the child&#39;s margin-top - so adjust our height to that position.
1411     RenderObject* lastBlock = lastChild();
1412     if (is&lt;RenderBlockFlow&gt;(lastBlock) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(*lastBlock).isSelfCollapsingBlock())
1413         setLogicalHeight(logicalHeight() - downcast&lt;RenderBlockFlow&gt;(*lastBlock).marginOffsetForSelfCollapsingBlock());
1414 
1415     // If we can&#39;t collapse with children then add in the bottom margin.
1416     if (!marginInfo.discardMargin() &amp;&amp; (!marginInfo.canCollapseWithMarginAfter() &amp;&amp; !marginInfo.canCollapseWithMarginBefore()
1417         &amp;&amp; (!document().inQuirksMode() || !marginInfo.quirkContainer() || !marginInfo.hasMarginAfterQuirk())))
1418         setLogicalHeight(logicalHeight() + marginInfo.margin());
1419 
1420     // Now add in our bottom border/padding.
1421     setLogicalHeight(logicalHeight() + afterSide);
1422 
1423     // Negative margins can cause our height to shrink below our minimal height (border/padding).
1424     // If this happens, ensure that the computed height is increased to the minimal height.
1425     setLogicalHeight(std::max(logicalHeight(), beforeSide + afterSide));
1426 
1427     // Update our bottom collapsed margin info.
1428     setCollapsedBottomMargin(marginInfo);
1429 }
1430 
1431 void RenderBlockFlow::setMaxMarginBeforeValues(LayoutUnit pos, LayoutUnit neg)
1432 {
1433     if (!hasRareBlockFlowData()) {
1434         if (pos == RenderBlockFlowRareData::positiveMarginBeforeDefault(*this) &amp;&amp; neg == RenderBlockFlowRareData::negativeMarginBeforeDefault(*this))
1435             return;
1436         materializeRareBlockFlowData();
1437     }
1438 
1439     rareBlockFlowData()-&gt;m_margins.setPositiveMarginBefore(pos);
1440     rareBlockFlowData()-&gt;m_margins.setNegativeMarginBefore(neg);
1441 }
1442 
1443 void RenderBlockFlow::setMaxMarginAfterValues(LayoutUnit pos, LayoutUnit neg)
1444 {
1445     if (!hasRareBlockFlowData()) {
1446         if (pos == RenderBlockFlowRareData::positiveMarginAfterDefault(*this) &amp;&amp; neg == RenderBlockFlowRareData::negativeMarginAfterDefault(*this))
1447             return;
1448         materializeRareBlockFlowData();
1449     }
1450 
1451     rareBlockFlowData()-&gt;m_margins.setPositiveMarginAfter(pos);
1452     rareBlockFlowData()-&gt;m_margins.setNegativeMarginAfter(neg);
1453 }
1454 
1455 void RenderBlockFlow::setMustDiscardMarginBefore(bool value)
1456 {
1457     if (style().marginBeforeCollapse() == MarginCollapse::Discard) {
1458         ASSERT(value);
1459         return;
1460     }
1461 
1462     if (!hasRareBlockFlowData()) {
1463         if (!value)
1464             return;
1465         materializeRareBlockFlowData();
1466     }
1467 
1468     rareBlockFlowData()-&gt;m_discardMarginBefore = value;
1469 }
1470 
1471 void RenderBlockFlow::setMustDiscardMarginAfter(bool value)
1472 {
1473     if (style().marginAfterCollapse() == MarginCollapse::Discard) {
1474         ASSERT(value);
1475         return;
1476     }
1477 
1478     if (!hasRareBlockFlowData()) {
1479         if (!value)
1480             return;
1481         materializeRareBlockFlowData();
1482     }
1483 
1484     rareBlockFlowData()-&gt;m_discardMarginAfter = value;
1485 }
1486 
1487 bool RenderBlockFlow::mustDiscardMarginBefore() const
1488 {
1489     return style().marginBeforeCollapse() == MarginCollapse::Discard || (hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_discardMarginBefore);
1490 }
1491 
1492 bool RenderBlockFlow::mustDiscardMarginAfter() const
1493 {
1494     return style().marginAfterCollapse() == MarginCollapse::Discard || (hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_discardMarginAfter);
1495 }
1496 
1497 bool RenderBlockFlow::mustDiscardMarginBeforeForChild(const RenderBox&amp; child) const
1498 {
1499     ASSERT(!child.selfNeedsLayout());
1500     if (!child.isWritingModeRoot())
1501         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginBefore() : (child.style().marginBeforeCollapse() == MarginCollapse::Discard);
1502     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1503         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginAfter() : (child.style().marginAfterCollapse() == MarginCollapse::Discard);
1504 
1505     // FIXME: We return false here because the implementation is not geometrically complete. We have values only for before/after, not start/end.
1506     // In case the boxes are perpendicular we assume the property is not specified.
1507     return false;
1508 }
1509 
1510 bool RenderBlockFlow::mustDiscardMarginAfterForChild(const RenderBox&amp; child) const
1511 {
1512     ASSERT(!child.selfNeedsLayout());
1513     if (!child.isWritingModeRoot())
1514         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginAfter() : (child.style().marginAfterCollapse() == MarginCollapse::Discard);
1515     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1516         return is&lt;RenderBlockFlow&gt;(child) ? downcast&lt;RenderBlockFlow&gt;(child).mustDiscardMarginBefore() : (child.style().marginBeforeCollapse() == MarginCollapse::Discard);
1517 
1518     // FIXME: See |mustDiscardMarginBeforeForChild| above.
1519     return false;
1520 }
1521 
1522 bool RenderBlockFlow::mustSeparateMarginBeforeForChild(const RenderBox&amp; child) const
1523 {
1524     ASSERT(!child.selfNeedsLayout());
1525     const RenderStyle&amp; childStyle = child.style();
1526     if (!child.isWritingModeRoot())
1527         return childStyle.marginBeforeCollapse() == MarginCollapse::Separate;
1528     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1529         return childStyle.marginAfterCollapse() == MarginCollapse::Separate;
1530 
1531     // FIXME: See |mustDiscardMarginBeforeForChild| above.
1532     return false;
1533 }
1534 
1535 bool RenderBlockFlow::mustSeparateMarginAfterForChild(const RenderBox&amp; child) const
1536 {
1537     ASSERT(!child.selfNeedsLayout());
1538     const RenderStyle&amp; childStyle = child.style();
1539     if (!child.isWritingModeRoot())
1540         return childStyle.marginAfterCollapse() == MarginCollapse::Separate;
1541     if (child.isHorizontalWritingMode() == isHorizontalWritingMode())
1542         return childStyle.marginBeforeCollapse() == MarginCollapse::Separate;
1543 
1544     // FIXME: See |mustDiscardMarginBeforeForChild| above.
1545     return false;
1546 }
1547 
1548 static bool inNormalFlow(RenderBox&amp; child)
1549 {
1550     RenderBlock* curr = child.containingBlock();
1551     while (curr &amp;&amp; curr != &amp;child.view()) {
1552         if (curr-&gt;isRenderFragmentedFlow())
1553             return true;
1554         if (curr-&gt;isFloatingOrOutOfFlowPositioned())
1555             return false;
1556         curr = curr-&gt;containingBlock();
1557     }
1558     return true;
1559 }
1560 
1561 LayoutUnit RenderBlockFlow::applyBeforeBreak(RenderBox&amp; child, LayoutUnit logicalOffset)
1562 {
1563     // FIXME: Add page break checking here when we support printing.
1564     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1565     bool isInsideMulticolFlow = fragmentedFlow;
1566     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
1567     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight(); // FIXME: Once columns can print we have to check this.
1568     bool checkFragmentBreaks = false;
1569     bool checkBeforeAlways = (checkColumnBreaks &amp;&amp; child.style().breakBefore() == BreakBetween::Column)
1570         || (checkPageBreaks &amp;&amp; alwaysPageBreak(child.style().breakBefore()));
1571     if (checkBeforeAlways &amp;&amp; inNormalFlow(child) &amp;&amp; hasNextPage(logicalOffset, IncludePageBoundary)) {
1572         if (checkColumnBreaks) {
1573             if (isInsideMulticolFlow)
1574                 checkFragmentBreaks = true;
1575         }
1576         if (checkFragmentBreaks) {
1577             LayoutUnit offsetBreakAdjustment;
1578             if (fragmentedFlow-&gt;addForcedFragmentBreak(this, offsetFromLogicalTopOfFirstPage() + logicalOffset, &amp;child, true, &amp;offsetBreakAdjustment))
1579                 return logicalOffset + offsetBreakAdjustment;
1580         }
1581         return nextPageLogicalTop(logicalOffset, IncludePageBoundary);
1582     }
1583     return logicalOffset;
1584 }
1585 
1586 LayoutUnit RenderBlockFlow::applyAfterBreak(RenderBox&amp; child, LayoutUnit logicalOffset, MarginInfo&amp; marginInfo)
1587 {
1588     // FIXME: Add page break checking here when we support printing.
1589     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1590     bool isInsideMulticolFlow = fragmentedFlow;
1591     bool checkColumnBreaks = fragmentedFlow &amp;&amp; fragmentedFlow-&gt;shouldCheckColumnBreaks();
1592     bool checkPageBreaks = !checkColumnBreaks &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight(); // FIXME: Once columns can print we have to check this.
1593     bool checkFragmentBreaks = false;
1594     bool checkAfterAlways = (checkColumnBreaks &amp;&amp; child.style().breakAfter() == BreakBetween::Column)
1595         || (checkPageBreaks &amp;&amp; alwaysPageBreak(child.style().breakAfter()));
1596     if (checkAfterAlways &amp;&amp; inNormalFlow(child) &amp;&amp; hasNextPage(logicalOffset, IncludePageBoundary)) {
1597         LayoutUnit marginOffset = marginInfo.canCollapseWithMarginBefore() ? 0_lu : marginInfo.margin();
1598 
1599         // So our margin doesn&#39;t participate in the next collapsing steps.
1600         marginInfo.clearMargin();
1601 
1602         if (checkColumnBreaks) {
1603             if (isInsideMulticolFlow)
1604                 checkFragmentBreaks = true;
1605         }
1606         if (checkFragmentBreaks) {
1607             LayoutUnit offsetBreakAdjustment;
1608             if (fragmentedFlow-&gt;addForcedFragmentBreak(this, offsetFromLogicalTopOfFirstPage() + logicalOffset + marginOffset, &amp;child, false, &amp;offsetBreakAdjustment))
1609                 return logicalOffset + marginOffset + offsetBreakAdjustment;
1610         }
1611         return nextPageLogicalTop(logicalOffset, IncludePageBoundary);
1612     }
1613     return logicalOffset;
1614 }
1615 
1616 LayoutUnit RenderBlockFlow::adjustBlockChildForPagination(LayoutUnit logicalTopAfterClear, LayoutUnit estimateWithoutPagination, RenderBox&amp; child, bool atBeforeSideOfBlock)
1617 {
1618     RenderBlock* childRenderBlock = is&lt;RenderBlock&gt;(child) ? &amp;downcast&lt;RenderBlock&gt;(child) : nullptr;
1619 
1620     if (estimateWithoutPagination != logicalTopAfterClear) {
1621         // Our guess prior to pagination movement was wrong. Before we attempt to paginate, let&#39;s try again at the new
1622         // position.
1623         setLogicalHeight(logicalTopAfterClear);
1624         setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);
1625 
1626         if (child.shrinkToAvoidFloats()) {
1627             // The child&#39;s width depends on the line width. When the child shifts to clear an item, its width can
1628             // change (because it has more available line width). So mark the item as dirty.
1629             child.setChildNeedsLayout(MarkOnlyThis);
1630         }
1631 
1632         if (childRenderBlock) {
1633             if (!child.avoidsFloats() &amp;&amp; childRenderBlock-&gt;containsFloats())
1634                 downcast&lt;RenderBlockFlow&gt;(*childRenderBlock).markAllDescendantsWithFloatsForLayout();
1635             child.markForPaginationRelayoutIfNeeded();
1636         }
1637 
1638         // Our guess was wrong. Make the child lay itself out again.
1639         child.layoutIfNeeded();
1640     }
1641 
1642     LayoutUnit oldTop = logicalTopAfterClear;
1643 
1644     // If the object has a page or column break value of &quot;before&quot;, then we should shift to the top of the next page.
1645     LayoutUnit result = applyBeforeBreak(child, logicalTopAfterClear);
1646 
1647     if (pageLogicalHeightForOffset(result)) {
1648         LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(result, ExcludePageBoundary);
1649         LayoutUnit spaceShortage = child.logicalHeight() - remainingLogicalHeight;
1650         if (spaceShortage &gt; 0) {
1651             // If the child crosses a column boundary, report a break, in case nothing inside it has already
1652             // done so. The column balancer needs to know how much it has to stretch the columns to make more
1653             // content fit. If no breaks are reported (but do occur), the balancer will have no clue. FIXME:
1654             // This should be improved, though, because here we just pretend that the child is
1655             // unsplittable. A splittable child, on the other hand, has break opportunities at every position
1656             // where there&#39;s no child content, border or padding. In other words, we risk stretching more
1657             // than necessary.
1658             setPageBreak(result, spaceShortage);
1659         }
1660     }
1661 
1662     // For replaced elements and scrolled elements, we want to shift them to the next page if they don&#39;t fit on the current one.
1663     LayoutUnit logicalTopBeforeUnsplittableAdjustment = result;
1664     LayoutUnit logicalTopAfterUnsplittableAdjustment = adjustForUnsplittableChild(child, result);
1665 
1666     LayoutUnit paginationStrut;
1667     LayoutUnit unsplittableAdjustmentDelta = logicalTopAfterUnsplittableAdjustment - logicalTopBeforeUnsplittableAdjustment;
1668     if (unsplittableAdjustmentDelta)
1669         paginationStrut = unsplittableAdjustmentDelta;
1670     else if (childRenderBlock &amp;&amp; childRenderBlock-&gt;paginationStrut())
1671         paginationStrut = childRenderBlock-&gt;paginationStrut();
1672 
1673     if (paginationStrut) {
1674         // We are willing to propagate out to our parent block as long as we were at the top of the block prior
1675         // to collapsing our margins, and as long as we didn&#39;t clear or move as a result of other pagination.
1676         if (atBeforeSideOfBlock &amp;&amp; oldTop == result &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
1677             // FIXME: Should really check if we&#39;re exceeding the page height before propagating the strut, but we don&#39;t
1678             // have all the information to do so (the strut only has the remaining amount to push). Gecko gets this wrong too
1679             // and pushes to the next page anyway, so not too concerned about it.
1680             setPaginationStrut(result + paginationStrut);
1681             if (childRenderBlock)
1682                 childRenderBlock-&gt;setPaginationStrut(0);
1683         } else
1684             result += paginationStrut;
1685     }
1686 
1687     // Similar to how we apply clearance. Boost height() to be the place where we&#39;re going to position the child.
1688     setLogicalHeight(logicalHeight() + (result - oldTop));
1689 
1690     // Return the final adjusted logical top.
1691     return result;
1692 }
1693 
1694 static inline LayoutUnit calculateMinimumPageHeight(const RenderStyle&amp; renderStyle, RootInlineBox&amp; lastLine, LayoutUnit lineTop, LayoutUnit lineBottom)
1695 {
1696     // We may require a certain minimum number of lines per page in order to satisfy
1697     // orphans and widows, and that may affect the minimum page height.
1698     unsigned lineCount = std::max&lt;unsigned&gt;(renderStyle.hasAutoOrphans() ? 1 : renderStyle.orphans(), renderStyle.hasAutoWidows() ? 1 : renderStyle.widows());
1699     if (lineCount &gt; 1) {
1700         RootInlineBox* line = &amp;lastLine;
1701         for (unsigned i = 1; i &lt; lineCount &amp;&amp; line-&gt;prevRootBox(); i++)
1702             line = line-&gt;prevRootBox();
1703 
1704         // FIXME: Paginating using line overflow isn&#39;t all fine. See FIXME in
1705         // adjustLinePositionForPagination() for more details.
1706         LayoutRect overflow = line-&gt;logicalVisualOverflowRect(line-&gt;lineTop(), line-&gt;lineBottom());
1707         lineTop = std::min(line-&gt;lineTopWithLeading(), overflow.y());
1708     }
1709     return lineBottom - lineTop;
1710 }
1711 
1712 static inline bool needsAppleMailPaginationQuirk(RootInlineBox&amp; lineBox)
1713 {
1714     auto&amp; renderer = lineBox.renderer();
1715 
1716     if (!renderer.settings().appleMailPaginationQuirkEnabled())
1717         return false;
1718 
1719     if (renderer.element() &amp;&amp; renderer.element()-&gt;idForStyleResolution() == &quot;messageContentContainer&quot;)
1720         return true;
1721 
1722     return false;
1723 }
1724 
1725 static void clearShouldBreakAtLineToAvoidWidowIfNeeded(RenderBlockFlow&amp; blockFlow)
1726 {
1727     if (!blockFlow.shouldBreakAtLineToAvoidWidow())
1728         return;
1729     blockFlow.clearShouldBreakAtLineToAvoidWidow();
1730     blockFlow.setDidBreakAtLineToAvoidWidow();
1731 }
1732 
1733 void RenderBlockFlow::adjustLinePositionForPagination(RootInlineBox* lineBox, LayoutUnit&amp; delta, bool&amp; overflowsFragment, RenderFragmentedFlow* fragmentedFlow)
1734 {
1735     // FIXME: For now we paginate using line overflow. This ensures that lines don&#39;t overlap at all when we
1736     // put a strut between them for pagination purposes. However, this really isn&#39;t the desired rendering, since
1737     // the line on the top of the next page will appear too far down relative to the same kind of line at the top
1738     // of the first column.
1739     //
1740     // The rendering we would like to see is one where the lineTopWithLeading is at the top of the column, and any line overflow
1741     // simply spills out above the top of the column. This effect would match what happens at the top of the first column.
1742     // We can&#39;t achieve this rendering, however, until we stop columns from clipping to the column bounds (thus allowing
1743     // for overflow to occur), and then cache visible overflow for each column rect.
1744     //
1745     // Furthermore, the paint we have to do when a column has overflow has to be special. We need to exclude
1746     // content that paints in a previous column (and content that paints in the following column).
1747     //
1748     // For now we&#39;ll at least honor the lineTopWithLeading when paginating if it is above the logical top overflow. This will
1749     // at least make positive leading work in typical cases.
1750     //
1751     // FIXME: Another problem with simply moving lines is that the available line width may change (because of floats).
1752     // Technically if the location we move the line to has a different line width than our old position, then we need to dirty the
1753     // line and all following lines.
1754     overflowsFragment = false;
1755     LayoutRect logicalVisualOverflow = lineBox-&gt;logicalVisualOverflowRect(lineBox-&gt;lineTop(), lineBox-&gt;lineBottom());
1756     LayoutUnit logicalOffset = std::min(lineBox-&gt;lineTopWithLeading(), logicalVisualOverflow.y());
1757     LayoutUnit logicalBottom = std::max(lineBox-&gt;lineBottomWithLeading(), logicalVisualOverflow.maxY());
1758     LayoutUnit lineHeight = logicalBottom - logicalOffset;
1759     updateMinimumPageHeight(logicalOffset, calculateMinimumPageHeight(style(), *lineBox, logicalOffset, logicalBottom));
1760     logicalOffset += delta;
1761     lineBox-&gt;setPaginationStrut(0);
1762     lineBox-&gt;setIsFirstAfterPageBreak(false);
1763     LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1764     bool hasUniformPageLogicalHeight = !fragmentedFlow || fragmentedFlow-&gt;fragmentsHaveUniformLogicalHeight();
1765     // If lineHeight is greater than pageLogicalHeight, but logicalVisualOverflow.height() still fits, we are
1766     // still going to add a strut, so that the visible overflow fits on a single page.
1767     if (!pageLogicalHeight || !hasNextPage(logicalOffset)) {
1768         // FIXME: In case the line aligns with the top of the page (or it&#39;s slightly shifted downwards) it will not be marked as the first line in the page.
1769         // From here, the fix is not straightforward because it&#39;s not easy to always determine when the current line is the first in the page.
1770         return;
1771     }
1772 
1773     if (hasUniformPageLogicalHeight &amp;&amp; logicalVisualOverflow.height() &gt; pageLogicalHeight) {
1774         // We are so tall that we are bigger than a page. Before we give up and just leave the line where it is, try drilling into the
1775         // line and computing a new height that excludes anything we consider &quot;blank space&quot;. We will discard margins, descent, and even overflow. If we are
1776         // able to fit with the blank space and overflow excluded, we will give the line its own page with the highest non-blank element being aligned with the
1777         // top of the page.
1778         // FIXME: We are still honoring gigantic margins, which does leave open the possibility of blank pages caused by this heuristic. It remains to be seen whether or not
1779         // this will be a real-world issue. For now we don&#39;t try to deal with this problem.
1780         logicalOffset = intMaxForLayoutUnit;
1781         logicalBottom = intMinForLayoutUnit;
1782         lineBox-&gt;computeReplacedAndTextLineTopAndBottom(logicalOffset, logicalBottom);
1783         lineHeight = logicalBottom - logicalOffset;
1784         if (logicalOffset == intMaxForLayoutUnit || lineHeight &gt; pageLogicalHeight) {
1785             // Give up. We&#39;re genuinely too big even after excluding blank space and overflow.
1786             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1787             return;
1788         }
1789         pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1790     }
1791 
1792     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
1793     overflowsFragment = (lineHeight &gt; remainingLogicalHeight);
1794 
1795     int lineIndex = complexLineLayout()-&gt;lineCountUntil(lineBox);
1796     if (remainingLogicalHeight &lt; lineHeight || (shouldBreakAtLineToAvoidWidow() &amp;&amp; lineBreakToAvoidWidow() == lineIndex)) {
1797         if (lineBreakToAvoidWidow() == lineIndex)
1798             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1799         // If we have a non-uniform page height, then we have to shift further possibly.
1800         if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, lineHeight))
1801             return;
1802         if (lineHeight &gt; pageLogicalHeight) {
1803             // Split the top margin in order to avoid splitting the visible part of the line.
1804             remainingLogicalHeight -= std::min(lineHeight - pageLogicalHeight, std::max&lt;LayoutUnit&gt;(0, logicalVisualOverflow.y() - lineBox-&gt;lineTopWithLeading()));
1805         }
1806         LayoutUnit remainingLogicalHeightAtNewOffset = pageRemainingLogicalHeightForOffset(logicalOffset + remainingLogicalHeight, ExcludePageBoundary);
1807         overflowsFragment = (lineHeight &gt; remainingLogicalHeightAtNewOffset);
1808         LayoutUnit totalLogicalHeight = lineHeight + std::max&lt;LayoutUnit&gt;(0, logicalOffset);
1809         LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset(logicalOffset + remainingLogicalHeight);
1810         setPageBreak(logicalOffset, lineHeight - remainingLogicalHeight);
1811         if (((lineBox == firstRootBox() &amp;&amp; totalLogicalHeight &lt; pageLogicalHeightAtNewOffset) || (!style().hasAutoOrphans() &amp;&amp; style().orphans() &gt;= lineIndex))
1812             &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
1813             auto firstRootBox = this-&gt;firstRootBox();
1814             if (!firstRootBox) {
1815                 setPaginationStrut(remainingLogicalHeight + logicalOffset);
1816                 return;
1817             }
1818             auto firstRootBoxOverflowRect = firstRootBox-&gt;logicalVisualOverflowRect(firstRootBox-&gt;lineTop(), firstRootBox-&gt;lineBottom());
1819             auto firstLineUpperOverhang = std::max(-firstRootBoxOverflowRect.y(), 0_lu);
1820             if (needsAppleMailPaginationQuirk(*lineBox))
1821                 return;
1822             setPaginationStrut(remainingLogicalHeight + logicalOffset + firstLineUpperOverhang);
1823         } else {
1824             delta += remainingLogicalHeight;
1825             lineBox-&gt;setPaginationStrut(remainingLogicalHeight);
1826             lineBox-&gt;setIsFirstAfterPageBreak(true);
1827         }
1828     } else if (remainingLogicalHeight == pageLogicalHeight) {
1829         // We&#39;re at the very top of a page or column.
1830         if (lineBox != firstRootBox())
1831             lineBox-&gt;setIsFirstAfterPageBreak(true);
1832         if (lineBox != firstRootBox() || offsetFromLogicalTopOfFirstPage())
1833             setPageBreak(logicalOffset, lineHeight);
1834     }
1835 }
1836 
1837 void RenderBlockFlow::setBreakAtLineToAvoidWidow(int lineToBreak)
1838 {
1839     ASSERT(lineToBreak &gt;= 0);
1840     ASSERT(!ensureRareBlockFlowData().m_didBreakAtLineToAvoidWidow);
1841     ensureRareBlockFlowData().m_lineBreakToAvoidWidow = lineToBreak;
1842 }
1843 
1844 void RenderBlockFlow::setDidBreakAtLineToAvoidWidow()
1845 {
1846     ASSERT(!shouldBreakAtLineToAvoidWidow());
1847     if (!hasRareBlockFlowData())
1848         return;
1849 
1850     rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow = true;
1851 }
1852 
1853 void RenderBlockFlow::clearDidBreakAtLineToAvoidWidow()
1854 {
1855     if (!hasRareBlockFlowData())
1856         return;
1857 
1858     rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow = false;
1859 }
1860 
1861 void RenderBlockFlow::clearShouldBreakAtLineToAvoidWidow() const
1862 {
1863     ASSERT(shouldBreakAtLineToAvoidWidow());
1864     if (!hasRareBlockFlowData())
1865         return;
1866 
1867     rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow = -1;
1868 }
1869 
1870 bool RenderBlockFlow::relayoutToAvoidWidows()
1871 {
1872     if (!shouldBreakAtLineToAvoidWidow())
1873         return false;
1874 
1875     setEverHadLayout(true);
1876     layoutBlock(false);
1877     return true;
1878 }
1879 
1880 bool RenderBlockFlow::hasNextPage(LayoutUnit logicalOffset, PageBoundaryRule pageBoundaryRule) const
1881 {
1882     ASSERT(view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated());
1883 
1884     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1885     if (!fragmentedFlow)
1886         return true; // Printing and multi-column both make new pages to accommodate content.
1887 
1888     // See if we&#39;re in the last fragment.
1889     LayoutUnit pageOffset = offsetFromLogicalTopOfFirstPage() + logicalOffset;
1890     RenderFragmentContainer* fragment = fragmentedFlow-&gt;fragmentAtBlockOffset(this, pageOffset, true);
1891     if (!fragment)
1892         return false;
1893 
1894     if (fragment-&gt;isLastFragment())
1895         return fragment-&gt;isRenderFragmentContainerSet() || (pageBoundaryRule == IncludePageBoundary &amp;&amp; pageOffset == fragment-&gt;logicalTopForFragmentedFlowContent());
1896 
1897     RenderFragmentContainer* startFragment = nullptr;
1898     RenderFragmentContainer* endFragment = nullptr;
1899     fragmentedFlow-&gt;getFragmentRangeForBox(this, startFragment, endFragment);
1900     return (endFragment &amp;&amp; fragment != endFragment);
1901 }
1902 
1903 LayoutUnit RenderBlockFlow::adjustForUnsplittableChild(RenderBox&amp; child, LayoutUnit logicalOffset, LayoutUnit childBeforeMargin, LayoutUnit childAfterMargin)
1904 {
1905     // When flexboxes are embedded inside a block flow, they don&#39;t perform any adjustments for unsplittable
1906     // children. We&#39;ll treat flexboxes themselves as unsplittable just to get them to paginate properly inside
1907     // a block flow.
1908     bool isUnsplittable = childBoxIsUnsplittableForFragmentation(child);
1909     if (!isUnsplittable &amp;&amp; !(child.isFlexibleBox() &amp;&amp; !downcast&lt;RenderFlexibleBox&gt;(child).isFlexibleBoxImpl()))
1910         return logicalOffset;
1911 
1912     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1913     LayoutUnit childLogicalHeight = logicalHeightForChild(child) + childBeforeMargin + childAfterMargin;
1914     LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1915     bool hasUniformPageLogicalHeight = !fragmentedFlow || fragmentedFlow-&gt;fragmentsHaveUniformLogicalHeight();
1916     if (isUnsplittable)
1917         updateMinimumPageHeight(logicalOffset, childLogicalHeight);
1918     if (!pageLogicalHeight || (hasUniformPageLogicalHeight &amp;&amp; childLogicalHeight &gt; pageLogicalHeight)
1919         || !hasNextPage(logicalOffset))
1920         return logicalOffset;
1921     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
1922     if (remainingLogicalHeight &lt; childLogicalHeight) {
1923         if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, childLogicalHeight))
1924             return logicalOffset;
1925         auto result = logicalOffset + remainingLogicalHeight;
1926         bool isInitialLetter = child.isFloating() &amp;&amp; child.style().styleType() == PseudoId::FirstLetter &amp;&amp; child.style().initialLetterDrop() &gt; 0;
1927         if (isInitialLetter) {
1928             // Increase our logical height to ensure that lines all get pushed along with the letter.
1929             setLogicalHeight(logicalOffset + remainingLogicalHeight);
1930         }
1931         return result;
1932     }
1933 
1934     return logicalOffset;
1935 }
1936 
1937 bool RenderBlockFlow::pushToNextPageWithMinimumLogicalHeight(LayoutUnit&amp; adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const
1938 {
1939     bool checkFragment = false;
1940     for (LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset + adjustment); pageLogicalHeight;
1941         pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset + adjustment)) {
1942         if (minimumLogicalHeight &lt;= pageLogicalHeight)
1943             return true;
1944         if (!hasNextPage(logicalOffset + adjustment))
1945             return false;
1946         adjustment += pageLogicalHeight;
1947         checkFragment = true;
1948     }
1949     return !checkFragment;
1950 }
1951 
1952 void RenderBlockFlow::setPageBreak(LayoutUnit offset, LayoutUnit spaceShortage)
1953 {
1954     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
1955         fragmentedFlow-&gt;setPageBreak(this, offsetFromLogicalTopOfFirstPage() + offset, spaceShortage);
1956 }
1957 
1958 void RenderBlockFlow::updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight)
1959 {
1960     if (RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow())
1961         fragmentedFlow-&gt;updateMinimumPageHeight(this, offsetFromLogicalTopOfFirstPage() + offset, minHeight);
1962 }
1963 
1964 LayoutUnit RenderBlockFlow::nextPageLogicalTop(LayoutUnit logicalOffset, PageBoundaryRule pageBoundaryRule) const
1965 {
1966     LayoutUnit pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1967     if (!pageLogicalHeight)
1968         return logicalOffset;
1969 
1970     // The logicalOffset is in our coordinate space.  We can add in our pushed offset.
1971     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset);
1972     if (pageBoundaryRule == ExcludePageBoundary)
1973         return logicalOffset + (remainingLogicalHeight ? remainingLogicalHeight : pageLogicalHeight);
1974     return logicalOffset + remainingLogicalHeight;
1975 }
1976 
1977 LayoutUnit RenderBlockFlow::pageLogicalTopForOffset(LayoutUnit offset) const
1978 {
1979     // Unsplittable objects clear out the pageLogicalHeight in the layout state as a way of signaling that no
1980     // pagination should occur. Therefore we have to check this first and bail if the value has been set to 0.
1981     auto* layoutState = view().frameView().layoutContext().layoutState();
1982     LayoutUnit pageLogicalHeight = layoutState-&gt;pageLogicalHeight();
1983     if (!pageLogicalHeight)
1984         return 0;
1985 
1986     LayoutUnit firstPageLogicalTop = isHorizontalWritingMode() ? layoutState-&gt;pageOffset().height() : layoutState-&gt;pageOffset().width();
1987     LayoutUnit blockLogicalTop = isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().height() : layoutState-&gt;layoutOffset().width();
1988 
1989     LayoutUnit cumulativeOffset = offset + blockLogicalTop;
1990     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
1991     if (!fragmentedFlow)
1992         return cumulativeOffset - roundToInt(cumulativeOffset - firstPageLogicalTop) % roundToInt(pageLogicalHeight);
1993     return firstPageLogicalTop + fragmentedFlow-&gt;pageLogicalTopForOffset(cumulativeOffset - firstPageLogicalTop);
1994 }
1995 
1996 LayoutUnit RenderBlockFlow::pageLogicalHeightForOffset(LayoutUnit offset) const
1997 {
1998     // Unsplittable objects clear out the pageLogicalHeight in the layout state as a way of signaling that no
1999     // pagination should occur. Therefore we have to check this first and bail if the value has been set to 0.
2000     LayoutUnit pageLogicalHeight = view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
2001     if (!pageLogicalHeight)
2002         return 0;
2003 
2004     // Now check for a flow thread.
2005     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2006     if (!fragmentedFlow)
2007         return pageLogicalHeight;
2008     return fragmentedFlow-&gt;pageLogicalHeightForOffset(offset + offsetFromLogicalTopOfFirstPage());
2009 }
2010 
2011 LayoutUnit RenderBlockFlow::pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule pageBoundaryRule) const
2012 {
2013     offset += offsetFromLogicalTopOfFirstPage();
2014 
2015     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
2016     if (!fragmentedFlow) {
2017         LayoutUnit pageLogicalHeight = view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeight();
2018         LayoutUnit remainingHeight = pageLogicalHeight - intMod(offset, pageLogicalHeight);
2019         if (pageBoundaryRule == IncludePageBoundary) {
2020             // If includeBoundaryPoint is true the line exactly on the top edge of a
2021             // column will act as being part of the previous column.
2022             remainingHeight = intMod(remainingHeight, pageLogicalHeight);
2023         }
2024         return remainingHeight;
2025     }
2026 
2027     return fragmentedFlow-&gt;pageRemainingLogicalHeightForOffset(offset, pageBoundaryRule);
2028 }
2029 
2030 LayoutUnit RenderBlockFlow::logicalHeightForChildForFragmentation(const RenderBox&amp; child) const
2031 {
2032     return logicalHeightForChild(child);
2033 }
2034 
2035 void RenderBlockFlow::layoutLineGridBox()
2036 {
2037     if (style().lineGrid() == RenderStyle::initialLineGrid()) {
2038         setLineGridBox(0);
2039         return;
2040     }
2041 
2042     setLineGridBox(0);
2043 
2044     auto lineGridBox = makeUnique&lt;RootInlineBox&gt;(*this);
2045     lineGridBox-&gt;setHasTextChildren(); // Needed to make the line ascent/descent actually be honored in quirks mode.
2046     lineGridBox-&gt;setConstructed();
2047     GlyphOverflowAndFallbackFontsMap textBoxDataMap;
2048     VerticalPositionCache verticalPositionCache;
2049     lineGridBox-&gt;alignBoxesInBlockDirection(logicalHeight(), textBoxDataMap, verticalPositionCache);
2050 
2051     setLineGridBox(WTFMove(lineGridBox));
2052 
2053     // FIXME: If any of the characteristics of the box change compared to the old one, then we need to do a deep dirtying
2054     // (similar to what happens when the page height changes). Ideally, though, we only do this if someone is actually snapping
2055     // to this grid.
2056 }
2057 
2058 bool RenderBlockFlow::containsFloat(RenderBox&amp; renderer) const
2059 {
2060     return m_floatingObjects &amp;&amp; m_floatingObjects-&gt;set().contains&lt;FloatingObjectHashTranslator&gt;(renderer);
2061 }
2062 
2063 void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
2064 {
2065     RenderBlock::styleDidChange(diff, oldStyle);
2066 
2067     // After our style changed, if we lose our ability to propagate floats into next sibling
2068     // blocks, then we need to find the top most parent containing that overhanging float and
2069     // then mark its descendants with floats for layout and clear all floats from its next
2070     // sibling blocks that exist in our floating objects list. See bug 56299 and 62875.
2071     bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() &amp;&amp; !avoidsFloats();
2072     if (diff == StyleDifference::Layout &amp;&amp; s_canPropagateFloatIntoSibling &amp;&amp; !canPropagateFloatIntoSibling &amp;&amp; hasOverhangingFloats()) {
2073         RenderBlockFlow* parentBlock = this;
2074         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2075 
2076         for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(*this)) {
2077             if (ancestor.isRenderView())
2078                 break;
2079             if (ancestor.hasOverhangingFloats()) {
2080                 for (auto it = floatingObjectSet.begin(), end = floatingObjectSet.end(); it != end; ++it) {
2081                     RenderBox&amp; renderer = (*it)-&gt;renderer();
2082                     if (ancestor.hasOverhangingFloat(renderer)) {
2083                         parentBlock = &amp;ancestor;
2084                         break;
2085                     }
2086                 }
2087             }
2088         }
2089 
2090         parentBlock-&gt;markAllDescendantsWithFloatsForLayout();
2091         parentBlock-&gt;markSiblingsWithFloatsForLayout();
2092     }
2093 
2094     if (diff &gt;= StyleDifference::Repaint) {
2095         auto shouldInvalidateLineLayoutPath = [&amp;] {
2096             if (selfNeedsLayout() || complexLineLayout())
2097                 return true;
2098             // FIXME: This could use a cheaper style-only test instead of SimpleLineLayout::canUseFor.
2099             if (simpleLineLayout() &amp;&amp; !SimpleLineLayout::canUseFor(*this))
2100                 return true;
2101 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
2102             if (layoutFormattingContextLineLayout() &amp;&amp; !LayoutIntegration::LineLayout::canUseFor(*this))
2103                 return true;
2104 #endif
2105             return false;
2106         };
2107         if (shouldInvalidateLineLayoutPath())
2108             invalidateLineLayoutPath();
2109     }
2110 
2111     if (multiColumnFlow())
2112         updateStylesForColumnChildren();
2113 
2114 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
2115     if (layoutFormattingContextLineLayout())
2116         layoutFormattingContextLineLayout()-&gt;updateStyle();
2117 #endif
2118 }
2119 
2120 void RenderBlockFlow::updateStylesForColumnChildren()
2121 {
2122     for (auto* child = firstChildBox(); child &amp;&amp; (child-&gt;isInFlowRenderFragmentedFlow() || child-&gt;isRenderMultiColumnSet()); child = child-&gt;nextSiblingBox())
2123         child-&gt;setStyle(RenderStyle::createAnonymousStyleWithDisplay(style(), DisplayType::Block));
2124 }
2125 
2126 void RenderBlockFlow::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
2127 {
2128     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
2129     s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrOutOfFlowPositioned() &amp;&amp; !avoidsFloats() : false;
2130 
2131     if (oldStyle) {
2132         auto oldPosition = oldStyle-&gt;position();
2133         auto newPosition = newStyle.position();
2134 
2135         if (parent() &amp;&amp; diff == StyleDifference::Layout &amp;&amp; oldPosition != newPosition) {
2136             if (containsFloats() &amp;&amp; !isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
2137                 markAllDescendantsWithFloatsForLayout();
2138         }
2139     }
2140 
2141     RenderBlock::styleWillChange(diff, newStyle);
2142 }
2143 
2144 void RenderBlockFlow::deleteLines()
2145 {
2146     m_lineLayout = WTF::Monostate();
2147 
2148     RenderBlock::deleteLines();
2149 }
2150 
2151 void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
2152 {
2153     // When a portion of the render tree is being detached, anonymous blocks
2154     // will be combined as their children are deleted. In this process, the
2155     // anonymous block later in the tree is merged into the one preceeding it.
2156     // It can happen that the later block (this) contains floats that the
2157     // previous block (toBlockFlow) did not contain, and thus are not in the
2158     // floating objects list for toBlockFlow. This can result in toBlockFlow
2159     // containing floats that are not in it&#39;s floating objects list, but are in
2160     // the floating objects lists of siblings and parents. This can cause
2161     // problems when the float itself is deleted, since the deletion code
2162     // assumes that if a float is not in it&#39;s containing block&#39;s floating
2163     // objects list, it isn&#39;t in any floating objects list. In order to
2164     // preserve this condition (removing it has serious performance
2165     // implications), we need to copy the floating objects from the old block
2166     // (this) to the new block (toBlockFlow). The float&#39;s metrics will likely
2167     // all be wrong, but since toBlockFlow is already marked for layout, this
2168     // will get fixed before anything gets displayed.
2169     // See bug https://bugs.webkit.org/show_bug.cgi?id=115566
2170     if (!m_floatingObjects)
2171         return;
2172 
2173     if (!toBlockFlow.m_floatingObjects)
2174         toBlockFlow.createFloatingObjects();
2175 
2176     for (auto&amp; floatingObject : m_floatingObjects-&gt;set()) {
2177         if (toBlockFlow.containsFloat(floatingObject-&gt;renderer()))
2178             continue;
2179         toBlockFlow.m_floatingObjects-&gt;add(floatingObject-&gt;cloneForNewParent());
2180     }
2181 }
2182 
2183 void RenderBlockFlow::addOverflowFromFloats()
2184 {
2185     if (!m_floatingObjects)
2186         return;
2187 
2188     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2189     auto end = floatingObjectSet.end();
2190     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2191         const auto&amp; floatingObject = *it-&gt;get();
2192         if (floatingObject.isDescendant())
2193             addOverflowFromChild(&amp;floatingObject.renderer(), floatingObject.locationOffsetOfBorderBox());
2194     }
2195 }
2196 
2197 void RenderBlockFlow::computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeFloats)
2198 {
2199     RenderBlock::computeOverflow(oldClientAfterEdge, recomputeFloats);
2200 
2201     if (!multiColumnFlow() &amp;&amp; (recomputeFloats || createsNewFormattingContext() || hasSelfPaintingLayer()))
2202         addOverflowFromFloats();
2203 }
2204 
2205 void RenderBlockFlow::repaintOverhangingFloats(bool paintAllDescendants)
2206 {
2207     // Repaint any overhanging floats (if we know we&#39;re the one to paint them).
2208     // Otherwise, bail out.
2209     if (!hasOverhangingFloats())
2210         return;
2211 
2212     // FIXME: Avoid disabling LayoutState. At the very least, don&#39;t disable it for floats originating
2213     // in this block. Better yet would be to push extra state for the containers of other floats.
2214     LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext());
2215     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2216     auto end = floatingObjectSet.end();
2217     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2218         const auto&amp; floatingObject = *it-&gt;get();
2219         // Only repaint the object if it is overhanging, is not in its own layer, and
2220         // is our responsibility to paint (m_shouldPaint is set). When paintAllDescendants is true, the latter
2221         // condition is replaced with being a descendant of us.
2222         auto&amp; renderer = floatingObject.renderer();
2223         if (logicalBottomForFloat(floatingObject) &gt; logicalHeight()
2224             &amp;&amp; !renderer.hasSelfPaintingLayer()
2225             &amp;&amp; (floatingObject.shouldPaint() || (paintAllDescendants &amp;&amp; renderer.isDescendantOf(this)))) {
2226             renderer.repaint();
2227             renderer.repaintOverhangingFloats(false);
2228         }
2229     }
2230 }
2231 
2232 void RenderBlockFlow::paintColumnRules(PaintInfo&amp; paintInfo, const LayoutPoint&amp; point)
2233 {
2234     RenderBlock::paintColumnRules(paintInfo, point);
2235 
2236     if (!multiColumnFlow() || paintInfo.context().paintingDisabled())
2237         return;
2238 
2239     // Iterate over our children and paint the column rules as needed.
2240     for (auto&amp; columnSet : childrenOfType&lt;RenderMultiColumnSet&gt;(*this)) {
2241         LayoutPoint childPoint = columnSet.location() + flipForWritingModeForChild(&amp;columnSet, point);
2242         columnSet.paintColumnRules(paintInfo, childPoint);
2243     }
2244 }
2245 
2246 void RenderBlockFlow::paintFloats(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, bool preservePhase)
2247 {
2248     if (!m_floatingObjects)
2249         return;
2250 
2251     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2252     auto end = floatingObjectSet.end();
2253     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2254         const auto&amp; floatingObject = *it-&gt;get();
2255         auto&amp; renderer = floatingObject.renderer();
2256         // Only paint the object if our m_shouldPaint flag is set.
2257         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2258             PaintInfo currentPaintInfo(paintInfo);
2259             currentPaintInfo.phase = preservePhase ? paintInfo.phase : PaintPhase::BlockBackground;
2260             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, paintOffset + floatingObject.translationOffsetToAncestor());
2261             renderer.paint(currentPaintInfo, childPoint);
2262             if (!preservePhase) {
2263                 currentPaintInfo.phase = PaintPhase::ChildBlockBackgrounds;
2264                 renderer.paint(currentPaintInfo, childPoint);
2265                 currentPaintInfo.phase = PaintPhase::Float;
2266                 renderer.paint(currentPaintInfo, childPoint);
2267                 currentPaintInfo.phase = PaintPhase::Foreground;
2268                 renderer.paint(currentPaintInfo, childPoint);
2269                 currentPaintInfo.phase = PaintPhase::Outline;
2270                 renderer.paint(currentPaintInfo, childPoint);
2271             }
2272         }
2273     }
2274 }
2275 
2276 void RenderBlockFlow::clipOutFloatingObjects(RenderBlock&amp; rootBlock, const PaintInfo* paintInfo, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock)
2277 {
2278     if (m_floatingObjects) {
2279         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2280         auto end = floatingObjectSet.end();
2281         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2282             const auto&amp; floatingObject = *it-&gt;get();
2283             LayoutRect floatBox(offsetFromRootBlock.width(), offsetFromRootBlock.height(), floatingObject.renderer().width(), floatingObject.renderer().height());
2284             floatBox.move(floatingObject.locationOffsetOfBorderBox());
2285             rootBlock.flipForWritingMode(floatBox);
2286             floatBox.move(rootBlockPhysicalPosition.x(), rootBlockPhysicalPosition.y());
2287             paintInfo-&gt;context().clipOut(snappedIntRect(floatBox));
2288         }
2289     }
2290 }
2291 
2292 void RenderBlockFlow::createFloatingObjects()
2293 {
2294     m_floatingObjects = makeUnique&lt;FloatingObjects&gt;(*this);
2295 }
2296 
2297 void RenderBlockFlow::removeFloatingObjects()
2298 {
2299     if (!m_floatingObjects)
2300         return;
2301 
2302     markSiblingsWithFloatsForLayout();
2303 
2304     m_floatingObjects-&gt;clear();
2305 }
2306 
2307 FloatingObject* RenderBlockFlow::insertFloatingObject(RenderBox&amp; floatBox)
2308 {
2309     ASSERT(floatBox.isFloating());
2310 
2311     // Create the list of special objects if we don&#39;t aleady have one
2312     if (!m_floatingObjects)
2313         createFloatingObjects();
2314     else {
2315         // Don&#39;t insert the floatingObject again if it&#39;s already in the list
2316         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2317         auto it = floatingObjectSet.find&lt;FloatingObjectHashTranslator&gt;(floatBox);
2318         if (it != floatingObjectSet.end())
2319             return it-&gt;get();
2320     }
2321 
2322     // Create the special floatingObject entry &amp; append it to the list
2323 
2324     std::unique_ptr&lt;FloatingObject&gt; floatingObject = FloatingObject::create(floatBox);
2325 
2326     // Our location is irrelevant if we&#39;re unsplittable or no pagination is in effect. Just lay out the float.
2327     bool isChildRenderBlock = floatBox.isRenderBlock();
2328     if (isChildRenderBlock &amp;&amp; !floatBox.needsLayout() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;pageLogicalHeightChanged())
2329         floatBox.setChildNeedsLayout(MarkOnlyThis);
2330 
2331     bool needsBlockDirectionLocationSetBeforeLayout = isChildRenderBlock &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;needsBlockDirectionLocationSetBeforeLayout();
2332     if (!needsBlockDirectionLocationSetBeforeLayout || isWritingModeRoot()) {
2333         // We are unsplittable if we&#39;re a block flow root.
2334         floatBox.layoutIfNeeded();
2335         floatingObject-&gt;setShouldPaint(!floatBox.hasSelfPaintingLayer());
2336     }
2337     else {
2338         floatBox.updateLogicalWidth();
2339         floatBox.computeAndSetBlockDirectionMargins(*this);
2340     }
2341 
2342     setLogicalWidthForFloat(*floatingObject, logicalWidthForChild(floatBox) + marginStartForChild(floatBox) + marginEndForChild(floatBox));
2343 
2344     return m_floatingObjects-&gt;add(WTFMove(floatingObject));
2345 }
2346 
2347 void RenderBlockFlow::removeFloatingObject(RenderBox&amp; floatBox)
2348 {
2349     if (m_floatingObjects) {
2350         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2351         auto it = floatingObjectSet.find&lt;FloatingObjectHashTranslator&gt;(floatBox);
2352         if (it != floatingObjectSet.end()) {
2353             auto&amp; floatingObject = *it-&gt;get();
2354             if (childrenInline()) {
2355                 LayoutUnit logicalTop = logicalTopForFloat(floatingObject);
2356                 LayoutUnit logicalBottom = logicalBottomForFloat(floatingObject);
2357 
2358                 // Fix for https://bugs.webkit.org/show_bug.cgi?id=54995.
2359                 if (logicalBottom &lt; 0 || logicalBottom &lt; logicalTop || logicalTop == LayoutUnit::max())
2360                     logicalBottom = LayoutUnit::max();
2361                 else {
2362                     // Special-case zero- and less-than-zero-height floats: those don&#39;t touch
2363                     // the line that they&#39;re on, but it still needs to be dirtied. This is
2364                     // accomplished by pretending they have a height of 1.
2365                     logicalBottom = std::max(logicalBottom, logicalTop + 1);
2366                 }
2367                 if (floatingObject.originatingLine()) {
2368                     floatingObject.originatingLine()-&gt;removeFloat(floatBox);
2369                     if (!selfNeedsLayout()) {
2370                         ASSERT(&amp;floatingObject.originatingLine()-&gt;renderer() == this);
2371                         floatingObject.originatingLine()-&gt;markDirty();
2372                     }
2373 #if ASSERT_ENABLED
2374                     floatingObject.clearOriginatingLine();
2375 #endif
2376                 }
2377                 markLinesDirtyInBlockRange(0, logicalBottom);
2378             }
2379             m_floatingObjects-&gt;remove(&amp;floatingObject);
2380         }
2381     }
2382 }
2383 
2384 void RenderBlockFlow::removeFloatingObjectsBelow(FloatingObject* lastFloat, int logicalOffset)
2385 {
2386     if (!containsFloats())
2387         return;
2388 
2389     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2390     FloatingObject* curr = floatingObjectSet.last().get();
2391     while (curr != lastFloat &amp;&amp; (!curr-&gt;isPlaced() || logicalTopForFloat(*curr) &gt;= logicalOffset)) {
2392         m_floatingObjects-&gt;remove(curr);
2393         if (floatingObjectSet.isEmpty())
2394             break;
2395         curr = floatingObjectSet.last().get();
2396     }
2397 }
2398 
2399 LayoutUnit RenderBlockFlow::logicalLeftOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const
2400 {
2401     LayoutUnit offset = fixedOffset;
2402     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasLeftObjects())
2403         offset = m_floatingObjects-&gt;logicalLeftOffsetForPositioningFloat(fixedOffset, logicalTop, heightRemaining);
2404     return adjustLogicalLeftOffsetForLine(offset, applyTextIndent);
2405 }
2406 
2407 LayoutUnit RenderBlockFlow::logicalRightOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const
2408 {
2409     LayoutUnit offset = fixedOffset;
2410     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasRightObjects())
2411         offset = m_floatingObjects-&gt;logicalRightOffsetForPositioningFloat(fixedOffset, logicalTop, heightRemaining);
2412     return adjustLogicalRightOffsetForLine(offset, applyTextIndent);
2413 }
2414 
2415 void RenderBlockFlow::computeLogicalLocationForFloat(FloatingObject&amp; floatingObject, LayoutUnit&amp; logicalTopOffset)
2416 {
2417     auto&amp; childBox = floatingObject.renderer();
2418     LayoutUnit logicalLeftOffset = logicalLeftOffsetForContent(logicalTopOffset); // Constant part of left offset.
2419     LayoutUnit logicalRightOffset = logicalRightOffsetForContent(logicalTopOffset); // Constant part of right offset.
2420 
2421     LayoutUnit floatLogicalWidth = std::min(logicalWidthForFloat(floatingObject), logicalRightOffset - logicalLeftOffset); // The width we look for.
2422 
2423     LayoutUnit floatLogicalLeft;
2424 
2425     bool insideFragmentedFlow = enclosingFragmentedFlow();
2426     bool isInitialLetter = childBox.style().styleType() == PseudoId::FirstLetter &amp;&amp; childBox.style().initialLetterDrop() &gt; 0;
2427 
2428     if (isInitialLetter) {
2429         int letterClearance = lowestInitialLetterLogicalBottom() - logicalTopOffset;
2430         if (letterClearance &gt; 0) {
2431             logicalTopOffset += letterClearance;
2432             setLogicalHeight(logicalHeight() + letterClearance);
2433         }
2434     }
2435 
2436     if (childBox.style().floating() == Float::Left) {
2437         LayoutUnit heightRemainingLeft = 1_lu;
2438         LayoutUnit heightRemainingRight = 1_lu;
2439         floatLogicalLeft = logicalLeftOffsetForPositioningFloat(logicalTopOffset, logicalLeftOffset, false, &amp;heightRemainingLeft);
2440         while (logicalRightOffsetForPositioningFloat(logicalTopOffset, logicalRightOffset, false, &amp;heightRemainingRight) - floatLogicalLeft &lt; floatLogicalWidth) {
2441             logicalTopOffset += std::min(heightRemainingLeft, heightRemainingRight);
2442             floatLogicalLeft = logicalLeftOffsetForPositioningFloat(logicalTopOffset, logicalLeftOffset, false, &amp;heightRemainingLeft);
2443             if (insideFragmentedFlow) {
2444                 // Have to re-evaluate all of our offsets, since they may have changed.
2445                 logicalRightOffset = logicalRightOffsetForContent(logicalTopOffset); // Constant part of right offset.
2446                 logicalLeftOffset = logicalLeftOffsetForContent(logicalTopOffset); // Constant part of left offset.
2447                 floatLogicalWidth = std::min(logicalWidthForFloat(floatingObject), logicalRightOffset - logicalLeftOffset);
2448             }
2449         }
2450         floatLogicalLeft = std::max(logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);
2451     } else {
2452         LayoutUnit heightRemainingLeft = 1_lu;
2453         LayoutUnit heightRemainingRight = 1_lu;
2454         floatLogicalLeft = logicalRightOffsetForPositioningFloat(logicalTopOffset, logicalRightOffset, false, &amp;heightRemainingRight);
2455         while (floatLogicalLeft - logicalLeftOffsetForPositioningFloat(logicalTopOffset, logicalLeftOffset, false, &amp;heightRemainingLeft) &lt; floatLogicalWidth) {
2456             logicalTopOffset += std::min(heightRemainingLeft, heightRemainingRight);
2457             floatLogicalLeft = logicalRightOffsetForPositioningFloat(logicalTopOffset, logicalRightOffset, false, &amp;heightRemainingRight);
2458             if (insideFragmentedFlow) {
2459                 // Have to re-evaluate all of our offsets, since they may have changed.
2460                 logicalRightOffset = logicalRightOffsetForContent(logicalTopOffset); // Constant part of right offset.
2461                 logicalLeftOffset = logicalLeftOffsetForContent(logicalTopOffset); // Constant part of left offset.
2462                 floatLogicalWidth = std::min(logicalWidthForFloat(floatingObject), logicalRightOffset - logicalLeftOffset);
2463             }
2464         }
2465         // Use the original width of the float here, since the local variable
2466         // |floatLogicalWidth| was capped to the available line width. See
2467         // fast/block/float/clamped-right-float.html.
2468         floatLogicalLeft -= logicalWidthForFloat(floatingObject);
2469     }
2470 
2471     LayoutUnit childLogicalLeftMargin = style().isLeftToRightDirection() ? marginStartForChild(childBox) : marginEndForChild(childBox);
2472     LayoutUnit childBeforeMargin = marginBeforeForChild(childBox);
2473 
2474     if (isInitialLetter)
2475         adjustInitialLetterPosition(childBox, logicalTopOffset, childBeforeMargin);
2476 
2477     setLogicalLeftForFloat(floatingObject, floatLogicalLeft);
2478     setLogicalLeftForChild(childBox, floatLogicalLeft + childLogicalLeftMargin);
2479 
2480     setLogicalTopForFloat(floatingObject, logicalTopOffset);
2481     setLogicalTopForChild(childBox, logicalTopOffset + childBeforeMargin);
2482 
2483     setLogicalMarginsForFloat(floatingObject, childLogicalLeftMargin, childBeforeMargin);
2484 }
2485 
2486 void RenderBlockFlow::adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset)
2487 {
2488     const RenderStyle&amp; style = firstLineStyle();
2489     const FontMetrics&amp; fontMetrics = style.fontMetrics();
2490     if (!fontMetrics.hasCapHeight())
2491         return;
2492 
2493     LayoutUnit heightOfLine = lineHeight(true, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
2494     LayoutUnit beforeMarginBorderPadding = childBox.borderAndPaddingBefore() + childBox.marginBefore();
2495 
2496     // Make an adjustment to align with the cap height of a theoretical block line.
2497     LayoutUnit adjustment = fontMetrics.ascent() + (heightOfLine - fontMetrics.height()) / 2 - fontMetrics.capHeight() - beforeMarginBorderPadding;
2498     logicalTopOffset += adjustment;
2499 
2500     // For sunken and raised caps, we have to make some adjustments. Test if we&#39;re sunken or raised (dropHeightDelta will be
2501     // positive for raised and negative for sunken).
2502     int dropHeightDelta = childBox.style().initialLetterHeight() - childBox.style().initialLetterDrop();
2503 
2504     // If we&#39;re sunken, the float needs to shift down but lines still need to avoid it. In order to do that we increase the float&#39;s margin.
2505     if (dropHeightDelta &lt; 0)
2506         marginBeforeOffset += -dropHeightDelta * heightOfLine;
2507 
2508     // If we&#39;re raised, then we actually have to grow the height of the block, since the lines have to be pushed down as though we&#39;re placing
2509     // empty lines beside the first letter.
2510     if (dropHeightDelta &gt; 0)
2511         setLogicalHeight(logicalHeight() + dropHeightDelta * heightOfLine);
2512 }
2513 
2514 bool RenderBlockFlow::positionNewFloats()
2515 {
2516     if (!m_floatingObjects)
2517         return false;
2518 
2519     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2520     if (floatingObjectSet.isEmpty())
2521         return false;
2522 
2523     // If all floats have already been positioned, then we have no work to do.
2524     if (floatingObjectSet.last()-&gt;isPlaced())
2525         return false;
2526 
2527     // Move backwards through our floating object list until we find a float that has
2528     // already been positioned. Then we&#39;ll be able to move forward, positioning all of
2529     // the new floats that need it.
2530     auto it = floatingObjectSet.end();
2531     --it; // Go to last item.
2532     auto begin = floatingObjectSet.begin();
2533     FloatingObject* lastPlacedFloatingObject = 0;
2534     while (it != begin) {
2535         --it;
2536         if ((*it)-&gt;isPlaced()) {
2537             lastPlacedFloatingObject = it-&gt;get();
2538             ++it;
2539             break;
2540         }
2541     }
2542 
2543     LayoutUnit logicalTop = logicalHeight();
2544 
2545     // The float cannot start above the top position of the last positioned float.
2546     if (lastPlacedFloatingObject)
2547         logicalTop = std::max(logicalTopForFloat(*lastPlacedFloatingObject), logicalTop);
2548 
2549     auto end = floatingObjectSet.end();
2550     // Now walk through the set of unpositioned floats and place them.
2551     for (; it != end; ++it) {
2552         auto&amp; floatingObject = *it-&gt;get();
2553         // The containing block is responsible for positioning floats, so if we have floats in our
2554         // list that come from somewhere else, do not attempt to position them.
2555         auto&amp; childBox = floatingObject.renderer();
2556         if (childBox.containingBlock() != this)
2557             continue;
2558 
2559         LayoutRect oldRect = childBox.frameRect();
2560 
2561         if (childBox.style().clear() == Clear::Left || childBox.style().clear() == Clear::Both)
2562             logicalTop = std::max(lowestFloatLogicalBottom(FloatingObject::FloatLeft), logicalTop);
2563         if (childBox.style().clear() == Clear::Right || childBox.style().clear() == Clear::Both)
2564             logicalTop = std::max(lowestFloatLogicalBottom(FloatingObject::FloatRight), logicalTop);
2565 
2566         computeLogicalLocationForFloat(floatingObject, logicalTop);
2567         LayoutUnit childLogicalTop = logicalTopForChild(childBox);
2568 
2569         estimateFragmentRangeForBoxChild(childBox);
2570 
2571         childBox.markForPaginationRelayoutIfNeeded();
2572         childBox.layoutIfNeeded();
2573 
2574         auto* layoutState = view().frameView().layoutContext().layoutState();
2575         bool isPaginated = layoutState-&gt;isPaginated();
2576         if (isPaginated) {
2577             // If we are unsplittable and don&#39;t fit, then we need to move down.
2578             // We include our margins as part of the unsplittable area.
2579             LayoutUnit newLogicalTop = adjustForUnsplittableChild(childBox, logicalTop, childLogicalTop - logicalTop, marginAfterForChild(childBox));
2580 
2581             // See if we have a pagination strut that is making us move down further.
2582             // Note that an unsplittable child can&#39;t also have a pagination strut, so this
2583             // is exclusive with the case above.
2584             RenderBlock* childBlock = is&lt;RenderBlock&gt;(childBox) ? &amp;downcast&lt;RenderBlock&gt;(childBox) : nullptr;
2585             if (childBlock &amp;&amp; childBlock-&gt;paginationStrut()) {
2586                 newLogicalTop += childBlock-&gt;paginationStrut();
2587                 childBlock-&gt;setPaginationStrut(0);
2588             }
2589 
2590             if (newLogicalTop != logicalTop) {
2591                 floatingObject.setPaginationStrut(newLogicalTop - logicalTop);
2592                 computeLogicalLocationForFloat(floatingObject, newLogicalTop);
2593                 if (childBlock)
2594                     childBlock-&gt;setChildNeedsLayout(MarkOnlyThis);
2595                 childBox.layoutIfNeeded();
2596                 logicalTop = newLogicalTop;
2597             }
2598 
2599             if (updateFragmentRangeForBoxChild(childBox)) {
2600                 childBox.setNeedsLayout(MarkOnlyThis);
2601                 childBox.layoutIfNeeded();
2602             }
2603         }
2604 
2605         setLogicalHeightForFloat(floatingObject, logicalHeightForChildForFragmentation(childBox) + (logicalTopForChild(childBox) - logicalTop) + marginAfterForChild(childBox));
2606 
2607         m_floatingObjects-&gt;addPlacedObject(&amp;floatingObject);
2608 
2609         if (ShapeOutsideInfo* shapeOutside = childBox.shapeOutsideInfo())
2610             shapeOutside-&gt;setReferenceBoxLogicalSize(logicalSizeForChild(childBox));
2611         // If the child moved, we have to repaint it.
2612         if (childBox.checkForRepaintDuringLayout())
2613             childBox.repaintDuringLayoutIfMoved(oldRect);
2614     }
2615     return true;
2616 }
2617 
2618 void RenderBlockFlow::clearFloats(Clear clear)
2619 {
2620     positionNewFloats();
2621     // set y position
2622     LayoutUnit newY;
2623     switch (clear) {
2624     case Clear::Left:
2625         newY = lowestFloatLogicalBottom(FloatingObject::FloatLeft);
2626         break;
2627     case Clear::Right:
2628         newY = lowestFloatLogicalBottom(FloatingObject::FloatRight);
2629         break;
2630     case Clear::Both:
2631         newY = lowestFloatLogicalBottom();
2632         break;
2633     case Clear::None:
2634         break;
2635     }
2636     if (height() &lt; newY)
2637         setLogicalHeight(newY);
2638 }
2639 
2640 LayoutUnit RenderBlockFlow::logicalLeftFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const
2641 {
2642     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasLeftObjects())
2643         return m_floatingObjects-&gt;logicalLeftOffset(fixedOffset, logicalTop, logicalHeight);
2644 
2645     return fixedOffset;
2646 }
2647 
2648 LayoutUnit RenderBlockFlow::logicalRightFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const
2649 {
2650     if (m_floatingObjects &amp;&amp; m_floatingObjects-&gt;hasRightObjects())
2651         return m_floatingObjects-&gt;logicalRightOffset(fixedOffset, logicalTop, logicalHeight);
2652 
2653     return fixedOffset;
2654 }
2655 
2656 LayoutUnit RenderBlockFlow::nextFloatLogicalBottomBelow(LayoutUnit logicalHeight) const
2657 {
2658     if (!m_floatingObjects)
2659         return logicalHeight;
2660 
2661     return m_floatingObjects-&gt;findNextFloatLogicalBottomBelow(logicalHeight);
2662 }
2663 
2664 LayoutUnit RenderBlockFlow::nextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight) const
2665 {
2666     if (!m_floatingObjects)
2667         return logicalHeight;
2668 
2669     return m_floatingObjects-&gt;findNextFloatLogicalBottomBelowForBlock(logicalHeight);
2670 }
2671 
2672 LayoutUnit RenderBlockFlow::lowestFloatLogicalBottom(FloatingObject::Type floatType) const
2673 {
2674     if (!m_floatingObjects)
2675         return 0;
2676     LayoutUnit lowestFloatBottom;
2677     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2678     auto end = floatingObjectSet.end();
2679     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2680         const auto&amp; floatingObject = *it-&gt;get();
2681         if (floatingObject.isPlaced() &amp;&amp; floatingObject.type() &amp; floatType)
2682             lowestFloatBottom = std::max(lowestFloatBottom, logicalBottomForFloat(floatingObject));
2683     }
2684     return lowestFloatBottom;
2685 }
2686 
2687 LayoutUnit RenderBlockFlow::lowestInitialLetterLogicalBottom() const
2688 {
2689     if (!m_floatingObjects)
2690         return 0;
2691     LayoutUnit lowestFloatBottom;
2692     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2693     auto end = floatingObjectSet.end();
2694     for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2695         const auto&amp; floatingObject = *it-&gt;get();
2696         if (floatingObject.isPlaced() &amp;&amp; floatingObject.renderer().style().styleType() == PseudoId::FirstLetter &amp;&amp; floatingObject.renderer().style().initialLetterDrop() &gt; 0)
2697             lowestFloatBottom = std::max(lowestFloatBottom, logicalBottomForFloat(floatingObject));
2698     }
2699     return lowestFloatBottom;
2700 }
2701 
2702 LayoutUnit RenderBlockFlow::addOverhangingFloats(RenderBlockFlow&amp; child, bool makeChildPaintOtherFloats)
2703 {
2704     // Prevent floats from being added to the canvas by the root element, e.g., &lt;html&gt;.
2705     if (!child.containsFloats() || child.createsNewFormattingContext())
2706         return 0;
2707 
2708     LayoutUnit childLogicalTop = child.logicalTop();
2709     LayoutUnit childLogicalLeft = child.logicalLeft();
2710     LayoutUnit lowestFloatLogicalBottom;
2711 
2712     // Floats that will remain the child&#39;s responsibility to paint should factor into its
2713     // overflow.
2714     auto childEnd = child.m_floatingObjects-&gt;set().end();
2715     for (auto childIt = child.m_floatingObjects-&gt;set().begin(); childIt != childEnd; ++childIt) {
2716         auto&amp; floatingObject = *childIt-&gt;get();
2717         LayoutUnit floatLogicalBottom = std::min(logicalBottomForFloat(floatingObject), LayoutUnit::max() - childLogicalTop);
2718         LayoutUnit logicalBottom = childLogicalTop + floatLogicalBottom;
2719         lowestFloatLogicalBottom = std::max(lowestFloatLogicalBottom, logicalBottom);
2720 
2721         if (logicalBottom &gt; logicalHeight()) {
2722             // If the object is not in the list, we add it now.
2723             if (!containsFloat(floatingObject.renderer())) {
2724                 LayoutSize offset = isHorizontalWritingMode() ? LayoutSize(-childLogicalLeft, -childLogicalTop) : LayoutSize(-childLogicalTop, -childLogicalLeft);
2725                 bool shouldPaint = false;
2726 
2727                 // The nearest enclosing layer always paints the float (so that zindex and stacking
2728                 // behaves properly). We always want to propagate the desire to paint the float as
2729                 // far out as we can, to the outermost block that overlaps the float, stopping only
2730                 // if we hit a self-painting layer boundary.
2731                 if (floatingObject.renderer().enclosingFloatPaintingLayer() == enclosingFloatPaintingLayer()) {
2732                     floatingObject.setShouldPaint(false);
2733                     shouldPaint = true;
2734                 }
2735                 // We create the floating object list lazily.
2736                 if (!m_floatingObjects)
2737                     createFloatingObjects();
2738 
2739                 m_floatingObjects-&gt;add(floatingObject.copyToNewContainer(offset, shouldPaint, true));
2740             }
2741         } else {
2742             const auto&amp; renderer = floatingObject.renderer();
2743             if (makeChildPaintOtherFloats &amp;&amp; !floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()
2744                 &amp;&amp; renderer.isDescendantOf(&amp;child) &amp;&amp; renderer.enclosingFloatPaintingLayer() == child.enclosingFloatPaintingLayer()) {
2745                 // The float is not overhanging from this block, so if it is a descendant of the child, the child should
2746                 // paint it (the other case is that it is intruding into the child), unless it has its own layer or enclosing
2747                 // layer.
2748                 // If makeChildPaintOtherFloats is false, it means that the child must already know about all the floats
2749                 // it should paint.
2750                 floatingObject.setShouldPaint(true);
2751             }
2752 
2753             // Since the float doesn&#39;t overhang, it didn&#39;t get put into our list. We need to add its overflow in to the child now.
2754             if (floatingObject.isDescendant())
2755                 child.addOverflowFromChild(&amp;renderer, floatingObject.locationOffsetOfBorderBox());
2756         }
2757     }
2758     return lowestFloatLogicalBottom;
2759 }
2760 
2761 bool RenderBlockFlow::hasOverhangingFloat(RenderBox&amp; renderer)
2762 {
2763     if (!m_floatingObjects || !parent())
2764         return false;
2765 
2766     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2767     const auto it = floatingObjectSet.find&lt;FloatingObjectHashTranslator&gt;(renderer);
2768     if (it == floatingObjectSet.end())
2769         return false;
2770 
2771     return logicalBottomForFloat(*it-&gt;get()) &gt; logicalHeight();
2772 }
2773 
2774 void RenderBlockFlow::addIntrudingFloats(RenderBlockFlow* prev, RenderBlockFlow* container, LayoutUnit logicalLeftOffset, LayoutUnit logicalTopOffset)
2775 {
2776     ASSERT(!avoidsFloats());
2777 
2778     // If we create our own block formatting context then our contents don&#39;t interact with floats outside it, even those from our parent.
2779     if (createsNewFormattingContext())
2780         return;
2781 
2782     // If the parent or previous sibling doesn&#39;t have any floats to add, don&#39;t bother.
2783     if (!prev-&gt;m_floatingObjects)
2784         return;
2785 
2786     logicalLeftOffset += marginLogicalLeft();
2787 
2788     const FloatingObjectSet&amp; prevSet = prev-&gt;m_floatingObjects-&gt;set();
2789     auto prevEnd = prevSet.end();
2790     for (auto prevIt = prevSet.begin(); prevIt != prevEnd; ++prevIt) {
2791         auto&amp; floatingObject = *prevIt-&gt;get();
2792         if (logicalBottomForFloat(floatingObject) &gt; logicalTopOffset) {
2793             if (!m_floatingObjects || !m_floatingObjects-&gt;set().contains(&amp;floatingObject)) {
2794                 // We create the floating object list lazily.
2795                 if (!m_floatingObjects)
2796                     createFloatingObjects();
2797 
2798                 // Applying the child&#39;s margin makes no sense in the case where the child was passed in.
2799                 // since this margin was added already through the modification of the |logicalLeftOffset| variable
2800                 // above. |logicalLeftOffset| will equal the margin in this case, so it&#39;s already been taken
2801                 // into account. Only apply this code if prev is the parent, since otherwise the left margin
2802                 // will get applied twice.
2803                 LayoutSize offset = isHorizontalWritingMode()
2804                     ? LayoutSize(logicalLeftOffset - (prev != container ? prev-&gt;marginLeft() : 0_lu), logicalTopOffset)
2805                     : LayoutSize(logicalTopOffset, logicalLeftOffset - (prev != container ? prev-&gt;marginTop() : 0_lu));
2806 
2807                 m_floatingObjects-&gt;add(floatingObject.copyToNewContainer(offset));
2808             }
2809         }
2810     }
2811 }
2812 
2813 void RenderBlockFlow::markAllDescendantsWithFloatsForLayout(RenderBox* floatToRemove, bool inLayout)
2814 {
2815     if (!everHadLayout() &amp;&amp; !containsFloats())
2816         return;
2817 
2818     MarkingBehavior markParents = inLayout ? MarkOnlyThis : MarkContainingBlockChain;
2819     setChildNeedsLayout(markParents);
2820 
2821     if (floatToRemove)
2822         removeFloatingObject(*floatToRemove);
2823     else if (childrenInline())
2824         return;
2825 
2826     // Iterate over our block children and mark them as needed.
2827     for (auto&amp; block : childrenOfType&lt;RenderBlock&gt;(*this)) {
2828         if (!floatToRemove &amp;&amp; block.isFloatingOrOutOfFlowPositioned())
2829             continue;
2830         if (!is&lt;RenderBlockFlow&gt;(block)) {
2831             if (block.shrinkToAvoidFloats() &amp;&amp; block.everHadLayout())
2832                 block.setChildNeedsLayout(markParents);
2833             continue;
2834         }
2835         auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(block);
2836         if ((floatToRemove ? blockFlow.containsFloat(*floatToRemove) : blockFlow.containsFloats()) || blockFlow.shrinkToAvoidFloats())
2837             blockFlow.markAllDescendantsWithFloatsForLayout(floatToRemove, inLayout);
2838     }
2839 }
2840 
2841 void RenderBlockFlow::markSiblingsWithFloatsForLayout(RenderBox* floatToRemove)
2842 {
2843     if (!m_floatingObjects)
2844         return;
2845 
2846     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2847     auto end = floatingObjectSet.end();
2848 
2849     for (RenderObject* next = nextSibling(); next; next = next-&gt;nextSibling()) {
2850         if (!is&lt;RenderBlockFlow&gt;(*next) || next-&gt;isFloatingOrOutOfFlowPositioned())
2851             continue;
2852 
2853         RenderBlockFlow&amp; nextBlock = downcast&lt;RenderBlockFlow&gt;(*next);
2854         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
2855             RenderBox&amp; floatingBox = (*it)-&gt;renderer();
2856             if (floatToRemove &amp;&amp; &amp;floatingBox != floatToRemove)
2857                 continue;
2858             if (nextBlock.containsFloat(floatingBox))
2859                 nextBlock.markAllDescendantsWithFloatsForLayout(&amp;floatingBox);
2860         }
2861     }
2862 }
2863 
2864 LayoutPoint RenderBlockFlow::flipFloatForWritingModeForChild(const FloatingObject&amp; child, const LayoutPoint&amp; point) const
2865 {
2866     if (!style().isFlippedBlocksWritingMode())
2867         return point;
2868 
2869     // This is similar to RenderBox::flipForWritingModeForChild. We have to subtract out our left/top offsets twice, since
2870     // it&#39;s going to get added back in. We hide this complication here so that the calling code looks normal for the unflipped
2871     // case.
2872     if (isHorizontalWritingMode())
2873         return LayoutPoint(point.x(), point.y() + height() - child.renderer().height() - 2 * child.locationOffsetOfBorderBox().height());
2874     return LayoutPoint(point.x() + width() - child.renderer().width() - 2 * child.locationOffsetOfBorderBox().width(), point.y());
2875 }
2876 
2877 LayoutUnit RenderBlockFlow::getClearDelta(RenderBox&amp; child, LayoutUnit logicalTop)
2878 {
2879     // There is no need to compute clearance if we have no floats.
2880     if (!containsFloats())
2881         return 0;
2882 
2883     // At least one float is present. We need to perform the clearance computation.
2884     bool clearSet = child.style().clear() != Clear::None;
2885     LayoutUnit logicalBottom;
2886     switch (child.style().clear()) {
2887     case Clear::None:
2888         break;
2889     case Clear::Left:
2890         logicalBottom = lowestFloatLogicalBottom(FloatingObject::FloatLeft);
2891         break;
2892     case Clear::Right:
2893         logicalBottom = lowestFloatLogicalBottom(FloatingObject::FloatRight);
2894         break;
2895     case Clear::Both:
2896         logicalBottom = lowestFloatLogicalBottom();
2897         break;
2898     }
2899 
2900     // We also clear floats if we are too big to sit on the same line as a float (and wish to avoid floats by default).
2901     LayoutUnit result = clearSet ? std::max&lt;LayoutUnit&gt;(0, logicalBottom - logicalTop) : 0_lu;
2902     if (!result &amp;&amp; child.avoidsFloats()) {
2903         LayoutUnit newLogicalTop = logicalTop;
2904         while (true) {
2905             LayoutUnit availableLogicalWidthAtNewLogicalTopOffset = availableLogicalWidthForLine(newLogicalTop, DoNotIndentText, logicalHeightForChild(child));
2906             if (availableLogicalWidthAtNewLogicalTopOffset == availableLogicalWidthForContent(newLogicalTop))
2907                 return newLogicalTop - logicalTop;
2908 
2909             RenderFragmentContainer* fragment = fragmentAtBlockOffset(logicalTopForChild(child));
2910             LayoutRect borderBox = child.borderBoxRectInFragment(fragment, DoNotCacheRenderBoxFragmentInfo);
2911             LayoutUnit childLogicalWidthAtOldLogicalTopOffset = isHorizontalWritingMode() ? borderBox.width() : borderBox.height();
2912 
2913             // FIXME: None of this is right for perpendicular writing-mode children.
2914             LayoutUnit childOldLogicalWidth = child.logicalWidth();
2915             LayoutUnit childOldMarginLeft = child.marginLeft();
2916             LayoutUnit childOldMarginRight = child.marginRight();
2917             LayoutUnit childOldLogicalTop = child.logicalTop();
2918 
2919             child.setLogicalTop(newLogicalTop);
2920             child.updateLogicalWidth();
2921             fragment = fragmentAtBlockOffset(logicalTopForChild(child));
2922             borderBox = child.borderBoxRectInFragment(fragment, DoNotCacheRenderBoxFragmentInfo);
2923             LayoutUnit childLogicalWidthAtNewLogicalTopOffset = isHorizontalWritingMode() ? borderBox.width() : borderBox.height();
2924 
2925             child.setLogicalTop(childOldLogicalTop);
2926             child.setLogicalWidth(childOldLogicalWidth);
2927             child.setMarginLeft(childOldMarginLeft);
2928             child.setMarginRight(childOldMarginRight);
2929 
2930             if (childLogicalWidthAtNewLogicalTopOffset &lt;= availableLogicalWidthAtNewLogicalTopOffset) {
2931                 // Even though we may not be moving, if the logical width did shrink because of the presence of new floats, then
2932                 // we need to force a relayout as though we shifted. This happens because of the dynamic addition of overhanging floats
2933                 // from previous siblings when negative margins exist on a child (see the addOverhangingFloats call at the end of collapseMargins).
2934                 if (childLogicalWidthAtOldLogicalTopOffset != childLogicalWidthAtNewLogicalTopOffset)
2935                     child.setChildNeedsLayout(MarkOnlyThis);
2936                 return newLogicalTop - logicalTop;
2937             }
2938 
2939             newLogicalTop = nextFloatLogicalBottomBelowForBlock(newLogicalTop);
2940             ASSERT(newLogicalTop &gt;= logicalTop);
2941             if (newLogicalTop &lt; logicalTop)
2942                 break;
2943         }
2944         ASSERT_NOT_REACHED();
2945     }
2946     return result;
2947 }
2948 
2949 bool RenderBlockFlow::hitTestFloats(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset)
2950 {
2951     if (!m_floatingObjects)
2952         return false;
2953 
2954     LayoutPoint adjustedLocation = accumulatedOffset;
2955     if (is&lt;RenderView&gt;(*this))
2956         adjustedLocation += toLayoutSize(downcast&lt;RenderView&gt;(*this).frameView().scrollPosition());
2957 
2958     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2959     auto begin = floatingObjectSet.begin();
2960     for (auto it = floatingObjectSet.end(); it != begin;) {
2961         --it;
2962         const auto&amp; floatingObject = *it-&gt;get();
2963         auto&amp; renderer = floatingObject.renderer();
2964         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2965             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + floatingObject.translationOffsetToAncestor());
2966             if (renderer.hitTest(request, result, locationInContainer, childPoint)) {
2967                 updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));
2968                 return true;
2969             }
2970         }
2971     }
2972 
2973     return false;
2974 }
2975 
2976 bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2977 {
2978     ASSERT(childrenInline());
2979 
2980     if (simpleLineLayout())
2981         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout(), request, result, locationInContainer, accumulatedOffset, hitTestAction);
2982 
2983 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
2984     if (layoutFormattingContextLineLayout())
2985         return layoutFormattingContextLineLayout()-&gt;hitTest(request, result, locationInContainer, accumulatedOffset, hitTestAction);
2986 #endif
2987 
2988     return complexLineLayout() &amp;&amp; complexLineLayout()-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);
2989 }
2990 
2991 void RenderBlockFlow::addOverflowFromInlineChildren()
2992 {
2993     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
2994         ASSERT(!hasOverflowClip());
2995         SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);
2996         return;
2997     }
2998 
2999 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3000     if (layoutFormattingContextLineLayout()) {
3001         layoutFormattingContextLineLayout()-&gt;collectOverflow(*this);
3002         return;
3003     }
3004 #endif
3005 
3006     if (complexLineLayout())
3007         complexLineLayout()-&gt;addOverflowFromInlineChildren();
3008 }
3009 
3010 void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
3011 {
3012     if (style().visibility() != Visibility::Visible)
3013         return;
3014 
3015     // We don&#39;t deal with relative positioning.  Our assumption is that you shrink to fit the lines without accounting
3016     // for either overflow or translations via relative positioning.
3017     if (childrenInline()) {
3018         const_cast&lt;RenderBlockFlow&amp;&gt;(*this).ensureLineBoxes();
3019 
3020         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3021             if (box-&gt;firstChild())
3022                 left = std::min(left, x + LayoutUnit(box-&gt;firstChild()-&gt;x()));
3023             if (box-&gt;lastChild())
3024                 right = std::max(right, x + LayoutUnit(ceilf(box-&gt;lastChild()-&gt;logicalRight())));
3025         }
3026     } else {
3027         for (RenderBox* obj = firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
3028             if (!obj-&gt;isFloatingOrOutOfFlowPositioned()) {
3029                 if (is&lt;RenderBlockFlow&gt;(*obj) &amp;&amp; !obj-&gt;hasOverflowClip())
3030                     downcast&lt;RenderBlockFlow&gt;(*obj).adjustForBorderFit(x + obj-&gt;x(), left, right);
3031                 else if (obj-&gt;style().visibility() == Visibility::Visible) {
3032                     // We are a replaced element or some kind of non-block-flow object.
3033                     left = std::min(left, x + obj-&gt;x());
3034                     right = std::max(right, x + obj-&gt;x() + obj-&gt;width());
3035                 }
3036             }
3037         }
3038     }
3039 
3040     if (m_floatingObjects) {
3041         const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
3042         auto end = floatingObjectSet.end();
3043         for (auto it = floatingObjectSet.begin(); it != end; ++it) {
3044             const auto&amp; floatingObject = *it-&gt;get();
3045             // Only examine the object if our m_shouldPaint flag is set.
3046             if (floatingObject.shouldPaint()) {
3047                 LayoutUnit floatLeft = floatingObject.translationOffsetToAncestor().width();
3048                 LayoutUnit floatRight = floatLeft + floatingObject.renderer().width();
3049                 left = std::min(left, floatLeft);
3050                 right = std::max(right, floatRight);
3051             }
3052         }
3053     }
3054 }
3055 
3056 void RenderBlockFlow::fitBorderToLinesIfNeeded()
3057 {
3058     if (style().borderFit() == BorderFit::Border || hasOverrideContentLogicalWidth())
3059         return;
3060 
3061     // Walk any normal flow lines to snugly fit.
3062     LayoutUnit left = LayoutUnit::max();
3063     LayoutUnit right = LayoutUnit::min();
3064     LayoutUnit oldWidth = contentWidth();
3065     adjustForBorderFit(0, left, right);
3066 
3067     // Clamp to our existing edges. We can never grow. We only shrink.
3068     LayoutUnit leftEdge = borderLeft() + paddingLeft();
3069     LayoutUnit rightEdge = leftEdge + oldWidth;
3070     left = std::min(rightEdge, std::max(leftEdge, left));
3071     right = std::max(leftEdge, std::min(rightEdge, right));
3072 
3073     LayoutUnit newContentWidth = right - left;
3074     if (newContentWidth == oldWidth)
3075         return;
3076 
3077     setOverrideContentLogicalWidth(newContentWidth);
3078     layoutBlock(false);
3079     clearOverrideContentLogicalWidth();
3080 }
3081 
3082 void RenderBlockFlow::markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest)
3083 {
3084     if (logicalTop &gt;= logicalBottom)
3085         return;
3086 
3087     // Floats currently affect the choice of layout path.
3088     if (simpleLineLayout()) {
3089         invalidateLineLayoutPath();
3090         return;
3091     }
3092 
3093 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3094     if (layoutFormattingContextLineLayout()) {
3095         invalidateLineLayoutPath();
3096         return;
3097     }
3098 #endif
3099 
3100     RootInlineBox* lowestDirtyLine = lastRootBox();
3101     RootInlineBox* afterLowest = lowestDirtyLine;
3102     while (lowestDirtyLine &amp;&amp; lowestDirtyLine-&gt;lineBottomWithLeading() &gt;= logicalBottom &amp;&amp; logicalBottom &lt; LayoutUnit::max()) {
3103         afterLowest = lowestDirtyLine;
3104         lowestDirtyLine = lowestDirtyLine-&gt;prevRootBox();
3105     }
3106 
3107     while (afterLowest &amp;&amp; afterLowest != highest &amp;&amp; (afterLowest-&gt;lineBottomWithLeading() &gt;= logicalTop || afterLowest-&gt;lineBottomWithLeading() &lt; 0)) {
3108         afterLowest-&gt;markDirty();
3109         afterLowest = afterLowest-&gt;prevRootBox();
3110     }
3111 }
3112 
3113 Optional&lt;int&gt; RenderBlockFlow::firstLineBaseline() const
3114 {
3115     if (isWritingModeRoot() &amp;&amp; !isRubyRun() &amp;&amp; !isGridItem())
3116         return WTF::nullopt;
3117 
3118     if (!childrenInline())
3119         return RenderBlock::firstLineBaseline();
3120 
3121     if (!hasLines())
3122         return WTF::nullopt;
3123 
3124 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3125     if (layoutFormattingContextLineLayout())
3126         return floorToInt(layoutFormattingContextLineLayout()-&gt;firstLineBaseline());
3127 #endif
3128 
3129     if (simpleLineLayout())
3130         return { SimpleLineLayout::computeFlowFirstLineBaseline(*this, *simpleLineLayout()) };
3131 
3132     ASSERT(firstRootBox());
3133     if (style().isFlippedLinesWritingMode())
3134         return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().descent(firstRootBox()-&gt;baselineType());
3135     return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().ascent(firstRootBox()-&gt;baselineType());
3136 }
3137 
3138 Optional&lt;int&gt; RenderBlockFlow::inlineBlockBaseline(LineDirectionMode lineDirection) const
3139 {
3140     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
3141         return WTF::nullopt;
3142 
3143     // Note that here we only take the left and bottom into consideration. Our caller takes the right and top into consideration.
3144     float boxHeight = lineDirection == HorizontalLine ? height() + m_marginBox.bottom() : width() + m_marginBox.left();
3145     float lastBaseline;
3146     if (!childrenInline()) {
3147         Optional&lt;int&gt; inlineBlockBaseline = RenderBlock::inlineBlockBaseline(lineDirection);
3148         if (!inlineBlockBaseline)
3149             return inlineBlockBaseline;
3150         lastBaseline = inlineBlockBaseline.value();
3151     } else {
3152         if (!hasLines()) {
3153             if (!hasLineIfEmpty())
3154                 return WTF::nullopt;
3155             const auto&amp; fontMetrics = firstLineStyle().fontMetrics();
3156             return Optional&lt;int&gt;(fontMetrics.ascent()
3157                 + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
3158                 + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
3159         }
3160 
3161         if (simpleLineLayout())
3162             lastBaseline = SimpleLineLayout::computeFlowLastLineBaseline(*this, *simpleLineLayout());
3163 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3164         else if (layoutFormattingContextLineLayout())
3165             lastBaseline = floorToInt(layoutFormattingContextLineLayout()-&gt;lastLineBaseline());
3166 #endif
3167         else {
3168             bool isFirstLine = lastRootBox() == firstRootBox();
3169             const auto&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
3170             // InlineFlowBox::placeBoxesInBlockDirection will flip lines in case of verticalLR mode, so we can assume verticalRL for now.
3171             lastBaseline = style.fontMetrics().ascent(lastRootBox()-&gt;baselineType())
3172                 + (style.isFlippedLinesWritingMode() ? logicalHeight() - lastRootBox()-&gt;logicalBottom() : lastRootBox()-&gt;logicalTop());
3173         }
3174     }
3175     // According to the CSS spec http://www.w3.org/TR/CSS21/visudet.html, we shouldn&#39;t be performing this min, but should
3176     // instead be returning boxHeight directly. However, we feel that a min here is better behavior (and is consistent
3177     // enough with the spec to not cause tons of breakages).
3178     return style().overflowY() == Overflow::Visible ? lastBaseline : std::min(boxHeight, lastBaseline);
3179 }
3180 
3181 void RenderBlockFlow::setSelectionState(SelectionState state)
3182 {
3183     if (state != SelectionNone)
3184         ensureLineBoxes();
3185     RenderBoxModelObject::setSelectionState(state);
3186 }
3187 
3188 GapRects RenderBlockFlow::inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
3189     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
3190 {
3191     ASSERT(!simpleLineLayout());
3192 
3193     GapRects result;
3194 
3195     bool containsStart = selectionState() == SelectionStart || selectionState() == SelectionBoth;
3196 
3197     if (!hasLines()) {
3198         if (containsStart) {
3199             // Update our lastLogicalTop to be the bottom of the block. &lt;hr&gt;s or empty blocks with height can trip this case.
3200             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
3201             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
3202             lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
3203         }
3204         return result;
3205     }
3206 
3207     RootInlineBox* lastSelectedLine = 0;
3208     RootInlineBox* curr;
3209     for (curr = firstRootBox(); curr &amp;&amp; !curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) { }
3210 
3211     // Now paint the gaps for the lines.
3212     for (; curr &amp;&amp; curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) {
3213         LayoutUnit selTop =  curr-&gt;selectionTopAdjustedForPrecedingBlock();
3214         LayoutUnit selHeight = curr-&gt;selectionHeightAdjustedForPrecedingBlock();
3215 
3216         if (!containsStart &amp;&amp; !lastSelectedLine &amp;&amp;
3217             selectionState() != SelectionStart &amp;&amp; selectionState() != SelectionBoth &amp;&amp; !isRubyBase())
3218             result.uniteCenter(blockSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, lastLogicalTop, lastLogicalLeft, lastLogicalRight, selTop, cache, paintInfo));
3219 
3220         LayoutRect logicalRect { LayoutUnit(curr-&gt;logicalLeft()), selTop, LayoutUnit(curr-&gt;logicalWidth()), selTop + selHeight };
3221         logicalRect.move(isHorizontalWritingMode() ? offsetFromRootBlock : offsetFromRootBlock.transposedSize());
3222         LayoutRect physicalRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
3223         if (!paintInfo || (isHorizontalWritingMode() &amp;&amp; physicalRect.y() &lt; paintInfo-&gt;rect.maxY() &amp;&amp; physicalRect.maxY() &gt; paintInfo-&gt;rect.y())
3224             || (!isHorizontalWritingMode() &amp;&amp; physicalRect.x() &lt; paintInfo-&gt;rect.maxX() &amp;&amp; physicalRect.maxX() &gt; paintInfo-&gt;rect.x()))
3225             result.unite(curr-&gt;lineSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, selTop, selHeight, cache, paintInfo));
3226 
3227         lastSelectedLine = curr;
3228     }
3229 
3230     if (containsStart &amp;&amp; !lastSelectedLine)
3231         // VisibleSelection must start just after our last line.
3232         lastSelectedLine = lastRootBox();
3233 
3234     if (lastSelectedLine &amp;&amp; selectionState() != SelectionEnd &amp;&amp; selectionState() != SelectionBoth) {
3235         // Update our lastY to be the bottom of the last selected line.
3236         lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + lastSelectedLine-&gt;selectionBottom();
3237         lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3238         lastLogicalRight = logicalRightSelectionOffset(rootBlock, lastSelectedLine-&gt;selectionBottom(), cache);
3239     }
3240     return result;
3241 }
3242 
3243 bool RenderBlockFlow::needsLayoutAfterFragmentRangeChange() const
3244 {
3245     // A block without floats or that expands to enclose them won&#39;t need a relayout
3246     // after a fragment range change. There is no overflow content needing relayout
3247     // in the fragment chain because the fragment range can only shrink after the estimation.
3248     if (!containsFloats() || createsNewFormattingContext())
3249         return false;
3250 
3251     return true;
3252 }
3253 
3254 void RenderBlockFlow::setMultiColumnFlow(RenderMultiColumnFlow&amp; fragmentedFlow)
3255 {
3256     ASSERT(!hasRareBlockFlowData() || !rareBlockFlowData()-&gt;m_multiColumnFlow);
3257     ensureRareBlockFlowData().m_multiColumnFlow = makeWeakPtr(fragmentedFlow);
3258 }
3259 
3260 void RenderBlockFlow::clearMultiColumnFlow()
3261 {
3262     ASSERT(hasRareBlockFlowData());
3263     ASSERT(rareBlockFlowData()-&gt;m_multiColumnFlow);
3264     rareBlockFlowData()-&gt;m_multiColumnFlow.clear();
3265 }
3266 
3267 static bool shouldCheckLines(const RenderBlockFlow&amp; blockFlow)
3268 {
3269     return !blockFlow.isFloatingOrOutOfFlowPositioned() &amp;&amp; blockFlow.style().height().isAuto();
3270 }
3271 
3272 RootInlineBox* RenderBlockFlow::lineAtIndex(int i) const
3273 {
3274     ASSERT(i &gt;= 0);
3275 
3276     if (style().visibility() != Visibility::Visible)
3277         return nullptr;
3278 
3279     if (childrenInline()) {
3280         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3281             if (!i--)
3282                 return box;
3283         }
3284         return nullptr;
3285     }
3286 
3287     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3288         if (!shouldCheckLines(blockFlow))
3289             continue;
3290         if (RootInlineBox* box = blockFlow.lineAtIndex(i))
3291             return box;
3292     }
3293 
3294     return nullptr;
3295 }
3296 
3297 int RenderBlockFlow::lineCount() const
3298 {
3299     // FIXME: This should be tested by clients.
3300     if (style().visibility() != Visibility::Visible)
3301         return 0;
3302 
3303     if (childrenInline()) {
3304 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3305         if (layoutFormattingContextLineLayout())
3306             return layoutFormattingContextLineLayout()-&gt;lineCount();
3307 #endif
3308         if (simpleLineLayout())
3309             return simpleLineLayout()-&gt;lineCount();
3310 
3311         if (complexLineLayout())
3312             return complexLineLayout()-&gt;lineCount();
3313 
3314         return 0;
3315     }
3316 
3317     int count = 0;
3318     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3319         if (!shouldCheckLines(blockFlow))
3320             continue;
3321         count += blockFlow.lineCount();
3322     }
3323 
3324     return count;
3325 }
3326 
3327 static int getHeightForLineCount(const RenderBlockFlow&amp; block, int lineCount, bool includeBottom, int&amp; count)
3328 {
3329     if (block.style().visibility() != Visibility::Visible)
3330         return -1;
3331 
3332     if (block.childrenInline()) {
3333         for (auto* box = block.firstRootBox(); box; box = box-&gt;nextRootBox()) {
3334             if (++count == lineCount)
3335                 return box-&gt;lineBottom() + (includeBottom ? (block.borderBottom() + block.paddingBottom()) : 0_lu);
3336         }
3337     } else {
3338         RenderBox* normalFlowChildWithoutLines = nullptr;
3339         for (auto* obj = block.firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
3340             if (is&lt;RenderBlockFlow&gt;(*obj) &amp;&amp; shouldCheckLines(downcast&lt;RenderBlockFlow&gt;(*obj))) {
3341                 int result = getHeightForLineCount(downcast&lt;RenderBlockFlow&gt;(*obj), lineCount, false, count);
3342                 if (result != -1)
3343                     return result + obj-&gt;y() + (includeBottom ? (block.borderBottom() + block.paddingBottom()) : 0_lu);
3344             } else if (!obj-&gt;isFloatingOrOutOfFlowPositioned())
3345                 normalFlowChildWithoutLines = obj;
3346         }
3347         if (normalFlowChildWithoutLines &amp;&amp; !lineCount)
3348             return normalFlowChildWithoutLines-&gt;y() + normalFlowChildWithoutLines-&gt;height();
3349     }
3350 
3351     return -1;
3352 }
3353 
3354 int RenderBlockFlow::heightForLineCount(int lineCount)
3355 {
3356     int count = 0;
3357     return getHeightForLineCount(*this, lineCount, true, count);
3358 }
3359 
3360 void RenderBlockFlow::clearTruncation()
3361 {
3362     if (style().visibility() != Visibility::Visible)
3363         return;
3364 
3365     if (childrenInline() &amp;&amp; hasMarkupTruncation()) {
3366         ensureLineBoxes();
3367 
3368         setHasMarkupTruncation(false);
3369         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())
3370             box-&gt;clearTruncation();
3371         return;
3372     }
3373 
3374     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3375         if (shouldCheckLines(blockFlow))
3376             blockFlow.clearTruncation();
3377     }
3378 }
3379 
3380 bool RenderBlockFlow::containsNonZeroBidiLevel() const
3381 {
3382     for (auto* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
3383         for (auto* box = root-&gt;firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {
3384             if (box-&gt;bidiLevel())
3385                 return true;
3386         }
3387     }
3388     return false;
3389 }
3390 
3391 Position RenderBlockFlow::positionForBox(InlineBox *box, bool start) const
3392 {
3393     if (!box)
3394         return Position();
3395 
3396     if (!box-&gt;renderer().nonPseudoNode())
3397         return createLegacyEditingPosition(nonPseudoElement(), start ? caretMinOffset() : caretMaxOffset());
3398 
3399     if (!is&lt;InlineTextBox&gt;(*box))
3400         return createLegacyEditingPosition(box-&gt;renderer().nonPseudoNode(), start ? box-&gt;renderer().caretMinOffset() : box-&gt;renderer().caretMaxOffset());
3401 
3402     auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*box);
3403     return createLegacyEditingPosition(textBox.renderer().nonPseudoNode(), start ? textBox.start() : textBox.start() + textBox.len());
3404 }
3405 
3406 RenderText* RenderBlockFlow::findClosestTextAtAbsolutePoint(const FloatPoint&amp; point)
3407 {
3408     // A light, non-recursive version of RenderBlock::positionForCoordinates that looks at
3409     // whether a point lies within the gaps between its root line boxes, to be called against
3410     // a node returned from elementAtPoint. We make the assumption that either the node or one
3411     // of its immediate children contains the root line boxes in question.
3412     // See &lt;rdar://problem/6824650&gt; for context.
3413 
3414     RenderBlock* block = this;
3415 
3416     FloatPoint localPoint = block-&gt;absoluteToLocal(point);
3417 
3418     if (!block-&gt;childrenInline()) {
3419         // Look among our immediate children for an alternate box that contains the point.
3420         for (RenderBox* child = block-&gt;firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
3421             if (!child-&gt;height() || child-&gt;style().visibility() != WebCore::Visibility::Visible || child-&gt;isFloatingOrOutOfFlowPositioned())
3422                 continue;
3423             float top = child-&gt;y();
3424 
3425             RenderBox* nextChild = child-&gt;nextSiblingBox();
3426             while (nextChild &amp;&amp; nextChild-&gt;isFloatingOrOutOfFlowPositioned())
3427                 nextChild = nextChild-&gt;nextSiblingBox();
3428             if (!nextChild) {
3429                 if (localPoint.y() &gt;= top) {
3430                     block = downcast&lt;RenderBlock&gt;(child);
3431                     break;
3432                 }
3433                 continue;
3434             }
3435 
3436             float bottom = nextChild-&gt;y();
3437 
3438             if (localPoint.y() &gt;= top &amp;&amp; localPoint.y() &lt; bottom &amp;&amp; is&lt;RenderBlock&gt;(*child)) {
3439                 block = downcast&lt;RenderBlock&gt;(child);
3440                 break;
3441             }
3442         }
3443 
3444         if (!block-&gt;childrenInline())
3445             return nullptr;
3446 
3447         localPoint = block-&gt;absoluteToLocal(point);
3448     }
3449 
3450     RenderBlockFlow&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*block);
3451 
3452     // Only check the gaps between the root line boxes. We deliberately ignore overflow because
3453     // experience has shown that hit tests on an exploded text node can fail when within the
3454     // overflow fragment.
3455     for (RootInlineBox* current = blockFlow.firstRootBox(); current &amp;&amp; current != blockFlow.lastRootBox(); current = current-&gt;nextRootBox()) {
3456         float currentBottom = current-&gt;y() + current-&gt;logicalHeight();
3457         if (localPoint.y() &lt; currentBottom)
3458             return nullptr;
3459 
3460         RootInlineBox* next = current-&gt;nextRootBox();
3461         float nextTop = next-&gt;y();
3462         if (localPoint.y() &lt; nextTop) {
3463             InlineBox* inlineBox = current-&gt;closestLeafChildForLogicalLeftPosition(localPoint.x());
3464             if (inlineBox &amp;&amp; inlineBox-&gt;behavesLikeText() &amp;&amp; is&lt;RenderText&gt;(inlineBox-&gt;renderer()))
3465                 return &amp;downcast&lt;RenderText&gt;(inlineBox-&gt;renderer());
3466         }
3467     }
3468     return nullptr;
3469 }
3470 
3471 VisiblePosition RenderBlockFlow::positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer* fragment)
3472 {
3473     ASSERT(childrenInline());
3474 
3475     ensureLineBoxes();
3476 
3477     if (!firstRootBox())
3478         return createVisiblePosition(0, DOWNSTREAM);
3479 
3480     bool linesAreFlipped = style().isFlippedLinesWritingMode();
3481     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
3482 
3483     // look for the closest line box in the root box which is at the passed-in y coordinate
3484     InlineBox* closestBox = 0;
3485     RootInlineBox* firstRootBoxWithChildren = 0;
3486     RootInlineBox* lastRootBoxWithChildren = 0;
3487     for (RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
3488         if (fragment &amp;&amp; root-&gt;containingFragment() != fragment)
3489             continue;
3490 
3491         if (!root-&gt;firstLeafDescendant())
3492             continue;
3493         if (!firstRootBoxWithChildren)
3494             firstRootBoxWithChildren = root;
3495 
3496         if (!linesAreFlipped &amp;&amp; root-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &lt; root-&gt;lineTopWithLeading()
3497             || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;lineTopWithLeading())))
3498             break;
3499 
3500         lastRootBoxWithChildren = root;
3501 
3502         // check if this root line box is located at this y coordinate
3503         if (pointInLogicalContents.y() &lt; root-&gt;selectionBottom() || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;selectionBottom())) {
3504             if (linesAreFlipped) {
3505                 RootInlineBox* nextRootBoxWithChildren = root-&gt;nextRootBox();
3506                 while (nextRootBoxWithChildren &amp;&amp; !nextRootBoxWithChildren-&gt;firstLeafDescendant())
3507                     nextRootBoxWithChildren = nextRootBoxWithChildren-&gt;nextRootBox();
3508 
3509                 if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
3510                     || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
3511                     continue;
3512             }
3513             closestBox = root-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3514             if (closestBox)
3515                 break;
3516         }
3517     }
3518 
3519     bool moveCaretToBoundary = frame().editor().behavior().shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom();
3520 
3521     if (!moveCaretToBoundary &amp;&amp; !closestBox &amp;&amp; lastRootBoxWithChildren) {
3522         // y coordinate is below last root line box, pretend we hit it
3523         closestBox = lastRootBoxWithChildren-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3524     }
3525 
3526     if (closestBox) {
3527         if (moveCaretToBoundary) {
3528             LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));
3529             if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
3530                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
3531                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafDescendant();
3532                 if (box-&gt;isLineBreak()) {
3533                     if (InlineBox* newBox = box-&gt;nextLeafOnLineIgnoringLineBreak())
3534                         box = newBox;
3535                 }
3536                 // y coordinate is above first root line box, so return the start of the first
3537                 return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
3538             }
3539         }
3540 
3541         // pass the box a top position that is inside it
3542         LayoutPoint point(pointInLogicalContents.x(), closestBox-&gt;root().blockDirectionPointInLine());
3543         if (!isHorizontalWritingMode())
3544             point = point.transposedPoint();
3545         if (closestBox-&gt;renderer().isReplaced())
3546             return positionForPointRespectingEditingBoundaries(*this, downcast&lt;RenderBox&gt;(closestBox-&gt;renderer()), point);
3547         return closestBox-&gt;renderer().positionForPoint(point, nullptr);
3548     }
3549 
3550     if (lastRootBoxWithChildren) {
3551         // We hit this case for Mac behavior when the Y coordinate is below the last box.
3552         ASSERT(moveCaretToBoundary);
3553         InlineBox* logicallyLastBox;
3554         if (lastRootBoxWithChildren-&gt;getLogicalEndBoxWithNode(logicallyLastBox))
3555             return VisiblePosition(positionForBox(logicallyLastBox, false), DOWNSTREAM);
3556     }
3557 
3558     // Can&#39;t reach this. We have a root line box, but it has no kids.
3559     // FIXME: This should ASSERT_NOT_REACHED(), but clicking on placeholder text
3560     // seems to hit this code path.
3561     return createVisiblePosition(0, DOWNSTREAM);
3562 }
3563 
3564 Position RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point)
3565 {
3566     // FIXME: It supports single text child only (which is the majority of simple line layout supported content at this point).
3567     if (!simpleLineLayout() || firstChild() != lastChild() || !is&lt;RenderText&gt;(firstChild()))
3568         return positionForPoint(point, nullptr).deepEquivalent();
3569     return downcast&lt;RenderText&gt;(*firstChild()).positionForPoint(point);
3570 }
3571 
3572 VisiblePosition RenderBlockFlow::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
3573 {
3574     return RenderBlock::positionForPoint(point, nullptr);
3575 }
3576 
3577 void RenderBlockFlow::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
3578 {
3579     ASSERT(childrenInline());
3580     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
3581         LayoutUnit top = std::max(curr-&gt;lineTop(), LayoutUnit(curr-&gt;top()));
3582         LayoutUnit bottom = std::min(curr-&gt;lineBottom(), LayoutUnit(curr-&gt;top() + curr-&gt;height()));
3583         LayoutRect rect { LayoutUnit(additionalOffset.x() + curr-&gt;x()), additionalOffset.y() + top, LayoutUnit(curr-&gt;width()), bottom - top };
3584         if (!rect.isEmpty())
3585             rects.append(rect);
3586     }
3587 }
3588 
3589 void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3590 {
3591     ASSERT(childrenInline());
3592 
3593 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3594     if (layoutFormattingContextLineLayout()) {
3595         layoutFormattingContextLineLayout()-&gt;paint(paintInfo, paintOffset);
3596         return;
3597     }
3598 #endif
3599 
3600     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3601         SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
3602         return;
3603     }
3604 
3605     if (complexLineLayout())
3606         complexLineLayout()-&gt;lineBoxes().paint(this, paintInfo, paintOffset);
3607 }
3608 
3609 bool RenderBlockFlow::relayoutForPagination()
3610 {
3611     if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
3612         return false;
3613 
3614     multiColumnFlow()-&gt;setNeedsHeightsRecalculation(false);
3615     multiColumnFlow()-&gt;setInBalancingPass(true); // Prevent re-entering this method (and recursion into layout).
3616 
3617     bool needsRelayout;
3618     bool neededRelayout = false;
3619     bool firstPass = true;
3620     do {
3621         // Column heights may change here because of balancing. We may have to do multiple layout
3622         // passes, depending on how the contents is fitted to the changed column heights. In most
3623         // cases, laying out again twice or even just once will suffice. Sometimes we need more
3624         // passes than that, though, but the number of retries should not exceed the number of
3625         // columns, unless we have a bug.
3626         needsRelayout = false;
3627         for (RenderMultiColumnSet* multicolSet = multiColumnFlow()-&gt;firstMultiColumnSet(); multicolSet; multicolSet = multicolSet-&gt;nextSiblingMultiColumnSet()) {
3628             if (multicolSet-&gt;recalculateColumnHeight(firstPass))
3629                 needsRelayout = true;
3630             if (needsRelayout) {
3631                 // Once a column set gets a new column height, that column set and all successive column
3632                 // sets need to be laid out over again, since their logical top will be affected by
3633                 // this, and therefore their column heights may change as well, at least if the multicol
3634                 // height is constrained.
3635                 multicolSet-&gt;setChildNeedsLayout(MarkOnlyThis);
3636             }
3637         }
3638         if (needsRelayout) {
3639             // Layout again. Column balancing resulted in a new height.
3640             neededRelayout = true;
3641             multiColumnFlow()-&gt;setChildNeedsLayout(MarkOnlyThis);
3642             setChildNeedsLayout(MarkOnlyThis);
3643             layoutBlock(false);
3644         }
3645         firstPass = false;
3646     } while (needsRelayout);
3647 
3648     multiColumnFlow()-&gt;setInBalancingPass(false);
3649 
3650     return neededRelayout;
3651 }
3652 
3653 bool RenderBlockFlow::hasLines() const
3654 {
3655     if (!childrenInline())
3656         return false;
3657 
3658 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3659     if (layoutFormattingContextLineLayout())
3660         return layoutFormattingContextLineLayout()-&gt;lineCount();
3661 #endif
3662     if (simpleLineLayout())
3663         return simpleLineLayout()-&gt;lineCount();
3664 
3665     return complexLineLayout() &amp;&amp; complexLineLayout()-&gt;lineBoxes().firstLineBox();
3666 }
3667 
3668 void RenderBlockFlow::invalidateLineLayoutPath()
3669 {
3670     switch (lineLayoutPath()) {
3671     case UndeterminedPath:
3672     case ForceLineBoxesPath:
3673         ASSERT(!simpleLineLayout());
3674         return;
3675     case LineBoxesPath:
3676         ASSERT(!simpleLineLayout());
3677         setLineLayoutPath(UndeterminedPath);
3678         return;
3679     case LayoutFormattingContextPath: // FIXME: Not all clients of invalidateLineLayoutPath() actually need to wipe the layout.
3680     case SimpleLinesPath:
3681         // The simple line layout may have become invalid.
3682         m_lineLayout = WTF::Monostate();
3683         setLineLayoutPath(UndeterminedPath);
3684         if (needsLayout())
3685             return;
3686         // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
3687         setNeedsLayout();
3688         return;
3689     }
3690     ASSERT_NOT_REACHED();
3691 }
3692 
3693 void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3694 {
3695     bool needsLayout = selfNeedsLayout() || relayoutChildren || !simpleLineLayout();
3696     if (needsLayout)
3697         m_lineLayout = SimpleLineLayout::create(*this);
3698 
3699     auto&amp; simpleLineLayout = *this-&gt;simpleLineLayout();
3700 
3701     if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
3702         simpleLineLayout.setIsPaginated();
3703         SimpleLineLayout::adjustLinePositionsForPagination(simpleLineLayout, *this);
3704     }
3705 
3706     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3707         renderer.clearNeedsLayout();
3708 
3709     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, simpleLineLayout);
3710     LayoutUnit lineLayoutTop = borderAndPaddingBefore();
3711     repaintLogicalTop = lineLayoutTop;
3712     repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
3713     setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
3714 }
3715 
3716 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
3717 void RenderBlockFlow::layoutLFCLines(bool, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3718 {
3719     if (!layoutFormattingContextLineLayout())
3720         m_lineLayout = makeUnique&lt;LayoutIntegration::LineLayout&gt;(*this);
3721 
3722     auto&amp; layoutFormattingContextLineLayout = *this-&gt;layoutFormattingContextLineLayout();
3723 
3724     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3725         renderer.clearNeedsLayout();
3726 
3727     layoutFormattingContextLineLayout.layout();
3728 
3729     auto contentHeight = layoutFormattingContextLineLayout.contentLogicalHeight();
3730     auto contentBoxTop = borderAndPaddingBefore();
3731     auto contentBoxBottom = contentBoxTop + contentHeight;
3732     auto borderBoxBottom = contentBoxBottom + borderAndPaddingAfter();
3733 
3734     repaintLogicalTop = contentBoxTop;
3735     repaintLogicalBottom = borderBoxBottom;
3736     setLogicalHeight(borderBoxBottom);
3737 }
3738 #endif
3739 
3740 void RenderBlockFlow::ensureLineBoxes()
3741 {
3742     if (!childrenInline())
3743         return;
3744 
3745     setLineLayoutPath(ForceLineBoxesPath);
3746 
3747     if (complexLineLayout() || !hasLineLayout())
3748         return;
3749 
3750     auto simpleLineLayout = makeRefPtr(this-&gt;simpleLineLayout());
3751 
3752     m_lineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);
3753 
3754     if (simpleLineLayout) {
3755         if (SimpleLineLayout::canUseForLineBoxTree(*this, *simpleLineLayout)) {
3756             SimpleLineLayout::generateLineBoxTree(*this, *simpleLineLayout);
3757             return;
3758         }
3759     }
3760 
3761     auto&amp; complexLineLayout = *this-&gt;complexLineLayout();
3762 
3763 #if ASSERT_ENABLED
3764     LayoutUnit oldHeight = logicalHeight();
3765 #endif
3766     bool didNeedLayout = needsLayout();
3767 
3768     bool relayoutChildren = false;
3769     LayoutUnit repaintLogicalTop;
3770     LayoutUnit repaintLogicalBottom;
3771     if (simpleLineLayout &amp;&amp; simpleLineLayout-&gt;isPaginated()) {
3772         PaginatedLayoutStateMaintainer state(*this);
3773         complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
3774         // This matches relayoutToAvoidWidows.
3775         if (shouldBreakAtLineToAvoidWidow())
3776             complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
3777         // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
3778         repaint();
3779     } else
3780         complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
3781 
3782     updateLogicalHeight();
3783     ASSERT(didNeedLayout || logicalHeight() == oldHeight);
3784 
3785     if (!didNeedLayout)
3786         clearNeedsLayout();
3787 }
3788 
3789 #if ENABLE(TREE_DEBUGGING)
3790 void RenderBlockFlow::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
3791 {
3792     for (const RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox())
3793         root-&gt;outputLineTreeAndMark(stream, markedBox, depth);
3794 
3795     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3796         SimpleLineLayout::outputLineLayoutForFlow(stream, *this, *simpleLineLayout, depth);
3797 }
3798 #endif
3799 
3800 RenderBlockFlow::RenderBlockFlowRareData&amp; RenderBlockFlow::ensureRareBlockFlowData()
3801 {
3802     if (hasRareBlockFlowData())
3803         return *m_rareBlockFlowData;
3804     materializeRareBlockFlowData();
3805     return *m_rareBlockFlowData;
3806 }
3807 
3808 void RenderBlockFlow::materializeRareBlockFlowData()
3809 {
3810     ASSERT(!hasRareBlockFlowData());
3811     m_rareBlockFlowData = makeUnique&lt;RenderBlockFlow::RenderBlockFlowRareData&gt;(*this);
3812 }
3813 
3814 #if ENABLE(TEXT_AUTOSIZING)
3815 
3816 static inline bool isVisibleRenderText(const RenderObject&amp; renderer)
3817 {
3818     if (!is&lt;RenderText&gt;(renderer))
3819         return false;
3820 
3821     auto&amp; renderText = downcast&lt;RenderText&gt;(renderer);
3822     return !renderText.linesBoundingBox().isEmpty() &amp;&amp; !renderText.text().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
3823 }
3824 
3825 static inline bool resizeTextPermitted(const RenderObject&amp; renderer)
3826 {
3827     // We disallow resizing for text input fields and textarea to address &lt;rdar://problem/5792987&gt; and &lt;rdar://problem/8021123&gt;
3828     for (auto* ancestor = renderer.parent(); ancestor; ancestor = ancestor-&gt;parent()) {
3829         // Get the first non-shadow HTMLElement and see if it&#39;s an input.
3830         if (is&lt;HTMLElement&gt;(ancestor-&gt;element()) &amp;&amp; !ancestor-&gt;element()-&gt;isInShadowTree()) {
3831             auto&amp; element = downcast&lt;HTMLElement&gt;(*ancestor-&gt;element());
3832             return !is&lt;HTMLInputElement&gt;(element) &amp;&amp; !is&lt;HTMLTextAreaElement&gt;(element);
3833         }
3834     }
3835     return true;
3836 }
3837 
3838 int RenderBlockFlow::lineCountForTextAutosizing()
3839 {
3840     if (style().visibility() != Visibility::Visible)
3841         return 0;
3842     if (childrenInline())
3843         return lineCount();
3844     // Only descend into list items.
3845     int count = 0;
3846     for (auto&amp; listItem : childrenOfType&lt;RenderListItem&gt;(*this))
3847         count += listItem.lineCount();
3848     return count;
3849 }
3850 
3851 static bool isNonBlocksOrNonFixedHeightListItems(const RenderObject&amp; renderer)
3852 {
3853     if (!renderer.isRenderBlock())
3854         return true;
3855     if (renderer.isListItem())
3856         return renderer.style().height().type() != Fixed;
3857     return false;
3858 }
3859 
3860 // For now, we auto size single lines of text the same as multiple lines.
3861 // We&#39;ve been experimenting with low values for single lines of text.
3862 static inline float oneLineTextMultiplier(RenderObject&amp; renderer, float specifiedSize)
3863 {
3864     const float coefficient = renderer.settings().oneLineTextMultiplierCoefficient();
3865     return std::max((1.0f / log10f(specifiedSize) * coefficient), 1.0f);
3866 }
3867 
3868 static inline float textMultiplier(RenderObject&amp; renderer, float specifiedSize)
3869 {
3870     const float coefficient = renderer.settings().multiLineTextMultiplierCoefficient();
3871     return std::max((1.0f / log10f(specifiedSize) * coefficient), 1.0f);
3872 }
3873 
3874 void RenderBlockFlow::adjustComputedFontSizes(float size, float visibleWidth)
3875 {
3876     LOG(TextAutosizing, &quot;RenderBlockFlow %p adjustComputedFontSizes, size=%f visibleWidth=%f, width()=%f. Bailing: %d&quot;, this, size, visibleWidth, width().toFloat(), visibleWidth &gt;= width());
3877 
3878     // Don&#39;t do any work if the block is smaller than the visible area.
3879     if (visibleWidth &gt;= width())
3880         return;
3881 
3882     unsigned lineCount;
3883     if (m_lineCountForTextAutosizing == NOT_SET) {
3884         int count = lineCountForTextAutosizing();
3885         if (!count)
3886             lineCount = NO_LINE;
3887         else if (count == 1)
3888             lineCount = ONE_LINE;
3889         else
3890             lineCount = MULTI_LINE;
3891     } else
3892         lineCount = m_lineCountForTextAutosizing;
3893 
3894     ASSERT(lineCount != NOT_SET);
3895     if (lineCount == NO_LINE)
3896         return;
3897 
3898     float actualWidth = m_widthForTextAutosizing != -1 ? static_cast&lt;float&gt;(m_widthForTextAutosizing) : static_cast&lt;float&gt;(width());
3899     float scale = visibleWidth / actualWidth;
3900     float minFontSize = roundf(size / scale);
3901 
3902     for (auto* descendant = RenderObjectTraversal::firstChild(*this); descendant; ) {
3903         if (!isNonBlocksOrNonFixedHeightListItems(*descendant)) {
3904             descendant = RenderObjectTraversal::nextSkippingChildren(*descendant, this);
3905             continue;
3906         }
3907         if (!isVisibleRenderText(*descendant) || !resizeTextPermitted(*descendant)) {
3908             descendant = RenderObjectTraversal::next(*descendant, this);
3909             continue;
3910         }
3911 
3912         auto&amp; text = downcast&lt;RenderText&gt;(*descendant);
3913         auto&amp; oldStyle = text.style();
3914         auto&amp; fontDescription = oldStyle.fontDescription();
3915         float specifiedSize = fontDescription.specifiedSize();
3916         float scaledSize = roundf(specifiedSize * scale);
3917         if (scaledSize &gt; 0 &amp;&amp; scaledSize &lt; minFontSize) {
3918             // Record the width of the block and the line count the first time we resize text and use it from then on for text resizing.
3919             // This makes text resizing consistent even if the block&#39;s width or line count changes (which can be caused by text resizing itself 5159915).
3920             if (m_lineCountForTextAutosizing == NOT_SET)
3921                 m_lineCountForTextAutosizing = lineCount;
3922             if (m_widthForTextAutosizing == -1)
3923                 m_widthForTextAutosizing = actualWidth;
3924 
3925             float lineTextMultiplier = lineCount == ONE_LINE ? oneLineTextMultiplier(text, specifiedSize) : textMultiplier(text, specifiedSize);
3926             float candidateNewSize = roundf(std::min(minFontSize, specifiedSize * lineTextMultiplier));
3927 
3928             if (candidateNewSize &gt; specifiedSize &amp;&amp; candidateNewSize != fontDescription.computedSize() &amp;&amp; text.textNode() &amp;&amp; oldStyle.textSizeAdjust().isAuto())
3929                 document().textAutoSizing().addTextNode(*text.textNode(), candidateNewSize);
3930         }
3931 
3932         descendant = RenderObjectTraversal::nextSkippingChildren(text, this);
3933     }
3934 }
3935 
3936 #endif // ENABLE(TEXT_AUTOSIZING)
3937 
3938 void RenderBlockFlow::layoutExcludedChildren(bool relayoutChildren)
3939 {
3940     RenderBlock::layoutExcludedChildren(relayoutChildren);
3941 
3942     auto* fragmentedFlow = multiColumnFlow();
3943     if (!fragmentedFlow)
3944         return;
3945 
3946     fragmentedFlow-&gt;setIsExcludedFromNormalLayout(true);
3947 
3948     setLogicalTopForChild(*fragmentedFlow, borderAndPaddingBefore());
3949 
3950     if (relayoutChildren)
3951         fragmentedFlow-&gt;setChildNeedsLayout(MarkOnlyThis);
3952 
3953     if (fragmentedFlow-&gt;needsLayout()) {
3954         for (RenderMultiColumnSet* columnSet = fragmentedFlow-&gt;firstMultiColumnSet(); columnSet; columnSet = columnSet-&gt;nextSiblingMultiColumnSet())
3955             columnSet-&gt;prepareForLayout(!fragmentedFlow-&gt;inBalancingPass());
3956 
3957         fragmentedFlow-&gt;invalidateFragments(MarkOnlyThis);
3958         fragmentedFlow-&gt;setNeedsHeightsRecalculation(true);
3959         fragmentedFlow-&gt;layout();
3960     } else {
3961         // At the end of multicol layout, relayoutForPagination() is called unconditionally, but if
3962         // no children are to be laid out (e.g. fixed width with layout already being up-to-date),
3963         // we want to prevent it from doing any work, so that the column balancing machinery doesn&#39;t
3964         // kick in and trigger additional unnecessary layout passes. Actually, it&#39;s not just a good
3965         // idea in general to not waste time on balancing content that hasn&#39;t been re-laid out; we
3966         // are actually required to guarantee this. The calculation of implicit breaks needs to be
3967         // preceded by a proper layout pass, since it&#39;s layout that sets up content runs, and the
3968         // runs get deleted right after every pass.
3969         fragmentedFlow-&gt;setNeedsHeightsRecalculation(false);
3970     }
3971     determineLogicalLeftPositionForChild(*fragmentedFlow);
3972 }
3973 
3974 void RenderBlockFlow::checkForPaginationLogicalHeightChange(bool&amp; relayoutChildren, LayoutUnit&amp; pageLogicalHeight, bool&amp; pageLogicalHeightChanged)
3975 {
3976     // If we don&#39;t use columns or flow threads, then bail.
3977     if (!isRenderFragmentedFlow() &amp;&amp; !multiColumnFlow())
3978         return;
3979 
3980     // We don&#39;t actually update any of the variables. We just subclassed to adjust our column height.
3981     if (RenderMultiColumnFlow* fragmentedFlow = multiColumnFlow()) {
3982         LayoutUnit newColumnHeight;
3983         if (hasDefiniteLogicalHeight() || view().frameView().pagination().mode != Pagination::Unpaginated) {
3984             auto computedValues = computeLogicalHeight(0_lu, logicalTop());
3985             newColumnHeight = std::max&lt;LayoutUnit&gt;(computedValues.m_extent - borderAndPaddingLogicalHeight() - scrollbarLogicalHeight(), 0);
3986             if (fragmentedFlow-&gt;columnHeightAvailable() != newColumnHeight)
3987                 relayoutChildren = true;
3988         }
3989         fragmentedFlow-&gt;setColumnHeightAvailable(newColumnHeight);
3990     } else if (is&lt;RenderFragmentedFlow&gt;(*this)) {
3991         RenderFragmentedFlow&amp; fragmentedFlow = downcast&lt;RenderFragmentedFlow&gt;(*this);
3992 
3993         // FIXME: This is a hack to always make sure we have a page logical height, if said height
3994         // is known. The page logical height thing in RenderLayoutState is meaningless for flow
3995         // thread-based pagination (page height isn&#39;t necessarily uniform throughout the flow
3996         // thread), but as long as it is used universally as a means to determine whether page
3997         // height is known or not, we need this. Page height is unknown when column balancing is
3998         // enabled and flow thread height is still unknown (i.e. during the first layout pass). When
3999         // it&#39;s unknown, we need to prevent the pagination code from assuming page breaks everywhere
4000         // and thereby eating every top margin. It should be trivial to clean up and get rid of this
4001         // hack once the old multicol implementation is gone (see also RenderView::pushLayoutStateForPagination).
4002         pageLogicalHeight = fragmentedFlow.isPageLogicalHeightKnown() ? 1_lu : 0_lu;
4003 
4004         pageLogicalHeightChanged = fragmentedFlow.pageLogicalSizeChanged();
4005     }
4006 }
4007 
4008 bool RenderBlockFlow::requiresColumns(int desiredColumnCount) const
4009 {
4010     return willCreateColumns(desiredColumnCount);
4011 }
4012 
4013 void RenderBlockFlow::setComputedColumnCountAndWidth(int count, LayoutUnit width)
4014 {
4015     ASSERT(!!multiColumnFlow() == requiresColumns(count));
4016     if (!multiColumnFlow())
4017         return;
4018     multiColumnFlow()-&gt;setColumnCountAndWidth(count, width);
4019     multiColumnFlow()-&gt;setProgressionIsInline(style().hasInlineColumnAxis());
4020     multiColumnFlow()-&gt;setProgressionIsReversed(style().columnProgression() == ColumnProgression::Reverse);
4021 }
4022 
4023 void RenderBlockFlow::updateColumnProgressionFromStyle(RenderStyle&amp; style)
4024 {
4025     if (!multiColumnFlow())
4026         return;
4027 
4028     bool needsLayout = false;
4029     bool oldProgressionIsInline = multiColumnFlow()-&gt;progressionIsInline();
4030     bool newProgressionIsInline = style.hasInlineColumnAxis();
4031     if (oldProgressionIsInline != newProgressionIsInline) {
4032         multiColumnFlow()-&gt;setProgressionIsInline(newProgressionIsInline);
4033         needsLayout = true;
4034     }
4035 
4036     bool oldProgressionIsReversed = multiColumnFlow()-&gt;progressionIsReversed();
4037     bool newProgressionIsReversed = style.columnProgression() == ColumnProgression::Reverse;
4038     if (oldProgressionIsReversed != newProgressionIsReversed) {
4039         multiColumnFlow()-&gt;setProgressionIsReversed(newProgressionIsReversed);
4040         needsLayout = true;
4041     }
4042 
4043     if (needsLayout)
4044         setNeedsLayoutAndPrefWidthsRecalc();
4045 }
4046 
4047 LayoutUnit RenderBlockFlow::computedColumnWidth() const
4048 {
4049     if (multiColumnFlow())
4050         return multiColumnFlow()-&gt;computedColumnWidth();
4051     return contentLogicalWidth();
4052 }
4053 
4054 unsigned RenderBlockFlow::computedColumnCount() const
4055 {
4056     if (multiColumnFlow())
4057         return multiColumnFlow()-&gt;computedColumnCount();
4058 
4059     return 1;
4060 }
4061 
4062 bool RenderBlockFlow::isTopLayoutOverflowAllowed() const
4063 {
4064     bool hasTopOverflow = RenderBlock::isTopLayoutOverflowAllowed();
4065     if (!multiColumnFlow() || style().columnProgression() == ColumnProgression::Normal)
4066         return hasTopOverflow;
4067 
4068     if (!(isHorizontalWritingMode() ^ !style().hasInlineColumnAxis()))
4069         hasTopOverflow = !hasTopOverflow;
4070 
4071     return hasTopOverflow;
4072 }
4073 
4074 bool RenderBlockFlow::isLeftLayoutOverflowAllowed() const
4075 {
4076     bool hasLeftOverflow = RenderBlock::isLeftLayoutOverflowAllowed();
4077     if (!multiColumnFlow() || style().columnProgression() == ColumnProgression::Normal)
4078         return hasLeftOverflow;
4079 
4080     if (isHorizontalWritingMode() ^ !style().hasInlineColumnAxis())
4081         hasLeftOverflow = !hasLeftOverflow;
4082 
4083     return hasLeftOverflow;
4084 }
4085 
4086 struct InlineMinMaxIterator {
4087 /* InlineMinMaxIterator is a class that will iterate over all render objects that contribute to
4088    inline min/max width calculations.  Note the following about the way it walks:
4089    (1) Positioned content is skipped (since it does not contribute to min/max width of a block)
4090    (2) We do not drill into the children of floats or replaced elements, since you can&#39;t break
4091        in the middle of such an element.
4092    (3) Inline flows (e.g., &lt;a&gt;, &lt;span&gt;, &lt;i&gt;) are walked twice, since each side can have
4093        distinct borders/margin/padding that contribute to the min/max width.
4094 */
4095     const RenderBlockFlow&amp; parent;
4096     RenderObject* current;
4097     bool endOfInline;
4098     bool initial;
4099 
4100     InlineMinMaxIterator(const RenderBlockFlow&amp; p)
4101         : parent(p)
4102         , current(nullptr)
4103         , endOfInline(false)
4104         , initial(true)
4105         { }
4106 
4107     RenderObject* next();
4108 };
4109 
4110 RenderObject* InlineMinMaxIterator::next()
4111 {
4112     RenderObject* result = nullptr;
4113     bool oldEndOfInline = endOfInline;
4114     endOfInline = false;
4115     do {
4116         if (!oldEndOfInline &amp;&amp; (current &amp;&amp; !current-&gt;isFloating() &amp;&amp; !current-&gt;isReplaced() &amp;&amp; !current-&gt;isOutOfFlowPositioned()))
4117             result = current-&gt;firstChildSlow();
4118         else if (initial) {
4119             result = parent.firstChild();
4120             initial = false;
4121         }
4122 
4123         if (!result) {
4124             // We hit the end of our inline. (It was empty, e.g., &lt;span&gt;&lt;/span&gt;.)
4125             if (!oldEndOfInline &amp;&amp; current &amp;&amp; current-&gt;isRenderInline()) {
4126                 result = current;
4127                 endOfInline = true;
4128                 break;
4129             }
4130 
4131             while (current &amp;&amp; current != &amp;parent) {
4132                 result = current-&gt;nextSibling();
4133                 if (result)
4134                     break;
4135                 current = current-&gt;parent();
4136                 if (current &amp;&amp; current != &amp;parent &amp;&amp; current-&gt;isRenderInline()) {
4137                     result = current;
4138                     endOfInline = true;
4139                     break;
4140                 }
4141             }
4142         }
4143 
4144         if (!result)
4145             break;
4146 
4147         if (!result-&gt;isOutOfFlowPositioned() &amp;&amp; (result-&gt;isTextOrLineBreak() || result-&gt;isFloating() || result-&gt;isReplaced() || result-&gt;isRenderInline()))
4148             break;
4149 
4150         current = result;
4151         result = nullptr;
4152     } while (current || current == &amp;parent);
4153     // Update our position.
4154     current = result;
4155     return result;
4156 }
4157 
4158 static LayoutUnit getBPMWidth(LayoutUnit childValue, Length cssUnit)
4159 {
4160     if (cssUnit.type() != Auto)
4161         return (cssUnit.isFixed() ? LayoutUnit(cssUnit.value()) : childValue);
4162     return 0;
4163 }
4164 
4165 static LayoutUnit getBorderPaddingMargin(const RenderBoxModelObject&amp; child, bool endOfInline)
4166 {
4167     const RenderStyle&amp; childStyle = child.style();
4168     if (endOfInline) {
4169         return getBPMWidth(child.marginEnd(), childStyle.marginEnd()) +
4170                getBPMWidth(child.paddingEnd(), childStyle.paddingEnd()) +
4171                child.borderEnd();
4172     }
4173     return getBPMWidth(child.marginStart(), childStyle.marginStart()) +
4174                getBPMWidth(child.paddingStart(), childStyle.paddingStart()) +
4175                child.borderStart();
4176 }
4177 
4178 static inline void stripTrailingSpace(float&amp; inlineMax, float&amp; inlineMin, RenderObject* trailingSpaceChild)
4179 {
4180     if (is&lt;RenderText&gt;(trailingSpaceChild)) {
4181         // Collapse away the trailing space at the end of a block.
4182         RenderText&amp; renderText = downcast&lt;RenderText&gt;(*trailingSpaceChild);
4183         const UChar space = &#39; &#39;;
4184         const FontCascade&amp; font = renderText.style().fontCascade(); // FIXME: This ignores first-line.
4185         float spaceWidth = font.width(RenderBlock::constructTextRun(&amp;space, 1, renderText.style()));
4186         inlineMax -= spaceWidth + font.wordSpacing();
4187         if (inlineMin &gt; inlineMax)
4188             inlineMin = inlineMax;
4189     }
4190 }
4191 
4192 static inline LayoutUnit preferredWidth(LayoutUnit preferredWidth, float result)
4193 {
4194     return std::max(preferredWidth, LayoutUnit::fromFloatCeil(result));
4195 }
4196 
4197 void RenderBlockFlow::computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
4198 {
4199     float inlineMax = 0;
4200     float inlineMin = 0;
4201 
4202     const RenderStyle&amp; styleToUse = style();
4203     RenderBlock* containingBlock = this-&gt;containingBlock();
4204     LayoutUnit cw = containingBlock ? containingBlock-&gt;contentLogicalWidth() : 0_lu;
4205 
4206     // If we are at the start of a line, we want to ignore all white-space.
4207     // Also strip spaces if we previously had text that ended in a trailing space.
4208     bool stripFrontSpaces = true;
4209     RenderObject* trailingSpaceChild = nullptr;
4210 
4211     // Firefox and Opera will allow a table cell to grow to fit an image inside it under
4212     // very specific cirucumstances (in order to match common WinIE renderings).
4213     // Not supporting the quirk has caused us to mis-render some real sites. (See Bugzilla 10517.)
4214     bool allowImagesToBreak = !document().inQuirksMode() || !isTableCell() || !styleToUse.logicalWidth().isIntrinsicOrAuto();
4215 
4216     bool oldAutoWrap = styleToUse.autoWrap();
4217 
4218     InlineMinMaxIterator childIterator(*this);
4219 
4220     // Only gets added to the max preffered width once.
4221     bool addedTextIndent = false;
4222     // Signals the text indent was more negative than the min preferred width
4223     bool hasRemainingNegativeTextIndent = false;
4224 
4225     LayoutUnit textIndent = minimumValueForLength(styleToUse.textIndent(), cw);
4226     RenderObject* prevFloat = 0;
4227     bool isPrevChildInlineFlow = false;
4228     bool shouldBreakLineAfterText = false;
4229     bool canHangPunctuationAtStart = styleToUse.hangingPunctuation().contains(HangingPunctuation::First);
4230     bool canHangPunctuationAtEnd = styleToUse.hangingPunctuation().contains(HangingPunctuation::Last);
4231     RenderText* lastText = nullptr;
4232 
4233     bool addedStartPunctuationHang = false;
4234 
4235     while (RenderObject* child = childIterator.next()) {
4236         bool autoWrap = child-&gt;isReplaced() ? child-&gt;parent()-&gt;style().autoWrap() :
4237             child-&gt;style().autoWrap();
4238         if (!child-&gt;isBR()) {
4239             // Step One: determine whether or not we need to terminate our current line.
4240             // Each discrete chunk can become the new min-width, if it is the widest chunk
4241             // seen so far, and it can also become the max-width.
4242 
4243             // Children fall into three categories:
4244             // (1) An inline flow object. These objects always have a min/max of 0,
4245             // and are included in the iteration solely so that their margins can
4246             // be added in.
4247             //
4248             // (2) An inline non-text non-flow object, e.g., an inline replaced element.
4249             // These objects can always be on a line by themselves, so in this situation
4250             // we need to break the current line, and then add in our own margins and min/max
4251             // width on its own line, and then terminate the line.
4252             //
4253             // (3) A text object. Text runs can have breakable characters at the start,
4254             // the middle or the end. They may also lose whitespace off the front if
4255             // we&#39;re already ignoring whitespace. In order to compute accurate min-width
4256             // information, we need three pieces of information.
4257             // (a) the min-width of the first non-breakable run. Should be 0 if the text string
4258             // starts with whitespace.
4259             // (b) the min-width of the last non-breakable run. Should be 0 if the text string
4260             // ends with whitespace.
4261             // (c) the min/max width of the string (trimmed for whitespace).
4262             //
4263             // If the text string starts with whitespace, then we need to terminate our current line
4264             // (unless we&#39;re already in a whitespace stripping mode.
4265             //
4266             // If the text string has a breakable character in the middle, but didn&#39;t start
4267             // with whitespace, then we add the width of the first non-breakable run and
4268             // then end the current line. We then need to use the intermediate min/max width
4269             // values (if any of them are larger than our current min/max). We then look at
4270             // the width of the last non-breakable run and use that to start a new line
4271             // (unless we end in whitespace).
4272             const RenderStyle&amp; childStyle = child-&gt;style();
4273             float childMin = 0;
4274             float childMax = 0;
4275 
4276             if (!child-&gt;isText()) {
4277                 if (child-&gt;isLineBreakOpportunity()) {
4278                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4279                     inlineMin = 0;
4280                     continue;
4281                 }
4282                 // Case (1) and (2). Inline replaced and inline flow elements.
4283                 if (is&lt;RenderInline&gt;(*child)) {
4284                     // Add in padding/border/margin from the appropriate side of
4285                     // the element.
4286                     float bpm = getBorderPaddingMargin(downcast&lt;RenderInline&gt;(*child), childIterator.endOfInline);
4287                     childMin += bpm;
4288                     childMax += bpm;
4289 
4290                     inlineMin += childMin;
4291                     inlineMax += childMax;
4292 
4293                     child-&gt;setPreferredLogicalWidthsDirty(false);
4294                 } else {
4295                     // Inline replaced elts add in their margins to their min/max values.
4296                     if (!child-&gt;isFloating())
4297                         lastText = nullptr;
4298                     LayoutUnit margins;
4299                     Length startMargin = childStyle.marginStart();
4300                     Length endMargin = childStyle.marginEnd();
4301                     if (startMargin.isFixed())
4302                         margins += LayoutUnit::fromFloatCeil(startMargin.value());
4303                     if (endMargin.isFixed())
4304                         margins += LayoutUnit::fromFloatCeil(endMargin.value());
4305                     childMin += margins.ceilToFloat();
4306                     childMax += margins.ceilToFloat();
4307                 }
4308             }
4309 
4310             if (!is&lt;RenderInline&gt;(*child) &amp;&amp; !is&lt;RenderText&gt;(*child)) {
4311                 // Case (2). Inline replaced elements and floats.
4312                 // Terminate the current line as far as minwidth is concerned.
4313                 LayoutUnit childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth;
4314                 computeChildPreferredLogicalWidths(*child, childMinPreferredLogicalWidth, childMaxPreferredLogicalWidth);
4315                 childMin += childMinPreferredLogicalWidth.ceilToFloat();
4316                 childMax += childMaxPreferredLogicalWidth.ceilToFloat();
4317 
4318                 bool clearPreviousFloat;
4319                 if (child-&gt;isFloating()) {
4320                     clearPreviousFloat = (prevFloat
4321                         &amp;&amp; ((prevFloat-&gt;style().floating() == Float::Left &amp;&amp; (childStyle.clear() == Clear::Left || childStyle.clear() == Clear::Both))
4322                             || (prevFloat-&gt;style().floating() == Float::Right &amp;&amp; (childStyle.clear() == Clear::Right || childStyle.clear() == Clear::Both))));
4323                     prevFloat = child;
4324                 } else
4325                     clearPreviousFloat = false;
4326 
4327                 bool canBreakReplacedElement = !child-&gt;isImage() || allowImagesToBreak;
4328                 if (((canBreakReplacedElement &amp;&amp; (autoWrap || oldAutoWrap) &amp;&amp; (!isPrevChildInlineFlow || shouldBreakLineAfterText)) || clearPreviousFloat)) {
4329                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4330                     inlineMin = 0;
4331                 }
4332 
4333                 // If we&#39;re supposed to clear the previous float, then terminate maxwidth as well.
4334                 if (clearPreviousFloat) {
4335                     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4336                     inlineMax = 0;
4337                 }
4338 
4339                 // Add in text-indent. This is added in only once.
4340                 if (!addedTextIndent &amp;&amp; !child-&gt;isFloating()) {
4341                     LayoutUnit ceiledIndent { textIndent.ceilToFloat() };
4342                     childMin += ceiledIndent;
4343                     childMax += ceiledIndent;
4344 
4345                     if (childMin &lt; 0)
4346                         textIndent = LayoutUnit::fromFloatCeil(childMin);
4347                     else
4348                         addedTextIndent = true;
4349                 }
4350 
4351                 if (canHangPunctuationAtStart &amp;&amp; !addedStartPunctuationHang &amp;&amp; !child-&gt;isFloating())
4352                     addedStartPunctuationHang = true;
4353 
4354                 // Add our width to the max.
4355                 inlineMax += std::max&lt;float&gt;(0, childMax);
4356 
4357                 if ((!autoWrap || !canBreakReplacedElement || (isPrevChildInlineFlow &amp;&amp; !shouldBreakLineAfterText))) {
4358                     if (child-&gt;isFloating())
4359                         minLogicalWidth = preferredWidth(minLogicalWidth, childMin);
4360                     else
4361                         inlineMin += childMin;
4362                 } else {
4363                     // Now check our line.
4364                     minLogicalWidth = preferredWidth(minLogicalWidth, childMin);
4365 
4366                     // Now start a new line.
4367                     inlineMin = 0;
4368                 }
4369 
4370                 if (autoWrap &amp;&amp; canBreakReplacedElement &amp;&amp; isPrevChildInlineFlow) {
4371                     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4372                     inlineMin = 0;
4373                 }
4374 
4375                 // We are no longer stripping whitespace at the start of a line.
4376                 if (!child-&gt;isFloating()) {
4377                     stripFrontSpaces = false;
4378                     trailingSpaceChild = nullptr;
4379                     lastText = nullptr;
4380                 }
4381             } else if (is&lt;RenderText&gt;(*child)) {
4382                 // Case (3). Text.
4383                 RenderText&amp; renderText = downcast&lt;RenderText&gt;(*child);
4384 
4385                 if (renderText.style().hasTextCombine() &amp;&amp; renderText.isCombineText())
4386                     downcast&lt;RenderCombineText&gt;(renderText).combineTextIfNeeded();
4387 
4388                 // Determine if we have a breakable character. Pass in
4389                 // whether or not we should ignore any spaces at the front
4390                 // of the string. If those are going to be stripped out,
4391                 // then they shouldn&#39;t be considered in the breakable char
4392                 // check.
4393                 bool strippingBeginWS = stripFrontSpaces;
4394                 auto widths = renderText.trimmedPreferredWidths(inlineMax, stripFrontSpaces);
4395 
4396                 childMin = widths.min;
4397                 childMax = widths.max;
4398 
4399                 // This text object will not be rendered, but it may still provide a breaking opportunity.
4400                 if (!widths.hasBreak &amp;&amp; !childMax) {
4401                     if (autoWrap &amp;&amp; (widths.beginWS || widths.endWS)) {
4402                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4403                         inlineMin = 0;
4404                     }
4405                     continue;
4406                 }
4407 
4408                 lastText = &amp;renderText;
4409 
4410                 if (stripFrontSpaces)
4411                     trailingSpaceChild = child;
4412                 else
4413                     trailingSpaceChild = 0;
4414 
4415                 // Add in text-indent. This is added in only once.
4416                 float ti = 0;
4417                 if (!addedTextIndent || hasRemainingNegativeTextIndent) {
4418                     ti = textIndent.ceilToFloat();
4419                     childMin += ti;
4420                     widths.beginMin += ti;
4421 
4422                     // It the text indent negative and larger than the child minimum, we re-use the remainder
4423                     // in future minimum calculations, but using the negative value again on the maximum
4424                     // will lead to under-counting the max pref width.
4425                     if (!addedTextIndent) {
4426                         childMax += ti;
4427                         widths.beginMax += ti;
4428                         addedTextIndent = true;
4429                     }
4430 
4431                     if (childMin &lt; 0) {
4432                         textIndent = childMin;
4433                         hasRemainingNegativeTextIndent = true;
4434                     }
4435                 }
4436 
4437                 // See if we have a hanging punctuation situation at the start.
4438                 if (canHangPunctuationAtStart &amp;&amp; !addedStartPunctuationHang) {
4439                     unsigned startIndex = strippingBeginWS ? renderText.firstCharacterIndexStrippingSpaces() : 0;
4440                     float hangStartWidth = renderText.hangablePunctuationStartWidth(startIndex);
4441                     childMin -= hangStartWidth;
4442                     widths.beginMin -= hangStartWidth;
4443                     childMax -= hangStartWidth;
4444                     widths.beginMax -= hangStartWidth;
4445                     addedStartPunctuationHang = true;
4446                 }
4447 
4448                 // If we have no breakable characters at all,
4449                 // then this is the easy case. We add ourselves to the current
4450                 // min and max and continue.
4451                 if (!widths.hasBreakableChar)
4452                     inlineMin += childMin;
4453                 else {
4454                     // We have a breakable character. Now we need to know if
4455                     // we start and end with whitespace.
4456                     if (widths.beginWS) {
4457                         // End the current line.
4458                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4459                     } else {
4460                         inlineMin += widths.beginMin;
4461                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4462                         childMin -= ti;
4463                     }
4464 
4465                     inlineMin = childMin;
4466 
4467                     if (widths.endWS) {
4468                         // We end in whitespace, which means we can end our current line.
4469                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4470                         inlineMin = 0;
4471                         shouldBreakLineAfterText = false;
4472                     } else {
4473                         minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4474                         inlineMin = widths.endMin;
4475                         shouldBreakLineAfterText = true;
4476                     }
4477                 }
4478 
4479                 if (widths.hasBreak) {
4480                     inlineMax += widths.beginMax;
4481                     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4482                     maxLogicalWidth = preferredWidth(maxLogicalWidth, childMax);
4483                     inlineMax = widths.endMax;
4484                     addedTextIndent = true;
4485                     addedStartPunctuationHang = true;
4486                 } else
4487                     inlineMax += std::max&lt;float&gt;(0, childMax);
4488             }
4489 
4490             // Ignore spaces after a list marker.
4491             if (child-&gt;isListMarker())
4492                 stripFrontSpaces = true;
4493         } else {
4494             minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4495             maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4496             inlineMin = inlineMax = 0;
4497             stripFrontSpaces = true;
4498             trailingSpaceChild = 0;
4499             addedTextIndent = true;
4500             addedStartPunctuationHang = true;
4501         }
4502 
4503         if (!child-&gt;isText() &amp;&amp; child-&gt;isRenderInline())
4504             isPrevChildInlineFlow = true;
4505         else
4506             isPrevChildInlineFlow = false;
4507 
4508         oldAutoWrap = autoWrap;
4509     }
4510 
4511     if (styleToUse.collapseWhiteSpace())
4512         stripTrailingSpace(inlineMax, inlineMin, trailingSpaceChild);
4513 
4514     if (canHangPunctuationAtEnd &amp;&amp; lastText &amp;&amp; lastText-&gt;text().length() &gt; 0) {
4515         unsigned endIndex = trailingSpaceChild == lastText ? lastText-&gt;lastCharacterIndexStrippingSpaces() : lastText-&gt;text().length() - 1;
4516         float endHangWidth = lastText-&gt;hangablePunctuationEndWidth(endIndex);
4517         inlineMin -= endHangWidth;
4518         inlineMax -= endHangWidth;
4519     }
4520 
4521     minLogicalWidth = preferredWidth(minLogicalWidth, inlineMin);
4522     maxLogicalWidth = preferredWidth(maxLogicalWidth, inlineMax);
4523 }
4524 
4525 }
4526 // namespace WebCore
    </pre>
  </body>
</html>
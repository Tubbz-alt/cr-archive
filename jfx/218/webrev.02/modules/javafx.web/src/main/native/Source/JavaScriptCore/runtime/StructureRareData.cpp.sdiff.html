<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureRareData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StructureInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureRareData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StructureRareData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 
 41 Structure* StructureRareData::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 42 {
 43     return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
 44 }
 45 
 46 StructureRareData* StructureRareData::create(VM&amp; vm, Structure* previous)
 47 {
 48     StructureRareData* rareData = new (NotNull, allocateCell&lt;StructureRareData&gt;(vm.heap)) StructureRareData(vm, previous);
 49     rareData-&gt;finishCreation(vm);
 50     return rareData;
 51 }
 52 
 53 void StructureRareData::destroy(JSCell* cell)
 54 {
 55     static_cast&lt;StructureRareData*&gt;(cell)-&gt;StructureRareData::~StructureRareData();
 56 }
 57 
 58 StructureRareData::StructureRareData(VM&amp; vm, Structure* previous)
 59     : JSCell(vm, vm.structureRareDataStructure.get())
<span class="line-modified"> 60     , m_giveUpOnObjectToStringValueCache(false)</span>

 61 {
 62     if (previous)
 63         m_previous.set(vm, this, previous);
 64 }
 65 
 66 void StructureRareData::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 67 {
 68     StructureRareData* thisObject = jsCast&lt;StructureRareData*&gt;(cell);
 69     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 70 
 71     Base::visitChildren(thisObject, visitor);
 72     visitor.append(thisObject-&gt;m_previous);
<span class="line-modified"> 73     visitor.append(thisObject-&gt;m_objectToStringValue);</span>
 74     visitor.append(thisObject-&gt;m_cachedPropertyNameEnumerator);
 75     auto* cachedOwnKeys = thisObject-&gt;m_cachedOwnKeys.unvalidatedGet();
 76     if (cachedOwnKeys != cachedOwnKeysSentinel())
 77         visitor.appendUnbarriered(cachedOwnKeys);
 78 }
 79 
 80 // ----------- Object.prototype.toString() helper watchpoint classes -----------
 81 
 82 class ObjectToStringAdaptiveInferredPropertyValueWatchpoint final : public AdaptiveInferredPropertyValueWatchpointBase {
 83 public:
 84     typedef AdaptiveInferredPropertyValueWatchpointBase Base;
 85     ObjectToStringAdaptiveInferredPropertyValueWatchpoint(const ObjectPropertyCondition&amp;, StructureRareData*);
 86 
 87 private:
 88     bool isValid() const override;
 89     void handleFire(VM&amp;, const FireDetail&amp;) override;
 90 
 91     StructureRareData* m_structureRareData;
 92 };
 93 
<span class="line-modified"> 94 void StructureRareData::setObjectToStringValue(ExecState* exec, VM&amp; vm, Structure* ownStructure, JSString* value, PropertySlot toStringTagSymbolSlot)</span>
 95 {
<span class="line-modified"> 96     if (m_giveUpOnObjectToStringValueCache)</span>
 97         return;
 98 
 99     ObjectPropertyConditionSet conditionSet;
100     if (toStringTagSymbolSlot.isValue()) {
101         // We don&#39;t handle the own property case of Symbol.toStringTag because we would never know if a new
102         // object transitioning to the same structure had the same value stored in Symbol.toStringTag.
103         // Additionally, this is a super unlikely case anyway.
104         if (!toStringTagSymbolSlot.isCacheable() || toStringTagSymbolSlot.slotBase()-&gt;structure(vm) == ownStructure)
105             return;
106 
107 
108         // This will not create a condition for the current structure but that is good because we know the Symbol.toStringTag
109         // is not on the ownStructure so we will transisition if one is added and this cache will no longer be used.
<span class="line-modified">110         conditionSet = generateConditionsForPrototypePropertyHit(vm, this, exec, ownStructure, toStringTagSymbolSlot.slotBase(), vm.propertyNames-&gt;toStringTagSymbol.impl());</span>

111         ASSERT(!conditionSet.isValid() || conditionSet.hasOneSlotBaseCondition());
<span class="line-modified">112     } else if (toStringTagSymbolSlot.isUnset())</span>
<span class="line-modified">113         conditionSet = generateConditionsForPropertyMiss(vm, this, exec, ownStructure, vm.propertyNames-&gt;toStringTagSymbol.impl());</span>
<span class="line-modified">114     else</span>

115         return;
116 
117     if (!conditionSet.isValid()) {
<span class="line-modified">118         m_giveUpOnObjectToStringValueCache = true;</span>
119         return;
120     }
121 
122     ObjectPropertyCondition equivCondition;
123     for (const ObjectPropertyCondition&amp; condition : conditionSet) {
124         if (condition.condition().kind() == PropertyCondition::Presence) {
125             ASSERT(isValidOffset(condition.offset()));
126             condition.object()-&gt;structure(vm)-&gt;startWatchingPropertyForReplacements(vm, condition.offset());
127             equivCondition = condition.attemptToMakeEquivalenceWithoutBarrier(vm);
128 
129             // The equivalence condition won&#39;t be watchable if we have already seen a replacement.
130             if (!equivCondition.isWatchable()) {
<span class="line-modified">131                 m_giveUpOnObjectToStringValueCache = true;</span>
132                 return;
133             }
134         } else if (!condition.isWatchable()) {
<span class="line-modified">135             m_giveUpOnObjectToStringValueCache = true;</span>
136             return;
137         }
138     }
139 
140     ASSERT(conditionSet.structuresEnsureValidity());
141     for (ObjectPropertyCondition condition : conditionSet) {
142         if (condition.condition().kind() == PropertyCondition::Presence) {
143             m_objectToStringAdaptiveInferredValueWatchpoint = makeUnique&lt;ObjectToStringAdaptiveInferredPropertyValueWatchpoint&gt;(equivCondition, this);
144             m_objectToStringAdaptiveInferredValueWatchpoint-&gt;install(vm);
145         } else
146             m_objectToStringAdaptiveWatchpointSet.add(condition, this)-&gt;install(vm);
147     }
148 
149     m_objectToStringValue.set(vm, this, value);
150 }
151 
152 void StructureRareData::clearObjectToStringValue()
153 {
154     m_objectToStringAdaptiveWatchpointSet.clear();
155     m_objectToStringAdaptiveInferredValueWatchpoint.reset();
<span class="line-modified">156     m_objectToStringValue.clear();</span>

157 }
158 
159 void StructureRareData::finalizeUnconditionally(VM&amp; vm)
160 {
161     if (m_objectToStringAdaptiveInferredValueWatchpoint) {
162         if (!m_objectToStringAdaptiveInferredValueWatchpoint-&gt;key().isStillLive(vm)) {
163             clearObjectToStringValue();
164             return;
165         }
166     }
167     for (auto* watchpoint : m_objectToStringAdaptiveWatchpointSet) {
168         if (!watchpoint-&gt;key().isStillLive(vm)) {
169             clearObjectToStringValue();
170             return;
171         }
172     }
173 }
174 
175 // ------------- Methods for Object.prototype.toString() helper watchpoint classes --------------
176 
</pre>
</td>
<td>
<hr />
<pre>
 40 
 41 Structure* StructureRareData::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 42 {
 43     return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
 44 }
 45 
 46 StructureRareData* StructureRareData::create(VM&amp; vm, Structure* previous)
 47 {
 48     StructureRareData* rareData = new (NotNull, allocateCell&lt;StructureRareData&gt;(vm.heap)) StructureRareData(vm, previous);
 49     rareData-&gt;finishCreation(vm);
 50     return rareData;
 51 }
 52 
 53 void StructureRareData::destroy(JSCell* cell)
 54 {
 55     static_cast&lt;StructureRareData*&gt;(cell)-&gt;StructureRareData::~StructureRareData();
 56 }
 57 
 58 StructureRareData::StructureRareData(VM&amp; vm, Structure* previous)
 59     : JSCell(vm, vm.structureRareDataStructure.get())
<span class="line-modified"> 60     , m_maxOffset(invalidOffset)</span>
<span class="line-added"> 61     , m_transitionOffset(invalidOffset)</span>
 62 {
 63     if (previous)
 64         m_previous.set(vm, this, previous);
 65 }
 66 
 67 void StructureRareData::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 68 {
 69     StructureRareData* thisObject = jsCast&lt;StructureRareData*&gt;(cell);
 70     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 71 
 72     Base::visitChildren(thisObject, visitor);
 73     visitor.append(thisObject-&gt;m_previous);
<span class="line-modified"> 74     visitor.appendUnbarriered(thisObject-&gt;objectToStringValue());</span>
 75     visitor.append(thisObject-&gt;m_cachedPropertyNameEnumerator);
 76     auto* cachedOwnKeys = thisObject-&gt;m_cachedOwnKeys.unvalidatedGet();
 77     if (cachedOwnKeys != cachedOwnKeysSentinel())
 78         visitor.appendUnbarriered(cachedOwnKeys);
 79 }
 80 
 81 // ----------- Object.prototype.toString() helper watchpoint classes -----------
 82 
 83 class ObjectToStringAdaptiveInferredPropertyValueWatchpoint final : public AdaptiveInferredPropertyValueWatchpointBase {
 84 public:
 85     typedef AdaptiveInferredPropertyValueWatchpointBase Base;
 86     ObjectToStringAdaptiveInferredPropertyValueWatchpoint(const ObjectPropertyCondition&amp;, StructureRareData*);
 87 
 88 private:
 89     bool isValid() const override;
 90     void handleFire(VM&amp;, const FireDetail&amp;) override;
 91 
 92     StructureRareData* m_structureRareData;
 93 };
 94 
<span class="line-modified"> 95 void StructureRareData::setObjectToStringValue(JSGlobalObject* globalObject, VM&amp; vm, Structure* ownStructure, JSString* value, PropertySlot toStringTagSymbolSlot)</span>
 96 {
<span class="line-modified"> 97     if (canCacheObjectToStringValue())</span>
 98         return;
 99 
100     ObjectPropertyConditionSet conditionSet;
101     if (toStringTagSymbolSlot.isValue()) {
102         // We don&#39;t handle the own property case of Symbol.toStringTag because we would never know if a new
103         // object transitioning to the same structure had the same value stored in Symbol.toStringTag.
104         // Additionally, this is a super unlikely case anyway.
105         if (!toStringTagSymbolSlot.isCacheable() || toStringTagSymbolSlot.slotBase()-&gt;structure(vm) == ownStructure)
106             return;
107 
108 
109         // This will not create a condition for the current structure but that is good because we know the Symbol.toStringTag
110         // is not on the ownStructure so we will transisition if one is added and this cache will no longer be used.
<span class="line-modified">111         prepareChainForCaching(globalObject, ownStructure, toStringTagSymbolSlot.slotBase());</span>
<span class="line-added">112         conditionSet = generateConditionsForPrototypePropertyHit(vm, this, globalObject, ownStructure, toStringTagSymbolSlot.slotBase(), vm.propertyNames-&gt;toStringTagSymbol.impl());</span>
113         ASSERT(!conditionSet.isValid() || conditionSet.hasOneSlotBaseCondition());
<span class="line-modified">114     } else if (toStringTagSymbolSlot.isUnset()) {</span>
<span class="line-modified">115         prepareChainForCaching(globalObject, ownStructure, nullptr);</span>
<span class="line-modified">116         conditionSet = generateConditionsForPropertyMiss(vm, this, globalObject, ownStructure, vm.propertyNames-&gt;toStringTagSymbol.impl());</span>
<span class="line-added">117     } else</span>
118         return;
119 
120     if (!conditionSet.isValid()) {
<span class="line-modified">121         giveUpOnObjectToStringValueCache();</span>
122         return;
123     }
124 
125     ObjectPropertyCondition equivCondition;
126     for (const ObjectPropertyCondition&amp; condition : conditionSet) {
127         if (condition.condition().kind() == PropertyCondition::Presence) {
128             ASSERT(isValidOffset(condition.offset()));
129             condition.object()-&gt;structure(vm)-&gt;startWatchingPropertyForReplacements(vm, condition.offset());
130             equivCondition = condition.attemptToMakeEquivalenceWithoutBarrier(vm);
131 
132             // The equivalence condition won&#39;t be watchable if we have already seen a replacement.
133             if (!equivCondition.isWatchable()) {
<span class="line-modified">134                 giveUpOnObjectToStringValueCache();</span>
135                 return;
136             }
137         } else if (!condition.isWatchable()) {
<span class="line-modified">138             giveUpOnObjectToStringValueCache();</span>
139             return;
140         }
141     }
142 
143     ASSERT(conditionSet.structuresEnsureValidity());
144     for (ObjectPropertyCondition condition : conditionSet) {
145         if (condition.condition().kind() == PropertyCondition::Presence) {
146             m_objectToStringAdaptiveInferredValueWatchpoint = makeUnique&lt;ObjectToStringAdaptiveInferredPropertyValueWatchpoint&gt;(equivCondition, this);
147             m_objectToStringAdaptiveInferredValueWatchpoint-&gt;install(vm);
148         } else
149             m_objectToStringAdaptiveWatchpointSet.add(condition, this)-&gt;install(vm);
150     }
151 
152     m_objectToStringValue.set(vm, this, value);
153 }
154 
155 void StructureRareData::clearObjectToStringValue()
156 {
157     m_objectToStringAdaptiveWatchpointSet.clear();
158     m_objectToStringAdaptiveInferredValueWatchpoint.reset();
<span class="line-modified">159     if (!canCacheObjectToStringValue())</span>
<span class="line-added">160         m_objectToStringValue.clear();</span>
161 }
162 
163 void StructureRareData::finalizeUnconditionally(VM&amp; vm)
164 {
165     if (m_objectToStringAdaptiveInferredValueWatchpoint) {
166         if (!m_objectToStringAdaptiveInferredValueWatchpoint-&gt;key().isStillLive(vm)) {
167             clearObjectToStringValue();
168             return;
169         }
170     }
171     for (auto* watchpoint : m_objectToStringAdaptiveWatchpointSet) {
172         if (!watchpoint-&gt;key().isStillLive(vm)) {
173             clearObjectToStringValue();
174             return;
175         }
176     }
177 }
178 
179 // ------------- Methods for Object.prototype.toString() helper watchpoint classes --------------
180 
</pre>
</td>
</tr>
</table>
<center><a href="StructureInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StructureRareData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
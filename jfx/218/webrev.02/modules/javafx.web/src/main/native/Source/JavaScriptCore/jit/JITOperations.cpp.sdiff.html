<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOpcodes32_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JITOperations.h&quot;
  28 
  29 #if ENABLE(JIT)
  30 
  31 #include &quot;ArithProfile.h&quot;
  32 #include &quot;ArrayConstructor.h&quot;
<span class="line-modified">  33 #include &quot;CommonSlowPaths.h&quot;</span>

  34 #include &quot;DFGCompilationMode.h&quot;
  35 #include &quot;DFGDriver.h&quot;
  36 #include &quot;DFGOSREntry.h&quot;
  37 #include &quot;DFGThunks.h&quot;
  38 #include &quot;DFGWorklist.h&quot;
  39 #include &quot;Debugger.h&quot;
  40 #include &quot;DirectArguments.h&quot;
  41 #include &quot;Error.h&quot;
  42 #include &quot;ErrorHandlingScope.h&quot;
  43 #include &quot;EvalCodeBlock.h&quot;
  44 #include &quot;ExceptionFuzz.h&quot;
  45 #include &quot;ExecutableBaseInlines.h&quot;
  46 #include &quot;FTLOSREntry.h&quot;
  47 #include &quot;FrameTracers.h&quot;
  48 #include &quot;FunctionCodeBlock.h&quot;
  49 #include &quot;GetterSetter.h&quot;
  50 #include &quot;HostCallReturnValue.h&quot;
  51 #include &quot;ICStats.h&quot;
  52 #include &quot;Interpreter.h&quot;
  53 #include &quot;JIT.h&quot;
  54 #include &quot;JITExceptions.h&quot;
  55 #include &quot;JITToDFGDeferredCompilationCallback.h&quot;
  56 #include &quot;JSAsyncFunction.h&quot;

  57 #include &quot;JSAsyncGeneratorFunction.h&quot;
  58 #include &quot;JSCInlines.h&quot;
  59 #include &quot;JSCPtrTag.h&quot;
  60 #include &quot;JSGeneratorFunction.h&quot;
  61 #include &quot;JSGlobalObjectFunctions.h&quot;

  62 #include &quot;JSLexicalEnvironment.h&quot;
  63 #include &quot;JSWithScope.h&quot;
  64 #include &quot;ModuleProgramCodeBlock.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;PolymorphicAccess.h&quot;
  67 #include &quot;ProgramCodeBlock.h&quot;
  68 #include &quot;PropertyName.h&quot;
  69 #include &quot;RegExpObject.h&quot;
  70 #include &quot;Repatch.h&quot;
  71 #include &quot;ScopedArguments.h&quot;
  72 #include &quot;ShadowChicken.h&quot;
  73 #include &quot;StructureStubInfo.h&quot;
  74 #include &quot;SuperSampler.h&quot;
  75 #include &quot;TestRunnerUtils.h&quot;
  76 #include &quot;ThunkGenerators.h&quot;
  77 #include &quot;TypeProfilerLog.h&quot;
  78 #include &quot;VMInlines.h&quot;
  79 #include &quot;WebAssemblyFunction.h&quot;
  80 #include &lt;wtf/InlineASM.h&gt;
  81 


  82 namespace JSC {
  83 








  84 extern &quot;C&quot; {
  85 
  86 #if COMPILER(MSVC)
  87 void * _ReturnAddress(void);
  88 #pragma intrinsic(_ReturnAddress)
  89 
  90 #define OUR_RETURN_ADDRESS _ReturnAddress()
  91 #else
  92 #define OUR_RETURN_ADDRESS __builtin_return_address(0)
  93 #endif
  94 
  95 #if ENABLE(OPCODE_SAMPLING)
  96 #define CTI_SAMPLER vm.interpreter-&gt;sampler()
  97 #else
  98 #define CTI_SAMPLER 0
  99 #endif
 100 
 101 
<span class="line-modified"> 102 void JIT_OPERATION operationThrowStackOverflowError(ExecState* exec, CodeBlock* codeBlock)</span>
 103 {
 104     // We pass in our own code block, because the callframe hasn&#39;t been populated.
 105     VM&amp; vm = codeBlock-&gt;vm();


 106     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 107     exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 108     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed"> 109     throwStackOverflowError(exec, scope);</span>
 110 }
 111 
<span class="line-modified"> 112 void JIT_OPERATION throwStackOverflowErrorFromThunk(VM* vmPointer, ExecState* exec)</span>
 113 {
<span class="line-modified"> 114     VM&amp; vm = *vmPointer;</span>


 115     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 116     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified"> 117     throwStackOverflowError(exec, scope);</span>
<span class="line-removed"> 118     genericUnwind(vm, exec);</span>
 119     ASSERT(vm.targetMachinePCForThrow);
 120 }
 121 
<span class="line-modified"> 122 int32_t JIT_OPERATION operationCallArityCheck(ExecState* exec)</span>
 123 {
<span class="line-modified"> 124     VM&amp; vm = exec-&gt;vm();</span>


 125     auto scope = DECLARE_THROW_SCOPE(vm);
 126 
<span class="line-modified"> 127     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);</span>
 128     if (UNLIKELY(missingArgCount &lt; 0)) {
<span class="line-modified"> 129         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);</span>
<span class="line-modified"> 130         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 131         NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed"> 132         throwStackOverflowError(vm.topCallFrame, scope);</span>
 133     }
 134 
 135     return missingArgCount;
 136 }
 137 
<span class="line-modified"> 138 int32_t JIT_OPERATION operationConstructArityCheck(ExecState* exec)</span>
 139 {
<span class="line-modified"> 140     VM&amp; vm = exec-&gt;vm();</span>


 141     auto scope = DECLARE_THROW_SCOPE(vm);
 142 
<span class="line-modified"> 143     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);</span>
 144     if (UNLIKELY(missingArgCount &lt; 0)) {
<span class="line-modified"> 145         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);</span>
<span class="line-modified"> 146         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 147         NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed"> 148         throwStackOverflowError(vm.topCallFrame, scope);</span>
 149     }
 150 
 151     return missingArgCount;
 152 }
 153 
<span class="line-modified"> 154 EncodedJSValue JIT_OPERATION operationTryGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 155 {
<span class="line-modified"> 156     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 157     NativeCallFrameTracer tracer(vm, exec);</span>

 158     Identifier ident = Identifier::fromUid(vm, uid);
 159     stubInfo-&gt;tookSlowPath = true;
 160 
 161     JSValue baseValue = JSValue::decode(base);
 162     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 163     baseValue.getPropertySlot(exec, ident, slot);</span>
 164 
 165     return JSValue::encode(slot.getPureResult());
 166 }
 167 
 168 
<span class="line-modified"> 169 EncodedJSValue JIT_OPERATION operationTryGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)</span>
 170 {
<span class="line-modified"> 171     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 172     NativeCallFrameTracer tracer(vm, exec);</span>

 173     Identifier ident = Identifier::fromUid(vm, uid);
 174 
 175     JSValue baseValue = JSValue::decode(base);
 176     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 177     baseValue.getPropertySlot(exec, ident, slot);</span>
 178 
 179     return JSValue::encode(slot.getPureResult());
 180 }
 181 
<span class="line-modified"> 182 EncodedJSValue JIT_OPERATION operationTryGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 183 {
<span class="line-modified"> 184     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 185     NativeCallFrameTracer tracer(vm, exec);</span>

 186     auto scope = DECLARE_THROW_SCOPE(vm);
 187     Identifier ident = Identifier::fromUid(vm, uid);
 188 
 189     JSValue baseValue = JSValue::decode(base);
 190     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 191 
<span class="line-modified"> 192     baseValue.getPropertySlot(exec, ident, slot);</span>
 193     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 194 
<span class="line-modified"> 195     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()) &amp;&amp; !slot.isTaintedByOpaqueObject() &amp;&amp; (slot.isCacheableValue() || slot.isCacheableGetter() || slot.isUnset()))</span>
<span class="line-modified"> 196         repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Try);</span>

 197 
 198     return JSValue::encode(slot.getPureResult());
 199 }
 200 
<span class="line-modified"> 201 EncodedJSValue JIT_OPERATION operationGetByIdDirect(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 202 {
<span class="line-modified"> 203     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 204     NativeCallFrameTracer tracer(vm, exec);</span>

 205     auto scope = DECLARE_THROW_SCOPE(vm);
 206     Identifier ident = Identifier::fromUid(vm, uid);
 207     stubInfo-&gt;tookSlowPath = true;
 208 
 209     JSValue baseValue = JSValue::decode(base);
 210     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 211 
<span class="line-modified"> 212     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);</span>
 213     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 214 
<span class="line-modified"> 215     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));</span>
 216 }
 217 
<span class="line-modified"> 218 EncodedJSValue JIT_OPERATION operationGetByIdDirectGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)</span>
 219 {
<span class="line-modified"> 220     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 221     NativeCallFrameTracer tracer(vm, exec);</span>

 222     auto scope = DECLARE_THROW_SCOPE(vm);
 223     Identifier ident = Identifier::fromUid(vm, uid);
 224 
 225     JSValue baseValue = JSValue::decode(base);
 226     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 227 
<span class="line-modified"> 228     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);</span>
 229     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 230 
<span class="line-modified"> 231     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));</span>
 232 }
 233 
<span class="line-modified"> 234 EncodedJSValue JIT_OPERATION operationGetByIdDirectOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 235 {
<span class="line-modified"> 236     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 237     NativeCallFrameTracer tracer(vm, exec);</span>

 238     auto scope = DECLARE_THROW_SCOPE(vm);
 239     Identifier ident = Identifier::fromUid(vm, uid);
 240 
 241     JSValue baseValue = JSValue::decode(base);
 242     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 243 
<span class="line-modified"> 244     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);</span>
 245     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 246 
<span class="line-modified"> 247     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
<span class="line-modified"> 248         repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Direct);</span>

 249 
<span class="line-modified"> 250     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(exec, ident) : jsUndefined()));</span>
 251 }
 252 
<span class="line-modified"> 253 EncodedJSValue JIT_OPERATION operationGetById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 254 {
 255     SuperSamplerScope superSamplerScope(false);
 256 
<span class="line-modified"> 257     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 258     NativeCallFrameTracer tracer(vm, exec);</span>

 259 
 260     stubInfo-&gt;tookSlowPath = true;
 261 
 262     JSValue baseValue = JSValue::decode(base);
 263     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 264     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 265     JSValue result = baseValue.get(exec, ident, slot);</span>
 266 
 267     LOG_IC((ICEvent::OperationGetById, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 268 
 269     return JSValue::encode(result);
 270 }
 271 
<span class="line-modified"> 272 EncodedJSValue JIT_OPERATION operationGetByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)</span>
 273 {
 274     SuperSamplerScope superSamplerScope(false);
 275 
<span class="line-modified"> 276     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 277     NativeCallFrameTracer tracer(vm, exec);</span>

 278 
 279     JSValue baseValue = JSValue::decode(base);
 280     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 281     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 282     JSValue result = baseValue.get(exec, ident, slot);</span>
 283 
 284     LOG_IC((ICEvent::OperationGetByIdGeneric, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 285 
 286     return JSValue::encode(result);
 287 }
 288 
<span class="line-modified"> 289 EncodedJSValue JIT_OPERATION operationGetByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 290 {
 291     SuperSamplerScope superSamplerScope(false);
 292 
<span class="line-modified"> 293     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 294     NativeCallFrameTracer tracer(vm, exec);</span>

 295     Identifier ident = Identifier::fromUid(vm, uid);
 296 
 297     JSValue baseValue = JSValue::decode(base);
 298 
<span class="line-modified"> 299     return JSValue::encode(baseValue.getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
 300 
 301         LOG_IC((ICEvent::OperationGetByIdOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 302 
<span class="line-modified"> 303         if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
<span class="line-modified"> 304             repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::Normal);</span>
<span class="line-modified"> 305         return found ? slot.getValue(exec, ident) : jsUndefined();</span>

 306     }));
 307 }
 308 
<span class="line-modified"> 309 EncodedJSValue JIT_OPERATION operationGetByIdWithThis(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)</span>
 310 {
 311     SuperSamplerScope superSamplerScope(false);
 312 
<span class="line-modified"> 313     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 314     NativeCallFrameTracer tracer(vm, exec);</span>

 315     Identifier ident = Identifier::fromUid(vm, uid);
 316 
 317     stubInfo-&gt;tookSlowPath = true;
 318 
 319     JSValue baseValue = JSValue::decode(base);
 320     JSValue thisValue = JSValue::decode(thisEncoded);
 321     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 322 
<span class="line-modified"> 323     return JSValue::encode(baseValue.get(exec, ident, slot));</span>
 324 }
 325 
<span class="line-modified"> 326 EncodedJSValue JIT_OPERATION operationGetByIdWithThisGeneric(ExecState* exec, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)</span>
 327 {
 328     SuperSamplerScope superSamplerScope(false);
 329 
<span class="line-modified"> 330     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 331     NativeCallFrameTracer tracer(vm, exec);</span>

 332     Identifier ident = Identifier::fromUid(vm, uid);
 333 
 334     JSValue baseValue = JSValue::decode(base);
 335     JSValue thisValue = JSValue::decode(thisEncoded);
 336     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 337 
<span class="line-modified"> 338     return JSValue::encode(baseValue.get(exec, ident, slot));</span>
 339 }
 340 
<span class="line-modified"> 341 EncodedJSValue JIT_OPERATION operationGetByIdWithThisOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)</span>
 342 {
 343     SuperSamplerScope superSamplerScope(false);
 344 
<span class="line-modified"> 345     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 346     NativeCallFrameTracer tracer(vm, exec);</span>

 347     Identifier ident = Identifier::fromUid(vm, uid);
 348 
 349     JSValue baseValue = JSValue::decode(base);
 350     JSValue thisValue = JSValue::decode(thisEncoded);
 351 
 352     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 353     return JSValue::encode(baseValue.getPropertySlot(exec, ident, slot, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
 354         LOG_IC((ICEvent::OperationGetByIdWithThisOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 355 
<span class="line-modified"> 356         if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseValue.structureOrNull()))</span>
<span class="line-modified"> 357             repatchGetByID(exec, baseValue, ident, slot, *stubInfo, GetByIDKind::WithThis);</span>
<span class="line-modified"> 358         return found ? slot.getValue(exec, ident) : jsUndefined();</span>

 359     }));
 360 }
 361 
<span class="line-modified"> 362 EncodedJSValue JIT_OPERATION operationInById(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 363 {
 364     SuperSamplerScope superSamplerScope(false);
 365 
<span class="line-modified"> 366     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 367     NativeCallFrameTracer tracer(vm, exec);</span>

 368     auto scope = DECLARE_THROW_SCOPE(vm);
 369 
 370     stubInfo-&gt;tookSlowPath = true;
 371 
 372     Identifier ident = Identifier::fromUid(vm, uid);
 373 
 374     JSValue baseValue = JSValue::decode(base);
 375     if (!baseValue.isObject()) {
<span class="line-modified"> 376         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));</span>
 377         return JSValue::encode(jsUndefined());
 378     }
 379     JSObject* baseObject = asObject(baseValue);
 380 
 381     LOG_IC((ICEvent::OperationInById, baseObject-&gt;classInfo(vm), ident));
 382 
 383     scope.release();
 384     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 385     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(exec, ident, slot)));</span>
 386 }
 387 
<span class="line-modified"> 388 EncodedJSValue JIT_OPERATION operationInByIdGeneric(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)</span>
 389 {
 390     SuperSamplerScope superSamplerScope(false);
 391 
<span class="line-modified"> 392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 393     NativeCallFrameTracer tracer(vm, exec);</span>

 394     auto scope = DECLARE_THROW_SCOPE(vm);
 395 
 396     Identifier ident = Identifier::fromUid(vm, uid);
 397 
 398     JSValue baseValue = JSValue::decode(base);
 399     if (!baseValue.isObject()) {
<span class="line-modified"> 400         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));</span>
 401         return JSValue::encode(jsUndefined());
 402     }
 403     JSObject* baseObject = asObject(baseValue);
 404 
 405     LOG_IC((ICEvent::OperationInByIdGeneric, baseObject-&gt;classInfo(vm), ident));
 406 
 407     scope.release();
 408     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 409     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(exec, ident, slot)));</span>
 410 }
 411 
<span class="line-modified"> 412 EncodedJSValue JIT_OPERATION operationInByIdOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 413 {
 414     SuperSamplerScope superSamplerScope(false);
 415 
<span class="line-modified"> 416     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 417     NativeCallFrameTracer tracer(vm, exec);</span>

 418     auto scope = DECLARE_THROW_SCOPE(vm);
 419 
 420     Identifier ident = Identifier::fromUid(vm, uid);
 421 
 422     JSValue baseValue = JSValue::decode(base);
 423     if (!baseValue.isObject()) {
<span class="line-modified"> 424         throwException(exec, scope, createInvalidInParameterError(exec, baseValue));</span>
 425         return JSValue::encode(jsUndefined());
 426     }
 427     JSObject* baseObject = asObject(baseValue);
 428 
 429     LOG_IC((ICEvent::OperationInByIdOptimize, baseObject-&gt;classInfo(vm), ident));
 430 
 431     scope.release();
 432     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 433     bool found = baseObject-&gt;getPropertySlot(exec, ident, slot);</span>
<span class="line-modified"> 434     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), baseObject-&gt;structure(vm)))</span>
<span class="line-modified"> 435         repatchInByID(exec, baseObject, ident, found, slot, *stubInfo);</span>

 436     return JSValue::encode(jsBoolean(found));
 437 }
 438 
<span class="line-modified"> 439 EncodedJSValue JIT_OPERATION operationInByVal(ExecState* exec, JSCell* base, EncodedJSValue key)</span>
 440 {
 441     SuperSamplerScope superSamplerScope(false);
 442 
<span class="line-modified"> 443     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 444     NativeCallFrameTracer tracer(vm, exec);</span>

 445 
<span class="line-modified"> 446     return JSValue::encode(jsBoolean(CommonSlowPaths::opInByVal(exec, base, JSValue::decode(key))));</span>
 447 }
 448 
<span class="line-modified"> 449 void JIT_OPERATION operationPutByIdStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 450 {
 451     SuperSamplerScope superSamplerScope(false);
 452 
<span class="line-modified"> 453     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 454     NativeCallFrameTracer tracer(vm, exec);</span>

 455 
 456     stubInfo-&gt;tookSlowPath = true;
 457 
 458     JSValue baseValue = JSValue::decode(encodedBase);
 459     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 460     PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 461     baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);</span>
 462 
 463     LOG_IC((ICEvent::OperationPutByIdStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 464 }
 465 
<span class="line-modified"> 466 void JIT_OPERATION operationPutByIdNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 467 {
 468     SuperSamplerScope superSamplerScope(false);
 469 
<span class="line-modified"> 470     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 471     NativeCallFrameTracer tracer(vm, exec);</span>

 472 
 473     stubInfo-&gt;tookSlowPath = true;
 474 
 475     JSValue baseValue = JSValue::decode(encodedBase);
 476     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 477     PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 478     baseValue.putInline(exec, ident, JSValue::decode(encodedValue), slot);</span>
 479 
 480     LOG_IC((ICEvent::OperationPutByIdNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 481 }
 482 
<span class="line-modified"> 483 void JIT_OPERATION operationPutByIdDirectStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 484 {
 485     SuperSamplerScope superSamplerScope(false);
 486 
<span class="line-modified"> 487     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 488     NativeCallFrameTracer tracer(vm, exec);</span>

 489 
 490     stubInfo-&gt;tookSlowPath = true;
 491 
 492     JSValue baseValue = JSValue::decode(encodedBase);
 493     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 494     PutPropertySlot slot(baseValue, true, exec-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 495     CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);</span>
 496 
 497     LOG_IC((ICEvent::OperationPutByIdDirectStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 498 }
 499 
<span class="line-modified"> 500 void JIT_OPERATION operationPutByIdDirectNonStrict(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 501 {
 502     SuperSamplerScope superSamplerScope(false);
 503 
<span class="line-modified"> 504     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 505     NativeCallFrameTracer tracer(vm, exec);</span>

 506 
 507     stubInfo-&gt;tookSlowPath = true;
 508 
 509     JSValue baseValue = JSValue::decode(encodedBase);
 510     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 511     PutPropertySlot slot(baseValue, false, exec-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 512     CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);</span>
 513 
 514     LOG_IC((ICEvent::OperationPutByIdDirectNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 515 }
 516 
<span class="line-modified"> 517 void JIT_OPERATION operationPutByIdStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 518 {
 519     SuperSamplerScope superSamplerScope(false);
 520 
<span class="line-modified"> 521     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 522     NativeCallFrameTracer tracer(vm, exec);</span>

 523     auto scope = DECLARE_THROW_SCOPE(vm);
 524 
 525     Identifier ident = Identifier::fromUid(vm, uid);
 526     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 527 
 528     JSValue value = JSValue::decode(encodedValue);
 529     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 530     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 531     PutPropertySlot slot(baseValue, true, codeBlock-&gt;putByIdContext());
 532 
 533     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;
<span class="line-modified"> 534     baseValue.putInline(exec, ident, value, slot);</span>
 535 
 536     LOG_IC((ICEvent::OperationPutByIdStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 537 
 538     RETURN_IF_EXCEPTION(scope, void());
 539 
 540     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 541         return;
 542 
 543     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 544         repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);</span>
 545 }
 546 
<span class="line-modified"> 547 void JIT_OPERATION operationPutByIdNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 548 {
 549     SuperSamplerScope superSamplerScope(false);
 550 
<span class="line-modified"> 551     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 552     NativeCallFrameTracer tracer(vm, exec);</span>

 553     auto scope = DECLARE_THROW_SCOPE(vm);
 554 
 555     Identifier ident = Identifier::fromUid(vm, uid);
 556     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 557 
 558     JSValue value = JSValue::decode(encodedValue);
 559     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 560     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 561     PutPropertySlot slot(baseValue, false, codeBlock-&gt;putByIdContext());
 562 
 563     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;
<span class="line-modified"> 564     baseValue.putInline(exec, ident, value, slot);</span>
 565 
 566     LOG_IC((ICEvent::OperationPutByIdNonStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 567 
 568     RETURN_IF_EXCEPTION(scope, void());
 569 
 570     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 571         return;
 572 
 573     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 574         repatchPutByID(exec, baseValue, structure, ident, slot, *stubInfo, NotDirect);</span>
 575 }
 576 
<span class="line-modified"> 577 void JIT_OPERATION operationPutByIdDirectStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 578 {
 579     SuperSamplerScope superSamplerScope(false);
 580 
<span class="line-modified"> 581     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 582     NativeCallFrameTracer tracer(vm, exec);</span>

 583     auto scope = DECLARE_THROW_SCOPE(vm);
 584 
 585     Identifier ident = Identifier::fromUid(vm, uid);
 586     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 587 
 588     JSValue value = JSValue::decode(encodedValue);
 589     JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="line-modified"> 590     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 591     PutPropertySlot slot(baseObject, true, codeBlock-&gt;putByIdContext());
 592     Structure* structure = nullptr;
<span class="line-modified"> 593     CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);</span>
 594 
 595     LOG_IC((ICEvent::OperationPutByIdDirectStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));
 596 
 597     RETURN_IF_EXCEPTION(scope, void());
 598 
 599     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 600         return;
 601 
 602     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 603         repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);</span>
 604 }
 605 
<span class="line-modified"> 606 void JIT_OPERATION operationPutByIdDirectNonStrictOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 607 {
 608     SuperSamplerScope superSamplerScope(false);
 609 
<span class="line-modified"> 610     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 611     NativeCallFrameTracer tracer(vm, exec);</span>

 612     auto scope = DECLARE_THROW_SCOPE(vm);
 613 
 614     Identifier ident = Identifier::fromUid(vm, uid);
 615     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 616 
 617     JSValue value = JSValue::decode(encodedValue);
 618     JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="line-modified"> 619     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 620     PutPropertySlot slot(baseObject, false, codeBlock-&gt;putByIdContext());
 621     Structure* structure = nullptr;
<span class="line-modified"> 622     CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, ident, value, slot, &amp;structure);</span>
 623 
 624     LOG_IC((ICEvent::OperationPutByIdDirectNonStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));
 625 
 626     RETURN_IF_EXCEPTION(scope, void());
 627 
 628     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 629         return;
 630 
 631     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 632         repatchPutByID(exec, baseObject, structure, ident, slot, *stubInfo, Direct);</span>
 633 }
 634 
 635 ALWAYS_INLINE static bool isStringOrSymbol(JSValue value)
 636 {
 637     return value.isString() || value.isSymbol();
 638 }
 639 
<span class="line-modified"> 640 static void putByVal(CallFrame* callFrame, JSValue baseValue, JSValue subscript, JSValue value, ByValInfo* byValInfo)</span>
 641 {
<span class="line-modified"> 642     VM&amp; vm = callFrame-&gt;vm();</span>
 643     auto scope = DECLARE_THROW_SCOPE(vm);
 644     if (LIKELY(subscript.isUInt32())) {
 645         byValInfo-&gt;tookSlowPath = true;
 646         uint32_t i = subscript.asUInt32();
 647         if (baseValue.isObject()) {
 648             JSObject* object = asObject(baseValue);
 649             if (object-&gt;canSetIndexQuickly(i, value)) {
 650                 object-&gt;setIndexQuickly(vm, i, value);
 651                 return;
 652             }
 653 
 654             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 655             scope.release();
<span class="line-modified"> 656             object-&gt;methodTable(vm)-&gt;putByIndex(object, callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());</span>
 657             return;
 658         }
 659 
 660         scope.release();
<span class="line-modified"> 661         baseValue.putByIndex(callFrame, i, value, callFrame-&gt;codeBlock()-&gt;isStrictMode());</span>
 662         return;
 663     } else if (subscript.isInt32()) {
 664         byValInfo-&gt;tookSlowPath = true;
 665         if (baseValue.isObject())
 666             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 667     }
 668 
<span class="line-modified"> 669     auto property = subscript.toPropertyKey(callFrame);</span>
 670     // Don&#39;t put to an object if toString threw an exception.
 671     RETURN_IF_EXCEPTION(scope, void());
 672 
 673     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
 674         byValInfo-&gt;tookSlowPath = true;
 675 
 676     scope.release();
<span class="line-modified"> 677     PutPropertySlot slot(baseValue, callFrame-&gt;codeBlock()-&gt;isStrictMode());</span>
<span class="line-modified"> 678     baseValue.putInline(callFrame, property, value, slot);</span>
 679 }
 680 
<span class="line-modified"> 681 static void directPutByVal(CallFrame* callFrame, JSObject* baseObject, JSValue subscript, JSValue value, ByValInfo* byValInfo)</span>
 682 {
<span class="line-modified"> 683     VM&amp; vm = callFrame-&gt;vm();</span>
 684     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 685     bool isStrictMode = callFrame-&gt;codeBlock()-&gt;isStrictMode();</span>
 686 
 687     if (LIKELY(subscript.isUInt32())) {
 688         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
 689         byValInfo-&gt;tookSlowPath = true;
 690         uint32_t index = subscript.asUInt32();
 691         ASSERT(isIndex(index));
 692 
 693         switch (baseObject-&gt;indexingType()) {
 694         case ALL_INT32_INDEXING_TYPES:
 695         case ALL_DOUBLE_INDEXING_TYPES:
 696         case ALL_CONTIGUOUS_INDEXING_TYPES:
 697         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 698             if (index &lt; baseObject-&gt;butterfly()-&gt;vectorLength())
 699                 break;
 700             FALLTHROUGH;
 701         default:
 702             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 703             break;
 704         }
 705 
 706         scope.release();
<span class="line-modified"> 707         baseObject-&gt;putDirectIndex(callFrame, index, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 708         return;
 709     }
 710 
 711     if (subscript.isDouble()) {
 712         double subscriptAsDouble = subscript.asDouble();
 713         uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
 714         if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
 715             byValInfo-&gt;tookSlowPath = true;
 716             scope.release();
<span class="line-modified"> 717             baseObject-&gt;putDirectIndex(callFrame, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 718             return;
 719         }
 720     }
 721 
 722     // Don&#39;t put to an object if toString threw an exception.
<span class="line-modified"> 723     auto property = subscript.toPropertyKey(callFrame);</span>
 724     RETURN_IF_EXCEPTION(scope, void());
 725 
 726     if (Optional&lt;uint32_t&gt; index = parseIndex(property)) {
 727         byValInfo-&gt;tookSlowPath = true;
 728         scope.release();
<span class="line-modified"> 729         baseObject-&gt;putDirectIndex(callFrame, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 730         return;
 731     }
 732 
 733     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
 734         byValInfo-&gt;tookSlowPath = true;
 735 
 736     scope.release();
 737     PutPropertySlot slot(baseObject, isStrictMode);
<span class="line-modified"> 738     CommonSlowPaths::putDirectWithReify(vm, callFrame, baseObject, property, value, slot);</span>
 739 }
 740 
 741 enum class OptimizationResult {
 742     NotOptimized,
 743     SeenOnce,
 744     Optimized,
 745     GiveUp,
 746 };
 747 
<span class="line-modified"> 748 static OptimizationResult tryPutByValOptimize(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)</span>
 749 {


 750     // See if it&#39;s worth optimizing at all.
 751     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 752 
<span class="line-modified"> 753     VM&amp; vm = exec-&gt;vm();</span>
 754     auto scope = DECLARE_THROW_SCOPE(vm);
 755 
 756     if (baseValue.isObject() &amp;&amp; isCopyOnWrite(baseValue.getObject()-&gt;indexingMode()))
 757         return OptimizationResult::GiveUp;
 758 
 759     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
 760         JSObject* object = asObject(baseValue);
 761 
<span class="line-modified"> 762         ASSERT(exec-&gt;bytecodeOffset());</span>
 763         ASSERT(!byValInfo-&gt;stubRoutine);
 764 
 765         Structure* structure = object-&gt;structure(vm);
 766         if (hasOptimizableIndexing(structure)) {
 767             // Attempt to optimize.
 768             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 769             if (jitArrayModePermitsPut(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
<span class="line-removed"> 770                 CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 771                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 772                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
 773                 JIT::compilePutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);
 774                 optimizationResult = OptimizationResult::Optimized;
 775             }
 776         }
 777 
 778         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 779         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 780             optimizationResult = OptimizationResult::GiveUp;
 781     }
 782 
 783     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
<span class="line-modified"> 784         const Identifier propertyName = subscript.toPropertyKey(exec);</span>
 785         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);
 786         if (subscript.isSymbol() || !parseIndex(propertyName)) {
<span class="line-modified"> 787             ASSERT(exec-&gt;bytecodeOffset());</span>
 788             ASSERT(!byValInfo-&gt;stubRoutine);
 789             if (byValInfo-&gt;seen) {
 790                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 791                     JIT::compilePutByValWithCachedId&lt;OpPutByVal&gt;(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, NotDirect, propertyName);</span>
 792                     optimizationResult = OptimizationResult::Optimized;
 793                 } else {
 794                     // Seem like a generic property access site.
 795                     optimizationResult = OptimizationResult::GiveUp;
 796                 }
 797             } else {
<span class="line-removed"> 798                 CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 799                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 800                 byValInfo-&gt;seen = true;
 801                 byValInfo-&gt;cachedId = propertyName;
 802                 if (subscript.isSymbol())
 803                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 804                 optimizationResult = OptimizationResult::SeenOnce;
 805             }
 806         }
 807     }
 808 
 809     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 810         // If we take slow path more than 10 times without patching then make sure we
 811         // never make that mistake again. For cases where we see non-index-intercepting
 812         // objects, this gives 10 iterations worth of opportunity for us to observe
 813         // that the put_by_val may be polymorphic. We count up slowPathCount even if
 814         // the result is GiveUp.
 815         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 816             optimizationResult = OptimizationResult::GiveUp;
 817     }
 818 
 819     return optimizationResult;
 820 }
 821 
<span class="line-modified"> 822 void JIT_OPERATION operationPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 823 {
<span class="line-modified"> 824     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 825     NativeCallFrameTracer tracer(vm, exec);</span>

 826     auto scope = DECLARE_THROW_SCOPE(vm);
 827 
 828     JSValue baseValue = JSValue::decode(encodedBaseValue);
 829     JSValue subscript = JSValue::decode(encodedSubscript);
 830     JSValue value = JSValue::decode(encodedValue);
<span class="line-modified"> 831     OptimizationResult result = tryPutByValOptimize(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>

 832     RETURN_IF_EXCEPTION(scope, void());
 833     if (result == OptimizationResult::GiveUp) {
 834         // Don&#39;t ever try to optimize.
 835         byValInfo-&gt;tookSlowPath = true;
 836         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationPutByValGeneric);
 837     }
<span class="line-modified"> 838     RELEASE_AND_RETURN(scope, putByVal(exec, baseValue, subscript, value, byValInfo));</span>
 839 }
 840 
<span class="line-modified"> 841 static OptimizationResult tryDirectPutByValOptimize(ExecState* exec, JSObject* object, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)</span>
 842 {


 843     // See if it&#39;s worth optimizing at all.
 844     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 845 
<span class="line-modified"> 846     VM&amp; vm = exec-&gt;vm();</span>
 847     auto scope = DECLARE_THROW_SCOPE(vm);
 848 
 849     if (subscript.isInt32()) {
<span class="line-modified"> 850         ASSERT(exec-&gt;bytecodeOffset());</span>
 851         ASSERT(!byValInfo-&gt;stubRoutine);
 852 
 853         Structure* structure = object-&gt;structure(vm);
 854         if (hasOptimizableIndexing(structure)) {
 855             // Attempt to optimize.
 856             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 857             if (jitArrayModePermitsPutDirect(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {
<span class="line-removed"> 858                 CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 859                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 860                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
 861 
 862                 JIT::compileDirectPutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);
 863                 optimizationResult = OptimizationResult::Optimized;
 864             }
 865         }
 866 
 867         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 868         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 869             optimizationResult = OptimizationResult::GiveUp;
 870     } else if (isStringOrSymbol(subscript)) {
<span class="line-modified"> 871         const Identifier propertyName = subscript.toPropertyKey(exec);</span>
 872         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);
 873         if (subscript.isSymbol() || !parseIndex(propertyName)) {
<span class="line-modified"> 874             ASSERT(exec-&gt;bytecodeOffset());</span>
 875             ASSERT(!byValInfo-&gt;stubRoutine);
 876             if (byValInfo-&gt;seen) {
 877                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 878                     JIT::compilePutByValWithCachedId&lt;OpPutByValDirect&gt;(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, Direct, propertyName);</span>
 879                     optimizationResult = OptimizationResult::Optimized;
 880                 } else {
 881                     // Seem like a generic property access site.
 882                     optimizationResult = OptimizationResult::GiveUp;
 883                 }
 884             } else {
<span class="line-removed"> 885                 CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 886                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 887                 byValInfo-&gt;seen = true;
 888                 byValInfo-&gt;cachedId = propertyName;
 889                 if (subscript.isSymbol())
 890                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 891                 optimizationResult = OptimizationResult::SeenOnce;
 892             }
 893         }
 894     }
 895 
 896     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 897         // If we take slow path more than 10 times without patching then make sure we
 898         // never make that mistake again. For cases where we see non-index-intercepting
 899         // objects, this gives 10 iterations worth of opportunity for us to observe
 900         // that the get_by_val may be polymorphic. We count up slowPathCount even if
 901         // the result is GiveUp.
 902         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 903             optimizationResult = OptimizationResult::GiveUp;
 904     }
 905 
 906     return optimizationResult;
 907 }
 908 
<span class="line-modified"> 909 void JIT_OPERATION operationDirectPutByValOptimize(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 910 {
<span class="line-modified"> 911     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 912     NativeCallFrameTracer tracer(vm, exec);</span>

 913     auto scope = DECLARE_THROW_SCOPE(vm);
 914 
 915     JSValue baseValue = JSValue::decode(encodedBaseValue);
 916     JSValue subscript = JSValue::decode(encodedSubscript);
 917     JSValue value = JSValue::decode(encodedValue);
 918     RELEASE_ASSERT(baseValue.isObject());
 919     JSObject* object = asObject(baseValue);
<span class="line-modified"> 920     OptimizationResult result = tryDirectPutByValOptimize(exec, object, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>

 921     RETURN_IF_EXCEPTION(scope, void());
 922     if (result == OptimizationResult::GiveUp) {
 923         // Don&#39;t ever try to optimize.
 924         byValInfo-&gt;tookSlowPath = true;
 925         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationDirectPutByValGeneric);
 926     }
 927 
<span class="line-modified"> 928     RELEASE_AND_RETURN(scope, directPutByVal(exec, object, subscript, value, byValInfo));</span>
 929 }
 930 
<span class="line-modified"> 931 void JIT_OPERATION operationPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 932 {
<span class="line-modified"> 933     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 934     NativeCallFrameTracer tracer(vm, exec);</span>

 935 
 936     JSValue baseValue = JSValue::decode(encodedBaseValue);
 937     JSValue subscript = JSValue::decode(encodedSubscript);
 938     JSValue value = JSValue::decode(encodedValue);
 939 
<span class="line-modified"> 940     putByVal(exec, baseValue, subscript, value, byValInfo);</span>
 941 }
 942 
 943 
<span class="line-modified"> 944 void JIT_OPERATION operationDirectPutByValGeneric(ExecState* exec, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 945 {
<span class="line-modified"> 946     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified"> 947     NativeCallFrameTracer tracer(vm, exec);</span>

 948 
 949     JSValue baseValue = JSValue::decode(encodedBaseValue);
 950     JSValue subscript = JSValue::decode(encodedSubscript);
 951     JSValue value = JSValue::decode(encodedValue);
 952     RELEASE_ASSERT(baseValue.isObject());
<span class="line-modified"> 953     directPutByVal(exec, asObject(baseValue), subscript, value, byValInfo);</span>
 954 }
 955 
<span class="line-modified"> 956 EncodedJSValue JIT_OPERATION operationCallEval(ExecState* exec, ExecState* execCallee)</span>
 957 {
<span class="line-modified"> 958     VM&amp; vm = exec-&gt;vm();</span>
 959     auto scope = DECLARE_THROW_SCOPE(vm);
 960 
<span class="line-modified"> 961     execCallee-&gt;setCodeBlock(0);</span>
 962 
<span class="line-modified"> 963     if (!isHostFunction(execCallee-&gt;guaranteedJSValueCallee(), globalFuncEval))</span>
 964         return JSValue::encode(JSValue());
 965 
<span class="line-modified"> 966     JSValue result = eval(execCallee);</span>
 967     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 968 
 969     return JSValue::encode(result);
 970 }
 971 
<span class="line-modified"> 972 static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CallLinkInfo* callLinkInfo)</span>
 973 {
<span class="line-modified"> 974     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-removed"> 975     VM&amp; vm = exec-&gt;vm();</span>
 976     auto scope = DECLARE_THROW_SCOPE(vm);
 977 
<span class="line-modified"> 978     execCallee-&gt;setCodeBlock(0);</span>
 979 
 980     if (callLinkInfo-&gt;specializationKind() == CodeForCall) {
 981         CallData callData;
 982         CallType callType = getCallData(vm, callee, callData);
 983 
 984         ASSERT(callType != CallType::JS);
 985 
 986         if (callType == CallType::Host) {
<span class="line-modified"> 987             NativeCallFrameTracer tracer(vm, execCallee);</span>
<span class="line-modified"> 988             execCallee-&gt;setCallee(asObject(callee));</span>
<span class="line-modified"> 989             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
 990             if (UNLIKELY(scope.exception())) {
 991                 return encodeResult(
 992                     vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
 993                     reinterpret_cast&lt;void*&gt;(KeepTheFrame));
 994             }
 995 
 996             return encodeResult(
 997                 tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue),
 998                 reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
 999         }
1000 
1001         ASSERT(callType == CallType::None);
<span class="line-modified">1002         throwException(exec, scope, createNotAFunctionError(exec, callee));</span>
1003         return encodeResult(
1004             vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1005             reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1006     }
1007 
1008     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForConstruct);
1009 
1010     ConstructData constructData;
1011     ConstructType constructType = getConstructData(vm, callee, constructData);
1012 
1013     ASSERT(constructType != ConstructType::JS);
1014 
1015     if (constructType == ConstructType::Host) {
<span class="line-modified">1016         NativeCallFrameTracer tracer(vm, execCallee);</span>
<span class="line-modified">1017         execCallee-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1018         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
1019         if (UNLIKELY(scope.exception())) {
1020             return encodeResult(
1021                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1022                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1023         }
1024 
1025         return encodeResult(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue), reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1026     }
1027 
1028     ASSERT(constructType == ConstructType::None);
<span class="line-modified">1029     throwException(exec, scope, createNotAConstructorError(exec, callee));</span>
1030     return encodeResult(
1031         vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1032         reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1033 }
1034 
<span class="line-modified">1035 SlowPathReturnType JIT_OPERATION operationLinkCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)</span>
1036 {
<span class="line-modified">1037     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-modified">1038     VM&amp; vm = exec-&gt;vm();</span>
1039     auto throwScope = DECLARE_THROW_SCOPE(vm);
1040 
1041     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
<span class="line-modified">1042     NativeCallFrameTracer tracer(vm, exec);</span>
1043 
1044     RELEASE_ASSERT(!callLinkInfo-&gt;isDirect());
1045 
<span class="line-modified">1046     JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();</span>
1047     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1048     if (!calleeAsFunctionCell) {
1049         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1050             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1051             RELEASE_ASSERT(!!codePtr);
1052 
1053             if (!callLinkInfo-&gt;seenOnce())
1054                 callLinkInfo-&gt;setSeen();
1055             else
<span class="line-modified">1056                 linkFor(execCallee, *callLinkInfo, nullptr, internalFunction, codePtr);</span>
1057 
1058             void* linkedTarget = codePtr.executableAddress();
1059             return encodeResult(linkedTarget, reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1060         }
<span class="line-modified">1061         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));</span>
1062     }
1063 
1064     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1065     JSScope* scope = callee-&gt;scopeUnchecked();
1066     ExecutableBase* executable = callee-&gt;executable();
1067 
1068     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1069     CodeBlock* codeBlock = nullptr;
1070     if (executable-&gt;isHostFunction()) {
1071         codePtr = jsToWasmICCodePtr(vm, kind, callee);
1072         if (!codePtr)
1073             codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1074     } else {
1075         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1076 
1077         auto handleThrowException = [&amp;] () {
1078             void* throwTarget = vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress();
1079             return encodeResult(throwTarget, reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1080         };
1081 
1082         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
<span class="line-modified">1083             throwException(exec, throwScope, createNotAConstructorError(exec, callee));</span>
1084             return handleThrowException();
1085         }
1086 
<span class="line-modified">1087         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();</span>
1088         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);
1089         EXCEPTION_ASSERT(throwScope.exception() == error);
1090         if (UNLIKELY(error))
1091             return handleThrowException();
1092         codeBlock = *codeBlockSlot;
1093         ArityCheckMode arity;
<span class="line-modified">1094         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo-&gt;isVarargs())</span>
1095             arity = MustCheckArity;
1096         else
1097             arity = ArityCheckNotRequired;
1098         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1099     }
1100 
1101     if (!callLinkInfo-&gt;seenOnce())
1102         callLinkInfo-&gt;setSeen();
1103     else
<span class="line-modified">1104         linkFor(execCallee, *callLinkInfo, codeBlock, callee, codePtr);</span>
1105 
1106     return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1107 }
1108 
<span class="line-modified">1109 void JIT_OPERATION operationLinkDirectCall(ExecState* exec, CallLinkInfo* callLinkInfo, JSFunction* callee)</span>
<span class="line-removed">1110 {</span>
<span class="line-removed">1111     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1112     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1113 </span>
<span class="line-removed">1114     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();</span>
<span class="line-removed">1115     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">1116 </span>
<span class="line-removed">1117     RELEASE_ASSERT(callLinkInfo-&gt;isDirect());</span>
<span class="line-removed">1118 </span>
<span class="line-removed">1119     // This would happen if the executable died during GC but the CodeBlock did not die. That should</span>
<span class="line-removed">1120     // not happen because the CodeBlock should have a weak reference to any executable it uses for</span>
<span class="line-removed">1121     // this purpose.</span>
<span class="line-removed">1122     RELEASE_ASSERT(callLinkInfo-&gt;executable());</span>
<span class="line-removed">1123 </span>
<span class="line-removed">1124     // Having a CodeBlock indicates that this is linked. We shouldn&#39;t be taking this path if it&#39;s</span>
<span class="line-removed">1125     // linked.</span>
<span class="line-removed">1126     RELEASE_ASSERT(!callLinkInfo-&gt;codeBlock());</span>
<span class="line-removed">1127 </span>
<span class="line-removed">1128     // We just don&#39;t support this yet.</span>
<span class="line-removed">1129     RELEASE_ASSERT(!callLinkInfo-&gt;isVarargs());</span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131     ExecutableBase* executable = callLinkInfo-&gt;executable();</span>
<span class="line-removed">1132     RELEASE_ASSERT(callee-&gt;executable() == callLinkInfo-&gt;executable());</span>
<span class="line-removed">1133 </span>
<span class="line-removed">1134     JSScope* scope = callee-&gt;scopeUnchecked();</span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;</span>
<span class="line-removed">1137     CodeBlock* codeBlock = nullptr;</span>
<span class="line-removed">1138     if (executable-&gt;isHostFunction())</span>
<span class="line-removed">1139         codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-removed">1140     else {</span>
<span class="line-removed">1141         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);</span>
<span class="line-removed">1142 </span>
<span class="line-removed">1143         RELEASE_ASSERT(isCall(kind) || functionExecutable-&gt;constructAbility() != ConstructAbility::CannotConstruct);</span>
<span class="line-removed">1144 </span>
<span class="line-removed">1145         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, codeBlock);</span>
<span class="line-removed">1146         EXCEPTION_ASSERT_UNUSED(throwScope, throwScope.exception() == error);</span>
<span class="line-removed">1147         if (UNLIKELY(error))</span>
<span class="line-removed">1148             return;</span>
<span class="line-removed">1149         unsigned argumentStackSlots = callLinkInfo-&gt;maxNumArguments();</span>
<span class="line-removed">1150         if (argumentStackSlots &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
<span class="line-removed">1151             codePtr = functionExecutable-&gt;entrypointFor(kind, MustCheckArity);</span>
<span class="line-removed">1152         else</span>
<span class="line-removed">1153             codePtr = functionExecutable-&gt;entrypointFor(kind, ArityCheckNotRequired);</span>
<span class="line-removed">1154     }</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156     linkDirectFor(exec, *callLinkInfo, codeBlock, codePtr);</span>
<span class="line-removed">1157 }</span>
<span class="line-removed">1158 </span>
<span class="line-removed">1159 inline SlowPathReturnType virtualForWithFunction(</span>
<span class="line-removed">1160     ExecState* execCallee, CallLinkInfo* callLinkInfo, JSCell*&amp; calleeAsFunctionCell)</span>
1161 {
<span class="line-modified">1162     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-modified">1163     VM&amp; vm = exec-&gt;vm();</span>
1164     auto throwScope = DECLARE_THROW_SCOPE(vm);
1165 
1166     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
<span class="line-modified">1167     NativeCallFrameTracer tracer(vm, exec);</span>
1168 
<span class="line-modified">1169     JSValue calleeAsValue = execCallee-&gt;guaranteedJSValueCallee();</span>
1170     calleeAsFunctionCell = getJSFunction(calleeAsValue);
1171     if (UNLIKELY(!calleeAsFunctionCell)) {
1172         if (jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1173             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1174             ASSERT(!!codePtr);
1175             return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1176         }
<span class="line-modified">1177         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, callLinkInfo));</span>
1178     }
1179 
1180     JSFunction* function = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1181     JSScope* scope = function-&gt;scopeUnchecked();
1182     ExecutableBase* executable = function-&gt;executable();
1183     if (UNLIKELY(!executable-&gt;hasJITCodeFor(kind))) {
1184         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1185 
1186         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
<span class="line-modified">1187             throwException(exec, throwScope, createNotAConstructorError(exec, function));</span>
1188             return encodeResult(
1189                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1190                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1191         }
1192 
<span class="line-modified">1193         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();</span>
1194         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, kind, *codeBlockSlot);
1195         EXCEPTION_ASSERT(throwScope.exception() == error);
1196         if (UNLIKELY(error)) {
1197             return encodeResult(
1198                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1199                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1200         }
1201     }
1202     return encodeResult(executable-&gt;entrypointFor(
1203         kind, MustCheckArity).executableAddress(),
1204         reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1205 }
1206 
<span class="line-modified">1207 SlowPathReturnType JIT_OPERATION operationLinkPolymorphicCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)</span>
1208 {
1209     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForCall);
1210     JSCell* calleeAsFunctionCell;
<span class="line-modified">1211     SlowPathReturnType result = virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCell);</span>
1212 
<span class="line-modified">1213     linkPolymorphicCall(execCallee, *callLinkInfo, CallVariant(calleeAsFunctionCell));</span>
1214 
1215     return result;
1216 }
1217 
<span class="line-modified">1218 SlowPathReturnType JIT_OPERATION operationVirtualCall(ExecState* execCallee, CallLinkInfo* callLinkInfo)</span>
1219 {
1220     JSCell* calleeAsFunctionCellIgnored;
<span class="line-modified">1221     return virtualForWithFunction(execCallee, callLinkInfo, calleeAsFunctionCellIgnored);</span>
1222 }
1223 
<span class="line-modified">1224 size_t JIT_OPERATION operationCompareLess(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1225 {
<span class="line-modified">1226     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1227     NativeCallFrameTracer tracer(vm, exec);</span>

1228 
<span class="line-modified">1229     return jsLess&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));</span>
1230 }
1231 
<span class="line-modified">1232 size_t JIT_OPERATION operationCompareLessEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1233 {
<span class="line-modified">1234     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1235     NativeCallFrameTracer tracer(vm, exec);</span>

1236 
<span class="line-modified">1237     return jsLessEq&lt;true&gt;(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));</span>
1238 }
1239 
<span class="line-modified">1240 size_t JIT_OPERATION operationCompareGreater(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1241 {
<span class="line-modified">1242     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1243     NativeCallFrameTracer tracer(vm, exec);</span>

1244 
<span class="line-modified">1245     return jsLess&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));</span>
1246 }
1247 
<span class="line-modified">1248 size_t JIT_OPERATION operationCompareGreaterEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1249 {
<span class="line-modified">1250     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1251     NativeCallFrameTracer tracer(vm, exec);</span>

1252 
<span class="line-modified">1253     return jsLessEq&lt;false&gt;(exec, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));</span>
1254 }
1255 
<span class="line-modified">1256 size_t JIT_OPERATION operationCompareEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1257 {
<span class="line-modified">1258     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1259     NativeCallFrameTracer tracer(vm, exec);</span>

1260 
<span class="line-modified">1261     return JSValue::equalSlowCaseInline(exec, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));</span>
1262 }
1263 
1264 #if USE(JSVALUE64)
<span class="line-modified">1265 EncodedJSValue JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)</span>
1266 #else
<span class="line-modified">1267 size_t JIT_OPERATION operationCompareStringEq(ExecState* exec, JSCell* left, JSCell* right)</span>
1268 #endif
1269 {
<span class="line-modified">1270     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1271     NativeCallFrameTracer tracer(vm, exec);</span>

1272 
<span class="line-modified">1273     bool result = asString(left)-&gt;equal(exec, asString(right));</span>
1274 #if USE(JSVALUE64)
1275     return JSValue::encode(jsBoolean(result));
1276 #else
1277     return result;
1278 #endif
1279 }
1280 
<span class="line-modified">1281 size_t JIT_OPERATION operationCompareStrictEq(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1282 {
<span class="line-modified">1283     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1284     NativeCallFrameTracer tracer(vm, exec);</span>

1285 
1286     JSValue src1 = JSValue::decode(encodedOp1);
1287     JSValue src2 = JSValue::decode(encodedOp2);
1288 
<span class="line-modified">1289     return JSValue::strictEqual(exec, src1, src2);</span>
1290 }
1291 
<span class="line-modified">1292 EncodedJSValue JIT_OPERATION operationNewArrayWithProfile(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, int size)</span>
1293 {
<span class="line-modified">1294     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1295     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">1296     return JSValue::encode(constructArrayNegativeIndexed(exec, profile, values, size));</span>

1297 }
1298 
<span class="line-modified">1299 EncodedJSValue JIT_OPERATION operationNewArrayWithSizeAndProfile(ExecState* exec, ArrayAllocationProfile* profile, EncodedJSValue size)</span>
1300 {
<span class="line-modified">1301     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1302     NativeCallFrameTracer tracer(vm, exec);</span>

1303     JSValue sizeValue = JSValue::decode(size);
<span class="line-modified">1304     return JSValue::encode(constructArrayWithSizeQuirk(exec, profile, exec-&gt;lexicalGlobalObject(), sizeValue));</span>
1305 }
1306 
1307 }
1308 
1309 template&lt;typename FunctionType&gt;
<span class="line-modified">1310 static EncodedJSValue operationNewFunctionCommon(ExecState* exec, JSScope* scope, JSCell* functionExecutable, bool isInvalidated)</span>
1311 {
<span class="line-removed">1312     VM&amp; vm = exec-&gt;vm();</span>
1313     ASSERT(functionExecutable-&gt;inherits&lt;FunctionExecutable&gt;(vm));
<span class="line-removed">1314     NativeCallFrameTracer tracer(vm, exec);</span>
1315     if (isInvalidated)
1316         return JSValue::encode(FunctionType::createWithInvalidatedReallocationWatchpoint(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1317     return JSValue::encode(FunctionType::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1318 }
1319 
1320 extern &quot;C&quot; {
1321 
<span class="line-modified">1322 EncodedJSValue JIT_OPERATION operationNewFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1323 {
<span class="line-modified">1324     return operationNewFunctionCommon&lt;JSFunction&gt;(exec, scope, functionExecutable, false);</span>



1325 }
1326 
<span class="line-modified">1327 EncodedJSValue JIT_OPERATION operationNewFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1328 {
<span class="line-modified">1329     return operationNewFunctionCommon&lt;JSFunction&gt;(exec, scope, functionExecutable, true);</span>



1330 }
1331 
<span class="line-modified">1332 EncodedJSValue JIT_OPERATION operationNewGeneratorFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1333 {
<span class="line-modified">1334     return operationNewFunctionCommon&lt;JSGeneratorFunction&gt;(exec, scope, functionExecutable, false);</span>



1335 }
1336 
<span class="line-modified">1337 EncodedJSValue JIT_OPERATION operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1338 {
<span class="line-modified">1339     return operationNewFunctionCommon&lt;JSGeneratorFunction&gt;(exec, scope, functionExecutable, true);</span>



1340 }
1341 
<span class="line-modified">1342 EncodedJSValue JIT_OPERATION operationNewAsyncFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1343 {
<span class="line-modified">1344     return operationNewFunctionCommon&lt;JSAsyncFunction&gt;(exec, scope, functionExecutable, false);</span>



1345 }
1346 
<span class="line-modified">1347 EncodedJSValue JIT_OPERATION operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1348 {
<span class="line-modified">1349     return operationNewFunctionCommon&lt;JSAsyncFunction&gt;(exec, scope, functionExecutable, true);</span>



1350 }
1351 
<span class="line-modified">1352 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunction(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1353 {
<span class="line-modified">1354     return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, false);</span>



1355 }
1356 
<span class="line-modified">1357 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint(ExecState* exec, JSScope* scope, JSCell* functionExecutable)</span>
1358 {
<span class="line-modified">1359     return operationNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(exec, scope, functionExecutable, true);</span>



1360 }
1361 
<span class="line-modified">1362 void JIT_OPERATION operationSetFunctionName(ExecState* exec, JSCell* funcCell, EncodedJSValue encodedName)</span>
1363 {
<span class="line-modified">1364     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1365     NativeCallFrameTracer tracer(vm, exec);</span>

1366 
1367     JSFunction* func = jsCast&lt;JSFunction*&gt;(funcCell);
1368     JSValue name = JSValue::decode(encodedName);
<span class="line-modified">1369     func-&gt;setFunctionName(exec, name);</span>




































1370 }
1371 
<span class="line-modified">1372 JSCell* JIT_OPERATION operationNewObject(ExecState* exec, Structure* structure)</span>
1373 {
<span class="line-modified">1374     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1375     NativeCallFrameTracer tracer(vm, exec);</span>

1376 
<span class="line-modified">1377     return constructEmptyObject(exec, structure);</span>
1378 }
1379 
<span class="line-modified">1380 JSCell* JIT_OPERATION operationNewRegexp(ExecState* exec, JSCell* regexpPtr)</span>
1381 {
1382     SuperSamplerScope superSamplerScope(false);
<span class="line-modified">1383     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1384     NativeCallFrameTracer tracer(vm, exec);</span>

1385 
1386     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
1387     ASSERT(regexp-&gt;isValid());
<span class="line-modified">1388     return RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regexp);</span>
1389 }
1390 
1391 // The only reason for returning an UnusedPtr (instead of void) is so that we can reuse the
1392 // existing DFG slow path generator machinery when creating the slow path for CheckTraps
1393 // in the DFG. If a DFG slow path generator that supports a void return type is added in the
1394 // future, we can switch to using that then.
<span class="line-modified">1395 UnusedPtr JIT_OPERATION operationHandleTraps(ExecState* exec)</span>
1396 {
<span class="line-modified">1397     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1398     NativeCallFrameTracer tracer(vm, exec);</span>

1399     ASSERT(vm.needTrapHandling());
<span class="line-modified">1400     vm.handleTraps(exec);</span>
1401     return nullptr;
1402 }
1403 
<span class="line-modified">1404 void JIT_OPERATION operationDebug(ExecState* exec, int32_t debugHookType)</span>
1405 {
<span class="line-modified">1406     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1407     NativeCallFrameTracer tracer(vm, exec);</span>

1408 
<span class="line-modified">1409     vm.interpreter-&gt;debug(exec, static_cast&lt;DebugHookType&gt;(debugHookType));</span>
1410 }
1411 
1412 #if ENABLE(DFG_JIT)
1413 static void updateAllPredictionsAndOptimizeAfterWarmUp(CodeBlock* codeBlock)
1414 {
1415     codeBlock-&gt;updateAllPredictions();
1416     codeBlock-&gt;optimizeAfterWarmUp();
1417 }
1418 
<span class="line-modified">1419 SlowPathReturnType JIT_OPERATION operationOptimize(ExecState* exec, uint32_t bytecodeIndex)</span>
1420 {
<span class="line-modified">1421     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1422     NativeCallFrameTracer tracer(vm, exec);</span>


1423 
1424     // Defer GC for a while so that it doesn&#39;t run between when we enter into this
1425     // slow path and when we figure out the state of our code block. This prevents
1426     // a number of awkward reentrancy scenarios, including:
1427     //
1428     // - The optimized version of our code block being jettisoned by GC right after
1429     //   we concluded that we wanted to use it, but have not planted it into the JS
1430     //   stack yet.
1431     //
1432     // - An optimized version of our code block being installed just as we decided
1433     //   that it wasn&#39;t ready yet.
1434     //
1435     // Note that jettisoning won&#39;t happen if we already initiated OSR, because in
1436     // that case we would have already planted the optimized code block into the JS
1437     // stack.
1438     DeferGCForAWhile deferGC(vm.heap);
1439 
<span class="line-modified">1440     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1441     if (UNLIKELY(codeBlock-&gt;jitType() != JITType::BaselineJIT)) {
1442         dataLog(&quot;Unexpected code block in Baseline-&gt;DFG tier-up: &quot;, *codeBlock, &quot;\n&quot;);
1443         RELEASE_ASSERT_NOT_REACHED();
1444     }
1445 
1446     if (bytecodeIndex) {
1447         // If we&#39;re attempting to OSR from a loop, assume that this should be
1448         // separately optimized.
1449         codeBlock-&gt;m_shouldAlwaysBeInlined = false;
1450     }
1451 
1452     if (UNLIKELY(Options::verboseOSR())) {
1453         dataLog(
1454             *codeBlock, &quot;: Entered optimize with bytecodeIndex = &quot;, bytecodeIndex,
1455             &quot;, executeCounter = &quot;, codeBlock-&gt;jitExecuteCounter(),
1456             &quot;, optimizationDelayCounter = &quot;, codeBlock-&gt;reoptimizationRetryCounter(),
1457             &quot;, exitCounter = &quot;);
1458         if (codeBlock-&gt;hasOptimizedReplacement())
1459             dataLog(codeBlock-&gt;replacement()-&gt;osrExitCounter());
1460         else
1461             dataLog(&quot;N/A&quot;);
1462         dataLog(&quot;\n&quot;);
1463     }
1464 
1465     if (!codeBlock-&gt;checkIfOptimizationThresholdReached()) {
1466         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;counter = &quot;, codeBlock-&gt;jitExecuteCounter()));
1467         codeBlock-&gt;updateAllPredictions();
<span class="line-modified">1468         if (UNLIKELY(Options::verboseOSR()))</span>
<span class="line-removed">1469             dataLog(&quot;Choosing not to optimize &quot;, *codeBlock, &quot; yet, because the threshold hasn&#39;t been reached.\n&quot;);</span>
1470         return encodeResult(0, 0);
1471     }
1472 
1473     Debugger* debugger = codeBlock-&gt;globalObject()-&gt;debugger();
1474     if (UNLIKELY(debugger &amp;&amp; (debugger-&gt;isStepping() || codeBlock-&gt;baselineAlternative()-&gt;hasDebuggerRequests()))) {
1475         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;debugger is stepping or has requests&quot;));
1476         updateAllPredictionsAndOptimizeAfterWarmUp(codeBlock);
1477         return encodeResult(0, 0);
1478     }
1479 
1480     if (codeBlock-&gt;m_shouldAlwaysBeInlined) {
1481         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;should always be inlined&quot;));
1482         updateAllPredictionsAndOptimizeAfterWarmUp(codeBlock);
<span class="line-modified">1483         if (UNLIKELY(Options::verboseOSR()))</span>
<span class="line-removed">1484             dataLog(&quot;Choosing not to optimize &quot;, *codeBlock, &quot; yet, because m_shouldAlwaysBeInlined == true.\n&quot;);</span>
1485         return encodeResult(0, 0);
1486     }
1487 
1488     // We cannot be in the process of asynchronous compilation and also have an optimized
1489     // replacement.
1490     DFG::Worklist* worklist = DFG::existingGlobalDFGWorklistOrNull();
1491     ASSERT(
1492         !worklist
1493         || !(worklist-&gt;compilationState(DFG::CompilationKey(codeBlock, DFG::DFGMode)) != DFG::Worklist::NotKnown
1494         &amp;&amp; codeBlock-&gt;hasOptimizedReplacement()));
1495 
1496     DFG::Worklist::State worklistState;
1497     if (worklist) {
1498         // The call to DFG::Worklist::completeAllReadyPlansForVM() will complete all ready
1499         // (i.e. compiled) code blocks. But if it completes ours, we also need to know
1500         // what the result was so that we don&#39;t plow ahead and attempt OSR or immediate
1501         // reoptimization. This will have already also set the appropriate JIT execution
1502         // count threshold depending on what happened, so if the compilation was anything
1503         // but successful we just want to return early. See the case for worklistState ==
1504         // DFG::Worklist::Compiled, below.
</pre>
<hr />
<pre>
1519         worklistState = DFG::Worklist::NotKnown;
1520 
1521     if (worklistState == DFG::Worklist::Compiling) {
1522         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;compiling&quot;));
1523         // We cannot be in the process of asynchronous compilation and also have an optimized
1524         // replacement.
1525         RELEASE_ASSERT(!codeBlock-&gt;hasOptimizedReplacement());
1526         codeBlock-&gt;setOptimizationThresholdBasedOnCompilationResult(CompilationDeferred);
1527         return encodeResult(0, 0);
1528     }
1529 
1530     if (worklistState == DFG::Worklist::Compiled) {
1531         // If we don&#39;t have an optimized replacement but we did just get compiled, then
1532         // the compilation failed or was invalidated, in which case the execution count
1533         // thresholds have already been set appropriately by
1534         // CodeBlock::setOptimizationThresholdBasedOnCompilationResult() and we have
1535         // nothing left to do.
1536         if (!codeBlock-&gt;hasOptimizedReplacement()) {
1537             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;compiled and failed&quot;));
1538             codeBlock-&gt;updateAllPredictions();
<span class="line-modified">1539             if (UNLIKELY(Options::verboseOSR()))</span>
<span class="line-removed">1540                 dataLog(&quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.\n&quot;);</span>
1541             return encodeResult(0, 0);
1542         }
1543     } else if (codeBlock-&gt;hasOptimizedReplacement()) {
1544         CodeBlock* replacement = codeBlock-&gt;replacement();
<span class="line-modified">1545         if (UNLIKELY(Options::verboseOSR()))</span>
<span class="line-removed">1546             dataLog(&quot;Considering OSR &quot;, codeBlock, &quot; -&gt; &quot;, replacement, &quot;.\n&quot;);</span>
1547         // If we have an optimized replacement, then it must be the case that we entered
1548         // cti_optimize from a loop. That&#39;s because if there&#39;s an optimized replacement,
1549         // then all calls to this function will be relinked to the replacement and so
1550         // the prologue OSR will never fire.
1551 
1552         // This is an interesting threshold check. Consider that a function OSR exits
1553         // in the middle of a loop, while having a relatively low exit count. The exit
1554         // will reset the execution counter to some target threshold, meaning that this
1555         // code won&#39;t be reached until that loop heats up for &gt;=1000 executions. But then
1556         // we do a second check here, to see if we should either reoptimize, or just
1557         // attempt OSR entry. Hence it might even be correct for
1558         // shouldReoptimizeFromLoopNow() to always return true. But we make it do some
1559         // additional checking anyway, to reduce the amount of recompilation thrashing.
1560         if (replacement-&gt;shouldReoptimizeFromLoopNow()) {
1561             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;should reoptimize from loop now&quot;));
<span class="line-modified">1562             if (UNLIKELY(Options::verboseOSR())) {</span>
<span class="line-modified">1563                 dataLog(</span>
<span class="line-modified">1564                     &quot;Triggering reoptimization of &quot;, codeBlock,</span>
<span class="line-removed">1565                     &quot;(&quot;, replacement, &quot;) (in loop).\n&quot;);</span>
<span class="line-removed">1566             }</span>
1567             replacement-&gt;jettison(Profiler::JettisonDueToBaselineLoopReoptimizationTrigger, CountReoptimization);
1568             return encodeResult(0, 0);
1569         }
1570     } else {
1571         if (!codeBlock-&gt;shouldOptimizeNow()) {
1572             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;insufficient profiling&quot;));
<span class="line-modified">1573             if (UNLIKELY(Options::verboseOSR())) {</span>
<span class="line-modified">1574                 dataLog(</span>
<span class="line-modified">1575                     &quot;Delaying optimization for &quot;, *codeBlock,</span>
<span class="line-removed">1576                     &quot; because of insufficient profiling.\n&quot;);</span>
<span class="line-removed">1577             }</span>
1578             return encodeResult(0, 0);
1579         }
1580 
<span class="line-modified">1581         if (UNLIKELY(Options::verboseOSR()))</span>
<span class="line-removed">1582             dataLog(&quot;Triggering optimized compilation of &quot;, *codeBlock, &quot;\n&quot;);</span>
1583 
<span class="line-modified">1584         unsigned numVarsWithValues;</span>
1585         if (bytecodeIndex)
1586             numVarsWithValues = codeBlock-&gt;numCalleeLocals();
<span class="line-modified">1587         else</span>
<span class="line-modified">1588             numVarsWithValues = 0;</span>
<span class="line-removed">1589         Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues(codeBlock-&gt;numParameters(), numVarsWithValues);</span>
1590         int localsUsedForCalleeSaves = static_cast&lt;int&gt;(CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters());
1591         for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<span class="line-modified">1592             int operand = mustHandleValues.operandForIndex(i);</span>
<span class="line-modified">1593             if (operandIsLocal(operand) &amp;&amp; VirtualRegister(operand).toLocal() &lt; localsUsedForCalleeSaves)</span>

1594                 continue;
<span class="line-modified">1595             mustHandleValues[i] = exec-&gt;uncheckedR(operand).jsValue();</span>
1596         }
1597 
1598         CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
1599         CompilationResult result = DFG::compile(
1600             vm, replacementCodeBlock, nullptr, DFG::DFGMode, bytecodeIndex,
1601             mustHandleValues, JITToDFGDeferredCompilationCallback::create());
1602 
1603         if (result != CompilationSuccessful) {
1604             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;compilation failed&quot;));
1605             return encodeResult(0, 0);
1606         }
1607     }
1608 
1609     CodeBlock* optimizedCodeBlock = codeBlock-&gt;replacement();
1610     ASSERT(optimizedCodeBlock &amp;&amp; JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
1611 
<span class="line-modified">1612     if (void* dataBuffer = DFG::prepareOSREntry(exec, optimizedCodeBlock, bytecodeIndex)) {</span>
1613         CODEBLOCK_LOG_EVENT(optimizedCodeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, bytecodeIndex));
<span class="line-modified">1614         if (UNLIKELY(Options::verboseOSR())) {</span>
<span class="line-removed">1615             dataLog(</span>
<span class="line-removed">1616                 &quot;Performing OSR &quot;, codeBlock, &quot; -&gt; &quot;, optimizedCodeBlock, &quot;.\n&quot;);</span>
<span class="line-removed">1617         }</span>
1618 
1619         codeBlock-&gt;optimizeSoon();
1620         codeBlock-&gt;unlinkedCodeBlock()-&gt;setDidOptimize(TrueTriState);
1621         void* targetPC = vm.getCTIStub(DFG::osrEntryThunkGenerator).code().executableAddress();
<span class="line-modified">1622         targetPC = retagCodePtr(targetPC, JITThunkPtrTag, bitwise_cast&lt;PtrTag&gt;(exec));</span>
1623         return encodeResult(targetPC, dataBuffer);
1624     }
1625 
<span class="line-modified">1626     if (UNLIKELY(Options::verboseOSR())) {</span>
<span class="line-modified">1627         dataLog(</span>
<span class="line-modified">1628             &quot;Optimizing &quot;, codeBlock, &quot; -&gt; &quot;, codeBlock-&gt;replacement(),</span>
<span class="line-modified">1629             &quot; succeeded, OSR failed, after a delay of &quot;,</span>
<span class="line-removed">1630             codeBlock-&gt;optimizationDelayCounter(), &quot;.\n&quot;);</span>
<span class="line-removed">1631     }</span>
1632 
1633     // Count the OSR failure as a speculation failure. If this happens a lot, then
1634     // reoptimize.
1635     optimizedCodeBlock-&gt;countOSRExit();
1636 
1637     // We are a lot more conservative about triggering reoptimization after OSR failure than
1638     // before it. If we enter the optimize_from_loop trigger with a bucket full of fail
1639     // already, then we really would like to reoptimize immediately. But this case covers
1640     // something else: there weren&#39;t many (or any) speculation failures before, but we just
1641     // failed to enter the speculative code because some variable had the wrong value or
1642     // because the OSR code decided for any spurious reason that it did not want to OSR
1643     // right now. So, we only trigger reoptimization only upon the more conservative (non-loop)
1644     // reoptimization trigger.
1645     if (optimizedCodeBlock-&gt;shouldReoptimizeNow()) {
1646         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;should reoptimize now&quot;));
<span class="line-modified">1647         if (UNLIKELY(Options::verboseOSR())) {</span>
<span class="line-modified">1648             dataLog(</span>
<span class="line-modified">1649                 &quot;Triggering reoptimization of &quot;, codeBlock, &quot; -&gt; &quot;,</span>
<span class="line-removed">1650                 codeBlock-&gt;replacement(), &quot; (after OSR fail).\n&quot;);</span>
<span class="line-removed">1651         }</span>
1652         optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToBaselineLoopReoptimizationTriggerOnOSREntryFail, CountReoptimization);
1653         return encodeResult(0, 0);
1654     }
1655 
1656     // OSR failed this time, but it might succeed next time! Let the code run a bit
1657     // longer and then try again.
1658     codeBlock-&gt;optimizeAfterWarmUp();
1659 
1660     CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;OSR failed&quot;));
1661     return encodeResult(0, 0);
1662 }
1663 
<span class="line-modified">1664 char* JIT_OPERATION operationTryOSREnterAtCatch(ExecState* exec, uint32_t bytecodeIndex)</span>
1665 {
<span class="line-modified">1666     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1667     NativeCallFrameTracer tracer(vm, exec);</span>


1668 
<span class="line-modified">1669     CodeBlock* optimizedReplacement = exec-&gt;codeBlock()-&gt;replacement();</span>

1670     if (UNLIKELY(!optimizedReplacement))
1671         return nullptr;
1672 
1673     switch (optimizedReplacement-&gt;jitType()) {
1674     case JITType::DFGJIT:
1675     case JITType::FTLJIT: {
<span class="line-modified">1676         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);</span>
1677         return entry.executableAddress&lt;char*&gt;();
1678     }
1679     default:
1680         break;
1681     }
1682     return nullptr;
1683 }
1684 
<span class="line-modified">1685 char* JIT_OPERATION operationTryOSREnterAtCatchAndValueProfile(ExecState* exec, uint32_t bytecodeIndex)</span>
1686 {
<span class="line-modified">1687     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1688     NativeCallFrameTracer tracer(vm, exec);</span>


1689 
<span class="line-modified">1690     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1691     CodeBlock* optimizedReplacement = codeBlock-&gt;replacement();
1692     if (UNLIKELY(!optimizedReplacement))
1693         return nullptr;
1694 
1695     switch (optimizedReplacement-&gt;jitType()) {
1696     case JITType::DFGJIT:
1697     case JITType::FTLJIT: {
<span class="line-modified">1698         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(exec, optimizedReplacement, bytecodeIndex);</span>
1699         return entry.executableAddress&lt;char*&gt;();
1700     }
1701     default:
1702         break;
1703     }
1704 
<span class="line-modified">1705     codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(bytecodeIndex);</span>
1706     auto bytecode = codeBlock-&gt;instructions().at(bytecodeIndex)-&gt;as&lt;OpCatch&gt;();
1707     auto&amp; metadata = bytecode.metadata(codeBlock);
<span class="line-modified">1708     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
<span class="line-modified">1709         profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1710     });
1711 
1712     return nullptr;
1713 }
1714 
1715 #endif
1716 
<span class="line-modified">1717 void JIT_OPERATION operationPutByIndex(ExecState* exec, EncodedJSValue encodedArrayValue, int32_t index, EncodedJSValue encodedValue)</span>
1718 {
<span class="line-modified">1719     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1720     NativeCallFrameTracer tracer(vm, exec);</span>

1721 
1722     JSValue arrayValue = JSValue::decode(encodedArrayValue);
1723     ASSERT(isJSArray(arrayValue));
<span class="line-modified">1724     asArray(arrayValue)-&gt;putDirectIndex(exec, index, JSValue::decode(encodedValue));</span>
1725 }
1726 
1727 enum class AccessorType {
1728     Getter,
1729     Setter
1730 };
1731 
<span class="line-modified">1732 static void putAccessorByVal(ExecState* exec, JSObject* base, JSValue subscript, int32_t attribute, JSObject* accessor, AccessorType accessorType)</span>
1733 {
<span class="line-modified">1734     VM&amp; vm = exec-&gt;vm();</span>
1735     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1736     auto propertyKey = subscript.toPropertyKey(exec);</span>
1737     RETURN_IF_EXCEPTION(scope, void());
1738 
1739     scope.release();
1740     if (accessorType == AccessorType::Getter)
<span class="line-modified">1741         base-&gt;putGetter(exec, propertyKey, accessor, attribute);</span>
1742     else
<span class="line-modified">1743         base-&gt;putSetter(exec, propertyKey, accessor, attribute);</span>
1744 }
1745 
<span class="line-modified">1746 void JIT_OPERATION operationPutGetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* getter)</span>
1747 {
<span class="line-modified">1748     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1749     NativeCallFrameTracer tracer(vm, exec);</span>

1750 
1751     ASSERT(object &amp;&amp; object-&gt;isObject());
1752     JSObject* baseObj = object-&gt;getObject();
1753 
1754     ASSERT(getter-&gt;isObject());
<span class="line-modified">1755     baseObj-&gt;putGetter(exec, uid, getter, options);</span>
1756 }
1757 
<span class="line-modified">1758 void JIT_OPERATION operationPutSetterById(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* setter)</span>
1759 {
<span class="line-modified">1760     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1761     NativeCallFrameTracer tracer(vm, exec);</span>

1762 
1763     ASSERT(object &amp;&amp; object-&gt;isObject());
1764     JSObject* baseObj = object-&gt;getObject();
1765 
1766     ASSERT(setter-&gt;isObject());
<span class="line-modified">1767     baseObj-&gt;putSetter(exec, uid, setter, options);</span>
1768 }
1769 
<span class="line-modified">1770 void JIT_OPERATION operationPutGetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* getter)</span>
1771 {
<span class="line-modified">1772     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1773     NativeCallFrameTracer tracer(vm, exec);</span>

1774 
<span class="line-modified">1775     putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(getter), AccessorType::Getter);</span>
1776 }
1777 
<span class="line-modified">1778 void JIT_OPERATION operationPutSetterByVal(ExecState* exec, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* setter)</span>
1779 {
<span class="line-modified">1780     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1781     NativeCallFrameTracer tracer(vm, exec);</span>

1782 
<span class="line-modified">1783     putAccessorByVal(exec, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(setter), AccessorType::Setter);</span>
1784 }
1785 
1786 #if USE(JSVALUE64)
<span class="line-modified">1787 void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, EncodedJSValue encodedGetterValue, EncodedJSValue encodedSetterValue)</span>
1788 {
<span class="line-modified">1789     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1790     NativeCallFrameTracer tracer(vm, exec);</span>

1791 
1792     ASSERT(object &amp;&amp; object-&gt;isObject());
1793     JSObject* baseObject = asObject(object);
1794 
1795     JSValue getter = JSValue::decode(encodedGetterValue);
1796     JSValue setter = JSValue::decode(encodedSetterValue);
1797     ASSERT(getter.isObject() || setter.isObject());
<span class="line-modified">1798     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="line-modified">1799     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, uid, accessor, attribute);</span>
1800 }
1801 
1802 #else
<span class="line-modified">1803 void JIT_OPERATION operationPutGetterSetter(ExecState* exec, JSCell* object, UniquedStringImpl* uid, int32_t attribute, JSCell* getterCell, JSCell* setterCell)</span>
1804 {
<span class="line-modified">1805     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1806     NativeCallFrameTracer tracer(vm, exec);</span>

1807 
1808     ASSERT(object &amp;&amp; object-&gt;isObject());
1809     JSObject* baseObject = asObject(object);
1810 
1811     ASSERT(getterCell || setterCell);
1812     JSObject* getter = getterCell ? getterCell-&gt;getObject() : nullptr;
1813     JSObject* setter = setterCell ? setterCell-&gt;getObject() : nullptr;
<span class="line-modified">1814     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
<span class="line-modified">1815     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, uid, accessor, attribute);</span>
1816 }
1817 #endif
1818 
<span class="line-modified">1819 void JIT_OPERATION operationPopScope(ExecState* exec, int32_t scopeReg)</span>
1820 {
<span class="line-modified">1821     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1822     NativeCallFrameTracer tracer(vm, exec);</span>

1823 
<span class="line-modified">1824     JSScope* scope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
<span class="line-modified">1825     exec-&gt;uncheckedR(scopeReg) = scope-&gt;next();</span>
1826 }
1827 
<span class="line-modified">1828 int32_t JIT_OPERATION operationInstanceOfCustom(ExecState* exec, EncodedJSValue encodedValue, JSObject* constructor, EncodedJSValue encodedHasInstance)</span>
1829 {
<span class="line-modified">1830     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1831     NativeCallFrameTracer tracer(vm, exec);</span>

1832 
1833     JSValue value = JSValue::decode(encodedValue);
1834     JSValue hasInstanceValue = JSValue::decode(encodedHasInstance);
1835 
<span class="line-modified">1836     if (constructor-&gt;hasInstance(exec, value, hasInstanceValue))</span>
1837         return 1;
1838     return 0;
1839 }
1840 
1841 }
1842 
<span class="line-modified">1843 static JSValue getByVal(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)</span>
1844 {
<span class="line-modified">1845     VM&amp; vm = exec-&gt;vm();</span>

1846     auto scope = DECLARE_THROW_SCOPE(vm);
1847 
1848     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1849         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1850         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1851             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
1852             RETURN_IF_EXCEPTION(scope, JSValue());
1853             if (existingAtomString) {
1854                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get())) {
<span class="line-modified">1855                     ASSERT(exec-&gt;bytecodeOffset());</span>
<span class="line-removed">1856                     if (byValInfo-&gt;stubInfo &amp;&amp; byValInfo-&gt;cachedId.impl() != existingAtomString)</span>
<span class="line-removed">1857                         byValInfo-&gt;tookSlowPath = true;</span>
1858                     return result;
1859                 }
1860             }
1861         }
1862     }
1863 
1864     if (subscript.isInt32()) {
<span class="line-removed">1865         ASSERT(exec-&gt;bytecodeOffset());</span>
<span class="line-removed">1866         byValInfo-&gt;tookSlowPath = true;</span>
<span class="line-removed">1867 </span>
1868         int32_t i = subscript.asInt32();
1869         if (isJSString(baseValue)) {
<span class="line-modified">1870             if (i &gt;= 0 &amp;&amp; asString(baseValue)-&gt;canGetIndex(i)) {</span>
<span class="line-modified">1871                 ctiPatchCallByReturnAddress(returnAddress, operationGetByValString);</span>
<span class="line-modified">1872                 RELEASE_AND_RETURN(scope, asString(baseValue)-&gt;getIndex(exec, i));</span>
<span class="line-modified">1873             }</span>
<span class="line-removed">1874             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();</span>
1875         } else if (baseValue.isObject()) {
1876             JSObject* object = asObject(baseValue);
1877             if (object-&gt;canGetIndexQuickly(i))
1878                 return object-&gt;getIndexQuickly(i);
1879 
1880             bool skipMarkingOutOfBounds = false;
1881 
1882             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &gt;= 0 &amp;&amp; static_cast&lt;uint32_t&gt;(i) &lt; object-&gt;butterfly()-&gt;publicLength()) {
1883                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
1884                 // https://bugs.webkit.org/show_bug.cgi?id=182940
1885                 auto* globalObject = object-&gt;globalObject(vm);
1886                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
1887             }
1888 
1889             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i)) {
1890                 // FIXME: This will make us think that in-bounds typed array accesses are actually
1891                 // out-of-bounds.
1892                 // https://bugs.webkit.org/show_bug.cgi?id=149886
<span class="line-modified">1893                 byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();</span>

1894             }
1895         }
1896 
1897         if (i &gt;= 0)
<span class="line-modified">1898             RELEASE_AND_RETURN(scope, baseValue.get(exec, static_cast&lt;uint32_t&gt;(i)));</span>
1899     }
1900 
<span class="line-modified">1901     baseValue.requireObjectCoercible(exec);</span>
1902     RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">1903     auto property = subscript.toPropertyKey(exec);</span>
1904     RETURN_IF_EXCEPTION(scope, JSValue());
1905 
<span class="line-modified">1906     ASSERT(exec-&gt;bytecodeOffset());</span>
<span class="line-modified">1907     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))</span>
<span class="line-removed">1908         byValInfo-&gt;tookSlowPath = true;</span>
<span class="line-removed">1909 </span>
<span class="line-removed">1910     RELEASE_AND_RETURN(scope, baseValue.get(exec, property));</span>
1911 }
1912 
<span class="line-modified">1913 static OptimizationResult tryGetByValOptimize(ExecState* exec, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)</span>


1914 {
<span class="line-modified">1915     // See if it&#39;s worth optimizing this at all.</span>
<span class="line-modified">1916     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;</span>








1917 
<span class="line-modified">1918     VM&amp; vm = exec-&gt;vm();</span>




1919     auto scope = DECLARE_THROW_SCOPE(vm);
1920 
<span class="line-modified">1921     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {</span>
<span class="line-modified">1922         JSObject* object = asObject(baseValue);</span>
1923 
<span class="line-modified">1924         ASSERT(exec-&gt;bytecodeOffset());</span>
<span class="line-removed">1925         ASSERT(!byValInfo-&gt;stubRoutine);</span>
1926 
<span class="line-modified">1927         if (hasOptimizableIndexing(object-&gt;structure(vm))) {</span>
<span class="line-modified">1928             // Attempt to optimize.</span>
<span class="line-modified">1929             Structure* structure = object-&gt;structure(vm);</span>
<span class="line-modified">1930             JITArrayMode arrayMode = jitArrayModeForStructure(structure);</span>
<span class="line-removed">1931             if (arrayMode != byValInfo-&gt;arrayMode) {</span>
<span class="line-removed">1932                 // If we reached this case, we got an interesting array mode we did not expect when we compiled.</span>
<span class="line-removed">1933                 // Let&#39;s update the profile to do better next time.</span>
<span class="line-removed">1934                 CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1935                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified">1936                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);</span>
<span class="line-removed">1937 </span>
<span class="line-removed">1938                 JIT::compileGetByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);</span>
<span class="line-removed">1939                 optimizationResult = OptimizationResult::Optimized;</span>
1940             }

1941         }
<span class="line-removed">1942 </span>
<span class="line-removed">1943         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.</span>
<span class="line-removed">1944         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())</span>
<span class="line-removed">1945             optimizationResult = OptimizationResult::GiveUp;</span>
1946     }
1947 
<span class="line-modified">1948     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {</span>
<span class="line-modified">1949         const Identifier propertyName = subscript.toPropertyKey(exec);</span>
<span class="line-modified">1950         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);</span>
1951         if (subscript.isSymbol() || !parseIndex(propertyName)) {
<span class="line-modified">1952             ASSERT(exec-&gt;bytecodeOffset());</span>
<span class="line-modified">1953             ASSERT(!byValInfo-&gt;stubRoutine);</span>
<span class="line-modified">1954             if (byValInfo-&gt;seen) {</span>
<span class="line-removed">1955                 if (byValInfo-&gt;cachedId == propertyName) {</span>
<span class="line-removed">1956                     JIT::compileGetByValWithCachedId(vm, exec-&gt;codeBlock(), byValInfo, returnAddress, propertyName);</span>
<span class="line-removed">1957                     optimizationResult = OptimizationResult::Optimized;</span>
<span class="line-removed">1958                 } else {</span>
<span class="line-removed">1959                     // Seem like a generic property access site.</span>
<span class="line-removed">1960                     optimizationResult = OptimizationResult::GiveUp;</span>
<span class="line-removed">1961                 }</span>
<span class="line-removed">1962             } else {</span>
<span class="line-removed">1963                 CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">1964                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);</span>
<span class="line-removed">1965                 byValInfo-&gt;seen = true;</span>
<span class="line-removed">1966                 byValInfo-&gt;cachedId = propertyName;</span>
<span class="line-removed">1967                 if (subscript.isSymbol())</span>
<span class="line-removed">1968                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));</span>
<span class="line-removed">1969                 optimizationResult = OptimizationResult::SeenOnce;</span>
<span class="line-removed">1970             }</span>
<span class="line-removed">1971         }</span>
<span class="line-removed">1972     }</span>
1973 
<span class="line-modified">1974     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {</span>
<span class="line-modified">1975         // If we take slow path more than 10 times without patching then make sure we</span>
<span class="line-modified">1976         // never make that mistake again. For cases where we see non-index-intercepting</span>
<span class="line-modified">1977         // objects, this gives 10 iterations worth of opportunity for us to observe</span>
<span class="line-modified">1978         // that the get_by_val may be polymorphic. We count up slowPathCount even if</span>
<span class="line-removed">1979         // the result is GiveUp.</span>
<span class="line-removed">1980         if (++byValInfo-&gt;slowPathCount &gt;= 10)</span>
<span class="line-removed">1981             optimizationResult = OptimizationResult::GiveUp;</span>
1982     }
1983 
<span class="line-modified">1984     return optimizationResult;</span>
<span class="line-removed">1985 }</span>
<span class="line-removed">1986 </span>
<span class="line-removed">1987 extern &quot;C&quot; {</span>
<span class="line-removed">1988 </span>
<span class="line-removed">1989 EncodedJSValue JIT_OPERATION operationGetByValGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>
<span class="line-removed">1990 {</span>
<span class="line-removed">1991     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1992     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">1993     JSValue baseValue = JSValue::decode(encodedBase);</span>
<span class="line-removed">1994     JSValue subscript = JSValue::decode(encodedSubscript);</span>
<span class="line-removed">1995 </span>
<span class="line-removed">1996     JSValue result = getByVal(exec, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
<span class="line-removed">1997     return JSValue::encode(result);</span>
1998 }
1999 
<span class="line-modified">2000 EncodedJSValue JIT_OPERATION operationGetByValOptimize(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>
2001 {
<span class="line-modified">2002     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2003     NativeCallFrameTracer tracer(vm, exec);</span>

2004     auto scope = DECLARE_THROW_SCOPE(vm);
2005 
2006     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified">2007     JSValue subscript = JSValue::decode(encodedSubscript);</span>
<span class="line-modified">2008     ReturnAddressPtr returnAddress = ReturnAddressPtr(OUR_RETURN_ADDRESS);</span>
<span class="line-modified">2009     OptimizationResult result = tryGetByValOptimize(exec, baseValue, subscript, byValInfo, returnAddress);</span>
<span class="line-modified">2010     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-modified">2011     if (result == OptimizationResult::GiveUp) {</span>
<span class="line-modified">2012         // Don&#39;t ever try to optimize.</span>
<span class="line-modified">2013         byValInfo-&gt;tookSlowPath = true;</span>
<span class="line-modified">2014         ctiPatchCallByReturnAddress(returnAddress, operationGetByValGeneric);</span>
















2015     }
2016 
<span class="line-modified">2017     RELEASE_AND_RETURN(scope, JSValue::encode(getByVal(exec, baseValue, subscript, byValInfo, returnAddress)));</span>




2018 }
2019 
<span class="line-modified">2020 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyDefault(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>

2021 {
<span class="line-modified">2022     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2023     NativeCallFrameTracer tracer(vm, exec);</span>

2024     JSValue baseValue = JSValue::decode(encodedBase);
2025     JSValue subscript = JSValue::decode(encodedSubscript);
2026 
2027     ASSERT(baseValue.isObject());
2028     ASSERT(subscript.isUInt32AsAnyInt());
2029 
2030     JSObject* object = asObject(baseValue);
2031     bool didOptimize = false;
2032 
<span class="line-modified">2033     ASSERT(exec-&gt;bytecodeOffset());</span>
2034     ASSERT(!byValInfo-&gt;stubRoutine);
2035 
2036     if (hasOptimizableIndexing(object-&gt;structure(vm))) {
2037         // Attempt to optimize.
2038         JITArrayMode arrayMode = jitArrayModeForStructure(object-&gt;structure(vm));
2039         if (arrayMode != byValInfo-&gt;arrayMode) {
<span class="line-modified">2040             JIT::compileHasIndexedProperty(vm, exec-&gt;codeBlock(), byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS), arrayMode);</span>
2041             didOptimize = true;
2042         }
2043     }
2044 
2045     if (!didOptimize) {
2046         // If we take slow path more than 10 times without patching then make sure we
2047         // never make that mistake again. Or, if we failed to patch and we have some object
2048         // that intercepts indexed get, then don&#39;t even wait until 10 times. For cases
2049         // where we see non-index-intercepting objects, this gives 10 iterations worth of
2050         // opportunity for us to observe that the get_by_val may be polymorphic.
2051         if (++byValInfo-&gt;slowPathCount &gt;= 10
2052             || object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero()) {
2053             // Don&#39;t ever try to optimize.
2054             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationHasIndexedPropertyGeneric);
2055         }
2056     }
2057 
2058     uint32_t index = subscript.asUInt32AsAnyInt();
2059     if (object-&gt;canGetIndexQuickly(index))
2060         return JSValue::encode(JSValue(JSValue::JSTrue));
2061 
2062     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))
2063         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-modified">2064     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
2065 }
2066 
<span class="line-modified">2067 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyGeneric(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>
2068 {
<span class="line-modified">2069     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2070     NativeCallFrameTracer tracer(vm, exec);</span>

2071     JSValue baseValue = JSValue::decode(encodedBase);
2072     JSValue subscript = JSValue::decode(encodedSubscript);
2073 
2074     ASSERT(baseValue.isObject());
2075     ASSERT(subscript.isUInt32AsAnyInt());
2076 
2077     JSObject* object = asObject(baseValue);
2078     uint32_t index = subscript.asUInt32AsAnyInt();
2079     if (object-&gt;canGetIndexQuickly(index))
2080         return JSValue::encode(JSValue(JSValue::JSTrue));
2081 
2082     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))
2083         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-modified">2084     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(exec, index, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
2085 }
2086 
<span class="line-modified">2087 EncodedJSValue JIT_OPERATION operationGetByValString(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>
2088 {
<span class="line-removed">2089     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">2090     NativeCallFrameTracer tracer(vm, exec);</span>
2091     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">2092     JSValue baseValue = JSValue::decode(encodedBase);</span>
<span class="line-removed">2093     JSValue subscript = JSValue::decode(encodedSubscript);</span>
<span class="line-removed">2094 </span>
<span class="line-removed">2095     JSValue result;</span>
<span class="line-removed">2096     if (LIKELY(subscript.isUInt32())) {</span>
<span class="line-removed">2097         uint32_t i = subscript.asUInt32();</span>
<span class="line-removed">2098         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))</span>
<span class="line-removed">2099             RELEASE_AND_RETURN(scope, JSValue::encode(asString(baseValue)-&gt;getIndex(exec, i)));</span>
<span class="line-removed">2100 </span>
<span class="line-removed">2101         result = baseValue.get(exec, i);</span>
<span class="line-removed">2102         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">2103         if (!isJSString(baseValue)) {</span>
<span class="line-removed">2104             ASSERT(exec-&gt;bytecodeOffset());</span>
<span class="line-removed">2105             auto getByValFunction = byValInfo-&gt;stubRoutine ? operationGetByValGeneric : operationGetByValOptimize;</span>
<span class="line-removed">2106             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), getByValFunction);</span>
<span class="line-removed">2107         }</span>
<span class="line-removed">2108     } else {</span>
<span class="line-removed">2109         baseValue.requireObjectCoercible(exec);</span>
<span class="line-removed">2110         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">2111         auto property = subscript.toPropertyKey(exec);</span>
<span class="line-removed">2112         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">2113         scope.release();</span>
<span class="line-removed">2114         result = baseValue.get(exec, property);</span>
<span class="line-removed">2115     }</span>
<span class="line-removed">2116 </span>
<span class="line-removed">2117     return JSValue::encode(result);</span>
<span class="line-removed">2118 }</span>
<span class="line-removed">2119 </span>
<span class="line-removed">2120 EncodedJSValue JIT_OPERATION operationDeleteByIdJSResult(ExecState* exec, EncodedJSValue base, UniquedStringImpl* uid)</span>
<span class="line-removed">2121 {</span>
<span class="line-removed">2122     return JSValue::encode(jsBoolean(operationDeleteById(exec, base, uid)));</span>
<span class="line-removed">2123 }</span>
2124 
<span class="line-modified">2125 size_t JIT_OPERATION operationDeleteById(ExecState* exec, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
<span class="line-removed">2126 {</span>
<span class="line-removed">2127     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">2128     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">2129     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">2130 </span>
<span class="line-removed">2131     JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);</span>
2132     RETURN_IF_EXCEPTION(scope, false);
2133     if (!baseObj)
2134         return false;
<span class="line-modified">2135     bool couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, Identifier::fromUid(vm, uid));</span>
2136     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2137     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">2138         throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
2139     return couldDelete;
2140 }
2141 
<span class="line-modified">2142 EncodedJSValue JIT_OPERATION operationDeleteByValJSResult(ExecState* exec, EncodedJSValue base,  EncodedJSValue key)</span>









2143 {
<span class="line-modified">2144     return JSValue::encode(jsBoolean(operationDeleteByVal(exec, base, key)));</span>



2145 }
2146 
<span class="line-modified">2147 size_t JIT_OPERATION operationDeleteByVal(ExecState* exec, EncodedJSValue encodedBase, EncodedJSValue encodedKey)</span>
2148 {
<span class="line-removed">2149     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">2150     NativeCallFrameTracer tracer(vm, exec);</span>
2151     auto scope = DECLARE_THROW_SCOPE(vm);
2152 
<span class="line-modified">2153     JSObject* baseObj = JSValue::decode(encodedBase).toObject(exec);</span>
2154     RETURN_IF_EXCEPTION(scope, false);
<span class="line-removed">2155     JSValue key = JSValue::decode(encodedKey);</span>
2156     if (!baseObj)
2157         return false;
2158 
2159     bool couldDelete;
2160     uint32_t index;
2161     if (key.getUInt32(index))
<span class="line-modified">2162         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObj, exec, index);</span>
2163     else {
<span class="line-modified">2164         Identifier property = key.toPropertyKey(exec);</span>
2165         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2166         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, exec, property);</span>
2167     }
2168     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2169     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">2170         throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
2171     return couldDelete;
2172 }
2173 
<span class="line-modified">2174 JSCell* JIT_OPERATION operationPushWithScope(ExecState* exec, JSCell* currentScopeCell, EncodedJSValue objectValue)</span>
2175 {
<span class="line-modified">2176     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2177     NativeCallFrameTracer tracer(vm, exec);</span>

















2178     auto scope = DECLARE_THROW_SCOPE(vm);
2179 
<span class="line-modified">2180     JSObject* object = JSValue::decode(objectValue).toObject(exec);</span>
2181     RETURN_IF_EXCEPTION(scope, nullptr);
2182 
2183     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
2184 
<span class="line-modified">2185     return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);</span>
2186 }
2187 
<span class="line-modified">2188 JSCell* JIT_OPERATION operationPushWithScopeObject(ExecState* exec, JSCell* currentScopeCell, JSObject* object)</span>
2189 {
<span class="line-modified">2190     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2191     NativeCallFrameTracer tracer(vm, exec);</span>

2192     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
<span class="line-modified">2193     return JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, object);</span>
2194 }
2195 
<span class="line-modified">2196 EncodedJSValue JIT_OPERATION operationInstanceOf(ExecState* exec, EncodedJSValue encodedValue, EncodedJSValue encodedProto)</span>
2197 {
<span class="line-modified">2198     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2199     NativeCallFrameTracer tracer(vm, exec);</span>

2200     JSValue value = JSValue::decode(encodedValue);
2201     JSValue proto = JSValue::decode(encodedProto);
2202 
<span class="line-modified">2203     bool result = JSObject::defaultHasInstance(exec, value, proto);</span>
2204     return JSValue::encode(jsBoolean(result));
2205 }
2206 
<span class="line-modified">2207 EncodedJSValue JIT_OPERATION operationInstanceOfGeneric(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)</span>
2208 {
<span class="line-modified">2209     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2210     NativeCallFrameTracer tracer(vm, exec);</span>

2211     JSValue value = JSValue::decode(encodedValue);
2212     JSValue proto = JSValue::decode(encodedProto);
2213 
2214     stubInfo-&gt;tookSlowPath = true;
2215 
<span class="line-modified">2216     bool result = JSObject::defaultHasInstance(exec, value, proto);</span>
2217     return JSValue::encode(jsBoolean(result));
2218 }
2219 
<span class="line-modified">2220 EncodedJSValue JIT_OPERATION operationInstanceOfOptimize(ExecState* exec, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)</span>
2221 {
<span class="line-modified">2222     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2223     NativeCallFrameTracer tracer(vm, exec);</span>

2224     auto scope = DECLARE_THROW_SCOPE(vm);
2225     JSValue value = JSValue::decode(encodedValue);
2226     JSValue proto = JSValue::decode(encodedProto);
2227 
<span class="line-modified">2228     bool result = JSObject::defaultHasInstance(exec, value, proto);</span>
2229     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
2230 
<span class="line-modified">2231     if (stubInfo-&gt;considerCaching(vm, exec-&gt;codeBlock(), value.structureOrNull()))</span>
<span class="line-modified">2232         repatchInstanceOf(exec, value, proto, *stubInfo, result);</span>

2233 
2234     return JSValue::encode(jsBoolean(result));
2235 }
2236 
<span class="line-modified">2237 int32_t JIT_OPERATION operationSizeFrameForForwardArguments(ExecState* exec, EncodedJSValue, int32_t numUsedStackSlots, int32_t)</span>
2238 {
<span class="line-modified">2239     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2240     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2241     return sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);</span>

2242 }
2243 
<span class="line-modified">2244 int32_t JIT_OPERATION operationSizeFrameForVarargs(ExecState* exec, EncodedJSValue encodedArguments, int32_t numUsedStackSlots, int32_t firstVarArgOffset)</span>
2245 {
<span class="line-modified">2246     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2247     NativeCallFrameTracer tracer(vm, exec);</span>

2248     JSValue arguments = JSValue::decode(encodedArguments);
<span class="line-modified">2249     return sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArgOffset);</span>
2250 }
2251 
<span class="line-modified">2252 CallFrame* JIT_OPERATION operationSetupForwardArgumentsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue, int32_t, int32_t length)</span>
2253 {
<span class="line-modified">2254     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2255     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2256     setupForwardArgumentsFrame(exec, newCallFrame, length);</span>

2257     return newCallFrame;
2258 }
2259 
<span class="line-modified">2260 CallFrame* JIT_OPERATION operationSetupVarargsFrame(ExecState* exec, CallFrame* newCallFrame, EncodedJSValue encodedArguments, int32_t firstVarArgOffset, int32_t length)</span>
2261 {
<span class="line-modified">2262     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2263     NativeCallFrameTracer tracer(vm, exec);</span>

2264     JSValue arguments = JSValue::decode(encodedArguments);
<span class="line-modified">2265     setupVarargsFrame(exec, newCallFrame, arguments, firstVarArgOffset, length);</span>
2266     return newCallFrame;
2267 }
2268 
<span class="line-modified">2269 char* JIT_OPERATION operationSwitchCharWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)</span>
2270 {
<span class="line-modified">2271     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2272     NativeCallFrameTracer tracer(vm, exec);</span>



2273     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2274     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
2275 
2276     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2277     void* result = jumpTable.ctiDefault.executableAddress();
2278 
2279     if (key.isString()) {
<span class="line-modified">2280         StringImpl* value = asString(key)-&gt;value(exec).impl();</span>
<span class="line-modified">2281         if (value-&gt;length() == 1)</span>
<span class="line-modified">2282             result = jumpTable.ctiForValue((*value)[0]).executableAddress();</span>



2283     }
2284 
2285     assertIsTaggedWith(result, JSSwitchPtrTag);
2286     return reinterpret_cast&lt;char*&gt;(result);
2287 }
2288 
<span class="line-modified">2289 char* JIT_OPERATION operationSwitchImmWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)</span>
2290 {
<span class="line-modified">2291     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2292     NativeCallFrameTracer tracer(vm, exec);</span>

2293     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2294     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
2295 
2296     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2297     void* result;
2298     if (key.isInt32())
2299         result = jumpTable.ctiForValue(key.asInt32()).executableAddress();
2300     else if (key.isDouble() &amp;&amp; key.asDouble() == static_cast&lt;int32_t&gt;(key.asDouble()))
2301         result = jumpTable.ctiForValue(static_cast&lt;int32_t&gt;(key.asDouble())).executableAddress();
2302     else
2303         result = jumpTable.ctiDefault.executableAddress();
2304     assertIsTaggedWith(result, JSSwitchPtrTag);
2305     return reinterpret_cast&lt;char*&gt;(result);
2306 }
2307 
<span class="line-modified">2308 char* JIT_OPERATION operationSwitchStringWithUnknownKeyType(ExecState* exec, EncodedJSValue encodedKey, size_t tableIndex)</span>
2309 {
<span class="line-modified">2310     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2311     NativeCallFrameTracer tracer(vm, exec);</span>

2312     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2313     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
2314     auto throwScope = DECLARE_THROW_SCOPE(vm);
2315 
2316     void* result;
2317     StringJumpTable&amp; jumpTable = codeBlock-&gt;stringSwitchJumpTable(tableIndex);
2318 
2319     if (key.isString()) {
<span class="line-modified">2320         StringImpl* value = asString(key)-&gt;value(exec).impl();</span>
2321 
2322         RETURN_IF_EXCEPTION(throwScope, nullptr);
2323 
2324         result = jumpTable.ctiForValue(value).executableAddress();
2325     } else
2326         result = jumpTable.ctiDefault.executableAddress();
2327 
2328     assertIsTaggedWith(result, JSSwitchPtrTag);
2329     return reinterpret_cast&lt;char*&gt;(result);
2330 }
2331 
<span class="line-modified">2332 EncodedJSValue JIT_OPERATION operationGetFromScope(ExecState* exec, const Instruction* pc)</span>
2333 {
<span class="line-modified">2334     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2335     NativeCallFrameTracer tracer(vm, exec);</span>

2336     auto throwScope = DECLARE_THROW_SCOPE(vm);
2337 
<span class="line-modified">2338     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
2339 
2340     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
2341     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">2342     JSObject* scope = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedR(bytecode.m_scope.offset()).jsValue());</span>
2343     GetPutInfo&amp; getPutInfo = bytecode.metadata(codeBlock).m_getPutInfo;
2344 
2345     // ModuleVar is always converted to ClosureVar for get_from_scope.
2346     ASSERT(getPutInfo.resolveType() != ModuleVar);
2347 
<span class="line-modified">2348     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
2349         if (!found) {
2350             if (getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">2351                 throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
2352             return jsUndefined();
2353         }
2354 
2355         JSValue result = JSValue();
2356         if (scope-&gt;isGlobalLexicalEnvironment()) {
2357             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">2358             result = slot.getValue(exec, ident);</span>
2359             if (result == jsTDZValue()) {
<span class="line-modified">2360                 throwException(exec, throwScope, createTDZError(exec));</span>
2361                 return jsUndefined();
2362             }
2363         }
2364 
<span class="line-modified">2365         CommonSlowPaths::tryCacheGetFromScopeGlobal(exec, vm, bytecode, scope, slot, ident);</span>
2366 
2367         if (!result)
<span class="line-modified">2368             return slot.getValue(exec, ident);</span>
2369         return result;
2370     })));
2371 }
2372 
<span class="line-modified">2373 void JIT_OPERATION operationPutToScope(ExecState* exec, const Instruction* pc)</span>
2374 {
<span class="line-modified">2375     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2376     NativeCallFrameTracer tracer(vm, exec);</span>

2377     auto throwScope = DECLARE_THROW_SCOPE(vm);
2378 
<span class="line-modified">2379     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
2380     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
2381     auto&amp; metadata = bytecode.metadata(codeBlock);
2382 
2383     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">2384     JSObject* scope = jsCast&lt;JSObject*&gt;(exec-&gt;uncheckedR(bytecode.m_scope.offset()).jsValue());</span>
<span class="line-modified">2385     JSValue value = exec-&gt;r(bytecode.m_value.offset()).jsValue();</span>
2386     GetPutInfo&amp; getPutInfo = metadata.m_getPutInfo;
2387 
2388     // ModuleVar does not keep the scope register value alive in DFG.
2389     ASSERT(getPutInfo.resolveType() != ModuleVar);
2390 
2391     if (getPutInfo.resolveType() == LocalClosureVar) {
2392         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
2393         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
2394         if (WatchpointSet* set = metadata.m_watchpointSet)
2395             set-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
2396         return;
2397     }
2398 
<span class="line-modified">2399     bool hasProperty = scope-&gt;hasProperty(exec, ident);</span>
2400     RETURN_IF_EXCEPTION(throwScope, void());
2401     if (hasProperty
2402         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2403         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2404         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2405         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">2406         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);</span>
<span class="line-modified">2407         if (slot.getValue(exec, ident) == jsTDZValue()) {</span>
<span class="line-modified">2408             throwException(exec, throwScope, createTDZError(exec));</span>
2409             return;
2410         }
2411     }
2412 
2413     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
<span class="line-modified">2414         throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
2415         return;
2416     }
2417 
2418     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
<span class="line-modified">2419     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, value, slot);</span>
2420 
2421     RETURN_IF_EXCEPTION(throwScope, void());
2422 
<span class="line-modified">2423     CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);</span>
2424 }
2425 
<span class="line-modified">2426 void JIT_OPERATION operationThrow(ExecState* exec, EncodedJSValue encodedExceptionValue)</span>
2427 {
<span class="line-modified">2428     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2429     NativeCallFrameTracer tracer(vm, exec);</span>

2430     auto scope = DECLARE_THROW_SCOPE(vm);
2431 
2432     JSValue exceptionValue = JSValue::decode(encodedExceptionValue);
<span class="line-modified">2433     throwException(exec, scope, exceptionValue);</span>
2434 
2435     // Results stored out-of-band in vm.targetMachinePCForThrow &amp; vm.callFrameForCatch
<span class="line-modified">2436     genericUnwind(vm, exec);</span>
2437 }
2438 
<span class="line-modified">2439 char* JIT_OPERATION operationReallocateButterflyToHavePropertyStorageWithInitialCapacity(ExecState* exec, JSObject* object)</span>
2440 {
<span class="line-modified">2441     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2442     NativeCallFrameTracer tracer(vm, exec);</span>

2443 
2444     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2445     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity);
2446     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2447     return reinterpret_cast&lt;char*&gt;(result);
2448 }
2449 
<span class="line-modified">2450 char* JIT_OPERATION operationReallocateButterflyToGrowPropertyStorage(ExecState* exec, JSObject* object, size_t newSize)</span>
2451 {
<span class="line-modified">2452     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2453     NativeCallFrameTracer tracer(vm, exec);</span>

2454 
2455     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize);
2456     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2457     return reinterpret_cast&lt;char*&gt;(result);
2458 }
2459 
<span class="line-modified">2460 void JIT_OPERATION operationOSRWriteBarrier(ExecState* exec, JSCell* cell)</span>
2461 {
<span class="line-modified">2462     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2463     NativeCallFrameTracer tracer(vm, exec);</span>

2464     vm.heap.writeBarrier(cell);
2465 }
2466 
<span class="line-modified">2467 void JIT_OPERATION operationWriteBarrierSlowPath(ExecState* exec, JSCell* cell)</span>
2468 {
<span class="line-modified">2469     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2470     NativeCallFrameTracer tracer(vm, exec);</span>

2471     vm.heap.writeBarrierSlowPath(cell);
2472 }
2473 
<span class="line-modified">2474 void JIT_OPERATION lookupExceptionHandler(VM* vmPointer, ExecState* exec)</span>
2475 {
2476     VM&amp; vm = *vmPointer;
<span class="line-modified">2477     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2478     genericUnwind(vm, exec);</span>

2479     ASSERT(vm.targetMachinePCForThrow);
2480 }
2481 
<span class="line-modified">2482 void JIT_OPERATION lookupExceptionHandlerFromCallerFrame(VM* vm, ExecState* exec)</span>
2483 {
<span class="line-modified">2484     ASSERT(exec-&gt;isStackOverflowFrame());</span>
<span class="line-modified">2485     ASSERT(jsCast&lt;ErrorInstance*&gt;(vm-&gt;exceptionForInspection()-&gt;value().asCell())-&gt;isStackOverflowError());</span>
<span class="line-modified">2486     lookupExceptionHandler(vm, exec);</span>




2487 }
2488 
<span class="line-modified">2489 void JIT_OPERATION operationVMHandleException(ExecState* exec)</span>
2490 {
<span class="line-modified">2491     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2492     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2493     genericUnwind(vm, exec);</span>

2494 }
2495 
<span class="line-modified">2496 // This function &quot;should&quot; just take the ExecState*, but doing so would make it more difficult</span>
2497 // to call from exception check sites. So, unlike all of our other functions, we allow
2498 // ourselves to play some gnarly ABI tricks just to simplify the calling convention. This is
2499 // particularly safe here since this is never called on the critical path - it&#39;s only for
2500 // testing.
<span class="line-modified">2501 void JIT_OPERATION operationExceptionFuzz(ExecState* exec)</span>
2502 {
<span class="line-modified">2503     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2504     NativeCallFrameTracer tracer(vm, exec);</span>

2505     auto scope = DECLARE_THROW_SCOPE(vm);
2506     UNUSED_PARAM(scope);
2507 #if COMPILER(GCC_COMPATIBLE)
2508     void* returnPC = __builtin_return_address(0);
<span class="line-modified">2509     doExceptionFuzzing(exec, scope, &quot;JITOperations&quot;, returnPC);</span>
2510 #endif // COMPILER(GCC_COMPATIBLE)
2511 }
2512 
<span class="line-modified">2513 ALWAYS_INLINE static EncodedJSValue unprofiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2514 {
<span class="line-modified">2515     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2516     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2517 </span>
<span class="line-modified">2518     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-removed">2519     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-removed">2520 </span>
<span class="line-removed">2521     return JSValue::encode(jsAdd(exec, op1, op2));</span>
2522 }
2523 
<span class="line-modified">2524 ALWAYS_INLINE static EncodedJSValue profiledAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile)</span>
<span class="line-removed">2525 {</span>
<span class="line-removed">2526     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">2527     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-removed">2528 </span>
<span class="line-removed">2529     JSValue op1 = JSValue::decode(encodedOp1);</span>
<span class="line-removed">2530     JSValue op2 = JSValue::decode(encodedOp2);</span>
<span class="line-removed">2531 </span>
<span class="line-removed">2532     arithProfile.observeLHSAndRHS(op1, op2);</span>
<span class="line-removed">2533     JSValue result = jsAdd(exec, op1, op2);</span>
<span class="line-removed">2534     arithProfile.observeResult(result);</span>
<span class="line-removed">2535 </span>
<span class="line-removed">2536     return JSValue::encode(result);</span>
<span class="line-removed">2537 }</span>
<span class="line-removed">2538 </span>
<span class="line-removed">2539 EncodedJSValue JIT_OPERATION operationValueAdd(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
<span class="line-removed">2540 {</span>
<span class="line-removed">2541     return unprofiledAdd(exec, encodedOp1, encodedOp2);</span>
<span class="line-removed">2542 }</span>
<span class="line-removed">2543 </span>
<span class="line-removed">2544 EncodedJSValue JIT_OPERATION operationValueAddProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)</span>
2545 {
2546     ASSERT(arithProfile);
<span class="line-modified">2547     return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);</span>



2548 }
2549 
<span class="line-modified">2550 EncodedJSValue JIT_OPERATION operationValueAddProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)</span>
2551 {
<span class="line-modified">2552     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2553     NativeCallFrameTracer tracer(vm, exec);</span>

2554 
2555     JSValue op1 = JSValue::decode(encodedOp1);
2556     JSValue op2 = JSValue::decode(encodedOp2);
2557 
<span class="line-modified">2558     ArithProfile* arithProfile = addIC-&gt;arithProfile();</span>
2559     ASSERT(arithProfile);
2560     arithProfile-&gt;observeLHSAndRHS(op1, op2);
2561     auto nonOptimizeVariant = operationValueAddProfiledNoOptimize;
<span class="line-modified">2562     addIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);</span>
2563 
2564 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2565     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2566 #endif
2567 
<span class="line-modified">2568     JSValue result = jsAdd(exec, op1, op2);</span>
2569     arithProfile-&gt;observeResult(result);
2570 
2571     return JSValue::encode(result);
2572 }
2573 
<span class="line-modified">2574 EncodedJSValue JIT_OPERATION operationValueAddProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)</span>
2575 {
<span class="line-modified">2576     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2577     NativeCallFrameTracer tracer(vm, exec);</span>

2578 
<span class="line-modified">2579     ArithProfile* arithProfile = addIC-&gt;arithProfile();</span>
2580     ASSERT(arithProfile);
<span class="line-modified">2581     return profiledAdd(exec, encodedOp1, encodedOp2, *arithProfile);</span>
2582 }
2583 
<span class="line-modified">2584 EncodedJSValue JIT_OPERATION operationValueAddOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)</span>
2585 {
<span class="line-modified">2586     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2587     NativeCallFrameTracer tracer(vm, exec);</span>

2588 
2589     JSValue op1 = JSValue::decode(encodedOp1);
2590     JSValue op2 = JSValue::decode(encodedOp2);
2591 
2592     auto nonOptimizeVariant = operationValueAddNoOptimize;
<span class="line-modified">2593     if (ArithProfile* arithProfile = addIC-&gt;arithProfile())</span>
2594         arithProfile-&gt;observeLHSAndRHS(op1, op2);
<span class="line-modified">2595     addIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);</span>
2596 
2597 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2598     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2599 #endif
2600 
<span class="line-modified">2601     return JSValue::encode(jsAdd(exec, op1, op2));</span>
2602 }
2603 
<span class="line-modified">2604 EncodedJSValue JIT_OPERATION operationValueAddNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC*)</span>
2605 {
<span class="line-modified">2606     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2607     NativeCallFrameTracer tracer(vm, exec);</span>

2608 
2609     JSValue op1 = JSValue::decode(encodedOp1);
2610     JSValue op2 = JSValue::decode(encodedOp2);
2611 
<span class="line-modified">2612     JSValue result = jsAdd(exec, op1, op2);</span>
2613 
2614     return JSValue::encode(result);
2615 }
2616 
<span class="line-modified">2617 ALWAYS_INLINE static EncodedJSValue unprofiledMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2618 {
2619     JSValue op1 = JSValue::decode(encodedOp1);
2620     JSValue op2 = JSValue::decode(encodedOp2);
2621 
<span class="line-modified">2622     return JSValue::encode(jsMul(exec, op1, op2));</span>
2623 }
2624 
<span class="line-modified">2625 ALWAYS_INLINE static EncodedJSValue profiledMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)</span>
2626 {
<span class="line-modified">2627     VM&amp; vm = exec-&gt;vm();</span>
2628     auto scope = DECLARE_THROW_SCOPE(vm);
2629     JSValue op1 = JSValue::decode(encodedOp1);
2630     JSValue op2 = JSValue::decode(encodedOp2);
2631 
2632     if (shouldObserveLHSAndRHSTypes)
2633         arithProfile.observeLHSAndRHS(op1, op2);
2634 
<span class="line-modified">2635     JSValue result = jsMul(exec, op1, op2);</span>
2636     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2637     arithProfile.observeResult(result);
2638     return JSValue::encode(result);
2639 }
2640 
<span class="line-modified">2641 EncodedJSValue JIT_OPERATION operationValueMul(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2642 {
<span class="line-modified">2643     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2644     NativeCallFrameTracer tracer(vm, exec);</span>

2645 
<span class="line-modified">2646     return unprofiledMul(exec, encodedOp1, encodedOp2);</span>
2647 }
2648 
<span class="line-modified">2649 EncodedJSValue JIT_OPERATION operationValueMulNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC*)</span>
2650 {
<span class="line-modified">2651     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2652     NativeCallFrameTracer tracer(vm, exec);</span>

2653 
<span class="line-modified">2654     return unprofiledMul(exec, encodedOp1, encodedOp2);</span>
2655 }
2656 
<span class="line-modified">2657 EncodedJSValue JIT_OPERATION operationValueMulOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)</span>
2658 {
<span class="line-modified">2659     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2660     NativeCallFrameTracer tracer(vm, exec);</span>

2661 
2662     auto nonOptimizeVariant = operationValueMulNoOptimize;
<span class="line-modified">2663     if (ArithProfile* arithProfile = mulIC-&gt;arithProfile())</span>
2664         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
<span class="line-modified">2665     mulIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);</span>
2666 
2667 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2668     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2669 #endif
2670 
<span class="line-modified">2671     return unprofiledMul(exec, encodedOp1, encodedOp2);</span>
2672 }
2673 
<span class="line-modified">2674 EncodedJSValue JIT_OPERATION operationValueMulProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)</span>
2675 {
<span class="line-modified">2676     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2677     NativeCallFrameTracer tracer(vm, exec);</span>

2678 
2679     ASSERT(arithProfile);
<span class="line-modified">2680     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);</span>
2681 }
2682 
<span class="line-modified">2683 EncodedJSValue JIT_OPERATION operationValueMulProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)</span>
2684 {
<span class="line-modified">2685     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2686     NativeCallFrameTracer tracer(vm, exec);</span>

2687 
<span class="line-modified">2688     ArithProfile* arithProfile = mulIC-&gt;arithProfile();</span>
2689     ASSERT(arithProfile);
2690     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2691     auto nonOptimizeVariant = operationValueMulProfiledNoOptimize;
<span class="line-modified">2692     mulIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);</span>
2693 
2694 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2695     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2696 #endif
2697 
<span class="line-modified">2698     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile, false);</span>
2699 }
2700 
<span class="line-modified">2701 EncodedJSValue JIT_OPERATION operationValueMulProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)</span>
2702 {
<span class="line-modified">2703     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2704     NativeCallFrameTracer tracer(vm, exec);</span>

2705 
<span class="line-modified">2706     ArithProfile* arithProfile = mulIC-&gt;arithProfile();</span>
2707     ASSERT(arithProfile);
<span class="line-modified">2708     return profiledMul(exec, encodedOp1, encodedOp2, *arithProfile);</span>
2709 }
2710 
<span class="line-modified">2711 ALWAYS_INLINE static EncodedJSValue unprofiledNegate(ExecState* exec, EncodedJSValue encodedOperand)</span>
2712 {
<span class="line-modified">2713     VM&amp; vm = exec-&gt;vm();</span>
2714     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2715     NativeCallFrameTracer tracer(vm, exec);</span>

2716 
2717     JSValue operand = JSValue::decode(encodedOperand);
2718 
<span class="line-modified">2719     JSValue primValue = operand.toPrimitive(exec, PreferNumber);</span>
2720     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2721 
2722     if (primValue.isBigInt())
2723         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2724 
<span class="line-modified">2725     double number = primValue.toNumber(exec);</span>
2726     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2727     return JSValue::encode(jsNumber(-number));

2728 }
2729 
<span class="line-modified">2730 ALWAYS_INLINE static EncodedJSValue profiledNegate(ExecState* exec, EncodedJSValue encodedOperand, ArithProfile&amp; arithProfile)</span>
2731 {
<span class="line-modified">2732     VM&amp; vm = exec-&gt;vm();</span>

2733     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2734     NativeCallFrameTracer tracer(vm, exec);</span>

2735 
2736     JSValue operand = JSValue::decode(encodedOperand);
<span class="line-modified">2737     arithProfile.observeLHS(operand);</span>
2738 
<span class="line-modified">2739     JSValue primValue = operand.toPrimitive(exec);</span>
2740     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2741 
2742     if (primValue.isBigInt()) {
2743         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
<span class="line-modified">2744         arithProfile.observeResult(result);</span>
2745 
2746         return JSValue::encode(result);
2747     }
2748 
<span class="line-modified">2749     double number = primValue.toNumber(exec);</span>
2750     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2751     JSValue result = jsNumber(-number);
<span class="line-modified">2752     arithProfile.observeResult(result);</span>
2753     return JSValue::encode(result);
2754 }
2755 
<span class="line-modified">2756 EncodedJSValue JIT_OPERATION operationArithNegate(ExecState* exec, EncodedJSValue operand)</span>
<span class="line-removed">2757 {</span>
<span class="line-removed">2758     return unprofiledNegate(exec, operand);</span>
<span class="line-removed">2759 }</span>
<span class="line-removed">2760 </span>
<span class="line-removed">2761 EncodedJSValue JIT_OPERATION operationArithNegateProfiled(ExecState* exec, EncodedJSValue operand, ArithProfile* arithProfile)</span>
<span class="line-removed">2762 {</span>
<span class="line-removed">2763     ASSERT(arithProfile);</span>
<span class="line-removed">2764     return profiledNegate(exec, operand, *arithProfile);</span>
<span class="line-removed">2765 }</span>
<span class="line-removed">2766 </span>
<span class="line-removed">2767 EncodedJSValue JIT_OPERATION operationArithNegateProfiledOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)</span>
2768 {
<span class="line-modified">2769     VM&amp; vm = exec-&gt;vm();</span>
2770     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2771     NativeCallFrameTracer tracer(vm, exec);</span>

2772 
2773     JSValue operand = JSValue::decode(encodedOperand);
2774 
<span class="line-modified">2775     ArithProfile* arithProfile = negIC-&gt;arithProfile();</span>
2776     ASSERT(arithProfile);
<span class="line-modified">2777     arithProfile-&gt;observeLHS(operand);</span>
<span class="line-modified">2778     negIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), operationArithNegateProfiled);</span>
2779 
2780 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2781     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2782 #endif
2783 
<span class="line-modified">2784     JSValue primValue = operand.toPrimitive(exec);</span>
2785     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2786 
2787     if (primValue.isBigInt()) {
2788         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
2789         arithProfile-&gt;observeResult(result);
2790         return JSValue::encode(result);
2791     }
2792 
<span class="line-modified">2793     double number = primValue.toNumber(exec);</span>
2794     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2795     JSValue result = jsNumber(-number);
2796     arithProfile-&gt;observeResult(result);
2797     return JSValue::encode(result);
2798 }
2799 
<span class="line-modified">2800 EncodedJSValue JIT_OPERATION operationArithNegateOptimize(ExecState* exec, EncodedJSValue encodedOperand, JITNegIC* negIC)</span>
2801 {
<span class="line-modified">2802     VM&amp; vm = exec-&gt;vm();</span>
2803     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2804     NativeCallFrameTracer tracer(vm, exec);</span>

2805 
2806     JSValue operand = JSValue::decode(encodedOperand);
2807 
<span class="line-modified">2808     if (ArithProfile* arithProfile = negIC-&gt;arithProfile())</span>
<span class="line-modified">2809         arithProfile-&gt;observeLHS(operand);</span>
<span class="line-modified">2810     negIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), operationArithNegate);</span>
2811 
2812 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2813     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2814 #endif
2815 
<span class="line-modified">2816     JSValue primValue = operand.toPrimitive(exec);</span>
2817     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2818 
2819     if (primValue.isBigInt())
2820         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2821 
<span class="line-modified">2822     double number = primValue.toNumber(exec);</span>
2823     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2824     return JSValue::encode(jsNumber(-number));
2825 }
2826 
<span class="line-modified">2827 ALWAYS_INLINE static EncodedJSValue unprofiledSub(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2828 {
2829     JSValue op1 = JSValue::decode(encodedOp1);
2830     JSValue op2 = JSValue::decode(encodedOp2);
2831 
<span class="line-modified">2832     return JSValue::encode(jsSub(exec, op1, op2));</span>
2833 }
2834 
<span class="line-modified">2835 ALWAYS_INLINE static EncodedJSValue profiledSub(VM&amp; vm, ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)</span>
2836 {
2837     auto scope = DECLARE_THROW_SCOPE(vm);
2838 
2839     JSValue op1 = JSValue::decode(encodedOp1);
2840     JSValue op2 = JSValue::decode(encodedOp2);
2841 
2842     if (shouldObserveLHSAndRHSTypes)
2843         arithProfile.observeLHSAndRHS(op1, op2);
2844 
<span class="line-modified">2845     JSValue result = jsSub(exec, op1, op2);</span>
2846     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2847     arithProfile.observeResult(result);
2848     return JSValue::encode(result);
2849 }
2850 
<span class="line-modified">2851 EncodedJSValue JIT_OPERATION operationValueSub(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2852 {
<span class="line-modified">2853     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2854     NativeCallFrameTracer tracer(vm, exec);</span>
<span class="line-modified">2855     return unprofiledSub(exec, encodedOp1, encodedOp2);</span>

2856 }
2857 
<span class="line-modified">2858 EncodedJSValue JIT_OPERATION operationValueSubProfiled(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, ArithProfile* arithProfile)</span>
2859 {
2860     ASSERT(arithProfile);
2861 
<span class="line-modified">2862     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2863     NativeCallFrameTracer tracer(vm, exec);</span>

2864 
<span class="line-modified">2865     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
2866 }
2867 
<span class="line-modified">2868 EncodedJSValue JIT_OPERATION operationValueSubOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)</span>
2869 {
<span class="line-modified">2870     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2871     NativeCallFrameTracer tracer(vm, exec);</span>

2872 
2873     auto nonOptimizeVariant = operationValueSubNoOptimize;
<span class="line-modified">2874     if (ArithProfile* arithProfile = subIC-&gt;arithProfile())</span>
2875         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
<span class="line-modified">2876     subIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);</span>
2877 
2878 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2879     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2880 #endif
2881 
<span class="line-modified">2882     return unprofiledSub(exec, encodedOp1, encodedOp2);</span>
2883 }
2884 
<span class="line-modified">2885 EncodedJSValue JIT_OPERATION operationValueSubNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC*)</span>
2886 {
<span class="line-modified">2887     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2888     NativeCallFrameTracer tracer(vm, exec);</span>

2889 
<span class="line-modified">2890     return unprofiledSub(exec, encodedOp1, encodedOp2);</span>
2891 }
2892 
<span class="line-modified">2893 EncodedJSValue JIT_OPERATION operationValueSubProfiledOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)</span>
2894 {
<span class="line-modified">2895     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2896     NativeCallFrameTracer tracer(vm, exec);</span>

2897 
<span class="line-modified">2898     ArithProfile* arithProfile = subIC-&gt;arithProfile();</span>
2899     ASSERT(arithProfile);
2900     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2901     auto nonOptimizeVariant = operationValueSubProfiledNoOptimize;
<span class="line-modified">2902     subIC-&gt;generateOutOfLine(exec-&gt;codeBlock(), nonOptimizeVariant);</span>
2903 
2904 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2905     exec-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2906 #endif
2907 
<span class="line-modified">2908     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile, false);</span>
2909 }
2910 
<span class="line-modified">2911 EncodedJSValue JIT_OPERATION operationValueSubProfiledNoOptimize(ExecState* exec, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)</span>
2912 {
<span class="line-modified">2913     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2914     NativeCallFrameTracer tracer(vm, exec);</span>

2915 
<span class="line-modified">2916     ArithProfile* arithProfile = subIC-&gt;arithProfile();</span>
2917     ASSERT(arithProfile);
<span class="line-modified">2918     return profiledSub(vm, exec, encodedOp1, encodedOp2, *arithProfile);</span>
2919 }
2920 
<span class="line-modified">2921 void JIT_OPERATION operationProcessTypeProfilerLog(ExecState* exec)</span>
2922 {
<span class="line-modified">2923     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2924     NativeCallFrameTracer tracer(vm, exec);</span>

2925     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside baseline JIT&quot;_s);
2926 }
2927 
<span class="line-modified">2928 void JIT_OPERATION operationProcessShadowChickenLog(ExecState* exec)</span>
2929 {
<span class="line-modified">2930     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2931     NativeCallFrameTracer tracer(vm, exec);</span>

2932     RELEASE_ASSERT(vm.shadowChicken());
<span class="line-modified">2933     vm.shadowChicken()-&gt;update(vm, exec);</span>
2934 }
2935 
<span class="line-modified">2936 int32_t JIT_OPERATION operationCheckIfExceptionIsUncatchableAndNotifyProfiler(ExecState* exec)</span>
2937 {
<span class="line-modified">2938     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2939     NativeCallFrameTracer tracer(vm, exec);</span>

2940     auto scope = DECLARE_THROW_SCOPE(vm);
2941     RELEASE_ASSERT(!!scope.exception());
2942 
2943     if (isTerminatedExecutionException(vm, scope.exception())) {
<span class="line-modified">2944         genericUnwind(vm, exec);</span>
2945         return 1;
2946     }
2947     return 0;
2948 }
2949 
2950 } // extern &quot;C&quot;
2951 
2952 } // namespace JSC
2953 


2954 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2013-2020 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;JITOperations.h&quot;
  28 
  29 #if ENABLE(JIT)
  30 
  31 #include &quot;ArithProfile.h&quot;
  32 #include &quot;ArrayConstructor.h&quot;
<span class="line-modified">  33 #include &quot;CacheableIdentifierInlines.h&quot;</span>
<span class="line-added">  34 #include &quot;CommonSlowPathsInlines.h&quot;</span>
  35 #include &quot;DFGCompilationMode.h&quot;
  36 #include &quot;DFGDriver.h&quot;
  37 #include &quot;DFGOSREntry.h&quot;
  38 #include &quot;DFGThunks.h&quot;
  39 #include &quot;DFGWorklist.h&quot;
  40 #include &quot;Debugger.h&quot;
  41 #include &quot;DirectArguments.h&quot;
  42 #include &quot;Error.h&quot;
  43 #include &quot;ErrorHandlingScope.h&quot;
  44 #include &quot;EvalCodeBlock.h&quot;
  45 #include &quot;ExceptionFuzz.h&quot;
  46 #include &quot;ExecutableBaseInlines.h&quot;
  47 #include &quot;FTLOSREntry.h&quot;
  48 #include &quot;FrameTracers.h&quot;
  49 #include &quot;FunctionCodeBlock.h&quot;
  50 #include &quot;GetterSetter.h&quot;
  51 #include &quot;HostCallReturnValue.h&quot;
  52 #include &quot;ICStats.h&quot;
  53 #include &quot;Interpreter.h&quot;
  54 #include &quot;JIT.h&quot;
  55 #include &quot;JITExceptions.h&quot;
  56 #include &quot;JITToDFGDeferredCompilationCallback.h&quot;
  57 #include &quot;JSAsyncFunction.h&quot;
<span class="line-added">  58 #include &quot;JSAsyncGenerator.h&quot;</span>
  59 #include &quot;JSAsyncGeneratorFunction.h&quot;
  60 #include &quot;JSCInlines.h&quot;
  61 #include &quot;JSCPtrTag.h&quot;
  62 #include &quot;JSGeneratorFunction.h&quot;
  63 #include &quot;JSGlobalObjectFunctions.h&quot;
<span class="line-added">  64 #include &quot;JSInternalPromise.h&quot;</span>
  65 #include &quot;JSLexicalEnvironment.h&quot;
  66 #include &quot;JSWithScope.h&quot;
  67 #include &quot;ModuleProgramCodeBlock.h&quot;
  68 #include &quot;ObjectConstructor.h&quot;
  69 #include &quot;PolymorphicAccess.h&quot;
  70 #include &quot;ProgramCodeBlock.h&quot;
  71 #include &quot;PropertyName.h&quot;
  72 #include &quot;RegExpObject.h&quot;
  73 #include &quot;Repatch.h&quot;
  74 #include &quot;ScopedArguments.h&quot;
  75 #include &quot;ShadowChicken.h&quot;
  76 #include &quot;StructureStubInfo.h&quot;
  77 #include &quot;SuperSampler.h&quot;
  78 #include &quot;TestRunnerUtils.h&quot;
  79 #include &quot;ThunkGenerators.h&quot;
  80 #include &quot;TypeProfilerLog.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;WebAssemblyFunction.h&quot;
  83 #include &lt;wtf/InlineASM.h&gt;
  84 
<span class="line-added">  85 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">  86 </span>
  87 namespace JSC {
  88 
<span class="line-added">  89 ALWAYS_INLINE JSValue profiledAdd(JSGlobalObject* globalObject, JSValue op1, JSValue op2, BinaryArithProfile&amp; arithProfile)</span>
<span class="line-added">  90 {</span>
<span class="line-added">  91     arithProfile.observeLHSAndRHS(op1, op2);</span>
<span class="line-added">  92     JSValue result = jsAdd(globalObject, op1, op2);</span>
<span class="line-added">  93     arithProfile.observeResult(result);</span>
<span class="line-added">  94     return result;</span>
<span class="line-added">  95 }</span>
<span class="line-added">  96 </span>
  97 extern &quot;C&quot; {
  98 
  99 #if COMPILER(MSVC)
 100 void * _ReturnAddress(void);
 101 #pragma intrinsic(_ReturnAddress)
 102 
 103 #define OUR_RETURN_ADDRESS _ReturnAddress()
 104 #else
 105 #define OUR_RETURN_ADDRESS __builtin_return_address(0)
 106 #endif
 107 
 108 #if ENABLE(OPCODE_SAMPLING)
 109 #define CTI_SAMPLER vm.interpreter-&gt;sampler()
 110 #else
 111 #define CTI_SAMPLER 0
 112 #endif
 113 
 114 
<span class="line-modified"> 115 void JIT_OPERATION operationThrowStackOverflowError(CodeBlock* codeBlock)</span>
 116 {
 117     // We pass in our own code block, because the callframe hasn&#39;t been populated.
 118     VM&amp; vm = codeBlock-&gt;vm();
<span class="line-added"> 119     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 120     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 121     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 122     callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 123     throwStackOverflowError(codeBlock-&gt;globalObject(), scope);</span>

 124 }
 125 
<span class="line-modified"> 126 void JIT_OPERATION operationThrowStackOverflowErrorFromThunk(JSGlobalObject* globalObject)</span>
 127 {
<span class="line-modified"> 128     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 129     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 130     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 131     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 132     throwStackOverflowError(globalObject, scope);</span>
<span class="line-modified"> 133     genericUnwind(vm, callFrame);</span>

 134     ASSERT(vm.targetMachinePCForThrow);
 135 }
 136 
<span class="line-modified"> 137 int32_t JIT_OPERATION operationCallArityCheck(JSGlobalObject* globalObject)</span>
 138 {
<span class="line-modified"> 139     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 140     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 141     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 142     auto scope = DECLARE_THROW_SCOPE(vm);
 143 
<span class="line-modified"> 144     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForCall);</span>
 145     if (UNLIKELY(missingArgCount &lt; 0)) {
<span class="line-modified"> 146         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForCall);</span>
<span class="line-modified"> 147         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 148         throwStackOverflowError(globalObject, scope);</span>

 149     }
 150 
 151     return missingArgCount;
 152 }
 153 
<span class="line-modified"> 154 int32_t JIT_OPERATION operationConstructArityCheck(JSGlobalObject* globalObject)</span>
 155 {
<span class="line-modified"> 156     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 157     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 158     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 159     auto scope = DECLARE_THROW_SCOPE(vm);
 160 
<span class="line-modified"> 161     int32_t missingArgCount = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForConstruct);</span>
 162     if (UNLIKELY(missingArgCount &lt; 0)) {
<span class="line-modified"> 163         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForConstruct);</span>
<span class="line-modified"> 164         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 165         throwStackOverflowError(globalObject, scope);</span>

 166     }
 167 
 168     return missingArgCount;
 169 }
 170 
<span class="line-modified"> 171 EncodedJSValue JIT_OPERATION operationTryGetById(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 172 {
<span class="line-modified"> 173     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 174     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 175     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 176     Identifier ident = Identifier::fromUid(vm, uid);
 177     stubInfo-&gt;tookSlowPath = true;
 178 
 179     JSValue baseValue = JSValue::decode(base);
 180     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 181     baseValue.getPropertySlot(globalObject, ident, slot);</span>
 182 
 183     return JSValue::encode(slot.getPureResult());
 184 }
 185 
 186 
<span class="line-modified"> 187 EncodedJSValue JIT_OPERATION operationTryGetByIdGeneric(JSGlobalObject* globalObject, EncodedJSValue base, UniquedStringImpl* uid)</span>
 188 {
<span class="line-modified"> 189     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 190     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 191     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 192     Identifier ident = Identifier::fromUid(vm, uid);
 193 
 194     JSValue baseValue = JSValue::decode(base);
 195     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified"> 196     baseValue.getPropertySlot(globalObject, ident, slot);</span>
 197 
 198     return JSValue::encode(slot.getPureResult());
 199 }
 200 
<span class="line-modified"> 201 EncodedJSValue JIT_OPERATION operationTryGetByIdOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 202 {
<span class="line-modified"> 203     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 204     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 205     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 206     auto scope = DECLARE_THROW_SCOPE(vm);
 207     Identifier ident = Identifier::fromUid(vm, uid);
 208 
 209     JSValue baseValue = JSValue::decode(base);
 210     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::VMInquiry);
 211 
<span class="line-modified"> 212     baseValue.getPropertySlot(globalObject, ident, slot);</span>
 213     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 214 
<span class="line-modified"> 215     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified"> 216     if (stubInfo-&gt;considerCaching(vm, codeBlock, baseValue.structureOrNull()) &amp;&amp; !slot.isTaintedByOpaqueObject() &amp;&amp; (slot.isCacheableValue() || slot.isCacheableGetter() || slot.isUnset()))</span>
<span class="line-added"> 217         repatchGetBy(globalObject, codeBlock, baseValue, ident, slot, *stubInfo, GetByKind::Try);</span>
 218 
 219     return JSValue::encode(slot.getPureResult());
 220 }
 221 
<span class="line-modified"> 222 EncodedJSValue JIT_OPERATION operationGetByIdDirect(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 223 {
<span class="line-modified"> 224     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 225     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 226     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 227     auto scope = DECLARE_THROW_SCOPE(vm);
 228     Identifier ident = Identifier::fromUid(vm, uid);
 229     stubInfo-&gt;tookSlowPath = true;
 230 
 231     JSValue baseValue = JSValue::decode(base);
 232     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 233 
<span class="line-modified"> 234     bool found = baseValue.getOwnPropertySlot(globalObject, ident, slot);</span>
 235     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 236 
<span class="line-modified"> 237     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(globalObject, ident) : jsUndefined()));</span>
 238 }
 239 
<span class="line-modified"> 240 EncodedJSValue JIT_OPERATION operationGetByIdDirectGeneric(JSGlobalObject* globalObject, EncodedJSValue base, UniquedStringImpl* uid)</span>
 241 {
<span class="line-modified"> 242     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 243     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 244     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 245     auto scope = DECLARE_THROW_SCOPE(vm);
 246     Identifier ident = Identifier::fromUid(vm, uid);
 247 
 248     JSValue baseValue = JSValue::decode(base);
 249     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 250 
<span class="line-modified"> 251     bool found = baseValue.getOwnPropertySlot(globalObject, ident, slot);</span>
 252     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 253 
<span class="line-modified"> 254     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(globalObject, ident) : jsUndefined()));</span>
 255 }
 256 
<span class="line-modified"> 257 EncodedJSValue JIT_OPERATION operationGetByIdDirectOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 258 {
<span class="line-modified"> 259     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 260     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 261     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 262     auto scope = DECLARE_THROW_SCOPE(vm);
 263     Identifier ident = Identifier::fromUid(vm, uid);
 264 
 265     JSValue baseValue = JSValue::decode(base);
 266     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::GetOwnProperty);
 267 
<span class="line-modified"> 268     bool found = baseValue.getOwnPropertySlot(globalObject, ident, slot);</span>
 269     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 270 
<span class="line-modified"> 271     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified"> 272     if (stubInfo-&gt;considerCaching(vm, codeBlock, baseValue.structureOrNull()))</span>
<span class="line-added"> 273         repatchGetBy(globalObject, codeBlock, baseValue, ident, slot, *stubInfo, GetByKind::Direct);</span>
 274 
<span class="line-modified"> 275     RELEASE_AND_RETURN(scope, JSValue::encode(found ? slot.getValue(globalObject, ident) : jsUndefined()));</span>
 276 }
 277 
<span class="line-modified"> 278 EncodedJSValue JIT_OPERATION operationGetById(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 279 {
 280     SuperSamplerScope superSamplerScope(false);
 281 
<span class="line-modified"> 282     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 283     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 284     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 285 
 286     stubInfo-&gt;tookSlowPath = true;
 287 
 288     JSValue baseValue = JSValue::decode(base);
 289     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 290     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 291     JSValue result = baseValue.get(globalObject, ident, slot);</span>
 292 
 293     LOG_IC((ICEvent::OperationGetById, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 294 
 295     return JSValue::encode(result);
 296 }
 297 
<span class="line-modified"> 298 EncodedJSValue JIT_OPERATION operationGetByIdGeneric(JSGlobalObject* globalObject, EncodedJSValue base, UniquedStringImpl* uid)</span>
 299 {
 300     SuperSamplerScope superSamplerScope(false);
 301 
<span class="line-modified"> 302     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 303     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 304     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 305 
 306     JSValue baseValue = JSValue::decode(base);
 307     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
 308     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 309     JSValue result = baseValue.get(globalObject, ident, slot);</span>
 310 
 311     LOG_IC((ICEvent::OperationGetByIdGeneric, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 312 
 313     return JSValue::encode(result);
 314 }
 315 
<span class="line-modified"> 316 EncodedJSValue JIT_OPERATION operationGetByIdOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 317 {
 318     SuperSamplerScope superSamplerScope(false);
 319 
<span class="line-modified"> 320     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 321     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 322     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 323     Identifier ident = Identifier::fromUid(vm, uid);
 324 
 325     JSValue baseValue = JSValue::decode(base);
 326 
<span class="line-modified"> 327     return JSValue::encode(baseValue.getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
 328 
 329         LOG_IC((ICEvent::OperationGetByIdOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 330 
<span class="line-modified"> 331         CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified"> 332         if (stubInfo-&gt;considerCaching(vm, codeBlock, baseValue.structureOrNull()))</span>
<span class="line-modified"> 333             repatchGetBy(globalObject, codeBlock, baseValue, ident, slot, *stubInfo, GetByKind::Normal);</span>
<span class="line-added"> 334         return found ? slot.getValue(globalObject, ident) : jsUndefined();</span>
 335     }));
 336 }
 337 
<span class="line-modified"> 338 EncodedJSValue JIT_OPERATION operationGetByIdWithThis(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)</span>
 339 {
 340     SuperSamplerScope superSamplerScope(false);
 341 
<span class="line-modified"> 342     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 343     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 344     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 345     Identifier ident = Identifier::fromUid(vm, uid);
 346 
 347     stubInfo-&gt;tookSlowPath = true;
 348 
 349     JSValue baseValue = JSValue::decode(base);
 350     JSValue thisValue = JSValue::decode(thisEncoded);
 351     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 352 
<span class="line-modified"> 353     return JSValue::encode(baseValue.get(globalObject, ident, slot));</span>
 354 }
 355 
<span class="line-modified"> 356 EncodedJSValue JIT_OPERATION operationGetByIdWithThisGeneric(JSGlobalObject* globalObject, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)</span>
 357 {
 358     SuperSamplerScope superSamplerScope(false);
 359 
<span class="line-modified"> 360     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 361     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 362     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 363     Identifier ident = Identifier::fromUid(vm, uid);
 364 
 365     JSValue baseValue = JSValue::decode(base);
 366     JSValue thisValue = JSValue::decode(thisEncoded);
 367     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
 368 
<span class="line-modified"> 369     return JSValue::encode(baseValue.get(globalObject, ident, slot));</span>
 370 }
 371 
<span class="line-modified"> 372 EncodedJSValue JIT_OPERATION operationGetByIdWithThisOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, EncodedJSValue thisEncoded, UniquedStringImpl* uid)</span>
 373 {
 374     SuperSamplerScope superSamplerScope(false);
 375 
<span class="line-modified"> 376     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 377     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 378     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 379     Identifier ident = Identifier::fromUid(vm, uid);
 380 
 381     JSValue baseValue = JSValue::decode(base);
 382     JSValue thisValue = JSValue::decode(thisEncoded);
 383 
 384     PropertySlot slot(thisValue, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 385     return JSValue::encode(baseValue.getPropertySlot(globalObject, ident, slot, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
 386         LOG_IC((ICEvent::OperationGetByIdWithThisOptimize, baseValue.classInfoOrNull(vm), ident, baseValue == slot.slotBase()));
 387 
<span class="line-modified"> 388         CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified"> 389         if (stubInfo-&gt;considerCaching(vm, codeBlock, baseValue.structureOrNull()))</span>
<span class="line-modified"> 390             repatchGetBy(globalObject, codeBlock, baseValue, ident, slot, *stubInfo, GetByKind::WithThis);</span>
<span class="line-added"> 391         return found ? slot.getValue(globalObject, ident) : jsUndefined();</span>
 392     }));
 393 }
 394 
<span class="line-modified"> 395 EncodedJSValue JIT_OPERATION operationInById(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 396 {
 397     SuperSamplerScope superSamplerScope(false);
 398 
<span class="line-modified"> 399     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 400     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 401     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 402     auto scope = DECLARE_THROW_SCOPE(vm);
 403 
 404     stubInfo-&gt;tookSlowPath = true;
 405 
 406     Identifier ident = Identifier::fromUid(vm, uid);
 407 
 408     JSValue baseValue = JSValue::decode(base);
 409     if (!baseValue.isObject()) {
<span class="line-modified"> 410         throwException(globalObject, scope, createInvalidInParameterError(globalObject, baseValue));</span>
 411         return JSValue::encode(jsUndefined());
 412     }
 413     JSObject* baseObject = asObject(baseValue);
 414 
 415     LOG_IC((ICEvent::OperationInById, baseObject-&gt;classInfo(vm), ident));
 416 
 417     scope.release();
 418     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 419     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(globalObject, ident, slot)));</span>
 420 }
 421 
<span class="line-modified"> 422 EncodedJSValue JIT_OPERATION operationInByIdGeneric(JSGlobalObject* globalObject, EncodedJSValue base, UniquedStringImpl* uid)</span>
 423 {
 424     SuperSamplerScope superSamplerScope(false);
 425 
<span class="line-modified"> 426     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 427     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 428     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 429     auto scope = DECLARE_THROW_SCOPE(vm);
 430 
 431     Identifier ident = Identifier::fromUid(vm, uid);
 432 
 433     JSValue baseValue = JSValue::decode(base);
 434     if (!baseValue.isObject()) {
<span class="line-modified"> 435         throwException(globalObject, scope, createInvalidInParameterError(globalObject, baseValue));</span>
 436         return JSValue::encode(jsUndefined());
 437     }
 438     JSObject* baseObject = asObject(baseValue);
 439 
 440     LOG_IC((ICEvent::OperationInByIdGeneric, baseObject-&gt;classInfo(vm), ident));
 441 
 442     scope.release();
 443     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 444     return JSValue::encode(jsBoolean(baseObject-&gt;getPropertySlot(globalObject, ident, slot)));</span>
 445 }
 446 
<span class="line-modified"> 447 EncodedJSValue JIT_OPERATION operationInByIdOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue base, UniquedStringImpl* uid)</span>
 448 {
 449     SuperSamplerScope superSamplerScope(false);
 450 
<span class="line-modified"> 451     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 452     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 453     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 454     auto scope = DECLARE_THROW_SCOPE(vm);
 455 
 456     Identifier ident = Identifier::fromUid(vm, uid);
 457 
 458     JSValue baseValue = JSValue::decode(base);
 459     if (!baseValue.isObject()) {
<span class="line-modified"> 460         throwException(globalObject, scope, createInvalidInParameterError(globalObject, baseValue));</span>
 461         return JSValue::encode(jsUndefined());
 462     }
 463     JSObject* baseObject = asObject(baseValue);
 464 
 465     LOG_IC((ICEvent::OperationInByIdOptimize, baseObject-&gt;classInfo(vm), ident));
 466 
 467     scope.release();
 468     PropertySlot slot(baseObject, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 469     bool found = baseObject-&gt;getPropertySlot(globalObject, ident, slot);</span>
<span class="line-modified"> 470     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified"> 471     if (stubInfo-&gt;considerCaching(vm, codeBlock, baseObject-&gt;structure(vm)))</span>
<span class="line-added"> 472         repatchInByID(globalObject, codeBlock, baseObject, ident, found, slot, *stubInfo);</span>
 473     return JSValue::encode(jsBoolean(found));
 474 }
 475 
<span class="line-modified"> 476 EncodedJSValue JIT_OPERATION operationInByVal(JSGlobalObject* globalObject, JSCell* base, EncodedJSValue key)</span>
 477 {
 478     SuperSamplerScope superSamplerScope(false);
 479 
<span class="line-modified"> 480     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 481     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 482     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 483 
<span class="line-modified"> 484     return JSValue::encode(jsBoolean(CommonSlowPaths::opInByVal(globalObject, base, JSValue::decode(key))));</span>
 485 }
 486 
<span class="line-modified"> 487 void JIT_OPERATION operationPutByIdStrict(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 488 {
 489     SuperSamplerScope superSamplerScope(false);
 490 
<span class="line-modified"> 491     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 492     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 493     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 494 
 495     stubInfo-&gt;tookSlowPath = true;
 496 
 497     JSValue baseValue = JSValue::decode(encodedBase);
 498     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 499     PutPropertySlot slot(baseValue, true, callFrame-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 500     baseValue.putInline(globalObject, ident, JSValue::decode(encodedValue), slot);</span>
 501 
 502     LOG_IC((ICEvent::OperationPutByIdStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 503 }
 504 
<span class="line-modified"> 505 void JIT_OPERATION operationPutByIdNonStrict(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 506 {
 507     SuperSamplerScope superSamplerScope(false);
 508 
<span class="line-modified"> 509     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 510     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 511     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 512 
 513     stubInfo-&gt;tookSlowPath = true;
 514 
 515     JSValue baseValue = JSValue::decode(encodedBase);
 516     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 517     PutPropertySlot slot(baseValue, false, callFrame-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 518     baseValue.putInline(globalObject, ident, JSValue::decode(encodedValue), slot);</span>
 519 
 520     LOG_IC((ICEvent::OperationPutByIdNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 521 }
 522 
<span class="line-modified"> 523 void JIT_OPERATION operationPutByIdDirectStrict(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 524 {
 525     SuperSamplerScope superSamplerScope(false);
 526 
<span class="line-modified"> 527     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 528     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 529     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 530 
 531     stubInfo-&gt;tookSlowPath = true;
 532 
 533     JSValue baseValue = JSValue::decode(encodedBase);
 534     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 535     PutPropertySlot slot(baseValue, true, callFrame-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 536     CommonSlowPaths::putDirectWithReify(vm, globalObject, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);</span>
 537 
 538     LOG_IC((ICEvent::OperationPutByIdDirectStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 539 }
 540 
<span class="line-modified"> 541 void JIT_OPERATION operationPutByIdDirectNonStrict(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 542 {
 543     SuperSamplerScope superSamplerScope(false);
 544 
<span class="line-modified"> 545     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 546     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 547     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 548 
 549     stubInfo-&gt;tookSlowPath = true;
 550 
 551     JSValue baseValue = JSValue::decode(encodedBase);
 552     Identifier ident = Identifier::fromUid(vm, uid);
<span class="line-modified"> 553     PutPropertySlot slot(baseValue, false, callFrame-&gt;codeBlock()-&gt;putByIdContext());</span>
<span class="line-modified"> 554     CommonSlowPaths::putDirectWithReify(vm, globalObject, asObject(baseValue), ident, JSValue::decode(encodedValue), slot);</span>
 555 
 556     LOG_IC((ICEvent::OperationPutByIdDirectNonStrict, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 557 }
 558 
<span class="line-modified"> 559 void JIT_OPERATION operationPutByIdStrictOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 560 {
 561     SuperSamplerScope superSamplerScope(false);
 562 
<span class="line-modified"> 563     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 564     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 565     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 566     auto scope = DECLARE_THROW_SCOPE(vm);
 567 
 568     Identifier ident = Identifier::fromUid(vm, uid);
 569     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 570 
 571     JSValue value = JSValue::decode(encodedValue);
 572     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 573     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 574     PutPropertySlot slot(baseValue, true, codeBlock-&gt;putByIdContext());
 575 
 576     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;
<span class="line-modified"> 577     baseValue.putInline(globalObject, ident, value, slot);</span>
 578 
 579     LOG_IC((ICEvent::OperationPutByIdStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 580 
 581     RETURN_IF_EXCEPTION(scope, void());
 582 
 583     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 584         return;
 585 
 586     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 587         repatchPutByID(globalObject, codeBlock, baseValue, structure, ident, slot, *stubInfo, NotDirect);</span>
 588 }
 589 
<span class="line-modified"> 590 void JIT_OPERATION operationPutByIdNonStrictOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 591 {
 592     SuperSamplerScope superSamplerScope(false);
 593 
<span class="line-modified"> 594     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 595     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 596     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 597     auto scope = DECLARE_THROW_SCOPE(vm);
 598 
 599     Identifier ident = Identifier::fromUid(vm, uid);
 600     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 601 
 602     JSValue value = JSValue::decode(encodedValue);
 603     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified"> 604     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 605     PutPropertySlot slot(baseValue, false, codeBlock-&gt;putByIdContext());
 606 
 607     Structure* structure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;
<span class="line-modified"> 608     baseValue.putInline(globalObject, ident, value, slot);</span>
 609 
 610     LOG_IC((ICEvent::OperationPutByIdNonStrictOptimize, baseValue.classInfoOrNull(vm), ident, slot.base() == baseValue));
 611 
 612     RETURN_IF_EXCEPTION(scope, void());
 613 
 614     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 615         return;
 616 
 617     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 618         repatchPutByID(globalObject, codeBlock, baseValue, structure, ident, slot, *stubInfo, NotDirect);</span>
 619 }
 620 
<span class="line-modified"> 621 void JIT_OPERATION operationPutByIdDirectStrictOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 622 {
 623     SuperSamplerScope superSamplerScope(false);
 624 
<span class="line-modified"> 625     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 626     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 627     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 628     auto scope = DECLARE_THROW_SCOPE(vm);
 629 
 630     Identifier ident = Identifier::fromUid(vm, uid);
 631     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 632 
 633     JSValue value = JSValue::decode(encodedValue);
 634     JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="line-modified"> 635     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 636     PutPropertySlot slot(baseObject, true, codeBlock-&gt;putByIdContext());
 637     Structure* structure = nullptr;
<span class="line-modified"> 638     CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, ident, value, slot, &amp;structure);</span>
 639 
 640     LOG_IC((ICEvent::OperationPutByIdDirectStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));
 641 
 642     RETURN_IF_EXCEPTION(scope, void());
 643 
 644     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 645         return;
 646 
 647     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 648         repatchPutByID(globalObject, codeBlock, baseObject, structure, ident, slot, *stubInfo, Direct);</span>
 649 }
 650 
<span class="line-modified"> 651 void JIT_OPERATION operationPutByIdDirectNonStrictOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
 652 {
 653     SuperSamplerScope superSamplerScope(false);
 654 
<span class="line-modified"> 655     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 656     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 657     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 658     auto scope = DECLARE_THROW_SCOPE(vm);
 659 
 660     Identifier ident = Identifier::fromUid(vm, uid);
 661     AccessType accessType = static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType);
 662 
 663     JSValue value = JSValue::decode(encodedValue);
 664     JSObject* baseObject = asObject(JSValue::decode(encodedBase));
<span class="line-modified"> 665     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
 666     PutPropertySlot slot(baseObject, false, codeBlock-&gt;putByIdContext());
 667     Structure* structure = nullptr;
<span class="line-modified"> 668     CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, ident, value, slot, &amp;structure);</span>
 669 
 670     LOG_IC((ICEvent::OperationPutByIdDirectNonStrictOptimize, baseObject-&gt;classInfo(vm), ident, slot.base() == baseObject));
 671 
 672     RETURN_IF_EXCEPTION(scope, void());
 673 
 674     if (accessType != static_cast&lt;AccessType&gt;(stubInfo-&gt;accessType))
 675         return;
 676 
 677     if (stubInfo-&gt;considerCaching(vm, codeBlock, structure))
<span class="line-modified"> 678         repatchPutByID(globalObject, codeBlock, baseObject, structure, ident, slot, *stubInfo, Direct);</span>
 679 }
 680 
 681 ALWAYS_INLINE static bool isStringOrSymbol(JSValue value)
 682 {
 683     return value.isString() || value.isSymbol();
 684 }
 685 
<span class="line-modified"> 686 static void putByVal(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, JSValue value, ByValInfo* byValInfo)</span>
 687 {
<span class="line-modified"> 688     VM&amp; vm = globalObject-&gt;vm();</span>
 689     auto scope = DECLARE_THROW_SCOPE(vm);
 690     if (LIKELY(subscript.isUInt32())) {
 691         byValInfo-&gt;tookSlowPath = true;
 692         uint32_t i = subscript.asUInt32();
 693         if (baseValue.isObject()) {
 694             JSObject* object = asObject(baseValue);
 695             if (object-&gt;canSetIndexQuickly(i, value)) {
 696                 object-&gt;setIndexQuickly(vm, i, value);
 697                 return;
 698             }
 699 
 700             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 701             scope.release();
<span class="line-modified"> 702             object-&gt;methodTable(vm)-&gt;putByIndex(object, globalObject, i, value, codeBlock-&gt;isStrictMode());</span>
 703             return;
 704         }
 705 
 706         scope.release();
<span class="line-modified"> 707         baseValue.putByIndex(globalObject, i, value, codeBlock-&gt;isStrictMode());</span>
 708         return;
 709     } else if (subscript.isInt32()) {
 710         byValInfo-&gt;tookSlowPath = true;
 711         if (baseValue.isObject())
 712             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 713     }
 714 
<span class="line-modified"> 715     auto property = subscript.toPropertyKey(globalObject);</span>
 716     // Don&#39;t put to an object if toString threw an exception.
 717     RETURN_IF_EXCEPTION(scope, void());
 718 
 719     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
 720         byValInfo-&gt;tookSlowPath = true;
 721 
 722     scope.release();
<span class="line-modified"> 723     PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode());</span>
<span class="line-modified"> 724     baseValue.putInline(globalObject, property, value, slot);</span>
 725 }
 726 
<span class="line-modified"> 727 static void directPutByVal(JSGlobalObject* globalObject, CodeBlock* codeBlock, JSObject* baseObject, JSValue subscript, JSValue value, ByValInfo* byValInfo)</span>
 728 {
<span class="line-modified"> 729     VM&amp; vm = globalObject-&gt;vm();</span>
 730     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 731     bool isStrictMode = codeBlock-&gt;isStrictMode();</span>
 732 
 733     if (LIKELY(subscript.isUInt32())) {
 734         // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
 735         byValInfo-&gt;tookSlowPath = true;
 736         uint32_t index = subscript.asUInt32();
 737         ASSERT(isIndex(index));
 738 
 739         switch (baseObject-&gt;indexingType()) {
 740         case ALL_INT32_INDEXING_TYPES:
 741         case ALL_DOUBLE_INDEXING_TYPES:
 742         case ALL_CONTIGUOUS_INDEXING_TYPES:
 743         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 744             if (index &lt; baseObject-&gt;butterfly()-&gt;vectorLength())
 745                 break;
 746             FALLTHROUGH;
 747         default:
 748             byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
 749             break;
 750         }
 751 
 752         scope.release();
<span class="line-modified"> 753         baseObject-&gt;putDirectIndex(globalObject, index, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 754         return;
 755     }
 756 
 757     if (subscript.isDouble()) {
 758         double subscriptAsDouble = subscript.asDouble();
 759         uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
 760         if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
 761             byValInfo-&gt;tookSlowPath = true;
 762             scope.release();
<span class="line-modified"> 763             baseObject-&gt;putDirectIndex(globalObject, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 764             return;
 765         }
 766     }
 767 
 768     // Don&#39;t put to an object if toString threw an exception.
<span class="line-modified"> 769     auto property = subscript.toPropertyKey(globalObject);</span>
 770     RETURN_IF_EXCEPTION(scope, void());
 771 
 772     if (Optional&lt;uint32_t&gt; index = parseIndex(property)) {
 773         byValInfo-&gt;tookSlowPath = true;
 774         scope.release();
<span class="line-modified"> 775         baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
 776         return;
 777     }
 778 
 779     if (byValInfo-&gt;stubInfo &amp;&amp; (!isStringOrSymbol(subscript) || byValInfo-&gt;cachedId != property))
 780         byValInfo-&gt;tookSlowPath = true;
 781 
 782     scope.release();
 783     PutPropertySlot slot(baseObject, isStrictMode);
<span class="line-modified"> 784     CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, property, value, slot);</span>
 785 }
 786 
 787 enum class OptimizationResult {
 788     NotOptimized,
 789     SeenOnce,
 790     Optimized,
 791     GiveUp,
 792 };
 793 
<span class="line-modified"> 794 static OptimizationResult tryPutByValOptimize(JSGlobalObject* globalObject, CallFrame* callFrame, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)</span>
 795 {
<span class="line-added"> 796     UNUSED_PARAM(callFrame);</span>
<span class="line-added"> 797 </span>
 798     // See if it&#39;s worth optimizing at all.
 799     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 800 
<span class="line-modified"> 801     VM&amp; vm = globalObject-&gt;vm();</span>
 802     auto scope = DECLARE_THROW_SCOPE(vm);
 803 
 804     if (baseValue.isObject() &amp;&amp; isCopyOnWrite(baseValue.getObject()-&gt;indexingMode()))
 805         return OptimizationResult::GiveUp;
 806 
 807     if (baseValue.isObject() &amp;&amp; subscript.isInt32()) {
 808         JSObject* object = asObject(baseValue);
 809 
<span class="line-modified"> 810         ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>
 811         ASSERT(!byValInfo-&gt;stubRoutine);
 812 
 813         Structure* structure = object-&gt;structure(vm);
 814         if (hasOptimizableIndexing(structure)) {
 815             // Attempt to optimize.
 816             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 817             if (jitArrayModePermitsPut(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {

 818                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 819                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
 820                 JIT::compilePutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);
 821                 optimizationResult = OptimizationResult::Optimized;
 822             }
 823         }
 824 
 825         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 826         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 827             optimizationResult = OptimizationResult::GiveUp;
 828     }
 829 
 830     if (baseValue.isObject() &amp;&amp; isStringOrSymbol(subscript)) {
<span class="line-modified"> 831         const Identifier propertyName = subscript.toPropertyKey(globalObject);</span>
 832         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);
 833         if (subscript.isSymbol() || !parseIndex(propertyName)) {
<span class="line-modified"> 834             ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>
 835             ASSERT(!byValInfo-&gt;stubRoutine);
 836             if (byValInfo-&gt;seen) {
 837                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 838                     JIT::compilePutByValWithCachedId&lt;OpPutByVal&gt;(vm, codeBlock, byValInfo, returnAddress, NotDirect, propertyName);</span>
 839                     optimizationResult = OptimizationResult::Optimized;
 840                 } else {
 841                     // Seem like a generic property access site.
 842                     optimizationResult = OptimizationResult::GiveUp;
 843                 }
 844             } else {

 845                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 846                 byValInfo-&gt;seen = true;
 847                 byValInfo-&gt;cachedId = propertyName;
 848                 if (subscript.isSymbol())
 849                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 850                 optimizationResult = OptimizationResult::SeenOnce;
 851             }
 852         }
 853     }
 854 
 855     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 856         // If we take slow path more than 10 times without patching then make sure we
 857         // never make that mistake again. For cases where we see non-index-intercepting
 858         // objects, this gives 10 iterations worth of opportunity for us to observe
 859         // that the put_by_val may be polymorphic. We count up slowPathCount even if
 860         // the result is GiveUp.
 861         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 862             optimizationResult = OptimizationResult::GiveUp;
 863     }
 864 
 865     return optimizationResult;
 866 }
 867 
<span class="line-modified"> 868 void JIT_OPERATION operationPutByValOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 869 {
<span class="line-modified"> 870     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 871     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 872     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 873     auto scope = DECLARE_THROW_SCOPE(vm);
 874 
 875     JSValue baseValue = JSValue::decode(encodedBaseValue);
 876     JSValue subscript = JSValue::decode(encodedSubscript);
 877     JSValue value = JSValue::decode(encodedValue);
<span class="line-modified"> 878     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added"> 879     OptimizationResult result = tryPutByValOptimize(globalObject, callFrame, codeBlock, baseValue, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
 880     RETURN_IF_EXCEPTION(scope, void());
 881     if (result == OptimizationResult::GiveUp) {
 882         // Don&#39;t ever try to optimize.
 883         byValInfo-&gt;tookSlowPath = true;
 884         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationPutByValGeneric);
 885     }
<span class="line-modified"> 886     RELEASE_AND_RETURN(scope, putByVal(globalObject, codeBlock, baseValue, subscript, value, byValInfo));</span>
 887 }
 888 
<span class="line-modified"> 889 static OptimizationResult tryDirectPutByValOptimize(JSGlobalObject* globalObject, CallFrame* callFrame, CodeBlock* codeBlock, JSObject* object, JSValue subscript, ByValInfo* byValInfo, ReturnAddressPtr returnAddress)</span>
 890 {
<span class="line-added"> 891     UNUSED_PARAM(callFrame);</span>
<span class="line-added"> 892 </span>
 893     // See if it&#39;s worth optimizing at all.
 894     OptimizationResult optimizationResult = OptimizationResult::NotOptimized;
 895 
<span class="line-modified"> 896     VM&amp; vm = globalObject-&gt;vm();</span>
 897     auto scope = DECLARE_THROW_SCOPE(vm);
 898 
 899     if (subscript.isInt32()) {
<span class="line-modified"> 900         ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>
 901         ASSERT(!byValInfo-&gt;stubRoutine);
 902 
 903         Structure* structure = object-&gt;structure(vm);
 904         if (hasOptimizableIndexing(structure)) {
 905             // Attempt to optimize.
 906             JITArrayMode arrayMode = jitArrayModeForStructure(structure);
 907             if (jitArrayModePermitsPutDirect(arrayMode) &amp;&amp; arrayMode != byValInfo-&gt;arrayMode) {

 908                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 909                 byValInfo-&gt;arrayProfile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);
 910 
 911                 JIT::compileDirectPutByVal(locker, vm, codeBlock, byValInfo, returnAddress, arrayMode);
 912                 optimizationResult = OptimizationResult::Optimized;
 913             }
 914         }
 915 
 916         // If we failed to patch and we have some object that intercepts indexed get, then don&#39;t even wait until 10 times.
 917         if (optimizationResult != OptimizationResult::Optimized &amp;&amp; object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
 918             optimizationResult = OptimizationResult::GiveUp;
 919     } else if (isStringOrSymbol(subscript)) {
<span class="line-modified"> 920         const Identifier propertyName = subscript.toPropertyKey(globalObject);</span>
 921         RETURN_IF_EXCEPTION(scope, OptimizationResult::GiveUp);
 922         if (subscript.isSymbol() || !parseIndex(propertyName)) {
<span class="line-modified"> 923             ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>
 924             ASSERT(!byValInfo-&gt;stubRoutine);
 925             if (byValInfo-&gt;seen) {
 926                 if (byValInfo-&gt;cachedId == propertyName) {
<span class="line-modified"> 927                     JIT::compilePutByValWithCachedId&lt;OpPutByValDirect&gt;(vm, codeBlock, byValInfo, returnAddress, Direct, propertyName);</span>
 928                     optimizationResult = OptimizationResult::Optimized;
 929                 } else {
 930                     // Seem like a generic property access site.
 931                     optimizationResult = OptimizationResult::GiveUp;
 932                 }
 933             } else {

 934                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
 935                 byValInfo-&gt;seen = true;
 936                 byValInfo-&gt;cachedId = propertyName;
 937                 if (subscript.isSymbol())
 938                     byValInfo-&gt;cachedSymbol.set(vm, codeBlock, asSymbol(subscript));
 939                 optimizationResult = OptimizationResult::SeenOnce;
 940             }
 941         }
 942     }
 943 
 944     if (optimizationResult != OptimizationResult::Optimized &amp;&amp; optimizationResult != OptimizationResult::SeenOnce) {
 945         // If we take slow path more than 10 times without patching then make sure we
 946         // never make that mistake again. For cases where we see non-index-intercepting
 947         // objects, this gives 10 iterations worth of opportunity for us to observe
 948         // that the get_by_val may be polymorphic. We count up slowPathCount even if
 949         // the result is GiveUp.
 950         if (++byValInfo-&gt;slowPathCount &gt;= 10)
 951             optimizationResult = OptimizationResult::GiveUp;
 952     }
 953 
 954     return optimizationResult;
 955 }
 956 
<span class="line-modified"> 957 void JIT_OPERATION operationDirectPutByValOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 958 {
<span class="line-modified"> 959     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 960     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 961     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 962     auto scope = DECLARE_THROW_SCOPE(vm);
 963 
 964     JSValue baseValue = JSValue::decode(encodedBaseValue);
 965     JSValue subscript = JSValue::decode(encodedSubscript);
 966     JSValue value = JSValue::decode(encodedValue);
 967     RELEASE_ASSERT(baseValue.isObject());
 968     JSObject* object = asObject(baseValue);
<span class="line-modified"> 969     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added"> 970     OptimizationResult result = tryDirectPutByValOptimize(globalObject, callFrame, codeBlock, object, subscript, byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS));</span>
 971     RETURN_IF_EXCEPTION(scope, void());
 972     if (result == OptimizationResult::GiveUp) {
 973         // Don&#39;t ever try to optimize.
 974         byValInfo-&gt;tookSlowPath = true;
 975         ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationDirectPutByValGeneric);
 976     }
 977 
<span class="line-modified"> 978     RELEASE_AND_RETURN(scope, directPutByVal(globalObject, codeBlock, object, subscript, value, byValInfo));</span>
 979 }
 980 
<span class="line-modified"> 981 void JIT_OPERATION operationPutByValGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 982 {
<span class="line-modified"> 983     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 984     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 985     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
 986 
 987     JSValue baseValue = JSValue::decode(encodedBaseValue);
 988     JSValue subscript = JSValue::decode(encodedSubscript);
 989     JSValue value = JSValue::decode(encodedValue);
 990 
<span class="line-modified"> 991     putByVal(globalObject, callFrame-&gt;codeBlock(), baseValue, subscript, value, byValInfo);</span>
 992 }
 993 
 994 
<span class="line-modified"> 995 void JIT_OPERATION operationDirectPutByValGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBaseValue, EncodedJSValue encodedSubscript, EncodedJSValue encodedValue, ByValInfo* byValInfo)</span>
 996 {
<span class="line-modified"> 997     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified"> 998     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 999     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1000 
1001     JSValue baseValue = JSValue::decode(encodedBaseValue);
1002     JSValue subscript = JSValue::decode(encodedSubscript);
1003     JSValue value = JSValue::decode(encodedValue);
1004     RELEASE_ASSERT(baseValue.isObject());
<span class="line-modified">1005     directPutByVal(globalObject, callFrame-&gt;codeBlock(), asObject(baseValue), subscript, value, byValInfo);</span>
1006 }
1007 
<span class="line-modified">1008 EncodedJSValue JIT_OPERATION operationCallEval(JSGlobalObject* globalObject, CallFrame* calleeFrame)</span>
1009 {
<span class="line-modified">1010     VM&amp; vm = globalObject-&gt;vm();</span>
1011     auto scope = DECLARE_THROW_SCOPE(vm);
1012 
<span class="line-modified">1013     calleeFrame-&gt;setCodeBlock(0);</span>
1014 
<span class="line-modified">1015     if (!isHostFunction(calleeFrame-&gt;guaranteedJSValueCallee(), globalFuncEval))</span>
1016         return JSValue::encode(JSValue());
1017 
<span class="line-modified">1018     JSValue result = eval(globalObject, calleeFrame);</span>
1019     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1020 
1021     return JSValue::encode(result);
1022 }
1023 
<span class="line-modified">1024 static SlowPathReturnType handleHostCall(JSGlobalObject* globalObject, CallFrame* calleeFrame, JSValue callee, CallLinkInfo* callLinkInfo)</span>
1025 {
<span class="line-modified">1026     VM&amp; vm = globalObject-&gt;vm();</span>

1027     auto scope = DECLARE_THROW_SCOPE(vm);
1028 
<span class="line-modified">1029     calleeFrame-&gt;setCodeBlock(0);</span>
1030 
1031     if (callLinkInfo-&gt;specializationKind() == CodeForCall) {
1032         CallData callData;
1033         CallType callType = getCallData(vm, callee, callData);
1034 
1035         ASSERT(callType != CallType::JS);
1036 
1037         if (callType == CallType::Host) {
<span class="line-modified">1038             NativeCallFrameTracer tracer(vm, calleeFrame);</span>
<span class="line-modified">1039             calleeFrame-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1040             vm.hostCallReturnValue = JSValue::decode(callData.native.function(asObject(callee)-&gt;globalObject(vm), calleeFrame));</span>
1041             if (UNLIKELY(scope.exception())) {
1042                 return encodeResult(
1043                     vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1044                     reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1045             }
1046 
1047             return encodeResult(
1048                 tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue),
1049                 reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1050         }
1051 
1052         ASSERT(callType == CallType::None);
<span class="line-modified">1053         throwException(globalObject, scope, createNotAFunctionError(globalObject, callee));</span>
1054         return encodeResult(
1055             vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1056             reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1057     }
1058 
1059     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForConstruct);
1060 
1061     ConstructData constructData;
1062     ConstructType constructType = getConstructData(vm, callee, constructData);
1063 
1064     ASSERT(constructType != ConstructType::JS);
1065 
1066     if (constructType == ConstructType::Host) {
<span class="line-modified">1067         NativeCallFrameTracer tracer(vm, calleeFrame);</span>
<span class="line-modified">1068         calleeFrame-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">1069         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(asObject(callee)-&gt;globalObject(vm), calleeFrame));</span>
1070         if (UNLIKELY(scope.exception())) {
1071             return encodeResult(
1072                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1073                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1074         }
1075 
1076         return encodeResult(tagCFunctionPtr&lt;void*, JSEntryPtrTag&gt;(getHostCallReturnValue), reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1077     }
1078 
1079     ASSERT(constructType == ConstructType::None);
<span class="line-modified">1080     throwException(globalObject, scope, createNotAConstructorError(globalObject, callee));</span>
1081     return encodeResult(
1082         vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1083         reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1084 }
1085 
<span class="line-modified">1086 SlowPathReturnType JIT_OPERATION operationLinkCall(CallFrame* calleeFrame, JSGlobalObject* globalObject, CallLinkInfo* callLinkInfo)</span>
1087 {
<span class="line-modified">1088     CallFrame* callFrame = calleeFrame-&gt;callerFrame();</span>
<span class="line-modified">1089     VM&amp; vm = globalObject-&gt;vm();</span>
1090     auto throwScope = DECLARE_THROW_SCOPE(vm);
1091 
1092     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
<span class="line-modified">1093     NativeCallFrameTracer tracer(vm, callFrame);</span>
1094 
1095     RELEASE_ASSERT(!callLinkInfo-&gt;isDirect());
1096 
<span class="line-modified">1097     JSValue calleeAsValue = calleeFrame-&gt;guaranteedJSValueCallee();</span>
1098     JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
1099     if (!calleeAsFunctionCell) {
1100         if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1101             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1102             RELEASE_ASSERT(!!codePtr);
1103 
1104             if (!callLinkInfo-&gt;seenOnce())
1105                 callLinkInfo-&gt;setSeen();
1106             else
<span class="line-modified">1107                 linkFor(vm, calleeFrame, *callLinkInfo, nullptr, internalFunction, codePtr);</span>
1108 
1109             void* linkedTarget = codePtr.executableAddress();
1110             return encodeResult(linkedTarget, reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1111         }
<span class="line-modified">1112         RELEASE_AND_RETURN(throwScope, handleHostCall(globalObject, calleeFrame, calleeAsValue, callLinkInfo));</span>
1113     }
1114 
1115     JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1116     JSScope* scope = callee-&gt;scopeUnchecked();
1117     ExecutableBase* executable = callee-&gt;executable();
1118 
1119     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1120     CodeBlock* codeBlock = nullptr;
1121     if (executable-&gt;isHostFunction()) {
1122         codePtr = jsToWasmICCodePtr(vm, kind, callee);
1123         if (!codePtr)
1124             codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
1125     } else {
1126         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1127 
1128         auto handleThrowException = [&amp;] () {
1129             void* throwTarget = vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress();
1130             return encodeResult(throwTarget, reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1131         };
1132 
1133         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
<span class="line-modified">1134             throwException(globalObject, throwScope, createNotAConstructorError(globalObject, callee));</span>
1135             return handleThrowException();
1136         }
1137 
<span class="line-modified">1138         CodeBlock** codeBlockSlot = calleeFrame-&gt;addressOfCodeBlock();</span>
1139         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);
1140         EXCEPTION_ASSERT(throwScope.exception() == error);
1141         if (UNLIKELY(error))
1142             return handleThrowException();
1143         codeBlock = *codeBlockSlot;
1144         ArityCheckMode arity;
<span class="line-modified">1145         if (calleeFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo-&gt;isVarargs())</span>
1146             arity = MustCheckArity;
1147         else
1148             arity = ArityCheckNotRequired;
1149         codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
1150     }
1151 
1152     if (!callLinkInfo-&gt;seenOnce())
1153         callLinkInfo-&gt;setSeen();
1154     else
<span class="line-modified">1155         linkFor(vm, calleeFrame, *callLinkInfo, codeBlock, callee, codePtr);</span>
1156 
1157     return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1158 }
1159 
<span class="line-modified">1160 inline SlowPathReturnType virtualForWithFunction(JSGlobalObject* globalObject, CallFrame* calleeFrame, CallLinkInfo* callLinkInfo, JSCell*&amp; calleeAsFunctionCell)</span>



















































1161 {
<span class="line-modified">1162     CallFrame* callFrame = calleeFrame-&gt;callerFrame();</span>
<span class="line-modified">1163     VM&amp; vm = globalObject-&gt;vm();</span>
1164     auto throwScope = DECLARE_THROW_SCOPE(vm);
1165 
1166     CodeSpecializationKind kind = callLinkInfo-&gt;specializationKind();
<span class="line-modified">1167     NativeCallFrameTracer tracer(vm, callFrame);</span>
1168 
<span class="line-modified">1169     JSValue calleeAsValue = calleeFrame-&gt;guaranteedJSValueCallee();</span>
1170     calleeAsFunctionCell = getJSFunction(calleeAsValue);
1171     if (UNLIKELY(!calleeAsFunctionCell)) {
1172         if (jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
1173             MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
1174             ASSERT(!!codePtr);
1175             return encodeResult(codePtr.executableAddress(), reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1176         }
<span class="line-modified">1177         RELEASE_AND_RETURN(throwScope, handleHostCall(globalObject, calleeFrame, calleeAsValue, callLinkInfo));</span>
1178     }
1179 
1180     JSFunction* function = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
1181     JSScope* scope = function-&gt;scopeUnchecked();
1182     ExecutableBase* executable = function-&gt;executable();
1183     if (UNLIKELY(!executable-&gt;hasJITCodeFor(kind))) {
1184         FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
1185 
1186         if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct) {
<span class="line-modified">1187             throwException(globalObject, throwScope, createNotAConstructorError(globalObject, function));</span>
1188             return encodeResult(
1189                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1190                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1191         }
1192 
<span class="line-modified">1193         CodeBlock** codeBlockSlot = calleeFrame-&gt;addressOfCodeBlock();</span>
1194         Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, kind, *codeBlockSlot);
1195         EXCEPTION_ASSERT(throwScope.exception() == error);
1196         if (UNLIKELY(error)) {
1197             return encodeResult(
1198                 vm.getCTIStub(throwExceptionFromCallSlowPathGenerator).retaggedCode&lt;JSEntryPtrTag&gt;().executableAddress(),
1199                 reinterpret_cast&lt;void*&gt;(KeepTheFrame));
1200         }
1201     }
1202     return encodeResult(executable-&gt;entrypointFor(
1203         kind, MustCheckArity).executableAddress(),
1204         reinterpret_cast&lt;void*&gt;(callLinkInfo-&gt;callMode() == CallMode::Tail ? ReuseTheFrame : KeepTheFrame));
1205 }
1206 
<span class="line-modified">1207 SlowPathReturnType JIT_OPERATION operationLinkPolymorphicCall(CallFrame* calleeFrame, JSGlobalObject* globalObject, CallLinkInfo* callLinkInfo)</span>
1208 {
1209     ASSERT(callLinkInfo-&gt;specializationKind() == CodeForCall);
1210     JSCell* calleeAsFunctionCell;
<span class="line-modified">1211     SlowPathReturnType result = virtualForWithFunction(globalObject, calleeFrame, callLinkInfo, calleeAsFunctionCell);</span>
1212 
<span class="line-modified">1213     linkPolymorphicCall(globalObject, calleeFrame, *callLinkInfo, CallVariant(calleeAsFunctionCell));</span>
1214 
1215     return result;
1216 }
1217 
<span class="line-modified">1218 SlowPathReturnType JIT_OPERATION operationVirtualCall(CallFrame* calleeFrame, JSGlobalObject* globalObject, CallLinkInfo* callLinkInfo)</span>
1219 {
1220     JSCell* calleeAsFunctionCellIgnored;
<span class="line-modified">1221     return virtualForWithFunction(globalObject, calleeFrame, callLinkInfo, calleeAsFunctionCellIgnored);</span>
1222 }
1223 
<span class="line-modified">1224 size_t JIT_OPERATION operationCompareLess(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1225 {
<span class="line-modified">1226     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1227     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1228     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1229 
<span class="line-modified">1230     return jsLess&lt;true&gt;(globalObject, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));</span>
1231 }
1232 
<span class="line-modified">1233 size_t JIT_OPERATION operationCompareLessEq(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1234 {
<span class="line-modified">1235     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1236     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1237     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1238 
<span class="line-modified">1239     return jsLessEq&lt;true&gt;(globalObject, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));</span>
1240 }
1241 
<span class="line-modified">1242 size_t JIT_OPERATION operationCompareGreater(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1243 {
<span class="line-modified">1244     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1245     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1246     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1247 
<span class="line-modified">1248     return jsLess&lt;false&gt;(globalObject, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));</span>
1249 }
1250 
<span class="line-modified">1251 size_t JIT_OPERATION operationCompareGreaterEq(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1252 {
<span class="line-modified">1253     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1254     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1255     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1256 
<span class="line-modified">1257     return jsLessEq&lt;false&gt;(globalObject, JSValue::decode(encodedOp2), JSValue::decode(encodedOp1));</span>
1258 }
1259 
<span class="line-modified">1260 size_t JIT_OPERATION operationCompareEq(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1261 {
<span class="line-modified">1262     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1263     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1264     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1265 
<span class="line-modified">1266     return JSValue::equalSlowCaseInline(globalObject, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));</span>
1267 }
1268 
1269 #if USE(JSVALUE64)
<span class="line-modified">1270 EncodedJSValue JIT_OPERATION operationCompareStringEq(JSGlobalObject* globalObject, JSCell* left, JSCell* right)</span>
1271 #else
<span class="line-modified">1272 size_t JIT_OPERATION operationCompareStringEq(JSGlobalObject* globalObject, JSCell* left, JSCell* right)</span>
1273 #endif
1274 {
<span class="line-modified">1275     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1276     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1277     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1278 
<span class="line-modified">1279     bool result = asString(left)-&gt;equal(globalObject, asString(right));</span>
1280 #if USE(JSVALUE64)
1281     return JSValue::encode(jsBoolean(result));
1282 #else
1283     return result;
1284 #endif
1285 }
1286 
<span class="line-modified">1287 size_t JIT_OPERATION operationCompareStrictEq(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
1288 {
<span class="line-modified">1289     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1290     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1291     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1292 
1293     JSValue src1 = JSValue::decode(encodedOp1);
1294     JSValue src2 = JSValue::decode(encodedOp2);
1295 
<span class="line-modified">1296     return JSValue::strictEqual(globalObject, src1, src2);</span>
1297 }
1298 
<span class="line-modified">1299 EncodedJSValue JIT_OPERATION operationNewArrayWithProfile(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const JSValue* values, int size)</span>
1300 {
<span class="line-modified">1301     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1302     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">1303     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1304     return JSValue::encode(constructArrayNegativeIndexed(globalObject, profile, values, size));</span>
1305 }
1306 
<span class="line-modified">1307 EncodedJSValue JIT_OPERATION operationNewArrayWithSizeAndProfile(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, EncodedJSValue size)</span>
1308 {
<span class="line-modified">1309     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1310     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1311     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1312     JSValue sizeValue = JSValue::decode(size);
<span class="line-modified">1313     return JSValue::encode(constructArrayWithSizeQuirk(globalObject, profile, sizeValue));</span>
1314 }
1315 
1316 }
1317 
1318 template&lt;typename FunctionType&gt;
<span class="line-modified">1319 static EncodedJSValue newFunctionCommon(VM&amp; vm, JSScope* scope, JSCell* functionExecutable, bool isInvalidated)</span>
1320 {

1321     ASSERT(functionExecutable-&gt;inherits&lt;FunctionExecutable&gt;(vm));

1322     if (isInvalidated)
1323         return JSValue::encode(FunctionType::createWithInvalidatedReallocationWatchpoint(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1324     return JSValue::encode(FunctionType::create(vm, static_cast&lt;FunctionExecutable*&gt;(functionExecutable), scope));
1325 }
1326 
1327 extern &quot;C&quot; {
1328 
<span class="line-modified">1329 EncodedJSValue JIT_OPERATION operationNewFunction(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1330 {
<span class="line-modified">1331     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1332     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1333     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1334     return newFunctionCommon&lt;JSFunction&gt;(vm, scope, functionExecutable, false);</span>
1335 }
1336 
<span class="line-modified">1337 EncodedJSValue JIT_OPERATION operationNewFunctionWithInvalidatedReallocationWatchpoint(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1338 {
<span class="line-modified">1339     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1340     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1341     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1342     return newFunctionCommon&lt;JSFunction&gt;(vm, scope, functionExecutable, true);</span>
1343 }
1344 
<span class="line-modified">1345 EncodedJSValue JIT_OPERATION operationNewGeneratorFunction(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1346 {
<span class="line-modified">1347     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1348     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1349     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1350     return newFunctionCommon&lt;JSGeneratorFunction&gt;(vm, scope, functionExecutable, false);</span>
1351 }
1352 
<span class="line-modified">1353 EncodedJSValue JIT_OPERATION operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1354 {
<span class="line-modified">1355     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1356     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1357     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1358     return newFunctionCommon&lt;JSGeneratorFunction&gt;(vm, scope, functionExecutable, true);</span>
1359 }
1360 
<span class="line-modified">1361 EncodedJSValue JIT_OPERATION operationNewAsyncFunction(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1362 {
<span class="line-modified">1363     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1364     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1365     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1366     return newFunctionCommon&lt;JSAsyncFunction&gt;(vm, scope, functionExecutable, false);</span>
1367 }
1368 
<span class="line-modified">1369 EncodedJSValue JIT_OPERATION operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1370 {
<span class="line-modified">1371     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1372     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1373     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1374     return newFunctionCommon&lt;JSAsyncFunction&gt;(vm, scope, functionExecutable, true);</span>
1375 }
1376 
<span class="line-modified">1377 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunction(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1378 {
<span class="line-modified">1379     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1380     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1381     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1382     return newFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(vm, scope, functionExecutable, false);</span>
1383 }
1384 
<span class="line-modified">1385 EncodedJSValue JIT_OPERATION operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint(VM* vmPointer, JSScope* scope, JSCell* functionExecutable)</span>
1386 {
<span class="line-modified">1387     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1388     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1389     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1390     return newFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(vm, scope, functionExecutable, true);</span>
1391 }
1392 
<span class="line-modified">1393 void JIT_OPERATION operationSetFunctionName(JSGlobalObject* globalObject, JSCell* funcCell, EncodedJSValue encodedName)</span>
1394 {
<span class="line-modified">1395     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1396     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1397     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1398 
1399     JSFunction* func = jsCast&lt;JSFunction*&gt;(funcCell);
1400     JSValue name = JSValue::decode(encodedName);
<span class="line-modified">1401     func-&gt;setFunctionName(globalObject, name);</span>
<span class="line-added">1402 }</span>
<span class="line-added">1403 </span>
<span class="line-added">1404 JSCell* JIT_OPERATION operationNewObject(VM* vmPointer, Structure* structure)</span>
<span class="line-added">1405 {</span>
<span class="line-added">1406     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1407     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1408     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1409 </span>
<span class="line-added">1410     return constructEmptyObject(vm, structure);</span>
<span class="line-added">1411 }</span>
<span class="line-added">1412 </span>
<span class="line-added">1413 JSCell* JIT_OPERATION operationNewPromise(VM* vmPointer, Structure* structure)</span>
<span class="line-added">1414 {</span>
<span class="line-added">1415     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1416     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1417     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1418 </span>
<span class="line-added">1419     return JSPromise::create(vm, structure);</span>
<span class="line-added">1420 }</span>
<span class="line-added">1421 </span>
<span class="line-added">1422 JSCell* JIT_OPERATION operationNewInternalPromise(VM* vmPointer, Structure* structure)</span>
<span class="line-added">1423 {</span>
<span class="line-added">1424     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1425     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1426     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1427 </span>
<span class="line-added">1428     return JSInternalPromise::create(vm, structure);</span>
<span class="line-added">1429 }</span>
<span class="line-added">1430 </span>
<span class="line-added">1431 JSCell* JIT_OPERATION operationNewGenerator(VM* vmPointer, Structure* structure)</span>
<span class="line-added">1432 {</span>
<span class="line-added">1433     VM&amp; vm = *vmPointer;</span>
<span class="line-added">1434     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1435     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1436 </span>
<span class="line-added">1437     return JSGenerator::create(vm, structure);</span>
1438 }
1439 
<span class="line-modified">1440 JSCell* JIT_OPERATION operationNewAsyncGenerator(VM* vmPointer, Structure* structure)</span>
1441 {
<span class="line-modified">1442     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1443     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1444     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1445 
<span class="line-modified">1446     return JSAsyncGenerator::create(vm, structure);</span>
1447 }
1448 
<span class="line-modified">1449 JSCell* JIT_OPERATION operationNewRegexp(JSGlobalObject* globalObject, JSCell* regexpPtr)</span>
1450 {
1451     SuperSamplerScope superSamplerScope(false);
<span class="line-modified">1452     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1453     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1454     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1455 
1456     RegExp* regexp = static_cast&lt;RegExp*&gt;(regexpPtr);
1457     ASSERT(regexp-&gt;isValid());
<span class="line-modified">1458     return RegExpObject::create(vm, globalObject-&gt;regExpStructure(), regexp);</span>
1459 }
1460 
1461 // The only reason for returning an UnusedPtr (instead of void) is so that we can reuse the
1462 // existing DFG slow path generator machinery when creating the slow path for CheckTraps
1463 // in the DFG. If a DFG slow path generator that supports a void return type is added in the
1464 // future, we can switch to using that then.
<span class="line-modified">1465 UnusedPtr JIT_OPERATION operationHandleTraps(JSGlobalObject* globalObject)</span>
1466 {
<span class="line-modified">1467     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1468     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1469     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1470     ASSERT(vm.needTrapHandling());
<span class="line-modified">1471     vm.handleTraps(globalObject, callFrame);</span>
1472     return nullptr;
1473 }
1474 
<span class="line-modified">1475 void JIT_OPERATION operationDebug(VM* vmPointer, int32_t debugHookType)</span>
1476 {
<span class="line-modified">1477     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1478     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1479     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1480 
<span class="line-modified">1481     vm.interpreter-&gt;debug(callFrame, static_cast&lt;DebugHookType&gt;(debugHookType));</span>
1482 }
1483 
1484 #if ENABLE(DFG_JIT)
1485 static void updateAllPredictionsAndOptimizeAfterWarmUp(CodeBlock* codeBlock)
1486 {
1487     codeBlock-&gt;updateAllPredictions();
1488     codeBlock-&gt;optimizeAfterWarmUp();
1489 }
1490 
<span class="line-modified">1491 SlowPathReturnType JIT_OPERATION operationOptimize(VM* vmPointer, uint32_t bytecodeIndexBits)</span>
1492 {
<span class="line-modified">1493     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1494     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1495     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1496     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
1497 
1498     // Defer GC for a while so that it doesn&#39;t run between when we enter into this
1499     // slow path and when we figure out the state of our code block. This prevents
1500     // a number of awkward reentrancy scenarios, including:
1501     //
1502     // - The optimized version of our code block being jettisoned by GC right after
1503     //   we concluded that we wanted to use it, but have not planted it into the JS
1504     //   stack yet.
1505     //
1506     // - An optimized version of our code block being installed just as we decided
1507     //   that it wasn&#39;t ready yet.
1508     //
1509     // Note that jettisoning won&#39;t happen if we already initiated OSR, because in
1510     // that case we would have already planted the optimized code block into the JS
1511     // stack.
1512     DeferGCForAWhile deferGC(vm.heap);
1513 
<span class="line-modified">1514     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
1515     if (UNLIKELY(codeBlock-&gt;jitType() != JITType::BaselineJIT)) {
1516         dataLog(&quot;Unexpected code block in Baseline-&gt;DFG tier-up: &quot;, *codeBlock, &quot;\n&quot;);
1517         RELEASE_ASSERT_NOT_REACHED();
1518     }
1519 
1520     if (bytecodeIndex) {
1521         // If we&#39;re attempting to OSR from a loop, assume that this should be
1522         // separately optimized.
1523         codeBlock-&gt;m_shouldAlwaysBeInlined = false;
1524     }
1525 
1526     if (UNLIKELY(Options::verboseOSR())) {
1527         dataLog(
1528             *codeBlock, &quot;: Entered optimize with bytecodeIndex = &quot;, bytecodeIndex,
1529             &quot;, executeCounter = &quot;, codeBlock-&gt;jitExecuteCounter(),
1530             &quot;, optimizationDelayCounter = &quot;, codeBlock-&gt;reoptimizationRetryCounter(),
1531             &quot;, exitCounter = &quot;);
1532         if (codeBlock-&gt;hasOptimizedReplacement())
1533             dataLog(codeBlock-&gt;replacement()-&gt;osrExitCounter());
1534         else
1535             dataLog(&quot;N/A&quot;);
1536         dataLog(&quot;\n&quot;);
1537     }
1538 
1539     if (!codeBlock-&gt;checkIfOptimizationThresholdReached()) {
1540         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;counter = &quot;, codeBlock-&gt;jitExecuteCounter()));
1541         codeBlock-&gt;updateAllPredictions();
<span class="line-modified">1542         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to optimize &quot;, *codeBlock, &quot; yet, because the threshold hasn&#39;t been reached.&quot;);</span>

1543         return encodeResult(0, 0);
1544     }
1545 
1546     Debugger* debugger = codeBlock-&gt;globalObject()-&gt;debugger();
1547     if (UNLIKELY(debugger &amp;&amp; (debugger-&gt;isStepping() || codeBlock-&gt;baselineAlternative()-&gt;hasDebuggerRequests()))) {
1548         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;debugger is stepping or has requests&quot;));
1549         updateAllPredictionsAndOptimizeAfterWarmUp(codeBlock);
1550         return encodeResult(0, 0);
1551     }
1552 
1553     if (codeBlock-&gt;m_shouldAlwaysBeInlined) {
1554         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;should always be inlined&quot;));
1555         updateAllPredictionsAndOptimizeAfterWarmUp(codeBlock);
<span class="line-modified">1556         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to optimize &quot;, *codeBlock, &quot; yet, because m_shouldAlwaysBeInlined == true.&quot;);</span>

1557         return encodeResult(0, 0);
1558     }
1559 
1560     // We cannot be in the process of asynchronous compilation and also have an optimized
1561     // replacement.
1562     DFG::Worklist* worklist = DFG::existingGlobalDFGWorklistOrNull();
1563     ASSERT(
1564         !worklist
1565         || !(worklist-&gt;compilationState(DFG::CompilationKey(codeBlock, DFG::DFGMode)) != DFG::Worklist::NotKnown
1566         &amp;&amp; codeBlock-&gt;hasOptimizedReplacement()));
1567 
1568     DFG::Worklist::State worklistState;
1569     if (worklist) {
1570         // The call to DFG::Worklist::completeAllReadyPlansForVM() will complete all ready
1571         // (i.e. compiled) code blocks. But if it completes ours, we also need to know
1572         // what the result was so that we don&#39;t plow ahead and attempt OSR or immediate
1573         // reoptimization. This will have already also set the appropriate JIT execution
1574         // count threshold depending on what happened, so if the compilation was anything
1575         // but successful we just want to return early. See the case for worklistState ==
1576         // DFG::Worklist::Compiled, below.
</pre>
<hr />
<pre>
1591         worklistState = DFG::Worklist::NotKnown;
1592 
1593     if (worklistState == DFG::Worklist::Compiling) {
1594         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;compiling&quot;));
1595         // We cannot be in the process of asynchronous compilation and also have an optimized
1596         // replacement.
1597         RELEASE_ASSERT(!codeBlock-&gt;hasOptimizedReplacement());
1598         codeBlock-&gt;setOptimizationThresholdBasedOnCompilationResult(CompilationDeferred);
1599         return encodeResult(0, 0);
1600     }
1601 
1602     if (worklistState == DFG::Worklist::Compiled) {
1603         // If we don&#39;t have an optimized replacement but we did just get compiled, then
1604         // the compilation failed or was invalidated, in which case the execution count
1605         // thresholds have already been set appropriately by
1606         // CodeBlock::setOptimizationThresholdBasedOnCompilationResult() and we have
1607         // nothing left to do.
1608         if (!codeBlock-&gt;hasOptimizedReplacement()) {
1609             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;compiled and failed&quot;));
1610             codeBlock-&gt;updateAllPredictions();
<span class="line-modified">1611             dataLogLnIf(Options::verboseOSR(), &quot;Code block &quot;, *codeBlock, &quot; was compiled but it doesn&#39;t have an optimized replacement.&quot;);</span>

1612             return encodeResult(0, 0);
1613         }
1614     } else if (codeBlock-&gt;hasOptimizedReplacement()) {
1615         CodeBlock* replacement = codeBlock-&gt;replacement();
<span class="line-modified">1616         dataLogLnIf(Options::verboseOSR(), &quot;Considering OSR &quot;, codeBlock, &quot; -&gt; &quot;, replacement, &quot;.&quot;);</span>

1617         // If we have an optimized replacement, then it must be the case that we entered
1618         // cti_optimize from a loop. That&#39;s because if there&#39;s an optimized replacement,
1619         // then all calls to this function will be relinked to the replacement and so
1620         // the prologue OSR will never fire.
1621 
1622         // This is an interesting threshold check. Consider that a function OSR exits
1623         // in the middle of a loop, while having a relatively low exit count. The exit
1624         // will reset the execution counter to some target threshold, meaning that this
1625         // code won&#39;t be reached until that loop heats up for &gt;=1000 executions. But then
1626         // we do a second check here, to see if we should either reoptimize, or just
1627         // attempt OSR entry. Hence it might even be correct for
1628         // shouldReoptimizeFromLoopNow() to always return true. But we make it do some
1629         // additional checking anyway, to reduce the amount of recompilation thrashing.
1630         if (replacement-&gt;shouldReoptimizeFromLoopNow()) {
1631             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;should reoptimize from loop now&quot;));
<span class="line-modified">1632             dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">1633                 &quot;Triggering reoptimization of &quot;, codeBlock,</span>
<span class="line-modified">1634                 &quot;(&quot;, replacement, &quot;) (in loop).&quot;);</span>


1635             replacement-&gt;jettison(Profiler::JettisonDueToBaselineLoopReoptimizationTrigger, CountReoptimization);
1636             return encodeResult(0, 0);
1637         }
1638     } else {
1639         if (!codeBlock-&gt;shouldOptimizeNow()) {
1640             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;insufficient profiling&quot;));
<span class="line-modified">1641             dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">1642                 &quot;Delaying optimization for &quot;, *codeBlock,</span>
<span class="line-modified">1643                 &quot; because of insufficient profiling.&quot;);</span>


1644             return encodeResult(0, 0);
1645         }
1646 
<span class="line-modified">1647         dataLogLnIf(Options::verboseOSR(), &quot;Triggering optimized compilation of &quot;, *codeBlock);</span>

1648 
<span class="line-modified">1649         unsigned numVarsWithValues = 0;</span>
1650         if (bytecodeIndex)
1651             numVarsWithValues = codeBlock-&gt;numCalleeLocals();
<span class="line-modified">1652 </span>
<span class="line-modified">1653         Operands&lt;Optional&lt;JSValue&gt;&gt; mustHandleValues(codeBlock-&gt;numParameters(), numVarsWithValues, 0);</span>

1654         int localsUsedForCalleeSaves = static_cast&lt;int&gt;(CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters());
1655         for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<span class="line-modified">1656             Operand operand = mustHandleValues.operandForIndex(i);</span>
<span class="line-modified">1657 </span>
<span class="line-added">1658             if (operand.isLocal() &amp;&amp; operand.toLocal() &lt; localsUsedForCalleeSaves)</span>
1659                 continue;
<span class="line-modified">1660             mustHandleValues[i] = callFrame-&gt;uncheckedR(operand.virtualRegister()).jsValue();</span>
1661         }
1662 
1663         CodeBlock* replacementCodeBlock = codeBlock-&gt;newReplacement();
1664         CompilationResult result = DFG::compile(
1665             vm, replacementCodeBlock, nullptr, DFG::DFGMode, bytecodeIndex,
1666             mustHandleValues, JITToDFGDeferredCompilationCallback::create());
1667 
1668         if (result != CompilationSuccessful) {
1669             CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;compilation failed&quot;));
1670             return encodeResult(0, 0);
1671         }
1672     }
1673 
1674     CodeBlock* optimizedCodeBlock = codeBlock-&gt;replacement();
1675     ASSERT(optimizedCodeBlock &amp;&amp; JITCode::isOptimizingJIT(optimizedCodeBlock-&gt;jitType()));
1676 
<span class="line-modified">1677     if (void* dataBuffer = DFG::prepareOSREntry(vm, callFrame, optimizedCodeBlock, bytecodeIndex)) {</span>
1678         CODEBLOCK_LOG_EVENT(optimizedCodeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, bytecodeIndex));
<span class="line-modified">1679         dataLogLnIf(Options::verboseOSR(), &quot;Performing OSR &quot;, codeBlock, &quot; -&gt; &quot;, optimizedCodeBlock);</span>



1680 
1681         codeBlock-&gt;optimizeSoon();
1682         codeBlock-&gt;unlinkedCodeBlock()-&gt;setDidOptimize(TrueTriState);
1683         void* targetPC = vm.getCTIStub(DFG::osrEntryThunkGenerator).code().executableAddress();
<span class="line-modified">1684         targetPC = retagCodePtr(targetPC, JITThunkPtrTag, bitwise_cast&lt;PtrTag&gt;(callFrame));</span>
1685         return encodeResult(targetPC, dataBuffer);
1686     }
1687 
<span class="line-modified">1688     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">1689         &quot;Optimizing &quot;, codeBlock, &quot; -&gt; &quot;, codeBlock-&gt;replacement(),</span>
<span class="line-modified">1690         &quot; succeeded, OSR failed, after a delay of &quot;,</span>
<span class="line-modified">1691         codeBlock-&gt;optimizationDelayCounter());</span>


1692 
1693     // Count the OSR failure as a speculation failure. If this happens a lot, then
1694     // reoptimize.
1695     optimizedCodeBlock-&gt;countOSRExit();
1696 
1697     // We are a lot more conservative about triggering reoptimization after OSR failure than
1698     // before it. If we enter the optimize_from_loop trigger with a bucket full of fail
1699     // already, then we really would like to reoptimize immediately. But this case covers
1700     // something else: there weren&#39;t many (or any) speculation failures before, but we just
1701     // failed to enter the speculative code because some variable had the wrong value or
1702     // because the OSR code decided for any spurious reason that it did not want to OSR
1703     // right now. So, we only trigger reoptimization only upon the more conservative (non-loop)
1704     // reoptimization trigger.
1705     if (optimizedCodeBlock-&gt;shouldReoptimizeNow()) {
1706         CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;should reoptimize now&quot;));
<span class="line-modified">1707         dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">1708             &quot;Triggering reoptimization of &quot;, codeBlock, &quot; -&gt; &quot;,</span>
<span class="line-modified">1709             codeBlock-&gt;replacement(), &quot; (after OSR fail).&quot;);</span>


1710         optimizedCodeBlock-&gt;jettison(Profiler::JettisonDueToBaselineLoopReoptimizationTriggerOnOSREntryFail, CountReoptimization);
1711         return encodeResult(0, 0);
1712     }
1713 
1714     // OSR failed this time, but it might succeed next time! Let the code run a bit
1715     // longer and then try again.
1716     codeBlock-&gt;optimizeAfterWarmUp();
1717 
1718     CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayOptimizeToDFG&quot;, (&quot;OSR failed&quot;));
1719     return encodeResult(0, 0);
1720 }
1721 
<span class="line-modified">1722 char* JIT_OPERATION operationTryOSREnterAtCatch(VM* vmPointer, uint32_t bytecodeIndexBits)</span>
1723 {
<span class="line-modified">1724     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1725     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1726     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1727     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
1728 
<span class="line-modified">1729     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">1730     CodeBlock* optimizedReplacement = codeBlock-&gt;replacement();</span>
1731     if (UNLIKELY(!optimizedReplacement))
1732         return nullptr;
1733 
1734     switch (optimizedReplacement-&gt;jitType()) {
1735     case JITType::DFGJIT:
1736     case JITType::FTLJIT: {
<span class="line-modified">1737         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(vm, callFrame, codeBlock, optimizedReplacement, bytecodeIndex);</span>
1738         return entry.executableAddress&lt;char*&gt;();
1739     }
1740     default:
1741         break;
1742     }
1743     return nullptr;
1744 }
1745 
<span class="line-modified">1746 char* JIT_OPERATION operationTryOSREnterAtCatchAndValueProfile(VM* vmPointer, uint32_t bytecodeIndexBits)</span>
1747 {
<span class="line-modified">1748     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">1749     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1750     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1751     BytecodeIndex bytecodeIndex = BytecodeIndex::fromBits(bytecodeIndexBits);</span>
1752 
<span class="line-modified">1753     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
1754     CodeBlock* optimizedReplacement = codeBlock-&gt;replacement();
1755     if (UNLIKELY(!optimizedReplacement))
1756         return nullptr;
1757 
1758     switch (optimizedReplacement-&gt;jitType()) {
1759     case JITType::DFGJIT:
1760     case JITType::FTLJIT: {
<span class="line-modified">1761         MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; entry = DFG::prepareCatchOSREntry(vm, callFrame, codeBlock, optimizedReplacement, bytecodeIndex);</span>
1762         return entry.executableAddress&lt;char*&gt;();
1763     }
1764     default:
1765         break;
1766     }
1767 
<span class="line-modified">1768     codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeIndex(bytecodeIndex);</span>
1769     auto bytecode = codeBlock-&gt;instructions().at(bytecodeIndex)-&gt;as&lt;OpCatch&gt;();
1770     auto&amp; metadata = bytecode.metadata(codeBlock);
<span class="line-modified">1771     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
<span class="line-modified">1772         profile.m_buckets[0] = JSValue::encode(callFrame-&gt;uncheckedR(profile.m_operand).jsValue());</span>
1773     });
1774 
1775     return nullptr;
1776 }
1777 
1778 #endif
1779 
<span class="line-modified">1780 void JIT_OPERATION operationPutByIndex(JSGlobalObject* globalObject, EncodedJSValue encodedArrayValue, int32_t index, EncodedJSValue encodedValue)</span>
1781 {
<span class="line-modified">1782     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1783     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1784     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1785 
1786     JSValue arrayValue = JSValue::decode(encodedArrayValue);
1787     ASSERT(isJSArray(arrayValue));
<span class="line-modified">1788     asArray(arrayValue)-&gt;putDirectIndex(globalObject, index, JSValue::decode(encodedValue));</span>
1789 }
1790 
1791 enum class AccessorType {
1792     Getter,
1793     Setter
1794 };
1795 
<span class="line-modified">1796 static void putAccessorByVal(JSGlobalObject* globalObject, JSObject* base, JSValue subscript, int32_t attribute, JSObject* accessor, AccessorType accessorType)</span>
1797 {
<span class="line-modified">1798     VM&amp; vm = globalObject-&gt;vm();</span>
1799     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1800     auto propertyKey = subscript.toPropertyKey(globalObject);</span>
1801     RETURN_IF_EXCEPTION(scope, void());
1802 
1803     scope.release();
1804     if (accessorType == AccessorType::Getter)
<span class="line-modified">1805         base-&gt;putGetter(globalObject, propertyKey, accessor, attribute);</span>
1806     else
<span class="line-modified">1807         base-&gt;putSetter(globalObject, propertyKey, accessor, attribute);</span>
1808 }
1809 
<span class="line-modified">1810 void JIT_OPERATION operationPutGetterById(JSGlobalObject* globalObject, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* getter)</span>
1811 {
<span class="line-modified">1812     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1813     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1814     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1815 
1816     ASSERT(object &amp;&amp; object-&gt;isObject());
1817     JSObject* baseObj = object-&gt;getObject();
1818 
1819     ASSERT(getter-&gt;isObject());
<span class="line-modified">1820     baseObj-&gt;putGetter(globalObject, uid, getter, options);</span>
1821 }
1822 
<span class="line-modified">1823 void JIT_OPERATION operationPutSetterById(JSGlobalObject* globalObject, JSCell* object, UniquedStringImpl* uid, int32_t options, JSCell* setter)</span>
1824 {
<span class="line-modified">1825     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1826     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1827     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1828 
1829     ASSERT(object &amp;&amp; object-&gt;isObject());
1830     JSObject* baseObj = object-&gt;getObject();
1831 
1832     ASSERT(setter-&gt;isObject());
<span class="line-modified">1833     baseObj-&gt;putSetter(globalObject, uid, setter, options);</span>
1834 }
1835 
<span class="line-modified">1836 void JIT_OPERATION operationPutGetterByVal(JSGlobalObject* globalObject, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* getter)</span>
1837 {
<span class="line-modified">1838     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1839     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1840     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1841 
<span class="line-modified">1842     putAccessorByVal(globalObject, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(getter), AccessorType::Getter);</span>
1843 }
1844 
<span class="line-modified">1845 void JIT_OPERATION operationPutSetterByVal(JSGlobalObject* globalObject, JSCell* base, EncodedJSValue encodedSubscript, int32_t attribute, JSCell* setter)</span>
1846 {
<span class="line-modified">1847     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1848     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1849     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1850 
<span class="line-modified">1851     putAccessorByVal(globalObject, asObject(base), JSValue::decode(encodedSubscript), attribute, asObject(setter), AccessorType::Setter);</span>
1852 }
1853 
1854 #if USE(JSVALUE64)
<span class="line-modified">1855 void JIT_OPERATION operationPutGetterSetter(JSGlobalObject* globalObject, JSCell* object, UniquedStringImpl* uid, int32_t attribute, EncodedJSValue encodedGetterValue, EncodedJSValue encodedSetterValue)</span>
1856 {
<span class="line-modified">1857     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1858     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1859     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1860 
1861     ASSERT(object &amp;&amp; object-&gt;isObject());
1862     JSObject* baseObject = asObject(object);
1863 
1864     JSValue getter = JSValue::decode(encodedGetterValue);
1865     JSValue setter = JSValue::decode(encodedSetterValue);
1866     ASSERT(getter.isObject() || setter.isObject());
<span class="line-modified">1867     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
<span class="line-modified">1868     CommonSlowPaths::putDirectAccessorWithReify(vm, globalObject, baseObject, uid, accessor, attribute);</span>
1869 }
1870 
1871 #else
<span class="line-modified">1872 void JIT_OPERATION operationPutGetterSetter(JSGlobalObject* globalObject, JSCell* object, UniquedStringImpl* uid, int32_t attribute, JSCell* getterCell, JSCell* setterCell)</span>
1873 {
<span class="line-modified">1874     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1875     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1876     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1877 
1878     ASSERT(object &amp;&amp; object-&gt;isObject());
1879     JSObject* baseObject = asObject(object);
1880 
1881     ASSERT(getterCell || setterCell);
1882     JSObject* getter = getterCell ? getterCell-&gt;getObject() : nullptr;
1883     JSObject* setter = setterCell ? setterCell-&gt;getObject() : nullptr;
<span class="line-modified">1884     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
<span class="line-modified">1885     CommonSlowPaths::putDirectAccessorWithReify(vm, globalObject, baseObject, uid, accessor, attribute);</span>
1886 }
1887 #endif
1888 
<span class="line-modified">1889 void JIT_OPERATION operationPopScope(JSGlobalObject* globalObject, int32_t scopeReg)</span>
1890 {
<span class="line-modified">1891     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1892     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1893     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1894 
<span class="line-modified">1895     auto&amp; scopeSlot = callFrame-&gt;uncheckedR(VirtualRegister(scopeReg));</span>
<span class="line-modified">1896     scopeSlot = scopeSlot.Register::scope()-&gt;next();</span>
1897 }
1898 
<span class="line-modified">1899 int32_t JIT_OPERATION operationInstanceOfCustom(JSGlobalObject* globalObject, EncodedJSValue encodedValue, JSObject* constructor, EncodedJSValue encodedHasInstance)</span>
1900 {
<span class="line-modified">1901     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1902     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1903     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1904 
1905     JSValue value = JSValue::decode(encodedValue);
1906     JSValue hasInstanceValue = JSValue::decode(encodedHasInstance);
1907 
<span class="line-modified">1908     if (constructor-&gt;hasInstance(globalObject, value, hasInstanceValue))</span>
1909         return 1;
1910     return 0;
1911 }
1912 
1913 }
1914 
<span class="line-modified">1915 ALWAYS_INLINE static JSValue getByVal(JSGlobalObject* globalObject, CallFrame* callFrame, ArrayProfile* arrayProfile, JSValue baseValue, JSValue subscript)</span>
1916 {
<span class="line-modified">1917     UNUSED_PARAM(callFrame);</span>
<span class="line-added">1918     VM&amp; vm = globalObject-&gt;vm();</span>
1919     auto scope = DECLARE_THROW_SCOPE(vm);
1920 
1921     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1922         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1923         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1924             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
1925             RETURN_IF_EXCEPTION(scope, JSValue());
1926             if (existingAtomString) {
1927                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get())) {
<span class="line-modified">1928                     ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>


1929                     return result;
1930                 }
1931             }
1932         }
1933     }
1934 
1935     if (subscript.isInt32()) {



1936         int32_t i = subscript.asInt32();
1937         if (isJSString(baseValue)) {
<span class="line-modified">1938             if (i &gt;= 0 &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))</span>
<span class="line-modified">1939                 RELEASE_AND_RETURN(scope, asString(baseValue)-&gt;getIndex(globalObject, i));</span>
<span class="line-modified">1940             if (arrayProfile)</span>
<span class="line-modified">1941                 arrayProfile-&gt;setOutOfBounds();</span>

1942         } else if (baseValue.isObject()) {
1943             JSObject* object = asObject(baseValue);
1944             if (object-&gt;canGetIndexQuickly(i))
1945                 return object-&gt;getIndexQuickly(i);
1946 
1947             bool skipMarkingOutOfBounds = false;
1948 
1949             if (object-&gt;indexingType() == ArrayWithContiguous &amp;&amp; i &gt;= 0 &amp;&amp; static_cast&lt;uint32_t&gt;(i) &lt; object-&gt;butterfly()-&gt;publicLength()) {
1950                 // FIXME: expand this to ArrayStorage, Int32, and maybe Double:
1951                 // https://bugs.webkit.org/show_bug.cgi?id=182940
1952                 auto* globalObject = object-&gt;globalObject(vm);
1953                 skipMarkingOutOfBounds = globalObject-&gt;isOriginalArrayStructure(object-&gt;structure(vm)) &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane();
1954             }
1955 
1956             if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i)) {
1957                 // FIXME: This will make us think that in-bounds typed array accesses are actually
1958                 // out-of-bounds.
1959                 // https://bugs.webkit.org/show_bug.cgi?id=149886
<span class="line-modified">1960                 if (arrayProfile)</span>
<span class="line-added">1961                     arrayProfile-&gt;setOutOfBounds();</span>
1962             }
1963         }
1964 
1965         if (i &gt;= 0)
<span class="line-modified">1966             RELEASE_AND_RETURN(scope, baseValue.get(globalObject, static_cast&lt;uint32_t&gt;(i)));</span>
1967     }
1968 
<span class="line-modified">1969     baseValue.requireObjectCoercible(globalObject);</span>
1970     RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">1971     auto property = subscript.toPropertyKey(globalObject);</span>
1972     RETURN_IF_EXCEPTION(scope, JSValue());
1973 
<span class="line-modified">1974     ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>
<span class="line-modified">1975     RELEASE_AND_RETURN(scope, baseValue.get(globalObject, property));</span>



1976 }
1977 
<span class="line-modified">1978 extern &quot;C&quot; {</span>
<span class="line-added">1979 </span>
<span class="line-added">1980 EncodedJSValue JIT_OPERATION operationGetByValGeneric(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, ArrayProfile* profile, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript)</span>
1981 {
<span class="line-modified">1982     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1983     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1984     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">1985     JSValue baseValue = JSValue::decode(encodedBase);</span>
<span class="line-added">1986     JSValue subscript = JSValue::decode(encodedSubscript);</span>
<span class="line-added">1987 </span>
<span class="line-added">1988     stubInfo-&gt;tookSlowPath = true;</span>
<span class="line-added">1989 </span>
<span class="line-added">1990     return JSValue::encode(getByVal(globalObject, callFrame, profile, baseValue, subscript));</span>
<span class="line-added">1991 }</span>
1992 
<span class="line-modified">1993 EncodedJSValue JIT_OPERATION operationGetByValOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, ArrayProfile* profile, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript)</span>
<span class="line-added">1994 {</span>
<span class="line-added">1995     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1996     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">1997     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
1998     auto scope = DECLARE_THROW_SCOPE(vm);
1999 
<span class="line-modified">2000     JSValue baseValue = JSValue::decode(encodedBase);</span>
<span class="line-modified">2001     JSValue subscript = JSValue::decode(encodedSubscript);</span>
2002 
<span class="line-modified">2003     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>

2004 
<span class="line-modified">2005     if (baseValue.isCell() &amp;&amp; subscript.isInt32()) {</span>
<span class="line-modified">2006         Structure* structure = baseValue.asCell()-&gt;structure(vm);</span>
<span class="line-modified">2007         if (stubInfo-&gt;considerCaching(vm, codeBlock, structure)) {</span>
<span class="line-modified">2008             if (profile) {</span>




2009                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified">2010                 profile-&gt;computeUpdatedPrediction(locker, codeBlock, structure);</span>



2011             }
<span class="line-added">2012             repatchArrayGetByVal(globalObject, codeBlock, baseValue, subscript, *stubInfo);</span>
2013         }




2014     }
2015 
<span class="line-modified">2016     if (baseValue.isCell() &amp;&amp; CacheableIdentifier::isCacheableIdentifierCell(subscript)) {</span>
<span class="line-modified">2017         const Identifier propertyName = subscript.toPropertyKey(globalObject);</span>
<span class="line-modified">2018         RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
2019         if (subscript.isSymbol() || !parseIndex(propertyName)) {
<span class="line-modified">2020             scope.release();</span>
<span class="line-modified">2021             return JSValue::encode(baseValue.getPropertySlot(globalObject, propertyName, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
<span class="line-modified">2022                 LOG_IC((ICEvent::OperationGetByValOptimize, baseValue.classInfoOrNull(vm), propertyName, baseValue == slot.slotBase()));</span>


















2023 
<span class="line-modified">2024                 if (stubInfo-&gt;considerCaching(vm, codeBlock, baseValue.structureOrNull(), propertyName.impl()))</span>
<span class="line-modified">2025                     repatchGetBy(globalObject, codeBlock, baseValue, subscript.asCell(), slot, *stubInfo, GetByKind::NormalByVal);</span>
<span class="line-modified">2026                 return found ? slot.getValue(globalObject, propertyName) : jsUndefined();</span>
<span class="line-modified">2027             }));</span>
<span class="line-modified">2028         }</span>



2029     }
2030 
<span class="line-modified">2031     RELEASE_AND_RETURN(scope, JSValue::encode(getByVal(globalObject, callFrame, profile, baseValue, subscript)));</span>













2032 }
2033 
<span class="line-modified">2034 EncodedJSValue JIT_OPERATION operationGetByVal(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedProperty)</span>
2035 {
<span class="line-modified">2036     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2037     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2038     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2039     auto scope = DECLARE_THROW_SCOPE(vm);
2040 
2041     JSValue baseValue = JSValue::decode(encodedBase);
<span class="line-modified">2042     JSValue property = JSValue::decode(encodedProperty);</span>
<span class="line-modified">2043 </span>
<span class="line-modified">2044     if (LIKELY(baseValue.isCell())) {</span>
<span class="line-modified">2045         JSCell* base = baseValue.asCell();</span>
<span class="line-modified">2046 </span>
<span class="line-modified">2047         if (property.isUInt32())</span>
<span class="line-modified">2048             RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, property.asUInt32()));</span>
<span class="line-modified">2049 </span>
<span class="line-added">2050         if (property.isDouble()) {</span>
<span class="line-added">2051             double propertyAsDouble = property.asDouble();</span>
<span class="line-added">2052             uint32_t propertyAsUInt32 = static_cast&lt;uint32_t&gt;(propertyAsDouble);</span>
<span class="line-added">2053             if (propertyAsUInt32 == propertyAsDouble &amp;&amp; isIndex(propertyAsUInt32))</span>
<span class="line-added">2054                 RELEASE_AND_RETURN(scope, getByValWithIndex(globalObject, base, propertyAsUInt32));</span>
<span class="line-added">2055         } else if (property.isString()) {</span>
<span class="line-added">2056             Structure&amp; structure = *base-&gt;structure(vm);</span>
<span class="line-added">2057             if (JSCell::canUseFastGetOwnProperty(structure)) {</span>
<span class="line-added">2058                 RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(property)-&gt;toExistingAtomString(globalObject);</span>
<span class="line-added">2059                 RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">2060                 if (existingAtomString) {</span>
<span class="line-added">2061                     if (JSValue result = base-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))</span>
<span class="line-added">2062                         return JSValue::encode(result);</span>
<span class="line-added">2063                 }</span>
<span class="line-added">2064             }</span>
<span class="line-added">2065         }</span>
2066     }
2067 
<span class="line-modified">2068     baseValue.requireObjectCoercible(globalObject);</span>
<span class="line-added">2069     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">2070     auto propertyName = property.toPropertyKey(globalObject);</span>
<span class="line-added">2071     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">2072     RELEASE_AND_RETURN(scope, JSValue::encode(baseValue.get(globalObject, propertyName)));</span>
2073 }
2074 
<span class="line-modified">2075 </span>
<span class="line-added">2076 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyDefault(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>
2077 {
<span class="line-modified">2078     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2079     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2080     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2081     JSValue baseValue = JSValue::decode(encodedBase);
2082     JSValue subscript = JSValue::decode(encodedSubscript);
2083 
2084     ASSERT(baseValue.isObject());
2085     ASSERT(subscript.isUInt32AsAnyInt());
2086 
2087     JSObject* object = asObject(baseValue);
2088     bool didOptimize = false;
2089 
<span class="line-modified">2090     ASSERT(callFrame-&gt;bytecodeIndex() != BytecodeIndex(0));</span>
2091     ASSERT(!byValInfo-&gt;stubRoutine);
2092 
2093     if (hasOptimizableIndexing(object-&gt;structure(vm))) {
2094         // Attempt to optimize.
2095         JITArrayMode arrayMode = jitArrayModeForStructure(object-&gt;structure(vm));
2096         if (arrayMode != byValInfo-&gt;arrayMode) {
<span class="line-modified">2097             JIT::compileHasIndexedProperty(vm, callFrame-&gt;codeBlock(), byValInfo, ReturnAddressPtr(OUR_RETURN_ADDRESS), arrayMode);</span>
2098             didOptimize = true;
2099         }
2100     }
2101 
2102     if (!didOptimize) {
2103         // If we take slow path more than 10 times without patching then make sure we
2104         // never make that mistake again. Or, if we failed to patch and we have some object
2105         // that intercepts indexed get, then don&#39;t even wait until 10 times. For cases
2106         // where we see non-index-intercepting objects, this gives 10 iterations worth of
2107         // opportunity for us to observe that the get_by_val may be polymorphic.
2108         if (++byValInfo-&gt;slowPathCount &gt;= 10
2109             || object-&gt;structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero()) {
2110             // Don&#39;t ever try to optimize.
2111             ctiPatchCallByReturnAddress(ReturnAddressPtr(OUR_RETURN_ADDRESS), operationHasIndexedPropertyGeneric);
2112         }
2113     }
2114 
2115     uint32_t index = subscript.asUInt32AsAnyInt();
2116     if (object-&gt;canGetIndexQuickly(index))
2117         return JSValue::encode(JSValue(JSValue::JSTrue));
2118 
2119     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))
2120         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-modified">2121     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(globalObject, index, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
2122 }
2123 
<span class="line-modified">2124 EncodedJSValue JIT_OPERATION operationHasIndexedPropertyGeneric(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedSubscript, ByValInfo* byValInfo)</span>
2125 {
<span class="line-modified">2126     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2127     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2128     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2129     JSValue baseValue = JSValue::decode(encodedBase);
2130     JSValue subscript = JSValue::decode(encodedSubscript);
2131 
2132     ASSERT(baseValue.isObject());
2133     ASSERT(subscript.isUInt32AsAnyInt());
2134 
2135     JSObject* object = asObject(baseValue);
2136     uint32_t index = subscript.asUInt32AsAnyInt();
2137     if (object-&gt;canGetIndexQuickly(index))
2138         return JSValue::encode(JSValue(JSValue::JSTrue));
2139 
2140     if (!CommonSlowPaths::canAccessArgumentIndexQuickly(*object, index))
2141         byValInfo-&gt;arrayProfile-&gt;setOutOfBounds();
<span class="line-modified">2142     return JSValue::encode(jsBoolean(object-&gt;hasPropertyGeneric(globalObject, index, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
2143 }
2144 
<span class="line-modified">2145 static bool deleteById(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, JSValue base, UniquedStringImpl* uid)</span>
2146 {


2147     auto scope = DECLARE_THROW_SCOPE(vm);
































2148 
<span class="line-modified">2149     JSObject* baseObj = base.toObject(globalObject);</span>






2150     RETURN_IF_EXCEPTION(scope, false);
2151     if (!baseObj)
2152         return false;
<span class="line-modified">2153     bool couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, globalObject, Identifier::fromUid(vm, uid));</span>
2154     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2155     if (!couldDelete &amp;&amp; callFrame-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">2156         throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
2157     return couldDelete;
2158 }
2159 
<span class="line-modified">2160 </span>
<span class="line-added">2161 EncodedJSValue JIT_OPERATION operationDeleteByIdJSResult(JSGlobalObject* globalObject, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
<span class="line-added">2162 {</span>
<span class="line-added">2163     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2164     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2165     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2166     return JSValue::encode(jsBoolean(deleteById(globalObject, callFrame, vm, JSValue::decode(encodedBase), uid)));</span>
<span class="line-added">2167 }</span>
<span class="line-added">2168 </span>
<span class="line-added">2169 size_t JIT_OPERATION operationDeleteById(JSGlobalObject* globalObject, EncodedJSValue encodedBase, UniquedStringImpl* uid)</span>
2170 {
<span class="line-modified">2171     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2172     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2173     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2174     return deleteById(globalObject, callFrame, vm, JSValue::decode(encodedBase), uid);</span>
2175 }
2176 
<span class="line-modified">2177 static bool deleteByVal(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, JSValue base, JSValue key)</span>
2178 {


2179     auto scope = DECLARE_THROW_SCOPE(vm);
2180 
<span class="line-modified">2181     JSObject* baseObj = base.toObject(globalObject);</span>
2182     RETURN_IF_EXCEPTION(scope, false);

2183     if (!baseObj)
2184         return false;
2185 
2186     bool couldDelete;
2187     uint32_t index;
2188     if (key.getUInt32(index))
<span class="line-modified">2189         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObj, globalObject, index);</span>
2190     else {
<span class="line-modified">2191         Identifier property = key.toPropertyKey(globalObject);</span>
2192         RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2193         couldDelete = baseObj-&gt;methodTable(vm)-&gt;deleteProperty(baseObj, globalObject, property);</span>
2194     }
2195     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">2196     if (!couldDelete &amp;&amp; callFrame-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">2197         throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
2198     return couldDelete;
2199 }
2200 
<span class="line-modified">2201 EncodedJSValue JIT_OPERATION operationDeleteByValJSResult(JSGlobalObject* globalObject, EncodedJSValue encodedBase,  EncodedJSValue encodedKey)</span>
2202 {
<span class="line-modified">2203     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2204     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2205     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2206     return JSValue::encode(jsBoolean(deleteByVal(globalObject, callFrame, vm, JSValue::decode(encodedBase), JSValue::decode(encodedKey))));</span>
<span class="line-added">2207 }</span>
<span class="line-added">2208 </span>
<span class="line-added">2209 size_t JIT_OPERATION operationDeleteByVal(JSGlobalObject* globalObject, EncodedJSValue encodedBase, EncodedJSValue encodedKey)</span>
<span class="line-added">2210 {</span>
<span class="line-added">2211     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2212     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2213     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2214     return deleteByVal(globalObject, callFrame, vm, JSValue::decode(encodedBase), JSValue::decode(encodedKey));</span>
<span class="line-added">2215 }</span>
<span class="line-added">2216 </span>
<span class="line-added">2217 JSCell* JIT_OPERATION operationPushWithScope(JSGlobalObject* globalObject, JSCell* currentScopeCell, EncodedJSValue objectValue)</span>
<span class="line-added">2218 {</span>
<span class="line-added">2219     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2220     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2221     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2222     auto scope = DECLARE_THROW_SCOPE(vm);
2223 
<span class="line-modified">2224     JSObject* object = JSValue::decode(objectValue).toObject(globalObject);</span>
2225     RETURN_IF_EXCEPTION(scope, nullptr);
2226 
2227     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
2228 
<span class="line-modified">2229     return JSWithScope::create(vm, globalObject, currentScope, object);</span>
2230 }
2231 
<span class="line-modified">2232 JSCell* JIT_OPERATION operationPushWithScopeObject(JSGlobalObject* globalObject, JSCell* currentScopeCell, JSObject* object)</span>
2233 {
<span class="line-modified">2234     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2235     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2236     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2237     JSScope* currentScope = jsCast&lt;JSScope*&gt;(currentScopeCell);
<span class="line-modified">2238     return JSWithScope::create(vm, globalObject, currentScope, object);</span>
2239 }
2240 
<span class="line-modified">2241 EncodedJSValue JIT_OPERATION operationInstanceOf(JSGlobalObject* globalObject, EncodedJSValue encodedValue, EncodedJSValue encodedProto)</span>
2242 {
<span class="line-modified">2243     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2244     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2245     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2246     JSValue value = JSValue::decode(encodedValue);
2247     JSValue proto = JSValue::decode(encodedProto);
2248 
<span class="line-modified">2249     bool result = JSObject::defaultHasInstance(globalObject, value, proto);</span>
2250     return JSValue::encode(jsBoolean(result));
2251 }
2252 
<span class="line-modified">2253 EncodedJSValue JIT_OPERATION operationInstanceOfGeneric(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)</span>
2254 {
<span class="line-modified">2255     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2256     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2257     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2258     JSValue value = JSValue::decode(encodedValue);
2259     JSValue proto = JSValue::decode(encodedProto);
2260 
2261     stubInfo-&gt;tookSlowPath = true;
2262 
<span class="line-modified">2263     bool result = JSObject::defaultHasInstance(globalObject, value, proto);</span>
2264     return JSValue::encode(jsBoolean(result));
2265 }
2266 
<span class="line-modified">2267 EncodedJSValue JIT_OPERATION operationInstanceOfOptimize(JSGlobalObject* globalObject, StructureStubInfo* stubInfo, EncodedJSValue encodedValue, EncodedJSValue encodedProto)</span>
2268 {
<span class="line-modified">2269     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2270     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2271     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2272     auto scope = DECLARE_THROW_SCOPE(vm);
2273     JSValue value = JSValue::decode(encodedValue);
2274     JSValue proto = JSValue::decode(encodedProto);
2275 
<span class="line-modified">2276     bool result = JSObject::defaultHasInstance(globalObject, value, proto);</span>
2277     RETURN_IF_EXCEPTION(scope, JSValue::encode(jsUndefined()));
2278 
<span class="line-modified">2279     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified">2280     if (stubInfo-&gt;considerCaching(vm, codeBlock, value.structureOrNull()))</span>
<span class="line-added">2281         repatchInstanceOf(globalObject, codeBlock, value, proto, *stubInfo, result);</span>
2282 
2283     return JSValue::encode(jsBoolean(result));
2284 }
2285 
<span class="line-modified">2286 int32_t JIT_OPERATION operationSizeFrameForForwardArguments(JSGlobalObject* globalObject, EncodedJSValue, int32_t numUsedStackSlots, int32_t)</span>
2287 {
<span class="line-modified">2288     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2289     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2290     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2291     return sizeFrameForForwardArguments(globalObject, callFrame, vm, numUsedStackSlots);</span>
2292 }
2293 
<span class="line-modified">2294 int32_t JIT_OPERATION operationSizeFrameForVarargs(JSGlobalObject* globalObject, EncodedJSValue encodedArguments, int32_t numUsedStackSlots, int32_t firstVarArgOffset)</span>
2295 {
<span class="line-modified">2296     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2297     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2298     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2299     JSValue arguments = JSValue::decode(encodedArguments);
<span class="line-modified">2300     return sizeFrameForVarargs(globalObject, callFrame, vm, arguments, numUsedStackSlots, firstVarArgOffset);</span>
2301 }
2302 
<span class="line-modified">2303 CallFrame* JIT_OPERATION operationSetupForwardArgumentsFrame(JSGlobalObject* globalObject, CallFrame* newCallFrame, EncodedJSValue, int32_t, int32_t length)</span>
2304 {
<span class="line-modified">2305     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2306     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2307     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2308     setupForwardArgumentsFrame(globalObject, callFrame, newCallFrame, length);</span>
2309     return newCallFrame;
2310 }
2311 
<span class="line-modified">2312 CallFrame* JIT_OPERATION operationSetupVarargsFrame(JSGlobalObject* globalObject, CallFrame* newCallFrame, EncodedJSValue encodedArguments, int32_t firstVarArgOffset, int32_t length)</span>
2313 {
<span class="line-modified">2314     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2315     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2316     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2317     JSValue arguments = JSValue::decode(encodedArguments);
<span class="line-modified">2318     setupVarargsFrame(globalObject, callFrame, newCallFrame, arguments, firstVarArgOffset, length);</span>
2319     return newCallFrame;
2320 }
2321 
<span class="line-modified">2322 char* JIT_OPERATION operationSwitchCharWithUnknownKeyType(JSGlobalObject* globalObject, EncodedJSValue encodedKey, size_t tableIndex)</span>
2323 {
<span class="line-modified">2324     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2325     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2326     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2327     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">2328 </span>
2329     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2330     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
2331 
2332     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2333     void* result = jumpTable.ctiDefault.executableAddress();
2334 
2335     if (key.isString()) {
<span class="line-modified">2336         JSString* string = asString(key);</span>
<span class="line-modified">2337         if (string-&gt;length() == 1) {</span>
<span class="line-modified">2338             String value = string-&gt;value(globalObject);</span>
<span class="line-added">2339             RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
<span class="line-added">2340             result = jumpTable.ctiForValue(value[0]).executableAddress();</span>
<span class="line-added">2341         }</span>
2342     }
2343 
2344     assertIsTaggedWith(result, JSSwitchPtrTag);
2345     return reinterpret_cast&lt;char*&gt;(result);
2346 }
2347 
<span class="line-modified">2348 char* JIT_OPERATION operationSwitchImmWithUnknownKeyType(VM* vmPointer, EncodedJSValue encodedKey, size_t tableIndex)</span>
2349 {
<span class="line-modified">2350     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2351     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2352     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2353     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2354     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
2355 
2356     SimpleJumpTable&amp; jumpTable = codeBlock-&gt;switchJumpTable(tableIndex);
2357     void* result;
2358     if (key.isInt32())
2359         result = jumpTable.ctiForValue(key.asInt32()).executableAddress();
2360     else if (key.isDouble() &amp;&amp; key.asDouble() == static_cast&lt;int32_t&gt;(key.asDouble()))
2361         result = jumpTable.ctiForValue(static_cast&lt;int32_t&gt;(key.asDouble())).executableAddress();
2362     else
2363         result = jumpTable.ctiDefault.executableAddress();
2364     assertIsTaggedWith(result, JSSwitchPtrTag);
2365     return reinterpret_cast&lt;char*&gt;(result);
2366 }
2367 
<span class="line-modified">2368 char* JIT_OPERATION operationSwitchStringWithUnknownKeyType(JSGlobalObject* globalObject, EncodedJSValue encodedKey, size_t tableIndex)</span>
2369 {
<span class="line-modified">2370     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2371     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2372     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2373     JSValue key = JSValue::decode(encodedKey);
<span class="line-modified">2374     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
2375     auto throwScope = DECLARE_THROW_SCOPE(vm);
2376 
2377     void* result;
2378     StringJumpTable&amp; jumpTable = codeBlock-&gt;stringSwitchJumpTable(tableIndex);
2379 
2380     if (key.isString()) {
<span class="line-modified">2381         StringImpl* value = asString(key)-&gt;value(globalObject).impl();</span>
2382 
2383         RETURN_IF_EXCEPTION(throwScope, nullptr);
2384 
2385         result = jumpTable.ctiForValue(value).executableAddress();
2386     } else
2387         result = jumpTable.ctiDefault.executableAddress();
2388 
2389     assertIsTaggedWith(result, JSSwitchPtrTag);
2390     return reinterpret_cast&lt;char*&gt;(result);
2391 }
2392 
<span class="line-modified">2393 EncodedJSValue JIT_OPERATION operationGetFromScope(JSGlobalObject* globalObject, const Instruction* pc)</span>
2394 {
<span class="line-modified">2395     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2396     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2397     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2398     auto throwScope = DECLARE_THROW_SCOPE(vm);
2399 
<span class="line-modified">2400     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
2401 
2402     auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
2403     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">2404     JSObject* scope = jsCast&lt;JSObject*&gt;(callFrame-&gt;uncheckedR(bytecode.m_scope).jsValue());</span>
2405     GetPutInfo&amp; getPutInfo = bytecode.metadata(codeBlock).m_getPutInfo;
2406 
2407     // ModuleVar is always converted to ClosureVar for get_from_scope.
2408     ASSERT(getPutInfo.resolveType() != ModuleVar);
2409 
<span class="line-modified">2410     RELEASE_AND_RETURN(throwScope, JSValue::encode(scope-&gt;getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
2411         if (!found) {
2412             if (getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">2413                 throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
2414             return jsUndefined();
2415         }
2416 
2417         JSValue result = JSValue();
2418         if (scope-&gt;isGlobalLexicalEnvironment()) {
2419             // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">2420             result = slot.getValue(globalObject, ident);</span>
2421             if (result == jsTDZValue()) {
<span class="line-modified">2422                 throwException(globalObject, throwScope, createTDZError(globalObject));</span>
2423                 return jsUndefined();
2424             }
2425         }
2426 
<span class="line-modified">2427         CommonSlowPaths::tryCacheGetFromScopeGlobal(globalObject, codeBlock, vm, bytecode, scope, slot, ident);</span>
2428 
2429         if (!result)
<span class="line-modified">2430             return slot.getValue(globalObject, ident);</span>
2431         return result;
2432     })));
2433 }
2434 
<span class="line-modified">2435 void JIT_OPERATION operationPutToScope(JSGlobalObject* globalObject, const Instruction* pc)</span>
2436 {
<span class="line-modified">2437     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2438     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2439     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2440     auto throwScope = DECLARE_THROW_SCOPE(vm);
2441 
<span class="line-modified">2442     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
2443     auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
2444     auto&amp; metadata = bytecode.metadata(codeBlock);
2445 
2446     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">2447     JSObject* scope = jsCast&lt;JSObject*&gt;(callFrame-&gt;uncheckedR(bytecode.m_scope).jsValue());</span>
<span class="line-modified">2448     JSValue value = callFrame-&gt;r(bytecode.m_value).jsValue();</span>
2449     GetPutInfo&amp; getPutInfo = metadata.m_getPutInfo;
2450 
2451     // ModuleVar does not keep the scope register value alive in DFG.
2452     ASSERT(getPutInfo.resolveType() != ModuleVar);
2453 
2454     if (getPutInfo.resolveType() == LocalClosureVar) {
2455         JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
2456         environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
2457         if (WatchpointSet* set = metadata.m_watchpointSet)
2458             set-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
2459         return;
2460     }
2461 
<span class="line-modified">2462     bool hasProperty = scope-&gt;hasProperty(globalObject, ident);</span>
2463     RETURN_IF_EXCEPTION(throwScope, void());
2464     if (hasProperty
2465         &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
2466         &amp;&amp; !isInitialization(getPutInfo.initializationMode())) {
2467         // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
2468         PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">2469         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, globalObject, ident, slot);</span>
<span class="line-modified">2470         if (slot.getValue(globalObject, ident) == jsTDZValue()) {</span>
<span class="line-modified">2471             throwException(globalObject, throwScope, createTDZError(globalObject));</span>
2472             return;
2473         }
2474     }
2475 
2476     if (getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty) {
<span class="line-modified">2477         throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
2478         return;
2479     }
2480 
2481     PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(getPutInfo.initializationMode()));
<span class="line-modified">2482     scope-&gt;methodTable(vm)-&gt;put(scope, globalObject, ident, value, slot);</span>
2483 
2484     RETURN_IF_EXCEPTION(throwScope, void());
2485 
<span class="line-modified">2486     CommonSlowPaths::tryCachePutToScopeGlobal(globalObject, codeBlock, bytecode, scope, slot, ident);</span>
2487 }
2488 
<span class="line-modified">2489 void JIT_OPERATION operationThrow(JSGlobalObject* globalObject, EncodedJSValue encodedExceptionValue)</span>
2490 {
<span class="line-modified">2491     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2492     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2493     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2494     auto scope = DECLARE_THROW_SCOPE(vm);
2495 
2496     JSValue exceptionValue = JSValue::decode(encodedExceptionValue);
<span class="line-modified">2497     throwException(globalObject, scope, exceptionValue);</span>
2498 
2499     // Results stored out-of-band in vm.targetMachinePCForThrow &amp; vm.callFrameForCatch
<span class="line-modified">2500     genericUnwind(vm, callFrame);</span>
2501 }
2502 
<span class="line-modified">2503 char* JIT_OPERATION operationReallocateButterflyToHavePropertyStorageWithInitialCapacity(VM* vmPointer, JSObject* object)</span>
2504 {
<span class="line-modified">2505     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2506     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2507     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2508 
2509     ASSERT(!object-&gt;structure(vm)-&gt;outOfLineCapacity());
2510     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, 0, initialOutOfLineCapacity);
2511     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2512     return reinterpret_cast&lt;char*&gt;(result);
2513 }
2514 
<span class="line-modified">2515 char* JIT_OPERATION operationReallocateButterflyToGrowPropertyStorage(VM* vmPointer, JSObject* object, size_t newSize)</span>
2516 {
<span class="line-modified">2517     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2518     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2519     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2520 
2521     Butterfly* result = object-&gt;allocateMoreOutOfLineStorage(vm, object-&gt;structure(vm)-&gt;outOfLineCapacity(), newSize);
2522     object-&gt;nukeStructureAndSetButterfly(vm, object-&gt;structureID(), result);
2523     return reinterpret_cast&lt;char*&gt;(result);
2524 }
2525 
<span class="line-modified">2526 void JIT_OPERATION operationOSRWriteBarrier(VM* vmPointer, JSCell* cell)</span>
2527 {
<span class="line-modified">2528     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2529     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2530     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2531     vm.heap.writeBarrier(cell);
2532 }
2533 
<span class="line-modified">2534 void JIT_OPERATION operationWriteBarrierSlowPath(VM* vmPointer, JSCell* cell)</span>
2535 {
<span class="line-modified">2536     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2537     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2538     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2539     vm.heap.writeBarrierSlowPath(cell);
2540 }
2541 
<span class="line-modified">2542 void JIT_OPERATION operationLookupExceptionHandler(VM* vmPointer)</span>
2543 {
2544     VM&amp; vm = *vmPointer;
<span class="line-modified">2545     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2546     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2547     genericUnwind(vm, callFrame);</span>
2548     ASSERT(vm.targetMachinePCForThrow);
2549 }
2550 
<span class="line-modified">2551 void JIT_OPERATION operationLookupExceptionHandlerFromCallerFrame(VM* vmPointer)</span>
2552 {
<span class="line-modified">2553     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2554     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2555     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2556     ASSERT(callFrame-&gt;isStackOverflowFrame());</span>
<span class="line-added">2557     ASSERT(jsCast&lt;ErrorInstance*&gt;(vm.exceptionForInspection()-&gt;value().asCell())-&gt;isStackOverflowError());</span>
<span class="line-added">2558     genericUnwind(vm, callFrame);</span>
<span class="line-added">2559     ASSERT(vm.targetMachinePCForThrow);</span>
2560 }
2561 
<span class="line-modified">2562 void JIT_OPERATION operationVMHandleException(VM* vmPointer)</span>
2563 {
<span class="line-modified">2564     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2565     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2566     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2567     genericUnwind(vm, callFrame);</span>
2568 }
2569 
<span class="line-modified">2570 // This function &quot;should&quot; just take the JSGlobalObject*, but doing so would make it more difficult</span>
2571 // to call from exception check sites. So, unlike all of our other functions, we allow
2572 // ourselves to play some gnarly ABI tricks just to simplify the calling convention. This is
2573 // particularly safe here since this is never called on the critical path - it&#39;s only for
2574 // testing.
<span class="line-modified">2575 void JIT_OPERATION operationExceptionFuzz(JSGlobalObject* globalObject)</span>
2576 {
<span class="line-modified">2577     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2578     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2579     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2580     auto scope = DECLARE_THROW_SCOPE(vm);
2581     UNUSED_PARAM(scope);
2582 #if COMPILER(GCC_COMPATIBLE)
2583     void* returnPC = __builtin_return_address(0);
<span class="line-modified">2584     doExceptionFuzzing(globalObject, scope, &quot;JITOperations&quot;, returnPC);</span>
2585 #endif // COMPILER(GCC_COMPATIBLE)
2586 }
2587 
<span class="line-modified">2588 EncodedJSValue JIT_OPERATION operationValueAdd(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2589 {
<span class="line-modified">2590     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2591     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2592     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-modified">2593     return JSValue::encode(jsAdd(globalObject, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2)));</span>



2594 }
2595 
<span class="line-modified">2596 EncodedJSValue JIT_OPERATION operationValueAddProfiled(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BinaryArithProfile* arithProfile)</span>




















2597 {
2598     ASSERT(arithProfile);
<span class="line-modified">2599     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">2600     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2601     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2602     return JSValue::encode(profiledAdd(globalObject, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2), *arithProfile));</span>
2603 }
2604 
<span class="line-modified">2605 EncodedJSValue JIT_OPERATION operationValueAddProfiledOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)</span>
2606 {
<span class="line-modified">2607     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2608     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2609     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2610 
2611     JSValue op1 = JSValue::decode(encodedOp1);
2612     JSValue op2 = JSValue::decode(encodedOp2);
2613 
<span class="line-modified">2614     BinaryArithProfile* arithProfile = addIC-&gt;arithProfile();</span>
2615     ASSERT(arithProfile);
2616     arithProfile-&gt;observeLHSAndRHS(op1, op2);
2617     auto nonOptimizeVariant = operationValueAddProfiledNoOptimize;
<span class="line-modified">2618     addIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), nonOptimizeVariant);</span>
2619 
2620 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2621     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2622 #endif
2623 
<span class="line-modified">2624     JSValue result = jsAdd(globalObject, op1, op2);</span>
2625     arithProfile-&gt;observeResult(result);
2626 
2627     return JSValue::encode(result);
2628 }
2629 
<span class="line-modified">2630 EncodedJSValue JIT_OPERATION operationValueAddProfiledNoOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)</span>
2631 {
<span class="line-modified">2632     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2633     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2634     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2635 
<span class="line-modified">2636     BinaryArithProfile* arithProfile = addIC-&gt;arithProfile();</span>
2637     ASSERT(arithProfile);
<span class="line-modified">2638     return JSValue::encode(profiledAdd(globalObject, JSValue::decode(encodedOp1), JSValue::decode(encodedOp2), *arithProfile));</span>
2639 }
2640 
<span class="line-modified">2641 EncodedJSValue JIT_OPERATION operationValueAddOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC* addIC)</span>
2642 {
<span class="line-modified">2643     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2644     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2645     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2646 
2647     JSValue op1 = JSValue::decode(encodedOp1);
2648     JSValue op2 = JSValue::decode(encodedOp2);
2649 
2650     auto nonOptimizeVariant = operationValueAddNoOptimize;
<span class="line-modified">2651     if (BinaryArithProfile* arithProfile = addIC-&gt;arithProfile())</span>
2652         arithProfile-&gt;observeLHSAndRHS(op1, op2);
<span class="line-modified">2653     addIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), nonOptimizeVariant);</span>
2654 
2655 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2656     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2657 #endif
2658 
<span class="line-modified">2659     return JSValue::encode(jsAdd(globalObject, op1, op2));</span>
2660 }
2661 
<span class="line-modified">2662 EncodedJSValue JIT_OPERATION operationValueAddNoOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITAddIC*)</span>
2663 {
<span class="line-modified">2664     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2665     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2666     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2667 
2668     JSValue op1 = JSValue::decode(encodedOp1);
2669     JSValue op2 = JSValue::decode(encodedOp2);
2670 
<span class="line-modified">2671     JSValue result = jsAdd(globalObject, op1, op2);</span>
2672 
2673     return JSValue::encode(result);
2674 }
2675 
<span class="line-modified">2676 ALWAYS_INLINE static EncodedJSValue unprofiledMul(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2677 {
2678     JSValue op1 = JSValue::decode(encodedOp1);
2679     JSValue op2 = JSValue::decode(encodedOp2);
2680 
<span class="line-modified">2681     return JSValue::encode(jsMul(globalObject, op1, op2));</span>
2682 }
2683 
<span class="line-modified">2684 ALWAYS_INLINE static EncodedJSValue profiledMul(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BinaryArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)</span>
2685 {
<span class="line-modified">2686     VM&amp; vm = globalObject-&gt;vm();</span>
2687     auto scope = DECLARE_THROW_SCOPE(vm);
2688     JSValue op1 = JSValue::decode(encodedOp1);
2689     JSValue op2 = JSValue::decode(encodedOp2);
2690 
2691     if (shouldObserveLHSAndRHSTypes)
2692         arithProfile.observeLHSAndRHS(op1, op2);
2693 
<span class="line-modified">2694     JSValue result = jsMul(globalObject, op1, op2);</span>
2695     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2696     arithProfile.observeResult(result);
2697     return JSValue::encode(result);
2698 }
2699 
<span class="line-modified">2700 EncodedJSValue JIT_OPERATION operationValueMul(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2701 {
<span class="line-modified">2702     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2703     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2704     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2705 
<span class="line-modified">2706     return unprofiledMul(globalObject, encodedOp1, encodedOp2);</span>
2707 }
2708 
<span class="line-modified">2709 EncodedJSValue JIT_OPERATION operationValueMulNoOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC*)</span>
2710 {
<span class="line-modified">2711     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2712     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2713     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2714 
<span class="line-modified">2715     return unprofiledMul(globalObject, encodedOp1, encodedOp2);</span>
2716 }
2717 
<span class="line-modified">2718 EncodedJSValue JIT_OPERATION operationValueMulOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)</span>
2719 {
<span class="line-modified">2720     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2721     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2722     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2723 
2724     auto nonOptimizeVariant = operationValueMulNoOptimize;
<span class="line-modified">2725     if (BinaryArithProfile* arithProfile = mulIC-&gt;arithProfile())</span>
2726         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
<span class="line-modified">2727     mulIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), nonOptimizeVariant);</span>
2728 
2729 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2730     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2731 #endif
2732 
<span class="line-modified">2733     return unprofiledMul(globalObject, encodedOp1, encodedOp2);</span>
2734 }
2735 
<span class="line-modified">2736 EncodedJSValue JIT_OPERATION operationValueMulProfiled(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BinaryArithProfile* arithProfile)</span>
2737 {
<span class="line-modified">2738     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2739     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2740     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2741 
2742     ASSERT(arithProfile);
<span class="line-modified">2743     return profiledMul(globalObject, encodedOp1, encodedOp2, *arithProfile);</span>
2744 }
2745 
<span class="line-modified">2746 EncodedJSValue JIT_OPERATION operationValueMulProfiledOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)</span>
2747 {
<span class="line-modified">2748     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2749     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2750     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2751 
<span class="line-modified">2752     BinaryArithProfile* arithProfile = mulIC-&gt;arithProfile();</span>
2753     ASSERT(arithProfile);
2754     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2755     auto nonOptimizeVariant = operationValueMulProfiledNoOptimize;
<span class="line-modified">2756     mulIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), nonOptimizeVariant);</span>
2757 
2758 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2759     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2760 #endif
2761 
<span class="line-modified">2762     return profiledMul(globalObject, encodedOp1, encodedOp2, *arithProfile, false);</span>
2763 }
2764 
<span class="line-modified">2765 EncodedJSValue JIT_OPERATION operationValueMulProfiledNoOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITMulIC* mulIC)</span>
2766 {
<span class="line-modified">2767     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2768     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2769     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2770 
<span class="line-modified">2771     BinaryArithProfile* arithProfile = mulIC-&gt;arithProfile();</span>
2772     ASSERT(arithProfile);
<span class="line-modified">2773     return profiledMul(globalObject, encodedOp1, encodedOp2, *arithProfile);</span>
2774 }
2775 
<span class="line-modified">2776 EncodedJSValue JIT_OPERATION operationArithNegate(JSGlobalObject* globalObject, EncodedJSValue encodedOperand)</span>
2777 {
<span class="line-modified">2778     VM&amp; vm = globalObject-&gt;vm();</span>
2779     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2780     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2781     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2782 
2783     JSValue operand = JSValue::decode(encodedOperand);
2784 
<span class="line-modified">2785     JSValue primValue = operand.toPrimitive(globalObject, PreferNumber);</span>
2786     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2787 
2788     if (primValue.isBigInt())
2789         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2790 
<span class="line-modified">2791     double number = primValue.toNumber(globalObject);</span>
2792     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2793     return JSValue::encode(jsNumber(-number));
<span class="line-added">2794 </span>
2795 }
2796 
<span class="line-modified">2797 EncodedJSValue JIT_OPERATION operationArithNegateProfiled(JSGlobalObject* globalObject, EncodedJSValue encodedOperand, UnaryArithProfile* arithProfile)</span>
2798 {
<span class="line-modified">2799     ASSERT(arithProfile);</span>
<span class="line-added">2800     VM&amp; vm = globalObject-&gt;vm();</span>
2801     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2802     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2803     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2804 
2805     JSValue operand = JSValue::decode(encodedOperand);
<span class="line-modified">2806     arithProfile-&gt;observeArg(operand);</span>
2807 
<span class="line-modified">2808     JSValue primValue = operand.toPrimitive(globalObject);</span>
2809     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2810 
2811     if (primValue.isBigInt()) {
2812         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
<span class="line-modified">2813         arithProfile-&gt;observeResult(result);</span>
2814 
2815         return JSValue::encode(result);
2816     }
2817 
<span class="line-modified">2818     double number = primValue.toNumber(globalObject);</span>
2819     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2820     JSValue result = jsNumber(-number);
<span class="line-modified">2821     arithProfile-&gt;observeResult(result);</span>
2822     return JSValue::encode(result);
2823 }
2824 
<span class="line-modified">2825 EncodedJSValue JIT_OPERATION operationArithNegateProfiledOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOperand, JITNegIC* negIC)</span>











2826 {
<span class="line-modified">2827     VM&amp; vm = globalObject-&gt;vm();</span>
2828     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2829     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2830     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2831 
2832     JSValue operand = JSValue::decode(encodedOperand);
2833 
<span class="line-modified">2834     UnaryArithProfile* arithProfile = negIC-&gt;arithProfile();</span>
2835     ASSERT(arithProfile);
<span class="line-modified">2836     arithProfile-&gt;observeArg(operand);</span>
<span class="line-modified">2837     negIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), operationArithNegateProfiled);</span>
2838 
2839 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2840     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2841 #endif
2842 
<span class="line-modified">2843     JSValue primValue = operand.toPrimitive(globalObject);</span>
2844     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2845 
2846     if (primValue.isBigInt()) {
2847         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
2848         arithProfile-&gt;observeResult(result);
2849         return JSValue::encode(result);
2850     }
2851 
<span class="line-modified">2852     double number = primValue.toNumber(globalObject);</span>
2853     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2854     JSValue result = jsNumber(-number);
2855     arithProfile-&gt;observeResult(result);
2856     return JSValue::encode(result);
2857 }
2858 
<span class="line-modified">2859 EncodedJSValue JIT_OPERATION operationArithNegateOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOperand, JITNegIC* negIC)</span>
2860 {
<span class="line-modified">2861     VM&amp; vm = globalObject-&gt;vm();</span>
2862     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">2863     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2864     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2865 
2866     JSValue operand = JSValue::decode(encodedOperand);
2867 
<span class="line-modified">2868     if (UnaryArithProfile* arithProfile = negIC-&gt;arithProfile())</span>
<span class="line-modified">2869         arithProfile-&gt;observeArg(operand);</span>
<span class="line-modified">2870     negIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), operationArithNegate);</span>
2871 
2872 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2873     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2874 #endif
2875 
<span class="line-modified">2876     JSValue primValue = operand.toPrimitive(globalObject);</span>
2877     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2878 
2879     if (primValue.isBigInt())
2880         return JSValue::encode(JSBigInt::unaryMinus(vm, asBigInt(primValue)));
2881 
<span class="line-modified">2882     double number = primValue.toNumber(globalObject);</span>
2883     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2884     return JSValue::encode(jsNumber(-number));
2885 }
2886 
<span class="line-modified">2887 ALWAYS_INLINE static EncodedJSValue unprofiledSub(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2888 {
2889     JSValue op1 = JSValue::decode(encodedOp1);
2890     JSValue op2 = JSValue::decode(encodedOp2);
2891 
<span class="line-modified">2892     return JSValue::encode(jsSub(globalObject, op1, op2));</span>
2893 }
2894 
<span class="line-modified">2895 ALWAYS_INLINE static EncodedJSValue profiledSub(VM&amp; vm, JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BinaryArithProfile&amp; arithProfile, bool shouldObserveLHSAndRHSTypes = true)</span>
2896 {
2897     auto scope = DECLARE_THROW_SCOPE(vm);
2898 
2899     JSValue op1 = JSValue::decode(encodedOp1);
2900     JSValue op2 = JSValue::decode(encodedOp2);
2901 
2902     if (shouldObserveLHSAndRHSTypes)
2903         arithProfile.observeLHSAndRHS(op1, op2);
2904 
<span class="line-modified">2905     JSValue result = jsSub(globalObject, op1, op2);</span>
2906     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2907     arithProfile.observeResult(result);
2908     return JSValue::encode(result);
2909 }
2910 
<span class="line-modified">2911 EncodedJSValue JIT_OPERATION operationValueSub(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2)</span>
2912 {
<span class="line-modified">2913     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2914     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-modified">2915     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">2916     return unprofiledSub(globalObject, encodedOp1, encodedOp2);</span>
2917 }
2918 
<span class="line-modified">2919 EncodedJSValue JIT_OPERATION operationValueSubProfiled(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, BinaryArithProfile* arithProfile)</span>
2920 {
2921     ASSERT(arithProfile);
2922 
<span class="line-modified">2923     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2924     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2925     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2926 
<span class="line-modified">2927     return profiledSub(vm, globalObject, encodedOp1, encodedOp2, *arithProfile);</span>
2928 }
2929 
<span class="line-modified">2930 EncodedJSValue JIT_OPERATION operationValueSubOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)</span>
2931 {
<span class="line-modified">2932     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2933     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2934     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2935 
2936     auto nonOptimizeVariant = operationValueSubNoOptimize;
<span class="line-modified">2937     if (BinaryArithProfile* arithProfile = subIC-&gt;arithProfile())</span>
2938         arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
<span class="line-modified">2939     subIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), nonOptimizeVariant);</span>
2940 
2941 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2942     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2943 #endif
2944 
<span class="line-modified">2945     return unprofiledSub(globalObject, encodedOp1, encodedOp2);</span>
2946 }
2947 
<span class="line-modified">2948 EncodedJSValue JIT_OPERATION operationValueSubNoOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC*)</span>
2949 {
<span class="line-modified">2950     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2951     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2952     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2953 
<span class="line-modified">2954     return unprofiledSub(globalObject, encodedOp1, encodedOp2);</span>
2955 }
2956 
<span class="line-modified">2957 EncodedJSValue JIT_OPERATION operationValueSubProfiledOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)</span>
2958 {
<span class="line-modified">2959     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2960     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2961     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2962 
<span class="line-modified">2963     BinaryArithProfile* arithProfile = subIC-&gt;arithProfile();</span>
2964     ASSERT(arithProfile);
2965     arithProfile-&gt;observeLHSAndRHS(JSValue::decode(encodedOp1), JSValue::decode(encodedOp2));
2966     auto nonOptimizeVariant = operationValueSubProfiledNoOptimize;
<span class="line-modified">2967     subIC-&gt;generateOutOfLine(callFrame-&gt;codeBlock(), nonOptimizeVariant);</span>
2968 
2969 #if ENABLE(MATH_IC_STATS)
<span class="line-modified">2970     callFrame-&gt;codeBlock()-&gt;dumpMathICStats();</span>
2971 #endif
2972 
<span class="line-modified">2973     return profiledSub(vm, globalObject, encodedOp1, encodedOp2, *arithProfile, false);</span>
2974 }
2975 
<span class="line-modified">2976 EncodedJSValue JIT_OPERATION operationValueSubProfiledNoOptimize(JSGlobalObject* globalObject, EncodedJSValue encodedOp1, EncodedJSValue encodedOp2, JITSubIC* subIC)</span>
2977 {
<span class="line-modified">2978     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2979     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2980     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2981 
<span class="line-modified">2982     BinaryArithProfile* arithProfile = subIC-&gt;arithProfile();</span>
2983     ASSERT(arithProfile);
<span class="line-modified">2984     return profiledSub(vm, globalObject, encodedOp1, encodedOp2, *arithProfile);</span>
2985 }
2986 
<span class="line-modified">2987 void JIT_OPERATION operationProcessTypeProfilerLog(VM* vmPointer)</span>
2988 {
<span class="line-modified">2989     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2990     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2991     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
2992     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;Log Full, called from inside baseline JIT&quot;_s);
2993 }
2994 
<span class="line-modified">2995 void JIT_OPERATION operationProcessShadowChickenLog(VM* vmPointer)</span>
2996 {
<span class="line-modified">2997     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">2998     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">2999     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3000     RELEASE_ASSERT(vm.shadowChicken());
<span class="line-modified">3001     vm.shadowChicken()-&gt;update(vm, callFrame);</span>
3002 }
3003 
<span class="line-modified">3004 int32_t JIT_OPERATION operationCheckIfExceptionIsUncatchableAndNotifyProfiler(VM* vmPointer)</span>
3005 {
<span class="line-modified">3006     VM&amp; vm = *vmPointer;</span>
<span class="line-modified">3007     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">3008     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
3009     auto scope = DECLARE_THROW_SCOPE(vm);
3010     RELEASE_ASSERT(!!scope.exception());
3011 
3012     if (isTerminatedExecutionException(vm, scope.exception())) {
<span class="line-modified">3013         genericUnwind(vm, callFrame);</span>
3014         return 1;
3015     }
3016     return 0;
3017 }
3018 
3019 } // extern &quot;C&quot;
3020 
3021 } // namespace JSC
3022 
<span class="line-added">3023 IGNORE_WARNINGS_END</span>
<span class="line-added">3024 </span>
3025 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITOpcodes32_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
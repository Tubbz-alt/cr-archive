<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.idl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGL2RenderingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLActiveInfo.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.idl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 typedef long long          GLsizeiptr;
 35 typedef long long          GLint64;
 36 typedef octet              GLubyte;
 37 typedef unsigned short     GLushort;
 38 typedef unsigned long      GLuint;
 39 typedef unsigned long long GLuint64;
 40 typedef unrestricted float GLfloat;
 41 typedef unrestricted float GLclampf;
 42 typedef (ArrayBuffer or ArrayBufferView) BufferDataSource;
 43 typedef (Float32Array or sequence&lt;GLfloat&gt;) Float32List;
 44 typedef (Int32Array or sequence&lt;GLint&gt;) Int32List;
 45 typedef (Uint32Array or sequence&lt;GLuint&gt;) Uint32List;
 46 
 47 #ifdef ENABLE_VIDEO
 48 typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement or HTMLVideoElement) TexImageSource;
 49 #else
 50 typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement) TexImageSource;
 51 #endif
 52 
 53 [

 54     Conditional=WEBGL2,
 55     EnabledAtRuntime=WebGL2,
 56     JSCustomMarkFunction,
 57     JSGenerateToJSObject,
 58     DoNotCheckConstants,
 59     CallTracingCallback=recordCanvasAction,
 60 ] interface WebGL2RenderingContext {






 61     const GLenum READ_BUFFER                                   = 0x0C02;
 62     const GLenum UNPACK_ROW_LENGTH                             = 0x0CF2;
 63     const GLenum UNPACK_SKIP_ROWS                              = 0x0CF3;
 64     const GLenum UNPACK_SKIP_PIXELS                            = 0x0CF4;
 65     const GLenum PACK_ROW_LENGTH                               = 0x0D02;
 66     const GLenum PACK_SKIP_ROWS                                = 0x0D03;
 67     const GLenum PACK_SKIP_PIXELS                              = 0x0D04;
 68     const GLenum COLOR                                         = 0x1800;
 69     const GLenum DEPTH                                         = 0x1801;
 70     const GLenum STENCIL                                       = 0x1802;
 71     const GLenum RED                                           = 0x1903;
 72     const GLenum RGB8                                          = 0x8051;
 73     const GLenum RGBA8                                         = 0x8058;
 74     const GLenum RGB10_A2                                      = 0x8059;
 75     const GLenum TEXTURE_BINDING_3D                            = 0x806A;
 76     const GLenum UNPACK_SKIP_IMAGES                            = 0x806D;
 77     const GLenum UNPACK_IMAGE_HEIGHT                           = 0x806E;
 78     const GLenum TEXTURE_3D                                    = 0x806F;
 79     const GLenum TEXTURE_WRAP_R                                = 0x8072;
 80     const GLenum MAX_3D_TEXTURE_SIZE                           = 0x8073;
</pre>
<hr />
<pre>
307     const GLenum TIMEOUT_EXPIRED                               = 0x911B;
308     const GLenum CONDITION_SATISFIED                           = 0x911C;
309     const GLenum WAIT_FAILED                                   = 0x911D;
310     const GLenum SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001;
311     const GLenum VERTEX_ATTRIB_ARRAY_DIVISOR                   = 0x88FE;
312     const GLenum ANY_SAMPLES_PASSED                            = 0x8C2F;
313     const GLenum ANY_SAMPLES_PASSED_CONSERVATIVE               = 0x8D6A;
314     const GLenum SAMPLER_BINDING                               = 0x8919;
315     const GLenum RGB10_A2UI                                    = 0x906F;
316     const GLenum INT_2_10_10_10_REV                            = 0x8D9F;
317     const GLenum TRANSFORM_FEEDBACK                            = 0x8E22;
318     const GLenum TRANSFORM_FEEDBACK_PAUSED                     = 0x8E23;
319     const GLenum TRANSFORM_FEEDBACK_ACTIVE                     = 0x8E24;
320     const GLenum TRANSFORM_FEEDBACK_BINDING                    = 0x8E25;
321     const GLenum TEXTURE_IMMUTABLE_FORMAT                      = 0x912F;
322     const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
323     const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;
324 
325     const GLint64 TIMEOUT_IGNORED                              = -1;
326 
<span class="line-modified">327     /* WebGL-specific enums */</span>
328     const GLenum MAX_CLIENT_WAIT_TIMEOUT_WEBGL                 = 0x9247;
329 
<span class="line-modified">330     /* Buffer objects */</span>
331     void bufferData(GLenum target, ArrayBufferView data, GLenum usage, GLuint srcOffset, optional GLuint length = 0);
332     void bufferSubData(GLenum target, GLintptr dstByteOffset, ArrayBufferView srcData, GLuint srcOffset, optional GLuint length = 0);
333 
334     void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
<span class="line-removed">335     // MapBufferRange, in particular its read-only and write-only modes,</span>
<span class="line-removed">336     // can not be exposed safely to JavaScript. GetBufferSubData</span>
<span class="line-removed">337     // replaces it for the purpose of fetching data back from the GPU.</span>
338     void getBufferSubData(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstData, optional GLuint dstOffset = 0, optional GLuint length = 0);
339 
<span class="line-modified">340     /* Framebuffer objects */</span>
341     void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
342     void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level, GLint layer);
343     void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
344     void invalidateSubFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
345     void readBuffer(GLenum src);
346 
<span class="line-modified">347     /* Renderbuffer objects */</span>
348     [OverrideIDLType=IDLWebGLAny] any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
349     void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
350 
<span class="line-modified">351     /* Texture objects */</span>
352     void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
353     void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
354 
<span class="line-removed">355     // WebGL1 legacy entrypoints:</span>
<span class="line-removed">356     void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);</span>
<span class="line-removed">357     [MayThrowException] void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, TexImageSource? source);</span>
<span class="line-removed">358 </span>
<span class="line-removed">359     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView? pixels);</span>
<span class="line-removed">360     [MayThrowException] void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, TexImageSource? source);</span>
<span class="line-removed">361 </span>
<span class="line-removed">362     // WebGL2 entrypoints:</span>
<span class="line-removed">363     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-removed">364     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-removed">365     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-removed">366 </span>
367     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
368     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexImageSource source);
369     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
370     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
371 
<span class="line-removed">372     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-removed">373     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-removed">374     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-removed">375 </span>
376     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr pboOffset);
377     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexImageSource source);
378     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, ArrayBufferView? srcData, optional GLuint srcOffset = 0);
379 
380     void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
381 
<span class="line-removed">382     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset);</span>
<span class="line-removed">383     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);</span>
<span class="line-removed">384 </span>
385     void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset);
386     void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
387     void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset);
388     void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
389 
<span class="line-modified">390     /* Programs and shaders */</span>
391     GLint getFragDataLocation(WebGLProgram program, DOMString name);
392 
<span class="line-modified">393     /* Uniforms and attributes */</span>
394     void uniform1ui(WebGLUniformLocation? location, GLuint v0);
395     void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
396     void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
397     void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
398     void uniform1uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
399     void uniform2uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
400     void uniform3uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
401     void uniform4uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
402     void uniformMatrix2x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
403     void uniformMatrix3x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
404     void uniformMatrix2x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
405     void uniformMatrix4x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
406     void uniformMatrix3x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
407     void uniformMatrix4x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
408     void vertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
409     void vertexAttribI4iv(GLuint index, Int32List values);
410     void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
411     void vertexAttribI4uiv(GLuint index, Uint32List values);
412     void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
413 
<span class="line-modified">414     /* Writing to the drawing buffer */</span>
415     void vertexAttribDivisor(GLuint index, GLuint divisor);
416     void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
417     void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
418     void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);
419 
<span class="line-modified">420     /* Multiple Render Targets */</span>
421     void drawBuffers(sequence&lt;GLenum&gt; buffers);
422     void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values, optional GLuint srcOffset = 0);
423     void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values, optional GLuint srcOffset = 0);
424     void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values, optional GLuint srcOffset = 0);
425     void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
426 
<span class="line-modified">427     /* Query Objects */</span>
428     WebGLQuery? createQuery();
429     void deleteQuery(WebGLQuery? query);
430     GLboolean isQuery(WebGLQuery? query);
431     void beginQuery(GLenum target, WebGLQuery query);
432     void endQuery(GLenum target);
433     WebGLQuery? getQuery(GLenum target, GLenum pname);
434     [OverrideIDLType=IDLWebGLAny] any getQueryParameter(WebGLQuery query, GLenum pname);
435 
<span class="line-modified">436     /* Sampler Objects */</span>
437     WebGLSampler? createSampler();
438     void deleteSampler(WebGLSampler? sampler);
439     GLboolean isSampler(WebGLSampler? sampler);
440     void bindSampler(GLuint unit, WebGLSampler? sampler);
441     void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param);
442     void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param);
443     [OverrideIDLType=IDLWebGLAny] any getSamplerParameter(WebGLSampler sampler, GLenum pname);
444 
<span class="line-modified">445     /* Sync objects */</span>
446     WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
447     GLboolean isSync(WebGLSync? sync);
448     void deleteSync(WebGLSync? sync);
449     GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout);
450     void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout);
451     [OverrideIDLType=IDLWebGLAny] any getSyncParameter(WebGLSync sync, GLenum pname);
452 
<span class="line-modified">453     /* Transform Feedback */</span>
454     WebGLTransformFeedback? createTransformFeedback();
455     void deleteTransformFeedback(WebGLTransformFeedback? id);
456     GLboolean isTransformFeedback(WebGLTransformFeedback? id);
457     void bindTransformFeedback(GLenum target, WebGLTransformFeedback? id);
458     void beginTransformFeedback(GLenum primitiveMode);
459     void endTransformFeedback();
460     void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
461     WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index);
462     void pauseTransformFeedback();
463     void resumeTransformFeedback();
464 
<span class="line-modified">465     /* Uniform Buffer Objects and Transform Feedback Buffers */</span>
466     void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
467     void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
468     [OverrideIDLType=IDLWebGLAny] any getIndexedParameter(GLenum target, GLuint index);
469     sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames);
470     [OverrideIDLType=IDLWebGLAny] any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
471     GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName);
472     [OverrideIDLType=IDLWebGLAny] any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname);
473     [OverrideIDLType=IDLWebGLAny] DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex);
474     void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
475 
<span class="line-modified">476     /* Vertex Array Objects */</span>
477     WebGLVertexArrayObject? createVertexArray();
478     void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
479     GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
480     void bindVertexArray(WebGLVertexArrayObject? vertexArray);

































481 };
482 
483 WebGL2RenderingContext implements WebGLRenderingContextBase;
</pre>
</td>
<td>
<hr />
<pre>
 34 typedef long long          GLsizeiptr;
 35 typedef long long          GLint64;
 36 typedef octet              GLubyte;
 37 typedef unsigned short     GLushort;
 38 typedef unsigned long      GLuint;
 39 typedef unsigned long long GLuint64;
 40 typedef unrestricted float GLfloat;
 41 typedef unrestricted float GLclampf;
 42 typedef (ArrayBuffer or ArrayBufferView) BufferDataSource;
 43 typedef (Float32Array or sequence&lt;GLfloat&gt;) Float32List;
 44 typedef (Int32Array or sequence&lt;GLint&gt;) Int32List;
 45 typedef (Uint32Array or sequence&lt;GLuint&gt;) Uint32List;
 46 
 47 #ifdef ENABLE_VIDEO
 48 typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement or HTMLVideoElement) TexImageSource;
 49 #else
 50 typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement) TexImageSource;
 51 #endif
 52 
 53 [
<span class="line-added"> 54     ActiveDOMObject,</span>
 55     Conditional=WEBGL2,
 56     EnabledAtRuntime=WebGL2,
 57     JSCustomMarkFunction,
 58     JSGenerateToJSObject,
 59     DoNotCheckConstants,
 60     CallTracingCallback=recordCanvasAction,
 61 ] interface WebGL2RenderingContext {
<span class="line-added"> 62 </span>
<span class="line-added"> 63     // The specification splits the API surface into a WebGL2RenderingContextBase</span>
<span class="line-added"> 64     // and a WebGL2RenderingContext, but we merge both into one class.</span>
<span class="line-added"> 65 </span>
<span class="line-added"> 66     // WebGLRenderingContextBase contents.</span>
<span class="line-added"> 67 </span>
 68     const GLenum READ_BUFFER                                   = 0x0C02;
 69     const GLenum UNPACK_ROW_LENGTH                             = 0x0CF2;
 70     const GLenum UNPACK_SKIP_ROWS                              = 0x0CF3;
 71     const GLenum UNPACK_SKIP_PIXELS                            = 0x0CF4;
 72     const GLenum PACK_ROW_LENGTH                               = 0x0D02;
 73     const GLenum PACK_SKIP_ROWS                                = 0x0D03;
 74     const GLenum PACK_SKIP_PIXELS                              = 0x0D04;
 75     const GLenum COLOR                                         = 0x1800;
 76     const GLenum DEPTH                                         = 0x1801;
 77     const GLenum STENCIL                                       = 0x1802;
 78     const GLenum RED                                           = 0x1903;
 79     const GLenum RGB8                                          = 0x8051;
 80     const GLenum RGBA8                                         = 0x8058;
 81     const GLenum RGB10_A2                                      = 0x8059;
 82     const GLenum TEXTURE_BINDING_3D                            = 0x806A;
 83     const GLenum UNPACK_SKIP_IMAGES                            = 0x806D;
 84     const GLenum UNPACK_IMAGE_HEIGHT                           = 0x806E;
 85     const GLenum TEXTURE_3D                                    = 0x806F;
 86     const GLenum TEXTURE_WRAP_R                                = 0x8072;
 87     const GLenum MAX_3D_TEXTURE_SIZE                           = 0x8073;
</pre>
<hr />
<pre>
314     const GLenum TIMEOUT_EXPIRED                               = 0x911B;
315     const GLenum CONDITION_SATISFIED                           = 0x911C;
316     const GLenum WAIT_FAILED                                   = 0x911D;
317     const GLenum SYNC_FLUSH_COMMANDS_BIT                       = 0x00000001;
318     const GLenum VERTEX_ATTRIB_ARRAY_DIVISOR                   = 0x88FE;
319     const GLenum ANY_SAMPLES_PASSED                            = 0x8C2F;
320     const GLenum ANY_SAMPLES_PASSED_CONSERVATIVE               = 0x8D6A;
321     const GLenum SAMPLER_BINDING                               = 0x8919;
322     const GLenum RGB10_A2UI                                    = 0x906F;
323     const GLenum INT_2_10_10_10_REV                            = 0x8D9F;
324     const GLenum TRANSFORM_FEEDBACK                            = 0x8E22;
325     const GLenum TRANSFORM_FEEDBACK_PAUSED                     = 0x8E23;
326     const GLenum TRANSFORM_FEEDBACK_ACTIVE                     = 0x8E24;
327     const GLenum TRANSFORM_FEEDBACK_BINDING                    = 0x8E25;
328     const GLenum TEXTURE_IMMUTABLE_FORMAT                      = 0x912F;
329     const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
330     const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;
331 
332     const GLint64 TIMEOUT_IGNORED                              = -1;
333 
<span class="line-modified">334     // WebGL-specific enums/</span>
335     const GLenum MAX_CLIENT_WAIT_TIMEOUT_WEBGL                 = 0x9247;
336 
<span class="line-modified">337     // Buffer objects.</span>
338     void bufferData(GLenum target, ArrayBufferView data, GLenum usage, GLuint srcOffset, optional GLuint length = 0);
339     void bufferSubData(GLenum target, GLintptr dstByteOffset, ArrayBufferView srcData, GLuint srcOffset, optional GLuint length = 0);
340 
341     void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);



342     void getBufferSubData(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstData, optional GLuint dstOffset = 0, optional GLuint length = 0);
343 
<span class="line-modified">344     // Framebuffer objects.</span>
345     void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
346     void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level, GLint layer);
347     void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
348     void invalidateSubFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
349     void readBuffer(GLenum src);
350 
<span class="line-modified">351     // Renderbuffer objects.</span>
352     [OverrideIDLType=IDLWebGLAny] any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
353     void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
354 
<span class="line-modified">355     // Texture objects.</span>
356     void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
357     void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
358 












359     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
360     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexImageSource source);
361     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
362     void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
363 




364     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr pboOffset);
365     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexImageSource source);
366     void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, ArrayBufferView? srcData, optional GLuint srcOffset = 0);
367 
368     void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
369 



370     void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset);
371     void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
372     void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset);
373     void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
374 
<span class="line-modified">375     // Programs and shaders/</span>
376     GLint getFragDataLocation(WebGLProgram program, DOMString name);
377 
<span class="line-modified">378     // Uniforms and attributes.</span>
379     void uniform1ui(WebGLUniformLocation? location, GLuint v0);
380     void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
381     void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
382     void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
383     void uniform1uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
384     void uniform2uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
385     void uniform3uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
386     void uniform4uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
387     void uniformMatrix2x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
388     void uniformMatrix3x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
389     void uniformMatrix2x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
390     void uniformMatrix4x2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
391     void uniformMatrix3x4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
392     void uniformMatrix4x3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
393     void vertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w);
394     void vertexAttribI4iv(GLuint index, Int32List values);
395     void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
396     void vertexAttribI4uiv(GLuint index, Uint32List values);
397     void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
398 
<span class="line-modified">399     // Writing to the drawing buffer.</span>
400     void vertexAttribDivisor(GLuint index, GLuint divisor);
401     void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
402     void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
403     void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);
404 
<span class="line-modified">405     // Multiple Render Targets.</span>
406     void drawBuffers(sequence&lt;GLenum&gt; buffers);
407     void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values, optional GLuint srcOffset = 0);
408     void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values, optional GLuint srcOffset = 0);
409     void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values, optional GLuint srcOffset = 0);
410     void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
411 
<span class="line-modified">412     // Query Objects.</span>
413     WebGLQuery? createQuery();
414     void deleteQuery(WebGLQuery? query);
415     GLboolean isQuery(WebGLQuery? query);
416     void beginQuery(GLenum target, WebGLQuery query);
417     void endQuery(GLenum target);
418     WebGLQuery? getQuery(GLenum target, GLenum pname);
419     [OverrideIDLType=IDLWebGLAny] any getQueryParameter(WebGLQuery query, GLenum pname);
420 
<span class="line-modified">421     // Sampler Objects.</span>
422     WebGLSampler? createSampler();
423     void deleteSampler(WebGLSampler? sampler);
424     GLboolean isSampler(WebGLSampler? sampler);
425     void bindSampler(GLuint unit, WebGLSampler? sampler);
426     void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param);
427     void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param);
428     [OverrideIDLType=IDLWebGLAny] any getSamplerParameter(WebGLSampler sampler, GLenum pname);
429 
<span class="line-modified">430     // Sync objects.</span>
431     WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
432     GLboolean isSync(WebGLSync? sync);
433     void deleteSync(WebGLSync? sync);
434     GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout);
435     void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout);
436     [OverrideIDLType=IDLWebGLAny] any getSyncParameter(WebGLSync sync, GLenum pname);
437 
<span class="line-modified">438     // Transform Feedback.</span>
439     WebGLTransformFeedback? createTransformFeedback();
440     void deleteTransformFeedback(WebGLTransformFeedback? id);
441     GLboolean isTransformFeedback(WebGLTransformFeedback? id);
442     void bindTransformFeedback(GLenum target, WebGLTransformFeedback? id);
443     void beginTransformFeedback(GLenum primitiveMode);
444     void endTransformFeedback();
445     void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
446     WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index);
447     void pauseTransformFeedback();
448     void resumeTransformFeedback();
449 
<span class="line-modified">450     // Uniform Buffer Objects and Transform Feedback Buffers.</span>
451     void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
452     void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
453     [OverrideIDLType=IDLWebGLAny] any getIndexedParameter(GLenum target, GLuint index);
454     sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames);
455     [OverrideIDLType=IDLWebGLAny] any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
456     GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName);
457     [OverrideIDLType=IDLWebGLAny] any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname);
458     [OverrideIDLType=IDLWebGLAny] DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex);
459     void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
460 
<span class="line-modified">461     // Vertex Array Objects.</span>
462     WebGLVertexArrayObject? createVertexArray();
463     void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
464     GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
465     void bindVertexArray(WebGLVertexArrayObject? vertexArray);
<span class="line-added">466 </span>
<span class="line-added">467     // WebGL2RenderingContext API.</span>
<span class="line-added">468 </span>
<span class="line-added">469     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-added">470     [MayThrowException] void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-added">471     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-added">472 </span>
<span class="line-added">473     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-added">474     [MayThrowException] void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-added">475     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-added">476 </span>
<span class="line-added">477     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset);</span>
<span class="line-added">478     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, ArrayBufferView srcData, GLuint srcOffset, optional GLuint srcLengthOverride = 0);</span>
<span class="line-added">479 </span>
<span class="line-added">480     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset);</span>
<span class="line-added">481     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView srcData, GLuint srcOffset, optional GLuint srcLengthOverride = 0);</span>
<span class="line-added">482 </span>
<span class="line-added">483     void uniform1fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">484     void uniform2fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">485     void uniform3fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">486     void uniform4fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">487 </span>
<span class="line-added">488     void uniform1iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">489     void uniform2iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">490     void uniform3iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">491     void uniform4iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">492 </span>
<span class="line-added">493     void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">494     void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">495     void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">496 </span>
<span class="line-added">497     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset);</span>
<span class="line-added">498     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView dstData, GLuint dstOffset);</span>
499 };
500 
501 WebGL2RenderingContext implements WebGLRenderingContextBase;
</pre>
</td>
</tr>
</table>
<center><a href="WebGL2RenderingContext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLActiveInfo.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
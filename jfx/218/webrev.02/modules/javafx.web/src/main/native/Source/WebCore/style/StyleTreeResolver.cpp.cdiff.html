<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/style/StyleTreeResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleSharingResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleTreeResolver.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/style/StyleTreeResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 47,48 ***</span>
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;ShadowRoot.h&quot;
  #include &quot;StyleFontSizeFunctions.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;StyleScope.h&quot;
  #include &quot;Text.h&quot;
  
  namespace WebCore {
  
  namespace Style {
  
  TreeResolver::TreeResolver(Document&amp; document)
      : m_document(document)
  {
  }
  
  TreeResolver::~TreeResolver() = default;
  
  TreeResolver::Scope::Scope(Document&amp; document)
<span class="line-modified">!     : styleResolver(document.styleScope().resolver())</span>
<span class="line-modified">!     , sharingResolver(document, styleResolver.ruleSets(), selectorFilter)</span>
  {
      document.setIsResolvingTreeStyle(true);
  }
  
  TreeResolver::Scope::Scope(ShadowRoot&amp; shadowRoot, Scope&amp; enclosingScope)
<span class="line-modified">!     : styleResolver(shadowRoot.styleScope().resolver())</span>
<span class="line-modified">!     , sharingResolver(shadowRoot.documentScope(), styleResolver.ruleSets(), selectorFilter)</span>
      , shadowRoot(&amp;shadowRoot)
      , enclosingScope(&amp;enclosingScope)
  {
<span class="line-modified">!     styleResolver.setOverrideDocumentElementStyle(enclosingScope.styleResolver.overrideDocumentElementStyle());</span>
  }
  
  TreeResolver::Scope::~Scope()
  {
      if (!shadowRoot)
<span class="line-modified">!         styleResolver.document().setIsResolvingTreeStyle(false);</span>
  
<span class="line-modified">!     styleResolver.setOverrideDocumentElementStyle(nullptr);</span>
  }
  
  TreeResolver::Parent::Parent(Document&amp; document)
      : element(nullptr)
      , style(*document.renderStyle())
<span class="line-new-header">--- 47,51 ---</span>
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;ShadowRoot.h&quot;
<span class="line-added">+ #include &quot;StyleAdjuster.h&quot;</span>
  #include &quot;StyleFontSizeFunctions.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;StyleScope.h&quot;
  #include &quot;Text.h&quot;
  
  namespace WebCore {
  
  namespace Style {
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(TreeResolverScope);</span>
<span class="line-added">+ </span>
  TreeResolver::TreeResolver(Document&amp; document)
      : m_document(document)
  {
  }
  
  TreeResolver::~TreeResolver() = default;
  
  TreeResolver::Scope::Scope(Document&amp; document)
<span class="line-modified">!     : resolver(document.styleScope().resolver())</span>
<span class="line-modified">!     , sharingResolver(document, resolver.ruleSets(), selectorFilter)</span>
  {
      document.setIsResolvingTreeStyle(true);
  }
  
  TreeResolver::Scope::Scope(ShadowRoot&amp; shadowRoot, Scope&amp; enclosingScope)
<span class="line-modified">!     : resolver(shadowRoot.styleScope().resolver())</span>
<span class="line-modified">!     , sharingResolver(shadowRoot.documentScope(), resolver.ruleSets(), selectorFilter)</span>
      , shadowRoot(&amp;shadowRoot)
      , enclosingScope(&amp;enclosingScope)
  {
<span class="line-modified">!     resolver.setOverrideDocumentElementStyle(enclosingScope.resolver.overrideDocumentElementStyle());</span>
  }
  
  TreeResolver::Scope::~Scope()
  {
      if (!shadowRoot)
<span class="line-modified">!         resolver.document().setIsResolvingTreeStyle(false);</span>
  
<span class="line-modified">!     resolver.setOverrideDocumentElementStyle(nullptr);</span>
  }
  
  TreeResolver::Parent::Parent(Document&amp; document)
      : element(nullptr)
      , style(*document.renderStyle())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,11 ***</span>
      }
  
      if (auto style = scope().sharingResolver.resolve(element, *m_update))
          return style;
  
<span class="line-modified">!     auto elementStyle = scope().styleResolver.styleForElement(element, &amp;inheritedStyle, parentBoxStyle(), RuleMatchingBehavior::MatchAllRules, &amp;scope().selectorFilter);</span>
  
      if (elementStyle.relations)
          commitRelations(WTFMove(elementStyle.relations), *m_update);
  
      return WTFMove(elementStyle.renderStyle);
<span class="line-new-header">--- 135,11 ---</span>
      }
  
      if (auto style = scope().sharingResolver.resolve(element, *m_update))
          return style;
  
<span class="line-modified">!     auto elementStyle = scope().resolver.styleForElement(element, &amp;inheritedStyle, parentBoxStyle(), RuleMatchingBehavior::MatchAllRules, &amp;scope().selectorFilter);</span>
  
      if (elementStyle.relations)
          commitRelations(WTFMove(elementStyle.relations), *m_update);
  
      return WTFMove(elementStyle.renderStyle);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,10 ***</span>
<span class="line-new-header">--- 196,13 ---</span>
      if (m_didSeePendingStylesheet &amp;&amp; !element.renderer() &amp;&amp; !m_document.isIgnoringPendingStylesheets()) {
          m_document.setHasNodesWithMissingStyle();
          return { };
      }
  
<span class="line-added">+     if (!element.rendererIsEverNeeded())</span>
<span class="line-added">+         return { };</span>
<span class="line-added">+ </span>
      auto newStyle = styleForElement(element, parent().style);
  
      if (!affectsRenderedSubtree(element, *newStyle))
          return { };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,16 ***</span>
      auto update = createAnimatedElementUpdate(WTFMove(newStyle), element, parent().change);
      auto descendantsToResolve = computeDescendantsToResolve(update.change, element.styleValidity(), parent().descendantsToResolve);
  
      if (&amp;element == m_document.documentElement()) {
          m_documentElementStyle = RenderStyle::clonePtr(*update.style);
<span class="line-modified">!         scope().styleResolver.setOverrideDocumentElementStyle(m_documentElementStyle.get());</span>
  
          if (update.change != NoChange &amp;&amp; existingStyle &amp;&amp; existingStyle-&gt;computedFontPixelSize() != update.style-&gt;computedFontPixelSize()) {
              // &quot;rem&quot; units are relative to the document element&#39;s font size so we need to recompute everything.
              // In practice this is rare.
<span class="line-modified">!             scope().styleResolver.invalidateMatchedPropertiesCache();</span>
              descendantsToResolve = DescendantsToResolve::All;
          }
      }
  
      // This is needed for resolving color:-webkit-text for subsequent elements.
<span class="line-new-header">--- 216,16 ---</span>
      auto update = createAnimatedElementUpdate(WTFMove(newStyle), element, parent().change);
      auto descendantsToResolve = computeDescendantsToResolve(update.change, element.styleValidity(), parent().descendantsToResolve);
  
      if (&amp;element == m_document.documentElement()) {
          m_documentElementStyle = RenderStyle::clonePtr(*update.style);
<span class="line-modified">!         scope().resolver.setOverrideDocumentElementStyle(m_documentElementStyle.get());</span>
  
          if (update.change != NoChange &amp;&amp; existingStyle &amp;&amp; existingStyle-&gt;computedFontPixelSize() != update.style-&gt;computedFontPixelSize()) {
              // &quot;rem&quot; units are relative to the document element&#39;s font size so we need to recompute everything.
              // In practice this is rare.
<span class="line-modified">!             scope().resolver.invalidateMatchedDeclarationsCache();</span>
              descendantsToResolve = DescendantsToResolve::All;
          }
      }
  
      // This is needed for resolving color:-webkit-text for subsequent elements.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 252,11 ***</span>
      if (elementUpdate.style-&gt;display() == DisplayType::None)
          return { };
      if (!elementUpdate.style-&gt;hasPseudoStyle(pseudoId))
          return { };
  
<span class="line-modified">!     auto pseudoStyle = scope().styleResolver.pseudoStyleForElement(element, { pseudoId }, *elementUpdate.style, &amp;scope().selectorFilter);</span>
      if (!pseudoElementRendererIsNeeded(pseudoStyle.get()))
          return { };
  
      PseudoElement* pseudoElement = pseudoId == PseudoId::Before ? element.beforePseudoElement() : element.afterPseudoElement();
      if (!pseudoElement) {
<span class="line-new-header">--- 258,11 ---</span>
      if (elementUpdate.style-&gt;display() == DisplayType::None)
          return { };
      if (!elementUpdate.style-&gt;hasPseudoStyle(pseudoId))
          return { };
  
<span class="line-modified">!     auto pseudoStyle = scope().resolver.pseudoStyleForElement(element, { pseudoId }, *elementUpdate.style, parentBoxStyleForPseudo(elementUpdate), &amp;scope().selectorFilter);</span>
      if (!pseudoElementRendererIsNeeded(pseudoStyle.get()))
          return { };
  
      PseudoElement* pseudoElement = pseudoId == PseudoId::Before ? element.beforePseudoElement() : element.afterPseudoElement();
      if (!pseudoElement) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,68 ***</span>
  }
  
  const RenderStyle* TreeResolver::parentBoxStyle() const
  {
      // &#39;display: contents&#39; doesn&#39;t generate boxes.
<span class="line-modified">!     for (unsigned i = m_parentStack.size(); i; --i) {</span>
<span class="line-modified">!         auto&amp; parent = m_parentStack[i - 1];</span>
          if (parent.style.display() == DisplayType::None)
              return nullptr;
          if (parent.style.display() != DisplayType::Contents)
              return &amp;parent.style;
      }
      ASSERT_NOT_REACHED();
      return nullptr;
  }
  
  ElementUpdate TreeResolver::createAnimatedElementUpdate(std::unique_ptr&lt;RenderStyle&gt; newStyle, Element&amp; element, Change parentChange)
  {
      auto* oldStyle = element.renderOrDisplayContentsStyle();
  
<span class="line-modified">!     bool shouldRecompositeLayer = false;</span>
  
      // New code path for CSS Animations and CSS Transitions.
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
          // First, we need to make sure that any new CSS animation occuring on this element has a matching WebAnimation
          // on the document timeline. Note that we get timeline() on the Document here because we need a timeline created
          // in case no Web Animations have been created through the JS API.
<span class="line-modified">!         if (element.document().pageCacheState() == Document::NotInPageCache &amp;&amp; !element.document().renderView()-&gt;printing()) {</span>
              if (oldStyle &amp;&amp; (oldStyle-&gt;hasTransitions() || newStyle-&gt;hasTransitions()))
                  m_document.timeline().updateCSSTransitionsForElement(element, *oldStyle, *newStyle);
  
              if ((oldStyle &amp;&amp; oldStyle-&gt;hasAnimations()) || newStyle-&gt;hasAnimations())
                  m_document.timeline().updateCSSAnimationsForElement(element, oldStyle, *newStyle);
          }
      }
  
<span class="line-modified">!     if (auto timeline = m_document.existingTimeline()) {</span>
<span class="line-modified">!         // Now we can update all Web animations, which will include CSS Animations as well</span>
<span class="line-modified">!         // as animations created via the JS API.</span>
          auto animatedStyle = RenderStyle::clonePtr(*newStyle);
<span class="line-modified">!         shouldRecompositeLayer = timeline-&gt;resolveAnimationsForElement(element, *animatedStyle);</span>
          newStyle = WTFMove(animatedStyle);
      }
  
      // Old code path for CSS Animations and CSS Transitions.
      if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
          auto&amp; animationController = m_document.frame()-&gt;animation();
  
          auto animationUpdate = animationController.updateAnimations(element, *newStyle, oldStyle);
<span class="line-modified">!         shouldRecompositeLayer = animationUpdate.animationChangeRequiresRecomposite;</span>
  
          if (animationUpdate.style)
              newStyle = WTFMove(animationUpdate.style);
      }
  
      auto change = oldStyle ? determineChange(*oldStyle, *newStyle) : Detach;
  
      auto validity = element.styleValidity();
      if (validity &gt;= Validity::SubtreeAndRenderersInvalid || parentChange == Detach)
          change = Detach;
  
<span class="line-modified">!     shouldRecompositeLayer |= element.styleResolutionShouldRecompositeLayer();</span>
<span class="line-removed">- </span>
      return { WTFMove(newStyle), change, shouldRecompositeLayer };
  }
  
  void TreeResolver::pushParent(Element&amp; element, const RenderStyle&amp; style, Change change, DescendantsToResolve descendantsToResolve)
  {
<span class="line-new-header">--- 278,82 ---</span>
  }
  
  const RenderStyle* TreeResolver::parentBoxStyle() const
  {
      // &#39;display: contents&#39; doesn&#39;t generate boxes.
<span class="line-modified">!     for (auto i = m_parentStack.size(); i--;) {</span>
<span class="line-modified">!         auto&amp; parent = m_parentStack[i];</span>
          if (parent.style.display() == DisplayType::None)
              return nullptr;
          if (parent.style.display() != DisplayType::Contents)
              return &amp;parent.style;
      }
      ASSERT_NOT_REACHED();
      return nullptr;
  }
  
<span class="line-added">+ const RenderStyle* TreeResolver::parentBoxStyleForPseudo(const ElementUpdate&amp; elementUpdate) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (elementUpdate.style-&gt;display()) {</span>
<span class="line-added">+     case DisplayType::None:</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     case DisplayType::Contents:</span>
<span class="line-added">+         return parentBoxStyle();</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         return elementUpdate.style.get();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  ElementUpdate TreeResolver::createAnimatedElementUpdate(std::unique_ptr&lt;RenderStyle&gt; newStyle, Element&amp; element, Change parentChange)
  {
      auto* oldStyle = element.renderOrDisplayContentsStyle();
  
<span class="line-modified">!     OptionSet&lt;AnimationImpact&gt; animationImpact;</span>
  
      // New code path for CSS Animations and CSS Transitions.
      if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
          // First, we need to make sure that any new CSS animation occuring on this element has a matching WebAnimation
          // on the document timeline. Note that we get timeline() on the Document here because we need a timeline created
          // in case no Web Animations have been created through the JS API.
<span class="line-modified">!         if (element.document().backForwardCacheState() == Document::NotInBackForwardCache &amp;&amp; !element.document().renderView()-&gt;printing()) {</span>
              if (oldStyle &amp;&amp; (oldStyle-&gt;hasTransitions() || newStyle-&gt;hasTransitions()))
                  m_document.timeline().updateCSSTransitionsForElement(element, *oldStyle, *newStyle);
  
              if ((oldStyle &amp;&amp; oldStyle-&gt;hasAnimations()) || newStyle-&gt;hasAnimations())
                  m_document.timeline().updateCSSAnimationsForElement(element, oldStyle, *newStyle);
          }
      }
  
<span class="line-modified">!     // Now we can update all Web animations, which will include CSS Animations as well</span>
<span class="line-modified">!     // as animations created via the JS API.</span>
<span class="line-modified">!     if (element.hasKeyframeEffects()) {</span>
          auto animatedStyle = RenderStyle::clonePtr(*newStyle);
<span class="line-modified">!         animationImpact = element.applyKeyframeEffects(*animatedStyle);</span>
          newStyle = WTFMove(animatedStyle);
      }
  
      // Old code path for CSS Animations and CSS Transitions.
      if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
          auto&amp; animationController = m_document.frame()-&gt;animation();
  
          auto animationUpdate = animationController.updateAnimations(element, *newStyle, oldStyle);
<span class="line-modified">!         animationImpact.add(animationUpdate.impact);</span>
  
          if (animationUpdate.style)
              newStyle = WTFMove(animationUpdate.style);
      }
  
<span class="line-added">+     if (animationImpact)</span>
<span class="line-added">+         Adjuster::adjustAnimatedStyle(*newStyle, parentBoxStyle(), animationImpact);</span>
<span class="line-added">+ </span>
      auto change = oldStyle ? determineChange(*oldStyle, *newStyle) : Detach;
  
      auto validity = element.styleValidity();
      if (validity &gt;= Validity::SubtreeAndRenderersInvalid || parentChange == Detach)
          change = Detach;
  
<span class="line-modified">!     bool shouldRecompositeLayer = animationImpact.contains(AnimationImpact::RequiresRecomposite) || element.styleResolutionShouldRecompositeLayer();</span>
      return { WTFMove(newStyle), change, shouldRecompositeLayer };
  }
  
  void TreeResolver::pushParent(Element&amp; element, const RenderStyle&amp; style, Change change, DescendantsToResolve descendantsToResolve)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,11 ***</span>
  
  static std::unique_ptr&lt;RenderStyle&gt; createInheritedDisplayContentsStyleIfNeeded(const RenderStyle&amp; parentElementStyle, const RenderStyle* parentBoxStyle)
  {
      if (parentElementStyle.display() != DisplayType::Contents)
          return nullptr;
<span class="line-modified">!     if (parentBoxStyle &amp;&amp; !parentBoxStyle-&gt;inheritedNotEqual(&amp;parentElementStyle))</span>
          return nullptr;
      // Compute style for imaginary unstyled &lt;span&gt; around the text node.
      auto style = RenderStyle::createPtr();
      style-&gt;inheritFrom(parentElementStyle);
      return style;
<span class="line-new-header">--- 453,11 ---</span>
  
  static std::unique_ptr&lt;RenderStyle&gt; createInheritedDisplayContentsStyleIfNeeded(const RenderStyle&amp; parentElementStyle, const RenderStyle* parentBoxStyle)
  {
      if (parentElementStyle.display() != DisplayType::Contents)
          return nullptr;
<span class="line-modified">!     if (parentBoxStyle &amp;&amp; parentBoxStyle-&gt;inheritedEqual(parentElementStyle))</span>
          return nullptr;
      // Compute style for imaginary unstyled &lt;span&gt; around the text node.
      auto style = RenderStyle::createPtr();
      style-&gt;inheritFrom(parentElementStyle);
      return style;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,17 ***</span>
      m_update = makeUnique&lt;Update&gt;(m_document);
      m_scopeStack.append(adoptRef(*new Scope(m_document)));
      m_parentStack.append(Parent(m_document));
  
      // Pseudo element removal and similar may only work with these flags still set. Reset them after the style recalc.
<span class="line-modified">!     renderView.setUsesFirstLineRules(renderView.usesFirstLineRules() || scope().styleResolver.usesFirstLineRules());</span>
<span class="line-modified">!     renderView.setUsesFirstLetterRules(renderView.usesFirstLetterRules() || scope().styleResolver.usesFirstLetterRules());</span>
  
      resolveComposedTree();
  
<span class="line-modified">!     renderView.setUsesFirstLineRules(scope().styleResolver.usesFirstLineRules());</span>
<span class="line-modified">!     renderView.setUsesFirstLetterRules(scope().styleResolver.usesFirstLetterRules());</span>
  
      ASSERT(m_scopeStack.size() == 1);
      ASSERT(m_parentStack.size() == 1);
      m_parentStack.clear();
      popScope();
<span class="line-new-header">--- 571,17 ---</span>
      m_update = makeUnique&lt;Update&gt;(m_document);
      m_scopeStack.append(adoptRef(*new Scope(m_document)));
      m_parentStack.append(Parent(m_document));
  
      // Pseudo element removal and similar may only work with these flags still set. Reset them after the style recalc.
<span class="line-modified">!     renderView.setUsesFirstLineRules(renderView.usesFirstLineRules() || scope().resolver.usesFirstLineRules());</span>
<span class="line-modified">!     renderView.setUsesFirstLetterRules(renderView.usesFirstLetterRules() || scope().resolver.usesFirstLetterRules());</span>
  
      resolveComposedTree();
  
<span class="line-modified">!     renderView.setUsesFirstLineRules(scope().resolver.usesFirstLineRules());</span>
<span class="line-modified">!     renderView.setUsesFirstLetterRules(scope().resolver.usesFirstLetterRules());</span>
  
      ASSERT(m_scopeStack.size() == 1);
      ASSERT(m_parentStack.size() == 1);
      m_parentStack.clear();
      popScope();
</pre>
<center><a href="StyleSharingResolver.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleTreeResolver.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
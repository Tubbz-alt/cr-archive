<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitVector.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BlockObjCExceptions.mm.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  *  Copyright (C) 2010-2017 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  *  Copyright (C) 2010-2019 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Lesser General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,10 ***</span>
<span class="line-new-header">--- 49,11 ---</span>
      bool concurrentTestAndSet(size_t, Dependency = Dependency());
      bool concurrentTestAndClear(size_t, Dependency = Dependency());
      size_t nextPossiblyUnset(size_t) const;
      void clear(size_t);
      void clearAll();
<span class="line-added">+     void invert();</span>
      int64_t findRunOfZeros(size_t runLength) const;
      size_t count(size_t start = 0) const;
      size_t isEmpty() const;
      size_t isFull() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,37 ***</span>
          bool operator!=(const iterator&amp; other) const
          {
              return !(*this == other);
          }
  
      private:
          const Bitmap* m_bitmap;
          size_t m_index;
      };
  
      // Use this to iterate over set bits.
      iterator begin() const { return iterator(*this, findBit(0, true)); }
      iterator end() const { return iterator(*this, bitmapSize); }
  
      void mergeAndClear(Bitmap&amp;);
      void setAndClear(Bitmap&amp;);
  
      bool operator==(const Bitmap&amp;) const;
      bool operator!=(const Bitmap&amp;) const;
  
      unsigned hash() const;
  
  private:
<span class="line-modified">!     static const unsigned wordSize = sizeof(WordType) * 8;</span>
<span class="line-modified">!     static const unsigned words = (bitmapSize + wordSize - 1) / wordSize;</span>
  
      // the literal &#39;1&#39; is of type signed int.  We want to use an unsigned
      // version of the correct size when doing the calculations because if
      // WordType is larger than int, &#39;1 &lt;&lt; 31&#39; will first be sign extended
      // and then casted to unsigned, meaning that set(31) when WordType is
      // a 64 bit unsigned int would give 0xffff8000
<span class="line-modified">!     static const WordType one = 1;</span>
  
      std::array&lt;WordType, words&gt; bits;
  };
  
  template&lt;size_t bitmapSize, typename WordType&gt;
<span class="line-new-header">--- 101,46 ---</span>
          bool operator!=(const iterator&amp; other) const
          {
              return !(*this == other);
          }
  
<span class="line-added">+         iterator&amp; operator=(bool value)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             m_bitmap-&gt;set(m_index, value);</span>
<span class="line-added">+             return *this;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      private:
          const Bitmap* m_bitmap;
          size_t m_index;
      };
  
      // Use this to iterate over set bits.
      iterator begin() const { return iterator(*this, findBit(0, true)); }
      iterator end() const { return iterator(*this, bitmapSize); }
  
<span class="line-added">+     iterator operator[](size_t);</span>
<span class="line-added">+     const iterator operator[](size_t) const;</span>
<span class="line-added">+ </span>
      void mergeAndClear(Bitmap&amp;);
      void setAndClear(Bitmap&amp;);
  
      bool operator==(const Bitmap&amp;) const;
      bool operator!=(const Bitmap&amp;) const;
  
      unsigned hash() const;
  
  private:
<span class="line-modified">!     static constexpr unsigned wordSize = sizeof(WordType) * 8;</span>
<span class="line-modified">!     static constexpr unsigned words = (bitmapSize + wordSize - 1) / wordSize;</span>
  
      // the literal &#39;1&#39; is of type signed int.  We want to use an unsigned
      // version of the correct size when doing the calculations because if
      // WordType is larger than int, &#39;1 &lt;&lt; 31&#39; will first be sign extended
      // and then casted to unsigned, meaning that set(31) when WordType is
      // a 64 bit unsigned int would give 0xffff8000
<span class="line-modified">!     static constexpr WordType one = 1;</span>
  
      std::array&lt;WordType, words&gt; bits;
  };
  
  template&lt;size_t bitmapSize, typename WordType&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,10 ***</span>
<span class="line-new-header">--- 232,17 ---</span>
  inline void Bitmap&lt;bitmapSize, WordType&gt;::clearAll()
  {
      memset(bits.data(), 0, sizeof(bits));
  }
  
<span class="line-added">+ template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">+ inline void Bitmap&lt;bitmapSize, WordType&gt;::invert()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (size_t i = 0; i &lt; words; ++i)</span>
<span class="line-added">+         bits[i] = ~bits[i];</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template&lt;size_t bitmapSize, typename WordType&gt;
  inline size_t Bitmap&lt;bitmapSize, WordType&gt;::nextPossiblyUnset(size_t start) const
  {
      if (!~bits[start / wordSize])
          return ((start / wordSize) + 1) * wordSize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,10 ***</span>
<span class="line-new-header">--- 424,23 ---</span>
  inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator!=(const Bitmap&amp; other) const
  {
      return !(*this == other);
  }
  
<span class="line-added">+ template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">+ inline auto Bitmap&lt;bitmapSize, WordType&gt;::operator[](size_t index) -&gt; iterator</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(index &lt; size());</span>
<span class="line-added">+     return iterator(*this, index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">+ inline auto Bitmap&lt;bitmapSize, WordType&gt;::operator[](size_t index) const -&gt; const iterator</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return (*const_cast&lt;Bitmap&lt;bitmapSize, WordType&gt;*&gt;(this))[index];</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template&lt;size_t bitmapSize, typename WordType&gt;
  inline unsigned Bitmap&lt;bitmapSize, WordType&gt;::hash() const
  {
      unsigned result = 0;
      for (size_t i = 0; i &lt; words; ++i)
</pre>
<center><a href="BitVector.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BlockObjCExceptions.mm.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
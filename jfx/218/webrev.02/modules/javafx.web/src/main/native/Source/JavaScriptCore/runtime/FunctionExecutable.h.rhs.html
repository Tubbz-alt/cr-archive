<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionExecutable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ExecutableToCodeBlockEdge.h&quot;
 29 #include &quot;ScriptExecutable.h&quot;
 30 #include &quot;SourceCode.h&quot;
 31 #include &lt;wtf/Box.h&gt;
 32 #include &lt;wtf/Markable.h&gt;
 33 
 34 namespace JSC {
 35 
 36 struct FunctionOverrideInfo;
 37 
 38 class FunctionExecutable final : public ScriptExecutable {
 39     friend class JIT;
 40     friend class LLIntOffsetsExtractor;
 41 public:
 42     typedef ScriptExecutable Base;
<a name="2" id="anc2"></a><span class="line-modified"> 43     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
 44 
 45     template&lt;typename CellType, SubspaceAccess&gt;
 46     static IsoSubspace* subspaceFor(VM&amp; vm)
 47     {
 48         return &amp;vm.functionExecutableSpace.space;
 49     }
 50 
 51     static FunctionExecutable* create(VM&amp; vm, ScriptExecutable* topLevelExecutable, const SourceCode&amp; source, UnlinkedFunctionExecutable* unlinkedExecutable, Intrinsic intrinsic)
 52     {
 53         FunctionExecutable* executable = new (NotNull, allocateCell&lt;FunctionExecutable&gt;(vm.heap)) FunctionExecutable(vm, source, unlinkedExecutable, intrinsic);
 54         executable-&gt;finishCreation(vm, topLevelExecutable);
 55         return executable;
 56     }
 57     static FunctionExecutable* fromGlobalCode(
<a name="3" id="anc3"></a><span class="line-modified"> 58         const Identifier&amp; name, JSGlobalObject*, const SourceCode&amp;,</span>
 59         JSObject*&amp; exception, int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition);
 60 
 61     static void destroy(JSCell*);
 62 
 63     UnlinkedFunctionExecutable* unlinkedExecutable() const
 64     {
 65         return m_unlinkedExecutable.get();
 66     }
 67 
 68     // Returns either call or construct bytecode. This can be appropriate
 69     // for answering questions that that don&#39;t vary between call and construct --
 70     // for example, argumentsRegister().
 71     FunctionCodeBlock* eitherCodeBlock()
 72     {
 73         ExecutableToCodeBlockEdge* edge;
 74         if (m_codeBlockForCall)
 75             edge = m_codeBlockForCall.get();
 76         else
 77             edge = m_codeBlockForConstruct.get();
 78         return bitwise_cast&lt;FunctionCodeBlock*&gt;(ExecutableToCodeBlockEdge::unwrap(edge));
 79     }
 80 
 81     bool isGeneratedForCall() const
 82     {
 83         return !!m_codeBlockForCall;
 84     }
 85 
 86     FunctionCodeBlock* codeBlockForCall()
 87     {
 88         return bitwise_cast&lt;FunctionCodeBlock*&gt;(ExecutableToCodeBlockEdge::unwrap(m_codeBlockForCall.get()));
 89     }
 90 
 91     bool isGeneratedForConstruct() const
 92     {
 93         return !!m_codeBlockForConstruct;
 94     }
 95 
 96     FunctionCodeBlock* codeBlockForConstruct()
 97     {
 98         return bitwise_cast&lt;FunctionCodeBlock*&gt;(ExecutableToCodeBlockEdge::unwrap(m_codeBlockForConstruct.get()));
 99     }
100 
101     bool isGeneratedFor(CodeSpecializationKind kind)
102     {
103         if (kind == CodeForCall)
104             return isGeneratedForCall();
105         ASSERT(kind == CodeForConstruct);
106         return isGeneratedForConstruct();
107     }
108 
109     FunctionCodeBlock* codeBlockFor(CodeSpecializationKind kind)
110     {
111         if (kind == CodeForCall)
112             return codeBlockForCall();
113         ASSERT(kind == CodeForConstruct);
114         return codeBlockForConstruct();
115     }
116 
117     FunctionCodeBlock* baselineCodeBlockFor(CodeSpecializationKind);
118 
119     FunctionCodeBlock* profiledCodeBlockFor(CodeSpecializationKind kind)
120     {
121         return baselineCodeBlockFor(kind);
122     }
123 
124     RefPtr&lt;TypeSet&gt; returnStatementTypeSet()
125     {
126         RareData&amp; rareData = ensureRareData();
127         if (!rareData.m_returnStatementTypeSet)
128             rareData.m_returnStatementTypeSet = TypeSet::create();
129         return rareData.m_returnStatementTypeSet;
130     }
131 
132     FunctionMode functionMode() { return m_unlinkedExecutable-&gt;functionMode(); }
133     bool isBuiltinFunction() const { return m_unlinkedExecutable-&gt;isBuiltinFunction(); }
<a name="4" id="anc4"></a>
134     ConstructAbility constructAbility() const { return m_unlinkedExecutable-&gt;constructAbility(); }
135     bool isClass() const { return m_unlinkedExecutable-&gt;isClass(); }
136     bool isArrowFunction() const { return parseMode() == SourceParseMode::ArrowFunctionMode; }
137     bool isGetter() const { return parseMode() == SourceParseMode::GetterMode; }
138     bool isSetter() const { return parseMode() == SourceParseMode::SetterMode; }
139     bool isGenerator() const { return isGeneratorParseMode(parseMode()); }
140     bool isAsyncGenerator() const { return isAsyncGeneratorParseMode(parseMode()); }
141     bool isMethod() const { return parseMode() == SourceParseMode::MethodMode; }
142     bool hasCallerAndArgumentsProperties() const
143     {
144         // Per https://tc39.github.io/ecma262/#sec-forbidden-extensions, only sloppy-mode non-builtin functions in old-style (pre-ES6) syntactic forms can contain
145         // &quot;caller&quot; and &quot;arguments&quot;.
146         return !isStrictMode() &amp;&amp; parseMode() == SourceParseMode::NormalFunctionMode &amp;&amp; !isClassConstructorFunction();
147     }
148     bool hasPrototypeProperty() const
149     {
150         return SourceParseModeSet(
151             SourceParseMode::NormalFunctionMode,
152             SourceParseMode::GeneratorBodyMode,
153             SourceParseMode::GeneratorWrapperFunctionMode,
154             SourceParseMode::GeneratorWrapperMethodMode,
155             SourceParseMode::AsyncGeneratorWrapperFunctionMode,
156             SourceParseMode::AsyncGeneratorWrapperMethodMode,
157             SourceParseMode::AsyncGeneratorBodyMode
158         ).contains(parseMode()) || isClass();
159     }
160     DerivedContextType derivedContextType() const { return m_unlinkedExecutable-&gt;derivedContextType(); }
161     bool isClassConstructorFunction() const { return m_unlinkedExecutable-&gt;isClassConstructorFunction(); }
162     const Identifier&amp; name() { return m_unlinkedExecutable-&gt;name(); }
163     const Identifier&amp; ecmaName() { return m_unlinkedExecutable-&gt;ecmaName(); }
164     unsigned parameterCount() const { return m_unlinkedExecutable-&gt;parameterCount(); } // Excluding &#39;this&#39;!
165     SourceParseMode parseMode() const { return m_unlinkedExecutable-&gt;parseMode(); }
166     JSParserScriptMode scriptMode() const { return m_unlinkedExecutable-&gt;scriptMode(); }
167     SourceCode classSource() const { return m_unlinkedExecutable-&gt;classSource(); }
168 
169     static void visitChildren(JSCell*, SlotVisitor&amp;);
170     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue proto)
171     {
172         return Structure::create(vm, globalObject, proto, TypeInfo(FunctionExecutableType, StructureFlags), info());
173     }
174 
175     void setOverrideLineNumber(int overrideLineNumber)
176     {
177         if (overrideLineNumber == -1) {
178             if (UNLIKELY(m_rareData))
179                 m_rareData-&gt;m_overrideLineNumber = WTF::nullopt;
180             return;
181         }
182         ensureRareData().m_overrideLineNumber = overrideLineNumber;
183     }
184 
185     Optional&lt;int&gt; overrideLineNumber() const
186     {
187         if (UNLIKELY(m_rareData))
188             return m_rareData-&gt;m_overrideLineNumber;
189         return WTF::nullopt;
190     }
191 
192     int lineCount() const
193     {
194         if (UNLIKELY(m_rareData))
195             return m_rareData-&gt;m_lineCount;
196         return m_unlinkedExecutable-&gt;lineCount();
197     }
198 
199     int endColumn() const
200     {
201         if (UNLIKELY(m_rareData))
202             return m_rareData-&gt;m_endColumn;
203         return m_unlinkedExecutable-&gt;linkedEndColumn(m_source.startColumn().oneBasedInt());
204     }
205 
206     int firstLine() const
207     {
208         return source().firstLine().oneBasedInt();
209     }
210 
211     int lastLine() const
212     {
213         return firstLine() + lineCount();
214     }
215 
216     unsigned typeProfilingStartOffset(VM&amp;) const
217     {
218         return typeProfilingStartOffset();
219     }
220 
221     unsigned typeProfilingStartOffset() const
222     {
223         if (UNLIKELY(m_rareData))
224             return m_rareData-&gt;m_typeProfilingStartOffset;
225         return m_unlinkedExecutable-&gt;typeProfilingStartOffset();
226     }
227 
228     unsigned typeProfilingEndOffset(VM&amp;) const
229     {
230         return typeProfilingEndOffset();
231     }
232 
233     unsigned typeProfilingEndOffset() const
234     {
235         if (UNLIKELY(m_rareData))
236             return m_rareData-&gt;m_typeProfilingEndOffset;
237         return m_unlinkedExecutable-&gt;typeProfilingEndOffset();
238     }
239 
240     unsigned parametersStartOffset() const
241     {
242         if (UNLIKELY(m_rareData))
243             return m_rareData-&gt;m_parametersStartOffset;
244         return m_unlinkedExecutable-&gt;parametersStartOffset();
245     }
246 
247     void overrideInfo(const FunctionOverrideInfo&amp;);
248 
249     DECLARE_INFO;
250 
251     InferredValue&lt;JSFunction&gt;&amp; singleton()
252     {
253         return m_singleton;
254     }
255 
256     void notifyCreation(VM&amp; vm, JSFunction* function, const char* reason)
257     {
258         m_singleton.notifyWrite(vm, this, function, reason);
259     }
260 
261     // Cached poly proto structure for the result of constructing this executable.
262     Structure* cachedPolyProtoStructure()
263     {
264         if (UNLIKELY(m_rareData))
265             return m_rareData-&gt;m_cachedPolyProtoStructure.get();
266         return nullptr;
267     }
268     void setCachedPolyProtoStructure(VM&amp; vm, Structure* structure)
269     {
270         ensureRareData().m_cachedPolyProtoStructure.set(vm, this, structure);
271     }
272 
273     InlineWatchpointSet&amp; ensurePolyProtoWatchpoint()
274     {
275         if (!m_polyProtoWatchpoint)
276             m_polyProtoWatchpoint = Box&lt;InlineWatchpointSet&gt;::create(IsWatched);
277         return *m_polyProtoWatchpoint;
278     }
279 
280     Box&lt;InlineWatchpointSet&gt; sharedPolyProtoWatchpoint() const { return m_polyProtoWatchpoint; }
281 
282     ScriptExecutable* topLevelExecutable() const { return m_topLevelExecutable.get(); }
283 
284     TemplateObjectMap&amp; ensureTemplateObjectMap(VM&amp;);
285 
286     void finalizeUnconditionally(VM&amp;);
287 
288 private:
289     friend class ExecutableBase;
290     FunctionExecutable(VM&amp;, const SourceCode&amp;, UnlinkedFunctionExecutable*, Intrinsic);
291 
292     void finishCreation(VM&amp;, ScriptExecutable* topLevelExecutable);
293 
294     friend class ScriptExecutable;
295 
296     struct RareData {
297         WTF_MAKE_STRUCT_FAST_ALLOCATED;
298         RefPtr&lt;TypeSet&gt; m_returnStatementTypeSet;
299         unsigned m_lineCount;
300         unsigned m_endColumn;
301         Markable&lt;int, IntegralMarkableTraits&lt;int, -1&gt;&gt; m_overrideLineNumber;
302         unsigned m_parametersStartOffset { 0 };
303         unsigned m_typeProfilingStartOffset { UINT_MAX };
304         unsigned m_typeProfilingEndOffset { UINT_MAX };
305         std::unique_ptr&lt;TemplateObjectMap&gt; m_templateObjectMap;
306         WriteBarrier&lt;Structure&gt; m_cachedPolyProtoStructure;
307     };
308 
309     RareData&amp; ensureRareData()
310     {
311         if (LIKELY(m_rareData))
312             return *m_rareData;
313         return ensureRareDataSlow();
314     }
315     RareData&amp; ensureRareDataSlow();
316 
317     // FIXME: We can merge rareData pointer and top-level executable pointer. First time, setting parent.
318     // If RareData is required, materialize RareData, swap it, and store top-level executable pointer inside RareData.
319     // https://bugs.webkit.org/show_bug.cgi?id=197625
320     std::unique_ptr&lt;RareData&gt; m_rareData;
321     WriteBarrier&lt;ScriptExecutable&gt; m_topLevelExecutable;
322     WriteBarrier&lt;UnlinkedFunctionExecutable&gt; m_unlinkedExecutable;
323     WriteBarrier&lt;ExecutableToCodeBlockEdge&gt; m_codeBlockForCall;
324     WriteBarrier&lt;ExecutableToCodeBlockEdge&gt; m_codeBlockForConstruct;
325     InferredValue&lt;JSFunction&gt; m_singleton;
326     Box&lt;InlineWatchpointSet&gt; m_polyProtoWatchpoint;
327 };
328 
329 } // namespace JSC
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../linux/ResourceUsageOverlayLinux.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AsyncScrollingCoordinator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 48,11 ***</span>
  #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
  #include &quot;ScrollingStatePositionedNode.h&quot;
  #include &quot;ScrollingStateStickyNode.h&quot;
  #include &quot;ScrollingStateTree.h&quot;
  #include &quot;Settings.h&quot;
<span class="line-modified">! #include &quot;WheelEventTestTrigger.h&quot;</span>
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  
<span class="line-new-header">--- 48,11 ---</span>
  #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
  #include &quot;ScrollingStatePositionedNode.h&quot;
  #include &quot;ScrollingStateStickyNode.h&quot;
  #include &quot;ScrollingStateTree.h&quot;
  #include &quot;Settings.h&quot;
<span class="line-modified">! #include &quot;WheelEventTestMonitor.h&quot;</span>
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,19 ***</span>
  #if PLATFORM(COCOA)
      if (!coordinatesScrollingForFrameView(frameView))
          return;
  
      auto* page = frameView.frame().page();
<span class="line-modified">!     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) {</span>
<span class="line-modified">!         LOG(WheelEventTestTriggers, &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger=%d&quot;, page-&gt;expectsWheelEventTriggers());</span>
  
          auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
          if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))
              return;
  
          auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
<span class="line-modified">!         frameScrollingNode.setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());</span>
      }
  #else
      UNUSED_PARAM(frameView);
  #endif
  }
<span class="line-new-header">--- 135,19 ---</span>
  #if PLATFORM(COCOA)
      if (!coordinatesScrollingForFrameView(frameView))
          return;
  
      auto* page = frameView.frame().page();
<span class="line-modified">!     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents()) {</span>
<span class="line-modified">!         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger: &quot; &lt;&lt; page-&gt;isMonitoringWheelEvents());</span>
  
          auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
          if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))
              return;
  
          auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
<span class="line-modified">!         frameScrollingNode.setIsMonitoringWheelEvents(page-&gt;isMonitoringWheelEvents());</span>
      }
  #else
      UNUSED_PARAM(frameView);
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,21 ***</span>
          return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
      };
      frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
  }
  
<span class="line-modified">! void AsyncScrollingCoordinator::updateExpectsWheelEventTestTriggerWithFrameView(const FrameView&amp; frameView)</span>
  {
      auto* page = frameView.frame().page();
      if (!page)
          return;
  
      auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
      if (!node)
          return;
  
<span class="line-modified">!     node-&gt;setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());</span>
  }
  
  void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
  {
      if (!m_scrollingStateTree-&gt;rootStateNode())
<span class="line-new-header">--- 173,21 ---</span>
          return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
      };
      frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
  }
  
<span class="line-modified">! void AsyncScrollingCoordinator::updateIsMonitoringWheelEventsForFrameView(const FrameView&amp; frameView)</span>
  {
      auto* page = frameView.frame().page();
      if (!page)
          return;
  
      auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
      if (!node)
          return;
  
<span class="line-modified">!     node-&gt;setIsMonitoringWheelEvents(page-&gt;isMonitoringWheelEvents());</span>
  }
  
  void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
  {
      if (!m_scrollingStateTree-&gt;rootStateNode())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,11 ***</span>
      node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
      node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
      node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
  }
  
<span class="line-modified">! bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition)</span>
  {
      ASSERT(isMainThread());
      ASSERT(m_page);
  
      auto scrollingNodeID = scrollableArea.scrollingNodeID();
<span class="line-new-header">--- 228,11 ---</span>
      node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
      node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
      node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
  }
  
<span class="line-modified">! bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition, ScrollType scrollType, ScrollClamping clamping)</span>
  {
      ASSERT(isMainThread());
      ASSERT(m_page);
  
      auto scrollingNodeID = scrollableArea.scrollingNodeID();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,25 ***</span>
          return false;
  
      if (!coordinatesScrollingForFrameView(*frameView))
          return false;
  
<span class="line-modified">!     bool inPageCache = frameView-&gt;frame().document()-&gt;pageCacheState() != Document::NotInPageCache;</span>
      bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;
<span class="line-modified">!     if (inProgrammaticScroll || inPageCache)</span>
          updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);
  
<span class="line-modified">!     // If this frame view&#39;s document is being put into the page cache, we don&#39;t want to update our</span>
      // main frame scroll position. Just let the FrameView think that we did.
<span class="line-modified">!     if (inPageCache)</span>
          return true;
  
      auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));
      if (!stateNode)
          return false;
  
<span class="line-modified">!     stateNode-&gt;setRequestedScrollPosition(scrollPosition, inProgrammaticScroll);</span>
      return true;
  }
  
  void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()
  {
<span class="line-new-header">--- 244,27 ---</span>
          return false;
  
      if (!coordinatesScrollingForFrameView(*frameView))
          return false;
  
<span class="line-modified">!     bool inBackForwardCache = frameView-&gt;frame().document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache;</span>
      bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;
<span class="line-modified">!     if (inProgrammaticScroll || inBackForwardCache)</span>
          updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);
  
<span class="line-modified">!     ASSERT(inProgrammaticScroll == (scrollType == ScrollType::Programmatic));</span>
<span class="line-added">+ </span>
<span class="line-added">+     // If this frame view&#39;s document is being put into the back/forward cache, we don&#39;t want to update our</span>
      // main frame scroll position. Just let the FrameView think that we did.
<span class="line-modified">!     if (inBackForwardCache)</span>
          return true;
  
      auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));
      if (!stateNode)
          return false;
  
<span class="line-modified">!     stateNode-&gt;setRequestedScrollData({ scrollPosition, scrollType, clamping });</span>
      return true;
  }
  
  void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,41 ***</span>
  
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
  
      auto&amp; frameView = *frameViewPtr;
  
      if (scrollingNodeID == frameView.scrollingNodeID()) {
          reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(COCOA)</span>
<span class="line-removed">-         if (m_page-&gt;expectsWheelEventTriggers()) {</span>
<span class="line-removed">-             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());</span>
<span class="line-removed">-             if (const auto&amp; trigger = m_page-&gt;testTrigger())</span>
<span class="line-removed">-                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
          return;
      }
  
      // Overflow-scroll area.
      if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
          auto previousScrollType = scrollableArea-&gt;currentScrollType();
          scrollableArea-&gt;setCurrentScrollType(scrollType);
<span class="line-modified">!         scrollableArea-&gt;scrollToOffsetWithoutAnimation(ScrollableArea::scrollOffsetFromPosition(scrollPosition, toFloatSize(scrollableArea-&gt;scrollOrigin())));</span>
          scrollableArea-&gt;setCurrentScrollType(previousScrollType);
  
          if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
              m_page-&gt;editorClient().overflowScrollPositionChanged();
<span class="line-removed">- </span>
<span class="line-removed">- #if PLATFORM(COCOA)</span>
<span class="line-removed">-         if (m_page-&gt;expectsWheelEventTriggers()) {</span>
<span class="line-removed">-             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());</span>
<span class="line-removed">-             if (const auto&amp; trigger = m_page-&gt;testTrigger())</span>
<span class="line-removed">-                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- #endif</span>
      }
  }
  
  void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
  {
<span class="line-new-header">--- 343,29 ---</span>
  
      LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
  
      auto&amp; frameView = *frameViewPtr;
  
<span class="line-added">+     if (!frameViewPtr-&gt;frame().isMainFrame()) {</span>
<span class="line-added">+         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)</span>
<span class="line-added">+             m_page-&gt;editorClient().subFrameScrollPositionChanged();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (scrollingNodeID == frameView.scrollingNodeID()) {
          reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);
          return;
      }
  
      // Overflow-scroll area.
      if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
          auto previousScrollType = scrollableArea-&gt;currentScrollType();
          scrollableArea-&gt;setCurrentScrollType(scrollType);
<span class="line-modified">!         scrollableArea-&gt;notifyScrollPositionChanged(roundedIntPoint(scrollPosition));</span>
          scrollableArea-&gt;setCurrentScrollType(previousScrollType);
  
          if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
              m_page-&gt;editorClient().overflowScrollPositionChanged();
      }
  }
  
  void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 847,31 ***</span>
          scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
          scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
      }
  }
  
<span class="line-modified">! void AsyncScrollingCoordinator::deferTestsForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const</span>
  {
      ASSERT(isMainThread());
<span class="line-modified">!     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())</span>
          return;
  
<span class="line-modified">!     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {</span>
<span class="line-modified">!         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::deferTestsForReason: Deferring %p for reason %d.&quot;, identifier, reason);</span>
<span class="line-modified">!         trigger-&gt;deferTestsForReason(identifier, reason);</span>
      }
  }
  
<span class="line-modified">! void AsyncScrollingCoordinator::removeTestDeferralForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const</span>
  {
      ASSERT(isMainThread());
<span class="line-modified">!     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())</span>
          return;
  
<span class="line-modified">!     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {</span>
<span class="line-modified">!         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::removeTestDeferralForReason: Deferring %p for reason %d.&quot;, identifier, reason);</span>
<span class="line-modified">!         trigger-&gt;removeTestDeferralForReason(identifier, reason);</span>
      }
  }
  #endif
  
  #if ENABLE(CSS_SCROLL_SNAP)
<span class="line-new-header">--- 837,31 ---</span>
          scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
          scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
      }
  }
  
<span class="line-modified">! void AsyncScrollingCoordinator::deferWheelEventTestCompletionForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason) const</span>
  {
      ASSERT(isMainThread());
<span class="line-modified">!     if (!m_page || !m_page-&gt;isMonitoringWheelEvents())</span>
          return;
  
<span class="line-modified">!     if (const auto&amp; trigger = m_page-&gt;wheelEventTestMonitor()) {</span>
<span class="line-modified">!         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    (!) AsyncScrollingCoordinator::deferForReason: Deferring &quot; &lt;&lt; identifier &lt;&lt; &quot; for reason &quot; &lt;&lt; reason);</span>
<span class="line-modified">!         trigger-&gt;deferForReason(identifier, reason);</span>
      }
  }
  
<span class="line-modified">! void AsyncScrollingCoordinator::removeWheelEventTestCompletionDeferralForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason) const</span>
  {
      ASSERT(isMainThread());
<span class="line-modified">!     if (!m_page || !m_page-&gt;isMonitoringWheelEvents())</span>
          return;
  
<span class="line-modified">!     if (const auto&amp; trigger = m_page-&gt;wheelEventTestMonitor()) {</span>
<span class="line-modified">!         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    (!) AsyncScrollingCoordinator::removeWheelEventTestCompletionDeferralForReason: Deferring &quot; &lt;&lt; identifier &lt;&lt; &quot; for reason &quot; &lt;&lt; reason);</span>
<span class="line-modified">!         trigger-&gt;removeDeferralForReason(identifier, reason);</span>
      }
  }
  #endif
  
  #if ENABLE(CSS_SCROLL_SNAP)
</pre>
<center><a href="../linux/ResourceUsageOverlayLinux.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AsyncScrollingCoordinator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
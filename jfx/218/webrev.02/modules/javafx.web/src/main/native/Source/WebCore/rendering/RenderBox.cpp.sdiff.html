<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 550 int RenderBox::scrollHeight() const
 551 {
 552     if (hasOverflowClip() &amp;&amp; layer())
 553         return layer()-&gt;scrollHeight();
 554     // For objects with visible overflow, this matches IE.
 555     // FIXME: Need to work right with writing modes.
 556     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 557     return roundToInt(std::max(clientHeight(), layoutOverflowRect().maxY() - borderTop()));
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
<span class="line-modified"> 570 static void setupWheelEventTestTrigger(RenderLayer&amp; layer)</span>






 571 {
 572     Page&amp; page = layer.renderer().page();
<span class="line-modified"> 573     if (!page.expectsWheelEventTriggers())</span>
 574         return;
<span class="line-modified"> 575     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());</span>
 576 }
 577 
 578 void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
 579 {
 580     if (!hasOverflowClip() || !layer())
 581         return;
<span class="line-modified"> 582     setupWheelEventTestTrigger(*layer());</span>
 583     layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
 584 }
 585 
 586 void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
 587 {
 588     if (!hasOverflowClip() || !layer())
 589         return;
<span class="line-modified"> 590     setupWheelEventTestTrigger(*layer());</span>
 591     layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
 592 }
 593 
 594 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 595 {
 596     rects.append(snappedIntRect(accumulatedOffset, size()));
 597 }
 598 
 599 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 600 {
 601     FloatRect localRect(0, 0, width(), height());
 602 
 603     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 604     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 605         return;
 606 
 607     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 608 }
 609 
 610 void RenderBox::updateLayerTransform()
</pre>
<hr />
<pre>
 709         box = LayoutRect(containerRelativeQuad.boundingBox());
 710     }
 711 
 712     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 713     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 714     box.move(view().frameView().layoutContext().layoutDelta());
 715 
 716     return LayoutRect(snapRectToDevicePixels(box, document().deviceScaleFactor()));
 717 }
 718 
 719 void RenderBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
 720 {
 721     if (!size().isEmpty())
 722         rects.append(LayoutRect(additionalOffset, size()));
 723 }
 724 
 725 int RenderBox::reflectionOffset() const
 726 {
 727     if (!style().boxReflect())
 728         return 0;
<span class="line-modified"> 729     if (style().boxReflect()-&gt;direction() == ReflectionLeft || style().boxReflect()-&gt;direction() == ReflectionRight)</span>
 730         return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
 731     return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
 732 }
 733 
 734 LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
 735 {
 736     if (!style().boxReflect())
 737         return LayoutRect();
 738 
 739     LayoutRect box = borderBoxRect();
 740     LayoutRect result = r;
 741     switch (style().boxReflect()-&gt;direction()) {
<span class="line-modified"> 742         case ReflectionBelow:</span>
<span class="line-modified"> 743             result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));</span>
<span class="line-modified"> 744             break;</span>
<span class="line-modified"> 745         case ReflectionAbove:</span>
<span class="line-modified"> 746             result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));</span>
<span class="line-modified"> 747             break;</span>
<span class="line-modified"> 748         case ReflectionLeft:</span>
<span class="line-modified"> 749             result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));</span>
<span class="line-modified"> 750             break;</span>
<span class="line-modified"> 751         case ReflectionRight:</span>
<span class="line-modified"> 752             result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));</span>
<span class="line-modified"> 753             break;</span>
 754     }
 755     return result;
 756 }
 757 
 758 bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
 759 {
 760     return isFixedPositioned() &amp;&amp; container()-&gt;isRenderView() &amp;&amp; frameView.fixedElementsLayoutRelativeToFrame();
 761 }
 762 
 763 bool RenderBox::includeVerticalScrollbarSize() const
 764 {
 765     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 766         &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto);
 767 }
 768 
 769 bool RenderBox::includeHorizontalScrollbarSize() const
 770 {
 771     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 772         &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto);
 773 }
</pre>
<hr />
<pre>
1304         return;
1305 
1306     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1307     paintRect.moveBy(paintOffset);
1308     adjustBorderBoxRectForPainting(paintRect);
1309 
1310 #if PLATFORM(IOS_FAMILY)
1311     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
1312     // FIXME: Consolidate this code with the same code in RenderElement::paintOutline(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.
1313     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1314         int width = std::min(paintRect.width(), paintRect.height());
1315         int height = width;
1316         paintRect = IntRect { paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop
1317     }
1318 #endif
1319     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1320 
1321     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1322     // custom shadows of their own.
1323     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
<span class="line-modified">1324         paintBoxShadow(paintInfo, paintRect, style(), Normal);</span>
1325 
1326     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1327     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1328         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1329         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1330         // beginning the layer).
1331         stateSaver.save();
1332         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1333         paintInfo.context().beginTransparencyLayer(1);
1334     }
1335 
1336     // If we have a native theme appearance, paint that before painting our background.
1337     // The theme will tell us whether or not we should also paint the CSS background.
1338     bool borderOrBackgroundPaintingIsNeeded = true;
1339     if (style().hasAppearance()) {
1340         ControlStates* controlStates = controlStatesForRenderer(*this);
1341         borderOrBackgroundPaintingIsNeeded = theme().paint(*this, *controlStates, paintInfo, paintRect);
1342         if (controlStates-&gt;needsRepaint())
1343             view().scheduleLazyRepaint(*this);
1344     }
1345 
1346     if (borderOrBackgroundPaintingIsNeeded) {
1347         if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
1348             paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1349 
1350         paintBackground(paintInfo, paintRect, bleedAvoidance);
1351 
1352         if (style().hasAppearance())
1353             theme().paintDecorations(*this, paintInfo, paintRect);
1354     }
<span class="line-modified">1355     paintBoxShadow(paintInfo, paintRect, style(), Inset);</span>
1356 
1357     // The theme will tell us whether or not we should also paint the CSS border.
1358     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
1359         paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1360 
1361     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer)
1362         paintInfo.context().endTransparencyLayer();
1363 }
1364 
1365 bool RenderBox::paintsOwnBackground() const
1366 {
1367     if (isBody()) {
1368         // The &lt;body&gt; only paints its background if the root element has defined a background independent of the body,
1369         // or if the &lt;body&gt;&#39;s parent is not the document element&#39;s renderer (e.g. inside SVG foreignObject).
1370         auto documentElementRenderer = document().documentElement()-&gt;renderer();
1371         return !documentElementRenderer
1372             || documentElementRenderer-&gt;hasBackground()
1373             || (documentElementRenderer != parent());
1374     }
1375 
</pre>
<hr />
<pre>
1459         break;
1460     }
1461     return backgroundRect.contains(localRect);
1462 }
1463 
1464 static bool isCandidateForOpaquenessTest(const RenderBox&amp; childBox)
1465 {
1466     const RenderStyle&amp; childStyle = childBox.style();
1467     if (childStyle.position() != PositionType::Static &amp;&amp; childBox.containingBlock() != childBox.parent())
1468         return false;
1469     if (childStyle.visibility() != Visibility::Visible)
1470         return false;
1471     if (childStyle.shapeOutside())
1472         return false;
1473     if (!childBox.width() || !childBox.height())
1474         return false;
1475     if (RenderLayer* childLayer = childBox.layer()) {
1476         if (childLayer-&gt;isComposited())
1477             return false;
1478         // FIXME: Deal with z-index.
<span class="line-modified">1479         if (!childStyle.hasAutoZIndex())</span>
1480             return false;
1481         if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
1482             return false;
1483         if (!childBox.scrollPosition().isZero())
1484             return false;
1485     }
1486     return true;
1487 }
1488 
1489 bool RenderBox::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
1490 {
1491     if (!maxDepthToTest)
1492         return false;
1493 
1494     for (auto&amp; childBox : childrenOfType&lt;RenderBox&gt;(*this)) {
1495         if (!isCandidateForOpaquenessTest(childBox))
1496             continue;
1497         LayoutPoint childLocation = childBox.location();
1498         if (childBox.isRelativelyPositioned())
1499             childLocation.move(childBox.relativePositionOffset());
</pre>
<hr />
<pre>
1566     LayoutRect paintRect = LayoutRect(paintOffset, size());
1567     adjustBorderBoxRectForPainting(paintRect);
1568     paintMaskImages(paintInfo, paintRect);
1569 }
1570 
1571 void RenderBox::paintClippingMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1572 {
1573     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::ClippingMask || paintInfo.context().paintingDisabled())
1574         return;
1575 
1576     LayoutRect paintRect = LayoutRect(paintOffset, size());
1577     paintInfo.context().fillRect(snappedIntRect(paintRect), Color::black);
1578 }
1579 
1580 void RenderBox::paintMaskImages(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1581 {
1582     // Figure out if we need to push a transparency layer to render our mask.
1583     bool pushTransparencyLayer = false;
1584     bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
1585     bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">1586     CompositeOperator compositeOp = CompositeSourceOver;</span>
1587 
1588     bool allMaskImagesLoaded = true;
1589 
1590     if (!compositedMask || flattenCompositingLayers) {
1591         pushTransparencyLayer = true;
1592 
1593         // Don&#39;t render a masked element until all the mask images have loaded, to prevent a flash of unmasked content.
1594         if (auto* maskBoxImage = style().maskBoxImage().image())
1595             allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
1596 
1597         allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
1598 
<span class="line-modified">1599         paintInfo.context().setCompositeOperation(CompositeDestinationIn);</span>
1600         paintInfo.context().beginTransparencyLayer(1);
<span class="line-modified">1601         compositeOp = CompositeSourceOver;</span>
1602     }
1603 
1604     if (allMaskImagesLoaded) {
1605         paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
1606         paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
1607     }
1608 
1609     if (pushTransparencyLayer)
1610         paintInfo.context().endTransparencyLayer();
1611 }
1612 
1613 LayoutRect RenderBox::maskClipRect(const LayoutPoint&amp; paintOffset)
1614 {
1615     const NinePieceImage&amp; maskBoxImage = style().maskBoxImage();
1616     if (maskBoxImage.image()) {
1617         LayoutRect borderImageRect = borderBoxRect();
1618 
1619         // Apply outsets to the border box.
1620         borderImageRect.expand(style().maskBoxImageOutsets());
1621         return borderImageRect;
</pre>
<hr />
<pre>
1685     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1686         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1687             return true;
1688     }
1689     return false;
1690 }
1691 
1692 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1693 {
1694     if (!parent())
1695         return;
1696 
1697     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1698         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1699         repaint();
1700         return;
1701     }
1702 
1703     ShapeValue* shapeOutsideValue = style().shapeOutside();
1704     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="line-modified">1705         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();</span>
<span class="line-modified">1706         markShapeOutsideDependentsForLayout();</span>
<span class="line-modified">1707     }</span>



1708 
1709     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1710     if (!didFullRepaint)
1711         repaintLayerRectsForImage(image, style().maskLayers(), false);
1712 
1713     if (!isComposited())
1714         return;
1715 
1716     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1717         layer()-&gt;contentChanged(MaskImageChanged);
1718     if (layersUseImage(image, style().backgroundLayers()))
1719         layer()-&gt;contentChanged(BackgroundImageChanged);
1720 }
1721 
1722 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1723 {
1724     LayoutRect rendererRect;
1725     RenderBox* layerRenderer = nullptr;
1726 
1727     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
</pre>
<hr />
<pre>
4764     LayoutRect rect = layoutOverflowRectForPropagation(parentStyle);
4765     if (!parentStyle-&gt;isHorizontalWritingMode())
4766         return rect.transposedRect();
4767     return rect;
4768 }
4769 
4770 LayoutRect RenderBox::layoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4771 {
4772     // Only propagate interior layout overflow if we don&#39;t clip it.
4773     LayoutRect rect = borderBoxRect();
4774     if (!hasOverflowClip())
4775         rect.unite(layoutOverflowRect());
4776 
4777     bool hasTransform = this-&gt;hasTransform();
4778     if (isInFlowPositioned() || hasTransform) {
4779         // If we are relatively positioned or if we have a transform, then we have to convert
4780         // this rectangle into physical coordinates, apply relative positioning and transforms
4781         // to it, and then convert it back.
4782         flipForWritingMode(rect);
4783 
<span class="line-modified">4784         if (hasTransform)</span>
4785             rect = layer()-&gt;currentTransform().mapRect(rect);
4786 
4787         if (isInFlowPositioned())
4788             rect.move(offsetForInFlowPosition());
4789 
4790         // Now we need to flip back.
4791         flipForWritingMode(rect);
4792     }
4793 
4794     // If the writing modes of the child and parent match, then we don&#39;t have to
4795     // do anything fancy. Just return the result.
4796     if (parentStyle-&gt;writingMode() == style().writingMode())
4797         return rect;
4798 
4799     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4800     // in a particular axis, then we have to flip the rect along that axis.
4801     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4802         rect.setX(width() - rect.maxX());
4803     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4804         rect.setY(height() - rect.maxY());
</pre>
</td>
<td>
<hr />
<pre>
 550 int RenderBox::scrollHeight() const
 551 {
 552     if (hasOverflowClip() &amp;&amp; layer())
 553         return layer()-&gt;scrollHeight();
 554     // For objects with visible overflow, this matches IE.
 555     // FIXME: Need to work right with writing modes.
 556     // FIXME: This should use snappedIntSize() instead with absolute coordinates.
 557     return roundToInt(std::max(clientHeight(), layoutOverflowRect().maxY() - borderTop()));
 558 }
 559 
 560 int RenderBox::scrollLeft() const
 561 {
 562     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().x() : 0;
 563 }
 564 
 565 int RenderBox::scrollTop() const
 566 {
 567     return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
 568 }
 569 
<span class="line-modified"> 570 void RenderBox::resetLogicalHeightBeforeLayoutIfNeeded()</span>
<span class="line-added"> 571 {</span>
<span class="line-added"> 572     if (shouldResetLogicalHeightBeforeLayout() || (is&lt;RenderBlock&gt;(parent()) &amp;&amp; downcast&lt;RenderBlock&gt;(*parent()).shouldResetChildLogicalHeightBeforeLayout(*this)))</span>
<span class="line-added"> 573         setLogicalHeight(0_lu);</span>
<span class="line-added"> 574 }</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576 static void setupWheelEventMonitor(RenderLayer&amp; layer)</span>
 577 {
 578     Page&amp; page = layer.renderer().page();
<span class="line-modified"> 579     if (!page.isMonitoringWheelEvents())</span>
 580         return;
<span class="line-modified"> 581     layer.scrollAnimator().setWheelEventTestMonitor(page.wheelEventTestMonitor());</span>
 582 }
 583 
 584 void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
 585 {
 586     if (!hasOverflowClip() || !layer())
 587         return;
<span class="line-modified"> 588     setupWheelEventMonitor(*layer());</span>
 589     layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
 590 }
 591 
 592 void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
 593 {
 594     if (!hasOverflowClip() || !layer())
 595         return;
<span class="line-modified"> 596     setupWheelEventMonitor(*layer());</span>
 597     layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
 598 }
 599 
 600 void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 601 {
 602     rects.append(snappedIntRect(accumulatedOffset, size()));
 603 }
 604 
 605 void RenderBox::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 606 {
 607     FloatRect localRect(0, 0, width(), height());
 608 
 609     RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
 610     if (fragmentedFlow &amp;&amp; fragmentedFlow-&gt;absoluteQuadsForBox(quads, wasFixed, this, localRect.y(), localRect.maxY()))
 611         return;
 612 
 613     quads.append(localToAbsoluteQuad(localRect, UseTransforms, wasFixed));
 614 }
 615 
 616 void RenderBox::updateLayerTransform()
</pre>
<hr />
<pre>
 715         box = LayoutRect(containerRelativeQuad.boundingBox());
 716     }
 717 
 718     // FIXME: layoutDelta needs to be applied in parts before/after transforms and
 719     // repaint containers. https://bugs.webkit.org/show_bug.cgi?id=23308
 720     box.move(view().frameView().layoutContext().layoutDelta());
 721 
 722     return LayoutRect(snapRectToDevicePixels(box, document().deviceScaleFactor()));
 723 }
 724 
 725 void RenderBox::addFocusRingRects(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
 726 {
 727     if (!size().isEmpty())
 728         rects.append(LayoutRect(additionalOffset, size()));
 729 }
 730 
 731 int RenderBox::reflectionOffset() const
 732 {
 733     if (!style().boxReflect())
 734         return 0;
<span class="line-modified"> 735     if (style().boxReflect()-&gt;direction() == ReflectionDirection::Left || style().boxReflect()-&gt;direction() == ReflectionDirection::Right)</span>
 736         return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
 737     return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
 738 }
 739 
 740 LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
 741 {
 742     if (!style().boxReflect())
 743         return LayoutRect();
 744 
 745     LayoutRect box = borderBoxRect();
 746     LayoutRect result = r;
 747     switch (style().boxReflect()-&gt;direction()) {
<span class="line-modified"> 748     case ReflectionDirection::Below:</span>
<span class="line-modified"> 749         result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));</span>
<span class="line-modified"> 750         break;</span>
<span class="line-modified"> 751     case ReflectionDirection::Above:</span>
<span class="line-modified"> 752         result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));</span>
<span class="line-modified"> 753         break;</span>
<span class="line-modified"> 754     case ReflectionDirection::Left:</span>
<span class="line-modified"> 755         result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));</span>
<span class="line-modified"> 756         break;</span>
<span class="line-modified"> 757     case ReflectionDirection::Right:</span>
<span class="line-modified"> 758         result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));</span>
<span class="line-modified"> 759         break;</span>
 760     }
 761     return result;
 762 }
 763 
 764 bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
 765 {
 766     return isFixedPositioned() &amp;&amp; container()-&gt;isRenderView() &amp;&amp; frameView.fixedElementsLayoutRelativeToFrame();
 767 }
 768 
 769 bool RenderBox::includeVerticalScrollbarSize() const
 770 {
 771     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 772         &amp;&amp; (style().overflowY() == Overflow::Scroll || style().overflowY() == Overflow::Auto);
 773 }
 774 
 775 bool RenderBox::includeHorizontalScrollbarSize() const
 776 {
 777     return hasOverflowClip() &amp;&amp; layer() &amp;&amp; !layer()-&gt;hasOverlayScrollbars()
 778         &amp;&amp; (style().overflowX() == Overflow::Scroll || style().overflowX() == Overflow::Auto);
 779 }
</pre>
<hr />
<pre>
1310         return;
1311 
1312     LayoutRect paintRect = borderBoxRectInFragment(nullptr);
1313     paintRect.moveBy(paintOffset);
1314     adjustBorderBoxRectForPainting(paintRect);
1315 
1316 #if PLATFORM(IOS_FAMILY)
1317     // Workaround for &lt;rdar://problem/6209763&gt;. Force the painting bounds of checkboxes and radio controls to be square.
1318     // FIXME: Consolidate this code with the same code in RenderElement::paintOutline(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=194781&gt;.
1319     if (style().appearance() == CheckboxPart || style().appearance() == RadioPart) {
1320         int width = std::min(paintRect.width(), paintRect.height());
1321         int height = width;
1322         paintRect = IntRect { paintRect.x(), paintRect.y() + (this-&gt;height() - height) / 2, width, height }; // Vertically center the checkbox, like on desktop
1323     }
1324 #endif
1325     BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
1326 
1327     // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
1328     // custom shadows of their own.
1329     if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
<span class="line-modified">1330         paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Normal);</span>
1331 
1332     GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
1333     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
1334         // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
1335         // into a transparency layer, and then clip that in one go (which requires setting up the clip before
1336         // beginning the layer).
1337         stateSaver.save();
1338         paintInfo.context().clipRoundedRect(style().getRoundedBorderFor(paintRect).pixelSnappedRoundedRectForPainting(document().deviceScaleFactor()));
1339         paintInfo.context().beginTransparencyLayer(1);
1340     }
1341 
1342     // If we have a native theme appearance, paint that before painting our background.
1343     // The theme will tell us whether or not we should also paint the CSS background.
1344     bool borderOrBackgroundPaintingIsNeeded = true;
1345     if (style().hasAppearance()) {
1346         ControlStates* controlStates = controlStatesForRenderer(*this);
1347         borderOrBackgroundPaintingIsNeeded = theme().paint(*this, *controlStates, paintInfo, paintRect);
1348         if (controlStates-&gt;needsRepaint())
1349             view().scheduleLazyRepaint(*this);
1350     }
1351 
1352     if (borderOrBackgroundPaintingIsNeeded) {
1353         if (bleedAvoidance == BackgroundBleedBackgroundOverBorder)
1354             paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1355 
1356         paintBackground(paintInfo, paintRect, bleedAvoidance);
1357 
1358         if (style().hasAppearance())
1359             theme().paintDecorations(*this, paintInfo, paintRect);
1360     }
<span class="line-modified">1361     paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Inset);</span>
1362 
1363     // The theme will tell us whether or not we should also paint the CSS border.
1364     if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
1365         paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
1366 
1367     if (bleedAvoidance == BackgroundBleedUseTransparencyLayer)
1368         paintInfo.context().endTransparencyLayer();
1369 }
1370 
1371 bool RenderBox::paintsOwnBackground() const
1372 {
1373     if (isBody()) {
1374         // The &lt;body&gt; only paints its background if the root element has defined a background independent of the body,
1375         // or if the &lt;body&gt;&#39;s parent is not the document element&#39;s renderer (e.g. inside SVG foreignObject).
1376         auto documentElementRenderer = document().documentElement()-&gt;renderer();
1377         return !documentElementRenderer
1378             || documentElementRenderer-&gt;hasBackground()
1379             || (documentElementRenderer != parent());
1380     }
1381 
</pre>
<hr />
<pre>
1465         break;
1466     }
1467     return backgroundRect.contains(localRect);
1468 }
1469 
1470 static bool isCandidateForOpaquenessTest(const RenderBox&amp; childBox)
1471 {
1472     const RenderStyle&amp; childStyle = childBox.style();
1473     if (childStyle.position() != PositionType::Static &amp;&amp; childBox.containingBlock() != childBox.parent())
1474         return false;
1475     if (childStyle.visibility() != Visibility::Visible)
1476         return false;
1477     if (childStyle.shapeOutside())
1478         return false;
1479     if (!childBox.width() || !childBox.height())
1480         return false;
1481     if (RenderLayer* childLayer = childBox.layer()) {
1482         if (childLayer-&gt;isComposited())
1483             return false;
1484         // FIXME: Deal with z-index.
<span class="line-modified">1485         if (!childStyle.hasAutoUsedZIndex())</span>
1486             return false;
1487         if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
1488             return false;
1489         if (!childBox.scrollPosition().isZero())
1490             return false;
1491     }
1492     return true;
1493 }
1494 
1495 bool RenderBox::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
1496 {
1497     if (!maxDepthToTest)
1498         return false;
1499 
1500     for (auto&amp; childBox : childrenOfType&lt;RenderBox&gt;(*this)) {
1501         if (!isCandidateForOpaquenessTest(childBox))
1502             continue;
1503         LayoutPoint childLocation = childBox.location();
1504         if (childBox.isRelativelyPositioned())
1505             childLocation.move(childBox.relativePositionOffset());
</pre>
<hr />
<pre>
1572     LayoutRect paintRect = LayoutRect(paintOffset, size());
1573     adjustBorderBoxRectForPainting(paintRect);
1574     paintMaskImages(paintInfo, paintRect);
1575 }
1576 
1577 void RenderBox::paintClippingMask(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
1578 {
1579     if (!paintInfo.shouldPaintWithinRoot(*this) || style().visibility() != Visibility::Visible || paintInfo.phase != PaintPhase::ClippingMask || paintInfo.context().paintingDisabled())
1580         return;
1581 
1582     LayoutRect paintRect = LayoutRect(paintOffset, size());
1583     paintInfo.context().fillRect(snappedIntRect(paintRect), Color::black);
1584 }
1585 
1586 void RenderBox::paintMaskImages(const PaintInfo&amp; paintInfo, const LayoutRect&amp; paintRect)
1587 {
1588     // Figure out if we need to push a transparency layer to render our mask.
1589     bool pushTransparencyLayer = false;
1590     bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
1591     bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">1592     CompositeOperator compositeOp = CompositeOperator::SourceOver;</span>
1593 
1594     bool allMaskImagesLoaded = true;
1595 
1596     if (!compositedMask || flattenCompositingLayers) {
1597         pushTransparencyLayer = true;
1598 
1599         // Don&#39;t render a masked element until all the mask images have loaded, to prevent a flash of unmasked content.
1600         if (auto* maskBoxImage = style().maskBoxImage().image())
1601             allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
1602 
1603         allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
1604 
<span class="line-modified">1605         paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);</span>
1606         paintInfo.context().beginTransparencyLayer(1);
<span class="line-modified">1607         compositeOp = CompositeOperator::SourceOver;</span>
1608     }
1609 
1610     if (allMaskImagesLoaded) {
1611         paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
1612         paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
1613     }
1614 
1615     if (pushTransparencyLayer)
1616         paintInfo.context().endTransparencyLayer();
1617 }
1618 
1619 LayoutRect RenderBox::maskClipRect(const LayoutPoint&amp; paintOffset)
1620 {
1621     const NinePieceImage&amp; maskBoxImage = style().maskBoxImage();
1622     if (maskBoxImage.image()) {
1623         LayoutRect borderImageRect = borderBoxRect();
1624 
1625         // Apply outsets to the border box.
1626         borderImageRect.expand(style().maskBoxImageOutsets());
1627         return borderImageRect;
</pre>
<hr />
<pre>
1691     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
1692         if (layer-&gt;image() &amp;&amp; image == layer-&gt;image()-&gt;data())
1693             return true;
1694     }
1695     return false;
1696 }
1697 
1698 void RenderBox::imageChanged(WrappedImagePtr image, const IntRect*)
1699 {
1700     if (!parent())
1701         return;
1702 
1703     if ((style().borderImage().image() &amp;&amp; style().borderImage().image()-&gt;data() == image) ||
1704         (style().maskBoxImage().image() &amp;&amp; style().maskBoxImage().image()-&gt;data() == image)) {
1705         repaint();
1706         return;
1707     }
1708 
1709     ShapeValue* shapeOutsideValue = style().shapeOutside();
1710     if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="line-modified">1711         ShapeOutsideInfo&amp; info = ShapeOutsideInfo::ensureInfo(*this);</span>
<span class="line-modified">1712         if (!info.isComputingShape()) {</span>
<span class="line-modified">1713             info.markShapeAsDirty();</span>
<span class="line-added">1714             markShapeOutsideDependentsForLayout();</span>
<span class="line-added">1715         }</span>
<span class="line-added">1716      }</span>
1717 
1718     bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
1719     if (!didFullRepaint)
1720         repaintLayerRectsForImage(image, style().maskLayers(), false);
1721 
1722     if (!isComposited())
1723         return;
1724 
1725     if (layer()-&gt;hasCompositedMask() &amp;&amp; layersUseImage(image, style().maskLayers()))
1726         layer()-&gt;contentChanged(MaskImageChanged);
1727     if (layersUseImage(image, style().backgroundLayers()))
1728         layer()-&gt;contentChanged(BackgroundImageChanged);
1729 }
1730 
1731 bool RenderBox::repaintLayerRectsForImage(WrappedImagePtr image, const FillLayer&amp; layers, bool drawingBackground)
1732 {
1733     LayoutRect rendererRect;
1734     RenderBox* layerRenderer = nullptr;
1735 
1736     for (auto* layer = &amp;layers; layer; layer = layer-&gt;next()) {
</pre>
<hr />
<pre>
4773     LayoutRect rect = layoutOverflowRectForPropagation(parentStyle);
4774     if (!parentStyle-&gt;isHorizontalWritingMode())
4775         return rect.transposedRect();
4776     return rect;
4777 }
4778 
4779 LayoutRect RenderBox::layoutOverflowRectForPropagation(const RenderStyle* parentStyle) const
4780 {
4781     // Only propagate interior layout overflow if we don&#39;t clip it.
4782     LayoutRect rect = borderBoxRect();
4783     if (!hasOverflowClip())
4784         rect.unite(layoutOverflowRect());
4785 
4786     bool hasTransform = this-&gt;hasTransform();
4787     if (isInFlowPositioned() || hasTransform) {
4788         // If we are relatively positioned or if we have a transform, then we have to convert
4789         // this rectangle into physical coordinates, apply relative positioning and transforms
4790         // to it, and then convert it back.
4791         flipForWritingMode(rect);
4792 
<span class="line-modified">4793         if (hasTransform &amp;&amp; hasLayer())</span>
4794             rect = layer()-&gt;currentTransform().mapRect(rect);
4795 
4796         if (isInFlowPositioned())
4797             rect.move(offsetForInFlowPosition());
4798 
4799         // Now we need to flip back.
4800         flipForWritingMode(rect);
4801     }
4802 
4803     // If the writing modes of the child and parent match, then we don&#39;t have to
4804     // do anything fancy. Just return the result.
4805     if (parentStyle-&gt;writingMode() == style().writingMode())
4806         return rect;
4807 
4808     // We are putting ourselves into our parent&#39;s coordinate space.  If there is a flipped block mismatch
4809     // in a particular axis, then we have to flip the rect along that axis.
4810     if (style().writingMode() == RightToLeftWritingMode || parentStyle-&gt;writingMode() == RightToLeftWritingMode)
4811         rect.setX(width() - rect.maxX());
4812     else if (style().writingMode() == BottomToTopWritingMode || parentStyle-&gt;writingMode() == BottomToTopWritingMode)
4813         rect.setY(height() - rect.maxY());
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlockFlow.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
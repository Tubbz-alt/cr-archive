<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/SingleRootGraph.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SegmentedVector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SizeLimits.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/SingleRootGraph.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/FastMalloc.h&gt;
 29 #include &lt;wtf/GraphNodeWorklist.h&gt;
 30 #include &lt;wtf/Noncopyable.h&gt;
 31 #include &lt;wtf/StdLibExtras.h&gt;

 32 
 33 namespace WTF {
 34 
 35 template &lt;typename Graph&gt;
 36 class SingleRootGraphNode {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     // We use &quot;#root&quot; to refer to the synthetic root we have created.
 40     static const char* rootName() { return &quot;#root&quot;; };
 41 
 42     SingleRootGraphNode(typename Graph::Node node = typename Graph::Node())
 43         : m_node(node)
 44     {
 45     }
 46 
 47     static SingleRootGraphNode root()
 48     {
 49         SingleRootGraphNode result;
 50         result.m_node = 0;
 51         result.m_isRoot = true;
</pre>
<hr />
<pre>
268             Node node = this-&gt;node(i);
269             if (!node)
270                 continue;
271             out.print(dump(node), &quot;:\n&quot;);
272             out.print(&quot;    Preds: &quot;);
273             CommaPrinter comma;
274             for (Node predecessor : predecessors(node))
275                 out.print(comma, dump(predecessor));
276             out.print(&quot;\n&quot;);
277             out.print(&quot;    Succs: &quot;);
278             comma = CommaPrinter();
279             for (Node successor : successors(node))
280                 out.print(comma, dump(successor));
281             out.print(&quot;\n&quot;);
282         }
283     }
284 
285 private:
286     ALWAYS_INLINE void assertIsConsistent() const
287     {
<span class="line-modified">288 #if !ASSERT_DISABLED</span>
289         // We expect the roots() function to be idempotent while we&#39;re alive so we can cache
290         // the result in the constructor. If a user of this changes the result of its roots()
291         // function, it&#39;s expected that the user will create a new instance of this class.
292         List rootSuccessorList;
293         for (typename Graph::Node realRoot : m_graph.roots()) {
294             ASSERT(m_graph.predecessors(realRoot).isEmpty());
295             rootSuccessorList.append(realRoot);
296         }
297         ASSERT(rootSuccessorList.size());
298         ASSERT(rootSuccessorList == m_rootSuccessorList);
299 #endif
300     }
301 
302     Graph&amp; m_graph;
303     List m_rootSuccessorList;
304     typename Graph::Set m_rootSuccessorSet;
305 };
306 
307 } // namespace WTF
308 
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/FastMalloc.h&gt;
 29 #include &lt;wtf/GraphNodeWorklist.h&gt;
 30 #include &lt;wtf/Noncopyable.h&gt;
 31 #include &lt;wtf/StdLibExtras.h&gt;
<span class="line-added"> 32 #include &lt;wtf/StringPrintStream.h&gt;</span>
 33 
 34 namespace WTF {
 35 
 36 template &lt;typename Graph&gt;
 37 class SingleRootGraphNode {
 38     WTF_MAKE_FAST_ALLOCATED;
 39 public:
 40     // We use &quot;#root&quot; to refer to the synthetic root we have created.
 41     static const char* rootName() { return &quot;#root&quot;; };
 42 
 43     SingleRootGraphNode(typename Graph::Node node = typename Graph::Node())
 44         : m_node(node)
 45     {
 46     }
 47 
 48     static SingleRootGraphNode root()
 49     {
 50         SingleRootGraphNode result;
 51         result.m_node = 0;
 52         result.m_isRoot = true;
</pre>
<hr />
<pre>
269             Node node = this-&gt;node(i);
270             if (!node)
271                 continue;
272             out.print(dump(node), &quot;:\n&quot;);
273             out.print(&quot;    Preds: &quot;);
274             CommaPrinter comma;
275             for (Node predecessor : predecessors(node))
276                 out.print(comma, dump(predecessor));
277             out.print(&quot;\n&quot;);
278             out.print(&quot;    Succs: &quot;);
279             comma = CommaPrinter();
280             for (Node successor : successors(node))
281                 out.print(comma, dump(successor));
282             out.print(&quot;\n&quot;);
283         }
284     }
285 
286 private:
287     ALWAYS_INLINE void assertIsConsistent() const
288     {
<span class="line-modified">289 #if ASSERT_ENABLED</span>
290         // We expect the roots() function to be idempotent while we&#39;re alive so we can cache
291         // the result in the constructor. If a user of this changes the result of its roots()
292         // function, it&#39;s expected that the user will create a new instance of this class.
293         List rootSuccessorList;
294         for (typename Graph::Node realRoot : m_graph.roots()) {
295             ASSERT(m_graph.predecessors(realRoot).isEmpty());
296             rootSuccessorList.append(realRoot);
297         }
298         ASSERT(rootSuccessorList.size());
299         ASSERT(rootSuccessorList == m_rootSuccessorList);
300 #endif
301     }
302 
303     Graph&amp; m_graph;
304     List m_rootSuccessorList;
305     typename Graph::Set m_rootSuccessorSet;
306 };
307 
308 } // namespace WTF
309 
</pre>
</td>
</tr>
</table>
<center><a href="SegmentedVector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SizeLimits.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
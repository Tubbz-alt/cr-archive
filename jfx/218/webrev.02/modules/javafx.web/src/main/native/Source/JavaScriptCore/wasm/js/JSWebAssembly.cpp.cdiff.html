<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssembly.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSToWasmICCallee.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSWebAssembly.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssembly.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,21 ***</span>
  #include &quot;Exception.h&quot;
  #include &quot;FunctionPrototype.h&quot;
  #include &quot;JSCBuiltins.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSModuleNamespaceObject.h&quot;
<span class="line-modified">! #include &quot;JSPromiseDeferred.h&quot;</span>
  #include &quot;JSToWasm.h&quot;
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyModule.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;Options.h&quot;
<span class="line-modified">! #include &quot;PromiseDeferredTimer.h&quot;</span>
  #include &quot;StrongInlines.h&quot;
  #include &quot;ThrowScope.h&quot;
  #include &quot;WasmBBQPlan.h&quot;
  #include &quot;WasmToJS.h&quot;
  #include &quot;WasmWorklist.h&quot;
  #include &quot;WebAssemblyInstanceConstructor.h&quot;
  #include &quot;WebAssemblyModuleConstructor.h&quot;
  
<span class="line-new-header">--- 32,22 ---</span>
  #include &quot;Exception.h&quot;
  #include &quot;FunctionPrototype.h&quot;
  #include &quot;JSCBuiltins.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSModuleNamespaceObject.h&quot;
<span class="line-modified">! #include &quot;JSPromise.h&quot;</span>
  #include &quot;JSToWasm.h&quot;
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyModule.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;Options.h&quot;
<span class="line-modified">! #include &quot;PromiseTimer.h&quot;</span>
  #include &quot;StrongInlines.h&quot;
  #include &quot;ThrowScope.h&quot;
  #include &quot;WasmBBQPlan.h&quot;
<span class="line-added">+ #include &quot;WasmOperations.h&quot;</span>
  #include &quot;WasmToJS.h&quot;
  #include &quot;WasmWorklist.h&quot;
  #include &quot;WebAssemblyInstanceConstructor.h&quot;
  #include &quot;WebAssemblyModuleConstructor.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,13 ***</span>
  
  FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_CALLBACK_FOR_CONSTRUCTOR)
  
  #undef DEFINE_CALLBACK_FOR_CONSTRUCTOR
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyCompileFunc(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyInstantiateFunc(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyValidateFunc(ExecState*);</span>
  
  }
  
  #include &quot;JSWebAssembly.lut.h&quot;
  
<span class="line-new-header">--- 68,13 ---</span>
  
  FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_CALLBACK_FOR_CONSTRUCTOR)
  
  #undef DEFINE_CALLBACK_FOR_CONSTRUCTOR
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyCompileFunc(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyInstantiateFunc(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyValidateFunc(JSGlobalObject*, CallFrame*);</span>
  
  }
  
  #include &quot;JSWebAssembly.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,10 ***</span>
<span class="line-new-header">--- 83,11 ---</span>
  const ClassInfo JSWebAssembly::s_info = { &quot;WebAssembly&quot;, &amp;Base::s_info, &amp;webAssemblyTable, nullptr, CREATE_METHOD_TABLE(JSWebAssembly) };
  
  /* Source for JSWebAssembly.lut.h
  @begin webAssemblyTable
    CompileError    createWebAssemblyCompileError  DontEnum|PropertyCallback
<span class="line-added">+   Global          createWebAssemblyGlobal        DontEnum|PropertyCallback</span>
    Instance        createWebAssemblyInstance      DontEnum|PropertyCallback
    LinkError       createWebAssemblyLinkError     DontEnum|PropertyCallback
    Memory          createWebAssemblyMemory        DontEnum|PropertyCallback
    Module          createWebAssemblyModule        DontEnum|PropertyCallback
    RuntimeError    createWebAssemblyRuntimeError  DontEnum|PropertyCallback
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,292 ***</span>
  JSWebAssembly::JSWebAssembly(VM&amp; vm, Structure* structure)
      : JSNonFinalObject(vm, structure)
  {
  }
  
<span class="line-modified">! static void reject(ExecState* exec, CatchScope&amp; catchScope, JSPromiseDeferred* promise)</span>
  {
      Exception* exception = catchScope.exception();
      ASSERT(exception);
      catchScope.clearException();
<span class="line-modified">!     promise-&gt;reject(exec, exception-&gt;value());</span>
      CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, void());
  }
  
<span class="line-modified">! static void webAssemblyModuleValidateAsyncInternal(ExecState* exec, JSPromiseDeferred* promise, Vector&lt;uint8_t&gt;&amp;&amp; source)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
  
<span class="line-modified">!     vm.promiseDeferredTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
      Wasm::Module::validateAsync(&amp;vm.wasmContext, WTFMove(source), createSharedTask&lt;Wasm::Module::CallbackType&gt;([promise, globalObject, &amp;vm] (Wasm::Module::ValidationResult&amp;&amp; result) mutable {
<span class="line-modified">!         vm.promiseDeferredTimer-&gt;scheduleWorkSoon(promise, [promise, globalObject, result = WTFMove(result), &amp;vm] () mutable {</span>
              auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!             ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">-             JSValue module = JSWebAssemblyModule::createStub(vm, exec, globalObject-&gt;webAssemblyModuleStructure(), WTFMove(result));</span>
              if (UNLIKELY(scope.exception())) {
<span class="line-modified">!                 reject(exec, scope, promise);</span>
                  return;
              }
  
<span class="line-modified">!             promise-&gt;resolve(exec, module);</span>
              CLEAR_AND_RETURN_IF_EXCEPTION(scope, void());
          });
      }));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyCompileFunc(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
<span class="line-modified">!     JSPromiseDeferred* promise = JSPromiseDeferred::tryCreate(exec, globalObject);</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
  
      {
          auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!         Vector&lt;uint8_t&gt; source = createSourceBufferFromValue(vm, exec, exec-&gt;argument(0));</span>
  
          if (UNLIKELY(catchScope.exception()))
<span class="line-modified">!             reject(exec, catchScope, promise);</span>
          else
<span class="line-modified">!             webAssemblyModuleValidateAsyncInternal(exec, promise, WTFMove(source));</span>
  
<span class="line-modified">!         return JSValue::encode(promise-&gt;promise());</span>
      }
  }
  
  enum class Resolve { WithInstance, WithModuleRecord, WithModuleAndInstance };
<span class="line-modified">! static void resolve(VM&amp; vm, ExecState* exec, JSPromiseDeferred* promise, JSWebAssemblyInstance* instance, JSWebAssemblyModule* module, JSObject* importObject, Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; codeBlock, Resolve resolveKind, Wasm::CreationMode creationMode)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     instance-&gt;finalizeCreation(vm, exec, WTFMove(codeBlock), importObject, creationMode);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, reject(exec, scope, promise));</span>
  
      if (resolveKind == Resolve::WithInstance)
<span class="line-modified">!         promise-&gt;resolve(exec, instance);</span>
      else if (resolveKind == Resolve::WithModuleRecord) {
          auto* moduleRecord = instance-&gt;moduleNamespaceObject()-&gt;moduleRecord();
<span class="line-modified">!         if (Options::dumpModuleRecord())</span>
              moduleRecord-&gt;dump();
<span class="line-modified">!         promise-&gt;resolve(exec, moduleRecord);</span>
      } else {
<span class="line-modified">!         JSObject* result = constructEmptyObject(exec);</span>
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;module&quot;_s), module);
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;instance&quot;_s), instance);
<span class="line-modified">!         promise-&gt;resolve(exec, result);</span>
      }
      CLEAR_AND_RETURN_IF_EXCEPTION(scope, void());
  }
  
<span class="line-modified">! void JSWebAssembly::webAssemblyModuleValidateAsync(ExecState* exec, JSPromiseDeferred* promise, Vector&lt;uint8_t&gt;&amp;&amp; source)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     webAssemblyModuleValidateAsyncInternal(exec, promise, WTFMove(source));</span>
      CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, void());
  }
  
<span class="line-modified">! static void instantiate(VM&amp; vm, ExecState* exec, JSPromiseDeferred* promise, JSWebAssemblyModule* module, JSObject* importObject, const Identifier&amp; moduleKey, Resolve resolveKind, Wasm::CreationMode creationMode)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
      // In order to avoid potentially recompiling a module. We first gather all the import/memory information prior to compiling code.
<span class="line-modified">!     JSWebAssemblyInstance* instance = JSWebAssemblyInstance::create(vm, exec, moduleKey, module, importObject, exec-&gt;lexicalGlobalObject()-&gt;webAssemblyInstanceStructure(), Ref&lt;Wasm::Module&gt;(module-&gt;module()), creationMode);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, reject(exec, scope, promise));</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      // The instance keeps the module alive.
      dependencies.append(Strong&lt;JSCell&gt;(vm, instance));
      dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
<span class="line-modified">!     vm.promiseDeferredTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
      // Note: This completion task may or may not get called immediately.
      module-&gt;module().compileAsync(&amp;vm.wasmContext, instance-&gt;memoryMode(), createSharedTask&lt;Wasm::CodeBlock::CallbackType&gt;([promise, instance, module, importObject, resolveKind, creationMode, &amp;vm] (Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; refCodeBlock) mutable {
          RefPtr&lt;Wasm::CodeBlock&gt; codeBlock = WTFMove(refCodeBlock);
<span class="line-modified">!         vm.promiseDeferredTimer-&gt;scheduleWorkSoon(promise, [promise, instance, module, importObject, resolveKind, creationMode, &amp;vm, codeBlock = WTFMove(codeBlock)] () mutable {</span>
<span class="line-modified">!             ExecState* exec = instance-&gt;globalObject(vm)-&gt;globalExec();</span>
<span class="line-modified">!             resolve(vm, exec, promise, instance, module, importObject, codeBlock.releaseNonNull(), resolveKind, creationMode);</span>
          });
<span class="line-modified">!     }), &amp;Wasm::createJSToWasmWrapper, &amp;Wasm::wasmToJSException);</span>
  }
  
<span class="line-modified">! static void compileAndInstantiate(VM&amp; vm, ExecState* exec, JSPromiseDeferred* promise, const Identifier&amp; moduleKey, JSValue buffer, JSObject* importObject, Resolve resolveKind, Wasm::CreationMode creationMode)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">- </span>
      JSCell* moduleKeyCell = identifierToJSValue(vm, moduleKey).asCell();
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
      dependencies.append(Strong&lt;JSCell&gt;(vm, moduleKeyCell));
<span class="line-modified">!     vm.promiseDeferredTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
<span class="line-modified">!     Vector&lt;uint8_t&gt; source = createSourceBufferFromValue(vm, exec, buffer);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, reject(exec, scope, promise));</span>
  
      Wasm::Module::validateAsync(&amp;vm.wasmContext, WTFMove(source), createSharedTask&lt;Wasm::Module::CallbackType&gt;([promise, importObject, moduleKeyCell, globalObject, resolveKind, creationMode, &amp;vm] (Wasm::Module::ValidationResult&amp;&amp; result) mutable {
<span class="line-modified">!         vm.promiseDeferredTimer-&gt;scheduleWorkSoon(promise, [promise, importObject, moduleKeyCell, globalObject, result = WTFMove(result), resolveKind, creationMode, &amp;vm] () mutable {</span>
              auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!             ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">-             JSWebAssemblyModule* module = JSWebAssemblyModule::createStub(vm, exec, globalObject-&gt;webAssemblyModuleStructure(), WTFMove(result));</span>
              if (UNLIKELY(scope.exception()))
<span class="line-modified">!                 return reject(exec, scope, promise);</span>
  
<span class="line-modified">!             const Identifier moduleKey = JSValue(moduleKeyCell).toPropertyKey(exec);</span>
              if (UNLIKELY(scope.exception()))
<span class="line-modified">!                 return reject(exec, scope, promise);</span>
  
<span class="line-modified">!             instantiate(vm, exec, promise, module, importObject, moduleKey, resolveKind, creationMode);</span>
          });
      }));
  }
  
<span class="line-modified">! JSValue JSWebAssembly::instantiate(ExecState* exec, JSPromiseDeferred* promise, const Identifier&amp; moduleKey, JSValue argument)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     compileAndInstantiate(vm, exec, promise, moduleKey, argument, nullptr, Resolve::WithModuleRecord, Wasm::CreationMode::FromModuleLoader);</span>
<span class="line-modified">!     return promise-&gt;promise();</span>
  }
  
<span class="line-modified">! static void webAssemblyModuleInstantinateAsyncInternal(ExecState* exec, JSPromiseDeferred* promise, Vector&lt;uint8_t&gt;&amp;&amp; source, JSObject* importObject)</span>
  {
<span class="line-modified">!     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
      dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
<span class="line-modified">!     vm.promiseDeferredTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
      Wasm::Module::validateAsync(&amp;vm.wasmContext, WTFMove(source), createSharedTask&lt;Wasm::Module::CallbackType&gt;([promise, importObject, globalObject, &amp;vm] (Wasm::Module::ValidationResult&amp;&amp; result) mutable {
<span class="line-modified">!         vm.promiseDeferredTimer-&gt;scheduleWorkSoon(promise, [promise, importObject, globalObject, result = WTFMove(result), &amp;vm] () mutable {</span>
              auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!             ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">-             JSWebAssemblyModule* module = JSWebAssemblyModule::createStub(vm, exec, globalObject-&gt;webAssemblyModuleStructure(), WTFMove(result));</span>
              if (UNLIKELY(scope.exception()))
<span class="line-modified">!                 return reject(exec, scope, promise);</span>
  
<span class="line-modified">!             instantiate(vm, exec, promise, module, importObject, JSWebAssemblyInstance::createPrivateModuleKey(),  Resolve::WithModuleAndInstance, Wasm::CreationMode::FromJS);</span>
<span class="line-modified">!             CLEAR_AND_RETURN_IF_EXCEPTION(scope, reject(exec, scope, promise));</span>
          });
      }));
  }
  
<span class="line-modified">! void JSWebAssembly::webAssemblyModuleInstantinateAsync(ExecState* exec, JSPromiseDeferred* promise, Vector&lt;uint8_t&gt;&amp;&amp; source, JSObject* importedObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     webAssemblyModuleInstantinateAsyncInternal(exec, promise, WTFMove(source), importedObject);</span>
      CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, void());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyInstantiateFunc(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JSPromiseDeferred* promise = JSPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
  
      {
          auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         JSValue importArgument = exec-&gt;argument(1);</span>
          JSObject* importObject = importArgument.getObject();
          if (UNLIKELY(!importArgument.isUndefined() &amp;&amp; !importObject)) {
<span class="line-modified">!             promise-&gt;reject(exec, createTypeError(exec,</span>
                  &quot;second argument to WebAssembly.instantiate must be undefined or an Object&quot;_s, defaultSourceAppender, runtimeTypeForValue(vm, importArgument)));
<span class="line-modified">!             CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise-&gt;promise()));</span>
          } else {
<span class="line-modified">!             JSValue firstArgument = exec-&gt;argument(0);</span>
              if (auto* module = jsDynamicCast&lt;JSWebAssemblyModule*&gt;(vm, firstArgument))
<span class="line-modified">!                 instantiate(vm, exec, promise, module, importObject, JSWebAssemblyInstance::createPrivateModuleKey(), Resolve::WithInstance, Wasm::CreationMode::FromJS);</span>
              else
<span class="line-modified">!                 compileAndInstantiate(vm, exec, promise, JSWebAssemblyInstance::createPrivateModuleKey(), firstArgument, importObject, Resolve::WithModuleAndInstance, Wasm::CreationMode::FromJS);</span>
          }
  
<span class="line-modified">!         return JSValue::encode(promise-&gt;promise());</span>
      }
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyValidateFunc(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-removed">-     auto [base, byteSize] = getWasmBufferFromValue(exec, exec-&gt;argument(0));</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-removed">-     BBQPlan plan(&amp;vm.wasmContext, BBQPlan::Validation, Plan::dontFinalize());</span>
      // FIXME: We might want to throw an OOM exception here if we detect that something will OOM.
      // https://bugs.webkit.org/show_bug.cgi?id=166015
<span class="line-modified">!     return JSValue::encode(jsBoolean(plan.parseAndValidateModule(base, byteSize)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL webAssemblyCompileStreamingInternal(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     JSPromiseDeferred* promise = JSPromiseDeferred::tryCreate(exec, globalObject);</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
<span class="line-modified">!     vm.promiseDeferredTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;compileStreaming)
<span class="line-modified">!         globalObject-&gt;globalObjectMethodTable()-&gt;compileStreaming(globalObject, exec, promise, exec-&gt;argument(0));</span>
      else {
          // CompileStreaming is not supported in jsc, only in browser environment
          ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise-&gt;promise()));</span>
  
<span class="line-modified">!     return JSValue::encode(promise-&gt;promise());</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL webAssemblyInstantiateStreamingInternal(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
<span class="line-modified">!     JSPromiseDeferred* promise = JSPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
      {
          auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         JSValue importArgument = exec-&gt;argument(1);</span>
          JSObject* importObject = importArgument.getObject();
          if (UNLIKELY(!importArgument.isUndefined() &amp;&amp; !importObject)) {
<span class="line-modified">!             promise-&gt;reject(exec, createTypeError(exec,</span>
                  &quot;second argument to WebAssembly.instantiateStreaming must be undefined or an Object&quot;_s, defaultSourceAppender, runtimeTypeForValue(vm, importArgument)));
<span class="line-modified">!             CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise-&gt;promise()));</span>
          } else {
              if (globalObject-&gt;globalObjectMethodTable()-&gt;instantiateStreaming) {
                  Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
                  dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
                  dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
<span class="line-modified">!                 vm.promiseDeferredTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
                  // FIXME: &lt;http://webkit.org/b/184888&gt; if there&#39;s an importObject and it contains a Memory, then we can compile the module with the right memory type (fast or not) by looking at the memory&#39;s type.
<span class="line-modified">!                 globalObject-&gt;globalObjectMethodTable()-&gt;instantiateStreaming(globalObject, exec, promise, exec-&gt;argument(0), importObject);</span>
              } else {
                  // InstantiateStreaming is not supported in jsc, only in browser environment.
                  ASSERT_NOT_REACHED();
              }
          }
<span class="line-modified">!         CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise-&gt;promise()));</span>
  
<span class="line-modified">!         return JSValue::encode(promise-&gt;promise());</span>
      }
  }
  
  } // namespace JSC
  
<span class="line-new-header">--- 123,276 ---</span>
  JSWebAssembly::JSWebAssembly(VM&amp; vm, Structure* structure)
      : JSNonFinalObject(vm, structure)
  {
  }
  
<span class="line-modified">! static void reject(JSGlobalObject* globalObject, CatchScope&amp; catchScope, JSPromise* promise)</span>
  {
      Exception* exception = catchScope.exception();
      ASSERT(exception);
      catchScope.clearException();
<span class="line-modified">!     promise-&gt;reject(globalObject, exception-&gt;value());</span>
      CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, void());
  }
  
<span class="line-modified">! static void webAssemblyModuleValidateAsyncInternal(JSGlobalObject* globalObject, JSPromise* promise, Vector&lt;uint8_t&gt;&amp;&amp; source)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
  
<span class="line-modified">!     vm.promiseTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
      Wasm::Module::validateAsync(&amp;vm.wasmContext, WTFMove(source), createSharedTask&lt;Wasm::Module::CallbackType&gt;([promise, globalObject, &amp;vm] (Wasm::Module::ValidationResult&amp;&amp; result) mutable {
<span class="line-modified">!         vm.promiseTimer-&gt;scheduleWorkSoon(promise, [promise, globalObject, result = WTFMove(result), &amp;vm] () mutable {</span>
              auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!             JSValue module = JSWebAssemblyModule::createStub(vm, globalObject, globalObject-&gt;webAssemblyModuleStructure(), WTFMove(result));</span>
              if (UNLIKELY(scope.exception())) {
<span class="line-modified">!                 reject(globalObject, scope, promise);</span>
                  return;
              }
  
<span class="line-modified">!             promise-&gt;resolve(globalObject, module);</span>
              CLEAR_AND_RETURN_IF_EXCEPTION(scope, void());
          });
      }));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyCompileFunc(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
  
      {
          auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!         Vector&lt;uint8_t&gt; source = createSourceBufferFromValue(vm, globalObject, callFrame-&gt;argument(0));</span>
  
          if (UNLIKELY(catchScope.exception()))
<span class="line-modified">!             reject(globalObject, catchScope, promise);</span>
          else
<span class="line-modified">!             webAssemblyModuleValidateAsyncInternal(globalObject, promise, WTFMove(source));</span>
  
<span class="line-modified">!         return JSValue::encode(promise);</span>
      }
  }
  
  enum class Resolve { WithInstance, WithModuleRecord, WithModuleAndInstance };
<span class="line-modified">! static void resolve(VM&amp; vm, JSGlobalObject* globalObject, JSPromise* promise, JSWebAssemblyInstance* instance, JSWebAssemblyModule* module, JSObject* importObject, Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; codeBlock, Resolve resolveKind, Wasm::CreationMode creationMode)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     instance-&gt;finalizeCreation(vm, globalObject, WTFMove(codeBlock), importObject, creationMode);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, reject(globalObject, scope, promise));</span>
  
      if (resolveKind == Resolve::WithInstance)
<span class="line-modified">!         promise-&gt;resolve(globalObject, instance);</span>
      else if (resolveKind == Resolve::WithModuleRecord) {
          auto* moduleRecord = instance-&gt;moduleNamespaceObject()-&gt;moduleRecord();
<span class="line-modified">!         if (UNLIKELY(Options::dumpModuleRecord()))</span>
              moduleRecord-&gt;dump();
<span class="line-modified">!         promise-&gt;resolve(globalObject, moduleRecord);</span>
      } else {
<span class="line-modified">!         JSObject* result = constructEmptyObject(globalObject);</span>
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;module&quot;_s), module);
          result-&gt;putDirect(vm, Identifier::fromString(vm, &quot;instance&quot;_s), instance);
<span class="line-modified">!         promise-&gt;resolve(globalObject, result);</span>
      }
      CLEAR_AND_RETURN_IF_EXCEPTION(scope, void());
  }
  
<span class="line-modified">! void JSWebAssembly::webAssemblyModuleValidateAsync(JSGlobalObject* globalObject, JSPromise* promise, Vector&lt;uint8_t&gt;&amp;&amp; source)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     webAssemblyModuleValidateAsyncInternal(globalObject, promise, WTFMove(source));</span>
      CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, void());
  }
  
<span class="line-modified">! static void instantiate(VM&amp; vm, JSGlobalObject* globalObject, JSPromise* promise, JSWebAssemblyModule* module, JSObject* importObject, const Identifier&amp; moduleKey, Resolve resolveKind, Wasm::CreationMode creationMode)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
      // In order to avoid potentially recompiling a module. We first gather all the import/memory information prior to compiling code.
<span class="line-modified">!     JSWebAssemblyInstance* instance = JSWebAssemblyInstance::tryCreate(vm, globalObject, moduleKey, module, importObject, globalObject-&gt;webAssemblyInstanceStructure(), Ref&lt;Wasm::Module&gt;(module-&gt;module()), creationMode);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, reject(globalObject, scope, promise));</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      // The instance keeps the module alive.
      dependencies.append(Strong&lt;JSCell&gt;(vm, instance));
      dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
<span class="line-modified">!     vm.promiseTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
      // Note: This completion task may or may not get called immediately.
      module-&gt;module().compileAsync(&amp;vm.wasmContext, instance-&gt;memoryMode(), createSharedTask&lt;Wasm::CodeBlock::CallbackType&gt;([promise, instance, module, importObject, resolveKind, creationMode, &amp;vm] (Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; refCodeBlock) mutable {
          RefPtr&lt;Wasm::CodeBlock&gt; codeBlock = WTFMove(refCodeBlock);
<span class="line-modified">!         vm.promiseTimer-&gt;scheduleWorkSoon(promise, [promise, instance, module, importObject, resolveKind, creationMode, &amp;vm, codeBlock = WTFMove(codeBlock)] () mutable {</span>
<span class="line-modified">!             JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="line-modified">!             resolve(vm, globalObject, promise, instance, module, importObject, codeBlock.releaseNonNull(), resolveKind, creationMode);</span>
          });
<span class="line-modified">!     }));</span>
  }
  
<span class="line-modified">! static void compileAndInstantiate(VM&amp; vm, JSGlobalObject* globalObject, JSPromise* promise, const Identifier&amp; moduleKey, JSValue buffer, JSObject* importObject, Resolve resolveKind, Wasm::CreationMode creationMode)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      JSCell* moduleKeyCell = identifierToJSValue(vm, moduleKey).asCell();
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
      dependencies.append(Strong&lt;JSCell&gt;(vm, moduleKeyCell));
<span class="line-modified">!     vm.promiseTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
<span class="line-modified">!     Vector&lt;uint8_t&gt; source = createSourceBufferFromValue(vm, globalObject, buffer);</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, reject(globalObject, scope, promise));</span>
  
      Wasm::Module::validateAsync(&amp;vm.wasmContext, WTFMove(source), createSharedTask&lt;Wasm::Module::CallbackType&gt;([promise, importObject, moduleKeyCell, globalObject, resolveKind, creationMode, &amp;vm] (Wasm::Module::ValidationResult&amp;&amp; result) mutable {
<span class="line-modified">!         vm.promiseTimer-&gt;scheduleWorkSoon(promise, [promise, importObject, moduleKeyCell, globalObject, result = WTFMove(result), resolveKind, creationMode, &amp;vm] () mutable {</span>
              auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!             JSWebAssemblyModule* module = JSWebAssemblyModule::createStub(vm, globalObject, globalObject-&gt;webAssemblyModuleStructure(), WTFMove(result));</span>
              if (UNLIKELY(scope.exception()))
<span class="line-modified">!                 return reject(globalObject, scope, promise);</span>
  
<span class="line-modified">!             const Identifier moduleKey = JSValue(moduleKeyCell).toPropertyKey(globalObject);</span>
              if (UNLIKELY(scope.exception()))
<span class="line-modified">!                 return reject(globalObject, scope, promise);</span>
  
<span class="line-modified">!             instantiate(vm, globalObject, promise, module, importObject, moduleKey, resolveKind, creationMode);</span>
          });
      }));
  }
  
<span class="line-modified">! JSValue JSWebAssembly::instantiate(JSGlobalObject* globalObject, JSPromise* promise, const Identifier&amp; moduleKey, JSValue argument)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     compileAndInstantiate(vm, globalObject, promise, moduleKey, argument, nullptr, Resolve::WithModuleRecord, Wasm::CreationMode::FromModuleLoader);</span>
<span class="line-modified">!     return promise;</span>
  }
  
<span class="line-modified">! static void webAssemblyModuleInstantinateAsyncInternal(JSGlobalObject* globalObject, JSPromise* promise, Vector&lt;uint8_t&gt;&amp;&amp; source, JSObject* importObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
      dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
<span class="line-modified">!     vm.promiseTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
      Wasm::Module::validateAsync(&amp;vm.wasmContext, WTFMove(source), createSharedTask&lt;Wasm::Module::CallbackType&gt;([promise, importObject, globalObject, &amp;vm] (Wasm::Module::ValidationResult&amp;&amp; result) mutable {
<span class="line-modified">!         vm.promiseTimer-&gt;scheduleWorkSoon(promise, [promise, importObject, globalObject, result = WTFMove(result), &amp;vm] () mutable {</span>
              auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!             JSWebAssemblyModule* module = JSWebAssemblyModule::createStub(vm, globalObject, globalObject-&gt;webAssemblyModuleStructure(), WTFMove(result));</span>
              if (UNLIKELY(scope.exception()))
<span class="line-modified">!                 return reject(globalObject, scope, promise);</span>
  
<span class="line-modified">!             instantiate(vm, globalObject, promise, module, importObject, JSWebAssemblyInstance::createPrivateModuleKey(),  Resolve::WithModuleAndInstance, Wasm::CreationMode::FromJS);</span>
<span class="line-modified">!             CLEAR_AND_RETURN_IF_EXCEPTION(scope, reject(globalObject, scope, promise));</span>
          });
      }));
  }
  
<span class="line-modified">! void JSWebAssembly::webAssemblyModuleInstantinateAsync(JSGlobalObject* globalObject, JSPromise* promise, Vector&lt;uint8_t&gt;&amp;&amp; source, JSObject* importedObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     webAssemblyModuleInstantinateAsyncInternal(globalObject, promise, WTFMove(source), importedObject);</span>
      CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, void());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyInstantiateFunc(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-added">+     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
      {
          auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         JSValue importArgument = callFrame-&gt;argument(1);</span>
          JSObject* importObject = importArgument.getObject();
          if (UNLIKELY(!importArgument.isUndefined() &amp;&amp; !importObject)) {
<span class="line-modified">!             promise-&gt;reject(globalObject, createTypeError(globalObject,</span>
                  &quot;second argument to WebAssembly.instantiate must be undefined or an Object&quot;_s, defaultSourceAppender, runtimeTypeForValue(vm, importArgument)));
<span class="line-modified">!             CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise));</span>
          } else {
<span class="line-modified">!             JSValue firstArgument = callFrame-&gt;argument(0);</span>
              if (auto* module = jsDynamicCast&lt;JSWebAssemblyModule*&gt;(vm, firstArgument))
<span class="line-modified">!                 instantiate(vm, globalObject, promise, module, importObject, JSWebAssemblyInstance::createPrivateModuleKey(), Resolve::WithInstance, Wasm::CreationMode::FromJS);</span>
              else
<span class="line-modified">!                 compileAndInstantiate(vm, globalObject, promise, JSWebAssemblyInstance::createPrivateModuleKey(), firstArgument, importObject, Resolve::WithModuleAndInstance, Wasm::CreationMode::FromJS);</span>
          }
  
<span class="line-modified">!         return JSValue::encode(promise);</span>
      }
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL webAssemblyValidateFunc(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // FIXME: We might want to throw an OOM exception here if we detect that something will OOM.
      // https://bugs.webkit.org/show_bug.cgi?id=166015
<span class="line-modified">!     Vector&lt;uint8_t&gt; source = createSourceBufferFromValue(vm, globalObject, callFrame-&gt;argument(0));</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+     auto validationResult = Wasm::Module::validateSync(&amp;vm.wasmContext, WTFMove(source));</span>
<span class="line-added">+     return JSValue::encode(jsBoolean(validationResult.has_value()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL webAssemblyCompileStreamingInternal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
  
      Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
      dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
<span class="line-modified">!     vm.promiseTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;compileStreaming)
<span class="line-modified">!         globalObject-&gt;globalObjectMethodTable()-&gt;compileStreaming(globalObject, promise, callFrame-&gt;argument(0));</span>
      else {
          // CompileStreaming is not supported in jsc, only in browser environment
          ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise));</span>
  
<span class="line-modified">!     return JSValue::encode(promise);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL webAssemblyInstantiateStreamingInternal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     auto* promise = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
      {
          auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!         JSValue importArgument = callFrame-&gt;argument(1);</span>
          JSObject* importObject = importArgument.getObject();
          if (UNLIKELY(!importArgument.isUndefined() &amp;&amp; !importObject)) {
<span class="line-modified">!             promise-&gt;reject(globalObject, createTypeError(globalObject,</span>
                  &quot;second argument to WebAssembly.instantiateStreaming must be undefined or an Object&quot;_s, defaultSourceAppender, runtimeTypeForValue(vm, importArgument)));
<span class="line-modified">!             CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise));</span>
          } else {
              if (globalObject-&gt;globalObjectMethodTable()-&gt;instantiateStreaming) {
                  Vector&lt;Strong&lt;JSCell&gt;&gt; dependencies;
                  dependencies.append(Strong&lt;JSCell&gt;(vm, globalObject));
                  dependencies.append(Strong&lt;JSCell&gt;(vm, importObject));
<span class="line-modified">!                 vm.promiseTimer-&gt;addPendingPromise(vm, promise, WTFMove(dependencies));</span>
  
                  // FIXME: &lt;http://webkit.org/b/184888&gt; if there&#39;s an importObject and it contains a Memory, then we can compile the module with the right memory type (fast or not) by looking at the memory&#39;s type.
<span class="line-modified">!                 globalObject-&gt;globalObjectMethodTable()-&gt;instantiateStreaming(globalObject, promise, callFrame-&gt;argument(0), importObject);</span>
              } else {
                  // InstantiateStreaming is not supported in jsc, only in browser environment.
                  ASSERT_NOT_REACHED();
              }
          }
<span class="line-modified">!         CLEAR_AND_RETURN_IF_EXCEPTION(catchScope, JSValue::encode(promise));</span>
  
<span class="line-modified">!         return JSValue::encode(promise);</span>
      }
  }
  
  } // namespace JSC
  
</pre>
<center><a href="JSToWasmICCallee.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSWebAssembly.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
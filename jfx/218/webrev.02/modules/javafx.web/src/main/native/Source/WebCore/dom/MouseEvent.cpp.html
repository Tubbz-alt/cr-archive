<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/MouseEvent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2001 Peter Kelly (pmk@post.com)
  3  * Copyright (C) 2001 Tobias Anton (anton@stud.fbi.fh-darmstadt.de)
  4  * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5  * Copyright (C) 2003-2016 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;MouseEvent.h&quot;
 25 
 26 #include &quot;EventNames.h&quot;
 27 #include &quot;Frame.h&quot;
 28 #include &quot;FrameView.h&quot;
 29 #include &quot;HTMLIFrameElement.h&quot;
 30 #include &quot;JSDOMConvertInterface.h&quot;
 31 #include &quot;JSDOMConvertNullable.h&quot;
 32 #include &quot;JSEventTarget.h&quot;
 33 #include &quot;JSEventTargetCustom.h&quot;
 34 #include &quot;PlatformMouseEvent.h&quot;
 35 #include &quot;RuntimeApplicationChecks.h&quot;
 36 #include &lt;JavaScriptCore/CallFrame.h&gt;
 37 #include &lt;JavaScriptCore/JSGlobalObjectInlines.h&gt;
 38 #include &lt;wtf/IsoMallocInlines.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(MouseEvent);
 43 
 44 using namespace JSC;
 45 
 46 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; type, const MouseEventInit&amp; initializer)
 47 {
 48     return adoptRef(*new MouseEvent(type, initializer));
 49 }
 50 
 51 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; eventType, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, const PlatformMouseEvent&amp; event, int detail, Node* relatedTarget)
 52 {
 53     bool isMouseEnterOrLeave = eventType == eventNames().mouseenterEvent || eventType == eventNames().mouseleaveEvent;
 54     auto isCancelable = eventType != eventNames().mousemoveEvent &amp;&amp; !isMouseEnterOrLeave ? IsCancelable::Yes : IsCancelable::No;
 55     auto canBubble = !isMouseEnterOrLeave ? CanBubble::Yes : CanBubble::No;
 56     auto isComposed = !isMouseEnterOrLeave ? IsComposed::Yes : IsComposed::No;
 57 
 58     return MouseEvent::create(eventType, canBubble, isCancelable, isComposed, event.timestamp().approximateMonotonicTime(), WTFMove(view), detail,
 59         event.globalPosition(), event.position(),
 60 #if ENABLE(POINTER_LOCK)
 61         event.movementDelta(),
 62 #else
 63         { },
 64 #endif
 65         event.modifiers(), event.button(), event.buttons(), relatedTarget, event.force(), event.syntheticClickType());
 66 }
 67 
 68 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; type, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, MonotonicTime timestamp, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 69     const IntPoint&amp; screenLocation, const IntPoint&amp; windowLocation, const IntPoint&amp; movementDelta, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
 70     EventTarget* relatedTarget, double force, unsigned short syntheticClickType, IsSimulated isSimulated, IsTrusted isTrusted)
 71 {
 72     return adoptRef(*new MouseEvent(type, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail,
 73         screenLocation, windowLocation, movementDelta, modifiers, button, buttons, relatedTarget, force, syntheticClickType, isSimulated, isTrusted));
 74 }
 75 
 76 Ref&lt;MouseEvent&gt; MouseEvent::create(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 77     int screenX, int screenY, int clientX, int clientY, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
 78     unsigned short syntheticClickType, EventTarget* relatedTarget)
 79 {
 80     return adoptRef(*new MouseEvent(eventType, canBubble, isCancelable, isComposed, WTFMove(view), detail, { screenX, screenY }, { clientX, clientY }, modifiers, button, buttons, syntheticClickType, relatedTarget));
 81 }
 82 
 83 MouseEvent::MouseEvent() = default;
 84 
 85 MouseEvent::MouseEvent(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
 86     MonotonicTime timestamp, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
 87     const IntPoint&amp; screenLocation, const IntPoint&amp; windowLocation, const IntPoint&amp; movementDelta, OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons,
 88     EventTarget* relatedTarget, double force, unsigned short syntheticClickType, IsSimulated isSimulated, IsTrusted isTrusted)
 89     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, timestamp, WTFMove(view), detail, screenLocation, windowLocation, movementDelta, modifiers, isSimulated, isTrusted)
 90     , m_button(button == -2 ? 0 : button)
 91     , m_buttons(buttons)
 92     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
 93     , m_buttonDown(button != -2)
 94     , m_relatedTarget(relatedTarget)
 95     , m_force(force)
 96 {
 97 }
 98 
 99 MouseEvent::MouseEvent(const AtomString&amp; eventType, CanBubble canBubble, IsCancelable isCancelable, IsComposed isComposed,
100     RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail, const IntPoint&amp; screenLocation, const IntPoint&amp; clientLocation,
101     OptionSet&lt;Modifier&gt; modifiers, short button, unsigned short buttons, unsigned short syntheticClickType, EventTarget* relatedTarget)
102     : MouseRelatedEvent(eventType, canBubble, isCancelable, isComposed, MonotonicTime::now(), WTFMove(view), detail, screenLocation, { }, { }, modifiers, IsSimulated::No)
103     , m_button(button == -2 ? 0 : button)
104     , m_buttons(buttons)
105     , m_syntheticClickType(button == -2 ? 0 : syntheticClickType)
106     , m_buttonDown(button != -2)
107     , m_relatedTarget(relatedTarget)
108 {
109     initCoordinates(clientLocation);
110 }
111 
112 MouseEvent::MouseEvent(const AtomString&amp; eventType, const MouseEventInit&amp; initializer)
113     : MouseRelatedEvent(eventType, initializer)
114     , m_button(initializer.button == -2 ? 0 : initializer.button)
115     , m_buttons(initializer.buttons)
116     , m_buttonDown(initializer.button != -2)
117     , m_relatedTarget(initializer.relatedTarget)
118 {
119     initCoordinates({ initializer.clientX, initializer.clientY });
120 }
121 
122 MouseEvent::~MouseEvent() = default;
123 
124 void MouseEvent::initMouseEvent(const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail,
125     int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, EventTarget* relatedTarget)
126 {
127     if (isBeingDispatched())
128         return;
129 
130     initUIEvent(type, canBubble, cancelable, WTFMove(view), detail);
131 
132     m_screenLocation = IntPoint(screenX, screenY);
133     setModifierKeys(ctrlKey, altKey, shiftKey, metaKey);
134     m_button = button == -2 ? 0 : button;
135     m_syntheticClickType = 0;
136     m_buttonDown = button != -2;
137     m_relatedTarget = relatedTarget;
138 
139     initCoordinates(IntPoint(clientX, clientY));
140 
141     setIsSimulated(false);
142 }
143 
144 // FIXME: We need this quirk because iAd Producer is calling this function with a relatedTarget that is not an EventTarget (rdar://problem/30640101).
145 // We should remove this quirk when possible.
146 void MouseEvent::initMouseEventQuirk(JSGlobalObject&amp; state, ScriptExecutionContext&amp; scriptExecutionContext, const AtomString&amp; type, bool canBubble, bool cancelable, RefPtr&lt;WindowProxy&gt;&amp;&amp; view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, short button, JSValue relatedTargetValue)
147 {
148     EventTarget* relatedTarget = nullptr;
149 #if PLATFORM(MAC)
150     // Impacts iBooks too because of widgets generated by iAd Producer (rdar://problem/30797958).
151     if (MacApplication::isIAdProducer() || MacApplication::isIBooks()) {
152         // jsEventTargetCast() does not throw and will silently convert bad input to nullptr.
153         auto jsRelatedTarget = jsEventTargetCast(state.vm(), relatedTargetValue);
154         if (!jsRelatedTarget &amp;&amp; !relatedTargetValue.isUndefinedOrNull())
155             scriptExecutionContext.addConsoleMessage(MessageSource::JS, MessageLevel::Warning, &quot;Calling initMouseEvent() with a relatedTarget that is not an EventTarget is deprecated.&quot;_s);
156         relatedTarget = jsRelatedTarget ? &amp;jsRelatedTarget-&gt;wrapped() : nullptr;
157     } else {
158 #else
159     UNUSED_PARAM(scriptExecutionContext);
160 #endif
161         // This is what the bindings generator would have produced.
162         auto throwScope = DECLARE_THROW_SCOPE(state.vm());
163         relatedTarget = convert&lt;IDLNullable&lt;IDLInterface&lt;EventTarget&gt;&gt;&gt;(state, relatedTargetValue, [](JSGlobalObject&amp; state, ThrowScope&amp; scope) {
164             throwArgumentTypeError(state, scope, 14, &quot;relatedTarget&quot;, &quot;MouseEvent&quot;, &quot;initMouseEvent&quot;, &quot;EventTarget&quot;);
165         });
166         RETURN_IF_EXCEPTION(throwScope, void());
167 #if PLATFORM(MAC)
168     }
169 #endif
170     initMouseEvent(type, canBubble, cancelable, WTFMove(view), detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
171 }
172 
173 EventInterface MouseEvent::eventInterface() const
174 {
175     return MouseEventInterfaceType;
176 }
177 
178 bool MouseEvent::isMouseEvent() const
179 {
180     return true;
181 }
182 
183 bool MouseEvent::canTriggerActivationBehavior(const Event&amp; event)
184 {
185     return event.type() == eventNames().clickEvent &amp;&amp; (!is&lt;MouseEvent&gt;(event) || downcast&lt;MouseEvent&gt;(event).button() != RightButton);
186 }
187 
188 int MouseEvent::which() const
189 {
190     // For the DOM, the return values for left, middle and right mouse buttons are 0, 1, 2, respectively.
191     // For the Netscape &quot;which&quot; property, the return values for left, middle and right mouse buttons are 1, 2, 3, respectively.
192     // So we must add 1.
193     if (!m_buttonDown)
194         return 0;
195     return m_button + 1;
196 }
197 
198 RefPtr&lt;Node&gt; MouseEvent::toElement() const
199 {
200     // MSIE extension - &quot;the object toward which the user is moving the mouse pointer&quot;
201     EventTarget* target;
202     if (type() == eventNames().mouseoutEvent || type() == eventNames().mouseleaveEvent)
203         target = relatedTarget();
204     else
205         target = this-&gt;target();
206     return is&lt;Node&gt;(target) ? &amp;downcast&lt;Node&gt;(*target) : nullptr;
207 }
208 
209 RefPtr&lt;Node&gt; MouseEvent::fromElement() const
210 {
211     // MSIE extension - &quot;object from which activation or the mouse pointer is exiting during the event&quot; (huh?)
212     EventTarget* target;
213     if (type() == eventNames().mouseoutEvent || type() == eventNames().mouseleaveEvent)
214         target = this-&gt;target();
215     else
216         target = relatedTarget();
217     return is&lt;Node&gt;(target) ? &amp;downcast&lt;Node&gt;(*target) : nullptr;
218 }
219 
220 } // namespace WebCore
    </pre>
  </body>
</html>
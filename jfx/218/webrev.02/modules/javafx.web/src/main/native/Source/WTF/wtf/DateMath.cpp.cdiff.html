<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DataLog.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DateMath.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2009 Google Inc. All rights reserved.
   * Copyright (C) 2007-2009 Torch Mobile, Inc.
   * Copyright (C) 2010 &amp;yet, LLC. (nate@andyet.net)
   *
   * The Original Code is Mozilla Communicator client code, released
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<span class="line-modified">!  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2009 Google Inc. All rights reserved.
   * Copyright (C) 2007-2009 Torch Mobile, Inc.
   * Copyright (C) 2010 &amp;yet, LLC. (nate@andyet.net)
   *
   * The Original Code is Mozilla Communicator client code, released
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,19 ***</span>
      return equalLettersIgnoringASCIICase(string, lowercaseLetters, length - 1);
  }
  
  /* Constants */
  
<span class="line-modified">! static const double maxUnixTime = 2145859200.0; // 12/31/2037</span>
<span class="line-modified">! // ECMAScript asks not to support for a date of which total</span>
<span class="line-modified">! // millisecond value is larger than the following value.</span>
<span class="line-removed">- // See 15.9.1.14 of ECMA-262 5th edition.</span>
<span class="line-removed">- static const double maxECMAScriptTime = 8.64E15;</span>
  
  // Day of year for the first day of each month, where index 0 is January, and day 0 is January 1.
  // First for non-leap years, then for leap years.
<span class="line-modified">! static const int firstDayOfMonth[2][12] = {</span>
      {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
      {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
  };
  
  #if !OS(WINDOWS) || HAVE(TM_GMTOFF)
<span class="line-new-header">--- 107,17 ---</span>
      return equalLettersIgnoringASCIICase(string, lowercaseLetters, length - 1);
  }
  
  /* Constants */
  
<span class="line-modified">! const char* const weekdayName[7] = { &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot; };</span>
<span class="line-modified">! const char* const monthName[12] = { &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; };</span>
<span class="line-modified">! const char* const monthFullName[12] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };</span>
  
  // Day of year for the first day of each month, where index 0 is January, and day 0 is January 1.
  // First for non-leap years, then for leap years.
<span class="line-modified">! const int firstDayOfMonth[2][12] = {</span>
      {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
      {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
  };
  
  #if !OS(WINDOWS) || HAVE(TM_GMTOFF)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 131,189 ***</span>
      localtime_s(localTime, localTM);
  #endif
  }
  #endif
  
<span class="line-removed">- bool isLeapYear(int year)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (year % 4 != 0)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     if (year % 400 == 0)</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     if (year % 100 == 0)</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline int daysInYear(int year)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return 365 + isLeapYear(year);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline double daysFrom1970ToYear(int year)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // The Gregorian Calendar rules for leap years:</span>
<span class="line-removed">-     // Every fourth year is a leap year.  2004, 2008, and 2012 are leap years.</span>
<span class="line-removed">-     // However, every hundredth year is not a leap year.  1900 and 2100 are not leap years.</span>
<span class="line-removed">-     // Every four hundred years, there&#39;s a leap year after all.  2000 and 2400 are leap years.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static const int leapDaysBefore1971By4Rule = 1970 / 4;</span>
<span class="line-removed">-     static const int excludedLeapDaysBefore1971By100Rule = 1970 / 100;</span>
<span class="line-removed">-     static const int leapDaysBefore1971By400Rule = 1970 / 400;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const double yearMinusOne = year - 1;</span>
<span class="line-removed">-     const double yearsToAddBy4Rule = floor(yearMinusOne / 4.0) - leapDaysBefore1971By4Rule;</span>
<span class="line-removed">-     const double yearsToExcludeBy100Rule = floor(yearMinusOne / 100.0) - excludedLeapDaysBefore1971By100Rule;</span>
<span class="line-removed">-     const double yearsToAddBy400Rule = floor(yearMinusOne / 400.0) - leapDaysBefore1971By400Rule;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return 365.0 * (year - 1970.0) + yearsToAddBy4Rule - yearsToExcludeBy100Rule + yearsToAddBy400Rule;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- double msToDays(double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return floor(ms / msPerDay);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static void appendTwoDigitNumber(StringBuilder&amp; builder, int number)
  {
      ASSERT(number &gt;= 0);
      ASSERT(number &lt; 100);
      builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number / 10));
      builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number % 10));
  }
  
<span class="line-removed">- int msToYear(double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     int approxYear = static_cast&lt;int&gt;(floor(ms / (msPerDay * 365.2425)) + 1970);</span>
<span class="line-removed">-     double msFromApproxYearTo1970 = msPerDay * daysFrom1970ToYear(approxYear);</span>
<span class="line-removed">-     if (msFromApproxYearTo1970 &gt; ms)</span>
<span class="line-removed">-         return approxYear - 1;</span>
<span class="line-removed">-     if (msFromApproxYearTo1970 + msPerDay * daysInYear(approxYear) &lt;= ms)</span>
<span class="line-removed">-         return approxYear + 1;</span>
<span class="line-removed">-     return approxYear;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int dayInYear(double ms, int year)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return static_cast&lt;int&gt;(msToDays(ms) - daysFrom1970ToYear(year));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  static inline double msToMilliseconds(double ms)
  {
      double result = fmod(ms, msPerDay);
      if (result &lt; 0)
          result += msPerDay;
      return result;
  }
  
<span class="line-removed">- int msToMinutes(double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     double result = fmod(floor(ms / msPerMinute), minutesPerHour);</span>
<span class="line-removed">-     if (result &lt; 0)</span>
<span class="line-removed">-         result += minutesPerHour;</span>
<span class="line-removed">-     return static_cast&lt;int&gt;(result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int msToHours(double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     double result = fmod(floor(ms/msPerHour), hoursPerDay);</span>
<span class="line-removed">-     if (result &lt; 0)</span>
<span class="line-removed">-         result += hoursPerDay;</span>
<span class="line-removed">-     return static_cast&lt;int&gt;(result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int monthFromDayInYear(int dayInYear, bool leapYear)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     const int d = dayInYear;</span>
<span class="line-removed">-     int step;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (d &lt; (step = 31))</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     step += (leapYear ? 29 : 28);</span>
<span class="line-removed">-     if (d &lt; step)</span>
<span class="line-removed">-         return 1;</span>
<span class="line-removed">-     if (d &lt; (step += 31))</span>
<span class="line-removed">-         return 2;</span>
<span class="line-removed">-     if (d &lt; (step += 30))</span>
<span class="line-removed">-         return 3;</span>
<span class="line-removed">-     if (d &lt; (step += 31))</span>
<span class="line-removed">-         return 4;</span>
<span class="line-removed">-     if (d &lt; (step += 30))</span>
<span class="line-removed">-         return 5;</span>
<span class="line-removed">-     if (d &lt; (step += 31))</span>
<span class="line-removed">-         return 6;</span>
<span class="line-removed">-     if (d &lt; (step += 31))</span>
<span class="line-removed">-         return 7;</span>
<span class="line-removed">-     if (d &lt; (step += 30))</span>
<span class="line-removed">-         return 8;</span>
<span class="line-removed">-     if (d &lt; (step += 31))</span>
<span class="line-removed">-         return 9;</span>
<span class="line-removed">-     if (d &lt; (step += 30))</span>
<span class="line-removed">-         return 10;</span>
<span class="line-removed">-     return 11;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline bool checkMonth(int dayInYear, int&amp; startDayOfThisMonth, int&amp; startDayOfNextMonth, int daysInThisMonth)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     startDayOfThisMonth = startDayOfNextMonth;</span>
<span class="line-removed">-     startDayOfNextMonth += daysInThisMonth;</span>
<span class="line-removed">-     return (dayInYear &lt;= startDayOfNextMonth);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int dayInMonthFromDayInYear(int dayInYear, bool leapYear)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     const int d = dayInYear;</span>
<span class="line-removed">-     int step;</span>
<span class="line-removed">-     int next = 30;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (d &lt;= next)</span>
<span class="line-removed">-         return d + 1;</span>
<span class="line-removed">-     const int daysInFeb = (leapYear ? 29 : 28);</span>
<span class="line-removed">-     if (checkMonth(d, step, next, daysInFeb))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 31))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     if (checkMonth(d, step, next, 30))</span>
<span class="line-removed">-         return d - step;</span>
<span class="line-removed">-     step = next;</span>
<span class="line-removed">-     return d - step;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int dayInYear(int year, int month, int day)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return firstDayOfMonth[isLeapYear(year)][month] + day - 1;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- double dateToDaysFrom1970(int year, int month, int day)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     year += month / 12;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     month %= 12;</span>
<span class="line-removed">-     if (month &lt; 0) {</span>
<span class="line-removed">-         month += 12;</span>
<span class="line-removed">-         --year;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     double yearday = floor(daysFrom1970ToYear(year));</span>
<span class="line-removed">-     ASSERT((year &gt;= 1970 &amp;&amp; yearday &gt;= 0) || (year &lt; 1970 &amp;&amp; yearday &lt; 0));</span>
<span class="line-removed">-     return yearday + dayInYear(year, month, day);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // There is a hard limit at 2038 that we currently do not have a workaround
  // for (rdar://problem/5052975).
  static inline int maximumYearForDST()
  {
      return 2037;
<span class="line-new-header">--- 129,26 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,13 ***</span>
  #endif
  
  #if HAVE(TIMEGM)
      time_t utcOffset = timegm(&amp;localt) - mktime(&amp;localt);
  #else
<span class="line-modified">!     // Using a canned date of 01/01/2009 on platforms with weaker date-handling foo.</span>
<span class="line-modified">!     localt.tm_year = 109;</span>
<span class="line-modified">!     time_t utcOffset = 1230768000 - mktime(&amp;localt);</span>
  #endif
  
      return static_cast&lt;int32_t&gt;(utcOffset * 1000);
  #endif
  }
<span class="line-new-header">--- 267,13 ---</span>
  #endif
  
  #if HAVE(TIMEGM)
      time_t utcOffset = timegm(&amp;localt) - mktime(&amp;localt);
  #else
<span class="line-modified">!     // Using a canned date of 01/01/2019 on platforms with weaker date-handling foo.</span>
<span class="line-modified">!     localt.tm_year = 119;</span>
<span class="line-modified">!     time_t utcOffset = 1546300800 - mktime(&amp;localt);</span>
  #endif
  
      return static_cast&lt;int32_t&gt;(utcOffset * 1000);
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 540,11 ***</span>
  #endif
  }
  
  void initializeDates()
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      static bool alreadyInitialized;
      ASSERT(!alreadyInitialized);
      alreadyInitialized = true;
  #endif
  
<span class="line-new-header">--- 375,11 ---</span>
  #endif
  }
  
  void initializeDates()
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
      static bool alreadyInitialized;
      ASSERT(!alreadyInitialized);
      alreadyInitialized = true;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 681,15 ***</span>
      if ((postParsePosition - currentPosition) != 2)
          return 0;
      return postParsePosition;
  }
  
<span class="line-modified">! // Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)00:00].</span>
  // Fractional seconds parsing is lenient, allows any number of digits.
  // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
<span class="line-modified">! static char* parseES5TimePortion(char* currentPosition, long&amp; hours, long&amp; minutes, double&amp; seconds, long&amp; timeZoneSeconds)</span>
  {
      char* postParsePosition;
      if (!isASCIIDigit(*currentPosition))
          return 0;
      if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;hours))
          return 0;
<span class="line-new-header">--- 516,17 ---</span>
      if ((postParsePosition - currentPosition) != 2)
          return 0;
      return postParsePosition;
  }
  
<span class="line-modified">! // Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)].</span>
  // Fractional seconds parsing is lenient, allows any number of digits.
  // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
<span class="line-modified">! static char* parseES5TimePortion(char* currentPosition, long&amp; hours, long&amp; minutes, double&amp; seconds, bool&amp; isLocalTime, long&amp; timeZoneSeconds)</span>
  {
<span class="line-added">+     isLocalTime = false;</span>
<span class="line-added">+ </span>
      char* postParsePosition;
      if (!isASCIIDigit(*currentPosition))
          return 0;
      if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;hours))
          return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 738,38 ***</span>
      }
  
      if (*currentPosition == &#39;Z&#39;)
          return currentPosition + 1;
  
      bool tzNegative;
      if (*currentPosition == &#39;-&#39;)
          tzNegative = true;
      else if (*currentPosition == &#39;+&#39;)
          tzNegative = false;
<span class="line-modified">!     else</span>
<span class="line-modified">!         return currentPosition; // no timezone</span>
      ++currentPosition;
  
<span class="line-modified">!     long tzHours;</span>
<span class="line-modified">!     long tzHoursAbs;</span>
<span class="line-modified">!     long tzMinutes;</span>
  
      if (!isASCIIDigit(*currentPosition))
          return 0;
      if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzHours))
          return 0;
<span class="line-modified">!     if (*postParsePosition != &#39;:&#39; || (postParsePosition - currentPosition) != 2)</span>
<span class="line-modified">!         return 0;</span>
<span class="line-modified">!     tzHoursAbs = labs(tzHours);</span>
<span class="line-modified">!     currentPosition = postParsePosition + 1;</span>
  
<span class="line-modified">!     if (!isASCIIDigit(*currentPosition))</span>
<span class="line-modified">!         return 0;</span>
<span class="line-modified">!     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzMinutes))</span>
<span class="line-modified">!         return 0;</span>
<span class="line-modified">!     if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-modified">!         return 0;</span>
      currentPosition = postParsePosition;
  
      if (tzHoursAbs &gt; 24)
          return 0;
      if (tzMinutes &lt; 0 || tzMinutes &gt; 59)
<span class="line-new-header">--- 575,55 ---</span>
      }
  
      if (*currentPosition == &#39;Z&#39;)
          return currentPosition + 1;
  
<span class="line-added">+     // Parse (+|-)(00:00|0000|00).</span>
      bool tzNegative;
      if (*currentPosition == &#39;-&#39;)
          tzNegative = true;
      else if (*currentPosition == &#39;+&#39;)
          tzNegative = false;
<span class="line-modified">!     else {</span>
<span class="line-modified">!         isLocalTime = true;</span>
<span class="line-added">+         return currentPosition;</span>
<span class="line-added">+     }</span>
      ++currentPosition;
  
<span class="line-modified">!     long tzHours = 0;</span>
<span class="line-modified">!     long tzHoursAbs = 0;</span>
<span class="line-modified">!     long tzMinutes = 0;</span>
  
      if (!isASCIIDigit(*currentPosition))
          return 0;
      if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzHours))
          return 0;
<span class="line-modified">!     if (*postParsePosition != &#39;:&#39;) {</span>
<span class="line-modified">!         if ((postParsePosition - currentPosition) == 2) {</span>
<span class="line-modified">!             // &quot;00&quot; case.</span>
<span class="line-modified">!             tzHoursAbs = labs(tzHours);</span>
<span class="line-added">+         } else if ((postParsePosition - currentPosition) == 4) {</span>
<span class="line-added">+             // &quot;0000&quot; case.</span>
<span class="line-added">+             tzHoursAbs = labs(tzHours);</span>
<span class="line-added">+             tzMinutes = tzHoursAbs % 100;</span>
<span class="line-added">+             tzHoursAbs = tzHoursAbs / 100;</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             return 0;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         // &quot;00:00&quot; case.</span>
<span class="line-added">+         if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-added">+             return 0;</span>
<span class="line-added">+         tzHoursAbs = labs(tzHours);</span>
<span class="line-added">+         currentPosition = postParsePosition + 1; // Skip &quot;:&quot;.</span>
  
<span class="line-modified">!         if (!isASCIIDigit(*currentPosition))</span>
<span class="line-modified">!             return 0;</span>
<span class="line-modified">!         if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzMinutes))</span>
<span class="line-modified">!             return 0;</span>
<span class="line-modified">!         if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-modified">!             return 0;</span>
<span class="line-added">+     }</span>
      currentPosition = postParsePosition;
  
      if (tzHoursAbs &gt; 24)
          return 0;
      if (tzMinutes &lt; 0 || tzMinutes &gt; 59)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,12 ***</span>
          timeZoneSeconds = -timeZoneSeconds;
  
      return currentPosition;
  }
  
<span class="line-modified">! double parseES5DateFromNullTerminatedCharacters(const char* dateString)</span>
  {
      // This parses a date of the form defined in ecma262/#sec-date-time-string-format
      // (similar to RFC 3339 / ISO 8601: YYYY-MM-DDTHH:mm:ss[.sss]Z).
      // In most cases it is intentionally strict (e.g. correct field widths, no stray whitespace).
  
      static const long daysPerMonth[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
<span class="line-new-header">--- 634,14 ---</span>
          timeZoneSeconds = -timeZoneSeconds;
  
      return currentPosition;
  }
  
<span class="line-modified">! double parseES5DateFromNullTerminatedCharacters(const char* dateString, bool&amp; isLocalTime)</span>
  {
<span class="line-added">+     isLocalTime = false;</span>
<span class="line-added">+ </span>
      // This parses a date of the form defined in ecma262/#sec-date-time-string-format
      // (similar to RFC 3339 / ISO 8601: YYYY-MM-DDTHH:mm:ss[.sss]Z).
      // In most cases it is intentionally strict (e.g. correct field widths, no stray whitespace).
  
      static const long daysPerMonth[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 802,13 ***</span>
      // Parse the date YYYY[-MM[-DD]]
      char* currentPosition = parseES5DatePortion(dateString, year, month, day);
      if (!currentPosition)
          return std::numeric_limits&lt;double&gt;::quiet_NaN();
      // Look for a time portion.
      if (*currentPosition == &#39;T&#39;) {
<span class="line-modified">!         // Parse the time HH:mm[:ss[.sss]][Z|(+|-)00:00]</span>
<span class="line-modified">!         currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, timeZoneSeconds);</span>
          if (!currentPosition)
              return std::numeric_limits&lt;double&gt;::quiet_NaN();
      }
      // Check that we have parsed all characters in the string.
      if (*currentPosition)
<span class="line-new-header">--- 658,14 ---</span>
      // Parse the date YYYY[-MM[-DD]]
      char* currentPosition = parseES5DatePortion(dateString, year, month, day);
      if (!currentPosition)
          return std::numeric_limits&lt;double&gt;::quiet_NaN();
      // Look for a time portion.
<span class="line-added">+     // Note: As of ES2016, when a UTC offset is missing, date-time forms are local time while date-only forms are UTC.</span>
      if (*currentPosition == &#39;T&#39;) {
<span class="line-modified">!         // Parse the time HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)]</span>
<span class="line-modified">!         currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, isLocalTime, timeZoneSeconds);</span>
          if (!currentPosition)
              return std::numeric_limits&lt;double&gt;::quiet_NaN();
      }
      // Check that we have parsed all characters in the string.
      if (*currentPosition)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 838,14 ***</span>
      double dateSeconds = ymdhmsToSeconds(year, month, day, hours, minutes, seconds) - timeZoneSeconds;
      return dateSeconds * msPerSecond;
  }
  
  // Odd case where &#39;exec&#39; is allowed to be 0, to accomodate a caller in WebCore.
<span class="line-modified">! double parseDateFromNullTerminatedCharacters(const char* dateString, bool&amp; haveTZ, int&amp; offset)</span>
  {
<span class="line-modified">!     haveTZ = false;</span>
<span class="line-modified">!     offset = 0;</span>
  
      // This parses a date in the form:
      //     Tuesday, 09-Nov-99 23:12:40 GMT
      // or
      //     Sat, 01-Jan-2000 08:00:00 GMT
<span class="line-new-header">--- 695,14 ---</span>
      double dateSeconds = ymdhmsToSeconds(year, month, day, hours, minutes, seconds) - timeZoneSeconds;
      return dateSeconds * msPerSecond;
  }
  
  // Odd case where &#39;exec&#39; is allowed to be 0, to accomodate a caller in WebCore.
<span class="line-modified">! double parseDateFromNullTerminatedCharacters(const char* dateString, bool&amp; isLocalTime)</span>
  {
<span class="line-modified">!     isLocalTime = true;</span>
<span class="line-modified">!     int offset = 0;</span>
  
      // This parses a date in the form:
      //     Tuesday, 09-Nov-99 23:12:40 GMT
      // or
      //     Sat, 01-Jan-2000 08:00:00 GMT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1059,11 ***</span>
      // Don&#39;t fail if the time zone is missing.
      // Some websites omit the time zone (4275206).
      if (*dateString) {
          if (startsWithLettersIgnoringASCIICase(dateString, &quot;gmt&quot;) || startsWithLettersIgnoringASCIICase(dateString, &quot;utc&quot;)) {
              dateString += 3;
<span class="line-modified">!             haveTZ = true;</span>
          }
  
          if (*dateString == &#39;+&#39; || *dateString == &#39;-&#39;) {
              int o;
              if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o))
<span class="line-new-header">--- 916,11 ---</span>
      // Don&#39;t fail if the time zone is missing.
      // Some websites omit the time zone (4275206).
      if (*dateString) {
          if (startsWithLettersIgnoringASCIICase(dateString, &quot;gmt&quot;) || startsWithLettersIgnoringASCIICase(dateString, &quot;utc&quot;)) {
              dateString += 3;
<span class="line-modified">!             isLocalTime = false;</span>
          }
  
          if (*dateString == &#39;+&#39; || *dateString == &#39;-&#39;) {
              int o;
              if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1086,20 ***</span>
                  if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o2))
                      return std::numeric_limits&lt;double&gt;::quiet_NaN();
                  dateString = newPosStr;
                  offset = (o * 60 + o2) * sgn;
              }
<span class="line-modified">!             haveTZ = true;</span>
          } else {
              for (auto&amp; knownZone : knownZones) {
                  // Since the passed-in length is used for both strings, the following checks that
                  // dateString has the time zone name as a prefix, not that it is equal.
                  auto length = strlen(knownZone.tzName);
                  if (equalLettersIgnoringASCIICase(dateString, knownZone.tzName, length)) {
                      offset = knownZone.tzOffset;
                      dateString += length;
<span class="line-modified">!                     haveTZ = true;</span>
                      break;
                  }
              }
          }
      }
<span class="line-new-header">--- 943,20 ---</span>
                  if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o2))
                      return std::numeric_limits&lt;double&gt;::quiet_NaN();
                  dateString = newPosStr;
                  offset = (o * 60 + o2) * sgn;
              }
<span class="line-modified">!             isLocalTime = false;</span>
          } else {
              for (auto&amp; knownZone : knownZones) {
                  // Since the passed-in length is used for both strings, the following checks that
                  // dateString has the time zone name as a prefix, not that it is equal.
                  auto length = strlen(knownZone.tzName);
                  if (equalLettersIgnoringASCIICase(dateString, knownZone.tzName, length)) {
                      offset = knownZone.tzOffset;
                      dateString += length;
<span class="line-modified">!                     isLocalTime = false;</span>
                      break;
                  }
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1139,33 ***</span>
          //    may not be a leap year. In that case, `new Date(&quot;Feb 29&quot;).getMonth()` becomes 2 (March).
          year = 2000;
      }
      ASSERT(year);
  
<span class="line-modified">!     return ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) * msPerSecond;</span>
  }
  
  double parseDateFromNullTerminatedCharacters(const char* dateString)
  {
<span class="line-modified">!     bool haveTZ;</span>
<span class="line-modified">!     int offset;</span>
<span class="line-removed">-     double ms = parseDateFromNullTerminatedCharacters(dateString, haveTZ, offset);</span>
<span class="line-removed">-     if (std::isnan(ms))</span>
<span class="line-removed">-         return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // fall back to local timezone</span>
<span class="line-removed">-     if (!haveTZ)</span>
<span class="line-removed">-         offset = calculateLocalTimeOffset(ms, LocalTime).offset / msPerMinute; // ms value is in local time milliseconds.</span>
  
<span class="line-modified">!     return ms - (offset * msPerMinute);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! double timeClip(double t)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (std::abs(t) &gt; maxECMAScriptTime)</span>
<span class="line-removed">-         return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-removed">-     return std::trunc(t) + 0.0;</span>
  }
  
  // See http://tools.ietf.org/html/rfc2822#section-3.3 for more information.
  String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
  {
<span class="line-new-header">--- 996,23 ---</span>
          //    may not be a leap year. In that case, `new Date(&quot;Feb 29&quot;).getMonth()` becomes 2 (March).
          year = 2000;
      }
      ASSERT(year);
  
<span class="line-modified">!     double dateSeconds = ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) - offset * secondsPerMinute;</span>
<span class="line-added">+     return dateSeconds * msPerSecond;</span>
  }
  
  double parseDateFromNullTerminatedCharacters(const char* dateString)
  {
<span class="line-modified">!     bool isLocalTime;</span>
<span class="line-modified">!     double value = parseDateFromNullTerminatedCharacters(dateString, isLocalTime);</span>
  
<span class="line-modified">!     if (isLocalTime)</span>
<span class="line-modified">!         value -= calculateLocalTimeOffset(value, LocalTime).offset;</span>
  
<span class="line-modified">!     return value;</span>
  }
  
  // See http://tools.ietf.org/html/rfc2822#section-3.3 for more information.
  String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
  {
</pre>
<center><a href="DataLog.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DateMath.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
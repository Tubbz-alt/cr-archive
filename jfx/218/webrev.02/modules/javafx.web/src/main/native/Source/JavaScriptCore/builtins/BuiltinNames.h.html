<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinNames.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BuiltinUtils.h&quot;
 29 #include &quot;BytecodeIntrinsicRegistry.h&quot;
 30 #include &quot;CommonIdentifiers.h&quot;
 31 #include &quot;JSCBuiltins.h&quot;
 32 
 33 namespace JSC {
 34 
 35 #define DECLARE_BUILTIN_NAMES_IN_JSC(name) const JSC::Identifier m_##name;
 36 #define DECLARE_BUILTIN_SYMBOLS_IN_JSC(name) const JSC::Identifier m_##name##Symbol; const JSC::Identifier m_##name##SymbolPrivateIdentifier;
 37 #define DECLARE_BUILTIN_SYMBOL_ACCESSOR(name) \
 38     const JSC::Identifier&amp; name##Symbol() const { return m_##name##Symbol; }
 39 #define DECLARE_BUILTIN_IDENTIFIER_ACCESSOR_IN_JSC(name) \
 40     const JSC::Identifier&amp; name##PublicName() const { return m_##name; } \
 41     JSC::Identifier name##PrivateName() const { return JSC::Identifier::fromUid(*bitwise_cast&lt;SymbolImpl*&gt;(&amp;JSC::Symbols::name##PrivateName)); }
 42 
 43 
 44 #define JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_PROPERTY_NAME(macro) \
 45     JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(macro) \
 46     JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(macro) \
 47     macro(add) \
 48     macro(applyFunction) \
 49     macro(arraySpeciesCreate) \
 50     macro(assert) \
 51     macro(callFunction) \
 52     macro(charCodeAt) \
 53     macro(executor) \
 54     macro(isView) \
 55     macro(iteratedObject) \
 56     macro(iteratedString) \
 57     macro(promise) \
 58     macro(promiseOrCapability) \
 59     macro(Object) \
 60     macro(Number) \
 61     macro(Array) \
 62     macro(ArrayBuffer) \
 63     macro(RegExp) \
 64     macro(trunc) \
 65     macro(create) \
 66     macro(defineProperty) \
 67     macro(defaultPromiseThen) \
 68     macro(getPrototypeOf) \
 69     macro(getOwnPropertyNames) \
 70     macro(ownKeys) \
 71     macro(Set) \
 72     macro(throwTypeErrorFunction) \
 73     macro(typedArrayLength) \
 74     macro(typedArraySort) \
 75     macro(typedArrayGetOriginalConstructor) \
 76     macro(typedArraySubarrayCreate) \
 77     macro(BuiltinLog) \
 78     macro(BuiltinDescribe) \
 79     macro(homeObject) \
 80     macro(enqueueJob) \
 81     macro(hostPromiseRejectionTracker) \
 82     macro(onFulfilled) \
 83     macro(onRejected) \
 84     macro(push) \
 85     macro(repeatCharacter) \
 86     macro(starDefault) \
 87     macro(InspectorInstrumentation) \
 88     macro(get) \
 89     macro(set) \
 90     macro(shift) \
 91     macro(allocateTypedArray) \
 92     macro(Int8Array) \
 93     macro(Int16Array) \
 94     macro(Int32Array) \
 95     macro(Uint8Array) \
 96     macro(Uint8ClampedArray) \
 97     macro(Uint16Array) \
 98     macro(Uint32Array) \
 99     macro(Float32Array) \
100     macro(Float64Array) \
101     macro(exec) \
102     macro(generator) \
103     macro(generatorNext) \
104     macro(generatorState) \
105     macro(generatorFrame) \
106     macro(generatorValue) \
107     macro(generatorThis) \
108     macro(generatorResumeMode) \
109     macro(syncIterator) \
110     macro(nextMethod) \
111     macro(asyncGeneratorQueueItemNext) \
112     macro(dateTimeFormat) \
113     macro(intlSubstituteValue) \
114     macro(thisTimeValue) \
115     macro(newTargetLocal) \
116     macro(derivedConstructor) \
117     macro(isTypedArrayView) \
118     macro(isBoundFunction) \
119     macro(hasInstanceBoundFunction) \
120     macro(instanceOf) \
121     macro(isArraySlow) \
122     macro(isConstructor) \
123     macro(concatMemcpy) \
124     macro(appendMemcpy) \
125     macro(regExpCreate) \
126     macro(isRegExp) \
127     macro(replaceUsingRegExp) \
128     macro(replaceUsingStringSearch) \
129     macro(replaceAllUsingStringSearch) \
130     macro(makeTypeError) \
131     macro(mapBucket) \
132     macro(mapBucketHead) \
133     macro(mapBucketNext) \
134     macro(mapBucketKey) \
135     macro(mapBucketValue) \
136     macro(mapIteratorKind) \
137     macro(setBucket) \
138     macro(setBucketHead) \
139     macro(setBucketNext) \
140     macro(setBucketKey) \
141     macro(setIteratorKind) \
142     macro(regExpBuiltinExec) \
143     macro(regExpMatchFast) \
144     macro(regExpProtoFlagsGetter) \
145     macro(regExpProtoGlobalGetter) \
146     macro(regExpProtoIgnoreCaseGetter) \
147     macro(regExpProtoMultilineGetter) \
148     macro(regExpProtoSourceGetter) \
149     macro(regExpProtoStickyGetter) \
150     macro(regExpProtoUnicodeGetter) \
151     macro(regExpPrototypeSymbolReplace) \
152     macro(regExpSearchFast) \
153     macro(regExpSplitFast) \
154     macro(regExpTestFast) \
155     macro(regExpStringIteratorRegExp) \
156     macro(regExpStringIteratorString) \
157     macro(regExpStringIteratorGlobal) \
158     macro(regExpStringIteratorUnicode) \
159     macro(regExpStringIteratorDone) \
160     macro(stringIncludesInternal) \
161     macro(stringSplitFast) \
162     macro(stringSubstrInternal) \
163     macro(makeBoundFunction) \
164     macro(hasOwnLengthProperty) \
165     macro(importModule) \
166     macro(propertyIsEnumerable) \
167     macro(meta) \
168     macro(webAssemblyCompileStreamingInternal) \
169     macro(webAssemblyInstantiateStreamingInternal) \
170     macro(instanceFieldInitializer)
171 
172 namespace Symbols {
173 #define DECLARE_BUILTIN_STATIC_SYMBOLS(name) extern JS_EXPORT_PRIVATE SymbolImpl::StaticSymbolImpl name##Symbol;
174 JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_WELL_KNOWN_SYMBOL(DECLARE_BUILTIN_STATIC_SYMBOLS)
175 #undef DECLARE_BUILTIN_STATIC_SYMBOLS
176 
177 #define DECLARE_BUILTIN_PRIVATE_NAMES(name) extern JS_EXPORT_PRIVATE SymbolImpl::StaticSymbolImpl name##PrivateName;
178 JSC_FOREACH_BUILTIN_FUNCTION_NAME(DECLARE_BUILTIN_PRIVATE_NAMES)
179 JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_PROPERTY_NAME(DECLARE_BUILTIN_PRIVATE_NAMES)
180 #undef DECLARE_BUILTIN_PRIVATE_NAMES
181 
182 extern JS_EXPORT_PRIVATE SymbolImpl::StaticSymbolImpl dollarVMPrivateName;
183 extern JS_EXPORT_PRIVATE SymbolImpl::StaticSymbolImpl polyProtoPrivateName;
184 }
185 
186 class BuiltinNames {
187     WTF_MAKE_NONCOPYABLE(BuiltinNames); WTF_MAKE_FAST_ALLOCATED;
188 
189 public:
190     BuiltinNames(VM&amp;, CommonIdentifiers*);
191 
192     SymbolImpl* lookUpPrivateName(const Identifier&amp;) const;
193     Identifier getPublicName(VM&amp;, SymbolImpl*) const;
194 
195     void appendExternalName(const Identifier&amp; publicName, const Identifier&amp; privateName);
196 
197     JSC_FOREACH_BUILTIN_FUNCTION_NAME(DECLARE_BUILTIN_IDENTIFIER_ACCESSOR_IN_JSC)
198     JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_PROPERTY_NAME(DECLARE_BUILTIN_IDENTIFIER_ACCESSOR_IN_JSC)
199     JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_WELL_KNOWN_SYMBOL(DECLARE_BUILTIN_SYMBOL_ACCESSOR)
200     const JSC::Identifier&amp; dollarVMPublicName() const { return m_dollarVMName; }
201     const JSC::Identifier&amp; dollarVMPrivateName() const { return m_dollarVMPrivateName; }
202     const JSC::Identifier&amp; polyProtoName() const { return m_polyProtoPrivateName; }
203 
204 private:
205     void checkPublicToPrivateMapConsistency(UniquedStringImpl* publicName, UniquedStringImpl* privateName);
206 
207     Identifier m_emptyIdentifier;
208     JSC_FOREACH_BUILTIN_FUNCTION_NAME(DECLARE_BUILTIN_NAMES_IN_JSC)
209     JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_PROPERTY_NAME(DECLARE_BUILTIN_NAMES_IN_JSC)
210     JSC_COMMON_PRIVATE_IDENTIFIERS_EACH_WELL_KNOWN_SYMBOL(DECLARE_BUILTIN_SYMBOLS_IN_JSC)
211     const JSC::Identifier m_dollarVMName;
212     const JSC::Identifier m_dollarVMPrivateName;
213     const JSC::Identifier m_polyProtoPrivateName;
214     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, SymbolImpl*, IdentifierRepHash&gt; BuiltinNamesMap;
215     BuiltinNamesMap m_publicToPrivateMap;
216 };
217 
218 inline SymbolImpl* BuiltinNames::lookUpPrivateName(const Identifier&amp; ident) const
219 {
220     auto iter = m_publicToPrivateMap.find(ident.impl());
221     if (iter != m_publicToPrivateMap.end())
222         return iter-&gt;value;
223     return nullptr;
224 }
225 
226 inline Identifier BuiltinNames::getPublicName(VM&amp; vm, SymbolImpl* symbol) const
227 {
228     if (symbol-&gt;isPrivate())
229         return Identifier::fromString(vm, symbol);
230     // We have special handling for well-known symbols.
231     ASSERT(symbol-&gt;startsWith(&quot;Symbol.&quot;));
232     return Identifier::fromString(vm, makeString(String(symbol-&gt;substring(strlen(&quot;Symbol.&quot;))), &quot;Symbol&quot;));
233 }
234 
235 inline void BuiltinNames::checkPublicToPrivateMapConsistency(UniquedStringImpl* publicName, UniquedStringImpl* privateName)
236 {
237 #ifndef NDEBUG
238     for (const auto&amp; key : m_publicToPrivateMap.keys())
239         ASSERT(String(publicName) != *key);
240 
241     ASSERT(privateName-&gt;isSymbol());
242     SymbolImpl* symbol = static_cast&lt;SymbolImpl*&gt;(privateName);
243     if (symbol-&gt;isPrivate()) {
244         // This guarantees that we can get public symbols from private symbols by using content of private symbols.
245         ASSERT(String(symbol) == *publicName);
246     } else {
247         // We have a hack in m_publicToPrivateMap: adding non-private Symbol with readable name to use it
248         // in builtin code. The example is @iteratorSymbol =&gt; Symbol.iterator mapping. To allow the reverse
249         // transformation, we ensure that non-private symbol mapping has xxxSymbol =&gt; Symbol.xxx.
250         ASSERT(makeString(String(symbol), &quot;Symbol&quot;) == makeString(&quot;Symbol.&quot;, String(publicName)));
251     }
252 #else
253     UNUSED_PARAM(publicName);
254     UNUSED_PARAM(privateName);
255 #endif
256 }
257 
258 inline void BuiltinNames::appendExternalName(const Identifier&amp; publicName, const Identifier&amp; privateName)
259 {
260     checkPublicToPrivateMapConsistency(publicName.impl(), privateName.impl());
261     m_publicToPrivateMap.add(publicName.impl(), static_cast&lt;SymbolImpl*&gt;(privateName.impl()));
262 }
263 
264 } // namespace JSC
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditingBehavior.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EditingStyle.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/EditingStyle.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1140         return false;
1141 
1142     return !element.inlineStyle() || !equivalent.propertyExistsInStyle(EditingStyle::create(element.inlineStyle()).get());
1143 }
1144 
1145 static RefPtr&lt;MutableStyleProperties&gt; extractEditingProperties(const StyleProperties* style, EditingStyle::PropertiesToInclude propertiesToInclude)
1146 {
1147     if (!style)
1148         return nullptr;
1149 
1150     switch (propertiesToInclude) {
1151     case EditingStyle::OnlyEditingInheritableProperties:
1152         return copyEditingProperties(style, OnlyInheritableEditingProperties);
1153     case EditingStyle::AllProperties:
1154     case EditingStyle::EditingPropertiesInEffect:
1155         break;
1156     }
1157     return copyEditingProperties(style, AllEditingProperties);
1158 }
1159 
<span class="line-modified">1160 void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude)</span>
1161 {
1162     auto styleFromRules = EditingStyle::create();
<span class="line-modified">1163     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element);</span>
1164 
1165     if (element.inlineStyle())
1166         styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
1167 
1168     styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
1169     mergeStyle(styleFromRules-&gt;m_mutableStyle.get(), mode);
1170 
1171     for (auto&amp; equivalent : htmlElementEquivalents()) {
1172         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1173             equivalent-&gt;addToStyle(&amp;element, this);
1174     }
1175 
1176     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1177         if (equivalent-&gt;attributeName() == HTMLNames::dirAttr)
1178             continue; // We don&#39;t want to include directionality
1179         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1180             equivalent-&gt;addToStyle(&amp;element, this);
1181     }
1182 }
1183 
<span class="line-modified">1184 Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate)</span>
1185 {
1186     if (shouldAnnotate) {
1187         auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
1188 
1189         // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
1190         // to help us differentiate those styles from ones that the user has applied.
1191         // This helps us get the color of content pasted into blockquotes right.
1192         wrappingStyle-&gt;removeStyleAddedByNode(enclosingNodeOfType(firstPositionInOrBeforeNode(&amp;context), isMailBlockquote, CanCrossEditingBoundary));
1193 
1194         // Call collapseTextDecorationProperties first or otherwise it&#39;ll copy the value over from in-effect to text-decorations.
1195         wrappingStyle-&gt;collapseTextDecorationProperties();
1196 
1197         return wrappingStyle;
1198     }
1199 
1200     auto wrappingStyle = EditingStyle::create();
1201 
1202     // When not annotating for interchange, we only preserve inline style declarations.
1203     for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
1204         if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
<span class="line-modified">1205             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), EditingStyle::DoNotOverrideValues, EditingStyle::EditingPropertiesInEffect);</span>
1206     }
1207 
1208     return wrappingStyle;
1209 }
1210 
1211 
1212 static void mergeTextDecorationValues(CSSValueList&amp; mergedValue, const CSSValueList&amp; valueToMerge)
1213 {
1214     auto&amp; cssValuePool = CSSValuePool::singleton();
1215     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1216     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1217 
1218     if (valueToMerge.hasValue(underline.ptr()) &amp;&amp; !mergedValue.hasValue(underline.ptr()))
1219         mergedValue.append(WTFMove(underline));
1220 
1221     if (valueToMerge.hasValue(lineThrough.ptr()) &amp;&amp; !mergedValue.hasValue(lineThrough.ptr()))
1222         mergedValue.append(WTFMove(lineThrough));
1223 }
1224 
1225 void EditingStyle::mergeStyle(const StyleProperties* style, CSSPropertyOverrideMode mode)
</pre>
<hr />
<pre>
1244                 auto newValue = downcast&lt;CSSValueList&gt;(*value).copy();
1245                 mergeTextDecorationValues(newValue, downcast&lt;CSSValueList&gt;(*property.value()));
1246                 m_mutableStyle-&gt;setProperty(property.id(), WTFMove(newValue), property.isImportant());
1247                 continue;
1248             }
1249             value = nullptr; // text-decoration: none is equivalent to not having the property.
1250         }
1251 
1252         if (mode == OverrideValues || (mode == DoNotOverrideValues &amp;&amp; !value))
1253             m_mutableStyle-&gt;setProperty(property.id(), property.value(), property.isImportant());
1254     }
1255 
1256     int oldFontSizeDelta = m_fontSizeDelta;
1257     extractFontSizeDelta();
1258     m_fontSizeDelta += oldFontSizeDelta;
1259 }
1260 
1261 static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
1262 {
1263     auto style = MutableStyleProperties::create();
<span class="line-modified">1264     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude)) {</span>
<span class="line-modified">1265         if (matchedRule-&gt;isStyleRule())</span>
<span class="line-removed">1266             style-&gt;mergeAndOverrideOnConflict(static_pointer_cast&lt;StyleRule&gt;(matchedRule)-&gt;properties());</span>
<span class="line-removed">1267     }</span>
1268 
1269     return style;
1270 }
1271 
1272 void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
1273 {
1274     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
<span class="line-modified">1275         StyleResolver::AuthorCSSRules);</span>
1276     // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
1277     // over those from matched rules.
1278     if (m_mutableStyle)
1279         styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
1280 
1281     clear();
1282     m_mutableStyle = styleFromMatchedRules;
1283 }
1284 
<span class="line-modified">1285 static bool usesForbiddenSystemFontAsOnlyFontFamilyName(CSSValue&amp; value)</span>







1286 {



1287     if (!is&lt;CSSValueList&gt;(value) || downcast&lt;CSSValueList&gt;(value).length() != 1)
<span class="line-modified">1288         return false;</span>
1289 
1290     auto&amp; item = *downcast&lt;CSSValueList&gt;(value).item(0);
1291     if (!is&lt;CSSPrimitiveValue&gt;(item))
<span class="line-modified">1292         return false;</span>
1293 
<span class="line-modified">1294     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item);</span>
<span class="line-removed">1295     if (!primitiveValue.isFontFamily())</span>
<span class="line-removed">1296         return false;</span>
<span class="line-removed">1297     return FontCache::isSystemFontForbiddenForEditing(primitiveValue.fontFamily().familyName);</span>
1298 }
1299 
<span class="line-modified">1300 void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element)</span>
1301 {
1302     mergeStyleFromRules(element);
1303 
1304     // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
1305     // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
1306     // FIXME: There are others like this, see &lt;rdar://problem/5195123&gt; Slashdot copy/paste fidelity problem
1307     auto fromComputedStyle = MutableStyleProperties::create();
1308     ComputedStyleExtractor computedStyle(&amp;element);
1309 
1310     bool shouldRemoveFontFamily = false;
1311     {
1312         unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
1313         for (unsigned i = 0; i &lt; propertyCount; ++i) {
1314             StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
1315             CSSValue&amp; value = *property.value();
<span class="line-modified">1316             if (property.id() == CSSPropertyFontFamily &amp;&amp; usesForbiddenSystemFontAsOnlyFontFamilyName(value)) {</span>
<span class="line-modified">1317                 shouldRemoveFontFamily = true;</span>



1318                 continue;
1319             }
1320             if (!is&lt;CSSPrimitiveValue&gt;(value))
1321                 continue;
1322             if (downcast&lt;CSSPrimitiveValue&gt;(value).isPercentage()) {
1323                 if (auto computedPropertyValue = computedStyle.propertyValue(property.id()))
1324                     fromComputedStyle-&gt;addParsedProperty(CSSProperty(property.id(), WTFMove(computedPropertyValue)));
1325             }
1326         }
1327     }
1328     if (shouldRemoveFontFamily) {
1329         m_mutableStyle-&gt;removeProperty(CSSPropertyFontFamily);
1330         fromComputedStyle-&gt;removeProperty(CSSPropertyFontFamily);
1331     }
1332     m_mutableStyle-&gt;mergeAndOverrideOnConflict(fromComputedStyle.get());
1333 }
1334 
1335 static void removePropertiesInStyle(MutableStyleProperties* styleToRemovePropertiesFrom, MutableStyleProperties* style)
1336 {
1337     unsigned propertyCount = style-&gt;propertyCount();
1338     Vector&lt;CSSPropertyID&gt; propertiesToRemove(propertyCount);
1339     for (unsigned i = 0; i &lt; propertyCount; ++i)
1340         propertiesToRemove[i] = style-&gt;propertyAt(i).id();
1341 
1342     styleToRemovePropertiesFrom-&gt;removePropertiesInSet(propertiesToRemove.data(), propertiesToRemove.size());
1343 }
1344 
1345 void EditingStyle::removeStyleFromRulesAndContext(StyledElement&amp; element, Node* context)
1346 {
1347     if (!m_mutableStyle)
1348         return;
1349 
1350     // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
<span class="line-modified">1351     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, StyleResolver::AllButEmptyCSSRules);</span>
1352     if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
1353         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
1354 
1355     // 2. Remove style present in context and not overridden by matched rules.
1356     auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
1357     if (computedStyle-&gt;m_mutableStyle) {
1358         if (!computedStyle-&gt;m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor))
1359             computedStyle-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, CSSValueTransparent);
1360 
1361         removePropertiesInStyle(computedStyle-&gt;m_mutableStyle.get(), styleFromMatchedRules.get());
1362         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *computedStyle-&gt;m_mutableStyle);
1363     }
1364 
1365     // 3. If this element is a span and has display: inline or float: none, remove them unless they are overridden by rules.
1366     // These rules are added by serialization code to wrap text nodes.
1367     if (isStyleSpanOrSpanWithOnlyStyleAttribute(element)) {
1368         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyDisplay) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyDisplay) == CSSValueInline)
1369             m_mutableStyle-&gt;removeProperty(CSSPropertyDisplay);
1370         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyFloat) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyFloat) == CSSValueNone)
1371             m_mutableStyle-&gt;removeProperty(CSSPropertyFloat);
1372     }
1373 }
1374 
1375 void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
1376 {
1377     if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
1378         return;
1379 
<span class="line-modified">1380     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, StyleResolver::UAAndUserCSSRules);</span>
1381 
1382     removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
1383 }
1384 
1385 template&lt;typename T&gt;
1386 void EditingStyle::removeEquivalentProperties(T&amp; style)
1387 {
1388     Vector&lt;CSSPropertyID&gt; propertiesToRemove;
1389     for (auto&amp; property : m_mutableStyle-&gt;m_propertyVector) {
1390         if (style.propertyMatches(property.id(), property.value()))
1391             propertiesToRemove.append(property.id());
1392     }
1393     // FIXME: This should use mass removal.
1394     for (auto&amp; property : propertiesToRemove)
1395         m_mutableStyle-&gt;removeProperty(property);
1396 }
1397 
1398 void EditingStyle::forceInline()
1399 {
1400     if (!m_mutableStyle)
</pre>
<hr />
<pre>
1563         if (foundDirection != WritingDirection::Natural)
1564             return WritingDirection::Natural;
1565 
1566         // In the range case, make sure that the embedding element persists until the end of the range.
1567         if (selection.isRange() &amp;&amp; !end.deprecatedNode()-&gt;isDescendantOf(*node))
1568             return WritingDirection::Natural;
1569 
1570         foundDirection = directionValue == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
1571     }
1572     hasNestedOrMultipleEmbeddings = false;
1573     return foundDirection;
1574 }
1575 
1576 Ref&lt;EditingStyle&gt; EditingStyle::inverseTransformColorIfNeeded(Element&amp; element)
1577 {
1578     auto* renderer = element.renderer();
1579     if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
1580         return *this;
1581 
1582     bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);

1583     bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
<span class="line-modified">1584     if (!hasColor &amp;&amp; !hasBackgroundColor)</span>
1585         return *this;
1586 
1587     auto styleWithInvertedColors = copy();
1588     ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
1589 
1590     const auto&amp; colorFilter = renderer-&gt;style().appleColorFilter();
1591     auto invertedColor = [&amp;](CSSPropertyID propertyID) {
1592         Color newColor = cssValueToColor(extractPropertyValue(*m_mutableStyle, propertyID).get());
1593         colorFilter.inverseTransformColor(newColor);
1594         styleWithInvertedColors-&gt;m_mutableStyle-&gt;setProperty(propertyID, newColor.cssText());
1595     };
1596 
1597     if (hasColor)
1598         invertedColor(CSSPropertyColor);
1599 



1600     if (hasBackgroundColor)
1601         invertedColor(CSSPropertyBackgroundColor);
1602 
1603     return styleWithInvertedColors;
1604 }
1605 
1606 static void reconcileTextDecorationProperties(MutableStyleProperties* style)
1607 {
1608     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = style-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
1609     RefPtr&lt;CSSValue&gt; textDecoration = style-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
1610     // We shouldn&#39;t have both text-decoration and -webkit-text-decorations-in-effect because that wouldn&#39;t make sense.
1611     ASSERT(!textDecorationsInEffect || !textDecoration);
1612     if (textDecorationsInEffect) {
1613         style-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText());
1614         style-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
1615         textDecoration = textDecorationsInEffect;
1616     }
1617 
1618     // If text-decoration is set to &quot;none&quot;, remove the property because we don&#39;t want to add redundant &quot;text-decoration: none&quot;.
1619     if (textDecoration &amp;&amp; !textDecoration-&gt;isValueList())
</pre>
<hr />
<pre>
1853     if (extractPropertyValue(baseStyle, CSSPropertyBackgroundColor) &amp;&amp; equalIgnoringSemanticColor(backgroundColorFromStyle(mutableStyle), backgroundColorFromStyle(baseStyle)))
1854         mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1855 
1856     return mutableStyle;
1857 }
1858 
1859 template&lt;typename T&gt;
1860 Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1861 {
1862     return extractPropertiesNotIn(styleWithRedundantProperties, baseStyle);
1863 }
1864 
1865 static bool isCSSValueLength(CSSPrimitiveValue* value)
1866 {
1867     return value-&gt;isFontIndependentLength();
1868 }
1869 
1870 int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
1871 {
1872     if (isCSSValueLength(value)) {
<span class="line-modified">1873         int pixelFontSize = value-&gt;intValue(CSSPrimitiveValue::CSS_PX);</span>
1874         int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
1875         // Use legacy font size only if pixel value matches exactly to that of legacy font size.
1876         int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
1877         if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
1878             return legacyFontSize;
1879 
1880         return 0;
1881     }
1882 
1883     if (CSSValueXSmall &lt;= value-&gt;valueID() &amp;&amp; value-&gt;valueID() &lt;= CSSValueWebkitXxxLarge)
1884         return value-&gt;valueID() - CSSValueXSmall + 1;
1885 
1886     return 0;
1887 }
1888 
1889 static bool isTransparentColorValue(CSSValue* value)
1890 {
1891     if (!value)
1892         return true;
1893     if (!is&lt;CSSPrimitiveValue&gt;(*value))
</pre>
</td>
<td>
<hr />
<pre>
1140         return false;
1141 
1142     return !element.inlineStyle() || !equivalent.propertyExistsInStyle(EditingStyle::create(element.inlineStyle()).get());
1143 }
1144 
1145 static RefPtr&lt;MutableStyleProperties&gt; extractEditingProperties(const StyleProperties* style, EditingStyle::PropertiesToInclude propertiesToInclude)
1146 {
1147     if (!style)
1148         return nullptr;
1149 
1150     switch (propertiesToInclude) {
1151     case EditingStyle::OnlyEditingInheritableProperties:
1152         return copyEditingProperties(style, OnlyInheritableEditingProperties);
1153     case EditingStyle::AllProperties:
1154     case EditingStyle::EditingPropertiesInEffect:
1155         break;
1156     }
1157     return copyEditingProperties(style, AllEditingProperties);
1158 }
1159 
<span class="line-modified">1160 void EditingStyle::mergeInlineAndImplicitStyleOfElement(StyledElement&amp; element, CSSPropertyOverrideMode mode, PropertiesToInclude propertiesToInclude, StandardFontFamilySerializationMode standardFontFamilySerializationMode)</span>
1161 {
1162     auto styleFromRules = EditingStyle::create();
<span class="line-modified">1163     styleFromRules-&gt;mergeStyleFromRulesForSerialization(element, standardFontFamilySerializationMode);</span>
1164 
1165     if (element.inlineStyle())
1166         styleFromRules-&gt;m_mutableStyle-&gt;mergeAndOverrideOnConflict(*element.inlineStyle());
1167 
1168     styleFromRules-&gt;m_mutableStyle = extractEditingProperties(styleFromRules-&gt;m_mutableStyle.get(), propertiesToInclude);
1169     mergeStyle(styleFromRules-&gt;m_mutableStyle.get(), mode);
1170 
1171     for (auto&amp; equivalent : htmlElementEquivalents()) {
1172         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1173             equivalent-&gt;addToStyle(&amp;element, this);
1174     }
1175 
1176     for (auto&amp; equivalent : htmlAttributeEquivalents()) {
1177         if (equivalent-&gt;attributeName() == HTMLNames::dirAttr)
1178             continue; // We don&#39;t want to include directionality
1179         if (elementMatchesAndPropertyIsNotInInlineStyleDecl(*equivalent, element, mode, *this))
1180             equivalent-&gt;addToStyle(&amp;element, this);
1181     }
1182 }
1183 
<span class="line-modified">1184 Ref&lt;EditingStyle&gt; EditingStyle::wrappingStyleForSerialization(Node&amp; context, bool shouldAnnotate, StandardFontFamilySerializationMode standardFontFamilySerializationMode)</span>
1185 {
1186     if (shouldAnnotate) {
1187         auto wrappingStyle = EditingStyle::create(&amp;context, EditingStyle::EditingPropertiesInEffect);
1188 
1189         // Styles that Mail blockquotes contribute should only be placed on the Mail blockquote,
1190         // to help us differentiate those styles from ones that the user has applied.
1191         // This helps us get the color of content pasted into blockquotes right.
1192         wrappingStyle-&gt;removeStyleAddedByNode(enclosingNodeOfType(firstPositionInOrBeforeNode(&amp;context), isMailBlockquote, CanCrossEditingBoundary));
1193 
1194         // Call collapseTextDecorationProperties first or otherwise it&#39;ll copy the value over from in-effect to text-decorations.
1195         wrappingStyle-&gt;collapseTextDecorationProperties();
1196 
1197         return wrappingStyle;
1198     }
1199 
1200     auto wrappingStyle = EditingStyle::create();
1201 
1202     // When not annotating for interchange, we only preserve inline style declarations.
1203     for (Node* node = &amp;context; node &amp;&amp; !node-&gt;isDocumentNode(); node = node-&gt;parentNode()) {
1204         if (is&lt;StyledElement&gt;(*node) &amp;&amp; !isMailBlockquote(node))
<span class="line-modified">1205             wrappingStyle-&gt;mergeInlineAndImplicitStyleOfElement(downcast&lt;StyledElement&gt;(*node), DoNotOverrideValues, EditingPropertiesInEffect, standardFontFamilySerializationMode);</span>
1206     }
1207 
1208     return wrappingStyle;
1209 }
1210 
1211 
1212 static void mergeTextDecorationValues(CSSValueList&amp; mergedValue, const CSSValueList&amp; valueToMerge)
1213 {
1214     auto&amp; cssValuePool = CSSValuePool::singleton();
1215     Ref&lt;CSSPrimitiveValue&gt; underline = cssValuePool.createIdentifierValue(CSSValueUnderline);
1216     Ref&lt;CSSPrimitiveValue&gt; lineThrough = cssValuePool.createIdentifierValue(CSSValueLineThrough);
1217 
1218     if (valueToMerge.hasValue(underline.ptr()) &amp;&amp; !mergedValue.hasValue(underline.ptr()))
1219         mergedValue.append(WTFMove(underline));
1220 
1221     if (valueToMerge.hasValue(lineThrough.ptr()) &amp;&amp; !mergedValue.hasValue(lineThrough.ptr()))
1222         mergedValue.append(WTFMove(lineThrough));
1223 }
1224 
1225 void EditingStyle::mergeStyle(const StyleProperties* style, CSSPropertyOverrideMode mode)
</pre>
<hr />
<pre>
1244                 auto newValue = downcast&lt;CSSValueList&gt;(*value).copy();
1245                 mergeTextDecorationValues(newValue, downcast&lt;CSSValueList&gt;(*property.value()));
1246                 m_mutableStyle-&gt;setProperty(property.id(), WTFMove(newValue), property.isImportant());
1247                 continue;
1248             }
1249             value = nullptr; // text-decoration: none is equivalent to not having the property.
1250         }
1251 
1252         if (mode == OverrideValues || (mode == DoNotOverrideValues &amp;&amp; !value))
1253             m_mutableStyle-&gt;setProperty(property.id(), property.value(), property.isImportant());
1254     }
1255 
1256     int oldFontSizeDelta = m_fontSizeDelta;
1257     extractFontSizeDelta();
1258     m_fontSizeDelta += oldFontSizeDelta;
1259 }
1260 
1261 static Ref&lt;MutableStyleProperties&gt; styleFromMatchedRulesForElement(Element&amp; element, unsigned rulesToInclude)
1262 {
1263     auto style = MutableStyleProperties::create();
<span class="line-modified">1264     for (auto&amp; matchedRule : element.styleResolver().styleRulesForElement(&amp;element, rulesToInclude))</span>
<span class="line-modified">1265         style-&gt;mergeAndOverrideOnConflict(matchedRule-&gt;properties());</span>


1266 
1267     return style;
1268 }
1269 
1270 void EditingStyle::mergeStyleFromRules(StyledElement&amp; element)
1271 {
1272     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element,
<span class="line-modified">1273         Style::Resolver::AuthorCSSRules);</span>
1274     // Styles from the inline style declaration, held in the variable &quot;style&quot;, take precedence
1275     // over those from matched rules.
1276     if (m_mutableStyle)
1277         styleFromMatchedRules-&gt;mergeAndOverrideOnConflict(*m_mutableStyle);
1278 
1279     clear();
1280     m_mutableStyle = styleFromMatchedRules;
1281 }
1282 
<span class="line-modified">1283 static String familyNameFromCSSPrimitiveValue(const CSSPrimitiveValue&amp; primitiveValue)</span>
<span class="line-added">1284 {</span>
<span class="line-added">1285     if (!primitiveValue.isFontFamily())</span>
<span class="line-added">1286         return { };</span>
<span class="line-added">1287     return primitiveValue.fontFamily().familyName;</span>
<span class="line-added">1288 }</span>
<span class="line-added">1289 </span>
<span class="line-added">1290 static String loneFontFamilyName(const CSSValue&amp; value)</span>
1291 {
<span class="line-added">1292     if (is&lt;CSSPrimitiveValue&gt;(value))</span>
<span class="line-added">1293         return familyNameFromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(value));</span>
<span class="line-added">1294 </span>
1295     if (!is&lt;CSSValueList&gt;(value) || downcast&lt;CSSValueList&gt;(value).length() != 1)
<span class="line-modified">1296         return { };</span>
1297 
1298     auto&amp; item = *downcast&lt;CSSValueList&gt;(value).item(0);
1299     if (!is&lt;CSSPrimitiveValue&gt;(item))
<span class="line-modified">1300         return { };</span>
1301 
<span class="line-modified">1302     return familyNameFromCSSPrimitiveValue(downcast&lt;CSSPrimitiveValue&gt;(item));</span>



1303 }
1304 
<span class="line-modified">1305 void EditingStyle::mergeStyleFromRulesForSerialization(StyledElement&amp; element, StandardFontFamilySerializationMode standardFontFamilySerializationMode)</span>
1306 {
1307     mergeStyleFromRules(element);
1308 
1309     // The property value, if it&#39;s a percentage, may not reflect the actual computed value.
1310     // For example: style=&quot;height: 1%; overflow: visible;&quot; in quirksmode
1311     // FIXME: There are others like this, see &lt;rdar://problem/5195123&gt; Slashdot copy/paste fidelity problem
1312     auto fromComputedStyle = MutableStyleProperties::create();
1313     ComputedStyleExtractor computedStyle(&amp;element);
1314 
1315     bool shouldRemoveFontFamily = false;
1316     {
1317         unsigned propertyCount = m_mutableStyle-&gt;propertyCount();
1318         for (unsigned i = 0; i &lt; propertyCount; ++i) {
1319             StyleProperties::PropertyReference property = m_mutableStyle-&gt;propertyAt(i);
1320             CSSValue&amp; value = *property.value();
<span class="line-modified">1321             if (property.id() == CSSPropertyFontFamily) {</span>
<span class="line-modified">1322                 auto familyName = loneFontFamilyName(value);</span>
<span class="line-added">1323                 if (FontCache::isSystemFontForbiddenForEditing(familyName)</span>
<span class="line-added">1324                     || (standardFontFamilySerializationMode == StandardFontFamilySerializationMode::Strip &amp;&amp; familyName == standardFamily))</span>
<span class="line-added">1325                     shouldRemoveFontFamily = true;</span>
1326                 continue;
1327             }
1328             if (!is&lt;CSSPrimitiveValue&gt;(value))
1329                 continue;
1330             if (downcast&lt;CSSPrimitiveValue&gt;(value).isPercentage()) {
1331                 if (auto computedPropertyValue = computedStyle.propertyValue(property.id()))
1332                     fromComputedStyle-&gt;addParsedProperty(CSSProperty(property.id(), WTFMove(computedPropertyValue)));
1333             }
1334         }
1335     }
1336     if (shouldRemoveFontFamily) {
1337         m_mutableStyle-&gt;removeProperty(CSSPropertyFontFamily);
1338         fromComputedStyle-&gt;removeProperty(CSSPropertyFontFamily);
1339     }
1340     m_mutableStyle-&gt;mergeAndOverrideOnConflict(fromComputedStyle.get());
1341 }
1342 
1343 static void removePropertiesInStyle(MutableStyleProperties* styleToRemovePropertiesFrom, MutableStyleProperties* style)
1344 {
1345     unsigned propertyCount = style-&gt;propertyCount();
1346     Vector&lt;CSSPropertyID&gt; propertiesToRemove(propertyCount);
1347     for (unsigned i = 0; i &lt; propertyCount; ++i)
1348         propertiesToRemove[i] = style-&gt;propertyAt(i).id();
1349 
1350     styleToRemovePropertiesFrom-&gt;removePropertiesInSet(propertiesToRemove.data(), propertiesToRemove.size());
1351 }
1352 
1353 void EditingStyle::removeStyleFromRulesAndContext(StyledElement&amp; element, Node* context)
1354 {
1355     if (!m_mutableStyle)
1356         return;
1357 
1358     // 1. Remove style from matched rules because style remain without repeating it in inline style declaration
<span class="line-modified">1359     RefPtr&lt;MutableStyleProperties&gt; styleFromMatchedRules = styleFromMatchedRulesForElement(element, Style::Resolver::AllButEmptyCSSRules);</span>
1360     if (styleFromMatchedRules &amp;&amp; !styleFromMatchedRules-&gt;isEmpty())
1361         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *styleFromMatchedRules);
1362 
1363     // 2. Remove style present in context and not overridden by matched rules.
1364     auto computedStyle = EditingStyle::create(context, EditingPropertiesInEffect);
1365     if (computedStyle-&gt;m_mutableStyle) {
1366         if (!computedStyle-&gt;m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor))
1367             computedStyle-&gt;m_mutableStyle-&gt;setProperty(CSSPropertyBackgroundColor, CSSValueTransparent);
1368 
1369         removePropertiesInStyle(computedStyle-&gt;m_mutableStyle.get(), styleFromMatchedRules.get());
1370         m_mutableStyle = getPropertiesNotIn(*m_mutableStyle, *computedStyle-&gt;m_mutableStyle);
1371     }
1372 
1373     // 3. If this element is a span and has display: inline or float: none, remove them unless they are overridden by rules.
1374     // These rules are added by serialization code to wrap text nodes.
1375     if (isStyleSpanOrSpanWithOnlyStyleAttribute(element)) {
1376         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyDisplay) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyDisplay) == CSSValueInline)
1377             m_mutableStyle-&gt;removeProperty(CSSPropertyDisplay);
1378         if (!styleFromMatchedRules-&gt;getPropertyCSSValue(CSSPropertyFloat) &amp;&amp; identifierForStyleProperty(*m_mutableStyle, CSSPropertyFloat) == CSSValueNone)
1379             m_mutableStyle-&gt;removeProperty(CSSPropertyFloat);
1380     }
1381 }
1382 
1383 void EditingStyle::removePropertiesInElementDefaultStyle(Element&amp; element)
1384 {
1385     if (!m_mutableStyle || m_mutableStyle-&gt;isEmpty())
1386         return;
1387 
<span class="line-modified">1388     RefPtr&lt;MutableStyleProperties&gt; defaultStyle = styleFromMatchedRulesForElement(element, Style::Resolver::UAAndUserCSSRules);</span>
1389 
1390     removePropertiesInStyle(m_mutableStyle.get(), defaultStyle.get());
1391 }
1392 
1393 template&lt;typename T&gt;
1394 void EditingStyle::removeEquivalentProperties(T&amp; style)
1395 {
1396     Vector&lt;CSSPropertyID&gt; propertiesToRemove;
1397     for (auto&amp; property : m_mutableStyle-&gt;m_propertyVector) {
1398         if (style.propertyMatches(property.id(), property.value()))
1399             propertiesToRemove.append(property.id());
1400     }
1401     // FIXME: This should use mass removal.
1402     for (auto&amp; property : propertiesToRemove)
1403         m_mutableStyle-&gt;removeProperty(property);
1404 }
1405 
1406 void EditingStyle::forceInline()
1407 {
1408     if (!m_mutableStyle)
</pre>
<hr />
<pre>
1571         if (foundDirection != WritingDirection::Natural)
1572             return WritingDirection::Natural;
1573 
1574         // In the range case, make sure that the embedding element persists until the end of the range.
1575         if (selection.isRange() &amp;&amp; !end.deprecatedNode()-&gt;isDescendantOf(*node))
1576             return WritingDirection::Natural;
1577 
1578         foundDirection = directionValue == CSSValueLtr ? WritingDirection::LeftToRight : WritingDirection::RightToLeft;
1579     }
1580     hasNestedOrMultipleEmbeddings = false;
1581     return foundDirection;
1582 }
1583 
1584 Ref&lt;EditingStyle&gt; EditingStyle::inverseTransformColorIfNeeded(Element&amp; element)
1585 {
1586     auto* renderer = element.renderer();
1587     if (!m_mutableStyle || !renderer || !renderer-&gt;style().hasAppleColorFilter())
1588         return *this;
1589 
1590     bool hasColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyColor);
<span class="line-added">1591     bool hasCaretColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyCaretColor);</span>
1592     bool hasBackgroundColor = m_mutableStyle-&gt;getPropertyCSSValue(CSSPropertyBackgroundColor);
<span class="line-modified">1593     if (!hasColor &amp;&amp; !hasCaretColor &amp;&amp; !hasBackgroundColor)</span>
1594         return *this;
1595 
1596     auto styleWithInvertedColors = copy();
1597     ASSERT(styleWithInvertedColors-&gt;m_mutableStyle);
1598 
1599     const auto&amp; colorFilter = renderer-&gt;style().appleColorFilter();
1600     auto invertedColor = [&amp;](CSSPropertyID propertyID) {
1601         Color newColor = cssValueToColor(extractPropertyValue(*m_mutableStyle, propertyID).get());
1602         colorFilter.inverseTransformColor(newColor);
1603         styleWithInvertedColors-&gt;m_mutableStyle-&gt;setProperty(propertyID, newColor.cssText());
1604     };
1605 
1606     if (hasColor)
1607         invertedColor(CSSPropertyColor);
1608 
<span class="line-added">1609     if (hasCaretColor)</span>
<span class="line-added">1610         invertedColor(CSSPropertyCaretColor);</span>
<span class="line-added">1611 </span>
1612     if (hasBackgroundColor)
1613         invertedColor(CSSPropertyBackgroundColor);
1614 
1615     return styleWithInvertedColors;
1616 }
1617 
1618 static void reconcileTextDecorationProperties(MutableStyleProperties* style)
1619 {
1620     RefPtr&lt;CSSValue&gt; textDecorationsInEffect = style-&gt;getPropertyCSSValue(CSSPropertyWebkitTextDecorationsInEffect);
1621     RefPtr&lt;CSSValue&gt; textDecoration = style-&gt;getPropertyCSSValue(CSSPropertyTextDecoration);
1622     // We shouldn&#39;t have both text-decoration and -webkit-text-decorations-in-effect because that wouldn&#39;t make sense.
1623     ASSERT(!textDecorationsInEffect || !textDecoration);
1624     if (textDecorationsInEffect) {
1625         style-&gt;setProperty(CSSPropertyTextDecoration, textDecorationsInEffect-&gt;cssText());
1626         style-&gt;removeProperty(CSSPropertyWebkitTextDecorationsInEffect);
1627         textDecoration = textDecorationsInEffect;
1628     }
1629 
1630     // If text-decoration is set to &quot;none&quot;, remove the property because we don&#39;t want to add redundant &quot;text-decoration: none&quot;.
1631     if (textDecoration &amp;&amp; !textDecoration-&gt;isValueList())
</pre>
<hr />
<pre>
1865     if (extractPropertyValue(baseStyle, CSSPropertyBackgroundColor) &amp;&amp; equalIgnoringSemanticColor(backgroundColorFromStyle(mutableStyle), backgroundColorFromStyle(baseStyle)))
1866         mutableStyle-&gt;removeProperty(CSSPropertyBackgroundColor);
1867 
1868     return mutableStyle;
1869 }
1870 
1871 template&lt;typename T&gt;
1872 Ref&lt;MutableStyleProperties&gt; getPropertiesNotIn(StyleProperties&amp; styleWithRedundantProperties, T&amp; baseStyle)
1873 {
1874     return extractPropertiesNotIn(styleWithRedundantProperties, baseStyle);
1875 }
1876 
1877 static bool isCSSValueLength(CSSPrimitiveValue* value)
1878 {
1879     return value-&gt;isFontIndependentLength();
1880 }
1881 
1882 int legacyFontSizeFromCSSValue(Document&amp; document, CSSPrimitiveValue* value, bool shouldUseFixedFontDefaultSize, LegacyFontSizeMode mode)
1883 {
1884     if (isCSSValueLength(value)) {
<span class="line-modified">1885         int pixelFontSize = value-&gt;intValue(CSSUnitType::CSS_PX);</span>
1886         int legacyFontSize = Style::legacyFontSizeForPixelSize(pixelFontSize, shouldUseFixedFontDefaultSize, document);
1887         // Use legacy font size only if pixel value matches exactly to that of legacy font size.
1888         int cssPrimitiveEquivalent = legacyFontSize - 1 + CSSValueXSmall;
1889         if (mode == AlwaysUseLegacyFontSize || Style::fontSizeForKeyword(cssPrimitiveEquivalent, shouldUseFixedFontDefaultSize, document) == pixelFontSize)
1890             return legacyFontSize;
1891 
1892         return 0;
1893     }
1894 
1895     if (CSSValueXSmall &lt;= value-&gt;valueID() &amp;&amp; value-&gt;valueID() &lt;= CSSValueWebkitXxxLarge)
1896         return value-&gt;valueID() - CSSValueXSmall + 1;
1897 
1898     return 0;
1899 }
1900 
1901 static bool isTransparentColorValue(CSSValue* value)
1902 {
1903     if (!value)
1904         return true;
1905     if (!is&lt;CSSPrimitiveValue&gt;(*value))
</pre>
</td>
</tr>
</table>
<center><a href="EditingBehavior.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EditingStyle.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
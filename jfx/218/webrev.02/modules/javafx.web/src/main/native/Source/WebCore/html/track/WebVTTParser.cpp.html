<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/track/WebVTTParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
  3  * Copyright (C) 2013 Cable Television Labs, Inc.
  4  * Copyright (C) 2011-2020 Apple Inc.  All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions are
  8  * met:
  9  *
 10  *     * Redistributions of source code must retain the above copyright
 11  * notice, this list of conditions and the following disclaimer.
 12  *     * Redistributions in binary form must reproduce the above
 13  * copyright notice, this list of conditions and the following disclaimer
 14  * in the documentation and/or other materials provided with the
 15  * distribution.
 16  *     * Neither the name of Google Inc. nor the names of its
 17  * contributors may be used to endorse or promote products derived from
 18  * this software without specific prior written permission.
 19  *
 20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 
 35 #if ENABLE(VIDEO_TRACK)
 36 
 37 #include &quot;WebVTTParser.h&quot;
 38 
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;ISOVTTCue.h&quot;
 41 #include &quot;ProcessingInstruction.h&quot;
 42 #include &quot;StyleRule.h&quot;
 43 #include &quot;StyleRuleImport.h&quot;
 44 #include &quot;StyleSheetContents.h&quot;
 45 #include &quot;Text.h&quot;
 46 #include &quot;VTTScanner.h&quot;
 47 #include &quot;WebVTTElement.h&quot;
 48 #include &quot;WebVTTTokenizer.h&quot;
 49 
 50 namespace WebCore {
 51 
 52 const double secondsPerHour = 3600;
 53 const double secondsPerMinute = 60;
 54 const double secondsPerMillisecond = 0.001;
 55 const char* fileIdentifier = &quot;WEBVTT&quot;;
 56 const unsigned fileIdentifierLength = 6;
 57 const unsigned regionIdentifierLength = 6;
 58 const unsigned styleIdentifierLength = 5;
 59 
 60 bool WebVTTParser::parseFloatPercentageValue(VTTScanner&amp; valueScanner, float&amp; percentage)
 61 {
 62     float number;
 63     if (!valueScanner.scanFloat(number))
 64         return false;
 65     // &#39;%&#39; must be present and at the end of the setting value.
 66     if (!valueScanner.scan(&#39;%&#39;))
 67         return false;
 68 
 69     if (number &lt; 0 || number &gt; 100)
 70         return false;
 71 
 72     percentage = number;
 73     return true;
 74 }
 75 
 76 bool WebVTTParser::parseFloatPercentageValuePair(VTTScanner&amp; valueScanner, char delimiter, FloatPoint&amp; valuePair)
 77 {
 78     float firstCoord;
 79     if (!parseFloatPercentageValue(valueScanner, firstCoord))
 80         return false;
 81 
 82     if (!valueScanner.scan(delimiter))
 83         return false;
 84 
 85     float secondCoord;
 86     if (!parseFloatPercentageValue(valueScanner, secondCoord))
 87         return false;
 88 
 89     valuePair = FloatPoint(firstCoord, secondCoord);
 90     return true;
 91 }
 92 
 93 WebVTTParser::WebVTTParser(WebVTTParserClient* client, ScriptExecutionContext* context)
 94     : m_scriptExecutionContext(context)
 95     , m_state(Initial)
 96     , m_decoder(TextResourceDecoder::create(&quot;text/plain&quot;, UTF8Encoding()))
 97     , m_client(client)
 98 {
 99 }
100 
101 void WebVTTParser::getNewCues(Vector&lt;RefPtr&lt;WebVTTCueData&gt;&gt;&amp; outputCues)
102 {
103     outputCues = WTFMove(m_cuelist);
104 }
105 
106 void WebVTTParser::getNewRegions(Vector&lt;RefPtr&lt;VTTRegion&gt;&gt;&amp; outputRegions)
107 {
108     outputRegions = WTFMove(m_regionList);
109 }
110 
111 Vector&lt;String&gt; WebVTTParser::getStyleSheets()
112 {
113     return WTFMove(m_styleSheets);
114 }
115 
116 void WebVTTParser::parseFileHeader(String&amp;&amp; data)
117 {
118     m_state = Initial;
119     m_lineReader.reset();
120     m_lineReader.append(WTFMove(data));
121     parse();
122 }
123 
124 void WebVTTParser::parseBytes(const char* data, unsigned length)
125 {
126     m_lineReader.append(m_decoder-&gt;decode(data, length));
127     parse();
128 }
129 
130 void WebVTTParser::parseCueData(const ISOWebVTTCue&amp; data)
131 {
132     auto cue = WebVTTCueData::create();
133 
134     MediaTime startTime = data.presentationTime();
135     cue-&gt;setStartTime(startTime);
136     cue-&gt;setEndTime(startTime + data.duration());
137 
138     cue-&gt;setContent(data.cueText());
139     cue-&gt;setId(data.id());
140     cue-&gt;setSettings(data.settings());
141 
142     MediaTime originalStartTime;
143     if (WebVTTParser::collectTimeStamp(data.originalStartTime(), originalStartTime))
144         cue-&gt;setOriginalStartTime(originalStartTime);
145 
146     m_cuelist.append(WTFMove(cue));
147     if (m_client)
148         m_client-&gt;newCuesParsed();
149 }
150 
151 void WebVTTParser::flush()
152 {
153     m_lineReader.append(m_decoder-&gt;flush());
154     m_lineReader.appendEndOfStream();
155     parse();
156     flushPendingCue();
157 }
158 
159 void WebVTTParser::parse()
160 {
161     // WebVTT parser algorithm. (5.1 WebVTT file parsing.)
162     // Steps 1 - 3 - Initial setup.
163     while (auto line = m_lineReader.nextLine()) {
164         switch (m_state) {
165         case Initial:
166             // Steps 4 - 9 - Check for a valid WebVTT signature.
167             if (!hasRequiredFileIdentifier(*line)) {
168                 if (m_client)
169                     m_client-&gt;fileFailedToParse();
170                 return;
171             }
172 
173             m_state = Header;
174             break;
175 
176         case Header:
177             // Steps 11 - 14 - Collect WebVTT block
178             m_state = collectWebVTTBlock(*line);
179             break;
180 
181         case Region:
182             m_state = collectRegionSettings(*line);
183             break;
184 
185         case Style:
186             m_state = collectStyleSheet(*line);
187             break;
188 
189         case Id:
190             // Steps 17 - 20 - Allow any number of line terminators, then initialize new cue values.
191             if (line-&gt;isEmpty())
192                 break;
193 
194             // Step 21 - Cue creation (start a new cue).
195             resetCueValues();
196 
197             // Steps 22 - 25 - Check if this line contains an optional identifier or timing data.
198             m_state = collectCueId(*line);
199             break;
200 
201         case TimingsAndSettings:
202             // Steps 26 - 27 - Discard current cue if the line is empty.
203             if (line-&gt;isEmpty()) {
204                 m_state = Id;
205                 break;
206             }
207 
208             // Steps 28 - 29 - Collect cue timings and settings.
209             m_state = collectTimingsAndSettings(*line);
210             break;
211 
212         case CueText:
213             // Steps 31 - 41 - Collect the cue text, create a cue, and add it to the output.
214             m_state = collectCueText(*line);
215             break;
216 
217         case BadCue:
218             // Steps 42 - 48 - Discard lines until an empty line or a potential timing line is seen.
219             m_state = ignoreBadCue(*line);
220             break;
221 
222         case Finished:
223             ASSERT_NOT_REACHED();
224             break;
225         }
226     }
227 }
228 
229 void WebVTTParser::fileFinished()
230 {
231     ASSERT(m_state != Finished);
232     parseBytes(&quot;\n\n&quot;, 2);
233     m_state = Finished;
234 }
235 
236 void WebVTTParser::flushPendingCue()
237 {
238     ASSERT(m_lineReader.isAtEndOfStream());
239     // If we&#39;re in the CueText state when we run out of data, we emit the pending cue.
240     if (m_state == CueText)
241         createNewCue();
242 }
243 
244 bool WebVTTParser::hasRequiredFileIdentifier(const String&amp; line)
245 {
246     // A WebVTT file identifier consists of an optional BOM character,
247     // the string &quot;WEBVTT&quot; followed by an optional space or tab character,
248     // and any number of characters that are not line terminators ...
249     if (!line.startsWith(fileIdentifier))
250         return false;
251     if (line.length() &gt; fileIdentifierLength &amp;&amp; !isHTMLSpace(line[fileIdentifierLength]))
252         return false;
253     return true;
254 }
255 
256 WebVTTParser::ParseState WebVTTParser::collectRegionSettings(const String&amp; line)
257 {
258     // End of region block
259     if (checkAndStoreRegion(line))
260         return checkAndRecoverCue(line);
261 
262     m_currentRegion-&gt;setRegionSettings(line);
263     return Region;
264 }
265 
266 WebVTTParser::ParseState WebVTTParser::collectWebVTTBlock(const String&amp; line)
267 {
268     // collect a WebVTT block parsing. (WebVTT parser algorithm step 14)
269 
270     if (checkAndCreateRegion(line))
271         return Region;
272 
273     if (checkStyleSheet(line))
274         return Style;
275 
276     // Handle cue block.
277     ParseState state = checkAndRecoverCue(line);
278     if (state != Header) {
279         if (m_client) {
280             if (!m_regionList.isEmpty())
281                 m_client-&gt;newRegionsParsed();
282             if (!m_styleSheets.isEmpty())
283                 m_client-&gt;newStyleSheetsParsed();
284         }
285         if (!m_previousLine.isEmpty() &amp;&amp; !m_previousLine.contains(&quot;--&gt;&quot;))
286             m_currentId = m_previousLine;
287 
288         return state;
289     }
290 
291     // store previous line for cue id.
292     // length is more than 1 line clear m_previousLine and ignore line.
293     if (m_previousLine.isEmpty())
294         m_previousLine = line;
295     else
296         m_previousLine = emptyString();
297 
298     return state;
299 }
300 
301 WebVTTParser::ParseState WebVTTParser::checkAndRecoverCue(const String&amp; line)
302 {
303     // parse cue timings and settings
304     if (line.contains(&quot;--&gt;&quot;)) {
305         ParseState state = recoverCue(line);
306         if (state != BadCue)
307             return state;
308     }
309     return Header;
310 }
311 
312 WebVTTParser::ParseState WebVTTParser::collectStyleSheet(const String&amp; line)
313 {
314     // End of style block
315     if (checkAndStoreStyleSheet(line))
316         return checkAndRecoverCue(line);
317 
318     m_currentSourceStyleSheet.append(line);
319     return Style;
320 }
321 
322 bool WebVTTParser::checkAndCreateRegion(const String&amp; line)
323 {
324     if (m_previousLine.contains(&quot;--&gt;&quot;))
325         return false;
326     // line starts with the substring &quot;REGION&quot; and remaining characters
327     // zero or more U+0020 SPACE characters or U+0009 CHARACTER TABULATION
328     // (tab) characters expected other than these charecters it is invalid.
329     if (line.startsWith(&quot;REGION&quot;) &amp;&amp; line.substring(regionIdentifierLength).isAllSpecialCharacters&lt;isASpace&gt;()) {
330         m_currentRegion = VTTRegion::create(*m_scriptExecutionContext);
331         return true;
332     }
333     return false;
334 }
335 
336 bool WebVTTParser::checkAndStoreRegion(const String&amp; line)
337 {
338     if (!line.isEmpty() &amp;&amp; !line.contains(&quot;--&gt;&quot;))
339         return false;
340 
341     if (!m_currentRegion-&gt;id().isEmpty()) {
342         // If the text track list of regions regions contains a region
343         // with the same region identifier value as region, remove that region.
344         for (const auto&amp; region : m_regionList) {
345             if (region-&gt;id() == m_currentRegion-&gt;id()) {
346                 m_regionList.removeFirst(region);
347                 break;
348             }
349         }
350         m_regionList.append(m_currentRegion);
351     }
352     m_currentRegion = nullptr;
353     return true;
354 }
355 
356 bool WebVTTParser::checkStyleSheet(const String&amp; line)
357 {
358     if (m_previousLine.contains(&quot;--&gt;&quot;))
359         return false;
360     // line starts with the substring &quot;STYLE&quot; and remaining characters
361     // zero or more U+0020 SPACE characters or U+0009 CHARACTER TABULATION
362     // (tab) characters expected other than these charecters it is invalid.
363     if (line.startsWith(&quot;STYLE&quot;) &amp;&amp; line.substring(styleIdentifierLength).isAllSpecialCharacters&lt;isASpace&gt;())
364         return true;
365 
366     return false;
367 }
368 
369 bool WebVTTParser::checkAndStoreStyleSheet(const String&amp; line)
370 {
371     if (!line.isEmpty() &amp;&amp; !line.contains(&quot;--&gt;&quot;))
372         return false;
373 
374     auto styleSheetText = WTFMove(m_currentSourceStyleSheet);
375 
376     // WebVTTMode disallows non-data URLs.
377     auto contents = StyleSheetContents::create(CSSParserContext(WebVTTMode));
378     if (!contents-&gt;parseString(styleSheetText))
379         return true;
380 
381     auto&amp; namespaceRules = contents-&gt;namespaceRules();
382     if (namespaceRules.size())
383         return true;
384 
385     auto&amp; importRules = contents-&gt;importRules();
386     if (importRules.size())
387         return true;
388 
389     auto&amp; childRules = contents-&gt;childRules();
390     if (!childRules.size())
391         return true;
392 
393     StringBuilder sanitizedStyleSheetBuilder;
394 
395     for (const auto&amp; rule : childRules) {
396         if (!rule-&gt;isStyleRule())
397             return true;
398         const auto&amp; styleRule = downcast&lt;StyleRule&gt;(*rule);
399 
400         const auto&amp; selectorList = styleRule.selectorList();
401         if (selectorList.listSize() != 1)
402             return true;
403         auto selector = selectorList.selectorAt(0);
404         auto selectorText = selector-&gt;selectorText();
405 
406         bool isCue = selectorText == &quot;::cue&quot; || selectorText.startsWith(&quot;::cue(&quot;);
407         if (!isCue)
408             return true;
409 
410         if (styleRule.properties().isEmpty())
411             continue;
412 
413         sanitizedStyleSheetBuilder.append(selectorText, &quot; { &quot;, styleRule.properties().asText(), &quot;  }\n&quot;);
414     }
415 
416     // It would be more stylish to parse the stylesheet only once instead of serializing a sanitized version.
417     if (!sanitizedStyleSheetBuilder.isEmpty())
418         m_styleSheets.append(sanitizedStyleSheetBuilder.toString());
419 
420     return true;
421 }
422 
423 WebVTTParser::ParseState WebVTTParser::collectCueId(const String&amp; line)
424 {
425     if (line.contains(&quot;--&gt;&quot;))
426         return collectTimingsAndSettings(line);
427     m_currentId = line;
428     return TimingsAndSettings;
429 }
430 
431 WebVTTParser::ParseState WebVTTParser::collectTimingsAndSettings(const String&amp; line)
432 {
433     if (line.isEmpty())
434         return BadCue;
435 
436     VTTScanner input(line);
437 
438     // Collect WebVTT cue timings and settings. (5.3 WebVTT cue timings and settings parsing.)
439     // Steps 1 - 3 - Let input be the string being parsed and position be a pointer into input
440     input.skipWhile&lt;isHTMLSpace&lt;UChar&gt;&gt;();
441 
442     // Steps 4 - 5 - Collect a WebVTT timestamp. If that fails, then abort and return failure. Otherwise, let cue&#39;s text track cue start time be the collected time.
443     if (!collectTimeStamp(input, m_currentStartTime))
444         return BadCue;
445 
446     input.skipWhile&lt;isHTMLSpace&lt;UChar&gt;&gt;();
447 
448     // Steps 6 - 9 - If the next three characters are not &quot;--&gt;&quot;, abort and return failure.
449     if (!input.scan(&quot;--&gt;&quot;))
450         return BadCue;
451 
452     input.skipWhile&lt;isHTMLSpace&lt;UChar&gt;&gt;();
453 
454     // Steps 10 - 11 - Collect a WebVTT timestamp. If that fails, then abort and return failure. Otherwise, let cue&#39;s text track cue end time be the collected time.
455     if (!collectTimeStamp(input, m_currentEndTime))
456         return BadCue;
457 
458     input.skipWhile&lt;isHTMLSpace&lt;UChar&gt;&gt;();
459 
460     // Step 12 - Parse the WebVTT settings for the cue (conducted in TextTrackCue).
461     m_currentSettings = input.restOfInputAsString();
462     return CueText;
463 }
464 
465 WebVTTParser::ParseState WebVTTParser::collectCueText(const String&amp; line)
466 {
467     // Step 34.
468     if (line.isEmpty()) {
469         createNewCue();
470         return Id;
471     }
472     // Step 35.
473     if (line.contains(&quot;--&gt;&quot;)) {
474         // Step 39-40.
475         createNewCue();
476 
477         // Step 41 - New iteration of the cue loop.
478         return recoverCue(line);
479     }
480     if (!m_currentContent.isEmpty())
481         m_currentContent.append(&#39;\n&#39;);
482     m_currentContent.append(line);
483 
484     return CueText;
485 }
486 
487 WebVTTParser::ParseState WebVTTParser::recoverCue(const String&amp; line)
488 {
489     // Step 17 and 21.
490     resetCueValues();
491 
492     // Step 22.
493     return collectTimingsAndSettings(line);
494 }
495 
496 WebVTTParser::ParseState WebVTTParser::ignoreBadCue(const String&amp; line)
497 {
498     if (line.isEmpty())
499         return Id;
500     if (line.contains(&quot;--&gt;&quot;))
501         return recoverCue(line);
502     return BadCue;
503 }
504 
505 // A helper class for the construction of a &quot;cue fragment&quot; from the cue text.
506 class WebVTTTreeBuilder {
507 public:
508     WebVTTTreeBuilder(Document&amp; document)
509         : m_document(document) { }
510 
511     Ref&lt;DocumentFragment&gt; buildFromString(const String&amp; cueText);
512 
513 private:
514     void constructTreeFromToken(Document&amp;);
515 
516     WebVTTToken m_token;
517     RefPtr&lt;ContainerNode&gt; m_currentNode;
518     Vector&lt;AtomString&gt; m_languageStack;
519     Document&amp; m_document;
520 };
521 
522 Ref&lt;DocumentFragment&gt; WebVTTTreeBuilder::buildFromString(const String&amp; cueText)
523 {
524     // Cue text processing based on
525     // 5.4 WebVTT cue text parsing rules, and
526     // 5.5 WebVTT cue text DOM construction rules.
527     auto fragment = DocumentFragment::create(m_document);
528 
529     if (cueText.isEmpty()) {
530         fragment-&gt;parserAppendChild(Text::create(m_document, emptyString()));
531         return fragment;
532     }
533 
534     m_currentNode = fragment.ptr();
535 
536     WebVTTTokenizer tokenizer(cueText);
537     m_languageStack.clear();
538 
539     while (tokenizer.nextToken(m_token))
540         constructTreeFromToken(m_document);
541 
542     return fragment;
543 }
544 
545 Ref&lt;DocumentFragment&gt; WebVTTParser::createDocumentFragmentFromCueText(Document&amp; document, const String&amp; cueText)
546 {
547     WebVTTTreeBuilder treeBuilder(document);
548     return treeBuilder.buildFromString(cueText);
549 }
550 
551 void WebVTTParser::createNewCue()
552 {
553     auto cue = WebVTTCueData::create();
554     cue-&gt;setStartTime(m_currentStartTime);
555     cue-&gt;setEndTime(m_currentEndTime);
556     cue-&gt;setContent(m_currentContent.toString());
557     cue-&gt;setId(m_currentId);
558     cue-&gt;setSettings(m_currentSettings);
559 
560     m_cuelist.append(WTFMove(cue));
561     if (m_client)
562         m_client-&gt;newCuesParsed();
563 }
564 
565 void WebVTTParser::resetCueValues()
566 {
567     m_currentId = emptyString();
568     m_currentSettings = emptyString();
569     m_currentStartTime = MediaTime::zeroTime();
570     m_currentEndTime = MediaTime::zeroTime();
571     m_currentContent.clear();
572 }
573 
574 bool WebVTTParser::collectTimeStamp(const String&amp; line, MediaTime&amp; timeStamp)
575 {
576     if (line.isEmpty())
577         return false;
578 
579     VTTScanner input(line);
580     return collectTimeStamp(input, timeStamp);
581 }
582 
583 bool WebVTTParser::collectTimeStamp(VTTScanner&amp; input, MediaTime&amp; timeStamp)
584 {
585     // Collect a WebVTT timestamp (5.3 WebVTT cue timings and settings parsing.)
586     // Steps 1 - 4 - Initial checks, let most significant units be minutes.
587     enum Mode { minutes, hours };
588     Mode mode = minutes;
589 
590     // Steps 5 - 7 - Collect a sequence of characters that are 0-9.
591     // If not 2 characters or value is greater than 59, interpret as hours.
592     int value1;
593     unsigned value1Digits = input.scanDigits(value1);
594     if (!value1Digits)
595         return false;
596     if (value1Digits != 2 || value1 &gt; 59)
597         mode = hours;
598 
599     // Steps 8 - 11 - Collect the next sequence of 0-9 after &#39;:&#39; (must be 2 chars).
600     int value2;
601     if (!input.scan(&#39;:&#39;) || input.scanDigits(value2) != 2)
602         return false;
603 
604     // Step 12 - Detect whether this timestamp includes hours.
605     int value3;
606     if (mode == hours || input.match(&#39;:&#39;)) {
607         if (!input.scan(&#39;:&#39;) || input.scanDigits(value3) != 2)
608             return false;
609     } else {
610         value3 = value2;
611         value2 = value1;
612         value1 = 0;
613     }
614 
615     // Steps 13 - 17 - Collect next sequence of 0-9 after &#39;.&#39; (must be 3 chars).
616     int value4;
617     if (!input.scan(&#39;.&#39;) || input.scanDigits(value4) != 3)
618         return false;
619     if (value2 &gt; 59 || value3 &gt; 59)
620         return false;
621 
622     // Steps 18 - 19 - Calculate result.
623     timeStamp = MediaTime::createWithDouble((value1 * secondsPerHour) + (value2 * secondsPerMinute) + value3 + (value4 * secondsPerMillisecond));
624     return true;
625 }
626 
627 static WebVTTNodeType tokenToNodeType(WebVTTToken&amp; token)
628 {
629     switch (token.name().length()) {
630     case 1:
631         if (token.name()[0] == &#39;c&#39;)
632             return WebVTTNodeTypeClass;
633         if (token.name()[0] == &#39;v&#39;)
634             return WebVTTNodeTypeVoice;
635         if (token.name()[0] == &#39;b&#39;)
636             return WebVTTNodeTypeBold;
637         if (token.name()[0] == &#39;i&#39;)
638             return WebVTTNodeTypeItalic;
639         if (token.name()[0] == &#39;u&#39;)
640             return WebVTTNodeTypeUnderline;
641         break;
642     case 2:
643         if (token.name()[0] == &#39;r&#39; &amp;&amp; token.name()[1] == &#39;t&#39;)
644             return WebVTTNodeTypeRubyText;
645         break;
646     case 4:
647         if (token.name()[0] == &#39;r&#39; &amp;&amp; token.name()[1] == &#39;u&#39; &amp;&amp; token.name()[2] == &#39;b&#39; &amp;&amp; token.name()[3] == &#39;y&#39;)
648             return WebVTTNodeTypeRuby;
649         if (token.name()[0] == &#39;l&#39; &amp;&amp; token.name()[1] == &#39;a&#39; &amp;&amp; token.name()[2] == &#39;n&#39; &amp;&amp; token.name()[3] == &#39;g&#39;)
650             return WebVTTNodeTypeLanguage;
651         break;
652     }
653     return WebVTTNodeTypeNone;
654 }
655 
656 void WebVTTTreeBuilder::constructTreeFromToken(Document&amp; document)
657 {
658     // http://dev.w3.org/html5/webvtt/#webvtt-cue-text-dom-construction-rules
659 
660     switch (m_token.type()) {
661     case WebVTTTokenTypes::Character: {
662         m_currentNode-&gt;parserAppendChild(Text::create(document, m_token.characters()));
663         break;
664     }
665     case WebVTTTokenTypes::StartTag: {
666         WebVTTNodeType nodeType = tokenToNodeType(m_token);
667         if (nodeType == WebVTTNodeTypeNone)
668             break;
669 
670         WebVTTNodeType currentType = is&lt;WebVTTElement&gt;(*m_currentNode) ? downcast&lt;WebVTTElement&gt;(*m_currentNode).webVTTNodeType() : WebVTTNodeTypeNone;
671         // &lt;rt&gt; is only allowed if the current node is &lt;ruby&gt;.
672         if (nodeType == WebVTTNodeTypeRubyText &amp;&amp; currentType != WebVTTNodeTypeRuby)
673             break;
674 
675         auto child = WebVTTElement::create(nodeType, document);
676         if (!m_token.classes().isEmpty())
677             child-&gt;setAttributeWithoutSynchronization(classAttr, m_token.classes());
678 
679         if (nodeType == WebVTTNodeTypeVoice)
680             child-&gt;setAttributeWithoutSynchronization(WebVTTElement::voiceAttributeName(), m_token.annotation());
681         else if (nodeType == WebVTTNodeTypeLanguage) {
682             m_languageStack.append(m_token.annotation());
683             child-&gt;setAttributeWithoutSynchronization(WebVTTElement::langAttributeName(), m_languageStack.last());
684         }
685         if (!m_languageStack.isEmpty())
686             child-&gt;setLanguage(m_languageStack.last());
687         m_currentNode-&gt;parserAppendChild(child);
688         m_currentNode = WTFMove(child);
689         break;
690     }
691     case WebVTTTokenTypes::EndTag: {
692         WebVTTNodeType nodeType = tokenToNodeType(m_token);
693         if (nodeType == WebVTTNodeTypeNone)
694             break;
695 
696         // The only non-VTTElement would be the DocumentFragment root. (Text
697         // nodes and PIs will never appear as m_currentNode.)
698         if (!is&lt;WebVTTElement&gt;(*m_currentNode))
699             break;
700 
701         WebVTTNodeType currentType = downcast&lt;WebVTTElement&gt;(*m_currentNode).webVTTNodeType();
702         bool matchesCurrent = nodeType == currentType;
703         if (!matchesCurrent) {
704             // &lt;/ruby&gt; auto-closes &lt;rt&gt;
705             if (currentType == WebVTTNodeTypeRubyText &amp;&amp; nodeType == WebVTTNodeTypeRuby) {
706                 if (m_currentNode-&gt;parentNode())
707                     m_currentNode = m_currentNode-&gt;parentNode();
708             } else
709                 break;
710         }
711         if (nodeType == WebVTTNodeTypeLanguage)
712             m_languageStack.removeLast();
713         if (m_currentNode-&gt;parentNode())
714             m_currentNode = m_currentNode-&gt;parentNode();
715         break;
716     }
717     case WebVTTTokenTypes::TimestampTag: {
718         String charactersString = m_token.characters();
719         MediaTime parsedTimeStamp;
720         if (WebVTTParser::collectTimeStamp(charactersString, parsedTimeStamp))
721             m_currentNode-&gt;parserAppendChild(ProcessingInstruction::create(document, &quot;timestamp&quot;, charactersString));
722         break;
723     }
724     default:
725         break;
726     }
727 }
728 
729 }
730 
731 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RootInlineBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32 #include &quot;SelectionRangeData.h&quot;
 33 
 34 #include &quot;Document.h&quot;
 35 #include &quot;FrameSelection.h&quot;
 36 #include &quot;Position.h&quot;
 37 #include &quot;Range.h&quot;
 38 #include &quot;RenderLayer.h&quot;
 39 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 40 #include &quot;RenderObject.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;VisibleSelection.h&quot;
 43 
 44 namespace WebCore {
 45 
 46 namespace { // See bug #177808.
 47 
 48 struct SelectionData {
 49     using RendererMap = HashMap&lt;RenderObject*, std::unique_ptr&lt;RenderSelectionInfo&gt;&gt;;
 50     using RenderBlockMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockSelectionInfo&gt;&gt;;
 51 
<span class="line-modified"> 52     Optional&lt;unsigned&gt; startPosition;</span>
<span class="line-modified"> 53     Optional&lt;unsigned&gt; endPosition;</span>
 54     RendererMap renderers;
 55     RenderBlockMap blocks;
 56 };
 57 
 58 class SelectionIterator {
 59 public:
 60     SelectionIterator(RenderObject* start)
 61         : m_current(start)
 62     {
 63         checkForSpanner();
 64     }
 65 
 66     RenderObject* current() const
 67     {
 68         return m_current;
 69     }
 70 
 71     RenderObject* next()
 72     {
 73         RenderObject* currentSpan = m_spannerStack.isEmpty() ? nullptr : m_spannerStack.last()-&gt;spanner();
</pre>
<hr />
<pre>
 81         }
 82         return m_current;
 83     }
 84 
 85 private:
 86     void checkForSpanner()
 87     {
 88         if (!is&lt;RenderMultiColumnSpannerPlaceholder&gt;(m_current))
 89             return;
 90         auto&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*m_current);
 91         m_spannerStack.append(&amp;placeholder);
 92         m_current = placeholder.spanner();
 93     }
 94 
 95     RenderObject* m_current { nullptr };
 96     Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; m_spannerStack;
 97 };
 98 
 99 } // anonymous namespace
100 
<span class="line-modified">101 static RenderObject* rendererAfterPosition(const RenderObject&amp; renderer, unsigned offset)</span>
102 {
103     auto* child = renderer.childAt(offset);
104     return child ? child : renderer.nextInPreOrderAfterChildren();
105 }
106 
107 static bool isValidRendererForSelection(const RenderObject&amp; renderer, const SelectionRangeData::Context&amp; selection)
108 {
109     return (renderer.canBeSelectionLeaf() || &amp;renderer == selection.start() || &amp;renderer == selection.end())
110         &amp;&amp; renderer.selectionState() != RenderObject::SelectionNone
111         &amp;&amp; renderer.containingBlock();
112 }
113 
114 static RenderBlock* containingBlockBelowView(const RenderObject&amp; renderer)
115 {
116     auto* containingBlock = renderer.containingBlock();
117     return is&lt;RenderView&gt;(containingBlock) ? nullptr : containingBlock;
118 }
119 
120 static SelectionData collect(const SelectionRangeData::Context&amp; selection, bool repaintDifference)
121 {
<span class="line-modified">122     SelectionData oldSelectionData { selection.startPosition(), selection.endPosition(), { }, { } };</span>
123     // Blocks contain selected objects and fill gaps between them, either on the left, right, or in between lines and blocks.
124     // In order to get the repaint rect right, we have to examine left, middle, and right rects individually, since otherwise
125     // the union of those rects might remain the same even when changes have occurred.
126     auto* start = selection.start();
127     RenderObject* stop = nullptr;
128     if (selection.end())
<span class="line-modified">129         stop = rendererAfterPosition(*selection.end(), selection.endPosition().value());</span>
130     SelectionIterator selectionIterator(start);
131     while (start &amp;&amp; start != stop) {
132         if (isValidRendererForSelection(*start, selection)) {
133             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
134             oldSelectionData.renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, true));
135             if (repaintDifference) {
136                 for (auto* block = containingBlockBelowView(*start); block; block = containingBlockBelowView(*block)) {
137                     auto&amp; blockInfo = oldSelectionData.blocks.add(block, nullptr).iterator-&gt;value;
138                     if (blockInfo)
139                         break;
140                     blockInfo = makeUnique&lt;RenderBlockSelectionInfo&gt;(*block);
141                 }
142             }
143         }
144         start = selectionIterator.next();
145     }
146     return oldSelectionData;
147 }
148 
149 SelectionRangeData::SelectionRangeData(RenderView&amp; view)
150     : m_renderView(view)
151 #if ENABLE(SERVICE_CONTROLS)
152     , m_selectionRectGatherer(view)
153 #endif
154 {
155 }
156 







































157 void SelectionRangeData::set(const Context&amp; selection, RepaintMode blockRepaintMode)
158 {
<span class="line-removed">159     // Make sure both our start and end objects are defined.</span>
<span class="line-removed">160     // Check www.msnbc.com and try clicking around to find the case where this happened.</span>
161     if ((selection.start() &amp;&amp; !selection.end()) || (selection.end() &amp;&amp; !selection.start()))
162         return;
163     // Just return if the selection hasn&#39;t changed.
164     auto isCaret = m_renderView.frame().selection().isCaret();
165     if (selection == m_selectionContext &amp;&amp; m_selectionWasCaret == isCaret)
166         return;
167 #if ENABLE(SERVICE_CONTROLS)
168     // Clear the current rects and create a notifier for the new rects we are about to gather.
169     // The Notifier updates the Editor when it goes out of scope and is destroyed.
170     auto rectNotifier = m_selectionRectGatherer.clearAndCreateNotifier();
171 #endif
172     m_selectionWasCaret = isCaret;
173     apply(selection, blockRepaintMode);
174 }
175 
176 void SelectionRangeData::clear()
177 {
178     m_renderView.layer()-&gt;repaintBlockSelectionGaps();
179     set({ }, SelectionRangeData::RepaintMode::NewMinusOld);
180 }
181 
182 void SelectionRangeData::repaint() const
183 {
184     HashSet&lt;RenderBlock*&gt; processedBlocks;
185     RenderObject* end = nullptr;
186     if (m_selectionContext.end())
<span class="line-modified">187         end = rendererAfterPosition(*m_selectionContext.end(), m_selectionContext.endPosition().value());</span>
188     SelectionIterator selectionIterator(m_selectionContext.start());
189     for (auto* renderer = selectionIterator.current(); renderer &amp;&amp; renderer != end; renderer = selectionIterator.next()) {
190         if (!renderer-&gt;canBeSelectionLeaf() &amp;&amp; renderer != m_selectionContext.start() &amp;&amp; renderer != m_selectionContext.end())
191             continue;
192         if (renderer-&gt;selectionState() == RenderObject::SelectionNone)
193             continue;
194         RenderSelectionInfo(*renderer, true).repaint();
195         // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
196         for (auto* block = containingBlockBelowView(*renderer); block; block = containingBlockBelowView(*block)) {
197             if (!processedBlocks.add(block).isNewEntry)
198                 break;
199             RenderSelectionInfo(*block, true).repaint();
200         }
201     }
202 }
203 
204 IntRect SelectionRangeData::collectBounds(ClipToVisibleContent clipToVisibleContent) const
205 {
206     SelectionData::RendererMap renderers;
207     auto* start = m_selectionContext.start();
208     RenderObject* stop = nullptr;
209     if (m_selectionContext.end())
<span class="line-modified">210         stop = rendererAfterPosition(*m_selectionContext.end(), m_selectionContext.endPosition().value());</span>
211     SelectionIterator selectionIterator(start);
212     while (start &amp;&amp; start != stop) {
213         if ((start-&gt;canBeSelectionLeaf() || start == m_selectionContext.start() || start == m_selectionContext.end())
214             &amp;&amp; start-&gt;selectionState() != RenderObject::SelectionNone) {
215             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
216             renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, clipToVisibleContent == ClipToVisibleContent::Yes));
217             auto* block = start-&gt;containingBlock();
218             while (block &amp;&amp; !is&lt;RenderView&gt;(*block)) {
219                 std::unique_ptr&lt;RenderSelectionInfo&gt;&amp; blockInfo = renderers.add(block, nullptr).iterator-&gt;value;
220                 if (blockInfo)
221                     break;
222                 blockInfo = makeUnique&lt;RenderSelectionInfo&gt;(*block, clipToVisibleContent == ClipToVisibleContent::Yes);
223                 block = block-&gt;containingBlock();
224             }
225         }
226         start = selectionIterator.next();
227     }
228 
229     // Now create a single bounding box rect that encloses the whole selection.
230     LayoutRect selectionRect;
</pre>
<hr />
<pre>
244 {
245     auto oldSelectionData = collect(m_selectionContext, blockRepaintMode == RepaintMode::NewXOROld);
246     // Remove current selection.
247     for (auto* renderer : oldSelectionData.renderers.keys())
248         renderer-&gt;setSelectionStateIfNeeded(RenderObject::SelectionNone);
249     m_selectionContext = newSelection;
250     auto* selectionStart = m_selectionContext.start();
251     // Update the selection status of all objects between selectionStart and selectionEnd
252     if (selectionStart &amp;&amp; selectionStart == m_selectionContext.end())
253         selectionStart-&gt;setSelectionStateIfNeeded(RenderObject::SelectionBoth);
254     else {
255         if (selectionStart)
256             selectionStart-&gt;setSelectionStateIfNeeded(RenderObject::SelectionStart);
257         if (auto* end = m_selectionContext.end())
258             end-&gt;setSelectionStateIfNeeded(RenderObject::SelectionEnd);
259     }
260 
261     RenderObject* selectionEnd = nullptr;
262     auto* selectionDataEnd = m_selectionContext.end();
263     if (selectionDataEnd)
<span class="line-modified">264         selectionEnd = rendererAfterPosition(*selectionDataEnd, m_selectionContext.endPosition().value());</span>
265     SelectionIterator selectionIterator(selectionStart);
266     for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
267         if (currentRenderer == selectionStart || currentRenderer == m_selectionContext.end())
268             continue;
269         if (!currentRenderer-&gt;canBeSelectionLeaf())
270             continue;
271         currentRenderer-&gt;setSelectionStateIfNeeded(RenderObject::SelectionInside);
272     }
273 
274     if (blockRepaintMode != RepaintMode::Nothing)
275         m_renderView.layer()-&gt;clearBlockSelectionGapsBounds();
276 
277     // Now that the selection state has been updated for the new objects, walk them again and
278     // put them in the new objects list.
279     SelectionData::RendererMap newSelectedRenderers;
280     SelectionData::RenderBlockMap newSelectedBlocks;
281     selectionIterator = SelectionIterator(selectionStart);
282     for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
283         if (isValidRendererForSelection(*currentRenderer, m_selectionContext)) {
284             std::unique_ptr&lt;RenderSelectionInfo&gt; selectionInfo = makeUnique&lt;RenderSelectionInfo&gt;(*currentRenderer, true);
</pre>
<hr />
<pre>
295                 if (blockInfo)
296                     break;
297                 blockInfo = makeUnique&lt;RenderBlockSelectionInfo&gt;(*containingBlock);
298                 containingBlock = containingBlock-&gt;containingBlock();
299 #if ENABLE(SERVICE_CONTROLS)
300                 m_selectionRectGatherer.addGapRects(blockInfo-&gt;repaintContainer(), blockInfo-&gt;rects());
301 #endif
302             }
303         }
304     }
305 
306     if (blockRepaintMode == RepaintMode::Nothing)
307         return;
308 
309     // Have any of the old selected objects changed compared to the new selection?
310     for (auto&amp; selectedRendererInfo : oldSelectionData.renderers) {
311         auto* renderer = selectedRendererInfo.key;
312         auto* newInfo = newSelectedRenderers.get(renderer);
313         auto* oldInfo = selectedRendererInfo.value.get();
314         if (!newInfo || oldInfo-&gt;rect() != newInfo-&gt;rect() || oldInfo-&gt;state() != newInfo-&gt;state()
<span class="line-modified">315             || (m_selectionContext.start() == renderer &amp;&amp; oldSelectionData.startPosition != m_selectionContext.startPosition())</span>
<span class="line-modified">316             || (m_selectionContext.end() == renderer &amp;&amp; oldSelectionData.endPosition != m_selectionContext.endPosition())) {</span>
317             oldInfo-&gt;repaint();
318             if (newInfo) {
319                 newInfo-&gt;repaint();
320                 newSelectedRenderers.remove(renderer);
321             }
322         }
323     }
324 
325     // Any new objects that remain were not found in the old objects dict, and so they need to be updated.
326     for (auto&amp; selectedRendererInfo : newSelectedRenderers)
327         selectedRendererInfo.value-&gt;repaint();
328 
329     // Have any of the old blocks changed?
330     for (auto&amp; selectedBlockInfo : oldSelectionData.blocks) {
331         auto* block = selectedBlockInfo.key;
332         auto* newInfo = newSelectedBlocks.get(block);
333         auto* oldInfo = selectedBlockInfo.value.get();
334         if (!newInfo || oldInfo-&gt;rects() != newInfo-&gt;rects() || oldInfo-&gt;state() != newInfo-&gt;state()) {
335             oldInfo-&gt;repaint();
336             if (newInfo) {
</pre>
</td>
<td>
<hr />
<pre>
 32 #include &quot;SelectionRangeData.h&quot;
 33 
 34 #include &quot;Document.h&quot;
 35 #include &quot;FrameSelection.h&quot;
 36 #include &quot;Position.h&quot;
 37 #include &quot;Range.h&quot;
 38 #include &quot;RenderLayer.h&quot;
 39 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;
 40 #include &quot;RenderObject.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;VisibleSelection.h&quot;
 43 
 44 namespace WebCore {
 45 
 46 namespace { // See bug #177808.
 47 
 48 struct SelectionData {
 49     using RendererMap = HashMap&lt;RenderObject*, std::unique_ptr&lt;RenderSelectionInfo&gt;&gt;;
 50     using RenderBlockMap = HashMap&lt;const RenderBlock*, std::unique_ptr&lt;RenderBlockSelectionInfo&gt;&gt;;
 51 
<span class="line-modified"> 52     Optional&lt;unsigned&gt; startOffset;</span>
<span class="line-modified"> 53     Optional&lt;unsigned&gt; endOffset;</span>
 54     RendererMap renderers;
 55     RenderBlockMap blocks;
 56 };
 57 
 58 class SelectionIterator {
 59 public:
 60     SelectionIterator(RenderObject* start)
 61         : m_current(start)
 62     {
 63         checkForSpanner();
 64     }
 65 
 66     RenderObject* current() const
 67     {
 68         return m_current;
 69     }
 70 
 71     RenderObject* next()
 72     {
 73         RenderObject* currentSpan = m_spannerStack.isEmpty() ? nullptr : m_spannerStack.last()-&gt;spanner();
</pre>
<hr />
<pre>
 81         }
 82         return m_current;
 83     }
 84 
 85 private:
 86     void checkForSpanner()
 87     {
 88         if (!is&lt;RenderMultiColumnSpannerPlaceholder&gt;(m_current))
 89             return;
 90         auto&amp; placeholder = downcast&lt;RenderMultiColumnSpannerPlaceholder&gt;(*m_current);
 91         m_spannerStack.append(&amp;placeholder);
 92         m_current = placeholder.spanner();
 93     }
 94 
 95     RenderObject* m_current { nullptr };
 96     Vector&lt;RenderMultiColumnSpannerPlaceholder*&gt; m_spannerStack;
 97 };
 98 
 99 } // anonymous namespace
100 
<span class="line-modified">101 static RenderObject* rendererAfterOffset(const RenderObject&amp; renderer, unsigned offset)</span>
102 {
103     auto* child = renderer.childAt(offset);
104     return child ? child : renderer.nextInPreOrderAfterChildren();
105 }
106 
107 static bool isValidRendererForSelection(const RenderObject&amp; renderer, const SelectionRangeData::Context&amp; selection)
108 {
109     return (renderer.canBeSelectionLeaf() || &amp;renderer == selection.start() || &amp;renderer == selection.end())
110         &amp;&amp; renderer.selectionState() != RenderObject::SelectionNone
111         &amp;&amp; renderer.containingBlock();
112 }
113 
114 static RenderBlock* containingBlockBelowView(const RenderObject&amp; renderer)
115 {
116     auto* containingBlock = renderer.containingBlock();
117     return is&lt;RenderView&gt;(containingBlock) ? nullptr : containingBlock;
118 }
119 
120 static SelectionData collect(const SelectionRangeData::Context&amp; selection, bool repaintDifference)
121 {
<span class="line-modified">122     SelectionData oldSelectionData { selection.startOffset(), selection.endOffset(), { }, { } };</span>
123     // Blocks contain selected objects and fill gaps between them, either on the left, right, or in between lines and blocks.
124     // In order to get the repaint rect right, we have to examine left, middle, and right rects individually, since otherwise
125     // the union of those rects might remain the same even when changes have occurred.
126     auto* start = selection.start();
127     RenderObject* stop = nullptr;
128     if (selection.end())
<span class="line-modified">129         stop = rendererAfterOffset(*selection.end(), selection.endOffset().value());</span>
130     SelectionIterator selectionIterator(start);
131     while (start &amp;&amp; start != stop) {
132         if (isValidRendererForSelection(*start, selection)) {
133             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
134             oldSelectionData.renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, true));
135             if (repaintDifference) {
136                 for (auto* block = containingBlockBelowView(*start); block; block = containingBlockBelowView(*block)) {
137                     auto&amp; blockInfo = oldSelectionData.blocks.add(block, nullptr).iterator-&gt;value;
138                     if (blockInfo)
139                         break;
140                     blockInfo = makeUnique&lt;RenderBlockSelectionInfo&gt;(*block);
141                 }
142             }
143         }
144         start = selectionIterator.next();
145     }
146     return oldSelectionData;
147 }
148 
149 SelectionRangeData::SelectionRangeData(RenderView&amp; view)
150     : m_renderView(view)
151 #if ENABLE(SERVICE_CONTROLS)
152     , m_selectionRectGatherer(view)
153 #endif
154 {
155 }
156 
<span class="line-added">157 void SelectionRangeData::setContext(const Context&amp; context)</span>
<span class="line-added">158 {</span>
<span class="line-added">159     ASSERT(context.start() &amp;&amp; context.end());</span>
<span class="line-added">160     m_selectionContext = context;</span>
<span class="line-added">161 }</span>
<span class="line-added">162 </span>
<span class="line-added">163 RenderObject::SelectionState SelectionRangeData::selectionStateForRenderer(RenderObject&amp; renderer)</span>
<span class="line-added">164 {</span>
<span class="line-added">165     // FIXME: we shouldln&#39;t have to check that a renderer is a descendant of the render node</span>
<span class="line-added">166     // from the range. This is likely because we aren&#39;t using VisiblePositions yet.</span>
<span class="line-added">167     // Planned fix in a followup: &lt;rdar://problem/58095923&gt;</span>
<span class="line-added">168     // https://bugs.webkit.org/show_bug.cgi?id=205529</span>
<span class="line-added">169 </span>
<span class="line-added">170     if (&amp;renderer == m_selectionContext.start()) {</span>
<span class="line-added">171         if (m_selectionContext.start() &amp;&amp; m_selectionContext.end() &amp;&amp; m_selectionContext.start() == m_selectionContext.end())</span>
<span class="line-added">172             return RenderObject::SelectionBoth;</span>
<span class="line-added">173         if (m_selectionContext.start())</span>
<span class="line-added">174             return RenderObject::SelectionStart;</span>
<span class="line-added">175     }</span>
<span class="line-added">176     if (&amp;renderer == m_selectionContext.end())</span>
<span class="line-added">177         return RenderObject::SelectionEnd;</span>
<span class="line-added">178 </span>
<span class="line-added">179     RenderObject* selectionEnd = nullptr;</span>
<span class="line-added">180     auto* selectionDataEnd = m_selectionContext.end();</span>
<span class="line-added">181     if (selectionDataEnd)</span>
<span class="line-added">182         selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());</span>
<span class="line-added">183     SelectionIterator selectionIterator(m_selectionContext.start());</span>
<span class="line-added">184     for (auto* currentRenderer = m_selectionContext.start(); currentRenderer &amp;&amp; currentRenderer != m_selectionContext.end(); currentRenderer = selectionIterator.next()) {</span>
<span class="line-added">185         if (currentRenderer == m_selectionContext.start() || currentRenderer == m_selectionContext.end())</span>
<span class="line-added">186             continue;</span>
<span class="line-added">187         if (!currentRenderer-&gt;canBeSelectionLeaf())</span>
<span class="line-added">188             continue;</span>
<span class="line-added">189         if (&amp;renderer == currentRenderer)</span>
<span class="line-added">190             return RenderObject::SelectionInside;</span>
<span class="line-added">191     }</span>
<span class="line-added">192     return RenderObject::SelectionNone;</span>
<span class="line-added">193 </span>
<span class="line-added">194 }</span>
<span class="line-added">195 </span>
196 void SelectionRangeData::set(const Context&amp; selection, RepaintMode blockRepaintMode)
197 {


198     if ((selection.start() &amp;&amp; !selection.end()) || (selection.end() &amp;&amp; !selection.start()))
199         return;
200     // Just return if the selection hasn&#39;t changed.
201     auto isCaret = m_renderView.frame().selection().isCaret();
202     if (selection == m_selectionContext &amp;&amp; m_selectionWasCaret == isCaret)
203         return;
204 #if ENABLE(SERVICE_CONTROLS)
205     // Clear the current rects and create a notifier for the new rects we are about to gather.
206     // The Notifier updates the Editor when it goes out of scope and is destroyed.
207     auto rectNotifier = m_selectionRectGatherer.clearAndCreateNotifier();
208 #endif
209     m_selectionWasCaret = isCaret;
210     apply(selection, blockRepaintMode);
211 }
212 
213 void SelectionRangeData::clear()
214 {
215     m_renderView.layer()-&gt;repaintBlockSelectionGaps();
216     set({ }, SelectionRangeData::RepaintMode::NewMinusOld);
217 }
218 
219 void SelectionRangeData::repaint() const
220 {
221     HashSet&lt;RenderBlock*&gt; processedBlocks;
222     RenderObject* end = nullptr;
223     if (m_selectionContext.end())
<span class="line-modified">224         end = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());</span>
225     SelectionIterator selectionIterator(m_selectionContext.start());
226     for (auto* renderer = selectionIterator.current(); renderer &amp;&amp; renderer != end; renderer = selectionIterator.next()) {
227         if (!renderer-&gt;canBeSelectionLeaf() &amp;&amp; renderer != m_selectionContext.start() &amp;&amp; renderer != m_selectionContext.end())
228             continue;
229         if (renderer-&gt;selectionState() == RenderObject::SelectionNone)
230             continue;
231         RenderSelectionInfo(*renderer, true).repaint();
232         // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
233         for (auto* block = containingBlockBelowView(*renderer); block; block = containingBlockBelowView(*block)) {
234             if (!processedBlocks.add(block).isNewEntry)
235                 break;
236             RenderSelectionInfo(*block, true).repaint();
237         }
238     }
239 }
240 
241 IntRect SelectionRangeData::collectBounds(ClipToVisibleContent clipToVisibleContent) const
242 {
243     SelectionData::RendererMap renderers;
244     auto* start = m_selectionContext.start();
245     RenderObject* stop = nullptr;
246     if (m_selectionContext.end())
<span class="line-modified">247         stop = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());</span>
248     SelectionIterator selectionIterator(start);
249     while (start &amp;&amp; start != stop) {
250         if ((start-&gt;canBeSelectionLeaf() || start == m_selectionContext.start() || start == m_selectionContext.end())
251             &amp;&amp; start-&gt;selectionState() != RenderObject::SelectionNone) {
252             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
253             renderers.set(start, makeUnique&lt;RenderSelectionInfo&gt;(*start, clipToVisibleContent == ClipToVisibleContent::Yes));
254             auto* block = start-&gt;containingBlock();
255             while (block &amp;&amp; !is&lt;RenderView&gt;(*block)) {
256                 std::unique_ptr&lt;RenderSelectionInfo&gt;&amp; blockInfo = renderers.add(block, nullptr).iterator-&gt;value;
257                 if (blockInfo)
258                     break;
259                 blockInfo = makeUnique&lt;RenderSelectionInfo&gt;(*block, clipToVisibleContent == ClipToVisibleContent::Yes);
260                 block = block-&gt;containingBlock();
261             }
262         }
263         start = selectionIterator.next();
264     }
265 
266     // Now create a single bounding box rect that encloses the whole selection.
267     LayoutRect selectionRect;
</pre>
<hr />
<pre>
281 {
282     auto oldSelectionData = collect(m_selectionContext, blockRepaintMode == RepaintMode::NewXOROld);
283     // Remove current selection.
284     for (auto* renderer : oldSelectionData.renderers.keys())
285         renderer-&gt;setSelectionStateIfNeeded(RenderObject::SelectionNone);
286     m_selectionContext = newSelection;
287     auto* selectionStart = m_selectionContext.start();
288     // Update the selection status of all objects between selectionStart and selectionEnd
289     if (selectionStart &amp;&amp; selectionStart == m_selectionContext.end())
290         selectionStart-&gt;setSelectionStateIfNeeded(RenderObject::SelectionBoth);
291     else {
292         if (selectionStart)
293             selectionStart-&gt;setSelectionStateIfNeeded(RenderObject::SelectionStart);
294         if (auto* end = m_selectionContext.end())
295             end-&gt;setSelectionStateIfNeeded(RenderObject::SelectionEnd);
296     }
297 
298     RenderObject* selectionEnd = nullptr;
299     auto* selectionDataEnd = m_selectionContext.end();
300     if (selectionDataEnd)
<span class="line-modified">301         selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());</span>
302     SelectionIterator selectionIterator(selectionStart);
303     for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
304         if (currentRenderer == selectionStart || currentRenderer == m_selectionContext.end())
305             continue;
306         if (!currentRenderer-&gt;canBeSelectionLeaf())
307             continue;
308         currentRenderer-&gt;setSelectionStateIfNeeded(RenderObject::SelectionInside);
309     }
310 
311     if (blockRepaintMode != RepaintMode::Nothing)
312         m_renderView.layer()-&gt;clearBlockSelectionGapsBounds();
313 
314     // Now that the selection state has been updated for the new objects, walk them again and
315     // put them in the new objects list.
316     SelectionData::RendererMap newSelectedRenderers;
317     SelectionData::RenderBlockMap newSelectedBlocks;
318     selectionIterator = SelectionIterator(selectionStart);
319     for (auto* currentRenderer = selectionStart; currentRenderer &amp;&amp; currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
320         if (isValidRendererForSelection(*currentRenderer, m_selectionContext)) {
321             std::unique_ptr&lt;RenderSelectionInfo&gt; selectionInfo = makeUnique&lt;RenderSelectionInfo&gt;(*currentRenderer, true);
</pre>
<hr />
<pre>
332                 if (blockInfo)
333                     break;
334                 blockInfo = makeUnique&lt;RenderBlockSelectionInfo&gt;(*containingBlock);
335                 containingBlock = containingBlock-&gt;containingBlock();
336 #if ENABLE(SERVICE_CONTROLS)
337                 m_selectionRectGatherer.addGapRects(blockInfo-&gt;repaintContainer(), blockInfo-&gt;rects());
338 #endif
339             }
340         }
341     }
342 
343     if (blockRepaintMode == RepaintMode::Nothing)
344         return;
345 
346     // Have any of the old selected objects changed compared to the new selection?
347     for (auto&amp; selectedRendererInfo : oldSelectionData.renderers) {
348         auto* renderer = selectedRendererInfo.key;
349         auto* newInfo = newSelectedRenderers.get(renderer);
350         auto* oldInfo = selectedRendererInfo.value.get();
351         if (!newInfo || oldInfo-&gt;rect() != newInfo-&gt;rect() || oldInfo-&gt;state() != newInfo-&gt;state()
<span class="line-modified">352             || (m_selectionContext.start() == renderer &amp;&amp; oldSelectionData.startOffset != m_selectionContext.startOffset())</span>
<span class="line-modified">353             || (m_selectionContext.end() == renderer &amp;&amp; oldSelectionData.endOffset != m_selectionContext.endOffset())) {</span>
354             oldInfo-&gt;repaint();
355             if (newInfo) {
356                 newInfo-&gt;repaint();
357                 newSelectedRenderers.remove(renderer);
358             }
359         }
360     }
361 
362     // Any new objects that remain were not found in the old objects dict, and so they need to be updated.
363     for (auto&amp; selectedRendererInfo : newSelectedRenderers)
364         selectedRendererInfo.value-&gt;repaint();
365 
366     // Have any of the old blocks changed?
367     for (auto&amp; selectedBlockInfo : oldSelectionData.blocks) {
368         auto* block = selectedBlockInfo.key;
369         auto* newInfo = newSelectedBlocks.get(block);
370         auto* oldInfo = selectedBlockInfo.value.get();
371         if (!newInfo || oldInfo-&gt;rects() != newInfo-&gt;rects() || oldInfo-&gt;state() != newInfo-&gt;state()) {
372             oldInfo-&gt;repaint();
373             if (newInfo) {
</pre>
</td>
</tr>
</table>
<center><a href="RootInlineBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
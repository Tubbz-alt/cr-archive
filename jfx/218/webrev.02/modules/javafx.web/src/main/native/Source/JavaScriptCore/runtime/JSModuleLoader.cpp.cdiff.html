<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSModuleEnvironment.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleLoader.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,11 ***</span>
  #include &quot;Error.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSGlobalObjectFunctions.h&quot;
  #include &quot;JSInternalPromise.h&quot;
<span class="line-removed">- #include &quot;JSInternalPromiseDeferred.h&quot;</span>
  #include &quot;JSMap.h&quot;
  #include &quot;JSModuleEnvironment.h&quot;
  #include &quot;JSModuleNamespaceObject.h&quot;
  #include &quot;JSModuleRecord.h&quot;
  #include &quot;JSSourceCode.h&quot;
<span class="line-new-header">--- 33,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,18 ***</span>
  #include &quot;Parser.h&quot;
  #include &quot;ParserError.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(ExecState*);</span>
  
  }
  
  #include &quot;JSModuleLoader.lut.h&quot;
  
<span class="line-new-header">--- 47,18 ---</span>
  #include &quot;Parser.h&quot;
  #include &quot;ParserError.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(JSGlobalObject*, CallFrame*);</span>
  
  }
  
  #include &quot;JSModuleLoader.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,61 ***</span>
  JSModuleLoader::JSModuleLoader(VM&amp; vm, Structure* structure)
      : JSNonFinalObject(vm, structure)
  {
  }
  
<span class="line-modified">! void JSModuleLoader::finishCreation(ExecState* exec, VM&amp; vm, JSGlobalObject* globalObject)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
<span class="line-modified">!     JSMap* map = JSMap::create(exec, vm, globalObject-&gt;mapStructure());</span>
      scope.releaseAssertNoException();
      putDirect(vm, Identifier::fromString(vm, &quot;registry&quot;), map);
  }
  
  // ------------------------------ Functions --------------------------------
  
<span class="line-modified">! static String printableModuleKey(ExecState* exec, JSValue key)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      if (key.isString() || key.isSymbol()) {
<span class="line-modified">!         auto propertyName = key.toPropertyKey(exec);</span>
          scope.assertNoException(); // This is OK since this function is just for debugging purpose.
          return propertyName.impl();
      }
      return vm.propertyNames-&gt;emptyIdentifier.impl();
  }
  
<span class="line-modified">! JSArray* JSModuleLoader::dependencyKeysIfEvaluated(ExecState* exec, JSValue key)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().dependencyKeysIfEvaluatedPublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
      arguments.append(key);
  
<span class="line-modified">!     JSValue result = call(exec, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return jsDynamicCast&lt;JSArray*&gt;(vm, result);
  }
  
<span class="line-modified">! JSValue JSModuleLoader::provideFetch(ExecState* exec, JSValue key, const SourceCode&amp; sourceCode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().provideFetchPublicName()));</span>
      RETURN_IF_EXCEPTION(scope, { });
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
<span class="line-new-header">--- 98,61 ---</span>
  JSModuleLoader::JSModuleLoader(VM&amp; vm, Structure* structure)
      : JSNonFinalObject(vm, structure)
  {
  }
  
<span class="line-modified">! void JSModuleLoader::finishCreation(JSGlobalObject* globalObject, VM&amp; vm)</span>
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
<span class="line-modified">!     JSMap* map = JSMap::create(globalObject, vm, globalObject-&gt;mapStructure());</span>
      scope.releaseAssertNoException();
      putDirect(vm, Identifier::fromString(vm, &quot;registry&quot;), map);
  }
  
  // ------------------------------ Functions --------------------------------
  
<span class="line-modified">! static String printableModuleKey(JSGlobalObject* globalObject, JSValue key)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     auto scope = DECLARE_CATCH_SCOPE(vm);</span>
      if (key.isString() || key.isSymbol()) {
<span class="line-modified">!         auto propertyName = key.toPropertyKey(globalObject);</span>
          scope.assertNoException(); // This is OK since this function is just for debugging purpose.
          return propertyName.impl();
      }
      return vm.propertyNames-&gt;emptyIdentifier.impl();
  }
  
<span class="line-modified">! JSArray* JSModuleLoader::dependencyKeysIfEvaluated(JSGlobalObject* globalObject, JSValue key)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().dependencyKeysIfEvaluatedPublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
      arguments.append(key);
  
<span class="line-modified">!     JSValue result = call(globalObject, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      return jsDynamicCast&lt;JSArray*&gt;(vm, result);
  }
  
<span class="line-modified">! JSValue JSModuleLoader::provideFetch(JSGlobalObject* globalObject, JSValue key, const SourceCode&amp; sourceCode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().provideFetchPublicName()));</span>
      RETURN_IF_EXCEPTION(scope, { });
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,19 ***</span>
      MarkedArgumentBuffer arguments;
      arguments.append(key);
      arguments.append(JSSourceCode::create(vm, WTFMove(source)));
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, call(exec, function, callType, callData, this, arguments));</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::loadAndEvaluateModule(ExecState* exec, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().loadAndEvaluateModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
<span class="line-new-header">--- 160,19 ---</span>
      MarkedArgumentBuffer arguments;
      arguments.append(key);
      arguments.append(JSSourceCode::create(vm, WTFMove(source)));
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, call(globalObject, function, callType, callData, this, arguments));</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::loadAndEvaluateModule(JSGlobalObject* globalObject, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().loadAndEvaluateModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,21 ***</span>
      arguments.append(moduleName);
      arguments.append(parameters);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return jsCast&lt;JSInternalPromise*&gt;(promise);
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::loadModule(ExecState* exec, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().loadModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
<span class="line-new-header">--- 180,21 ---</span>
      arguments.append(moduleName);
      arguments.append(parameters);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     JSValue promise = call(globalObject, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return jsCast&lt;JSInternalPromise*&gt;(promise);
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::loadModule(JSGlobalObject* globalObject, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().loadModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,40 ***</span>
      arguments.append(moduleName);
      arguments.append(parameters);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return jsCast&lt;JSInternalPromise*&gt;(promise);
  }
  
<span class="line-modified">! JSValue JSModuleLoader::linkAndEvaluateModule(ExecState* exec, JSValue moduleKey, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().linkAndEvaluateModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, { });
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
      arguments.append(moduleKey);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, call(exec, function, callType, callData, this, arguments));</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::requestImportModule(ExecState* exec, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().requestImportModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      auto callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
<span class="line-new-header">--- 202,40 ---</span>
      arguments.append(moduleName);
      arguments.append(parameters);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     JSValue promise = call(globalObject, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return jsCast&lt;JSInternalPromise*&gt;(promise);
  }
  
<span class="line-modified">! JSValue JSModuleLoader::linkAndEvaluateModule(JSGlobalObject* globalObject, JSValue moduleKey, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().linkAndEvaluateModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, { });
      CallData callData;
      CallType callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
      arguments.append(moduleKey);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, call(globalObject, function, callType, callData, this, arguments));</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::requestImportModule(JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* function = jsCast&lt;JSObject*&gt;(get(globalObject, vm.propertyNames-&gt;builtinNames().requestImportModulePublicName()));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      CallData callData;
      auto callType = JSC::getCallData(vm, function, callData);
      ASSERT(callType != CallType::None);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,299 ***</span>
      arguments.append(jsString(vm, moduleKey.impl()));
      arguments.append(parameters);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return jsCast&lt;JSInternalPromise*&gt;(promise);
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::importModule(ExecState* exec, JSString* moduleName, JSValue parameters, const SourceOrigin&amp; referrer)</span>
  {
<span class="line-modified">!     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">-         dataLog(&quot;Loader [import] &quot;, printableModuleKey(exec, moduleName), &quot;\n&quot;);</span>
  
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
      VM&amp; vm = globalObject-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule)
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule(globalObject, exec, this, moduleName, parameters, referrer));</span>
  
<span class="line-modified">!     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     auto moduleNameString = moduleName-&gt;value(exec);</span>
      if (UNLIKELY(catchScope.exception())) {
          JSValue exception = catchScope.exception()-&gt;value();
          catchScope.clearException();
<span class="line-modified">!         deferred-&gt;reject(exec, exception);</span>
          catchScope.clearException();
<span class="line-modified">!         return deferred-&gt;promise();</span>
      }
<span class="line-modified">!     deferred-&gt;reject(exec, createError(exec, makeString(&quot;Could not import the module &#39;&quot;, moduleNameString, &quot;&#39;.&quot;)));</span>
      catchScope.clearException();
<span class="line-modified">!     return deferred-&gt;promise();</span>
  }
  
<span class="line-modified">! Identifier JSModuleLoader::resolveSync(ExecState* exec, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">-         dataLog(&quot;Loader [resolve] &quot;, printableModuleKey(exec, name), &quot;\n&quot;);</span>
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve)
<span class="line-modified">!         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve(globalObject, exec, this, name, referrer, scriptFetcher);</span>
<span class="line-modified">!     return name.toPropertyKey(exec);</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::resolve(ExecState* exec, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="line-modified">!     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     const Identifier moduleKey = resolveSync(exec, name, referrer, scriptFetcher);</span>
      if (UNLIKELY(catchScope.exception())) {
          JSValue exception = catchScope.exception();
          catchScope.clearException();
<span class="line-modified">!         auto result = deferred-&gt;reject(exec, exception);</span>
          catchScope.clearException();
<span class="line-modified">!         return result;</span>
      }
<span class="line-modified">!     auto result = deferred-&gt;resolve(exec, identifierToJSValue(vm, moduleKey));</span>
      catchScope.clearException();
<span class="line-modified">!     return result;</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::fetch(ExecState* exec, JSValue key, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">-         dataLog(&quot;Loader [fetch] &quot;, printableModuleKey(exec, key), &quot;\n&quot;);</span>
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      VM&amp; vm = globalObject-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch)
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch(globalObject, exec, this, key, parameters, scriptFetcher));</span>
  
<span class="line-modified">!     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     String moduleKey = key.toWTFString(exec);</span>
      if (UNLIKELY(catchScope.exception())) {
          JSValue exception = catchScope.exception()-&gt;value();
          catchScope.clearException();
<span class="line-modified">!         deferred-&gt;reject(exec, exception);</span>
          catchScope.clearException();
<span class="line-modified">!         return deferred-&gt;promise();</span>
      }
<span class="line-modified">!     deferred-&gt;reject(exec, createError(exec, makeString(&quot;Could not open the module &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
      catchScope.clearException();
<span class="line-modified">!     return deferred-&gt;promise();</span>
  }
  
<span class="line-modified">! JSObject* JSModuleLoader::createImportMetaProperties(ExecState* exec, JSValue key, JSModuleRecord* moduleRecord, JSValue scriptFetcher)</span>
  {
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties)
<span class="line-modified">!         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties(globalObject, exec, this, key, moduleRecord, scriptFetcher);</span>
<span class="line-modified">!     return constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
  }
  
<span class="line-modified">! JSValue JSModuleLoader::evaluate(ExecState* exec, JSValue key, JSValue moduleRecordValue, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">-         dataLog(&quot;Loader [evaluate] &quot;, printableModuleKey(exec, key), &quot;\n&quot;);</span>
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate)
<span class="line-modified">!         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate(globalObject, exec, this, key, moduleRecordValue, scriptFetcher);</span>
  
<span class="line-modified">!     return evaluateNonVirtual(exec, key, moduleRecordValue, scriptFetcher);</span>
  }
  
<span class="line-modified">! JSValue JSModuleLoader::evaluateNonVirtual(ExecState* exec, JSValue, JSValue moduleRecordValue, JSValue)</span>
  {
<span class="line-modified">!     if (auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(exec-&gt;vm(), moduleRecordValue))</span>
<span class="line-modified">!         return moduleRecord-&gt;evaluate(exec);</span>
      return jsUndefined();
  }
  
<span class="line-modified">! JSModuleNamespaceObject* JSModuleLoader::getModuleNamespaceObject(ExecState* exec, JSValue moduleRecordValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, moduleRecordValue);
      if (!moduleRecord) {
<span class="line-modified">!         throwTypeError(exec, scope);</span>
          return nullptr;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, moduleRecord-&gt;getModuleNamespace(exec));</span>
  }
  
  // ------------------------------ Functions --------------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
  
<span class="line-modified">!     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">-     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return JSValue::encode(result);</span>
      };
  
<span class="line-modified">!     const Identifier moduleKey = exec-&gt;argument(0).toPropertyKey(exec);</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
<span class="line-modified">!     JSValue source = exec-&gt;argument(1);</span>
      auto* jsSourceCode = jsCast&lt;JSSourceCode*&gt;(source);
      SourceCode sourceCode = jsSourceCode-&gt;sourceCode();
  
  #if ENABLE(WEBASSEMBLY)
      if (sourceCode.provider()-&gt;sourceType() == SourceProviderSourceType::WebAssembly)
<span class="line-modified">!         return JSValue::encode(JSWebAssembly::instantiate(exec, deferred, moduleKey, jsSourceCode));</span>
  #endif
  
      CodeProfiling profile(sourceCode);
  
      ParserError error;
      std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
          vm, sourceCode, Identifier(), JSParserBuiltinMode::NotBuiltin,
          JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
      if (error.isValid())
<span class="line-modified">!         return reject(error.toErrorObject(exec-&gt;lexicalGlobalObject(), sourceCode));</span>
      ASSERT(moduleProgramNode);
  
<span class="line-modified">!     ModuleAnalyzer moduleAnalyzer(exec, moduleKey, sourceCode, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
<span class="line-modified">!     auto result = deferred-&gt;resolve(exec, moduleAnalyzer.analyze(*moduleProgramNode));</span>
      catchScope.clearException();
<span class="line-modified">!     return JSValue::encode(result);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, exec-&gt;argument(0));</span>
      if (!moduleRecord)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr)));</span>
  
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, nullptr, moduleRecord-&gt;requestedModules().size());</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      size_t i = 0;
      for (auto&amp; key : moduleRecord-&gt;requestedModules()) {
<span class="line-modified">!         result-&gt;putDirectIndex(exec, i++, jsString(vm, key.get()));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, exec-&gt;argument(0));</span>
      if (!moduleRecord)
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">-         dataLog(&quot;Loader [link] &quot;, moduleRecord-&gt;moduleKey(), &quot;\n&quot;);</span>
  
<span class="line-modified">!     moduleRecord-&gt;link(exec, exec-&gt;argument(1));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      return JSValue::encode(jsUndefined());
  }
  
  // ------------------------------ Hook Functions ---------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      // Hook point, Loader.resolve.
      // https://whatwg.github.io/loader/#browser-resolve
      // Take the name and resolve it to the unique identifier for the resource location.
      // For example, take the &quot;jquery&quot; and return the URL for the resource.
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(loader-&gt;resolve(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     auto result = loader-&gt;resolveSync(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(identifierToJSValue(vm, result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      // Hook point, Loader.fetch
      // https://whatwg.github.io/loader/#browser-fetch
      // Take the key and fetch the resource actually.
      // For example, JavaScriptCore shell can provide the hook fetching the resource
      // from the local file system.
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(loader-&gt;fetch(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     auto* moduleNamespaceObject = loader-&gt;getModuleNamespaceObject(exec, exec-&gt;argument(0));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(moduleNamespaceObject);
  }
  
  // ------------------- Additional Hook Functions ---------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(ExecState* exec)</span>
  {
      // To instrument and retrieve the errors raised from the module execution,
      // we inserted the hook point here.
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(loader-&gt;evaluate(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
  }
  
  } // namespace JSC
<span class="line-new-header">--- 243,283 ---</span>
      arguments.append(jsString(vm, moduleKey.impl()));
      arguments.append(parameters);
      arguments.append(scriptFetcher);
      ASSERT(!arguments.hasOverflowed());
  
<span class="line-modified">!     JSValue promise = call(globalObject, function, callType, callData, this, arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      return jsCast&lt;JSInternalPromise*&gt;(promise);
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::importModule(JSGlobalObject* globalObject, JSString* moduleName, JSValue parameters, const SourceOrigin&amp; referrer)</span>
  {
<span class="line-modified">!     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [import] &quot;, printableModuleKey(globalObject, moduleName));</span>
  
      VM&amp; vm = globalObject-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule)
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule(globalObject, this, moduleName, parameters, referrer));</span>
  
<span class="line-modified">!     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     auto moduleNameString = moduleName-&gt;value(globalObject);</span>
      if (UNLIKELY(catchScope.exception())) {
          JSValue exception = catchScope.exception()-&gt;value();
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, exception);</span>
          catchScope.clearException();
<span class="line-modified">!         return promise;</span>
      }
<span class="line-modified">!     promise-&gt;reject(globalObject, createError(globalObject, makeString(&quot;Could not import the module &#39;&quot;, moduleNameString, &quot;&#39;.&quot;)));</span>
      catchScope.clearException();
<span class="line-modified">!     return promise;</span>
  }
  
<span class="line-modified">! Identifier JSModuleLoader::resolveSync(JSGlobalObject* globalObject, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [resolve] &quot;, printableModuleKey(globalObject, name));</span>
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve)
<span class="line-modified">!         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve(globalObject, this, name, referrer, scriptFetcher);</span>
<span class="line-modified">!     return name.toPropertyKey(globalObject);</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::resolve(JSGlobalObject* globalObject, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     const Identifier moduleKey = resolveSync(globalObject, name, referrer, scriptFetcher);</span>
      if (UNLIKELY(catchScope.exception())) {
          JSValue exception = catchScope.exception();
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, exception);</span>
          catchScope.clearException();
<span class="line-modified">!         return promise;</span>
      }
<span class="line-modified">!     promise-&gt;resolve(globalObject, identifierToJSValue(vm, moduleKey));</span>
      catchScope.clearException();
<span class="line-modified">!     return promise;</span>
  }
  
<span class="line-modified">! JSInternalPromise* JSModuleLoader::fetch(JSGlobalObject* globalObject, JSValue key, JSValue parameters, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [fetch] &quot;, printableModuleKey(globalObject, key));</span>
  
      VM&amp; vm = globalObject-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch)
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch(globalObject, this, key, parameters, scriptFetcher));</span>
  
<span class="line-modified">!     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
  
<span class="line-modified">!     String moduleKey = key.toWTFString(globalObject);</span>
      if (UNLIKELY(catchScope.exception())) {
          JSValue exception = catchScope.exception()-&gt;value();
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, exception);</span>
          catchScope.clearException();
<span class="line-modified">!         return promise;</span>
      }
<span class="line-modified">!     promise-&gt;reject(globalObject, createError(globalObject, makeString(&quot;Could not open the module &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
      catchScope.clearException();
<span class="line-modified">!     return promise;</span>
  }
  
<span class="line-modified">! JSObject* JSModuleLoader::createImportMetaProperties(JSGlobalObject* globalObject, JSValue key, JSModuleRecord* moduleRecord, JSValue scriptFetcher)</span>
  {
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties)
<span class="line-modified">!         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties(globalObject, this, key, moduleRecord, scriptFetcher);</span>
<span class="line-modified">!     return constructEmptyObject(globalObject-&gt;vm(), globalObject-&gt;nullPrototypeObjectStructure());</span>
  }
  
<span class="line-modified">! JSValue JSModuleLoader::evaluate(JSGlobalObject* globalObject, JSValue key, JSValue moduleRecordValue, JSValue scriptFetcher)</span>
  {
<span class="line-modified">!     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [evaluate] &quot;, printableModuleKey(globalObject, key));</span>
  
      if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate)
<span class="line-modified">!         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate(globalObject, this, key, moduleRecordValue, scriptFetcher);</span>
  
<span class="line-modified">!     return evaluateNonVirtual(globalObject, key, moduleRecordValue, scriptFetcher);</span>
  }
  
<span class="line-modified">! JSValue JSModuleLoader::evaluateNonVirtual(JSGlobalObject* globalObject, JSValue, JSValue moduleRecordValue, JSValue)</span>
  {
<span class="line-modified">!     if (auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(globalObject-&gt;vm(), moduleRecordValue))</span>
<span class="line-modified">!         return moduleRecord-&gt;evaluate(globalObject);</span>
      return jsUndefined();
  }
  
<span class="line-modified">! JSModuleNamespaceObject* JSModuleLoader::getModuleNamespaceObject(JSGlobalObject* globalObject, JSValue moduleRecordValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, moduleRecordValue);
      if (!moduleRecord) {
<span class="line-modified">!         throwTypeError(globalObject, scope);</span>
          return nullptr;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, moduleRecord-&gt;getModuleNamespace(globalObject));</span>
  }
  
  // ------------------------------ Functions --------------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
  
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
      auto reject = [&amp;] (JSValue rejectionReason) {
          catchScope.clearException();
<span class="line-modified">!         promise-&gt;reject(globalObject, rejectionReason);</span>
          catchScope.clearException();
<span class="line-modified">!         return JSValue::encode(promise);</span>
      };
  
<span class="line-modified">!     const Identifier moduleKey = callFrame-&gt;argument(0).toPropertyKey(globalObject);</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
<span class="line-modified">!     JSValue source = callFrame-&gt;argument(1);</span>
      auto* jsSourceCode = jsCast&lt;JSSourceCode*&gt;(source);
      SourceCode sourceCode = jsSourceCode-&gt;sourceCode();
  
  #if ENABLE(WEBASSEMBLY)
      if (sourceCode.provider()-&gt;sourceType() == SourceProviderSourceType::WebAssembly)
<span class="line-modified">!         return JSValue::encode(JSWebAssembly::instantiate(globalObject, promise, moduleKey, jsSourceCode));</span>
  #endif
  
      CodeProfiling profile(sourceCode);
  
      ParserError error;
      std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
          vm, sourceCode, Identifier(), JSParserBuiltinMode::NotBuiltin,
          JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
      if (error.isValid())
<span class="line-modified">!         return reject(error.toErrorObject(globalObject, sourceCode));</span>
      ASSERT(moduleProgramNode);
  
<span class="line-modified">!     ModuleAnalyzer moduleAnalyzer(globalObject, moduleKey, sourceCode, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
      if (UNLIKELY(catchScope.exception()))
          return reject(catchScope.exception());
  
<span class="line-modified">!     promise-&gt;resolve(globalObject, moduleAnalyzer.analyze(*moduleProgramNode));</span>
      catchScope.clearException();
<span class="line-modified">!     return JSValue::encode(promise);</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!moduleRecord)
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(globalObject, nullptr)));</span>
  
<span class="line-modified">!     JSArray* result = constructEmptyArray(globalObject, nullptr, moduleRecord-&gt;requestedModules().size());</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      size_t i = 0;
      for (auto&amp; key : moduleRecord-&gt;requestedModules()) {
<span class="line-modified">!         result-&gt;putDirectIndex(globalObject, i++, jsString(vm, key.get()));</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!moduleRecord)
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     dataLogLnIf(Options::dumpModuleLoadingState(), &quot;Loader [link] &quot;, moduleRecord-&gt;moduleKey());</span>
  
<span class="line-modified">!     moduleRecord-&gt;link(globalObject, callFrame-&gt;argument(1));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      return JSValue::encode(jsUndefined());
  }
  
  // ------------------------------ Hook Functions ---------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      // Hook point, Loader.resolve.
      // https://whatwg.github.io/loader/#browser-resolve
      // Take the name and resolve it to the unique identifier for the resource location.
      // For example, take the &quot;jquery&quot; and return the URL for the resource.
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(loader-&gt;resolve(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     auto result = loader-&gt;resolveSync(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(identifierToJSValue(vm, result));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      // Hook point, Loader.fetch
      // https://whatwg.github.io/loader/#browser-fetch
      // Take the key and fetch the resource actually.
      // For example, JavaScriptCore shell can provide the hook fetching the resource
      // from the local file system.
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(loader-&gt;fetch(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     auto* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     auto* moduleNamespaceObject = loader-&gt;getModuleNamespaceObject(globalObject, callFrame-&gt;argument(0));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(moduleNamespaceObject);
  }
  
  // ------------------- Additional Hook Functions ---------------------------
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // To instrument and retrieve the errors raised from the module execution,
      // we inserted the hook point here.
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!loader)
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(loader-&gt;evaluate(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1), callFrame-&gt;argument(2)));</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="JSModuleEnvironment.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSModuleLoader.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
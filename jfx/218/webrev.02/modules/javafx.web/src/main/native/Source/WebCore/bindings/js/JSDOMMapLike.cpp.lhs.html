<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMMapLike.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre> 1 /*
 2  * Copyright (C) 2017 Apple Inc. All rights reserved.
 3  *
 4  * Redistribution and use in source and binary forms, with or without
 5  * modification, are permitted provided that the following conditions
 6  * are met:
 7  * 1. Redistributions of source code must retain the above copyright
 8  *    notice, this list of conditions and the following disclaimer.
 9  * 2. Redistributions in binary form must reproduce the above copyright
10  *    notice, this list of conditions and the following disclaimer in the
11  *    documentation and/or other materials provided with the distribution.
12  *
13  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
24  */
25 
26 #include &quot;config.h&quot;
27 #include &quot;JSDOMMapLike.h&quot;
28 
29 #include &quot;WebCoreJSClientData.h&quot;
30 #include &lt;JavaScriptCore/CatchScope.h&gt;
<a name="1" id="anc1"></a>
31 
32 namespace WebCore {
33 
<a name="2" id="anc2"></a><span class="line-modified">34 static inline JSC::JSObject&amp; getBackingMap(JSC::ExecState&amp; state, JSC::JSObject&amp; mapLike)</span>
35 {
<a name="3" id="anc3"></a><span class="line-modified">36     auto&amp; vm = state.vm();</span>
<span class="line-modified">37     auto backingMap = mapLike.get(&amp;state, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName());</span>
<span class="line-modified">38     return *JSC::asObject(backingMap);</span>









39 }
40 
<a name="4" id="anc4"></a><span class="line-modified">41 void initializeBackingMap(JSC::VM&amp; vm, JSC::JSObject&amp; mapLike, JSC::JSMap&amp; backingMap)</span>
42 {
<a name="5" id="anc5"></a><span class="line-modified">43     mapLike.putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName(), &amp;backingMap, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));</span>









44 }
45 
<a name="6" id="anc6"></a><span class="line-modified">46 JSC::JSMap&amp; createBackingMap(JSC::ExecState&amp; state, JSC::JSGlobalObject&amp; globalObject, JSC::JSObject&amp; mapLike)</span>
47 {
<a name="7" id="anc7"></a><span class="line-modified">48     auto&amp; vm = state.vm();</span>
<span class="line-modified">49     auto scope = DECLARE_CATCH_SCOPE(vm);</span>
50 
<a name="8" id="anc8"></a><span class="line-modified">51     ASSERT(mapLike.get(&amp;state, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName()).isUndefined());</span>
<span class="line-modified">52     auto backingMap = JSC::JSMap::create(&amp;state, vm, globalObject.mapStructure());</span>
<span class="line-modified">53     scope.releaseAssertNoException();</span>
<span class="line-modified">54     mapLike.putDirect(vm, static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().backingMapPrivateName(), backingMap, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontEnum));</span>
<span class="line-modified">55     return *backingMap;</span>




56 }
57 
<a name="9" id="anc9"></a><span class="line-modified">58 JSC::JSValue forwardAttributeGetterToBackingMap(JSC::ExecState&amp; state, JSC::JSObject&amp; mapLike, const JSC::Identifier&amp; attributeName)</span>
59 {
<a name="10" id="anc10"></a><span class="line-modified">60     return getBackingMap(state, mapLike).get(&amp;state, attributeName);</span>
61 }
62 
<a name="11" id="anc11"></a><span class="line-modified">63 JSC::JSValue forwardFunctionCallToBackingMap(JSC::ExecState&amp; state, JSC::JSObject&amp; mapLike, const JSC::Identifier&amp; functionName)</span>
64 {
<a name="12" id="anc12"></a><span class="line-modified">65     auto&amp; backingMap = getBackingMap(state, mapLike);</span>
<span class="line-removed">66 </span>
<span class="line-removed">67     JSC::JSValue function = backingMap.get(&amp;state, functionName);</span>
<span class="line-removed">68     ASSERT(function);</span>
69 
70     JSC::CallData callData;
<a name="13" id="anc13"></a><span class="line-modified">71     JSC::CallType callType = JSC::getCallData(state.vm(), function, callData);</span>
<span class="line-modified">72     ASSERT(callType != JSC::CallType::None);</span>


73     JSC::MarkedArgumentBuffer arguments;
<a name="14" id="anc14"></a><span class="line-modified">74     for (size_t cptr = 0; cptr &lt; state.argumentCount(); ++cptr)</span>
<span class="line-modified">75         arguments.append(state.uncheckedArgument(cptr));</span>
76     ASSERT(!arguments.hasOverflowed());
<a name="15" id="anc15"></a><span class="line-modified">77     return JSC::call(&amp;state, function, callType, callData, &amp;backingMap, arguments);</span>
78 }
79 
<a name="16" id="anc16"></a><span class="line-modified">80 JSC::JSValue forwardForEachCallToBackingMap(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::JSObject&amp; mapLike)</span>
81 {
<a name="17" id="anc17"></a><span class="line-modified">82     auto* function = globalObject.builtinInternalFunctions().jsDOMBindingInternals().m_mapLikeForEachFunction.get();</span>
<span class="line-modified">83     ASSERT(function);</span>
84 
<a name="18" id="anc18"></a><span class="line-modified">85     getBackingMap(state, mapLike);</span>

86 
87     JSC::CallData callData;
<a name="19" id="anc19"></a><span class="line-modified">88     JSC::CallType callType = JSC::getCallData(state.vm(), function, callData);</span>
89     ASSERT(callType != JSC::CallType::None);
<a name="20" id="anc20"></a>
90     JSC::MarkedArgumentBuffer arguments;
<a name="21" id="anc21"></a><span class="line-modified">91     for (size_t cptr = 0; cptr &lt; state.argumentCount(); ++cptr)</span>
<span class="line-modified">92         arguments.append(state.uncheckedArgument(cptr));</span>

93     ASSERT(!arguments.hasOverflowed());
<a name="22" id="anc22"></a><span class="line-modified">94     return JSC::call(&amp;state, function, callType, callData, &amp;mapLike, arguments);</span>





95 }
96 
97 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp
@@ -55,32 +55,35 @@
 
         WASM_PARSER_FAIL_IF(!parseInt7(type), "can't get ", i, "th Type's type");
         WASM_PARSER_FAIL_IF(type != Func, i, "th Type is non-Func ", type);
         WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), "can't get ", i, "th Type's argument count");
         WASM_PARSER_FAIL_IF(argumentCount > maxFunctionParams, i, "th argument count is too big ", argumentCount, " maximum ", maxFunctionParams);
-        RefPtr<Signature> maybeSignature = Signature::tryCreate(argumentCount);
-        WASM_PARSER_FAIL_IF(!maybeSignature, "can't allocate enough memory for Type section's ", i, "th signature");
-        Ref<Signature> signature = maybeSignature.releaseNonNull();
+        Vector<Type> arguments;
+        WASM_PARSER_FAIL_IF(!arguments.tryReserveCapacity(argumentCount), "can't allocate enough memory for Type section's ", i, "th signature");
 
         for (unsigned i = 0; i < argumentCount; ++i) {
             Type argumentType;
             WASM_PARSER_FAIL_IF(!parseValueType(argumentType), "can't get ", i, "th argument Type");
-            signature->argument(i) = argumentType;
+            arguments.append(argumentType);
         }
 
-        uint8_t returnCount;
-        WASM_PARSER_FAIL_IF(!parseVarUInt1(returnCount), "can't get ", i, "th Type's return count");
-        Type returnType;
-        if (returnCount) {
+        uint32_t returnCount;
+        WASM_PARSER_FAIL_IF(!parseVarUInt32(returnCount), "can't get ", i, "th Type's return count");
+        WASM_PARSER_FAIL_IF(returnCount > 1 && !Options::useWebAssemblyMultiValues(), "Signatures cannot have more than one result type yet.");
+
+        Vector<Type, 1> returnTypes;
+        WASM_PARSER_FAIL_IF(!returnTypes.tryReserveCapacity(argumentCount), "can't allocate enough memory for Type section's ", i, "th signature");
+        for (unsigned i = 0; i < returnCount; ++i) {
             Type value;
             WASM_PARSER_FAIL_IF(!parseValueType(value), "can't get ", i, "th Type's return value");
-            returnType = static_cast<Type>(value);
-        } else
-            returnType = Type::Void;
-        signature->returnType() = returnType;
+            returnTypes.append(value);
+        }
+
+        RefPtr<Signature> signature = SignatureInformation::signatureFor(returnTypes, arguments);
+        WASM_PARSER_FAIL_IF(!signature, "can't allocate enough memory for Type section's ", i, "th signature");
 
-        m_info->usedSignatures.uncheckedAppend(SignatureInformation::adopt(WTFMove(signature)));
+        m_info->usedSignatures.uncheckedAppend(signature.releaseNonNull());
     }
     return { };
 }
 
 auto SectionParser::parseImport() -> PartialResult
@@ -131,14 +134,15 @@
             if (UNLIKELY(!result))
                 return makeUnexpected(WTFMove(result.error()));
             break;
         }
         case ExternalKind::Global: {
-            Global global;
+            GlobalInformation global;
             WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
-            WASM_PARSER_FAIL_IF(global.mutability == Global::Mutable, "Mutable Globals aren't supported");
-
+            // Only mutable globals need floating bindings.
+            if (global.mutability == GlobalInformation::Mutability::Mutable)
+                global.bindingMode = GlobalInformation::BindingMode::Portable;
             kindIndex = m_info->globals.size();
             m_info->globals.uncheckedAppend(WTFMove(global));
             break;
         }
         }
@@ -280,22 +284,22 @@
     WASM_PARSER_FAIL_IF(globalCount > maxGlobals, "Global section's count is too big ", globalCount, " maximum ", maxGlobals);
     size_t totalBytes = globalCount + m_info->firstInternalGlobal;
     WASM_PARSER_FAIL_IF((static_cast<uint32_t>(totalBytes) < globalCount) || !m_info->globals.tryReserveCapacity(totalBytes), "can't allocate memory for ", totalBytes, " globals");
 
     for (uint32_t globalIndex = 0; globalIndex < globalCount; ++globalIndex) {
-        Global global;
+        GlobalInformation global;
         uint8_t initOpcode;
 
         WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
         Type typeForInitOpcode;
         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
         if (initOpcode == GetGlobal)
-            global.initializationType = Global::FromGlobalImport;
+            global.initializationType = GlobalInformation::FromGlobalImport;
         else if (initOpcode == RefFunc)
-            global.initializationType = Global::FromRefFunc;
+            global.initializationType = GlobalInformation::FromRefFunc;
         else
-            global.initializationType = Global::FromExpression;
+            global.initializationType = GlobalInformation::FromExpression;
         WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), "Global init_expr opcode of type ", typeForInitOpcode, " doesn't match global's type ", global.type);
 
         m_info->globals.uncheckedAppend(WTFMove(global));
     }
 
@@ -338,11 +342,14 @@
             WASM_PARSER_FAIL_IF(kindIndex, "can't export Memory ", kindIndex, " only one Table is currently supported");
             break;
         }
         case ExternalKind::Global: {
             WASM_PARSER_FAIL_IF(kindIndex >= m_info->globals.size(), exportNumber, "th Export has invalid global number ", kindIndex, " it exceeds the globals count ", m_info->globals.size(), ", named '", fieldString, "'");
-            WASM_PARSER_FAIL_IF(m_info->globals[kindIndex].mutability != Global::Immutable, exportNumber, "th Export isn't immutable, named '", fieldString, "'");
+            // Only mutable globals need floating bindings.
+            GlobalInformation& global = m_info->globals[kindIndex];
+            if (global.mutability == GlobalInformation::Mutability::Mutable)
+                global.bindingMode = GlobalInformation::BindingMode::Portable;
             break;
         }
         }
 
         m_info->exports.uncheckedAppend({ WTFMove(fieldString), kind, kindIndex });
@@ -357,11 +364,11 @@
     WASM_PARSER_FAIL_IF(!parseVarUInt32(startFunctionIndex), "can't get Start index");
     WASM_PARSER_FAIL_IF(startFunctionIndex >= m_info->functionIndexSpaceSize(), "Start index ", startFunctionIndex, " exceeds function index space ", m_info->functionIndexSpaceSize());
     SignatureIndex signatureIndex = m_info->signatureIndexFromFunctionIndexSpace(startFunctionIndex);
     const Signature& signature = SignatureInformation::get(signatureIndex);
     WASM_PARSER_FAIL_IF(signature.argumentCount(), "Start function can't have arguments");
-    WASM_PARSER_FAIL_IF(signature.returnType() != Void, "Start function can't return a value");
+    WASM_PARSER_FAIL_IF(!signature.returnsVoid(), "Start function can't return a value");
     m_info->startFunctionIndexSpace = startFunctionIndex;
     return { };
 }
 
 auto SectionParser::parseElement() -> PartialResult
@@ -409,34 +416,14 @@
     }
 
     return { };
 }
 
-// This function will be changed to be RELEASE_ASSERT_NOT_REACHED once we switch our parsing infrastructure to the streaming parser.
 auto SectionParser::parseCode() -> PartialResult
 {
-    m_info->codeSectionSize = length();
-    uint32_t count;
-    WASM_PARSER_FAIL_IF(!parseVarUInt32(count), "can't get Code section's count");
-    WASM_PARSER_FAIL_IF(count == std::numeric_limits<uint32_t>::max(), "Code section's count is too big ", count);
-    WASM_PARSER_FAIL_IF(count != m_info->functions.size(), "Code section count ", count, " exceeds the declared number of functions ", m_info->functions.size());
-
-    for (uint32_t i = 0; i < count; ++i) {
-        uint32_t functionSize;
-        WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSize), "can't get ", i, "th Code function's size");
-        WASM_PARSER_FAIL_IF(functionSize > length(), "Code function's size ", functionSize, " exceeds the module's size ", length());
-        WASM_PARSER_FAIL_IF(functionSize > length() - m_offset, "Code function's size ", functionSize, " exceeds the module's remaining size", length() - m_offset);
-        WASM_PARSER_FAIL_IF(functionSize > maxFunctionSize, "Code function's size ", functionSize, " is too big");
-
-        Vector<uint8_t> data(functionSize);
-        std::memcpy(data.data(), source() + m_offset, functionSize);
-        m_info->functions[i].start = m_offsetInSource + m_offset;
-        m_info->functions[i].end = m_offsetInSource + m_offset + functionSize;
-        m_info->functions[i].data = WTFMove(data);
-        m_offset += functionSize;
-    }
-
+    // The Code section is handled specially in StreamingParser.
+    RELEASE_ASSERT_NOT_REACHED();
     return { };
 }
 
 auto SectionParser::parseInitExpr(uint8_t& opcode, uint64_t& bitsOrImportNumber, Type& resultType) -> PartialResult
 {
@@ -479,12 +466,12 @@
         uint32_t index;
         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), "can't get get_global's index");
 
         WASM_PARSER_FAIL_IF(index >= m_info->globals.size(), "get_global's index ", index, " exceeds the number of globals ", m_info->globals.size());
         WASM_PARSER_FAIL_IF(index >= m_info->firstInternalGlobal, "get_global import kind index ", index, " exceeds the first internal global ", m_info->firstInternalGlobal);
+        WASM_PARSER_FAIL_IF(m_info->globals[index].mutability != GlobalInformation::Immutable, "get_global import kind index ", index, " is mutable ");
 
-        ASSERT(m_info->globals[index].mutability == Global::Immutable);
         resultType = m_info->globals[index].type;
         bitsOrImportNumber = index;
         break;
     }
 
@@ -513,16 +500,16 @@
     WASM_PARSER_FAIL_IF(endOpcode != OpType::End, "init_expr should end with end, ended with ", endOpcode);
 
     return { };
 }
 
-auto SectionParser::parseGlobalType(Global& global) -> PartialResult
+auto SectionParser::parseGlobalType(GlobalInformation& global) -> PartialResult
 {
     uint8_t mutability;
     WASM_PARSER_FAIL_IF(!parseValueType(global.type), "can't get Global's value type");
     WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), "can't get Global type's mutability");
-    global.mutability = static_cast<Global::Mutability>(mutability);
+    global.mutability = static_cast<GlobalInformation::Mutability>(mutability);
     return { };
 }
 
 auto SectionParser::parseData() -> PartialResult
 {

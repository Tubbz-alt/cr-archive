<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBody.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMWindowFetch.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchBody.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/fetch/FetchBody.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchBody.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;FetchBodyOwner.h&quot;
 34 #include &quot;FetchBodySource.h&quot;
 35 #include &quot;FetchHeaders.h&quot;
 36 #include &quot;HTTPHeaderValues.h&quot;
 37 #include &quot;HTTPParsers.h&quot;

 38 #include &quot;ReadableStreamSource.h&quot;
 39 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 ExceptionOr&lt;FetchBody&gt; FetchBody::extract(Init&amp;&amp; value, String&amp; contentType)
 44 {
 45     return WTF::switchOn(value, [&amp;](RefPtr&lt;Blob&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 46         Ref&lt;const Blob&gt; blob = value.releaseNonNull();
 47         if (!blob-&gt;type().isEmpty())
 48             contentType = blob-&gt;type();
 49         return FetchBody(WTFMove(blob));
 50     }, [&amp;](RefPtr&lt;DOMFormData&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 51         Ref&lt;DOMFormData&gt; domFormData = value.releaseNonNull();
 52         auto formData = FormData::createMultiPart(domFormData.get());
 53         contentType = makeString(&quot;multipart/form-data; boundary=&quot;, formData-&gt;boundary().data());
 54         return FetchBody(WTFMove(formData));
 55     }, [&amp;](RefPtr&lt;URLSearchParams&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 56         Ref&lt;const URLSearchParams&gt; params = value.releaseNonNull();
 57         contentType = HTTPHeaderValues::formURLEncodedContentType();
 58         return FetchBody(WTFMove(params));
 59     }, [&amp;](RefPtr&lt;ArrayBuffer&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 60         Ref&lt;const ArrayBuffer&gt; buffer = value.releaseNonNull();
 61         return FetchBody(WTFMove(buffer));
 62     }, [&amp;](RefPtr&lt;ArrayBufferView&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 63         Ref&lt;const ArrayBufferView&gt; buffer = value.releaseNonNull();
 64         return FetchBody(WTFMove(buffer));
 65     }, [&amp;](RefPtr&lt;ReadableStream&gt;&amp; stream) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 66         if (stream-&gt;isDisturbed())
 67             return Exception { TypeError, &quot;Input body is disturbed.&quot;_s };
 68         if (stream-&gt;isLocked())
 69             return Exception { TypeError, &quot;Input body is locked.&quot;_s };
 70 
 71         return FetchBody(stream.releaseNonNull());
 72     }, [&amp;](String&amp; value) -&gt; ExceptionOr&lt;FetchBody&gt; {
 73         contentType = HTTPHeaderValues::textPlainContentType();
 74         return FetchBody(WTFMove(value));
 75     });
 76 }
 77 
<span class="line-modified"> 78 Optional&lt;FetchBody&gt; FetchBody::fromFormData(PAL::SessionID sessionID, FormData&amp; formData)</span>
 79 {
 80     ASSERT(!formData.isEmpty());
 81 
 82     if (auto buffer = formData.asSharedBuffer()) {
 83         FetchBody body;
 84         body.m_consumer.setData(buffer.releaseNonNull());
 85         return body;
 86     }
 87 
 88     auto url = formData.asBlobURL();
 89     if (!url.isNull()) {
 90         // FIXME: Properly set mime type and size of the blob.
<span class="line-modified"> 91         Ref&lt;const Blob&gt; blob = Blob::deserialize(sessionID, url, { }, { }, { });</span>
 92         return FetchBody { WTFMove(blob) };
 93     }
 94 
 95     // FIXME: Support form data bodies.
 96     return WTF::nullopt;
 97 }
 98 
 99 void FetchBody::arrayBuffer(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
100 {
101     m_consumer.setType(FetchBodyConsumer::Type::ArrayBuffer);
102     consume(owner, WTFMove(promise));
103 }
104 
105 void FetchBody::blob(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; contentType)
106 {
107     m_consumer.setType(FetchBodyConsumer::Type::Blob);
108     m_consumer.setContentType(Blob::normalizedContentType(extractMIMETypeFromMediaType(contentType)));
109     consume(owner, WTFMove(promise));
110 }
111 
112 void FetchBody::json(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
113 {
114     if (isText()) {
115         fulfillPromiseWithJSON(WTFMove(promise), textBody());
116         return;
117     }
118     m_consumer.setType(FetchBodyConsumer::Type::JSON);
119     consume(owner, WTFMove(promise));
120 }
121 
122 void FetchBody::text(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
123 {
124     if (isText()) {
125         promise-&gt;resolve&lt;IDLDOMString&gt;(textBody());
126         return;
127     }
128     m_consumer.setType(FetchBodyConsumer::Type::Text);
129     consume(owner, WTFMove(promise));
130 }
131 





132 void FetchBody::consumeOnceLoadingFinished(FetchBodyConsumer::Type type, Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; contentType)
133 {
134     m_consumer.setType(type);
135     m_consumer.setConsumePromise(WTFMove(promise));
136     if (type == FetchBodyConsumer::Type::Blob)
137         m_consumer.setContentType(Blob::normalizedContentType(extractMIMETypeFromMediaType(contentType)));
138 }
139 
140 void FetchBody::consume(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
141 {
142     if (isArrayBuffer()) {
143         consumeArrayBuffer(WTFMove(promise));
144         return;
145     }
146     if (isArrayBufferView()) {
147         consumeArrayBufferView(WTFMove(promise));
148         return;
149     }
150     if (isText()) {
151         consumeText(WTFMove(promise), textBody());
</pre>
<hr />
<pre>
222     m_data = nullptr;
223 }
224 
225 void FetchBody::consumeBlob(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
226 {
227     m_consumer.setConsumePromise(WTFMove(promise));
228     owner.loadBlob(blobBody(), &amp;m_consumer);
229     m_data = nullptr;
230 }
231 
232 void FetchBody::loadingFailed(const Exception&amp; exception)
233 {
234     m_consumer.loadingFailed(exception);
235 }
236 
237 void FetchBody::loadingSucceeded()
238 {
239     m_consumer.loadingSucceeded();
240 }
241 
<span class="line-modified">242 RefPtr&lt;FormData&gt; FetchBody::bodyAsFormData(ScriptExecutionContext&amp; context) const</span>
243 {
244     if (isText())
245         return FormData::create(UTF8Encoding().encode(textBody(), UnencodableHandling::Entities));
246     if (isURLSearchParams())
247         return FormData::create(UTF8Encoding().encode(urlSearchParamsBody().toString(), UnencodableHandling::Entities));
248     if (isBlob()) {
249         auto body = FormData::create();
250         body-&gt;appendBlob(blobBody().url());
251         return body;
252     }
253     if (isArrayBuffer())
254         return FormData::create(arrayBufferBody().data(), arrayBufferBody().byteLength());
255     if (isArrayBufferView())
256         return FormData::create(arrayBufferViewBody().baseAddress(), arrayBufferViewBody().byteLength());
257     if (isFormData()) {
<span class="line-removed">258         ASSERT_UNUSED(context, !context.isWorkerGlobalScope());</span>
259         auto body = makeRef(const_cast&lt;FormData&amp;&gt;(formDataBody()));
260         return body;
261     }
262     if (auto* data = m_consumer.data())
263         return FormData::create(data-&gt;data(), data-&gt;size());
264 
265     ASSERT_NOT_REACHED();
266     return nullptr;
267 }
268 
269 FetchBody::TakenData FetchBody::take()
270 {
271     if (m_consumer.hasData()) {
272         auto buffer = m_consumer.takeData();
273         if (!buffer)
274             return nullptr;
275         return buffer.releaseNonNull();
276     }
277 
278     if (isBlob()) {
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL CANON INC. AND ITS CONTRIBUTORS BE LIABLE FOR
 21  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 22  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 24  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 25  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;FetchBody.h&quot;
 31 
 32 #include &quot;Document.h&quot;
 33 #include &quot;FetchBodyOwner.h&quot;
 34 #include &quot;FetchBodySource.h&quot;
 35 #include &quot;FetchHeaders.h&quot;
 36 #include &quot;HTTPHeaderValues.h&quot;
 37 #include &quot;HTTPParsers.h&quot;
<span class="line-added"> 38 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 39 #include &quot;ReadableStreamSource.h&quot;
 40 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 ExceptionOr&lt;FetchBody&gt; FetchBody::extract(Init&amp;&amp; value, String&amp; contentType)
 45 {
 46     return WTF::switchOn(value, [&amp;](RefPtr&lt;Blob&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 47         Ref&lt;const Blob&gt; blob = value.releaseNonNull();
 48         if (!blob-&gt;type().isEmpty())
 49             contentType = blob-&gt;type();
 50         return FetchBody(WTFMove(blob));
 51     }, [&amp;](RefPtr&lt;DOMFormData&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 52         Ref&lt;DOMFormData&gt; domFormData = value.releaseNonNull();
 53         auto formData = FormData::createMultiPart(domFormData.get());
 54         contentType = makeString(&quot;multipart/form-data; boundary=&quot;, formData-&gt;boundary().data());
 55         return FetchBody(WTFMove(formData));
 56     }, [&amp;](RefPtr&lt;URLSearchParams&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 57         Ref&lt;const URLSearchParams&gt; params = value.releaseNonNull();
 58         contentType = HTTPHeaderValues::formURLEncodedContentType();
 59         return FetchBody(WTFMove(params));
 60     }, [&amp;](RefPtr&lt;ArrayBuffer&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 61         Ref&lt;const ArrayBuffer&gt; buffer = value.releaseNonNull();
 62         return FetchBody(WTFMove(buffer));
 63     }, [&amp;](RefPtr&lt;ArrayBufferView&gt;&amp; value) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 64         Ref&lt;const ArrayBufferView&gt; buffer = value.releaseNonNull();
 65         return FetchBody(WTFMove(buffer));
 66     }, [&amp;](RefPtr&lt;ReadableStream&gt;&amp; stream) mutable -&gt; ExceptionOr&lt;FetchBody&gt; {
 67         if (stream-&gt;isDisturbed())
 68             return Exception { TypeError, &quot;Input body is disturbed.&quot;_s };
 69         if (stream-&gt;isLocked())
 70             return Exception { TypeError, &quot;Input body is locked.&quot;_s };
 71 
 72         return FetchBody(stream.releaseNonNull());
 73     }, [&amp;](String&amp; value) -&gt; ExceptionOr&lt;FetchBody&gt; {
 74         contentType = HTTPHeaderValues::textPlainContentType();
 75         return FetchBody(WTFMove(value));
 76     });
 77 }
 78 
<span class="line-modified"> 79 Optional&lt;FetchBody&gt; FetchBody::fromFormData(FormData&amp; formData)</span>
 80 {
 81     ASSERT(!formData.isEmpty());
 82 
 83     if (auto buffer = formData.asSharedBuffer()) {
 84         FetchBody body;
 85         body.m_consumer.setData(buffer.releaseNonNull());
 86         return body;
 87     }
 88 
 89     auto url = formData.asBlobURL();
 90     if (!url.isNull()) {
 91         // FIXME: Properly set mime type and size of the blob.
<span class="line-modified"> 92         Ref&lt;const Blob&gt; blob = Blob::deserialize(url, { }, { }, { });</span>
 93         return FetchBody { WTFMove(blob) };
 94     }
 95 
 96     // FIXME: Support form data bodies.
 97     return WTF::nullopt;
 98 }
 99 
100 void FetchBody::arrayBuffer(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
101 {
102     m_consumer.setType(FetchBodyConsumer::Type::ArrayBuffer);
103     consume(owner, WTFMove(promise));
104 }
105 
106 void FetchBody::blob(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; contentType)
107 {
108     m_consumer.setType(FetchBodyConsumer::Type::Blob);
109     m_consumer.setContentType(Blob::normalizedContentType(extractMIMETypeFromMediaType(contentType)));
110     consume(owner, WTFMove(promise));
111 }
112 
113 void FetchBody::json(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
114 {
115     if (isText()) {
116         fulfillPromiseWithJSON(WTFMove(promise), textBody());
117         return;
118     }
119     m_consumer.setType(FetchBodyConsumer::Type::JSON);
120     consume(owner, WTFMove(promise));
121 }
122 
123 void FetchBody::text(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
124 {
125     if (isText()) {
126         promise-&gt;resolve&lt;IDLDOMString&gt;(textBody());
127         return;
128     }
129     m_consumer.setType(FetchBodyConsumer::Type::Text);
130     consume(owner, WTFMove(promise));
131 }
132 
<span class="line-added">133 void FetchBody::formData(FetchBodyOwner&amp;, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-added">134 {</span>
<span class="line-added">135     promise.get().reject(NotSupportedError);</span>
<span class="line-added">136 }</span>
<span class="line-added">137 </span>
138 void FetchBody::consumeOnceLoadingFinished(FetchBodyConsumer::Type type, Ref&lt;DeferredPromise&gt;&amp;&amp; promise, const String&amp; contentType)
139 {
140     m_consumer.setType(type);
141     m_consumer.setConsumePromise(WTFMove(promise));
142     if (type == FetchBodyConsumer::Type::Blob)
143         m_consumer.setContentType(Blob::normalizedContentType(extractMIMETypeFromMediaType(contentType)));
144 }
145 
146 void FetchBody::consume(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
147 {
148     if (isArrayBuffer()) {
149         consumeArrayBuffer(WTFMove(promise));
150         return;
151     }
152     if (isArrayBufferView()) {
153         consumeArrayBufferView(WTFMove(promise));
154         return;
155     }
156     if (isText()) {
157         consumeText(WTFMove(promise), textBody());
</pre>
<hr />
<pre>
228     m_data = nullptr;
229 }
230 
231 void FetchBody::consumeBlob(FetchBodyOwner&amp; owner, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
232 {
233     m_consumer.setConsumePromise(WTFMove(promise));
234     owner.loadBlob(blobBody(), &amp;m_consumer);
235     m_data = nullptr;
236 }
237 
238 void FetchBody::loadingFailed(const Exception&amp; exception)
239 {
240     m_consumer.loadingFailed(exception);
241 }
242 
243 void FetchBody::loadingSucceeded()
244 {
245     m_consumer.loadingSucceeded();
246 }
247 
<span class="line-modified">248 RefPtr&lt;FormData&gt; FetchBody::bodyAsFormData() const</span>
249 {
250     if (isText())
251         return FormData::create(UTF8Encoding().encode(textBody(), UnencodableHandling::Entities));
252     if (isURLSearchParams())
253         return FormData::create(UTF8Encoding().encode(urlSearchParamsBody().toString(), UnencodableHandling::Entities));
254     if (isBlob()) {
255         auto body = FormData::create();
256         body-&gt;appendBlob(blobBody().url());
257         return body;
258     }
259     if (isArrayBuffer())
260         return FormData::create(arrayBufferBody().data(), arrayBufferBody().byteLength());
261     if (isArrayBufferView())
262         return FormData::create(arrayBufferViewBody().baseAddress(), arrayBufferViewBody().byteLength());
263     if (isFormData()) {

264         auto body = makeRef(const_cast&lt;FormData&amp;&gt;(formDataBody()));
265         return body;
266     }
267     if (auto* data = m_consumer.data())
268         return FormData::create(data-&gt;data(), data-&gt;size());
269 
270     ASSERT_NOT_REACHED();
271     return nullptr;
272 }
273 
274 FetchBody::TakenData FetchBody::take()
275 {
276     if (m_consumer.hasData()) {
277         auto buffer = m_consumer.takeData();
278         if (!buffer)
279             return nullptr;
280         return buffer.releaseNonNull();
281     }
282 
283     if (isBlob()) {
</pre>
</td>
</tr>
</table>
<center><a href="DOMWindowFetch.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FetchBody.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
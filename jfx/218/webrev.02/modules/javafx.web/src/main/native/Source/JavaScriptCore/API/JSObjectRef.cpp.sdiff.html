<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSObjectRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSHeapFinalizerPrivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScriptRef.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSObjectRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2008 Kelvin W Sherlock (ksherlock@gmail.com)
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 30 
 31 #include &quot;APICast.h&quot;
 32 #include &quot;APIUtils.h&quot;
 33 #include &quot;DateConstructor.h&quot;
 34 #include &quot;ErrorConstructor.h&quot;
 35 #include &quot;Exception.h&quot;
 36 #include &quot;FunctionConstructor.h&quot;
 37 #include &quot;Identifier.h&quot;
 38 #include &quot;InitializeThreading.h&quot;
 39 #include &quot;JSAPIWrapperObject.h&quot;
 40 #include &quot;JSArray.h&quot;
 41 #include &quot;JSCInlines.h&quot;
 42 #include &quot;JSCallbackConstructor.h&quot;
 43 #include &quot;JSCallbackFunction.h&quot;
 44 #include &quot;JSCallbackObject.h&quot;
 45 #include &quot;JSClassRef.h&quot;
 46 #include &quot;JSFunction.h&quot;
 47 #include &quot;JSGlobalObject.h&quot;
 48 #include &quot;JSObject.h&quot;
 49 #include &quot;JSPromise.h&quot;
<span class="line-removed"> 50 #include &quot;JSPromiseDeferred.h&quot;</span>
 51 #include &quot;JSRetainPtr.h&quot;
 52 #include &quot;JSString.h&quot;
 53 #include &quot;JSValueRef.h&quot;
 54 #include &quot;ObjectConstructor.h&quot;
 55 #include &quot;ObjectPrototype.h&quot;
 56 #include &quot;PropertyNameArray.h&quot;
 57 #include &quot;ProxyObject.h&quot;
 58 #include &quot;RegExpConstructor.h&quot;
 59 
 60 #if ENABLE(REMOTE_INSPECTOR)
 61 #include &quot;JSGlobalObjectInspectorController.h&quot;
 62 #endif
 63 
 64 using namespace JSC;
 65 
 66 JSClassRef JSClassCreate(const JSClassDefinition* definition)
 67 {
 68     initializeThreading();
 69     auto jsClass = (definition-&gt;attributes &amp; kJSClassAttributeNoAutomaticPrototype)
 70         ? OpaqueJSClass::createNoAutomaticPrototype(definition)
</pre>
<hr />
<pre>
 73     return &amp;jsClass.leakRef();
 74 }
 75 
 76 JSClassRef JSClassRetain(JSClassRef jsClass)
 77 {
 78     jsClass-&gt;ref();
 79     return jsClass;
 80 }
 81 
 82 void JSClassRelease(JSClassRef jsClass)
 83 {
 84     jsClass-&gt;deref();
 85 }
 86 
 87 JSObjectRef JSObjectMake(JSContextRef ctx, JSClassRef jsClass, void* data)
 88 {
 89     if (!ctx) {
 90         ASSERT_NOT_REACHED();
 91         return 0;
 92     }
<span class="line-modified"> 93     ExecState* exec = toJS(ctx);</span>
<span class="line-modified"> 94     VM&amp; vm = exec-&gt;vm();</span>
 95     JSLockHolder locker(vm);
 96 
 97     if (!jsClass)
<span class="line-modified"> 98         return toRef(constructEmptyObject(exec));</span>
 99 
<span class="line-modified">100     JSCallbackObject&lt;JSDestructibleObject&gt;* object = JSCallbackObject&lt;JSDestructibleObject&gt;::create(exec, exec-&gt;lexicalGlobalObject(), exec-&gt;lexicalGlobalObject()-&gt;callbackObjectStructure(), jsClass, data);</span>
<span class="line-modified">101     if (JSObject* prototype = jsClass-&gt;prototype(exec))</span>
102         object-&gt;setPrototypeDirect(vm, prototype);
103 
104     return toRef(object);
105 }
106 
107 JSObjectRef JSObjectMakeFunctionWithCallback(JSContextRef ctx, JSStringRef name, JSObjectCallAsFunctionCallback callAsFunction)
108 {
109     if (!ctx) {
110         ASSERT_NOT_REACHED();
111         return 0;
112     }
<span class="line-modified">113     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">114     VM&amp; vm = exec-&gt;vm();</span>
115     JSLockHolder locker(vm);
<span class="line-modified">116     return toRef(JSCallbackFunction::create(vm, exec-&gt;lexicalGlobalObject(), callAsFunction, name ? name-&gt;string() : &quot;anonymous&quot;_s));</span>
117 }
118 
119 JSObjectRef JSObjectMakeConstructor(JSContextRef ctx, JSClassRef jsClass, JSObjectCallAsConstructorCallback callAsConstructor)
120 {
121     if (!ctx) {
122         ASSERT_NOT_REACHED();
123         return 0;
124     }
<span class="line-modified">125     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">126     VM&amp; vm = exec-&gt;vm();</span>
127     JSLockHolder locker(vm);
128 
<span class="line-modified">129     JSValue jsPrototype = jsClass ? jsClass-&gt;prototype(exec) : 0;</span>
130     if (!jsPrototype)
<span class="line-modified">131         jsPrototype = exec-&gt;lexicalGlobalObject()-&gt;objectPrototype();</span>
132 
<span class="line-modified">133     JSCallbackConstructor* constructor = JSCallbackConstructor::create(exec, exec-&gt;lexicalGlobalObject(), exec-&gt;lexicalGlobalObject()-&gt;callbackConstructorStructure(), jsClass, callAsConstructor);</span>
134     constructor-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, jsPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
135     return toRef(constructor);
136 }
137 
138 JSObjectRef JSObjectMakeFunction(JSContextRef ctx, JSStringRef name, unsigned parameterCount, const JSStringRef parameterNames[], JSStringRef body, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
139 {
140     if (!ctx) {
141         ASSERT_NOT_REACHED();
142         return 0;
143     }
<span class="line-modified">144     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">145     VM&amp; vm = exec-&gt;vm();</span>
146     JSLockHolder locker(vm);
147     auto scope = DECLARE_CATCH_SCOPE(vm);
148 
149     startingLineNumber = std::max(1, startingLineNumber);
150     Identifier nameID = name ? name-&gt;identifier(&amp;vm) : Identifier::fromString(vm, &quot;anonymous&quot;);
151 
152     MarkedArgumentBuffer args;
153     for (unsigned i = 0; i &lt; parameterCount; i++)
154         args.append(jsString(vm, parameterNames[i]-&gt;string()));
155     args.append(jsString(vm, body-&gt;string()));
156     if (UNLIKELY(args.hasOverflowed())) {
157         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">158         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">159         handleExceptionIfNeeded(scope, exec, exception);</span>
160         return 0;
161     }
162 
163     auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
<span class="line-modified">164     JSObject* result = constructFunction(exec, exec-&gt;lexicalGlobalObject(), args, nameID, SourceOrigin { sourceURLString }, sourceURLString, TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));</span>
<span class="line-modified">165     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
166         result = 0;
167     return toRef(result);
168 }
169 
170 JSObjectRef JSObjectMakeArray(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
171 {
172     if (!ctx) {
173         ASSERT_NOT_REACHED();
174         return 0;
175     }
<span class="line-modified">176     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">177     VM&amp; vm = exec-&gt;vm();</span>
178     JSLockHolder locker(vm);
179     auto scope = DECLARE_CATCH_SCOPE(vm);
180 
181     JSObject* result;
182     if (argumentCount) {
183         MarkedArgumentBuffer argList;
184         for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">185             argList.append(toJS(exec, arguments[i]));</span>
186         if (UNLIKELY(argList.hasOverflowed())) {
187             auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">188             throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">189             handleExceptionIfNeeded(scope, exec, exception);</span>
190             return 0;
191         }
192 
<span class="line-modified">193         result = constructArray(exec, static_cast&lt;ArrayAllocationProfile*&gt;(0), argList);</span>
194     } else
<span class="line-modified">195         result = constructEmptyArray(exec, 0);</span>
196 
<span class="line-modified">197     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
198         result = 0;
199 
200     return toRef(result);
201 }
202 
203 JSObjectRef JSObjectMakeDate(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
204 {
205     if (!ctx) {
206         ASSERT_NOT_REACHED();
207         return 0;
208     }
<span class="line-modified">209     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">210     VM&amp; vm = exec-&gt;vm();</span>
211     JSLockHolder locker(vm);
212     auto scope = DECLARE_CATCH_SCOPE(vm);
213 
214     MarkedArgumentBuffer argList;
215     for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">216         argList.append(toJS(exec, arguments[i]));</span>
217     if (UNLIKELY(argList.hasOverflowed())) {
218         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">219         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">220         handleExceptionIfNeeded(scope, exec, exception);</span>
221         return 0;
222     }
223 
<span class="line-modified">224     JSObject* result = constructDate(exec, exec-&gt;lexicalGlobalObject(), JSValue(), argList);</span>
<span class="line-modified">225     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
226         result = 0;
227 
228     return toRef(result);
229 }
230 
231 JSObjectRef JSObjectMakeError(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
232 {
233     if (!ctx) {
234         ASSERT_NOT_REACHED();
235         return 0;
236     }
<span class="line-modified">237     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">238     VM&amp; vm = exec-&gt;vm();</span>
239     JSLockHolder locker(vm);
240     auto scope = DECLARE_CATCH_SCOPE(vm);
241 
<span class="line-modified">242     JSValue message = argumentCount ? toJS(exec, arguments[0]) : jsUndefined();</span>
<span class="line-modified">243     Structure* errorStructure = exec-&gt;lexicalGlobalObject()-&gt;errorStructure();</span>
<span class="line-modified">244     JSObject* result = ErrorInstance::create(exec, errorStructure, message);</span>
245 
<span class="line-modified">246     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
247         result = 0;
248 
249     return toRef(result);
250 }
251 
252 JSObjectRef JSObjectMakeRegExp(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
253 {
254     if (!ctx) {
255         ASSERT_NOT_REACHED();
256         return 0;
257     }
<span class="line-modified">258     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">259     VM&amp; vm = exec-&gt;vm();</span>
260     JSLockHolder locker(vm);
261     auto scope = DECLARE_CATCH_SCOPE(vm);
262 
263     MarkedArgumentBuffer argList;
264     for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">265         argList.append(toJS(exec, arguments[i]));</span>
266     if (UNLIKELY(argList.hasOverflowed())) {
267         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">268         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">269         handleExceptionIfNeeded(scope, exec, exception);</span>
270         return 0;
271     }
272 
<span class="line-modified">273     JSObject* result = constructRegExp(exec, exec-&gt;lexicalGlobalObject(), argList);</span>
<span class="line-modified">274     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
275         result = 0;
276 
277     return toRef(result);
278 }
279 
280 JSObjectRef JSObjectMakeDeferredPromise(JSContextRef ctx, JSObjectRef* resolve, JSObjectRef* reject, JSValueRef* exception)
281 {
282     if (!ctx) {
283         ASSERT_NOT_REACHED();
284         return nullptr;
285     }
286 
<span class="line-modified">287     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">288     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">289     JSLockHolder locker(exec);</span>
290     auto scope = DECLARE_CATCH_SCOPE(vm);
291 
<span class="line-modified">292     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-modified">293     JSPromiseDeferred::DeferredData data = JSPromiseDeferred::createDeferredData(exec, globalObject, globalObject-&gt;promiseConstructor());</span>
<span class="line-removed">294     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
295         return nullptr;
296 
297     if (resolve)
298         *resolve = toRef(data.resolve);
299     if (reject)
300         *reject = toRef(data.reject);
301     return toRef(data.promise);
302 }
303 
304 JSValueRef JSObjectGetPrototype(JSContextRef ctx, JSObjectRef object)
305 {
306     if (!ctx) {
307         ASSERT_NOT_REACHED();
308         return 0;
309     }
<span class="line-modified">310     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">311     JSLockHolder locker(exec);</span>
312 
313     JSObject* jsObject = toJS(object);
<span class="line-modified">314     return toRef(exec, jsObject-&gt;getPrototypeDirect(exec-&gt;vm()));</span>
315 }
316 
317 void JSObjectSetPrototype(JSContextRef ctx, JSObjectRef object, JSValueRef value)
318 {
319     if (!ctx) {
320         ASSERT_NOT_REACHED();
321         return;
322     }
<span class="line-modified">323     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">324     VM&amp; vm = exec-&gt;vm();</span>
325     JSLockHolder locker(vm);
326     auto scope = DECLARE_CATCH_SCOPE(vm);
327 
328     JSObject* jsObject = toJS(object);
<span class="line-modified">329     JSValue jsValue = toJS(exec, value);</span>
<span class="line-modified">330     jsObject-&gt;setPrototype(vm, exec, jsValue.isObject() ? jsValue : jsNull());</span>
<span class="line-modified">331     handleExceptionIfNeeded(scope, exec, nullptr);</span>
332 }
333 
334 bool JSObjectHasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
335 {
336     if (!ctx) {
337         ASSERT_NOT_REACHED();
338         return false;
339     }
<span class="line-modified">340     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">341     VM&amp; vm = exec-&gt;vm();</span>
342     JSLockHolder locker(vm);
343 
344     JSObject* jsObject = toJS(object);
345 
<span class="line-modified">346     return jsObject-&gt;hasProperty(exec, propertyName-&gt;identifier(&amp;vm));</span>
347 }
348 
349 JSValueRef JSObjectGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
350 {
<span class="line-modified">351     if (!ctx) {</span>
352         ASSERT_NOT_REACHED();
353         return 0;
354     }
<span class="line-modified">355     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">356     VM&amp; vm = exec-&gt;vm();</span>
357     JSLockHolder locker(vm);
358     auto scope = DECLARE_CATCH_SCOPE(vm);
359 
360     JSObject* jsObject = toJS(object);
361 
<span class="line-modified">362     JSValue jsValue = jsObject-&gt;get(exec, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">363     handleExceptionIfNeeded(scope, exec, exception);</span>
<span class="line-modified">364     return toRef(exec, jsValue);</span>
365 }
366 
367 void JSObjectSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
368 {
369     if (!ctx) {
370         ASSERT_NOT_REACHED();
371         return;
372     }
<span class="line-modified">373     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">374     VM&amp; vm = exec-&gt;vm();</span>
375     JSLockHolder locker(vm);
376     auto scope = DECLARE_CATCH_SCOPE(vm);
377 
378     JSObject* jsObject = toJS(object);
379     Identifier name(propertyName-&gt;identifier(&amp;vm));
<span class="line-modified">380     JSValue jsValue = toJS(exec, value);</span>
381 
<span class="line-modified">382     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(exec, name);</span>
383     if (LIKELY(!scope.exception())) {
384         if (doesNotHaveProperty) {
385             PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">386             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, exec, name, desc, false);</span>
387         } else {
388             PutPropertySlot slot(jsObject);
<span class="line-modified">389             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, exec, name, jsValue, slot);</span>
390         }
391     }
<span class="line-modified">392     handleExceptionIfNeeded(scope, exec, exception);</span>
393 }
394 
395 bool JSObjectHasPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
396 {
397     if (!ctx) {
398         ASSERT_NOT_REACHED();
399         return false;
400     }
<span class="line-modified">401     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">402     VM&amp; vm = exec-&gt;vm();</span>
403     JSLockHolder locker(vm);
404     auto scope = DECLARE_CATCH_SCOPE(vm);
405 
406     JSObject* jsObject = toJS(object);
<span class="line-modified">407     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">408     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
409         return false;
410 
<span class="line-modified">411     bool result = jsObject-&gt;hasProperty(exec, ident);</span>
<span class="line-modified">412     handleExceptionIfNeeded(scope, exec, exception);</span>
413     return result;
414 }
415 
416 JSValueRef JSObjectGetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
417 {
418     if (!ctx) {
419         ASSERT_NOT_REACHED();
420         return nullptr;
421     }
<span class="line-modified">422     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">423     VM&amp; vm = exec-&gt;vm();</span>
424     JSLockHolder locker(vm);
425     auto scope = DECLARE_CATCH_SCOPE(vm);
426 
427     JSObject* jsObject = toJS(object);
<span class="line-modified">428     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">429     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
430         return nullptr;
431 
<span class="line-modified">432     JSValue jsValue = jsObject-&gt;get(exec, ident);</span>
<span class="line-modified">433     handleExceptionIfNeeded(scope, exec, exception);</span>
<span class="line-modified">434     return toRef(exec, jsValue);</span>
435 }
436 
437 void JSObjectSetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
438 {
439     if (!ctx) {
440         ASSERT_NOT_REACHED();
441         return;
442     }
<span class="line-modified">443     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">444     VM&amp; vm = exec-&gt;vm();</span>
445     JSLockHolder locker(vm);
446     auto scope = DECLARE_CATCH_SCOPE(vm);
447 
448     JSObject* jsObject = toJS(object);
<span class="line-modified">449     JSValue jsValue = toJS(exec, value);</span>
450 
<span class="line-modified">451     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">452     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
453         return;
454 
<span class="line-modified">455     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(exec, ident);</span>
456     if (LIKELY(!scope.exception())) {
457         if (doesNotHaveProperty) {
458             PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">459             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, exec, ident, desc, false);</span>
460         } else {
461             PutPropertySlot slot(jsObject);
<span class="line-modified">462             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, exec, ident, jsValue, slot);</span>
463         }
464     }
<span class="line-modified">465     handleExceptionIfNeeded(scope, exec, exception);</span>
466 }
467 
468 bool JSObjectDeletePropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
469 {
470     if (!ctx) {
471         ASSERT_NOT_REACHED();
472         return false;
473     }
<span class="line-modified">474     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">475     VM&amp; vm = exec-&gt;vm();</span>
476     JSLockHolder locker(vm);
477     auto scope = DECLARE_CATCH_SCOPE(vm);
478 
479     JSObject* jsObject = toJS(object);
<span class="line-modified">480     Identifier ident = toJS(exec, key).toPropertyKey(exec);</span>
<span class="line-modified">481     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
482         return false;
483 
<span class="line-modified">484     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, exec, ident);</span>
<span class="line-modified">485     handleExceptionIfNeeded(scope, exec, exception);</span>
486     return result;
487 }
488 
489 JSValueRef JSObjectGetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef* exception)
490 {
491     if (!ctx) {
492         ASSERT_NOT_REACHED();
493         return 0;
494     }
<span class="line-modified">495     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">496     VM&amp; vm = exec-&gt;vm();</span>
497     JSLockHolder locker(vm);
498     auto scope = DECLARE_CATCH_SCOPE(vm);
499 
500     JSObject* jsObject = toJS(object);
501 
<span class="line-modified">502     JSValue jsValue = jsObject-&gt;get(exec, propertyIndex);</span>
<span class="line-modified">503     handleExceptionIfNeeded(scope, exec, exception);</span>
<span class="line-modified">504     return toRef(exec, jsValue);</span>
505 }
506 
507 
508 void JSObjectSetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef value, JSValueRef* exception)
509 {
510     if (!ctx) {
511         ASSERT_NOT_REACHED();
512         return;
513     }
<span class="line-modified">514     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">515     VM&amp; vm = exec-&gt;vm();</span>
516     JSLockHolder locker(vm);
517     auto scope = DECLARE_CATCH_SCOPE(vm);
518 
519     JSObject* jsObject = toJS(object);
<span class="line-modified">520     JSValue jsValue = toJS(exec, value);</span>
521 
<span class="line-modified">522     jsObject-&gt;methodTable(vm)-&gt;putByIndex(jsObject, exec, propertyIndex, jsValue, false);</span>
<span class="line-modified">523     handleExceptionIfNeeded(scope, exec, exception);</span>
524 }
525 
526 bool JSObjectDeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
527 {
528     if (!ctx) {
529         ASSERT_NOT_REACHED();
530         return false;
531     }
<span class="line-modified">532     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">533     VM&amp; vm = exec-&gt;vm();</span>
534     JSLockHolder locker(vm);
535     auto scope = DECLARE_CATCH_SCOPE(vm);
536 
537     JSObject* jsObject = toJS(object);
538 
<span class="line-modified">539     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, exec, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">540     handleExceptionIfNeeded(scope, exec, exception);</span>
541     return result;
542 }
543 
544 // API objects have private properties, which may get accessed during destruction. This
545 // helper lets us get the ClassInfo of an API object from a function that may get called
546 // during destruction.
547 static const ClassInfo* classInfoPrivate(JSObject* jsObject)
548 {
549     VM&amp; vm = jsObject-&gt;vm();
550 
551     if (vm.currentlyDestructingCallbackObject != jsObject)
552         return jsObject-&gt;classInfo(vm);
553 
554     return vm.currentlyDestructingCallbackObjectClassInfo;
555 }
556 
557 void* JSObjectGetPrivate(JSObjectRef object)
558 {
559     JSObject* jsObject = uncheckedToJS(object);
560     VM&amp; vm = jsObject-&gt;vm();
561 
562     const ClassInfo* classInfo = classInfoPrivate(jsObject);
563 
564     // Get wrapped object if proxied
565     if (classInfo-&gt;isSubClassOf(JSProxy::info())) {
566         jsObject = static_cast&lt;JSProxy*&gt;(jsObject)-&gt;target();
567         classInfo = jsObject-&gt;classInfo(vm);
568     }
569 
570     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info()))
571         return static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivate();
<span class="line-modified">572     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSDestructibleObject&gt;::info()))</span>
<span class="line-modified">573         return static_cast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;getPrivate();</span>
574 #if JSC_OBJC_API_ENABLED
575     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info()))
576         return static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivate();
577 #endif
578 
579     return 0;
580 }
581 
582 bool JSObjectSetPrivate(JSObjectRef object, void* data)
583 {
584     JSObject* jsObject = uncheckedToJS(object);
585     VM&amp; vm = jsObject-&gt;vm();
586 
587     const ClassInfo* classInfo = classInfoPrivate(jsObject);
588 
589     // Get wrapped object if proxied
590     if (classInfo-&gt;isSubClassOf(JSProxy::info())) {
591         jsObject = static_cast&lt;JSProxy*&gt;(jsObject)-&gt;target();
592         classInfo = jsObject-&gt;classInfo(vm);
593     }
594 
595     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info())) {
596         static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
597         return true;
598     }
<span class="line-modified">599     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSDestructibleObject&gt;::info())) {</span>
<span class="line-modified">600         static_cast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);</span>
601         return true;
602     }
603 #if JSC_OBJC_API_ENABLED
604     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info())) {
605         static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
606         return true;
607     }
608 #endif
609 
610     return false;
611 }
612 
613 JSValueRef JSObjectGetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
614 {
<span class="line-modified">615     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">616     VM&amp; vm = exec-&gt;vm();</span>
617     JSLockHolder locker(vm);
618     JSObject* jsObject = toJS(object);
619     JSValue result;
620     Identifier name(propertyName-&gt;identifier(&amp;vm));
621 
622 
623     // Get wrapped object if proxied
624     if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
625         jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
626 
627     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm))
628         result = jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
<span class="line-modified">629     else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSDestructibleObject&gt;&gt;(vm))</span>
<span class="line-modified">630         result = jsCast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);</span>
631 #if JSC_OBJC_API_ENABLED
632     else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm))
633         result = jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
634 #endif
<span class="line-modified">635     return toRef(exec, result);</span>
636 }
637 
638 bool JSObjectSetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value)
639 {
<span class="line-modified">640     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">641     VM&amp; vm = exec-&gt;vm();</span>
642     JSLockHolder locker(vm);
643     JSObject* jsObject = toJS(object);
<span class="line-modified">644     JSValue jsValue = value ? toJS(exec, value) : JSValue();</span>
645     Identifier name(propertyName-&gt;identifier(&amp;vm));
646 
647     // Get wrapped object if proxied
648     if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
649         jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
650 
651     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
652         jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
653         return true;
654     }
<span class="line-modified">655     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSDestructibleObject&gt;&gt;(vm)) {</span>
<span class="line-modified">656         jsCast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);</span>
657         return true;
658     }
659 #if JSC_OBJC_API_ENABLED
660     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
661         jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
662         return true;
663     }
664 #endif
665     return false;
666 }
667 
668 bool JSObjectDeletePrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
669 {
<span class="line-modified">670     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">671     VM&amp; vm = exec-&gt;vm();</span>
672     JSLockHolder locker(vm);
673     JSObject* jsObject = toJS(object);
674     Identifier name(propertyName-&gt;identifier(&amp;vm));
675 
676     // Get wrapped object if proxied
677     if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
678         jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
679 
680     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
681         jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
682         return true;
683     }
<span class="line-modified">684     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSDestructibleObject&gt;&gt;(vm)) {</span>
<span class="line-modified">685         jsCast&lt;JSCallbackObject&lt;JSDestructibleObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);</span>
686         return true;
687     }
688 #if JSC_OBJC_API_ENABLED
689     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
690         jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
691         return true;
692     }
693 #endif
694     return false;
695 }
696 
697 bool JSObjectIsFunction(JSContextRef ctx, JSObjectRef object)
698 {
699     if (!object)
700         return false;
<span class="line-modified">701     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">702     VM&amp; vm = exec-&gt;vm();</span>
703     JSLockHolder locker(vm);
704     CallData callData;
705     JSCell* cell = toJS(object);
706     return cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData) != CallType::None;
707 }
708 
709 JSValueRef JSObjectCallAsFunction(JSContextRef ctx, JSObjectRef object, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
710 {
<span class="line-modified">711     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">712     VM&amp; vm = exec-&gt;vm();</span>
713     JSLockHolder locker(vm);
714     auto scope = DECLARE_CATCH_SCOPE(vm);
715 
716     if (!object)
717         return 0;
718 
719     JSObject* jsObject = toJS(object);
720     JSObject* jsThisObject = toJS(thisObject);
721 
722     if (!jsThisObject)
<span class="line-modified">723         jsThisObject = exec-&gt;globalThisValue();</span>
724 
725     MarkedArgumentBuffer argList;
726     for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">727         argList.append(toJS(exec, arguments[i]));</span>
728     if (UNLIKELY(argList.hasOverflowed())) {
729         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">730         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">731         handleExceptionIfNeeded(scope, exec, exception);</span>
732         return 0;
733     }
734 
735     CallData callData;
736     CallType callType = jsObject-&gt;methodTable(vm)-&gt;getCallData(jsObject, callData);
737     if (callType == CallType::None)
738         return 0;
739 
<span class="line-modified">740     JSValueRef result = toRef(exec, profiledCall(exec, ProfilingReason::API, jsObject, callType, callData, jsThisObject, argList));</span>
<span class="line-modified">741     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
742         result = 0;
743     return result;
744 }
745 
746 bool JSObjectIsConstructor(JSContextRef ctx, JSObjectRef object)
747 {
<span class="line-modified">748     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">749     VM&amp; vm = exec-&gt;vm();</span>
750     JSLockHolder locker(vm);
751     if (!object)
752         return false;
753     return toJS(object)-&gt;isConstructor(vm);
754 }
755 
756 JSObjectRef JSObjectCallAsConstructor(JSContextRef ctx, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
757 {
<span class="line-modified">758     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">759     VM&amp; vm = exec-&gt;vm();</span>
760     JSLockHolder locker(vm);
761     auto scope = DECLARE_CATCH_SCOPE(vm);
762 
763     if (!object)
764         return 0;
765 
766     JSObject* jsObject = toJS(object);
767 
768     ConstructData constructData;
769     ConstructType constructType = jsObject-&gt;methodTable(vm)-&gt;getConstructData(jsObject, constructData);
770     if (constructType == ConstructType::None)
771         return 0;
772 
773     MarkedArgumentBuffer argList;
774     for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">775         argList.append(toJS(exec, arguments[i]));</span>
776     if (UNLIKELY(argList.hasOverflowed())) {
777         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">778         throwOutOfMemoryError(exec, throwScope);</span>
<span class="line-modified">779         handleExceptionIfNeeded(scope, exec, exception);</span>
780         return 0;
781     }
782 
<span class="line-modified">783     JSObjectRef result = toRef(profiledConstruct(exec, ProfilingReason::API, jsObject, constructType, constructData, argList));</span>
<span class="line-modified">784     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
785         result = 0;
786     return result;
787 }
788 
789 struct OpaqueJSPropertyNameArray {
790     WTF_MAKE_FAST_ALLOCATED;
791 public:
792     // FIXME: Why not inherit from RefCounted?
793     OpaqueJSPropertyNameArray(VM* vm)
794         : refCount(0)
795         , vm(vm)
796     {
797     }
798 
799     unsigned refCount;
800     VM* vm;
801     Vector&lt;Ref&lt;OpaqueJSString&gt;&gt; array;
802 };
803 
804 JSPropertyNameArrayRef JSObjectCopyPropertyNames(JSContextRef ctx, JSObjectRef object)
805 {
806     if (!ctx) {
807         ASSERT_NOT_REACHED();
808         return 0;
809     }
<span class="line-modified">810     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">811     JSLockHolder locker(exec);</span>
812 
<span class="line-modified">813     VM&amp; vm = exec-&gt;vm();</span>
814 
815     JSObject* jsObject = toJS(object);
816     JSPropertyNameArrayRef propertyNames = new OpaqueJSPropertyNameArray(&amp;vm);
817     PropertyNameArray array(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">818     jsObject-&gt;methodTable(vm)-&gt;getPropertyNames(jsObject, exec, array, EnumerationMode());</span>
819 
820     size_t size = array.size();
821     propertyNames-&gt;array.reserveInitialCapacity(size);
822     for (size_t i = 0; i &lt; size; ++i)
823         propertyNames-&gt;array.uncheckedAppend(OpaqueJSString::tryCreate(array[i].string()).releaseNonNull());
824 
825     return JSPropertyNameArrayRetain(propertyNames);
826 }
827 
828 JSPropertyNameArrayRef JSPropertyNameArrayRetain(JSPropertyNameArrayRef array)
829 {
830     ++array-&gt;refCount;
831     return array;
832 }
833 
834 void JSPropertyNameArrayRelease(JSPropertyNameArrayRef array)
835 {
836     if (--array-&gt;refCount == 0) {
837         JSLockHolder locker(array-&gt;vm);
838         delete array;
</pre>
<hr />
<pre>
860 JSObjectRef JSObjectGetProxyTarget(JSObjectRef objectRef)
861 {
862     JSObject* object = toJS(objectRef);
863     if (!object)
864         return nullptr;
865     VM&amp; vm = object-&gt;vm();
866     JSLockHolder locker(vm);
867     JSObject* result = nullptr;
868     if (JSProxy* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, object))
869         result = proxy-&gt;target();
870     else if (ProxyObject* proxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, object))
871         result = proxy-&gt;target();
872     return toRef(result);
873 }
874 
875 JSGlobalContextRef JSObjectGetGlobalContext(JSObjectRef objectRef)
876 {
877     JSObject* object = toJS(objectRef);
878     if (!object)
879         return nullptr;
<span class="line-modified">880     return reinterpret_cast&lt;JSGlobalContextRef&gt;(object-&gt;globalObject()-&gt;globalExec());</span>
881 }
882 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2008 Kelvin W Sherlock (ksherlock@gmail.com)
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
</pre>
<hr />
<pre>
 30 
 31 #include &quot;APICast.h&quot;
 32 #include &quot;APIUtils.h&quot;
 33 #include &quot;DateConstructor.h&quot;
 34 #include &quot;ErrorConstructor.h&quot;
 35 #include &quot;Exception.h&quot;
 36 #include &quot;FunctionConstructor.h&quot;
 37 #include &quot;Identifier.h&quot;
 38 #include &quot;InitializeThreading.h&quot;
 39 #include &quot;JSAPIWrapperObject.h&quot;
 40 #include &quot;JSArray.h&quot;
 41 #include &quot;JSCInlines.h&quot;
 42 #include &quot;JSCallbackConstructor.h&quot;
 43 #include &quot;JSCallbackFunction.h&quot;
 44 #include &quot;JSCallbackObject.h&quot;
 45 #include &quot;JSClassRef.h&quot;
 46 #include &quot;JSFunction.h&quot;
 47 #include &quot;JSGlobalObject.h&quot;
 48 #include &quot;JSObject.h&quot;
 49 #include &quot;JSPromise.h&quot;

 50 #include &quot;JSRetainPtr.h&quot;
 51 #include &quot;JSString.h&quot;
 52 #include &quot;JSValueRef.h&quot;
 53 #include &quot;ObjectConstructor.h&quot;
 54 #include &quot;ObjectPrototype.h&quot;
 55 #include &quot;PropertyNameArray.h&quot;
 56 #include &quot;ProxyObject.h&quot;
 57 #include &quot;RegExpConstructor.h&quot;
 58 
 59 #if ENABLE(REMOTE_INSPECTOR)
 60 #include &quot;JSGlobalObjectInspectorController.h&quot;
 61 #endif
 62 
 63 using namespace JSC;
 64 
 65 JSClassRef JSClassCreate(const JSClassDefinition* definition)
 66 {
 67     initializeThreading();
 68     auto jsClass = (definition-&gt;attributes &amp; kJSClassAttributeNoAutomaticPrototype)
 69         ? OpaqueJSClass::createNoAutomaticPrototype(definition)
</pre>
<hr />
<pre>
 72     return &amp;jsClass.leakRef();
 73 }
 74 
 75 JSClassRef JSClassRetain(JSClassRef jsClass)
 76 {
 77     jsClass-&gt;ref();
 78     return jsClass;
 79 }
 80 
 81 void JSClassRelease(JSClassRef jsClass)
 82 {
 83     jsClass-&gt;deref();
 84 }
 85 
 86 JSObjectRef JSObjectMake(JSContextRef ctx, JSClassRef jsClass, void* data)
 87 {
 88     if (!ctx) {
 89         ASSERT_NOT_REACHED();
 90         return 0;
 91     }
<span class="line-modified"> 92     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified"> 93     VM&amp; vm = globalObject-&gt;vm();</span>
 94     JSLockHolder locker(vm);
 95 
 96     if (!jsClass)
<span class="line-modified"> 97         return toRef(constructEmptyObject(globalObject));</span>
 98 
<span class="line-modified"> 99     JSCallbackObject&lt;JSNonFinalObject&gt;* object = JSCallbackObject&lt;JSNonFinalObject&gt;::create(globalObject, globalObject-&gt;callbackObjectStructure(), jsClass, data);</span>
<span class="line-modified">100     if (JSObject* prototype = jsClass-&gt;prototype(globalObject))</span>
101         object-&gt;setPrototypeDirect(vm, prototype);
102 
103     return toRef(object);
104 }
105 
106 JSObjectRef JSObjectMakeFunctionWithCallback(JSContextRef ctx, JSStringRef name, JSObjectCallAsFunctionCallback callAsFunction)
107 {
108     if (!ctx) {
109         ASSERT_NOT_REACHED();
110         return 0;
111     }
<span class="line-modified">112     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">113     VM&amp; vm = globalObject-&gt;vm();</span>
114     JSLockHolder locker(vm);
<span class="line-modified">115     return toRef(JSCallbackFunction::create(vm, globalObject, callAsFunction, name ? name-&gt;string() : &quot;anonymous&quot;_s));</span>
116 }
117 
118 JSObjectRef JSObjectMakeConstructor(JSContextRef ctx, JSClassRef jsClass, JSObjectCallAsConstructorCallback callAsConstructor)
119 {
120     if (!ctx) {
121         ASSERT_NOT_REACHED();
122         return 0;
123     }
<span class="line-modified">124     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">125     VM&amp; vm = globalObject-&gt;vm();</span>
126     JSLockHolder locker(vm);
127 
<span class="line-modified">128     JSValue jsPrototype = jsClass ? jsClass-&gt;prototype(globalObject) : 0;</span>
129     if (!jsPrototype)
<span class="line-modified">130         jsPrototype = globalObject-&gt;objectPrototype();</span>
131 
<span class="line-modified">132     JSCallbackConstructor* constructor = JSCallbackConstructor::create(globalObject, globalObject-&gt;callbackConstructorStructure(), jsClass, callAsConstructor);</span>
133     constructor-&gt;putDirect(vm, vm.propertyNames-&gt;prototype, jsPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
134     return toRef(constructor);
135 }
136 
137 JSObjectRef JSObjectMakeFunction(JSContextRef ctx, JSStringRef name, unsigned parameterCount, const JSStringRef parameterNames[], JSStringRef body, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
138 {
139     if (!ctx) {
140         ASSERT_NOT_REACHED();
141         return 0;
142     }
<span class="line-modified">143     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">144     VM&amp; vm = globalObject-&gt;vm();</span>
145     JSLockHolder locker(vm);
146     auto scope = DECLARE_CATCH_SCOPE(vm);
147 
148     startingLineNumber = std::max(1, startingLineNumber);
149     Identifier nameID = name ? name-&gt;identifier(&amp;vm) : Identifier::fromString(vm, &quot;anonymous&quot;);
150 
151     MarkedArgumentBuffer args;
152     for (unsigned i = 0; i &lt; parameterCount; i++)
153         args.append(jsString(vm, parameterNames[i]-&gt;string()));
154     args.append(jsString(vm, body-&gt;string()));
155     if (UNLIKELY(args.hasOverflowed())) {
156         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">157         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">158         handleExceptionIfNeeded(scope, ctx, exception);</span>
159         return 0;
160     }
161 
162     auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
<span class="line-modified">163     JSObject* result = constructFunction(globalObject, args, nameID, SourceOrigin { sourceURLString }, sourceURLString, TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));</span>
<span class="line-modified">164     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
165         result = 0;
166     return toRef(result);
167 }
168 
169 JSObjectRef JSObjectMakeArray(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
170 {
171     if (!ctx) {
172         ASSERT_NOT_REACHED();
173         return 0;
174     }
<span class="line-modified">175     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">176     VM&amp; vm = globalObject-&gt;vm();</span>
177     JSLockHolder locker(vm);
178     auto scope = DECLARE_CATCH_SCOPE(vm);
179 
180     JSObject* result;
181     if (argumentCount) {
182         MarkedArgumentBuffer argList;
183         for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">184             argList.append(toJS(globalObject, arguments[i]));</span>
185         if (UNLIKELY(argList.hasOverflowed())) {
186             auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">187             throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">188             handleExceptionIfNeeded(scope, ctx, exception);</span>
189             return 0;
190         }
191 
<span class="line-modified">192         result = constructArray(globalObject, static_cast&lt;ArrayAllocationProfile*&gt;(0), argList);</span>
193     } else
<span class="line-modified">194         result = constructEmptyArray(globalObject, 0);</span>
195 
<span class="line-modified">196     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
197         result = 0;
198 
199     return toRef(result);
200 }
201 
202 JSObjectRef JSObjectMakeDate(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
203 {
204     if (!ctx) {
205         ASSERT_NOT_REACHED();
206         return 0;
207     }
<span class="line-modified">208     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">209     VM&amp; vm = globalObject-&gt;vm();</span>
210     JSLockHolder locker(vm);
211     auto scope = DECLARE_CATCH_SCOPE(vm);
212 
213     MarkedArgumentBuffer argList;
214     for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">215         argList.append(toJS(globalObject, arguments[i]));</span>
216     if (UNLIKELY(argList.hasOverflowed())) {
217         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">218         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">219         handleExceptionIfNeeded(scope, ctx, exception);</span>
220         return 0;
221     }
222 
<span class="line-modified">223     JSObject* result = constructDate(globalObject, JSValue(), argList);</span>
<span class="line-modified">224     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
225         result = 0;
226 
227     return toRef(result);
228 }
229 
230 JSObjectRef JSObjectMakeError(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
231 {
232     if (!ctx) {
233         ASSERT_NOT_REACHED();
234         return 0;
235     }
<span class="line-modified">236     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">237     VM&amp; vm = globalObject-&gt;vm();</span>
238     JSLockHolder locker(vm);
239     auto scope = DECLARE_CATCH_SCOPE(vm);
240 
<span class="line-modified">241     JSValue message = argumentCount ? toJS(globalObject, arguments[0]) : jsUndefined();</span>
<span class="line-modified">242     Structure* errorStructure = globalObject-&gt;errorStructure();</span>
<span class="line-modified">243     JSObject* result = ErrorInstance::create(globalObject, errorStructure, message);</span>
244 
<span class="line-modified">245     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
246         result = 0;
247 
248     return toRef(result);
249 }
250 
251 JSObjectRef JSObjectMakeRegExp(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[],  JSValueRef* exception)
252 {
253     if (!ctx) {
254         ASSERT_NOT_REACHED();
255         return 0;
256     }
<span class="line-modified">257     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">258     VM&amp; vm = globalObject-&gt;vm();</span>
259     JSLockHolder locker(vm);
260     auto scope = DECLARE_CATCH_SCOPE(vm);
261 
262     MarkedArgumentBuffer argList;
263     for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">264         argList.append(toJS(globalObject, arguments[i]));</span>
265     if (UNLIKELY(argList.hasOverflowed())) {
266         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">267         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">268         handleExceptionIfNeeded(scope, ctx, exception);</span>
269         return 0;
270     }
271 
<span class="line-modified">272     JSObject* result = constructRegExp(globalObject, argList);</span>
<span class="line-modified">273     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
274         result = 0;
275 
276     return toRef(result);
277 }
278 
279 JSObjectRef JSObjectMakeDeferredPromise(JSContextRef ctx, JSObjectRef* resolve, JSObjectRef* reject, JSValueRef* exception)
280 {
281     if (!ctx) {
282         ASSERT_NOT_REACHED();
283         return nullptr;
284     }
285 
<span class="line-modified">286     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">287     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">288     JSLockHolder locker(globalObject);</span>
289     auto scope = DECLARE_CATCH_SCOPE(vm);
290 
<span class="line-modified">291     JSPromise::DeferredData data = JSPromise::createDeferredData(globalObject, globalObject-&gt;promiseConstructor());</span>
<span class="line-modified">292     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>

293         return nullptr;
294 
295     if (resolve)
296         *resolve = toRef(data.resolve);
297     if (reject)
298         *reject = toRef(data.reject);
299     return toRef(data.promise);
300 }
301 
302 JSValueRef JSObjectGetPrototype(JSContextRef ctx, JSObjectRef object)
303 {
304     if (!ctx) {
305         ASSERT_NOT_REACHED();
306         return 0;
307     }
<span class="line-modified">308     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">309     JSLockHolder locker(globalObject);</span>
310 
311     JSObject* jsObject = toJS(object);
<span class="line-modified">312     return toRef(globalObject, jsObject-&gt;getPrototypeDirect(globalObject-&gt;vm()));</span>
313 }
314 
315 void JSObjectSetPrototype(JSContextRef ctx, JSObjectRef object, JSValueRef value)
316 {
317     if (!ctx) {
318         ASSERT_NOT_REACHED();
319         return;
320     }
<span class="line-modified">321     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">322     VM&amp; vm = globalObject-&gt;vm();</span>
323     JSLockHolder locker(vm);
324     auto scope = DECLARE_CATCH_SCOPE(vm);
325 
326     JSObject* jsObject = toJS(object);
<span class="line-modified">327     JSValue jsValue = toJS(globalObject, value);</span>
<span class="line-modified">328     jsObject-&gt;setPrototype(vm, globalObject, jsValue.isObject() ? jsValue : jsNull());</span>
<span class="line-modified">329     handleExceptionIfNeeded(scope, ctx, nullptr);</span>
330 }
331 
332 bool JSObjectHasProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
333 {
334     if (!ctx) {
335         ASSERT_NOT_REACHED();
336         return false;
337     }
<span class="line-modified">338     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">339     VM&amp; vm = globalObject-&gt;vm();</span>
340     JSLockHolder locker(vm);
341 
342     JSObject* jsObject = toJS(object);
343 
<span class="line-modified">344     return jsObject-&gt;hasProperty(globalObject, propertyName-&gt;identifier(&amp;vm));</span>
345 }
346 
347 JSValueRef JSObjectGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
348 {
<span class="line-modified">349     if (!ctx || !object) {</span>
350         ASSERT_NOT_REACHED();
351         return 0;
352     }
<span class="line-modified">353     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">354     VM&amp; vm = globalObject-&gt;vm();</span>
355     JSLockHolder locker(vm);
356     auto scope = DECLARE_CATCH_SCOPE(vm);
357 
358     JSObject* jsObject = toJS(object);
359 
<span class="line-modified">360     JSValue jsValue = jsObject-&gt;get(globalObject, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">361     handleExceptionIfNeeded(scope, ctx, exception);</span>
<span class="line-modified">362     return toRef(globalObject, jsValue);</span>
363 }
364 
365 void JSObjectSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
366 {
367     if (!ctx) {
368         ASSERT_NOT_REACHED();
369         return;
370     }
<span class="line-modified">371     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">372     VM&amp; vm = globalObject-&gt;vm();</span>
373     JSLockHolder locker(vm);
374     auto scope = DECLARE_CATCH_SCOPE(vm);
375 
376     JSObject* jsObject = toJS(object);
377     Identifier name(propertyName-&gt;identifier(&amp;vm));
<span class="line-modified">378     JSValue jsValue = toJS(globalObject, value);</span>
379 
<span class="line-modified">380     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(globalObject, name);</span>
381     if (LIKELY(!scope.exception())) {
382         if (doesNotHaveProperty) {
383             PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">384             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, globalObject, name, desc, false);</span>
385         } else {
386             PutPropertySlot slot(jsObject);
<span class="line-modified">387             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, globalObject, name, jsValue, slot);</span>
388         }
389     }
<span class="line-modified">390     handleExceptionIfNeeded(scope, ctx, exception);</span>
391 }
392 
393 bool JSObjectHasPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
394 {
395     if (!ctx) {
396         ASSERT_NOT_REACHED();
397         return false;
398     }
<span class="line-modified">399     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">400     VM&amp; vm = globalObject-&gt;vm();</span>
401     JSLockHolder locker(vm);
402     auto scope = DECLARE_CATCH_SCOPE(vm);
403 
404     JSObject* jsObject = toJS(object);
<span class="line-modified">405     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">406     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
407         return false;
408 
<span class="line-modified">409     bool result = jsObject-&gt;hasProperty(globalObject, ident);</span>
<span class="line-modified">410     handleExceptionIfNeeded(scope, ctx, exception);</span>
411     return result;
412 }
413 
414 JSValueRef JSObjectGetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
415 {
416     if (!ctx) {
417         ASSERT_NOT_REACHED();
418         return nullptr;
419     }
<span class="line-modified">420     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">421     VM&amp; vm = globalObject-&gt;vm();</span>
422     JSLockHolder locker(vm);
423     auto scope = DECLARE_CATCH_SCOPE(vm);
424 
425     JSObject* jsObject = toJS(object);
<span class="line-modified">426     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">427     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
428         return nullptr;
429 
<span class="line-modified">430     JSValue jsValue = jsObject-&gt;get(globalObject, ident);</span>
<span class="line-modified">431     handleExceptionIfNeeded(scope, ctx, exception);</span>
<span class="line-modified">432     return toRef(globalObject, jsValue);</span>
433 }
434 
435 void JSObjectSetPropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef value, JSPropertyAttributes attributes, JSValueRef* exception)
436 {
437     if (!ctx) {
438         ASSERT_NOT_REACHED();
439         return;
440     }
<span class="line-modified">441     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">442     VM&amp; vm = globalObject-&gt;vm();</span>
443     JSLockHolder locker(vm);
444     auto scope = DECLARE_CATCH_SCOPE(vm);
445 
446     JSObject* jsObject = toJS(object);
<span class="line-modified">447     JSValue jsValue = toJS(globalObject, value);</span>
448 
<span class="line-modified">449     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">450     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
451         return;
452 
<span class="line-modified">453     bool doesNotHaveProperty = attributes &amp;&amp; !jsObject-&gt;hasProperty(globalObject, ident);</span>
454     if (LIKELY(!scope.exception())) {
455         if (doesNotHaveProperty) {
456             PropertyDescriptor desc(jsValue, attributes);
<span class="line-modified">457             jsObject-&gt;methodTable(vm)-&gt;defineOwnProperty(jsObject, globalObject, ident, desc, false);</span>
458         } else {
459             PutPropertySlot slot(jsObject);
<span class="line-modified">460             jsObject-&gt;methodTable(vm)-&gt;put(jsObject, globalObject, ident, jsValue, slot);</span>
461         }
462     }
<span class="line-modified">463     handleExceptionIfNeeded(scope, ctx, exception);</span>
464 }
465 
466 bool JSObjectDeletePropertyForKey(JSContextRef ctx, JSObjectRef object, JSValueRef key, JSValueRef* exception)
467 {
468     if (!ctx) {
469         ASSERT_NOT_REACHED();
470         return false;
471     }
<span class="line-modified">472     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">473     VM&amp; vm = globalObject-&gt;vm();</span>
474     JSLockHolder locker(vm);
475     auto scope = DECLARE_CATCH_SCOPE(vm);
476 
477     JSObject* jsObject = toJS(object);
<span class="line-modified">478     Identifier ident = toJS(globalObject, key).toPropertyKey(globalObject);</span>
<span class="line-modified">479     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
480         return false;
481 
<span class="line-modified">482     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, globalObject, ident);</span>
<span class="line-modified">483     handleExceptionIfNeeded(scope, ctx, exception);</span>
484     return result;
485 }
486 
487 JSValueRef JSObjectGetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef* exception)
488 {
489     if (!ctx) {
490         ASSERT_NOT_REACHED();
491         return 0;
492     }
<span class="line-modified">493     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">494     VM&amp; vm = globalObject-&gt;vm();</span>
495     JSLockHolder locker(vm);
496     auto scope = DECLARE_CATCH_SCOPE(vm);
497 
498     JSObject* jsObject = toJS(object);
499 
<span class="line-modified">500     JSValue jsValue = jsObject-&gt;get(globalObject, propertyIndex);</span>
<span class="line-modified">501     handleExceptionIfNeeded(scope, ctx, exception);</span>
<span class="line-modified">502     return toRef(globalObject, jsValue);</span>
503 }
504 
505 
506 void JSObjectSetPropertyAtIndex(JSContextRef ctx, JSObjectRef object, unsigned propertyIndex, JSValueRef value, JSValueRef* exception)
507 {
508     if (!ctx) {
509         ASSERT_NOT_REACHED();
510         return;
511     }
<span class="line-modified">512     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">513     VM&amp; vm = globalObject-&gt;vm();</span>
514     JSLockHolder locker(vm);
515     auto scope = DECLARE_CATCH_SCOPE(vm);
516 
517     JSObject* jsObject = toJS(object);
<span class="line-modified">518     JSValue jsValue = toJS(globalObject, value);</span>
519 
<span class="line-modified">520     jsObject-&gt;methodTable(vm)-&gt;putByIndex(jsObject, globalObject, propertyIndex, jsValue, false);</span>
<span class="line-modified">521     handleExceptionIfNeeded(scope, ctx, exception);</span>
522 }
523 
524 bool JSObjectDeleteProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef* exception)
525 {
526     if (!ctx) {
527         ASSERT_NOT_REACHED();
528         return false;
529     }
<span class="line-modified">530     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">531     VM&amp; vm = globalObject-&gt;vm();</span>
532     JSLockHolder locker(vm);
533     auto scope = DECLARE_CATCH_SCOPE(vm);
534 
535     JSObject* jsObject = toJS(object);
536 
<span class="line-modified">537     bool result = jsObject-&gt;methodTable(vm)-&gt;deleteProperty(jsObject, globalObject, propertyName-&gt;identifier(&amp;vm));</span>
<span class="line-modified">538     handleExceptionIfNeeded(scope, ctx, exception);</span>
539     return result;
540 }
541 
542 // API objects have private properties, which may get accessed during destruction. This
543 // helper lets us get the ClassInfo of an API object from a function that may get called
544 // during destruction.
545 static const ClassInfo* classInfoPrivate(JSObject* jsObject)
546 {
547     VM&amp; vm = jsObject-&gt;vm();
548 
549     if (vm.currentlyDestructingCallbackObject != jsObject)
550         return jsObject-&gt;classInfo(vm);
551 
552     return vm.currentlyDestructingCallbackObjectClassInfo;
553 }
554 
555 void* JSObjectGetPrivate(JSObjectRef object)
556 {
557     JSObject* jsObject = uncheckedToJS(object);
558     VM&amp; vm = jsObject-&gt;vm();
559 
560     const ClassInfo* classInfo = classInfoPrivate(jsObject);
561 
562     // Get wrapped object if proxied
563     if (classInfo-&gt;isSubClassOf(JSProxy::info())) {
564         jsObject = static_cast&lt;JSProxy*&gt;(jsObject)-&gt;target();
565         classInfo = jsObject-&gt;classInfo(vm);
566     }
567 
568     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info()))
569         return static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivate();
<span class="line-modified">570     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSNonFinalObject&gt;::info()))</span>
<span class="line-modified">571         return static_cast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;getPrivate();</span>
572 #if JSC_OBJC_API_ENABLED
573     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info()))
574         return static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivate();
575 #endif
576 
577     return 0;
578 }
579 
580 bool JSObjectSetPrivate(JSObjectRef object, void* data)
581 {
582     JSObject* jsObject = uncheckedToJS(object);
583     VM&amp; vm = jsObject-&gt;vm();
584 
585     const ClassInfo* classInfo = classInfoPrivate(jsObject);
586 
587     // Get wrapped object if proxied
588     if (classInfo-&gt;isSubClassOf(JSProxy::info())) {
589         jsObject = static_cast&lt;JSProxy*&gt;(jsObject)-&gt;target();
590         classInfo = jsObject-&gt;classInfo(vm);
591     }
592 
593     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSGlobalObject&gt;::info())) {
594         static_cast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
595         return true;
596     }
<span class="line-modified">597     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSNonFinalObject&gt;::info())) {</span>
<span class="line-modified">598         static_cast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);</span>
599         return true;
600     }
601 #if JSC_OBJC_API_ENABLED
602     if (classInfo-&gt;isSubClassOf(JSCallbackObject&lt;JSAPIWrapperObject&gt;::info())) {
603         static_cast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivate(data);
604         return true;
605     }
606 #endif
607 
608     return false;
609 }
610 
611 JSValueRef JSObjectGetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
612 {
<span class="line-modified">613     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">614     VM&amp; vm = globalObject-&gt;vm();</span>
615     JSLockHolder locker(vm);
616     JSObject* jsObject = toJS(object);
617     JSValue result;
618     Identifier name(propertyName-&gt;identifier(&amp;vm));
619 
620 
621     // Get wrapped object if proxied
622     if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
623         jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
624 
625     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm))
626         result = jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
<span class="line-modified">627     else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;(vm))</span>
<span class="line-modified">628         result = jsCast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);</span>
629 #if JSC_OBJC_API_ENABLED
630     else if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm))
631         result = jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;getPrivateProperty(name);
632 #endif
<span class="line-modified">633     return toRef(globalObject, result);</span>
634 }
635 
636 bool JSObjectSetPrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value)
637 {
<span class="line-modified">638     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">639     VM&amp; vm = globalObject-&gt;vm();</span>
640     JSLockHolder locker(vm);
641     JSObject* jsObject = toJS(object);
<span class="line-modified">642     JSValue jsValue = value ? toJS(globalObject, value) : JSValue();</span>
643     Identifier name(propertyName-&gt;identifier(&amp;vm));
644 
645     // Get wrapped object if proxied
646     if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
647         jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
648 
649     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
650         jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
651         return true;
652     }
<span class="line-modified">653     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;(vm)) {</span>
<span class="line-modified">654         jsCast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);</span>
655         return true;
656     }
657 #if JSC_OBJC_API_ENABLED
658     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
659         jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;setPrivateProperty(vm, name, jsValue);
660         return true;
661     }
662 #endif
663     return false;
664 }
665 
666 bool JSObjectDeletePrivateProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName)
667 {
<span class="line-modified">668     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">669     VM&amp; vm = globalObject-&gt;vm();</span>
670     JSLockHolder locker(vm);
671     JSObject* jsObject = toJS(object);
672     Identifier name(propertyName-&gt;identifier(&amp;vm));
673 
674     // Get wrapped object if proxied
675     if (jsObject-&gt;inherits&lt;JSProxy&gt;(vm))
676         jsObject = jsCast&lt;JSProxy*&gt;(jsObject)-&gt;target();
677 
678     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSGlobalObject&gt;&gt;(vm)) {
679         jsCast&lt;JSCallbackObject&lt;JSGlobalObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
680         return true;
681     }
<span class="line-modified">682     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSNonFinalObject&gt;&gt;(vm)) {</span>
<span class="line-modified">683         jsCast&lt;JSCallbackObject&lt;JSNonFinalObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);</span>
684         return true;
685     }
686 #if JSC_OBJC_API_ENABLED
687     if (jsObject-&gt;inherits&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;&gt;(vm)) {
688         jsCast&lt;JSCallbackObject&lt;JSAPIWrapperObject&gt;*&gt;(jsObject)-&gt;deletePrivateProperty(name);
689         return true;
690     }
691 #endif
692     return false;
693 }
694 
695 bool JSObjectIsFunction(JSContextRef ctx, JSObjectRef object)
696 {
697     if (!object)
698         return false;
<span class="line-modified">699     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">700     VM&amp; vm = globalObject-&gt;vm();</span>
701     JSLockHolder locker(vm);
702     CallData callData;
703     JSCell* cell = toJS(object);
704     return cell-&gt;methodTable(vm)-&gt;getCallData(cell, callData) != CallType::None;
705 }
706 
707 JSValueRef JSObjectCallAsFunction(JSContextRef ctx, JSObjectRef object, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
708 {
<span class="line-modified">709     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">710     VM&amp; vm = globalObject-&gt;vm();</span>
711     JSLockHolder locker(vm);
712     auto scope = DECLARE_CATCH_SCOPE(vm);
713 
714     if (!object)
715         return 0;
716 
717     JSObject* jsObject = toJS(object);
718     JSObject* jsThisObject = toJS(thisObject);
719 
720     if (!jsThisObject)
<span class="line-modified">721         jsThisObject = globalObject-&gt;globalThis();</span>
722 
723     MarkedArgumentBuffer argList;
724     for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">725         argList.append(toJS(globalObject, arguments[i]));</span>
726     if (UNLIKELY(argList.hasOverflowed())) {
727         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">728         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">729         handleExceptionIfNeeded(scope, ctx, exception);</span>
730         return 0;
731     }
732 
733     CallData callData;
734     CallType callType = jsObject-&gt;methodTable(vm)-&gt;getCallData(jsObject, callData);
735     if (callType == CallType::None)
736         return 0;
737 
<span class="line-modified">738     JSValueRef result = toRef(globalObject, profiledCall(globalObject, ProfilingReason::API, jsObject, callType, callData, jsThisObject, argList));</span>
<span class="line-modified">739     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
740         result = 0;
741     return result;
742 }
743 
744 bool JSObjectIsConstructor(JSContextRef ctx, JSObjectRef object)
745 {
<span class="line-modified">746     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">747     VM&amp; vm = globalObject-&gt;vm();</span>
748     JSLockHolder locker(vm);
749     if (!object)
750         return false;
751     return toJS(object)-&gt;isConstructor(vm);
752 }
753 
754 JSObjectRef JSObjectCallAsConstructor(JSContextRef ctx, JSObjectRef object, size_t argumentCount, const JSValueRef arguments[], JSValueRef* exception)
755 {
<span class="line-modified">756     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">757     VM&amp; vm = globalObject-&gt;vm();</span>
758     JSLockHolder locker(vm);
759     auto scope = DECLARE_CATCH_SCOPE(vm);
760 
761     if (!object)
762         return 0;
763 
764     JSObject* jsObject = toJS(object);
765 
766     ConstructData constructData;
767     ConstructType constructType = jsObject-&gt;methodTable(vm)-&gt;getConstructData(jsObject, constructData);
768     if (constructType == ConstructType::None)
769         return 0;
770 
771     MarkedArgumentBuffer argList;
772     for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">773         argList.append(toJS(globalObject, arguments[i]));</span>
774     if (UNLIKELY(argList.hasOverflowed())) {
775         auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">776         throwOutOfMemoryError(globalObject, throwScope);</span>
<span class="line-modified">777         handleExceptionIfNeeded(scope, ctx, exception);</span>
778         return 0;
779     }
780 
<span class="line-modified">781     JSObjectRef result = toRef(profiledConstruct(globalObject, ProfilingReason::API, jsObject, constructType, constructData, argList));</span>
<span class="line-modified">782     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
783         result = 0;
784     return result;
785 }
786 
787 struct OpaqueJSPropertyNameArray {
788     WTF_MAKE_FAST_ALLOCATED;
789 public:
790     // FIXME: Why not inherit from RefCounted?
791     OpaqueJSPropertyNameArray(VM* vm)
792         : refCount(0)
793         , vm(vm)
794     {
795     }
796 
797     unsigned refCount;
798     VM* vm;
799     Vector&lt;Ref&lt;OpaqueJSString&gt;&gt; array;
800 };
801 
802 JSPropertyNameArrayRef JSObjectCopyPropertyNames(JSContextRef ctx, JSObjectRef object)
803 {
804     if (!ctx) {
805         ASSERT_NOT_REACHED();
806         return 0;
807     }
<span class="line-modified">808     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">809     JSLockHolder locker(globalObject);</span>
810 
<span class="line-modified">811     VM&amp; vm = globalObject-&gt;vm();</span>
812 
813     JSObject* jsObject = toJS(object);
814     JSPropertyNameArrayRef propertyNames = new OpaqueJSPropertyNameArray(&amp;vm);
815     PropertyNameArray array(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">816     jsObject-&gt;methodTable(vm)-&gt;getPropertyNames(jsObject, globalObject, array, EnumerationMode());</span>
817 
818     size_t size = array.size();
819     propertyNames-&gt;array.reserveInitialCapacity(size);
820     for (size_t i = 0; i &lt; size; ++i)
821         propertyNames-&gt;array.uncheckedAppend(OpaqueJSString::tryCreate(array[i].string()).releaseNonNull());
822 
823     return JSPropertyNameArrayRetain(propertyNames);
824 }
825 
826 JSPropertyNameArrayRef JSPropertyNameArrayRetain(JSPropertyNameArrayRef array)
827 {
828     ++array-&gt;refCount;
829     return array;
830 }
831 
832 void JSPropertyNameArrayRelease(JSPropertyNameArrayRef array)
833 {
834     if (--array-&gt;refCount == 0) {
835         JSLockHolder locker(array-&gt;vm);
836         delete array;
</pre>
<hr />
<pre>
858 JSObjectRef JSObjectGetProxyTarget(JSObjectRef objectRef)
859 {
860     JSObject* object = toJS(objectRef);
861     if (!object)
862         return nullptr;
863     VM&amp; vm = object-&gt;vm();
864     JSLockHolder locker(vm);
865     JSObject* result = nullptr;
866     if (JSProxy* proxy = jsDynamicCast&lt;JSProxy*&gt;(vm, object))
867         result = proxy-&gt;target();
868     else if (ProxyObject* proxy = jsDynamicCast&lt;ProxyObject*&gt;(vm, object))
869         result = proxy-&gt;target();
870     return toRef(result);
871 }
872 
873 JSGlobalContextRef JSObjectGetGlobalContext(JSObjectRef objectRef)
874 {
875     JSObject* object = toJS(objectRef);
876     if (!object)
877         return nullptr;
<span class="line-modified">878     return reinterpret_cast&lt;JSGlobalContextRef&gt;(object-&gt;globalObject());</span>
879 }
880 
</pre>
</td>
</tr>
</table>
<center><a href="JSHeapFinalizerPrivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScriptRef.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TrackListBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="VTTCue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTCue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
<span class="line-modified">   3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</pre>
<hr />
<pre>
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;VTTCue.h&quot;
  34 
  35 #if ENABLE(VIDEO_TRACK)
  36 
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CSSValueKeywords.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Event.h&quot;
  41 #include &quot;HTMLDivElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLStyleElement.h&quot;
  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeTraversal.h&quot;
  46 #include &quot;RenderVTTCue.h&quot;
  47 #include &quot;ScriptDisallowedScope.h&quot;
  48 #include &quot;Text.h&quot;
  49 #include &quot;TextTrack.h&quot;

  50 #include &quot;TextTrackCueList.h&quot;
  51 #include &quot;VTTRegionList.h&quot;
  52 #include &quot;VTTScanner.h&quot;
  53 #include &quot;WebVTTElement.h&quot;
  54 #include &quot;WebVTTParser.h&quot;
  55 #include &lt;wtf/IsoMallocInlines.h&gt;
  56 #include &lt;wtf/MathExtras.h&gt;
  57 #include &lt;wtf/text/StringBuilder.h&gt;
  58 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  59 
  60 namespace WebCore {
  61 
<span class="line-removed">  62 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCueBox);</span>
  63 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCue);

  64 
  65 // This constant should correspond with the percentage returned by CaptionUserPreferences::captionFontSizeScaleAndImportance.
<span class="line-modified">  66 const static double DEFAULTCAPTIONFONTSIZEPERCENTAGE = 5;</span>
  67 
<span class="line-modified">  68 static const int undefinedPosition = -1;</span>
  69 
  70 static const CSSValueID displayWritingModeMap[] = {
  71     CSSValueHorizontalTb, CSSValueVerticalRl, CSSValueVerticalLr
  72 };
  73 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayWritingModeMap) == VTTCue::NumberOfWritingDirections, displayWritingModeMap_has_wrong_size);
  74 
  75 static const CSSValueID displayAlignmentMap[] = {
  76     CSSValueStart, CSSValueCenter, CSSValueEnd, CSSValueLeft, CSSValueRight
  77 };
  78 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayAlignmentMap) == VTTCue::NumberOfAlignments, displayAlignmentMap_has_wrong_size);
  79 
  80 static const String&amp; startKeyword()
  81 {
  82     static NeverDestroyed&lt;const String&gt; start(MAKE_STATIC_STRING_IMPL(&quot;start&quot;));
  83     return start;
  84 }
  85 
  86 static const String&amp; centerKeyword()
  87 {
  88     static NeverDestroyed&lt;const String&gt; center(MAKE_STATIC_STRING_IMPL(&quot;center&quot;));
</pre>
<hr />
<pre>
 109 
 110 static const String&amp; horizontalKeyword()
 111 {
 112     return emptyString();
 113 }
 114 
 115 static const String&amp; verticalGrowingLeftKeyword()
 116 {
 117     static NeverDestroyed&lt;const String&gt; verticalrl(MAKE_STATIC_STRING_IMPL(&quot;rl&quot;));
 118     return verticalrl;
 119 }
 120 
 121 static const String&amp; verticalGrowingRightKeyword()
 122 {
 123     static NeverDestroyed&lt;const String&gt; verticallr(MAKE_STATIC_STRING_IMPL(&quot;lr&quot;));
 124     return verticallr;
 125 }
 126 
 127 // ----------------------------
 128 
<span class="line-removed"> 129 Ref&lt;VTTCueBox&gt; VTTCueBox::create(Document&amp; document, VTTCue&amp; cue)</span>
<span class="line-removed"> 130 {</span>
<span class="line-removed"> 131     VTTCueBox&amp; cueBox = *new VTTCueBox(document, cue);</span>
<span class="line-removed"> 132     cueBox.setPseudo(VTTCueBox::vttCueBoxShadowPseudoId());</span>
<span class="line-removed"> 133     return adoptRef(cueBox);</span>
<span class="line-removed"> 134 }</span>
<span class="line-removed"> 135 </span>
 136 VTTCueBox::VTTCueBox(Document&amp; document, VTTCue&amp; cue)
<span class="line-modified"> 137     : HTMLElement(divTag, document)</span>
<span class="line-removed"> 138     , m_cue(makeWeakPtr(cue))</span>
 139 {
<span class="line-removed"> 140     setPseudo(vttCueBoxShadowPseudoId());</span>
<span class="line-removed"> 141 }</span>
<span class="line-removed"> 142 </span>
<span class="line-removed"> 143 VTTCue* VTTCueBox::getCue() const</span>
<span class="line-removed"> 144 {</span>
<span class="line-removed"> 145     return m_cue.get();</span>
 146 }
 147 
 148 void VTTCueBox::applyCSSProperties(const IntSize&amp; videoSize)
 149 {
<span class="line-modified"> 150     if (!m_cue)</span>

 151         return;
 152 
<span class="line-modified"> 153     auto cue = makeRef(*m_cue);</span>

 154 
 155     // FIXME: Apply all the initial CSS positioning properties. http://wkb.ug/79916
 156     if (!cue-&gt;regionId().isEmpty()) {
 157         setInlineStyleProperty(CSSPropertyPosition, CSSValueRelative);
 158         return;
 159     }
 160 
 161     // 3.5.1 On the (root) List of WebVTT Node Objects:
 162 
 163     // the &#39;position&#39; property must be set to &#39;absolute&#39;
 164     setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
 165 
 166     //  the &#39;unicode-bidi&#39; property must be set to &#39;plaintext&#39;
 167     setInlineStyleProperty(CSSPropertyUnicodeBidi, CSSValuePlaintext);
 168 
 169     // the &#39;direction&#39; property must be set to direction
 170     setInlineStyleProperty(CSSPropertyDirection, cue-&gt;getCSSWritingDirection());
 171 
 172     // the &#39;writing-mode&#39; property must be set to writing-mode
 173     setInlineStyleProperty(CSSPropertyWritingMode, cue-&gt;getCSSWritingMode(), false);
 174 
 175     auto position = cue-&gt;getCSSPosition();
 176 
 177     // the &#39;top&#39; property must be set to top,
<span class="line-modified"> 178     setInlineStyleProperty(CSSPropertyTop, position.second, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 179 
 180     // the &#39;left&#39; property must be set to left
 181     if (cue-&gt;vertical() == horizontalKeyword())
<span class="line-modified"> 182         setInlineStyleProperty(CSSPropertyLeft, position.first, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
<span class="line-modified"> 183     else if (cue-&gt;vertical() == verticalGrowingRightKeyword())</span>
<span class="line-modified"> 184         setInlineStyleProperty(CSSPropertyLeft, makeString(&quot;calc(-&quot;, FormattedNumber::fixedWidth(videoSize.width(), 2), &quot;px - &quot;, FormattedNumber::fixedWidth(cue-&gt;getCSSSize(), 2), &quot;px)&quot;));</span>


 185 
 186     double authorFontSize = std::min(videoSize.width(), videoSize.height()) * DEFAULTCAPTIONFONTSIZEPERCENTAGE / 100.0;
 187     double multiplier = 1.0;
 188     if (authorFontSize)
 189         multiplier = m_fontSizeFromCaptionUserPrefs / authorFontSize;
 190 
 191     double textPosition = cue-&gt;calculateComputedTextPosition();
 192     double maxSize = 100.0;
 193     CSSValueID alignment = cue-&gt;getCSSAlignment();
 194     if (alignment == CSSValueEnd || alignment == CSSValueRight)
 195         maxSize = textPosition;
 196     else if (alignment == CSSValueStart || alignment == CSSValueLeft)
 197         maxSize = 100.0 - textPosition;
 198 
 199     double newCueSize = std::min(cue-&gt;getCSSSize() * multiplier, 100.0);
 200     // the &#39;width&#39; property must be set to width, and the &#39;height&#39; property  must be set to height
 201     if (cue-&gt;vertical() == horizontalKeyword()) {
<span class="line-modified"> 202         setInlineStyleProperty(CSSPropertyWidth, newCueSize, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 203         setInlineStyleProperty(CSSPropertyHeight, CSSValueAuto);
 204         setInlineStyleProperty(CSSPropertyMinWidth, &quot;min-content&quot;);
<span class="line-modified"> 205         setInlineStyleProperty(CSSPropertyMaxWidth, maxSize, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 206         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
<span class="line-modified"> 207             setInlineStyleProperty(CSSPropertyLeft, static_cast&lt;double&gt;(position.first - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 208     } else {
 209         setInlineStyleProperty(CSSPropertyWidth, CSSValueAuto);
<span class="line-modified"> 210         setInlineStyleProperty(CSSPropertyHeight, newCueSize, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 211         setInlineStyleProperty(CSSPropertyMinHeight, &quot;min-content&quot;);
<span class="line-modified"> 212         setInlineStyleProperty(CSSPropertyMaxHeight, maxSize, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 213         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
<span class="line-modified"> 214             setInlineStyleProperty(CSSPropertyTop, static_cast&lt;double&gt;(position.second - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSPrimitiveValue::CSS_PERCENTAGE);</span>
 215     }
 216 
 217     // The &#39;text-align&#39; property on the (root) List of WebVTT Node Objects must
 218     // be set to the value in the second cell of the row of the table below
 219     // whose first cell is the value of the corresponding cue&#39;s text track cue
 220     // alignment:
 221     setInlineStyleProperty(CSSPropertyTextAlign, cue-&gt;getCSSAlignment());
 222 
 223     if (!cue-&gt;snapToLines()) {
 224         // 10.13.1 Set up x and y:
 225         // Note: x and y are set through the CSS left and top above.
 226 
 227         // 10.13.2 Position the boxes in boxes such that the point x% along the
 228         // width of the bounding box of the boxes in boxes is x% of the way
 229         // across the width of the video&#39;s rendering area, and the point y%
 230         // along the height of the bounding box of the boxes in boxes is y%
 231         // of the way across the height of the video&#39;s rendering area, while
 232         // maintaining the relative positions of the boxes in boxes to each
 233         // other.
<span class="line-modified"> 234         setInlineStyleProperty(CSSPropertyTransform,</span>
<span class="line-removed"> 235             makeString(&quot;translate(&quot;, FormattedNumber::fixedWidth(-position.first, 2), &quot;%, &quot;, FormattedNumber::fixedWidth(-position.second, 2), &quot;%)&quot;));</span>
 236 
 237         setInlineStyleProperty(CSSPropertyWhiteSpace, CSSValuePre);
 238     }
 239 
 240     // Make sure shadow or stroke is not clipped.
 241     setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 242     cue-&gt;element().setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 243 }
 244 
<span class="line-removed"> 245 const AtomString&amp; VTTCueBox::vttCueBoxShadowPseudoId()</span>
<span class="line-removed"> 246 {</span>
<span class="line-removed"> 247     static NeverDestroyed&lt;const AtomString&gt; trackDisplayBoxShadowPseudoId(&quot;-webkit-media-text-track-display&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-removed"> 248     return trackDisplayBoxShadowPseudoId;</span>
<span class="line-removed"> 249 }</span>
<span class="line-removed"> 250 </span>
 251 RenderPtr&lt;RenderElement&gt; VTTCueBox::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 252 {
 253     return createRenderer&lt;RenderVTTCue&gt;(*this, WTFMove(style));
 254 }
 255 
 256 // ----------------------------
 257 
<span class="line-removed"> 258 const AtomString&amp; VTTCue::cueBackdropShadowPseudoId()</span>
<span class="line-removed"> 259 {</span>
<span class="line-removed"> 260     static NeverDestroyed&lt;const AtomString&gt; cueBackdropShadowPseudoId(&quot;-webkit-media-text-track-display-backdrop&quot;, AtomString::ConstructFromLiteral);</span>
<span class="line-removed"> 261     return cueBackdropShadowPseudoId;</span>
<span class="line-removed"> 262 }</span>
<span class="line-removed"> 263 </span>
 264 Ref&lt;VTTCue&gt; VTTCue::create(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; data)
 265 {
 266     return adoptRef(*new VTTCue(context, data));
 267 }
 268 
 269 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, const String&amp; content)
 270     : TextTrackCue(context, start, end)
 271     , m_content(content)
 272 {
 273     initialize(context);
 274 }
 275 
 276 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; cueData)
 277     : TextTrackCue(context, MediaTime::zeroTime(), MediaTime::zeroTime())
 278 {
 279     initialize(context);
 280     setText(cueData.content());
 281     setStartTime(cueData.startTime());
 282     setEndTime(cueData.endTime());
 283     setId(cueData.id());
</pre>
<hr />
<pre>
 850     if (!track()-&gt;isRendered())
 851         return;
 852 
 853     // Mutating the VTT contents is safe because it&#39;s never exposed to author scripts.
 854     ScriptDisallowedScope::EventAllowedScope allowedScopeForCueHighlightBox(*m_cueHighlightBox);
 855 
 856     // Clear the contents of the set.
 857     m_cueHighlightBox-&gt;removeChildren();
 858 
 859     // Update the two sets containing past and future WebVTT objects.
 860     RefPtr&lt;DocumentFragment&gt; referenceTree = createCueRenderingTree();
 861     if (!referenceTree)
 862         return;
 863 
 864     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*referenceTree);
 865 
 866     markFutureAndPastNodes(referenceTree.get(), startMediaTime(), movieTime);
 867     m_cueHighlightBox-&gt;appendChild(*referenceTree);
 868 }
 869 
<span class="line-modified"> 870 VTTCueBox&amp; VTTCue::getDisplayTree(const IntSize&amp; videoSize, int fontSize)</span>
 871 {
 872     Ref&lt;VTTCueBox&gt; displayTree = displayTreeInternal();
 873     if (!m_displayTreeShouldChange || !track()-&gt;isRendered())
<span class="line-modified"> 874         return displayTree.get();</span>
 875 
 876     // 10.1 - 10.10
 877     calculateDisplayParameters();
 878 
 879     // 10.11. Apply the terms of the CSS specifications to nodes within the
 880     // following constraints, thus obtaining a set of CSS boxes positioned
 881     // relative to an initial containing block:
 882     displayTree-&gt;removeChildren();
 883 
 884     // The document tree is the tree of WebVTT Node Objects rooted at nodes.
 885 
 886     // The children of the nodes must be wrapped in an anonymous box whose
 887     // &#39;display&#39; property has the value &#39;inline&#39;. This is the WebVTT cue
 888     // background box.
 889 
 890     // Note: This is contained by default in m_cueHighlightBox.
 891     m_cueHighlightBox-&gt;setPseudo(cueShadowPseudoId());
 892 
 893     m_cueBackdropBox-&gt;setPseudo(cueBackdropShadowPseudoId());
 894     m_cueBackdropBox-&gt;appendChild(*m_cueHighlightBox);
</pre>
<hr />
<pre>
 900 
 901     displayTree-&gt;setFontSizeFromCaptionUserPrefs(fontSize);
 902     displayTree-&gt;applyCSSProperties(videoSize);
 903 
 904     if (displayTree-&gt;document().page()) {
 905         auto cssString = displayTree-&gt;document().page()-&gt;captionUserPreferencesStyleSheet();
 906         auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 907         style-&gt;setTextContent(cssString);
 908         displayTree-&gt;appendChild(style);
 909     }
 910 
 911     const auto&amp; styleSheets = track()-&gt;styleSheets();
 912     if (styleSheets) {
 913         for (const auto&amp; cssString : *styleSheets) {
 914             auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 915             style-&gt;setTextContent(cssString);
 916             displayTree-&gt;appendChild(style);
 917         }
 918     }
 919 



 920     m_displayTreeShouldChange = false;
 921 







 922     // 10.15. Let cue&#39;s text track cue display state have the CSS boxes in
 923     // boxes.
<span class="line-modified"> 924     return displayTree.get();</span>
 925 }
 926 
 927 void VTTCue::removeDisplayTree()
 928 {



 929     // The region needs to be informed about the cue removal.
 930     if (m_notifyRegion &amp;&amp; track()) {
 931         if (VTTRegionList* regions = track()-&gt;regions()) {
 932             if (RefPtr&lt;VTTRegion&gt; region = regions-&gt;getRegionById(m_regionId)) {
 933                 if (hasDisplayTree())
 934                     region-&gt;willRemoveTextTrackCueBox(m_displayTree.get());
 935             }
 936         }
 937     }
 938 
<span class="line-removed"> 939     if (!hasDisplayTree())</span>
<span class="line-removed"> 940         return;</span>
<span class="line-removed"> 941 </span>
 942     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
 943     ScriptDisallowedScope::EventAllowedScope allowedScope(displayTreeInternal());
 944     displayTreeInternal().remove();
 945 }
 946 
 947 std::pair&lt;double, double&gt; VTTCue::getPositionCoordinates() const
 948 {
 949     // This method is used for setting x and y when snap to lines is not set.
 950     std::pair&lt;double, double&gt; coordinates;
 951 
 952     auto textPosition = calculateComputedTextPosition();
 953 
 954     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueLtr) {
 955         coordinates.first = textPosition;
 956         coordinates.second = m_computedLinePosition;
 957 
 958         return coordinates;
 959     }
 960 
 961     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueRtl) {
</pre>
<hr />
<pre>
1231 {
1232     if (!TextTrackCue::isEqual(cue, match))
1233         return false;
1234 
1235     if (cue.cueType() != WebVTT)
1236         return false;
1237 
1238     return cueContentsMatch(cue);
1239 }
1240 
1241 bool VTTCue::doesExtendCue(const TextTrackCue&amp; cue) const
1242 {
1243     if (!cueContentsMatch(cue))
1244         return false;
1245 
1246     return TextTrackCue::doesExtendCue(cue);
1247 }
1248 
1249 void VTTCue::setFontSize(int fontSize, const IntSize&amp;, bool important)
1250 {
<span class="line-modified">1251     if (!hasDisplayTree() || !fontSize)</span>
1252         return;
1253 
1254     m_displayTreeShouldChange = true;
<span class="line-modified">1255     displayTreeInternal().setInlineStyleProperty(CSSPropertyFontSize, fontSize, CSSPrimitiveValue::CSS_PX, important);</span>

1256 }
1257 
1258 VTTCue* toVTTCue(TextTrackCue* cue)
1259 {
1260     return const_cast&lt;VTTCue*&gt;(toVTTCue(const_cast&lt;const TextTrackCue*&gt;(cue)));
1261 }
1262 
1263 const VTTCue* toVTTCue(const TextTrackCue* cue)
1264 {
<span class="line-modified">1265     ASSERT_WITH_SECURITY_IMPLICATION(cue-&gt;isRenderable());</span>
1266     return static_cast&lt;const VTTCue*&gt;(cue);
1267 }
1268 
1269 String VTTCue::toJSONString() const
1270 {
1271     auto object = JSON::Object::create();
1272     toJSON(object.get());
1273 
1274     return object-&gt;toJSONString();
1275 }
1276 
1277 void VTTCue::toJSON(JSON::Object&amp; object) const
1278 {
1279     TextTrackCue::toJSON(object);
1280 
1281 #if !LOG_DISABLED
1282     object.setString(&quot;text&quot;_s, text());
1283 #endif
1284     object.setString(&quot;vertical&quot;_s, vertical());
1285     object.setBoolean(&quot;snapToLines&quot;_s, snapToLines());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
<span class="line-modified">   3  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
</pre>
<hr />
<pre>
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;VTTCue.h&quot;
  34 
  35 #if ENABLE(VIDEO_TRACK)
  36 
  37 #include &quot;CSSPropertyNames.h&quot;
  38 #include &quot;CSSValueKeywords.h&quot;
  39 #include &quot;DocumentFragment.h&quot;
  40 #include &quot;Event.h&quot;
  41 #include &quot;HTMLDivElement.h&quot;
  42 #include &quot;HTMLSpanElement.h&quot;
  43 #include &quot;HTMLStyleElement.h&quot;
  44 #include &quot;Logging.h&quot;
  45 #include &quot;NodeTraversal.h&quot;
  46 #include &quot;RenderVTTCue.h&quot;
  47 #include &quot;ScriptDisallowedScope.h&quot;
  48 #include &quot;Text.h&quot;
  49 #include &quot;TextTrack.h&quot;
<span class="line-added">  50 #include &quot;TextTrackCueGeneric.h&quot;</span>
  51 #include &quot;TextTrackCueList.h&quot;
  52 #include &quot;VTTRegionList.h&quot;
  53 #include &quot;VTTScanner.h&quot;
  54 #include &quot;WebVTTElement.h&quot;
  55 #include &quot;WebVTTParser.h&quot;
  56 #include &lt;wtf/IsoMallocInlines.h&gt;
  57 #include &lt;wtf/MathExtras.h&gt;
  58 #include &lt;wtf/text/StringBuilder.h&gt;
  59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  60 
  61 namespace WebCore {
  62 

  63 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCue);
<span class="line-added">  64 WTF_MAKE_ISO_ALLOCATED_IMPL(VTTCueBox);</span>
  65 
  66 // This constant should correspond with the percentage returned by CaptionUserPreferences::captionFontSizeScaleAndImportance.
<span class="line-modified">  67 static constexpr double DEFAULTCAPTIONFONTSIZEPERCENTAGE = 5;</span>
  68 
<span class="line-modified">  69 static constexpr int undefinedPosition = -1;</span>
  70 
  71 static const CSSValueID displayWritingModeMap[] = {
  72     CSSValueHorizontalTb, CSSValueVerticalRl, CSSValueVerticalLr
  73 };
  74 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayWritingModeMap) == VTTCue::NumberOfWritingDirections, displayWritingModeMap_has_wrong_size);
  75 
  76 static const CSSValueID displayAlignmentMap[] = {
  77     CSSValueStart, CSSValueCenter, CSSValueEnd, CSSValueLeft, CSSValueRight
  78 };
  79 COMPILE_ASSERT(WTF_ARRAY_LENGTH(displayAlignmentMap) == VTTCue::NumberOfAlignments, displayAlignmentMap_has_wrong_size);
  80 
  81 static const String&amp; startKeyword()
  82 {
  83     static NeverDestroyed&lt;const String&gt; start(MAKE_STATIC_STRING_IMPL(&quot;start&quot;));
  84     return start;
  85 }
  86 
  87 static const String&amp; centerKeyword()
  88 {
  89     static NeverDestroyed&lt;const String&gt; center(MAKE_STATIC_STRING_IMPL(&quot;center&quot;));
</pre>
<hr />
<pre>
 110 
 111 static const String&amp; horizontalKeyword()
 112 {
 113     return emptyString();
 114 }
 115 
 116 static const String&amp; verticalGrowingLeftKeyword()
 117 {
 118     static NeverDestroyed&lt;const String&gt; verticalrl(MAKE_STATIC_STRING_IMPL(&quot;rl&quot;));
 119     return verticalrl;
 120 }
 121 
 122 static const String&amp; verticalGrowingRightKeyword()
 123 {
 124     static NeverDestroyed&lt;const String&gt; verticallr(MAKE_STATIC_STRING_IMPL(&quot;lr&quot;));
 125     return verticallr;
 126 }
 127 
 128 // ----------------------------
 129 







 130 VTTCueBox::VTTCueBox(Document&amp; document, VTTCue&amp; cue)
<span class="line-modified"> 131     : TextTrackCueBox(document, cue)</span>

 132 {






 133 }
 134 
 135 void VTTCueBox::applyCSSProperties(const IntSize&amp; videoSize)
 136 {
<span class="line-modified"> 137     auto textTrackCue = getCue();</span>
<span class="line-added"> 138     if (!textTrackCue)</span>
 139         return;
 140 
<span class="line-modified"> 141     ASSERT(is&lt;VTTCue&gt;(textTrackCue) || is&lt;TextTrackCueGeneric&gt;(textTrackCue));</span>
<span class="line-added"> 142     auto cue = makeRef(*toVTTCue(textTrackCue));</span>
 143 
 144     // FIXME: Apply all the initial CSS positioning properties. http://wkb.ug/79916
 145     if (!cue-&gt;regionId().isEmpty()) {
 146         setInlineStyleProperty(CSSPropertyPosition, CSSValueRelative);
 147         return;
 148     }
 149 
 150     // 3.5.1 On the (root) List of WebVTT Node Objects:
 151 
 152     // the &#39;position&#39; property must be set to &#39;absolute&#39;
 153     setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
 154 
 155     //  the &#39;unicode-bidi&#39; property must be set to &#39;plaintext&#39;
 156     setInlineStyleProperty(CSSPropertyUnicodeBidi, CSSValuePlaintext);
 157 
 158     // the &#39;direction&#39; property must be set to direction
 159     setInlineStyleProperty(CSSPropertyDirection, cue-&gt;getCSSWritingDirection());
 160 
 161     // the &#39;writing-mode&#39; property must be set to writing-mode
 162     setInlineStyleProperty(CSSPropertyWritingMode, cue-&gt;getCSSWritingMode(), false);
 163 
 164     auto position = cue-&gt;getCSSPosition();
 165 
 166     // the &#39;top&#39; property must be set to top,
<span class="line-modified"> 167     setInlineStyleProperty(CSSPropertyTop, position.second, CSSUnitType::CSS_PERCENTAGE);</span>
 168 
 169     // the &#39;left&#39; property must be set to left
 170     if (cue-&gt;vertical() == horizontalKeyword())
<span class="line-modified"> 171         setInlineStyleProperty(CSSPropertyLeft, position.first, CSSUnitType::CSS_PERCENTAGE);</span>
<span class="line-modified"> 172     else if (cue-&gt;vertical() == verticalGrowingRightKeyword()) {</span>
<span class="line-modified"> 173         // FIXME: Why use calc to do the math instead of doing the subtraction here?</span>
<span class="line-added"> 174         setInlineStyleProperty(CSSPropertyLeft, makeString(&quot;calc(-&quot;, videoSize.width(), &quot;px - &quot;, cue-&gt;getCSSSize(), &quot;px)&quot;));</span>
<span class="line-added"> 175     }</span>
 176 
 177     double authorFontSize = std::min(videoSize.width(), videoSize.height()) * DEFAULTCAPTIONFONTSIZEPERCENTAGE / 100.0;
 178     double multiplier = 1.0;
 179     if (authorFontSize)
 180         multiplier = m_fontSizeFromCaptionUserPrefs / authorFontSize;
 181 
 182     double textPosition = cue-&gt;calculateComputedTextPosition();
 183     double maxSize = 100.0;
 184     CSSValueID alignment = cue-&gt;getCSSAlignment();
 185     if (alignment == CSSValueEnd || alignment == CSSValueRight)
 186         maxSize = textPosition;
 187     else if (alignment == CSSValueStart || alignment == CSSValueLeft)
 188         maxSize = 100.0 - textPosition;
 189 
 190     double newCueSize = std::min(cue-&gt;getCSSSize() * multiplier, 100.0);
 191     // the &#39;width&#39; property must be set to width, and the &#39;height&#39; property  must be set to height
 192     if (cue-&gt;vertical() == horizontalKeyword()) {
<span class="line-modified"> 193         setInlineStyleProperty(CSSPropertyWidth, newCueSize, CSSUnitType::CSS_PERCENTAGE);</span>
 194         setInlineStyleProperty(CSSPropertyHeight, CSSValueAuto);
 195         setInlineStyleProperty(CSSPropertyMinWidth, &quot;min-content&quot;);
<span class="line-modified"> 196         setInlineStyleProperty(CSSPropertyMaxWidth, maxSize, CSSUnitType::CSS_PERCENTAGE);</span>
 197         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
<span class="line-modified"> 198             setInlineStyleProperty(CSSPropertyLeft, static_cast&lt;double&gt;(position.first - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSUnitType::CSS_PERCENTAGE);</span>
 199     } else {
 200         setInlineStyleProperty(CSSPropertyWidth, CSSValueAuto);
<span class="line-modified"> 201         setInlineStyleProperty(CSSPropertyHeight, newCueSize, CSSUnitType::CSS_PERCENTAGE);</span>
 202         setInlineStyleProperty(CSSPropertyMinHeight, &quot;min-content&quot;);
<span class="line-modified"> 203         setInlineStyleProperty(CSSPropertyMaxHeight, maxSize, CSSUnitType::CSS_PERCENTAGE);</span>
 204         if ((alignment == CSSValueMiddle || alignment == CSSValueCenter) &amp;&amp; multiplier != 1.0)
<span class="line-modified"> 205             setInlineStyleProperty(CSSPropertyTop, static_cast&lt;double&gt;(position.second - (newCueSize - cue-&gt;getCSSSize()) / 2), CSSUnitType::CSS_PERCENTAGE);</span>
 206     }
 207 
 208     // The &#39;text-align&#39; property on the (root) List of WebVTT Node Objects must
 209     // be set to the value in the second cell of the row of the table below
 210     // whose first cell is the value of the corresponding cue&#39;s text track cue
 211     // alignment:
 212     setInlineStyleProperty(CSSPropertyTextAlign, cue-&gt;getCSSAlignment());
 213 
 214     if (!cue-&gt;snapToLines()) {
 215         // 10.13.1 Set up x and y:
 216         // Note: x and y are set through the CSS left and top above.
 217 
 218         // 10.13.2 Position the boxes in boxes such that the point x% along the
 219         // width of the bounding box of the boxes in boxes is x% of the way
 220         // across the width of the video&#39;s rendering area, and the point y%
 221         // along the height of the bounding box of the boxes in boxes is y%
 222         // of the way across the height of the video&#39;s rendering area, while
 223         // maintaining the relative positions of the boxes in boxes to each
 224         // other.
<span class="line-modified"> 225         setInlineStyleProperty(CSSPropertyTransform, makeString(&quot;translate(&quot;, -position.first, &quot;%, &quot;, -position.second, &quot;%)&quot;));</span>

 226 
 227         setInlineStyleProperty(CSSPropertyWhiteSpace, CSSValuePre);
 228     }
 229 
 230     // Make sure shadow or stroke is not clipped.
 231     setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 232     cue-&gt;element().setInlineStyleProperty(CSSPropertyOverflow, CSSValueVisible);
 233 }
 234 






 235 RenderPtr&lt;RenderElement&gt; VTTCueBox::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 236 {
 237     return createRenderer&lt;RenderVTTCue&gt;(*this, WTFMove(style));
 238 }
 239 
 240 // ----------------------------
 241 






 242 Ref&lt;VTTCue&gt; VTTCue::create(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; data)
 243 {
 244     return adoptRef(*new VTTCue(context, data));
 245 }
 246 
 247 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, const String&amp; content)
 248     : TextTrackCue(context, start, end)
 249     , m_content(content)
 250 {
 251     initialize(context);
 252 }
 253 
 254 VTTCue::VTTCue(ScriptExecutionContext&amp; context, const WebVTTCueData&amp; cueData)
 255     : TextTrackCue(context, MediaTime::zeroTime(), MediaTime::zeroTime())
 256 {
 257     initialize(context);
 258     setText(cueData.content());
 259     setStartTime(cueData.startTime());
 260     setEndTime(cueData.endTime());
 261     setId(cueData.id());
</pre>
<hr />
<pre>
 828     if (!track()-&gt;isRendered())
 829         return;
 830 
 831     // Mutating the VTT contents is safe because it&#39;s never exposed to author scripts.
 832     ScriptDisallowedScope::EventAllowedScope allowedScopeForCueHighlightBox(*m_cueHighlightBox);
 833 
 834     // Clear the contents of the set.
 835     m_cueHighlightBox-&gt;removeChildren();
 836 
 837     // Update the two sets containing past and future WebVTT objects.
 838     RefPtr&lt;DocumentFragment&gt; referenceTree = createCueRenderingTree();
 839     if (!referenceTree)
 840         return;
 841 
 842     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*referenceTree);
 843 
 844     markFutureAndPastNodes(referenceTree.get(), startMediaTime(), movieTime);
 845     m_cueHighlightBox-&gt;appendChild(*referenceTree);
 846 }
 847 
<span class="line-modified"> 848 RefPtr&lt;TextTrackCueBox&gt; VTTCue::getDisplayTree(const IntSize&amp; videoSize, int fontSize)</span>
 849 {
 850     Ref&lt;VTTCueBox&gt; displayTree = displayTreeInternal();
 851     if (!m_displayTreeShouldChange || !track()-&gt;isRendered())
<span class="line-modified"> 852         return displayTree;</span>
 853 
 854     // 10.1 - 10.10
 855     calculateDisplayParameters();
 856 
 857     // 10.11. Apply the terms of the CSS specifications to nodes within the
 858     // following constraints, thus obtaining a set of CSS boxes positioned
 859     // relative to an initial containing block:
 860     displayTree-&gt;removeChildren();
 861 
 862     // The document tree is the tree of WebVTT Node Objects rooted at nodes.
 863 
 864     // The children of the nodes must be wrapped in an anonymous box whose
 865     // &#39;display&#39; property has the value &#39;inline&#39;. This is the WebVTT cue
 866     // background box.
 867 
 868     // Note: This is contained by default in m_cueHighlightBox.
 869     m_cueHighlightBox-&gt;setPseudo(cueShadowPseudoId());
 870 
 871     m_cueBackdropBox-&gt;setPseudo(cueBackdropShadowPseudoId());
 872     m_cueBackdropBox-&gt;appendChild(*m_cueHighlightBox);
</pre>
<hr />
<pre>
 878 
 879     displayTree-&gt;setFontSizeFromCaptionUserPrefs(fontSize);
 880     displayTree-&gt;applyCSSProperties(videoSize);
 881 
 882     if (displayTree-&gt;document().page()) {
 883         auto cssString = displayTree-&gt;document().page()-&gt;captionUserPreferencesStyleSheet();
 884         auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 885         style-&gt;setTextContent(cssString);
 886         displayTree-&gt;appendChild(style);
 887     }
 888 
 889     const auto&amp; styleSheets = track()-&gt;styleSheets();
 890     if (styleSheets) {
 891         for (const auto&amp; cssString : *styleSheets) {
 892             auto style = HTMLStyleElement::create(HTMLNames::styleTag, displayTree-&gt;document(), false);
 893             style-&gt;setTextContent(cssString);
 894             displayTree-&gt;appendChild(style);
 895         }
 896     }
 897 
<span class="line-added"> 898     if (m_fontSize)</span>
<span class="line-added"> 899         displayTree-&gt;setInlineStyleProperty(CSSPropertyFontSize, m_fontSize, CSSUnitType::CSS_PX, m_fontSizeIsImportant);</span>
<span class="line-added"> 900 </span>
 901     m_displayTreeShouldChange = false;
 902 
<span class="line-added"> 903     if (track()) {</span>
<span class="line-added"> 904         if (auto* regions = track()-&gt;regions()) {</span>
<span class="line-added"> 905             if (auto region = regions-&gt;getRegionById(m_regionId))</span>
<span class="line-added"> 906                 region-&gt;cueStyleChanged();</span>
<span class="line-added"> 907         }</span>
<span class="line-added"> 908     }</span>
<span class="line-added"> 909 </span>
 910     // 10.15. Let cue&#39;s text track cue display state have the CSS boxes in
 911     // boxes.
<span class="line-modified"> 912     return displayTree;</span>
 913 }
 914 
 915 void VTTCue::removeDisplayTree()
 916 {
<span class="line-added"> 917     if (!hasDisplayTree())</span>
<span class="line-added"> 918         return;</span>
<span class="line-added"> 919 </span>
 920     // The region needs to be informed about the cue removal.
 921     if (m_notifyRegion &amp;&amp; track()) {
 922         if (VTTRegionList* regions = track()-&gt;regions()) {
 923             if (RefPtr&lt;VTTRegion&gt; region = regions-&gt;getRegionById(m_regionId)) {
 924                 if (hasDisplayTree())
 925                     region-&gt;willRemoveTextTrackCueBox(m_displayTree.get());
 926             }
 927         }
 928     }
 929 



 930     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
 931     ScriptDisallowedScope::EventAllowedScope allowedScope(displayTreeInternal());
 932     displayTreeInternal().remove();
 933 }
 934 
 935 std::pair&lt;double, double&gt; VTTCue::getPositionCoordinates() const
 936 {
 937     // This method is used for setting x and y when snap to lines is not set.
 938     std::pair&lt;double, double&gt; coordinates;
 939 
 940     auto textPosition = calculateComputedTextPosition();
 941 
 942     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueLtr) {
 943         coordinates.first = textPosition;
 944         coordinates.second = m_computedLinePosition;
 945 
 946         return coordinates;
 947     }
 948 
 949     if (m_writingDirection == Horizontal &amp;&amp; m_displayDirection == CSSValueRtl) {
</pre>
<hr />
<pre>
1219 {
1220     if (!TextTrackCue::isEqual(cue, match))
1221         return false;
1222 
1223     if (cue.cueType() != WebVTT)
1224         return false;
1225 
1226     return cueContentsMatch(cue);
1227 }
1228 
1229 bool VTTCue::doesExtendCue(const TextTrackCue&amp; cue) const
1230 {
1231     if (!cueContentsMatch(cue))
1232         return false;
1233 
1234     return TextTrackCue::doesExtendCue(cue);
1235 }
1236 
1237 void VTTCue::setFontSize(int fontSize, const IntSize&amp;, bool important)
1238 {
<span class="line-modified">1239     if (fontSize == m_fontSize &amp;&amp; important == m_fontSizeIsImportant)</span>
1240         return;
1241 
1242     m_displayTreeShouldChange = true;
<span class="line-modified">1243     m_fontSizeIsImportant = important;</span>
<span class="line-added">1244     m_fontSize = fontSize;</span>
1245 }
1246 
1247 VTTCue* toVTTCue(TextTrackCue* cue)
1248 {
1249     return const_cast&lt;VTTCue*&gt;(toVTTCue(const_cast&lt;const TextTrackCue*&gt;(cue)));
1250 }
1251 
1252 const VTTCue* toVTTCue(const TextTrackCue* cue)
1253 {
<span class="line-modified">1254     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(is&lt;VTTCue&gt;(cue) || is&lt;TextTrackCueGeneric&gt;(cue));</span>
1255     return static_cast&lt;const VTTCue*&gt;(cue);
1256 }
1257 
1258 String VTTCue::toJSONString() const
1259 {
1260     auto object = JSON::Object::create();
1261     toJSON(object.get());
1262 
1263     return object-&gt;toJSONString();
1264 }
1265 
1266 void VTTCue::toJSON(JSON::Object&amp; object) const
1267 {
1268     TextTrackCue::toJSON(object);
1269 
1270 #if !LOG_DISABLED
1271     object.setString(&quot;text&quot;_s, text());
1272 #endif
1273     object.setString(&quot;vertical&quot;_s, vertical());
1274     object.setBoolean(&quot;snapToLines&quot;_s, snapToLines());
</pre>
</td>
</tr>
</table>
<center><a href="TrackListBase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="VTTCue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
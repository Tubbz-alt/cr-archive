<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryIDBBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBBackingStore.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;IDBValue.h&quot;
  44 #include &quot;IndexKey.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;SQLiteDatabase.h&quot;
  47 #include &quot;SQLiteFileSystem.h&quot;
  48 #include &quot;SQLiteIDBCursor.h&quot;
  49 #include &quot;SQLiteStatement.h&quot;
  50 #include &quot;SQLiteTransaction.h&quot;
  51 #include &quot;ThreadSafeDataBuffer.h&quot;
  52 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
  53 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;
  55 #include &lt;wtf/FileSystem.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  58 
  59 namespace WebCore {
  60 using namespace JSC;
  61 namespace IDBServer {
  62 






  63 // Current version of the metadata schema being used in the metadata database.
  64 static const int currentMetadataVersion = 1;
  65 
  66 // The IndexedDatabase spec defines the max key generator value as 2^53.
  67 static const uint64_t maxGeneratorValue = 0x20000000000000;
  68 
  69 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  70 {
  71     IDBKeyData a, b;
  72     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  73         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  74 
  75         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  76         // We arbitrarily choose &quot;A &gt; B&quot;
  77         return 1;
  78     }
  79     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(bBuffer), bLength, b)) {
  80         LOG_ERROR(&quot;Unable to deserialize key B in collation function.&quot;);
  81 
  82         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
</pre>
<hr />
<pre>
 172     return v2IndexRecordsTableSchemaString;
 173 }
 174 
 175 static const String v3IndexRecordsTableSchema(const String&amp; tableName)
 176 {
 177     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, objectStoreRecordID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 178 }
 179 
 180 static const String v3IndexRecordsTableSchema()
 181 {
 182     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;IndexRecords&quot;);
 183     return indexRecordsTableSchemaString;
 184 }
 185 
 186 static const String v3IndexRecordsTableSchemaAlternate()
 187 {
 188     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;);
 189     return indexRecordsTableSchemaString;
 190 }
 191 
<span class="line-removed"> 192 static const String&amp; v1IndexRecordsIndexSchema()</span>
<span class="line-removed"> 193 {</span>
<span class="line-removed"> 194     static NeverDestroyed&lt;WTF::String&gt; indexRecordsIndexSchemaString(&quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (key)&quot;);</span>
<span class="line-removed"> 195     return indexRecordsIndexSchemaString;</span>
<span class="line-removed"> 196 }</span>
<span class="line-removed"> 197 </span>
 198 static const String blobRecordsTableSchema(const String&amp; tableName)
 199 {
 200     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)&quot;);
 201 }
 202 
 203 static const String&amp; blobRecordsTableSchema()
 204 {
 205     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;BlobRecords&quot;));
 206     return blobRecordsTableSchemaString;
 207 }
 208 
 209 static const String&amp; blobRecordsTableSchemaAlternate()
 210 {
 211     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;\&quot;BlobRecords\&quot;&quot;));
 212     return blobRecordsTableSchemaString;
 213 }
 214 
 215 static const String blobFilesTableSchema(const String&amp; tableName)
 216 {
 217     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 218 }
 219 
 220 static const String&amp; blobFilesTableSchema()
 221 {
 222     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 223     return blobFilesTableSchemaString;
 224 }
 225 
 226 static const String&amp; blobFilesTableSchemaAlternate()
 227 {
 228     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 229     return blobFilesTableSchemaString;
 230 }
 231 
<span class="line-modified"> 232 SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory, IDBBackingStoreTemporaryFileHandler&amp; fileHandler)</span>










 233     : m_sessionID(sessionID)
 234     , m_identifier(identifier)
 235     , m_databaseRootDirectory(databaseRootDirectory)
<span class="line-removed"> 236     , m_temporaryFileHandler(fileHandler)</span>
 237     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
 238 {
 239     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
 240 }
 241 
 242 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 243 {
 244     if (m_sqliteDB)
 245         closeSQLiteDB();
 246 }
 247 
 248 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 249 {
 250     String currentSchema;
 251     {
 252         // Fetch the schema for an existing records table.
 253         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 254         if (statement.prepare() != SQLITE_OK) {
 255             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 256             return false;
</pre>
<hr />
<pre>
 483 }
 484 
 485 bool SQLiteIDBBackingStore::ensureValidIndexRecordsIndex()
 486 {
 487     ASSERT(m_sqliteDB);
 488     ASSERT(m_sqliteDB-&gt;isOpen());
 489 
 490     String currentSchema;
 491     {
 492         // Fetch the schema for an existing index record index.
 493         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsIndex&#39;&quot;);
 494         if (statement.prepare() != SQLITE_OK) {
 495             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsIndex index.&quot;);
 496             return false;
 497         }
 498 
 499         int sqliteResult = statement.step();
 500 
 501         // If there is no IndexRecordsIndex index at all, create it and then bail.
 502         if (sqliteResult == SQLITE_DONE) {
<span class="line-modified"> 503             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsIndexSchema())) {</span>
 504                 LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 505                 return false;
 506             }
 507 
 508             return true;
 509         }
 510 
 511         if (sqliteResult != SQLITE_ROW) {
 512             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsIndex index.&quot;);
 513             return false;
 514         }
 515 
 516         currentSchema = statement.getColumnText(0);
 517     }
 518 
 519     ASSERT(!currentSchema.isEmpty());
 520 
 521     // If the schema in the backing store is the current schema, we&#39;re done.
<span class="line-modified"> 522     if (currentSchema == v1IndexRecordsIndexSchema())</span>
























































 523         return true;
 524 
<span class="line-removed"> 525     // There is currently no outdated schema for the IndexRecordsIndex, so any other existing schema means this database is invalid.</span>
 526     return false;
 527 }
 528 
 529 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
 530 {
 531     ASSERT(m_sqliteDB);
 532     ASSERT(m_sqliteDB-&gt;isOpen());
 533 
 534     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IDBDatabaseInfo (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value TEXT NOT NULL ON CONFLICT FAIL);&quot;)) {
 535         LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 536         closeSQLiteDB();
 537         return nullptr;
 538     }
 539 
<span class="line-modified"> 540     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {</span>
 541         LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 542         closeSQLiteDB();
 543         return nullptr;
 544     }
 545 
 546     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IndexInfo (id INTEGER NOT NULL ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, isUnique INTEGER NOT NULL ON CONFLICT FAIL, multiEntry INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 547         LOG_ERROR(&quot;Could not create IndexInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 548         closeSQLiteDB();
 549         return nullptr;
 550     }
 551 
 552     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE KeyGenerators (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, currentKey INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 553         LOG_ERROR(&quot;Could not create KeyGenerators table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 554         closeSQLiteDB();
 555         return nullptr;
 556     }
 557 
 558     {
 559         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MetadataVersion&#39;, ?);&quot;_s);
 560         if (sql.prepare() != SQLITE_OK
</pre>
<hr />
<pre>
 578     {
 579         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 580         // Therefore we&#39;ll store the version as a String.
 581         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 582         if (sql.prepare() != SQLITE_OK
 583             || sql.bindText(1, String::number(0)) != SQLITE_OK
 584             || sql.step() != SQLITE_DONE) {
 585             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 586             closeSQLiteDB();
 587             return nullptr;
 588         }
 589     }
 590 
 591     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 592         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 593         closeSQLiteDB();
 594         return nullptr;
 595     }
 596 
 597     // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified"> 598     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0);</span>





























































 599 }
 600 
 601 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 602 {
 603     ASSERT(m_sqliteDB);
 604 
 605     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 606         return nullptr;
 607 
 608     String databaseName;
 609     {
 610         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 611         if (sql.isColumnNull(0))
 612             return nullptr;
 613         databaseName = sql.getColumnText(0);
 614         if (databaseName != m_identifier.databaseName()) {
 615             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 616             return nullptr;
 617         }
 618     }
 619     uint64_t databaseVersion;
 620     {
 621         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 622         if (sql.isColumnNull(0))
 623             return nullptr;
 624         String stringVersion = sql.getColumnText(0);
 625         bool ok;
 626         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 627         if (!ok) {
 628             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 629             return nullptr;
 630         }
 631     }
 632 
<span class="line-modified"> 633     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion);</span>






 634 
 635     {
<span class="line-modified"> 636         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc, maxIndexID FROM ObjectStoreInfo;&quot;_s);</span>
 637         if (sql.prepare() != SQLITE_OK)
 638             return nullptr;
 639 
 640         int result = sql.step();
 641         while (result == SQLITE_ROW) {
 642             uint64_t objectStoreID = sql.getColumnInt64(0);
 643             String objectStoreName = sql.getColumnText(1);
 644 
 645             Vector&lt;char&gt; keyPathBuffer;
 646             sql.getColumnBlobAsVector(2, keyPathBuffer);
 647 
 648             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 649             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 650                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 651                 return nullptr;
 652             }
 653 
 654             bool autoIncrement = sql.getColumnInt(3);
 655 
 656             databaseInfo-&gt;addExistingObjectStore({ objectStoreID, objectStoreName, WTFMove(objectStoreKeyPath), autoIncrement });
 657 
 658             result = sql.step();
 659         }
 660 
 661         if (result != SQLITE_DONE) {
 662             LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
 663             return nullptr;
 664         }
 665     }
 666 


 667     {
 668         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
<span class="line-modified"> 669         if (sql.prepare() != SQLITE_OK)</span>

 670             return nullptr;

 671 
 672         int result = sql.step();
 673         while (result == SQLITE_ROW) {
 674             uint64_t indexID = sql.getColumnInt64(0);
 675             String indexName = sql.getColumnText(1);
 676             uint64_t objectStoreID = sql.getColumnInt64(2);
 677 
 678             Vector&lt;char&gt; keyPathBuffer;
 679             sql.getColumnBlobAsVector(3, keyPathBuffer);
 680 
 681             Optional&lt;IDBKeyPath&gt; indexKeyPath;
 682             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), indexKeyPath)) {
 683                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 684                 return nullptr;
 685             }
 686             if (!indexKeyPath) {
 687                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 688                 return nullptr;
 689             }
 690 
 691             bool unique = sql.getColumnInt(4);
 692             bool multiEntry = sql.getColumnInt(5);
 693 
 694             auto objectStore = databaseInfo-&gt;infoForExistingObjectStore(objectStoreID);
 695             if (!objectStore) {
 696                 LOG_ERROR(&quot;Found index referring to a non-existant object store&quot;);
 697                 return nullptr;
 698             }
 699 





 700             objectStore-&gt;addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });

 701 
 702             result = sql.step();
 703         }
 704 
 705         if (result != SQLITE_DONE) {
 706             LOG_ERROR(&quot;Error fetching index info from database on disk&quot;);
 707             return nullptr;
 708         }


























 709     }
 710 
 711     return databaseInfo;
 712 }
 713 
 714 String SQLiteIDBBackingStore::databaseNameFromEncodedFilename(const String&amp; encodedName)
 715 {
 716     if (encodedName == &quot;%00&quot;_s)
 717         return { };
 718 
 719     String partiallyDecoded = encodedName;
 720     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 721 
 722     return FileSystem::decodeFromFilename(partiallyDecoded);
 723 }
 724 
 725 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 726 {
 727     ASSERT(!m_identifier.databaseName().isNull());
 728 
</pre>
<hr />
<pre>
 807     });
 808 
 809     if (!ensureValidRecordsTable()) {
 810         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 811         closeSQLiteDB();
 812         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 813     }
 814 
 815     if (!ensureValidIndexRecordsTable()) {
 816         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
 817         closeSQLiteDB();
 818         return IDBError { UnknownError, &quot;Error creating or migrating Index Records table in database&quot;_s };
 819     }
 820 
 821     if (!ensureValidIndexRecordsIndex()) {
 822         LOG_ERROR(&quot;Error creating or migrating Index Records index in database&quot;);
 823         closeSQLiteDB();
 824         return IDBError { UnknownError, &quot;Error creating or migrating Index Records index in database&quot;_s };
 825     }
 826 






 827     if (!ensureValidBlobTables()) {
 828         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
 829         closeSQLiteDB();
 830         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
 831     }
 832 
 833     auto databaseInfo = extractExistingDatabaseInfo();
 834     if (!databaseInfo)
 835         databaseInfo = createAndPopulateInitialDatabaseInfo();
 836 
 837     if (!databaseInfo) {
 838         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
 839         closeSQLiteDB();
 840         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
 841     }
 842 
 843     m_databaseInfo = WTFMove(databaseInfo);
 844     info = *m_databaseInfo;
 845     return IDBError { };
 846 }
 847 
 848 uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String&amp; directory)
 849 {
 850     uint64_t diskUsage = 0;
 851     for (auto&amp; dbDirectory : FileSystem::listDirectory(directory, &quot;*&quot;)) {
 852         for (auto&amp; file : FileSystem::listDirectory(dbDirectory, &quot;*.sqlite3&quot;_s))
 853             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
 854     }
 855     return diskUsage;
 856 }
 857 
<span class="line-removed"> 858 uint64_t SQLiteIDBBackingStore::databaseSize() const</span>
<span class="line-removed"> 859 {</span>
<span class="line-removed"> 860     ASSERT(!isMainThread());</span>
<span class="line-removed"> 861     return SQLiteFileSystem::getDatabaseFileSize(fullDatabasePath());</span>
<span class="line-removed"> 862 }</span>
<span class="line-removed"> 863 </span>
 864 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 865 {
 866     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
 867 
 868     ASSERT(m_sqliteDB);
 869     ASSERT(m_sqliteDB-&gt;isOpen());
 870     ASSERT(m_databaseInfo);
 871 
 872     auto addResult = m_transactions.add(info.identifier(), nullptr);
 873     if (!addResult.isNewEntry) {
 874         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
 875         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
 876     }
 877 
 878     addResult.iterator-&gt;value = makeUnique&lt;SQLiteIDBTransaction&gt;(*this, info);
 879 
 880     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
 881     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
 882         m_originalDatabaseInfoBeforeVersionChange = makeUnique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);
 883 
</pre>
<hr />
<pre>
 942 
 943     ASSERT(m_sqliteDB);
 944     ASSERT(m_sqliteDB-&gt;isOpen());
 945 
 946     auto* transaction = m_transactions.get(transactionIdentifier);
 947     if (!transaction || !transaction-&gt;inProgress())
 948         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
 949 
 950     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
 951         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
 952         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
 953     }
 954 
 955     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
 956     if (!keyPathBlob) {
 957         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
 958         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
 959     }
 960 
 961     {
<span class="line-modified"> 962         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?, ?);&quot;_s);</span>
 963         if (!sql
 964             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 965             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
 966             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
 967             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK
<span class="line-removed"> 968             || sql-&gt;bindInt64(5, info.maxIndexID()) != SQLITE_OK</span>
 969             || sql-&gt;step() != SQLITE_DONE) {
 970             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 971             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
 972         }
 973     }
 974 
 975     {
 976         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
 977         if (!sql
 978             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
 979             || sql-&gt;step() != SQLITE_DONE) {
 980             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 981             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
 982         }
 983     }
 984 
 985     m_databaseInfo-&gt;addExistingObjectStore(info);
 986 
 987     return IDBError { };
 988 }
</pre>
<hr />
<pre>
1179         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1180         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1181         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1182         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1183         || sql-&gt;step() != SQLITE_DONE) {
1184         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1185         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1186     }
1187 
1188     // Write index records for any records that already exist in this object store.
1189 
1190     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1191 
1192     if (!cursor) {
1193         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1194         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1195     }
1196 
1197     while (!cursor-&gt;currentKey().isNull()) {
1198         auto&amp; key = cursor-&gt;currentKey();
<span class="line-modified">1199         auto* value = cursor-&gt;currentValue();</span>
<span class="line-modified">1200         ThreadSafeDataBuffer valueBuffer = value ? value-&gt;data() : ThreadSafeDataBuffer();</span>
1201 
1202         ASSERT(cursor-&gt;currentRecordRowID());
1203 
1204         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1205         if (!error.isNull()) {
1206             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1207             if (!sql
1208                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1209                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1210                 || sql-&gt;step() != SQLITE_DONE) {
1211                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1212                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1213             }
1214 
1215             return error;
1216         }
1217 
1218         if (!cursor-&gt;advance(1)) {
1219             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1220             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1221         }
1222     }
1223 
1224     ASSERT(m_databaseInfo);
1225     if (!m_databaseInfo) {
1226         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null&quot;, this);
1227         return IDBError { UnknownError, &quot;Database info is invalid&quot;_s };
1228     }
1229 
1230     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1231     ASSERT(objectStore);
1232     objectStore-&gt;addExistingIndex(info);

1233 
1234     return IDBError { };
1235 }
1236 
1237 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1238 {
1239     hasRecord = false;
1240 
1241     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1242     if (!indexKeyBuffer) {
1243         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1244         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1245     }
1246 
<span class="line-modified">1247     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
1248     if (!sql
1249         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">1250         || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK</span>
<span class="line-removed">1251         || sql-&gt;bindBlob(3, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {</span>
1252         LOG_ERROR(&quot;Error checking for index record in database&quot;);
1253         return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
1254     }
1255 
1256     int sqlResult = sql-&gt;step();
1257     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1258         return IDBError { };
1259 
1260     if (sqlResult != SQLITE_ROW) {
1261         // There was an error fetching the record from the database.
1262         LOG_ERROR(&quot;Could not check if key exists in index (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1263         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in index&quot;_s };
1264     }
1265 
1266     hasRecord = true;
1267     return IDBError { };
1268 }
1269 
1270 IDBError SQLiteIDBBackingStore::uncheckedPutIndexKey(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const IndexKey&amp; indexKey, int64_t recordID)
1271 {
</pre>
<hr />
<pre>
1349     if (!transaction || !transaction-&gt;inProgress())
1350         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
1351 
1352     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1353         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1354         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1355     }
1356 
1357     {
1358         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1359         if (!sql
1360             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1361             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1362             || sql-&gt;step() != SQLITE_DONE) {
1363             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1364             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1365         }
1366     }
1367 
1368     {
<span class="line-modified">1369         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ? AND objectStoreID = ?;&quot;_s);</span>
1370         if (!sql
1371             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
<span class="line-removed">1372             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK</span>
1373             || sql-&gt;step() != SQLITE_DONE) {
1374             LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1375             return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
1376         }
1377     }
1378 
1379     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1380     ASSERT(objectStore);
1381     objectStore-&gt;deleteIndex(indexIdentifier);
1382 
1383     return IDBError { };
1384 }
1385 
1386 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1387 {
1388     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1389 
1390     ASSERT(m_sqliteDB);
1391     ASSERT(m_sqliteDB-&gt;isOpen());
1392 
</pre>
<hr />
<pre>
1506 
1507     return IDBError { };
1508 }
1509 
1510 IDBError SQLiteIDBBackingStore::deleteRecord(SQLiteIDBTransaction&amp; transaction, int64_t objectStoreID, const IDBKeyData&amp; keyData)
1511 {
1512     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1513 
1514     ASSERT(m_sqliteDB);
1515     ASSERT(m_sqliteDB-&gt;isOpen());
1516     ASSERT(transaction.inProgress());
1517     ASSERT(transaction.mode() != IDBTransactionMode::Readonly);
1518     UNUSED_PARAM(transaction);
1519 
1520     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1521     if (!keyBuffer) {
1522         LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
1523         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
1524     }
1525 
<span class="line-modified">1526     // Get the record ID</span>
1527     int64_t recordID;

1528     {
<span class="line-modified">1529         auto* sql = cachedStatement(SQL::GetObjectStoreRecordID, &quot;SELECT recordID FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
1530 
1531         if (!sql
1532             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1533             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1534             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1535             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1536         }
1537 
1538         int result = sql-&gt;step();
1539 
1540         // If there&#39;s no record ID, there&#39;s no record to delete.
1541         if (result == SQLITE_DONE)
1542             return IDBError { };
1543 
1544         if (result != SQLITE_ROW) {
1545             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (unable to fetch record ID) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1546             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1547         }
1548 
1549         recordID = sql-&gt;getColumnInt64(0);




1550     }
1551 
1552     if (recordID &lt; 1) {
1553         LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (record ID is invalid) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1554         return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1555     }
1556 
1557     // Delete the blob records for this object store record.
1558     {
1559         auto* sql = cachedStatement(SQL::DeleteBlobRecord, &quot;DELETE FROM BlobRecords WHERE objectStoreRow = ?;&quot;_s);
1560 
1561         if (!sql
1562             || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1563             || sql-&gt;step() != SQLITE_DONE) {
1564             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (Could not delete BlobRecords records) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1565             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1566         }
1567     }
1568 
1569     auto error = deleteUnusedBlobFileRecords(transaction);
1570     if (!error.isNull())
1571         return error;
1572 
1573     // Delete record from object store
1574     {
1575         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1576 
1577         if (!sql
1578             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1579             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1580             || sql-&gt;step() != SQLITE_DONE) {
1581             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1582             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1583         }
1584     }
1585 
1586     // Delete record from indexes store
1587     {
<span class="line-modified">1588         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);</span>
1589 
1590         if (!sql
1591             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
<span class="line-modified">1592             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK</span>
1593             || sql-&gt;step() != SQLITE_DONE) {
1594             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1595             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1596         }
1597     }
1598 
1599     return IDBError { };
1600 }
1601 
1602 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1603 {
1604     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1605 
1606     ASSERT(m_sqliteDB);
1607     ASSERT(m_sqliteDB-&gt;isOpen());
1608 
1609     auto* transaction = m_transactions.get(transactionIdentifier);
1610     if (!transaction || !transaction-&gt;inProgress())
1611         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
1612 
</pre>
<hr />
<pre>
1686     if (jsValue.isUndefinedOrNull())
1687         return IDBError { };
1688 
1689     IDBError error;
1690     bool anyRecordsSucceeded = false;
1691     for (auto&amp; index : info.indexMap().values()) {
1692         IndexKey indexKey;
1693         generateIndexKeyForValue(m_serializationContext-&gt;execState(), index, jsValue, indexKey, info.keyPath(), key);
1694 
1695         if (indexKey.isNull())
1696             continue;
1697 
1698         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1699         if (!error.isNull())
1700             break;
1701 
1702         anyRecordsSucceeded = true;
1703     }
1704 
1705     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
<span class="line-modified">1706         RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(key);</span>
<span class="line-removed">1707 </span>
<span class="line-removed">1708         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND value = CAST(? AS TEXT);&quot;_s);</span>
1709 
1710         if (!sql
1711             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">1712             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK</span>
1713             || sql-&gt;step() != SQLITE_DONE) {
1714             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1715             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1716         }
1717     }
1718 
1719     return error;
1720 }
1721 
1722 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1723 {
1724     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1725 
1726     ASSERT(m_sqliteDB);
1727     ASSERT(m_sqliteDB-&gt;isOpen());
1728     ASSERT(value.data().data());
1729     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1730 
1731     auto* transaction = m_transactions.get(transactionIdentifier);
1732     if (!transaction || !transaction-&gt;inProgress())
</pre>
<hr />
<pre>
2165         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2166     }
2167 
2168     if (cursor-&gt;didError()) {
2169         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2170         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2171     }
2172 
2173     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
2174     ASSERT(objectStoreInfo);
2175     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };
2176 
2177     uint32_t currentCount = 0;
2178     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2179     if (!targetCount)
2180         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2181     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
2182         IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();
2183         result.addKey(WTFMove(keyCopy));
2184         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
<span class="line-modified">2185             result.addValue(cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue());</span>
2186 
2187         ++currentCount;
2188         cursor-&gt;advance(1);
2189     }
2190 
2191     if (cursor-&gt;didError()) {
2192         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2193         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2194     }
2195 
2196     return IDBError { };
2197 }
2198 
2199 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2200 {
2201     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2202 
2203     ASSERT(m_sqliteDB);
2204     ASSERT(m_sqliteDB-&gt;isOpen());
2205 
</pre>
<hr />
<pre>
2212 
2213     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2214     if (!cursor) {
2215         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2216         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2217     }
2218 
2219     if (cursor-&gt;didError()) {
2220         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2221         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2222     }
2223 
2224     if (cursor-&gt;didComplete())
2225         getResult = { };
2226     else {
2227         if (type == IndexedDB::IndexRecordType::Key)
2228             getResult = { cursor-&gt;currentPrimaryKey() };
2229         else {
2230             auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2231             ASSERT(objectStoreInfo);
<span class="line-modified">2232             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), cursor-&gt;currentValue() ? *cursor-&gt;currentValue() : IDBValue(), objectStoreInfo-&gt;keyPath() };</span>
2233         }
2234     }
2235 
2236     return IDBError { };
2237 }
2238 
2239 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2240 {
2241     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2242 
2243     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2244 
2245     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2246     if (!buffer) {
2247         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2248         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2249     }
2250 
<span class="line-modified">2251     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.objectStoreID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);</span>
2252 
2253     if (!sql
2254         || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
<span class="line-modified">2255         || sql-&gt;bindInt64(2, objectStoreID) != SQLITE_OK</span>
<span class="line-removed">2256         || sql-&gt;bindBlob(3, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
2257         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2258         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2259     }
2260 
2261     int result = sql-&gt;step();
2262     if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
2263         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2264         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2265     }
2266 
2267     if (result == SQLITE_DONE)
2268         return IDBError { };
2269 
2270     IDBKeyData objectStoreKey;
2271     Vector&lt;uint8_t&gt; keyVector;
2272     sql-&gt;getColumnBlobAsVector(0, keyVector);
2273 
2274     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2275         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2276         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
</pre>
<hr />
<pre>
2287     int64_t recordID = sql-&gt;getColumnInt64(2);
2288     Vector&lt;String&gt; blobURLs, blobFilePaths;
2289     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2290     ASSERT(blobURLs.size() == blobFilePaths.size());
2291 
2292     if (!error.isNull())
2293         return error;
2294 
2295     auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2296     ASSERT(objectStoreInfo);
2297     getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath() };
2298     return IDBError { };
2299 }
2300 
2301 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2302 {
2303     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2304     ASSERT(m_sqliteDB);
2305     ASSERT(m_sqliteDB-&gt;isOpen());
2306 
<span class="line-removed">2307     outCount = 0;</span>
<span class="line-removed">2308 </span>
2309     auto* transaction = m_transactions.get(transactionIdentifier);
2310     if (!transaction || !transaction-&gt;inProgress())
2311         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
2312 
<span class="line-modified">2313     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreIdentifier, indexIdentifier, range);</span>
<span class="line-modified">2314     if (!cursor) {</span>
<span class="line-modified">2315         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);</span>
<span class="line-modified">2316         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };</span>


























































2317     }
2318 
<span class="line-modified">2319     while (cursor-&gt;advance(1))</span>
<span class="line-modified">2320         ++outCount;</span>
2321 

2322     return IDBError { };
2323 }
2324 
2325 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2326 {
2327     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2328     if (!sql
2329         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2330         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2331         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
2332     }
2333     int result = sql-&gt;step();
2334     if (result != SQLITE_ROW) {
2335         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2336         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2337     }
2338 
2339     int64_t value = sql-&gt;getColumnInt64(0);
2340     if (value &lt; 0)
2341         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
</pre>
<hr />
<pre>
2476 
2477     auto key = data.keyData;
2478     auto primaryKey = data.primaryKeyData;
2479     auto count = data.count;
2480 
2481     if (key.isValid()) {
2482         if (!cursor-&gt;iterate(key, primaryKey)) {
2483             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2484             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2485         }
2486     } else {
2487         ASSERT(!primaryKey.isValid());
2488         if (!count)
2489             count = 1;
2490         if (!cursor-&gt;advance(count)) {
2491             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2492             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2493         }
2494     }
2495 
<span class="line-modified">2496     auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());</span>
<span class="line-modified">2497     ASSERT(objectStoreInfo);</span>
<span class="line-modified">2498     cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath());</span>
<span class="line-removed">2499     return IDBError { };</span>
<span class="line-removed">2500 }</span>
2501 
<span class="line-modified">2502 bool SQLiteIDBBackingStore::prefetchCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier)</span>
<span class="line-modified">2503 {</span>
<span class="line-modified">2504     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::prefetchCursor&quot;);</span>
2505 
<span class="line-modified">2506     ASSERT(m_sqliteDB);</span>
<span class="line-modified">2507     ASSERT(m_sqliteDB-&gt;isOpen());</span>
<span class="line-removed">2508 </span>
<span class="line-removed">2509     auto* cursor = m_cursors.get(cursorIdentifier);</span>
<span class="line-removed">2510     if (!cursor || !cursor-&gt;transaction() || !cursor-&gt;transaction()-&gt;inProgress())</span>
<span class="line-removed">2511         return false;</span>
<span class="line-removed">2512 </span>
<span class="line-removed">2513     ASSERT_UNUSED(transactionIdentifier, cursor-&gt;transaction()-&gt;transactionIdentifier() == transactionIdentifier);</span>
2514 
<span class="line-modified">2515     return cursor-&gt;prefetch();</span>
2516 }
2517 
2518 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
2519 {
2520     ASSERT(m_databaseInfo);
2521     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
2522 }
2523 
2524 void SQLiteIDBBackingStore::deleteBackingStore()
2525 {
2526     String dbFilename = fullDatabasePath();
2527 
2528     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteBackingStore deleting file &#39;%s&#39; on disk&quot;, dbFilename.utf8().data());
2529 
2530     Vector&lt;String&gt; blobFiles;
2531     {
2532         bool errored = true;
2533 
2534         if (m_sqliteDB) {
2535             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
</pre>
<hr />
<pre>
2554         if (!FileSystem::deleteFile(fullPath))
2555             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2556     }
2557 
2558     if (m_sqliteDB)
2559         closeSQLiteDB();
2560 
2561     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
2562     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);
2563     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));
2564 }
2565 
2566 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2567 {
2568     ASSERT(m_cursors.contains(cursor.identifier()));
2569     m_cursors.remove(cursor.identifier());
2570 }
2571 
2572 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2573 {
<span class="line-modified">2574     if (sql &gt;= SQL::Count) {</span>
2575         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2576         return nullptr;
2577     }
2578 
2579     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2580         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2581             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2582         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2583     }
2584 
2585     if (m_sqliteDB) {
2586         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = makeUnique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);
2587         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2588             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2589     }
2590 
2591     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2592 }
2593 
2594 void SQLiteIDBBackingStore::close()
2595 {
2596     closeSQLiteDB();
2597 }
2598 
2599 void SQLiteIDBBackingStore::closeSQLiteDB()
2600 {
<span class="line-modified">2601     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Count); ++i)</span>
2602         m_cachedStatements[i] = nullptr;
2603 
2604     if (m_sqliteDB)
2605         m_sqliteDB-&gt;close();
2606 
2607     m_sqliteDB = nullptr;
2608 }
2609 
2610 bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier&amp; transactionIdentifier) const
2611 {
2612     ASSERT(isMainThread());
2613     return m_transactions.contains(transactionIdentifier);
2614 }
2615 
2616 } // namespace IDBServer
2617 } // namespace WebCore
2618 
2619 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;IDBValue.h&quot;
  44 #include &quot;IndexKey.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;SQLiteDatabase.h&quot;
  47 #include &quot;SQLiteFileSystem.h&quot;
  48 #include &quot;SQLiteIDBCursor.h&quot;
  49 #include &quot;SQLiteStatement.h&quot;
  50 #include &quot;SQLiteTransaction.h&quot;
  51 #include &quot;ThreadSafeDataBuffer.h&quot;
  52 #include &lt;JavaScriptCore/AuxiliaryBarrierInlines.h&gt;
  53 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  54 #include &lt;JavaScriptCore/StrongInlines.h&gt;
  55 #include &lt;wtf/FileSystem.h&gt;
  56 #include &lt;wtf/NeverDestroyed.h&gt;
  57 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  58 
  59 namespace WebCore {
  60 using namespace JSC;
  61 namespace IDBServer {
  62 
<span class="line-added">  63 constexpr auto objectStoreInfoTableName = &quot;ObjectStoreInfo&quot;_s;</span>
<span class="line-added">  64 constexpr auto objectStoreInfoTableNameAlternate = &quot;\&quot;ObjectStoreInfo\&quot;&quot;_s;</span>
<span class="line-added">  65 constexpr auto v2ObjectStoreInfoSchema = &quot;CREATE TABLE ObjectStoreInfo (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)&quot;_s;</span>
<span class="line-added">  66 constexpr auto v1IndexRecordsRecordIndexSchema = &quot;CREATE INDEX IndexRecordsRecordIndex ON IndexRecords (objectStoreID, objectStoreRecordID)&quot;_s;</span>
<span class="line-added">  67 constexpr auto IndexRecordsIndexSchema = &quot;CREATE INDEX IndexRecordsIndex ON IndexRecords (indexID, key, value)&quot;_s;</span>
<span class="line-added">  68 </span>
  69 // Current version of the metadata schema being used in the metadata database.
  70 static const int currentMetadataVersion = 1;
  71 
  72 // The IndexedDatabase spec defines the max key generator value as 2^53.
  73 static const uint64_t maxGeneratorValue = 0x20000000000000;
  74 
  75 static int idbKeyCollate(int aLength, const void* aBuffer, int bLength, const void* bBuffer)
  76 {
  77     IDBKeyData a, b;
  78     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(aBuffer), aLength, a)) {
  79         LOG_ERROR(&quot;Unable to deserialize key A in collation function.&quot;);
  80 
  81         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
  82         // We arbitrarily choose &quot;A &gt; B&quot;
  83         return 1;
  84     }
  85     if (!deserializeIDBKeyData(static_cast&lt;const uint8_t*&gt;(bBuffer), bLength, b)) {
  86         LOG_ERROR(&quot;Unable to deserialize key B in collation function.&quot;);
  87 
  88         // There&#39;s no way to indicate an error to SQLite - we have to return a sorting decision.
</pre>
<hr />
<pre>
 178     return v2IndexRecordsTableSchemaString;
 179 }
 180 
 181 static const String v3IndexRecordsTableSchema(const String&amp; tableName)
 182 {
 183     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (indexID INTEGER NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, key TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, value TEXT COLLATE IDBKEY NOT NULL ON CONFLICT FAIL, objectStoreRecordID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);
 184 }
 185 
 186 static const String v3IndexRecordsTableSchema()
 187 {
 188     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;IndexRecords&quot;);
 189     return indexRecordsTableSchemaString;
 190 }
 191 
 192 static const String v3IndexRecordsTableSchemaAlternate()
 193 {
 194     static NeverDestroyed&lt;WTF::String&gt; indexRecordsTableSchemaString = v3IndexRecordsTableSchema(&quot;\&quot;IndexRecords\&quot;&quot;);
 195     return indexRecordsTableSchemaString;
 196 }
 197 






 198 static const String blobRecordsTableSchema(const String&amp; tableName)
 199 {
 200     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (objectStoreRow INTEGER NOT NULL ON CONFLICT FAIL, blobURL TEXT NOT NULL ON CONFLICT FAIL)&quot;);
 201 }
 202 
 203 static const String&amp; blobRecordsTableSchema()
 204 {
 205     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;BlobRecords&quot;));
 206     return blobRecordsTableSchemaString;
 207 }
 208 
 209 static const String&amp; blobRecordsTableSchemaAlternate()
 210 {
 211     static NeverDestroyed&lt;String&gt; blobRecordsTableSchemaString(blobRecordsTableSchema(&quot;\&quot;BlobRecords\&quot;&quot;));
 212     return blobRecordsTableSchemaString;
 213 }
 214 
 215 static const String blobFilesTableSchema(const String&amp; tableName)
 216 {
 217     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (blobURL TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, fileName TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL)&quot;);
 218 }
 219 
 220 static const String&amp; blobFilesTableSchema()
 221 {
 222     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;BlobFiles&quot;));
 223     return blobFilesTableSchemaString;
 224 }
 225 
 226 static const String&amp; blobFilesTableSchemaAlternate()
 227 {
 228     static NeverDestroyed&lt;String&gt; blobFilesTableSchemaString(blobFilesTableSchema(&quot;\&quot;BlobFiles\&quot;&quot;));
 229     return blobFilesTableSchemaString;
 230 }
 231 
<span class="line-modified"> 232 static String createV1ObjectStoreInfoSchema(ASCIILiteral tableName)</span>
<span class="line-added"> 233 {</span>
<span class="line-added"> 234     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL, maxIndexID INTEGER NOT NULL ON CONFLICT FAIL)&quot;);</span>
<span class="line-added"> 235 }</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237 static String createV2ObjectStoreInfoSchema(ASCIILiteral tableName)</span>
<span class="line-added"> 238 {</span>
<span class="line-added"> 239     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (id INTEGER PRIMARY KEY NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, autoInc INTEGER NOT NULL ON CONFLICT FAIL)&quot;);</span>
<span class="line-added"> 240 }</span>
<span class="line-added"> 241 </span>
<span class="line-added"> 242 SQLiteIDBBackingStore::SQLiteIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier, const String&amp; databaseRootDirectory)</span>
 243     : m_sessionID(sessionID)
 244     , m_identifier(identifier)
 245     , m_databaseRootDirectory(databaseRootDirectory)

 246     , m_serializationContext(IDBSerializationContext::getOrCreateIDBSerializationContext(sessionID))
 247 {
 248     m_databaseDirectory = fullDatabaseDirectoryWithUpgrade();
 249 }
 250 
 251 SQLiteIDBBackingStore::~SQLiteIDBBackingStore()
 252 {
 253     if (m_sqliteDB)
 254         closeSQLiteDB();
 255 }
 256 
 257 static bool createOrMigrateRecordsTableIfNecessary(SQLiteDatabase&amp; database)
 258 {
 259     String currentSchema;
 260     {
 261         // Fetch the schema for an existing records table.
 262         SQLiteStatement statement(database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
 263         if (statement.prepare() != SQLITE_OK) {
 264             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the Records table.&quot;);
 265             return false;
</pre>
<hr />
<pre>
 492 }
 493 
 494 bool SQLiteIDBBackingStore::ensureValidIndexRecordsIndex()
 495 {
 496     ASSERT(m_sqliteDB);
 497     ASSERT(m_sqliteDB-&gt;isOpen());
 498 
 499     String currentSchema;
 500     {
 501         // Fetch the schema for an existing index record index.
 502         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsIndex&#39;&quot;);
 503         if (statement.prepare() != SQLITE_OK) {
 504             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsIndex index.&quot;);
 505             return false;
 506         }
 507 
 508         int sqliteResult = statement.step();
 509 
 510         // If there is no IndexRecordsIndex index at all, create it and then bail.
 511         if (sqliteResult == SQLITE_DONE) {
<span class="line-modified"> 512             if (!m_sqliteDB-&gt;executeCommand(IndexRecordsIndexSchema)) {</span>
 513                 LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 514                 return false;
 515             }
 516 
 517             return true;
 518         }
 519 
 520         if (sqliteResult != SQLITE_ROW) {
 521             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsIndex index.&quot;);
 522             return false;
 523         }
 524 
 525         currentSchema = statement.getColumnText(0);
 526     }
 527 
 528     ASSERT(!currentSchema.isEmpty());
 529 
 530     // If the schema in the backing store is the current schema, we&#39;re done.
<span class="line-modified"> 531     if (currentSchema == IndexRecordsIndexSchema)</span>
<span class="line-added"> 532         return true;</span>
<span class="line-added"> 533 </span>
<span class="line-added"> 534     // Otherwise, update the schema.</span>
<span class="line-added"> 535     SQLiteTransaction transaction(*m_sqliteDB);</span>
<span class="line-added"> 536     transaction.begin();</span>
<span class="line-added"> 537 </span>
<span class="line-added"> 538     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP INDEX IndexRecordsIndex&quot;)) {</span>
<span class="line-added"> 539         LOG_ERROR(&quot;Could not drop index IndexRecordsIndex in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 540         return false;</span>
<span class="line-added"> 541     }</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543     if (!m_sqliteDB-&gt;executeCommand(IndexRecordsIndexSchema)) {</span>
<span class="line-added"> 544         LOG_ERROR(&quot;Could not create IndexRecordsIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 545         return false;</span>
<span class="line-added"> 546     }</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548     transaction.commit();</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550     return true;</span>
<span class="line-added"> 551 }</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553 bool SQLiteIDBBackingStore::ensureValidIndexRecordsRecordIndex()</span>
<span class="line-added"> 554 {</span>
<span class="line-added"> 555     ASSERT(m_sqliteDB);</span>
<span class="line-added"> 556     ASSERT(m_sqliteDB-&gt;isOpen());</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558     String currentSchema;</span>
<span class="line-added"> 559     {</span>
<span class="line-added"> 560         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE name=&#39;IndexRecordsRecordIndex&#39;&quot;);</span>
<span class="line-added"> 561         if (statement.prepare() != SQLITE_OK) {</span>
<span class="line-added"> 562             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the IndexRecordsRecordIndex index.&quot;);</span>
<span class="line-added"> 563             return false;</span>
<span class="line-added"> 564         }</span>
<span class="line-added"> 565 </span>
<span class="line-added"> 566         int sqliteResult = statement.step();</span>
<span class="line-added"> 567 </span>
<span class="line-added"> 568         if (sqliteResult == SQLITE_DONE) {</span>
<span class="line-added"> 569             if (!m_sqliteDB-&gt;executeCommand(v1IndexRecordsRecordIndexSchema)) {</span>
<span class="line-added"> 570                 LOG_ERROR(&quot;Could not create IndexRecordsRecordIndex index in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 571                 return false;</span>
<span class="line-added"> 572             }</span>
<span class="line-added"> 573 </span>
<span class="line-added"> 574             return true;</span>
<span class="line-added"> 575         }</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577         if (sqliteResult != SQLITE_ROW) {</span>
<span class="line-added"> 578             LOG_ERROR(&quot;Error executing statement to fetch schema for the IndexRecordsRecordIndex index.&quot;);</span>
<span class="line-added"> 579             return false;</span>
<span class="line-added"> 580         }</span>
<span class="line-added"> 581 </span>
<span class="line-added"> 582         currentSchema = statement.getColumnText(0);</span>
<span class="line-added"> 583     }</span>
<span class="line-added"> 584 </span>
<span class="line-added"> 585     ASSERT(!currentSchema.isEmpty());</span>
<span class="line-added"> 586 </span>
<span class="line-added"> 587     if (currentSchema == v1IndexRecordsRecordIndexSchema)</span>
 588         return true;
 589 

 590     return false;
 591 }
 592 
 593 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::createAndPopulateInitialDatabaseInfo()
 594 {
 595     ASSERT(m_sqliteDB);
 596     ASSERT(m_sqliteDB-&gt;isOpen());
 597 
 598     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IDBDatabaseInfo (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, value TEXT NOT NULL ON CONFLICT FAIL);&quot;)) {
 599         LOG_ERROR(&quot;Could not create IDBDatabaseInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 600         closeSQLiteDB();
 601         return nullptr;
 602     }
 603 
<span class="line-modified"> 604     if (!m_sqliteDB-&gt;executeCommand(v2ObjectStoreInfoSchema)) {</span>
 605         LOG_ERROR(&quot;Could not create ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 606         closeSQLiteDB();
 607         return nullptr;
 608     }
 609 
 610     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE IndexInfo (id INTEGER NOT NULL ON CONFLICT FAIL, name TEXT NOT NULL ON CONFLICT FAIL, objectStoreID INTEGER NOT NULL ON CONFLICT FAIL, keyPath BLOB NOT NULL ON CONFLICT FAIL, isUnique INTEGER NOT NULL ON CONFLICT FAIL, multiEntry INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 611         LOG_ERROR(&quot;Could not create IndexInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 612         closeSQLiteDB();
 613         return nullptr;
 614     }
 615 
 616     if (!m_sqliteDB-&gt;executeCommand(&quot;CREATE TABLE KeyGenerators (objectStoreID INTEGER NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, currentKey INTEGER NOT NULL ON CONFLICT FAIL);&quot;)) {
 617         LOG_ERROR(&quot;Could not create KeyGenerators table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 618         closeSQLiteDB();
 619         return nullptr;
 620     }
 621 
 622     {
 623         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MetadataVersion&#39;, ?);&quot;_s);
 624         if (sql.prepare() != SQLITE_OK
</pre>
<hr />
<pre>
 642     {
 643         // Database versions are defined to be a uin64_t in the spec but sqlite3 doesn&#39;t support native binding of unsigned integers.
 644         // Therefore we&#39;ll store the version as a String.
 645         SQLiteStatement sql(*m_sqliteDB, &quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;DatabaseVersion&#39;, ?);&quot;_s);
 646         if (sql.prepare() != SQLITE_OK
 647             || sql.bindText(1, String::number(0)) != SQLITE_OK
 648             || sql.step() != SQLITE_DONE) {
 649             LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 650             closeSQLiteDB();
 651             return nullptr;
 652         }
 653     }
 654 
 655     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO IDBDatabaseInfo VALUES (&#39;MaxObjectStoreID&#39;, 1);&quot;_s)) {
 656         LOG_ERROR(&quot;Could not insert default version into IDBDatabaseInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
 657         closeSQLiteDB();
 658         return nullptr;
 659     }
 660 
 661     // This initial database info matches the default values we just put into the metadata database.
<span class="line-modified"> 662     return makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0, 0);</span>
<span class="line-added"> 663 }</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665 Optional&lt;IsSchemaUpgraded&gt; SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable()</span>
<span class="line-added"> 666 {</span>
<span class="line-added"> 667     ASSERT(m_sqliteDB);</span>
<span class="line-added"> 668     ASSERT(m_sqliteDB-&gt;isOpen());</span>
<span class="line-added"> 669 </span>
<span class="line-added"> 670     String currentSchema;</span>
<span class="line-added"> 671     {</span>
<span class="line-added"> 672         // Fetch the schema for ObjectStoreInfo table.</span>
<span class="line-added"> 673         SQLiteStatement statement(*m_sqliteDB, &quot;SELECT sql FROM sqlite_master WHERE tbl_name=&#39;ObjectStoreInfo&#39;&quot;);</span>
<span class="line-added"> 674         if (statement.prepare() != SQLITE_OK) {</span>
<span class="line-added"> 675             LOG_ERROR(&quot;Unable to prepare statement to fetch schema for the ObjectStoreInfo table.&quot;);</span>
<span class="line-added"> 676             return WTF::nullopt;</span>
<span class="line-added"> 677         }</span>
<span class="line-added"> 678 </span>
<span class="line-added"> 679         int sqliteResult = statement.step();</span>
<span class="line-added"> 680         if (sqliteResult != SQLITE_ROW) {</span>
<span class="line-added"> 681             LOG_ERROR(&quot;Error executing statement to fetch schema for the ObjectStoreInfo table.&quot;);</span>
<span class="line-added"> 682             return WTF::nullopt;</span>
<span class="line-added"> 683         }</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685         currentSchema = statement.getColumnText(0);</span>
<span class="line-added"> 686     }</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688     ASSERT(!currentSchema.isEmpty());</span>
<span class="line-added"> 689     if (currentSchema == v2ObjectStoreInfoSchema || currentSchema == createV2ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate))</span>
<span class="line-added"> 690         return { IsSchemaUpgraded::No };</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692     if (currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableName) &amp;&amp; currentSchema != createV1ObjectStoreInfoSchema(objectStoreInfoTableNameAlternate)) {</span>
<span class="line-added"> 693         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::ensureValidObjectStoreInfoTable: schema is invalid - %s&quot;, this, currentSchema.utf8().data());</span>
<span class="line-added"> 694         return WTF::nullopt;</span>
<span class="line-added"> 695     }</span>
<span class="line-added"> 696 </span>
<span class="line-added"> 697     // Drop column maxIndexID from table.</span>
<span class="line-added"> 698     SQLiteTransaction transaction(*m_sqliteDB);</span>
<span class="line-added"> 699     transaction.begin();</span>
<span class="line-added"> 700 </span>
<span class="line-added"> 701     if (!m_sqliteDB-&gt;executeCommand(createV2ObjectStoreInfoSchema(&quot;_Temp_ObjectStoreInfo&quot;_s))) {</span>
<span class="line-added"> 702         LOG_ERROR(&quot;Could not create temporary ObjectStoreInfo table in database (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 703         return WTF::nullopt;</span>
<span class="line-added"> 704     }</span>
<span class="line-added"> 705 </span>
<span class="line-added"> 706     if (!m_sqliteDB-&gt;executeCommand(&quot;INSERT INTO _Temp_ObjectStoreInfo (id, name, keyPath, autoInc) SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo&quot;)) {</span>
<span class="line-added"> 707         LOG_ERROR(&quot;Could not migrate existing ObjectStoreInfo content (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 708         return WTF::nullopt;</span>
<span class="line-added"> 709     }</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711     if (!m_sqliteDB-&gt;executeCommand(&quot;DROP TABLE ObjectStoreInfo&quot;)) {</span>
<span class="line-added"> 712         LOG_ERROR(&quot;Could not drop existing ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 713         return WTF::nullopt;</span>
<span class="line-added"> 714     }</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716     if (!m_sqliteDB-&gt;executeCommand(&quot;ALTER TABLE _Temp_ObjectStoreInfo RENAME TO ObjectStoreInfo&quot;)) {</span>
<span class="line-added"> 717         LOG_ERROR(&quot;Could not rename temporary ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added"> 718         return WTF::nullopt;</span>
<span class="line-added"> 719     }</span>
<span class="line-added"> 720 </span>
<span class="line-added"> 721     transaction.commit();</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723     return { IsSchemaUpgraded::Yes };</span>
 724 }
 725 
 726 std::unique_ptr&lt;IDBDatabaseInfo&gt; SQLiteIDBBackingStore::extractExistingDatabaseInfo()
 727 {
 728     ASSERT(m_sqliteDB);
 729 
 730     if (!m_sqliteDB-&gt;tableExists(&quot;IDBDatabaseInfo&quot;_s))
 731         return nullptr;
 732 
 733     String databaseName;
 734     {
 735         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseName&#39;;&quot;);
 736         if (sql.isColumnNull(0))
 737             return nullptr;
 738         databaseName = sql.getColumnText(0);
 739         if (databaseName != m_identifier.databaseName()) {
 740             LOG_ERROR(&quot;Database name in the info database (&#39;%s&#39;) does not match the expected name (&#39;%s&#39;)&quot;, databaseName.utf8().data(), m_identifier.databaseName().utf8().data());
 741             return nullptr;
 742         }
 743     }
 744     uint64_t databaseVersion;
 745     {
 746         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT value FROM IDBDatabaseInfo WHERE key = &#39;DatabaseVersion&#39;;&quot;_s);
 747         if (sql.isColumnNull(0))
 748             return nullptr;
 749         String stringVersion = sql.getColumnText(0);
 750         bool ok;
 751         databaseVersion = stringVersion.toUInt64Strict(&amp;ok);
 752         if (!ok) {
 753             LOG_ERROR(&quot;Database version on disk (&#39;%s&#39;) does not cleanly convert to an unsigned 64-bit integer version&quot;, stringVersion.utf8().data());
 754             return nullptr;
 755         }
 756     }
 757 
<span class="line-modified"> 758     auto databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(databaseName, databaseVersion, 0);</span>
<span class="line-added"> 759 </span>
<span class="line-added"> 760     auto result = ensureValidObjectStoreInfoTable();</span>
<span class="line-added"> 761     if (!result)</span>
<span class="line-added"> 762         return nullptr;</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764     bool shouldUpdateIndexID = (result.value() == IsSchemaUpgraded::Yes);</span>
 765 
 766     {
<span class="line-modified"> 767         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, keyPath, autoInc FROM ObjectStoreInfo;&quot;_s);</span>
 768         if (sql.prepare() != SQLITE_OK)
 769             return nullptr;
 770 
 771         int result = sql.step();
 772         while (result == SQLITE_ROW) {
 773             uint64_t objectStoreID = sql.getColumnInt64(0);
 774             String objectStoreName = sql.getColumnText(1);
 775 
 776             Vector&lt;char&gt; keyPathBuffer;
 777             sql.getColumnBlobAsVector(2, keyPathBuffer);
 778 
 779             Optional&lt;IDBKeyPath&gt; objectStoreKeyPath;
 780             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), objectStoreKeyPath)) {
 781                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 782                 return nullptr;
 783             }
 784 
 785             bool autoIncrement = sql.getColumnInt(3);
 786 
 787             databaseInfo-&gt;addExistingObjectStore({ objectStoreID, objectStoreName, WTFMove(objectStoreKeyPath), autoIncrement });
 788 
 789             result = sql.step();
 790         }
 791 
 792         if (result != SQLITE_DONE) {
 793             LOG_ERROR(&quot;Error fetching object store info from database on disk&quot;);
 794             return nullptr;
 795         }
 796     }
 797 
<span class="line-added"> 798     uint64_t maxIndexID = 0;</span>
<span class="line-added"> 799     HashMap&lt;std::pair&lt;uint64_t, uint64_t&gt;, uint64_t&gt; indexIDMap;</span>
 800     {
 801         SQLiteStatement sql(*m_sqliteDB, &quot;SELECT id, name, objectStoreID, keyPath, isUnique, multiEntry FROM IndexInfo;&quot;_s);
<span class="line-modified"> 802         if (sql.prepare() != SQLITE_OK) {</span>
<span class="line-added"> 803             LOG_ERROR(&quot;Unable to prepare statement to fetch records from the IndexInfo table.&quot;);</span>
 804             return nullptr;
<span class="line-added"> 805         }</span>
 806 
 807         int result = sql.step();
 808         while (result == SQLITE_ROW) {
 809             uint64_t indexID = sql.getColumnInt64(0);
 810             String indexName = sql.getColumnText(1);
 811             uint64_t objectStoreID = sql.getColumnInt64(2);
 812 
 813             Vector&lt;char&gt; keyPathBuffer;
 814             sql.getColumnBlobAsVector(3, keyPathBuffer);
 815 
 816             Optional&lt;IDBKeyPath&gt; indexKeyPath;
 817             if (!deserializeIDBKeyPath(reinterpret_cast&lt;const uint8_t*&gt;(keyPathBuffer.data()), keyPathBuffer.size(), indexKeyPath)) {
 818                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 819                 return nullptr;
 820             }
 821             if (!indexKeyPath) {
 822                 LOG_ERROR(&quot;Unable to extract key path from database&quot;);
 823                 return nullptr;
 824             }
 825 
 826             bool unique = sql.getColumnInt(4);
 827             bool multiEntry = sql.getColumnInt(5);
 828 
 829             auto objectStore = databaseInfo-&gt;infoForExistingObjectStore(objectStoreID);
 830             if (!objectStore) {
 831                 LOG_ERROR(&quot;Found index referring to a non-existant object store&quot;);
 832                 return nullptr;
 833             }
 834 
<span class="line-added"> 835             if (shouldUpdateIndexID) {</span>
<span class="line-added"> 836                 indexIDMap.set({ objectStoreID, indexID }, ++maxIndexID);</span>
<span class="line-added"> 837                 indexID = maxIndexID;</span>
<span class="line-added"> 838             }</span>
<span class="line-added"> 839 </span>
 840             objectStore-&gt;addExistingIndex({ indexID, objectStoreID, indexName, WTFMove(indexKeyPath.value()), unique, multiEntry });
<span class="line-added"> 841             maxIndexID = maxIndexID &lt; indexID ? indexID : maxIndexID;</span>
 842 
 843             result = sql.step();
 844         }
 845 
 846         if (result != SQLITE_DONE) {
 847             LOG_ERROR(&quot;Error fetching index info from database on disk&quot;);
 848             return nullptr;
 849         }
<span class="line-added"> 850         databaseInfo-&gt;setMaxIndexID(maxIndexID);</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852         if (!shouldUpdateIndexID)</span>
<span class="line-added"> 853             return databaseInfo;</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855         for (auto&amp; entry : indexIDMap) {</span>
<span class="line-added"> 856             SQLiteStatement sql(*m_sqliteDB, &quot;UPDATE IndexInfo SET id = ? WHERE id = ? AND objectStoreID = ?;&quot;_s);</span>
<span class="line-added"> 857             if (sql.prepare() != SQLITE_OK</span>
<span class="line-added"> 858                 || sql.bindInt64(1, entry.value) != SQLITE_OK</span>
<span class="line-added"> 859                 || sql.bindInt64(2, entry.key.second) != SQLITE_OK</span>
<span class="line-added"> 860                 || sql.bindInt64(3, entry.key.first) != SQLITE_OK</span>
<span class="line-added"> 861                 || sql.step() != SQLITE_DONE) {</span>
<span class="line-added"> 862                 LOG_ERROR(&quot;Unable to update id of IndexInfo table&quot;);</span>
<span class="line-added"> 863                 return nullptr;</span>
<span class="line-added"> 864             }</span>
<span class="line-added"> 865 </span>
<span class="line-added"> 866             SQLiteStatement recordSql(*m_sqliteDB, &quot;UPDATE IndexRecords SET indexID = ? WHERE indexID = ? AND objectStoreID = ?;&quot;_s);</span>
<span class="line-added"> 867             if (recordSql.prepare() != SQLITE_OK</span>
<span class="line-added"> 868                 || recordSql.bindInt64(1, entry.value) != SQLITE_OK</span>
<span class="line-added"> 869                 || recordSql.bindInt64(2, entry.key.second) != SQLITE_OK</span>
<span class="line-added"> 870                 || recordSql.bindInt64(3, entry.key.first) != SQLITE_OK</span>
<span class="line-added"> 871                 || recordSql.step() != SQLITE_DONE) {</span>
<span class="line-added"> 872                 LOG_ERROR(&quot;Unable to update indexID of IndexRecords table&quot;);</span>
<span class="line-added"> 873                 return nullptr;</span>
<span class="line-added"> 874             }</span>
<span class="line-added"> 875         }</span>
 876     }
 877 
 878     return databaseInfo;
 879 }
 880 
 881 String SQLiteIDBBackingStore::databaseNameFromEncodedFilename(const String&amp; encodedName)
 882 {
 883     if (encodedName == &quot;%00&quot;_s)
 884         return { };
 885 
 886     String partiallyDecoded = encodedName;
 887     partiallyDecoded.replace(&quot;%2E&quot;_s, &quot;.&quot;_s);
 888 
 889     return FileSystem::decodeFromFilename(partiallyDecoded);
 890 }
 891 
 892 String SQLiteIDBBackingStore::filenameForDatabaseName() const
 893 {
 894     ASSERT(!m_identifier.databaseName().isNull());
 895 
</pre>
<hr />
<pre>
 974     });
 975 
 976     if (!ensureValidRecordsTable()) {
 977         LOG_ERROR(&quot;Error creating or migrating Records table in database&quot;);
 978         closeSQLiteDB();
 979         return IDBError { UnknownError, &quot;Error creating or migrating Records table in database&quot;_s };
 980     }
 981 
 982     if (!ensureValidIndexRecordsTable()) {
 983         LOG_ERROR(&quot;Error creating or migrating Index Records table in database&quot;);
 984         closeSQLiteDB();
 985         return IDBError { UnknownError, &quot;Error creating or migrating Index Records table in database&quot;_s };
 986     }
 987 
 988     if (!ensureValidIndexRecordsIndex()) {
 989         LOG_ERROR(&quot;Error creating or migrating Index Records index in database&quot;);
 990         closeSQLiteDB();
 991         return IDBError { UnknownError, &quot;Error creating or migrating Index Records index in database&quot;_s };
 992     }
 993 
<span class="line-added"> 994     if (!ensureValidIndexRecordsRecordIndex()) {</span>
<span class="line-added"> 995         LOG_ERROR(&quot;Error creating or migrating Index Records second index for in database&quot;);</span>
<span class="line-added"> 996         closeSQLiteDB();</span>
<span class="line-added"> 997         return IDBError { UnknownError, &quot;Error creating or migrating Index Records second index in database&quot;_s };</span>
<span class="line-added"> 998     }</span>
<span class="line-added"> 999 </span>
1000     if (!ensureValidBlobTables()) {
1001         LOG_ERROR(&quot;Error creating or confirming Blob Records tables in database&quot;);
1002         closeSQLiteDB();
1003         return IDBError { UnknownError, &quot;Error creating or confirming Blob Records tables in database&quot;_s };
1004     }
1005 
1006     auto databaseInfo = extractExistingDatabaseInfo();
1007     if (!databaseInfo)
1008         databaseInfo = createAndPopulateInitialDatabaseInfo();
1009 
1010     if (!databaseInfo) {
1011         LOG_ERROR(&quot;Unable to establish IDB database at path &#39;%s&#39;&quot;, dbFilename.utf8().data());
1012         closeSQLiteDB();
1013         return IDBError { UnknownError, &quot;Unable to establish IDB database file&quot;_s };
1014     }
1015 
1016     m_databaseInfo = WTFMove(databaseInfo);
1017     info = *m_databaseInfo;
1018     return IDBError { };
1019 }
1020 
1021 uint64_t SQLiteIDBBackingStore::databasesSizeForDirectory(const String&amp; directory)
1022 {
1023     uint64_t diskUsage = 0;
1024     for (auto&amp; dbDirectory : FileSystem::listDirectory(directory, &quot;*&quot;)) {
1025         for (auto&amp; file : FileSystem::listDirectory(dbDirectory, &quot;*.sqlite3&quot;_s))
1026             diskUsage += SQLiteFileSystem::getDatabaseFileSize(file);
1027     }
1028     return diskUsage;
1029 }
1030 






1031 IDBError SQLiteIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
1032 {
1033     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::beginTransaction - %s&quot;, info.identifier().loggingString().utf8().data());
1034 
1035     ASSERT(m_sqliteDB);
1036     ASSERT(m_sqliteDB-&gt;isOpen());
1037     ASSERT(m_databaseInfo);
1038 
1039     auto addResult = m_transactions.add(info.identifier(), nullptr);
1040     if (!addResult.isNewEntry) {
1041         LOG_ERROR(&quot;Attempt to establish transaction identifier that already exists&quot;);
1042         return IDBError { UnknownError, &quot;Attempt to establish transaction identifier that already exists&quot;_s };
1043     }
1044 
1045     addResult.iterator-&gt;value = makeUnique&lt;SQLiteIDBTransaction&gt;(*this, info);
1046 
1047     auto error = addResult.iterator-&gt;value-&gt;begin(*m_sqliteDB);
1048     if (error.isNull() &amp;&amp; info.mode() == IDBTransactionMode::Versionchange) {
1049         m_originalDatabaseInfoBeforeVersionChange = makeUnique&lt;IDBDatabaseInfo&gt;(*m_databaseInfo);
1050 
</pre>
<hr />
<pre>
1109 
1110     ASSERT(m_sqliteDB);
1111     ASSERT(m_sqliteDB-&gt;isOpen());
1112 
1113     auto* transaction = m_transactions.get(transactionIdentifier);
1114     if (!transaction || !transaction-&gt;inProgress())
1115         return IDBError { UnknownError, &quot;Attempt to create an object store without an in-progress transaction&quot;_s };
1116 
1117     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1118         LOG_ERROR(&quot;Attempt to create an object store in a non-version-change transaction&quot;);
1119         return IDBError { UnknownError, &quot;Attempt to create an object store in a non-version-change transaction&quot;_s };
1120     }
1121 
1122     RefPtr&lt;SharedBuffer&gt; keyPathBlob = serializeIDBKeyPath(info.keyPath());
1123     if (!keyPathBlob) {
1124         LOG_ERROR(&quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;);
1125         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyPath to save in database for new object store&quot;_s };
1126     }
1127 
1128     {
<span class="line-modified">1129         auto* sql = cachedStatement(SQL::CreateObjectStoreInfo, &quot;INSERT INTO ObjectStoreInfo VALUES (?, ?, ?, ?);&quot;_s);</span>
1130         if (!sql
1131             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1132             || sql-&gt;bindText(2, info.name()) != SQLITE_OK
1133             || sql-&gt;bindBlob(3, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1134             || sql-&gt;bindInt(4, info.autoIncrement()) != SQLITE_OK

1135             || sql-&gt;step() != SQLITE_DONE) {
1136             LOG_ERROR(&quot;Could not add object store &#39;%s&#39; to ObjectStoreInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1137             return IDBError { UnknownError, &quot;Could not create object store&quot;_s };
1138         }
1139     }
1140 
1141     {
1142         auto* sql = cachedStatement(SQL::CreateObjectStoreKeyGenerator, &quot;INSERT INTO KeyGenerators VALUES (?, 0);&quot;_s);
1143         if (!sql
1144             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1145             || sql-&gt;step() != SQLITE_DONE) {
1146             LOG_ERROR(&quot;Could not seed initial key generator value for ObjectStoreInfo table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1147             return IDBError { UnknownError, &quot;Could not seed initial key generator value for object store&quot;_s };
1148         }
1149     }
1150 
1151     m_databaseInfo-&gt;addExistingObjectStore(info);
1152 
1153     return IDBError { };
1154 }
</pre>
<hr />
<pre>
1345         || sql-&gt;bindInt64(3, info.objectStoreIdentifier()) != SQLITE_OK
1346         || sql-&gt;bindBlob(4, keyPathBlob-&gt;data(), keyPathBlob-&gt;size()) != SQLITE_OK
1347         || sql-&gt;bindInt(5, info.unique()) != SQLITE_OK
1348         || sql-&gt;bindInt(6, info.multiEntry()) != SQLITE_OK
1349         || sql-&gt;step() != SQLITE_DONE) {
1350         LOG_ERROR(&quot;Could not add index &#39;%s&#39; to IndexInfo table (%i) - %s&quot;, info.name().utf8().data(), m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1351         return IDBError { UnknownError, &quot;Unable to create index in database&quot;_s };
1352     }
1353 
1354     // Write index records for any records that already exist in this object store.
1355 
1356     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(info.objectStoreIdentifier(), 0, IDBKeyRangeData::allKeys());
1357 
1358     if (!cursor) {
1359         LOG_ERROR(&quot;Cannot open cursor to populate indexes in database&quot;);
1360         return IDBError { UnknownError, &quot;Unable to populate indexes in database&quot;_s };
1361     }
1362 
1363     while (!cursor-&gt;currentKey().isNull()) {
1364         auto&amp; key = cursor-&gt;currentKey();
<span class="line-modified">1365         auto value = cursor-&gt;currentValue();</span>
<span class="line-modified">1366         ThreadSafeDataBuffer valueBuffer = value.data();</span>
1367 
1368         ASSERT(cursor-&gt;currentRecordRowID());
1369 
1370         IDBError error = updateOneIndexForAddRecord(info, key, valueBuffer, cursor-&gt;currentRecordRowID());
1371         if (!error.isNull()) {
1372             auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1373             if (!sql
1374                 || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
1375                 || sql-&gt;bindInt64(2, info.objectStoreIdentifier()) != SQLITE_OK
1376                 || sql-&gt;step() != SQLITE_DONE) {
1377                 LOG_ERROR(&quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;);
1378                 return IDBError { UnknownError, &quot;Index creation failed due to uniqueness constraint failure, but there was an error deleting the Index record from the database&quot;_s };
1379             }
1380 
1381             return error;
1382         }
1383 
1384         if (!cursor-&gt;advance(1)) {
1385             LOG_ERROR(&quot;Error advancing cursor while indexing existing records for new index.&quot;);
1386             return IDBError { UnknownError, &quot;Error advancing cursor while indexing existing records for new index&quot;_s };
1387         }
1388     }
1389 
1390     ASSERT(m_databaseInfo);
1391     if (!m_databaseInfo) {
1392         RELEASE_LOG_ERROR(IndexedDB, &quot;%p - SQLiteIDBBackingStore::clearObjectStore: m_databaseInfo is null&quot;, this);
1393         return IDBError { UnknownError, &quot;Database info is invalid&quot;_s };
1394     }
1395 
1396     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());
1397     ASSERT(objectStore);
1398     objectStore-&gt;addExistingIndex(info);
<span class="line-added">1399     m_databaseInfo-&gt;setMaxIndexID(info.identifier());</span>
1400 
1401     return IDBError { };
1402 }
1403 
1404 IDBError SQLiteIDBBackingStore::uncheckedHasIndexRecord(const IDBIndexInfo&amp; info, const IDBKeyData&amp; indexKey, bool&amp; hasRecord)
1405 {
1406     hasRecord = false;
1407 
1408     RefPtr&lt;SharedBuffer&gt; indexKeyBuffer = serializeIDBKeyData(indexKey);
1409     if (!indexKeyBuffer) {
1410         LOG_ERROR(&quot;Unable to serialize index key to be stored in the database&quot;);
1411         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to check for index record in database&quot;_s };
1412     }
1413 
<span class="line-modified">1414     auto* sql = cachedStatement(SQL::HasIndexRecord, &quot;SELECT rowid FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
1415     if (!sql
1416         || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">1417         || sql-&gt;bindBlob(2, indexKeyBuffer-&gt;data(), indexKeyBuffer-&gt;size()) != SQLITE_OK) {</span>

1418         LOG_ERROR(&quot;Error checking for index record in database&quot;);
1419         return IDBError { UnknownError, &quot;Error checking for index record in database&quot;_s };
1420     }
1421 
1422     int sqlResult = sql-&gt;step();
1423     if (sqlResult == SQLITE_OK || sqlResult == SQLITE_DONE)
1424         return IDBError { };
1425 
1426     if (sqlResult != SQLITE_ROW) {
1427         // There was an error fetching the record from the database.
1428         LOG_ERROR(&quot;Could not check if key exists in index (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1429         return IDBError { UnknownError, &quot;Error checking for existence of IDBKey in index&quot;_s };
1430     }
1431 
1432     hasRecord = true;
1433     return IDBError { };
1434 }
1435 
1436 IDBError SQLiteIDBBackingStore::uncheckedPutIndexKey(const IDBIndexInfo&amp; info, const IDBKeyData&amp; key, const IndexKey&amp; indexKey, int64_t recordID)
1437 {
</pre>
<hr />
<pre>
1515     if (!transaction || !transaction-&gt;inProgress())
1516         return IDBError { UnknownError, &quot;Attempt to delete index without an in-progress transaction&quot;_s };
1517 
1518     if (transaction-&gt;mode() != IDBTransactionMode::Versionchange) {
1519         LOG_ERROR(&quot;Attempt to delete index during a non-version-change transaction&quot;);
1520         return IDBError { UnknownError, &quot;Attempt to delete index during a non-version-change transaction&quot;_s };
1521     }
1522 
1523     {
1524         auto* sql = cachedStatement(SQL::DeleteIndexInfo, &quot;DELETE FROM IndexInfo WHERE id = ? AND objectStoreID = ?;&quot;_s);
1525         if (!sql
1526             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK
1527             || sql-&gt;bindInt64(2, objectStoreIdentifier) != SQLITE_OK
1528             || sql-&gt;step() != SQLITE_DONE) {
1529             LOG_ERROR(&quot;Could not delete index id %&quot; PRIi64 &quot; from IndexInfo table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1530             return IDBError { UnknownError, &quot;Error deleting index from database&quot;_s };
1531         }
1532     }
1533 
1534     {
<span class="line-modified">1535         auto* sql = cachedStatement(SQL::DeleteIndexRecords, &quot;DELETE FROM IndexRecords WHERE indexID = ?;&quot;_s);</span>
1536         if (!sql
1537             || sql-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK

1538             || sql-&gt;step() != SQLITE_DONE) {
1539             LOG_ERROR(&quot;Could not delete index records for index id %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1540             return IDBError { UnknownError, &quot;Error deleting index records from database&quot;_s };
1541         }
1542     }
1543 
1544     auto* objectStore = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
1545     ASSERT(objectStore);
1546     objectStore-&gt;deleteIndex(indexIdentifier);
1547 
1548     return IDBError { };
1549 }
1550 
1551 IDBError SQLiteIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
1552 {
1553     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::renameIndex - object store %&quot; PRIu64 &quot;, index %&quot; PRIu64, objectStoreIdentifier, indexIdentifier);
1554 
1555     ASSERT(m_sqliteDB);
1556     ASSERT(m_sqliteDB-&gt;isOpen());
1557 
</pre>
<hr />
<pre>
1671 
1672     return IDBError { };
1673 }
1674 
1675 IDBError SQLiteIDBBackingStore::deleteRecord(SQLiteIDBTransaction&amp; transaction, int64_t objectStoreID, const IDBKeyData&amp; keyData)
1676 {
1677     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreID);
1678 
1679     ASSERT(m_sqliteDB);
1680     ASSERT(m_sqliteDB-&gt;isOpen());
1681     ASSERT(transaction.inProgress());
1682     ASSERT(transaction.mode() != IDBTransactionMode::Readonly);
1683     UNUSED_PARAM(transaction);
1684 
1685     RefPtr&lt;SharedBuffer&gt; keyBuffer = serializeIDBKeyData(keyData);
1686     if (!keyBuffer) {
1687         LOG_ERROR(&quot;Unable to serialize IDBKeyData to be removed from the database&quot;);
1688         return IDBError { UnknownError, &quot;Unable to serialize IDBKeyData to be removed from the database&quot;_s };
1689     }
1690 
<span class="line-modified">1691     // Get the record ID and value.</span>
1692     int64_t recordID;
<span class="line-added">1693     ThreadSafeDataBuffer value;</span>
1694     {
<span class="line-modified">1695         auto* sql = cachedStatement(SQL::GetObjectStoreRecord, &quot;SELECT recordID, value FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);</span>
1696 
1697         if (!sql
1698             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1699             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK) {
1700             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1701             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1702         }
1703 
1704         int result = sql-&gt;step();
1705 
1706         // If there&#39;s no record ID, there&#39;s no record to delete.
1707         if (result == SQLITE_DONE)
1708             return IDBError { };
1709 
1710         if (result != SQLITE_ROW) {
1711             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (unable to fetch record ID) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1712             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1713         }
1714 
1715         recordID = sql-&gt;getColumnInt64(0);
<span class="line-added">1716 </span>
<span class="line-added">1717         Vector&lt;uint8_t&gt; valueBuffer;</span>
<span class="line-added">1718         sql-&gt;getColumnBlobAsVector(1, valueBuffer);</span>
<span class="line-added">1719         value = ThreadSafeDataBuffer::create(WTFMove(valueBuffer));</span>
1720     }
1721 
1722     if (recordID &lt; 1) {
1723         LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (record ID is invalid) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1724         return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1725     }
1726 
1727     // Delete the blob records for this object store record.
1728     {
1729         auto* sql = cachedStatement(SQL::DeleteBlobRecord, &quot;DELETE FROM BlobRecords WHERE objectStoreRow = ?;&quot;_s);
1730 
1731         if (!sql
1732             || sql-&gt;bindInt64(1, recordID) != SQLITE_OK
1733             || sql-&gt;step() != SQLITE_DONE) {
1734             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) (Could not delete BlobRecords records) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1735             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1736         }
1737     }
1738 
1739     auto error = deleteUnusedBlobFileRecords(transaction);
1740     if (!error.isNull())
1741         return error;
1742 
1743     // Delete record from object store
1744     {
1745         auto* sql = cachedStatement(SQL::DeleteObjectStoreRecord, &quot;DELETE FROM Records WHERE objectStoreID = ? AND key = CAST(? AS TEXT);&quot;_s);
1746 
1747         if (!sql
1748             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
1749             || sql-&gt;bindBlob(2, keyBuffer-&gt;data(), keyBuffer-&gt;size()) != SQLITE_OK
1750             || sql-&gt;step() != SQLITE_DONE) {
1751             LOG_ERROR(&quot;Could not delete record from object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1752             return IDBError { UnknownError, &quot;Failed to delete record from object store&quot;_s };
1753         }
1754     }
1755 
1756     // Delete record from indexes store
1757     {
<span class="line-modified">1758         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;&quot;_s);</span>
1759 
1760         if (!sql
1761             || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK
<span class="line-modified">1762             || sql-&gt;bindInt64(2, recordID) != SQLITE_OK</span>
1763             || sql-&gt;step() != SQLITE_DONE) {
1764             LOG_ERROR(&quot;Could not delete record from indexes for object store %&quot; PRIi64 &quot; (%i) - %s&quot;, objectStoreID, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
1765             return IDBError { UnknownError, &quot;Failed to delete index entries for object store record&quot;_s };
1766         }
1767     }
1768 
1769     return IDBError { };
1770 }
1771 
1772 IDBError SQLiteIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, const IDBKeyRangeData&amp; keyRange)
1773 {
1774     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteRange - range %s, object store %&quot; PRIu64, keyRange.loggingString().utf8().data(), objectStoreID);
1775 
1776     ASSERT(m_sqliteDB);
1777     ASSERT(m_sqliteDB-&gt;isOpen());
1778 
1779     auto* transaction = m_transactions.get(transactionIdentifier);
1780     if (!transaction || !transaction-&gt;inProgress())
1781         return IDBError { UnknownError, &quot;Attempt to delete range from database without an in-progress transaction&quot;_s };
1782 
</pre>
<hr />
<pre>
1856     if (jsValue.isUndefinedOrNull())
1857         return IDBError { };
1858 
1859     IDBError error;
1860     bool anyRecordsSucceeded = false;
1861     for (auto&amp; index : info.indexMap().values()) {
1862         IndexKey indexKey;
1863         generateIndexKeyForValue(m_serializationContext-&gt;execState(), index, jsValue, indexKey, info.keyPath(), key);
1864 
1865         if (indexKey.isNull())
1866             continue;
1867 
1868         error = uncheckedPutIndexKey(index, key, indexKey, recordID);
1869         if (!error.isNull())
1870             break;
1871 
1872         anyRecordsSucceeded = true;
1873     }
1874 
1875     if (!error.isNull() &amp;&amp; anyRecordsSucceeded) {
<span class="line-modified">1876         auto* sql = cachedStatement(SQL::DeleteObjectStoreIndexRecord, &quot;DELETE FROM IndexRecords WHERE objectStoreID = ? AND objectStoreRecordID = ?;&quot;_s);</span>


1877 
1878         if (!sql
1879             || sql-&gt;bindInt64(1, info.identifier()) != SQLITE_OK
<span class="line-modified">1880             || sql-&gt;bindInt64(2, recordID) != SQLITE_OK</span>
1881             || sql-&gt;step() != SQLITE_DONE) {
1882             LOG_ERROR(&quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;);
1883             return IDBError { UnknownError, &quot;Adding one Index record failed, but failed to remove all others that previously succeeded&quot;_s };
1884         }
1885     }
1886 
1887     return error;
1888 }
1889 
1890 IDBError SQLiteIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
1891 {
1892     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::addRecord - key %s, object store %&quot; PRIu64, keyData.loggingString().utf8().data(), objectStoreInfo.identifier());
1893 
1894     ASSERT(m_sqliteDB);
1895     ASSERT(m_sqliteDB-&gt;isOpen());
1896     ASSERT(value.data().data());
1897     ASSERT(value.blobURLs().size() == value.blobFilePaths().size());
1898 
1899     auto* transaction = m_transactions.get(transactionIdentifier);
1900     if (!transaction || !transaction-&gt;inProgress())
</pre>
<hr />
<pre>
2333         return IDBError { UnknownError, &quot;Cannot open cursor to perform index gets in database&quot;_s };
2334     }
2335 
2336     if (cursor-&gt;didError()) {
2337         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2338         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2339     }
2340 
2341     auto* objectStoreInfo = infoForObjectStore(getAllRecordsData.objectStoreIdentifier);
2342     ASSERT(objectStoreInfo);
2343     result = { getAllRecordsData.getAllType, objectStoreInfo-&gt;keyPath() };
2344 
2345     uint32_t currentCount = 0;
2346     uint32_t targetCount = getAllRecordsData.count ? getAllRecordsData.count.value() : 0;
2347     if (!targetCount)
2348         targetCount = std::numeric_limits&lt;uint32_t&gt;::max();
2349     while (!cursor-&gt;didComplete() &amp;&amp; !cursor-&gt;didError() &amp;&amp; currentCount &lt; targetCount) {
2350         IDBKeyData keyCopy = cursor-&gt;currentPrimaryKey();
2351         result.addKey(WTFMove(keyCopy));
2352         if (getAllRecordsData.getAllType == IndexedDB::GetAllType::Values)
<span class="line-modified">2353             result.addValue(IDBValue(cursor-&gt;currentValue()));</span>
2354 
2355         ++currentCount;
2356         cursor-&gt;advance(1);
2357     }
2358 
2359     if (cursor-&gt;didError()) {
2360         LOG_ERROR(&quot;Cursor failed while looking up index records in database&quot;);
2361         return IDBError { UnknownError, &quot;Cursor failed while looking up index records in database&quot;_s };
2362     }
2363 
2364     return IDBError { };
2365 }
2366 
2367 IDBError SQLiteIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreID, uint64_t indexID, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range, IDBGetResult&amp; getResult)
2368 {
2369     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getIndexRecord - %s&quot;, range.loggingString().utf8().data());
2370 
2371     ASSERT(m_sqliteDB);
2372     ASSERT(m_sqliteDB-&gt;isOpen());
2373 
</pre>
<hr />
<pre>
2380 
2381     auto cursor = transaction-&gt;maybeOpenBackingStoreCursor(objectStoreID, indexID, range);
2382     if (!cursor) {
2383         LOG_ERROR(&quot;Cannot open cursor to perform index get in database&quot;);
2384         return IDBError { UnknownError, &quot;Cannot open cursor to perform index get in database&quot;_s };
2385     }
2386 
2387     if (cursor-&gt;didError()) {
2388         LOG_ERROR(&quot;Cursor failed while looking up index record in database&quot;);
2389         return IDBError { UnknownError, &quot;Cursor failed while looking up index record in database&quot;_s };
2390     }
2391 
2392     if (cursor-&gt;didComplete())
2393         getResult = { };
2394     else {
2395         if (type == IndexedDB::IndexRecordType::Key)
2396             getResult = { cursor-&gt;currentPrimaryKey() };
2397         else {
2398             auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2399             ASSERT(objectStoreInfo);
<span class="line-modified">2400             getResult = { cursor-&gt;currentPrimaryKey(), cursor-&gt;currentPrimaryKey(), IDBValue(cursor-&gt;currentValue()), objectStoreInfo-&gt;keyPath() };</span>
2401         }
2402     }
2403 
2404     return IDBError { };
2405 }
2406 
2407 IDBError SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey(int64_t indexID, int64_t objectStoreID, IndexedDB::IndexRecordType type, const IDBKeyData&amp; key, IDBGetResult&amp; getResult)
2408 {
2409     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::uncheckedGetIndexRecordForOneKey&quot;);
2410 
2411     ASSERT(key.isValid() &amp;&amp; key.type() != IndexedDB::KeyType::Max &amp;&amp; key.type() != IndexedDB::KeyType::Min);
2412 
2413     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);
2414     if (!buffer) {
2415         LOG_ERROR(&quot;Unable to serialize IDBKey to look up one index record&quot;);
2416         return IDBError { UnknownError, &quot;Unable to serialize IDBKey to look up one index record&quot;_s };
2417     }
2418 
<span class="line-modified">2419     auto* sql = cachedStatement(SQL::GetIndexRecordForOneKey, &quot;SELECT IndexRecords.value, Records.value, Records.recordID FROM Records INNER JOIN IndexRecords ON Records.objectStoreID = IndexRecords.objectStoreID AND Records.recordID = IndexRecords.objectStoreRecordID WHERE IndexRecords.indexID = ? AND IndexRecords.key = CAST(? AS TEXT) ORDER BY IndexRecords.key, IndexRecords.value&quot;_s);</span>
2420 
2421     if (!sql
2422         || sql-&gt;bindInt64(1, indexID) != SQLITE_OK
<span class="line-modified">2423         || sql-&gt;bindBlob(2, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>

2424         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2425         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2426     }
2427 
2428     int result = sql-&gt;step();
2429     if (result != SQLITE_ROW &amp;&amp; result != SQLITE_DONE) {
2430         LOG_ERROR(&quot;Unable to lookup index record in database&quot;);
2431         return IDBError { UnknownError, &quot;Unable to lookup index record in database&quot;_s };
2432     }
2433 
2434     if (result == SQLITE_DONE)
2435         return IDBError { };
2436 
2437     IDBKeyData objectStoreKey;
2438     Vector&lt;uint8_t&gt; keyVector;
2439     sql-&gt;getColumnBlobAsVector(0, keyVector);
2440 
2441     if (!deserializeIDBKeyData(keyVector.data(), keyVector.size(), objectStoreKey)) {
2442         LOG_ERROR(&quot;Unable to deserialize key looking up index record in database&quot;);
2443         return IDBError { UnknownError, &quot;Unable to deserialize key looking up index record in database&quot;_s };
</pre>
<hr />
<pre>
2454     int64_t recordID = sql-&gt;getColumnInt64(2);
2455     Vector&lt;String&gt; blobURLs, blobFilePaths;
2456     auto error = getBlobRecordsForObjectStoreRecord(recordID, blobURLs, blobFilePaths);
2457     ASSERT(blobURLs.size() == blobFilePaths.size());
2458 
2459     if (!error.isNull())
2460         return error;
2461 
2462     auto* objectStoreInfo = infoForObjectStore(objectStoreID);
2463     ASSERT(objectStoreInfo);
2464     getResult = { objectStoreKey, objectStoreKey, { ThreadSafeDataBuffer::create(WTFMove(valueVector)), WTFMove(blobURLs), WTFMove(blobFilePaths) }, objectStoreInfo-&gt;keyPath() };
2465     return IDBError { };
2466 }
2467 
2468 IDBError SQLiteIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
2469 {
2470     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::getCount - object store %&quot; PRIu64, objectStoreIdentifier);
2471     ASSERT(m_sqliteDB);
2472     ASSERT(m_sqliteDB-&gt;isOpen());
2473 


2474     auto* transaction = m_transactions.get(transactionIdentifier);
2475     if (!transaction || !transaction-&gt;inProgress())
2476         return IDBError { UnknownError, &quot;Attempt to get count from database without an in-progress transaction&quot;_s };
2477 
<span class="line-modified">2478     outCount = 0;</span>
<span class="line-modified">2479 </span>
<span class="line-modified">2480     auto lowerKey = range.lowerKey.isNull() ? IDBKeyData::minimum() : range.lowerKey;</span>
<span class="line-modified">2481     RefPtr&lt;SharedBuffer&gt; lowerBuffer = serializeIDBKeyData(lowerKey);</span>
<span class="line-added">2482     if (!lowerBuffer) {</span>
<span class="line-added">2483         LOG_ERROR(&quot;Unable to serialize lower IDBKey in lookup range&quot;);</span>
<span class="line-added">2484         return IDBError { UnknownError, &quot;Unable to serialize lower IDBKey in lookup range for count operation&quot;_s };</span>
<span class="line-added">2485     }</span>
<span class="line-added">2486 </span>
<span class="line-added">2487     auto upperKey = range.upperKey.isNull() ? IDBKeyData::maximum() : range.upperKey;</span>
<span class="line-added">2488     RefPtr&lt;SharedBuffer&gt; upperBuffer = serializeIDBKeyData(upperKey);</span>
<span class="line-added">2489     if (!upperBuffer) {</span>
<span class="line-added">2490         LOG_ERROR(&quot;Unable to serialize upper IDBKey in lookup range&quot;);</span>
<span class="line-added">2491         return IDBError { UnknownError, &quot;Unable to serialize upper IDBKey in lookup range for count operation&quot;_s };</span>
<span class="line-added">2492     }</span>
<span class="line-added">2493 </span>
<span class="line-added">2494     SQLiteStatement* statement = nullptr;</span>
<span class="line-added">2495 </span>
<span class="line-added">2496     if (!indexIdentifier) {</span>
<span class="line-added">2497         static const char* const countLowerOpenUpperOpenRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2498         static const char* const countLowerOpenUpperClosedRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2499         static const char* const countLowerClosedUpperOpenRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2500         static const char* const countLowerClosedUpperClosedRecords = &quot;SELECT COUNT(*) FROM Records WHERE objectStoreID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2501 </span>
<span class="line-added">2502         if (range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">2503             statement = cachedStatement(SQL::CountRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenRecords);</span>
<span class="line-added">2504         else if (range.lowerOpen &amp;&amp; !range.upperOpen)</span>
<span class="line-added">2505             statement = cachedStatement(SQL::CountRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedRecords);</span>
<span class="line-added">2506         else if (!range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">2507             statement = cachedStatement(SQL::CountRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenRecords);</span>
<span class="line-added">2508         else</span>
<span class="line-added">2509             statement = cachedStatement(SQL::CountRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedRecords);</span>
<span class="line-added">2510 </span>
<span class="line-added">2511         if (!statement</span>
<span class="line-added">2512             || statement-&gt;bindInt64(1, objectStoreIdentifier) != SQLITE_OK</span>
<span class="line-added">2513             || statement-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK</span>
<span class="line-added">2514             || statement-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">2515             LOG_ERROR(&quot;Could not count records in object store %&quot; PRIi64 &quot; from Records table (%i) - %s&quot;, objectStoreIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">2516             return IDBError { UnknownError, &quot;Unable to count records in object store due to binding failure&quot;_s };</span>
<span class="line-added">2517         }</span>
<span class="line-added">2518     } else {</span>
<span class="line-added">2519         static const char* const countLowerOpenUpperOpenIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt; CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2520         static const char* const countLowerOpenUpperClosedIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt; CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2521         static const char* const countLowerClosedUpperOpenIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt; CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2522         static const char* const countLowerClosedUpperClosedIndexRecords = &quot;SELECT COUNT(*) FROM IndexRecords WHERE indexID = ? AND key &gt;= CAST(? AS TEXT) AND key &lt;= CAST(? AS TEXT);&quot;;</span>
<span class="line-added">2523 </span>
<span class="line-added">2524         if (range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">2525             statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperOpen, countLowerOpenUpperOpenIndexRecords);</span>
<span class="line-added">2526         else if (range.lowerOpen &amp;&amp; !range.upperOpen)</span>
<span class="line-added">2527             statement = cachedStatement(SQL::CountIndexRecordsLowerOpenUpperClosed, countLowerOpenUpperClosedIndexRecords);</span>
<span class="line-added">2528         else if (!range.lowerOpen &amp;&amp; range.upperOpen)</span>
<span class="line-added">2529             statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperOpen, countLowerClosedUpperOpenIndexRecords);</span>
<span class="line-added">2530         else</span>
<span class="line-added">2531             statement = cachedStatement(SQL::CountIndexRecordsLowerClosedUpperClosed, countLowerClosedUpperClosedIndexRecords);</span>
<span class="line-added">2532 </span>
<span class="line-added">2533         if (!statement</span>
<span class="line-added">2534             || statement-&gt;bindInt64(1, indexIdentifier) != SQLITE_OK</span>
<span class="line-added">2535             || statement-&gt;bindBlob(2, lowerBuffer-&gt;data(), lowerBuffer-&gt;size()) != SQLITE_OK</span>
<span class="line-added">2536             || statement-&gt;bindBlob(3, upperBuffer-&gt;data(), upperBuffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">2537             LOG_ERROR(&quot;Could not count records with index %&quot; PRIi64 &quot; from IndexRecords table (%i) - %s&quot;, indexIdentifier, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());</span>
<span class="line-added">2538             return IDBError { UnknownError, &quot;Unable to count records for index due to binding failure&quot;_s };</span>
<span class="line-added">2539         }</span>
2540     }
2541 
<span class="line-modified">2542     if (statement-&gt;step() != SQLITE_ROW)</span>
<span class="line-modified">2543         return IDBError { UnknownError, &quot;Unable to count records&quot;_s };</span>
2544 
<span class="line-added">2545     outCount = statement-&gt;getColumnInt(0);</span>
2546     return IDBError { };
2547 }
2548 
2549 IDBError SQLiteIDBBackingStore::uncheckedGetKeyGeneratorValue(int64_t objectStoreID, uint64_t&amp; outValue)
2550 {
2551     auto* sql = cachedStatement(SQL::GetKeyGeneratorValue, &quot;SELECT currentKey FROM KeyGenerators WHERE objectStoreID = ?;&quot;_s);
2552     if (!sql
2553         || sql-&gt;bindInt64(1, objectStoreID) != SQLITE_OK) {
2554         LOG_ERROR(&quot;Could not retrieve currentKey from KeyGenerators table (%i) - %s&quot;, m_sqliteDB-&gt;lastError(), m_sqliteDB-&gt;lastErrorMsg());
2555         return IDBError { UnknownError, &quot;Error getting current key generator value from database&quot;_s };
2556     }
2557     int result = sql-&gt;step();
2558     if (result != SQLITE_ROW) {
2559         LOG_ERROR(&quot;Could not retreive key generator value for object store, but it should be there.&quot;);
2560         return IDBError { UnknownError, &quot;Error finding current key generator value in database&quot;_s };
2561     }
2562 
2563     int64_t value = sql-&gt;getColumnInt64(0);
2564     if (value &lt; 0)
2565         return IDBError { ConstraintError, &quot;Current key generator value from database is invalid&quot; };
</pre>
<hr />
<pre>
2700 
2701     auto key = data.keyData;
2702     auto primaryKey = data.primaryKeyData;
2703     auto count = data.count;
2704 
2705     if (key.isValid()) {
2706         if (!cursor-&gt;iterate(key, primaryKey)) {
2707             LOG_ERROR(&quot;Attempt to iterate cursor failed&quot;);
2708             return IDBError { UnknownError, &quot;Attempt to iterate cursor failed&quot;_s };
2709         }
2710     } else {
2711         ASSERT(!primaryKey.isValid());
2712         if (!count)
2713             count = 1;
2714         if (!cursor-&gt;advance(count)) {
2715             LOG_ERROR(&quot;Attempt to advance cursor failed&quot;);
2716             return IDBError { UnknownError, &quot;Attempt to advance cursor failed&quot;_s };
2717         }
2718     }
2719 
<span class="line-modified">2720     if (data.option == IndexedDB::CursorIterateOption::Reply) {</span>
<span class="line-modified">2721         auto* objectStoreInfo = infoForObjectStore(cursor-&gt;objectStoreID());</span>
<span class="line-modified">2722         ASSERT(objectStoreInfo);</span>


2723 
<span class="line-modified">2724         bool shouldPrefetch = key.isNull() &amp;&amp; primaryKey.isNull();</span>
<span class="line-modified">2725         if (shouldPrefetch)</span>
<span class="line-modified">2726             cursor-&gt;prefetch();</span>
2727 
<span class="line-modified">2728         cursor-&gt;currentData(result, objectStoreInfo-&gt;keyPath(), shouldPrefetch ? SQLiteIDBCursor::ShouldIncludePrefetchedRecords::Yes : SQLiteIDBCursor::ShouldIncludePrefetchedRecords::No);</span>
<span class="line-modified">2729     }</span>






2730 
<span class="line-modified">2731     return IDBError { };</span>
2732 }
2733 
2734 IDBObjectStoreInfo* SQLiteIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
2735 {
2736     ASSERT(m_databaseInfo);
2737     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
2738 }
2739 
2740 void SQLiteIDBBackingStore::deleteBackingStore()
2741 {
2742     String dbFilename = fullDatabasePath();
2743 
2744     LOG(IndexedDB, &quot;SQLiteIDBBackingStore::deleteBackingStore deleting file &#39;%s&#39; on disk&quot;, dbFilename.utf8().data());
2745 
2746     Vector&lt;String&gt; blobFiles;
2747     {
2748         bool errored = true;
2749 
2750         if (m_sqliteDB) {
2751             SQLiteStatement sql(*m_sqliteDB, &quot;SELECT fileName FROM BlobFiles;&quot;_s);
</pre>
<hr />
<pre>
2770         if (!FileSystem::deleteFile(fullPath))
2771             LOG_ERROR(&quot;Error deleting blob file %s&quot;, fullPath.utf8().data());
2772     }
2773 
2774     if (m_sqliteDB)
2775         closeSQLiteDB();
2776 
2777     SQLiteFileSystem::deleteDatabaseFile(dbFilename);
2778     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_databaseDirectory);
2779     SQLiteFileSystem::deleteEmptyDatabaseDirectory(m_identifier.databaseDirectoryRelativeToRoot(databaseRootDirectoryIsolatedCopy()));
2780 }
2781 
2782 void SQLiteIDBBackingStore::unregisterCursor(SQLiteIDBCursor&amp; cursor)
2783 {
2784     ASSERT(m_cursors.contains(cursor.identifier()));
2785     m_cursors.remove(cursor.identifier());
2786 }
2787 
2788 SQLiteStatement* SQLiteIDBBackingStore::cachedStatement(SQLiteIDBBackingStore::SQL sql, const char* statement)
2789 {
<span class="line-modified">2790     if (sql &gt;= SQL::Invalid) {</span>
2791         LOG_ERROR(&quot;Invalid SQL statement ID passed to cachedStatement()&quot;);
2792         return nullptr;
2793     }
2794 
2795     if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]) {
2796         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;reset() == SQLITE_OK)
2797             return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2798         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2799     }
2800 
2801     if (m_sqliteDB) {
2802         m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = makeUnique&lt;SQLiteStatement&gt;(*m_sqliteDB, statement);
2803         if (m_cachedStatements[static_cast&lt;size_t&gt;(sql)]-&gt;prepare() != SQLITE_OK)
2804             m_cachedStatements[static_cast&lt;size_t&gt;(sql)] = nullptr;
2805     }
2806 
2807     return m_cachedStatements[static_cast&lt;size_t&gt;(sql)].get();
2808 }
2809 
2810 void SQLiteIDBBackingStore::close()
2811 {
2812     closeSQLiteDB();
2813 }
2814 
2815 void SQLiteIDBBackingStore::closeSQLiteDB()
2816 {
<span class="line-modified">2817     for (size_t i = 0; i &lt; static_cast&lt;int&gt;(SQL::Invalid); ++i)</span>
2818         m_cachedStatements[i] = nullptr;
2819 
2820     if (m_sqliteDB)
2821         m_sqliteDB-&gt;close();
2822 
2823     m_sqliteDB = nullptr;
2824 }
2825 
2826 bool SQLiteIDBBackingStore::hasTransaction(const IDBResourceIdentifier&amp; transactionIdentifier) const
2827 {
2828     ASSERT(isMainThread());
2829     return m_transactions.contains(transactionIdentifier);
2830 }
2831 
2832 } // namespace IDBServer
2833 } // namespace WebCore
2834 
2835 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="MemoryIDBBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBBackingStore.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkStatus.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallLinkInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallLinkStatus.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkStatus.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CallLinkStatus.h&quot;
 28 
 29 #include &quot;BytecodeStructs.h&quot;
 30 #include &quot;CallLinkInfo.h&quot;
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;InlineCallFrame.h&quot;
 34 #include &quot;InterpreterInlines.h&quot;
 35 #include &quot;LLIntCallLinkInfo.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &lt;wtf/CommaPrinter.h&gt;
 38 #include &lt;wtf/ListDump.h&gt;
 39 
 40 namespace JSC {
 41 
 42 namespace CallLinkStatusInternal {
<span class="line-modified"> 43 static const bool verbose = false;</span>
 44 }
 45 
 46 CallLinkStatus::CallLinkStatus(JSValue value)
 47     : m_couldTakeSlowPath(false)
 48     , m_isProved(false)
 49 {
 50     if (!value || !value.isCell()) {
 51         m_couldTakeSlowPath = true;
 52         return;
 53     }
 54 
 55     m_variants.append(CallVariant(value.asCell()));
 56 }
 57 
<span class="line-modified"> 58 CallLinkStatus CallLinkStatus::computeFromLLInt(const ConcurrentJSLocker&amp;, CodeBlock* profiledBlock, unsigned bytecodeIndex)</span>
 59 {
 60     UNUSED_PARAM(profiledBlock);
 61     UNUSED_PARAM(bytecodeIndex);
 62 #if ENABLE(DFG_JIT)
 63     if (profiledBlock-&gt;unlinkedCodeBlock()-&gt;hasExitSite(DFG::FrequentExitSite(bytecodeIndex, BadCell))) {
 64         // We could force this to be a closure call, but instead we&#39;ll just assume that it
 65         // takes slow path.
 66         return takesSlowPath();
 67     }
 68 #endif
 69 
<span class="line-modified"> 70     auto instruction = profiledBlock-&gt;instructions().at(bytecodeIndex);</span>
 71     OpcodeID op = instruction-&gt;opcodeID();
 72 
 73     LLIntCallLinkInfo* callLinkInfo;
 74     switch (op) {
 75     case op_call:
 76         callLinkInfo = &amp;instruction-&gt;as&lt;OpCall&gt;().metadata(profiledBlock).m_callLinkInfo;
 77         break;
 78     case op_construct:
 79         callLinkInfo = &amp;instruction-&gt;as&lt;OpConstruct&gt;().metadata(profiledBlock).m_callLinkInfo;
 80         break;
 81     case op_tail_call:
 82         callLinkInfo = &amp;instruction-&gt;as&lt;OpTailCall&gt;().metadata(profiledBlock).m_callLinkInfo;
 83         break;
 84     default:
 85         return CallLinkStatus();
 86     }
 87 
 88 
 89     return CallLinkStatus(callLinkInfo-&gt;lastSeenCallee());
 90 }
 91 
 92 CallLinkStatus CallLinkStatus::computeFor(
<span class="line-modified"> 93     CodeBlock* profiledBlock, unsigned bytecodeIndex, const ICStatusMap&amp; map,</span>
 94     ExitSiteData exitSiteData)
 95 {
 96     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
 97 
 98     UNUSED_PARAM(profiledBlock);
 99     UNUSED_PARAM(bytecodeIndex);
100     UNUSED_PARAM(map);
101     UNUSED_PARAM(exitSiteData);
102 #if ENABLE(DFG_JIT)
103     CallLinkInfo* callLinkInfo = map.get(CodeOrigin(bytecodeIndex)).callLinkInfo;
104     if (!callLinkInfo) {
105         if (exitSiteData.takesSlowPath)
106             return takesSlowPath();
107         return computeFromLLInt(locker, profiledBlock, bytecodeIndex);
108     }
109 
110     return computeFor(locker, profiledBlock, *callLinkInfo, exitSiteData);
111 #else
112     return CallLinkStatus();
113 #endif
114 }
115 
116 CallLinkStatus CallLinkStatus::computeFor(
<span class="line-modified">117     CodeBlock* profiledBlock, unsigned bytecodeIndex, const ICStatusMap&amp; map)</span>
118 {
119     return computeFor(profiledBlock, bytecodeIndex, map, computeExitSiteData(profiledBlock, bytecodeIndex));
120 }
121 
<span class="line-modified">122 CallLinkStatus::ExitSiteData CallLinkStatus::computeExitSiteData(CodeBlock* profiledBlock, unsigned bytecodeIndex)</span>
123 {
124     ExitSiteData exitSiteData;
125 #if ENABLE(DFG_JIT)
126     UnlinkedCodeBlock* codeBlock = profiledBlock-&gt;unlinkedCodeBlock();
127     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
128 
129     auto takesSlowPath = [&amp;] (ExitingInlineKind inlineKind) -&gt; ExitFlag {
130         return ExitFlag(
131             codeBlock-&gt;hasExitSite(locker, DFG::FrequentExitSite(bytecodeIndex, BadType, ExitFromAnything, inlineKind))
132             || codeBlock-&gt;hasExitSite(locker, DFG::FrequentExitSite(bytecodeIndex, BadExecutable, ExitFromAnything, inlineKind)),
133             inlineKind);
134     };
135 
136     auto badFunction = [&amp;] (ExitingInlineKind inlineKind) -&gt; ExitFlag {
137         return ExitFlag(codeBlock-&gt;hasExitSite(locker, DFG::FrequentExitSite(bytecodeIndex, BadCell, ExitFromAnything, inlineKind)), inlineKind);
138     };
139 
140     exitSiteData.takesSlowPath |= takesSlowPath(ExitFromNotInlined);
141     exitSiteData.takesSlowPath |= takesSlowPath(ExitFromInlined);
142     exitSiteData.badFunction |= badFunction(ExitFromNotInlined);
143     exitSiteData.badFunction |= badFunction(ExitFromInlined);
144 #else
145     UNUSED_PARAM(profiledBlock);
146     UNUSED_PARAM(bytecodeIndex);
147 #endif
148 
149     return exitSiteData;
150 }
151 
152 #if ENABLE(JIT)
153 CallLinkStatus CallLinkStatus::computeFor(
154     const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, CallLinkInfo&amp; callLinkInfo)
155 {
156     // We don&#39;t really need this, but anytime we have to debug this code, it becomes indispensable.
157     UNUSED_PARAM(profiledBlock);
158 
159     CallLinkStatus result = computeFromCallLinkInfo(locker, callLinkInfo);
<span class="line-modified">160     result.m_maxNumArguments = callLinkInfo.maxNumArguments();</span>
161     return result;
162 }
163 
164 CallLinkStatus CallLinkStatus::computeFromCallLinkInfo(
165     const ConcurrentJSLocker&amp;, CallLinkInfo&amp; callLinkInfo)
166 {
167     // We cannot tell you anything about direct calls.
168     if (callLinkInfo.isDirect())
169         return CallLinkStatus();
170 
171     if (callLinkInfo.clearedByGC() || callLinkInfo.clearedByVirtual())
172         return takesSlowPath();
173 
174     // Note that despite requiring that the locker is held, this code is racy with respect
175     // to the CallLinkInfo: it may get cleared while this code runs! This is because
176     // CallLinkInfo::unlink() may be called from a different CodeBlock than the one that owns
177     // the CallLinkInfo and currently we save space by not having CallLinkInfos know who owns
178     // them. So, there is no way for either the caller of CallLinkInfo::unlock() or unlock()
179     // itself to figure out which lock to lock.
180     //
</pre>
<hr />
<pre>
457 {
458     if (!isSet()) {
459         out.print(&quot;Not Set&quot;);
460         return;
461     }
462 
463     CommaPrinter comma;
464 
465     if (m_isProved)
466         out.print(comma, &quot;Statically Proved&quot;);
467 
468     if (m_couldTakeSlowPath)
469         out.print(comma, &quot;Could Take Slow Path&quot;);
470 
471     if (m_isBasedOnStub)
472         out.print(comma, &quot;Based On Stub&quot;);
473 
474     if (!m_variants.isEmpty())
475         out.print(comma, listDump(m_variants));
476 
<span class="line-modified">477     if (m_maxNumArguments)</span>
<span class="line-modified">478         out.print(comma, &quot;maxNumArguments = &quot;, m_maxNumArguments);</span>
479 }
480 
481 } // namespace JSC
482 
</pre>
</td>
<td>
<hr />
<pre>
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CallLinkStatus.h&quot;
 28 
 29 #include &quot;BytecodeStructs.h&quot;
 30 #include &quot;CallLinkInfo.h&quot;
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;InlineCallFrame.h&quot;
 34 #include &quot;InterpreterInlines.h&quot;
 35 #include &quot;LLIntCallLinkInfo.h&quot;
 36 #include &quot;JSCInlines.h&quot;
 37 #include &lt;wtf/CommaPrinter.h&gt;
 38 #include &lt;wtf/ListDump.h&gt;
 39 
 40 namespace JSC {
 41 
 42 namespace CallLinkStatusInternal {
<span class="line-modified"> 43 static constexpr bool verbose = false;</span>
 44 }
 45 
 46 CallLinkStatus::CallLinkStatus(JSValue value)
 47     : m_couldTakeSlowPath(false)
 48     , m_isProved(false)
 49 {
 50     if (!value || !value.isCell()) {
 51         m_couldTakeSlowPath = true;
 52         return;
 53     }
 54 
 55     m_variants.append(CallVariant(value.asCell()));
 56 }
 57 
<span class="line-modified"> 58 CallLinkStatus CallLinkStatus::computeFromLLInt(const ConcurrentJSLocker&amp;, CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex)</span>
 59 {
 60     UNUSED_PARAM(profiledBlock);
 61     UNUSED_PARAM(bytecodeIndex);
 62 #if ENABLE(DFG_JIT)
 63     if (profiledBlock-&gt;unlinkedCodeBlock()-&gt;hasExitSite(DFG::FrequentExitSite(bytecodeIndex, BadCell))) {
 64         // We could force this to be a closure call, but instead we&#39;ll just assume that it
 65         // takes slow path.
 66         return takesSlowPath();
 67     }
 68 #endif
 69 
<span class="line-modified"> 70     auto instruction = profiledBlock-&gt;instructions().at(bytecodeIndex.offset());</span>
 71     OpcodeID op = instruction-&gt;opcodeID();
 72 
 73     LLIntCallLinkInfo* callLinkInfo;
 74     switch (op) {
 75     case op_call:
 76         callLinkInfo = &amp;instruction-&gt;as&lt;OpCall&gt;().metadata(profiledBlock).m_callLinkInfo;
 77         break;
 78     case op_construct:
 79         callLinkInfo = &amp;instruction-&gt;as&lt;OpConstruct&gt;().metadata(profiledBlock).m_callLinkInfo;
 80         break;
 81     case op_tail_call:
 82         callLinkInfo = &amp;instruction-&gt;as&lt;OpTailCall&gt;().metadata(profiledBlock).m_callLinkInfo;
 83         break;
 84     default:
 85         return CallLinkStatus();
 86     }
 87 
 88 
 89     return CallLinkStatus(callLinkInfo-&gt;lastSeenCallee());
 90 }
 91 
 92 CallLinkStatus CallLinkStatus::computeFor(
<span class="line-modified"> 93     CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex, const ICStatusMap&amp; map,</span>
 94     ExitSiteData exitSiteData)
 95 {
 96     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
 97 
 98     UNUSED_PARAM(profiledBlock);
 99     UNUSED_PARAM(bytecodeIndex);
100     UNUSED_PARAM(map);
101     UNUSED_PARAM(exitSiteData);
102 #if ENABLE(DFG_JIT)
103     CallLinkInfo* callLinkInfo = map.get(CodeOrigin(bytecodeIndex)).callLinkInfo;
104     if (!callLinkInfo) {
105         if (exitSiteData.takesSlowPath)
106             return takesSlowPath();
107         return computeFromLLInt(locker, profiledBlock, bytecodeIndex);
108     }
109 
110     return computeFor(locker, profiledBlock, *callLinkInfo, exitSiteData);
111 #else
112     return CallLinkStatus();
113 #endif
114 }
115 
116 CallLinkStatus CallLinkStatus::computeFor(
<span class="line-modified">117     CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex, const ICStatusMap&amp; map)</span>
118 {
119     return computeFor(profiledBlock, bytecodeIndex, map, computeExitSiteData(profiledBlock, bytecodeIndex));
120 }
121 
<span class="line-modified">122 CallLinkStatus::ExitSiteData CallLinkStatus::computeExitSiteData(CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex)</span>
123 {
124     ExitSiteData exitSiteData;
125 #if ENABLE(DFG_JIT)
126     UnlinkedCodeBlock* codeBlock = profiledBlock-&gt;unlinkedCodeBlock();
127     ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
128 
129     auto takesSlowPath = [&amp;] (ExitingInlineKind inlineKind) -&gt; ExitFlag {
130         return ExitFlag(
131             codeBlock-&gt;hasExitSite(locker, DFG::FrequentExitSite(bytecodeIndex, BadType, ExitFromAnything, inlineKind))
132             || codeBlock-&gt;hasExitSite(locker, DFG::FrequentExitSite(bytecodeIndex, BadExecutable, ExitFromAnything, inlineKind)),
133             inlineKind);
134     };
135 
136     auto badFunction = [&amp;] (ExitingInlineKind inlineKind) -&gt; ExitFlag {
137         return ExitFlag(codeBlock-&gt;hasExitSite(locker, DFG::FrequentExitSite(bytecodeIndex, BadCell, ExitFromAnything, inlineKind)), inlineKind);
138     };
139 
140     exitSiteData.takesSlowPath |= takesSlowPath(ExitFromNotInlined);
141     exitSiteData.takesSlowPath |= takesSlowPath(ExitFromInlined);
142     exitSiteData.badFunction |= badFunction(ExitFromNotInlined);
143     exitSiteData.badFunction |= badFunction(ExitFromInlined);
144 #else
145     UNUSED_PARAM(profiledBlock);
146     UNUSED_PARAM(bytecodeIndex);
147 #endif
148 
149     return exitSiteData;
150 }
151 
152 #if ENABLE(JIT)
153 CallLinkStatus CallLinkStatus::computeFor(
154     const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, CallLinkInfo&amp; callLinkInfo)
155 {
156     // We don&#39;t really need this, but anytime we have to debug this code, it becomes indispensable.
157     UNUSED_PARAM(profiledBlock);
158 
159     CallLinkStatus result = computeFromCallLinkInfo(locker, callLinkInfo);
<span class="line-modified">160     result.m_maxArgumentCountIncludingThis = callLinkInfo.maxArgumentCountIncludingThis();</span>
161     return result;
162 }
163 
164 CallLinkStatus CallLinkStatus::computeFromCallLinkInfo(
165     const ConcurrentJSLocker&amp;, CallLinkInfo&amp; callLinkInfo)
166 {
167     // We cannot tell you anything about direct calls.
168     if (callLinkInfo.isDirect())
169         return CallLinkStatus();
170 
171     if (callLinkInfo.clearedByGC() || callLinkInfo.clearedByVirtual())
172         return takesSlowPath();
173 
174     // Note that despite requiring that the locker is held, this code is racy with respect
175     // to the CallLinkInfo: it may get cleared while this code runs! This is because
176     // CallLinkInfo::unlink() may be called from a different CodeBlock than the one that owns
177     // the CallLinkInfo and currently we save space by not having CallLinkInfos know who owns
178     // them. So, there is no way for either the caller of CallLinkInfo::unlock() or unlock()
179     // itself to figure out which lock to lock.
180     //
</pre>
<hr />
<pre>
457 {
458     if (!isSet()) {
459         out.print(&quot;Not Set&quot;);
460         return;
461     }
462 
463     CommaPrinter comma;
464 
465     if (m_isProved)
466         out.print(comma, &quot;Statically Proved&quot;);
467 
468     if (m_couldTakeSlowPath)
469         out.print(comma, &quot;Could Take Slow Path&quot;);
470 
471     if (m_isBasedOnStub)
472         out.print(comma, &quot;Based On Stub&quot;);
473 
474     if (!m_variants.isEmpty())
475         out.print(comma, listDump(m_variants));
476 
<span class="line-modified">477     if (m_maxArgumentCountIncludingThis)</span>
<span class="line-modified">478         out.print(comma, &quot;maxArgumentCountIncludingThis = &quot;, m_maxArgumentCountIncludingThis);</span>
479 }
480 
481 } // namespace JSC
482 
</pre>
</td>
</tr>
</table>
<center><a href="CallLinkInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallLinkStatus.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
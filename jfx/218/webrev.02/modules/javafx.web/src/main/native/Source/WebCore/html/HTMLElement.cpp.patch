diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.cpp
@@ -32,10 +32,11 @@
 #include "Chrome.h"
 #include "ChromeClient.h"
 #include "DOMTokenList.h"
 #include "DocumentFragment.h"
 #include "ElementAncestorIterator.h"
+#include "EnterKeyHint.h"
 #include "Event.h"
 #include "EventListener.h"
 #include "EventNames.h"
 #include "Frame.h"
 #include "FrameLoader.h"
@@ -111,11 +112,11 @@
     return hasTagName(tableTag) ? 1 : 0;
 }
 
 void HTMLElement::applyBorderAttributeToStyle(const AtomString& value, MutableStyleProperties& style)
 {
-    addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSPrimitiveValue::CSS_PX);
+    addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderWidth, parseBorderWidthAttribute(value), CSSUnitType::CSS_PX);
     addPropertyToPresentationAttributeStyle(style, CSSPropertyBorderStyle, CSSValueSolid);
 }
 
 void HTMLElement::mapLanguageAttributeToLocale(const AtomString& value, MutableStyleProperties& style)
 {
@@ -730,22 +731,22 @@
 void HTMLElement::setTranslate(bool enable)
 {
     setAttributeWithoutSynchronization(translateAttr, enable ? "yes" : "no");
 }
 
-bool HTMLElement::rendererIsNeeded(const RenderStyle& style)
+bool HTMLElement::rendererIsEverNeeded()
 {
     if (hasTagName(noscriptTag)) {
         RefPtr<Frame> frame = document().frame();
         if (frame && frame->script().canExecuteScripts(NotAboutToExecuteScript))
             return false;
     } else if (hasTagName(noembedTag)) {
         RefPtr<Frame> frame = document().frame();
         if (frame && frame->loader().subframeLoader().allowPlugins())
             return false;
     }
-    return StyledElement::rendererIsNeeded(style);
+    return StyledElement::rendererIsEverNeeded();
 }
 
 RenderPtr<RenderElement> HTMLElement::createElementRenderer(RenderStyle&& style, const RenderTreePosition&)
 {
     return RenderElement::createFor(*this, WTFMove(style));
@@ -1066,11 +1067,11 @@
 bool HTMLElement::isActuallyDisabled() const
 {
     return canBeActuallyDisabled() && isDisabledFormControl();
 }
 
-#if ENABLE(IOS_AUTOCORRECT_AND_AUTOCAPITALIZE)
+#if ENABLE(AUTOCAPITALIZE)
 
 const AtomString& HTMLElement::autocapitalize() const
 {
     return stringForAutocapitalizeType(autocapitalizeType());
 }
@@ -1083,10 +1084,14 @@
 void HTMLElement::setAutocapitalize(const AtomString& value)
 {
     setAttributeWithoutSynchronization(autocapitalizeAttr, value);
 }
 
+#endif
+
+#if ENABLE(AUTOCORRECT)
+
 bool HTMLElement::shouldAutocorrect() const
 {
     auto& autocorrectValue = attributeWithoutSynchronization(HTMLNames::autocorrectAttr);
     // Unrecognized values fall back to "on".
     return !equalLettersIgnoringASCIICase(autocorrectValue, "off");
@@ -1117,10 +1122,25 @@
 void HTMLElement::setInputMode(const AtomString& value)
 {
     setAttributeWithoutSynchronization(inputmodeAttr, value);
 }
 
+EnterKeyHint HTMLElement::canonicalEnterKeyHint() const
+{
+    return enterKeyHintForAttributeValue(attributeWithoutSynchronization(enterkeyhintAttr));
+}
+
+String HTMLElement::enterKeyHint() const
+{
+    return attributeValueForEnterKeyHint(canonicalEnterKeyHint());
+}
+
+void HTMLElement::setEnterKeyHint(const String& value)
+{
+    setAttributeWithoutSynchronization(enterkeyhintAttr, value);
+}
+
 } // namespace WebCore
 
 #ifndef NDEBUG
 
 // For use in the debugger

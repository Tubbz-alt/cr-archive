<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RadioButtonGroups.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Range.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Range.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 474,31 ***</span>
  ExceptionOr&lt;bool&gt; Range::intersectsNode(Node&amp; refNode) const
  {
      if (!refNode.isConnected() || &amp;refNode.document() != &amp;ownerDocument())
          return false;
  
<span class="line-modified">!     ContainerNode* parentNode = refNode.parentNode();</span>
      if (!parentNode)
          return true;
  
      unsigned nodeIndex = refNode.computeNodeIndex();
  
<span class="line-modified">!     // If (parent, offset) is before end and (parent, offset + 1) is after start, return true.</span>
      // Otherwise, return false.
<span class="line-modified">!     auto result = comparePoint(*parentNode, nodeIndex);</span>
<span class="line-modified">!     if (result.hasException())</span>
<span class="line-modified">!         return result.releaseException();</span>
<span class="line-modified">!     auto compareFirst = result.releaseReturnValue();</span>
<span class="line-modified">!     result = comparePoint(*parentNode, nodeIndex + 1);</span>
<span class="line-modified">!     if (result.hasException())</span>
<span class="line-modified">!         return result.releaseException();</span>
<span class="line-removed">-     auto compareSecond = result.releaseReturnValue();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool isFirstBeforeEnd = m_start == m_end ? compareFirst &lt; 0 : compareFirst &lt;= 0;</span>
<span class="line-removed">-     bool isSecondAfterStart = m_start == m_end ? compareSecond &gt; 0 : compareSecond &gt;= 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return isFirstBeforeEnd &amp;&amp; isSecondAfterStart;</span>
  }
  
  static inline Node* highestAncestorUnderCommonRoot(Node* node, Node* commonRoot)
  {
      if (node == commonRoot)
<span class="line-new-header">--- 474,25 ---</span>
  ExceptionOr&lt;bool&gt; Range::intersectsNode(Node&amp; refNode) const
  {
      if (!refNode.isConnected() || &amp;refNode.document() != &amp;ownerDocument())
          return false;
  
<span class="line-modified">!     auto* parentNode = refNode.parentNode();</span>
      if (!parentNode)
          return true;
  
      unsigned nodeIndex = refNode.computeNodeIndex();
  
<span class="line-modified">!     // If (parentNode, nodeIndex) is before end and (parentNode, nodeIndex + 1) is after start, return true.</span>
      // Otherwise, return false.
<span class="line-modified">!     auto compareEndResult = compareBoundaryPoints(parentNode, nodeIndex, m_end.container(), m_end.offset());</span>
<span class="line-modified">!     if (compareEndResult.hasException())</span>
<span class="line-modified">!         return compareEndResult.releaseException();</span>
<span class="line-modified">!     auto compareStartResult = compareBoundaryPoints(parentNode, nodeIndex + 1, m_start.container(), m_start.offset());</span>
<span class="line-modified">!     if (compareStartResult.hasException())</span>
<span class="line-modified">!         return compareStartResult.releaseException();</span>
<span class="line-modified">!     return compareEndResult.returnValue() == -1 &amp;&amp; compareStartResult.returnValue() == 1;</span>
  }
  
  static inline Node* highestAncestorUnderCommonRoot(Node* node, Node* commonRoot)
  {
      if (node == commonRoot)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 940,15 ***</span>
  
      Node* pastLast = pastLastNode();
      for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
          auto type = node-&gt;nodeType();
          if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
<span class="line-modified">!             auto&amp; data = downcast&lt;CharacterData&gt;(*node).data();</span>
<span class="line-modified">!             unsigned length = data.length();</span>
<span class="line-modified">!             unsigned start = node == &amp;startContainer() ? std::min(m_start.offset(), length) : 0U;</span>
<span class="line-removed">-             unsigned end = node == &amp;endContainer() ? std::min(std::max(start, m_end.offset()), length) : length;</span>
<span class="line-removed">-             builder.appendSubstring(data, start, end - start);</span>
          }
      }
  
      return builder.toString();
  }
<span class="line-new-header">--- 934,13 ---</span>
  
      Node* pastLast = pastLastNode();
      for (Node* node = firstNode(); node != pastLast; node = NodeTraversal::next(*node)) {
          auto type = node-&gt;nodeType();
          if (type == Node::TEXT_NODE || type == Node::CDATA_SECTION_NODE) {
<span class="line-modified">!             unsigned start = node == &amp;startContainer() ? m_start.offset() : 0U;</span>
<span class="line-modified">!             unsigned end = node == &amp;endContainer() ? std::max(start, m_end.offset()) : std::numeric_limits&lt;unsigned&gt;::max();</span>
<span class="line-modified">!             builder.appendSubstring(downcast&lt;CharacterData&gt;(*node).data(), start, end - start);</span>
          }
      }
  
      return builder.toString();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1149,26 ***</span>
      if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
          return child;
      return NodeTraversal::nextSkippingChildren(endContainer());
  }
  
<span class="line-modified">! IntRect Range::absoluteBoundingBox() const</span>
  {
      IntRect result;
      Vector&lt;IntRect&gt; rects;
<span class="line-modified">!     absoluteTextRects(rects);</span>
      for (auto&amp; rect : rects)
          result.unite(rect);
      return result;
  }
  
  Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
  {
      unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
      unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
  
<span class="line-modified">!     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &amp;isFixed);</span>
  
      if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {
          Vector&lt;FloatRect&gt; clippedRects;
          clippedRects.reserveInitialCapacity(textQuads.size());
  
<span class="line-new-header">--- 1141,28 ---</span>
      if (Node* child = endContainer().traverseToChildAt(m_end.offset()))
          return child;
      return NodeTraversal::nextSkippingChildren(endContainer());
  }
  
<span class="line-modified">! IntRect Range::absoluteBoundingBox(OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const</span>
  {
      IntRect result;
      Vector&lt;IntRect&gt; rects;
<span class="line-modified">!     bool useSelectionHeight = false;</span>
<span class="line-added">+     RangeInFixedPosition* inFixed = nullptr;</span>
<span class="line-added">+     absoluteTextRects(rects, useSelectionHeight, inFixed, rectOptions);</span>
      for (auto&amp; rect : rects)
          result.unite(rect);
      return result;
  }
  
  Vector&lt;FloatRect&gt; Range::absoluteRectsForRangeInText(Node* node, RenderText&amp; renderText, bool useSelectionHeight, bool&amp; isFixed, OptionSet&lt;BoundingRectBehavior&gt; rectOptions) const
  {
      unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
      unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
  
<span class="line-modified">!     auto textQuads = renderText.absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, rectOptions.contains(BoundingRectBehavior::IgnoreEmptyTextSelections), &amp;isFixed);</span>
  
      if (rectOptions.contains(BoundingRectBehavior::RespectClipping)) {
          Vector&lt;FloatRect&gt; clippedRects;
          clippedRects.reserveInitialCapacity(textQuads.size());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,11 ***</span>
          if (renderer-&gt;isBR())
              renderer-&gt;absoluteQuads(quads, &amp;isFixed);
          else if (is&lt;RenderText&gt;(*renderer)) {
              unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
              unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
<span class="line-modified">!             quads.appendVector(downcast&lt;RenderText&gt;(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, &amp;isFixed));</span>
          } else
              continue;
          allFixed &amp;= isFixed;
          someFixed |= isFixed;
      }
<span class="line-new-header">--- 1227,11 ---</span>
          if (renderer-&gt;isBR())
              renderer-&gt;absoluteQuads(quads, &amp;isFixed);
          else if (is&lt;RenderText&gt;(*renderer)) {
              unsigned startOffset = node == &amp;startContainer() ? m_start.offset() : 0;
              unsigned endOffset = node == &amp;endContainer() ? m_end.offset() : std::numeric_limits&lt;unsigned&gt;::max();
<span class="line-modified">!             quads.appendVector(downcast&lt;RenderText&gt;(*renderer).absoluteQuadsForRange(startOffset, endOffset, useSelectionHeight, false /* ignoreEmptyTextSelections */, &amp;isFixed));</span>
          } else
              continue;
          allFixed &amp;= isFixed;
          someFixed |= isFixed;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1571,11 ***</span>
          return false;
  
      if (a == b)
          return true;
  
<span class="line-modified">!     if (a-&gt;commonAncestorContainer()-&gt;ownerDocument() != b-&gt;commonAncestorContainer()-&gt;ownerDocument())</span>
          return false;
  
      short startToStart = a-&gt;compareBoundaryPoints(Range::START_TO_START, *b).releaseReturnValue();
      short endToEnd = a-&gt;compareBoundaryPoints(Range::END_TO_END, *b).releaseReturnValue();
  
<span class="line-new-header">--- 1565,11 ---</span>
          return false;
  
      if (a == b)
          return true;
  
<span class="line-modified">!     if (!areNodesConnectedInSameTreeScope(a-&gt;commonAncestorContainer(), b-&gt;commonAncestorContainer()))</span>
          return false;
  
      short startToStart = a-&gt;compareBoundaryPoints(Range::START_TO_START, *b).releaseReturnValue();
      short endToEnd = a-&gt;compareBoundaryPoints(Range::END_TO_END, *b).releaseReturnValue();
  
</pre>
<center><a href="RadioButtonGroups.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Range.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
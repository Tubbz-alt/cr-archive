<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerRegistration.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;DOMWindow.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;JSDOMPromiseDeferred.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;ServiceWorker.h&quot;
 37 #include &quot;ServiceWorkerContainer.h&quot;
 38 #include &quot;ServiceWorkerTypes.h&quot;
 39 #include &quot;WorkerGlobalScope.h&quot;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 #define REGISTRATION_RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(m_container-&gt;isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerRegistration::&quot; fmt, this, ##__VA_ARGS__)
 43 #define REGISTRATION_RELEASE_LOG_ERROR_IF_ALLOWED(fmt, ...) RELEASE_LOG_ERROR_IF(m_container-&gt;isAlwaysOnLoggingAllowed(), ServiceWorker, &quot;%p - ServiceWorkerRegistration::&quot; fmt, this, ##__VA_ARGS__)
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerRegistration);
 48 
 49 Ref&lt;ServiceWorkerRegistration&gt; ServiceWorkerRegistration::getOrCreate(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; data)
 50 {
 51     if (auto* registration = container-&gt;registration(data.identifier)) {
 52         ASSERT(!registration-&gt;m_isStopped);
 53         return *registration;
 54     }
 55 
 56     return adoptRef(*new ServiceWorkerRegistration(context, WTFMove(container), WTFMove(data)));
 57 }
 58 
 59 ServiceWorkerRegistration::ServiceWorkerRegistration(ScriptExecutionContext&amp; context, Ref&lt;ServiceWorkerContainer&gt;&amp;&amp; container, ServiceWorkerRegistrationData&amp;&amp; registrationData)
 60     : ActiveDOMObject(&amp;context)
 61     , m_registrationData(WTFMove(registrationData))
 62     , m_container(WTFMove(container))
 63 {
 64     LOG(ServiceWorker, &quot;Creating registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
 65     suspendIfNeeded();
 66 
 67     if (m_registrationData.installingWorker)
 68         m_installingWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.installingWorker));
 69     if (m_registrationData.waitingWorker)
 70         m_waitingWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.waitingWorker));
 71     if (m_registrationData.activeWorker)
 72         m_activeWorker = ServiceWorker::getOrCreate(context, WTFMove(*m_registrationData.activeWorker));
 73 
 74     REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;ServiceWorkerRegistration: ID %llu, installing: %llu, waiting: %llu, active: %llu&quot;, identifier().toUInt64(), m_installingWorker ? m_installingWorker-&gt;identifier().toUInt64() : 0, m_waitingWorker ? m_waitingWorker-&gt;identifier().toUInt64() : 0, m_activeWorker ? m_activeWorker-&gt;identifier().toUInt64() : 0);
 75 
 76     m_container-&gt;addRegistration(*this);
 77 
 78     relaxAdoptionRequirement();
 79 }
 80 
 81 ServiceWorkerRegistration::~ServiceWorkerRegistration()
 82 {
 83     LOG(ServiceWorker, &quot;Deleting registration %p for registration key %s&quot;, this, m_registrationData.key.loggingString().utf8().data());
 84 
 85     m_container-&gt;removeRegistration(*this);
 86 }
 87 
 88 ServiceWorker* ServiceWorkerRegistration::installing()
 89 {
 90     return m_installingWorker.get();
 91 }
 92 
 93 ServiceWorker* ServiceWorkerRegistration::waiting()
 94 {
 95     return m_waitingWorker.get();
 96 }
 97 
 98 ServiceWorker* ServiceWorkerRegistration::active()
 99 {
100     return m_activeWorker.get();
101 }
102 
103 ServiceWorker* ServiceWorkerRegistration::getNewestWorker() const
104 {
105     if (m_installingWorker)
106         return m_installingWorker.get();
107     if (m_waitingWorker)
108         return m_waitingWorker.get();
109 
110     return m_activeWorker.get();
111 }
112 
113 const String&amp; ServiceWorkerRegistration::scope() const
114 {
115     return m_registrationData.scopeURL;
116 }
117 
118 ServiceWorkerUpdateViaCache ServiceWorkerRegistration::updateViaCache() const
119 {
120     return m_registrationData.updateViaCache;
121 }
122 
123 WallTime ServiceWorkerRegistration::lastUpdateTime() const
124 {
125     return m_registrationData.lastUpdateTime;
126 }
127 
128 void ServiceWorkerRegistration::setLastUpdateTime(WallTime lastUpdateTime)
129 {
130     m_registrationData.lastUpdateTime = lastUpdateTime;
131 }
132 
133 void ServiceWorkerRegistration::setUpdateViaCache(ServiceWorkerUpdateViaCache updateViaCache)
134 {
135     m_registrationData.updateViaCache = updateViaCache;
136 }
137 
138 void ServiceWorkerRegistration::update(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
139 {
140     if (m_isStopped) {
141         promise-&gt;reject(Exception(InvalidStateError));
142         return;
143     }
144 
145     auto* newestWorker = getNewestWorker();
146     if (!newestWorker) {
147         promise-&gt;reject(Exception(InvalidStateError, &quot;newestWorker is null&quot;_s));
148         return;
149     }
150 
151     // FIXME: Support worker types.
152     m_container-&gt;updateRegistration(m_registrationData.scopeURL, newestWorker-&gt;scriptURL(), WorkerType::Classic, WTFMove(promise));
153 }
154 
155 void ServiceWorkerRegistration::unregister(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
156 {
157     if (m_isStopped) {
158         promise-&gt;reject(Exception(InvalidStateError));
159         return;
160     }
161 
162     m_container-&gt;removeRegistration(m_registrationData.scopeURL, WTFMove(promise));
163 }
164 
165 void ServiceWorkerRegistration::updateStateFromServer(ServiceWorkerRegistrationState state, RefPtr&lt;ServiceWorker&gt;&amp;&amp; serviceWorker)
166 {
167     switch (state) {
168     case ServiceWorkerRegistrationState::Installing:
169         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu installing worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
170         m_installingWorker = WTFMove(serviceWorker);
171         break;
172     case ServiceWorkerRegistrationState::Waiting:
173         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu waiting worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
174         m_waitingWorker = WTFMove(serviceWorker);
175         break;
176     case ServiceWorkerRegistrationState::Active:
177         REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;updateStateFromServer: Setting registration %llu active worker to %llu&quot;, identifier().toUInt64(), serviceWorker ? serviceWorker-&gt;identifier().toUInt64() : 0);
178         m_activeWorker = WTFMove(serviceWorker);
179         break;
180     }
181 }
182 
183 void ServiceWorkerRegistration::queueTaskToFireUpdateFoundEvent()
184 {
185     if (m_isStopped)
186         return;
187 
188     REGISTRATION_RELEASE_LOG_IF_ALLOWED(&quot;fireUpdateFoundEvent: Firing updatefound event for registration %llu&quot;, identifier().toUInt64());
189 
190     queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));
191 }
192 
193 EventTargetInterface ServiceWorkerRegistration::eventTargetInterface() const
194 {
195     return ServiceWorkerRegistrationEventTargetInterfaceType;
196 }
197 
198 ScriptExecutionContext* ServiceWorkerRegistration::scriptExecutionContext() const
199 {
200     return ActiveDOMObject::scriptExecutionContext();
201 }
202 
203 const char* ServiceWorkerRegistration::activeDOMObjectName() const
204 {
205     return &quot;ServiceWorkerRegistration&quot;;
206 }
207 
208 void ServiceWorkerRegistration::stop()
209 {
210     m_isStopped = true;
211     removeAllEventListeners();
212 }
213 
214 bool ServiceWorkerRegistration::hasPendingActivity() const
215 {
216     if (!m_isStopped &amp;&amp; getNewestWorker() &amp;&amp; hasEventListeners())
217         return true;
218 
219     return ActiveDOMObject::hasPendingActivity();
220 }
221 
222 } // namespace WebCore
223 
224 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/StaticPerProcess.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SmallPage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Vector.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/StaticPerProcess.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62             return getSlowCase();
 63         return object;
 64     }
 65 
 66     static T* getFastCase()
 67     {
 68         using Storage = typename StaticPerProcessStorageTraits&lt;T&gt;::Storage;
 69         return (Storage::s_object).load(std::memory_order_relaxed);
 70     }
 71 
 72     static Mutex&amp; mutex()
 73     {
 74         using Storage = typename StaticPerProcessStorageTraits&lt;T&gt;::Storage;
 75         return Storage::s_mutex;
 76     }
 77 
 78 private:
 79     BNO_INLINE static T* getSlowCase()
 80     {
 81         using Storage = typename StaticPerProcessStorageTraits&lt;T&gt;::Storage;
<span class="line-modified"> 82         std::lock_guard&lt;Mutex&gt; lock(Storage::s_mutex);</span>
 83         if (!Storage::s_object.load(std::memory_order_consume)) {
 84             T* t = new (&amp;Storage::s_memory) T(lock);
 85             Storage::s_object.store(t, std::memory_order_release);
 86         }
 87         return Storage::s_object.load(std::memory_order_consume);
 88     }
 89 };
 90 
 91 #define DECLARE_STATIC_PER_PROCESS_STORAGE(Type) \
 92 template&lt;&gt; struct StaticPerProcessStorageTraits&lt;Type&gt; { \
 93     using Memory = typename std::aligned_storage&lt;sizeof(Type), std::alignment_of&lt;Type&gt;::value&gt;::type; \
 94     struct BEXPORT Storage { \
 95         BEXPORT static std::atomic&lt;Type*&gt; s_object; \
 96         BEXPORT static Mutex s_mutex; \
 97         BEXPORT static Memory s_memory; \
 98     }; \
 99 };
100 
101 #define DEFINE_STATIC_PER_PROCESS_STORAGE(Type) \
102     std::atomic&lt;Type*&gt; StaticPerProcessStorageTraits&lt;Type&gt;::Storage::s_object { nullptr }; \
</pre>
</td>
<td>
<hr />
<pre>
 62             return getSlowCase();
 63         return object;
 64     }
 65 
 66     static T* getFastCase()
 67     {
 68         using Storage = typename StaticPerProcessStorageTraits&lt;T&gt;::Storage;
 69         return (Storage::s_object).load(std::memory_order_relaxed);
 70     }
 71 
 72     static Mutex&amp; mutex()
 73     {
 74         using Storage = typename StaticPerProcessStorageTraits&lt;T&gt;::Storage;
 75         return Storage::s_mutex;
 76     }
 77 
 78 private:
 79     BNO_INLINE static T* getSlowCase()
 80     {
 81         using Storage = typename StaticPerProcessStorageTraits&lt;T&gt;::Storage;
<span class="line-modified"> 82         LockHolder lock(Storage::s_mutex);</span>
 83         if (!Storage::s_object.load(std::memory_order_consume)) {
 84             T* t = new (&amp;Storage::s_memory) T(lock);
 85             Storage::s_object.store(t, std::memory_order_release);
 86         }
 87         return Storage::s_object.load(std::memory_order_consume);
 88     }
 89 };
 90 
 91 #define DECLARE_STATIC_PER_PROCESS_STORAGE(Type) \
 92 template&lt;&gt; struct StaticPerProcessStorageTraits&lt;Type&gt; { \
 93     using Memory = typename std::aligned_storage&lt;sizeof(Type), std::alignment_of&lt;Type&gt;::value&gt;::type; \
 94     struct BEXPORT Storage { \
 95         BEXPORT static std::atomic&lt;Type*&gt; s_object; \
 96         BEXPORT static Mutex s_mutex; \
 97         BEXPORT static Memory s_memory; \
 98     }; \
 99 };
100 
101 #define DEFINE_STATIC_PER_PROCESS_STORAGE(Type) \
102     std::atomic&lt;Type*&gt; StaticPerProcessStorageTraits&lt;Type&gt;::Storage::s_object { nullptr }; \
</pre>
</td>
</tr>
</table>
<center><a href="SmallPage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Vector.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
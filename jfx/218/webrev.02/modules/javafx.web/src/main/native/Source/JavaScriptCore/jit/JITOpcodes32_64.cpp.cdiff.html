<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOpcodes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 48,14 ***</span>
  namespace JSC {
  
  void JIT::emit_op_mov(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpMov&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_src.offset();</span>
  
<span class="line-modified">!     if (m_codeBlock-&gt;isConstantRegisterIndex(src))</span>
          emitStore(dst, getConstantOperand(src));
      else {
          emitLoad(src, regT1, regT0);
          emitStore(dst, regT1, regT0);
      }
<span class="line-new-header">--- 48,14 ---</span>
  namespace JSC {
  
  void JIT::emit_op_mov(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpMov&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_src;</span>
  
<span class="line-modified">!     if (src.isConstant())</span>
          emitStore(dst, getConstantOperand(src));
      else {
          emitLoad(src, regT1, regT0);
          emitStore(dst, regT1, regT0);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 63,11 ***</span>
  
  void JIT::emit_op_end(const Instruction* currentInstruction)
  {
      ASSERT(returnValueGPR != callFrameRegister);
      auto bytecode = currentInstruction-&gt;as&lt;OpEnd&gt;();
<span class="line-modified">!     emitLoad(bytecode.m_value.offset(), regT1, returnValueGPR);</span>
      emitRestoreCalleeSaves();
      emitFunctionEpilogue();
      ret();
  }
  
<span class="line-new-header">--- 63,11 ---</span>
  
  void JIT::emit_op_end(const Instruction* currentInstruction)
  {
      ASSERT(returnValueGPR != callFrameRegister);
      auto bytecode = currentInstruction-&gt;as&lt;OpEnd&gt;();
<span class="line-modified">!     emitLoad(bytecode.m_value, regT1, returnValueGPR);</span>
      emitRestoreCalleeSaves();
      emitFunctionEpilogue();
      ret();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,32 ***</span>
          JumpList slowCases;
          auto butterfly = TrustedImmPtr(nullptr);
          emitAllocateJSObject(resultReg, JITAllocator::constant(allocator), allocatorReg, TrustedImmPtr(structure), butterfly, scratchReg, slowCases);
          emitInitializeInlineStorage(resultReg, structure-&gt;inlineCapacity());
          addSlowCase(slowCases);
<span class="line-modified">!         emitStoreCell(bytecode.m_dst.offset(), resultReg);</span>
      }
  }
  
  void JIT::emitSlow_op_new_object(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpNewObject&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
      Structure* structure = metadata.m_objectAllocationProfile.structure();
<span class="line-modified">!     callOperation(operationNewObject, structure);</span>
      emitStoreCell(dst, returnValueGPR);
  }
  
  void JIT::emit_op_overrides_has_instance(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpOverridesHasInstance&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int constructor = bytecode.m_constructor.offset();</span>
<span class="line-modified">!     int hasInstanceValue = bytecode.m_hasInstanceValue.offset();</span>
  
      emitLoadPayload(hasInstanceValue, regT0);
      // We don&#39;t jump if we know what Symbol.hasInstance would do.
      Jump hasInstanceValueNotCell = emitJumpIfNotJSCell(hasInstanceValue);
      Jump customhasInstanceValue = branchPtr(NotEqual, regT0, TrustedImmPtr(m_codeBlock-&gt;globalObject()-&gt;functionProtoHasInstanceSymbolFunction()));
<span class="line-new-header">--- 96,32 ---</span>
          JumpList slowCases;
          auto butterfly = TrustedImmPtr(nullptr);
          emitAllocateJSObject(resultReg, JITAllocator::constant(allocator), allocatorReg, TrustedImmPtr(structure), butterfly, scratchReg, slowCases);
          emitInitializeInlineStorage(resultReg, structure-&gt;inlineCapacity());
          addSlowCase(slowCases);
<span class="line-modified">!         emitStoreCell(bytecode.m_dst, resultReg);</span>
      }
  }
  
  void JIT::emitSlow_op_new_object(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpNewObject&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
      Structure* structure = metadata.m_objectAllocationProfile.structure();
<span class="line-modified">!     callOperation(operationNewObject, TrustedImmPtr(&amp;vm()), structure);</span>
      emitStoreCell(dst, returnValueGPR);
  }
  
  void JIT::emit_op_overrides_has_instance(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpOverridesHasInstance&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister constructor = bytecode.m_constructor;</span>
<span class="line-modified">!     VirtualRegister hasInstanceValue = bytecode.m_hasInstanceValue;</span>
  
      emitLoadPayload(hasInstanceValue, regT0);
      // We don&#39;t jump if we know what Symbol.hasInstance would do.
      Jump hasInstanceValueNotCell = emitJumpIfNotJSCell(hasInstanceValue);
      Jump customhasInstanceValue = branchPtr(NotEqual, regT0, TrustedImmPtr(m_codeBlock-&gt;globalObject()-&gt;functionProtoHasInstanceSymbolFunction()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,13 ***</span>
  }
  
  void JIT::emit_op_instanceof(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
<span class="line-modified">!     int proto = bytecode.m_prototype.offset();</span>
  
      // Load the operands into registers.
      // We use regT0 for baseVal since we will be done with this first, and we can then use it for the result.
      emitLoadPayload(value, regT2);
      emitLoadPayload(proto, regT1);
<span class="line-new-header">--- 143,13 ---</span>
  }
  
  void JIT::emit_op_instanceof(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
<span class="line-modified">!     VirtualRegister proto = bytecode.m_prototype;</span>
  
      // Load the operands into registers.
      // We use regT0 for baseVal since we will be done with this first, and we can then use it for the result.
      emitLoadPayload(value, regT2);
      emitLoadPayload(proto, regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,11 ***</span>
      // Check that proto are cells. baseVal must be a cell - this is checked by the get_by_id for Symbol.hasInstance.
      emitJumpSlowCaseIfNotJSCell(value);
      emitJumpSlowCaseIfNotJSCell(proto);
  
      JITInstanceOfGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset),</span>
          RegisterSet::stubUnavailableRegisters(),
          regT0, // result
          regT2, // value
          regT1, // proto
          regT3, regT4); // scratch
<span class="line-new-header">--- 157,11 ---</span>
      // Check that proto are cells. baseVal must be a cell - this is checked by the get_by_id for Symbol.hasInstance.
      emitJumpSlowCaseIfNotJSCell(value);
      emitJumpSlowCaseIfNotJSCell(proto);
  
      JITInstanceOfGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex),</span>
          RegisterSet::stubUnavailableRegisters(),
          regT0, // result
          regT2, // value
          regT1, // proto
          regT3, regT4); // scratch
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,57 ***</span>
  void JIT::emitSlow_op_instanceof(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
<span class="line-modified">!     int proto = bytecode.m_prototype.offset();</span>
  
      JITInstanceOfGenerator&amp; gen = m_instanceOfs[m_instanceOfIndex++];
  
      Label coldPathBegin = label();
      emitLoadTag(value, regT0);
      emitLoadTag(proto, regT3);
<span class="line-modified">!     Call call = callOperation(operationInstanceOfOptimize, dst, gen.stubInfo(), JSValueRegs(regT0, regT2), JSValueRegs(regT3, regT1));</span>
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitSlow_op_instanceof_custom(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
<span class="line-modified">!     int constructor = bytecode.m_constructor.offset();</span>
<span class="line-modified">!     int hasInstanceValue = bytecode.m_hasInstanceValue.offset();</span>
  
      emitLoad(value, regT1, regT0);
      emitLoadPayload(constructor, regT2);
      emitLoad(hasInstanceValue, regT4, regT3);
<span class="line-modified">!     callOperation(operationInstanceOfCustom, JSValueRegs(regT1, regT0), regT2, JSValueRegs(regT4, regT3));</span>
      emitStoreBool(dst, returnValueGPR);
  }
  
  void JIT::emit_op_is_empty(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsEmpty&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitLoad(value, regT1, regT0);
      compare32(Equal, regT1, TrustedImm32(JSValue::EmptyValueTag), regT0);
  
      emitStoreBool(dst, regT0);
  }
  
  void JIT::emit_op_is_undefined(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefined&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitLoad(value, regT1, regT0);
      Jump isCell = branchIfCell(regT1);
  
      compare32(Equal, regT1, TrustedImm32(JSValue::UndefinedTag), regT0);
<span class="line-new-header">--- 180,57 ---</span>
  void JIT::emitSlow_op_instanceof(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
<span class="line-modified">!     VirtualRegister proto = bytecode.m_prototype;</span>
  
      JITInstanceOfGenerator&amp; gen = m_instanceOfs[m_instanceOfIndex++];
  
      Label coldPathBegin = label();
      emitLoadTag(value, regT0);
      emitLoadTag(proto, regT3);
<span class="line-modified">!     Call call = callOperation(operationInstanceOfOptimize, dst, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT0, regT2), JSValueRegs(regT3, regT1));</span>
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitSlow_op_instanceof_custom(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
<span class="line-modified">!     VirtualRegister constructor = bytecode.m_constructor;</span>
<span class="line-modified">!     VirtualRegister hasInstanceValue = bytecode.m_hasInstanceValue;</span>
  
      emitLoad(value, regT1, regT0);
      emitLoadPayload(constructor, regT2);
      emitLoad(hasInstanceValue, regT4, regT3);
<span class="line-modified">!     callOperation(operationInstanceOfCustom, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), regT2, JSValueRegs(regT4, regT3));</span>
      emitStoreBool(dst, returnValueGPR);
  }
  
  void JIT::emit_op_is_empty(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsEmpty&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitLoad(value, regT1, regT0);
      compare32(Equal, regT1, TrustedImm32(JSValue::EmptyValueTag), regT0);
  
      emitStoreBool(dst, regT0);
  }
  
  void JIT::emit_op_is_undefined(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefined&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitLoad(value, regT1, regT0);
      Jump isCell = branchIfCell(regT1);
  
      compare32(Equal, regT1, TrustedImm32(JSValue::UndefinedTag), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,12 ***</span>
  }
  
  void JIT::emit_op_is_undefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefinedOrNull&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitLoadTag(value, regT0);
      static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
      or32(TrustedImm32(1), regT0);
      compare32(Equal, regT0, TrustedImm32(JSValue::NullTag), regT0);
<span class="line-new-header">--- 253,12 ---</span>
  }
  
  void JIT::emit_op_is_undefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsUndefinedOrNull&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitLoadTag(value, regT0);
      static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
      or32(TrustedImm32(1), regT0);
      compare32(Equal, regT0, TrustedImm32(JSValue::NullTag), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 266,35 ***</span>
  }
  
  void JIT::emit_op_is_boolean(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsBoolean&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitLoadTag(value, regT0);
      compare32(Equal, regT0, TrustedImm32(JSValue::BooleanTag), regT0);
      emitStoreBool(dst, regT0);
  }
  
  void JIT::emit_op_is_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsNumber&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitLoadTag(value, regT0);
      add32(TrustedImm32(1), regT0);
      compare32(Below, regT0, TrustedImm32(JSValue::LowestTag + 1), regT0);
      emitStoreBool(dst, regT0);
  }
  
  void JIT::emit_op_is_cell_with_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsCellWithType&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
      int type = bytecode.m_type;
  
      emitLoad(value, regT1, regT0);
      Jump isNotCell = branchIfNotCell(regT1);
  
<span class="line-new-header">--- 266,35 ---</span>
  }
  
  void JIT::emit_op_is_boolean(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsBoolean&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitLoadTag(value, regT0);
      compare32(Equal, regT0, TrustedImm32(JSValue::BooleanTag), regT0);
      emitStoreBool(dst, regT0);
  }
  
  void JIT::emit_op_is_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsNumber&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitLoadTag(value, regT0);
      add32(TrustedImm32(1), regT0);
      compare32(Below, regT0, TrustedImm32(JSValue::LowestTag + 1), regT0);
      emitStoreBool(dst, regT0);
  }
  
  void JIT::emit_op_is_cell_with_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsCellWithType&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
      int type = bytecode.m_type;
  
      emitLoad(value, regT1, regT0);
      Jump isNotCell = branchIfNotCell(regT1);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,12 ***</span>
  }
  
  void JIT::emit_op_is_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsObject&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int value = bytecode.m_operand.offset();</span>
  
      emitLoad(value, regT1, regT0);
      Jump isNotCell = branchIfNotCell(regT1);
  
      compare8(AboveOrEqual, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(ObjectType), regT0);
<span class="line-new-header">--- 309,12 ---</span>
  }
  
  void JIT::emit_op_is_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpIsObject&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_operand;</span>
  
      emitLoad(value, regT1, regT0);
      Jump isNotCell = branchIfNotCell(regT1);
  
      compare8(AboveOrEqual, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(ObjectType), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,12 ***</span>
  }
  
  void JIT::emit_op_to_primitive(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_src.offset();</span>
  
      emitLoad(src, regT1, regT0);
  
      Jump isImm = branchIfNotCell(regT1);
      addSlowCase(branchIfObject(regT0));
<span class="line-new-header">--- 328,12 ---</span>
  }
  
  void JIT::emit_op_to_primitive(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_src;</span>
  
      emitLoad(src, regT1, regT0);
  
      Jump isImm = branchIfNotCell(regT1);
      addSlowCase(branchIfObject(regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,25 ***</span>
  
      if (dst != src)
          emitStore(dst, regT1, regT0);
  }
  
  void JIT::emit_op_set_function_name(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">!     int func = bytecode.m_function.offset();</span>
<span class="line-modified">!     int name = bytecode.m_name.offset();</span>
      emitLoadPayload(func, regT1);
      emitLoad(name, regT3, regT2);
<span class="line-modified">!     callOperation(operationSetFunctionName, regT1, JSValueRegs(regT3, regT2));</span>
  }
  
  void JIT::emit_op_not(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNot&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_operand.offset();</span>
  
      emitLoadTag(src, regT0);
  
      emitLoad(src, regT1, regT0);
      addSlowCase(branchIfNotBoolean(regT1, InvalidGPRReg));
<span class="line-new-header">--- 341,42 ---</span>
  
      if (dst != src)
          emitStore(dst, regT1, regT0);
  }
  
<span class="line-added">+ void JIT::emit_op_to_property_key(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpToPropertyKey&gt;();</span>
<span class="line-added">+     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-added">+     VirtualRegister src = bytecode.m_src;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLoad(src, regT1, regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     addSlowCase(branchIfNotCell(regT1));</span>
<span class="line-added">+     Jump done = branchIfSymbol(regT0);</span>
<span class="line-added">+     addSlowCase(branchIfNotString(regT0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     done.link(this);</span>
<span class="line-added">+     if (src != dst)</span>
<span class="line-added">+         emitStore(dst, regT1, regT0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_set_function_name(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">!     VirtualRegister func = bytecode.m_function;</span>
<span class="line-modified">!     VirtualRegister name = bytecode.m_name;</span>
      emitLoadPayload(func, regT1);
      emitLoad(name, regT3, regT2);
<span class="line-modified">!     callOperation(operationSetFunctionName, m_codeBlock-&gt;globalObject(), regT1, JSValueRegs(regT3, regT2));</span>
  }
  
  void JIT::emit_op_not(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNot&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_operand;</span>
  
      emitLoadTag(src, regT0);
  
      emitLoad(src, regT1, regT0);
      addSlowCase(branchIfNotBoolean(regT1, InvalidGPRReg));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,11 ***</span>
  }
  
  void JIT::emit_op_jfalse(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
<span class="line-modified">!     int cond = bytecode.m_condition.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(cond, regT1, regT0);
  
      JSValueRegs value(regT1, regT0);
<span class="line-new-header">--- 386,11 ---</span>
  }
  
  void JIT::emit_op_jfalse(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJfalse&gt;();
<span class="line-modified">!     VirtualRegister cond = bytecode.m_condition;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(cond, regT1, regT0);
  
      JSValueRegs value(regT1, regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,11 ***</span>
  }
  
  void JIT::emit_op_jtrue(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
<span class="line-modified">!     int cond = bytecode.m_condition.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(cond, regT1, regT0);
      bool shouldCheckMasqueradesAsUndefined = true;
      JSValueRegs value(regT1, regT0);
<span class="line-new-header">--- 401,11 ---</span>
  }
  
  void JIT::emit_op_jtrue(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJtrue&gt;();
<span class="line-modified">!     VirtualRegister cond = bytecode.m_condition;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(cond, regT1, regT0);
      bool shouldCheckMasqueradesAsUndefined = true;
      JSValueRegs value(regT1, regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,11 ***</span>
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
<span class="line-modified">!     int src = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(src, regT1, regT0);
  
      Jump isImmediate = branchIfNotCell(regT1);
<span class="line-new-header">--- 415,11 ---</span>
  }
  
  void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeqNull&gt;();
<span class="line-modified">!     VirtualRegister src = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(src, regT1, regT0);
  
      Jump isImmediate = branchIfNotCell(regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,11 ***</span>
  }
  
  void JIT::emit_op_jneq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqNull&gt;();
<span class="line-modified">!     int src = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(src, regT1, regT0);
  
      Jump isImmediate = branchIfNotCell(regT1);
<span class="line-new-header">--- 441,11 ---</span>
  }
  
  void JIT::emit_op_jneq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqNull&gt;();
<span class="line-modified">!     VirtualRegister src = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(src, regT1, regT0);
  
      Jump isImmediate = branchIfNotCell(regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,11 ***</span>
  }
  
  void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoadTag(value, regT0);
      static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
      or32(TrustedImm32(1), regT0);
<span class="line-new-header">--- 467,11 ---</span>
  }
  
  void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJundefinedOrNull&gt;();
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoadTag(value, regT0);
      static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
      or32(TrustedImm32(1), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,11 ***</span>
  }
  
  void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoadTag(value, regT0);
      static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
      or32(TrustedImm32(1), regT0);
<span class="line-new-header">--- 479,11 ---</span>
  }
  
  void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJnundefinedOrNull&gt;();
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoadTag(value, regT0);
      static_assert((JSValue::UndefinedTag + 1 == JSValue::NullTag) &amp;&amp; (JSValue::NullTag &amp; 0x1), &quot;&quot;);
      or32(TrustedImm32(1), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,30 ***</span>
  
  void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int src = bytecode.m_value.offset();</span>
<span class="line-modified">!     Special::Pointer ptr = bytecode.m_specialPointer;</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(src, regT1, regT0);
      Jump notCell = branchIfNotCell(regT1);
<span class="line-modified">!     Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(actualPointerFor(m_codeBlock, ptr)));</span>
      notCell.link(this);
      store8(TrustedImm32(1), &amp;metadata.m_hasJumped);
      addJump(jump(), target);
      equal.link(this);
  }
  
  void JIT::emit_op_eq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
  
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
<span class="line-new-header">--- 492,31 ---</span>
  
  void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneqPtr&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister src = bytecode.m_value;</span>
<span class="line-modified">!     JSValue specialPointer = getConstantOperand(bytecode.m_specialPointer);</span>
<span class="line-added">+     ASSERT(specialPointer.isCell());</span>
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
  
      emitLoad(src, regT1, regT0);
      Jump notCell = branchIfNotCell(regT1);
<span class="line-modified">!     Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(specialPointer.asCell()));</span>
      notCell.link(this);
      store8(TrustedImm32(1), &amp;metadata.m_hasJumped);
      addJump(jump(), target);
      equal.link(this);
  }
  
  void JIT::emit_op_eq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
  
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,11 ***</span>
  }
  
  void JIT::emitSlow_op_eq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
  
      JumpList storeResult;
      JumpList genericCase;
  
      genericCase.append(getSlowCase(iter)); // tags not equal
<span class="line-new-header">--- 527,11 ---</span>
  }
  
  void JIT::emitSlow_op_eq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEq&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
  
      JumpList storeResult;
      JumpList genericCase;
  
      genericCase.append(getSlowCase(iter)); // tags not equal
</pre>
<hr />
<pre>
<span class="line-old-header">*** 521,28 ***</span>
      linkSlowCase(iter); // tags equal and JSCell
      genericCase.append(branchIfNotString(regT0));
      genericCase.append(branchIfNotString(regT2));
  
      // String case.
<span class="line-modified">!     callOperation(operationCompareStringEq, regT0, regT2);</span>
      storeResult.append(jump());
  
      // Generic case.
      genericCase.append(getSlowCase(iter)); // doubles
      genericCase.link(this);
<span class="line-modified">!     callOperation(operationCompareEq, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
  
      storeResult.link(this);
      emitStoreBool(dst, returnValueGPR);
  }
  
  void JIT::emit_op_jeq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
<span class="line-new-header">--- 539,28 ---</span>
      linkSlowCase(iter); // tags equal and JSCell
      genericCase.append(branchIfNotString(regT0));
      genericCase.append(branchIfNotString(regT2));
  
      // String case.
<span class="line-modified">!     callOperation(operationCompareStringEq, m_codeBlock-&gt;globalObject(), regT0, regT2);</span>
      storeResult.append(jump());
  
      // Generic case.
      genericCase.append(getSlowCase(iter)); // doubles
      genericCase.link(this);
<span class="line-modified">!     callOperation(operationCompareEq, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
  
      storeResult.link(this);
      emitStoreBool(dst, returnValueGPR);
  }
  
  void JIT::emit_op_jeq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJeq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 560,18 ***</span>
      linkSlowCase(iter); // tags equal and JSCell
      genericCase.append(branchIfNotString(regT0));
      genericCase.append(branchIfNotString(regT2));
  
      // String case.
<span class="line-modified">!     callOperation(operationCompareStringEq, regT0, regT2);</span>
      emitJumpSlowToHot(branchTest32(type == CompileOpEqType::Eq ? NonZero : Zero, returnValueGPR), jumpTarget);
      done.append(jump());
  
      // Generic case.
      genericCase.append(getSlowCase(iter)); // doubles
      genericCase.link(this);
<span class="line-modified">!     callOperation(operationCompareEq, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(type == CompileOpEqType::Eq ? NonZero : Zero, returnValueGPR), jumpTarget);
  
      done.link(this);
  }
  
<span class="line-new-header">--- 578,18 ---</span>
      linkSlowCase(iter); // tags equal and JSCell
      genericCase.append(branchIfNotString(regT0));
      genericCase.append(branchIfNotString(regT2));
  
      // String case.
<span class="line-modified">!     callOperation(operationCompareStringEq, m_codeBlock-&gt;globalObject(), regT0, regT2);</span>
      emitJumpSlowToHot(branchTest32(type == CompileOpEqType::Eq ? NonZero : Zero, returnValueGPR), jumpTarget);
      done.append(jump());
  
      // Generic case.
      genericCase.append(getSlowCase(iter)); // doubles
      genericCase.link(this);
<span class="line-modified">!     callOperation(operationCompareEq, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(type == CompileOpEqType::Eq ? NonZero : Zero, returnValueGPR), jumpTarget);
  
      done.link(this);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,13 ***</span>
  }
  
  void JIT::emit_op_neq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
<span class="line-new-header">--- 601,13 ---</span>
  }
  
  void JIT::emit_op_neq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,11 ***</span>
  }
  
  void JIT::emitSlow_op_neq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
  
      JumpList storeResult;
      JumpList genericCase;
  
      genericCase.append(getSlowCase(iter)); // tags not equal
<span class="line-new-header">--- 618,11 ---</span>
  }
  
  void JIT::emitSlow_op_neq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeq&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
  
      JumpList storeResult;
      JumpList genericCase;
  
      genericCase.append(getSlowCase(iter)); // tags not equal
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,29 ***</span>
      linkSlowCase(iter); // tags equal and JSCell
      genericCase.append(branchIfNotString(regT0));
      genericCase.append(branchIfNotString(regT2));
  
      // String case.
<span class="line-modified">!     callOperation(operationCompareStringEq, regT0, regT2);</span>
      storeResult.append(jump());
  
      // Generic case.
      genericCase.append(getSlowCase(iter)); // doubles
      genericCase.link(this);
<span class="line-modified">!     callOperation(operationCompareEq, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
  
      storeResult.link(this);
      xor32(TrustedImm32(0x1), returnValueGPR);
      emitStoreBool(dst, returnValueGPR);
  }
  
  void JIT::emit_op_jneq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
<span class="line-new-header">--- 630,29 ---</span>
      linkSlowCase(iter); // tags equal and JSCell
      genericCase.append(branchIfNotString(regT0));
      genericCase.append(branchIfNotString(regT2));
  
      // String case.
<span class="line-modified">!     callOperation(operationCompareStringEq, m_codeBlock-&gt;globalObject(), regT0, regT2);</span>
      storeResult.append(jump());
  
      // Generic case.
      genericCase.append(getSlowCase(iter)); // doubles
      genericCase.link(this);
<span class="line-modified">!     callOperation(operationCompareEq, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
  
      storeResult.link(this);
      xor32(TrustedImm32(0x1), returnValueGPR);
      emitStoreBool(dst, returnValueGPR);
  }
  
  void JIT::emit_op_jneq(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpJneq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
      addSlowCase(branch32(NotEqual, regT1, regT3));
      addSlowCase(branchIfCell(regT1));
      addSlowCase(branch32(Below, regT1, TrustedImm32(JSValue::LowestTag)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 651,13 ***</span>
  
  template &lt;typename Op&gt;
  void JIT::compileOpStrictEq(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
  
      // Bail if the tags differ, or are double.
      addSlowCase(branch32(NotEqual, regT1, regT3));
<span class="line-new-header">--- 669,13 ---</span>
  
  template &lt;typename Op&gt;
  void JIT::compileOpStrictEq(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
  
      // Bail if the tags differ, or are double.
      addSlowCase(branch32(NotEqual, regT1, regT3));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 692,12 ***</span>
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEqJump(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      int target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     int src1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int src2 = bytecode.m_rhs.offset();</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
  
      // Bail if the tags differ, or are double.
      addSlowCase(branch32(NotEqual, regT1, regT3));
<span class="line-new-header">--- 710,12 ---</span>
  template&lt;typename Op&gt;
  void JIT::compileOpStrictEqJump(const Instruction* currentInstruction, CompileOpStrictEqType type)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      int target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     VirtualRegister src1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister src2 = bytecode.m_rhs;</span>
  
      emitLoad2(src1, regT1, regT0, src2, regT3, regT2);
  
      // Bail if the tags differ, or are double.
      addSlowCase(branch32(NotEqual, regT1, regT3));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,29 ***</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_jnstricteq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJnstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
  }
  
  void JIT::emit_op_eq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEqNull&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_operand.offset();</span>
  
      emitLoad(src, regT1, regT0);
      Jump isImmediate = branchIfNotCell(regT1);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
<span class="line-new-header">--- 749,29 ---</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
  }
  
  void JIT::emitSlow_op_jnstricteq(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpJnstricteq&gt;();
      unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
<span class="line-modified">!     callOperation(operationCompareStrictEq, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
      emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
  }
  
  void JIT::emit_op_eq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEqNull&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_operand;</span>
  
      emitLoad(src, regT1, regT0);
      Jump isImmediate = branchIfNotCell(regT1);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 780,12 ***</span>
  }
  
  void JIT::emit_op_neq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeqNull&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_operand.offset();</span>
  
      emitLoad(src, regT1, regT0);
      Jump isImmediate = branchIfNotCell(regT1);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
<span class="line-new-header">--- 798,12 ---</span>
  }
  
  void JIT::emit_op_neq_null(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpNeqNull&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_operand;</span>
  
      emitLoad(src, regT1, regT0);
      Jump isImmediate = branchIfNotCell(regT1);
  
      Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 814,20 ***</span>
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
      copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
<span class="line-modified">!     emitLoad(bytecode.m_value.offset(), regT1, regT0);</span>
<span class="line-modified">!     callOperationNoExceptionCheck(operationThrow, JSValueRegs(regT1, regT0));</span>
      jumpToExceptionHandler(vm());
  }
  
  void JIT::emit_op_to_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_operand.offset();</span>
  
      emitLoad(src, regT1, regT0);
  
      Jump isInt32 = branchIfInt32(regT1);
      addSlowCase(branch32(AboveOrEqual, regT1, TrustedImm32(JSValue::LowestTag)));
<span class="line-new-header">--- 832,20 ---</span>
  void JIT::emit_op_throw(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpThrow&gt;();
      ASSERT(regT0 == returnValueGPR);
      copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
<span class="line-modified">!     emitLoad(bytecode.m_value, regT1, regT0);</span>
<span class="line-modified">!     callOperationNoExceptionCheck(operationThrow, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0));</span>
      jumpToExceptionHandler(vm());
  }
  
  void JIT::emit_op_to_number(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToNumber&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_operand;</span>
  
      emitLoad(src, regT1, regT0);
  
      Jump isInt32 = branchIfInt32(regT1);
      addSlowCase(branch32(AboveOrEqual, regT1, TrustedImm32(JSValue::LowestTag)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 836,15 ***</span>
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
      if (src != dst)
          emitStore(dst, regT1, regT0);
  }
  
  void JIT::emit_op_to_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToString&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_operand.offset();</span>
  
      emitLoad(src, regT1, regT0);
  
      addSlowCase(branchIfNotCell(regT1));
      addSlowCase(branchIfNotString(regT0));
<span class="line-new-header">--- 854,37 ---</span>
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
      if (src != dst)
          emitStore(dst, regT1, regT0);
  }
  
<span class="line-added">+ void JIT::emit_op_to_numeric(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpToNumeric&gt;();</span>
<span class="line-added">+     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-added">+     VirtualRegister src = bytecode.m_operand;</span>
<span class="line-added">+     JSValueRegs argumentValueRegs(regT1, regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitLoad(src, regT1, regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Jump isNotCell = branchIfNotCell(regT1);</span>
<span class="line-added">+     addSlowCase(branchIfNotBigInt(regT0));</span>
<span class="line-added">+     Jump isBigInt = jump();</span>
<span class="line-added">+ </span>
<span class="line-added">+     isNotCell.link(this);</span>
<span class="line-added">+     addSlowCase(branchIfNotNumber(argumentValueRegs, regT2));</span>
<span class="line-added">+     isBigInt.link(this);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-added">+     if (src != dst)</span>
<span class="line-added">+         emitStore(dst, regT1, regT0);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_to_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToString&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_operand;</span>
  
      emitLoad(src, regT1, regT0);
  
      addSlowCase(branchIfNotCell(regT1));
      addSlowCase(branchIfNotString(regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 854,12 ***</span>
  }
  
  void JIT::emit_op_to_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToObject&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int src = bytecode.m_operand.offset();</span>
  
      emitLoad(src, regT1, regT0);
  
      addSlowCase(branchIfNotCell(regT1));
      addSlowCase(branchIfNotObject(regT0));
<span class="line-new-header">--- 894,12 ---</span>
  }
  
  void JIT::emit_op_to_object(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToObject&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister src = bytecode.m_operand;</span>
  
      emitLoad(src, regT1, regT0);
  
      addSlowCase(branchIfNotCell(regT1));
      addSlowCase(branchIfNotObject(regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,11 ***</span>
      load32(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!     callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);</span>
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
      jumpToExceptionHandler(vm());
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
<span class="line-new-header">--- 920,11 ---</span>
      load32(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
      storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
  
<span class="line-modified">!     callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler, TrustedImmPtr(&amp;vm()));</span>
      Jump isCatchableException = branchTest32(Zero, returnValueGPR);
      jumpToExceptionHandler(vm());
      isCatchableException.link(this);
  
      move(TrustedImmPtr(m_vm), regT3);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 893,36 ***</span>
      load32(Address(regT3, VM::exceptionOffset()), regT2);
      move(TrustedImm32(JSValue::CellTag), regT1);
  
      store32(TrustedImm32(0), Address(regT3, VM::exceptionOffset()));
  
<span class="line-modified">!     unsigned exception = bytecode.m_exception.offset();</span>
<span class="line-removed">-     emitStore(exception, regT1, regT2);</span>
  
      load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT0);
      load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), regT1);
  
<span class="line-modified">!     unsigned thrownValue = bytecode.m_thrownValue.offset();</span>
<span class="line-removed">-     emitStore(thrownValue, regT1, regT0);</span>
  
  #if ENABLE(DFG_JIT)
      // FIXME: consider inline caching the process of doing OSR entry, including
      // argument type proofs, storing locals to the buffer, etc
      // https://bugs.webkit.org/show_bug.cgi?id=175598
  
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     ValueProfileAndOperandBuffer* buffer = metadata.m_buffer;</span>
      if (buffer || !shouldEmitProfiling())
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);</span>
      else
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);</span>
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
      farJump(returnValueGPR, NoPtrTag);
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
              JSValueRegs regs(regT1, regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
              emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));
          });
      }
<span class="line-new-header">--- 933,34 ---</span>
      load32(Address(regT3, VM::exceptionOffset()), regT2);
      move(TrustedImm32(JSValue::CellTag), regT1);
  
      store32(TrustedImm32(0), Address(regT3, VM::exceptionOffset()));
  
<span class="line-modified">!     emitStore(bytecode.m_exception, regT1, regT2);</span>
  
      load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)), regT0);
      load32(Address(regT2, Exception::valueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), regT1);
  
<span class="line-modified">!     emitStore(bytecode.m_thrownValue, regT1, regT0);</span>
  
  #if ENABLE(DFG_JIT)
      // FIXME: consider inline caching the process of doing OSR entry, including
      // argument type proofs, storing locals to the buffer, etc
      // https://bugs.webkit.org/show_bug.cgi?id=175598
  
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     ValueProfileAndVirtualRegisterBuffer* buffer = metadata.m_buffer;</span>
      if (buffer || !shouldEmitProfiling())
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatch, &amp;vm(), m_bytecodeIndex.asBits());</span>
      else
<span class="line-modified">!         callOperation(operationTryOSREnterAtCatchAndValueProfile, &amp;vm(), m_bytecodeIndex.asBits());</span>
      auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
      emitRestoreCalleeSaves();
      farJump(returnValueGPR, NoPtrTag);
      skipOSREntry.link(this);
      if (buffer &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
              JSValueRegs regs(regT1, regT0);
              emitGetVirtualRegister(profile.m_operand, regs);
              emitValueProfilingSite(static_cast&lt;ValueProfile&amp;&gt;(profile));
          });
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,89 ***</span>
  }
  
  void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetParentScope&gt;();
<span class="line-modified">!     int currentScope = bytecode.m_scope.offset();</span>
      emitLoadPayload(currentScope, regT0);
      loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
<span class="line-modified">!     emitStoreCell(bytecode.m_dst.offset(), regT0);</span>
  }
  
  void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     unsigned scrutinee = bytecode.m_scrutinee.offset();</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
<span class="line-modified">!     callOperation(operationSwitchImmWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);</span>
      farJump(returnValueGPR, NoPtrTag);
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     unsigned scrutinee = bytecode.m_scrutinee.offset();</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
<span class="line-modified">!     callOperation(operationSwitchCharWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);</span>
      farJump(returnValueGPR, NoPtrTag);
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     unsigned scrutinee = bytecode.m_scrutinee.offset();</span>
  
      // create jump table for switch destinations, track this switch statement.
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));</span>
  
      emitLoad(scrutinee, regT1, regT0);
<span class="line-modified">!     callOperation(operationSwitchStringWithUnknownKeyType, JSValueRegs(regT1, regT0), tableIndex);</span>
      farJump(returnValueGPR, NoPtrTag);
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
      load32(codeBlock()-&gt;debuggerRequestsAddress(), regT0);
      Jump noDebuggerRequests = branchTest32(Zero, regT0);
<span class="line-modified">!     callOperation(operationDebug, static_cast&lt;int&gt;(bytecode.m_debugHookType));</span>
      noDebuggerRequests.link(this);
  }
  
  void JIT::emit_op_get_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
      emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
      loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
      emitStoreCell(dst, regT0);
  }
  
  void JIT::emit_op_create_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCreateThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int callee = bytecode.m_callee.offset();</span>
      WriteBarrierBase&lt;JSCell&gt;* cachedFunction = &amp;metadata.m_cachedCallee;
      RegisterID calleeReg = regT0;
      RegisterID rareDataReg = regT4;
      RegisterID resultReg = regT0;
      RegisterID allocatorReg = regT1;
<span class="line-new-header">--- 973,104 ---</span>
  }
  
  void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetParentScope&gt;();
<span class="line-modified">!     VirtualRegister currentScope = bytecode.m_scope;</span>
      emitLoadPayload(currentScope, regT0);
      loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
<span class="line-modified">!     emitStoreCell(bytecode.m_dst, regT0);</span>
  }
  
  void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchImm&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     VirtualRegister scrutinee = bytecode.m_scrutinee;</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset, SwitchRecord::Immediate));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
<span class="line-modified">!     callOperation(operationSwitchImmWithUnknownKeyType, TrustedImmPtr(&amp;vm()), JSValueRegs(regT1, regT0), tableIndex);</span>
      farJump(returnValueGPR, NoPtrTag);
  }
  
  void JIT::emit_op_switch_char(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchChar&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     VirtualRegister scrutinee = bytecode.m_scrutinee;</span>
  
      // create jump table for switch destinations, track this switch statement.
      SimpleJumpTable* jumpTable = &amp;m_codeBlock-&gt;switchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset, SwitchRecord::Character));</span>
      jumpTable-&gt;ensureCTITable();
  
      emitLoad(scrutinee, regT1, regT0);
<span class="line-modified">!     callOperation(operationSwitchCharWithUnknownKeyType, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), tableIndex);</span>
      farJump(returnValueGPR, NoPtrTag);
  }
  
  void JIT::emit_op_switch_string(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpSwitchString&gt;();
      size_t tableIndex = bytecode.m_tableIndex;
      unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
<span class="line-modified">!     VirtualRegister scrutinee = bytecode.m_scrutinee;</span>
  
      // create jump table for switch destinations, track this switch statement.
      StringJumpTable* jumpTable = &amp;m_codeBlock-&gt;stringSwitchJumpTable(tableIndex);
<span class="line-modified">!     m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset));</span>
  
      emitLoad(scrutinee, regT1, regT0);
<span class="line-modified">!     callOperation(operationSwitchStringWithUnknownKeyType, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), tableIndex);</span>
      farJump(returnValueGPR, NoPtrTag);
  }
  
  void JIT::emit_op_debug(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDebug&gt;();
      load32(codeBlock()-&gt;debuggerRequestsAddress(), regT0);
      Jump noDebuggerRequests = branchTest32(Zero, regT0);
<span class="line-modified">!     callOperation(operationDebug, &amp;vm(), static_cast&lt;int&gt;(bytecode.m_debugHookType));</span>
      noDebuggerRequests.link(this);
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_op_enter(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitEnterOptimizationCheck();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Even though JIT code doesn&#39;t use them, we initialize our constant</span>
<span class="line-added">+     // registers to zap stale pointers, to avoid unnecessarily prolonging</span>
<span class="line-added">+     // object lifetime and increasing GC pressure.</span>
<span class="line-added">+     for (int i = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); i &lt; m_codeBlock-&gt;numVars(); ++i)</span>
<span class="line-added">+         emitStore(virtualRegisterForLocal(i), jsUndefined());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_enter);</span>
<span class="line-added">+     slowPathCall.call();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JIT::emit_op_get_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetScope&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
      emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
      loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
      emitStoreCell(dst, regT0);
  }
  
  void JIT::emit_op_create_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCreateThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister callee = bytecode.m_callee;</span>
      WriteBarrierBase&lt;JSCell&gt;* cachedFunction = &amp;metadata.m_cachedCallee;
      RegisterID calleeReg = regT0;
      RegisterID rareDataReg = regT4;
      RegisterID resultReg = regT0;
      RegisterID allocatorReg = regT1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1025,14 ***</span>
      RegisterID cachedFunctionReg = regT4;
      RegisterID scratchReg = regT3;
  
      emitLoadPayload(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
<span class="line-modified">!     loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);</span>
<span class="line-modified">!     addSlowCase(branchTestPtr(Zero, rareDataReg));</span>
<span class="line-modified">!     load32(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorReg);</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
<span class="line-new-header">--- 1078,14 ---</span>
      RegisterID cachedFunctionReg = regT4;
      RegisterID scratchReg = regT3;
  
      emitLoadPayload(callee, calleeReg);
      addSlowCase(branchIfNotFunction(calleeReg));
<span class="line-modified">!     loadPtr(Address(calleeReg, JSFunction::offsetOfExecutableOrRareData()), rareDataReg);</span>
<span class="line-modified">!     addSlowCase(branchTestPtr(Zero, rareDataReg, TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-modified">!     load32(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator() - JSFunction::rareDataTag), allocatorReg);</span>
<span class="line-modified">!     loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure() - JSFunction::rareDataTag), structureReg);</span>
  
      loadPtr(cachedFunction, cachedFunctionReg);
      Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
      addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
      hasSeenMultipleCallees.link(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1041,19 ***</span>
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
      load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
<span class="line-modified">!     emitStoreCell(bytecode.m_dst.offset(), resultReg);</span>
  }
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;
<span class="line-modified">!     int thisRegister = bytecode.m_srcDst.offset();</span>
  
      emitLoad(thisRegister, regT3, regT2);
  
      addSlowCase(branchIfNotCell(regT3));
      addSlowCase(branchIfNotType(regT2, FinalObjectType));
<span class="line-new-header">--- 1094,19 ---</span>
      auto butterfly = TrustedImmPtr(nullptr);
      emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
      load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);
      emitInitializeInlineStorage(resultReg, scratchReg);
      addSlowCase(slowCases);
<span class="line-modified">!     emitStoreCell(bytecode.m_dst, resultReg);</span>
  }
  
  void JIT::emit_op_to_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpToThis&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      StructureID* cachedStructureID = &amp;metadata.m_cachedStructureID;
<span class="line-modified">!     VirtualRegister thisRegister = bytecode.m_srcDst;</span>
  
      emitLoad(thisRegister, regT3, regT2);
  
      addSlowCase(branchIfNotCell(regT3));
      addSlowCase(branchIfNotType(regT2, FinalObjectType));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,20 ***</span>
  }
  
  void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCheckTdz&gt;();
<span class="line-modified">!     emitLoadTag(bytecode.m_targetVirtualRegister.offset(), regT0);</span>
      addSlowCase(branchIfEmpty(regT0));
  }
  
  void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
  
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
  
      emitLoadPayload(enumerator, regT1);
<span class="line-new-header">--- 1116,20 ---</span>
  }
  
  void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpCheckTdz&gt;();
<span class="line-modified">!     emitLoadTag(bytecode.m_targetVirtualRegister, regT0);</span>
      addSlowCase(branchIfEmpty(regT0));
  }
  
  void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
  
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
  
      emitLoadPayload(enumerator, regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1117,13 ***</span>
  
  void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
<span class="line-new-header">--- 1170,13 ---</span>
  
  void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1157,41 ***</span>
  
      emitStoreBool(dst, regT0);
  
      Label nextHotPath = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, PatchableJump(), badType, mode, profile, done, nextHotPath));</span>
  }
  
  void JIT::emitSlow_op_has_indexed_property(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
  
      Label slowPath = label();
  
      emitLoad(base, regT1, regT0);
      emitLoad(property, regT3, regT2);
<span class="line-modified">!     Call call = callOperation(operationHasIndexedPropertyDefault, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2), byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_get_direct_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetDirectPname&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int index = bytecode.m_index.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
  
      // Check that base is a cell
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
  
<span class="line-new-header">--- 1210,41 ---</span>
  
      emitStoreBool(dst, regT0);
  
      Label nextHotPath = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, PatchableJump(), badType, mode, profile, done, nextHotPath));</span>
  }
  
  void JIT::emitSlow_op_has_indexed_property(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
  
      Label slowPath = label();
  
      emitLoad(base, regT1, regT0);
      emitLoad(property, regT3, regT2);
<span class="line-modified">!     Call call = callOperation(operationHasIndexedPropertyDefault, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2), byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_get_direct_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetDirectPname&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister index = bytecode.m_index;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
  
      // Check that base is a cell
      emitLoadPayload(base, regT0);
      emitJumpSlowCaseIfNotJSCell(base);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1225,13 ***</span>
  }
  
  void JIT::emit_op_enumerator_structure_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorStructurePname&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
<span class="line-modified">!     int index = bytecode.m_index.offset();</span>
  
      emitLoadPayload(index, regT0);
      emitLoadPayload(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endStructurePropertyIndexOffset()));
  
<span class="line-new-header">--- 1278,13 ---</span>
  }
  
  void JIT::emit_op_enumerator_structure_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorStructurePname&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
<span class="line-modified">!     VirtualRegister index = bytecode.m_index;</span>
  
      emitLoadPayload(index, regT0);
      emitLoadPayload(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endStructurePropertyIndexOffset()));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1250,13 ***</span>
  }
  
  void JIT::emit_op_enumerator_generic_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorGenericPname&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int enumerator = bytecode.m_enumerator.offset();</span>
<span class="line-modified">!     int index = bytecode.m_index.offset();</span>
  
      emitLoadPayload(index, regT0);
      emitLoadPayload(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
  
<span class="line-new-header">--- 1303,13 ---</span>
  }
  
  void JIT::emit_op_enumerator_generic_pname(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpEnumeratorGenericPname&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister enumerator = bytecode.m_enumerator;</span>
<span class="line-modified">!     VirtualRegister index = bytecode.m_index;</span>
  
      emitLoadPayload(index, regT0);
      emitLoadPayload(enumerator, regT1);
      Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1277,11 ***</span>
  void JIT::emit_op_profile_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpProfileType&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      TypeLocation* cachedTypeLocation = metadata.m_typeLocation;
<span class="line-modified">!     int valueToProfile = bytecode.m_targetVirtualRegister.offset();</span>
  
      // Load payload in T0. Load tag in T3.
      emitLoadPayload(valueToProfile, regT0);
      emitLoadTag(valueToProfile, regT3);
  
<span class="line-new-header">--- 1330,11 ---</span>
  void JIT::emit_op_profile_type(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpProfileType&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      TypeLocation* cachedTypeLocation = metadata.m_typeLocation;
<span class="line-modified">!     VirtualRegister valueToProfile = bytecode.m_targetVirtualRegister;</span>
  
      // Load payload in T0. Load tag in T3.
      emitLoadPayload(valueToProfile, regT0);
      emitLoadTag(valueToProfile, regT3);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1334,11 ***</span>
      // Increment the current log entry.
      addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
      store32(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
      jumpToEnd.append(branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr())));
      // Clear the log if we&#39;re at the end of the log.
<span class="line-modified">!     callOperation(operationProcessTypeProfilerLog);</span>
  
      jumpToEnd.link(this);
  }
  
  void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
<span class="line-new-header">--- 1387,11 ---</span>
      // Increment the current log entry.
      addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
      store32(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
      jumpToEnd.append(branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr())));
      // Clear the log if we&#39;re at the end of the log.
<span class="line-modified">!     callOperation(operationProcessTypeProfilerLog, &amp;vm());</span>
  
      jumpToEnd.link(this);
  }
  
  void JIT::emit_op_log_shadow_chicken_prologue(const Instruction* currentInstruction)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1351,11 ***</span>
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
  
      scratch1Reg = regT4;
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope.offset(), regT3);</span>
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
<span class="line-new-header">--- 1404,11 ---</span>
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
  
      scratch1Reg = regT4;
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope, regT3);</span>
      logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
  }
  
  void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1365,15 ***</span>
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
<span class="line-modified">!     emitLoadPayload(bytecode.m_thisValue.offset(), regT2);</span>
<span class="line-modified">!     emitLoadTag(bytecode.m_thisValue.offset(), regT1);</span>
      JSValueRegs thisRegs(regT1, regT2);
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope.offset(), regT3);</span>
<span class="line-modified">!     logShadowChickenTailPacket(shadowPacketReg, thisRegs, regT3, m_codeBlock, CallSiteIndex(currentInstruction));</span>
  }
  
  } // namespace JSC
  
  #endif // USE(JSVALUE32_64)
<span class="line-new-header">--- 1418,15 ---</span>
      auto bytecode = currentInstruction-&gt;as&lt;OpLogShadowChickenTail&gt;();
      GPRReg shadowPacketReg = regT0;
      GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
      GPRReg scratch2Reg = regT2;
      ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
<span class="line-modified">!     emitLoadPayload(bytecode.m_thisValue, regT2);</span>
<span class="line-modified">!     emitLoadTag(bytecode.m_thisValue, regT1);</span>
      JSValueRegs thisRegs(regT1, regT2);
<span class="line-modified">!     emitLoadPayload(bytecode.m_scope, regT3);</span>
<span class="line-modified">!     logShadowChickenTailPacket(shadowPacketReg, thisRegs, regT3, m_codeBlock, CallSiteIndex(m_bytecodeIndex));</span>
  }
  
  } // namespace JSC
  
  #endif // USE(JSVALUE32_64)
</pre>
<center><a href="JITOpcodes.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITOperations.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
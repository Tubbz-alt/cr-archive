<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGlobalObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGlobalObject.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,25 ***</span>
  #include &quot;ArrayBufferSharingMode.h&quot;
  #include &quot;BigIntPrototype.h&quot;
  #include &quot;BooleanPrototype.h&quot;
  #include &quot;ErrorType.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;InternalFunction.h&quot;
  #include &quot;JSArray.h&quot;
  #include &quot;JSArrayBufferPrototype.h&quot;
  #include &quot;JSClassRef.h&quot;
  #include &quot;JSGlobalLexicalEnvironment.h&quot;
<span class="line-modified">! #include &quot;JSPromiseDeferred.h&quot;</span>
  #include &quot;JSSegmentedVariableObject.h&quot;
  #include &quot;JSWeakObjectMapRefInternal.h&quot;
  #include &quot;LazyProperty.h&quot;
  #include &quot;LazyClassStructure.h&quot;
  #include &quot;NumberPrototype.h&quot;
  #include &quot;ParserModes.h&quot;
  #include &quot;RegExpGlobalData.h&quot;
  #include &quot;RuntimeFlags.h&quot;
<span class="line-removed">- #include &quot;SpecialPointer.h&quot;</span>
  #include &quot;StringPrototype.h&quot;
  #include &quot;SymbolPrototype.h&quot;
  #include &quot;VM.h&quot;
  #include &quot;Watchpoint.h&quot;
  #include &lt;JavaScriptCore/JSBase.h&gt;
<span class="line-new-header">--- 25,25 ---</span>
  #include &quot;ArrayBufferSharingMode.h&quot;
  #include &quot;BigIntPrototype.h&quot;
  #include &quot;BooleanPrototype.h&quot;
  #include &quot;ErrorType.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
<span class="line-added">+ #include &quot;GetVM.h&quot;</span>
  #include &quot;InternalFunction.h&quot;
  #include &quot;JSArray.h&quot;
  #include &quot;JSArrayBufferPrototype.h&quot;
  #include &quot;JSClassRef.h&quot;
  #include &quot;JSGlobalLexicalEnvironment.h&quot;
<span class="line-modified">! #include &quot;JSPromise.h&quot;</span>
  #include &quot;JSSegmentedVariableObject.h&quot;
  #include &quot;JSWeakObjectMapRefInternal.h&quot;
  #include &quot;LazyProperty.h&quot;
  #include &quot;LazyClassStructure.h&quot;
  #include &quot;NumberPrototype.h&quot;
  #include &quot;ParserModes.h&quot;
  #include &quot;RegExpGlobalData.h&quot;
  #include &quot;RuntimeFlags.h&quot;
  #include &quot;StringPrototype.h&quot;
  #include &quot;SymbolPrototype.h&quot;
  #include &quot;VM.h&quot;
  #include &quot;Watchpoint.h&quot;
  #include &lt;JavaScriptCore/JSBase.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,10 ***</span>
<span class="line-new-header">--- 60,11 ---</span>
  }
  
  namespace JSC {
  class ArrayConstructor;
  class ArrayPrototype;
<span class="line-added">+ class ArrayIteratorPrototype;</span>
  class AsyncIteratorPrototype;
  class AsyncFunctionPrototype;
  class AsyncGeneratorPrototype;
  class AsyncGeneratorFunctionPrototype;
  class BooleanPrototype;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,10 ***</span>
<span class="line-new-header">--- 117,11 ---</span>
  class SourceOrigin;
  class UnlinkedModuleProgramCodeBlock;
  class VariableEnvironment;
  struct ActivationStackNode;
  struct HashTable;
<span class="line-added">+ enum class LinkTimeConstant : int32_t;</span>
  
  #ifdef JSC_GLIB_API_ENABLED
  class WrapperMap;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,12 ***</span>
  
  #define DEFINE_STANDARD_BUILTIN(macro, upperName, lowerName) macro(upperName, lowerName, lowerName, JS ## upperName, upperName, object, typeExposedByDefault)
  
  #define FOR_EACH_SIMPLE_BUILTIN_TYPE_WITH_CONSTRUCTOR(macro) \
      macro(String, string, stringObject, StringObject, String, object, typeExposedByDefault) \
<span class="line-removed">-     macro(Map, map, map, JSMap, Map, object, typeExposedByDefault) \</span>
<span class="line-removed">-     macro(Set, set, set, JSSet, Set, object, typeExposedByDefault) \</span>
      macro(JSPromise, promise, promise, JSPromise, Promise, object, typeExposedByDefault) \
      macro(BigInt, bigInt, bigIntObject, BigIntObject, BigInt, object, Options::useBigInt()) \
      macro(WeakObjectRef, weakObjectRef, weakObjectRef, JSWeakObjectRef, WeakRef, object, Options::useWeakRefs()) \
  
  #define FOR_EACH_BUILTIN_DERIVED_ITERATOR_TYPE(macro) \
<span class="line-new-header">--- 131,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,11 ***</span>
<span class="line-new-header">--- 146,13 ---</span>
  
  #define FOR_EACH_LAZY_BUILTIN_TYPE_WITH_DECLARATION(macro) \
      macro(Boolean, boolean, booleanObject, BooleanObject, Boolean, object, typeExposedByDefault) \
      macro(Date, date, date, DateInstance, Date, object, typeExposedByDefault) \
      macro(Error, error, error, ErrorInstance, Error, object, typeExposedByDefault) \
<span class="line-added">+     macro(Map, map, map, JSMap, Map, object, typeExposedByDefault) \</span>
      macro(Number, number, numberObject, NumberObject, Number, object, typeExposedByDefault) \
<span class="line-added">+     macro(Set, set, set, JSSet, Set, object, typeExposedByDefault) \</span>
      macro(Symbol, symbol, symbolObject, SymbolObject, Symbol, object, typeExposedByDefault) \
      DEFINE_STANDARD_BUILTIN(macro, WeakMap, weakMap) \
      DEFINE_STANDARD_BUILTIN(macro, WeakSet, weakSet) \
  
  #define FOR_EACH_LAZY_BUILTIN_TYPE(macro) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,10 ***</span>
<span class="line-new-header">--- 160,11 ---</span>
      macro(JSArrayBuffer, arrayBuffer, arrayBuffer, JSArrayBuffer, ArrayBuffer, object, typeExposedByDefault) \
  
  #if ENABLE(WEBASSEMBLY)
  #define FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(macro) \
      macro(WebAssemblyCompileError, webAssemblyCompileError, webAssemblyCompileError, JSWebAssemblyCompileError, CompileError, error, typeExposedByDefault) \
<span class="line-added">+     macro(WebAssemblyGlobal,       webAssemblyGlobal,       webAssemblyGlobal,       JSWebAssemblyGlobal,       Global,       object, typeExposedByDefault) \</span>
      macro(WebAssemblyInstance,     webAssemblyInstance,     webAssemblyInstance,     JSWebAssemblyInstance,     Instance,     object, typeExposedByDefault) \
      macro(WebAssemblyLinkError,    webAssemblyLinkError,    webAssemblyLinkError,    JSWebAssemblyLinkError,    LinkError,    error, typeExposedByDefault) \
      macro(WebAssemblyMemory,       webAssemblyMemory,       webAssemblyMemory,       JSWebAssemblyMemory,       Memory,       object, typeExposedByDefault) \
      macro(WebAssemblyModule,       webAssemblyModule,       webAssemblyModule,       JSWebAssemblyModule,       Module,       object, typeExposedByDefault) \
      macro(WebAssemblyRuntimeError, webAssemblyRuntimeError, webAssemblyRuntimeError, JSWebAssemblyRuntimeError, RuntimeError, error, typeExposedByDefault) \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,35 ***</span>
      QueueTaskToEventLoopFunctionPtr queueTaskToEventLoop;
  
      typedef bool (*ShouldInterruptScriptBeforeTimeoutPtr)(const JSGlobalObject*);
      ShouldInterruptScriptBeforeTimeoutPtr shouldInterruptScriptBeforeTimeout;
  
<span class="line-modified">!     typedef JSInternalPromise* (*ModuleLoaderImportModulePtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
      ModuleLoaderImportModulePtr moduleLoaderImportModule;
  
<span class="line-modified">!     typedef Identifier (*ModuleLoaderResolvePtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
      ModuleLoaderResolvePtr moduleLoaderResolve;
  
<span class="line-modified">!     typedef JSInternalPromise* (*ModuleLoaderFetchPtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
      ModuleLoaderFetchPtr moduleLoaderFetch;
  
<span class="line-modified">!     typedef JSObject* (*ModuleLoaderCreateImportMetaPropertiesPtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
      ModuleLoaderCreateImportMetaPropertiesPtr moduleLoaderCreateImportMetaProperties;
  
<span class="line-modified">!     typedef JSValue (*ModuleLoaderEvaluatePtr)(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
      ModuleLoaderEvaluatePtr moduleLoaderEvaluate;
  
<span class="line-modified">!     typedef void (*PromiseRejectionTrackerPtr)(JSGlobalObject*, ExecState*, JSPromise*, JSPromiseRejectionOperation);</span>
      PromiseRejectionTrackerPtr promiseRejectionTracker;
  
      typedef String (*DefaultLanguageFunctionPtr)();
      DefaultLanguageFunctionPtr defaultLanguage;
  
<span class="line-modified">!     typedef void (*CompileStreamingPtr)(JSGlobalObject*, ExecState*, JSPromiseDeferred*, JSValue);</span>
      CompileStreamingPtr compileStreaming;
  
<span class="line-modified">!     typedef void (*InstantiateStreamingPtr)(JSGlobalObject*, ExecState*, JSPromiseDeferred*, JSValue, JSObject*);</span>
      InstantiateStreamingPtr instantiateStreaming;
  };
  
  class JSGlobalObject : public JSSegmentedVariableObject {
  private:
<span class="line-new-header">--- 205,35 ---</span>
      QueueTaskToEventLoopFunctionPtr queueTaskToEventLoop;
  
      typedef bool (*ShouldInterruptScriptBeforeTimeoutPtr)(const JSGlobalObject*);
      ShouldInterruptScriptBeforeTimeoutPtr shouldInterruptScriptBeforeTimeout;
  
<span class="line-modified">!     typedef JSInternalPromise* (*ModuleLoaderImportModulePtr)(JSGlobalObject*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
      ModuleLoaderImportModulePtr moduleLoaderImportModule;
  
<span class="line-modified">!     typedef Identifier (*ModuleLoaderResolvePtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
      ModuleLoaderResolvePtr moduleLoaderResolve;
  
<span class="line-modified">!     typedef JSInternalPromise* (*ModuleLoaderFetchPtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
      ModuleLoaderFetchPtr moduleLoaderFetch;
  
<span class="line-modified">!     typedef JSObject* (*ModuleLoaderCreateImportMetaPropertiesPtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
      ModuleLoaderCreateImportMetaPropertiesPtr moduleLoaderCreateImportMetaProperties;
  
<span class="line-modified">!     typedef JSValue (*ModuleLoaderEvaluatePtr)(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
      ModuleLoaderEvaluatePtr moduleLoaderEvaluate;
  
<span class="line-modified">!     typedef void (*PromiseRejectionTrackerPtr)(JSGlobalObject*, JSPromise*, JSPromiseRejectionOperation);</span>
      PromiseRejectionTrackerPtr promiseRejectionTracker;
  
      typedef String (*DefaultLanguageFunctionPtr)();
      DefaultLanguageFunctionPtr defaultLanguage;
  
<span class="line-modified">!     typedef void (*CompileStreamingPtr)(JSGlobalObject*, JSPromise*, JSValue);</span>
      CompileStreamingPtr compileStreaming;
  
<span class="line-modified">!     typedef void (*InstantiateStreamingPtr)(JSGlobalObject*, JSPromise*, JSValue, JSObject*);</span>
      InstantiateStreamingPtr instantiateStreaming;
  };
  
  class JSGlobalObject : public JSSegmentedVariableObject {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,16 ***</span>
          unsigned profileGroup;
  
          OpaqueJSClassDataMap opaqueJSClassData;
      };
  
  // Our hashtable code-generator tries to access these properties, so we make them public.
  // However, we&#39;d like it better if they could be protected.
  public:
      template&lt;typename T&gt; using Initializer = typename LazyProperty&lt;JSGlobalObject, T&gt;::Initializer;
  
<span class="line-modified">!     Register m_globalCallFrame[CallFrame::headerSizeInRegisters];</span>
  
      WriteBarrier&lt;JSObject&gt; m_globalThis;
  
      WriteBarrier&lt;JSGlobalLexicalEnvironment&gt; m_globalLexicalEnvironment;
      WriteBarrier&lt;JSScope&gt; m_globalScopeExtension;
<span class="line-new-header">--- 252,20 ---</span>
          unsigned profileGroup;
  
          OpaqueJSClassDataMap opaqueJSClassData;
      };
  
<span class="line-added">+     // m_vm must be a pointer (instead of a reference) because the JSCLLIntOffsetsExtractor</span>
<span class="line-added">+     // cannot handle it being a reference.</span>
<span class="line-added">+     VM* m_vm;</span>
<span class="line-added">+ </span>
  // Our hashtable code-generator tries to access these properties, so we make them public.
  // However, we&#39;d like it better if they could be protected.
  public:
      template&lt;typename T&gt; using Initializer = typename LazyProperty&lt;JSGlobalObject, T&gt;::Initializer;
  
<span class="line-modified">!     Register m_deprecatedCallFrameForDebugger[CallFrame::headerSizeInRegisters];</span>
  
      WriteBarrier&lt;JSObject&gt; m_globalThis;
  
      WriteBarrier&lt;JSGlobalLexicalEnvironment&gt; m_globalLexicalEnvironment;
      WriteBarrier&lt;JSScope&gt; m_globalScopeExtension;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,15 ***</span>
      LazyClassStructure m_typeErrorStructure;
      LazyClassStructure m_URIErrorStructure;
  
      WriteBarrier&lt;ObjectConstructor&gt; m_objectConstructor;
      WriteBarrier&lt;ArrayConstructor&gt; m_arrayConstructor;
      WriteBarrier&lt;JSPromiseConstructor&gt; m_promiseConstructor;
      WriteBarrier&lt;JSInternalPromiseConstructor&gt; m_internalPromiseConstructor;
  
  #if ENABLE(INTL)
<span class="line-modified">!     WriteBarrier&lt;IntlCollator&gt; m_defaultCollator;</span>
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_collatorStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_numberFormatStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_dateTimeFormatStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_pluralRulesStructure;
  #endif
<span class="line-new-header">--- 279,17 ---</span>
      LazyClassStructure m_typeErrorStructure;
      LazyClassStructure m_URIErrorStructure;
  
      WriteBarrier&lt;ObjectConstructor&gt; m_objectConstructor;
      WriteBarrier&lt;ArrayConstructor&gt; m_arrayConstructor;
<span class="line-added">+     WriteBarrier&lt;RegExpConstructor&gt; m_regExpConstructor;</span>
<span class="line-added">+     WriteBarrier&lt;FunctionConstructor&gt; m_functionConstructor;</span>
      WriteBarrier&lt;JSPromiseConstructor&gt; m_promiseConstructor;
      WriteBarrier&lt;JSInternalPromiseConstructor&gt; m_internalPromiseConstructor;
  
  #if ENABLE(INTL)
<span class="line-modified">!     LazyProperty&lt;JSGlobalObject, IntlCollator&gt; m_defaultCollator;</span>
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_collatorStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_numberFormatStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_dateTimeFormatStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_pluralRulesStructure;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 288,28 ***</span>
      WriteBarrier&lt;NullSetterFunction&gt; m_nullSetterFunction;
  
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_parseIntFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_parseFloatFunction;
  
<span class="line-removed">-     WriteBarrier&lt;JSFunction&gt; m_callFunction;</span>
<span class="line-removed">-     WriteBarrier&lt;JSFunction&gt; m_applyFunction;</span>
<span class="line-removed">-     WriteBarrier&lt;JSFunction&gt; m_throwTypeErrorFunction;</span>
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoToStringFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoValuesFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_evalFunction;
<span class="line-removed">-     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_initializePromiseFunction;</span>
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_iteratorProtocolFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_promiseResolveFunction;
      WriteBarrier&lt;JSFunction&gt; m_objectProtoValueOfFunction;
<span class="line-removed">-     WriteBarrier&lt;JSFunction&gt; m_numberProtoToStringFunction;</span>
<span class="line-removed">-     WriteBarrier&lt;JSFunction&gt; m_newPromiseCapabilityFunction;</span>
      WriteBarrier&lt;JSFunction&gt; m_functionProtoHasInstanceSymbolFunction;
      LazyProperty&lt;JSGlobalObject, GetterSetter&gt; m_throwTypeErrorGetterSetter;
<span class="line-removed">-     WriteBarrier&lt;JSObject&gt; m_regExpProtoExec;</span>
      WriteBarrier&lt;JSObject&gt; m_regExpProtoSymbolReplace;
<span class="line-removed">-     WriteBarrier&lt;JSObject&gt; m_regExpProtoGlobalGetter;</span>
<span class="line-removed">-     WriteBarrier&lt;JSObject&gt; m_regExpProtoUnicodeGetter;</span>
      WriteBarrier&lt;GetterSetter&gt; m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter;
  
      LazyProperty&lt;JSGlobalObject, JSModuleLoader&gt; m_moduleLoader;
  
      WriteBarrier&lt;ObjectPrototype&gt; m_objectPrototype;
<span class="line-new-header">--- 297,20 ---</span>
      WriteBarrier&lt;NullSetterFunction&gt; m_nullSetterFunction;
  
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_parseIntFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_parseFloatFunction;
  
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoToStringFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_arrayProtoValuesFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_evalFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_iteratorProtocolFunction;
      LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_promiseResolveFunction;
<span class="line-added">+     LazyProperty&lt;JSGlobalObject, JSFunction&gt; m_numberProtoToStringFunction;</span>
      WriteBarrier&lt;JSFunction&gt; m_objectProtoValueOfFunction;
      WriteBarrier&lt;JSFunction&gt; m_functionProtoHasInstanceSymbolFunction;
      LazyProperty&lt;JSGlobalObject, GetterSetter&gt; m_throwTypeErrorGetterSetter;
      WriteBarrier&lt;JSObject&gt; m_regExpProtoSymbolReplace;
      WriteBarrier&lt;GetterSetter&gt; m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter;
  
      LazyProperty&lt;JSGlobalObject, JSModuleLoader&gt; m_moduleLoader;
  
      WriteBarrier&lt;ObjectPrototype&gt; m_objectPrototype;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,10 ***</span>
<span class="line-new-header">--- 320,11 ---</span>
      WriteBarrier&lt;IteratorPrototype&gt; m_iteratorPrototype;
      WriteBarrier&lt;AsyncIteratorPrototype&gt; m_asyncIteratorPrototype;
      WriteBarrier&lt;GeneratorFunctionPrototype&gt; m_generatorFunctionPrototype;
      WriteBarrier&lt;GeneratorPrototype&gt; m_generatorPrototype;
      WriteBarrier&lt;AsyncGeneratorPrototype&gt; m_asyncGeneratorPrototype;
<span class="line-added">+     WriteBarrier&lt;ArrayIteratorPrototype&gt; m_arrayIteratorPrototype;</span>
  
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_debuggerScopeStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_withScopeStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_strictEvalActivationStructure;
      WriteBarrier&lt;Structure&gt; m_lexicalEnvironmentStructure;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,22 ***</span>
      FunctionStructures m_builtinFunctions;
      FunctionStructures m_ordinaryFunctions;
  
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_boundFunctionStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_customGetterSetterFunctionStructure;
<span class="line-removed">-     WriteBarrier&lt;Structure&gt; m_getterSetterStructure;</span>
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_nativeStdFunctionStructure;
      PropertyOffset m_functionNameOffset;
      WriteBarrier&lt;Structure&gt; m_regExpStructure;
      WriteBarrier&lt;AsyncFunctionPrototype&gt; m_asyncFunctionPrototype;
      WriteBarrier&lt;AsyncGeneratorFunctionPrototype&gt; m_asyncGeneratorFunctionPrototype;
      WriteBarrier&lt;Structure&gt; m_asyncFunctionStructure;
      WriteBarrier&lt;Structure&gt; m_asyncGeneratorFunctionStructure;
      WriteBarrier&lt;Structure&gt; m_generatorFunctionStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_iteratorResultObjectStructure;
      WriteBarrier&lt;Structure&gt; m_regExpMatchesArrayStructure;
<span class="line-removed">-     WriteBarrier&lt;Structure&gt; m_regExpMatchesArrayWithGroupsStructure;</span>
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleRecordStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleNamespaceObjectStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_proxyObjectStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_callableProxyObjectStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_proxyRevokeStructure;
<span class="line-new-header">--- 365,23 ---</span>
      FunctionStructures m_builtinFunctions;
      FunctionStructures m_ordinaryFunctions;
  
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_boundFunctionStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_customGetterSetterFunctionStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_nativeStdFunctionStructure;
      PropertyOffset m_functionNameOffset;
      WriteBarrier&lt;Structure&gt; m_regExpStructure;
      WriteBarrier&lt;AsyncFunctionPrototype&gt; m_asyncFunctionPrototype;
      WriteBarrier&lt;AsyncGeneratorFunctionPrototype&gt; m_asyncGeneratorFunctionPrototype;
      WriteBarrier&lt;Structure&gt; m_asyncFunctionStructure;
      WriteBarrier&lt;Structure&gt; m_asyncGeneratorFunctionStructure;
      WriteBarrier&lt;Structure&gt; m_generatorFunctionStructure;
<span class="line-added">+     WriteBarrier&lt;Structure&gt; m_generatorStructure;</span>
<span class="line-added">+     WriteBarrier&lt;Structure&gt; m_asyncGeneratorStructure;</span>
<span class="line-added">+     WriteBarrier&lt;Structure&gt; m_arrayIteratorStructure;</span>
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_iteratorResultObjectStructure;
      WriteBarrier&lt;Structure&gt; m_regExpMatchesArrayStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleRecordStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_moduleNamespaceObjectStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_proxyObjectStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_callableProxyObjectStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_proxyRevokeStructure;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 400,11 ***</span>
  #if ENABLE(WEBASSEMBLY)
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyModuleRecordStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyFunctionStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_jsToWasmICCalleeStructure;
      LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyWrapperFunctionStructure;
<span class="line-removed">-     LazyProperty&lt;JSGlobalObject, Structure&gt; m_webAssemblyToJSCalleeStructure;</span>
      FOR_EACH_WEBASSEMBLY_CONSTRUCTOR_TYPE(DEFINE_STORAGE_FOR_LAZY_TYPE)
  #endif // ENABLE(WEBASSEMBLY)
  
      FOR_EACH_LAZY_BUILTIN_TYPE(DEFINE_STORAGE_FOR_LAZY_TYPE)
  
<span class="line-new-header">--- 403,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,33 ***</span>
  
  #define DECLARE_TYPED_ARRAY_TYPE_STRUCTURE(name) LazyClassStructure m_typedArray ## name;
      FOR_EACH_TYPED_ARRAY_TYPE(DECLARE_TYPED_ARRAY_TYPE_STRUCTURE)
  #undef DECLARE_TYPED_ARRAY_TYPE_STRUCTURE
  
<span class="line-modified">!     JSCell* m_specialPointers[Special::TableSize]; // Special pointers used by the LLInt and JIT.</span>
<span class="line-removed">-     JSCell* m_linkTimeConstants[LinkTimeConstantCount];</span>
  
      String m_name;
  
      Strong&lt;JSObject&gt; m_unhandledRejectionCallback;
  
      Debugger* m_debugger;
  
<span class="line-removed">-     VM&amp; m_vm;</span>
<span class="line-removed">- </span>
  #if ENABLE(REMOTE_INSPECTOR)
      std::unique_ptr&lt;Inspector::JSGlobalObjectInspectorController&gt; m_inspectorController;
      std::unique_ptr&lt;JSGlobalObjectDebuggable&gt; m_inspectorDebuggable;
  #endif
  
<span class="line-removed">- #if ENABLE(INTL)</span>
<span class="line-removed">-     HashSet&lt;String&gt; m_intlCollatorAvailableLocales;</span>
<span class="line-removed">-     HashSet&lt;String&gt; m_intlDateTimeFormatAvailableLocales;</span>
<span class="line-removed">-     HashSet&lt;String&gt; m_intlNumberFormatAvailableLocales;</span>
<span class="line-removed">-     HashSet&lt;String&gt; m_intlPluralRulesAvailableLocales;</span>
<span class="line-removed">- #endif // ENABLE(INTL)</span>
<span class="line-removed">- </span>
      RefPtr&lt;WatchpointSet&gt; m_masqueradesAsUndefinedWatchpoint;
      RefPtr&lt;WatchpointSet&gt; m_havingABadTimeWatchpoint;
      RefPtr&lt;WatchpointSet&gt; m_varInjectionWatchpoint;
  
      std::unique_ptr&lt;JSGlobalObjectRareData&gt; m_rareData;
<span class="line-new-header">--- 420,23 ---</span>
  
  #define DECLARE_TYPED_ARRAY_TYPE_STRUCTURE(name) LazyClassStructure m_typedArray ## name;
      FOR_EACH_TYPED_ARRAY_TYPE(DECLARE_TYPED_ARRAY_TYPE_STRUCTURE)
  #undef DECLARE_TYPED_ARRAY_TYPE_STRUCTURE
  
<span class="line-modified">!     Vector&lt;LazyProperty&lt;JSGlobalObject, JSCell&gt;&gt; m_linkTimeConstants;</span>
  
      String m_name;
  
      Strong&lt;JSObject&gt; m_unhandledRejectionCallback;
  
      Debugger* m_debugger;
  
  #if ENABLE(REMOTE_INSPECTOR)
      std::unique_ptr&lt;Inspector::JSGlobalObjectInspectorController&gt; m_inspectorController;
      std::unique_ptr&lt;JSGlobalObjectDebuggable&gt; m_inspectorDebuggable;
  #endif
  
      RefPtr&lt;WatchpointSet&gt; m_masqueradesAsUndefinedWatchpoint;
      RefPtr&lt;WatchpointSet&gt; m_havingABadTimeWatchpoint;
      RefPtr&lt;WatchpointSet&gt; m_varInjectionWatchpoint;
  
      std::unique_ptr&lt;JSGlobalObjectRareData&gt; m_rareData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,12 ***</span>
      String m_webAssemblyDisabledErrorMessage;
      RuntimeFlags m_runtimeFlags;
      ConsoleClient* m_consoleClient { nullptr };
      Optional&lt;unsigned&gt; m_stackTraceLimit;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
<span class="line-modified">!     const ExecState* m_callFrameAtDebuggerEntry { nullptr };</span>
  #endif
  
      static JS_EXPORT_PRIVATE const GlobalObjectMethodTable s_globalObjectMethodTable;
      const GlobalObjectMethodTable* m_globalObjectMethodTable;
  
<span class="line-new-header">--- 505,12 ---</span>
      String m_webAssemblyDisabledErrorMessage;
      RuntimeFlags m_runtimeFlags;
      ConsoleClient* m_consoleClient { nullptr };
      Optional&lt;unsigned&gt; m_stackTraceLimit;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
<span class="line-modified">!     const JSGlobalObject* m_globalObjectAtDebuggerEntry { nullptr };</span>
  #endif
  
      static JS_EXPORT_PRIVATE const GlobalObjectMethodTable s_globalObjectMethodTable;
      const GlobalObjectMethodTable* m_globalObjectMethodTable;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 528,12 ***</span>
              return;
          m_rareData = makeUnique&lt;JSGlobalObjectRareData&gt;();
      }
  
  public:
<span class="line-modified">!     typedef JSSegmentedVariableObject Base;</span>
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot | OverridesGetPropertyNames | IsImmutablePrototypeExoticObject;</span>
  
      JS_EXPORT_PRIVATE static JSGlobalObject* create(VM&amp;, Structure*);
  
      DECLARE_EXPORT_INFO;
  
<span class="line-new-header">--- 520,19 ---</span>
              return;
          m_rareData = makeUnique&lt;JSGlobalObjectRareData&gt;();
      }
  
  public:
<span class="line-modified">!     using Base = JSSegmentedVariableObject;</span>
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot | OverridesGetPropertyNames | IsImmutablePrototypeExoticObject;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static constexpr bool needsDestruction = true;</span>
<span class="line-added">+     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return vm.globalObjectSpace&lt;mode&gt;();</span>
<span class="line-added">+     }</span>
  
      JS_EXPORT_PRIVATE static JSGlobalObject* create(VM&amp;, Structure*);
  
      DECLARE_EXPORT_INFO;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,68 ***</span>
      JS_EXPORT_PRIVATE ~JSGlobalObject();
      JS_EXPORT_PRIVATE static void destroy(JSCell*);
  
      JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static void defineGetter(JSObject*, ExecState*, PropertyName, JSObject* getterFunc, unsigned attributes);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static void defineSetter(JSObject*, ExecState*, PropertyName, JSObject* setterFunc, unsigned attributes);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
  
<span class="line-modified">!     void addVar(ExecState* exec, const Identifier&amp; propertyName)</span>
      {
<span class="line-modified">!         if (!hasOwnProperty(exec, propertyName))</span>
              addGlobalVar(propertyName);
      }
<span class="line-modified">!     void addFunction(ExecState*, const Identifier&amp;);</span>
  
      JSScope* globalScope() { return m_globalLexicalEnvironment.get(); }
      JSGlobalLexicalEnvironment* globalLexicalEnvironment() { return m_globalLexicalEnvironment.get(); }
  
      JSScope* globalScopeExtension() { return m_globalScopeExtension.get(); }
      void setGlobalScopeExtension(JSScope*);
      void clearGlobalScopeExtension();
  
      // The following accessors return pristine values, even if a script
      // replaces the global object&#39;s associated property.
  
      GetterSetter* speciesGetterSetter() const { return m_speciesGetterSetter.get(); }
  
      ArrayConstructor* arrayConstructor() const { return m_arrayConstructor.get(); }
      ObjectConstructor* objectConstructor() const { return m_objectConstructor.get(); }
      JSPromiseConstructor* promiseConstructor() const { return m_promiseConstructor.get(); }
      JSInternalPromiseConstructor* internalPromiseConstructor() const { return m_internalPromiseConstructor.get(); }
  
  #if ENABLE(INTL)
<span class="line-modified">!     IntlCollator* defaultCollator(ExecState*);</span>
  #endif
  
      NullGetterFunction* nullGetterFunction() const { return m_nullGetterFunction.get(); }
      NullSetterFunction* nullSetterFunction() const { return m_nullSetterFunction.get(); }
  
      JSFunction* parseIntFunction() const { return m_parseIntFunction.get(this); }
      JSFunction* parseFloatFunction() const { return m_parseFloatFunction.get(this); }
  
      JSFunction* evalFunction() const { return m_evalFunction.get(this); }
<span class="line-modified">!     JSFunction* callFunction() const { return m_callFunction.get(); }</span>
<span class="line-removed">-     JSFunction* applyFunction() const { return m_applyFunction.get(); }</span>
<span class="line-removed">-     JSFunction* throwTypeErrorFunction() const { return m_throwTypeErrorFunction.get(); }</span>
      JSFunction* arrayProtoToStringFunction() const { return m_arrayProtoToStringFunction.get(this); }
      JSFunction* arrayProtoValuesFunction() const { return m_arrayProtoValuesFunction.get(this); }
<span class="line-removed">-     JSFunction* initializePromiseFunction() const { return m_initializePromiseFunction.get(this); }</span>
      JSFunction* iteratorProtocolFunction() const { return m_iteratorProtocolFunction.get(this); }
      JSFunction* promiseResolveFunction() const { return m_promiseResolveFunction.get(this); }
      JSFunction* objectProtoValueOfFunction() const { return m_objectProtoValueOfFunction.get(); }
<span class="line-modified">!     JSFunction* numberProtoToStringFunction() const { return m_numberProtoToStringFunction.get(); }</span>
<span class="line-removed">-     JSFunction* newPromiseCapabilityFunction() const { return m_newPromiseCapabilityFunction.get(); }</span>
      JSFunction* functionProtoHasInstanceSymbolFunction() const { return m_functionProtoHasInstanceSymbolFunction.get(); }
<span class="line-modified">!     JSObject* regExpProtoExecFunction() const { return m_regExpProtoExec.get(); }</span>
      JSObject* regExpProtoSymbolReplaceFunction() const { return m_regExpProtoSymbolReplace.get(); }
<span class="line-modified">!     JSObject* regExpProtoGlobalGetter() const { return m_regExpProtoGlobalGetter.get(); }</span>
<span class="line-modified">!     JSObject* regExpProtoUnicodeGetter() const { return m_regExpProtoUnicodeGetter.get(); }</span>
      GetterSetter* throwTypeErrorArgumentsCalleeAndCallerGetterSetter()
      {
          return m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter.get();
      }
  
<span class="line-new-header">--- 561,72 ---</span>
      JS_EXPORT_PRIVATE ~JSGlobalObject();
      JS_EXPORT_PRIVATE static void destroy(JSCell*);
  
      JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static void defineGetter(JSObject*, JSGlobalObject*, PropertyName, JSObject* getterFunc, unsigned attributes);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static void defineSetter(JSObject*, JSGlobalObject*, PropertyName, JSObject* setterFunc, unsigned attributes);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
  
<span class="line-modified">!     void addVar(JSGlobalObject* globalObject, const Identifier&amp; propertyName)</span>
      {
<span class="line-modified">!         if (!hasOwnProperty(globalObject, propertyName))</span>
              addGlobalVar(propertyName);
      }
<span class="line-modified">!     void addFunction(JSGlobalObject*, const Identifier&amp;);</span>
  
      JSScope* globalScope() { return m_globalLexicalEnvironment.get(); }
      JSGlobalLexicalEnvironment* globalLexicalEnvironment() { return m_globalLexicalEnvironment.get(); }
  
      JSScope* globalScopeExtension() { return m_globalScopeExtension.get(); }
      void setGlobalScopeExtension(JSScope*);
      void clearGlobalScopeExtension();
  
<span class="line-added">+     JSCallee* globalCallee() { return m_globalCallee.get(); }</span>
<span class="line-added">+ </span>
      // The following accessors return pristine values, even if a script
      // replaces the global object&#39;s associated property.
  
      GetterSetter* speciesGetterSetter() const { return m_speciesGetterSetter.get(); }
  
      ArrayConstructor* arrayConstructor() const { return m_arrayConstructor.get(); }
<span class="line-added">+     RegExpConstructor* regExpConstructor() const { return m_regExpConstructor.get(); }</span>
      ObjectConstructor* objectConstructor() const { return m_objectConstructor.get(); }
<span class="line-added">+     FunctionConstructor* functionConstructor() const { return m_functionConstructor.get(); }</span>
      JSPromiseConstructor* promiseConstructor() const { return m_promiseConstructor.get(); }
      JSInternalPromiseConstructor* internalPromiseConstructor() const { return m_internalPromiseConstructor.get(); }
  
  #if ENABLE(INTL)
<span class="line-modified">!     IntlCollator* defaultCollator() const { return m_defaultCollator.get(this); }</span>
  #endif
  
      NullGetterFunction* nullGetterFunction() const { return m_nullGetterFunction.get(); }
      NullSetterFunction* nullSetterFunction() const { return m_nullSetterFunction.get(); }
  
      JSFunction* parseIntFunction() const { return m_parseIntFunction.get(this); }
      JSFunction* parseFloatFunction() const { return m_parseFloatFunction.get(this); }
  
      JSFunction* evalFunction() const { return m_evalFunction.get(this); }
<span class="line-modified">!     JSFunction* throwTypeErrorFunction() const;</span>
      JSFunction* arrayProtoToStringFunction() const { return m_arrayProtoToStringFunction.get(this); }
      JSFunction* arrayProtoValuesFunction() const { return m_arrayProtoValuesFunction.get(this); }
      JSFunction* iteratorProtocolFunction() const { return m_iteratorProtocolFunction.get(this); }
<span class="line-added">+     JSFunction* newPromiseCapabilityFunction() const;</span>
      JSFunction* promiseResolveFunction() const { return m_promiseResolveFunction.get(this); }
<span class="line-added">+     JSFunction* resolvePromiseFunction() const;</span>
<span class="line-added">+     JSFunction* rejectPromiseFunction() const;</span>
<span class="line-added">+     JSFunction* promiseProtoThenFunction() const;</span>
      JSFunction* objectProtoValueOfFunction() const { return m_objectProtoValueOfFunction.get(); }
<span class="line-modified">!     JSFunction* numberProtoToStringFunction() const { return m_numberProtoToStringFunction.getInitializedOnMainThread(this); }</span>
      JSFunction* functionProtoHasInstanceSymbolFunction() const { return m_functionProtoHasInstanceSymbolFunction.get(); }
<span class="line-modified">!     JSFunction* regExpProtoExecFunction() const;</span>
      JSObject* regExpProtoSymbolReplaceFunction() const { return m_regExpProtoSymbolReplace.get(); }
<span class="line-modified">!     GetterSetter* regExpProtoGlobalGetter() const;</span>
<span class="line-modified">!     GetterSetter* regExpProtoUnicodeGetter() const;</span>
      GetterSetter* throwTypeErrorArgumentsCalleeAndCallerGetterSetter()
      {
          return m_throwTypeErrorArgumentsCalleeAndCallerGetterSetter.get();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,13 ***</span>
      IteratorPrototype* iteratorPrototype() const { return m_iteratorPrototype.get(); }
      AsyncIteratorPrototype* asyncIteratorPrototype() const { return m_asyncIteratorPrototype.get(); }
      GeneratorFunctionPrototype* generatorFunctionPrototype() const { return m_generatorFunctionPrototype.get(); }
      GeneratorPrototype* generatorPrototype() const { return m_generatorPrototype.get(); }
      AsyncFunctionPrototype* asyncFunctionPrototype() const { return m_asyncFunctionPrototype.get(); }
<span class="line-modified">!     MapPrototype* mapPrototype() const { return m_mapPrototype.get(); }</span>
      // Workaround for the name conflict between JSCell::setPrototype.
<span class="line-modified">!     SetPrototype* jsSetPrototype() const { return m_setPrototype.get(); }</span>
      JSPromisePrototype* promisePrototype() const { return m_promisePrototype.get(); }
      AsyncGeneratorPrototype* asyncGeneratorPrototype() const { return m_asyncGeneratorPrototype.get(); }
      AsyncGeneratorFunctionPrototype* asyncGeneratorFunctionPrototype() const { return m_asyncGeneratorFunctionPrototype.get(); }
  
      Structure* debuggerScopeStructure() const { return m_debuggerScopeStructure.get(this); }
<span class="line-new-header">--- 646,14 ---</span>
      IteratorPrototype* iteratorPrototype() const { return m_iteratorPrototype.get(); }
      AsyncIteratorPrototype* asyncIteratorPrototype() const { return m_asyncIteratorPrototype.get(); }
      GeneratorFunctionPrototype* generatorFunctionPrototype() const { return m_generatorFunctionPrototype.get(); }
      GeneratorPrototype* generatorPrototype() const { return m_generatorPrototype.get(); }
      AsyncFunctionPrototype* asyncFunctionPrototype() const { return m_asyncFunctionPrototype.get(); }
<span class="line-modified">!     ArrayIteratorPrototype* arrayIteratorPrototype() const { return m_arrayIteratorPrototype.get(); }</span>
<span class="line-added">+     JSObject* mapPrototype() const { return m_mapStructure.prototype(this); }</span>
      // Workaround for the name conflict between JSCell::setPrototype.
<span class="line-modified">!     JSObject* jsSetPrototype() const { return m_setStructure.prototype(this); }</span>
      JSPromisePrototype* promisePrototype() const { return m_promisePrototype.get(); }
      AsyncGeneratorPrototype* asyncGeneratorPrototype() const { return m_asyncGeneratorPrototype.get(); }
      AsyncGeneratorFunctionPrototype* asyncGeneratorFunctionPrototype() const { return m_asyncGeneratorFunctionPrototype.get(); }
  
      Structure* debuggerScopeStructure() const { return m_debuggerScopeStructure.get(this); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 669,17 ***</span>
      Structure* arrayStructureForIndexingTypeDuringAllocation(IndexingType indexingType) const
      {
          ASSERT(indexingType &amp; IsArray);
          return m_arrayStructureForIndexingShapeDuringAllocation[arrayIndexFromIndexingType(indexingType)].get();
      }
<span class="line-modified">!     Structure* arrayStructureForIndexingTypeDuringAllocation(ExecState* exec, IndexingType indexingType, JSValue newTarget) const</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-         return InternalFunction::createSubclassStructure(exec, newTarget, arrayStructureForIndexingTypeDuringAllocation(indexingType));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Structure* arrayStructureForProfileDuringAllocation(ExecState* exec, ArrayAllocationProfile* profile, JSValue newTarget) const</span>
      {
<span class="line-modified">!         return arrayStructureForIndexingTypeDuringAllocation(exec, ArrayAllocationProfile::selectIndexingTypeFor(profile), newTarget);</span>
      }
  
      bool isOriginalArrayStructure(Structure* structure)
      {
          return originalArrayStructureForIndexingType(structure-&gt;indexingMode() | IsArray) == structure;
<span class="line-new-header">--- 673,14 ---</span>
      Structure* arrayStructureForIndexingTypeDuringAllocation(IndexingType indexingType) const
      {
          ASSERT(indexingType &amp; IsArray);
          return m_arrayStructureForIndexingShapeDuringAllocation[arrayIndexFromIndexingType(indexingType)].get();
      }
<span class="line-modified">!     Structure* arrayStructureForIndexingTypeDuringAllocation(JSGlobalObject* globalObject, IndexingType indexingType, JSValue newTarget) const;</span>
<span class="line-modified">!     Structure* arrayStructureForProfileDuringAllocation(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, JSValue newTarget) const</span>
      {
<span class="line-modified">!         return arrayStructureForIndexingTypeDuringAllocation(globalObject, ArrayAllocationProfile::selectIndexingTypeFor(profile), newTarget);</span>
      }
  
      bool isOriginalArrayStructure(Structure* structure)
      {
          return originalArrayStructureForIndexingType(structure-&gt;indexingMode() | IsArray) == structure;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 744,23 ***</span>
          return m_ordinaryFunctions.strictFunctionStructure.get();
      }
  
      Structure* boundFunctionStructure() const { return m_boundFunctionStructure.get(this); }
      Structure* customGetterSetterFunctionStructure() const { return m_customGetterSetterFunctionStructure.get(this); }
<span class="line-removed">-     Structure* getterSetterStructure() const { return m_getterSetterStructure.get(); }</span>
      Structure* nativeStdFunctionStructure() const { return m_nativeStdFunctionStructure.get(this); }
      PropertyOffset functionNameOffset() const { return m_functionNameOffset; }
      Structure* numberObjectStructure() const { return m_numberObjectStructure.get(this); }
<span class="line-removed">-     Structure* mapStructure() const { return m_mapStructure.get(); }</span>
      Structure* regExpStructure() const { return m_regExpStructure.get(); }
      Structure* generatorFunctionStructure() const { return m_generatorFunctionStructure.get(); }
      Structure* asyncFunctionStructure() const { return m_asyncFunctionStructure.get(); }
      Structure* asyncGeneratorFunctionStructure() const { return m_asyncGeneratorFunctionStructure.get(); }
      Structure* stringObjectStructure() const { return m_stringObjectStructure.get(); }
      Structure* iteratorResultObjectStructure() const { return m_iteratorResultObjectStructure.get(this); }
      Structure* regExpMatchesArrayStructure() const { return m_regExpMatchesArrayStructure.get(); }
<span class="line-removed">-     Structure* regExpMatchesArrayWithGroupsStructure() const { return m_regExpMatchesArrayWithGroupsStructure.get(); }</span>
      Structure* moduleRecordStructure() const { return m_moduleRecordStructure.get(this); }
      Structure* moduleNamespaceObjectStructure() const { return m_moduleNamespaceObjectStructure.get(this); }
      Structure* proxyObjectStructure() const { return m_proxyObjectStructure.get(this); }
      Structure* callableProxyObjectStructure() const { return m_callableProxyObjectStructure.get(this); }
      Structure* proxyRevokeStructure() const { return m_proxyRevokeStructure.get(this); }
<span class="line-new-header">--- 745,23 ---</span>
          return m_ordinaryFunctions.strictFunctionStructure.get();
      }
  
      Structure* boundFunctionStructure() const { return m_boundFunctionStructure.get(this); }
      Structure* customGetterSetterFunctionStructure() const { return m_customGetterSetterFunctionStructure.get(this); }
      Structure* nativeStdFunctionStructure() const { return m_nativeStdFunctionStructure.get(this); }
      PropertyOffset functionNameOffset() const { return m_functionNameOffset; }
      Structure* numberObjectStructure() const { return m_numberObjectStructure.get(this); }
      Structure* regExpStructure() const { return m_regExpStructure.get(); }
<span class="line-added">+     Structure* generatorStructure() const { return m_generatorStructure.get(); }</span>
<span class="line-added">+     Structure* asyncGeneratorStructure() const { return m_asyncGeneratorStructure.get(); }</span>
      Structure* generatorFunctionStructure() const { return m_generatorFunctionStructure.get(); }
      Structure* asyncFunctionStructure() const { return m_asyncFunctionStructure.get(); }
      Structure* asyncGeneratorFunctionStructure() const { return m_asyncGeneratorFunctionStructure.get(); }
<span class="line-added">+     Structure* arrayIteratorStructure() const { return m_arrayIteratorStructure.get(); }</span>
      Structure* stringObjectStructure() const { return m_stringObjectStructure.get(); }
      Structure* iteratorResultObjectStructure() const { return m_iteratorResultObjectStructure.get(this); }
      Structure* regExpMatchesArrayStructure() const { return m_regExpMatchesArrayStructure.get(); }
      Structure* moduleRecordStructure() const { return m_moduleRecordStructure.get(this); }
      Structure* moduleNamespaceObjectStructure() const { return m_moduleNamespaceObjectStructure.get(this); }
      Structure* proxyObjectStructure() const { return m_proxyObjectStructure.get(this); }
      Structure* callableProxyObjectStructure() const { return m_callableProxyObjectStructure.get(this); }
      Structure* proxyRevokeStructure() const { return m_proxyRevokeStructure.get(this); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 769,11 ***</span>
  #if ENABLE(WEBASSEMBLY)
      Structure* webAssemblyModuleRecordStructure() const { return m_webAssemblyModuleRecordStructure.get(this); }
      Structure* webAssemblyFunctionStructure() const { return m_webAssemblyFunctionStructure.get(this); }
      Structure* jsToWasmICCalleeStructure() const { return m_jsToWasmICCalleeStructure.get(this); }
      Structure* webAssemblyWrapperFunctionStructure() const { return m_webAssemblyWrapperFunctionStructure.get(this); }
<span class="line-removed">-     Structure* webAssemblyToJSCalleeStructure() const { return m_webAssemblyToJSCalleeStructure.get(this); }</span>
  #endif // ENABLE(WEBASSEMBLY)
  #if ENABLE(INTL)
      Structure* collatorStructure() { return m_collatorStructure.get(this); }
      Structure* numberFormatStructure() { return m_numberFormatStructure.get(this); }
      Structure* dateTimeFormatStructure() { return m_dateTimeFormatStructure.get(this); }
<span class="line-new-header">--- 770,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,17 ***</span>
  #if ENABLE(REMOTE_INSPECTOR)
      Inspector::JSGlobalObjectInspectorController&amp; inspectorController() const { return *m_inspectorController.get(); }
      JSGlobalObjectDebuggable&amp; inspectorDebuggable() { return *m_inspectorDebuggable.get(); }
  #endif
  
<span class="line-removed">- #if ENABLE(INTL)</span>
<span class="line-removed">-     const HashSet&lt;String&gt;&amp; intlCollatorAvailableLocales();</span>
<span class="line-removed">-     const HashSet&lt;String&gt;&amp; intlDateTimeFormatAvailableLocales();</span>
<span class="line-removed">-     const HashSet&lt;String&gt;&amp; intlNumberFormatAvailableLocales();</span>
<span class="line-removed">-     const HashSet&lt;String&gt;&amp; intlPluralRulesAvailableLocales();</span>
<span class="line-removed">- #endif // ENABLE(INTL)</span>
<span class="line-removed">- </span>
      void bumpGlobalLexicalBindingEpoch(VM&amp;);
      unsigned globalLexicalBindingEpoch() const { return m_globalLexicalBindingEpoch; }
      static ptrdiff_t globalLexicalBindingEpochOffset() { return OBJECT_OFFSETOF(JSGlobalObject, m_globalLexicalBindingEpoch); }
      unsigned* addressOfGlobalLexicalBindingEpoch() { return &amp;m_globalLexicalBindingEpoch; }
  
<span class="line-new-header">--- 789,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 899,20 ***</span>
      JSObject* typedArrayConstructor(TypedArrayType type) const
      {
          return lazyTypedArrayStructure(type).constructor(this);
      }
  
<span class="line-modified">!     JSCell* actualPointerFor(Special::Pointer pointer)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         ASSERT(pointer &lt; Special::TableSize);</span>
<span class="line-removed">-         return m_specialPointers[pointer];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     JSCell* jsCellForLinkTimeConstant(LinkTimeConstant type)</span>
      {
<span class="line-modified">!         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-modified">!         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-modified">!         return m_linkTimeConstants[index];</span>
      }
  
      WatchpointSet* masqueradesAsUndefinedWatchpoint() { return m_masqueradesAsUndefinedWatchpoint.get(); }
      WatchpointSet* havingABadTimeWatchpoint() { return m_havingABadTimeWatchpoint.get(); }
      WatchpointSet* varInjectionWatchpoint() { return m_varInjectionWatchpoint.get(); }
<span class="line-new-header">--- 892,15 ---</span>
      JSObject* typedArrayConstructor(TypedArrayType type) const
      {
          return lazyTypedArrayStructure(type).constructor(this);
      }
  
<span class="line-modified">!     JSCell* linkTimeConstant(LinkTimeConstant value) const</span>
      {
<span class="line-modified">!         JSCell* result = m_linkTimeConstants[static_cast&lt;unsigned&gt;(value)].getInitializedOnMainThread(this);</span>
<span class="line-modified">!         ASSERT(result);</span>
<span class="line-modified">!         return result;</span>
      }
  
      WatchpointSet* masqueradesAsUndefinedWatchpoint() { return m_masqueradesAsUndefinedWatchpoint.get(); }
      WatchpointSet* havingABadTimeWatchpoint() { return m_havingABadTimeWatchpoint.get(); }
      WatchpointSet* varInjectionWatchpoint() { return m_varInjectionWatchpoint.get(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 939,13 ***</span>
      Debugger* debugger() const { return m_debugger; }
      void setDebugger(Debugger*);
  
      const GlobalObjectMethodTable* globalObjectMethodTable() const { return m_globalObjectMethodTable; }
  
<span class="line-modified">!     static bool supportsRichSourceInfo(const JSGlobalObject*) { return true; }</span>
  
<span class="line-modified">!     JS_EXPORT_PRIVATE ExecState* globalExec();</span>
  
      static bool shouldInterruptScript(const JSGlobalObject*) { return true; }
      static bool shouldInterruptScriptBeforeTimeout(const JSGlobalObject*) { return false; }
      static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags(); }
  
<span class="line-new-header">--- 927,13 ---</span>
      Debugger* debugger() const { return m_debugger; }
      void setDebugger(Debugger*);
  
      const GlobalObjectMethodTable* globalObjectMethodTable() const { return m_globalObjectMethodTable; }
  
<span class="line-modified">!     JS_EXPORT_PRIVATE CallFrame* deprecatedCallFrameForDebugger();</span>
  
<span class="line-modified">!     static bool supportsRichSourceInfo(const JSGlobalObject*) { return true; }</span>
  
      static bool shouldInterruptScript(const JSGlobalObject*) { return true; }
      static bool shouldInterruptScriptBeforeTimeout(const JSGlobalObject*) { return false; }
      static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags(); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 964,18 ***</span>
      {
          m_webAssemblyEnabled = enabled;
          m_webAssemblyDisabledErrorMessage = errorMessage;
      }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
<span class="line-modified">!     const ExecState* callFrameAtDebuggerEntry() const { return m_callFrameAtDebuggerEntry; }</span>
<span class="line-modified">!     void setCallFrameAtDebuggerEntry(const ExecState* callFrame) { m_callFrameAtDebuggerEntry = callFrame; }</span>
  #endif
  
      void resetPrototype(VM&amp;, JSValue prototype);
  
<span class="line-modified">!     VM&amp; vm() const { return m_vm; }</span>
      JSObject* globalThis() const;
      WriteBarrier&lt;JSObject&gt;* addressOfGlobalThis() { return &amp;m_globalThis; }
      OptionSet&lt;CodeGenerationMode&gt; defaultCodeGenerationMode() const;
  
      static Structure* createStructure(VM&amp; vm, JSValue prototype)
<span class="line-new-header">--- 952,18 ---</span>
      {
          m_webAssemblyEnabled = enabled;
          m_webAssemblyDisabledErrorMessage = errorMessage;
      }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
<span class="line-modified">!     const JSGlobalObject* globalObjectAtDebuggerEntry() const { return m_globalObjectAtDebuggerEntry; }</span>
<span class="line-modified">!     void setGlobalObjectAtDebuggerEntry(const JSGlobalObject* globalObject) { m_globalObjectAtDebuggerEntry = globalObject; }</span>
  #endif
  
      void resetPrototype(VM&amp;, JSValue prototype);
  
<span class="line-modified">!     VM&amp; vm() const { return *m_vm; }</span>
      JSObject* globalThis() const;
      WriteBarrier&lt;JSObject&gt;* addressOfGlobalThis() { return &amp;m_globalThis; }
      OptionSet&lt;CodeGenerationMode&gt; defaultCodeGenerationMode() const;
  
      static Structure* createStructure(VM&amp; vm, JSValue prototype)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1018,11 ***</span>
  #ifdef JSC_GLIB_API_ENABLED
      WrapperMap* wrapperMap() const { return m_wrapperMap.get(); }
      void setWrapperMap(std::unique_ptr&lt;WrapperMap&gt;&amp;&amp;);
  #endif
  
<span class="line-modified">!     void tryInstallArraySpeciesWatchpoint(ExecState*);</span>
  
  protected:
      struct GlobalPropertyInfo {
          GlobalPropertyInfo(const Identifier&amp; i, JSValue v, unsigned a)
              : identifier(i)
<span class="line-new-header">--- 1006,14 ---</span>
  #ifdef JSC_GLIB_API_ENABLED
      WrapperMap* wrapperMap() const { return m_wrapperMap.get(); }
      void setWrapperMap(std::unique_ptr&lt;WrapperMap&gt;&amp;&amp;);
  #endif
  
<span class="line-modified">!     void tryInstallArraySpeciesWatchpoint();</span>
<span class="line-added">+     void installNumberPrototypeWatchpoint(NumberPrototype*);</span>
<span class="line-added">+     void installMapPrototypeWatchpoint(MapPrototype*);</span>
<span class="line-added">+     void installSetPrototypeWatchpoint(SetPrototype*);</span>
  
  protected:
      struct GlobalPropertyInfo {
          GlobalPropertyInfo(const Identifier&amp; i, JSValue v, unsigned a)
              : identifier(i)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1060,79 ***</span>
  #ifdef JSC_GLIB_API_ENABLED
      std::unique_ptr&lt;WrapperMap&gt; m_wrapperMap;
  #endif
  };
  
<span class="line-modified">! inline JSArray* constructEmptyArray(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, unsigned initialLength = 0, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      Structure* structure;
      if (initialLength &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)
<span class="line-modified">!         structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(exec, ArrayWithArrayStorage, newTarget);</span>
      else
<span class="line-modified">!         structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      JSArray* result = JSArray::tryCreate(vm, structure, initialLength);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      return ArrayAllocationProfile::updateLastAllocationFor(profile, result);
  }
  
<span class="line-modified">! inline JSArray* constructEmptyArray(ExecState* exec, ArrayAllocationProfile* profile, unsigned initialLength = 0, JSValue newTarget = JSValue())</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return constructEmptyArray(exec, profile, exec-&gt;lexicalGlobalObject(), initialLength, newTarget);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, const ArgList&amp; values, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(exec, structure, values));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, const ArgList&amp; values, JSValue newTarget = JSValue())</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return constructArray(exec, profile, exec-&gt;lexicalGlobalObject(), values, newTarget);</span>
  }
  
<span class="line-modified">! inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, const JSValue* values, unsigned length, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(exec, structure, values, length));</span>
  }
  
<span class="line-modified">! inline JSArray* constructArray(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     return constructArray(exec, profile, exec-&gt;lexicalGlobalObject(), values, length, newTarget);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline JSArray* constructArrayNegativeIndexed(ExecState* exec, ArrayAllocationProfile* profile, JSGlobalObject* globalObject, const JSValue* values, unsigned length, JSValue newTarget = JSValue())</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(exec, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArrayNegativeIndexed(exec, structure, values, length));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline JSArray* constructArrayNegativeIndexed(ExecState* exec, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return constructArrayNegativeIndexed(exec, profile, exec-&gt;lexicalGlobalObject(), values, length, newTarget);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline JSObject* ExecState::globalThisValue() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return lexicalGlobalObject()-&gt;globalThis();</span>
  }
  
  inline JSObject* JSScope::globalThis()
  {
      return globalObject()-&gt;globalThis();
<span class="line-new-header">--- 1051,54 ---</span>
  #ifdef JSC_GLIB_API_ENABLED
      std::unique_ptr&lt;WrapperMap&gt; m_wrapperMap;
  #endif
  };
  
<span class="line-modified">! inline JSArray* constructEmptyArray(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, unsigned initialLength = 0, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      Structure* structure;
      if (initialLength &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)
<span class="line-modified">!         structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(globalObject, ArrayWithArrayStorage, newTarget);</span>
      else
<span class="line-modified">!         structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      JSArray* result = JSArray::tryCreate(vm, structure, initialLength);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      return ArrayAllocationProfile::updateLastAllocationFor(profile, result);
  }
  
<span class="line-modified">! inline JSArray* constructArray(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const ArgList&amp; values, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(globalObject, structure, values));</span>
  }
  
<span class="line-modified">! inline JSArray* constructArray(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArray(globalObject, structure, values, length));</span>
  }
  
<span class="line-modified">! inline JSArray* constructArrayNegativeIndexed(JSGlobalObject* globalObject, ArrayAllocationProfile* profile, const JSValue* values, unsigned length, JSValue newTarget = JSValue())</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     Structure* structure = globalObject-&gt;arrayStructureForProfileDuringAllocation(globalObject, profile, newTarget);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!     return ArrayAllocationProfile::updateLastAllocationFor(profile, constructArrayNegativeIndexed(globalObject, structure, values, length));</span>
  }
  
  inline JSObject* JSScope::globalThis()
  {
      return globalObject()-&gt;globalThis();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1146,13 ***</span>
  inline OptionSet&lt;CodeGenerationMode&gt; JSGlobalObject::defaultCodeGenerationMode() const
  {
      OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode;
      if (hasInteractiveDebugger() || Options::forceDebuggerBytecodeGeneration())
          codeGenerationMode.add(CodeGenerationMode::Debugger);
<span class="line-modified">!     if (m_vm.typeProfiler())</span>
          codeGenerationMode.add(CodeGenerationMode::TypeProfiler);
<span class="line-modified">!     if (m_vm.controlFlowProfiler())</span>
          codeGenerationMode.add(CodeGenerationMode::ControlFlowProfiler);
      return codeGenerationMode;
  }
  
  } // namespace JSC
<span class="line-new-header">--- 1112,13 ---</span>
  inline OptionSet&lt;CodeGenerationMode&gt; JSGlobalObject::defaultCodeGenerationMode() const
  {
      OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode;
      if (hasInteractiveDebugger() || Options::forceDebuggerBytecodeGeneration())
          codeGenerationMode.add(CodeGenerationMode::Debugger);
<span class="line-modified">!     if (vm().typeProfiler())</span>
          codeGenerationMode.add(CodeGenerationMode::TypeProfiler);
<span class="line-modified">!     if (vm().controlFlowProfiler())</span>
          codeGenerationMode.add(CodeGenerationMode::ControlFlowProfiler);
      return codeGenerationMode;
  }
  
  } // namespace JSC
</pre>
<center><a href="JSGlobalObject.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalObjectFunctions.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
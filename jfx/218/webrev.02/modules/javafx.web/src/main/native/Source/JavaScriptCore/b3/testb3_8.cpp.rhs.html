<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_8.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;testb3.h&quot;
  28 
<a name="1" id="anc1"></a><span class="line-added">  29 #include &lt;wtf/UniqueArray.h&gt;</span>
<span class="line-added">  30 </span>
  31 #if ENABLE(B3_JIT)
  32 
  33 template&lt;typename T&gt;
  34 void testAtomicWeakCAS()
  35 {
  36     constexpr Type type = NativeTraits&lt;T&gt;::type;
  37     constexpr Width width = NativeTraits&lt;T&gt;::width;
  38 
  39     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
  40         if (isX86()) {
  41             checkUsesInstruction(compilation, &quot;lock&quot;);
  42             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
  43         } else {
  44             if (fenced) {
  45                 checkUsesInstruction(compilation, &quot;ldax&quot;);
  46                 checkUsesInstruction(compilation, &quot;stlx&quot;);
  47             } else {
  48                 checkUsesInstruction(compilation, &quot;ldx&quot;);
  49                 checkUsesInstruction(compilation, &quot;stx&quot;);
  50             }
  51         }
  52     };
  53 
  54     {
  55         Procedure proc;
  56         BasicBlock* root = proc.addBlock();
  57         BasicBlock* reloop = proc.addBlock();
  58         BasicBlock* done = proc.addBlock();
  59 
  60         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  61         root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
  62         root-&gt;setSuccessors(reloop);
  63 
  64         reloop-&gt;appendNew&lt;Value&gt;(
  65             proc, Branch, Origin(),
  66             reloop-&gt;appendNew&lt;AtomicValue&gt;(
  67                 proc, AtomicWeakCAS, Origin(), width,
  68                 reloop-&gt;appendIntConstant(proc, Origin(), type, 42),
  69                 reloop-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
  70                 ptr));
  71         reloop-&gt;setSuccessors(done, reloop);
  72 
  73         done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
  74 
  75         auto code = compileProc(proc);
  76         T value[2];
  77         value[0] = 42;
  78         value[1] = 13;
  79         invoke&lt;void&gt;(*code, value);
  80         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
  81         CHECK_EQ(value[1], 13);
  82         checkMyDisassembly(*code, true);
  83     }
  84 
  85     {
  86         Procedure proc;
  87         BasicBlock* root = proc.addBlock();
  88         BasicBlock* reloop = proc.addBlock();
  89         BasicBlock* done = proc.addBlock();
  90 
  91         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
  92         root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
  93         root-&gt;setSuccessors(reloop);
  94 
  95         reloop-&gt;appendNew&lt;Value&gt;(
  96             proc, Branch, Origin(),
  97             reloop-&gt;appendNew&lt;AtomicValue&gt;(
  98                 proc, AtomicWeakCAS, Origin(), width,
  99                 reloop-&gt;appendIntConstant(proc, Origin(), type, 42),
 100                 reloop-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 101                 ptr, 0, HeapRange(42), HeapRange()));
 102         reloop-&gt;setSuccessors(done, reloop);
 103 
 104         done-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 105 
 106         auto code = compileProc(proc);
 107         T value[2];
 108         value[0] = 42;
 109         value[1] = 13;
 110         invoke&lt;void&gt;(*code, value);
 111         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 112         CHECK_EQ(value[1], 13);
 113         checkMyDisassembly(*code, false);
 114     }
 115 
 116     {
 117         Procedure proc;
 118         BasicBlock* root = proc.addBlock();
 119         BasicBlock* succ = proc.addBlock();
 120         BasicBlock* fail = proc.addBlock();
 121 
 122         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 123         root-&gt;appendNew&lt;Value&gt;(
 124             proc, Branch, Origin(),
 125             root-&gt;appendNew&lt;AtomicValue&gt;(
 126                 proc, AtomicWeakCAS, Origin(), width,
 127                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 128                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 129                 ptr));
 130         root-&gt;setSuccessors(succ, fail);
 131 
 132         succ-&gt;appendNew&lt;MemoryValue&gt;(
 133             proc, storeOpcode(GP, width), Origin(),
 134             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 135             ptr);
 136         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 137 
 138         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 139 
 140         auto code = compileProc(proc);
 141         T value[2];
 142         value[0] = 42;
 143         value[1] = 13;
 144         while (value[0] == 42)
 145             invoke&lt;void&gt;(*code, value);
 146         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 147         CHECK_EQ(value[1], 13);
 148         value[0] = static_cast&lt;T&gt;(300);
 149         invoke&lt;void&gt;(*code, value);
 150         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 151         CHECK_EQ(value[1], 13);
 152         checkMyDisassembly(*code, true);
 153     }
 154 
 155     {
 156         Procedure proc;
 157         BasicBlock* root = proc.addBlock();
 158         BasicBlock* succ = proc.addBlock();
 159         BasicBlock* fail = proc.addBlock();
 160 
 161         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 162         root-&gt;appendNew&lt;Value&gt;(
 163             proc, Branch, Origin(),
 164             root-&gt;appendNew&lt;Value&gt;(
 165                 proc, Equal, Origin(),
 166                 root-&gt;appendNew&lt;AtomicValue&gt;(
 167                     proc, AtomicWeakCAS, Origin(), width,
 168                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 169                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 170                     ptr),
 171                 root-&gt;appendIntConstant(proc, Origin(), Int32, 0)));
 172         root-&gt;setSuccessors(fail, succ);
 173 
 174         succ-&gt;appendNew&lt;MemoryValue&gt;(
 175             proc, storeOpcode(GP, width), Origin(),
 176             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 177             ptr);
 178         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 179 
 180         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 181 
 182         auto code = compileProc(proc);
 183         T value[2];
 184         value[0] = 42;
 185         value[1] = 13;
 186         while (value[0] == 42)
 187             invoke&lt;void&gt;(*code, value);
 188         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 189         CHECK_EQ(value[1], 13);
 190         value[0] = static_cast&lt;T&gt;(300);
 191         invoke&lt;void&gt;(*code, value);
 192         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 193         CHECK_EQ(value[1], 13);
 194         checkMyDisassembly(*code, true);
 195     }
 196 
 197     {
 198         Procedure proc;
 199         BasicBlock* root = proc.addBlock();
 200         root-&gt;appendNew&lt;Value&gt;(
 201             proc, Return, Origin(),
 202             root-&gt;appendNew&lt;AtomicValue&gt;(
 203                 proc, AtomicWeakCAS, Origin(), width,
 204                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 205                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 206                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 207 
 208         auto code = compileProc(proc);
 209         T value[2];
 210         value[0] = 42;
 211         value[1] = 13;
 212         while (!invoke&lt;bool&gt;(*code, value)) { }
 213         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 214         CHECK_EQ(value[1], 13);
 215 
 216         value[0] = static_cast&lt;T&gt;(300);
 217         CHECK(!invoke&lt;bool&gt;(*code, value));
 218         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 219         CHECK_EQ(value[1], 13);
 220         checkMyDisassembly(*code, true);
 221     }
 222 
 223     {
 224         Procedure proc;
 225         BasicBlock* root = proc.addBlock();
 226         root-&gt;appendNew&lt;Value&gt;(
 227             proc, Return, Origin(),
 228             root-&gt;appendNew&lt;Value&gt;(
 229                 proc, Equal, Origin(),
 230                 root-&gt;appendNew&lt;AtomicValue&gt;(
 231                     proc, AtomicWeakCAS, Origin(), width,
 232                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 233                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 234                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 235                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
 236 
 237         auto code = compileProc(proc);
 238         T value[2];
 239         value[0] = 42;
 240         value[1] = 13;
 241         while (invoke&lt;bool&gt;(*code, value)) { }
 242         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 243         CHECK_EQ(value[1], 13);
 244 
 245         value[0] = static_cast&lt;T&gt;(300);
 246         CHECK(invoke&lt;bool&gt;(*code, value));
 247         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 248         CHECK_EQ(value[1], 13);
 249         checkMyDisassembly(*code, true);
 250     }
 251 
 252     {
 253         Procedure proc;
 254         BasicBlock* root = proc.addBlock();
 255         root-&gt;appendNew&lt;Value&gt;(
 256             proc, Return, Origin(),
 257             root-&gt;appendNew&lt;AtomicValue&gt;(
 258                 proc, AtomicWeakCAS, Origin(), width,
 259                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 260                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 261                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 262                 42));
 263 
 264         auto code = compileProc(proc);
 265         T value[2];
 266         value[0] = 42;
 267         value[1] = 13;
 268         while (!invoke&lt;bool&gt;(*code, bitwise_cast&lt;intptr_t&gt;(value) - 42)) { }
 269         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 270         CHECK_EQ(value[1], 13);
 271 
 272         value[0] = static_cast&lt;T&gt;(300);
 273         CHECK(!invoke&lt;bool&gt;(*code, bitwise_cast&lt;intptr_t&gt;(value) - 42));
 274         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 275         CHECK_EQ(value[1], 13);
 276         checkMyDisassembly(*code, true);
 277     }
 278 }
 279 
 280 template&lt;typename T&gt;
 281 void testAtomicStrongCAS()
 282 {
 283     constexpr Type type = NativeTraits&lt;T&gt;::type;
 284     constexpr Width width = NativeTraits&lt;T&gt;::width;
 285 
 286     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
 287         if (isX86()) {
 288             checkUsesInstruction(compilation, &quot;lock&quot;);
 289             checkUsesInstruction(compilation, &quot;cmpxchg&quot;);
 290         } else {
 291             if (fenced) {
 292                 checkUsesInstruction(compilation, &quot;ldax&quot;);
 293                 checkUsesInstruction(compilation, &quot;stlx&quot;);
 294             } else {
 295                 checkUsesInstruction(compilation, &quot;ldx&quot;);
 296                 checkUsesInstruction(compilation, &quot;stx&quot;);
 297             }
 298         }
 299     };
 300 
 301     {
 302         Procedure proc;
 303         BasicBlock* root = proc.addBlock();
 304         BasicBlock* succ = proc.addBlock();
 305         BasicBlock* fail = proc.addBlock();
 306 
 307         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 308         root-&gt;appendNew&lt;Value&gt;(
 309             proc, Branch, Origin(),
 310             root-&gt;appendNew&lt;Value&gt;(
 311                 proc, Equal, Origin(),
 312                 root-&gt;appendNew&lt;AtomicValue&gt;(
 313                     proc, AtomicStrongCAS, Origin(), width,
 314                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 315                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 316                     ptr),
 317                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 318         root-&gt;setSuccessors(succ, fail);
 319 
 320         succ-&gt;appendNew&lt;MemoryValue&gt;(
 321             proc, storeOpcode(GP, width), Origin(),
 322             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 323             ptr);
 324         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 325 
 326         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 327 
 328         auto code = compileProc(proc);
 329         T value[2];
 330         value[0] = 42;
 331         value[1] = 13;
 332         invoke&lt;void&gt;(*code, value);
 333         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 334         CHECK_EQ(value[1], 13);
 335         value[0] = static_cast&lt;T&gt;(300);
 336         invoke&lt;void&gt;(*code, value);
 337         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 338         CHECK_EQ(value[1], 13);
 339         checkMyDisassembly(*code, true);
 340     }
 341 
 342     {
 343         Procedure proc;
 344         BasicBlock* root = proc.addBlock();
 345         BasicBlock* succ = proc.addBlock();
 346         BasicBlock* fail = proc.addBlock();
 347 
 348         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 349         root-&gt;appendNew&lt;Value&gt;(
 350             proc, Branch, Origin(),
 351             root-&gt;appendNew&lt;Value&gt;(
 352                 proc, Equal, Origin(),
 353                 root-&gt;appendNew&lt;AtomicValue&gt;(
 354                     proc, AtomicStrongCAS, Origin(), width,
 355                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 356                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 357                     ptr, 0, HeapRange(42), HeapRange()),
 358                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 359         root-&gt;setSuccessors(succ, fail);
 360 
 361         succ-&gt;appendNew&lt;MemoryValue&gt;(
 362             proc, storeOpcode(GP, width), Origin(),
 363             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 364             ptr);
 365         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 366 
 367         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 368 
 369         auto code = compileProc(proc);
 370         T value[2];
 371         value[0] = 42;
 372         value[1] = 13;
 373         invoke&lt;void&gt;(*code, value);
 374         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 375         CHECK_EQ(value[1], 13);
 376         value[0] = static_cast&lt;T&gt;(300);
 377         invoke&lt;void&gt;(*code, value);
 378         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 379         CHECK_EQ(value[1], 13);
 380         checkMyDisassembly(*code, false);
 381     }
 382 
 383     {
 384         Procedure proc;
 385         BasicBlock* root = proc.addBlock();
 386         BasicBlock* succ = proc.addBlock();
 387         BasicBlock* fail = proc.addBlock();
 388 
 389         Value* ptr = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 390         root-&gt;appendNew&lt;Value&gt;(
 391             proc, Branch, Origin(),
 392             root-&gt;appendNew&lt;Value&gt;(
 393                 proc, NotEqual, Origin(),
 394                 root-&gt;appendNew&lt;AtomicValue&gt;(
 395                     proc, AtomicStrongCAS, Origin(), width,
 396                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 397                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 398                     ptr),
 399                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 400         root-&gt;setSuccessors(fail, succ);
 401 
 402         succ-&gt;appendNew&lt;MemoryValue&gt;(
 403             proc, storeOpcode(GP, width), Origin(),
 404             succ-&gt;appendIntConstant(proc, Origin(), type, 100),
 405             ptr);
 406         succ-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 407 
 408         fail-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 409 
 410         auto code = compileProc(proc);
 411         T value[2];
 412         value[0] = 42;
 413         value[1] = 13;
 414         invoke&lt;void&gt;(*code, value);
 415         CHECK_EQ(value[0], static_cast&lt;T&gt;(100));
 416         CHECK_EQ(value[1], 13);
 417         value[0] = static_cast&lt;T&gt;(300);
 418         invoke&lt;void&gt;(*code, value);
 419         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 420         CHECK_EQ(value[1], 13);
 421         checkMyDisassembly(*code, true);
 422     }
 423 
 424     {
 425         Procedure proc;
 426         BasicBlock* root = proc.addBlock();
 427         root-&gt;appendNew&lt;Value&gt;(
 428             proc, Return, Origin(),
 429             root-&gt;appendNew&lt;AtomicValue&gt;(
 430                 proc, AtomicStrongCAS, Origin(), width,
 431                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 432                 root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 433                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 434 
 435         auto code = compileProc(proc);
 436         T value[2];
 437         value[0] = 42;
 438         value[1] = 13;
 439         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), 42);
 440         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 441         CHECK_EQ(value[1], 13);
 442         value[0] = static_cast&lt;T&gt;(300);
 443         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(300)));
 444         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 445         CHECK_EQ(value[1], 13);
 446         value[0] = static_cast&lt;T&gt;(-1);
 447         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(-1)));
 448         CHECK_EQ(value[0], static_cast&lt;T&gt;(-1));
 449         CHECK_EQ(value[1], 13);
 450         checkMyDisassembly(*code, true);
 451     }
 452 
 453     {
 454         // Test for https://bugs.webkit.org/show_bug.cgi?id=169867.
 455 
 456         Procedure proc;
 457         BasicBlock* root = proc.addBlock();
 458         root-&gt;appendNew&lt;Value&gt;(
 459             proc, Return, Origin(),
 460             root-&gt;appendNew&lt;Value&gt;(
 461                 proc, BitXor, Origin(),
 462                 root-&gt;appendNew&lt;AtomicValue&gt;(
 463                     proc, AtomicStrongCAS, Origin(), width,
 464                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 465                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 466                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 467                 root-&gt;appendIntConstant(proc, Origin(), type, 1)));
 468 
 469         typename NativeTraits&lt;T&gt;::CanonicalType one = 1;
 470 
 471         auto code = compileProc(proc);
 472         T value[2];
 473         value[0] = 42;
 474         value[1] = 13;
 475         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), 42 ^ one);
 476         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 477         CHECK_EQ(value[1], 13);
 478         value[0] = static_cast&lt;T&gt;(300);
 479         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(300)) ^ one);
 480         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 481         CHECK_EQ(value[1], 13);
 482         value[0] = static_cast&lt;T&gt;(-1);
 483         CHECK_EQ(invoke&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(*code, value), static_cast&lt;typename NativeTraits&lt;T&gt;::CanonicalType&gt;(static_cast&lt;T&gt;(-1)) ^ one);
 484         CHECK_EQ(value[0], static_cast&lt;T&gt;(-1));
 485         CHECK_EQ(value[1], 13);
 486         checkMyDisassembly(*code, true);
 487     }
 488 
 489     {
 490         Procedure proc;
 491         BasicBlock* root = proc.addBlock();
 492         root-&gt;appendNew&lt;Value&gt;(
 493             proc, Return, Origin(),
 494             root-&gt;appendNew&lt;Value&gt;(
 495                 proc, Equal, Origin(),
 496                 root-&gt;appendNew&lt;AtomicValue&gt;(
 497                     proc, AtomicStrongCAS, Origin(), width,
 498                     root-&gt;appendIntConstant(proc, Origin(), type, 42),
 499                     root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 500                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 501                 root-&gt;appendIntConstant(proc, Origin(), type, 42)));
 502 
 503         auto code = compileProc(proc);
 504         T value[2];
 505         value[0] = 42;
 506         value[1] = 13;
 507         CHECK(invoke&lt;bool&gt;(*code, value));
 508         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 509         CHECK_EQ(value[1], 13);
 510         value[0] = static_cast&lt;T&gt;(300);
 511         CHECK(!invoke&lt;bool&gt;(*code, value));
 512         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 513         CHECK_EQ(value[1], 13);
 514         checkMyDisassembly(*code, true);
 515     }
 516 
 517     {
 518         Procedure proc;
 519         BasicBlock* root = proc.addBlock();
 520         root-&gt;appendNew&lt;Value&gt;(
 521             proc, Return, Origin(),
 522             root-&gt;appendNew&lt;Value&gt;(
 523                 proc, Equal, Origin(),
 524                 root-&gt;appendNew&lt;Value&gt;(
 525                     proc, NotEqual, Origin(),
 526                     root-&gt;appendNew&lt;AtomicValue&gt;(
 527                         proc, AtomicStrongCAS, Origin(), width,
 528                         root-&gt;appendIntConstant(proc, Origin(), type, 42),
 529                         root-&gt;appendIntConstant(proc, Origin(), type, 0xbeef),
 530                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)),
 531                     root-&gt;appendIntConstant(proc, Origin(), type, 42)),
 532                 root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0)));
 533 
 534         auto code = compileProc(proc);
 535         T value[2];
 536         value[0] = 42;
 537         value[1] = 13;
 538         CHECK(invoke&lt;bool&gt;(*code, value));
 539         CHECK_EQ(value[0], static_cast&lt;T&gt;(0xbeef));
 540         CHECK_EQ(value[1], 13);
 541         value[0] = static_cast&lt;T&gt;(300);
 542         CHECK(!invoke&lt;bool&gt;(*code, &amp;value));
 543         CHECK_EQ(value[0], static_cast&lt;T&gt;(300));
 544         CHECK_EQ(value[1], 13);
 545         checkMyDisassembly(*code, true);
 546     }
 547 }
 548 
 549 template&lt;typename T&gt;
 550 void testAtomicXchg(B3::Opcode opcode)
 551 {
 552     constexpr Type type = NativeTraits&lt;T&gt;::type;
 553     constexpr Width width = NativeTraits&lt;T&gt;::width;
 554 
 555     auto doTheMath = [&amp;] (T&amp; memory, T operand) -&gt; T {
 556         T oldValue = memory;
 557         switch (opcode) {
 558         case AtomicXchgAdd:
 559             memory += operand;
 560             break;
 561         case AtomicXchgAnd:
 562             memory &amp;= operand;
 563             break;
 564         case AtomicXchgOr:
 565             memory |= operand;
 566             break;
 567         case AtomicXchgSub:
 568             memory -= operand;
 569             break;
 570         case AtomicXchgXor:
 571             memory ^= operand;
 572             break;
 573         case AtomicXchg:
 574             memory = operand;
 575             break;
 576         default:
 577             RELEASE_ASSERT_NOT_REACHED();
 578         }
 579         return oldValue;
 580     };
 581 
 582     auto oldValue = [&amp;] (T memory, T operand) -&gt; T {
 583         return doTheMath(memory, operand);
 584     };
 585 
 586     auto newValue = [&amp;] (T memory, T operand) -&gt; T {
 587         doTheMath(memory, operand);
 588         return memory;
 589     };
 590 
 591     auto checkMyDisassembly = [&amp;] (Compilation&amp; compilation, bool fenced) {
 592         if (isX86())
 593             checkUsesInstruction(compilation, &quot;lock&quot;);
 594         else {
 595             if (fenced) {
 596                 checkUsesInstruction(compilation, &quot;ldax&quot;);
 597                 checkUsesInstruction(compilation, &quot;stlx&quot;);
 598             } else {
 599                 checkUsesInstruction(compilation, &quot;ldx&quot;);
 600                 checkUsesInstruction(compilation, &quot;stx&quot;);
 601             }
 602         }
 603     };
 604 
 605     {
 606         Procedure proc;
 607         BasicBlock* root = proc.addBlock();
 608         root-&gt;appendNew&lt;Value&gt;(
 609             proc, Return, Origin(),
 610             root-&gt;appendNew&lt;AtomicValue&gt;(
 611                 proc, opcode, Origin(), width,
 612                 root-&gt;appendIntConstant(proc, Origin(), type, 1),
 613                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 614 
 615         auto code = compileProc(proc);
 616         T value[2];
 617         value[0] = 5;
 618         value[1] = 100;
 619         CHECK_EQ(invoke&lt;T&gt;(*code, value), oldValue(5, 1));
 620         CHECK_EQ(value[0], newValue(5, 1));
 621         CHECK_EQ(value[1], 100);
 622         checkMyDisassembly(*code, true);
 623     }
 624 
 625     {
 626         Procedure proc;
 627         BasicBlock* root = proc.addBlock();
 628         root-&gt;appendNew&lt;Value&gt;(
 629             proc, Return, Origin(),
 630             root-&gt;appendNew&lt;AtomicValue&gt;(
 631                 proc, opcode, Origin(), width,
 632                 root-&gt;appendIntConstant(proc, Origin(), type, 42),
 633                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 634 
 635         auto code = compileProc(proc);
 636         T value[2];
 637         value[0] = 5;
 638         value[1] = 100;
 639         CHECK_EQ(invoke&lt;T&gt;(*code, value), oldValue(5, 42));
 640         CHECK_EQ(value[0], newValue(5, 42));
 641         CHECK_EQ(value[1], 100);
 642         checkMyDisassembly(*code, true);
 643     }
 644 
 645     {
 646         Procedure proc;
 647         BasicBlock* root = proc.addBlock();
 648         root-&gt;appendNew&lt;AtomicValue&gt;(
 649             proc, opcode, Origin(), width,
 650             root-&gt;appendIntConstant(proc, Origin(), type, 42),
 651             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));
 652         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 653 
 654         auto code = compileProc(proc);
 655         T value[2];
 656         value[0] = 5;
 657         value[1] = 100;
 658         invoke&lt;T&gt;(*code, value);
 659         CHECK_EQ(value[0], newValue(5, 42));
 660         CHECK_EQ(value[1], 100);
 661         checkMyDisassembly(*code, true);
 662     }
 663 
 664     {
 665         Procedure proc;
 666         BasicBlock* root = proc.addBlock();
 667         root-&gt;appendNew&lt;AtomicValue&gt;(
 668             proc, opcode, Origin(), width,
 669             root-&gt;appendIntConstant(proc, Origin(), type, 42),
 670             root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 671             0, HeapRange(42), HeapRange());
 672         root-&gt;appendNew&lt;Value&gt;(proc, Return, Origin());
 673 
 674         auto code = compileProc(proc);
 675         T value[2];
 676         value[0] = 5;
 677         value[1] = 100;
 678         invoke&lt;T&gt;(*code, value);
 679         CHECK_EQ(value[0], newValue(5, 42));
 680         CHECK_EQ(value[1], 100);
 681         checkMyDisassembly(*code, false);
 682     }
 683 }
 684 
 685 void addAtomicTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
 686 {
 687     RUN(testAtomicWeakCAS&lt;int8_t&gt;());
 688     RUN(testAtomicWeakCAS&lt;int16_t&gt;());
 689     RUN(testAtomicWeakCAS&lt;int32_t&gt;());
 690     RUN(testAtomicWeakCAS&lt;int64_t&gt;());
 691     RUN(testAtomicStrongCAS&lt;int8_t&gt;());
 692     RUN(testAtomicStrongCAS&lt;int16_t&gt;());
 693     RUN(testAtomicStrongCAS&lt;int32_t&gt;());
 694     RUN(testAtomicStrongCAS&lt;int64_t&gt;());
 695     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgAdd));
 696     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgAdd));
 697     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgAdd));
 698     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgAdd));
 699     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgAnd));
 700     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgAnd));
 701     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgAnd));
 702     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgAnd));
 703     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgOr));
 704     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgOr));
 705     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgOr));
 706     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgOr));
 707     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgSub));
 708     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgSub));
 709     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgSub));
 710     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgSub));
 711     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchgXor));
 712     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchgXor));
 713     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchgXor));
 714     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchgXor));
 715     RUN(testAtomicXchg&lt;int8_t&gt;(AtomicXchg));
 716     RUN(testAtomicXchg&lt;int16_t&gt;(AtomicXchg));
 717     RUN(testAtomicXchg&lt;int32_t&gt;(AtomicXchg));
 718     RUN(testAtomicXchg&lt;int64_t&gt;(AtomicXchg));
 719 }
 720 
 721 template&lt;typename CType, typename InputType&gt;
 722 void testLoad(B3::Type type, B3::Opcode opcode, InputType value)
 723 {
 724     // Simple load from an absolute address.
 725     {
 726         Procedure proc;
 727         BasicBlock* root = proc.addBlock();
 728 
 729         root-&gt;appendNewControlValue(
 730             proc, Return, Origin(),
 731             root-&gt;appendNew&lt;MemoryValue&gt;(
 732                 proc, opcode, type, Origin(),
 733                 root-&gt;appendNew&lt;ConstPtrValue&gt;(proc, Origin(), &amp;value)));
 734 
 735         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc), modelLoad&lt;CType&gt;(value)));
 736     }
 737 
 738     // Simple load from an address in a register.
 739     {
 740         Procedure proc;
 741         BasicBlock* root = proc.addBlock();
 742 
 743         root-&gt;appendNewControlValue(
 744             proc, Return, Origin(),
 745             root-&gt;appendNew&lt;MemoryValue&gt;(
 746                 proc, opcode, type, Origin(),
 747                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0)));
 748 
 749         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value), modelLoad&lt;CType&gt;(value)));
 750     }
 751 
 752     // Simple load from an address in a register, at an offset.
 753     {
 754         Procedure proc;
 755         BasicBlock* root = proc.addBlock();
 756 
 757         root-&gt;appendNewControlValue(
 758             proc, Return, Origin(),
 759             root-&gt;appendNew&lt;MemoryValue&gt;(
 760                 proc, opcode, type, Origin(),
 761                 root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 762                 static_cast&lt;int32_t&gt;(sizeof(InputType))));
 763 
 764         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 1), modelLoad&lt;CType&gt;(value)));
 765     }
 766 
 767     // Load from a simple base-index with various scales.
 768     for (unsigned logScale = 0; logScale &lt;= 3; ++logScale) {
 769         Procedure proc;
 770         BasicBlock* root = proc.addBlock();
 771 
 772         root-&gt;appendNewControlValue(
 773             proc, Return, Origin(),
 774             root-&gt;appendNew&lt;MemoryValue&gt;(
 775                 proc, opcode, type, Origin(),
 776                 root-&gt;appendNew&lt;Value&gt;(
 777                     proc, Add, Origin(),
 778                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0),
 779                     root-&gt;appendNew&lt;Value&gt;(
 780                         proc, Shl, Origin(),
 781                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 782                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)))));
 783 
 784         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 2, (sizeof(InputType) * 2) &gt;&gt; logScale), modelLoad&lt;CType&gt;(value)));
 785     }
 786 
 787     // Load from a simple base-index with various scales, but commuted.
 788     for (unsigned logScale = 0; logScale &lt;= 3; ++logScale) {
 789         Procedure proc;
 790         BasicBlock* root = proc.addBlock();
 791 
 792         root-&gt;appendNewControlValue(
 793             proc, Return, Origin(),
 794             root-&gt;appendNew&lt;MemoryValue&gt;(
 795                 proc, opcode, type, Origin(),
 796                 root-&gt;appendNew&lt;Value&gt;(
 797                     proc, Add, Origin(),
 798                     root-&gt;appendNew&lt;Value&gt;(
 799                         proc, Shl, Origin(),
 800                         root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1),
 801                         root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), logScale)),
 802                     root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0))));
 803 
 804         CHECK(isIdentical(compileAndRun&lt;CType&gt;(proc, &amp;value - 2, (sizeof(InputType) * 2) &gt;&gt; logScale), modelLoad&lt;CType&gt;(value)));
 805     }
 806 }
 807 
 808 template&lt;typename T&gt;
 809 void testLoad(B3::Opcode opcode, int32_t value)
 810 {
 811     return testLoad&lt;T&gt;(B3::Int32, opcode, value);
 812 }
 813 
 814 template&lt;typename T&gt;
 815 void testLoad(B3::Type type, T value)
 816 {
 817     return testLoad&lt;T&gt;(type, Load, value);
 818 }
 819 
 820 void addLoadTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
 821 {
 822     RUN(testLoad(Int32, 60));
 823     RUN(testLoad(Int32, -60));
 824     RUN(testLoad(Int32, 1000));
 825     RUN(testLoad(Int32, -1000));
 826     RUN(testLoad(Int32, 1000000));
 827     RUN(testLoad(Int32, -1000000));
 828     RUN(testLoad(Int32, 1000000000));
 829     RUN(testLoad(Int32, -1000000000));
 830     RUN_BINARY(testLoad, { MAKE_OPERAND(Int64) }, int64Operands());
 831     RUN_BINARY(testLoad, { MAKE_OPERAND(Float) }, floatingPointOperands&lt;float&gt;());
 832     RUN_BINARY(testLoad, { MAKE_OPERAND(Double) }, floatingPointOperands&lt;double&gt;());
 833 
 834     RUN(testLoad&lt;int8_t&gt;(Load8S, 60));
 835     RUN(testLoad&lt;int8_t&gt;(Load8S, -60));
 836     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000));
 837     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000));
 838     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000000));
 839     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000000));
 840     RUN(testLoad&lt;int8_t&gt;(Load8S, 1000000000));
 841     RUN(testLoad&lt;int8_t&gt;(Load8S, -1000000000));
 842 
 843     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 60));
 844     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -60));
 845     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000));
 846     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000));
 847     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000000));
 848     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000000));
 849     RUN(testLoad&lt;uint8_t&gt;(Load8Z, 1000000000));
 850     RUN(testLoad&lt;uint8_t&gt;(Load8Z, -1000000000));
 851 
 852     RUN(testLoad&lt;int16_t&gt;(Load16S, 60));
 853     RUN(testLoad&lt;int16_t&gt;(Load16S, -60));
 854     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000));
 855     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000));
 856     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000000));
 857     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000));
 858     RUN(testLoad&lt;int16_t&gt;(Load16S, 1000000000));
 859     RUN(testLoad&lt;int16_t&gt;(Load16S, -1000000000));
 860 
 861     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 60));
 862     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -60));
 863     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000));
 864     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000));
 865     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000));
 866     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000));
 867     RUN(testLoad&lt;uint16_t&gt;(Load16Z, 1000000000));
 868     RUN(testLoad&lt;uint16_t&gt;(Load16Z, -1000000000));
 869 }
 870 
 871 void testFastForwardCopy32()
 872 {
 873 #if CPU(X86_64)
 874     for (const bool aligned : { true, false }) {
 875         for (const bool overlap : { false, true }) {
 876             for (size_t arrsize : { 1, 4, 5, 6, 8, 10, 12, 16, 20, 40, 100, 1000}) {
 877                 size_t overlapAmount = 5;
 878 
<a name="2" id="anc2"></a><span class="line-added"> 879                 UniqueArray&lt;uint32_t&gt; array1, array2;</span>
 880                 uint32_t* arr1, *arr2;
 881 
 882                 if (overlap) {
<a name="3" id="anc3"></a><span class="line-modified"> 883                     array1 = makeUniqueArray&lt;uint32_t&gt;(arrsize * 2);</span>
<span class="line-added"> 884                     arr1 = &amp;array1[0];</span>
 885                     arr2 = arr1 + (arrsize - overlapAmount);
 886                 } else {
<a name="4" id="anc4"></a><span class="line-modified"> 887                     array1 = makeUniqueArray&lt;uint32_t&gt;(arrsize);</span>
<span class="line-modified"> 888                     array2 = makeUniqueArray&lt;uint32_t&gt;(arrsize);</span>
<span class="line-added"> 889                     arr1 = &amp;array1[0];</span>
<span class="line-added"> 890                     arr2 = &amp;array2[0];</span>
 891                 }
 892 
 893                 if (!aligned &amp;&amp; arrsize &lt; 3)
 894                     continue;
 895                 if (overlap &amp;&amp; arrsize &lt;= overlapAmount + 3)
 896                     continue;
 897 
 898                 if (!aligned) {
 899                     ++arr1;
 900                     ++arr2;
 901                     arrsize -= 1;
 902                     overlapAmount -= 1;
 903                 }
 904 
 905                 for (size_t i = 0; i &lt; arrsize; ++i)
 906                     arr1[i] = i;
 907 
 908                 fastForwardCopy32(arr2, arr1, arrsize);
 909 
 910                 if (overlap) {
 911                     for (size_t i = 0; i &lt; arrsize - overlapAmount; ++i)
 912                         CHECK(arr2[i] == i);
 913                     for (size_t i = arrsize - overlapAmount; i &lt; arrsize; ++i)
 914                         CHECK(arr2[i] == i - (arrsize - overlapAmount));
 915                 } else {
 916                     for (size_t i = 0; i &lt; arrsize; ++i)
 917                         CHECK(arr2[i] == i);
 918                 }
 919 
 920                 if (!aligned) {
 921                     --arr1;
 922                     --arr2;
 923                 }
<a name="5" id="anc5"></a>





 924             }
 925         }
 926     }
 927 #endif
 928 }
 929 
 930 void testByteCopyLoop()
 931 {
 932     Procedure proc;
 933     BasicBlock* root = proc.addBlock();
 934     BasicBlock* head = proc.addBlock();
 935     BasicBlock* update = proc.addBlock();
 936     BasicBlock* continuation = proc.addBlock();
 937 
 938     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 939     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 940     auto* arraySize = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 941     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 942     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 943     UpsilonValue* startingIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
 944     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 945     root-&gt;setSuccessors(FrequentedBlock(head));
 946 
 947     auto* index = head-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
 948     startingIndex-&gt;setPhi(index);
 949     auto* loadIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arraySrc,
 950         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
 951     auto* storeIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arrayDst,
 952         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
 953     head-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), head-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), loadIndex), storeIndex);
 954     auto* newIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
 955     auto* cmpValue = head-&gt;appendNew&lt;Value&gt;(proc, GreaterThan, Origin(), newIndex, arraySize);
 956     head-&gt;appendNew&lt;Value&gt;(proc, Branch, Origin(), cmpValue);
 957     head-&gt;setSuccessors(FrequentedBlock(continuation), FrequentedBlock(update));
 958 
 959     UpsilonValue* updateIndex = update-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newIndex);
 960     updateIndex-&gt;setPhi(index);
 961     update-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
 962     update-&gt;setSuccessors(FrequentedBlock(head));
 963 
 964     continuation-&gt;appendNewControlValue(proc, Return, Origin());
 965 
 966     int* arr1 = new int[3];
 967     int* arr2 = new int[3];
 968 
 969     arr1[0] = 0;
 970     arr1[1] = 0;
 971     arr1[2] = 0;
 972     arr2[0] = 1;
 973     arr2[1] = 2;
 974     arr2[2] = 3;
 975 
 976     compileAndRun&lt;void&gt;(proc, arr2, arr1, 3);
 977 
 978     CHECK_EQ(arr1[0], 1);
 979     CHECK_EQ(arr1[1], 2);
 980     CHECK_EQ(arr1[2], 3);
 981 
 982     delete[] arr1;
 983     delete [] arr2;
 984 }
 985 
 986 void testByteCopyLoopStartIsLoopDependent()
 987 {
 988     Procedure proc;
 989     BasicBlock* root = proc.addBlock();
 990     BasicBlock* head = proc.addBlock();
 991     BasicBlock* update = proc.addBlock();
 992     BasicBlock* continuation = proc.addBlock();
 993 
 994     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
 995     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
 996     auto* arraySize = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));
 997     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
 998     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
 999     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1000     root-&gt;setSuccessors(FrequentedBlock(head));
1001 
1002     UpsilonValue* startingIndex = head-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), head-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
1003     auto* index = head-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
1004     startingIndex-&gt;setPhi(index);
1005     auto* loadIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arraySrc,
1006         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1007     auto* storeIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arrayDst,
1008         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1009     head-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), head-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), loadIndex), storeIndex);
1010     auto* newIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
1011     auto* cmpValue = head-&gt;appendNew&lt;Value&gt;(proc, GreaterThan, Origin(), newIndex, arraySize);
1012     head-&gt;appendNew&lt;Value&gt;(proc, Branch, Origin(), cmpValue);
1013     head-&gt;setSuccessors(FrequentedBlock(continuation), FrequentedBlock(update));
1014 
1015     UpsilonValue* updateIndex = update-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newIndex);
1016     updateIndex-&gt;setPhi(index);
1017     update-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1018     update-&gt;setSuccessors(FrequentedBlock(head));
1019 
1020     continuation-&gt;appendNewControlValue(proc, Return, Origin());
1021 
1022     int* arr1 = new int[3];
1023     int* arr2 = new int[3];
1024 
1025     arr1[0] = 0;
1026     arr1[1] = 0;
1027     arr1[2] = 0;
1028     arr2[0] = 1;
1029     arr2[1] = 2;
1030     arr2[2] = 3;
1031 
1032     compileAndRun&lt;void&gt;(proc, arr2, arr1, 0);
1033 
1034     CHECK_EQ(arr1[0], 1);
1035     CHECK_EQ(arr1[1], 0);
1036     CHECK_EQ(arr1[2], 0);
1037 
1038     delete[] arr1;
1039     delete [] arr2;
1040 }
1041 
1042 void testByteCopyLoopBoundIsLoopDependent()
1043 {
1044     Procedure proc;
1045     BasicBlock* root = proc.addBlock();
1046     BasicBlock* head = proc.addBlock();
1047     BasicBlock* update = proc.addBlock();
1048     BasicBlock* continuation = proc.addBlock();
1049 
1050     auto* arraySrc = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
1051     auto* arrayDst = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
1052     auto* one = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 1);
1053     auto* two = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 2);
1054     UpsilonValue* startingIndex = root-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), 0));
1055     root-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1056     root-&gt;setSuccessors(FrequentedBlock(head));
1057 
1058     auto* index = head-&gt;appendNew&lt;Value&gt;(proc, Phi, Int32, Origin());
1059     startingIndex-&gt;setPhi(index);
1060     auto* loadIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arraySrc,
1061         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1062     auto* storeIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), arrayDst,
1063         head-&gt;appendNew&lt;Value&gt;(proc, ZExt32, Origin(), head-&gt;appendNew&lt;Value&gt;(proc, Shl, Origin(), index, two)));
1064     head-&gt;appendNew&lt;MemoryValue&gt;(proc, Store, Origin(), head-&gt;appendNew&lt;MemoryValue&gt;(proc, Load, Int32, Origin(), loadIndex), storeIndex);
1065     auto* newIndex = head-&gt;appendNew&lt;Value&gt;(proc, Add, Origin(), index, one);
1066     auto* cmpValue = head-&gt;appendNew&lt;Value&gt;(proc, GreaterThan, Origin(), newIndex, index);
1067     head-&gt;appendNew&lt;Value&gt;(proc, Branch, Origin(), cmpValue);
1068     head-&gt;setSuccessors(FrequentedBlock(continuation), FrequentedBlock(update));
1069 
1070     UpsilonValue* updateIndex = update-&gt;appendNew&lt;UpsilonValue&gt;(proc, Origin(), newIndex);
1071     updateIndex-&gt;setPhi(index);
1072     update-&gt;appendNew&lt;Value&gt;(proc, Jump, Origin());
1073     update-&gt;setSuccessors(FrequentedBlock(head));
1074 
1075     continuation-&gt;appendNewControlValue(proc, Return, Origin());
1076 
1077     int* arr1 = new int[3];
1078     int* arr2 = new int[3];
1079 
1080     arr1[0] = 0;
1081     arr1[1] = 0;
1082     arr1[2] = 0;
1083     arr2[0] = 1;
1084     arr2[1] = 2;
1085     arr2[2] = 3;
1086 
1087     compileAndRun&lt;void&gt;(proc, arr2, arr1, 3);
1088 
1089     CHECK_EQ(arr1[0], 1);
1090     CHECK_EQ(arr1[1], 0);
1091     CHECK_EQ(arr1[2], 0);
1092 
1093     delete[] arr1;
1094     delete [] arr2;
1095 }
1096 
1097 void addCopyTests(const char* filter, Deque&lt;RefPtr&lt;SharedTask&lt;void()&gt;&gt;&gt;&amp; tasks)
1098 {
1099     RUN(testFastForwardCopy32());
1100     RUN(testByteCopyLoop());
1101     RUN(testByteCopyLoopStartIsLoopDependent());
1102     RUN(testByteCopyLoopBoundIsLoopDependent());
1103 }
1104 
1105 #endif // ENABLE(B3_JIT)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
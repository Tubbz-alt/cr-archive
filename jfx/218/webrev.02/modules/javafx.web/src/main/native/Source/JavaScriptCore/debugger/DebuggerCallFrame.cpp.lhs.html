<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/DebuggerCallFrame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008, 2013-2014, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;DebuggerCallFrame.h&quot;
 31 
 32 #include &quot;CatchScope.h&quot;
 33 #include &quot;CodeBlock.h&quot;
 34 #include &quot;DebuggerEvalEnabler.h&quot;
 35 #include &quot;DebuggerScope.h&quot;
 36 #include &quot;Interpreter.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;JSFunction.h&quot;
 39 #include &quot;JSLexicalEnvironment.h&quot;
 40 #include &quot;JSWithScope.h&quot;
 41 #include &quot;Parser.h&quot;
 42 #include &quot;ShadowChickenInlines.h&quot;
 43 #include &quot;StackVisitor.h&quot;
 44 #include &quot;StrongInlines.h&quot;
 45 
 46 namespace JSC {
 47 
 48 class LineAndColumnFunctor {
 49 public:
 50     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 51     {
 52         visitor-&gt;computeLineAndColumn(m_line, m_column);
 53         return StackVisitor::Done;
 54     }
 55 
 56     unsigned line() const { return m_line; }
 57     unsigned column() const { return m_column; }
 58 
 59 private:
 60     mutable unsigned m_line { 0 };
 61     mutable unsigned m_column { 0 };
 62 };
 63 
 64 Ref&lt;DebuggerCallFrame&gt; DebuggerCallFrame::create(VM&amp; vm, CallFrame* callFrame)
 65 {
<a name="1" id="anc1"></a><span class="line-modified"> 66     if (UNLIKELY(callFrame == callFrame-&gt;wasmAwareLexicalGlobalObject(vm)-&gt;globalExec())) {</span>






 67         ShadowChicken::Frame emptyFrame;
 68         RELEASE_ASSERT(!emptyFrame.isTailDeleted);
 69         return adoptRef(*new DebuggerCallFrame(vm, callFrame, emptyFrame));
 70     }
 71 
 72     Vector&lt;ShadowChicken::Frame&gt; frames;
 73     vm.ensureShadowChicken();
 74     vm.shadowChicken()-&gt;iterate(vm, callFrame, [&amp;] (const ShadowChicken::Frame&amp; frame) -&gt; bool {
 75         frames.append(frame);
 76         return true;
 77     });
 78 
 79     RELEASE_ASSERT(frames.size());
 80     ASSERT(!frames[0].isTailDeleted); // The top frame should never be tail deleted.
 81 
 82     RefPtr&lt;DebuggerCallFrame&gt; currentParent = nullptr;
<a name="2" id="anc2"></a><span class="line-removed"> 83     ExecState* exec = callFrame-&gt;wasmAwareLexicalGlobalObject(vm)-&gt;globalExec();</span>
 84     // This walks the stack from the entry stack frame to the top of the stack.
 85     for (unsigned i = frames.size(); i--; ) {
 86         const ShadowChicken::Frame&amp; frame = frames[i];
 87         if (!frame.isTailDeleted)
<a name="3" id="anc3"></a><span class="line-modified"> 88             exec = frame.frame;</span>
<span class="line-modified"> 89         Ref&lt;DebuggerCallFrame&gt; currentFrame = adoptRef(*new DebuggerCallFrame(vm, exec, frame));</span>
 90         currentFrame-&gt;m_caller = currentParent;
 91         currentParent = WTFMove(currentFrame);
 92     }
 93     return *currentParent;
 94 }
 95 
 96 DebuggerCallFrame::DebuggerCallFrame(VM&amp; vm, CallFrame* callFrame, const ShadowChicken::Frame&amp; frame)
 97     : m_validMachineFrame(callFrame)
 98     , m_shadowChickenFrame(frame)
 99 {
100     m_position = currentPosition(vm);
101 }
102 
103 RefPtr&lt;DebuggerCallFrame&gt; DebuggerCallFrame::callerFrame()
104 {
105     ASSERT(isValid());
106     if (!isValid())
107         return nullptr;
108 
109     return m_caller;
110 }
111 
<a name="4" id="anc4"></a><span class="line-modified">112 ExecState* DebuggerCallFrame::globalExec()</span>
113 {
<a name="5" id="anc5"></a><span class="line-modified">114     return scope()-&gt;globalObject()-&gt;globalExec();</span>
115 }
116 
<a name="6" id="anc6"></a><span class="line-modified">117 JSC::JSGlobalObject* DebuggerCallFrame::vmEntryGlobalObject() const</span>
118 {
119     ASSERT(isValid());
120     if (!isValid())
121         return nullptr;
<a name="7" id="anc7"></a><span class="line-modified">122     VM&amp; vm = m_validMachineFrame-&gt;vm();</span>
<span class="line-modified">123     return vm.vmEntryGlobalObject(m_validMachineFrame);</span>
124 }
125 
126 SourceID DebuggerCallFrame::sourceID() const
127 {
128     ASSERT(isValid());
129     if (!isValid())
130         return noSourceID;
131     if (isTailDeleted())
132         return m_shadowChickenFrame.codeBlock-&gt;ownerExecutable()-&gt;sourceID();
133     return sourceIDForCallFrame(m_validMachineFrame);
134 }
135 
136 String DebuggerCallFrame::functionName() const
137 {
138     ASSERT(isValid());
139     if (!isValid())
140         return String();
141 
<a name="8" id="anc8"></a><span class="line-modified">142     VM&amp; vm = m_validMachineFrame-&gt;vm();</span>
143     if (isTailDeleted()) {
144         if (JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, m_shadowChickenFrame.callee))
145             return func-&gt;calculatedDisplayName(vm);
146         return m_shadowChickenFrame.codeBlock-&gt;inferredName().data();
147     }
148 
149     return m_validMachineFrame-&gt;friendlyFunctionName();
150 }
151 
152 DebuggerScope* DebuggerCallFrame::scope()
153 {
154     ASSERT(isValid());
155     if (!isValid())
156         return nullptr;
157 
158     if (!m_scope) {
<a name="9" id="anc9"></a><span class="line-modified">159         VM&amp; vm = m_validMachineFrame-&gt;vm();</span>
160         JSScope* scope;
161         CodeBlock* codeBlock = m_validMachineFrame-&gt;codeBlock();
162         if (isTailDeleted())
163             scope = m_shadowChickenFrame.scope;
164         else if (codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid())
165             scope = m_validMachineFrame-&gt;scope(codeBlock-&gt;scopeRegister().offset());
166         else if (JSCallee* callee = jsDynamicCast&lt;JSCallee*&gt;(vm, m_validMachineFrame-&gt;jsCallee()))
167             scope = callee-&gt;scope();
168         else
<a name="10" id="anc10"></a><span class="line-modified">169             scope = m_validMachineFrame-&gt;lexicalGlobalObject()-&gt;globalLexicalEnvironment();</span>
170 
171         m_scope.set(vm, DebuggerScope::create(vm, scope));
172     }
173     return m_scope.get();
174 }
175 
176 DebuggerCallFrame::Type DebuggerCallFrame::type() const
177 {
178     ASSERT(isValid());
179     if (!isValid())
180         return ProgramType;
181 
182     if (isTailDeleted())
183         return FunctionType;
184 
<a name="11" id="anc11"></a><span class="line-modified">185     if (jsDynamicCast&lt;JSFunction*&gt;(m_validMachineFrame-&gt;vm(), m_validMachineFrame-&gt;jsCallee()))</span>
186         return FunctionType;
187 
188     return ProgramType;
189 }
190 
<a name="12" id="anc12"></a><span class="line-modified">191 JSValue DebuggerCallFrame::thisValue() const</span>
192 {
193     ASSERT(isValid());
194     if (!isValid())
195         return jsUndefined();
196 
197     CodeBlock* codeBlock = nullptr;
198     JSValue thisValue;
199     if (isTailDeleted()) {
200         thisValue = m_shadowChickenFrame.thisValue;
201         codeBlock = m_shadowChickenFrame.codeBlock;
202     } else {
203         thisValue = m_validMachineFrame-&gt;thisValue();
204         codeBlock = m_validMachineFrame-&gt;codeBlock();
205     }
206 
207     if (!thisValue)
208         return jsUndefined();
209 
210     ECMAMode ecmaMode = NotStrictMode;
211     if (codeBlock &amp;&amp; codeBlock-&gt;isStrictMode())
212         ecmaMode = StrictMode;
<a name="13" id="anc13"></a><span class="line-modified">213     return thisValue.toThis(m_validMachineFrame, ecmaMode);</span>
214 }
215 
216 // Evaluate some JavaScript code in the scope of this frame.
217 JSValue DebuggerCallFrame::evaluateWithScopeExtension(const String&amp; script, JSObject* scopeExtensionObject, NakedPtr&lt;Exception&gt;&amp; exception)
218 {
219     ASSERT(isValid());
220     CallFrame* callFrame = m_validMachineFrame;
221     if (!callFrame)
222         return jsUndefined();
223 
<a name="14" id="anc14"></a><span class="line-modified">224     VM&amp; vm = callFrame-&gt;vm();</span>
225     JSLockHolder lock(vm);
226     auto catchScope = DECLARE_CATCH_SCOPE(vm);
227 
228     CodeBlock* codeBlock = nullptr;
229     if (isTailDeleted())
230         codeBlock = m_shadowChickenFrame.codeBlock;
231     else
232         codeBlock = callFrame-&gt;codeBlock();
233     if (!codeBlock)
234         return jsUndefined();
235 
<a name="15" id="anc15"></a><span class="line-modified">236     DebuggerEvalEnabler evalEnabler(callFrame, DebuggerEvalEnabler::Mode::EvalOnCallFrameAtDebuggerEntry);</span>

237 
238     EvalContextType evalContextType;
239 
240     if (isFunctionParseMode(codeBlock-&gt;unlinkedCodeBlock()-&gt;parseMode()))
241         evalContextType = EvalContextType::FunctionEvalContext;
242     else if (codeBlock-&gt;unlinkedCodeBlock()-&gt;codeType() == EvalCode)
243         evalContextType = codeBlock-&gt;unlinkedCodeBlock()-&gt;evalContextType();
244     else
245         evalContextType = EvalContextType::None;
246 
247     VariableEnvironment variablesUnderTDZ;
248     JSScope::collectClosureVariablesUnderTDZ(scope()-&gt;jsScope(), variablesUnderTDZ);
249 
<a name="16" id="anc16"></a><span class="line-modified">250     auto* eval = DirectEvalExecutable::create(callFrame, makeSource(script, callFrame-&gt;callerSourceOrigin()), codeBlock-&gt;isStrictMode(), codeBlock-&gt;unlinkedCodeBlock()-&gt;derivedContextType(), codeBlock-&gt;unlinkedCodeBlock()-&gt;isArrowFunction(), evalContextType, &amp;variablesUnderTDZ);</span>
251     if (UNLIKELY(catchScope.exception())) {
252         exception = catchScope.exception();
253         catchScope.clearException();
254         return jsUndefined();
255     }
256 
<a name="17" id="anc17"></a><span class="line-removed">257     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(callFrame);</span>
258     if (scopeExtensionObject) {
259         JSScope* ignoredPreviousScope = globalObject-&gt;globalScope();
260         globalObject-&gt;setGlobalScopeExtension(JSWithScope::create(vm, globalObject, ignoredPreviousScope, scopeExtensionObject));
261     }
262 
<a name="18" id="anc18"></a><span class="line-modified">263     JSValue thisValue = this-&gt;thisValue();</span>
<span class="line-modified">264     JSValue result = vm.interpreter-&gt;execute(eval, callFrame, thisValue, scope()-&gt;jsScope());</span>
265     if (UNLIKELY(catchScope.exception())) {
266         exception = catchScope.exception();
267         catchScope.clearException();
268     }
269 
270     if (scopeExtensionObject)
271         globalObject-&gt;clearGlobalScopeExtension();
272 
273     ASSERT(result);
274     return result;
275 }
276 
277 void DebuggerCallFrame::invalidate()
278 {
279     RefPtr&lt;DebuggerCallFrame&gt; frame = this;
280     while (frame) {
281         frame-&gt;m_validMachineFrame = nullptr;
282         if (frame-&gt;m_scope) {
283             frame-&gt;m_scope-&gt;invalidateChain();
284             frame-&gt;m_scope.clear();
285         }
286         frame = WTFMove(frame-&gt;m_caller);
287     }
288 }
289 
290 TextPosition DebuggerCallFrame::currentPosition(VM&amp; vm)
291 {
292     if (!m_validMachineFrame)
293         return TextPosition();
294 
295     if (isTailDeleted()) {
296         CodeBlock* codeBlock = m_shadowChickenFrame.codeBlock;
<a name="19" id="anc19"></a><span class="line-modified">297         if (Optional&lt;unsigned&gt; bytecodeOffset = codeBlock-&gt;bytecodeOffsetFromCallSiteIndex(m_shadowChickenFrame.callSiteIndex)) {</span>
<span class="line-modified">298             return TextPosition(OrdinalNumber::fromOneBasedInt(codeBlock-&gt;lineNumberForBytecodeOffset(*bytecodeOffset)),</span>
<span class="line-modified">299                 OrdinalNumber::fromOneBasedInt(codeBlock-&gt;columnNumberForBytecodeOffset(*bytecodeOffset)));</span>
300         }
301     }
302 
303     return positionForCallFrame(vm, m_validMachineFrame);
304 }
305 
306 TextPosition DebuggerCallFrame::positionForCallFrame(VM&amp; vm, CallFrame* callFrame)
307 {
308     LineAndColumnFunctor functor;
<a name="20" id="anc20"></a><span class="line-modified">309     StackVisitor::visit(callFrame, &amp;vm, functor);</span>
310     return TextPosition(OrdinalNumber::fromOneBasedInt(functor.line()), OrdinalNumber::fromOneBasedInt(functor.column()));
311 }
312 
313 SourceID DebuggerCallFrame::sourceIDForCallFrame(CallFrame* callFrame)
314 {
<a name="21" id="anc21"></a><span class="line-modified">315     ASSERT(callFrame);</span>

316     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<a name="22" id="anc22"></a><span class="line-modified">317     if (!codeBlock)</span>
318         return noSourceID;
319     return codeBlock-&gt;ownerExecutable()-&gt;sourceID();
320 }
321 
322 } // namespace JSC
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
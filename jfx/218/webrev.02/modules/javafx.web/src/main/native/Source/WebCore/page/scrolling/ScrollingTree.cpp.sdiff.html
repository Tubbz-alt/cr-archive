<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingStateScrollingNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 54     LockHolder lock(m_treeStateMutex);
 55 
 56     bool shouldSetLatch = wheelEvent.shouldConsiderLatching();
 57 
 58     if (hasLatchedNode() &amp;&amp; !shouldSetLatch)
 59         return false;
 60 
 61     if (shouldSetLatch)
 62         m_treeState.latchedNodeID = 0;
 63 
 64     if (!m_treeState.eventTrackingRegions.isEmpty() &amp;&amp; m_rootNode) {
 65         FloatPoint position = wheelEvent.position();
 66         position.move(m_rootNode-&gt;viewToContentsOffset(m_treeState.mainFrameScrollPosition));
 67 
 68         const EventNames&amp; names = eventNames();
 69         IntPoint roundedPosition = roundedIntPoint(position);
 70 
 71         // Event regions are affected by page scale, so no need to map through scale.
 72         bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous
 73             || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;
<span class="line-modified"> 74         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent at &quot; &lt;&lt; wheelEvent.position() &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);</span>
 75 
 76         if (isSynchronousDispatchRegion)
 77             return true;
 78     }
 79     return false;
 80 }
 81 
 82 void ScrollingTree::setOrClearLatchedNode(const PlatformWheelEvent&amp; wheelEvent, ScrollingNodeID nodeID)
 83 {
 84     if (wheelEvent.shouldConsiderLatching()) {
 85         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: setting latched node &quot; &lt;&lt; nodeID);
 86         setLatchedNode(nodeID);
 87     } else if (wheelEvent.shouldResetLatching()) {
 88         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: clearing latched node (was &quot; &lt;&lt; latchedNode() &lt;&lt; &quot;)&quot;);
 89         clearLatchedNode();
 90     }
 91 }
 92 
 93 ScrollingEventResult ScrollingTree::handleWheelEvent(const PlatformWheelEvent&amp; wheelEvent)
 94 {
</pre>
<hr />
<pre>
123                     return ScrollingEventResult::DidHandleEvent;
124             }
125             node = node-&gt;parent();
126         }
127     }
128     return ScrollingEventResult::DidNotHandleEvent;
129 }
130 
131 void ScrollingTree::mainFrameViewportChangedViaDelegatedScrolling(const FloatPoint&amp; scrollPosition, const FloatRect&amp; layoutViewport, double)
132 {
133     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::viewportChangedViaDelegatedScrolling - layoutViewport &quot; &lt;&lt; layoutViewport);
134 
135     if (!m_rootNode)
136         return;
137 
138     m_rootNode-&gt;wasScrolledByDelegatedScrolling(scrollPosition, layoutViewport);
139 }
140 
141 void ScrollingTree::commitTreeState(std::unique_ptr&lt;ScrollingStateTree&gt; scrollingStateTree)
142 {

143     LockHolder locker(m_treeMutex);
144 
145     bool rootStateNodeChanged = scrollingStateTree-&gt;hasNewRootStateNode();
146 
147     LOG(Scrolling, &quot;\nScrollingTree %p commitTreeState&quot;, this);
148 
149     auto* rootNode = scrollingStateTree-&gt;rootStateNode();
150     if (rootNode
151         &amp;&amp; (rootStateNodeChanged
152             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
153             || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
<span class="line-modified">154             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))) {</span>

155         LockHolder lock(m_treeStateMutex);
156 
157         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
158             m_treeState.mainFrameScrollPosition = { };
159 
160         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
161             m_treeState.eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();
162 
163         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
164             m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();



165     }
166 
167     // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
168     // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
169     HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
170     for (auto nodeID : m_nodeMap.keys())
171         unvisitedNodes.add(nodeID);
172 
173     m_overflowRelatedNodesMap.clear();
174     m_activeOverflowScrollProxyNodes.clear();
175     m_activePositionedNodes.clear();
176 
177     // orphanNodes keeps child nodes alive while we rebuild child lists.
178     OrphanScrollingNodeMap orphanNodes;
179     updateTreeFromStateNode(rootNode, orphanNodes, unvisitedNodes);
180 
181     for (auto nodeID : unvisitedNodes) {
182         if (nodeID == m_treeState.latchedNodeID)
183             clearLatchedNode();
184 
</pre>
<hr />
<pre>
223         if (parentIt != m_nodeMap.end()) {
224             auto* parent = parentIt-&gt;value.get();
225 
226             auto* oldParent = node-&gt;parent();
227             if (oldParent)
228                 oldParent-&gt;removeChild(*node);
229 
230             if (oldParent != parent)
231                 node-&gt;setParent(parent);
232 
233             parent-&gt;appendChild(*node);
234         } else {
235             // FIXME: Use WeakPtr in m_nodeMap.
236             m_nodeMap.remove(nodeID);
237         }
238     }
239 
240     node-&gt;commitStateBeforeChildren(*stateNode);
241 
242     // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
<span class="line-modified">243     if (auto nodeChildren = node-&gt;children()) {</span>
<span class="line-modified">244         for (auto&amp; childScrollingNode : *nodeChildren) {</span>
<span class="line-modified">245             childScrollingNode-&gt;setParent(nullptr);</span>
<span class="line-removed">246             orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.get());</span>
<span class="line-removed">247         }</span>
<span class="line-removed">248         nodeChildren-&gt;clear();</span>
249     }

250 
251     // Now update the children if we have any.
252     if (auto children = stateNode-&gt;children()) {
253         for (auto&amp; child : *children)
254             updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
255     }
256 
257     node-&gt;commitStateAfterChildren(*stateNode);
258 }
259 
260 void ScrollingTree::applyLayerPositionsAfterCommit()
261 {
262     // Scrolling tree needs to make adjustments only if the UI side positions have changed.
263     if (!m_wasScrolledByDelegatedScrollingSincePreviousCommit)
264         return;
265     m_wasScrolledByDelegatedScrollingSincePreviousCommit = false;
266 
267     applyLayerPositions();
268 }
269 
270 void ScrollingTree::applyLayerPositions()
271 {
272     ASSERT(isMainThread());
273     LockHolder locker(m_treeMutex);
274 
275     if (!m_rootNode)
276         return;
277 
278     LOG(Scrolling, &quot;\nScrollingTree %p applyLayerPositions&quot;, this);
279 
280     applyLayerPositionsRecursive(*m_rootNode);
281 
282     LOG(Scrolling, &quot;ScrollingTree %p applyLayerPositions - done\n&quot;, this);
283 }
284 
<span class="line-modified">285 void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode&amp; currNode)</span>
286 {
<span class="line-modified">287     currNode.applyLayerPositions();</span>
288 
<span class="line-modified">289     if (auto children = currNode.children()) {</span>
<span class="line-modified">290         for (auto&amp; child : *children)</span>
<span class="line-removed">291             applyLayerPositionsRecursive(*child);</span>
<span class="line-removed">292     }</span>
293 }
294 
295 ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const
296 {
297     if (!nodeID)
298         return nullptr;
299 
300     return m_nodeMap.get(nodeID);
301 }
302 
303 void ScrollingTree::notifyRelatedNodesAfterScrollPositionChange(ScrollingTreeScrollingNode&amp; changedNode)
304 {
305     Vector&lt;ScrollingNodeID&gt; additionalUpdateRoots;
306 
307     if (is&lt;ScrollingTreeOverflowScrollingNode&gt;(changedNode))
308         additionalUpdateRoots = overflowRelatedNodes().get(changedNode.scrollingNodeID());
309 
310     notifyRelatedNodesRecursive(changedNode);
311 
312     for (auto positionedNodeID : additionalUpdateRoots) {
313         auto* positionedNode = nodeForID(positionedNodeID);
314         if (positionedNode)
315             notifyRelatedNodesRecursive(*positionedNode);
316     }
317 }
318 
319 void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode&amp; node)
320 {
321     node.applyLayerPositions();
322 
<span class="line-modified">323     if (!node.children())</span>
<span class="line-removed">324         return;</span>
<span class="line-removed">325 </span>
<span class="line-removed">326     for (auto&amp; child : *node.children()) {</span>
327         // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.
328         if (is&lt;ScrollingTreeFrameScrollingNode&gt;(child))
329             continue;
330 
<span class="line-modified">331         notifyRelatedNodesRecursive(*child);</span>
332     }
333 }
334 
335 void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)
336 {
337     m_asyncFrameOrOverflowScrollingEnabled = enabled;
338 }
339 
340 void ScrollingTree::setMainFrameScrollPosition(FloatPoint position)
341 {
342     LockHolder lock(m_treeStateMutex);
343     m_treeState.mainFrameScrollPosition = position;
344 }
345 
346 TrackingType ScrollingTree::eventTrackingTypeForPoint(const AtomString&amp; eventName, IntPoint p)
347 {
348     LockHolder lock(m_treeStateMutex);
349     return m_treeState.eventTrackingRegions.trackingTypeForPoint(eventName, p);
350 }
351 
</pre>
</td>
<td>
<hr />
<pre>
 54     LockHolder lock(m_treeStateMutex);
 55 
 56     bool shouldSetLatch = wheelEvent.shouldConsiderLatching();
 57 
 58     if (hasLatchedNode() &amp;&amp; !shouldSetLatch)
 59         return false;
 60 
 61     if (shouldSetLatch)
 62         m_treeState.latchedNodeID = 0;
 63 
 64     if (!m_treeState.eventTrackingRegions.isEmpty() &amp;&amp; m_rootNode) {
 65         FloatPoint position = wheelEvent.position();
 66         position.move(m_rootNode-&gt;viewToContentsOffset(m_treeState.mainFrameScrollPosition));
 67 
 68         const EventNames&amp; names = eventNames();
 69         IntPoint roundedPosition = roundedIntPoint(position);
 70 
 71         // Event regions are affected by page scale, so no need to map through scale.
 72         bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous
 73             || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;
<span class="line-modified"> 74         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\n\nScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent &quot; &lt;&lt; wheelEvent &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);</span>
 75 
 76         if (isSynchronousDispatchRegion)
 77             return true;
 78     }
 79     return false;
 80 }
 81 
 82 void ScrollingTree::setOrClearLatchedNode(const PlatformWheelEvent&amp; wheelEvent, ScrollingNodeID nodeID)
 83 {
 84     if (wheelEvent.shouldConsiderLatching()) {
 85         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: setting latched node &quot; &lt;&lt; nodeID);
 86         setLatchedNode(nodeID);
 87     } else if (wheelEvent.shouldResetLatching()) {
 88         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree &quot; &lt;&lt; this &lt;&lt; &quot; setOrClearLatchedNode: clearing latched node (was &quot; &lt;&lt; latchedNode() &lt;&lt; &quot;)&quot;);
 89         clearLatchedNode();
 90     }
 91 }
 92 
 93 ScrollingEventResult ScrollingTree::handleWheelEvent(const PlatformWheelEvent&amp; wheelEvent)
 94 {
</pre>
<hr />
<pre>
123                     return ScrollingEventResult::DidHandleEvent;
124             }
125             node = node-&gt;parent();
126         }
127     }
128     return ScrollingEventResult::DidNotHandleEvent;
129 }
130 
131 void ScrollingTree::mainFrameViewportChangedViaDelegatedScrolling(const FloatPoint&amp; scrollPosition, const FloatRect&amp; layoutViewport, double)
132 {
133     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::viewportChangedViaDelegatedScrolling - layoutViewport &quot; &lt;&lt; layoutViewport);
134 
135     if (!m_rootNode)
136         return;
137 
138     m_rootNode-&gt;wasScrolledByDelegatedScrolling(scrollPosition, layoutViewport);
139 }
140 
141 void ScrollingTree::commitTreeState(std::unique_ptr&lt;ScrollingStateTree&gt; scrollingStateTree)
142 {
<span class="line-added">143     SetForScope&lt;bool&gt; inCommitTreeState(m_inCommitTreeState, true);</span>
144     LockHolder locker(m_treeMutex);
145 
146     bool rootStateNodeChanged = scrollingStateTree-&gt;hasNewRootStateNode();
147 
148     LOG(Scrolling, &quot;\nScrollingTree %p commitTreeState&quot;, this);
149 
150     auto* rootNode = scrollingStateTree-&gt;rootStateNode();
151     if (rootNode
152         &amp;&amp; (rootStateNodeChanged
153             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
154             || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
<span class="line-modified">155             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled)</span>
<span class="line-added">156             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))) {</span>
157         LockHolder lock(m_treeStateMutex);
158 
159         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
160             m_treeState.mainFrameScrollPosition = { };
161 
162         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
163             m_treeState.eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();
164 
165         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
166             m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();
<span class="line-added">167 </span>
<span class="line-added">168         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))</span>
<span class="line-added">169             m_isMonitoringWheelEvents = scrollingStateTree-&gt;rootStateNode()-&gt;isMonitoringWheelEvents();</span>
170     }
171 
172     // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
173     // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
174     HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
175     for (auto nodeID : m_nodeMap.keys())
176         unvisitedNodes.add(nodeID);
177 
178     m_overflowRelatedNodesMap.clear();
179     m_activeOverflowScrollProxyNodes.clear();
180     m_activePositionedNodes.clear();
181 
182     // orphanNodes keeps child nodes alive while we rebuild child lists.
183     OrphanScrollingNodeMap orphanNodes;
184     updateTreeFromStateNode(rootNode, orphanNodes, unvisitedNodes);
185 
186     for (auto nodeID : unvisitedNodes) {
187         if (nodeID == m_treeState.latchedNodeID)
188             clearLatchedNode();
189 
</pre>
<hr />
<pre>
228         if (parentIt != m_nodeMap.end()) {
229             auto* parent = parentIt-&gt;value.get();
230 
231             auto* oldParent = node-&gt;parent();
232             if (oldParent)
233                 oldParent-&gt;removeChild(*node);
234 
235             if (oldParent != parent)
236                 node-&gt;setParent(parent);
237 
238             parent-&gt;appendChild(*node);
239         } else {
240             // FIXME: Use WeakPtr in m_nodeMap.
241             m_nodeMap.remove(nodeID);
242         }
243     }
244 
245     node-&gt;commitStateBeforeChildren(*stateNode);
246 
247     // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
<span class="line-modified">248     for (auto&amp; childScrollingNode : node-&gt;children()) {</span>
<span class="line-modified">249         childScrollingNode-&gt;setParent(nullptr);</span>
<span class="line-modified">250         orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.ptr());</span>



251     }
<span class="line-added">252     node-&gt;removeAllChildren();</span>
253 
254     // Now update the children if we have any.
255     if (auto children = stateNode-&gt;children()) {
256         for (auto&amp; child : *children)
257             updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
258     }
259 
260     node-&gt;commitStateAfterChildren(*stateNode);
261 }
262 
263 void ScrollingTree::applyLayerPositionsAfterCommit()
264 {
265     // Scrolling tree needs to make adjustments only if the UI side positions have changed.
266     if (!m_wasScrolledByDelegatedScrollingSincePreviousCommit)
267         return;
268     m_wasScrolledByDelegatedScrollingSincePreviousCommit = false;
269 
270     applyLayerPositions();
271 }
272 
273 void ScrollingTree::applyLayerPositions()
274 {
275     ASSERT(isMainThread());
276     LockHolder locker(m_treeMutex);
277 
278     if (!m_rootNode)
279         return;
280 
281     LOG(Scrolling, &quot;\nScrollingTree %p applyLayerPositions&quot;, this);
282 
283     applyLayerPositionsRecursive(*m_rootNode);
284 
285     LOG(Scrolling, &quot;ScrollingTree %p applyLayerPositions - done\n&quot;, this);
286 }
287 
<span class="line-modified">288 void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode&amp; node)</span>
289 {
<span class="line-modified">290     node.applyLayerPositions();</span>
291 
<span class="line-modified">292     for (auto&amp; child : node.children())</span>
<span class="line-modified">293         applyLayerPositionsRecursive(child.get());</span>


294 }
295 
296 ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const
297 {
298     if (!nodeID)
299         return nullptr;
300 
301     return m_nodeMap.get(nodeID);
302 }
303 
304 void ScrollingTree::notifyRelatedNodesAfterScrollPositionChange(ScrollingTreeScrollingNode&amp; changedNode)
305 {
306     Vector&lt;ScrollingNodeID&gt; additionalUpdateRoots;
307 
308     if (is&lt;ScrollingTreeOverflowScrollingNode&gt;(changedNode))
309         additionalUpdateRoots = overflowRelatedNodes().get(changedNode.scrollingNodeID());
310 
311     notifyRelatedNodesRecursive(changedNode);
312 
313     for (auto positionedNodeID : additionalUpdateRoots) {
314         auto* positionedNode = nodeForID(positionedNodeID);
315         if (positionedNode)
316             notifyRelatedNodesRecursive(*positionedNode);
317     }
318 }
319 
320 void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode&amp; node)
321 {
322     node.applyLayerPositions();
323 
<span class="line-modified">324     for (auto&amp; child : node.children()) {</span>



325         // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.
326         if (is&lt;ScrollingTreeFrameScrollingNode&gt;(child))
327             continue;
328 
<span class="line-modified">329         notifyRelatedNodesRecursive(child.get());</span>
330     }
331 }
332 
333 void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)
334 {
335     m_asyncFrameOrOverflowScrollingEnabled = enabled;
336 }
337 
338 void ScrollingTree::setMainFrameScrollPosition(FloatPoint position)
339 {
340     LockHolder lock(m_treeStateMutex);
341     m_treeState.mainFrameScrollPosition = position;
342 }
343 
344 TrackingType ScrollingTree::eventTrackingTypeForPoint(const AtomString&amp; eventName, IntPoint p)
345 {
346     LockHolder lock(m_treeStateMutex);
347     return m_treeState.eventTrackingRegions.trackingTypeForPoint(eventName, p);
348 }
349 
</pre>
</td>
</tr>
</table>
<center><a href="ScrollingStateScrollingNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
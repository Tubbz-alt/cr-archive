diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringObject.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringObject.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringObject.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringObject.cpp
@@ -42,130 +42,130 @@
     Base::finishCreation(vm);
     ASSERT(inherits(vm, info()));
     setInternalValue(vm, string);
 }
 
-bool StringObject::getOwnPropertySlot(JSObject* cell, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+bool StringObject::getOwnPropertySlot(JSObject* cell, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)
 {
     StringObject* thisObject = jsCast<StringObject*>(cell);
-    if (thisObject->internalValue()->getStringPropertySlot(exec, propertyName, slot))
+    if (thisObject->internalValue()->getStringPropertySlot(globalObject, propertyName, slot))
         return true;
-    return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);
+    return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 }
 
-bool StringObject::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot& slot)
+bool StringObject::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot& slot)
 {
     StringObject* thisObject = jsCast<StringObject*>(object);
-    if (thisObject->internalValue()->getStringPropertySlot(exec, propertyName, slot))
+    if (thisObject->internalValue()->getStringPropertySlot(globalObject, propertyName, slot))
         return true;
-    VM& vm = exec->vm();
-    return JSObject::getOwnPropertySlot(thisObject, exec, Identifier::from(vm, propertyName), slot);
+    VM& vm = globalObject->vm();
+    return JSObject::getOwnPropertySlot(thisObject, globalObject, Identifier::from(vm, propertyName), slot);
 }
 
-bool StringObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+bool StringObject::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     StringObject* thisObject = jsCast<StringObject*>(cell);
 
     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
-        RELEASE_AND_RETURN(scope, ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
+        RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode()));
 
     if (propertyName == vm.propertyNames->length)
-        return typeError(exec, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
+        return typeError(globalObject, scope, slot.isStrictMode(), ReadonlyPropertyWriteError);
     if (Optional<uint32_t> index = parseIndex(propertyName))
-        RELEASE_AND_RETURN(scope, putByIndex(cell, exec, index.value(), value, slot.isStrictMode()));
-    RELEASE_AND_RETURN(scope, JSObject::put(cell, exec, propertyName, value, slot));
+        RELEASE_AND_RETURN(scope, putByIndex(cell, globalObject, index.value(), value, slot.isStrictMode()));
+    RELEASE_AND_RETURN(scope, JSObject::put(cell, globalObject, propertyName, value, slot));
 }
 
-bool StringObject::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)
+bool StringObject::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     StringObject* thisObject = jsCast<StringObject*>(cell);
     if (thisObject->internalValue()->canGetIndex(propertyName))
-        return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);
-    RELEASE_AND_RETURN(scope, JSObject::putByIndex(cell, exec, propertyName, value, shouldThrow));
+        return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);
+    RELEASE_AND_RETURN(scope, JSObject::putByIndex(cell, globalObject, propertyName, value, shouldThrow));
 }
 
-static bool isStringOwnProperty(ExecState* exec, StringObject* object, PropertyName propertyName)
+static bool isStringOwnProperty(JSGlobalObject* globalObject, StringObject* object, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     if (propertyName == vm.propertyNames->length)
         return true;
     if (Optional<uint32_t> index = parseIndex(propertyName)) {
         if (object->internalValue()->canGetIndex(index.value()))
             return true;
     }
     return false;
 }
 
-bool StringObject::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor& descriptor, bool throwException)
+bool StringObject::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, const PropertyDescriptor& descriptor, bool throwException)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     StringObject* thisObject = jsCast<StringObject*>(object);
 
-    if (isStringOwnProperty(exec, thisObject, propertyName)) {
+    if (isStringOwnProperty(globalObject, thisObject, propertyName)) {
         // The current PropertyDescriptor is always
         // PropertyDescriptor{[[Value]]: value, [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false}.
         // This ensures that any property descriptor cannot change the existing one.
         // Here, simply return the result of validateAndApplyPropertyDescriptor.
         // https://tc39.github.io/ecma262/#sec-string-exotic-objects-getownproperty-p
         PropertyDescriptor current;
-        bool isCurrentDefined = thisObject->getOwnPropertyDescriptor(exec, propertyName, current);
+        bool isCurrentDefined = thisObject->getOwnPropertyDescriptor(globalObject, propertyName, current);
         EXCEPTION_ASSERT(!scope.exception() == isCurrentDefined);
         RETURN_IF_EXCEPTION(scope, false);
-        bool isExtensible = thisObject->isExtensible(exec);
+        bool isExtensible = thisObject->isExtensible(globalObject);
         RETURN_IF_EXCEPTION(scope, false);
-        RELEASE_AND_RETURN(scope, validateAndApplyPropertyDescriptor(exec, nullptr, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));
+        RELEASE_AND_RETURN(scope, validateAndApplyPropertyDescriptor(globalObject, nullptr, propertyName, isExtensible, descriptor, isCurrentDefined, current, throwException));
     }
 
-    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, propertyName, descriptor, throwException));
+    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, propertyName, descriptor, throwException));
 }
 
-bool StringObject::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)
+bool StringObject::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     StringObject* thisObject = jsCast<StringObject*>(cell);
     if (propertyName == vm.propertyNames->length)
         return false;
     Optional<uint32_t> index = parseIndex(propertyName);
     if (index && thisObject->internalValue()->canGetIndex(index.value()))
         return false;
-    return JSObject::deleteProperty(thisObject, exec, propertyName);
+    return JSObject::deleteProperty(thisObject, globalObject, propertyName);
 }
 
-bool StringObject::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned i)
+bool StringObject::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned i)
 {
     StringObject* thisObject = jsCast<StringObject*>(cell);
     if (thisObject->internalValue()->canGetIndex(i))
         return false;
-    return JSObject::deletePropertyByIndex(thisObject, exec, i);
+    return JSObject::deletePropertyByIndex(thisObject, globalObject, i);
 }
 
-void StringObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& propertyNames, EnumerationMode mode)
+void StringObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& propertyNames, EnumerationMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     StringObject* thisObject = jsCast<StringObject*>(object);
     if (propertyNames.includeStringProperties()) {
         int size = thisObject->internalValue()->length();
         for (int i = 0; i < size; ++i)
             propertyNames.add(Identifier::from(vm, i));
     }
-    return JSObject::getOwnPropertyNames(thisObject, exec, propertyNames, mode);
+    return JSObject::getOwnPropertyNames(thisObject, globalObject, propertyNames, mode);
 }
 
-void StringObject::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray& propertyNames, EnumerationMode mode)
+void StringObject::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& propertyNames, EnumerationMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     StringObject* thisObject = jsCast<StringObject*>(object);
     if (mode.includeDontEnumProperties())
         propertyNames.add(vm.propertyNames->length);
-    return JSObject::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);
+    return JSObject::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);
 }
 
 StringObject* constructString(VM& vm, JSGlobalObject* globalObject, JSValue string)
 {
     StringObject* object = StringObject::create(vm, globalObject->stringObjectStructure());

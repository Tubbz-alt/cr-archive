<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999-2003 Lars Knoll (knoll@kde.org)
  3  *               1999 Waldo Bastian (bastian@kde.org)
  4  *               2001 Andreas Schlapbach (schlpbch@iam.unibe.ch)
  5  *               2001-2003 Dirk Mueller (mueller@kde.org)
  6  * Copyright (C) 2002, 2006, 2007, 2008, 2009, 2010, 2013, 2014 Apple Inc. All rights reserved.
  7  * Copyright (C) 2008 David Smith (catfish.man@gmail.com)
  8  * Copyright (C) 2010 Google Inc. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSSelector.h&quot;
 28 
 29 #include &quot;CSSMarkup.h&quot;
 30 #include &quot;CSSSelectorList.h&quot;
 31 #include &quot;HTMLNames.h&quot;
 32 #include &quot;RuntimeEnabledFeatures.h&quot;
 33 #include &quot;SelectorPseudoTypeMap.h&quot;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/StdLibExtras.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/AtomStringHash.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 using namespace HTMLNames;
 43 
 44 struct SameSizeAsCSSSelector {
 45     unsigned flags;
 46     void* unionPointer;
 47 };
 48 
 49 static_assert(CSSSelector::RelationType::Subselector == 0, &quot;Subselector must be 0 for consumeCombinator.&quot;);
 50 static_assert(sizeof(CSSSelector) == sizeof(SameSizeAsCSSSelector), &quot;CSSSelector should remain small.&quot;);
 51 
 52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSSelectorRareData);
 53 
 54 CSSSelector::CSSSelector(const QualifiedName&amp; tagQName, bool tagIsForNamespaceRule)
 55     : m_relation(DescendantSpace)
 56     , m_match(Tag)
 57     , m_pseudoType(0)
 58     , m_isLastInSelectorList(false)
 59     , m_isLastInTagHistory(true)
 60     , m_hasRareData(false)
 61     , m_hasNameWithCase(false)
 62     , m_isForPage(false)
 63     , m_tagIsForNamespaceRule(tagIsForNamespaceRule)
 64     , m_caseInsensitiveAttributeValueMatching(false)
 65 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 66     , m_destructorHasBeenCalled(false)
 67 #endif
 68 {
 69     const AtomString&amp; tagLocalName = tagQName.localName();
 70     const AtomString tagLocalNameASCIILowercase = tagLocalName.convertToASCIILowercase();
 71 
 72     if (tagLocalName == tagLocalNameASCIILowercase) {
 73         m_data.m_tagQName = tagQName.impl();
 74         m_data.m_tagQName-&gt;ref();
 75     } else {
 76         m_data.m_nameWithCase = adoptRef(new NameWithCase(tagQName, tagLocalNameASCIILowercase)).leakRef();
 77         m_hasNameWithCase = true;
 78     }
 79 }
 80 
 81 void CSSSelector::createRareData()
 82 {
 83     ASSERT(match() != Tag);
 84     ASSERT(!m_hasNameWithCase);
 85     if (m_hasRareData)
 86         return;
 87     // Move the value to the rare data stucture.
 88     AtomString value { adoptRef(m_data.m_value) };
 89     m_data.m_rareData = &amp;RareData::create(WTFMove(value)).leakRef();
 90     m_hasRareData = true;
 91 }
 92 
 93 static unsigned simpleSelectorSpecificityInternal(const CSSSelector&amp; simpleSelector, bool isComputingMaximumSpecificity);
 94 
 95 static unsigned selectorSpecificity(const CSSSelector&amp; firstSimpleSelector, bool isComputingMaximumSpecificity)
 96 {
 97     unsigned total = simpleSelectorSpecificityInternal(firstSimpleSelector, isComputingMaximumSpecificity);
 98 
 99     for (const CSSSelector* selector = firstSimpleSelector.tagHistory(); selector; selector = selector-&gt;tagHistory())
100         total = CSSSelector::addSpecificities(total, simpleSelectorSpecificityInternal(*selector, isComputingMaximumSpecificity));
101     return total;
102 }
103 
104 static unsigned maxSpecificity(const CSSSelectorList&amp; selectorList)
105 {
106     unsigned maxSpecificity = 0;
107     for (const CSSSelector* subSelector = selectorList.first(); subSelector; subSelector = CSSSelectorList::next(subSelector))
108         maxSpecificity = std::max(maxSpecificity, selectorSpecificity(*subSelector, true));
109     return maxSpecificity;
110 }
111 
112 static unsigned simpleSelectorSpecificityInternal(const CSSSelector&amp; simpleSelector, bool isComputingMaximumSpecificity)
113 {
114     ASSERT_WITH_MESSAGE(!simpleSelector.isForPage(), &quot;At the time of this writing, page selectors are not treated as real selectors that are matched. The value computed here only account for real selectors.&quot;);
115 
116     switch (simpleSelector.match()) {
117     case CSSSelector::Id:
118         return static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassA);
119 
120     case CSSSelector::PagePseudoClass:
121         break;
122     case CSSSelector::PseudoClass:
123         if (simpleSelector.pseudoClassType() == CSSSelector::PseudoClassMatches) {
124             ASSERT_WITH_MESSAGE(simpleSelector.selectorList() &amp;&amp; simpleSelector.selectorList()-&gt;first(), &quot;The parser should never generate a valid selector for an empty :matches().&quot;);
125             if (!isComputingMaximumSpecificity)
126                 return 0;
127             return maxSpecificity(*simpleSelector.selectorList());
128         }
129 
130         if (simpleSelector.pseudoClassType() == CSSSelector::PseudoClassNot) {
131             ASSERT_WITH_MESSAGE(simpleSelector.selectorList() &amp;&amp; simpleSelector.selectorList()-&gt;first(), &quot;The parser should never generate a valid selector for an empty :not().&quot;);
132             return maxSpecificity(*simpleSelector.selectorList());
133         }
134         FALLTHROUGH;
135     case CSSSelector::Exact:
136     case CSSSelector::Class:
137     case CSSSelector::Set:
138     case CSSSelector::List:
139     case CSSSelector::Hyphen:
140     case CSSSelector::Contain:
141     case CSSSelector::Begin:
142     case CSSSelector::End:
143         return static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassB);
144     case CSSSelector::Tag:
145         return (simpleSelector.tagQName().localName() != starAtom()) ? static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassC) : 0;
146     case CSSSelector::PseudoElement:
147         return static_cast&lt;unsigned&gt;(SelectorSpecificityIncrement::ClassC);
148     case CSSSelector::Unknown:
149         return 0;
150     }
151     ASSERT_NOT_REACHED();
152     return 0;
153 }
154 
155 unsigned CSSSelector::simpleSelectorSpecificity() const
156 {
157     return simpleSelectorSpecificityInternal(*this, false);
158 }
159 
160 static unsigned staticSpecificityInternal(const CSSSelector&amp; firstSimpleSelector, bool&amp; ok);
161 
162 static unsigned simpleSelectorFunctionalPseudoClassStaticSpecificity(const CSSSelector&amp; simpleSelector, bool&amp; ok)
163 {
164     if (simpleSelector.match() == CSSSelector::PseudoClass) {
165         CSSSelector::PseudoClassType pseudoClassType = simpleSelector.pseudoClassType();
166         if (pseudoClassType == CSSSelector::PseudoClassMatches || pseudoClassType == CSSSelector::PseudoClassNthChild || pseudoClassType == CSSSelector::PseudoClassNthLastChild) {
167             const CSSSelectorList* selectorList = simpleSelector.selectorList();
168             if (!selectorList) {
169                 ASSERT_WITH_MESSAGE(pseudoClassType != CSSSelector::PseudoClassMatches, &quot;:matches() should never be created without a valid selector list.&quot;);
170                 return 0;
171             }
172 
173             const CSSSelector&amp; firstSubselector = *selectorList-&gt;first();
174 
175             unsigned initialSpecificity = staticSpecificityInternal(firstSubselector, ok);
176             if (!ok)
177                 return 0;
178 
179             const CSSSelector* subselector = &amp;firstSubselector;
180             while ((subselector = CSSSelectorList::next(subselector))) {
181                 unsigned subSelectorSpecificity = staticSpecificityInternal(*subselector, ok);
182                 if (initialSpecificity != subSelectorSpecificity)
183                     ok = false;
184                 if (!ok)
185                     return 0;
186             }
187             return initialSpecificity;
188         }
189     }
190     return 0;
191 }
192 
193 static unsigned functionalPseudoClassStaticSpecificity(const CSSSelector&amp; firstSimpleSelector, bool&amp; ok)
194 {
195     unsigned total = 0;
196     for (const CSSSelector* selector = &amp;firstSimpleSelector; selector; selector = selector-&gt;tagHistory()) {
197         total = CSSSelector::addSpecificities(total, simpleSelectorFunctionalPseudoClassStaticSpecificity(*selector, ok));
198         if (!ok)
199             return 0;
200     }
201     return total;
202 }
203 
204 static unsigned staticSpecificityInternal(const CSSSelector&amp; firstSimpleSelector, bool&amp; ok)
205 {
206     unsigned staticSpecificity = selectorSpecificity(firstSimpleSelector, false);
207     return CSSSelector::addSpecificities(staticSpecificity, functionalPseudoClassStaticSpecificity(firstSimpleSelector, ok));
208 }
209 
210 unsigned CSSSelector::staticSpecificity(bool &amp;ok) const
211 {
212     ok = true;
213     return staticSpecificityInternal(*this, ok);
214 }
215 
216 unsigned CSSSelector::addSpecificities(unsigned a, unsigned b)
217 {
218     unsigned total = a;
219 
220     unsigned newIdValue = (b &amp; idMask);
221     if (((total &amp; idMask) + newIdValue) &amp; ~idMask)
222         total |= idMask;
223     else
224         total += newIdValue;
225 
226     unsigned newClassValue = (b &amp; classMask);
227     if (((total &amp; classMask) + newClassValue) &amp; ~classMask)
228         total |= classMask;
229     else
230         total += newClassValue;
231 
232     unsigned newElementValue = (b &amp; elementMask);
233     if (((total &amp; elementMask) + newElementValue) &amp; ~elementMask)
234         total |= elementMask;
235     else
236         total += newElementValue;
237 
238     return total;
239 }
240 
241 unsigned CSSSelector::specificityForPage() const
242 {
243     ASSERT(isForPage());
244 
245     // See http://dev.w3.org/csswg/css3-page/#cascading-and-page-context
246     unsigned s = 0;
247 
248     for (const CSSSelector* component = this; component; component = component-&gt;tagHistory()) {
249         switch (component-&gt;match()) {
250         case Tag:
251             s += tagQName().localName() == starAtom() ? 0 : 4;
252             break;
253         case PagePseudoClass:
254             switch (component-&gt;pagePseudoClassType()) {
255             case PagePseudoClassFirst:
256                 s += 2;
257                 break;
258             case PagePseudoClassLeft:
259             case PagePseudoClassRight:
260                 s += 1;
261                 break;
262             }
263             break;
264         default:
265             break;
266         }
267     }
268     return s;
269 }
270 
271 PseudoId CSSSelector::pseudoId(PseudoElementType type)
272 {
273     switch (type) {
274     case PseudoElementFirstLine:
275         return PseudoId::FirstLine;
276     case PseudoElementFirstLetter:
277         return PseudoId::FirstLetter;
278     case PseudoElementSelection:
279         return PseudoId::Selection;
280     case PseudoElementHighlight:
281         return PseudoId::Highlight;
282     case PseudoElementMarker:
283         return PseudoId::Marker;
284     case PseudoElementBefore:
285         return PseudoId::Before;
286     case PseudoElementAfter:
287         return PseudoId::After;
288     case PseudoElementScrollbar:
289         return PseudoId::Scrollbar;
290     case PseudoElementScrollbarButton:
291         return PseudoId::ScrollbarButton;
292     case PseudoElementScrollbarCorner:
293         return PseudoId::ScrollbarCorner;
294     case PseudoElementScrollbarThumb:
295         return PseudoId::ScrollbarThumb;
296     case PseudoElementScrollbarTrack:
297         return PseudoId::ScrollbarTrack;
298     case PseudoElementScrollbarTrackPiece:
299         return PseudoId::ScrollbarTrackPiece;
300     case PseudoElementResizer:
301         return PseudoId::Resizer;
302 #if ENABLE(VIDEO_TRACK)
303     case PseudoElementCue:
304 #endif
305     case PseudoElementSlotted:
306     case PseudoElementPart:
307     case PseudoElementUnknown:
308     case PseudoElementWebKitCustom:
309     case PseudoElementWebKitCustomLegacyPrefixed:
310         return PseudoId::None;
311     }
312 
313     ASSERT_NOT_REACHED();
314     return PseudoId::None;
315 }
316 
317 CSSSelector::PseudoElementType CSSSelector::parsePseudoElementType(StringView name)
318 {
319     if (name.isNull())
320         return PseudoElementUnknown;
321 
322     auto type = parsePseudoElementString(name);
323     if (type == PseudoElementUnknown) {
324         if (name.startsWith(&quot;-webkit-&quot;))
325             type = PseudoElementWebKitCustom;
326     }
327 
328     if (type == PseudoElementHighlight &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().highlightAPIEnabled())
329         return PseudoElementUnknown;
330 
331     if (type == PseudoElementPart &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())
332         return PseudoElementUnknown;
333 
334     return type;
335 }
336 
337 bool CSSSelector::operator==(const CSSSelector&amp; other) const
338 {
339     const CSSSelector* sel1 = this;
340     const CSSSelector* sel2 = &amp;other;
341 
342     while (sel1 &amp;&amp; sel2) {
343         if (sel1-&gt;attribute() != sel2-&gt;attribute()
344             || sel1-&gt;relation() != sel2-&gt;relation()
345             || sel1-&gt;match() != sel2-&gt;match()
346             || sel1-&gt;value() != sel2-&gt;value()
347             || sel1-&gt;m_pseudoType != sel2-&gt;m_pseudoType
348             || sel1-&gt;argument() != sel2-&gt;argument()) {
349             return false;
350         }
351         if (sel1-&gt;match() == Tag) {
352             if (sel1-&gt;tagQName() != sel2-&gt;tagQName())
353                 return false;
354         }
355         sel1 = sel1-&gt;tagHistory();
356         sel2 = sel2-&gt;tagHistory();
357     }
358 
359     if (sel1 || sel2)
360         return false;
361 
362     return true;
363 }
364 
365 static void appendPseudoClassFunctionTail(StringBuilder&amp; builder, const CSSSelector* selector)
366 {
367     switch (selector-&gt;pseudoClassType()) {
368 #if ENABLE(CSS_SELECTORS_LEVEL4)
369     case CSSSelector::PseudoClassDir:
370 #endif
371     case CSSSelector::PseudoClassLang:
372     case CSSSelector::PseudoClassNthChild:
373     case CSSSelector::PseudoClassNthLastChild:
374     case CSSSelector::PseudoClassNthOfType:
375     case CSSSelector::PseudoClassNthLastOfType:
376 #if ENABLE(CSS_SELECTORS_LEVEL4)
377     case CSSSelector::PseudoClassRole:
378 #endif
379         builder.append(selector-&gt;argument());
380         builder.append(&#39;)&#39;);
381         break;
382     default:
383         break;
384     }
385 
386 }
387 
388 static void appendLangArgumentList(StringBuilder&amp; builder, const Vector&lt;AtomString&gt;&amp; argumentList)
389 {
390     unsigned argumentListSize = argumentList.size();
391     for (unsigned i = 0; i &lt; argumentListSize; ++i) {
392         builder.append(&#39;&quot;&#39;);
393         builder.append(argumentList[i]);
394         builder.append(&#39;&quot;&#39;);
395         if (i != argumentListSize - 1)
396             builder.appendLiteral(&quot;, &quot;);
397     }
398 }
399 
400 // http://dev.w3.org/csswg/css-syntax/#serializing-anb
401 static void outputNthChildAnPlusB(const CSSSelector&amp; selector, StringBuilder&amp; builder)
402 {
403     auto outputFirstTerm = [&amp;builder] (int a) {
404         switch (a) {
405         case 1:
406             break;
407         case -1:
408             builder.append(&#39;-&#39;);
409             break;
410         default:
411             builder.append(a);
412         }
413     };
414 
415     if (selector.argument() == nullAtom())
416         return;
417 
418     int a = selector.nthA();
419     int b = selector.nthB();
420     if (a == 0 &amp;&amp; b == 0)
421         builder.append(&#39;0&#39;);
422     else if (a == 0)
423         builder.append(b);
424     else if (b == 0) {
425         outputFirstTerm(a);
426         builder.append(&#39;n&#39;);
427     } else if (b &lt; 0) {
428         outputFirstTerm(a);
429         builder.append(&#39;n&#39;, b);
430     } else {
431         outputFirstTerm(a);
432         builder.append(&quot;n+&quot;, b);
433     }
434 }
435 
436 String CSSSelector::selectorText(const String&amp; rightSide) const
437 {
438     StringBuilder builder;
439 
440     if (match() == CSSSelector::Tag &amp;&amp; !m_tagIsForNamespaceRule) {
441         if (tagQName().prefix().isNull())
442             builder.append(tagQName().localName());
443         else {
444             builder.append(tagQName().prefix().string());
445             builder.append(&#39;|&#39;);
446             builder.append(tagQName().localName());
447         }
448     }
449 
450     const CSSSelector* cs = this;
451     while (true) {
452         if (cs-&gt;match() == CSSSelector::Id) {
453             builder.append(&#39;#&#39;);
454             serializeIdentifier(cs-&gt;serializingValue(), builder);
455         } else if (cs-&gt;match() == CSSSelector::Class) {
456             builder.append(&#39;.&#39;);
457             serializeIdentifier(cs-&gt;serializingValue(), builder);
458         } else if (cs-&gt;match() == CSSSelector::PseudoClass) {
459             switch (cs-&gt;pseudoClassType()) {
460 #if ENABLE(FULLSCREEN_API)
461             case CSSSelector::PseudoClassAnimatingFullScreenTransition:
462                 builder.appendLiteral(&quot;:-webkit-animating-full-screen-transition&quot;);
463                 break;
464 #endif
465             case CSSSelector::PseudoClassAny: {
466                 builder.appendLiteral(&quot;:-webkit-any(&quot;);
467                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);
468                 builder.append(&#39;)&#39;);
469                 break;
470             }
471             case CSSSelector::PseudoClassAnyLink:
472                 builder.appendLiteral(&quot;:any-link&quot;);
473                 break;
474             case CSSSelector::PseudoClassAnyLinkDeprecated:
475                 builder.appendLiteral(&quot;:-webkit-any-link&quot;);
476                 break;
477             case CSSSelector::PseudoClassAutofill:
478                 builder.appendLiteral(&quot;:-webkit-autofill&quot;);
479                 break;
480             case CSSSelector::PseudoClassAutofillStrongPassword:
481                 builder.appendLiteral(&quot;:-webkit-autofill-strong-password&quot;);
482                 break;
483             case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
484                 builder.appendLiteral(&quot;:-webkit-autofill-strong-password-viewable&quot;);
485                 break;
486             case CSSSelector::PseudoClassDirectFocus:
487                 builder.appendLiteral(&quot;:-webkit-direct-focus&quot;);
488                 break;
489             case CSSSelector::PseudoClassDrag:
490                 builder.appendLiteral(&quot;:-webkit-drag&quot;);
491                 break;
492             case CSSSelector::PseudoClassFullPageMedia:
493                 builder.appendLiteral(&quot;:-webkit-full-page-media&quot;);
494                 break;
495 #if ENABLE(FULLSCREEN_API)
496             case CSSSelector::PseudoClassFullScreen:
497                 builder.appendLiteral(&quot;:-webkit-full-screen&quot;);
498                 break;
499             case CSSSelector::PseudoClassFullScreenAncestor:
500                 builder.appendLiteral(&quot;:-webkit-full-screen-ancestor&quot;);
501                 break;
502             case CSSSelector::PseudoClassFullScreenDocument:
503                 builder.appendLiteral(&quot;:-webkit-full-screen-document&quot;);
504                 break;
505             case CSSSelector::PseudoClassFullScreenControlsHidden:
506                 builder.appendLiteral(&quot;:-webkit-full-screen-controls-hidden&quot;);
507                 break;
508 #endif
509 #if ENABLE(PICTURE_IN_PICTURE_API)
510             case CSSSelector::PseudoClassPictureInPicture:
511                 builder.appendLiteral(&quot;:picture-in-picture&quot;);
512                 break;
513 #endif
514             case CSSSelector::PseudoClassActive:
515                 builder.appendLiteral(&quot;:active&quot;);
516                 break;
517             case CSSSelector::PseudoClassChecked:
518                 builder.appendLiteral(&quot;:checked&quot;);
519                 break;
520             case CSSSelector::PseudoClassCornerPresent:
521                 builder.appendLiteral(&quot;:corner-present&quot;);
522                 break;
523             case CSSSelector::PseudoClassDecrement:
524                 builder.appendLiteral(&quot;:decrement&quot;);
525                 break;
526             case CSSSelector::PseudoClassDefault:
527                 builder.appendLiteral(&quot;:default&quot;);
528                 break;
529 #if ENABLE(CSS_SELECTORS_LEVEL4)
530             case CSSSelector::PseudoClassDir:
531                 builder.appendLiteral(&quot;:dir(&quot;);
532                 appendPseudoClassFunctionTail(builder, cs);
533                 break;
534 #endif
535             case CSSSelector::PseudoClassDisabled:
536                 builder.appendLiteral(&quot;:disabled&quot;);
537                 break;
538             case CSSSelector::PseudoClassDoubleButton:
539                 builder.appendLiteral(&quot;:double-button&quot;);
540                 break;
541             case CSSSelector::PseudoClassEmpty:
542                 builder.appendLiteral(&quot;:empty&quot;);
543                 break;
544             case CSSSelector::PseudoClassEnabled:
545                 builder.appendLiteral(&quot;:enabled&quot;);
546                 break;
547             case CSSSelector::PseudoClassEnd:
548                 builder.appendLiteral(&quot;:end&quot;);
549                 break;
550             case CSSSelector::PseudoClassFirstChild:
551                 builder.appendLiteral(&quot;:first-child&quot;);
552                 break;
553             case CSSSelector::PseudoClassFirstOfType:
554                 builder.appendLiteral(&quot;:first-of-type&quot;);
555                 break;
556             case CSSSelector::PseudoClassFocus:
557                 builder.appendLiteral(&quot;:focus&quot;);
558                 break;
559             case CSSSelector::PseudoClassFocusWithin:
560                 builder.appendLiteral(&quot;:focus-within&quot;);
561                 break;
562 #if ENABLE(VIDEO_TRACK)
563             case CSSSelector::PseudoClassFuture:
564                 builder.appendLiteral(&quot;:future&quot;);
565                 break;
566 #endif
567 #if ENABLE(ATTACHMENT_ELEMENT)
568             case CSSSelector::PseudoClassHasAttachment:
569                 builder.appendLiteral(&quot;:has-attachment&quot;);
570                 break;
571 #endif
572             case CSSSelector::PseudoClassHorizontal:
573                 builder.appendLiteral(&quot;:horizontal&quot;);
574                 break;
575             case CSSSelector::PseudoClassHover:
576                 builder.appendLiteral(&quot;:hover&quot;);
577                 break;
578             case CSSSelector::PseudoClassInRange:
579                 builder.appendLiteral(&quot;:in-range&quot;);
580                 break;
581             case CSSSelector::PseudoClassIncrement:
582                 builder.appendLiteral(&quot;:increment&quot;);
583                 break;
584             case CSSSelector::PseudoClassIndeterminate:
585                 builder.appendLiteral(&quot;:indeterminate&quot;);
586                 break;
587             case CSSSelector::PseudoClassInvalid:
588                 builder.appendLiteral(&quot;:invalid&quot;);
589                 break;
590             case CSSSelector::PseudoClassLang:
591                 builder.appendLiteral(&quot;:lang(&quot;);
592                 ASSERT_WITH_MESSAGE(cs-&gt;argumentList() &amp;&amp; !cs-&gt;argumentList()-&gt;isEmpty(), &quot;An empty :lang() is invalid and should never be generated by the parser.&quot;);
593                 appendLangArgumentList(builder, *cs-&gt;argumentList());
594                 builder.append(&#39;)&#39;);
595                 break;
596             case CSSSelector::PseudoClassLastChild:
597                 builder.appendLiteral(&quot;:last-child&quot;);
598                 break;
599             case CSSSelector::PseudoClassLastOfType:
600                 builder.appendLiteral(&quot;:last-of-type&quot;);
601                 break;
602             case CSSSelector::PseudoClassLink:
603                 builder.appendLiteral(&quot;:link&quot;);
604                 break;
605             case CSSSelector::PseudoClassNoButton:
606                 builder.appendLiteral(&quot;:no-button&quot;);
607                 break;
608             case CSSSelector::PseudoClassNot:
609                 builder.appendLiteral(&quot;:not(&quot;);
610                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);
611                 builder.append(&#39;)&#39;);
612                 break;
613             case CSSSelector::PseudoClassNthChild:
614                 builder.appendLiteral(&quot;:nth-child(&quot;);
615                 outputNthChildAnPlusB(*cs, builder);
616                 if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
617                     builder.appendLiteral(&quot; of &quot;);
618                     selectorList-&gt;buildSelectorsText(builder);
619                 }
620                 builder.append(&#39;)&#39;);
621                 break;
622             case CSSSelector::PseudoClassNthLastChild:
623                 builder.appendLiteral(&quot;:nth-last-child(&quot;);
624                 outputNthChildAnPlusB(*cs, builder);
625                 if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
626                     builder.appendLiteral(&quot; of &quot;);
627                     selectorList-&gt;buildSelectorsText(builder);
628                 }
629                 builder.append(&#39;)&#39;);
630                 break;
631             case CSSSelector::PseudoClassNthLastOfType:
632                 builder.appendLiteral(&quot;:nth-last-of-type(&quot;);
633                 appendPseudoClassFunctionTail(builder, cs);
634                 break;
635             case CSSSelector::PseudoClassNthOfType:
636                 builder.appendLiteral(&quot;:nth-of-type(&quot;);
637                 appendPseudoClassFunctionTail(builder, cs);
638                 break;
639             case CSSSelector::PseudoClassOnlyChild:
640                 builder.appendLiteral(&quot;:only-child&quot;);
641                 break;
642             case CSSSelector::PseudoClassOnlyOfType:
643                 builder.appendLiteral(&quot;:only-of-type&quot;);
644                 break;
645             case CSSSelector::PseudoClassOptional:
646                 builder.appendLiteral(&quot;:optional&quot;);
647                 break;
648             case CSSSelector::PseudoClassMatches: {
649                 builder.appendLiteral(&quot;:matches(&quot;);
650                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);
651                 builder.append(&#39;)&#39;);
652                 break;
653             }
654             case CSSSelector::PseudoClassPlaceholderShown:
655                 builder.appendLiteral(&quot;:placeholder-shown&quot;);
656                 break;
657             case CSSSelector::PseudoClassOutOfRange:
658                 builder.appendLiteral(&quot;:out-of-range&quot;);
659                 break;
660 #if ENABLE(VIDEO_TRACK)
661             case CSSSelector::PseudoClassPast:
662                 builder.appendLiteral(&quot;:past&quot;);
663                 break;
664 #endif
665             case CSSSelector::PseudoClassReadOnly:
666                 builder.appendLiteral(&quot;:read-only&quot;);
667                 break;
668             case CSSSelector::PseudoClassReadWrite:
669                 builder.appendLiteral(&quot;:read-write&quot;);
670                 break;
671             case CSSSelector::PseudoClassRequired:
672                 builder.appendLiteral(&quot;:required&quot;);
673                 break;
674 #if ENABLE(CSS_SELECTORS_LEVEL4)
675             case CSSSelector::PseudoClassRole:
676                 builder.appendLiteral(&quot;:role(&quot;);
677                 appendPseudoClassFunctionTail(builder, cs);
678                 break;
679 #endif
680             case CSSSelector::PseudoClassRoot:
681                 builder.appendLiteral(&quot;:root&quot;);
682                 break;
683             case CSSSelector::PseudoClassScope:
684                 builder.appendLiteral(&quot;:scope&quot;);
685                 break;
686             case CSSSelector::PseudoClassSingleButton:
687                 builder.appendLiteral(&quot;:single-button&quot;);
688                 break;
689             case CSSSelector::PseudoClassStart:
690                 builder.appendLiteral(&quot;:start&quot;);
691                 break;
692             case CSSSelector::PseudoClassTarget:
693                 builder.appendLiteral(&quot;:target&quot;);
694                 break;
695             case CSSSelector::PseudoClassValid:
696                 builder.appendLiteral(&quot;:valid&quot;);
697                 break;
698             case CSSSelector::PseudoClassVertical:
699                 builder.appendLiteral(&quot;:vertical&quot;);
700                 break;
701             case CSSSelector::PseudoClassVisited:
702                 builder.appendLiteral(&quot;:visited&quot;);
703                 break;
704             case CSSSelector::PseudoClassWindowInactive:
705                 builder.appendLiteral(&quot;:window-inactive&quot;);
706                 break;
707             case CSSSelector::PseudoClassHost:
708                 builder.appendLiteral(&quot;:host&quot;);
709                 break;
710             case CSSSelector::PseudoClassDefined:
711                 builder.appendLiteral(&quot;:defined&quot;);
712                 break;
713             case CSSSelector::PseudoClassUnknown:
714                 ASSERT_NOT_REACHED();
715             }
716         } else if (cs-&gt;match() == CSSSelector::PseudoElement) {
717             switch (cs-&gt;pseudoElementType()) {
718             case CSSSelector::PseudoElementSlotted:
719                 builder.appendLiteral(&quot;::slotted(&quot;);
720                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);
721                 builder.append(&#39;)&#39;);
722                 break;
723             case CSSSelector::PseudoElementPart: {
724                 builder.appendLiteral(&quot;::part(&quot;);
725                 bool isFirst = true;
726                 for (auto&amp; partName : *cs-&gt;argumentList()) {
727                     if (!isFirst)
728                         builder.append(&#39; &#39;);
729                     isFirst = false;
730                     builder.append(partName);
731                 }
732                 builder.append(&#39;)&#39;);
733                 break;
734             }
735             case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
736                 if (cs-&gt;value() == &quot;placeholder&quot;)
737                     builder.appendLiteral(&quot;::-webkit-input-placeholder&quot;);
738                 break;
739 #if ENABLE(VIDEO_TRACK)
740             case CSSSelector::PseudoElementCue: {
741                 if (auto* selectorList = cs-&gt;selectorList()) {
742                     builder.appendLiteral(&quot;::cue(&quot;);
743                     selectorList-&gt;buildSelectorsText(builder);
744                     builder.append(&#39;)&#39;);
745                 } else
746                     builder.appendLiteral(&quot;::cue&quot;);
747                 break;
748             }
749 #endif
750             default:
751                 builder.appendLiteral(&quot;::&quot;);
752                 builder.append(cs-&gt;serializingValue());
753             }
754         } else if (cs-&gt;isAttributeSelector()) {
755             builder.append(&#39;[&#39;);
756             const AtomString&amp; prefix = cs-&gt;attribute().prefix();
757             if (!prefix.isEmpty()) {
758                 builder.append(prefix);
759                 builder.append(&#39;|&#39;);
760             }
761             builder.append(cs-&gt;attribute().localName());
762             switch (cs-&gt;match()) {
763                 case CSSSelector::Exact:
764                     builder.append(&#39;=&#39;);
765                     break;
766                 case CSSSelector::Set:
767                     // set has no operator or value, just the attrName
768                     builder.append(&#39;]&#39;);
769                     break;
770                 case CSSSelector::List:
771                     builder.appendLiteral(&quot;~=&quot;);
772                     break;
773                 case CSSSelector::Hyphen:
774                     builder.appendLiteral(&quot;|=&quot;);
775                     break;
776                 case CSSSelector::Begin:
777                     builder.appendLiteral(&quot;^=&quot;);
778                     break;
779                 case CSSSelector::End:
780                     builder.appendLiteral(&quot;$=&quot;);
781                     break;
782                 case CSSSelector::Contain:
783                     builder.appendLiteral(&quot;*=&quot;);
784                     break;
785                 default:
786                     break;
787             }
788             if (cs-&gt;match() != CSSSelector::Set) {
789                 serializeString(cs-&gt;serializingValue(), builder);
790                 if (cs-&gt;attributeValueMatchingIsCaseInsensitive())
791                     builder.appendLiteral(&quot; i]&quot;);
792                 else
793                     builder.append(&#39;]&#39;);
794             }
795         } else if (cs-&gt;match() == CSSSelector::PagePseudoClass) {
796             switch (cs-&gt;pagePseudoClassType()) {
797             case PagePseudoClassFirst:
798                 builder.appendLiteral(&quot;:first&quot;);
799                 break;
800             case PagePseudoClassLeft:
801                 builder.appendLiteral(&quot;:left&quot;);
802                 break;
803             case PagePseudoClassRight:
804                 builder.appendLiteral(&quot;:right&quot;);
805                 break;
806             }
807         }
808 
809         if (cs-&gt;relation() != CSSSelector::Subselector || !cs-&gt;tagHistory())
810             break;
811         cs = cs-&gt;tagHistory();
812     }
813 
814     if (const CSSSelector* tagHistory = cs-&gt;tagHistory()) {
815         switch (cs-&gt;relation()) {
816         case CSSSelector::DescendantSpace:
817             return tagHistory-&gt;selectorText(&quot; &quot; + builder.toString() + rightSide);
818         case CSSSelector::Child:
819             return tagHistory-&gt;selectorText(&quot; &gt; &quot; + builder.toString() + rightSide);
820         case CSSSelector::DirectAdjacent:
821             return tagHistory-&gt;selectorText(&quot; + &quot; + builder.toString() + rightSide);
822         case CSSSelector::IndirectAdjacent:
823             return tagHistory-&gt;selectorText(&quot; ~ &quot; + builder.toString() + rightSide);
824         case CSSSelector::Subselector:
825             ASSERT_NOT_REACHED();
826 #if !ASSERT_ENABLED
827             FALLTHROUGH;
828 #endif
829         case CSSSelector::ShadowDescendant:
830             return tagHistory-&gt;selectorText(builder.toString() + rightSide);
831         }
832     }
833     return builder.toString() + rightSide;
834 }
835 
836 void CSSSelector::setAttribute(const QualifiedName&amp; value, bool convertToLowercase, AttributeMatchType matchType)
837 {
838     createRareData();
839     m_data.m_rareData-&gt;m_attribute = value;
840     m_data.m_rareData-&gt;m_attributeCanonicalLocalName = convertToLowercase ? value.localName().convertToASCIILowercase() : value.localName();
841     m_caseInsensitiveAttributeValueMatching = matchType == CaseInsensitive;
842 }
843 
844 void CSSSelector::setArgument(const AtomString&amp; value)
845 {
846     createRareData();
847     m_data.m_rareData-&gt;m_argument = value;
848 }
849 
850 void CSSSelector::setArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)
851 {
852     createRareData();
853     m_data.m_rareData-&gt;m_argumentList = WTFMove(argumentList);
854 }
855 
856 void CSSSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
857 {
858     createRareData();
859     m_data.m_rareData-&gt;m_selectorList = WTFMove(selectorList);
860 }
861 
862 void CSSSelector::setNth(int a, int b)
863 {
864     createRareData();
865     m_data.m_rareData-&gt;m_a = a;
866     m_data.m_rareData-&gt;m_b = b;
867 }
868 
869 bool CSSSelector::matchNth(int count) const
870 {
871     ASSERT(m_hasRareData);
872     return m_data.m_rareData-&gt;matchNth(count);
873 }
874 
875 int CSSSelector::nthA() const
876 {
877     ASSERT(m_hasRareData);
878     return m_data.m_rareData-&gt;m_a;
879 }
880 
881 int CSSSelector::nthB() const
882 {
883     ASSERT(m_hasRareData);
884     return m_data.m_rareData-&gt;m_b;
885 }
886 
887 CSSSelector::RareData::RareData(AtomString&amp;&amp; value)
888     : m_matchingValue(value)
889     , m_serializingValue(value)
890     , m_a(0)
891     , m_b(0)
892     , m_attribute(anyQName())
893     , m_argument(nullAtom())
894 {
895 }
896 
897 CSSSelector::RareData::~RareData() = default;
898 
899 // a helper function for checking nth-arguments
900 bool CSSSelector::RareData::matchNth(int count)
901 {
902     if (!m_a)
903         return count == m_b;
904     else if (m_a &gt; 0) {
905         if (count &lt; m_b)
906             return false;
907         return (count - m_b) % m_a == 0;
908     } else {
909         if (count &gt; m_b)
910             return false;
911         return (m_b - count) % (-m_a) == 0;
912     }
913 }
914 
915 } // namespace WebCore
    </pre>
  </body>
</html>
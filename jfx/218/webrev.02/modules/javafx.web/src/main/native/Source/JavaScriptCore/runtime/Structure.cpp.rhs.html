<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Structure.h&quot;
  28 
  29 #include &quot;BuiltinNames.h&quot;
  30 #include &quot;CodeBlock.h&quot;
  31 #include &quot;DumpContext.h&quot;
  32 #include &quot;JSCInlines.h&quot;
  33 #include &quot;JSObject.h&quot;
  34 #include &quot;JSPropertyNameEnumerator.h&quot;
  35 #include &quot;Lookup.h&quot;
  36 #include &quot;PropertyMapHashTable.h&quot;
  37 #include &quot;PropertyNameArray.h&quot;
  38 #include &quot;StructureChain.h&quot;
  39 #include &quot;StructureRareDataInlines.h&quot;
  40 #include &quot;WeakGCMapInlines.h&quot;
  41 #include &lt;wtf/CommaPrinter.h&gt;
  42 #include &lt;wtf/NeverDestroyed.h&gt;
  43 #include &lt;wtf/ProcessID.h&gt;
  44 #include &lt;wtf/RefPtr.h&gt;
  45 #include &lt;wtf/Threading.h&gt;
  46 
  47 #define DUMP_STRUCTURE_ID_STATISTICS 0
  48 
  49 namespace JSC {
  50 
  51 #if DUMP_STRUCTURE_ID_STATISTICS
  52 static HashSet&lt;Structure*&gt;&amp; liveStructureSet = *(new HashSet&lt;Structure*&gt;);
  53 #endif
  54 
  55 class SingleSlotTransitionWeakOwner final : public WeakHandleOwner {
  56     void finalize(Handle&lt;Unknown&gt;, void* context) override
  57     {
  58         StructureTransitionTable* table = reinterpret_cast&lt;StructureTransitionTable*&gt;(context);
  59         ASSERT(table-&gt;isUsingSingleSlot());
  60         WeakSet::deallocate(table-&gt;weakImpl());
  61         table-&gt;m_data = StructureTransitionTable::UsingSingleSlotFlag;
  62     }
  63 };
  64 
  65 static SingleSlotTransitionWeakOwner&amp; singleSlotTransitionWeakOwner()
  66 {
  67     static NeverDestroyed&lt;SingleSlotTransitionWeakOwner&gt; owner;
  68     return owner;
  69 }
  70 
  71 inline Structure* StructureTransitionTable::singleTransition() const
  72 {
  73     ASSERT(isUsingSingleSlot());
  74     if (WeakImpl* impl = this-&gt;weakImpl()) {
  75         if (impl-&gt;state() == WeakImpl::Live)
  76             return jsCast&lt;Structure*&gt;(impl-&gt;jsValue().asCell());
  77     }
  78     return nullptr;
  79 }
  80 
  81 inline void StructureTransitionTable::setSingleTransition(Structure* structure)
  82 {
  83     ASSERT(isUsingSingleSlot());
  84     if (WeakImpl* impl = this-&gt;weakImpl())
  85         WeakSet::deallocate(impl);
  86     WeakImpl* impl = WeakSet::allocate(structure, &amp;singleSlotTransitionWeakOwner(), this);
  87     m_data = bitwise_cast&lt;intptr_t&gt;(impl) | UsingSingleSlotFlag;
  88 }
  89 
<a name="1" id="anc1"></a><span class="line-modified">  90 bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes, bool isAddition) const</span>
  91 {
  92     if (isUsingSingleSlot()) {
  93         Structure* transition = singleTransition();
<a name="2" id="anc2"></a><span class="line-modified">  94         return transition &amp;&amp; transition-&gt;m_transitionPropertyName == rep &amp;&amp; transition-&gt;transitionPropertyAttributes() == attributes &amp;&amp; transition-&gt;isPropertyDeletionTransition() == !isAddition;</span>
  95     }
<a name="3" id="anc3"></a><span class="line-modified">  96     return map()-&gt;get(StructureTransitionTable::Hash::Key(rep, attributes, isAddition));</span>
  97 }
  98 
<a name="4" id="anc4"></a><span class="line-modified">  99 inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes, bool isAddition) const</span>
 100 {
 101     if (isUsingSingleSlot()) {
 102         Structure* transition = singleTransition();
<a name="5" id="anc5"></a><span class="line-modified"> 103         return (transition &amp;&amp; transition-&gt;m_transitionPropertyName == rep &amp;&amp; transition-&gt;transitionPropertyAttributes() == attributes &amp;&amp; transition-&gt;isPropertyDeletionTransition() == !isAddition) ? transition : 0;</span>
 104     }
<a name="6" id="anc6"></a><span class="line-modified"> 105     return map()-&gt;get(StructureTransitionTable::Hash::Key(rep, attributes, isAddition));</span>
 106 }
 107 
 108 void StructureTransitionTable::add(VM&amp; vm, Structure* structure)
 109 {
 110     if (isUsingSingleSlot()) {
 111         Structure* existingTransition = singleTransition();
 112 
 113         // This handles the first transition being added.
 114         if (!existingTransition) {
 115             setSingleTransition(structure);
 116             return;
 117         }
 118 
 119         // This handles the second transition being added
 120         // (or the first transition being despecified!)
 121         setMap(new TransitionMap(vm));
 122         add(vm, existingTransition);
 123     }
 124 
 125     // Add the structure to the map.
<a name="7" id="anc7"></a><span class="line-modified"> 126     map()-&gt;set(StructureTransitionTable::Hash::Key(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionPropertyAttributes(), !structure-&gt;isPropertyDeletionTransition()), structure);</span>




 127 }
 128 
 129 void Structure::dumpStatistics()
 130 {
 131 #if DUMP_STRUCTURE_ID_STATISTICS
 132     unsigned numberLeaf = 0;
 133     unsigned numberUsingSingleSlot = 0;
 134     unsigned numberSingletons = 0;
 135     unsigned numberWithPropertyMaps = 0;
 136     unsigned totalPropertyMapsSize = 0;
 137 
 138     HashSet&lt;Structure*&gt;::const_iterator end = liveStructureSet.end();
 139     for (HashSet&lt;Structure*&gt;::const_iterator it = liveStructureSet.begin(); it != end; ++it) {
 140         Structure* structure = *it;
 141 
 142         switch (structure-&gt;m_transitionTable.size()) {
 143             case 0:
 144                 ++numberLeaf;
 145                 if (!structure-&gt;previousID())
 146                     ++numberSingletons;
 147                 break;
 148 
 149             case 1:
 150                 ++numberUsingSingleSlot;
 151                 break;
 152         }
 153 
 154         if (PropertyTable* table = structure-&gt;propertyTableOrNull()) {
 155             ++numberWithPropertyMaps;
 156             totalPropertyMapsSize += table-&gt;sizeInMemory();
 157         }
 158     }
 159 
 160     dataLogF(&quot;Number of live Structures: %d\n&quot;, liveStructureSet.size());
 161     dataLogF(&quot;Number of Structures using the single item optimization for transition map: %d\n&quot;, numberUsingSingleSlot);
 162     dataLogF(&quot;Number of Structures that are leaf nodes: %d\n&quot;, numberLeaf);
 163     dataLogF(&quot;Number of Structures that singletons: %d\n&quot;, numberSingletons);
 164     dataLogF(&quot;Number of Structures with PropertyMaps: %d\n&quot;, numberWithPropertyMaps);
 165 
 166     dataLogF(&quot;Size of a single Structures: %d\n&quot;, static_cast&lt;unsigned&gt;(sizeof(Structure)));
 167     dataLogF(&quot;Size of sum of all property maps: %d\n&quot;, totalPropertyMapsSize);
 168     dataLogF(&quot;Size of average of all property maps: %f\n&quot;, static_cast&lt;double&gt;(totalPropertyMapsSize) / static_cast&lt;double&gt;(liveStructureSet.size()));
 169 #else
 170     dataLogF(&quot;Dumping Structure statistics is not enabled.\n&quot;);
 171 #endif
 172 }
 173 
 174 Structure::Structure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 175     : JSCell(vm, vm.structureStructure.get())
 176     , m_blob(vm.heap.structureIDTable().allocateID(this), indexingType, typeInfo)
 177     , m_outOfLineTypeFlags(typeInfo.outOfLineTypeFlags())
 178     , m_inlineCapacity(inlineCapacity)
 179     , m_bitField(0)
 180     , m_globalObject(vm, this, globalObject, WriteBarrier&lt;JSGlobalObject&gt;::MayBeNull)
 181     , m_prototype(vm, this, prototype)
 182     , m_classInfo(classInfo)
 183     , m_transitionWatchpointSet(IsWatched)
<a name="8" id="anc8"></a>
 184     , m_propertyHash(0)
 185 {
 186     setDictionaryKind(NoneDictionaryKind);
 187     setIsPinnedPropertyTable(false);
 188     setHasGetterSetterProperties(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 189     setHasCustomGetterSetterProperties(false);
 190     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 191     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 192     setIsQuickPropertyAccessAllowedForEnumeration(true);
<a name="9" id="anc9"></a><span class="line-modified"> 193     setTransitionPropertyAttributes(0);</span>
 194     setDidPreventExtensions(false);
 195     setDidTransition(false);
 196     setStaticPropertiesReified(false);
 197     setTransitionWatchpointIsLikelyToBeFired(false);
 198     setHasBeenDictionary(false);
<a name="10" id="anc10"></a><span class="line-modified"> 199     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 200     setIsPropertyDeletionTransition(false);</span>
<span class="line-added"> 201     setTransitionOffset(vm, invalidOffset);</span>
<span class="line-added"> 202     setMaxOffset(vm, invalidOffset);</span>
 203 
 204     ASSERT(inlineCapacity &lt;= JSFinalObject::maxInlineCapacity());
 205     ASSERT(static_cast&lt;PropertyOffset&gt;(inlineCapacity) &lt; firstOutOfLineOffset);
 206     ASSERT(!hasRareData());
 207     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 208     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 209     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 210 }
 211 
 212 const ClassInfo Structure::s_info = { &quot;Structure&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(Structure) };
 213 
 214 Structure::Structure(VM&amp; vm)
 215     : JSCell(CreatingEarlyCell)
 216     , m_inlineCapacity(0)
 217     , m_bitField(0)
 218     , m_prototype(vm, this, jsNull())
 219     , m_classInfo(info())
 220     , m_transitionWatchpointSet(IsWatched)
<a name="11" id="anc11"></a>
 221     , m_propertyHash(0)
 222 {
 223     setDictionaryKind(NoneDictionaryKind);
 224     setIsPinnedPropertyTable(false);
 225     setHasGetterSetterProperties(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 226     setHasCustomGetterSetterProperties(false);
 227     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 228     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 229     setIsQuickPropertyAccessAllowedForEnumeration(true);
<a name="12" id="anc12"></a><span class="line-modified"> 230     setTransitionPropertyAttributes(0);</span>
 231     setDidPreventExtensions(false);
 232     setDidTransition(false);
 233     setStaticPropertiesReified(false);
 234     setTransitionWatchpointIsLikelyToBeFired(false);
 235     setHasBeenDictionary(false);
<a name="13" id="anc13"></a><span class="line-modified"> 236     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 237     setIsPropertyDeletionTransition(false);</span>
<span class="line-added"> 238     setTransitionOffset(vm, invalidOffset);</span>
<span class="line-added"> 239     setMaxOffset(vm, invalidOffset);</span>
 240 
 241     TypeInfo typeInfo = TypeInfo(CellType, StructureFlags);
 242     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), 0, typeInfo);
 243     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 244 
 245     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 246     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 247     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 248 }
 249 
 250 Structure::Structure(VM&amp; vm, Structure* previous, DeferredStructureTransitionWatchpointFire* deferred)
 251     : JSCell(vm, vm.structureStructure.get())
 252     , m_inlineCapacity(previous-&gt;m_inlineCapacity)
 253     , m_bitField(0)
 254     , m_prototype(vm, this, previous-&gt;m_prototype.get())
 255     , m_classInfo(previous-&gt;m_classInfo)
 256     , m_transitionWatchpointSet(IsWatched)
<a name="14" id="anc14"></a>
 257     , m_propertyHash(previous-&gt;m_propertyHash)
<a name="15" id="anc15"></a><span class="line-added"> 258     , m_seenProperties(previous-&gt;m_seenProperties)</span>
 259 {
 260     setDictionaryKind(previous-&gt;dictionaryKind());
 261     setIsPinnedPropertyTable(false);
 262     setHasBeenFlattenedBefore(previous-&gt;hasBeenFlattenedBefore());
 263     setHasGetterSetterProperties(previous-&gt;hasGetterSetterProperties());
 264     setHasCustomGetterSetterProperties(previous-&gt;hasCustomGetterSetterProperties());
 265     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(previous-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto());
 266     setHasUnderscoreProtoPropertyExcludingOriginalProto(previous-&gt;hasUnderscoreProtoPropertyExcludingOriginalProto());
 267     setIsQuickPropertyAccessAllowedForEnumeration(previous-&gt;isQuickPropertyAccessAllowedForEnumeration());
<a name="16" id="anc16"></a><span class="line-modified"> 268     setTransitionPropertyAttributes(0);</span>
 269     setDidPreventExtensions(previous-&gt;didPreventExtensions());
 270     setDidTransition(true);
 271     setStaticPropertiesReified(previous-&gt;staticPropertiesReified());
 272     setHasBeenDictionary(previous-&gt;hasBeenDictionary());
<a name="17" id="anc17"></a><span class="line-modified"> 273     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 274     setIsPropertyDeletionTransition(false);</span>
<span class="line-added"> 275     setTransitionOffset(vm, invalidOffset);</span>
<span class="line-added"> 276     setMaxOffset(vm, invalidOffset);</span>
 277 
 278     TypeInfo typeInfo = previous-&gt;typeInfo();
 279     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), previous-&gt;indexingModeIncludingHistory(), typeInfo);
 280     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 281 
 282     ASSERT(!previous-&gt;typeInfo().structureIsImmortal());
 283     setPreviousID(vm, previous);
 284 
 285     previous-&gt;didTransitionFromThisStructure(deferred);
 286 
 287     // Copy this bit now, in case previous was being watched.
 288     setTransitionWatchpointIsLikelyToBeFired(previous-&gt;transitionWatchpointIsLikelyToBeFired());
 289 
 290     if (previous-&gt;m_globalObject)
 291         m_globalObject.set(vm, this, previous-&gt;m_globalObject.get());
 292     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 293     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 294     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 295 }
 296 
 297 Structure::~Structure()
 298 {
 299     if (typeInfo().structureIsImmortal())
 300         return;
 301     Heap::heap(this)-&gt;structureIDTable().deallocateID(this, m_blob.structureID());
 302 }
 303 
 304 void Structure::destroy(JSCell* cell)
 305 {
 306     static_cast&lt;Structure*&gt;(cell)-&gt;Structure::~Structure();
 307 }
 308 
 309 Structure* Structure::create(PolyProtoTag, VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 310 {
 311     Structure* result = create(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 312 
 313     unsigned oldOutOfLineCapacity = result-&gt;outOfLineCapacity();
 314     result-&gt;addPropertyWithoutTransition(
 315         vm, vm.propertyNames-&gt;builtinNames().polyProtoName(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum),
<a name="18" id="anc18"></a><span class="line-modified"> 316         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified"> 317             RELEASE_ASSERT(Structure::outOfLineCapacity(newMaxOffset) == oldOutOfLineCapacity);</span>
 318             RELEASE_ASSERT(offset == knownPolyProtoOffset);
 319             RELEASE_ASSERT(isInlineOffset(knownPolyProtoOffset));
 320             result-&gt;m_prototype.setWithoutWriteBarrier(JSValue());
<a name="19" id="anc19"></a><span class="line-modified"> 321             result-&gt;setMaxOffset(vm, newMaxOffset);</span>
 322         });
 323 
 324     return result;
 325 }
 326 
 327 bool Structure::isValidPrototype(JSValue prototype)
 328 {
 329     return prototype.isNull() || (prototype.isObject() &amp;&amp; prototype.getObject()-&gt;mayBePrototype());
 330 }
 331 
 332 void Structure::findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp; structure, PropertyTable*&amp; table)
 333 {
 334     ASSERT(structures.isEmpty());
 335     table = 0;
 336 
 337     for (structure = this; structure; structure = structure-&gt;previousID()) {
 338         structure-&gt;m_lock.lock();
 339 
 340         table = structure-&gt;propertyTableOrNull();
 341         if (table) {
 342             // Leave the structure locked, so that the caller can do things to it atomically
 343             // before it loses its property table.
 344             return;
 345         }
 346 
 347         structures.append(structure);
 348         structure-&gt;m_lock.unlock();
 349     }
 350 
 351     ASSERT(!structure);
 352     ASSERT(!table);
 353 }
 354 
 355 PropertyTable* Structure::materializePropertyTable(VM&amp; vm, bool setPropertyTable)
 356 {
 357     ASSERT(structure(vm)-&gt;classInfo() == info());
<a name="20" id="anc20"></a><span class="line-modified"> 358     ASSERT(!protectPropertyTableWhileTransitioning());</span>
 359 
 360     DeferGC deferGC(vm.heap);
 361 
 362     Vector&lt;Structure*, 8&gt; structures;
 363     Structure* structure;
 364     PropertyTable* table;
 365 
 366     findStructuresAndMapForMaterialization(structures, structure, table);
 367 
<a name="21" id="anc21"></a><span class="line-modified"> 368     unsigned capacity = numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity);</span>
 369     if (table) {
 370         table = table-&gt;copy(vm, capacity);
 371         structure-&gt;m_lock.unlock();
 372     } else
 373         table = PropertyTable::create(vm, capacity);
 374 
 375     // Must hold the lock on this structure, since we will be modifying this structure&#39;s
 376     // property map. We don&#39;t want getConcurrently() to see the property map in a half-baked
 377     // state.
 378     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 379     if (setPropertyTable)
 380         this-&gt;setPropertyTable(vm, table);
 381 
 382     for (size_t i = structures.size(); i--;) {
 383         structure = structures[i];
<a name="22" id="anc22"></a><span class="line-modified"> 384         if (!structure-&gt;m_transitionPropertyName)</span>
<span class="line-added"> 385             continue;</span>
<span class="line-added"> 386         if (structure-&gt;isPropertyDeletionTransition()) {</span>
<span class="line-added"> 387             auto item = table-&gt;find(structure-&gt;m_transitionPropertyName.get());</span>
<span class="line-added"> 388             ASSERT(item.first);</span>
<span class="line-added"> 389             table-&gt;remove(item);</span>
<span class="line-added"> 390             table-&gt;addDeletedOffset(structure-&gt;transitionOffset());</span>
 391             continue;
<a name="23" id="anc23"></a><span class="line-modified"> 392         }</span>
<span class="line-modified"> 393         PropertyMapEntry entry(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionOffset(), structure-&gt;transitionPropertyAttributes());</span>
<span class="line-added"> 394         auto nextOffset = table-&gt;nextOffset(structure-&gt;inlineCapacity());</span>
<span class="line-added"> 395         ASSERT_UNUSED(nextOffset, nextOffset == structure-&gt;transitionOffset());</span>
<span class="line-added"> 396         auto result = table-&gt;add(entry);</span>
<span class="line-added"> 397         ASSERT_UNUSED(result, result.second);</span>
<span class="line-added"> 398         ASSERT_UNUSED(result, result.first.first-&gt;offset == nextOffset);</span>
 399     }
 400 
 401     checkOffsetConsistency(
 402         table,
 403         [&amp;] () {
 404             dataLog(&quot;Detected in materializePropertyTable.\n&quot;);
 405             dataLog(&quot;Found structure = &quot;, RawPointer(structure), &quot;\n&quot;);
 406             dataLog(&quot;structures = &quot;);
 407             CommaPrinter comma;
 408             for (Structure* structure : structures)
 409                 dataLog(comma, RawPointer(structure));
 410             dataLog(&quot;\n&quot;);
 411         });
 412 
 413     return table;
 414 }
 415 
 416 Structure* Structure::addPropertyTransitionToExistingStructureImpl(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 417 {
 418     ASSERT(!structure-&gt;isDictionary());
 419     ASSERT(structure-&gt;isObject());
 420 
<a name="24" id="anc24"></a><span class="line-modified"> 421     constexpr bool isAddition = true;</span>
<span class="line-modified"> 422     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes, isAddition)) {</span>
<span class="line-modified"> 423         validateOffset(existingTransition-&gt;transitionOffset(), existingTransition-&gt;inlineCapacity());</span>
<span class="line-added"> 424         offset = existingTransition-&gt;transitionOffset();</span>
 425         return existingTransition;
 426     }
 427 
 428     return 0;
 429 }
 430 
 431 Structure* Structure::addPropertyTransitionToExistingStructure(Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 432 {
 433     ASSERT(!isCompilationThread());
 434     return addPropertyTransitionToExistingStructureImpl(structure, propertyName.uid(), attributes, offset);
 435 }
 436 
 437 Structure* Structure::addPropertyTransitionToExistingStructureConcurrently(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 438 {
 439     ConcurrentJSLocker locker(structure-&gt;m_lock);
 440     return addPropertyTransitionToExistingStructureImpl(structure, uid, attributes, offset);
 441 }
 442 
 443 bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const
 444 {
 445     ASSERT(base-&gt;structure(vm) == this);
 446 
 447     if (this-&gt;mayInterceptIndexedAccesses())
 448         return true;
 449 
 450     JSValue prototype = this-&gt;storedPrototype(base);
 451     if (!prototype.isObject())
 452         return false;
 453     JSObject* object = asObject(prototype);
 454 
 455     while (true) {
 456         Structure&amp; structure = *object-&gt;structure(vm);
 457         if (hasIndexedProperties(object-&gt;indexingType()) || structure.mayInterceptIndexedAccesses())
 458             return true;
 459         prototype = structure.storedPrototype(object);
 460         if (!prototype.isObject())
 461             return false;
 462         object = asObject(prototype);
 463     }
 464 
 465     RELEASE_ASSERT_NOT_REACHED();
 466     return false;
 467 }
 468 
 469 Structure* Structure::addPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 470 {
 471     Structure* newStructure = addPropertyTransitionToExistingStructure(
 472         structure, propertyName, attributes, offset);
 473     if (newStructure)
 474         return newStructure;
 475 
 476     return addNewPropertyTransition(
 477         vm, structure, propertyName, attributes, offset, PutPropertySlot::UnknownContext);
 478 }
 479 
 480 Structure* Structure::addNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset, PutPropertySlot::Context context, DeferredStructureTransitionWatchpointFire* deferred)
 481 {
 482     ASSERT(!structure-&gt;isDictionary());
 483     ASSERT(structure-&gt;isObject());
 484     ASSERT(!Structure::addPropertyTransitionToExistingStructure(structure, propertyName, attributes, offset));
 485 
 486     int maxTransitionLength;
 487     if (context == PutPropertySlot::PutById)
 488         maxTransitionLength = s_maxTransitionLengthForNonEvalPutById;
 489     else
 490         maxTransitionLength = s_maxTransitionLength;
<a name="25" id="anc25"></a><span class="line-modified"> 491     if (structure-&gt;transitionCountEstimate() &gt; maxTransitionLength) {</span>
 492         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
 493         Structure* transition = toCacheableDictionaryTransition(vm, structure, deferred);
 494         ASSERT(structure != transition);
 495         offset = transition-&gt;add(vm, propertyName, attributes);
 496         return transition;
 497     }
 498 
 499     Structure* transition = create(vm, structure, deferred);
 500 
 501     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());
 502 
 503     // While we are adding the property, rematerializing the property table is super weird: we already
<a name="26" id="anc26"></a><span class="line-modified"> 504     // have a m_transitionPropertyName and transitionPropertyAttributes but the m_transitionOffset is still wrong. If the</span>
 505     // materialization algorithm runs, it&#39;ll build a property table that already has the property but
 506     // at a bogus offset. Rather than try to teach the materialization code how to create a table under
 507     // those conditions, we just tell the GC not to blow the table away during this period of time.
 508     // Holding the lock ensures that we either do this before the GC starts scanning the structure, in
 509     // which case the GC will not blow the table away, or we do it after the GC already ran in which
 510     // case all is well.  If it wasn&#39;t for the lock, the GC would have TOCTOU: if could read
<a name="27" id="anc27"></a><span class="line-modified"> 511     // protectPropertyTableWhileTransitioning before we set it to true, and then blow the table away after.</span>
 512     {
 513         ConcurrentJSLocker locker(transition-&gt;m_lock);
<a name="28" id="anc28"></a><span class="line-modified"> 514         transition-&gt;setProtectPropertyTableWhileTransitioning(true);</span>
 515     }
 516 
 517     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);
<a name="29" id="anc29"></a><span class="line-modified"> 518     transition-&gt;m_transitionPropertyName = propertyName.uid();</span>
<span class="line-modified"> 519     transition-&gt;setTransitionPropertyAttributes(attributes);</span>
 520     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<a name="30" id="anc30"></a><span class="line-modified"> 521     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 522 
 523     offset = transition-&gt;add(vm, propertyName, attributes);
<a name="31" id="anc31"></a><span class="line-added"> 524     transition-&gt;setTransitionOffset(vm, offset);</span>
 525 
 526     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the
 527     // table away if it wants. We can now rebuild it fine.
 528     WTF::storeStoreFence();
<a name="32" id="anc32"></a><span class="line-modified"> 529     transition-&gt;setProtectPropertyTableWhileTransitioning(false);</span>
 530 
<a name="33" id="anc33"></a><span class="line-modified"> 531     checkOffset(transition-&gt;transitionOffset(), transition-&gt;inlineCapacity());</span>
 532     {
<a name="34" id="anc34"></a><span class="line-modified"> 533         GCSafeConcurrentJSLocker locker(structure-&gt;m_lock, vm.heap);</span>

 534         structure-&gt;m_transitionTable.add(vm, transition);
 535     }
 536     transition-&gt;checkOffsetConsistency();
 537     structure-&gt;checkOffsetConsistency();
 538     return transition;
 539 }
 540 
<a name="35" id="anc35"></a><span class="line-modified"> 541 Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire* deferred)</span>
<span class="line-modified"> 542 {</span>
<span class="line-modified"> 543     Structure* newStructure = removePropertyTransitionFromExistingStructure(</span>
<span class="line-modified"> 544         vm, structure, propertyName, offset, deferred);</span>
<span class="line-modified"> 545     if (newStructure)</span>
<span class="line-modified"> 546         return newStructure;</span>
<span class="line-modified"> 547 </span>
<span class="line-modified"> 548     return removeNewPropertyTransition(</span>
<span class="line-modified"> 549         vm, structure, propertyName, offset, deferred);</span>
<span class="line-modified"> 550 }</span>
<span class="line-modified"> 551 </span>
<span class="line-modified"> 552 Structure* Structure::removePropertyTransitionFromExistingStructure(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire*)</span>
<span class="line-modified"> 553 {</span>
<span class="line-modified"> 554     ASSERT(!isCompilationThread());</span>
 555     ASSERT(!structure-&gt;isUncacheableDictionary());
<a name="36" id="anc36"></a><span class="line-added"> 556     ASSERT(structure-&gt;isObject());</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558     unsigned attributes;</span>
<span class="line-added"> 559     structure-&gt;get(vm, propertyName, attributes);</span>
 560 
<a name="37" id="anc37"></a><span class="line-modified"> 561     constexpr bool isAddition = false;</span>
<span class="line-added"> 562     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(propertyName.uid(), attributes, isAddition)) {</span>
<span class="line-added"> 563         validateOffset(existingTransition-&gt;transitionOffset(), existingTransition-&gt;inlineCapacity());</span>
<span class="line-added"> 564         offset = existingTransition-&gt;transitionOffset();</span>
<span class="line-added"> 565         return existingTransition;</span>
<span class="line-added"> 566     }</span>
 567 
<a name="38" id="anc38"></a><span class="line-modified"> 568     return nullptr;</span>
<span class="line-added"> 569 }</span>
 570 
<a name="39" id="anc39"></a><span class="line-added"> 571 Structure* Structure::removeNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire* deferred)</span>
<span class="line-added"> 572 {</span>
<span class="line-added"> 573     ASSERT(!structure-&gt;isUncacheableDictionary());</span>
<span class="line-added"> 574     ASSERT(structure-&gt;isObject());</span>
<span class="line-added"> 575     ASSERT(!Structure::removePropertyTransitionFromExistingStructure(vm, structure, propertyName, offset, deferred));</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577     int transitionCount = 0;</span>
<span class="line-added"> 578     for (auto* s = structure; s &amp;&amp; transitionCount &lt;= s_maxTransitionLength; s = s-&gt;previousID())</span>
<span class="line-added"> 579         ++transitionCount;</span>
<span class="line-added"> 580 </span>
<span class="line-added"> 581     if (transitionCount &gt; s_maxTransitionLength) {</span>
<span class="line-added"> 582         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));</span>
<span class="line-added"> 583         Structure* transition = toUncacheableDictionaryTransition(vm, structure, deferred);</span>
<span class="line-added"> 584         ASSERT(structure != transition);</span>
<span class="line-added"> 585         offset = transition-&gt;remove(vm, propertyName);</span>
<span class="line-added"> 586         return transition;</span>
<span class="line-added"> 587     }</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589     Structure* transition = create(vm, structure, deferred);</span>
<span class="line-added"> 590     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592     // While we are deleting the property, we need to make sure the table is not cleared.</span>
<span class="line-added"> 593     {</span>
<span class="line-added"> 594         ConcurrentJSLocker locker(transition-&gt;m_lock);</span>
<span class="line-added"> 595         transition-&gt;setProtectPropertyTableWhileTransitioning(true);</span>
<span class="line-added"> 596     }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);</span>
<span class="line-added"> 599     transition-&gt;m_transitionPropertyName = propertyName.uid();</span>
<span class="line-added"> 600     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));</span>
<span class="line-added"> 601     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
<span class="line-added"> 602     transition-&gt;setIsPropertyDeletionTransition(true);</span>
<span class="line-added"> 603 </span>
<span class="line-added"> 604     offset = transition-&gt;remove(vm, propertyName);</span>
<span class="line-added"> 605     ASSERT(offset != invalidOffset);</span>
<span class="line-added"> 606     transition-&gt;setTransitionOffset(vm, offset);</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the</span>
<span class="line-added"> 609     // table away if it wants. We can now rebuild it fine.</span>
<span class="line-added"> 610     WTF::storeStoreFence();</span>
<span class="line-added"> 611     transition-&gt;setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613     checkOffset(transition-&gt;transitionOffset(), transition-&gt;inlineCapacity());</span>
<span class="line-added"> 614     {</span>
<span class="line-added"> 615         GCSafeConcurrentJSLocker locker(structure-&gt;m_lock, vm.heap);</span>
<span class="line-added"> 616         structure-&gt;m_transitionTable.add(vm, transition);</span>
<span class="line-added"> 617     }</span>
 618     transition-&gt;checkOffsetConsistency();
<a name="40" id="anc40"></a><span class="line-added"> 619     structure-&gt;checkOffsetConsistency();</span>
 620     return transition;
 621 }
 622 
 623 Structure* Structure::changePrototypeTransition(VM&amp; vm, Structure* structure, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp; deferred)
 624 {
 625     ASSERT(isValidPrototype(prototype));
 626 
 627     DeferGC deferGC(vm.heap);
 628     Structure* transition = create(vm, structure, &amp;deferred);
 629 
 630     transition-&gt;m_prototype.set(vm, transition, prototype);
 631 
 632     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 633     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<a name="41" id="anc41"></a><span class="line-modified"> 634     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 635 
 636     transition-&gt;checkOffsetConsistency();
 637     return transition;
 638 }
 639 
 640 Structure* Structure::attributeChangeTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes)
 641 {
 642     if (!structure-&gt;isUncacheableDictionary()) {
 643         Structure* transition = create(vm, structure);
 644 
 645         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 646         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<a name="42" id="anc42"></a><span class="line-modified"> 647         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 648 
 649         structure = transition;
 650     }
 651 
 652     PropertyMapEntry* entry = structure-&gt;ensurePropertyTable(vm)-&gt;get(propertyName.uid());
 653     ASSERT(entry);
 654     entry-&gt;attributes = attributes;
 655 
 656     structure-&gt;checkOffsetConsistency();
 657     return structure;
 658 }
 659 
 660 Structure* Structure::toDictionaryTransition(VM&amp; vm, Structure* structure, DictionaryKind kind, DeferredStructureTransitionWatchpointFire* deferred)
 661 {
 662     ASSERT(!structure-&gt;isUncacheableDictionary());
 663     DeferGC deferGC(vm.heap);
 664 
 665     Structure* transition = create(vm, structure, deferred);
 666 
 667     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 668     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<a name="43" id="anc43"></a><span class="line-modified"> 669     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 670     transition-&gt;setDictionaryKind(kind);
 671     transition-&gt;setHasBeenDictionary(true);
 672 
 673     transition-&gt;checkOffsetConsistency();
 674     return transition;
 675 }
 676 
 677 Structure* Structure::toCacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)
 678 {
 679     return toDictionaryTransition(vm, structure, CachedDictionaryKind, deferred);
 680 }
 681 
<a name="44" id="anc44"></a><span class="line-modified"> 682 Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)</span>
 683 {
<a name="45" id="anc45"></a><span class="line-modified"> 684     return toDictionaryTransition(vm, structure, UncachedDictionaryKind, deferred);</span>
 685 }
 686 
 687 Structure* Structure::sealTransition(VM&amp; vm, Structure* structure)
 688 {
 689     return nonPropertyTransition(vm, structure, NonPropertyTransition::Seal);
 690 }
 691 
 692 Structure* Structure::freezeTransition(VM&amp; vm, Structure* structure)
 693 {
 694     return nonPropertyTransition(vm, structure, NonPropertyTransition::Freeze);
 695 }
 696 
 697 Structure* Structure::preventExtensionsTransition(VM&amp; vm, Structure* structure)
 698 {
 699     return nonPropertyTransition(vm, structure, NonPropertyTransition::PreventExtensions);
 700 }
 701 
 702 PropertyTable* Structure::takePropertyTableOrCloneIfPinned(VM&amp; vm)
 703 {
 704     // This must always return a property table. It can&#39;t return null.
 705     PropertyTable* result = propertyTableOrNull();
 706     if (result) {
 707         if (isPinnedPropertyTable())
 708             return result-&gt;copy(vm, result-&gt;size() + 1);
 709         ConcurrentJSLocker locker(m_lock);
 710         setPropertyTable(vm, nullptr);
 711         return result;
 712     }
 713     bool setPropertyTable = false;
 714     return materializePropertyTable(vm, setPropertyTable);
 715 }
 716 
 717 Structure* Structure::nonPropertyTransitionSlow(VM&amp; vm, Structure* structure, NonPropertyTransition transitionKind)
 718 {
 719     unsigned attributes = toAttributes(transitionKind);
 720     IndexingType indexingModeIncludingHistory = newIndexingType(structure-&gt;indexingModeIncludingHistory(), transitionKind);
 721 
 722     Structure* existingTransition;
<a name="46" id="anc46"></a><span class="line-modified"> 723     constexpr bool isAddition = true;</span>
<span class="line-modified"> 724     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes, isAddition))) {</span>
<span class="line-added"> 725         ASSERT(existingTransition-&gt;transitionPropertyAttributes() == attributes);</span>
 726         ASSERT(existingTransition-&gt;indexingModeIncludingHistory() == indexingModeIncludingHistory);
 727         return existingTransition;
 728     }
 729 
 730     DeferGC deferGC(vm.heap);
 731 
 732     Structure* transition = create(vm, structure);
<a name="47" id="anc47"></a><span class="line-modified"> 733     transition-&gt;setTransitionPropertyAttributes(attributes);</span>
 734     transition-&gt;m_blob.setIndexingModeIncludingHistory(indexingModeIncludingHistory);
 735 
 736     if (preventsExtensions(transitionKind))
 737         transition-&gt;setDidPreventExtensions(true);
 738 
 739     if (setsDontDeleteOnAllProperties(transitionKind)
 740         || setsReadOnlyOnNonAccessorProperties(transitionKind)) {
 741         // We pin the property table on transitions that do wholesale editing of the property
 742         // table, since our logic for walking the property transition chain to rematerialize the
 743         // table doesn&#39;t know how to take into account such wholesale edits.
 744 
 745         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 746         transition-&gt;pinForCaching(holdLock(transition-&gt;m_lock), vm, table);
<a name="48" id="anc48"></a><span class="line-modified"> 747         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 748 
 749         table = transition-&gt;propertyTableOrNull();
 750         RELEASE_ASSERT(table);
 751         for (auto&amp; entry : *table) {
 752             if (setsDontDeleteOnAllProperties(transitionKind))
 753                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete);
 754             if (setsReadOnlyOnNonAccessorProperties(transitionKind) &amp;&amp; !(entry.attributes &amp; PropertyAttribute::Accessor))
 755                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly);
 756         }
 757     } else {
 758         transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<a name="49" id="anc49"></a><span class="line-modified"> 759         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
<span class="line-modified"> 760         checkOffset(transition-&gt;maxOffset(), transition-&gt;inlineCapacity());</span>
 761     }
 762 
 763     if (setsReadOnlyOnNonAccessorProperties(transitionKind)
 764         &amp;&amp; !transition-&gt;propertyTableOrNull()-&gt;isEmpty())
 765         transition-&gt;setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
 766 
 767     if (structure-&gt;isDictionary()) {
 768         PropertyTable* table = transition-&gt;ensurePropertyTable(vm);
 769         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 770     } else {
 771         auto locker = holdLock(structure-&gt;m_lock);
 772         structure-&gt;m_transitionTable.add(vm, transition);
 773     }
 774 
 775     transition-&gt;checkOffsetConsistency();
 776     return transition;
 777 }
 778 
 779 // In future we may want to cache this property.
 780 bool Structure::isSealed(VM&amp; vm)
 781 {
 782     if (isStructureExtensible())
 783         return false;
 784 
 785     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 786     if (!table)
 787         return true;
 788 
 789     PropertyTable::iterator end = table-&gt;end();
 790     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 791         if ((iter-&gt;attributes &amp; PropertyAttribute::DontDelete) != static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete))
 792             return false;
 793     }
 794     return true;
 795 }
 796 
 797 // In future we may want to cache this property.
 798 bool Structure::isFrozen(VM&amp; vm)
 799 {
 800     if (isStructureExtensible())
 801         return false;
 802 
 803     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 804     if (!table)
 805         return true;
 806 
 807     PropertyTable::iterator end = table-&gt;end();
 808     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 809         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontDelete))
 810             return false;
 811         if (!(iter-&gt;attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor)))
 812             return false;
 813     }
 814     return true;
 815 }
 816 
 817 Structure* Structure::flattenDictionaryStructure(VM&amp; vm, JSObject* object)
 818 {
 819     checkOffsetConsistency();
 820     ASSERT(isDictionary());
<a name="50" id="anc50"></a><span class="line-added"> 821     ASSERT(object-&gt;structure(vm) == this);</span>
 822 
 823     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 824 
 825     object-&gt;setStructureIDDirectly(nuke(id()));
 826     WTF::storeStoreFence();
 827 
 828     size_t beforeOutOfLineCapacity = this-&gt;outOfLineCapacity();
 829     if (isUncacheableDictionary()) {
 830         PropertyTable* table = propertyTableOrNull();
 831         ASSERT(table);
 832 
 833         size_t propertyCount = table-&gt;size();
 834 
 835         // Holds our values compacted by insertion order.
 836         Vector&lt;JSValue&gt; values(propertyCount);
 837 
 838         // Copies out our values from their hashed locations, compacting property table offsets as we go.
 839         unsigned i = 0;
 840         PropertyTable::iterator end = table-&gt;end();
<a name="51" id="anc51"></a><span class="line-modified"> 841         auto offset = invalidOffset;</span>
 842         for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter, ++i) {
 843             values[i] = object-&gt;getDirect(iter-&gt;offset);
<a name="52" id="anc52"></a><span class="line-modified"> 844             offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);</span>
 845         }
<a name="53" id="anc53"></a><span class="line-added"> 846         setMaxOffset(vm, offset);</span>
<span class="line-added"> 847         ASSERT(transitionOffset() == invalidOffset);</span>
 848 
 849         // Copies in our values to their compacted locations.
 850         for (unsigned i = 0; i &lt; propertyCount; i++)
 851             object-&gt;putDirect(vm, offsetForPropertyNumber(i, m_inlineCapacity), values[i]);
 852 
 853         table-&gt;clearDeletedOffsets();
 854 
 855         // We need to zero our unused property space; otherwise the GC might see a
 856         // stale pointer when we add properties in the future.
<a name="54" id="anc54"></a><span class="line-modified"> 857         gcSafeZeroMemory(</span>
 858             object-&gt;inlineStorageUnsafe() + inlineSize(),
<a name="55" id="anc55"></a>
 859             (inlineCapacity() - inlineSize()) * sizeof(EncodedJSValue));
 860 
 861         Butterfly* butterfly = object-&gt;butterfly();
 862         size_t preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(this);
 863         void* base = butterfly-&gt;base(preCapacity, beforeOutOfLineCapacity);
 864         void* startOfPropertyStorageSlots = reinterpret_cast&lt;EncodedJSValue*&gt;(base) + preCapacity;
<a name="56" id="anc56"></a><span class="line-modified"> 865         gcSafeZeroMemory(static_cast&lt;JSValue*&gt;(startOfPropertyStorageSlots), (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));</span>
 866         checkOffsetConsistency();
 867     }
 868 
 869     setDictionaryKind(NoneDictionaryKind);
 870     setHasBeenFlattenedBefore(true);
 871 
 872     size_t afterOutOfLineCapacity = this-&gt;outOfLineCapacity();
 873 
 874     if (object-&gt;butterfly() &amp;&amp; beforeOutOfLineCapacity != afterOutOfLineCapacity) {
 875         ASSERT(beforeOutOfLineCapacity &gt; afterOutOfLineCapacity);
 876         // If the object had a Butterfly but after flattening/compacting we no longer have need of it,
 877         // we need to zero it out because the collector depends on the Structure to know the size for copying.
 878         if (!afterOutOfLineCapacity &amp;&amp; !this-&gt;hasIndexingHeader(object))
 879             object-&gt;setButterfly(vm, nullptr);
 880         // If the object was down-sized to the point where the base of the Butterfly is no longer within the
 881         // first CopiedBlock::blockSize bytes, we&#39;ll get the wrong answer if we try to mask the base back to
 882         // the CopiedBlock header. To prevent this case we need to memmove the Butterfly down.
 883         else
 884             object-&gt;shiftButterflyAfterFlattening(locker, vm, this, afterOutOfLineCapacity);
 885     }
 886 
 887     WTF::storeStoreFence();
 888     object-&gt;setStructureIDDirectly(id());
 889 
 890     // We need to do a writebarrier here because the GC thread might be scanning the butterfly while
 891     // we are shuffling properties around. See: https://bugs.webkit.org/show_bug.cgi?id=166989
 892     vm.heap.writeBarrier(object);
 893 
 894     return this;
 895 }
 896 
 897 void Structure::pin(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 898 {
 899     setIsPinnedPropertyTable(true);
 900     setPropertyTable(vm, table);
 901     clearPreviousID();
<a name="57" id="anc57"></a><span class="line-modified"> 902     m_transitionPropertyName = nullptr;</span>
 903 }
 904 
 905 void Structure::pinForCaching(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 906 {
 907     setIsPinnedPropertyTable(true);
 908     setPropertyTable(vm, table);
<a name="58" id="anc58"></a><span class="line-modified"> 909     m_transitionPropertyName = nullptr;</span>
 910 }
 911 
 912 void Structure::allocateRareData(VM&amp; vm)
 913 {
 914     ASSERT(!hasRareData());
 915     StructureRareData* rareData = StructureRareData::create(vm, previousID());
 916     WTF::storeStoreFence();
 917     m_previousOrRareData.set(vm, this, rareData);
 918     ASSERT(hasRareData());
 919 }
 920 
 921 WatchpointSet* Structure::ensurePropertyReplacementWatchpointSet(VM&amp; vm, PropertyOffset offset)
 922 {
 923     ASSERT(!isUncacheableDictionary());
 924 
 925     // In some places it&#39;s convenient to call this with an invalid offset. So, we do the check here.
 926     if (!isValidOffset(offset))
 927         return nullptr;
 928 
 929     if (!hasRareData())
 930         allocateRareData(vm);
 931     ConcurrentJSLocker locker(m_lock);
 932     StructureRareData* rareData = this-&gt;rareData();
 933     if (!rareData-&gt;m_replacementWatchpointSets) {
 934         rareData-&gt;m_replacementWatchpointSets =
 935             makeUnique&lt;StructureRareData::PropertyWatchpointMap&gt;();
 936         WTF::storeStoreFence();
 937     }
 938     auto result = rareData-&gt;m_replacementWatchpointSets-&gt;add(offset, nullptr);
 939     if (result.isNewEntry)
 940         result.iterator-&gt;value = adoptRef(new WatchpointSet(IsWatched));
 941     return result.iterator-&gt;value.get();
 942 }
 943 
 944 void Structure::startWatchingPropertyForReplacements(VM&amp; vm, PropertyName propertyName)
 945 {
 946     ASSERT(!isUncacheableDictionary());
 947 
 948     startWatchingPropertyForReplacements(vm, get(vm, propertyName));
 949 }
 950 
 951 void Structure::didCachePropertyReplacement(VM&amp; vm, PropertyOffset offset)
 952 {
 953     RELEASE_ASSERT(isValidOffset(offset));
 954     ensurePropertyReplacementWatchpointSet(vm, offset)-&gt;fireAll(vm, &quot;Did cache property replacement&quot;);
 955 }
 956 
 957 void Structure::startWatchingInternalProperties(VM&amp; vm)
 958 {
 959     if (!isUncacheableDictionary()) {
 960         startWatchingPropertyForReplacements(vm, vm.propertyNames-&gt;toString);
 961         startWatchingPropertyForReplacements(vm, vm.propertyNames-&gt;valueOf);
 962     }
 963     setDidWatchInternalProperties(true);
 964 }
 965 
 966 #if DUMP_PROPERTYMAP_STATS
 967 
 968 PropertyMapHashTableStats* propertyMapHashTableStats = 0;
 969 
 970 struct PropertyMapStatisticsExitLogger {
 971     PropertyMapStatisticsExitLogger();
 972     ~PropertyMapStatisticsExitLogger();
 973 };
 974 
 975 DEFINE_GLOBAL_FOR_LOGGING(PropertyMapStatisticsExitLogger, logger, );
 976 
 977 PropertyMapStatisticsExitLogger::PropertyMapStatisticsExitLogger()
 978 {
 979     propertyMapHashTableStats = adoptPtr(new PropertyMapHashTableStats()).leakPtr();
 980 }
 981 
 982 PropertyMapStatisticsExitLogger::~PropertyMapStatisticsExitLogger()
 983 {
 984     unsigned finds = propertyMapHashTableStats-&gt;numFinds;
 985     unsigned collisions = propertyMapHashTableStats-&gt;numCollisions;
 986     dataLogF(&quot;\nJSC::PropertyMap statistics for process %d\n\n&quot;, getCurrentProcessID());
 987     dataLogF(&quot;%d finds\n&quot;, finds);
 988     dataLogF(&quot;%d collisions (%.1f%%)\n&quot;, collisions, 100.0 * collisions / finds);
 989     dataLogF(&quot;%d lookups\n&quot;, propertyMapHashTableStats-&gt;numLookups.load());
 990     dataLogF(&quot;%d lookup probings\n&quot;, propertyMapHashTableStats-&gt;numLookupProbing.load());
 991     dataLogF(&quot;%d adds\n&quot;, propertyMapHashTableStats-&gt;numAdds.load());
 992     dataLogF(&quot;%d removes\n&quot;, propertyMapHashTableStats-&gt;numRemoves.load());
 993     dataLogF(&quot;%d rehashes\n&quot;, propertyMapHashTableStats-&gt;numRehashes.load());
 994     dataLogF(&quot;%d reinserts\n&quot;, propertyMapHashTableStats-&gt;numReinserts.load());
 995 }
 996 
 997 #endif
 998 
 999 PropertyTable* Structure::copyPropertyTableForPinning(VM&amp; vm)
1000 {
1001     if (PropertyTable* table = propertyTableOrNull())
1002         return PropertyTable::clone(vm, *table);
1003     bool setPropertyTable = false;
1004     return materializePropertyTable(vm, setPropertyTable);
1005 }
1006 
1007 PropertyOffset Structure::getConcurrently(UniquedStringImpl* uid, unsigned&amp; attributes)
1008 {
1009     PropertyOffset result = invalidOffset;
1010 
1011     forEachPropertyConcurrently(
1012         [&amp;] (const PropertyMapEntry&amp; candidate) -&gt; bool {
1013             if (candidate.key != uid)
1014                 return true;
1015 
1016             result = candidate.offset;
1017             attributes = candidate.attributes;
1018             return false;
1019         });
1020 
1021     return result;
1022 }
1023 
1024 Vector&lt;PropertyMapEntry&gt; Structure::getPropertiesConcurrently()
1025 {
1026     Vector&lt;PropertyMapEntry&gt; result;
1027 
1028     forEachPropertyConcurrently(
1029         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1030             result.append(entry);
1031             return true;
1032         });
1033 
1034     return result;
1035 }
1036 
1037 PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes)
1038 {
1039     return add&lt;ShouldPin::No&gt;(
1040         vm, propertyName, attributes,
<a name="59" id="anc59"></a><span class="line-modified">1041         [this, &amp;vm] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified">1042             setMaxOffset(vm, newMaxOffset);</span>
1043         });
1044 }
1045 
<a name="60" id="anc60"></a><span class="line-modified">1046 PropertyOffset Structure::remove(VM&amp; vm, PropertyName propertyName)</span>
1047 {
<a name="61" id="anc61"></a><span class="line-modified">1048     return remove&lt;ShouldPin::No&gt;(vm, propertyName, [this, &amp;vm] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newMaxOffset) {</span>
<span class="line-added">1049         setMaxOffset(vm, newMaxOffset);</span>
<span class="line-added">1050     });</span>
1051 }
1052 
1053 void Structure::getPropertyNamesFromStructure(VM&amp; vm, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
1054 {
1055     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
1056     if (!table)
1057         return;
1058 
1059     bool knownUnique = propertyNames.canAddKnownUniqueForStructure();
1060 
1061     PropertyTable::iterator end = table-&gt;end();
1062     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
1063         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !(iter-&gt;attributes &amp; PropertyAttribute::DontEnum));
1064         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !iter-&gt;key-&gt;isSymbol());
1065         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties()) {
1066             if (iter-&gt;key-&gt;isSymbol() &amp;&amp; !propertyNames.includeSymbolProperties())
1067                 continue;
1068             if (knownUnique)
1069                 propertyNames.addUnchecked(iter-&gt;key);
1070             else
1071                 propertyNames.add(iter-&gt;key);
1072         }
1073     }
1074 }
1075 
1076 void StructureFireDetail::dump(PrintStream&amp; out) const
1077 {
1078     out.print(&quot;Structure transition from &quot;, *m_structure);
1079 }
1080 
1081 DeferredStructureTransitionWatchpointFire::DeferredStructureTransitionWatchpointFire(VM&amp; vm, Structure* structure)
1082     : DeferredWatchpointFire(vm)
1083     , m_structure(structure)
1084 {
1085 }
1086 
1087 DeferredStructureTransitionWatchpointFire::~DeferredStructureTransitionWatchpointFire()
1088 {
1089     fireAll();
1090 }
1091 
1092 void DeferredStructureTransitionWatchpointFire::dump(PrintStream&amp; out) const
1093 {
1094     out.print(&quot;Structure transition from &quot;, *m_structure);
1095 }
1096 
1097 void Structure::didTransitionFromThisStructure(DeferredStructureTransitionWatchpointFire* deferred) const
1098 {
1099     // If the structure is being watched, and this is the kind of structure that the DFG would
1100     // like to watch, then make sure to note for all future versions of this structure that it&#39;s
1101     // unwise to watch it.
1102     if (m_transitionWatchpointSet.isBeingWatched())
1103         const_cast&lt;Structure*&gt;(this)-&gt;setTransitionWatchpointIsLikelyToBeFired(true);
1104 
1105     if (deferred) {
1106         ASSERT(deferred-&gt;structure() == this);
1107         m_transitionWatchpointSet.fireAll(vm(), deferred);
1108     } else
1109         m_transitionWatchpointSet.fireAll(vm(), StructureFireDetail(this));
1110 }
1111 
1112 void Structure::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1113 {
1114     Structure* thisObject = jsCast&lt;Structure*&gt;(cell);
1115     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1116 
1117     Base::visitChildren(thisObject, visitor);
1118 
1119     ConcurrentJSLocker locker(thisObject-&gt;m_lock);
1120 
1121     visitor.append(thisObject-&gt;m_globalObject);
1122     if (!thisObject-&gt;isObject())
1123         thisObject-&gt;m_cachedPrototypeChain.clear();
1124     else {
1125         visitor.append(thisObject-&gt;m_prototype);
1126         visitor.append(thisObject-&gt;m_cachedPrototypeChain);
1127     }
1128     visitor.append(thisObject-&gt;m_previousOrRareData);
1129 
<a name="62" id="anc62"></a><span class="line-modified">1130     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;protectPropertyTableWhileTransitioning()) {</span>
1131         // NOTE: This can interleave in pin(), in which case it may see a null property table.
1132         // That&#39;s fine, because then the barrier will fire and we will scan this again.
1133         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1134     } else if (visitor.isAnalyzingHeap())
1135         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1136     else if (thisObject-&gt;m_propertyTableUnsafe)
1137         thisObject-&gt;m_propertyTableUnsafe.clear();
1138 }
1139 
1140 bool Structure::isCheapDuringGC(VM&amp; vm)
1141 {
1142     // FIXME: We could make this even safer by returning false if this structure&#39;s property table
1143     // has any large property names.
1144     // https://bugs.webkit.org/show_bug.cgi?id=157334
1145 
1146     return (!m_globalObject || vm.heap.isMarked(m_globalObject.get()))
1147         &amp;&amp; (hasPolyProto() || !storedPrototypeObject() || vm.heap.isMarked(storedPrototypeObject()));
1148 }
1149 
1150 bool Structure::markIfCheap(SlotVisitor&amp; visitor)
1151 {
1152     VM&amp; vm = visitor.vm();
1153     if (!isCheapDuringGC(vm))
1154         return vm.heap.isMarked(this);
1155 
1156     visitor.appendUnbarriered(this);
1157     return true;
1158 }
1159 
1160 Ref&lt;StructureShape&gt; Structure::toStructureShape(JSValue value, bool&amp; sawPolyProtoStructure)
1161 {
1162     Ref&lt;StructureShape&gt; baseShape = StructureShape::create();
1163     RefPtr&lt;StructureShape&gt; curShape = baseShape.ptr();
1164     Structure* curStructure = this;
1165     JSValue curValue = value;
1166     sawPolyProtoStructure = false;
1167     while (curStructure) {
1168         sawPolyProtoStructure |= curStructure-&gt;hasPolyProto();
1169         curStructure-&gt;forEachPropertyConcurrently(
1170             [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1171                 if (!PropertyName(entry.key).isPrivateName())
1172                     curShape-&gt;addProperty(*entry.key);
1173                 return true;
1174             });
1175 
1176         if (JSObject* curObject = curValue.getObject())
1177             curShape-&gt;setConstructorName(JSObject::calculatedClassName(curObject));
1178         else
1179             curShape-&gt;setConstructorName(curStructure-&gt;classInfo()-&gt;className);
1180 
1181         if (curStructure-&gt;isDictionary())
1182             curShape-&gt;enterDictionaryMode();
1183 
1184         curShape-&gt;markAsFinal();
1185 
1186         if (!curValue.isObject())
1187             break;
1188 
1189         JSObject* object = asObject(curValue);
1190         JSObject* prototypeObject = object-&gt;structure()-&gt;storedPrototypeObject(object);
1191         if (!prototypeObject)
1192             break;
1193 
1194         auto newShape = StructureShape::create();
1195         curShape-&gt;setProto(newShape.copyRef());
1196         curShape = WTFMove(newShape);
1197         curValue = prototypeObject;
1198         curStructure = prototypeObject-&gt;structure();
1199     }
1200 
1201     return baseShape;
1202 }
1203 
1204 void Structure::dump(PrintStream&amp; out) const
1205 {
1206     out.print(RawPointer(this), &quot;:[&quot;, classInfo()-&gt;className, &quot;, {&quot;);
1207 
1208     CommaPrinter comma;
1209 
1210     const_cast&lt;Structure*&gt;(this)-&gt;forEachPropertyConcurrently(
1211         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1212             out.print(comma, entry.key, &quot;:&quot;, static_cast&lt;int&gt;(entry.offset));
1213             return true;
1214         });
1215 
1216     out.print(&quot;}, &quot;, IndexingTypeDump(indexingMode()));
1217 
1218     if (hasPolyProto())
1219         out.print(&quot;, PolyProto offset:&quot;, knownPolyProtoOffset);
1220     else if (m_prototype.get().isCell())
1221         out.print(&quot;, Proto:&quot;, RawPointer(m_prototype.get().asCell()));
1222 
1223     switch (dictionaryKind()) {
1224     case NoneDictionaryKind:
1225         if (hasBeenDictionary())
1226             out.print(&quot;, Has been dictionary&quot;);
1227         break;
1228     case CachedDictionaryKind:
1229         out.print(&quot;, Dictionary&quot;);
1230         break;
1231     case UncachedDictionaryKind:
1232         out.print(&quot;, UncacheableDictionary&quot;);
1233         break;
1234     }
1235 
1236     if (transitionWatchpointSetIsStillValid())
1237         out.print(&quot;, Leaf&quot;);
1238     else if (transitionWatchpointIsLikelyToBeFired())
1239         out.print(&quot;, Shady leaf&quot;);
1240 
1241     out.print(&quot;]&quot;);
1242 }
1243 
1244 void Structure::dumpInContext(PrintStream&amp; out, DumpContext* context) const
1245 {
1246     if (context)
1247         context-&gt;structures.dumpBrief(this, out);
1248     else
1249         dump(out);
1250 }
1251 
1252 void Structure::dumpBrief(PrintStream&amp; out, const CString&amp; string) const
1253 {
1254     out.print(&quot;%&quot;, string, &quot;:&quot;, classInfo()-&gt;className);
1255 }
1256 
1257 void Structure::dumpContextHeader(PrintStream&amp; out)
1258 {
1259     out.print(&quot;Structures:&quot;);
1260 }
1261 
1262 bool ClassInfo::hasStaticSetterOrReadonlyProperties() const
1263 {
1264     for (const ClassInfo* ci = this; ci; ci = ci-&gt;parentClass) {
1265         if (const HashTable* table = ci-&gt;staticPropHashTable) {
1266             if (table-&gt;hasSetterOrReadonlyProperties)
1267                 return true;
1268         }
1269     }
1270     return false;
1271 }
1272 
1273 void Structure::setCachedPropertyNameEnumerator(VM&amp; vm, JSPropertyNameEnumerator* enumerator)
1274 {
1275     ASSERT(!isDictionary());
1276     if (!hasRareData())
1277         allocateRareData(vm);
1278     rareData()-&gt;setCachedPropertyNameEnumerator(vm, enumerator);
1279 }
1280 
1281 JSPropertyNameEnumerator* Structure::cachedPropertyNameEnumerator() const
1282 {
1283     if (!hasRareData())
1284         return nullptr;
1285     return rareData()-&gt;cachedPropertyNameEnumerator();
1286 }
1287 
<a name="63" id="anc63"></a><span class="line-modified">1288 bool Structure::canCachePropertyNameEnumerator(VM&amp; vm) const</span>
1289 {
1290     if (!this-&gt;canCacheOwnKeys())
1291         return false;
1292 
1293     StructureChain* structureChain = m_cachedPrototypeChain.get();
1294     ASSERT(structureChain);
<a name="64" id="anc64"></a><span class="line-modified">1295     StructureID* currentStructureID = structureChain-&gt;head();</span>
1296     while (true) {
<a name="65" id="anc65"></a><span class="line-modified">1297         StructureID structureID = *currentStructureID;</span>
<span class="line-added">1298         if (!structureID)</span>
1299             return true;
<a name="66" id="anc66"></a><span class="line-modified">1300         Structure* structure = vm.getStructure(structureID);</span>
<span class="line-added">1301         if (!structure-&gt;canCacheOwnKeys())</span>
1302             return false;
<a name="67" id="anc67"></a><span class="line-modified">1303         currentStructureID++;</span>
1304     }
1305 
1306     ASSERT_NOT_REACHED();
1307     return true;
1308 }
1309 
1310 bool Structure::canAccessPropertiesQuicklyForEnumeration() const
1311 {
1312     if (!isQuickPropertyAccessAllowedForEnumeration())
1313         return false;
1314     if (hasGetterSetterProperties())
1315         return false;
1316     if (isUncacheableDictionary())
1317         return false;
1318     return true;
1319 }
1320 
<a name="68" id="anc68"></a><span class="line-added">1321 auto Structure::findPropertyHashEntry(PropertyName propertyName) const -&gt; Optional&lt;PropertyHashEntry&gt;</span>
<span class="line-added">1322 {</span>
<span class="line-added">1323     for (const ClassInfo* info = classInfo(); info; info = info-&gt;parentClass) {</span>
<span class="line-added">1324         if (const HashTable* propHashTable = info-&gt;staticPropHashTable) {</span>
<span class="line-added">1325             if (const HashTableValue* entry = propHashTable-&gt;entry(propertyName))</span>
<span class="line-added">1326                 return PropertyHashEntry { propHashTable, entry };</span>
<span class="line-added">1327         }</span>
<span class="line-added">1328     }</span>
<span class="line-added">1329     return WTF::nullopt;</span>
<span class="line-added">1330 }</span>
<span class="line-added">1331 </span>
1332 } // namespace JSC
<a name="69" id="anc69"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="69" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2003, 2006, 2009, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #ifndef Path_h
 29 #define Path_h
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;WindRule.h&quot;
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/Function.h&gt;
 35 #include &lt;wtf/Forward.h&gt;
 36 
 37 #if USE(CG)
 38 
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #include &lt;CoreGraphics/CGPath.h&gt;
 41 typedef struct CGPath PlatformPath;
 42 
 43 #elif USE(DIRECT2D)
 44 #include &quot;COMPtr.h&quot;
 45 
 46 interface ID2D1Geometry;
 47 interface ID2D1GeometryGroup;
 48 interface ID2D1PathGeometry;
 49 interface ID2D1GeometrySink;
 50 
 51 typedef ID2D1GeometryGroup PlatformPath;
 52 
<a name="1" id="anc1"></a><span class="line-added"> 53 namespace WebCore {</span>
<span class="line-added"> 54 class PlatformContextDirect2D;</span>
<span class="line-added"> 55 }</span>
<span class="line-added"> 56 </span>
 57 #elif USE(CAIRO)
 58 
 59 namespace WebCore {
 60 class CairoPath;
 61 }
 62 typedef WebCore::CairoPath PlatformPath;
 63 
 64 #elif USE(WINGDI)
 65 
 66 namespace WebCore {
 67 class PlatformPath;
 68 }
 69 typedef WebCore::PlatformPath PlatformPath;
 70 
 71 #elif PLATFORM(JAVA)
 72 #include &lt;wtf/RefPtr.h&gt;
 73 #include &quot;RQRef.h&quot;
 74 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPath;
 75 
 76 #else
 77 
 78 typedef void PlatformPath;
 79 
 80 #endif
 81 
 82 #if PLATFORM(JAVA)
 83 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPathPtr;
 84 #else
 85 typedef PlatformPath* PlatformPathPtr;
 86 #endif
 87 
 88 namespace WTF {
 89 class TextStream;
 90 }
 91 
 92 namespace WebCore {
 93 
<a name="2" id="anc2"></a><span class="line-modified"> 94 class AffineTransform;</span>
<span class="line-modified"> 95 class FloatPoint;</span>
<span class="line-modified"> 96 class FloatRoundedRect;</span>
<span class="line-modified"> 97 class FloatSize;</span>
<span class="line-modified"> 98 class GraphicsContext;</span>
<span class="line-modified"> 99 class PathTraversalState;</span>
<span class="line-modified">100 class RoundedRect;</span>
<span class="line-modified">101 class StrokeStyleApplier;</span>
<span class="line-modified">102 </span>
<span class="line-modified">103 // The points in the structure are the same as those that would be used with the</span>
<span class="line-modified">104 // add... method. For example, a line returns the endpoint, while a cubic returns</span>
<span class="line-modified">105 // two tangent points and the endpoint.</span>
<span class="line-modified">106 struct PathElement {</span>
<span class="line-modified">107     enum class Type : uint8_t {</span>
<span class="line-modified">108         MoveToPoint, // The points member will contain 1 value.</span>
<span class="line-added">109         AddLineToPoint, // The points member will contain 1 value.</span>
<span class="line-added">110         AddQuadCurveToPoint, // The points member will contain 2 values.</span>
<span class="line-added">111         AddCurveToPoint, // The points member will contain 3 values.</span>
<span class="line-added">112         CloseSubpath // The points member will contain no values.</span>
113     };
114 
<a name="3" id="anc3"></a><span class="line-modified">115     FloatPoint points[3];</span>
<span class="line-modified">116     Type type;</span>
<span class="line-modified">117 };</span>




118 
<a name="4" id="anc4"></a><span class="line-modified">119 using PathApplierFunction = WTF::Function&lt;void(const PathElement&amp;)&gt;;</span>
120 
<a name="5" id="anc5"></a><span class="line-modified">121 class Path {</span>
<span class="line-modified">122     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-modified">123 public:</span>
<span class="line-modified">124     WEBCORE_EXPORT Path();</span>
125 #if USE(CG)
<a name="6" id="anc6"></a><span class="line-modified">126     Path(RetainPtr&lt;CGMutablePathRef&gt;);</span>
127 #endif
<a name="7" id="anc7"></a><span class="line-modified">128     WEBCORE_EXPORT ~Path();</span>
<span class="line-modified">129 </span>
<span class="line-modified">130     WEBCORE_EXPORT Path(const Path&amp;);</span>
<span class="line-modified">131     WEBCORE_EXPORT Path(Path&amp;&amp;);</span>
<span class="line-modified">132     WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);</span>
<span class="line-modified">133     WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);</span>
<span class="line-modified">134 </span>
<span class="line-modified">135     static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);</span>
<span class="line-modified">136 </span>
<span class="line-modified">137     bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;</span>
<span class="line-modified">138     bool strokeContains(StrokeStyleApplier&amp;, const FloatPoint&amp;) const;</span>
<span class="line-modified">139     // fastBoundingRect() should equal or contain boundingRect(); boundingRect()</span>
<span class="line-modified">140     // should perfectly bound the points within the path.</span>
<span class="line-modified">141     FloatRect boundingRect() const;</span>
<span class="line-modified">142     WEBCORE_EXPORT FloatRect fastBoundingRect() const;</span>
<span class="line-modified">143     FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;</span>
<span class="line-modified">144 </span>
<span class="line-modified">145     float length() const;</span>
<span class="line-modified">146     PathTraversalState traversalStateAtLength(float length) const;</span>
<span class="line-modified">147     FloatPoint pointAtLength(float length) const;</span>
<span class="line-modified">148 </span>
<span class="line-modified">149     WEBCORE_EXPORT void clear();</span>
<span class="line-modified">150     bool isNull() const { return !m_path; }</span>
<span class="line-modified">151     bool isEmpty() const;</span>
<span class="line-modified">152     // Gets the current point of the current path, which is conceptually the final point reached by the path so far.</span>
<span class="line-modified">153     // Note the Path can be empty (isEmpty() == true) and still have a current point.</span>
<span class="line-modified">154     bool hasCurrentPoint() const;</span>
<span class="line-modified">155     FloatPoint currentPoint() const;</span>
<span class="line-modified">156 </span>
<span class="line-modified">157     WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);</span>
<span class="line-modified">158     WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);</span>
<span class="line-modified">159     WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">160     WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);</span>
<span class="line-modified">161     void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);</span>
<span class="line-modified">162     WEBCORE_EXPORT void closeSubpath();</span>
<span class="line-modified">163 </span>
<span class="line-modified">164     void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">165     void addRect(const FloatRect&amp;);</span>
<span class="line-modified">166     void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);</span>
<span class="line-modified">167     void addEllipse(const FloatRect&amp;);</span>
<span class="line-modified">168 </span>
<span class="line-modified">169     enum class RoundedRectStrategy : uint8_t {</span>
<span class="line-modified">170         PreferNative,</span>
<span class="line-modified">171         PreferBezier</span>
<span class="line-modified">172     };</span>
<span class="line-modified">173 </span>
<span class="line-modified">174     WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = RoundedRectStrategy::PreferNative);</span>
<span class="line-modified">175     WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = RoundedRectStrategy::PreferNative);</span>
<span class="line-modified">176     void addRoundedRect(const RoundedRect&amp;);</span>
<span class="line-modified">177 </span>
<span class="line-modified">178     void addPath(const Path&amp;, const AffineTransform&amp;);</span>
<span class="line-modified">179 </span>
<span class="line-modified">180     void translate(const FloatSize&amp;);</span>
<span class="line-modified">181 </span>
<span class="line-modified">182     // To keep Path() cheap, it does not allocate a PlatformPath immediately</span>
<span class="line-modified">183     // meaning Path::platformPath() can return null.</span>

184 #if USE(DIRECT2D)
<a name="8" id="anc8"></a><span class="line-modified">185     FloatRect fastBoundingRectForStroke(const PlatformContextDirect2D&amp;) const;</span>
<span class="line-added">186     PlatformPathPtr platformPath() const { return m_path.get(); }</span>
187 #else
<a name="9" id="anc9"></a><span class="line-modified">188     PlatformPathPtr platformPath() const { return m_path; }</span>
189 #endif
<a name="10" id="anc10"></a><span class="line-modified">190     // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.</span>
<span class="line-modified">191     WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();</span>
192 
<a name="11" id="anc11"></a><span class="line-modified">193     WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;</span>
<span class="line-modified">194     void transform(const AffineTransform&amp;);</span>
195 
<a name="12" id="anc12"></a><span class="line-modified">196     static float circleControlPoint()</span>
<span class="line-modified">197     {</span>
<span class="line-modified">198         // Approximation of control point positions on a bezier to simulate a quarter of a circle.</span>
<span class="line-modified">199         // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3</span>
<span class="line-modified">200         return 0.447715;</span>
<span class="line-modified">201     }</span>
202 
<a name="13" id="anc13"></a><span class="line-modified">203     void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
204 
205 #if USE(CG) || USE(DIRECT2D)
<a name="14" id="anc14"></a><span class="line-modified">206     void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);</span>
207 #endif
208 
209 #if USE(DIRECT2D)
<a name="15" id="anc15"></a><span class="line-modified">210     void appendGeometry(ID2D1Geometry*);</span>
<span class="line-modified">211     void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;</span>
<span class="line-modified">212 </span>
<span class="line-modified">213     void openFigureAtCurrentPointIfNecessary();</span>
<span class="line-modified">214     void closeAnyOpenGeometries(unsigned figureEndStyle) const;</span>
<span class="line-modified">215     void clearGeometries();</span>


216 #endif
217 
218 #ifndef NDEBUG
<a name="16" id="anc16"></a><span class="line-modified">219     void dump() const;</span>
220 #endif
221 
<a name="17" id="anc17"></a><span class="line-modified">222     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added">223     template&lt;class Decoder&gt; static Optional&lt;Path&gt; decode(Decoder&amp;);</span>
<span class="line-added">224 </span>
<span class="line-added">225 private:</span>
226 #if USE(DIRECT2D)
<a name="18" id="anc18"></a><span class="line-modified">227     Vector&lt;ID2D1Geometry*&gt; m_geometries;</span>
<span class="line-modified">228     COMPtr&lt;ID2D1GeometryGroup&gt; m_path;</span>
<span class="line-modified">229     mutable COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;</span>
<span class="line-modified">230     mutable bool m_figureIsOpened { false };</span>
231 #else
<a name="19" id="anc19"></a><span class="line-modified">232     PlatformPathPtr m_path { nullptr };</span>
233 #endif
<a name="20" id="anc20"></a><span class="line-modified">234 };</span>
235 
236 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
237 
<a name="21" id="anc21"></a><span class="line-added">238 template&lt;class Encoder&gt; void Path::encode(Encoder&amp; encoder) const</span>
<span class="line-added">239 {</span>
<span class="line-added">240     uint64_t numPoints = 0;</span>
<span class="line-added">241     apply([&amp;numPoints](const PathElement&amp;) {</span>
<span class="line-added">242         ++numPoints;</span>
<span class="line-added">243     });</span>
<span class="line-added">244 </span>
<span class="line-added">245     encoder &lt;&lt; numPoints;</span>
<span class="line-added">246 </span>
<span class="line-added">247     apply([&amp;](auto&amp; element) {</span>
<span class="line-added">248         encoder.encodeEnum(element.type);</span>
<span class="line-added">249 </span>
<span class="line-added">250         switch (element.type) {</span>
<span class="line-added">251         case PathElement::Type::MoveToPoint:</span>
<span class="line-added">252             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">253             break;</span>
<span class="line-added">254         case PathElement::Type::AddLineToPoint:</span>
<span class="line-added">255             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">256             break;</span>
<span class="line-added">257         case PathElement::Type::AddQuadCurveToPoint:</span>
<span class="line-added">258             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">259             encoder &lt;&lt; element.points[1];</span>
<span class="line-added">260             break;</span>
<span class="line-added">261         case PathElement::Type::AddCurveToPoint:</span>
<span class="line-added">262             encoder &lt;&lt; element.points[0];</span>
<span class="line-added">263             encoder &lt;&lt; element.points[1];</span>
<span class="line-added">264             encoder &lt;&lt; element.points[2];</span>
<span class="line-added">265             break;</span>
<span class="line-added">266         case PathElement::Type::CloseSubpath:</span>
<span class="line-added">267             break;</span>
<span class="line-added">268         }</span>
<span class="line-added">269     });</span>
<span class="line-added">270 }</span>
<span class="line-added">271 </span>
<span class="line-added">272 template&lt;class Decoder&gt; Optional&lt;Path&gt; Path::decode(Decoder&amp; decoder)</span>
<span class="line-added">273 {</span>
<span class="line-added">274     Path path;</span>
<span class="line-added">275     uint64_t numPoints;</span>
<span class="line-added">276     if (!decoder.decode(numPoints))</span>
<span class="line-added">277         return WTF::nullopt;</span>
<span class="line-added">278 </span>
<span class="line-added">279     path.clear();</span>
<span class="line-added">280 </span>
<span class="line-added">281     for (uint64_t i = 0; i &lt; numPoints; ++i) {</span>
<span class="line-added">282         PathElement::Type elementType;</span>
<span class="line-added">283         if (!decoder.decodeEnum(elementType))</span>
<span class="line-added">284             return WTF::nullopt;</span>
<span class="line-added">285 </span>
<span class="line-added">286         switch (elementType) {</span>
<span class="line-added">287         case PathElement::Type::MoveToPoint: {</span>
<span class="line-added">288             FloatPoint point;</span>
<span class="line-added">289             if (!decoder.decode(point))</span>
<span class="line-added">290                 return WTF::nullopt;</span>
<span class="line-added">291             path.moveTo(point);</span>
<span class="line-added">292             break;</span>
<span class="line-added">293         }</span>
<span class="line-added">294         case PathElement::Type::AddLineToPoint: {</span>
<span class="line-added">295             FloatPoint point;</span>
<span class="line-added">296             if (!decoder.decode(point))</span>
<span class="line-added">297                 return WTF::nullopt;</span>
<span class="line-added">298             path.addLineTo(point);</span>
<span class="line-added">299             break;</span>
<span class="line-added">300         }</span>
<span class="line-added">301         case PathElement::Type::AddQuadCurveToPoint: {</span>
<span class="line-added">302             FloatPoint controlPoint;</span>
<span class="line-added">303             if (!decoder.decode(controlPoint))</span>
<span class="line-added">304                 return WTF::nullopt;</span>
<span class="line-added">305 </span>
<span class="line-added">306             FloatPoint endPoint;</span>
<span class="line-added">307             if (!decoder.decode(endPoint))</span>
<span class="line-added">308                 return WTF::nullopt;</span>
<span class="line-added">309 </span>
<span class="line-added">310             path.addQuadCurveTo(controlPoint, endPoint);</span>
<span class="line-added">311             break;</span>
<span class="line-added">312         }</span>
<span class="line-added">313         case PathElement::Type::AddCurveToPoint: {</span>
<span class="line-added">314             FloatPoint controlPoint1;</span>
<span class="line-added">315             if (!decoder.decode(controlPoint1))</span>
<span class="line-added">316                 return WTF::nullopt;</span>
<span class="line-added">317 </span>
<span class="line-added">318             FloatPoint controlPoint2;</span>
<span class="line-added">319             if (!decoder.decode(controlPoint2))</span>
<span class="line-added">320                 return WTF::nullopt;</span>
<span class="line-added">321 </span>
<span class="line-added">322             FloatPoint endPoint;</span>
<span class="line-added">323             if (!decoder.decode(endPoint))</span>
<span class="line-added">324                 return WTF::nullopt;</span>
<span class="line-added">325 </span>
<span class="line-added">326             path.addBezierCurveTo(controlPoint1, controlPoint2, endPoint);</span>
<span class="line-added">327             break;</span>
<span class="line-added">328         }</span>
<span class="line-added">329         case PathElement::Type::CloseSubpath:</span>
<span class="line-added">330             path.closeSubpath();</span>
<span class="line-added">331             break;</span>
<span class="line-added">332         }</span>
<span class="line-added">333     }</span>
<span class="line-added">334 </span>
<span class="line-added">335     return path;</span>
<span class="line-added">336 }</span>
<span class="line-added">337 </span>
338 }
339 
340 #endif
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
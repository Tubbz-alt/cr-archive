<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLDepthTexture.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLDrawBuffers.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,17 ***</span>
  #include &quot;config.h&quot;
  
  #if ENABLE(WEBGL)
  #include &quot;WebGLDrawBuffers.h&quot;
  
<span class="line-modified">! #include &quot;Extensions3D.h&quot;</span>
  
  namespace WebCore {
  
  WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
      : WebGLExtension(context)
  {
  }
  
  WebGLDrawBuffers::~WebGLDrawBuffers() = default;
  
  WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
<span class="line-new-header">--- 26,18 ---</span>
  #include &quot;config.h&quot;
  
  #if ENABLE(WEBGL)
  #include &quot;WebGLDrawBuffers.h&quot;
  
<span class="line-modified">! #include &quot;ExtensionsGL.h&quot;</span>
  
  namespace WebCore {
  
  WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
      : WebGLExtension(context)
  {
<span class="line-added">+     context.graphicsContextGL()-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;);</span>
  }
  
  WebGLDrawBuffers::~WebGLDrawBuffers() = default;
  
  WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,112 ***</span>
      return WebGLExtension::WebGLDrawBuffersName;
  }
  
  bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
  {
<span class="line-modified">!     return context.graphicsContext3D()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)</span>
          &amp;&amp; satisfiesWebGLRequirements(context);
  }
  
<span class="line-modified">! void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GC3Denum&gt;&amp; buffers)</span>
  {
      if (m_context.isContextLost())
          return;
<span class="line-modified">!     GC3Dsizei n = buffers.size();</span>
<span class="line-modified">!     const GC3Denum* bufs = buffers.data();</span>
      if (!m_context.m_framebufferBinding) {
          if (n != 1) {
<span class="line-modified">!             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);</span>
              return;
          }
<span class="line-modified">!         if (bufs[0] != GraphicsContext3D::BACK &amp;&amp; bufs[0] != GraphicsContext3D::NONE) {</span>
<span class="line-modified">!             m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);</span>
              return;
          }
          // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified">!         GC3Denum value = (bufs[0] == GraphicsContext3D::BACK) ? GraphicsContext3D::COLOR_ATTACHMENT0 : GraphicsContext3D::NONE;</span>
<span class="line-modified">!         m_context.graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
          m_context.setBackDrawBuffer(bufs[0]);
      } else {
          if (n &gt; m_context.getMaxDrawBuffers()) {
<span class="line-modified">!             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);</span>
              return;
          }
<span class="line-modified">!         for (GC3Dsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified">!             if (bufs[i] != GraphicsContext3D::NONE &amp;&amp; bufs[i] != static_cast&lt;GC3Denum&gt;(Extensions3D::COLOR_ATTACHMENT0_EXT + i)) {</span>
<span class="line-modified">!                 m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);</span>
                  return;
              }
          }
          m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
      }
  }
  
  // static
  bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
  {
<span class="line-modified">!     GraphicsContext3D* context = webglContext.graphicsContext3D();</span>
  
      // This is called after we make sure GL_EXT_draw_buffers is supported.
<span class="line-modified">!     GC3Dint maxDrawBuffers = 0;</span>
<span class="line-modified">!     GC3Dint maxColorAttachments = 0;</span>
<span class="line-modified">!     context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);</span>
<span class="line-modified">!     context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);</span>
      if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
          return false;
  
<span class="line-modified">!     Platform3DObject fbo = context-&gt;createFramebuffer();</span>
<span class="line-modified">!     context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, fbo);</span>
  
      const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
      bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
          || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
      bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
          || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
<span class="line-modified">!     Platform3DObject depthStencil = 0;</span>
      if (supportsDepthStencil) {
          depthStencil = context-&gt;createTexture();
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depthStencil);</span>
<span class="line-modified">!         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_STENCIL, 1, 1, 0, GraphicsContext3D::DEPTH_STENCIL, GraphicsContext3D::UNSIGNED_INT_24_8, buffer);</span>
      }
<span class="line-modified">!     Platform3DObject depth = 0;</span>
      if (supportsDepth) {
          depth = context-&gt;createTexture();
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depth);</span>
<span class="line-modified">!         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_COMPONENT, 1, 1, 0, GraphicsContext3D::DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT, buffer);</span>
      }
  
<span class="line-modified">!     Vector&lt;Platform3DObject&gt; colors;</span>
      bool ok = true;
<span class="line-modified">!     GC3Dint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);</span>
<span class="line-modified">!     for (GC3Dint i = 0; i &lt; maxAllowedBuffers; ++i) {</span>
<span class="line-modified">!         Platform3DObject color = context-&gt;createTexture();</span>
          colors.append(color);
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, color);</span>
<span class="line-modified">!         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1, 0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, buffer);</span>
<span class="line-modified">!         context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0 + i, GraphicsContext3D::TEXTURE_2D, color, 0);</span>
<span class="line-modified">!         if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
              ok = false;
              break;
          }
          if (supportsDepth) {
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depth, 0);</span>
<span class="line-modified">!             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
                  ok = false;
                  break;
              }
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
          }
          if (supportsDepthStencil) {
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">!             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
                  ok = false;
                  break;
              }
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
          }
      }
  
      webglContext.restoreCurrentFramebuffer();
      context-&gt;deleteFramebuffer(fbo);
<span class="line-new-header">--- 45,116 ---</span>
      return WebGLExtension::WebGLDrawBuffersName;
  }
  
  bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
  {
<span class="line-modified">! #if USE(ANGLE)</span>
<span class="line-added">+     return context.graphicsContextGL()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     return context.graphicsContextGL()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)</span>
          &amp;&amp; satisfiesWebGLRequirements(context);
<span class="line-added">+ #endif</span>
  }
  
<span class="line-modified">! void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GCGLenum&gt;&amp; buffers)</span>
  {
      if (m_context.isContextLost())
          return;
<span class="line-modified">!     GCGLsizei n = buffers.size();</span>
<span class="line-modified">!     const GCGLenum* bufs = buffers.data();</span>
      if (!m_context.m_framebufferBinding) {
          if (n != 1) {
<span class="line-modified">!             m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);</span>
              return;
          }
<span class="line-modified">!         if (bufs[0] != GraphicsContextGL::BACK &amp;&amp; bufs[0] != GraphicsContextGL::NONE) {</span>
<span class="line-modified">!             m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);</span>
              return;
          }
          // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified">!         GCGLenum value = (bufs[0] == GraphicsContextGL::BACK) ? GraphicsContextGL::COLOR_ATTACHMENT0 : GraphicsContextGL::NONE;</span>
<span class="line-modified">!         m_context.graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
          m_context.setBackDrawBuffer(bufs[0]);
      } else {
          if (n &gt; m_context.getMaxDrawBuffers()) {
<span class="line-modified">!             m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);</span>
              return;
          }
<span class="line-modified">!         for (GCGLsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified">!             if (bufs[i] != GraphicsContextGL::NONE &amp;&amp; bufs[i] != static_cast&lt;GCGLenum&gt;(ExtensionsGL::COLOR_ATTACHMENT0_EXT + i)) {</span>
<span class="line-modified">!                 m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);</span>
                  return;
              }
          }
          m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
      }
  }
  
  // static
  bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
  {
<span class="line-modified">!     GraphicsContextGLOpenGL* context = webglContext.graphicsContextGL();</span>
  
      // This is called after we make sure GL_EXT_draw_buffers is supported.
<span class="line-modified">!     GCGLint maxDrawBuffers = 0;</span>
<span class="line-modified">!     GCGLint maxColorAttachments = 0;</span>
<span class="line-modified">!     context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);</span>
<span class="line-modified">!     context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);</span>
      if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
          return false;
  
<span class="line-modified">!     PlatformGLObject fbo = context-&gt;createFramebuffer();</span>
<span class="line-modified">!     context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, fbo);</span>
  
      const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
      bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
          || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
      bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
          || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
<span class="line-modified">!     PlatformGLObject depthStencil = 0;</span>
      if (supportsDepthStencil) {
          depthStencil = context-&gt;createTexture();
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, depthStencil);</span>
<span class="line-modified">!         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_STENCIL, 1, 1, 0, GraphicsContextGL::DEPTH_STENCIL, GraphicsContextGL::UNSIGNED_INT_24_8, buffer);</span>
      }
<span class="line-modified">!     PlatformGLObject depth = 0;</span>
      if (supportsDepth) {
          depth = context-&gt;createTexture();
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, depth);</span>
<span class="line-modified">!         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_COMPONENT, 1, 1, 0, GraphicsContextGL::DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT, buffer);</span>
      }
  
<span class="line-modified">!     Vector&lt;PlatformGLObject&gt; colors;</span>
      bool ok = true;
<span class="line-modified">!     GCGLint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);</span>
<span class="line-modified">!     for (GCGLint i = 0; i &lt; maxAllowedBuffers; ++i) {</span>
<span class="line-modified">!         PlatformGLObject color = context-&gt;createTexture();</span>
          colors.append(color);
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, color);</span>
<span class="line-modified">!         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1, 0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, buffer);</span>
<span class="line-modified">!         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0 + i, GraphicsContextGL::TEXTURE_2D, color, 0);</span>
<span class="line-modified">!         if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
              ok = false;
              break;
          }
          if (supportsDepth) {
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depth, 0);</span>
<span class="line-modified">!             if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
                  ok = false;
                  break;
              }
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);</span>
          }
          if (supportsDepthStencil) {
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">!             if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
                  ok = false;
                  break;
              }
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);</span>
<span class="line-modified">!             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);</span>
          }
      }
  
      webglContext.restoreCurrentFramebuffer();
      context-&gt;deleteFramebuffer(fbo);
</pre>
<center><a href="WebGLDepthTexture.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLDrawBuffers.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
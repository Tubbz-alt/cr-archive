<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  * Copyright (C) 2009 Joseph Pecoraro
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;InspectorDOMAgent.h&quot;
  33 
  34 #include &quot;AXObjectCache.h&quot;
  35 #include &quot;AccessibilityNodeObject.h&quot;
  36 #include &quot;Attr.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  38 #include &quot;CSSParser.h&quot;</span>
  39 #include &quot;CSSPropertyNames.h&quot;
  40 #include &quot;CSSPropertySourceData.h&quot;
  41 #include &quot;CSSRule.h&quot;
  42 #include &quot;CSSRuleList.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  43 #include &quot;CSSSelector.h&quot;</span>
<span class="line-added">  44 #include &quot;CSSSelectorList.h&quot;</span>
  45 #include &quot;CSSStyleRule.h&quot;
  46 #include &quot;CSSStyleSheet.h&quot;
  47 #include &quot;CharacterData.h&quot;
  48 #include &quot;CommandLineAPIHost.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  49 #include &quot;ComposedTreeIterator.h&quot;</span>
  50 #include &quot;ContainerNode.h&quot;
  51 #include &quot;Cookie.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;DOMEditor.h&quot;
  54 #include &quot;DOMException.h&quot;
  55 #include &quot;DOMPatchSupport.h&quot;
  56 #include &quot;DOMWindow.h&quot;
  57 #include &quot;Document.h&quot;
  58 #include &quot;DocumentType.h&quot;
  59 #include &quot;Editing.h&quot;
  60 #include &quot;Element.h&quot;
  61 #include &quot;Event.h&quot;
  62 #include &quot;EventListener.h&quot;
  63 #include &quot;EventNames.h&quot;
  64 #include &quot;Frame.h&quot;
  65 #include &quot;FrameTree.h&quot;
  66 #include &quot;FrameView.h&quot;
  67 #include &quot;FullscreenManager.h&quot;
  68 #include &quot;HTMLElement.h&quot;
  69 #include &quot;HTMLFrameOwnerElement.h&quot;
  70 #include &quot;HTMLMediaElement.h&quot;
  71 #include &quot;HTMLNames.h&quot;
  72 #include &quot;HTMLParserIdioms.h&quot;
  73 #include &quot;HTMLScriptElement.h&quot;
  74 #include &quot;HTMLStyleElement.h&quot;
  75 #include &quot;HTMLTemplateElement.h&quot;
  76 #include &quot;HTMLVideoElement.h&quot;
  77 #include &quot;HitTestResult.h&quot;
  78 #include &quot;InspectorCSSAgent.h&quot;
  79 #include &quot;InspectorClient.h&quot;
  80 #include &quot;InspectorController.h&quot;
  81 #include &quot;InspectorHistory.h&quot;
  82 #include &quot;InspectorNodeFinder.h&quot;
  83 #include &quot;InspectorOverlay.h&quot;
  84 #include &quot;InspectorPageAgent.h&quot;
  85 #include &quot;InstrumentingAgents.h&quot;
  86 #include &quot;IntRect.h&quot;
  87 #include &quot;JSDOMBindingSecurity.h&quot;
  88 #include &quot;JSEventListener.h&quot;
  89 #include &quot;JSNode.h&quot;
  90 #include &quot;MutationEvent.h&quot;
  91 #include &quot;Node.h&quot;
  92 #include &quot;NodeList.h&quot;
  93 #include &quot;Page.h&quot;
  94 #include &quot;Pasteboard.h&quot;
  95 #include &quot;PseudoElement.h&quot;
  96 #include &quot;RenderStyle.h&quot;
  97 #include &quot;RenderStyleConstants.h&quot;
  98 #include &quot;ScriptState.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  99 #include &quot;SelectorChecker.h&quot;</span>
 100 #include &quot;ShadowRoot.h&quot;
 101 #include &quot;StaticNodeList.h&quot;
 102 #include &quot;StyleProperties.h&quot;
 103 #include &quot;StyleResolver.h&quot;
 104 #include &quot;StyleSheetList.h&quot;
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextNodeTraversal.h&quot;
 107 #include &quot;Timer.h&quot;
 108 #include &quot;VideoPlaybackQuality.h&quot;
 109 #include &quot;WebInjectedScriptManager.h&quot;
 110 #include &quot;XPathResult.h&quot;
 111 #include &quot;markup.h&quot;
 112 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 113 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 114 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 115 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 116 #include &lt;pal/crypto/CryptoDigest.h&gt;
<a name="5" id="anc5"></a><span class="line-added"> 117 #include &lt;wtf/Function.h&gt;</span>
 118 #include &lt;wtf/text/Base64.h&gt;
 119 #include &lt;wtf/text/CString.h&gt;
 120 #include &lt;wtf/text/WTFString.h&gt;
 121 
 122 namespace WebCore {
 123 
 124 using namespace Inspector;
 125 
 126 using namespace HTMLNames;
 127 
 128 static const size_t maxTextSize = 10000;
 129 static const UChar ellipsisUChar[] = { 0x2026, 0 };
 130 
 131 static Color parseColor(const JSON::Object* colorObject)
 132 {
 133     if (!colorObject)
 134         return Color::transparent;
 135 
 136     int r = 0;
 137     int g = 0;
 138     int b = 0;
 139     if (!colorObject-&gt;getInteger(&quot;r&quot;, r) || !colorObject-&gt;getInteger(&quot;g&quot;, g) || !colorObject-&gt;getInteger(&quot;b&quot;, b))
 140         return Color::transparent;
 141 
 142     double a = 1.0;
 143     if (!colorObject-&gt;getDouble(&quot;a&quot;, a))
 144         return Color(r, g, b);
 145 
 146     // Clamp alpha to the [0..1] range.
 147     if (a &lt; 0)
 148         a = 0;
 149     else if (a &gt; 1)
 150         a = 1;
 151 
 152     return Color(r, g, b, static_cast&lt;int&gt;(a * 255));
 153 }
 154 
 155 static Color parseConfigColor(const String&amp; fieldName, const JSON::Object* configObject)
 156 {
 157     RefPtr&lt;JSON::Object&gt; colorObject;
 158     configObject-&gt;getObject(fieldName, colorObject);
 159 
 160     return parseColor(colorObject.get());
 161 }
 162 
 163 static bool parseQuad(const JSON::Array&amp; quadArray, FloatQuad* quad)
 164 {
 165     const size_t coordinatesInQuad = 8;
 166     double coordinates[coordinatesInQuad];
 167     if (quadArray.length() != coordinatesInQuad)
 168         return false;
 169     for (size_t i = 0; i &lt; coordinatesInQuad; ++i) {
 170         if (!quadArray.get(i)-&gt;asDouble(*(coordinates + i)))
 171             return false;
 172     }
 173     quad-&gt;setP1(FloatPoint(coordinates[0], coordinates[1]));
 174     quad-&gt;setP2(FloatPoint(coordinates[2], coordinates[3]));
 175     quad-&gt;setP3(FloatPoint(coordinates[4], coordinates[5]));
 176     quad-&gt;setP4(FloatPoint(coordinates[6], coordinates[7]));
 177 
 178     return true;
 179 }
 180 
 181 class RevalidateStyleAttributeTask {
 182     WTF_MAKE_FAST_ALLOCATED;
 183 public:
 184     RevalidateStyleAttributeTask(InspectorDOMAgent*);
 185     void scheduleFor(Element*);
 186     void reset() { m_timer.stop(); }
 187     void timerFired();
 188 
 189 private:
 190     InspectorDOMAgent* m_domAgent;
 191     Timer m_timer;
 192     HashSet&lt;RefPtr&lt;Element&gt;&gt; m_elements;
 193 };
 194 
 195 RevalidateStyleAttributeTask::RevalidateStyleAttributeTask(InspectorDOMAgent* domAgent)
 196     : m_domAgent(domAgent)
 197     , m_timer(*this, &amp;RevalidateStyleAttributeTask::timerFired)
 198 {
 199 }
 200 
 201 void RevalidateStyleAttributeTask::scheduleFor(Element* element)
 202 {
 203     m_elements.add(element);
 204     if (!m_timer.isActive())
 205         m_timer.startOneShot(0_s);
 206 }
 207 
 208 void RevalidateStyleAttributeTask::timerFired()
 209 {
 210     // The timer is stopped on m_domAgent destruction, so this method will never be called after m_domAgent has been destroyed.
 211     Vector&lt;Element*&gt; elements;
 212     for (auto&amp; element : m_elements)
 213         elements.append(element.get());
 214     m_domAgent-&gt;styleAttributeInvalidated(elements);
 215 
 216     m_elements.clear();
 217 }
 218 
 219 class InspectableNode final : public CommandLineAPIHost::InspectableObject {
 220 public:
 221     explicit InspectableNode(Node* node)
 222         : m_node(node)
 223     {
 224     }
 225 
<a name="6" id="anc6"></a><span class="line-modified"> 226     JSC::JSValue get(JSC::JSGlobalObject&amp; state) final</span>
 227     {
 228         return InspectorDOMAgent::nodeAsScriptValue(state, m_node.get());
 229     }
 230 private:
 231     RefPtr&lt;Node&gt; m_node;
 232 };
 233 
 234 class EventFiredCallback final : public EventListener {
 235 public:
 236     static Ref&lt;EventFiredCallback&gt; create(InspectorDOMAgent&amp; domAgent)
 237     {
 238         return adoptRef(*new EventFiredCallback(domAgent));
 239     }
 240 
 241     bool operator==(const EventListener&amp; other) const final
 242     {
 243         return this == &amp;other;
 244     }
 245 
 246     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
 247     {
 248         if (!is&lt;Node&gt;(event.target()) || m_domAgent.m_dispatchedEvents.contains(&amp;event))
 249             return;
 250 
 251         auto* node = downcast&lt;Node&gt;(event.target());
 252         int nodeId = m_domAgent.pushNodePathToFrontend(node);
 253         if (!nodeId)
 254             return;
 255 
 256         m_domAgent.m_dispatchedEvents.add(&amp;event);
 257 
 258         RefPtr&lt;JSON::Object&gt; data = JSON::Object::create();
 259 
 260 #if ENABLE(FULLSCREEN_API)
 261         if (event.type() == eventNames().webkitfullscreenchangeEvent)
 262             data-&gt;setBoolean(&quot;enabled&quot;_s, !!node-&gt;document().fullscreenManager().fullscreenElement());
 263 #endif // ENABLE(FULLSCREEN_API)
 264 
 265         auto timestamp = m_domAgent.m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 266         m_domAgent.m_frontendDispatcher-&gt;didFireEvent(nodeId, event.type(), timestamp, data-&gt;size() ? WTFMove(data) : nullptr);
 267     }
 268 
 269 private:
 270     EventFiredCallback(InspectorDOMAgent&amp; domAgent)
 271         : EventListener(EventListener::CPPEventListenerType)
 272         , m_domAgent(domAgent)
 273     {
 274     }
 275 
 276     InspectorDOMAgent&amp; m_domAgent;
 277 };
 278 
 279 String InspectorDOMAgent::toErrorString(ExceptionCode ec)
 280 {
 281     return ec ? String(DOMException::name(ec)) : emptyString();
 282 }
 283 
 284 String InspectorDOMAgent::toErrorString(Exception&amp;&amp; exception)
 285 {
 286     return DOMException::name(exception.code());
 287 }
 288 
 289 InspectorDOMAgent::InspectorDOMAgent(PageAgentContext&amp; context, InspectorOverlay* overlay)
 290     : InspectorAgentBase(&quot;DOM&quot;_s, context)
 291     , m_injectedScriptManager(context.injectedScriptManager)
 292     , m_frontendDispatcher(makeUnique&lt;Inspector::DOMFrontendDispatcher&gt;(context.frontendRouter))
 293     , m_backendDispatcher(Inspector::DOMBackendDispatcher::create(context.backendDispatcher, this))
 294     , m_inspectedPage(context.inspectedPage)
 295     , m_overlay(overlay)
 296 #if ENABLE(VIDEO)
 297     , m_mediaMetricsTimer(*this, &amp;InspectorDOMAgent::mediaMetricsTimerFired)
 298 #endif
 299 {
 300 }
 301 
 302 InspectorDOMAgent::~InspectorDOMAgent() = default;
 303 
 304 void InspectorDOMAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 305 {
 306     m_history = makeUnique&lt;InspectorHistory&gt;();
 307     m_domEditor = makeUnique&lt;DOMEditor&gt;(*m_history);
 308 
 309     m_instrumentingAgents.setInspectorDOMAgent(this);
 310     m_document = m_inspectedPage.mainFrame().document();
 311 
 312 #if ENABLE(VIDEO)
 313     if (m_document)
 314         addEventListenersToNode(*m_document);
 315 
 316     for (auto* mediaElement : HTMLMediaElement::allMediaElements())
 317         addEventListenersToNode(*mediaElement);
 318 #endif
 319 }
 320 
 321 void InspectorDOMAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 322 {
 323     m_history.reset();
 324     m_domEditor.reset();
 325     m_nodeToFocus = nullptr;
 326     m_mousedOverNode = nullptr;
 327     m_inspectedNode = nullptr;
 328 
 329     ErrorString ignored;
 330     setSearchingForNode(ignored, false, nullptr, false);
 331     hideHighlight(ignored);
 332 
 333     m_instrumentingAgents.setInspectorDOMAgent(nullptr);
 334     m_documentRequested = false;
 335     reset();
 336 }
 337 
 338 Vector&lt;Document*&gt; InspectorDOMAgent::documents()
 339 {
 340     Vector&lt;Document*&gt; result;
 341     for (Frame* frame = m_document-&gt;frame(); frame; frame = frame-&gt;tree().traverseNext()) {
 342         Document* document = frame-&gt;document();
 343         if (!document)
 344             continue;
 345         result.append(document);
 346     }
 347     return result;
 348 }
 349 
 350 void InspectorDOMAgent::reset()
 351 {
 352     if (m_history)
 353         m_history-&gt;reset();
 354     m_searchResults.clear();
 355     discardBindings();
 356     if (m_revalidateStyleAttrTask)
 357         m_revalidateStyleAttrTask-&gt;reset();
 358     m_document = nullptr;
 359 }
 360 
 361 void InspectorDOMAgent::setDocument(Document* document)
 362 {
 363     if (document == m_document.get())
 364         return;
 365 
 366     reset();
 367 
 368     m_document = document;
 369 
 370     if (!m_documentRequested)
 371         return;
 372 
 373     // Immediately communicate null document or document that has finished loading.
 374     if (!document || !document-&gt;parsing())
 375         m_frontendDispatcher-&gt;documentUpdated();
 376 }
 377 
 378 void InspectorDOMAgent::releaseDanglingNodes()
 379 {
 380     m_danglingNodeToIdMaps.clear();
 381 }
 382 
 383 int InspectorDOMAgent::bind(Node* node, NodeToIdMap* nodesMap)
 384 {
 385     int id = nodesMap-&gt;get(node);
 386     if (id)
 387         return id;
 388     id = m_lastNodeId++;
 389     nodesMap-&gt;set(node, id);
 390     m_idToNode.set(id, node);
 391     m_idToNodesMap.set(id, nodesMap);
 392     return id;
 393 }
 394 
 395 void InspectorDOMAgent::unbind(Node* node, NodeToIdMap* nodesMap)
 396 {
 397     int id = nodesMap-&gt;get(node);
 398     if (!id)
 399         return;
 400 
 401     m_idToNode.remove(id);
 402 
 403     if (node-&gt;isFrameOwnerElement()) {
 404         const HTMLFrameOwnerElement* frameOwner = static_cast&lt;const HTMLFrameOwnerElement*&gt;(node);
 405         if (Document* contentDocument = frameOwner-&gt;contentDocument())
 406             unbind(contentDocument, nodesMap);
 407     }
 408 
 409     if (is&lt;Element&gt;(*node)) {
 410         Element&amp; element = downcast&lt;Element&gt;(*node);
 411         if (ShadowRoot* root = element.shadowRoot())
 412             unbind(root, nodesMap);
 413         if (PseudoElement* beforeElement = element.beforePseudoElement())
 414             unbind(beforeElement, nodesMap);
 415         if (PseudoElement* afterElement = element.afterPseudoElement())
 416             unbind(afterElement, nodesMap);
 417     }
 418 
 419     nodesMap-&gt;remove(node);
 420 
 421     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
 422         cssAgent-&gt;didRemoveDOMNode(*node, id);
 423 
 424     if (m_childrenRequested.remove(id)) {
 425         // FIXME: Would be better to do this iteratively rather than recursively.
 426         for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
 427             unbind(child, nodesMap);
 428     }
 429 }
 430 
 431 Node* InspectorDOMAgent::assertNode(ErrorString&amp; errorString, int nodeId)
 432 {
 433     Node* node = nodeForId(nodeId);
 434     if (!node) {
 435         errorString = &quot;Missing node for given nodeId&quot;_s;
 436         return nullptr;
 437     }
 438     return node;
 439 }
 440 
 441 Document* InspectorDOMAgent::assertDocument(ErrorString&amp; errorString, int nodeId)
 442 {
 443     Node* node = assertNode(errorString, nodeId);
 444     if (!node)
 445         return nullptr;
 446     if (!is&lt;Document&gt;(node)) {
 447         errorString = &quot;Node for given nodeId is not a document&quot;_s;
 448         return nullptr;
 449     }
 450     return downcast&lt;Document&gt;(node);
 451 }
 452 
 453 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 454 {
 455     Node* node = assertNode(errorString, nodeId);
 456     if (!node)
 457         return nullptr;
 458     if (!is&lt;Element&gt;(node)) {
 459         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 460         return nullptr;
 461     }
 462     return downcast&lt;Element&gt;(node);
 463 }
 464 
 465 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 466 {
 467     Node* node = assertNode(errorString, nodeId);
 468     if (!node)
 469         return nullptr;
<a name="7" id="anc7"></a><span class="line-modified"> 470     if (node-&gt;isInUserAgentShadowTree() &amp;&amp; !m_allowEditingUserAgentShadowTrees) {</span>
 471         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;
 472         return nullptr;
 473     }
 474     if (node-&gt;isPseudoElement()) {
 475         errorString = &quot;Node for given nodeId is a pseudo-element&quot;_s;
 476         return nullptr;
 477     }
 478     return node;
 479 }
 480 
 481 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 482 {
 483     Node* node = assertEditableNode(errorString, nodeId);
 484     if (!node)
 485         return nullptr;
 486     if (!is&lt;Element&gt;(node)) {
 487         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 488         return nullptr;
 489     }
 490     return downcast&lt;Element&gt;(node);
 491 }
 492 
 493 void InspectorDOMAgent::getDocument(ErrorString&amp; errorString, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root)
 494 {
 495     m_documentRequested = true;
 496 
 497     if (!m_document) {
 498         errorString = &quot;Internal error: missing document&quot;_s;
 499         return;
 500     }
 501 
 502     // Reset backend state.
 503     RefPtr&lt;Document&gt; document = m_document;
 504     reset();
 505     m_document = document;
 506 
 507     root = buildObjectForNode(m_document.get(), 2, &amp;m_documentNodeToIdMap);
 508 
 509     if (m_nodeToFocus)
 510         focusNode();
 511 }
 512 
 513 void InspectorDOMAgent::pushChildNodesToFrontend(int nodeId, int depth)
 514 {
 515     Node* node = nodeForId(nodeId);
 516     if (!node || (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_FRAGMENT_NODE))
 517         return;
 518 
 519     NodeToIdMap* nodeMap = m_idToNodesMap.get(nodeId);
 520 
 521     if (m_childrenRequested.contains(nodeId)) {
 522         if (depth &lt;= 1)
 523             return;
 524 
 525         depth--;
 526 
 527         for (node = innerFirstChild(node); node; node = innerNextSibling(node)) {
 528             int childNodeId = nodeMap-&gt;get(node);
 529             ASSERT(childNodeId);
 530             pushChildNodesToFrontend(childNodeId, depth);
 531         }
 532 
 533         return;
 534     }
 535 
 536     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 537     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 538 }
 539 
 540 void InspectorDOMAgent::discardBindings()
 541 {
 542     m_documentNodeToIdMap.clear();
 543     m_idToNode.clear();
 544     m_dispatchedEvents.clear();
 545     m_eventListenerEntries.clear();
 546     releaseDanglingNodes();
 547     m_childrenRequested.clear();
 548 }
 549 
<a name="8" id="anc8"></a><span class="line-added"> 550 int InspectorDOMAgent::pushNodeToFrontend(Node* nodeToPush)</span>
<span class="line-added"> 551 {</span>
<span class="line-added"> 552     if (!nodeToPush)</span>
<span class="line-added"> 553         return 0;</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555     ErrorString ignored;</span>
<span class="line-added"> 556     return pushNodeToFrontend(ignored, boundNodeId(&amp;nodeToPush-&gt;document()), nodeToPush);</span>
<span class="line-added"> 557 }</span>
<span class="line-added"> 558 </span>
 559 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 560 {
 561     Document* document = assertDocument(errorString, documentNodeId);
 562     if (!document)
 563         return 0;
 564     if (&amp;nodeToPush-&gt;document() != document) {
 565         errorString = &quot;nodeToPush is not part of the document with given documentNodeId&quot;_s;
 566         return 0;
 567     }
 568 
<a name="9" id="anc9"></a><span class="line-modified"> 569     return pushNodePathToFrontend(errorString, nodeToPush);</span>
 570 }
 571 
 572 Node* InspectorDOMAgent::nodeForId(int id)
 573 {
 574     if (!m_idToNode.isValidKey(id))
 575         return nullptr;
 576 
 577     return m_idToNode.get(id);
 578 }
 579 
 580 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 581 {
 582     int sanitizedDepth;
 583 
 584     if (!depth)
 585         sanitizedDepth = 1;
 586     else if (*depth == -1)
 587         sanitizedDepth = INT_MAX;
 588     else if (*depth &gt; 0)
 589         sanitizedDepth = *depth;
 590     else {
 591         errorString = &quot;Unexpected value below -1 for given depth&quot;_s;
 592         return;
 593     }
 594 
 595     pushChildNodesToFrontend(nodeId, sanitizedDepth);
 596 }
 597 
 598 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 599 {
 600     *elementId = 0;
 601     Node* node = assertNode(errorString, nodeId);
 602     if (!node)
 603         return;
 604     if (!is&lt;ContainerNode&gt;(*node)) {
 605         assertElement(errorString, nodeId);
 606         return;
 607     }
 608 
 609     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 610     if (queryResult.hasException()) {
 611         errorString = &quot;DOM Error while querying with given selectors&quot;_s;
 612         return;
 613     }
 614 
 615     if (auto* element = queryResult.releaseReturnValue())
<a name="10" id="anc10"></a><span class="line-modified"> 616         *elementId = pushNodePathToFrontend(errorString, element);</span>
 617 }
 618 
 619 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 620 {
 621     Node* node = assertNode(errorString, nodeId);
 622     if (!node)
 623         return;
 624     if (!is&lt;ContainerNode&gt;(*node)) {
 625         assertElement(errorString, nodeId);
 626         return;
 627     }
 628 
 629     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 630     if (queryResult.hasException()) {
 631         errorString = &quot;DOM Error while querying with given selectors&quot;_s;
 632         return;
 633     }
 634 
 635     auto nodes = queryResult.releaseReturnValue();
 636     result = JSON::ArrayOf&lt;int&gt;::create();
 637     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 638         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 639 }
 640 
 641 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
<a name="11" id="anc11"></a><span class="line-added"> 642 {</span>
<span class="line-added"> 643     ErrorString ignored;</span>
<span class="line-added"> 644     return pushNodePathToFrontend(ignored, nodeToPush);</span>
<span class="line-added"> 645 }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647 int InspectorDOMAgent::pushNodePathToFrontend(ErrorString errorString, Node* nodeToPush)</span>
 648 {
 649     ASSERT(nodeToPush);  // Invalid input
 650 
<a name="12" id="anc12"></a><span class="line-modified"> 651     if (!m_document) {</span>
<span class="line-added"> 652         errorString = &quot;Missing document&quot;_s;</span>
 653         return 0;
<a name="13" id="anc13"></a><span class="line-modified"> 654     }</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     if (!m_documentNodeToIdMap.contains(m_document)) {</span>
<span class="line-added"> 657         errorString = &quot;Document must have been requested&quot;_s;</span>
 658         return 0;
<a name="14" id="anc14"></a><span class="line-added"> 659     }</span>
 660 
 661     // Return id in case the node is known.
 662     int result = m_documentNodeToIdMap.get(nodeToPush);
 663     if (result)
 664         return result;
 665 
 666     Node* node = nodeToPush;
 667     Vector&lt;Node*&gt; path;
 668     NodeToIdMap* danglingMap = 0;
 669 
 670     while (true) {
 671         Node* parent = innerParentNode(node);
 672         if (!parent) {
 673             // Node being pushed is detached -&gt; push subtree root.
 674             auto newMap = makeUnique&lt;NodeToIdMap&gt;();
 675             danglingMap = newMap.get();
 676             m_danglingNodeToIdMaps.append(newMap.release());
 677             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 678             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 679             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
 680             break;
 681         } else {
 682             path.append(parent);
 683             if (m_documentNodeToIdMap.get(parent))
 684                 break;
 685             else
 686                 node = parent;
 687         }
 688     }
 689 
 690     NodeToIdMap* map = danglingMap ? danglingMap : &amp;m_documentNodeToIdMap;
 691     for (int i = path.size() - 1; i &gt;= 0; --i) {
 692         int nodeId = map-&gt;get(path.at(i));
 693         ASSERT(nodeId);
 694         pushChildNodesToFrontend(nodeId);
 695     }
 696     return map-&gt;get(nodeToPush);
 697 }
 698 
 699 int InspectorDOMAgent::boundNodeId(const Node* node)
 700 {
 701     return m_documentNodeToIdMap.get(const_cast&lt;Node*&gt;(node));
 702 }
 703 
 704 void InspectorDOMAgent::setAttributeValue(ErrorString&amp; errorString, int elementId, const String&amp; name, const String&amp; value)
 705 {
 706     Element* element = assertEditableElement(errorString, elementId);
 707     if (!element)
 708         return;
 709 
 710     m_domEditor-&gt;setAttribute(*element, name, value, errorString);
 711 }
 712 
 713 void InspectorDOMAgent::setAttributesAsText(ErrorString&amp; errorString, int elementId, const String&amp; text, const String* name)
 714 {
 715     Element* element = assertEditableElement(errorString, elementId);
 716     if (!element)
 717         return;
 718 
 719     auto parsedElement = createHTMLElement(element-&gt;document(), spanTag);
 720     auto result = parsedElement.get().setInnerHTML(&quot;&lt;span &quot; + text + &quot;&gt;&lt;/span&gt;&quot;);
 721     if (result.hasException()) {
 722         errorString = toErrorString(result.releaseException());
 723         return;
 724     }
 725 
 726     Node* child = parsedElement-&gt;firstChild();
 727     if (!child) {
 728         errorString = &quot;Could not parse given text&quot;_s;
 729         return;
 730     }
 731 
 732     Element* childElement = downcast&lt;Element&gt;(child);
 733     if (!childElement-&gt;hasAttributes() &amp;&amp; name) {
 734         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 735         return;
 736     }
 737 
 738     bool foundOriginalAttribute = false;
 739     for (const Attribute&amp; attribute : childElement-&gt;attributesIterator()) {
 740         // Add attribute pair
 741         foundOriginalAttribute = foundOriginalAttribute || (name &amp;&amp; attribute.name().toString() == *name);
 742         if (!m_domEditor-&gt;setAttribute(*element, attribute.name().toString(), attribute.value(), errorString))
 743             return;
 744     }
 745 
 746     if (!foundOriginalAttribute &amp;&amp; name &amp;&amp; !name-&gt;stripWhiteSpace().isEmpty())
 747         m_domEditor-&gt;removeAttribute(*element, *name, errorString);
 748 }
 749 
 750 void InspectorDOMAgent::removeAttribute(ErrorString&amp; errorString, int elementId, const String&amp; name)
 751 {
 752     Element* element = assertEditableElement(errorString, elementId);
 753     if (!element)
 754         return;
 755 
 756     m_domEditor-&gt;removeAttribute(*element, name, errorString);
 757 }
 758 
 759 void InspectorDOMAgent::removeNode(ErrorString&amp; errorString, int nodeId)
 760 {
 761     Node* node = assertEditableNode(errorString, nodeId);
 762     if (!node)
 763         return;
 764 
 765     ContainerNode* parentNode = node-&gt;parentNode();
 766     if (!parentNode) {
 767         errorString = &quot;Cannot remove detached node&quot;_s;
 768         return;
 769     }
 770 
 771     m_domEditor-&gt;removeChild(*parentNode, *node, errorString);
 772 }
 773 
 774 void InspectorDOMAgent::setNodeName(ErrorString&amp; errorString, int nodeId, const String&amp; tagName, int* newId)
 775 {
 776     *newId = 0;
 777 
 778     RefPtr&lt;Node&gt; oldNode = nodeForId(nodeId);
 779     if (!is&lt;Element&gt;(oldNode))
 780         return;
 781 
 782     auto createElementResult = oldNode-&gt;document().createElementForBindings(tagName);
 783     if (createElementResult.hasException())
 784         return;
 785     auto newElement = createElementResult.releaseReturnValue();
 786 
 787     // Copy over the original node&#39;s attributes.
 788     newElement-&gt;cloneAttributesFromElement(downcast&lt;Element&gt;(*oldNode));
 789 
 790     // Copy over the original node&#39;s children.
 791     RefPtr&lt;Node&gt; child;
 792     while ((child = oldNode-&gt;firstChild())) {
 793         if (!m_domEditor-&gt;insertBefore(newElement, *child, 0, errorString))
 794             return;
 795     }
 796 
 797     // Replace the old node with the new node
 798     RefPtr&lt;ContainerNode&gt; parent = oldNode-&gt;parentNode();
 799     if (!m_domEditor-&gt;insertBefore(*parent, newElement.copyRef(), oldNode-&gt;nextSibling(), errorString))
 800         return;
 801     if (!m_domEditor-&gt;removeChild(*parent, *oldNode, errorString))
 802         return;
 803 
<a name="15" id="anc15"></a><span class="line-modified"> 804     *newId = pushNodePathToFrontend(errorString, newElement.ptr());</span>
 805     if (m_childrenRequested.contains(nodeId))
 806         pushChildNodesToFrontend(*newId);
 807 }
 808 
 809 void InspectorDOMAgent::getOuterHTML(ErrorString&amp; errorString, int nodeId, WTF::String* outerHTML)
 810 {
 811     Node* node = assertNode(errorString, nodeId);
 812     if (!node)
 813         return;
 814 
 815     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 816 }
 817 
 818 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 819 {
 820     if (!nodeId) {
 821         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 822         return;
 823     }
 824 
 825     Node* node = assertEditableNode(errorString, nodeId);
 826     if (!node)
 827         return;
 828 
 829     Document&amp; document = node-&gt;document();
 830     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
 831         errorString = &quot;Document of node for given nodeId is not HTML/XML&quot;_s;
 832         return;
 833     }
 834 
 835     Node* newNode = nullptr;
 836     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 837         return;
 838 
 839     if (!newNode) {
 840         // The only child node has been deleted.
 841         return;
 842     }
 843 
<a name="16" id="anc16"></a><span class="line-modified"> 844     int newId = pushNodePathToFrontend(errorString, newNode);</span>
 845 
 846     bool childrenRequested = m_childrenRequested.contains(nodeId);
 847     if (childrenRequested)
 848         pushChildNodesToFrontend(newId);
 849 }
 850 
 851 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 852 {
 853     Node* node = assertEditableNode(errorString, nodeId);
 854     if (!node)
 855         return;
 856 
 857     if (!is&lt;Element&gt;(node)) {
 858         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 859         return;
 860     }
 861 
 862     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 863 }
 864 
 865 void InspectorDOMAgent::setNodeValue(ErrorString&amp; errorString, int nodeId, const String&amp; value)
 866 {
 867     Node* node = assertEditableNode(errorString, nodeId);
 868     if (!node)
 869         return;
 870 
 871     if (!is&lt;Text&gt;(*node)) {
 872         errorString = &quot;Node for given nodeId is not text&quot;_s;
 873         return;
 874     }
 875 
 876     m_domEditor-&gt;replaceWholeText(downcast&lt;Text&gt;(*node), value, errorString);
 877 }
 878 
 879 void InspectorDOMAgent::getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames)
 880 {
 881     eventNames = JSON::ArrayOf&lt;String&gt;::create();
 882 
 883 #define DOM_EVENT_NAMES_ADD(name) eventNames-&gt;addItem(#name);
 884     DOM_EVENT_NAMES_FOR_EACH(DOM_EVENT_NAMES_ADD)
 885 #undef DOM_EVENT_NAMES_ADD
 886 }
 887 
 888 void InspectorDOMAgent::getDataBindingsForNode(ErrorString&amp; errorString, int /* nodeId */, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::DataBinding&gt;&gt;&amp; /* dataBindings */)
 889 {
 890     errorString = &quot;Not supported&quot;_s;
 891 }
 892 
 893 void InspectorDOMAgent::getAssociatedDataForNode(ErrorString&amp; errorString, int /* nodeId */, Optional&lt;String&gt;&amp; /* associatedData */)
 894 {
 895     errorString = &quot;Not supported&quot;_s;
 896 }
 897 
 898 void InspectorDOMAgent::getEventListenersForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray)
 899 {
 900     listenersArray = JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;::create();
 901 
 902     auto* node = assertNode(errorString, nodeId);
 903     if (!node)
 904         return;
 905 
 906     Vector&lt;RefPtr&lt;EventTarget&gt;&gt; ancestors;
 907     ancestors.append(node);
 908     for (auto* ancestor = node-&gt;parentOrShadowHostNode(); ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode())
 909         ancestors.append(ancestor);
 910     if (auto* window = node-&gt;document().domWindow())
 911         ancestors.append(window);
 912 
 913     struct EventListenerInfo {
 914         RefPtr&lt;EventTarget&gt; eventTarget;
 915         const AtomString eventType;
 916         const EventListenerVector eventListeners;
 917     };
 918 
 919     Vector&lt;EventListenerInfo&gt; eventInformation;
 920     for (size_t i = ancestors.size(); i; --i) {
 921         auto&amp; ancestor = ancestors[i - 1];
 922         for (auto&amp; eventType : ancestor-&gt;eventTypes()) {
 923             EventListenerVector filteredListeners;
 924             for (auto&amp; listener : ancestor-&gt;eventListeners(eventType)) {
 925                 if (listener-&gt;callback().type() == EventListener::JSEventListenerType)
 926                     filteredListeners.append(listener);
 927             }
 928             if (!filteredListeners.isEmpty())
 929                 eventInformation.append({ ancestor, eventType, WTFMove(filteredListeners) });
 930         }
 931     }
 932 
 933     auto addListener = [&amp;] (RegisteredEventListener&amp; listener, const EventListenerInfo&amp; info) {
 934         int identifier = 0;
 935         bool disabled = false;
 936         bool hasBreakpoint = false;
 937 
 938         for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
 939             if (inspectorEventListener.matches(*info.eventTarget, info.eventType, listener.callback(), listener.useCapture())) {
 940                 identifier = inspectorEventListener.identifier;
 941                 disabled = inspectorEventListener.disabled;
 942                 hasBreakpoint = inspectorEventListener.hasBreakpoint;
 943                 break;
 944             }
 945         }
 946 
 947         if (!identifier) {
 948             InspectorEventListener inspectorEventListener(m_lastEventListenerId++, *info.eventTarget, info.eventType, listener.callback(), listener.useCapture());
 949 
 950             identifier = inspectorEventListener.identifier;
 951             disabled = inspectorEventListener.disabled;
 952             hasBreakpoint = inspectorEventListener.hasBreakpoint;
 953 
 954             m_eventListenerEntries.add(identifier, inspectorEventListener);
 955         }
 956 
 957         listenersArray-&gt;addItem(buildObjectForEventListener(listener, identifier, *info.eventTarget, info.eventType, disabled, hasBreakpoint));
 958     };
 959 
 960     // Get Capturing Listeners (in this order)
 961     size_t eventInformationLength = eventInformation.size();
 962     for (auto&amp; info : eventInformation) {
 963         for (auto&amp; listener : info.eventListeners) {
 964             if (listener-&gt;useCapture())
 965                 addListener(*listener, info);
 966         }
 967     }
 968 
 969     // Get Bubbling Listeners (reverse order)
 970     for (size_t i = eventInformationLength; i; --i) {
 971         const EventListenerInfo&amp; info = eventInformation[i - 1];
 972         for (auto&amp; listener : info.eventListeners) {
 973             if (!listener-&gt;useCapture())
 974                 addListener(*listener, info);
 975         }
 976     }
 977 
 978     if (m_inspectedNode == node)
 979         m_suppressEventListenerChangedEvent = false;
 980 }
 981 
 982 void InspectorDOMAgent::setEventListenerDisabled(ErrorString&amp; errorString, int eventListenerId, bool disabled)
 983 {
 984     auto it = m_eventListenerEntries.find(eventListenerId);
 985     if (it == m_eventListenerEntries.end()) {
 986         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;
 987         return;
 988     }
 989 
 990     it-&gt;value.disabled = disabled;
 991 }
 992 
 993 void InspectorDOMAgent::setBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
 994 {
 995     auto it = m_eventListenerEntries.find(eventListenerId);
 996     if (it == m_eventListenerEntries.end()) {
 997         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;
 998         return;
 999     }
1000 
1001     it-&gt;value.hasBreakpoint = true;
1002 }
1003 
1004 void InspectorDOMAgent::removeBreakpointForEventListener(ErrorString&amp; errorString, int eventListenerId)
1005 {
1006     auto it = m_eventListenerEntries.find(eventListenerId);
1007     if (it == m_eventListenerEntries.end()) {
1008         errorString = &quot;Missing event listener for given eventListenerId&quot;_s;
1009         return;
1010     }
1011 
1012     it-&gt;value.hasBreakpoint = false;
1013 }
1014 
1015 void InspectorDOMAgent::getAccessibilityPropertiesForNode(ErrorString&amp; errorString, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties)
1016 {
1017     Node* node = assertNode(errorString, nodeId);
1018     if (!node)
1019         return;
1020 
1021     axProperties = buildObjectForAccessibilityProperties(node);
1022 }
1023 
1024 void InspectorDOMAgent::performSearch(ErrorString&amp; errorString, const String&amp; query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount)
1025 {
1026     // FIXME: Search works with node granularity - number of matches within node is not calculated.
1027     InspectorNodeFinder finder(query, caseSensitive &amp;&amp; *caseSensitive);
1028 
1029     if (nodeIds) {
1030         for (auto&amp; nodeValue : *nodeIds) {
1031             if (!nodeValue) {
1032                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;
1033                 return;
1034             }
1035             int nodeId = 0;
1036             if (!nodeValue-&gt;asInteger(nodeId)) {
1037                 errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;
1038                 return;
1039             }
1040             Node* node = assertNode(errorString, nodeId);
1041             if (!node) {
1042                 // assertNode should have filled the errorString for us.
1043                 ASSERT(errorString.length());
1044                 return;
1045             }
1046             finder.performSearch(node);
1047         }
1048     } else {
1049         // There&#39;s no need to iterate the frames tree because
1050         // the search helper will go inside the frame owner elements.
1051         finder.performSearch(m_document.get());
1052     }
1053 
1054     *searchId = IdentifiersFactory::createIdentifier();
1055 
1056     auto&amp; resultsVector = m_searchResults.add(*searchId, Vector&lt;RefPtr&lt;Node&gt;&gt;()).iterator-&gt;value;
1057     for (auto&amp; result : finder.results())
1058         resultsVector.append(result);
1059 
1060     *resultCount = resultsVector.size();
1061 }
1062 
1063 void InspectorDOMAgent::getSearchResults(ErrorString&amp; errorString, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; nodeIds)
1064 {
1065     SearchResults::iterator it = m_searchResults.find(searchId);
1066     if (it == m_searchResults.end()) {
1067         errorString = &quot;Missing search result for given searchId&quot;_s;
1068         return;
1069     }
1070 
1071     int size = it-&gt;value.size();
1072     if (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt;= toIndex) {
1073         errorString = &quot;Invalid search result range for given fromIndex and toIndex&quot;_s;
1074         return;
1075     }
1076 
1077     nodeIds = JSON::ArrayOf&lt;int&gt;::create();
1078     for (int i = fromIndex; i &lt; toIndex; ++i)
1079         nodeIds-&gt;addItem(pushNodePathToFrontend((it-&gt;value)[i].get()));
1080 }
1081 
1082 void InspectorDOMAgent::discardSearchResults(ErrorString&amp;, const String&amp; searchId)
1083 {
1084     m_searchResults.remove(searchId);
1085 }
1086 
1087 bool InspectorDOMAgent::handleMousePress()
1088 {
1089     if (!m_searchingForNode)
1090         return false;
1091 
1092     if (Node* node = m_overlay-&gt;highlightedNode()) {
1093         inspect(node);
1094         return true;
1095     }
1096     return false;
1097 }
1098 
1099 bool InspectorDOMAgent::handleTouchEvent(Node&amp; node)
1100 {
1101     if (!m_searchingForNode)
1102         return false;
1103     if (m_inspectModeHighlightConfig) {
1104         m_overlay-&gt;highlightNode(&amp;node, *m_inspectModeHighlightConfig);
1105         inspect(&amp;node);
1106         return true;
1107     }
1108     return false;
1109 }
1110 
1111 void InspectorDOMAgent::inspect(Node* inspectedNode)
1112 {
1113     ErrorString ignored;
1114     RefPtr&lt;Node&gt; node = inspectedNode;
1115     setSearchingForNode(ignored, false, nullptr, false);
1116 
1117     if (node-&gt;nodeType() != Node::ELEMENT_NODE &amp;&amp; node-&gt;nodeType() != Node::DOCUMENT_NODE)
1118         node = node-&gt;parentNode();
1119     m_nodeToFocus = node;
1120 
1121     if (!m_nodeToFocus)
1122         return;
1123 
1124     focusNode();
1125 }
1126 
1127 void InspectorDOMAgent::focusNode()
1128 {
1129     if (!m_documentRequested)
1130         return;
1131 
1132     ASSERT(m_nodeToFocus);
1133 
1134     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1135     m_nodeToFocus = nullptr;
1136 
1137     Frame* frame = node-&gt;document().frame();
1138     if (!frame)
1139         return;
1140 
<a name="17" id="anc17"></a><span class="line-modified">1141     JSC::JSGlobalObject* scriptState = mainWorldExecState(frame);</span>
1142     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1143     if (injectedScript.hasNoValue())
1144         return;
1145 
1146     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1147 }
1148 
1149 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1150 {
1151     m_mousedOverNode = result.innerNode();
1152 
1153     if (!m_searchingForNode)
1154         return;
1155 
1156     highlightMousedOverNode();
1157 }
1158 
1159 void InspectorDOMAgent::highlightMousedOverNode()
1160 {
1161     Node* node = m_mousedOverNode.get();
1162     while (node &amp;&amp; node-&gt;nodeType() == Node::TEXT_NODE)
1163         node = node-&gt;parentNode();
1164     if (node &amp;&amp; m_inspectModeHighlightConfig)
1165         m_overlay-&gt;highlightNode(node, *m_inspectModeHighlightConfig);
1166 }
1167 
1168 void InspectorDOMAgent::setSearchingForNode(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightInspectorObject, bool showRulers)
1169 {
1170     if (m_searchingForNode == enabled)
1171         return;
1172 
1173     m_searchingForNode = enabled;
1174 
1175     m_overlay-&gt;setShowRulersDuringElementSelection(m_searchingForNode &amp;&amp; showRulers);
1176 
1177     if (m_searchingForNode) {
1178         m_inspectModeHighlightConfig = highlightConfigFromInspectorObject(errorString, highlightInspectorObject);
1179         if (!m_inspectModeHighlightConfig)
1180             return;
1181         highlightMousedOverNode();
1182     } else
1183         hideHighlight(errorString);
1184 
1185     m_overlay-&gt;didSetSearchingForNode(m_searchingForNode);
1186 
1187     if (InspectorClient* client = m_inspectedPage.inspectorController().inspectorClient())
1188         client-&gt;elementSelectionChanged(m_searchingForNode);
1189 }
1190 
1191 std::unique_ptr&lt;HighlightConfig&gt; InspectorDOMAgent::highlightConfigFromInspectorObject(ErrorString&amp; errorString, const JSON::Object* highlightInspectorObject)
1192 {
1193     if (!highlightInspectorObject) {
1194         errorString = &quot;Internal error: highlight configuration parameter is missing&quot;_s;
1195         return nullptr;
1196     }
1197 
1198     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();
1199     bool showInfo = false; // Default: false (do not show a tooltip).
1200     highlightInspectorObject-&gt;getBoolean(&quot;showInfo&quot;, showInfo);
1201     highlightConfig-&gt;showInfo = showInfo;
1202     highlightConfig-&gt;content = parseConfigColor(&quot;contentColor&quot;, highlightInspectorObject);
1203     highlightConfig-&gt;contentOutline = parseConfigColor(&quot;contentOutlineColor&quot;, highlightInspectorObject);
1204     highlightConfig-&gt;padding = parseConfigColor(&quot;paddingColor&quot;, highlightInspectorObject);
1205     highlightConfig-&gt;border = parseConfigColor(&quot;borderColor&quot;, highlightInspectorObject);
1206     highlightConfig-&gt;margin = parseConfigColor(&quot;marginColor&quot;, highlightInspectorObject);
1207     return highlightConfig;
1208 }
1209 
1210 void InspectorDOMAgent::setInspectModeEnabled(ErrorString&amp; errorString, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers)
1211 {
1212     setSearchingForNode(errorString, enabled, highlightConfig ? highlightConfig : nullptr, showRulers &amp;&amp; *showRulers);
1213 }
1214 
1215 void InspectorDOMAgent::highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1216 {
1217     auto quad = makeUnique&lt;FloatQuad&gt;(FloatRect(x, y, width, height));
1218     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1219 }
1220 
1221 void InspectorDOMAgent::highlightQuad(ErrorString&amp; errorString, const JSON::Array&amp; quadArray, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1222 {
1223     auto quad = makeUnique&lt;FloatQuad&gt;();
1224     if (!parseQuad(quadArray, quad.get())) {
1225         errorString = &quot;Unexpected invalid quadArray&quot;_s;
1226         return;
1227     }
1228     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1229 }
1230 
1231 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1232 {
1233     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();
1234     highlightConfig-&gt;content = parseColor(color);
1235     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1236     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1237     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1238 }
1239 
1240 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1241 {
<a name="18" id="anc18"></a><span class="line-added">1242     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);</span>
<span class="line-added">1243     if (!highlightConfig)</span>
<span class="line-added">1244         return;</span>
<span class="line-added">1245 </span>
1246     RefPtr&lt;Document&gt; document;
1247 
1248     if (frameId) {
1249         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
1250         if (!pageAgent) {
1251             errorString = &quot;Page domain must be enabled&quot;_s;
1252             return;
1253         }
1254 
1255         auto* frame = pageAgent-&gt;assertFrame(errorString, *frameId);
1256         if (!frame)
1257             return;
1258 
1259         document = frame-&gt;document();
1260     } else
1261         document = m_document;
1262 
1263     if (!document) {
1264         errorString = &quot;Missing document of frame for given frameId&quot;_s;
1265         return;
1266     }
1267 
<a name="19" id="anc19"></a><span class="line-modified">1268     CSSParser parser(*document);</span>
<span class="line-modified">1269     CSSSelectorList selectorList;</span>
<span class="line-modified">1270     parser.parseSelector(selectorString, selectorList);</span>



1271 
<a name="20" id="anc20"></a><span class="line-modified">1272     SelectorChecker selectorChecker(*document);</span>


1273 
<a name="21" id="anc21"></a><span class="line-modified">1274     Vector&lt;Ref&lt;Node&gt;&gt; nodeList;</span>
<span class="line-added">1275     HashSet&lt;Node*&gt; seenNodes;</span>
<span class="line-added">1276 </span>
<span class="line-added">1277     for (auto&amp; descendant : composedTreeDescendants(*document)) {</span>
<span class="line-added">1278         if (!is&lt;Element&gt;(descendant))</span>
<span class="line-added">1279             continue;</span>
<span class="line-added">1280 </span>
<span class="line-added">1281         auto&amp; descendantElement = downcast&lt;Element&gt;(descendant);</span>
<span class="line-added">1282 </span>
<span class="line-added">1283         auto isInUserAgentShadowTree = descendantElement.isInUserAgentShadowTree();</span>
<span class="line-added">1284         auto pseudoId = descendantElement.pseudoId();</span>
<span class="line-added">1285         auto&amp; pseudo = descendantElement.pseudo();</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         for (const auto* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector)) {</span>
<span class="line-added">1288             if (isInUserAgentShadowTree &amp;&amp; (selector-&gt;match() != CSSSelector::PseudoElement || selector-&gt;value() != pseudo))</span>
<span class="line-added">1289                 continue;</span>
<span class="line-added">1290 </span>
<span class="line-added">1291             SelectorChecker::CheckingContext context(SelectorChecker::Mode::ResolvingStyle);</span>
<span class="line-added">1292             context.pseudoId = pseudoId;</span>
<span class="line-added">1293 </span>
<span class="line-added">1294             unsigned ignoredSpecificity;</span>
<span class="line-added">1295             if (selectorChecker.match(*selector, descendantElement, context, ignoredSpecificity)) {</span>
<span class="line-added">1296                 if (seenNodes.add(&amp;descendantElement))</span>
<span class="line-added">1297                     nodeList.append(descendantElement);</span>
<span class="line-added">1298             }</span>
<span class="line-added">1299 </span>
<span class="line-added">1300             if (context.pseudoIDSet) {</span>
<span class="line-added">1301                 auto pseudoIDs = PseudoIdSet::fromMask(context.pseudoIDSet.data());</span>
<span class="line-added">1302 </span>
<span class="line-added">1303                 if (pseudoIDs.has(PseudoId::Before)) {</span>
<span class="line-added">1304                     pseudoIDs.remove(PseudoId::Before);</span>
<span class="line-added">1305                     if (auto* beforePseudoElement = descendantElement.beforePseudoElement()) {</span>
<span class="line-added">1306                         if (seenNodes.add(beforePseudoElement))</span>
<span class="line-added">1307                             nodeList.append(*beforePseudoElement);</span>
<span class="line-added">1308                     }</span>
<span class="line-added">1309                 }</span>
<span class="line-added">1310 </span>
<span class="line-added">1311                 if (pseudoIDs.has(PseudoId::After)) {</span>
<span class="line-added">1312                     pseudoIDs.remove(PseudoId::After);</span>
<span class="line-added">1313                     if (auto* afterPseudoElement = descendantElement.afterPseudoElement()) {</span>
<span class="line-added">1314                         if (seenNodes.add(afterPseudoElement))</span>
<span class="line-added">1315                             nodeList.append(*afterPseudoElement);</span>
<span class="line-added">1316                     }</span>
<span class="line-added">1317                 }</span>
<span class="line-added">1318 </span>
<span class="line-added">1319                 if (pseudoIDs) {</span>
<span class="line-added">1320                     if (seenNodes.add(&amp;descendantElement))</span>
<span class="line-added">1321                         nodeList.append(descendantElement);</span>
<span class="line-added">1322                 }</span>
<span class="line-added">1323             }</span>
<span class="line-added">1324         }</span>
<span class="line-added">1325     }</span>
<span class="line-added">1326 </span>
<span class="line-added">1327     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodeList)), *highlightConfig);</span>
1328 }
1329 
1330 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1331 {
1332     Node* node = nullptr;
1333     if (nodeId)
1334         node = assertNode(errorString, *nodeId);
1335     else if (objectId) {
1336         node = nodeForObjectId(*objectId);
1337         if (!node)
1338             errorString = &quot;Missing node for given objectId&quot;_s;
1339     } else
1340         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1341 
1342     if (!node)
1343         return;
1344 
1345     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1346     if (!highlightConfig)
1347         return;
1348 
1349     m_overlay-&gt;highlightNode(node, *highlightConfig);
1350 }
1351 
1352 void InspectorDOMAgent::highlightNodeList(ErrorString&amp; errorString, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightInspectorObject)
1353 {
1354     Vector&lt;Ref&lt;Node&gt;&gt; nodes;
1355     for (auto&amp; nodeValue : nodeIds) {
1356         if (!nodeValue) {
1357             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;
1358             return;
1359         }
1360 
1361         int nodeId = 0;
1362         if (!nodeValue-&gt;asInteger(nodeId)) {
1363             errorString = &quot;Unexpected non-integer item in given nodeIds&quot;_s;
1364             return;
1365         }
1366 
1367         // In the case that a node is removed in the time between when highlightNodeList is invoked
1368         // by the frontend and it is executed by the backend, we should still attempt to highlight
1369         // as many nodes as possible. As such, we should ignore any errors generated when attempting
1370         // to get a Node from a given nodeId.
1371         ErrorString ignored;
1372         Node* node = assertNode(ignored, nodeId);
1373         if (!node)
1374             continue;
1375 
1376         nodes.append(*node);
1377     }
1378 
1379     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1380     if (!highlightConfig)
1381         return;
1382 
1383     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodes)), *highlightConfig);
1384 }
1385 
1386 void InspectorDOMAgent::highlightFrame(ErrorString&amp; errorString, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor)
1387 {
1388     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
1389     if (!pageAgent) {
1390         errorString = &quot;Page domain must be enabled&quot;_s;
1391         return;
1392     }
1393 
1394     auto* frame = pageAgent-&gt;assertFrame(errorString, frameId);
1395     if (!frame)
1396         return;
1397 
1398     if (frame-&gt;ownerElement()) {
1399         auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();
1400         highlightConfig-&gt;showInfo = true; // Always show tooltips for frames.
1401         highlightConfig-&gt;content = parseColor(color);
1402         highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1403         m_overlay-&gt;highlightNode(frame-&gt;ownerElement(), *highlightConfig);
1404     }
1405 }
1406 
1407 void InspectorDOMAgent::hideHighlight(ErrorString&amp;)
1408 {
1409     m_overlay-&gt;hideHighlight();
1410 }
1411 
1412 void InspectorDOMAgent::moveTo(ErrorString&amp; errorString, int nodeId, int targetElementId, const int* anchorNodeId, int* newNodeId)
1413 {
1414     Node* node = assertEditableNode(errorString, nodeId);
1415     if (!node)
1416         return;
1417 
1418     Element* targetElement = assertEditableElement(errorString, targetElementId);
1419     if (!targetElement)
1420         return;
1421 
1422     Node* anchorNode = 0;
1423     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1424         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1425         if (!anchorNode)
1426             return;
1427         if (anchorNode-&gt;parentNode() != targetElement) {
1428             errorString = &quot;Given anchorNodeId must be a child of given targetElementId&quot;_s;
1429             return;
1430         }
1431     }
1432 
1433     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1434         return;
1435 
<a name="22" id="anc22"></a><span class="line-modified">1436     *newNodeId = pushNodePathToFrontend(errorString, node);</span>
1437 }
1438 
1439 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1440 {
1441     auto result = m_history-&gt;undo();
1442     if (result.hasException())
1443         errorString = toErrorString(result.releaseException());
1444 }
1445 
1446 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1447 {
1448     auto result = m_history-&gt;redo();
1449     if (result.hasException())
1450         errorString = toErrorString(result.releaseException());
1451 }
1452 
1453 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1454 {
1455     m_history-&gt;markUndoableState();
1456 }
1457 
1458 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1459 {
1460     Element* element = assertElement(errorString, nodeId);
1461     if (!element)
1462         return;
1463     if (!element-&gt;isFocusable()) {
1464         errorString = &quot;Element for given nodeId is not focusable&quot;_s;
1465         return;
1466     }
1467     element-&gt;focus();
1468 }
1469 
1470 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1471 {
1472     Node* node = assertNode(errorString, nodeId);
1473     if (!node)
1474         return;
1475 
<a name="23" id="anc23"></a><span class="line-modified">1476     if (node-&gt;isInUserAgentShadowTree() &amp;&amp; !m_allowEditingUserAgentShadowTrees) {</span>
1477         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;
1478         return;
1479     }
1480 
1481     m_inspectedNode = node;
1482 
1483     if (auto&amp; commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())
1484         commandLineAPIHost-&gt;addInspectedObject(makeUnique&lt;InspectableNode&gt;(node));
1485 
1486     m_suppressEventListenerChangedEvent = false;
1487 }
1488 
1489 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1490 {
1491     String objectGroupName = objectGroup ? *objectGroup : emptyString();
1492     Node* node = assertNode(errorString, nodeId);
1493     if (!node)
1494         return;
1495     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1496     if (!object) {
1497         errorString = &quot;Missing injected script for given nodeId&quot;_s;
1498         return;
1499     }
1500     result = object;
1501 }
1502 
1503 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1504 {
1505     Element* element = assertElement(errorString, nodeId);
1506     if (!element)
1507         return;
1508 
1509     result = buildArrayForElementAttributes(element);
1510 }
1511 
<a name="24" id="anc24"></a><span class="line-modified">1512 void InspectorDOMAgent::requestNode(ErrorString&amp; errorString, const String&amp; objectId, int* nodeId)</span>
1513 {
1514     Node* node = nodeForObjectId(objectId);
1515     if (node)
<a name="25" id="anc25"></a><span class="line-modified">1516         *nodeId = pushNodePathToFrontend(errorString, node);</span>
1517     else
1518         *nodeId = 0;
1519 }
1520 
1521 String InspectorDOMAgent::documentURLString(Document* document)
1522 {
1523     if (!document || document-&gt;url().isNull())
1524         return emptyString();
1525     return document-&gt;url().string();
1526 }
1527 
1528 static String documentBaseURLString(Document* document)
1529 {
1530     return document-&gt;completeURL(emptyString()).string();
1531 }
1532 
1533 static bool pseudoElementType(PseudoId pseudoId, Inspector::Protocol::DOM::PseudoType* type)
1534 {
1535     switch (pseudoId) {
1536     case PseudoId::Before:
1537         *type = Inspector::Protocol::DOM::PseudoType::Before;
1538         return true;
1539     case PseudoId::After:
1540         *type = Inspector::Protocol::DOM::PseudoType::After;
1541         return true;
1542     default:
1543         return false;
1544     }
1545 }
1546 
1547 static Inspector::Protocol::DOM::ShadowRootType shadowRootType(ShadowRootMode mode)
1548 {
1549     switch (mode) {
1550     case ShadowRootMode::UserAgent:
1551         return Inspector::Protocol::DOM::ShadowRootType::UserAgent;
1552     case ShadowRootMode::Closed:
1553         return Inspector::Protocol::DOM::ShadowRootType::Closed;
1554     case ShadowRootMode::Open:
1555         return Inspector::Protocol::DOM::ShadowRootType::Open;
1556     }
1557 
1558     ASSERT_NOT_REACHED();
1559     return Inspector::Protocol::DOM::ShadowRootType::UserAgent;
1560 }
1561 
1562 static Inspector::Protocol::DOM::CustomElementState customElementState(const Element&amp; element)
1563 {
1564     if (element.isDefinedCustomElement())
1565         return Inspector::Protocol::DOM::CustomElementState::Custom;
1566     if (element.isFailedCustomElement())
1567         return Inspector::Protocol::DOM::CustomElementState::Failed;
1568     if (element.isUndefinedCustomElement() || element.isCustomElementUpgradeCandidate())
1569         return Inspector::Protocol::DOM::CustomElementState::Waiting;
1570     return Inspector::Protocol::DOM::CustomElementState::Builtin;
1571 }
1572 
1573 static String computeContentSecurityPolicySHA256Hash(const Element&amp; element)
1574 {
1575     // FIXME: Compute the digest with respect to the raw bytes received from the page.
1576     // See &lt;https://bugs.webkit.org/show_bug.cgi?id=155184&gt;.
1577     TextEncoding documentEncoding = element.document().textEncoding();
1578     const TextEncoding&amp; encodingToUse = documentEncoding.isValid() ? documentEncoding : UTF8Encoding();
1579     auto content = encodingToUse.encode(TextNodeTraversal::contentsAsString(element), UnencodableHandling::Entities);
1580     auto cryptoDigest = PAL::CryptoDigest::create(PAL::CryptoDigest::Algorithm::SHA_256);
1581     cryptoDigest-&gt;addBytes(content.data(), content.size());
1582     auto digest = cryptoDigest-&gt;computeHash();
1583     return makeString(&quot;sha256-&quot;, base64Encode(digest.data(), digest.size()));
1584 }
1585 
1586 Ref&lt;Inspector::Protocol::DOM::Node&gt; InspectorDOMAgent::buildObjectForNode(Node* node, int depth, NodeToIdMap* nodesMap)
1587 {
1588     int id = bind(node, nodesMap);
1589     String nodeName;
1590     String localName;
1591     String nodeValue;
1592 
1593     switch (node-&gt;nodeType()) {
1594     case Node::PROCESSING_INSTRUCTION_NODE:
1595         nodeName = node-&gt;nodeName();
1596         localName = node-&gt;localName();
1597         FALLTHROUGH;
1598     case Node::TEXT_NODE:
1599     case Node::COMMENT_NODE:
1600     case Node::CDATA_SECTION_NODE:
1601         nodeValue = node-&gt;nodeValue();
1602         if (nodeValue.length() &gt; maxTextSize) {
1603             nodeValue = nodeValue.left(maxTextSize);
1604             nodeValue.append(ellipsisUChar);
1605         }
1606         break;
1607     case Node::ATTRIBUTE_NODE:
1608         localName = node-&gt;localName();
1609         break;
1610     case Node::DOCUMENT_FRAGMENT_NODE:
1611     case Node::DOCUMENT_NODE:
1612     case Node::ELEMENT_NODE:
1613     default:
1614         nodeName = node-&gt;nodeName();
1615         localName = node-&gt;localName();
1616         break;
1617     }
1618 
1619     auto value = Inspector::Protocol::DOM::Node::create()
1620         .setNodeId(id)
1621         .setNodeType(static_cast&lt;int&gt;(node-&gt;nodeType()))
1622         .setNodeName(nodeName)
1623         .setLocalName(localName)
1624         .setNodeValue(nodeValue)
1625         .release();
1626 
1627     if (node-&gt;isContainerNode()) {
1628         int nodeCount = innerChildNodeCount(node);
1629         value-&gt;setChildNodeCount(nodeCount);
1630         Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; children = buildArrayForContainerChildren(node, depth, nodesMap);
1631         if (children-&gt;length() &gt; 0)
1632             value-&gt;setChildren(WTFMove(children));
1633     }
1634 
1635     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
1636     if (pageAgent) {
1637         if (auto* frameView = node-&gt;document().view())
1638             value-&gt;setFrameId(pageAgent-&gt;frameId(&amp;frameView-&gt;frame()));
1639     }
1640 
1641     if (is&lt;Element&gt;(*node)) {
1642         Element&amp; element = downcast&lt;Element&gt;(*node);
1643         value-&gt;setAttributes(buildArrayForElementAttributes(&amp;element));
1644         if (is&lt;HTMLFrameOwnerElement&gt;(element)) {
1645             if (auto* document = downcast&lt;HTMLFrameOwnerElement&gt;(element).contentDocument())
1646                 value-&gt;setContentDocument(buildObjectForNode(document, 0, nodesMap));
1647         }
1648 
1649         if (ShadowRoot* root = element.shadowRoot()) {
1650             auto shadowRoots = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1651             shadowRoots-&gt;addItem(buildObjectForNode(root, 0, nodesMap));
1652             value-&gt;setShadowRoots(WTFMove(shadowRoots));
1653         }
1654 
1655         if (is&lt;HTMLTemplateElement&gt;(element))
1656             value-&gt;setTemplateContent(buildObjectForNode(&amp;downcast&lt;HTMLTemplateElement&gt;(element).content(), 0, nodesMap));
1657 
1658         if (is&lt;HTMLStyleElement&gt;(element) || (is&lt;HTMLScriptElement&gt;(element) &amp;&amp; !element.hasAttributeWithoutSynchronization(HTMLNames::srcAttr)))
1659             value-&gt;setContentSecurityPolicyHash(computeContentSecurityPolicySHA256Hash(element));
1660 
1661         auto state = customElementState(element);
1662         if (state != Inspector::Protocol::DOM::CustomElementState::Builtin)
1663             value-&gt;setCustomElementState(state);
1664 
1665         if (element.pseudoId() != PseudoId::None) {
1666             Inspector::Protocol::DOM::PseudoType pseudoType;
1667             if (pseudoElementType(element.pseudoId(), &amp;pseudoType))
1668                 value-&gt;setPseudoType(pseudoType);
1669         } else {
1670             if (auto pseudoElements = buildArrayForPseudoElements(element, nodesMap))
1671                 value-&gt;setPseudoElements(WTFMove(pseudoElements));
1672         }
1673     } else if (is&lt;Document&gt;(*node)) {
1674         Document&amp; document = downcast&lt;Document&gt;(*node);
1675         if (pageAgent)
1676             value-&gt;setFrameId(pageAgent-&gt;frameId(document.frame()));
1677         value-&gt;setDocumentURL(documentURLString(&amp;document));
1678         value-&gt;setBaseURL(documentBaseURLString(&amp;document));
1679         value-&gt;setXmlVersion(document.xmlVersion());
1680     } else if (is&lt;DocumentType&gt;(*node)) {
1681         DocumentType&amp; docType = downcast&lt;DocumentType&gt;(*node);
1682         value-&gt;setPublicId(docType.publicId());
1683         value-&gt;setSystemId(docType.systemId());
1684     } else if (is&lt;Attr&gt;(*node)) {
1685         Attr&amp; attribute = downcast&lt;Attr&gt;(*node);
1686         value-&gt;setName(attribute.name());
1687         value-&gt;setValue(attribute.value());
1688     } else if (is&lt;ShadowRoot&gt;(*node)) {
1689         ShadowRoot&amp; shadowRoot = downcast&lt;ShadowRoot&gt;(*node);
1690         value-&gt;setShadowRootType(shadowRootType(shadowRoot.mode()));
1691     }
1692 
1693     return value;
1694 }
1695 
1696 Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; InspectorDOMAgent::buildArrayForElementAttributes(Element* element)
1697 {
1698     auto attributesValue = JSON::ArrayOf&lt;String&gt;::create();
1699     // Go through all attributes and serialize them.
1700     if (!element-&gt;hasAttributes())
1701         return attributesValue;
1702     for (const Attribute&amp; attribute : element-&gt;attributesIterator()) {
1703         // Add attribute pair
1704         attributesValue-&gt;addItem(attribute.name().toString());
1705         attributesValue-&gt;addItem(attribute.value());
1706     }
1707     return attributesValue;
1708 }
1709 
1710 Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForContainerChildren(Node* container, int depth, NodeToIdMap* nodesMap)
1711 {
1712     auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1713     if (depth == 0) {
1714         // Special-case the only text child - pretend that container&#39;s children have been requested.
1715         Node* firstChild = container-&gt;firstChild();
1716         if (firstChild &amp;&amp; firstChild-&gt;nodeType() == Node::TEXT_NODE &amp;&amp; !firstChild-&gt;nextSibling()) {
1717             children-&gt;addItem(buildObjectForNode(firstChild, 0, nodesMap));
1718             m_childrenRequested.add(bind(container, nodesMap));
1719         }
1720         return children;
1721     }
1722 
1723     Node* child = innerFirstChild(container);
1724     depth--;
1725     m_childrenRequested.add(bind(container, nodesMap));
1726 
1727     while (child) {
1728         children-&gt;addItem(buildObjectForNode(child, depth, nodesMap));
1729         child = innerNextSibling(child);
1730     }
1731     return children;
1732 }
1733 
1734 RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; InspectorDOMAgent::buildArrayForPseudoElements(const Element&amp; element, NodeToIdMap* nodesMap)
1735 {
1736     PseudoElement* beforeElement = element.beforePseudoElement();
1737     PseudoElement* afterElement = element.afterPseudoElement();
1738     if (!beforeElement &amp;&amp; !afterElement)
1739         return nullptr;
1740 
1741     auto pseudoElements = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
1742     if (beforeElement)
1743         pseudoElements-&gt;addItem(buildObjectForNode(beforeElement, 0, nodesMap));
1744     if (afterElement)
1745         pseudoElements-&gt;addItem(buildObjectForNode(afterElement, 0, nodesMap));
1746     return pseudoElements;
1747 }
1748 
1749 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, EventTarget&amp; eventTarget, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint)
1750 {
1751     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1752 
1753     String handlerName;
1754     int lineNumber = 0;
1755     int columnNumber = 0;
1756     String scriptID;
1757     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1758         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1759 
1760         Document* document = nullptr;
1761         if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {
1762             if (is&lt;Document&gt;(scriptExecutionContext))
1763                 document = downcast&lt;Document&gt;(scriptExecutionContext);
1764         } else if (is&lt;Node&gt;(eventTarget))
1765             document = &amp;downcast&lt;Node&gt;(eventTarget).document();
1766 
1767         JSC::JSObject* handlerObject = nullptr;
<a name="26" id="anc26"></a><span class="line-modified">1768         JSC::JSGlobalObject* exec = nullptr;</span>
1769 
1770         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1771 
1772         if (document) {
1773             handlerObject = scriptListener.jsFunction(*document);
1774             exec = execStateFromNode(scriptListener.isolatedWorld(), document);
1775         }
1776 
1777         if (handlerObject &amp;&amp; exec) {
1778             JSC::VM&amp; vm = exec-&gt;vm();
1779             JSC::JSFunction* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handlerObject);
1780 
1781             if (!handlerFunction) {
1782                 auto scope = DECLARE_CATCH_SCOPE(vm);
1783 
1784                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
1785                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(vm, &quot;handleEvent&quot;));
1786 
1787                 if (UNLIKELY(scope.exception()))
1788                     scope.clearException();
1789 
1790                 if (handleEventValue)
1791                     handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handleEventValue);
1792             }
1793 
1794             if (handlerFunction &amp;&amp; !handlerFunction-&gt;isHostOrBuiltinFunction()) {
1795                 // If the listener implements the EventListener interface, use the class name instead of
1796                 // &quot;handleEvent&quot;, unless it is a plain object.
1797                 if (handlerFunction != handlerObject)
1798                     handlerName = JSC::JSObject::calculatedClassName(handlerObject);
1799                 if (handlerName.isEmpty() || handlerName == &quot;Object&quot;_s)
1800                     handlerName = handlerFunction-&gt;calculatedDisplayName(vm);
1801 
1802                 if (auto executable = handlerFunction-&gt;jsExecutable()) {
1803                     lineNumber = executable-&gt;firstLine() - 1;
1804                     columnNumber = executable-&gt;startColumn() - 1;
1805                     scriptID = executable-&gt;sourceID() == JSC::SourceProvider::nullID ? emptyString() : String::number(executable-&gt;sourceID());
1806                 }
1807             }
1808         }
1809     }
1810 
1811     auto value = Inspector::Protocol::DOM::EventListener::create()
1812         .setEventListenerId(identifier)
1813         .setType(eventType)
1814         .setUseCapture(registeredEventListener.useCapture())
1815         .setIsAttribute(eventListener-&gt;isAttribute())
1816         .release();
1817     if (is&lt;Node&gt;(eventTarget))
1818         value-&gt;setNodeId(pushNodePathToFrontend(&amp;downcast&lt;Node&gt;(eventTarget)));
1819     else if (is&lt;DOMWindow&gt;(eventTarget))
1820         value-&gt;setOnWindow(true);
1821     if (!scriptID.isNull()) {
1822         auto location = Inspector::Protocol::Debugger::Location::create()
1823             .setScriptId(scriptID)
1824             .setLineNumber(lineNumber)
1825             .release();
1826         location-&gt;setColumnNumber(columnNumber);
1827         value-&gt;setLocation(WTFMove(location));
1828     }
1829     if (!handlerName.isEmpty())
1830         value-&gt;setHandlerName(handlerName);
1831     if (registeredEventListener.isPassive())
1832         value-&gt;setPassive(true);
1833     if (registeredEventListener.isOnce())
1834         value-&gt;setOnce(true);
1835     if (disabled)
1836         value-&gt;setDisabled(disabled);
1837     if (hasBreakpoint)
1838         value-&gt;setHasBreakpoint(hasBreakpoint);
1839     return value;
1840 }
1841 
<a name="27" id="anc27"></a><span class="line-modified">1842 void InspectorDOMAgent::processAccessibilityChildren(AXCoreObject&amp; axObject, JSON::ArrayOf&lt;int&gt;&amp; childNodeIds)</span>
1843 {
1844     const auto&amp; children = axObject.children();
1845     if (!children.size())
1846         return;
1847 
1848     for (const auto&amp; childObject : children) {
1849         if (Node* childNode = childObject-&gt;node())
1850             childNodeIds.addItem(pushNodePathToFrontend(childNode));
1851         else
1852             processAccessibilityChildren(*childObject, childNodeIds);
1853     }
1854 }
1855 
1856 RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; InspectorDOMAgent::buildObjectForAccessibilityProperties(Node* node)
1857 {
1858     ASSERT(node);
1859     if (!node)
1860         return nullptr;
1861 
1862     if (!WebCore::AXObjectCache::accessibilityEnabled())
1863         WebCore::AXObjectCache::enableAccessibility();
1864 
1865     Node* activeDescendantNode = nullptr;
1866     bool busy = false;
1867     auto checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::False;
1868     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; childNodeIds;
1869     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; controlledNodeIds;
1870     auto currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::False;
1871     bool exists = false;
1872     bool expanded = false;
1873     bool disabled = false;
1874     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; flowedNodeIds;
1875     bool focused = false;
1876     bool ignored = true;
1877     bool ignoredByDefault = false;
1878     auto invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False;
1879     bool hidden = false;
1880     String label;
1881     bool liveRegionAtomic = false;
1882     RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt; liveRegionRelevant;
1883     auto liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Off;
1884     Node* mouseEventNode = nullptr;
1885     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; ownedNodeIds;
1886     Node* parentNode = nullptr;
1887     bool pressed = false;
1888     bool readonly = false;
1889     bool required = false;
1890     String role;
1891     bool selected = false;
1892     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; selectedChildNodeIds;
1893     bool supportsChecked = false;
1894     bool supportsExpanded = false;
1895     bool supportsLiveRegion = false;
1896     bool supportsPressed = false;
1897     bool supportsRequired = false;
1898     bool supportsFocused = false;
1899     bool isPopupButton = false;
1900     int headingLevel = 0;
1901     unsigned hierarchicalLevel = 0;
1902     unsigned level = 0;
1903 
1904     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {
<a name="28" id="anc28"></a><span class="line-modified">1905         if (AXCoreObject* axObject = axObjectCache-&gt;getOrCreate(node)) {</span>
1906 
<a name="29" id="anc29"></a><span class="line-modified">1907             if (AXCoreObject* activeDescendant = axObject-&gt;activeDescendant())</span>
1908                 activeDescendantNode = activeDescendant-&gt;node();
1909 
1910             // An AX object is &quot;busy&quot; if it or any ancestor has aria-busy=&quot;true&quot; set.
<a name="30" id="anc30"></a><span class="line-modified">1911             AXCoreObject* current = axObject;</span>
1912             while (!busy &amp;&amp; current) {
1913                 busy = current-&gt;isBusy();
1914                 current = current-&gt;parentObject();
1915             }
1916 
1917             supportsChecked = axObject-&gt;supportsChecked();
1918             if (supportsChecked) {
1919                 AccessibilityButtonState checkValue = axObject-&gt;checkboxOrRadioValue(); // Element using aria-checked.
1920                 if (checkValue == AccessibilityButtonState::On)
1921                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1922                 else if (checkValue == AccessibilityButtonState::Mixed)
1923                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::Mixed;
1924                 else if (axObject-&gt;isChecked()) // Native checkbox.
1925                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1926             }
1927 
1928             if (!axObject-&gt;children().isEmpty()) {
1929                 childNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1930                 processAccessibilityChildren(*axObject, *childNodeIds);
1931             }
1932 
1933             Vector&lt;Element*&gt; controlledElements;
1934             axObject-&gt;elementsFromAttribute(controlledElements, aria_controlsAttr);
1935             if (controlledElements.size()) {
1936                 controlledNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1937                 for (Element* controlledElement : controlledElements)
1938                     controlledNodeIds-&gt;addItem(pushNodePathToFrontend(controlledElement));
1939             }
1940 
1941             switch (axObject-&gt;currentState()) {
1942             case AccessibilityCurrentState::False:
1943                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::False;
1944                 break;
1945             case AccessibilityCurrentState::Page:
1946                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Page;
1947                 break;
1948             case AccessibilityCurrentState::Step:
1949                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Step;
1950                 break;
1951             case AccessibilityCurrentState::Location:
1952                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Location;
1953                 break;
1954             case AccessibilityCurrentState::Date:
1955                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Date;
1956                 break;
1957             case AccessibilityCurrentState::Time:
1958                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::Time;
1959                 break;
1960             case AccessibilityCurrentState::True:
1961                 currentState = Inspector::Protocol::DOM::AccessibilityProperties::Current::True;
1962                 break;
1963             }
1964 
1965             disabled = !axObject-&gt;isEnabled();
1966             exists = true;
1967 
1968             supportsExpanded = axObject-&gt;supportsExpanded();
1969             if (supportsExpanded)
1970                 expanded = axObject-&gt;isExpanded();
1971 
1972             Vector&lt;Element*&gt; flowedElements;
1973             axObject-&gt;elementsFromAttribute(flowedElements, aria_flowtoAttr);
1974             if (flowedElements.size()) {
1975                 flowedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1976                 for (Element* flowedElement : flowedElements)
1977                     flowedNodeIds-&gt;addItem(pushNodePathToFrontend(flowedElement));
1978             }
1979 
1980             if (is&lt;Element&gt;(*node)) {
1981                 supportsFocused = axObject-&gt;canSetFocusAttribute();
1982                 if (supportsFocused)
1983                     focused = axObject-&gt;isFocused();
1984             }
1985 
1986             ignored = axObject-&gt;accessibilityIsIgnored();
1987             ignoredByDefault = axObject-&gt;accessibilityIsIgnoredByDefault();
1988 
1989             String invalidValue = axObject-&gt;invalidStatus();
1990             if (invalidValue == &quot;false&quot;)
1991                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False;
1992             else if (invalidValue == &quot;grammar&quot;)
1993                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Grammar;
1994             else if (invalidValue == &quot;spelling&quot;)
1995                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::Spelling;
1996             else // Future versions of ARIA may allow additional truthy values. Ex. format, order, or size.
1997                 invalid = Inspector::Protocol::DOM::AccessibilityProperties::Invalid::True;
1998 
1999             if (axObject-&gt;isAXHidden() || axObject-&gt;isDOMHidden())
2000                 hidden = true;
2001 
2002             label = axObject-&gt;computedLabel();
2003 
2004             if (axObject-&gt;supportsLiveRegion()) {
2005                 supportsLiveRegion = true;
2006                 liveRegionAtomic = axObject-&gt;liveRegionAtomic();
2007 
2008                 String ariaRelevantAttrValue = axObject-&gt;liveRegionRelevant();
2009                 if (!ariaRelevantAttrValue.isEmpty()) {
2010                     // FIXME: Pass enum values rather than strings once unblocked. http://webkit.org/b/133711
2011                     String ariaRelevantAdditions = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Additions);
2012                     String ariaRelevantRemovals = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Removals);
2013                     String ariaRelevantText = Inspector::Protocol::InspectorHelpers::getEnumConstantValue(Inspector::Protocol::DOM::LiveRegionRelevant::Text);
2014                     liveRegionRelevant = JSON::ArrayOf&lt;String&gt;::create();
2015                     const SpaceSplitString&amp; values = SpaceSplitString(ariaRelevantAttrValue, true);
2016                     // @aria-relevant=&quot;all&quot; is exposed as [&quot;additions&quot;,&quot;removals&quot;,&quot;text&quot;], in order.
2017                     // This order is controlled in WebCore and expected in WebInspectorUI.
2018                     if (values.contains(&quot;all&quot;)) {
2019                         liveRegionRelevant-&gt;addItem(ariaRelevantAdditions);
2020                         liveRegionRelevant-&gt;addItem(ariaRelevantRemovals);
2021                         liveRegionRelevant-&gt;addItem(ariaRelevantText);
2022                     } else {
2023                         if (values.contains(ariaRelevantAdditions))
2024                             liveRegionRelevant-&gt;addItem(ariaRelevantAdditions);
2025                         if (values.contains(ariaRelevantRemovals))
2026                             liveRegionRelevant-&gt;addItem(ariaRelevantRemovals);
2027                         if (values.contains(ariaRelevantText))
2028                             liveRegionRelevant-&gt;addItem(ariaRelevantText);
2029                     }
2030                 }
2031 
2032                 String ariaLive = axObject-&gt;liveRegionStatus();
2033                 if (ariaLive == &quot;assertive&quot;)
2034                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Assertive;
2035                 else if (ariaLive == &quot;polite&quot;)
2036                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Polite;
2037             }
2038 
2039             if (is&lt;AccessibilityNodeObject&gt;(*axObject))
2040                 mouseEventNode = downcast&lt;AccessibilityNodeObject&gt;(*axObject).mouseButtonListener(MouseButtonListenerResultFilter::IncludeBodyElement);
2041 
2042             if (axObject-&gt;supportsARIAOwns()) {
2043                 Vector&lt;Element*&gt; ownedElements;
2044                 axObject-&gt;elementsFromAttribute(ownedElements, aria_ownsAttr);
2045                 if (ownedElements.size()) {
2046                     ownedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
2047                     for (Element* ownedElement : ownedElements)
2048                         ownedNodeIds-&gt;addItem(pushNodePathToFrontend(ownedElement));
2049                 }
2050             }
2051 
<a name="31" id="anc31"></a><span class="line-modified">2052             if (AXCoreObject* parentObject = axObject-&gt;parentObjectUnignored())</span>
2053                 parentNode = parentObject-&gt;node();
2054 
2055             supportsPressed = axObject-&gt;pressedIsPresent();
2056             if (supportsPressed)
2057                 pressed = axObject-&gt;isPressed();
2058 
2059             if (axObject-&gt;isTextControl())
2060                 readonly = !axObject-&gt;canSetValueAttribute();
2061 
2062             supportsRequired = axObject-&gt;supportsRequiredAttribute();
2063             if (supportsRequired)
2064                 required = axObject-&gt;isRequired();
2065 
2066             role = axObject-&gt;computedRoleString();
2067             selected = axObject-&gt;isSelected();
2068 
<a name="32" id="anc32"></a><span class="line-modified">2069             AXCoreObject::AccessibilityChildrenVector selectedChildren;</span>
2070             axObject-&gt;selectedChildren(selectedChildren);
2071             if (selectedChildren.size()) {
2072                 selectedChildNodeIds = JSON::ArrayOf&lt;int&gt;::create();
2073                 for (auto&amp; selectedChildObject : selectedChildren) {
2074                     if (Node* selectedChildNode = selectedChildObject-&gt;node())
2075                         selectedChildNodeIds-&gt;addItem(pushNodePathToFrontend(selectedChildNode));
2076                 }
2077             }
2078 
2079             headingLevel = axObject-&gt;headingLevel();
2080             hierarchicalLevel = axObject-&gt;hierarchicalLevel();
2081 
2082             level = hierarchicalLevel ? hierarchicalLevel : headingLevel;
2083             isPopupButton = axObject-&gt;isPopUpButton() || axObject-&gt;hasPopup();
2084         }
2085     }
2086 
2087     Ref&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; value = Inspector::Protocol::DOM::AccessibilityProperties::create()
2088         .setExists(exists)
2089         .setLabel(label)
2090         .setRole(role)
2091         .setNodeId(pushNodePathToFrontend(node))
2092         .release();
2093 
2094     if (exists) {
2095         if (activeDescendantNode)
2096             value-&gt;setActiveDescendantNodeId(pushNodePathToFrontend(activeDescendantNode));
2097         if (busy)
2098             value-&gt;setBusy(busy);
2099         if (supportsChecked)
2100             value-&gt;setChecked(checked);
2101         if (childNodeIds)
2102             value-&gt;setChildNodeIds(childNodeIds);
2103         if (controlledNodeIds)
2104             value-&gt;setControlledNodeIds(controlledNodeIds);
2105         if (currentState != Inspector::Protocol::DOM::AccessibilityProperties::Current::False)
2106             value-&gt;setCurrent(currentState);
2107         if (disabled)
2108             value-&gt;setDisabled(disabled);
2109         if (supportsExpanded)
2110             value-&gt;setExpanded(expanded);
2111         if (flowedNodeIds)
2112             value-&gt;setFlowedNodeIds(flowedNodeIds);
2113         if (supportsFocused)
2114             value-&gt;setFocused(focused);
2115         if (ignored)
2116             value-&gt;setIgnored(ignored);
2117         if (ignoredByDefault)
2118             value-&gt;setIgnoredByDefault(ignoredByDefault);
2119         if (invalid != Inspector::Protocol::DOM::AccessibilityProperties::Invalid::False)
2120             value-&gt;setInvalid(invalid);
2121         if (hidden)
2122             value-&gt;setHidden(hidden);
2123         if (supportsLiveRegion) {
2124             value-&gt;setLiveRegionAtomic(liveRegionAtomic);
2125             if (liveRegionRelevant-&gt;length())
2126                 value-&gt;setLiveRegionRelevant(liveRegionRelevant);
2127             value-&gt;setLiveRegionStatus(liveRegionStatus);
2128         }
2129         if (mouseEventNode)
2130             value-&gt;setMouseEventNodeId(pushNodePathToFrontend(mouseEventNode));
2131         if (ownedNodeIds)
2132             value-&gt;setOwnedNodeIds(ownedNodeIds);
2133         if (parentNode)
2134             value-&gt;setParentNodeId(pushNodePathToFrontend(parentNode));
2135         if (supportsPressed)
2136             value-&gt;setPressed(pressed);
2137         if (readonly)
2138             value-&gt;setReadonly(readonly);
2139         if (supportsRequired)
2140             value-&gt;setRequired(required);
2141         if (selected)
2142             value-&gt;setSelected(selected);
2143         if (selectedChildNodeIds)
2144             value-&gt;setSelectedChildNodeIds(selectedChildNodeIds);
2145 
2146         // H1 -- H6 always have a headingLevel property that can be complimented by a hierarchicalLevel
2147         // property when aria-level is set on the element, in which case we want to remain calling
2148         // this value the &quot;Heading Level&quot; in the inspector.
2149         // Also, we do not want it to say Hierarchy Level: 0
2150         if (headingLevel)
2151             value-&gt;setHeadingLevel(level);
2152         else if (level)
2153             value-&gt;setHierarchyLevel(level);
2154         if (isPopupButton)
2155             value-&gt;setIsPopUpButton(isPopupButton);
2156     }
2157 
2158     return value;
2159 }
2160 
2161 static bool containsOnlyHTMLWhitespace(Node* node)
2162 {
2163     // FIXME: Respect ignoreWhitespace setting from inspector front end?
2164     return is&lt;Text&gt;(node) &amp;&amp; downcast&lt;Text&gt;(*node).data().isAllSpecialCharacters&lt;isHTMLSpace&gt;();
2165 }
2166 
2167 Node* InspectorDOMAgent::innerFirstChild(Node* node)
2168 {
2169     node = node-&gt;firstChild();
2170     while (containsOnlyHTMLWhitespace(node))
2171         node = node-&gt;nextSibling();
2172     return node;
2173 }
2174 
2175 Node* InspectorDOMAgent::innerNextSibling(Node* node)
2176 {
2177     do {
2178         node = node-&gt;nextSibling();
2179     } while (containsOnlyHTMLWhitespace(node));
2180     return node;
2181 }
2182 
2183 Node* InspectorDOMAgent::innerPreviousSibling(Node* node)
2184 {
2185     do {
2186         node = node-&gt;previousSibling();
2187     } while (containsOnlyHTMLWhitespace(node));
2188     return node;
2189 }
2190 
2191 unsigned InspectorDOMAgent::innerChildNodeCount(Node* node)
2192 {
2193     unsigned count = 0;
2194     for (Node* child = innerFirstChild(node); child; child = innerNextSibling(child))
2195         ++count;
2196     return count;
2197 }
2198 
2199 Node* InspectorDOMAgent::innerParentNode(Node* node)
2200 {
2201     ASSERT(node);
2202     if (is&lt;Document&gt;(*node))
2203         return downcast&lt;Document&gt;(*node).ownerElement();
2204     if (is&lt;ShadowRoot&gt;(*node))
2205         return downcast&lt;ShadowRoot&gt;(*node).host();
2206     return node-&gt;parentNode();
2207 }
2208 
2209 void InspectorDOMAgent::didCommitLoad(Document* document)
2210 {
2211     if (m_nodeToFocus &amp;&amp; &amp;m_nodeToFocus-&gt;document() == document)
2212         m_nodeToFocus = nullptr;
2213 
2214     if (m_mousedOverNode &amp;&amp; &amp;m_mousedOverNode-&gt;document() == document)
2215         m_mousedOverNode = nullptr;
2216 
2217     if (m_inspectedNode &amp;&amp; &amp;m_inspectedNode-&gt;document() == document)
2218         m_inspectedNode = nullptr;
2219 
2220     RefPtr&lt;Element&gt; frameOwner = document-&gt;ownerElement();
2221     if (!frameOwner)
2222         return;
2223 
2224     int frameOwnerId = m_documentNodeToIdMap.get(frameOwner);
2225     if (!frameOwnerId)
2226         return;
2227 
2228     // Re-add frame owner element together with its new children.
2229     int parentId = m_documentNodeToIdMap.get(innerParentNode(frameOwner.get()));
2230     m_frontendDispatcher-&gt;childNodeRemoved(parentId, frameOwnerId);
2231     unbind(frameOwner.get(), &amp;m_documentNodeToIdMap);
2232 
2233     Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(frameOwner.get(), 0, &amp;m_documentNodeToIdMap);
2234     Node* previousSibling = innerPreviousSibling(frameOwner.get());
2235     int prevId = previousSibling ? m_documentNodeToIdMap.get(previousSibling) : 0;
2236     m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2237 }
2238 
2239 int InspectorDOMAgent::identifierForNode(Node&amp; node)
2240 {
2241     return pushNodePathToFrontend(&amp;node);
2242 }
2243 
2244 void InspectorDOMAgent::addEventListenersToNode(Node&amp; node)
2245 {
2246 #if ENABLE(VIDEO)
2247     auto callback = EventFiredCallback::create(*this);
2248 
2249     auto createEventListener = [&amp;] (const AtomString&amp; eventName) {
2250         node.addEventListener(eventName, callback.copyRef(), false);
2251     };
2252 
2253 #if ENABLE(FULLSCREEN_API)
2254     if (is&lt;Document&gt;(node) || is&lt;HTMLMediaElement&gt;(node))
2255         createEventListener(eventNames().webkitfullscreenchangeEvent);
2256 #endif // ENABLE(FULLSCREEN_API)
2257 
2258     if (is&lt;HTMLMediaElement&gt;(node)) {
2259         createEventListener(eventNames().abortEvent);
2260         createEventListener(eventNames().canplayEvent);
2261         createEventListener(eventNames().canplaythroughEvent);
2262         createEventListener(eventNames().emptiedEvent);
2263         createEventListener(eventNames().endedEvent);
2264         createEventListener(eventNames().loadeddataEvent);
2265         createEventListener(eventNames().loadedmetadataEvent);
2266         createEventListener(eventNames().loadstartEvent);
2267         createEventListener(eventNames().pauseEvent);
2268         createEventListener(eventNames().playEvent);
2269         createEventListener(eventNames().playingEvent);
2270         createEventListener(eventNames().seekedEvent);
2271         createEventListener(eventNames().seekingEvent);
2272         createEventListener(eventNames().stalledEvent);
2273         createEventListener(eventNames().suspendEvent);
2274         createEventListener(eventNames().waitingEvent);
2275 
2276         if (!m_mediaMetricsTimer.isActive())
2277             m_mediaMetricsTimer.start(0_s, 1_s / 15.);
2278     }
2279 #else
2280     UNUSED_PARAM(node);
2281 #endif // ENABLE(VIDEO)
2282 }
2283 
2284 void InspectorDOMAgent::didInsertDOMNode(Node&amp; node)
2285 {
2286     if (containsOnlyHTMLWhitespace(&amp;node))
2287         return;
2288 
2289     // We could be attaching existing subtree. Forget the bindings.
2290     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2291 
2292     ContainerNode* parent = node.parentNode();
2293     if (!parent)
2294         return;
2295 
2296     int parentId = m_documentNodeToIdMap.get(parent);
2297     // Return if parent is not mapped yet.
2298     if (!parentId)
2299         return;
2300 
2301     if (!m_childrenRequested.contains(parentId)) {
2302         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2303         m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, innerChildNodeCount(parent));
2304     } else {
2305         // Children have been requested -&gt; return value of a new child.
2306         Node* prevSibling = innerPreviousSibling(&amp;node);
2307         int prevId = prevSibling ? m_documentNodeToIdMap.get(prevSibling) : 0;
2308         Ref&lt;Inspector::Protocol::DOM::Node&gt; value = buildObjectForNode(&amp;node, 0, &amp;m_documentNodeToIdMap);
2309         m_frontendDispatcher-&gt;childNodeInserted(parentId, prevId, WTFMove(value));
2310     }
2311 }
2312 
2313 void InspectorDOMAgent::didRemoveDOMNode(Node&amp; node)
2314 {
2315     if (containsOnlyHTMLWhitespace(&amp;node))
2316         return;
2317 
2318     ContainerNode* parent = node.parentNode();
2319 
2320     // If parent is not mapped yet -&gt; ignore the event.
2321     if (!m_documentNodeToIdMap.contains(parent))
2322         return;
2323 
2324     int parentId = m_documentNodeToIdMap.get(parent);
2325 
2326     if (!m_childrenRequested.contains(parentId)) {
2327         // No children are mapped yet -&gt; only notify on changes of hasChildren.
2328         if (innerChildNodeCount(parent) == 1)
2329             m_frontendDispatcher-&gt;childNodeCountUpdated(parentId, 0);
2330     } else
2331         m_frontendDispatcher-&gt;childNodeRemoved(parentId, m_documentNodeToIdMap.get(&amp;node));
2332     unbind(&amp;node, &amp;m_documentNodeToIdMap);
2333 }
2334 
2335 void InspectorDOMAgent::willModifyDOMAttr(Element&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue)
2336 {
2337     m_suppressAttributeModifiedEvent = (oldValue == newValue);
2338 }
2339 
2340 void InspectorDOMAgent::didModifyDOMAttr(Element&amp; element, const AtomString&amp; name, const AtomString&amp; value)
2341 {
2342     bool shouldSuppressEvent = m_suppressAttributeModifiedEvent;
2343     m_suppressAttributeModifiedEvent = false;
2344     if (shouldSuppressEvent)
2345         return;
2346 
2347     int id = boundNodeId(&amp;element);
2348     if (!id)
2349         return;
2350 
2351     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
2352         cssAgent-&gt;didModifyDOMAttr(element);
2353 
2354     m_frontendDispatcher-&gt;attributeModified(id, name, value);
2355 }
2356 
2357 void InspectorDOMAgent::didRemoveDOMAttr(Element&amp; element, const AtomString&amp; name)
2358 {
2359     int id = boundNodeId(&amp;element);
2360     if (!id)
2361         return;
2362 
2363     if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
2364         cssAgent-&gt;didModifyDOMAttr(element);
2365 
2366     m_frontendDispatcher-&gt;attributeRemoved(id, name);
2367 }
2368 
2369 void InspectorDOMAgent::styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements)
2370 {
2371     auto nodeIds = JSON::ArrayOf&lt;int&gt;::create();
2372     for (auto&amp; element : elements) {
2373         int id = boundNodeId(element);
2374         if (!id)
2375             continue;
2376 
2377         if (auto* cssAgent = m_instrumentingAgents.inspectorCSSAgent())
2378             cssAgent-&gt;didModifyDOMAttr(*element);
2379 
2380         nodeIds-&gt;addItem(id);
2381     }
2382     m_frontendDispatcher-&gt;inlineStyleInvalidated(WTFMove(nodeIds));
2383 }
2384 
2385 void InspectorDOMAgent::characterDataModified(CharacterData&amp; characterData)
2386 {
2387     int id = m_documentNodeToIdMap.get(&amp;characterData);
2388     if (!id) {
2389         // Push text node if it is being created.
2390         didInsertDOMNode(characterData);
2391         return;
2392     }
2393     m_frontendDispatcher-&gt;characterDataModified(id, characterData.data());
2394 }
2395 
2396 void InspectorDOMAgent::didInvalidateStyleAttr(Element&amp; element)
2397 {
2398     int id = m_documentNodeToIdMap.get(&amp;element);
2399     if (!id)
2400         return;
2401 
2402     if (!m_revalidateStyleAttrTask)
2403         m_revalidateStyleAttrTask = makeUnique&lt;RevalidateStyleAttributeTask&gt;(this);
2404     m_revalidateStyleAttrTask-&gt;scheduleFor(&amp;element);
2405 }
2406 
2407 void InspectorDOMAgent::didPushShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2408 {
2409     int hostId = m_documentNodeToIdMap.get(&amp;host);
2410     if (hostId)
2411         m_frontendDispatcher-&gt;shadowRootPushed(hostId, buildObjectForNode(&amp;root, 0, &amp;m_documentNodeToIdMap));
2412 }
2413 
2414 void InspectorDOMAgent::willPopShadowRoot(Element&amp; host, ShadowRoot&amp; root)
2415 {
2416     int hostId = m_documentNodeToIdMap.get(&amp;host);
2417     int rootId = m_documentNodeToIdMap.get(&amp;root);
2418     if (hostId &amp;&amp; rootId)
2419         m_frontendDispatcher-&gt;shadowRootPopped(hostId, rootId);
2420 }
2421 
2422 void InspectorDOMAgent::didChangeCustomElementState(Element&amp; element)
2423 {
2424     int elementId = m_documentNodeToIdMap.get(&amp;element);
2425     if (!elementId)
2426         return;
2427 
2428     m_frontendDispatcher-&gt;customElementStateChanged(elementId, customElementState(element));
2429 }
2430 
2431 void InspectorDOMAgent::frameDocumentUpdated(Frame&amp; frame)
2432 {
2433     Document* document = frame.document();
2434     if (!document)
2435         return;
2436 
2437     if (!frame.isMainFrame())
2438         return;
2439 
2440     // Only update the main frame document, nested frame document updates are not required
2441     // (will be handled by didCommitLoad()).
2442     setDocument(document);
2443 }
2444 
2445 void InspectorDOMAgent::pseudoElementCreated(PseudoElement&amp; pseudoElement)
2446 {
2447     Element* parent = pseudoElement.hostElement();
2448     if (!parent)
2449         return;
2450 
2451     int parentId = m_documentNodeToIdMap.get(parent);
2452     if (!parentId)
2453         return;
2454 
2455     pushChildNodesToFrontend(parentId, 1);
2456     m_frontendDispatcher-&gt;pseudoElementAdded(parentId, buildObjectForNode(&amp;pseudoElement, 0, &amp;m_documentNodeToIdMap));
2457 }
2458 
2459 void InspectorDOMAgent::pseudoElementDestroyed(PseudoElement&amp; pseudoElement)
2460 {
2461     int pseudoElementId = m_documentNodeToIdMap.get(&amp;pseudoElement);
2462     if (!pseudoElementId)
2463         return;
2464 
2465     // If a PseudoElement is bound, its parent element must have been bound.
2466     Element* parent = pseudoElement.hostElement();
2467     ASSERT(parent);
2468     int parentId = m_documentNodeToIdMap.get(parent);
2469     ASSERT(parentId);
2470 
2471     unbind(&amp;pseudoElement, &amp;m_documentNodeToIdMap);
2472     m_frontendDispatcher-&gt;pseudoElementRemoved(parentId, pseudoElementId);
2473 }
2474 
2475 void InspectorDOMAgent::didAddEventListener(EventTarget&amp; target)
2476 {
2477     if (!is&lt;Node&gt;(target))
2478         return;
2479 
2480     auto&amp; node = downcast&lt;Node&gt;(target);
2481     if (!node.contains(m_inspectedNode.get()))
2482         return;
2483 
2484     int nodeId = boundNodeId(&amp;node);
2485     if (!nodeId)
2486         return;
2487 
2488     if (m_suppressEventListenerChangedEvent)
2489         return;
2490 
2491     m_suppressEventListenerChangedEvent = true;
2492 
2493     m_frontendDispatcher-&gt;didAddEventListener(nodeId);
2494 }
2495 
2496 void InspectorDOMAgent::willRemoveEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)
2497 {
2498     if (!is&lt;Node&gt;(target))
2499         return;
2500 
2501     auto&amp; node = downcast&lt;Node&gt;(target);
2502     if (!node.contains(m_inspectedNode.get()))
2503         return;
2504 
2505     int nodeId = boundNodeId(&amp;node);
2506     if (!nodeId)
2507         return;
2508 
2509     bool listenerExists = false;
2510     for (auto&amp; item : node.eventListeners(eventType)) {
2511         if (item-&gt;callback() == listener &amp;&amp; item-&gt;useCapture() == capture) {
2512             listenerExists = true;
2513             break;
2514         }
2515     }
2516 
2517     if (!listenerExists)
2518         return;
2519 
2520     m_eventListenerEntries.removeIf([&amp;] (auto&amp; entry) {
2521         return entry.value.matches(target, eventType, listener, capture);
2522     });
2523 
2524     if (m_suppressEventListenerChangedEvent)
2525         return;
2526 
2527     m_suppressEventListenerChangedEvent = true;
2528 
2529     m_frontendDispatcher-&gt;willRemoveEventListener(nodeId);
2530 }
2531 
2532 bool InspectorDOMAgent::isEventListenerDisabled(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)
2533 {
2534     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2535         if (inspectorEventListener.matches(target, eventType, listener, capture))
2536             return inspectorEventListener.disabled;
2537     }
2538     return false;
2539 }
2540 
2541 void InspectorDOMAgent::eventDidResetAfterDispatch(const Event&amp; event)
2542 {
2543     m_dispatchedEvents.remove(&amp;event);
2544 }
2545 
2546 bool InspectorDOMAgent::hasBreakpointForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)
2547 {
2548     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2549         if (inspectorEventListener.matches(target, eventType, listener, capture))
2550             return inspectorEventListener.hasBreakpoint;
2551     }
2552     return false;
2553 }
2554 
2555 int InspectorDOMAgent::idForEventListener(EventTarget&amp; target, const AtomString&amp; eventType, EventListener&amp; listener, bool capture)
2556 {
2557     for (auto&amp; inspectorEventListener : m_eventListenerEntries.values()) {
2558         if (inspectorEventListener.matches(target, eventType, listener, capture))
2559             return inspectorEventListener.identifier;
2560     }
2561     return 0;
2562 }
2563 
2564 #if ENABLE(VIDEO)
2565 void InspectorDOMAgent::mediaMetricsTimerFired()
2566 {
2567     // FIXME: remove metrics information for any media element when it&#39;s destroyed
2568 
2569     if (HTMLMediaElement::allMediaElements().isEmpty()) {
2570         if (m_mediaMetricsTimer.isActive())
2571             m_mediaMetricsTimer.stop();
2572         m_mediaMetrics.clear();
2573         return;
2574     }
2575 
2576     for (auto* mediaElement : HTMLMediaElement::allMediaElements()) {
2577         if (!is&lt;HTMLVideoElement&gt;(mediaElement) || !mediaElement-&gt;isPlaying())
2578             continue;
2579 
2580         auto videoPlaybackQuality = mediaElement-&gt;getVideoPlaybackQuality();
2581         unsigned displayCompositedVideoFrames = videoPlaybackQuality-&gt;displayCompositedVideoFrames();
2582 
2583         auto iterator = m_mediaMetrics.find(mediaElement);
2584         if (iterator == m_mediaMetrics.end()) {
2585             m_mediaMetrics.set(mediaElement, MediaMetrics(displayCompositedVideoFrames));
2586             continue;
2587         }
2588 
2589         bool isPowerEfficient = (displayCompositedVideoFrames - iterator-&gt;value.displayCompositedFrames) &gt; 0;
2590         if (iterator-&gt;value.isPowerEfficient != isPowerEfficient) {
2591             iterator-&gt;value.isPowerEfficient = isPowerEfficient;
2592 
2593             int nodeId = pushNodePathToFrontend(mediaElement);
2594             if (nodeId) {
2595                 auto timestamp = m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
2596                 m_frontendDispatcher-&gt;powerEfficientPlaybackStateChanged(nodeId, timestamp, iterator-&gt;value.isPowerEfficient);
2597             }
2598         }
2599 
2600         iterator-&gt;value.displayCompositedFrames = displayCompositedVideoFrames;
2601     }
2602 
2603     m_mediaMetrics.removeIf([&amp;] (auto&amp; entry) {
2604         return !HTMLMediaElement::allMediaElements().contains(entry.key);
2605     });
2606 }
2607 #endif
2608 
2609 Node* InspectorDOMAgent::nodeForPath(const String&amp; path)
2610 {
2611     // The path is of form &quot;1,HTML,2,BODY,1,DIV&quot;
2612     if (!m_document)
2613         return nullptr;
2614 
2615     Node* node = m_document.get();
2616     Vector&lt;String&gt; pathTokens = path.split(&#39;,&#39;);
2617     if (!pathTokens.size())
2618         return nullptr;
2619 
2620     for (size_t i = 0; i &lt; pathTokens.size() - 1; i += 2) {
2621         bool success = true;
2622         unsigned childNumber = pathTokens[i].toUInt(&amp;success);
2623         if (!success)
2624             return nullptr;
2625 
2626         Node* child;
2627         if (is&lt;HTMLFrameOwnerElement&gt;(*node)) {
2628             ASSERT(!childNumber);
2629             auto&amp; frameOwner = downcast&lt;HTMLFrameOwnerElement&gt;(*node);
2630             child = frameOwner.contentDocument();
2631         } else {
2632             if (childNumber &gt;= innerChildNodeCount(node))
2633                 return nullptr;
2634 
2635             child = innerFirstChild(node);
2636             for (size_t j = 0; child &amp;&amp; j &lt; childNumber; ++j)
2637                 child = innerNextSibling(child);
2638         }
2639 
2640         const auto&amp; childName = pathTokens[i + 1];
2641         if (!child || child-&gt;nodeName() != childName)
2642             return nullptr;
2643         node = child;
2644     }
2645     return node;
2646 }
2647 
2648 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2649 {
2650     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2651     if (injectedScript.hasNoValue())
2652         return nullptr;
2653 
2654     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2655 }
2656 
2657 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2658 {
2659     if (Node* node = nodeForPath(path))
<a name="33" id="anc33"></a><span class="line-modified">2660         *nodeId = pushNodePathToFrontend(errorString, node);</span>
2661     else
2662         errorString = &quot;Missing node for given path&quot;_s;
2663 }
2664 
2665 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2666 {
2667     Document* document = &amp;node-&gt;document();
2668     if (auto* templateHost = document-&gt;templateDocumentHost())
2669         document = templateHost;
2670     auto* frame =  document-&gt;frame();
2671     if (!frame)
2672         return nullptr;
2673 
2674     auto&amp; state = *mainWorldExecState(frame);
2675     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2676     if (injectedScript.hasNoValue())
2677         return nullptr;
2678 
2679     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2680 }
2681 
2682 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2683 {
2684     if (!value || !value.isObject())
2685         return nullptr;
2686     return JSNode::toWrapped(value.getObject()-&gt;vm(), value.getObject());
2687 }
2688 
<a name="34" id="anc34"></a><span class="line-modified">2689 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::JSGlobalObject&amp; state, Node* node)</span>
2690 {
2691     JSC::JSLockHolder lock(&amp;state);
2692     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2693 }
2694 
<a name="35" id="anc35"></a><span class="line-added">2695 void InspectorDOMAgent::setAllowEditingUserAgentShadowTrees(ErrorString&amp;, bool allow)</span>
<span class="line-added">2696 {</span>
<span class="line-added">2697     m_allowEditingUserAgentShadowTrees = allow;</span>
<span class="line-added">2698 }</span>
<span class="line-added">2699 </span>
2700 } // namespace WebCore
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;Parser.h&quot;
  25 
  26 #include &quot;ASTBuilder.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;DebuggerParseData.h&quot;
  29 #include &quot;JSCInlines.h&quot;
  30 #include &quot;VM.h&quot;
  31 #include &lt;utility&gt;
  32 #include &lt;wtf/Scope.h&gt;
  33 #include &lt;wtf/SetForScope.h&gt;
  34 #include &lt;wtf/StringPrintStream.h&gt;
  35 
  36 #define updateErrorMessage(shouldPrintToken, ...) do {\
  37     propagateError(); \
  38     logError(shouldPrintToken, __VA_ARGS__); \
  39 } while (0)
  40 
  41 #define propagateError() do { if (UNLIKELY(hasError())) return 0; } while (0)
  42 #define internalFailWithMessage(shouldPrintToken, ...) do { updateErrorMessage(shouldPrintToken, __VA_ARGS__); return 0; } while (0)
  43 #define handleErrorToken() do { if (m_token.m_type == EOFTOK || m_token.m_type &amp; ErrorTokenFlag) { failDueToUnexpectedToken(); } } while (0)
  44 #define failWithMessage(...) do { { handleErrorToken(); updateErrorMessage(true, __VA_ARGS__); } return 0; } while (0)
  45 #define failWithStackOverflow() do { updateErrorMessage(false, &quot;Stack exhausted&quot;); m_hasStackOverflow = true; return 0; } while (0)
  46 #define failIfFalse(cond, ...) do { if (!(cond)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  47 #define failIfTrue(cond, ...) do { if (cond) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  48 #define failIfTrueIfStrict(cond, ...) do { if ((cond) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  49 #define failIfFalseIfStrict(cond, ...) do { if ((!(cond)) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  50 #define consumeOrFail(tokenType, ...) do { if (!consume(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  51 #define consumeOrFailWithFlags(tokenType, flags, ...) do { if (!consume(tokenType, flags)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  52 #define matchOrFail(tokenType, ...) do { if (!match(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  53 #define failIfStackOverflow() do { if (UNLIKELY(!canRecurse())) failWithStackOverflow(); } while (0)
  54 #define semanticFail(...) do { internalFailWithMessage(false, __VA_ARGS__); } while (0)
  55 #define semanticFailIfTrue(cond, ...) do { if (UNLIKELY(cond)) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  56 #define semanticFailIfFalse(cond, ...) do { if (UNLIKELY(!(cond))) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  57 #define regexFail(failure) do { setErrorMessage(failure); return 0; } while (0)
  58 #define failDueToUnexpectedToken() do {\
  59         logError(true);\
  60     return 0;\
  61 } while (0)
  62 
  63 #define handleProductionOrFail(token, tokenString, operation, production) do {\
  64     consumeOrFail(token, &quot;Expected &#39;&quot;, tokenString, &quot;&#39; to &quot;, operation, &quot; a &quot;, production);\
  65 } while (0)
  66 
  67 #define handleProductionOrFail2(token, tokenString, operation, production) do {\
  68     consumeOrFail(token, &quot;Expected &#39;&quot;, tokenString, &quot;&#39; to &quot;, operation, &quot; an &quot;, production);\
  69 } while (0)
  70 
  71 #define semanticFailureDueToKeywordCheckingToken(token, ...) do { \
  72     if (strictMode() &amp;&amp; token.m_type == RESERVED_IF_STRICT) \
  73         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__, &quot; in strict mode&quot;); \
  74     if (token.m_type == RESERVED || token.m_type == RESERVED_IF_STRICT) \
  75         semanticFail(&quot;Cannot use the reserved word &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  76     if (token.m_type &amp; KeywordTokenFlag) { \
  77         if (!isAnyContextualKeyword(token)) \
  78             semanticFail(&quot;Cannot use the keyword &#39;&quot;, getToken(token), &quot;&#39; as a &quot;, __VA_ARGS__); \
  79         if (isDisallowedIdentifierLet(token)) \
  80             semanticFail(&quot;Cannot use &#39;let&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierLetReason()); \
  81         if (isDisallowedIdentifierAwait(token)) \
  82             semanticFail(&quot;Cannot use &#39;await&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierAwaitReason()); \
  83         if (isDisallowedIdentifierYield(token)) \
  84             semanticFail(&quot;Cannot use &#39;yield&#39; as a &quot;, __VA_ARGS__, &quot; &quot;, disallowedIdentifierYieldReason()); \
  85     } \
  86 } while (0)
  87 
  88 #define semanticFailureDueToKeyword(...) semanticFailureDueToKeywordCheckingToken(m_token, __VA_ARGS__);
  89 
  90 namespace JSC {
  91 
  92 std::atomic&lt;unsigned&gt; globalParseCount { 0 };
  93 
  94 ALWAYS_INLINE static SourceParseMode getAsynFunctionBodyParseMode(SourceParseMode parseMode)
  95 {
  96     if (isAsyncGeneratorWrapperParseMode(parseMode))
  97         return SourceParseMode::AsyncGeneratorBodyMode;
  98 
  99     if (parseMode == SourceParseMode::AsyncArrowFunctionMode)
 100         return SourceParseMode::AsyncArrowFunctionBodyMode;
 101 
 102     return SourceParseMode::AsyncFunctionBodyMode;
 103 }
 104 
 105 template &lt;typename LexerType&gt;
 106 void Parser&lt;LexerType&gt;::logError(bool)
 107 {
 108     if (hasError())
 109         return;
 110     StringPrintStream stream;
 111     printUnexpectedTokenText(stream);
 112     setErrorMessage(stream.toStringWithLatin1Fallback());
 113 }
 114 
 115 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 116 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 117 {
 118     if (hasError())
 119         return;
 120     StringPrintStream stream;
 121     if (shouldPrintToken) {
 122         printUnexpectedTokenText(stream);
 123         stream.print(&quot;. &quot;);
 124     }
 125     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 126     setErrorMessage(stream.toStringWithLatin1Fallback());
 127 }
 128 
 129 template &lt;typename LexerType&gt;
 130 Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKindForTopLevelFunction, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)
 131     : m_vm(vm)
 132     , m_source(&amp;source)
 133     , m_hasStackOverflow(false)
 134     , m_allowsIn(true)
 135     , m_statementDepth(0)
 136     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 137     , m_scriptMode(scriptMode)
 138     , m_superBinding(superBinding)
 139     , m_defaultConstructorKindForTopLevelFunction(defaultConstructorKindForTopLevelFunction)
 140     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 141     , m_debuggerParseData(debuggerParseData)
 142 {
 143     m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);
 144     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 145     m_token.m_location.line = source.firstLine().oneBasedInt();
 146     m_token.m_location.startOffset = source.startOffset();
 147     m_token.m_location.endOffset = source.startOffset();
 148     m_token.m_location.lineStartOffset = source.startOffset();
 149     m_functionCache = vm.addSourceProviderCache(source.provider());
 150     m_expressionErrorClassifier = nullptr;
 151 
 152     ScopeRef scope = pushScope();
 153     scope-&gt;setSourceParseMode(parseMode);
 154     scope-&gt;setIsEvalContext(isEvalContext);
 155     if (isEvalContext)
 156         scope-&gt;setEvalContextType(evalContextType);
 157 
 158     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 159         scope-&gt;setConstructorKind(ConstructorKind::Extends);
 160         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 161     }
 162 
 163     if (derivedContextType == DerivedContextType::DerivedMethodContext)
 164         scope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
 165 
 166     if (strictMode == JSParserStrictMode::Strict)
 167         scope-&gt;setStrictMode();
 168 
 169     if (isModuleParseMode(parseMode))
 170         m_moduleScopeData = ModuleScopeData::create();
 171 
 172     if (isProgramOrModuleParseMode(parseMode))
 173         scope-&gt;setIsGlobalCodeScope();
 174 
 175     next();
 176 }
 177 
 178 class Scope::MaybeParseAsGeneratorForScope {
 179 public:
 180     MaybeParseAsGeneratorForScope(ScopeRef&amp; scope, bool shouldParseAsGenerator)
 181         : m_scope(scope)
 182         , m_oldValue(scope-&gt;m_isGenerator)
 183     {
 184         m_scope-&gt;m_isGenerator = shouldParseAsGenerator;
 185     }
 186 
 187     ~MaybeParseAsGeneratorForScope()
 188     {
 189         m_scope-&gt;m_isGenerator = m_oldValue;
 190     }
 191 
 192 private:
 193     ScopeRef m_scope;
 194     bool m_oldValue;
 195 };
 196 
 197 struct DepthManager : private SetForScope&lt;int&gt; {
 198 public:
 199     DepthManager(int* depth)
 200         : SetForScope&lt;int&gt;(*depth, *depth)
 201     {
 202     }
 203 };
 204 
 205 template &lt;typename LexerType&gt;
 206 Parser&lt;LexerType&gt;::~Parser()
 207 {
 208 }
 209 
 210 template &lt;typename LexerType&gt;
 211 Expected&lt;typename Parser&lt;LexerType&gt;::ParseInnerResult, String&gt; Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition, const Vector&lt;JSTextPosition&gt;* instanceFieldLocations)
 212 {
 213     ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));
 214     ScopeRef scope = currentScope();
 215     scope-&gt;setIsLexicalScope();
 216     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 217 
 218     FunctionParameters* parameters = nullptr;
 219     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 220     if (m_lexer-&gt;isReparsingFunction()) {
 221         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 222         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 223             parameters = createGeneratorParameters(context, functionInfo.parameterCount);
 224         else if (parseMode == SourceParseMode::InstanceFieldInitializerMode)
 225             parameters = context.createFormalParameterList();
 226         else
 227             parameters = parseFunctionParameters(context, parseMode, functionInfo);
 228 
 229         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 230             // The only way we could have an error wile reparsing is if we run out of stack space.
 231             RELEASE_ASSERT(match(ARROWFUNCTION));
 232             next();
 233             isArrowFunctionBodyExpression = !match(OPENBRACE);
 234         }
 235     }
 236 
 237     if (!calleeName.isNull())
 238         scope-&gt;declareCallee(&amp;calleeName);
 239 
 240     if (m_lexer-&gt;isReparsingFunction())
 241         m_statementDepth--;
 242 
 243     SourceElements* sourceElements = nullptr;
 244     // The only way we can error this early is if we reparse a function and we run out of stack space.
 245     if (!hasError()) {
 246         if (isAsyncFunctionWrapperParseMode(parseMode))
 247             sourceElements = parseAsyncFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 248         else if (isArrowFunctionBodyExpression)
 249             sourceElements = parseArrowFunctionSingleExpressionBodySourceElements(context);
 250         else if (isModuleParseMode(parseMode))
 251             sourceElements = parseModuleSourceElements(context, parseMode);
 252         else if (isGeneratorWrapperParseMode(parseMode))
 253             sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
 254         else if (isAsyncGeneratorWrapperParseMode(parseMode))
 255             sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 256         else if (parsingContext == ParsingContext::FunctionConstructor)
 257             sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
 258         else if (parseMode == SourceParseMode::InstanceFieldInitializerMode) {
 259             ASSERT(instanceFieldLocations &amp;&amp; !instanceFieldLocations-&gt;isEmpty());
 260             sourceElements = parseInstanceFieldInitializerSourceElements(context, *instanceFieldLocations);
 261         } else
 262             sourceElements = parseSourceElements(context, CheckForStrictMode);
 263     }
 264 
 265     bool validEnding = consume(EOFTOK);
 266     if (!sourceElements || !validEnding)
 267         return makeUnexpected(hasError() ? m_errorMessage : &quot;Parser error&quot;_s);
 268 
 269     IdentifierSet capturedVariables;
 270     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 271     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 272     scope-&gt;getCapturedVars(capturedVariables);
 273 
 274     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 275     for (auto&amp; entry : capturedVariables)
 276         varDeclarations.markVariableAsCaptured(entry);
 277 
 278     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
 279         if (scope-&gt;usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 280             context.propagateArgumentsUse();
 281     }
 282 
 283     CodeFeatures features = context.features();
 284     if (scope-&gt;strictMode())
 285         features |= StrictModeFeature;
 286     if (scope-&gt;shadowsArguments())
 287         features |= ShadowsArgumentsFeature;
 288     if (m_seenTaggedTemplate)
 289         features |= NoEvalCacheFeature;
 290 
 291 #if ASSERT_ENABLED
 292     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 293         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 294         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 295         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 296             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
 297             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm.propertyNames-&gt;async.impl()) {
 298                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 299                 dataLog(m_source-&gt;view());
 300                 CRASH();
 301             }
 302         }
 303     }
 304 #endif // ASSERT_ENABLED
 305 
 306     return ParseInnerResult { parameters, sourceElements, scope-&gt;takeFunctionDeclarations(), WTFMove(varDeclarations), WTFMove(sloppyModeHoistedFunctions), features, context.numConstants() };
 307 }
 308 
 309 template &lt;typename LexerType&gt;
 310 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isArrowFunctionParameters(TreeBuilder&amp; context)
 311 {
 312     if (match(OPENPAREN)) {
 313         SavePoint saveArrowFunctionPoint = createSavePoint(context);
 314         next();
 315         bool isArrowFunction = false;
 316         if (match(CLOSEPAREN)) {
 317             next();
 318             isArrowFunction = match(ARROWFUNCTION);
 319         } else {
 320             SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 321             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 322             AutoPopScopeRef fakeScope(this, pushScope());
 323             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 324 
 325             unsigned parametersCount = 0;
 326             bool isArrowFunctionParameterList = true;
 327             bool isMethod = false;
 328             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 329             propagateError();
 330             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 331         }
 332         restoreSavePoint(context, saveArrowFunctionPoint);
 333         return isArrowFunction;
 334     }
 335 
 336     if (matchSpecIdentifier()) {
 337         semanticFailIfTrue(!m_parserState.allowAwait &amp;&amp; match(AWAIT), &quot;Cannot use &#39;await&#39; as a parameter name in an async function&quot;);
 338         SavePoint saveArrowFunctionPoint = createSavePoint(context);
 339         next();
 340         bool isArrowFunction = match(ARROWFUNCTION);
 341         restoreSavePoint(context, saveArrowFunctionPoint);
 342         return isArrowFunction;
 343     }
 344 
 345     return false;
 346 }
 347 
 348 template &lt;typename LexerType&gt;
 349 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 350 {
 351     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 352 }
 353 
 354 template &lt;typename LexerType&gt;
 355 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 356 {
 357     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 358     TreeSourceElements sourceElements = context.createSourceElements();
 359     const Identifier* directive = 0;
 360     unsigned directiveLiteralLength = 0;
 361     auto savePoint = createSavePoint(context);
 362     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 363 
 364     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 365         if (shouldCheckForUseStrict) {
 366             if (directive) {
 367                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
 368                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm.propertyNames-&gt;useStrictIdentifier == *directive) {
 369                     setStrictMode();
 370                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 371                     if (!isValidStrictMode()) {
 372                         if (m_parserState.lastFunctionName) {
 373                             if (m_vm.propertyNames-&gt;arguments == *m_parserState.lastFunctionName)
 374                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
 375                             if (m_vm.propertyNames-&gt;eval == *m_parserState.lastFunctionName)
 376                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 377                         }
 378                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;arguments))
 379                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
 380                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;eval))
 381                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 382                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 383                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 384                     }
 385                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
 386                     restoreSavePoint(context, savePoint);
 387                     propagateError();
 388                     continue;
 389                 }
 390 
 391                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 392                 // see if the next statement we parse is also a directive.
 393                 directive = nullptr;
 394             } else {
 395                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 396                 // is only allowed as the first statement, or after a sequence of directives before it, but
 397                 // not after non-directive statements.
 398                 shouldCheckForUseStrict = false;
 399             }
 400         }
 401         context.appendStatement(sourceElements, statement);
 402     }
 403 
 404     propagateError();
 405     return sourceElements;
 406 }
 407 
 408 template &lt;typename LexerType&gt;
 409 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 410 {
 411     TreeSourceElements sourceElements = context.createSourceElements();
 412     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 413 
 414     while (true) {
 415         TreeStatement statement = 0;
 416         switch (m_token.m_type) {
 417         case EXPORT_:
 418             statement = parseExportDeclaration(context);
 419             if (statement)
 420                 recordPauseLocation(context.breakpointLocation(statement));
 421             break;
 422 
 423         case IMPORT: {
 424             SavePoint savePoint = createSavePoint(context);
 425             next();
 426             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
 427             restoreSavePoint(context, savePoint);
 428             if (isImportDeclaration) {
 429                 statement = parseImportDeclaration(context);
 430                 if (statement)
 431                     recordPauseLocation(context.breakpointLocation(statement));
 432                 break;
 433             }
 434 
 435             // This is `import(&quot;...&quot;)` call or `import.meta` meta property case.
 436             FALLTHROUGH;
 437         }
 438 
 439         default: {
 440             const Identifier* directive = 0;
 441             unsigned directiveLiteralLength = 0;
 442             if (parseMode == SourceParseMode::ModuleAnalyzeMode) {
 443                 if (!parseStatementListItem(syntaxChecker, directive, &amp;directiveLiteralLength))
 444                     goto end;
 445                 continue;
 446             }
 447             statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength);
 448             break;
 449         }
 450         }
 451 
 452         if (!statement)
 453             goto end;
 454         context.appendStatement(sourceElements, statement);
 455     }
 456 
 457 end:
 458     propagateError();
 459 
 460     for (const auto&amp; pair : m_moduleScopeData-&gt;exportedBindings()) {
 461         const auto&amp; uid = pair.key;
 462         if (currentScope()-&gt;hasDeclaredVariable(uid)) {
 463             currentScope()-&gt;declaredVariables().markVariableAsExported(uid);
 464             continue;
 465         }
 466 
 467         if (currentScope()-&gt;hasLexicallyDeclaredVariable(uid)) {
 468             currentScope()-&gt;lexicalVariables().markVariableAsExported(uid);
 469             continue;
 470         }
 471 
 472         semanticFail(&quot;Exported binding &#39;&quot;, uid.get(), &quot;&#39; needs to refer to a top-level declared variable&quot;);
 473     }
 474 
 475     return sourceElements;
 476 }
 477 
 478 template &lt;typename LexerType&gt;
 479 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseGeneratorFunctionSourceElements(TreeBuilder&amp; context, const Identifier&amp; name, SourceElementsMode mode)
 480 {
 481     auto sourceElements = context.createSourceElements();
 482 
 483     unsigned functionKeywordStart = tokenStart();
 484     JSTokenLocation startLocation(tokenLocation());
 485     JSTextPosition start = tokenStartPosition();
 486     unsigned startColumn = tokenColumn();
 487     int functionNameStart = m_token.m_location.startOffset;
 488     int parametersStart = m_token.m_location.startOffset;
 489 
 490     ParserFunctionInfo&lt;TreeBuilder&gt; info;
 491     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
 492     createGeneratorParameters(context, info.parameterCount);
 493     info.startOffset = parametersStart;
 494     info.startLine = tokenLine();
 495 
 496     {
 497         AutoPopScopeRef generatorBodyScope(this, pushScope());
 498         generatorBodyScope-&gt;setSourceParseMode(SourceParseMode::GeneratorBodyMode);
 499         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
 500         generatorBodyScope-&gt;setExpectedSuperBinding(m_superBinding);
 501 
 502         SyntaxChecker generatorFunctionContext(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 503         failIfFalse(parseSourceElements(generatorFunctionContext, mode), &quot;Cannot parse the body of a generator&quot;);
 504         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 505     }
 506     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, SourceParseMode::GeneratorBodyMode, false);
 507 
 508     info.endLine = tokenLine();
 509     info.endOffset = m_token.m_data.offset;
 510     info.parametersStartColumn = startColumn;
 511 
 512     auto functionExpr = context.createGeneratorFunctionBody(startLocation, info, name);
 513     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 514     context.appendStatement(sourceElements, statement);
 515 
 516     return sourceElements;
 517 }
 518 
 519 template &lt;typename LexerType&gt;
 520 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 521 {
 522     ASSERT(isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode));
 523     auto sourceElements = context.createSourceElements();
 524 
 525     unsigned functionKeywordStart = tokenStart();
 526     JSTokenLocation startLocation(tokenLocation());
 527     JSTextPosition start = tokenStartPosition();
 528     unsigned startColumn = tokenColumn();
 529     int functionNameStart = m_token.m_location.startOffset;
 530     int parametersStart = m_token.m_location.startOffset;
 531 
 532     ParserFunctionInfo&lt;TreeBuilder&gt; info;
 533     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
 534     createGeneratorParameters(context, info.parameterCount);
 535     info.startOffset = parametersStart;
 536     info.startLine = tokenLine();
 537 
 538     SourceParseMode innerParseMode = getAsynFunctionBodyParseMode(parseMode);
 539 
 540     {
 541         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 542         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
 543         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 544         if (isArrowFunctionBodyExpression) {
 545             if (m_debuggerParseData)
 546                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 547             else
 548                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 549         } else {
 550             if (m_debuggerParseData)
 551                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 552             else
 553                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 554         }
 555         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 556     }
 557     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 558 
 559     info.endLine = tokenLine();
 560     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 561     info.parametersStartColumn = startColumn;
 562 
 563     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 564     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 565     context.appendStatement(sourceElements, statement);
 566 
 567     return sourceElements;
 568 }
 569 
 570 template &lt;typename LexerType&gt;
 571 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode, bool isArrowFunctionBodyExpression, SourceElementsMode mode)
 572 {
 573     ASSERT_UNUSED(parseMode, isAsyncGeneratorWrapperParseMode(parseMode));
 574     auto sourceElements = context.createSourceElements();
 575 
 576     unsigned functionKeywordStart = tokenStart();
 577     JSTokenLocation startLocation(tokenLocation());
 578     JSTextPosition start = tokenStartPosition();
 579     unsigned startColumn = tokenColumn();
 580     int functionNameStart = m_token.m_location.startOffset;
 581     int parametersStart = m_token.m_location.startOffset;
 582 
 583     ParserFunctionInfo&lt;TreeBuilder&gt; info;
 584     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
 585     createGeneratorParameters(context, info.parameterCount);
 586     info.startOffset = parametersStart;
 587     info.startLine = tokenLine();
 588     SourceParseMode innerParseMode = SourceParseMode::AsyncGeneratorBodyMode;
 589     {
 590         AutoPopScopeRef asyncFunctionBodyScope(this, pushScope());
 591         asyncFunctionBodyScope-&gt;setSourceParseMode(innerParseMode);
 592         SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 593         if (isArrowFunctionBodyExpression) {
 594             if (m_debuggerParseData)
 595                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse the body of async arrow function&quot;);
 596             else
 597                 failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse the body of async arrow function&quot;);
 598         } else {
 599             if (m_debuggerParseData)
 600                 failIfFalse(parseSourceElements(context, mode), &quot;Cannot parse the body of async function&quot;);
 601             else
 602                 failIfFalse(parseSourceElements(syntaxChecker, mode), &quot;Cannot parse the body of async function&quot;);
 603         }
 604         popScope(asyncFunctionBodyScope, TreeBuilder::NeedsFreeVariableInfo);
 605     }
 606     info.body = context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, tokenColumn(), functionKeywordStart, functionNameStart, parametersStart, strictMode(), ConstructorKind::None, m_superBinding, info.parameterCount, innerParseMode, isArrowFunctionBodyExpression);
 607 
 608     info.endLine = tokenLine();
 609     info.endOffset = isArrowFunctionBodyExpression ? tokenLocation().endOffset : m_token.m_data.offset;
 610     info.parametersStartColumn = startColumn;
 611 
 612     auto functionExpr = context.createAsyncFunctionBody(startLocation, info, innerParseMode);
 613     auto statement = context.createExprStatement(startLocation, functionExpr, start, m_lastTokenEndPosition.line);
 614     context.appendStatement(sourceElements, statement);
 615 
 616     return sourceElements;
 617 }
 618 
 619 template &lt;typename LexerType&gt;
 620 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSingleFunction(TreeBuilder&amp; context, Optional&lt;int&gt; functionConstructorParametersEndPosition)
 621 {
 622     TreeSourceElements sourceElements = context.createSourceElements();
 623     TreeStatement statement = 0;
 624     switch (m_token.m_type) {
 625     case FUNCTION:
 626         statement = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 627         break;
 628     case IDENT:
 629         if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {
 630             next();
 631             failIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Cannot parse the async function&quot;);
 632             statement = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::Standard, functionConstructorParametersEndPosition);
 633             break;
 634         }
 635         FALLTHROUGH;
 636     default:
 637         failDueToUnexpectedToken();
 638         break;
 639     }
 640 
 641     if (statement) {
 642         context.setEndOffset(statement, m_lastTokenEndPosition.offset);
 643         context.appendStatement(sourceElements, statement);
 644     }
 645 
 646     propagateError();
 647     return sourceElements;
 648 }
 649 
 650 
 651 template &lt;typename LexerType&gt;
 652 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 653 {
 654     // The grammar is documented here:
 655     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 656     DepthManager statementDepth(&amp;m_statementDepth);
 657     m_statementDepth++;
 658     failIfStackOverflow();
 659     TreeStatement result = 0;
 660     bool shouldSetEndOffset = true;
 661     bool shouldSetPauseLocation = false;
 662 
 663     switch (m_token.m_type) {
 664     case CONSTTOKEN:
 665         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 666         shouldSetPauseLocation = true;
 667         break;
 668     case LET: {
 669         bool shouldParseVariableDeclaration = true;
 670         if (!strictMode()) {
 671             SavePoint savePoint = createSavePoint(context);
 672             next();
 673             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 674             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 675             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 676             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 677             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 678             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 679                 shouldParseVariableDeclaration = false;
 680             restoreSavePoint(context, savePoint);
 681         }
 682         if (shouldParseVariableDeclaration)
 683             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 684         else {
 685             bool allowFunctionDeclarationAsStatement = true;
 686             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 687         }
 688         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 689         break;
 690     }
 691     case CLASSTOKEN:
 692         result = parseClassDeclaration(context);
 693         break;
 694     case FUNCTION:
 695         result = parseFunctionDeclaration(context);
 696         break;
 697     case IDENT:
 698         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
 699             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 700             // but could be mistakenly parsed as an AsyncFunctionExpression.
 701             SavePoint savePoint = createSavePoint(context);
 702             next();
 703             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 704                 result = parseAsyncFunctionDeclaration(context);
 705                 break;
 706             }
 707             restoreSavePoint(context, savePoint);
 708         }
 709         FALLTHROUGH;
 710     case AWAIT:
 711     case YIELD: {
 712         // This is a convenient place to notice labeled statements
 713         // (even though we also parse them as normal statements)
 714         // because we allow the following type of code in sloppy mode:
 715         // ``` function foo() { label: function bar() { } } ```
 716         bool allowFunctionDeclarationAsStatement = true;
 717         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 718         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 719         break;
 720     }
 721     default:
 722         m_statementDepth--; // parseStatement() increments the depth.
 723         result = parseStatement(context, directive, directiveLiteralLength);
 724         shouldSetEndOffset = false;
 725         break;
 726     }
 727 
 728     if (result) {
 729         if (shouldSetEndOffset)
 730             context.setEndOffset(result, m_lastTokenEndPosition.offset);
 731         if (shouldSetPauseLocation)
 732             recordPauseLocation(context.breakpointLocation(result));
 733     }
 734 
 735     return result;
 736 }
 737 
 738 template &lt;typename LexerType&gt;
 739 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseVariableDeclaration(TreeBuilder&amp; context, DeclarationType declarationType, ExportType exportType)
 740 {
 741     ASSERT(match(VAR) || match(LET) || match(CONSTTOKEN));
 742     JSTokenLocation location(tokenLocation());
 743     int start = tokenLine();
 744     int end = 0;
 745     int scratch;
 746     TreeDestructuringPattern scratch1 = 0;
 747     TreeExpression scratch2 = 0;
 748     JSTextPosition scratch3;
 749     bool scratchBool;
 750     TreeExpression variableDecls = parseVariableDeclarationList(context, scratch, scratch1, scratch2, scratch3, scratch3, scratch3, VarDeclarationContext, declarationType, exportType, scratchBool);
 751     propagateError();
 752     failIfFalse(autoSemiColon(), &quot;Expected &#39;;&#39; after variable declaration&quot;);
 753 
 754     return context.createDeclarationStatement(location, variableDecls, start, end);
 755 }
 756 
 757 template &lt;typename LexerType&gt;
 758 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDoWhileStatement(TreeBuilder&amp; context)
 759 {
 760     ASSERT(match(DO));
 761     int startLine = tokenLine();
 762     next();
 763     const Identifier* unused = 0;
 764     startLoop();
 765     TreeStatement statement = parseStatement(context, unused);
 766     endLoop();
 767     failIfFalse(statement, &quot;Expected a statement following &#39;do&#39;&quot;);
 768     int endLine = tokenLine();
 769     JSTokenLocation location(tokenLocation());
 770     handleProductionOrFail(WHILE, &quot;while&quot;, &quot;end&quot;, &quot;do-while loop&quot;);
 771     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;do-while loop condition&quot;);
 772     semanticFailIfTrue(match(CLOSEPAREN), &quot;Must provide an expression as a do-while loop condition&quot;);
 773     TreeExpression expr = parseExpression(context);
 774     failIfFalse(expr, &quot;Unable to parse do-while loop condition&quot;);
 775     recordPauseLocation(context.breakpointLocation(expr));
 776     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;do-while loop condition&quot;);
 777     if (match(SEMICOLON))
 778         next(); // Always performs automatic semicolon insertion.
 779     return context.createDoWhileStatement(location, statement, expr, startLine, endLine);
 780 }
 781 
 782 template &lt;typename LexerType&gt;
 783 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWhileStatement(TreeBuilder&amp; context)
 784 {
 785     ASSERT(match(WHILE));
 786     JSTokenLocation location(tokenLocation());
 787     int startLine = tokenLine();
 788     next();
 789 
 790     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;while loop condition&quot;);
 791     semanticFailIfTrue(match(CLOSEPAREN), &quot;Must provide an expression as a while loop condition&quot;);
 792     TreeExpression expr = parseExpression(context);
 793     failIfFalse(expr, &quot;Unable to parse while loop condition&quot;);
 794     recordPauseLocation(context.breakpointLocation(expr));
 795     int endLine = tokenLine();
 796     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;while loop condition&quot;);
 797 
 798     const Identifier* unused = 0;
 799     startLoop();
 800     TreeStatement statement = parseStatement(context, unused);
 801     endLoop();
 802     failIfFalse(statement, &quot;Expected a statement as the body of a while loop&quot;);
 803     return context.createWhileStatement(location, expr, statement, startLine, endLine);
 804 }
 805 
 806 template &lt;typename LexerType&gt;
 807 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseVariableDeclarationList(TreeBuilder&amp; context, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext declarationListContext, DeclarationType declarationType, ExportType exportType, bool&amp; forLoopConstDoesNotHaveInitializer)
 808 {
 809     ASSERT(declarationType == DeclarationType::LetDeclaration || declarationType == DeclarationType::VarDeclaration || declarationType == DeclarationType::ConstDeclaration);
 810     TreeExpression head = 0;
 811     TreeExpression tail = 0;
 812     const Identifier* lastIdent;
 813     JSToken lastIdentToken;
 814     AssignmentContext assignmentContext = assignmentContextFromDeclarationType(declarationType);
 815     do {
 816         lastIdent = 0;
 817         lastPattern = TreeDestructuringPattern(0);
 818         JSTokenLocation location(tokenLocation());
 819         next();
 820         TreeExpression node = 0;
 821         declarations++;
 822         bool hasInitializer = false;
 823         if (matchSpecIdentifier()) {
 824             failIfTrue(match(LET) &amp;&amp; (declarationType == DeclarationType::LetDeclaration || declarationType == DeclarationType::ConstDeclaration),
 825                 &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
 826             semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, declarationTypeToVariableKind(declarationType), &quot; &quot;, disallowedIdentifierAwaitReason());
 827             JSTextPosition varStart = tokenStartPosition();
 828             JSTokenLocation varStartLocation(tokenLocation());
 829             identStart = varStart;
 830             const Identifier* name = m_token.m_data.ident;
 831             lastIdent = name;
 832             lastIdentToken = m_token;
 833             next();
 834             hasInitializer = match(EQUAL);
 835             DeclarationResultMask declarationResult = declareVariable(name, declarationType);
 836             if (declarationResult != DeclarationResult::Valid) {
 837                 failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &quot;, name-&gt;impl(), &quot; in strict mode&quot;);
 838                 if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 839                     if (declarationType == DeclarationType::LetDeclaration)
 840                         internalFailWithMessage(false, &quot;Cannot declare a let variable twice: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 841                     if (declarationType == DeclarationType::ConstDeclaration)
 842                         internalFailWithMessage(false, &quot;Cannot declare a const variable twice: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 843                     ASSERT(declarationType == DeclarationType::VarDeclaration);
 844                     internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 845                 }
 846             }
 847             if (exportType == ExportType::Exported) {
 848                 semanticFailIfFalse(exportName(*name), &quot;Cannot export a duplicate name &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 849                 m_moduleScopeData-&gt;exportBinding(*name);
 850             }
 851 
 852             if (hasInitializer) {
 853                 JSTextPosition varDivot = tokenStartPosition() + 1;
 854                 initStart = tokenStartPosition();
 855                 next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
 856                 propagateError();
 857                 TreeExpression initializer = parseAssignmentExpression(context);
 858                 initEnd = lastTokenEndPosition();
 859                 lastInitializer = initializer;
 860                 failIfFalse(initializer, &quot;Expected expression as the intializer for the variable &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;);
 861 
 862                 node = context.createAssignResolve(location, *name, initializer, varStart, varDivot, lastTokenEndPosition(), assignmentContext);
 863             } else {
 864                 if (declarationListContext == ForLoopContext &amp;&amp; declarationType == DeclarationType::ConstDeclaration)
 865                     forLoopConstDoesNotHaveInitializer = true;
 866                 failIfTrue(declarationListContext != ForLoopContext &amp;&amp; declarationType == DeclarationType::ConstDeclaration, &quot;const declared variable &#39;&quot;, name-&gt;impl(), &quot;&#39;&quot;, &quot; must have an initializer&quot;);
 867                 if (declarationType == DeclarationType::VarDeclaration)
 868                     node = context.createEmptyVarExpression(varStartLocation, *name);
 869                 else
 870                     node = context.createEmptyLetExpression(varStartLocation, *name);
 871             }
 872         } else {
 873             lastIdent = 0;
 874             auto pattern = parseDestructuringPattern(context, destructuringKindFromDeclarationType(declarationType), exportType, nullptr, nullptr, assignmentContext);
 875             failIfFalse(pattern, &quot;Cannot parse this destructuring pattern&quot;);
 876             hasInitializer = match(EQUAL);
 877             failIfTrue(declarationListContext == VarDeclarationContext &amp;&amp; !hasInitializer, &quot;Expected an initializer in destructuring variable declaration&quot;);
 878             lastPattern = pattern;
 879             if (hasInitializer) {
 880                 next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
 881                 TreeExpression rhs = parseAssignmentExpression(context);
 882                 propagateError();
 883                 ASSERT(rhs);
 884                 node = context.createDestructuringAssignment(location, pattern, rhs);
 885                 lastInitializer = rhs;
 886             }
 887         }
 888 
 889         if (node) {
 890             if (!head)
 891                 head = node;
 892             else if (!tail) {
 893                 head = context.createCommaExpr(location, head);
 894                 tail = context.appendToCommaExpr(location, head, head, node);
 895             } else
 896                 tail = context.appendToCommaExpr(location, head, tail, node);
 897         }
 898     } while (match(COMMA));
 899     if (lastIdent)
 900         lastPattern = context.createBindingLocation(lastIdentToken.m_location, *lastIdent, lastIdentToken.m_startPosition, lastIdentToken.m_endPosition, assignmentContext);
 901 
 902     return head;
 903 }
 904 
 905 template &lt;typename LexerType&gt;
 906 bool Parser&lt;LexerType&gt;::declareRestOrNormalParameter(const Identifier&amp; name, const Identifier** duplicateIdentifier)
 907 {
 908     DeclarationResultMask declarationResult = declareParameter(&amp;name);
 909     if ((declarationResult &amp; DeclarationResult::InvalidStrictMode) &amp;&amp; strictMode()) {
 910         semanticFailIfTrue(isEvalOrArguments(&amp;name), &quot;Cannot destructure to a parameter name &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 911         if (m_parserState.lastFunctionName &amp;&amp; name == *m_parserState.lastFunctionName)
 912             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; as it shadows the name of a strict mode function&quot;);
 913         semanticFailureDueToKeyword(&quot;parameter name&quot;);
 914         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 915             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 916         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 917     }
 918     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 919         // It&#39;s not always an error to define a duplicate parameter.
 920         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 921         // We note this value now so we can check it later.
 922         if (duplicateIdentifier)
 923             *duplicateIdentifier = &amp;name;
 924     }
 925 
 926     return true;
 927 }
 928 
 929 template &lt;typename LexerType&gt;
 930 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, const JSToken&amp; token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)
 931 {
 932     ASSERT(!name.isNull());
 933 
 934     ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());
 935 
 936     switch (kind) {
 937     case DestructuringKind::DestructureToVariables: {
 938         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 939         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 940         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 941             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 942         break;
 943     }
 944 
 945     case DestructuringKind::DestructureToLet:
 946     case DestructuringKind::DestructureToConst:
 947     case DestructuringKind::DestructureToCatchParameters: {
 948         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 949         if (declarationResult != DeclarationResult::Valid) {
 950             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 951             failIfTrue(declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration, &quot;Cannot declare a lexical variable twice: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 952         }
 953         break;
 954     }
 955 
 956     case DestructuringKind::DestructureToParameters: {
 957         declareRestOrNormalParameter(name, duplicateIdentifier);
 958         propagateError();
 959         break;
 960     }
 961 
 962     case DestructuringKind::DestructureToExpressions: {
 963         break;
 964     }
 965     }
 966 
 967     if (exportType == ExportType::Exported) {
 968         semanticFailIfFalse(exportName(name), &quot;Cannot export a duplicate name &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 969         m_moduleScopeData-&gt;exportBinding(name);
 970     }
 971     return context.createBindingLocation(token.m_location, name, token.m_startPosition, token.m_endPosition, bindingContext);
 972 }
 973 
 974 template &lt;typename LexerType&gt;
 975 template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern Parser&lt;LexerType&gt;::createAssignmentElement(TreeBuilder&amp; context, TreeExpression&amp; assignmentTarget, const JSTextPosition&amp; startPosition, const JSTextPosition&amp; endPosition)
 976 {
 977     return context.createAssignmentElement(assignmentTarget, startPosition, endPosition);
 978 }
 979 
 980 template &lt;typename LexerType&gt;
 981 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp; context)
 982 {
 983     ASSERT(!match(OPENBRACE));
 984 
 985     JSTokenLocation location(tokenLocation());
 986     JSTextPosition start = tokenStartPosition();
 987 
 988     failIfStackOverflow();
 989     TreeExpression expr = parseAssignmentExpression(context);
 990     failIfFalse(expr, &quot;Cannot parse the arrow function expression&quot;);
 991 
 992     context.setEndOffset(expr, m_lastTokenEndPosition.offset);
 993 
 994     JSTextPosition end = tokenEndPosition();
 995 
 996     TreeSourceElements sourceElements = context.createSourceElements();
 997     TreeStatement body = context.createReturnStatement(location, expr, start, end);
 998     context.setEndOffset(body, m_lastTokenEndPosition.offset);
 999     recordPauseLocation(context.breakpointLocation(body));
1000     context.appendStatement(sourceElements, body);
1001 
1002     return sourceElements;
1003 }
1004 
1005 template &lt;typename LexerType&gt;
1006 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::tryParseDestructuringPatternExpression(TreeBuilder&amp; context, AssignmentContext bindingContext)
1007 {
1008     return parseDestructuringPattern(context, DestructuringKind::DestructureToExpressions, ExportType::NotExported, nullptr, nullptr, bindingContext);
1009 }
1010 
1011 template &lt;typename LexerType&gt;
1012 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1013 {
1014     if (kind == DestructuringKind::DestructureToExpressions)
1015         return parseAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1016     return parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1017 }
1018 
1019 template &lt;typename LexerType&gt;
1020 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestAssignmentElement(TreeBuilder&amp; context)
1021 {
1022     JSTextPosition startPosition = tokenStartPosition();
1023     auto element = parseMemberExpression(context);
1024 
1025     if (!element || !context.isAssignmentLocation(element)) {
1026         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1027         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1028     }
1029 
1030     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1031         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1032         if (isEvalOrArguments &amp;&amp; strictMode())
1033             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1034         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1035     }
1036 
1037     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1038 }
1039 
1040 template &lt;typename LexerType&gt;
1041 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1042 {
1043     TreeDestructuringPattern assignmentTarget = 0;
1044 
1045     if (match(OPENBRACE) || match(OPENBRACKET)) {
1046         SavePoint savePoint = createSavePoint(context);
1047         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1048         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1049             return assignmentTarget;
1050         restoreSavePoint(context, savePoint);
1051     }
1052 
1053     JSTextPosition startPosition = tokenStartPosition();
1054     auto element = parseMemberExpression(context);
1055 
1056     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1057 
1058     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1059         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1060         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1061     }
1062 
1063     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1064 }
1065 
1066 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1067 {
1068     switch (kind) {
1069     case DestructuringKind::DestructureToLet:
1070     case DestructuringKind::DestructureToConst:
1071         return &quot;lexical variable name&quot;;
1072     case DestructuringKind::DestructureToVariables:
1073         return &quot;variable name&quot;;
1074     case DestructuringKind::DestructureToParameters:
1075         return &quot;parameter name&quot;;
1076     case DestructuringKind::DestructureToCatchParameters:
1077         return &quot;catch parameter name&quot;;
1078     case DestructuringKind::DestructureToExpressions:
1079         return &quot;expression name&quot;;
1080     }
1081     RELEASE_ASSERT_NOT_REACHED();
1082     return &quot;invalid&quot;;
1083 }
1084 
1085 template &lt;typename LexerType&gt;
1086 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext)
1087 {
1088     ASSERT(kind != DestructuringKind::DestructureToExpressions);
1089     failIfStackOverflow();
1090     TreeDestructuringPattern pattern;
1091 
1092     if (!matchSpecIdentifier()) {
1093         semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1094         failWithMessage(&quot;Expected a binding element&quot;);
1095     }
1096     failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1097     semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1098     pattern = createBindingPattern(context, kind, exportType, *m_token.m_data.ident, m_token, bindingContext, duplicateIdentifier);
1099     next();
1100     return pattern;
1101 }
1102 
1103 template &lt;typename LexerType&gt;
1104 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext)
1105 {
1106     if (kind == DestructuringKind::DestructureToExpressions)
1107         return parseObjectRestAssignmentElement(context);
1108     return parseObjectRestElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1109 }
1110 
1111 template &lt;typename LexerType&gt;
1112 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseDestructuringPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1113 {
1114     failIfStackOverflow();
1115     int nonLHSCount = m_parserState.nonLHSCount;
1116     TreeDestructuringPattern pattern;
1117     switch (m_token.m_type) {
1118     case OPENBRACKET: {
1119         JSTextPosition divotStart = tokenStartPosition();
1120         auto arrayPattern = context.createArrayPattern(m_token.m_location);
1121         next();
1122 
1123         if (hasDestructuringPattern)
1124             *hasDestructuringPattern = true;
1125 
1126         bool restElementWasFound = false;
1127 
1128         do {
1129             while (match(COMMA)) {
1130                 context.appendArrayPatternSkipEntry(arrayPattern, m_token.m_location);
1131                 next();
1132             }
1133             propagateError();
1134 
1135             if (match(CLOSEBRACKET))
1136                 break;
1137 
1138             if (UNLIKELY(match(DOTDOTDOT))) {
1139                 JSTokenLocation location = m_token.m_location;
1140                 next();
1141                 auto innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1142                 if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1143                     return 0;
1144                 failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1145                 context.appendArrayPatternRestEntry(arrayPattern, location, innerPattern);
1146                 restElementWasFound = true;
1147                 break;
1148             }
1149 
1150             JSTokenLocation location = m_token.m_location;
1151             auto innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1152             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1153                 return 0;
1154             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1155             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1156             propagateError();
1157             context.appendArrayPatternEntry(arrayPattern, location, innerPattern, defaultValue);
1158         } while (consume(COMMA));
1159 
1160         consumeOrFail(CLOSEBRACKET, restElementWasFound ? &quot;Expected a closing &#39;]&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an element destructuring pattern&quot;);
1161         context.finishArrayPattern(arrayPattern, divotStart, divotStart, lastTokenEndPosition());
1162         pattern = arrayPattern;
1163         break;
1164     }
1165     case OPENBRACE: {
1166         auto objectPattern = context.createObjectPattern(m_token.m_location);
1167         next();
1168 
1169         if (hasDestructuringPattern)
1170             *hasDestructuringPattern = true;
1171 
1172         bool restElementWasFound = false;
1173 
1174         do {
1175             bool wasString = false;
1176 
1177             if (match(CLOSEBRACE))
1178                 break;
1179 
1180             if (match(DOTDOTDOT)) {
1181                 JSTokenLocation location = m_token.m_location;
1182                 next();
1183                 auto innerPattern = parseObjectRestBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, bindingContext);
1184                 propagateError();
1185                 if (!innerPattern)
1186                     return 0;
1187                 context.appendObjectPatternRestEntry(m_vm, objectPattern, location, innerPattern);
1188                 restElementWasFound = true;
1189                 context.setContainsObjectRestElement(objectPattern, restElementWasFound);
1190                 break;
1191             }
1192 
1193             const Identifier* propertyName = nullptr;
1194             TreeExpression propertyExpression = 0;
1195             TreeDestructuringPattern innerPattern = 0;
1196             JSTokenLocation location = m_token.m_location;
1197             if (matchSpecIdentifier()) {
1198                 failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1199                 propertyName = m_token.m_data.ident;
1200                 JSToken identifierToken = m_token;
1201                 next();
1202                 if (consume(COLON))
1203                     innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1204                 else {
1205                     if (kind == DestructuringKind::DestructureToExpressions) {
1206                         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *propertyName || m_vm.propertyNames-&gt;arguments == *propertyName;
1207                         if (isEvalOrArguments &amp;&amp; strictMode())
1208                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1209                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1210                     }
1211                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1212                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1213                 }
1214             } else {
1215                 JSTokenType tokenType = m_token.m_type;
1216                 switch (m_token.m_type) {
1217                 case DOUBLE:
1218                 case INTEGER:
1219                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
1220                     break;
1221                 case STRING:
1222                     propertyName = m_token.m_data.ident;
1223                     wasString = true;
1224                     break;
1225                 case BIGINT:
1226                     propertyName = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);
1227                     break;
1228                 case OPENBRACKET:
1229                     next();
1230                     propertyExpression = parseAssignmentExpression(context);
1231                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1232                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1233                     break;
1234                 default:
1235                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1236                         if (kind == DestructuringKind::DestructureToExpressions)
1237                             return 0;
1238                         failWithMessage(&quot;Expected a property name&quot;);
1239                     }
1240                     propertyName = m_token.m_data.ident;
1241                     break;
1242                 }
1243                 next();
1244                 if (!consume(COLON)) {
1245                     if (kind == DestructuringKind::DestructureToExpressions)
1246                         return 0;
1247                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1248                     semanticFailIfTrue(tokenType == RESERVED_IF_STRICT, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1249                     semanticFailIfTrue(tokenType &amp; KeywordTokenFlag, &quot;Cannot use abbreviated destructuring syntax for keyword &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
1250 
1251                     failWithMessage(&quot;Expected a &#39;:&#39; prior to a named destructuring property&quot;);
1252                 }
1253                 innerPattern = parseBindingOrAssignmentElement(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth + 1);
1254             }
1255             if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !innerPattern)
1256                 return 0;
1257             failIfFalse(innerPattern, &quot;Cannot parse this destructuring pattern&quot;);
1258             TreeExpression defaultValue = parseDefaultValueForDestructuringPattern(context);
1259             propagateError();
1260             if (propertyExpression) {
1261                 context.appendObjectPatternEntry(m_vm, objectPattern, location, propertyExpression, innerPattern, defaultValue);
1262                 context.setContainsComputedProperty(objectPattern, true);
1263             } else {
1264                 ASSERT(propertyName);
1265                 context.appendObjectPatternEntry(objectPattern, location, wasString, *propertyName, innerPattern, defaultValue);
1266             }
1267         } while (consume(COMMA));
1268 
1269         if (kind == DestructuringKind::DestructureToExpressions &amp;&amp; !match(CLOSEBRACE))
1270             return 0;
1271         consumeOrFail(CLOSEBRACE, restElementWasFound ? &quot;Expected a closing &#39;}&#39; following a rest element destructuring pattern&quot; : &quot;Expected either a closing &#39;}&#39; or an &#39;,&#39; after a property destructuring pattern&quot;);
1272         pattern = objectPattern;
1273         break;
1274     }
1275 
1276     default: {
1277         if (!matchSpecIdentifier()) {
1278             if (kind == DestructuringKind::DestructureToExpressions)
1279                 return 0;
1280             semanticFailureDueToKeyword(destructuringKindToVariableKindName(kind));
1281             failWithMessage(&quot;Expected a parameter pattern or a &#39;)&#39; in parameter list&quot;);
1282         }
1283         failIfTrue(match(LET) &amp;&amp; (kind == DestructuringKind::DestructureToLet || kind == DestructuringKind::DestructureToConst), &quot;Cannot use &#39;let&#39; as an identifier name for a LexicalDeclaration&quot;);
1284         semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1285         pattern = createBindingPattern(context, kind, exportType, *m_token.m_data.ident, m_token, bindingContext, duplicateIdentifier);
1286         next();
1287         break;
1288     }
1289     }
1290     m_parserState.nonLHSCount = nonLHSCount;
1291     return pattern;
1292 }
1293 
1294 template &lt;typename LexerType&gt;
1295 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseDefaultValueForDestructuringPattern(TreeBuilder&amp; context)
1296 {
1297     if (!match(EQUAL))
1298         return 0;
1299 
1300     next(TreeBuilder::DontBuildStrings); // consume &#39;=&#39;
1301     return parseAssignmentExpression(context);
1302 }
1303 
1304 template &lt;typename LexerType&gt;
1305 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseForStatement(TreeBuilder&amp; context)
1306 {
1307     ASSERT(match(FOR));
1308     JSTokenLocation location(tokenLocation());
1309     int startLine = tokenLine();
1310     bool isAwaitFor = false;
1311     next();
1312 
1313     DepthManager statementDepth(&amp;m_statementDepth);
1314     m_statementDepth++;
1315 
1316     if (match(AWAIT)) {
1317         semanticFailIfFalse(currentScope()-&gt;isAsyncFunction(), &quot;for-await-of can only be used in an async function or async generator&quot;);
1318         isAwaitFor = true;
1319         next();
1320     }
1321 
1322     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;for-loop header&quot;);
1323     int nonLHSCount = m_parserState.nonLHSCount;
1324     int declarations = 0;
1325     JSTokenLocation declLocation(tokenLocation());
1326     JSTextPosition declsStart;
1327     JSTextPosition declsEnd;
1328     TreeExpression decls = 0;
1329     TreeDestructuringPattern pattern = 0;
1330     bool isVarDeclaraton = match(VAR);
1331     bool isLetDeclaration = match(LET);
1332     bool isConstDeclaration = match(CONSTTOKEN);
1333     bool forLoopConstDoesNotHaveInitializer = false;
1334 
1335     VariableEnvironment dummySet;
1336     VariableEnvironment* lexicalVariables = nullptr;
1337     AutoCleanupLexicalScope lexicalScope;
1338 
1339     auto gatherLexicalVariablesIfNecessary = [&amp;] {
1340         if (isLetDeclaration || isConstDeclaration) {
1341             ScopeRef scope = lexicalScope.scope();
1342             lexicalVariables = &amp;scope-&gt;finalizeLexicalEnvironment();
1343         } else
1344             lexicalVariables = &amp;dummySet;
1345     };
1346 
1347     auto popLexicalScopeIfNecessary = [&amp;] {
1348         if (isLetDeclaration || isConstDeclaration)
1349             popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1350     };
1351 
1352     if (isVarDeclaraton || isLetDeclaration || isConstDeclaration) {
1353         /*
1354          for (var/let/const IDENT in/of expression) statement
1355          for (var/let/const varDeclarationList; expressionOpt; expressionOpt)
1356          */
1357         if (isLetDeclaration || isConstDeclaration) {
1358             ScopeRef newScope = pushScope();
1359             newScope-&gt;setIsLexicalScope();
1360             newScope-&gt;preventVarDeclarations();
1361             lexicalScope.setIsValid(newScope, this);
1362         }
1363 
1364         TreeDestructuringPattern forInTarget = 0;
1365         TreeExpression forInInitializer = 0;
1366         m_allowsIn = false;
1367         JSTextPosition initStart;
1368         JSTextPosition initEnd;
1369         DeclarationType declarationType;
1370         if (isVarDeclaraton)
1371             declarationType = DeclarationType::VarDeclaration;
1372         else if (isLetDeclaration)
1373             declarationType = DeclarationType::LetDeclaration;
1374         else if (isConstDeclaration)
1375             declarationType = DeclarationType::ConstDeclaration;
1376         else
1377             RELEASE_ASSERT_NOT_REACHED();
1378         decls = parseVariableDeclarationList(context, declarations, forInTarget, forInInitializer, declsStart, initStart, initEnd, ForLoopContext, declarationType, ExportType::NotExported, forLoopConstDoesNotHaveInitializer);
1379         m_allowsIn = true;
1380         propagateError();
1381 
1382         // Remainder of a standard for loop is handled identically
1383         if (match(SEMICOLON))
1384             goto standardForLoop;
1385 
1386         failIfFalse(declarations == 1, &quot;can only declare a single variable in an enumeration&quot;);
1387 
1388         // Handle for-in with var declaration
1389         JSTextPosition inLocation = tokenStartPosition();
1390         bool isOfEnumeration = false;
1391         if (!match(INTOKEN)) {
1392             failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);
1393             isOfEnumeration = true;
1394             next();
1395         } else {
1396             failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1397             next();
1398         }
1399 
1400         bool hasAnyAssignments = !!forInInitializer;
1401         if (hasAnyAssignments) {
1402             if (isOfEnumeration)
1403                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-of loop header&quot;);
1404             if (strictMode() || (isLetDeclaration || isConstDeclaration) || !context.isBindingNode(forInTarget))
1405                 internalFailWithMessage(false, &quot;Cannot assign to the loop variable inside a for-in loop header&quot;);
1406         }
1407         TreeExpression expr = parseExpression(context);
1408         failIfFalse(expr, &quot;Expected expression to enumerate&quot;);
1409         recordPauseLocation(context.breakpointLocation(expr));
1410         JSTextPosition exprEnd = lastTokenEndPosition();
1411 
1412         int endLine = tokenLine();
1413 
1414         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1415 
1416         const Identifier* unused = 0;
1417         startLoop();
1418         TreeStatement statement = parseStatement(context, unused);
1419         endLoop();
1420         failIfFalse(statement, &quot;Expected statement as body of for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1421         gatherLexicalVariablesIfNecessary();
1422         TreeStatement result;
1423         if (isOfEnumeration)
1424             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1425         else {
1426             ASSERT(!isAwaitFor);
1427             if (isVarDeclaraton &amp;&amp; forInInitializer)
1428                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1429             else
1430                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1431         }
1432         popLexicalScopeIfNecessary();
1433         return result;
1434     }
1435 
1436     if (!match(SEMICOLON)) {
1437         if (match(OPENBRACE) || match(OPENBRACKET)) {
1438             SavePoint savePoint = createSavePoint(context);
1439             declsStart = tokenStartPosition();
1440             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1441             declsEnd = lastTokenEndPosition();
1442             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))
1443                 goto enumerationLoop;
1444             pattern = TreeDestructuringPattern(0);
1445             restoreSavePoint(context, savePoint);
1446         }
1447         m_allowsIn = false;
1448         declsStart = tokenStartPosition();
1449         decls = parseExpression(context);
1450         declsEnd = lastTokenEndPosition();
1451         m_allowsIn = true;
1452         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1453         recordPauseLocation(context.breakpointLocation(decls));
1454     }
1455 
1456     if (match(SEMICOLON)) {
1457     standardForLoop:
1458         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1459         // Standard for loop
1460         if (decls)
1461             recordPauseLocation(context.breakpointLocation(decls));
1462         next();
1463         TreeExpression condition = 0;
1464         failIfTrue(forLoopConstDoesNotHaveInitializer &amp;&amp; isConstDeclaration, &quot;const variables in for loops must have initializers&quot;);
1465 
1466         if (!match(SEMICOLON)) {
1467             condition = parseExpression(context);
1468             failIfFalse(condition, &quot;Cannot parse for loop condition expression&quot;);
1469             recordPauseLocation(context.breakpointLocation(condition));
1470         }
1471         consumeOrFail(SEMICOLON, &quot;Expected a &#39;;&#39; after the for loop condition expression&quot;);
1472 
1473         TreeExpression increment = 0;
1474         if (!match(CLOSEPAREN)) {
1475             increment = parseExpression(context);
1476             failIfFalse(increment, &quot;Cannot parse for loop iteration expression&quot;);
1477             recordPauseLocation(context.breakpointLocation(increment));
1478         }
1479         int endLine = tokenLine();
1480         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;for-loop header&quot;);
1481         const Identifier* unused = 0;
1482         startLoop();
1483         TreeStatement statement = parseStatement(context, unused);
1484         endLoop();
1485         failIfFalse(statement, &quot;Expected a statement as the body of a for loop&quot;);
1486         gatherLexicalVariablesIfNecessary();
1487         TreeStatement result = context.createForLoop(location, decls, condition, increment, statement, startLine, endLine, *lexicalVariables);
1488         popLexicalScopeIfNecessary();
1489         return result;
1490     }
1491 
1492     // For-in and For-of loop
1493 enumerationLoop:
1494     failIfFalse(nonLHSCount == m_parserState.nonLHSCount, &quot;Expected a reference on the left hand side of an enumeration statement&quot;);
1495     bool isOfEnumeration = false;
1496     if (!match(INTOKEN)) {
1497         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;of), &quot;Expected either &#39;in&#39; or &#39;of&#39; in enumeration syntax&quot;);
1498         isOfEnumeration = true;
1499         next();
1500     } else {
1501         failIfFalse(!isAwaitFor, &quot;Expected &#39;of&#39; in for-await syntax&quot;);
1502         next();
1503     }
1504 
1505     TreeExpression expr = parseExpression(context);
1506     failIfFalse(expr, &quot;Cannot parse subject for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1507     recordPauseLocation(context.breakpointLocation(expr));
1508     JSTextPosition exprEnd = lastTokenEndPosition();
1509     int endLine = tokenLine();
1510 
1511     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, (isOfEnumeration ? &quot;for-of header&quot; : &quot;for-in header&quot;));
1512     const Identifier* unused = 0;
1513     startLoop();
1514     TreeStatement statement = parseStatement(context, unused);
1515     endLoop();
1516     failIfFalse(statement, &quot;Expected a statement as the body of a for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot;loop&quot;);
1517     gatherLexicalVariablesIfNecessary();
1518     TreeStatement result;
1519     if (pattern) {
1520         ASSERT(!decls);
1521         if (isOfEnumeration)
1522             result = context.createForOfLoop(isAwaitFor, location, pattern, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1523         else {
1524             ASSERT(!isAwaitFor);
1525             result = context.createForInLoop(location, pattern, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1526         }
1527 
1528         popLexicalScopeIfNecessary();
1529         return result;
1530     }
1531     if (isOfEnumeration)
1532         result = context.createForOfLoop(isAwaitFor, location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1533     else {
1534         ASSERT(!isAwaitFor);
1535         result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, declsEnd, exprEnd, startLine, endLine, *lexicalVariables);
1536     }
1537     popLexicalScopeIfNecessary();
1538     return result;
1539 }
1540 
1541 template &lt;typename LexerType&gt;
1542 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBreakStatement(TreeBuilder&amp; context)
1543 {
1544     ASSERT(match(BREAK));
1545     JSTokenLocation location(tokenLocation());
1546     JSTextPosition start = tokenStartPosition();
1547     JSTextPosition end = tokenEndPosition();
1548     next();
1549 
1550     if (autoSemiColon()) {
1551         semanticFailIfFalse(breakIsValid(), &quot;&#39;break&#39; is only valid inside a switch or loop statement&quot;);
1552         return context.createBreakStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);
1553     }
1554     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a break statement&quot;);
1555     const Identifier* ident = m_token.m_data.ident;
1556     semanticFailIfFalse(getLabel(ident), &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1557     end = tokenEndPosition();
1558     next();
1559     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted break statement&quot;);
1560     return context.createBreakStatement(location, ident, start, end);
1561 }
1562 
1563 template &lt;typename LexerType&gt;
1564 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseContinueStatement(TreeBuilder&amp; context)
1565 {
1566     ASSERT(match(CONTINUE));
1567     JSTokenLocation location(tokenLocation());
1568     JSTextPosition start = tokenStartPosition();
1569     JSTextPosition end = tokenEndPosition();
1570     next();
1571 
1572     if (autoSemiColon()) {
1573         semanticFailIfFalse(continueIsValid(), &quot;&#39;continue&#39; is only valid inside a loop statement&quot;);
1574         return context.createContinueStatement(location, &amp;m_vm.propertyNames-&gt;nullIdentifier, start, end);
1575     }
1576     failIfFalse(matchSpecIdentifier(), &quot;Expected an identifier as the target for a continue statement&quot;);
1577     const Identifier* ident = m_token.m_data.ident;
1578     ScopeLabelInfo* label = getLabel(ident);
1579     semanticFailIfFalse(label, &quot;Cannot use the undeclared label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
1580     semanticFailIfFalse(label-&gt;isLoop, &quot;Cannot continue to the label &#39;&quot;, ident-&gt;impl(), &quot;&#39; as it is not targeting a loop&quot;);
1581     end = tokenEndPosition();
1582     next();
1583     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted continue statement&quot;);
1584     return context.createContinueStatement(location, ident, start, end);
1585 }
1586 
1587 template &lt;typename LexerType&gt;
1588 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseReturnStatement(TreeBuilder&amp; context)
1589 {
1590     ASSERT(match(RETURN));
1591     JSTokenLocation location(tokenLocation());
1592     semanticFailIfFalse(currentScope()-&gt;isFunction(), &quot;Return statements are only valid inside functions&quot;);
1593     JSTextPosition start = tokenStartPosition();
1594     JSTextPosition end = tokenEndPosition();
1595     next();
1596     // We do the auto semicolon check before attempting to parse expression
1597     // as we need to ensure the a line break after the return correctly terminates
1598     // the statement
1599     if (match(SEMICOLON))
1600         end = tokenEndPosition();
1601 
1602     if (autoSemiColon())
1603         return context.createReturnStatement(location, 0, start, end);
1604     TreeExpression expr = parseExpression(context);
1605     failIfFalse(expr, &quot;Cannot parse the return expression&quot;);
1606     end = lastTokenEndPosition();
1607     if (match(SEMICOLON))
1608         end  = tokenEndPosition();
1609     if (!autoSemiColon())
1610         failWithMessage(&quot;Expected a &#39;;&#39; following a return statement&quot;);
1611     return context.createReturnStatement(location, expr, start, end);
1612 }
1613 
1614 template &lt;typename LexerType&gt;
1615 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseThrowStatement(TreeBuilder&amp; context)
1616 {
1617     ASSERT(match(THROW));
1618     JSTokenLocation location(tokenLocation());
1619     JSTextPosition start = tokenStartPosition();
1620     next();
1621     failIfTrue(match(SEMICOLON), &quot;Expected expression after &#39;throw&#39;&quot;);
1622     semanticFailIfTrue(autoSemiColon(), &quot;Cannot have a newline after &#39;throw&#39;&quot;);
1623 
1624     TreeExpression expr = parseExpression(context);
1625     failIfFalse(expr, &quot;Cannot parse expression for throw statement&quot;);
1626     JSTextPosition end = lastTokenEndPosition();
1627     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; after a throw statement&quot;);
1628 
1629     return context.createThrowStatement(location, expr, start, end);
1630 }
1631 
1632 template &lt;typename LexerType&gt;
1633 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseWithStatement(TreeBuilder&amp; context)
1634 {
1635     ASSERT(match(WITH));
1636     JSTokenLocation location(tokenLocation());
1637     semanticFailIfTrue(strictMode(), &quot;&#39;with&#39; statements are not valid in strict mode&quot;);
1638     currentScope()-&gt;setNeedsFullActivation();
1639     int startLine = tokenLine();
1640     next();
1641 
1642     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;subject of a &#39;with&#39; statement&quot;);
1643     int start = tokenStart();
1644     TreeExpression expr = parseExpression(context);
1645     failIfFalse(expr, &quot;Cannot parse &#39;with&#39; subject expression&quot;);
1646     recordPauseLocation(context.breakpointLocation(expr));
1647     JSTextPosition end = lastTokenEndPosition();
1648     int endLine = tokenLine();
1649     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;start&quot;, &quot;subject of a &#39;with&#39; statement&quot;);
1650     const Identifier* unused = 0;
1651     TreeStatement statement = parseStatement(context, unused);
1652     failIfFalse(statement, &quot;A &#39;with&#39; statement must have a body&quot;);
1653 
1654     return context.createWithStatement(location, expr, statement, start, end, startLine, endLine);
1655 }
1656 
1657 template &lt;typename LexerType&gt;
1658 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseSwitchStatement(TreeBuilder&amp; context)
1659 {
1660     ASSERT(match(SWITCH));
1661     JSTokenLocation location(tokenLocation());
1662     int startLine = tokenLine();
1663     next();
1664     handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;subject of a &#39;switch&#39;&quot;);
1665     TreeExpression expr = parseExpression(context);
1666     failIfFalse(expr, &quot;Cannot parse switch subject expression&quot;);
1667     recordPauseLocation(context.breakpointLocation(expr));
1668     int endLine = tokenLine();
1669 
1670     handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;subject of a &#39;switch&#39;&quot;);
1671     handleProductionOrFail(OPENBRACE, &quot;{&quot;, &quot;start&quot;, &quot;body of a &#39;switch&#39;&quot;);
1672     AutoPopScopeRef lexicalScope(this, pushScope());
1673     lexicalScope-&gt;setIsLexicalScope();
1674     lexicalScope-&gt;preventVarDeclarations();
1675     startSwitch();
1676     TreeClauseList firstClauses = parseSwitchClauses(context);
1677     propagateError();
1678 
1679     TreeClause defaultClause = parseSwitchDefaultClause(context);
1680     propagateError();
1681 
1682     TreeClauseList secondClauses = parseSwitchClauses(context);
1683     propagateError();
1684     endSwitch();
1685     handleProductionOrFail(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;body of a &#39;switch&#39;&quot;);
1686 
1687     TreeStatement result = context.createSwitchStatement(location, expr, firstClauses, defaultClause, secondClauses, startLine, endLine, lexicalScope-&gt;finalizeLexicalEnvironment(), lexicalScope-&gt;takeFunctionDeclarations());
1688     popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1689     return result;
1690 }
1691 
1692 template &lt;typename LexerType&gt;
1693 template &lt;class TreeBuilder&gt; TreeClauseList Parser&lt;LexerType&gt;::parseSwitchClauses(TreeBuilder&amp; context)
1694 {
1695     if (!match(CASE))
1696         return 0;
1697     unsigned startOffset = tokenStart();
1698     next();
1699     TreeExpression condition = parseExpression(context);
1700     failIfFalse(condition, &quot;Cannot parse switch clause&quot;);
1701     consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch clause expression&quot;);
1702     TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1703     failIfFalse(statements, &quot;Cannot parse the body of a switch clause&quot;);
1704     TreeClause clause = context.createClause(condition, statements);
1705     context.setStartOffset(clause, startOffset);
1706     TreeClauseList clauseList = context.createClauseList(clause);
1707     TreeClauseList tail = clauseList;
1708 
1709     while (match(CASE)) {
1710         startOffset = tokenStart();
1711         next();
1712         TreeExpression condition = parseExpression(context);
1713         failIfFalse(condition, &quot;Cannot parse switch case expression&quot;);
1714         consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch clause expression&quot;);
1715         TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1716         failIfFalse(statements, &quot;Cannot parse the body of a switch clause&quot;);
1717         clause = context.createClause(condition, statements);
1718         context.setStartOffset(clause, startOffset);
1719         tail = context.createClauseList(tail, clause);
1720     }
1721     return clauseList;
1722 }
1723 
1724 template &lt;typename LexerType&gt;
1725 template &lt;class TreeBuilder&gt; TreeClause Parser&lt;LexerType&gt;::parseSwitchDefaultClause(TreeBuilder&amp; context)
1726 {
1727     if (!match(DEFAULT))
1728         return 0;
1729     unsigned startOffset = tokenStart();
1730     next();
1731     consumeOrFail(COLON, &quot;Expected a &#39;:&#39; after switch default clause&quot;);
1732     TreeSourceElements statements = parseSourceElements(context, DontCheckForStrictMode);
1733     failIfFalse(statements, &quot;Cannot parse the body of a switch default clause&quot;);
1734     TreeClause result = context.createClause(0, statements);
1735     context.setStartOffset(result, startOffset);
1736     return result;
1737 }
1738 
1739 template &lt;typename LexerType&gt;
1740 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseTryStatement(TreeBuilder&amp; context)
1741 {
1742     ASSERT(match(TRY));
1743     JSTokenLocation location(tokenLocation());
1744     TreeStatement tryBlock = 0;
1745     TreeDestructuringPattern catchPattern = 0;
1746     TreeStatement catchBlock = 0;
1747     TreeStatement finallyBlock = 0;
1748     int firstLine = tokenLine();
1749     next();
1750     matchOrFail(OPENBRACE, &quot;Expected a block statement as body of a try statement&quot;);
1751 
1752     tryBlock = parseBlockStatement(context);
1753     failIfFalse(tryBlock, &quot;Cannot parse the body of try block&quot;);
1754     int lastLine = m_lastTokenEndPosition.line;
1755     VariableEnvironment catchEnvironment;
1756     if (match(CATCH)) {
1757         next();
1758 
1759         if (match(OPENBRACE)) {
1760             catchBlock = parseBlockStatement(context);
1761             failIfFalse(catchBlock, &quot;Unable to parse &#39;catch&#39; block&quot;);
1762         } else {
1763             handleProductionOrFail(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;catch&#39; target&quot;);
1764             AutoPopScopeRef catchScope(this, pushScope());
1765             catchScope-&gt;setIsLexicalScope();
1766             catchScope-&gt;preventVarDeclarations();
1767             const Identifier* ident = nullptr;
1768             if (matchSpecIdentifier()) {
1769                 catchScope-&gt;setIsSimpleCatchParameterScope();
1770                 ident = m_token.m_data.ident;
1771                 catchPattern = context.createBindingLocation(m_token.m_location, *ident, m_token.m_startPosition, m_token.m_endPosition, AssignmentContext::DeclarationStatement);
1772                 next();
1773                 failIfTrueIfStrict(catchScope-&gt;declareLexicalVariable(ident, false) &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a catch variable named &#39;&quot;, ident-&gt;impl(), &quot;&#39; in strict mode&quot;);
1774             } else {
1775                 catchPattern = parseDestructuringPattern(context, DestructuringKind::DestructureToCatchParameters, ExportType::NotExported);
1776                 failIfFalse(catchPattern, &quot;Cannot parse this destructuring pattern&quot;);
1777             }
1778             handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;catch&#39; target&quot;);
1779             matchOrFail(OPENBRACE, &quot;Expected exception handler to be a block statement&quot;);
1780             catchBlock = parseBlockStatement(context);
1781             failIfFalse(catchBlock, &quot;Unable to parse &#39;catch&#39; block&quot;);
1782             catchEnvironment = catchScope-&gt;finalizeLexicalEnvironment();
1783             RELEASE_ASSERT(!ident || (catchEnvironment.size() == 1 &amp;&amp; catchEnvironment.contains(ident-&gt;impl())));
1784             popScope(catchScope, TreeBuilder::NeedsFreeVariableInfo);
1785         }
1786     }
1787 
1788     if (match(FINALLY)) {
1789         next();
1790         matchOrFail(OPENBRACE, &quot;Expected block statement for finally body&quot;);
1791         finallyBlock = parseBlockStatement(context);
1792         failIfFalse(finallyBlock, &quot;Cannot parse finally body&quot;);
1793     }
1794     failIfFalse(catchBlock || finallyBlock, &quot;Try statements must have at least a catch or finally block&quot;);
1795     return context.createTryStatement(location, tryBlock, catchPattern, catchBlock, finallyBlock, firstLine, lastLine, catchEnvironment);
1796 }
1797 
1798 template &lt;typename LexerType&gt;
1799 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseDebuggerStatement(TreeBuilder&amp; context)
1800 {
1801     ASSERT(match(DEBUGGER));
1802     JSTokenLocation location(tokenLocation());
1803     int startLine = tokenLine();
1804     int endLine = startLine;
1805     next();
1806     if (match(SEMICOLON))
1807         startLine = tokenLine();
1808     failIfFalse(autoSemiColon(), &quot;Debugger keyword must be followed by a &#39;;&#39;&quot;);
1809     return context.createDebugger(location, startLine, endLine);
1810 }
1811 
1812 template &lt;typename LexerType&gt;
1813 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseBlockStatement(TreeBuilder&amp; context)
1814 {
1815     ASSERT(match(OPENBRACE));
1816 
1817     // We should treat the first block statement of the function (the body of the function) as the lexical
1818     // scope of the function itself, and not the lexical scope of a &#39;block&#39; statement within the function.
1819     AutoCleanupLexicalScope lexicalScope;
1820     bool shouldPushLexicalScope = m_statementDepth &gt; 0;
1821     if (shouldPushLexicalScope) {
1822         ScopeRef newScope = pushScope();
1823         newScope-&gt;setIsLexicalScope();
1824         newScope-&gt;preventVarDeclarations();
1825         lexicalScope.setIsValid(newScope, this);
1826     }
1827     JSTokenLocation location(tokenLocation());
1828     int startOffset = m_token.m_data.offset;
1829     int start = tokenLine();
1830     VariableEnvironment emptyEnvironment;
1831     DeclarationStacks::FunctionStack emptyFunctionStack;
1832     next();
1833     if (match(CLOSEBRACE)) {
1834         int endOffset = m_token.m_data.offset;
1835         next();
1836         TreeStatement result = context.createBlockStatement(location, 0, start, m_lastTokenEndPosition.line, shouldPushLexicalScope ? currentScope()-&gt;finalizeLexicalEnvironment() : emptyEnvironment, shouldPushLexicalScope ? currentScope()-&gt;takeFunctionDeclarations() : WTFMove(emptyFunctionStack));
1837         context.setStartOffset(result, startOffset);
1838         context.setEndOffset(result, endOffset);
1839         if (shouldPushLexicalScope)
1840             popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1841         return result;
1842     }
1843     TreeSourceElements subtree = parseSourceElements(context, DontCheckForStrictMode);
1844     failIfFalse(subtree, &quot;Cannot parse the body of the block statement&quot;);
1845     matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; at the end of a block statement&quot;);
1846     int endOffset = m_token.m_data.offset;
1847     next();
1848     TreeStatement result = context.createBlockStatement(location, subtree, start, m_lastTokenEndPosition.line, shouldPushLexicalScope ? currentScope()-&gt;finalizeLexicalEnvironment() : emptyEnvironment, shouldPushLexicalScope ? currentScope()-&gt;takeFunctionDeclarations() : WTFMove(emptyFunctionStack));
1849     context.setStartOffset(result, startOffset);
1850     context.setEndOffset(result, endOffset);
1851     if (shouldPushLexicalScope)
1852         popScope(lexicalScope, TreeBuilder::NeedsFreeVariableInfo);
1853 
1854     return result;
1855 }
1856 
1857 template &lt;typename LexerType&gt;
1858 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatement(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
1859 {
1860     DepthManager statementDepth(&amp;m_statementDepth);
1861     m_statementDepth++;
1862     int nonTrivialExpressionCount = 0;
1863     failIfStackOverflow();
1864     TreeStatement result = 0;
1865     bool shouldSetEndOffset = true;
1866     bool shouldSetPauseLocation = false;
1867     bool parentAllowsFunctionDeclarationAsStatement = m_immediateParentAllowsFunctionDeclarationInStatement;
1868     m_immediateParentAllowsFunctionDeclarationInStatement = false;
1869 
1870     switch (m_token.m_type) {
1871     case OPENBRACE:
1872         result = parseBlockStatement(context);
1873         shouldSetEndOffset = false;
1874         break;
1875     case VAR:
1876         result = parseVariableDeclaration(context, DeclarationType::VarDeclaration);
1877         shouldSetPauseLocation = true;
1878         break;
1879     case FUNCTION: {
1880         const bool isAsync = false;
1881         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
1882         break;
1883     }
1884     case SEMICOLON: {
1885         JSTokenLocation location(tokenLocation());
1886         next();
1887         result = context.createEmptyStatement(location);
1888         shouldSetPauseLocation = true;
1889         break;
1890     }
1891     case IF:
1892         result = parseIfStatement(context);
1893         break;
1894     case DO:
1895         result = parseDoWhileStatement(context);
1896         break;
1897     case WHILE:
1898         result = parseWhileStatement(context);
1899         break;
1900     case FOR:
1901         result = parseForStatement(context);
1902         break;
1903     case CONTINUE:
1904         result = parseContinueStatement(context);
1905         shouldSetPauseLocation = true;
1906         break;
1907     case BREAK:
1908         result = parseBreakStatement(context);
1909         shouldSetPauseLocation = true;
1910         break;
1911     case RETURN:
1912         result = parseReturnStatement(context);
1913         shouldSetPauseLocation = true;
1914         break;
1915     case WITH:
1916         result = parseWithStatement(context);
1917         break;
1918     case SWITCH:
1919         result = parseSwitchStatement(context);
1920         break;
1921     case THROW:
1922         result = parseThrowStatement(context);
1923         shouldSetPauseLocation = true;
1924         break;
1925     case TRY:
1926         result = parseTryStatement(context);
1927         break;
1928     case DEBUGGER:
1929         result = parseDebuggerStatement(context);
1930         shouldSetPauseLocation = true;
1931         break;
1932     case EOFTOK:
1933     case CASE:
1934     case CLOSEBRACE:
1935     case DEFAULT:
1936         // These tokens imply the end of a set of source elements
1937         return 0;
1938     case LET: {
1939         if (!strictMode())
1940             goto identcase;
1941         goto defaultCase;
1942     }
1943     case IDENT:
1944         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
1945             if (maybeParseAsyncFunctionDeclarationStatement(context, result, parentAllowsFunctionDeclarationAsStatement))
1946                 break;
1947         }
1948         FALLTHROUGH;
1949     case AWAIT:
1950     case YIELD: {
1951         identcase:
1952         bool allowFunctionDeclarationAsStatement = false;
1953         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
1954         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
1955         break;
1956     }
1957     case STRING:
1958         directive = m_token.m_data.ident;
1959         if (directiveLiteralLength)
1960             *directiveLiteralLength = m_token.m_location.endOffset - m_token.m_location.startOffset;
1961         nonTrivialExpressionCount = m_parserState.nonTrivialExpressionCount;
1962         FALLTHROUGH;
1963     default:
1964         defaultCase:
1965         TreeStatement exprStatement = parseExpressionStatement(context);
1966         if (directive &amp;&amp; nonTrivialExpressionCount != m_parserState.nonTrivialExpressionCount)
1967             directive = nullptr;
1968         result = exprStatement;
1969         shouldSetPauseLocation = true;
1970         break;
1971     }
1972 
1973     if (result) {
1974         if (shouldSetEndOffset)
1975             context.setEndOffset(result, m_lastTokenEndPosition.offset);
1976         if (shouldSetPauseLocation)
1977             recordPauseLocation(context.breakpointLocation(result));
1978     }
1979 
1980     return result;
1981 }
1982 
1983 template &lt;typename LexerType&gt;
1984 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclarationStatement(TreeBuilder&amp; context, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement)
1985 {
1986     semanticFailIfTrue(strictMode(), &quot;Function declarations are only allowed inside blocks or switch statements in strict mode&quot;);
1987     failIfFalse(parentAllowsFunctionDeclarationAsStatement, &quot;Function declarations are only allowed inside block statements or at the top level of a program&quot;);
1988     if (!currentScope()-&gt;isFunction() &amp;&amp; !closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext()) {
1989         // We only implement annex B.3.3 if we&#39;re in function mode or eval mode. Otherwise, we fall back
1990         // to hoisting behavior.
1991         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=155813
1992         DepthManager statementDepth(&amp;m_statementDepth);
1993         m_statementDepth = 1;
1994         if (isAsync)
1995             return parseAsyncFunctionDeclaration(context);
1996         return parseFunctionDeclaration(context);
1997     }
1998 
1999     // Any function declaration that isn&#39;t in a block is a syntax error unless it&#39;s
2000     // in an if/else statement. If it&#39;s in an if/else statement, we will magically
2001     // treat it as if the if/else statement is inside a block statement.
2002     // to the very top like a &quot;var&quot;. For example:
2003     // function a() {
2004     //     if (cond) function foo() { }
2005     // }
2006     // will be rewritten as:
2007     // function a() {
2008     //     if (cond) { function foo() { } }
2009     // }
2010     AutoPopScopeRef blockScope(this, pushScope());
2011     blockScope-&gt;setIsLexicalScope();
2012     blockScope-&gt;preventVarDeclarations();
2013     JSTokenLocation location(tokenLocation());
2014     int start = tokenLine();
2015 
2016     TreeStatement function = 0;
2017     if (!isAsync)
2018         function = parseFunctionDeclaration(context);
2019     else
2020         function = parseAsyncFunctionDeclaration(context);
2021     propagateError();
2022     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2023     TreeSourceElements sourceElements = context.createSourceElements();
2024     context.appendStatement(sourceElements, function);
2025     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2026     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2027     return result;
2028 }
2029 
2030 template &lt;typename LexerType&gt;
2031 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2032 {
2033     ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
2034     SavePoint savePoint = createSavePoint(context);
2035     next();
2036     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2037         const bool isAsync = true;
2038         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2039         return true;
2040     }
2041     restoreSavePoint(context, savePoint);
2042     return false;
2043 }
2044 
2045 template &lt;typename LexerType&gt;
2046 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2047 {
2048 #define failIfDuplicateIfViolation() \
2049     if (duplicateParameter) {\
2050         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2051         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2052         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2053         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
2054         semanticFailIfTrue(isMethod, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in a method&quot;);\
2055     }
2056 
2057     bool hasDefaultParameterValues = false;
2058     bool hasDestructuringPattern = false;
2059     bool isRestParameter = false;
2060     const Identifier* duplicateParameter = nullptr;
2061     unsigned restParameterStart = 0;
2062     do {
2063         TreeDestructuringPattern parameter = 0;
2064         TreeExpression defaultValue = 0;
2065 
2066         if (UNLIKELY(match(CLOSEPAREN)))
2067             break;
2068 
2069         if (match(DOTDOTDOT)) {
2070             next();
2071             semanticFailIfTrue(!m_parserState.allowAwait &amp;&amp; match(AWAIT), &quot;Cannot use &#39;await&#39; as a parameter name in an async function&quot;);
2072             TreeDestructuringPattern destructuringPattern = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2073             propagateError();
2074             parameter = context.createRestParameter(destructuringPattern, restParameterStart);
2075             failIfTrue(match(COMMA), &quot;Rest parameter should be the last parameter in a function declaration&quot;); // Let&#39;s have a good error message for this common case.
2076             isRestParameter = true;
2077         } else
2078             parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2079         failIfFalse(parameter, &quot;Cannot parse parameter pattern&quot;);
2080         if (!isRestParameter) {
2081             defaultValue = parseDefaultValueForDestructuringPattern(context);
2082             if (defaultValue)
2083                 hasDefaultParameterValues = true;
2084         }
2085         propagateError();
2086         failIfDuplicateIfViolation();
2087         if (isRestParameter || defaultValue || hasDestructuringPattern)
2088             currentScope()-&gt;setHasNonSimpleParameterList();
2089         context.appendParameter(list, parameter, defaultValue);
2090         if (!isRestParameter) {
2091             restParameterStart++;
2092             if (!hasDefaultParameterValues)
2093                 parameterCount++;
2094         }
2095     } while (!isRestParameter &amp;&amp; consume(COMMA));
2096 
2097     return true;
2098 #undef failIfDuplicateIfViolation
2099 }
2100 
2101 template &lt;typename LexerType&gt;
2102 template &lt;class TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(
2103     TreeBuilder&amp; context, SyntaxChecker&amp; syntaxChecker, const JSTokenLocation&amp; startLocation, int startColumn, int functionKeywordStart, int functionNameStart, int parametersStart,
2104     ConstructorKind constructorKind, SuperBinding superBinding, FunctionBodyType bodyType, unsigned parameterCount, SourceParseMode parseMode)
2105 {
2106     SetForScope&lt;bool&gt; overrideParsingClassFieldInitializer(m_parserState.isParsingClassFieldInitializer, bodyType == StandardFunctionBodyBlock ? false : m_parserState.isParsingClassFieldInitializer);
2107     bool isArrowFunctionBodyExpression = bodyType == ArrowFunctionBodyExpression;
2108     if (!isArrowFunctionBodyExpression) {
2109         next();
2110         if (match(CLOSEBRACE)) {
2111             unsigned endColumn = tokenColumn();
2112             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2113             return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2114         }
2115     }
2116 
2117     DepthManager statementDepth(&amp;m_statementDepth);
2118     m_statementDepth = 0;
2119     if (bodyType == ArrowFunctionBodyExpression) {
2120         if (m_debuggerParseData)
2121             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse body of this arrow function&quot;);
2122         else
2123             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse body of this arrow function&quot;);
2124     } else {
2125         if (m_debuggerParseData)
2126             failIfFalse(parseSourceElements(context, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
2127         else
2128             failIfFalse(parseSourceElements(syntaxChecker, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
2129     }
2130     unsigned endColumn = tokenColumn();
2131     SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2132     return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2133 }
2134 
2135 static const char* stringArticleForFunctionMode(SourceParseMode mode)
2136 {
2137     switch (mode) {
2138     case SourceParseMode::GetterMode:
2139     case SourceParseMode::SetterMode:
2140     case SourceParseMode::NormalFunctionMode:
2141     case SourceParseMode::MethodMode:
2142     case SourceParseMode::GeneratorBodyMode:
2143     case SourceParseMode::GeneratorWrapperFunctionMode:
2144     case SourceParseMode::GeneratorWrapperMethodMode:
2145         return &quot;a &quot;;
2146     case SourceParseMode::ArrowFunctionMode:
2147     case SourceParseMode::AsyncFunctionMode:
2148     case SourceParseMode::AsyncFunctionBodyMode:
2149     case SourceParseMode::AsyncMethodMode:
2150     case SourceParseMode::AsyncArrowFunctionBodyMode:
2151     case SourceParseMode::AsyncArrowFunctionMode:
2152     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2153     case SourceParseMode::AsyncGeneratorBodyMode:
2154     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2155         return &quot;an &quot;;
2156     case SourceParseMode::ProgramMode:
2157     case SourceParseMode::ModuleAnalyzeMode:
2158     case SourceParseMode::ModuleEvaluateMode:
2159     case SourceParseMode::InstanceFieldInitializerMode:
2160         RELEASE_ASSERT_NOT_REACHED();
2161         return &quot;&quot;;
2162     }
2163     RELEASE_ASSERT_NOT_REACHED();
2164     return nullptr;
2165 }
2166 
2167 static const char* stringForFunctionMode(SourceParseMode mode)
2168 {
2169     switch (mode) {
2170     case SourceParseMode::GetterMode:
2171         return &quot;getter&quot;;
2172     case SourceParseMode::SetterMode:
2173         return &quot;setter&quot;;
2174     case SourceParseMode::NormalFunctionMode:
2175         return &quot;function&quot;;
2176     case SourceParseMode::MethodMode:
2177         return &quot;method&quot;;
2178     case SourceParseMode::GeneratorBodyMode:
2179         return &quot;generator&quot;;
2180     case SourceParseMode::GeneratorWrapperFunctionMode:
2181     case SourceParseMode::GeneratorWrapperMethodMode:
2182         return &quot;generator function&quot;;
2183     case SourceParseMode::ArrowFunctionMode:
2184         return &quot;arrow function&quot;;
2185     case SourceParseMode::AsyncFunctionMode:
2186     case SourceParseMode::AsyncFunctionBodyMode:
2187         return &quot;async function&quot;;
2188     case SourceParseMode::AsyncMethodMode:
2189         return &quot;async method&quot;;
2190     case SourceParseMode::AsyncArrowFunctionBodyMode:
2191     case SourceParseMode::AsyncArrowFunctionMode:
2192         return &quot;async arrow function&quot;;
2193     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2194     case SourceParseMode::AsyncGeneratorBodyMode:
2195         return &quot;async generator function&quot;;
2196     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2197         return &quot;async generator method&quot;;
2198     case SourceParseMode::ProgramMode:
2199     case SourceParseMode::ModuleAnalyzeMode:
2200     case SourceParseMode::ModuleEvaluateMode:
2201     case SourceParseMode::InstanceFieldInitializerMode:
2202         RELEASE_ASSERT_NOT_REACHED();
2203         return &quot;&quot;;
2204     }
2205     RELEASE_ASSERT_NOT_REACHED();
2206     return nullptr;
2207 }
2208 
2209 template &lt;typename LexerType&gt; template &lt;class TreeBuilder, class FunctionInfoType&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::parseFunctionParameters(TreeBuilder&amp; context, SourceParseMode mode, FunctionInfoType&amp; functionInfo)
2210 {
2211     RELEASE_ASSERT(!(SourceParseModeSet(SourceParseMode::ProgramMode, SourceParseMode::ModuleAnalyzeMode, SourceParseMode::ModuleEvaluateMode).contains(mode)));
2212     TreeFormalParameterList parameterList = context.createFormalParameterList();
2213     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Parameters);
2214 
2215     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2216         if (!matchSpecIdentifier() &amp;&amp; !match(OPENPAREN)) {
2217             semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2218             failWithMessage(&quot;Expected an arrow function input parameter&quot;);
2219         } else {
2220             if (match(OPENPAREN)) {
2221                 next();
2222 
2223                 if (match(CLOSEPAREN)) {
2224                     functionInfo.parameterCount = 0;
2225                 } else {
2226                     bool isArrowFunction = true;
2227                     bool isMethod = false;
2228                     failIfFalse(parseFormalParameters(context, parameterList, isArrowFunction, isMethod, functionInfo.parameterCount), &quot;Cannot parse parameters for this &quot;, stringForFunctionMode(mode));
2229                 }
2230 
2231                 consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; or a &#39;,&#39; after a parameter declaration&quot;);
2232             } else {
2233                 functionInfo.parameterCount = 1;
2234                 auto parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported);
2235                 failIfFalse(parameter, &quot;Cannot parse parameter pattern&quot;);
2236                 context.appendParameter(parameterList, parameter, 0);
2237             }
2238         }
2239 
2240         return parameterList;
2241     }
2242 
2243     if (!consume(OPENPAREN)) {
2244         semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2245         failWithMessage(&quot;Expected an opening &#39;(&#39; before a &quot;, stringForFunctionMode(mode), &quot;&#39;s parameter list&quot;);
2246     }
2247 
2248     if (mode == SourceParseMode::GetterMode) {
2249         consumeOrFail(CLOSEPAREN, &quot;getter functions must have no parameters&quot;);
2250         functionInfo.parameterCount = 0;
2251     } else if (mode == SourceParseMode::SetterMode) {
2252         failIfTrue(match(CLOSEPAREN), &quot;setter functions must have one parameter&quot;);
2253         const Identifier* duplicateParameter = nullptr;
2254         bool hasDestructuringPattern = false;
2255         auto parameter = parseDestructuringPattern(context, DestructuringKind::DestructureToParameters, ExportType::NotExported, &amp;duplicateParameter, &amp;hasDestructuringPattern);
2256         failIfFalse(parameter, &quot;setter functions must have one parameter&quot;);
2257         auto defaultValue = parseDefaultValueForDestructuringPattern(context);
2258         propagateError();
2259         if (defaultValue || hasDestructuringPattern) {
2260             semanticFailIfTrue(duplicateParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with non-simple parameter list&quot;);
2261             currentScope()-&gt;setHasNonSimpleParameterList();
2262         }
2263         context.appendParameter(parameterList, parameter, defaultValue);
2264         functionInfo.parameterCount = defaultValue ? 0 : 1;
2265         failIfTrue(match(COMMA), &quot;setter functions must have one parameter&quot;);
2266         consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; after a parameter declaration&quot;);
2267     } else {
2268         if (match(CLOSEPAREN)) {
2269             functionInfo.parameterCount = 0;
2270         } else {
2271             bool isArrowFunction = false;
2272             bool isMethod = isMethodParseMode(mode);
2273             failIfFalse(parseFormalParameters(context, parameterList, isArrowFunction, isMethod, functionInfo.parameterCount), &quot;Cannot parse parameters for this &quot;, stringForFunctionMode(mode));
2274         }
2275         consumeOrFail(CLOSEPAREN, &quot;Expected a &#39;)&#39; or a &#39;,&#39; after a parameter declaration&quot;);
2276     }
2277 
2278     return parameterList;
2279 }
2280 
2281 template &lt;typename LexerType&gt;
2282 template &lt;class TreeBuilder&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::createGeneratorParameters(TreeBuilder&amp; context, unsigned&amp; parameterCount)
2283 {
2284     auto parameters = context.createFormalParameterList();
2285 
2286     JSTokenLocation location(tokenLocation());
2287     JSTextPosition position = tokenStartPosition();
2288 
2289     auto addParameter = [&amp;](const Identifier&amp; name) {
2290         declareParameter(&amp;name);
2291         auto binding = context.createBindingLocation(location, name, position, position, AssignmentContext::DeclarationStatement);
2292         context.appendParameter(parameters, binding, 0);
2293         ++parameterCount;
2294     };
2295 
2296     // @generator
2297     addParameter(m_vm.propertyNames-&gt;generatorPrivateName);
2298     // @generatorState
2299     addParameter(m_vm.propertyNames-&gt;generatorStatePrivateName);
2300     // @generatorValue
2301     addParameter(m_vm.propertyNames-&gt;generatorValuePrivateName);
2302     // @generatorResumeMode
2303     addParameter(m_vm.propertyNames-&gt;generatorResumeModePrivateName);
2304     // @generatorFrame
2305     addParameter(m_vm.propertyNames-&gt;generatorFramePrivateName);
2306 
2307     return parameters;
2308 }
2309 
2310 template &lt;typename LexerType&gt;
2311 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFunctionInfo(TreeBuilder&amp; context, FunctionNameRequirements requirements, SourceParseMode mode, bool nameIsInContainingScope, ConstructorKind constructorKind, SuperBinding expectedSuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp; functionInfo, FunctionDefinitionType functionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2312 {
2313     RELEASE_ASSERT(isFunctionParseMode(mode));
2314 
2315     ScopeRef parentScope = currentScope();
2316 
2317     bool isDisallowedAwaitFunctionName = isDisallowedIdentifierAwait(m_token);
2318     const char* isDisallowedAwaitFunctionNameReason = isDisallowedAwaitFunctionName ? disallowedIdentifierAwaitReason() : nullptr;
2319 
2320     AutoPopScopeRef functionScope(this, pushScope());
2321     functionScope-&gt;setSourceParseMode(mode);
2322     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2323     functionScope-&gt;setConstructorKind(constructorKind);
2324     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
2325     int functionNameStart = m_token.m_location.startOffset;
2326     const Identifier* lastFunctionName = m_parserState.lastFunctionName;
2327     m_parserState.lastFunctionName = nullptr;
2328     int parametersStart = -1;
2329     JSTokenLocation startLocation;
2330     int startColumn = -1;
2331     FunctionBodyType functionBodyType;
2332 
2333     auto loadCachedFunction = [&amp;] () -&gt; bool {
2334         if (UNLIKELY(!Options::useSourceProviderCache()))
2335             return false;
2336 
2337         if (UNLIKELY(m_debuggerParseData))
2338             return false;
2339 
2340         ASSERT(parametersStart != -1);
2341         ASSERT(startColumn != -1);
2342 
2343         // If we know about this function already, we can use the cached info and skip the parser to the end of the function.
2344         if (const SourceProviderCacheItem* cachedInfo = TreeBuilder::CanUseFunctionCache ? findCachedFunctionInfo(parametersStart) : 0) {
2345             // If we&#39;re in a strict context, the cached function info must say it was strict too.
2346             ASSERT(!strictMode() || cachedInfo-&gt;strictMode);
2347             JSTokenLocation endLocation;
2348 
2349             ConstructorKind constructorKind = static_cast&lt;ConstructorKind&gt;(cachedInfo-&gt;constructorKind);
2350             SuperBinding expectedSuperBinding = static_cast&lt;SuperBinding&gt;(cachedInfo-&gt;expectedSuperBinding);
2351 
2352             endLocation.line = cachedInfo-&gt;lastTokenLine;
2353             endLocation.startOffset = cachedInfo-&gt;lastTokenStartOffset;
2354             endLocation.lineStartOffset = cachedInfo-&gt;lastTokenLineStartOffset;
2355             ASSERT(endLocation.startOffset &gt;= endLocation.lineStartOffset);
2356 
2357             bool endColumnIsOnStartLine = endLocation.line == functionInfo.startLine;
2358             unsigned currentLineStartOffset = m_lexer-&gt;currentLineStartOffset();
2359             unsigned bodyEndColumn = endColumnIsOnStartLine ? endLocation.startOffset - currentLineStartOffset : endLocation.startOffset - endLocation.lineStartOffset;
2360 
2361             ASSERT(endLocation.startOffset &gt;= endLocation.lineStartOffset);
2362 
2363             FunctionBodyType functionBodyType;
2364             if (UNLIKELY(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))
2365                 functionBodyType = cachedInfo-&gt;isBodyArrowExpression ?  ArrowFunctionBodyExpression : ArrowFunctionBodyBlock;
2366             else
2367                 functionBodyType = StandardFunctionBodyBlock;
2368 
2369             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, expectedSuperBinding, cachedInfo-&gt;needsSuperBinding, cachedInfo-&gt;usesEval, cachedInfo-&gt;innerArrowFunctionFeatures);
2370 
2371             functionInfo.body = context.createFunctionMetadata(
2372                 startLocation, endLocation, startColumn, bodyEndColumn,
2373                 functionKeywordStart, functionNameStart, parametersStart,
2374                 cachedInfo-&gt;strictMode, constructorKind, functionSuperBinding,
2375                 cachedInfo-&gt;parameterCount,
2376                 mode, functionBodyType == ArrowFunctionBodyExpression);
2377             functionInfo.endOffset = cachedInfo-&gt;endFunctionOffset;
2378             functionInfo.parameterCount = cachedInfo-&gt;parameterCount;
2379 
2380             functionScope-&gt;restoreFromSourceProviderCache(cachedInfo);
2381             popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2382 
2383             m_token = cachedInfo-&gt;endFunctionToken();
2384 
2385             if (endColumnIsOnStartLine)
2386                 m_token.m_location.lineStartOffset = currentLineStartOffset;
2387 
2388             m_lexer-&gt;setOffset(m_token.m_location.endOffset, m_token.m_location.lineStartOffset);
2389             m_lexer-&gt;setLineNumber(m_token.m_location.line);
2390 
2391             switch (functionBodyType) {
2392             case ArrowFunctionBodyExpression:
2393                 next();
2394                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2395                 break;
2396             case ArrowFunctionBodyBlock:
2397             case StandardFunctionBodyBlock:
2398                 context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2399                 next();
2400                 break;
2401             }
2402             functionInfo.endLine = m_lastTokenEndPosition.line;
2403             return true;
2404         }
2405 
2406         return false;
2407     };
2408 
2409     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
2410 
2411     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2412         startLocation = tokenLocation();
2413         functionInfo.startLine = tokenLine();
2414         startColumn = tokenColumn();
2415 
2416         parametersStart = m_token.m_location.startOffset;
2417         functionInfo.startOffset = parametersStart;
2418         functionInfo.parametersStartColumn = startColumn;
2419 
2420         if (loadCachedFunction())
2421             return true;
2422 
2423         {
2424             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2425             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2426             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
2427             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !parentScope-&gt;isAsyncFunction() &amp;&amp; !isAsyncFunctionParseMode(mode));
2428             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2429             propagateError();
2430         }
2431 
2432         matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
2433 
2434         if (m_lexer-&gt;hasLineTerminatorBeforeToken())
2435             failDueToUnexpectedToken();
2436 
2437         ASSERT(constructorKind == ConstructorKind::None);
2438 
2439         // Check if arrow body start with {. If it true it mean that arrow function is Fat arrow function
2440         // and we need use common approach to parse function body
2441         next();
2442         functionBodyType = match(OPENBRACE) ? ArrowFunctionBodyBlock : ArrowFunctionBodyExpression;
2443     } else {
2444         // http://ecma-international.org/ecma-262/6.0/#sec-function-definitions
2445         // FunctionExpression :
2446         //     function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
2447         //
2448         // FunctionDeclaration[Yield, Default] :
2449         //     function BindingIdentifier[?Yield] ( FormalParameters ) { FunctionBody }
2450         //     [+Default] function ( FormalParameters ) { FunctionBody }
2451         //
2452         // GeneratorDeclaration[Yield, Default] :
2453         //     function * BindingIdentifier[?Yield] ( FormalParameters[Yield] ) { GeneratorBody }
2454         //     [+Default] function * ( FormalParameters[Yield] ) { GeneratorBody }
2455         //
2456         // GeneratorExpression :
2457         //     function * BindingIdentifier[Yield]opt ( FormalParameters[Yield] ) { GeneratorBody }
2458         //
2459         // The name of FunctionExpression and AsyncFunctionExpression can accept &quot;yield&quot; even in the context of generator.
2460         bool upperScopeIsGenerator = false;
2461         if (!(functionDefinitionType == FunctionDefinitionType::Expression &amp;&amp; SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::AsyncFunctionMode).contains(mode)))
2462             upperScopeIsGenerator = upperScope(1)-&gt;isGenerator();
2463 
2464         if (requirements != FunctionNameRequirements::Unnamed) {
2465             ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !functionInfo.name), &quot;When specifying FunctionNameRequirements::None, we need to initialize functionInfo.name with the default value in the caller side.&quot;);
2466             if (matchSpecIdentifier(upperScopeIsGenerator)) {
2467                 functionInfo.name = m_token.m_data.ident;
2468                 m_parserState.lastFunctionName = functionInfo.name;
2469                 if (UNLIKELY(isDisallowedAwaitFunctionName))
2470                     semanticFailIfTrue(functionDefinitionType == FunctionDefinitionType::Declaration || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode), &quot;Cannot declare function named &#39;await&#39; &quot;, isDisallowedAwaitFunctionNameReason);
2471                 else if (isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode) &amp;&amp; match(AWAIT) &amp;&amp; functionDefinitionType == FunctionDefinitionType::Expression)
2472                     semanticFail(&quot;Cannot declare &quot;, stringForFunctionMode(mode), &quot; named &#39;await&#39;&quot;);
2473                 else if (isGeneratorWrapperParseMode(mode) &amp;&amp; match(YIELD) &amp;&amp; functionDefinitionType == FunctionDefinitionType::Expression)
2474                     semanticFail(&quot;Cannot declare generator function named &#39;yield&#39;&quot;);
2475                 next();
2476                 if (!nameIsInContainingScope)
2477                     failIfTrueIfStrict(functionScope-&gt;declareCallee(functionInfo.name) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid &quot;, stringForFunctionMode(mode), &quot; name in strict mode&quot;);
2478             } else if (requirements == FunctionNameRequirements::Named) {
2479                 if (match(OPENPAREN)) {
2480                     semanticFailIfTrue(mode == SourceParseMode::NormalFunctionMode, &quot;Function statements must have a name&quot;);
2481                     semanticFailIfTrue(mode == SourceParseMode::AsyncFunctionMode, &quot;Async function statements must have a name&quot;);
2482                 }
2483                 semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2484                 failDueToUnexpectedToken();
2485                 return false;
2486             }
2487             ASSERT(functionInfo.name);
2488         }
2489 
2490         startLocation = tokenLocation();
2491         functionInfo.startLine = tokenLine();
2492         startColumn = tokenColumn();
2493         functionInfo.parametersStartColumn = startColumn;
2494 
2495         parametersStart = m_token.m_location.startOffset;
2496         functionInfo.startOffset = parametersStart;
2497 
2498         if (loadCachedFunction())
2499             return true;
2500         {
2501             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2502             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2503             propagateError();
2504         }
2505 
2506         matchOrFail(OPENBRACE, &quot;Expected an opening &#39;{&#39; at the start of a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2507 
2508         // If the code is invoked from function constructor, we need to ensure that parameters are only composed by the string offered as parameters.
2509         if (UNLIKELY(functionConstructorParametersEndPosition))
2510             semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
2511 
2512         // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
2513         // Set ConstructorKind to None for non-constructor methods of classes.
2514 
2515         if (parentScope-&gt;isGlobalCodeScope() &amp;&amp; m_defaultConstructorKindForTopLevelFunction != ConstructorKind::None) {
2516             constructorKind = m_defaultConstructorKindForTopLevelFunction;
2517             expectedSuperBinding = m_defaultConstructorKindForTopLevelFunction == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;
2518         }
2519 
2520         functionBodyType = StandardFunctionBodyBlock;
2521     }
2522 
2523     functionScope-&gt;setConstructorKind(constructorKind);
2524     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2525 
2526     m_parserState.lastFunctionName = lastFunctionName;
2527     ParserState oldState = internalSaveParserState(context);
2528 
2529     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
2530     // This loop collects the set of capture candidates that aren&#39;t
2531     // part of the set of this function&#39;s declared parameters. We will
2532     // figure out which parameters are captured for this function when
2533     // we actually generate code for it. For now, we just propagate to
2534     // our parent scopes which variables we might have closed over that
2535     // belong to them. This is necessary for correctness when using
2536     // the source provider cache because we can&#39;t close over a variable
2537     // that we don&#39;t claim to close over. The source provider cache must
2538     // know this information to properly cache this function.
2539     // This might work itself out nicer if we declared a different
2540     // Scope struct for the parameters (because they are indeed implemented
2541     // as their own scope).
2542     UniquedStringImplPtrSet nonLocalCapturesFromParameterExpressions;
2543     functionScope-&gt;forEachUsedVariable([&amp;] (UniquedStringImpl* impl) {
2544         if (!functionScope-&gt;hasDeclaredParameter(impl)) {
2545             nonLocalCapturesFromParameterExpressions.add(impl);
2546             if (TreeBuilder::NeedsFreeVariableInfo)
2547                 parentScope-&gt;addClosedVariableCandidateUnconditionally(impl);
2548         }
2549     });
2550 
2551     auto performParsingFunctionBody = [&amp;] {
2552         return parseFunctionBody(context, syntaxChecker, startLocation, startColumn, functionKeywordStart, functionNameStart, parametersStart, constructorKind, expectedSuperBinding, functionBodyType, functionInfo.parameterCount, mode);
2553     };
2554 
2555     if (isGeneratorOrAsyncFunctionWrapperParseMode(mode)) {
2556         AutoPopScopeRef generatorBodyScope(this, pushScope());
2557         SourceParseMode innerParseMode = SourceParseMode::GeneratorBodyMode;
2558         if (isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode))
2559             innerParseMode = getAsynFunctionBodyParseMode(mode);
2560 
2561         generatorBodyScope-&gt;setSourceParseMode(innerParseMode);
2562         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
2563         generatorBodyScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2564 
2565         // Disallow &#39;use strict&#39; directives in the implicit inner function if
2566         // needed.
2567         if (functionScope-&gt;hasNonSimpleParameterList())
2568             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2569 
2570         functionInfo.body = performParsingFunctionBody();
2571 
2572         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2573         if  (generatorBodyScope-&gt;strictMode())
2574             functionScope-&gt;setStrictMode();
2575 
2576         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2577     } else
2578         functionInfo.body = performParsingFunctionBody();
2579 
2580     restoreParserState(context, oldState);
2581     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2582     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2583     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2584         ASSERT(functionInfo.name);
2585         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
2586         semanticFailIfTrue(m_vm.propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2587         semanticFailIfTrue(m_vm.propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2588     }
2589 
2590     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2591     functionInfo.endOffset = m_token.m_data.offset;
2592 
2593     if (functionBodyType == ArrowFunctionBodyExpression) {
2594         location = locationBeforeLastToken();
2595         functionInfo.endOffset = location.endOffset;
2596     } else {
2597         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2598         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2599     }
2600 
2601     // Cache the tokenizer state and the function scope the first time the function is parsed.
2602     // Any future reparsing can then skip the function.
2603     // For arrow function is 8 = x=&gt;x + 4 symbols;
2604     // For ordinary function is 16  = function(){} + 4 symbols
2605     const int minimumSourceLengthToCache = functionBodyType == StandardFunctionBodyBlock ? 16 : 8;
2606     std::unique_ptr&lt;SourceProviderCacheItem&gt; newInfo;
2607     int sourceLength = functionInfo.endOffset - functionInfo.startOffset;
2608     if (TreeBuilder::CanUseFunctionCache &amp;&amp; m_functionCache &amp;&amp; sourceLength &gt; minimumSourceLengthToCache) {
2609         SourceProviderCacheItemCreationParameters parameters;
2610         parameters.endFunctionOffset = functionInfo.endOffset;
2611         parameters.lastTokenLine = location.line;
2612         parameters.lastTokenStartOffset = location.startOffset;
2613         parameters.lastTokenEndOffset = location.endOffset;
2614         parameters.lastTokenLineStartOffset = location.lineStartOffset;
2615         parameters.parameterCount = functionInfo.parameterCount;
2616         parameters.constructorKind = constructorKind;
2617         parameters.expectedSuperBinding = expectedSuperBinding;
2618         if (functionBodyType == ArrowFunctionBodyExpression) {
2619             parameters.isBodyArrowExpression = true;
2620             parameters.tokenType = m_token.m_type;
2621         }
2622         functionScope-&gt;fillParametersForSourceProviderCache(parameters, nonLocalCapturesFromParameterExpressions);
2623         newInfo = SourceProviderCacheItem::create(parameters);
2624     }
2625 
2626     bool functionScopeWasStrictMode = functionScope-&gt;strictMode();
2627 
2628     popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2629 
2630     if (functionBodyType != ArrowFunctionBodyExpression) {
2631         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2632         next();
2633     } else {
2634         // We need to lex the last token again because the last token is lexed under the different context because of the following possibilities.
2635         // 1. which may have different strict mode.
2636         // 2. which may not build strings for tokens.
2637         // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
2638         // So we only check TreeBuilder&#39;s type here.
2639         ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
2640         if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
2641             lexCurrentTokenAgainUnderCurrentContext(context);
2642     }
2643 
2644     if (newInfo)
2645         m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
2646 
2647     functionInfo.endLine = m_lastTokenEndPosition.line;
2648     return true;
2649 }
2650 
2651 static NO_RETURN_DUE_TO_CRASH FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
2652 static FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;ASTBuilder&gt;&amp; info) { return info.body; }
2653 
2654 template &lt;typename LexerType&gt;
2655 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2656 {
2657     ASSERT(match(FUNCTION));
2658     JSTokenLocation location(tokenLocation());
2659     unsigned functionKeywordStart = tokenStart();
2660     next();
2661     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
2662     if (consume(TIMES))
2663         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
2664 
2665     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
2666     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2667     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2668         // Under the &quot;export default&quot; context, function declaration does not require the function name.
2669         //
2670         //     ExportDeclaration:
2671         //         ...
2672         //         export default HoistableDeclaration[~Yield, +Default]
2673         //         ...
2674         //
2675         //     HoistableDeclaration[Yield, Default]:
2676         //         FunctionDeclaration[?Yield, ?Default]
2677         //         GeneratorDeclaration[?Yield, ?Default]
2678         //
2679         //     FunctionDeclaration[Yield, Default]:
2680         //         ...
2681         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2682         //
2683         //     GeneratorDeclaration[Yield, Default]:
2684         //         ...
2685         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2686         //
2687         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2688         requirements = FunctionNameRequirements::None;
2689         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
2690     }
2691 
2692     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this function&quot;);
2693     ASSERT(functionInfo.name);
2694 
2695     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2696     DeclarationResultMask declarationResult = functionDeclaration.first;
2697     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2698     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2699         internalFailWithMessage(false, &quot;Cannot declare a function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2700     if (exportType == ExportType::Exported) {
2701         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2702         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2703         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2704     }
2705 
2706     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2707     if (TreeBuilder::CreatesAST)
2708         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2709     return result;
2710 }
2711 
2712 template &lt;typename LexerType&gt;
2713 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseAsyncFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2714 {
2715     ASSERT(match(FUNCTION));
2716     JSTokenLocation location(tokenLocation());
2717     unsigned functionKeywordStart = tokenStart();
2718     next();
2719     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
2720     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
2721     if (consume(TIMES))
2722         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
2723 
2724     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2725     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2726         // Under the &quot;export default&quot; context, function declaration does not require the function name.
2727         //
2728         //     ExportDeclaration:
2729         //         ...
2730         //         export default HoistableDeclaration[~Yield, +Default]
2731         //         ...
2732         //
2733         //     HoistableDeclaration[Yield, Default]:
2734         //         FunctionDeclaration[?Yield, ?Default]
2735         //         GeneratorDeclaration[?Yield, ?Default]
2736         //
2737         //     FunctionDeclaration[Yield, Default]:
2738         //         ...
2739         //         [+Default] function ( FormalParameters[~Yield] ) { FunctionBody[~Yield] }
2740         //
2741         //     GeneratorDeclaration[Yield, Default]:
2742         //         ...
2743         //         [+Default] function * ( FormalParameters[+Yield] ) { GeneratorBody }
2744         //
2745         // In this case, we use &quot;*default*&quot; as this function declaration&#39;s name.
2746         requirements = FunctionNameRequirements::None;
2747         functionInfo.name = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
2748     }
2749 
2750     failIfFalse((parseFunctionInfo(context, requirements, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Declaration, functionConstructorParametersEndPosition)), &quot;Cannot parse this async function&quot;);
2751     failIfFalse(functionInfo.name, &quot;Async function statements must have a name&quot;);
2752 
2753     std::pair&lt;DeclarationResultMask, ScopeRef&gt; functionDeclaration = declareFunction(functionInfo.name);
2754     DeclarationResultMask declarationResult = functionDeclaration.first;
2755     failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an async function named &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2756     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2757         internalFailWithMessage(false, &quot;Cannot declare an async function that shadows a let/const/class/function variable &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; in strict mode&quot;);
2758     if (exportType == ExportType::Exported) {
2759         semanticFailIfFalse(exportName(*functionInfo.name), &quot;Cannot export a duplicate function name: &#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39;&quot;);
2760         m_moduleScopeData-&gt;exportBinding(*functionInfo.name);
2761     }
2762 
2763     TreeStatement result = context.createFuncDeclStatement(location, functionInfo);
2764     if (TreeBuilder::CreatesAST)
2765         functionDeclaration.second-&gt;appendFunction(getMetadata(functionInfo));
2766     return result;
2767 }
2768 
2769 template &lt;typename LexerType&gt;
2770 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseClassDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext)
2771 {
2772     ASSERT(match(CLASSTOKEN));
2773     JSTokenLocation location(tokenLocation());
2774     JSTextPosition classStart = tokenStartPosition();
2775     unsigned classStartLine = tokenLine();
2776 
2777     ParserClassInfo&lt;TreeBuilder&gt; info;
2778     FunctionNameRequirements requirements = FunctionNameRequirements::Named;
2779     if (declarationDefaultContext == DeclarationDefaultContext::ExportDefault) {
2780         // Under the &quot;export default&quot; context, class declaration does not require the class name.
2781         //
2782         //     ExportDeclaration:
2783         //         ...
2784         //         export default ClassDeclaration[~Yield, +Default]
2785         //         ...
2786         //
2787         //     ClassDeclaration[Yield, Default]:
2788         //         ...
2789         //         [+Default] class ClassTail[?Yield]
2790         //
2791         // In this case, we use &quot;*default*&quot; as this class declaration&#39;s name.
2792         requirements = FunctionNameRequirements::None;
2793         info.className = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
2794     }
2795 
2796     TreeClassExpression classExpr = parseClass(context, requirements, info);
2797     failIfFalse(classExpr, &quot;Failed to parse class&quot;);
2798     ASSERT(info.className);
2799 
2800     DeclarationResultMask declarationResult = declareVariable(info.className, DeclarationType::LetDeclaration);
2801     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
2802         internalFailWithMessage(false, &quot;Cannot declare a class twice: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2803     if (exportType == ExportType::Exported) {
2804         ASSERT_WITH_MESSAGE(declarationDefaultContext != DeclarationDefaultContext::ExportDefault, &quot;Export default case will export the name and binding in the caller.&quot;);
2805         semanticFailIfFalse(exportName(*info.className), &quot;Cannot export a duplicate class name: &#39;&quot;, info.className-&gt;impl(), &quot;&#39;&quot;);
2806         m_moduleScopeData-&gt;exportBinding(*info.className);
2807     }
2808 
2809     JSTextPosition classEnd = lastTokenEndPosition();
2810     unsigned classEndLine = tokenLine();
2811 
2812     return context.createClassDeclStatement(location, classExpr, classStart, classEnd, classStartLine, classEndLine);
2813 }
2814 
2815 template &lt;typename LexerType&gt;
2816 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClass(TreeBuilder&amp; context, FunctionNameRequirements requirements, ParserClassInfo&lt;TreeBuilder&gt;&amp; info)
2817 {
2818     ASSERT(match(CLASSTOKEN));
2819     JSTokenLocation location(tokenLocation());
2820     info.startLine = location.line;
2821     info.startColumn = tokenColumn();
2822     info.startOffset = location.startOffset;
2823     next();
2824 
2825     AutoPopScopeRef classScope(this, pushScope());
2826     classScope-&gt;setIsLexicalScope();
2827     classScope-&gt;preventVarDeclarations();
2828     classScope-&gt;setStrictMode();
2829 
2830     ASSERT_WITH_MESSAGE(requirements != FunctionNameRequirements::Unnamed, &quot;Currently, there is no caller that uses FunctionNameRequirements::Unnamed for class syntax.&quot;);
2831     ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !info.className), &quot;When specifying FunctionNameRequirements::None, we need to initialize info.className with the default value in the caller side.&quot;);
2832     if (match(IDENT)) {
2833         info.className = m_token.m_data.ident;
2834         next();
2835         failIfTrue(classScope-&gt;declareLexicalVariable(info.className, true) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, info.className-&gt;impl(), &quot;&#39; is not a valid class name&quot;);
2836     } else if (requirements == FunctionNameRequirements::Named) {
2837         if (match(OPENBRACE))
2838             semanticFail(&quot;Class statements must have a name&quot;);
2839         semanticFailureDueToKeyword(&quot;class name&quot;);
2840         failDueToUnexpectedToken();
2841     }
2842     ASSERT(info.className);
2843 
2844     TreeExpression parentClass = 0;
2845     if (consume(EXTENDS)) {
2846         parentClass = parseMemberExpression(context);
2847         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2848     }
2849     classScope-&gt;setIsClassScope();
2850     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2851 
2852     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2853 
2854     TreeExpression constructor = 0;
2855     TreePropertyList classElements = 0;
2856     TreePropertyList classElementsTail = 0;
2857     unsigned numComputedFields = 0;
2858     while (!match(CLOSEBRACE)) {
2859         if (match(SEMICOLON)) {
2860             next();
2861             continue;
2862         }
2863 
2864         JSTokenLocation methodLocation(tokenLocation());
2865         unsigned methodStart = tokenStart();
2866 
2867         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2868         ClassElementTag tag = ClassElementTag::Instance;
2869         auto type = PropertyNode::Constant;
2870         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {
2871             SavePoint savePoint = createSavePoint(context);
2872             next();
2873             if (match(OPENPAREN)) {
2874                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
2875                 restoreSavePoint(context, savePoint);
2876             } else
2877                 tag = ClassElementTag::Static;
2878         }
2879 
2880         // FIXME: Figure out a way to share more code with parseProperty.
2881         const CommonIdentifiers&amp; propertyNames = *m_vm.propertyNames;
2882         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2883         TreeExpression computedPropertyName = 0;
2884         bool isGetter = false;
2885         bool isSetter = false;
2886         SourceParseMode parseMode = SourceParseMode::MethodMode;
2887         if (consume(TIMES))
2888             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2889 
2890 parseMethod:
2891         switch (m_token.m_type) {
2892         namedKeyword:
2893         case STRING:
2894             ident = m_token.m_data.ident;
2895             ASSERT(ident);
2896             next();
2897             break;
2898         case BIGINT:
2899             ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);
2900             ASSERT(ident);
2901             next();
2902             break;
2903         case IDENT:
2904             if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
2905                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2906                     ident = m_token.m_data.ident;
2907                     next();
2908                     // We match SEMICOLON as a special case for a field called &#39;async&#39; without initializer.
2909                     if (match(OPENPAREN) || match(COLON) || match(SEMICOLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())
2910                         break;
2911                     if (UNLIKELY(consume(TIMES)))
2912                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2913                     else
2914                         parseMode = SourceParseMode::AsyncMethodMode;
2915                     goto parseMethod;
2916                 }
2917             }
2918             FALLTHROUGH;
2919         case AWAIT:
2920             ident = m_token.m_data.ident;
2921             ASSERT(ident);
2922             next();
2923             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(BIGINT) || match(OPENBRACKET))) {
2924                 isGetter = *ident == propertyNames.get;
2925                 isSetter = *ident == propertyNames.set;
2926             }
2927             break;
2928         case DOUBLE:
2929         case INTEGER:
2930             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
2931             ASSERT(ident);
2932             next();
2933             break;
2934         case OPENBRACKET:
2935             next();
2936             computedPropertyName = parseAssignmentExpression(context);
2937             type = static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed);
2938             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2939             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2940             break;
2941         default:
2942             if (m_token.m_type &amp; KeywordTokenFlag)
2943                 goto namedKeyword;
2944             failDueToUnexpectedToken();
2945         }
2946 
2947         TreeProperty property;
2948         const bool alwaysStrictInsideClass = true;
2949         if (isGetter || isSetter) {
2950             type = static_cast&lt;PropertyNode::Type&gt;(type &amp; ~PropertyNode::Constant);
2951             type = static_cast&lt;PropertyNode::Type&gt;(type | (isGetter ? PropertyNode::Getter : PropertyNode::Setter));
2952             property = parseGetterSetter(context, alwaysStrictInsideClass, type, methodStart, ConstructorKind::None, tag);
2953             failIfFalse(property, &quot;Cannot parse this method&quot;);
2954         } else if (Options::useClassFields() &amp;&amp; !match(OPENPAREN) &amp;&amp; tag == ClassElementTag::Instance &amp;&amp; parseMode == SourceParseMode::MethodMode) {
2955             ASSERT(!isGetter &amp;&amp; !isSetter);
2956             if (ident)
2957                 semanticFailIfTrue(*ident == propertyNames.constructor, &quot;Cannot declare class field named &#39;constructor&#39;&quot;);
2958 
2959             if (computedPropertyName) {
2960                 ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(m_vm, numComputedFields++);
2961                 DeclarationResultMask declarationResult = classScope-&gt;declareLexicalVariable(ident, true);
2962                 ASSERT_UNUSED(declarationResult, declarationResult == DeclarationResult::Valid);
2963                 classScope-&gt;useVariable(ident, false);
2964                 classScope-&gt;addClosedVariableCandidateUnconditionally(ident-&gt;impl());
2965             }
2966 
2967             TreeExpression initializer = 0;
2968             if (consume(EQUAL)) {
2969                 SetForScope&lt;bool&gt; overrideParsingClassFieldInitializer(m_parserState.isParsingClassFieldInitializer, true);
2970                 classScope-&gt;setExpectedSuperBinding(SuperBinding::Needed);
2971                 initializer = parseAssignmentExpression(context);
2972                 classScope-&gt;setExpectedSuperBinding(SuperBinding::NotNeeded);
2973                 failIfFalse(initializer, &quot;Cannot parse initializer for class field&quot;);
2974                 classScope-&gt;markLastUsedVariablesSetAsCaptured();
2975             }
2976             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a class field&quot;);
2977             auto inferName = initializer ? InferName::Allowed : InferName::Disallowed;
2978             if (computedPropertyName)
2979                 property = context.createProperty(ident, computedPropertyName, initializer, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::NotNeeded, tag);
2980             else
2981                 property = context.createProperty(ident, initializer, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::NotNeeded, inferName, tag);
2982         } else {
2983             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2984             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2985             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2986                 isConstructor = false;
2987                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);
2988                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);
2989             }
2990 
2991             methodInfo.name = isConstructor ? info.className : ident;
2992             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2993 
2994             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2995             if (isConstructor) {
2996                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2997                 constructor = method;
2998                 continue;
2999             }
3000 
3001             // FIXME: Syntax error when super() is called
3002             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
3003                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
3004 
3005             if (computedPropertyName) {
3006                 property = context.createProperty(computedPropertyName, method, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);
3007             } else {
3008                 property = context.createProperty(methodInfo.name, method, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);
3009             }
3010         }
3011 
3012         if (classElementsTail)
3013             classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
3014         else
3015             classElements = classElementsTail = context.createPropertyList(methodLocation, property);
3016     }
3017 
3018     info.endOffset = tokenLocation().endOffset - 1;
3019     consumeOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a class body&quot;);
3020 
3021     auto classExpression = context.createClassExpr(location, info, classScope-&gt;finalizeLexicalEnvironment(), constructor, parentClass, classElements);
3022     popScope(classScope, TreeBuilder::NeedsFreeVariableInfo);
3023     return classExpression;
3024 }
3025 
3026 template &lt;typename LexerType&gt;
3027 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseInstanceFieldInitializerSourceElements(TreeBuilder&amp; context, const Vector&lt;JSTextPosition&gt;&amp; instanceFieldLocations)
3028 {
3029     TreeSourceElements sourceElements = context.createSourceElements();
3030     currentScope()-&gt;setIsClassScope();
3031 
3032     unsigned numComputedFields = 0;
3033     for (auto location : instanceFieldLocations) {
3034         // We don&#39;t need to worry about hasLineTerminatorBeforeToken
3035         // on class fields, so we set this value to false.
3036         LexerState lexerState { location.offset, static_cast&lt;unsigned&gt;(location.lineStartOffset), static_cast&lt;unsigned&gt;(location.line), static_cast&lt;unsigned&gt;(location.line), false };
3037         restoreLexerState(lexerState);
3038 
3039         JSTokenLocation fieldLocation = tokenLocation();
3040         const Identifier* ident = nullptr;
3041         TreeExpression computedPropertyName = 0;
3042         DefineFieldNode::Type type = DefineFieldNode::Type::Name;
3043         switch (m_token.m_type) {
3044         case STRING:
3045         case IDENT:
3046         namedKeyword:
3047             ident = m_token.m_data.ident;
3048             ASSERT(ident);
3049             next();
3050             break;
3051         case BIGINT:
3052             ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);
3053             ASSERT(ident);
3054             next();
3055             break;
3056         case DOUBLE:
3057         case INTEGER:
3058             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
3059             ASSERT(ident);
3060             next();
3061             break;
3062         case OPENBRACKET:
3063             next();
3064             computedPropertyName = parseAssignmentExpression(context);
3065             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
3066             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
3067             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(m_vm, numComputedFields++);
3068             type = DefineFieldNode::Type::ComputedName;
3069             break;
3070         default:
3071             if (m_token.m_type &amp; KeywordTokenFlag)
3072                 goto namedKeyword;
3073             failDueToUnexpectedToken();
3074         }
3075 
3076         // Only valid class fields are handled in this function.
3077         ASSERT(match(EQUAL) || match(SEMICOLON) || match(CLOSEBRACE) || m_lexer-&gt;hasLineTerminatorBeforeToken());
3078 
3079         TreeExpression initializer = 0;
3080         if (consume(EQUAL))
3081             initializer = parseAssignmentExpression(context);
3082 
3083         TreeStatement defineField = context.createDefineField(fieldLocation, ident, initializer, type);
3084         context.appendStatement(sourceElements, defineField);
3085     }
3086 
3087     ASSERT(!hasError());
3088     // Trick parseInner() into believing we&#39;ve parsed the entire SourceCode, in order to prevent it from producing an error.
3089     m_token.m_type = EOFTOK;
3090     return sourceElements;
3091 }
3092 
3093 struct LabelInfo {
3094     LabelInfo(const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
3095     : m_ident(ident)
3096     , m_start(start)
3097     , m_end(end)
3098     {
3099     }
3100 
3101     const Identifier* m_ident;
3102     JSTextPosition m_start;
3103     JSTextPosition m_end;
3104 };
3105 
3106 template &lt;typename LexerType&gt;
3107 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionOrLabelStatement(TreeBuilder&amp; context, bool allowFunctionDeclarationAsStatement)
3108 {
3109 
3110     /* Expression and Label statements are ambiguous at LL(1), so we have a
3111      * special case that looks for a colon as the next character in the input.
3112      */
3113     Vector&lt;LabelInfo&gt; labels;
3114     JSTokenLocation location;
3115     do {
3116         JSTextPosition start = tokenStartPosition();
3117         location = tokenLocation();
3118         if (!nextTokenIsColon()) {
3119             // If we hit this path we&#39;re making a expression statement, which
3120             // by definition can&#39;t make use of continue/break so we can just
3121             // ignore any labels we might have accumulated.
3122             TreeExpression expression = parseExpression(context);
3123             failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3124             if (!autoSemiColon())
3125                 failDueToUnexpectedToken();
3126             return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3127         }
3128 
3129         semanticFailIfTrue(isDisallowedIdentifierAwait(m_token), &quot;Cannot use &#39;await&#39; as a label &quot;, disallowedIdentifierAwaitReason());
3130         semanticFailIfTrue(isDisallowedIdentifierYield(m_token), &quot;Cannot use &#39;yield&#39; as a label &quot;, disallowedIdentifierYieldReason());
3131 
3132         const Identifier* ident = m_token.m_data.ident;
3133         JSTextPosition end = tokenEndPosition();
3134         next();
3135         consumeOrFail(COLON, &quot;Labels must be followed by a &#39;:&#39;&quot;);
3136 
3137         // This is O(N^2) over the current list of consecutive labels, but I
3138         // have never seen more than one label in a row in the real world.
3139         for (size_t i = 0; i &lt; labels.size(); i++)
3140             failIfTrue(ident-&gt;impl() == labels[i].m_ident-&gt;impl(), &quot;Attempted to redeclare the label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
3141         failIfTrue(getLabel(ident), &quot;Cannot find scope for the label &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
3142         labels.append(LabelInfo(ident, start, end));
3143     } while (matchSpecIdentifier());
3144     bool isLoop = false;
3145     switch (m_token.m_type) {
3146     case FOR:
3147     case WHILE:
3148     case DO:
3149         isLoop = true;
3150         break;
3151 
3152     default:
3153         break;
3154     }
3155     const Identifier* unused = 0;
3156     ScopeRef labelScope = currentScope();
3157     for (size_t i = 0; i &lt; labels.size(); i++)
3158         pushLabel(labels[i].m_ident, isLoop);
3159     m_immediateParentAllowsFunctionDeclarationInStatement = allowFunctionDeclarationAsStatement;
3160     TreeStatement statement = parseStatement(context, unused);
3161     for (size_t i = 0; i &lt; labels.size(); i++)
3162         popLabel(labelScope);
3163     failIfFalse(statement, &quot;Cannot parse statement&quot;);
3164     for (size_t i = 0; i &lt; labels.size(); i++) {
3165         const LabelInfo&amp; info = labels[labels.size() - i - 1];
3166         statement = context.createLabelStatement(location, info.m_ident, statement, info.m_start, info.m_end);
3167     }
3168     return statement;
3169 }
3170 
3171 template &lt;typename LexerType&gt;
3172 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionStatement(TreeBuilder&amp; context)
3173 {
3174     switch (m_token.m_type) {
3175     // Consult: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-expression-statement
3176     // The ES6 spec mandates that we should fail from FUNCTION token here. We handle this case
3177     // in parseStatement() which is the only caller of parseExpressionStatement().
3178     // We actually allow FUNCTION in situations where it should not be allowed unless we&#39;re in strict mode.
3179     case CLASSTOKEN:
3180         failWithMessage(&quot;&#39;class&#39; declaration is not directly within a block statement&quot;);
3181         break;
3182     default:
3183         // FIXME: when implementing &#39;let&#39; we should fail when we see the token sequence &quot;let [&quot;.
3184         // https://bugs.webkit.org/show_bug.cgi?id=142944
3185         break;
3186     }
3187     JSTextPosition start = tokenStartPosition();
3188     JSTokenLocation location(tokenLocation());
3189     TreeExpression expression = parseExpression(context);
3190     failIfFalse(expression, &quot;Cannot parse expression statement&quot;);
3191     failIfFalse(autoSemiColon(), &quot;Parse error&quot;);
3192     return context.createExprStatement(location, expression, start, m_lastTokenEndPosition.line);
3193 }
3194 
3195 template &lt;typename LexerType&gt;
3196 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseIfStatement(TreeBuilder&amp; context)
3197 {
3198     ASSERT(match(IF));
3199     JSTokenLocation ifLocation(tokenLocation());
3200     int start = tokenLine();
3201     next();
3202     handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3203 
3204     TreeExpression condition = parseExpression(context);
3205     failIfFalse(condition, &quot;Expected an expression as the condition for an if statement&quot;);
3206     recordPauseLocation(context.breakpointLocation(condition));
3207     int end = tokenLine();
3208     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3209 
3210     const Identifier* unused = 0;
3211     m_immediateParentAllowsFunctionDeclarationInStatement = true;
3212     TreeStatement trueBlock = parseStatement(context, unused);
3213     failIfFalse(trueBlock, &quot;Expected a statement as the body of an if block&quot;);
3214 
3215     if (!match(ELSE))
3216         return context.createIfStatement(ifLocation, condition, trueBlock, 0, start, end);
3217 
3218     Vector&lt;TreeExpression&gt; exprStack;
3219     Vector&lt;std::pair&lt;int, int&gt;&gt; posStack;
3220     Vector&lt;JSTokenLocation&gt; tokenLocationStack;
3221     Vector&lt;TreeStatement&gt; statementStack;
3222     bool trailingElse = false;
3223     do {
3224         JSTokenLocation tempLocation = tokenLocation();
3225         next();
3226         if (!match(IF)) {
3227             const Identifier* unused = 0;
3228             m_immediateParentAllowsFunctionDeclarationInStatement = true;
3229             TreeStatement block = parseStatement(context, unused);
3230             failIfFalse(block, &quot;Expected a statement as the body of an else block&quot;);
3231             statementStack.append(block);
3232             trailingElse = true;
3233             break;
3234         }
3235         int innerStart = tokenLine();
3236         next();
3237 
3238         handleProductionOrFail2(OPENPAREN, &quot;(&quot;, &quot;start&quot;, &quot;&#39;if&#39; condition&quot;);
3239 
3240         TreeExpression innerCondition = parseExpression(context);
3241         failIfFalse(innerCondition, &quot;Expected an expression as the condition for an if statement&quot;);
3242         recordPauseLocation(context.breakpointLocation(innerCondition));
3243         int innerEnd = tokenLine();
3244         handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;&#39;if&#39; condition&quot;);
3245         const Identifier* unused = 0;
3246         m_immediateParentAllowsFunctionDeclarationInStatement = true;
3247         TreeStatement innerTrueBlock = parseStatement(context, unused);
3248         failIfFalse(innerTrueBlock, &quot;Expected a statement as the body of an if block&quot;);
3249         tokenLocationStack.append(tempLocation);
3250         exprStack.append(innerCondition);
3251         posStack.append(std::make_pair(innerStart, innerEnd));
3252         statementStack.append(innerTrueBlock);
3253     } while (match(ELSE));
3254 
3255     if (!trailingElse) {
3256         TreeExpression condition = exprStack.last();
3257         exprStack.removeLast();
3258         TreeStatement trueBlock = statementStack.last();
3259         statementStack.removeLast();
3260         std::pair&lt;int, int&gt; pos = posStack.last();
3261         posStack.removeLast();
3262         JSTokenLocation elseLocation = tokenLocationStack.last();
3263         tokenLocationStack.removeLast();
3264         TreeStatement ifStatement = context.createIfStatement(elseLocation, condition, trueBlock, 0, pos.first, pos.second);
3265         context.setEndOffset(ifStatement, context.endOffset(trueBlock));
3266         statementStack.append(ifStatement);
3267     }
3268 
3269     while (!exprStack.isEmpty()) {
3270         TreeExpression condition = exprStack.last();
3271         exprStack.removeLast();
3272         TreeStatement falseBlock = statementStack.last();
3273         statementStack.removeLast();
3274         TreeStatement trueBlock = statementStack.last();
3275         statementStack.removeLast();
3276         std::pair&lt;int, int&gt; pos = posStack.last();
3277         posStack.removeLast();
3278         JSTokenLocation elseLocation = tokenLocationStack.last();
3279         tokenLocationStack.removeLast();
3280         TreeStatement ifStatement = context.createIfStatement(elseLocation, condition, trueBlock, falseBlock, pos.first, pos.second);
3281         context.setEndOffset(ifStatement, context.endOffset(falseBlock));
3282         statementStack.append(ifStatement);
3283     }
3284 
3285     return context.createIfStatement(ifLocation, condition, trueBlock, statementStack.last(), start, end);
3286 }
3287 
3288 template &lt;typename LexerType&gt;
3289 template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName Parser&lt;LexerType&gt;::parseModuleName(TreeBuilder&amp; context)
3290 {
3291     // ModuleName (ModuleSpecifier in the spec) represents the module name imported by the script.
3292     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3293     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3294     JSTokenLocation specifierLocation(tokenLocation());
3295     failIfFalse(match(STRING), &quot;Imported modules names must be string literals&quot;);
3296     const Identifier* moduleName = m_token.m_data.ident;
3297     next();
3298     return context.createModuleName(specifierLocation, *moduleName);
3299 }
3300 
3301 template &lt;typename LexerType&gt;
3302 template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier Parser&lt;LexerType&gt;::parseImportClauseItem(TreeBuilder&amp; context, ImportSpecifierType specifierType)
3303 {
3304     // Produced node is the item of the ImportClause.
3305     // That is the ImportSpecifier, ImportedDefaultBinding or NameSpaceImport.
3306     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3307     JSTokenLocation specifierLocation(tokenLocation());
3308     JSToken localNameToken;
3309     const Identifier* importedName = nullptr;
3310     const Identifier* localName = nullptr;
3311 
3312     switch (specifierType) {
3313     case ImportSpecifierType::NamespaceImport: {
3314         // NameSpaceImport :
3315         // * as ImportedBinding
3316         // e.g.
3317         //     * as namespace
3318         ASSERT(match(TIMES));
3319         importedName = &amp;m_vm.propertyNames-&gt;timesIdentifier;
3320         next();
3321 
3322         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;as), &quot;Expected &#39;as&#39; before imported binding name&quot;);
3323         next();
3324 
3325         failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3326         localNameToken = m_token;
3327         localName = m_token.m_data.ident;
3328         next();
3329         break;
3330     }
3331 
3332     case ImportSpecifierType::NamedImport: {
3333         // ImportSpecifier :
3334         // ImportedBinding
3335         // IdentifierName as ImportedBinding
3336         // e.g.
3337         //     A
3338         //     A as B
3339         ASSERT(matchIdentifierOrKeyword());
3340         localNameToken = m_token;
3341         localName = m_token.m_data.ident;
3342         importedName = localName;
3343         next();
3344 
3345         if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {
3346             next();
3347             failIfFalse(matchSpecIdentifier(), &quot;Expected a variable name for the import declaration&quot;);
3348             localNameToken = m_token;
3349             localName = m_token.m_data.ident;
3350             next();
3351         }
3352         break;
3353     }
3354 
3355     case ImportSpecifierType::DefaultImport: {
3356         // ImportedDefaultBinding :
3357         // ImportedBinding
3358         ASSERT(matchSpecIdentifier());
3359         localNameToken = m_token;
3360         localName = m_token.m_data.ident;
3361         importedName = &amp;m_vm.propertyNames-&gt;defaultKeyword;
3362         next();
3363         break;
3364     }
3365     }
3366 
3367     semanticFailIfTrue(localNameToken.m_type == AWAIT, &quot;Cannot use &#39;await&#39; as an imported binding name&quot;);
3368     semanticFailIfTrue(localNameToken.m_type &amp; KeywordTokenFlag, &quot;Cannot use keyword as imported binding name&quot;);
3369     DeclarationResultMask declarationResult = declareVariable(localName, DeclarationType::ConstDeclaration, (specifierType == ImportSpecifierType::NamespaceImport) ? DeclarationImportType::ImportedNamespace : DeclarationImportType::Imported);
3370     if (declarationResult != DeclarationResult::Valid) {
3371         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare an imported binding named &quot;, localName-&gt;impl(), &quot; in strict mode&quot;);
3372         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3373             internalFailWithMessage(false, &quot;Cannot declare an imported binding name twice: &#39;&quot;, localName-&gt;impl(), &quot;&#39;&quot;);
3374     }
3375 
3376     return context.createImportSpecifier(specifierLocation, *importedName, *localName);
3377 }
3378 
3379 template &lt;typename LexerType&gt;
3380 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseImportDeclaration(TreeBuilder&amp; context)
3381 {
3382     // http://www.ecma-international.org/ecma-262/6.0/#sec-imports
3383     ASSERT(match(IMPORT));
3384     JSTokenLocation importLocation(tokenLocation());
3385     next();
3386 
3387     auto specifierList = context.createImportSpecifierList();
3388 
3389     if (match(STRING)) {
3390         // import ModuleSpecifier ;
3391         auto moduleName = parseModuleName(context);
3392         failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3393         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3394         return context.createImportDeclaration(importLocation, specifierList, moduleName);
3395     }
3396 
3397     bool isFinishedParsingImport = false;
3398     if (matchSpecIdentifier()) {
3399         // ImportedDefaultBinding :
3400         // ImportedBinding
3401         auto specifier = parseImportClauseItem(context, ImportSpecifierType::DefaultImport);
3402         failIfFalse(specifier, &quot;Cannot parse the default import&quot;);
3403         context.appendImportSpecifier(specifierList, specifier);
3404         if (match(COMMA))
3405             next();
3406         else
3407             isFinishedParsingImport = true;
3408     }
3409 
3410     if (!isFinishedParsingImport) {
3411         if (match(TIMES)) {
3412             // import NameSpaceImport FromClause ;
3413             auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamespaceImport);
3414             failIfFalse(specifier, &quot;Cannot parse the namespace import&quot;);
3415             context.appendImportSpecifier(specifierList, specifier);
3416         } else if (match(OPENBRACE)) {
3417             // NamedImports :
3418             // { }
3419             // { ImportsList }
3420             // { ImportsList , }
3421             next();
3422 
3423             while (!match(CLOSEBRACE)) {
3424                 failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an imported name for the import declaration&quot;);
3425                 auto specifier = parseImportClauseItem(context, ImportSpecifierType::NamedImport);
3426                 failIfFalse(specifier, &quot;Cannot parse the named import&quot;);
3427                 context.appendImportSpecifier(specifierList, specifier);
3428                 if (!consume(COMMA))
3429                     break;
3430             }
3431             handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;import list&quot;);
3432         } else
3433             failWithMessage(&quot;Expected namespace import or import list&quot;);
3434     }
3435 
3436     // FromClause :
3437     // from ModuleSpecifier
3438 
3439     failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before imported module name&quot;);
3440     next();
3441 
3442     auto moduleName = parseModuleName(context);
3443     failIfFalse(moduleName, &quot;Cannot parse the module name&quot;);
3444     failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted import declaration&quot;);
3445 
3446     return context.createImportDeclaration(importLocation, specifierList, moduleName);
3447 }
3448 
3449 template &lt;typename LexerType&gt;
3450 template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier Parser&lt;LexerType&gt;::parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings)
3451 {
3452     // ExportSpecifier :
3453     // IdentifierName
3454     // IdentifierName as IdentifierName
3455     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3456     ASSERT(matchIdentifierOrKeyword());
3457     JSTokenLocation specifierLocation(tokenLocation());
3458     if (m_token.m_type &amp; KeywordTokenFlag)
3459         hasKeywordForLocalBindings = true;
3460     const Identifier* localName = m_token.m_data.ident;
3461     const Identifier* exportedName = localName;
3462     next();
3463 
3464     if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {
3465         next();
3466         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3467         exportedName = m_token.m_data.ident;
3468         next();
3469     }
3470 
3471     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3472     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3473     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3474 }
3475 
3476 template &lt;typename LexerType&gt;
3477 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3478 {
3479     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
3480     ASSERT(match(EXPORT_));
3481     JSTokenLocation exportLocation(tokenLocation());
3482     next();
3483 
3484     switch (m_token.m_type) {
3485     case TIMES: {
3486         // export * FromClause ;
3487         next();
3488 
3489         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);
3490         next();
3491         auto moduleName = parseModuleName(context);
3492         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3493         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3494 
3495         return context.createExportAllDeclaration(exportLocation, moduleName);
3496     }
3497 
3498     case DEFAULT: {
3499         // export default HoistableDeclaration[Default]
3500         // export default ClassDeclaration[Default]
3501         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3502 
3503         next();
3504 
3505         TreeStatement result = 0;
3506         bool isFunctionOrClassDeclaration = false;
3507         const Identifier* localName = nullptr;
3508 
3509         bool startsWithFunction = match(FUNCTION);
3510         if (startsWithFunction || match(CLASSTOKEN)) {
3511             SavePoint savePoint = createSavePoint(context);
3512             isFunctionOrClassDeclaration = true;
3513             next();
3514 
3515             // ES6 Generators
3516             if (startsWithFunction &amp;&amp; match(TIMES))
3517                 next();
3518             if (match(IDENT))
3519                 localName = m_token.m_data.ident;
3520             restoreSavePoint(context, savePoint);
3521         } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
3522             SavePoint savePoint = createSavePoint(context);
3523             next();
3524             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3525                 next();
3526                 if (match(IDENT))
3527                     localName = m_token.m_data.ident;
3528                 isFunctionOrClassDeclaration = true;
3529             }
3530             restoreSavePoint(context, savePoint);
3531         }
3532 
3533         if (!localName)
3534             localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
3535 
3536         if (isFunctionOrClassDeclaration) {
3537             if (startsWithFunction) {
3538                 ASSERT(match(FUNCTION));
3539                 DepthManager statementDepth(&amp;m_statementDepth);
3540                 m_statementDepth = 1;
3541                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3542             } else if (match(CLASSTOKEN)) {
3543                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3544             } else {
3545                 ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
3546                 next();
3547                 DepthManager statementDepth(&amp;m_statementDepth);
3548                 m_statementDepth = 1;
3549                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3550             }
3551         } else {
3552             // export default expr;
3553             //
3554             // It should be treated as the same to the following.
3555             //
3556             // const *default* = expr;
3557             // export { *default* as default }
3558             //
3559             // In the above example, *default* is the invisible variable to the users.
3560             // We use the private symbol to represent the name of this variable.
3561             JSTokenLocation location(tokenLocation());
3562             JSTextPosition start = tokenStartPosition();
3563             TreeExpression expression = parseAssignmentExpression(context);
3564             failIfFalse(expression, &quot;Cannot parse expression&quot;);
3565 
3566             DeclarationResultMask declarationResult = declareVariable(&amp;m_vm.propertyNames-&gt;starDefaultPrivateName, DeclarationType::ConstDeclaration);
3567             if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
3568                 internalFailWithMessage(false, &quot;Only one &#39;default&#39; export is allowed&quot;);
3569 
3570             TreeExpression assignment = context.createAssignResolve(location, m_vm.propertyNames-&gt;starDefaultPrivateName, expression, start, start, tokenEndPosition(), AssignmentContext::ConstDeclarationStatement);
3571             result = context.createExprStatement(location, assignment, start, tokenEndPosition());
3572             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3573         }
3574         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3575 
3576         semanticFailIfFalse(exportName(m_vm.propertyNames-&gt;defaultKeyword), &quot;Only one &#39;default&#39; export is allowed&quot;);
3577         m_moduleScopeData-&gt;exportBinding(*localName, m_vm.propertyNames-&gt;defaultKeyword);
3578         return context.createExportDefaultDeclaration(exportLocation, result, *localName);
3579     }
3580 
3581     case OPENBRACE: {
3582         // export ExportClause FromClause ;
3583         // export ExportClause ;
3584         //
3585         // ExportClause :
3586         // { }
3587         // { ExportsList }
3588         // { ExportsList , }
3589         //
3590         // ExportsList :
3591         // ExportSpecifier
3592         // ExportsList , ExportSpecifier
3593 
3594         next();
3595 
3596         auto specifierList = context.createExportSpecifierList();
3597         Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt; maybeExportedLocalNames;
3598 
3599         bool hasKeywordForLocalBindings = false;
3600         while (!match(CLOSEBRACE)) {
3601             failIfFalse(matchIdentifierOrKeyword(), &quot;Expected a variable name for the export declaration&quot;);
3602             auto specifier = parseExportSpecifier(context, maybeExportedLocalNames, hasKeywordForLocalBindings);
3603             failIfFalse(specifier, &quot;Cannot parse the named export&quot;);
3604             context.appendExportSpecifier(specifierList, specifier);
3605             if (!consume(COMMA))
3606                 break;
3607         }
3608         handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;export list&quot;);
3609 
3610         typename TreeBuilder::ModuleName moduleName = 0;
3611         if (matchContextualKeyword(m_vm.propertyNames-&gt;from)) {
3612             next();
3613             moduleName = parseModuleName(context);
3614             failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3615         }
3616         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3617 
3618         if (!moduleName) {
3619             semanticFailIfTrue(hasKeywordForLocalBindings, &quot;Cannot use keyword as exported variable name&quot;);
3620             // Since this export declaration does not have module specifier part, it exports the local bindings.
3621             // While the export declaration with module specifier does not have any effect on the current module&#39;s scope,
3622             // the export named declaration without module specifier references the local binding names.
3623             // For example,
3624             //   export { A, B, C as D } from &quot;mod&quot;
3625             // does not have effect on the current module&#39;s scope. But,
3626             //   export { A, B, C as D }
3627             // will reference the current module&#39;s bindings.
3628             for (const auto&amp; pair : maybeExportedLocalNames) {
3629                 const Identifier* localName = pair.first;
3630                 const Identifier* exportedName = pair.second;
3631                 m_moduleScopeData-&gt;exportBinding(*localName, *exportedName);
3632             }
3633         }
3634 
3635         return context.createExportNamedDeclaration(exportLocation, specifierList, moduleName);
3636     }
3637 
3638     default: {
3639         // export VariableStatement
3640         // export Declaration
3641         TreeStatement result = 0;
3642         switch (m_token.m_type) {
3643         case VAR:
3644             result = parseVariableDeclaration(context, DeclarationType::VarDeclaration, ExportType::Exported);
3645             break;
3646 
3647         case CONSTTOKEN:
3648             result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration, ExportType::Exported);
3649             break;
3650 
3651         case LET:
3652             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration, ExportType::Exported);
3653             break;
3654 
3655         case FUNCTION: {
3656             DepthManager statementDepth(&amp;m_statementDepth);
3657             m_statementDepth = 1;
3658             result = parseFunctionDeclaration(context, ExportType::Exported);
3659             break;
3660         }
3661 
3662         case CLASSTOKEN:
3663             result = parseClassDeclaration(context, ExportType::Exported);
3664             break;
3665 
3666         case IDENT:
3667             if (*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped) {
3668                 next();
3669                 semanticFailIfFalse(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected &#39;function&#39; keyword following &#39;async&#39; keyword with no preceding line terminator&quot;);
3670                 DepthManager statementDepth(&amp;m_statementDepth);
3671                 m_statementDepth = 1;
3672                 result = parseAsyncFunctionDeclaration(context, ExportType::Exported);
3673                 break;
3674             }
3675             FALLTHROUGH;
3676         default:
3677             failWithMessage(&quot;Expected either a declaration or a variable statement&quot;);
3678             break;
3679         }
3680 
3681         failIfFalse(result, &quot;Cannot parse the declaration&quot;);
3682         return context.createExportLocalDeclaration(exportLocation, result);
3683     }
3684     }
3685 
3686     RELEASE_ASSERT_NOT_REACHED();
3687     return 0;
3688 }
3689 
3690 template &lt;typename LexerType&gt;
3691 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseExpression(TreeBuilder&amp; context)
3692 {
3693     failIfStackOverflow();
3694     JSTokenLocation location(tokenLocation());
3695     TreeExpression node = parseAssignmentExpression(context);
3696     failIfFalse(node, &quot;Cannot parse expression&quot;);
3697     context.setEndOffset(node, m_lastTokenEndPosition.offset);
3698     if (!match(COMMA))
3699         return node;
3700     next();
3701     m_parserState.nonTrivialExpressionCount++;
3702     m_parserState.nonLHSCount++;
3703     TreeExpression right = parseAssignmentExpression(context);
3704     failIfFalse(right, &quot;Cannot parse expression in a comma expression&quot;);
3705     context.setEndOffset(right, m_lastTokenEndPosition.offset);
3706     typename TreeBuilder::Comma head = context.createCommaExpr(location, node);
3707     typename TreeBuilder::Comma tail = context.appendToCommaExpr(location, head, head, right);
3708     while (match(COMMA)) {
3709         next(TreeBuilder::DontBuildStrings);
3710         right = parseAssignmentExpression(context);
3711         failIfFalse(right, &quot;Cannot parse expression in a comma expression&quot;);
3712         context.setEndOffset(right, m_lastTokenEndPosition.offset);
3713         tail = context.appendToCommaExpr(location, head, tail, right);
3714     }
3715     context.setEndOffset(head, m_lastTokenEndPosition.offset);
3716     return head;
3717 }
3718 
3719 template &lt;typename LexerType&gt;
3720 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp; context)
3721 {
3722     ExpressionErrorClassifier classifier(this);
3723     auto assignment = parseAssignmentExpression(context, classifier);
3724     if (!assignment)
3725         classifier.propagateExpressionErrorClass();
3726     return assignment;
3727 }
3728 
3729 template &lt;typename LexerType&gt;
3730 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context)
3731 {
3732     ExpressionErrorClassifier classifier(this);
3733     return parseAssignmentExpression(context, classifier);
3734 }
3735 
3736 
3737 template &lt;typename LexerType&gt;
3738 template &lt;typename TreeBuilder&gt; NEVER_INLINE const char* Parser&lt;LexerType&gt;::metaPropertyName(TreeBuilder&amp; context, TreeExpression expr)
3739 {
3740     if (context.isNewTarget(expr))
3741         return &quot;new.target&quot;;
3742     if (context.isImportMeta(expr))
3743         return &quot;import.meta&quot;;
3744     RELEASE_ASSERT_NOT_REACHED();
3745     return &quot;error&quot;;
3746 }
3747 
3748 template &lt;typename LexerType&gt;
3749 template &lt;typename TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isSimpleAssignmentTarget(TreeBuilder&amp; context, TreeExpression expr)
3750 {
3751     // Web compatibility concerns prevent us from handling a function call LHS as an early error in sloppy mode.
3752     // This behavior is currently unspecified, but see: https://github.com/tc39/ecma262/issues/257#issuecomment-195106880
3753     return context.isLocation(expr) || (!strictMode() &amp;&amp; context.isFunctionCall(expr));
3754 }
3755 
3756 template &lt;typename LexerType&gt;
3757 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3758 {
3759     ASSERT(!hasError());
3760 
3761     failIfStackOverflow();
3762 
3763     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3764         return parseYieldExpression(context);
3765 
3766     JSTextPosition start = tokenStartPosition();
3767     JSTokenLocation location(tokenLocation());
3768     int initialAssignmentCount = m_parserState.assignmentCount;
3769     int initialNonLHSCount = m_parserState.nonLHSCount;
3770     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3771     bool wasOpenParen = match(OPENPAREN);
3772     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3773     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3774     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3775     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
3776     SavePoint savePoint = createSavePoint(context);
3777     size_t usedVariablesSize = 0;
3778 
3779     if (wasOpenParen) {
3780         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3781         currentScope()-&gt;pushUsedVariableSet();
3782     }
3783 
3784     TreeExpression lhs = parseConditionalExpression(context);
3785 
3786     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3787         bool isArrowFunctionToken = match(ARROWFUNCTION);
3788         if (!lhs || isArrowFunctionToken) {
3789             SavePointWithError errorRestorationSavePoint = swapSavePointForError(context, savePoint);
3790             bool isAsyncArrow = false;
3791             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
3792                 if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
3793                     next();
3794                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3795                 }
3796             }
3797             if (isArrowFunctionParameters(context)) {
3798                 if (wasOpenParen)
3799                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3800                 return parseArrowFunctionExpression(context, isAsyncArrow);
3801             }
3802             if (isArrowFunctionToken)
3803                 propagateError();
3804             restoreSavePointWithError(context, errorRestorationSavePoint);
3805             if (isArrowFunctionToken)
3806                 failDueToUnexpectedToken();
3807         }
3808     }
3809 
3810     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3811         propagateError();
3812 
3813     if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
3814         SavePointWithError expressionErrorLocation = swapSavePointForError(context, savePoint);
3815         auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
3816         if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
3817             restoreSavePointWithError(context, expressionErrorLocation);
3818             return 0;
3819         }
3820         failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
3821         consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
3822         auto rhs = parseAssignmentExpression(context);
3823         if (!rhs)
3824             propagateError();
3825         return context.createDestructuringAssignment(location, pattern, rhs);
3826     }
3827 
3828     failIfFalse(lhs, &quot;Cannot parse expression&quot;);
3829     if (initialNonLHSCount != m_parserState.nonLHSCount) {
3830         if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3831             semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3832 
3833         return lhs;
3834     }
3835 
3836     int assignmentStack = 0;
3837     Operator op;
3838     bool hadAssignment = false;
3839     while (true) {
3840         switch (m_token.m_type) {
3841         case EQUAL: op = OpEqual; break;
3842         case PLUSEQUAL: op = OpPlusEq; break;
3843         case MINUSEQUAL: op = OpMinusEq; break;
3844         case MULTEQUAL: op = OpMultEq; break;
3845         case DIVEQUAL: op = OpDivEq; break;
3846         case LSHIFTEQUAL: op = OpLShift; break;
3847         case RSHIFTEQUAL: op = OpRShift; break;
3848         case URSHIFTEQUAL: op = OpURShift; break;
3849         case ANDEQUAL: op = OpAndEq; break;
3850         case XOREQUAL: op = OpXOrEq; break;
3851         case OREQUAL: op = OpOrEq; break;
3852         case MODEQUAL: op = OpModEq; break;
3853         case POWEQUAL: op = OpPowEq; break;
3854         default:
3855             goto end;
3856         }
3857         m_parserState.nonTrivialExpressionCount++;
3858         hadAssignment = true;
3859         semanticFailIfTrue(context.isMetaProperty(lhs), metaPropertyName(context, lhs), &quot; can&#39;t be the left hand side of an assignment expression&quot;);
3860         semanticFailIfFalse(isSimpleAssignmentTarget(context, lhs), &quot;Left side of assignment is not a reference&quot;);
3861         context.assignmentStackAppend(assignmentStack, lhs, start, tokenStartPosition(), m_parserState.assignmentCount, op);
3862         start = tokenStartPosition();
3863         m_parserState.assignmentCount++;
3864         next(TreeBuilder::DontBuildStrings);
3865         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
3866             failIfTrueIfStrict(m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);
3867             failIfTrueIfStrict(m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);
3868             m_parserState.lastIdentifier = 0;
3869         }
3870         lhs = parseAssignmentExpression(context);
3871         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3872         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3873             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3874                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3875             break;
3876         }
3877     }
3878 end:
3879     if (hadAssignment)
3880         m_parserState.nonLHSCount++;
3881 
3882     while (assignmentStack)
3883         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3884 
3885     return lhs;
3886 }
3887 
3888 template &lt;typename LexerType&gt;
3889 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseYieldExpression(TreeBuilder&amp; context)
3890 {
3891     // YieldExpression[In] :
3892     //     yield
3893     //     yield [no LineTerminator here] AssignmentExpression[?In, Yield]
3894     //     yield [no LineTerminator here] * AssignmentExpression[?In, Yield]
3895 
3896     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions
3897     failIfFalse(currentScope()-&gt;isGenerator() &amp;&amp; !currentScope()-&gt;isArrowFunctionBoundary(), &quot;Cannot use yield expression out of generator&quot;);
3898 
3899     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
3900     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
3901 
3902     JSTokenLocation location(tokenLocation());
3903     JSTextPosition divotStart = tokenStartPosition();
3904     ASSERT(match(YIELD));
3905     SavePoint savePoint = createSavePoint(context);
3906     next();
3907     if (m_lexer-&gt;hasLineTerminatorBeforeToken())
3908         return context.createYield(location);
3909 
3910     bool delegate = consume(TIMES);
3911     JSTextPosition argumentStart = tokenStartPosition();
3912     TreeExpression argument = parseAssignmentExpression(context);
3913     if (!argument) {
3914         restoreSavePoint(context, savePoint);
3915         next();
3916         return context.createYield(location);
3917     }
3918     return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
3919 }
3920 
3921 template &lt;typename LexerType&gt;
3922 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
3923 {
3924     ASSERT(match(AWAIT));
3925     ASSERT(currentScope()-&gt;isAsyncFunction());
3926     ASSERT(m_parserState.functionParsePhase != FunctionParsePhase::Parameters);
3927     JSTokenLocation location(tokenLocation());
3928     JSTextPosition divotStart = tokenStartPosition();
3929     next();
3930     JSTextPosition argumentStart = tokenStartPosition();
3931     ExpressionErrorClassifier classifier(this);
3932     TreeExpression argument = parseUnaryExpression(context);
3933     failIfFalse(argument, &quot;Failed to parse await expression&quot;);
3934     return context.createAwait(location, argument, divotStart, argumentStart, lastTokenEndPosition());
3935 }
3936 
3937 template &lt;typename LexerType&gt;
3938 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseConditionalExpression(TreeBuilder&amp; context)
3939 {
3940     JSTokenLocation location(tokenLocation());
3941     TreeExpression cond = parseBinaryExpression(context);
3942     failIfFalse(cond, &quot;Cannot parse expression&quot;);
3943     if (!match(QUESTION))
3944         return cond;
3945     m_parserState.nonTrivialExpressionCount++;
3946     m_parserState.nonLHSCount++;
3947     next(TreeBuilder::DontBuildStrings);
3948     TreeExpression lhs = parseAssignmentExpression(context);
3949     failIfFalse(lhs, &quot;Cannot parse left hand side of ternary operator&quot;);
3950     context.setEndOffset(lhs, m_lastTokenEndPosition.offset);
3951     consumeOrFailWithFlags(COLON, TreeBuilder::DontBuildStrings, &quot;Expected &#39;:&#39; in ternary operator&quot;);
3952 
3953     TreeExpression rhs = parseAssignmentExpression(context);
3954     failIfFalse(rhs, &quot;Cannot parse right hand side of ternary operator&quot;);
3955     context.setEndOffset(rhs, m_lastTokenEndPosition.offset);
3956     return context.createConditionalExpr(location, cond, lhs, rhs);
3957 }
3958 
3959 ALWAYS_INLINE static bool isUnaryOpExcludingUpdateOp(JSTokenType token)
3960 {
3961     if (isUpdateOp(token))
3962         return false;
3963     return isUnaryOp(token);
3964 }
3965 
3966 template &lt;typename LexerType&gt;
3967 int Parser&lt;LexerType&gt;::isBinaryOperator(JSTokenType token)
3968 {
3969     if (m_allowsIn)
3970         return token &amp; (BinaryOpTokenPrecedenceMask &lt;&lt; BinaryOpTokenAllowsInPrecedenceAdditionalShift);
3971     return token &amp; BinaryOpTokenPrecedenceMask;
3972 }
3973 
3974 template &lt;typename LexerType&gt;
3975 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseBinaryExpression(TreeBuilder&amp; context)
3976 {
3977     int operandStackDepth = 0;
3978     int operatorStackDepth = 0;
3979     typename TreeBuilder::BinaryExprContext binaryExprContext(context);
3980     JSTokenLocation location(tokenLocation());
3981     bool hasLogicalOperator = false;
3982     bool hasCoalesceOperator = false;
3983 
3984     while (true) {
3985         JSTextPosition exprStart = tokenStartPosition();
3986         int initialAssignments = m_parserState.assignmentCount;
3987         JSTokenType leadingTokenTypeForUnaryExpression = m_token.m_type;
3988         TreeExpression current = parseUnaryExpression(context);
3989         failIfFalse(current, &quot;Cannot parse expression&quot;);
3990 
3991         context.appendBinaryExpressionInfo(operandStackDepth, current, exprStart, lastTokenEndPosition(), lastTokenEndPosition(), initialAssignments != m_parserState.assignmentCount);
3992         int precedence = isBinaryOperator(m_token.m_type);
3993         if (!precedence)
3994             break;
3995 
3996         // 12.6 https://tc39.github.io/ecma262/#sec-exp-operator
3997         // ExponentiationExpresion is described as follows.
3998         //
3999         //     ExponentiationExpression[Yield]:
4000         //         UnaryExpression[?Yield]
4001         //         UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
4002         //
4003         // As we can see, the left hand side of the ExponentiationExpression is UpdateExpression, not UnaryExpression.
4004         // So placing UnaryExpression not included in UpdateExpression here is a syntax error.
4005         // This is intentional. For example, if UnaryExpression is allowed, we can have the code like `-x**y`.
4006         // But this is confusing: `-(x**y)` OR `(-x)**y`, which interpretation is correct?
4007         // To avoid this problem, ECMA262 makes unparenthesized exponentiation expression as operand of unary operators an early error.
4008         // More rationale: https://mail.mozilla.org/pipermail/es-discuss/2015-September/044232.html
4009         //
4010         // Here, we guarantee that the left hand side of this expression is not unary expression by checking the leading operator of the parseUnaryExpression.
4011         // This check just works. Let&#39;s consider the example,
4012         //     y &lt;&gt; -x ** z
4013         //          ^
4014         //          Check this.
4015         // If the binary operator &lt;&gt; has higher precedence than one of &quot;**&quot;, this check does not work.
4016         // But it&#39;s OK for ** because the operator &quot;**&quot; has the highest operator precedence in the binary operators.
4017         failIfTrue(match(POW) &amp;&amp; isUnaryOpExcludingUpdateOp(leadingTokenTypeForUnaryExpression), &quot;Ambiguous unary expression in the left hand side of the exponentiation expression; parentheses must be used to disambiguate the expression&quot;);
4018 
4019         // Mixing ?? with || or &amp;&amp; is currently specified as an early error.
4020         // Since ?? is the lowest-precedence binary operator, it suffices to check whether these ever coexist in the operator stack.
4021         if (match(AND) || match(OR))
4022             hasLogicalOperator = true;
4023         else if (match(COALESCE))
4024             hasCoalesceOperator = true;
4025         failIfTrue(hasLogicalOperator &amp;&amp; hasCoalesceOperator, &quot;Coalescing and logical operators used together in the same expression; parentheses must be used to disambiguate&quot;);
4026 
4027         m_parserState.nonTrivialExpressionCount++;
4028         m_parserState.nonLHSCount++;
4029         int operatorToken = m_token.m_type;
4030         next(TreeBuilder::DontBuildStrings);
4031 
4032         while (operatorStackDepth &amp;&amp; context.operatorStackShouldReduce(precedence)) {
4033             ASSERT(operandStackDepth &gt; 1);
4034 
4035             typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
4036             typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
4037             context.shrinkOperandStackBy(operandStackDepth, 2);
4038             context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
4039             context.operatorStackPop(operatorStackDepth);
4040         }
4041         context.operatorStackAppend(operatorStackDepth, operatorToken, precedence);
4042     }
4043     while (operatorStackDepth) {
4044         ASSERT(operandStackDepth &gt; 1);
4045 
4046         typename TreeBuilder::BinaryOperand rhs = context.getFromOperandStack(-1);
4047         typename TreeBuilder::BinaryOperand lhs = context.getFromOperandStack(-2);
4048         context.shrinkOperandStackBy(operandStackDepth, 2);
4049         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
4050         context.operatorStackPop(operatorStackDepth);
4051     }
4052     return context.popOperandStack(operandStackDepth);
4053 }
4054 
4055 template &lt;typename LexerType&gt;
4056 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
4057 {
4058     SourceParseMode parseMode = SourceParseMode::MethodMode;
4059     bool wasIdent = false;
4060 
4061     if (consume(TIMES))
4062         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
4063 
4064 parseProperty:
4065     switch (m_token.m_type) {
4066     case IDENT:
4067         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
4068             if (parseMode == SourceParseMode::MethodMode) {
4069                 SavePoint savePoint = createSavePoint(context);
4070                 next();
4071 
4072                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
4073                     restoreSavePoint(context, savePoint);
4074                     wasIdent = true;
4075                     goto namedProperty;
4076                 }
4077 
4078                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
4079                 if (UNLIKELY(consume(TIMES)))
4080                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
4081                 else
4082                     parseMode = SourceParseMode::AsyncMethodMode;
4083                 goto parseProperty;
4084             }
4085         }
4086         FALLTHROUGH;
4087     case YIELD:
4088     case AWAIT:
4089         wasIdent = true;
4090         FALLTHROUGH;
4091     case STRING: {
4092 namedProperty:
4093         const Identifier* ident = m_token.m_data.ident;
4094         unsigned getterOrSetterStartOffset = tokenStart();
4095         JSToken identToken = m_token;
4096 
4097         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))
4098             nextExpectIdentifier(LexerFlags::IgnoreReservedWords);
4099         else
4100             nextExpectIdentifier(TreeBuilder::DontBuildKeywords | LexerFlags::IgnoreReservedWords);
4101 
4102         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
4103             next();
4104             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
4105             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4106             context.setEndOffset(node, m_lexer-&gt;currentOffset());
4107             InferName inferName = ident &amp;&amp; *ident == m_vm.propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;
4108             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
4109         }
4110 
4111         if (match(OPENPAREN)) {
4112             auto method = parsePropertyMethod(context, ident, parseMode);
4113             propagateError();
4114             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4115         }
4116         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4117 
4118         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
4119 
4120         if (match(COMMA) || match(CLOSEBRACE)) {
4121             semanticFailureDueToKeywordCheckingToken(identToken, &quot;shorthand property name&quot;);
4122             JSTextPosition start = tokenStartPosition();
4123             JSTokenLocation location(tokenLocation());
4124             currentScope()-&gt;useVariable(ident, m_vm.propertyNames-&gt;eval == *ident);
4125             if (currentScope()-&gt;isArrowFunction())
4126                 currentScope()-&gt;setInnerArrowFunctionUsesEval();
4127             TreeExpression node = context.createResolve(location, *ident, start, lastTokenEndPosition());
4128             return context.createProperty(ident, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Shorthand), PropertyNode::KnownDirect, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
4129         }
4130 
4131         if (match(EQUAL)) // CoverInitializedName is exclusive to BindingPattern and AssignmentPattern
4132             classifyExpressionError(ErrorIndicatesPattern);
4133 
4134         PropertyNode::Type type;
4135         if (*ident == m_vm.propertyNames-&gt;get)
4136             type = PropertyNode::Getter;
4137         else if (*ident == m_vm.propertyNames-&gt;set)
4138             type = PropertyNode::Setter;
4139         else
4140             failWithMessage(&quot;Expected a &#39;:&#39; following the property name &#39;&quot;, ident-&gt;impl(), &quot;&#39;&quot;);
4141         return parseGetterSetter(context, complete, type, getterOrSetterStartOffset, ConstructorKind::None, ClassElementTag::No);
4142     }
4143     case DOUBLE:
4144     case INTEGER: {
4145         double propertyName = m_token.m_data.doubleValue;
4146         next();
4147 
4148         if (match(OPENPAREN)) {
4149             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), propertyName);
4150             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4151             propagateError();
4152             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4153         }
4154         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4155 
4156         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4157         TreeExpression node = parseAssignmentExpression(context);
4158         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4159         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4160         return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4161     }
4162     case BIGINT: {
4163         const Identifier* ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);
4164         next();
4165 
4166         if (match(OPENPAREN)) {
4167             auto method = parsePropertyMethod(context, ident, parseMode);
4168             propagateError();
4169             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4170         }
4171         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4172 
4173         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4174         TreeExpression node = parseAssignmentExpression(context);
4175         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4176         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4177         return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);
4178     }
4179     case OPENBRACKET: {
4180         next();
4181         auto propertyName = parseAssignmentExpression(context);
4182         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4183         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4184 
4185         if (match(OPENPAREN)) {
4186             auto method = parsePropertyMethod(context, &amp;m_vm.propertyNames-&gt;nullIdentifier, parseMode);
4187             propagateError();
4188             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4189         }
4190         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4191 
4192         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4193         TreeExpression node = parseAssignmentExpression(context);
4194         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4195         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4196         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4197     }
4198     case DOTDOTDOT: {
4199         auto spreadLocation = m_token.m_location;
4200         auto start = m_token.m_startPosition;
4201         auto divot = m_token.m_endPosition;
4202         next();
4203         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4204         failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4205         auto node = context.createObjectSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4206         return context.createProperty(node, PropertyNode::Spread, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4207     }
4208     default:
4209         failIfFalse(m_token.m_type &amp; KeywordTokenFlag, &quot;Expected a property name&quot;);
4210         wasIdent = true; // Treat keyword token as an identifier
4211         goto namedProperty;
4212     }
4213 }
4214 
4215 template &lt;typename LexerType&gt;
4216 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode parseMode)
4217 {
4218     ASSERT(isMethodParseMode(parseMode));
4219     JSTokenLocation methodLocation(tokenLocation());
4220     unsigned methodStart = tokenStart();
4221     ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
4222     methodInfo.name = methodName;
4223     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
4224     return context.createMethodDefinition(methodLocation, methodInfo);
4225 }
4226 
4227 template &lt;typename LexerType&gt;
4228 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4229     ConstructorKind constructorKind, ClassElementTag tag)
4230 {
4231     const Identifier* stringPropertyName = 0;
4232     double numericPropertyName = 0;
4233     TreeExpression computedPropertyName = 0;
4234 
4235     JSTokenLocation location(tokenLocation());
4236 
4237     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4238         stringPropertyName = m_token.m_data.ident;
4239         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;prototype,
4240             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
4241         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;constructor,
4242             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4243         next();
4244     } else if (match(DOUBLE) || match(INTEGER)) {
4245         numericPropertyName = m_token.m_data.doubleValue;
4246         next();
4247     } else if (match(BIGINT)) {
4248         stringPropertyName = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);
4249         next();
4250     } else if (match(OPENBRACKET)) {
4251         next();
4252         computedPropertyName = parseAssignmentExpression(context);
4253         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4254         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4255     } else
4256         failDueToUnexpectedToken();
4257 
4258     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4259     if (type &amp; PropertyNode::Getter) {
4260         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4261         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4262     } else {
4263         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4264         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4265     }
4266 
4267     if (stringPropertyName)
4268         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4269 
4270     if (computedPropertyName)
4271         return context.createGetterOrSetterProperty(location, static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed), strict, computedPropertyName, info, tag);
4272 
4273     return context.createGetterOrSetterProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, location, type, strict, numericPropertyName, info, tag);
4274 }
4275 
4276 template &lt;typename LexerType&gt;
4277 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp; context, const TreeProperty&amp; property)
4278 {
4279     if (!context.getName(property))
4280         return false;
4281 
4282     // A Constant property that is not a Computed or Shorthand Constant property.
4283     return context.getType(property) == PropertyNode::Constant;
4284 }
4285 
4286 template &lt;typename LexerType&gt;
4287 void Parser&lt;LexerType&gt;::recordPauseLocation(const JSTextPosition&amp; position)
4288 {
4289     if (LIKELY(!m_debuggerParseData))
4290         return;
4291 
4292     if (position.line &lt; 0)
4293         return;
4294 
4295     m_debuggerParseData-&gt;pausePositions.appendPause(position);
4296 }
4297 
4298 template &lt;typename LexerType&gt;
4299 void Parser&lt;LexerType&gt;::recordFunctionEntryLocation(const JSTextPosition&amp; position)
4300 {
4301     if (LIKELY(!m_debuggerParseData))
4302         return;
4303 
4304     m_debuggerParseData-&gt;pausePositions.appendEntry(position);
4305 }
4306 
4307 template &lt;typename LexerType&gt;
4308 void Parser&lt;LexerType&gt;::recordFunctionLeaveLocation(const JSTextPosition&amp; position)
4309 {
4310     if (LIKELY(!m_debuggerParseData))
4311         return;
4312 
4313     m_debuggerParseData-&gt;pausePositions.appendLeave(position);
4314 }
4315 
4316 template &lt;typename LexerType&gt;
4317 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
4318 {
4319     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4320 
4321     int oldNonLHSCount = m_parserState.nonLHSCount;
4322 
4323     JSTokenLocation location(tokenLocation());
4324     if (match(CLOSEBRACE)) {
4325         next();
4326         return context.createObjectLiteral(location);
4327     }
4328 
4329     TreeProperty property = parseProperty(context, true);
4330     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4331 
4332     bool seenUnderscoreProto = false;
4333     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
4334         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;
4335 
4336     TreePropertyList propertyList = context.createPropertyList(location, property);
4337     TreePropertyList tail = propertyList;
4338     while (match(COMMA)) {
4339         next();
4340         if (match(CLOSEBRACE))
4341             break;
4342         JSTokenLocation propertyLocation(tokenLocation());
4343         property = parseProperty(context, true);
4344         failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4345         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {
4346             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {
4347                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);
4348                 seenUnderscoreProto = true;
4349             }
4350         }
4351         tail = context.createPropertyList(propertyLocation, property, tail);
4352     }
4353 
4354     location = tokenLocation();
4355     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);
4356 
4357     m_parserState.nonLHSCount = oldNonLHSCount;
4358 
4359     return context.createObjectLiteral(location, propertyList);
4360 }
4361 
4362 template &lt;typename LexerType&gt;
4363 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrayLiteral(TreeBuilder&amp; context)
4364 {
4365     consumeOrFailWithFlags(OPENBRACKET, TreeBuilder::DontBuildStrings, &quot;Expected an opening &#39;[&#39; at the beginning of an array literal&quot;);
4366 
4367     int oldNonLHSCount = m_parserState.nonLHSCount;
4368 
4369     int elisions = 0;
4370     while (match(COMMA)) {
4371         next(TreeBuilder::DontBuildStrings);
4372         elisions++;
4373     }
4374     if (match(CLOSEBRACKET)) {
4375         JSTokenLocation location(tokenLocation());
4376         next(TreeBuilder::DontBuildStrings);
4377         return context.createArray(location, elisions);
4378     }
4379 
4380     TreeExpression elem;
4381     if (UNLIKELY(match(DOTDOTDOT))) {
4382         auto spreadLocation = m_token.m_location;
4383         auto start = m_token.m_startPosition;
4384         auto divot = m_token.m_endPosition;
4385         next();
4386         auto spreadExpr = parseAssignmentExpressionOrPropagateErrorClass(context);
4387         failIfFalse(spreadExpr, &quot;Cannot parse subject of a spread operation&quot;);
4388         elem = context.createSpreadExpression(spreadLocation, spreadExpr, start, divot, m_lastTokenEndPosition);
4389     } else
4390         elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4391     failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4392     typename TreeBuilder::ElementList elementList = context.createElementList(elisions, elem);
4393     typename TreeBuilder::ElementList tail = elementList;
4394     elisions = 0;
4395     while (match(COMMA)) {
4396         next(TreeBuilder::DontBuildStrings);
4397         elisions = 0;
4398 
4399         while (match(COMMA)) {
4400             next();
4401             elisions++;
4402         }
4403 
4404         if (match(CLOSEBRACKET)) {
4405             JSTokenLocation location(tokenLocation());
4406             next(TreeBuilder::DontBuildStrings);
4407             return context.createArray(location, elisions, elementList);
4408         }
4409         if (UNLIKELY(match(DOTDOTDOT))) {
4410             auto spreadLocation = m_token.m_location;
4411             auto start = m_token.m_startPosition;
4412             auto divot = m_token.m_endPosition;
4413             next();
4414             TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4415             failIfFalse(elem, &quot;Cannot parse subject of a spread operation&quot;);
4416             auto spread = context.createSpreadExpression(spreadLocation, elem, start, divot, m_lastTokenEndPosition);
4417             tail = context.createElementList(tail, elisions, spread);
4418             continue;
4419         }
4420         TreeExpression elem = parseAssignmentExpressionOrPropagateErrorClass(context);
4421         failIfFalse(elem, &quot;Cannot parse array literal element&quot;);
4422         tail = context.createElementList(tail, elisions, elem);
4423     }
4424 
4425     JSTokenLocation location(tokenLocation());
4426     if (!consume(CLOSEBRACKET)) {
4427         failIfFalse(match(DOTDOTDOT), &quot;Expected either a closing &#39;]&#39; or a &#39;,&#39; following an array element&quot;);
4428         semanticFail(&quot;The &#39;...&#39; operator should come before a target expression&quot;);
4429     }
4430 
4431     m_parserState.nonLHSCount = oldNonLHSCount;
4432 
4433     return context.createArray(location, elementList);
4434 }
4435 
4436 template &lt;typename LexerType&gt;
4437 template &lt;class TreeBuilder&gt; TreeClassExpression Parser&lt;LexerType&gt;::parseClassExpression(TreeBuilder&amp; context)
4438 {
4439     ASSERT(match(CLASSTOKEN));
4440     ParserClassInfo&lt;TreeBuilder&gt; info;
4441     info.className = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4442     return parseClass(context, FunctionNameRequirements::None, info);
4443 }
4444 
4445 template &lt;typename LexerType&gt;
4446 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseFunctionExpression(TreeBuilder&amp; context)
4447 {
4448     ASSERT(match(FUNCTION));
4449     JSTokenLocation location(tokenLocation());
4450     unsigned functionKeywordStart = tokenStart();
4451     next();
4452     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
4453     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4454     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
4455     if (consume(TIMES))
4456         parseMode = SourceParseMode::GeneratorWrapperFunctionMode;
4457     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression)), &quot;Cannot parse function expression&quot;);
4458     return context.createFunctionExpr(location, functionInfo);
4459 }
4460 
4461 template &lt;typename LexerType&gt;
4462 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAsyncFunctionExpression(TreeBuilder&amp; context)
4463 {
4464     ASSERT(match(FUNCTION));
4465     JSTokenLocation location(tokenLocation());
4466     unsigned functionKeywordStart = tokenStart();
4467     next();
4468     SourceParseMode parseMode = SourceParseMode::AsyncFunctionMode;
4469 
4470     if (consume(TIMES))
4471         parseMode = SourceParseMode::AsyncGeneratorWrapperFunctionMode;
4472 
4473     ParserFunctionInfo&lt;TreeBuilder&gt; functionInfo;
4474     functionInfo.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
4475     failIfFalse(parseFunctionInfo(context, FunctionNameRequirements::None, parseMode, false, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, functionInfo, FunctionDefinitionType::Expression), parseMode == SourceParseMode::AsyncFunctionMode ? &quot;Cannot parse async function expression&quot; : &quot;Cannot parse async generator function expression&quot;);
4476     return context.createFunctionExpr(location, functionInfo);
4477 }
4478 
4479 template &lt;typename LexerType&gt;
4480 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateString Parser&lt;LexerType&gt;::parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode rawStringsBuildMode, bool&amp; elementIsTail)
4481 {
4482     if (isTemplateHead)
4483         ASSERT(match(BACKQUOTE));
4484     else
4485         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; following an expression in template literal&quot;);
4486 
4487     // Re-scan the token to recognize it as Template Element.
4488     m_token.m_type = m_lexer-&gt;scanTemplateString(&amp;m_token, rawStringsBuildMode);
4489     matchOrFail(TEMPLATE, &quot;Expected an template element&quot;);
4490     const Identifier* cooked = m_token.m_data.cooked;
4491     const Identifier* raw = m_token.m_data.raw;
4492     elementIsTail = m_token.m_data.isTail;
4493     JSTokenLocation location(tokenLocation());
4494     next();
4495     return context.createTemplateString(location, cooked, raw);
4496 }
4497 
4498 template &lt;typename LexerType&gt;
4499 template &lt;class TreeBuilder&gt; typename TreeBuilder::TemplateLiteral Parser&lt;LexerType&gt;::parseTemplateLiteral(TreeBuilder&amp; context, typename LexerType::RawStringsBuildMode rawStringsBuildMode)
4500 {
4501     ASSERT(match(BACKQUOTE));
4502     JSTokenLocation location(tokenLocation());
4503     bool elementIsTail = false;
4504 
4505     auto headTemplateString = parseTemplateString(context, true, rawStringsBuildMode, elementIsTail);
4506     failIfFalse(headTemplateString, &quot;Cannot parse head template element&quot;);
4507 
4508     typename TreeBuilder::TemplateStringList templateStringList = context.createTemplateStringList(headTemplateString);
4509     typename TreeBuilder::TemplateStringList templateStringTail = templateStringList;
4510 
4511     if (elementIsTail)
4512         return context.createTemplateLiteral(location, templateStringList);
4513 
4514     failIfTrue(match(CLOSEBRACE), &quot;Template literal expression cannot be empty&quot;);
4515     TreeExpression expression = parseExpression(context);
4516     failIfFalse(expression, &quot;Cannot parse expression in template literal&quot;);
4517 
4518     typename TreeBuilder::TemplateExpressionList templateExpressionList = context.createTemplateExpressionList(expression);
4519     typename TreeBuilder::TemplateExpressionList templateExpressionTail = templateExpressionList;
4520 
4521     auto templateString = parseTemplateString(context, false, rawStringsBuildMode, elementIsTail);
4522     failIfFalse(templateString, &quot;Cannot parse template element&quot;);
4523     templateStringTail = context.createTemplateStringList(templateStringTail, templateString);
4524 
4525     while (!elementIsTail) {
4526         failIfTrue(match(CLOSEBRACE), &quot;Template literal expression cannot be empty&quot;);
4527         TreeExpression expression = parseExpression(context);
4528         failIfFalse(expression, &quot;Cannot parse expression in template literal&quot;);
4529 
4530         templateExpressionTail = context.createTemplateExpressionList(templateExpressionTail, expression);
4531 
4532         auto templateString = parseTemplateString(context, false, rawStringsBuildMode, elementIsTail);
4533         failIfFalse(templateString, &quot;Cannot parse template element&quot;);
4534         templateStringTail = context.createTemplateStringList(templateStringTail, templateString);
4535     }
4536 
4537     return context.createTemplateLiteral(location, templateStringList, templateExpressionList);
4538 }
4539 
4540 template &lt;class LexerType&gt;
4541 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::createResolveAndUseVariable(TreeBuilder&amp; context, const Identifier* ident, bool isEval, const JSTextPosition&amp; start, const JSTokenLocation&amp; location)
4542 {
4543     currentScope()-&gt;useVariable(ident, isEval);
4544     m_parserState.lastIdentifier = ident;
4545     return context.createResolve(location, *ident, start, lastTokenEndPosition());
4546 }
4547 
4548 template &lt;typename LexerType&gt;
4549 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePrimaryExpression(TreeBuilder&amp; context)
4550 {
4551     failIfStackOverflow();
4552     switch (m_token.m_type) {
4553     case FUNCTION:
4554         return parseFunctionExpression(context);
4555     case CLASSTOKEN:
4556         return parseClassExpression(context);
4557     case OPENBRACE:
4558         return parseObjectLiteral(context);
4559     case OPENBRACKET:
4560         return parseArrayLiteral(context);
4561     case OPENPAREN: {
4562         next();
4563         int oldNonLHSCount = m_parserState.nonLHSCount;
4564         TreeExpression result = parseExpression(context);
4565         m_parserState.nonLHSCount = oldNonLHSCount;
4566         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4567         return result;
4568     }
4569     case THISTOKEN: {
4570         JSTokenLocation location(tokenLocation());
4571         next();
4572         if (currentScope()-&gt;isArrowFunction())
4573             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4574         return context.createThisExpr(location);
4575     }
4576     case AWAIT:
4577         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
4578             semanticFailIfFalse(m_parserState.allowAwait, &quot;Cannot use &#39;await&#39; within a parameter default expression&quot;);
4579         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4580             return parseAwaitExpression(context);
4581 
4582         goto identifierExpression;
4583     case IDENT: {
4584         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
4585             JSTextPosition start = tokenStartPosition();
4586             const Identifier* ident = m_token.m_data.ident;
4587             JSTokenLocation location(tokenLocation());
4588             next();
4589             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4590                 return parseAsyncFunctionExpression(context);
4591 
4592             // Avoid using variable if it is an arrow function parameter
4593             if (UNLIKELY(match(ARROWFUNCTION)))
4594                 return 0;
4595 
4596             const bool isEval = false;
4597             return createResolveAndUseVariable(context, ident, isEval, start, location);
4598         }
4599         if (UNLIKELY(m_parserState.isParsingClassFieldInitializer))
4600             failIfTrue(*m_token.m_data.ident == m_vm.propertyNames-&gt;arguments, &quot;Cannot reference &#39;arguments&#39; in class field initializer&quot;);
4601     identifierExpression:
4602         JSTextPosition start = tokenStartPosition();
4603         const Identifier* ident = m_token.m_data.ident;
4604         if (UNLIKELY(currentScope()-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext))
4605             failIfTrue(*ident == m_vm.propertyNames-&gt;arguments, &quot;arguments is not valid in this context&quot;);
4606         JSTokenLocation location(tokenLocation());
4607         next();
4608 
4609         // Avoid using variable if it is an arrow function parameter
4610         if (UNLIKELY(match(ARROWFUNCTION)))
4611             return 0;
4612 
4613         return createResolveAndUseVariable(context, ident, *ident == m_vm.propertyNames-&gt;eval, start, location);
4614     }
4615     case BIGINT: {
4616         const Identifier* ident = m_token.m_data.bigIntString;
4617         uint8_t radix = m_token.m_data.radix;
4618         JSTokenLocation location(tokenLocation());
4619         next();
4620         return context.createBigInt(location, ident, radix);
4621     }
4622     case STRING: {
4623         const Identifier* ident = m_token.m_data.ident;
4624         JSTokenLocation location(tokenLocation());
4625         next();
4626         return context.createString(location, ident);
4627     }
4628     case DOUBLE: {
4629         double d = m_token.m_data.doubleValue;
4630         JSTokenLocation location(tokenLocation());
4631         next();
4632         return context.createDoubleExpr(location, d);
4633     }
4634     case INTEGER: {
4635         double d = m_token.m_data.doubleValue;
4636         JSTokenLocation location(tokenLocation());
4637         next();
4638         return context.createIntegerExpr(location, d);
4639     }
4640     case NULLTOKEN: {
4641         JSTokenLocation location(tokenLocation());
4642         next();
4643         return context.createNull(location);
4644     }
4645     case TRUETOKEN: {
4646         JSTokenLocation location(tokenLocation());
4647         next();
4648         return context.createBoolean(location, true);
4649     }
4650     case FALSETOKEN: {
4651         JSTokenLocation location(tokenLocation());
4652         next();
4653         return context.createBoolean(location, false);
4654     }
4655     case DIVEQUAL:
4656     case DIVIDE: {
4657         /* regexp */
4658         if (match(DIVEQUAL))
4659             m_token.m_type = m_lexer-&gt;scanRegExp(&amp;m_token, &#39;=&#39;);
4660         else
4661             m_token.m_type = m_lexer-&gt;scanRegExp(&amp;m_token);
4662         matchOrFail(REGEXP, &quot;Invalid regular expression&quot;);
4663 
4664         const Identifier* pattern = m_token.m_data.pattern;
4665         const Identifier* flags = m_token.m_data.flags;
4666         JSTextPosition start = tokenStartPosition();
4667         JSTokenLocation location(tokenLocation());
4668         next();
4669         TreeExpression re = context.createRegExp(location, *pattern, *flags, start);
4670         if (!re) {
4671             Yarr::ErrorCode errorCode = Yarr::checkSyntax(pattern-&gt;string(), flags-&gt;string());
4672             regexFail(Yarr::errorMessage(errorCode));
4673         }
4674         return re;
4675     }
4676     case BACKQUOTE:
4677         return parseTemplateLiteral(context, LexerType::RawStringsBuildMode::DontBuildRawStrings);
4678     case YIELD:
4679         if (!strictMode() &amp;&amp; !currentScope()-&gt;isGenerator())
4680             goto identifierExpression;
4681         failDueToUnexpectedToken();
4682     case LET:
4683         if (!strictMode())
4684             goto identifierExpression;
4685         FALLTHROUGH;
4686     default:
4687         failDueToUnexpectedToken();
4688     }
4689 }
4690 
4691 template &lt;typename LexerType&gt;
4692 template &lt;class TreeBuilder&gt; TreeArguments Parser&lt;LexerType&gt;::parseArguments(TreeBuilder&amp; context)
4693 {
4694     consumeOrFailWithFlags(OPENPAREN, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;(&#39; at start of argument list&quot;);
4695     JSTokenLocation location(tokenLocation());
4696     if (match(CLOSEPAREN)) {
4697         next(TreeBuilder::DontBuildStrings);
4698         return context.createArguments();
4699     }
4700     auto argumentsStart = m_token.m_startPosition;
4701     auto argumentsDivot = m_token.m_endPosition;
4702 
4703     ArgumentType argType = ArgumentType::Normal;
4704     TreeExpression firstArg = parseArgument(context, argType);
4705     failIfFalse(firstArg, &quot;Cannot parse function argument&quot;);
4706     semanticFailIfTrue(match(DOTDOTDOT), &quot;The &#39;...&#39; operator should come before the target expression&quot;);
4707 
4708     bool hasSpread = false;
4709     if (argType == ArgumentType::Spread)
4710         hasSpread = true;
4711     TreeArgumentsList argList = context.createArgumentsList(location, firstArg);
4712     TreeArgumentsList tail = argList;
4713 
4714     while (match(COMMA)) {
4715         JSTokenLocation argumentLocation(tokenLocation());
4716         next(TreeBuilder::DontBuildStrings);
4717 
4718         if (UNLIKELY(match(CLOSEPAREN)))
4719             break;
4720 
4721         TreeExpression arg = parseArgument(context, argType);
4722         propagateError();
4723         semanticFailIfTrue(match(DOTDOTDOT), &quot;The &#39;...&#39; operator should come before the target expression&quot;);
4724 
4725         if (argType == ArgumentType::Spread)
4726             hasSpread = true;
4727 
4728         tail = context.createArgumentsList(argumentLocation, tail, arg);
4729     }
4730 
4731     handleProductionOrFail2(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;argument list&quot;);
4732     if (hasSpread) {
4733         TreeExpression spreadArray = context.createSpreadExpression(location, context.createArray(location, context.createElementList(argList)), argumentsStart, argumentsDivot, m_lastTokenEndPosition);
4734         return context.createArguments(context.createArgumentsList(location, spreadArray));
4735     }
4736 
4737     return context.createArguments(argList);
4738 }
4739 
4740 template &lt;typename LexerType&gt;
4741 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArgument(TreeBuilder&amp; context, ArgumentType&amp; type)
4742 {
4743     if (UNLIKELY(match(DOTDOTDOT))) {
4744         JSTokenLocation spreadLocation(tokenLocation());
4745         auto start = m_token.m_startPosition;
4746         auto divot = m_token.m_endPosition;
4747         next();
4748         TreeExpression spreadExpr = parseAssignmentExpression(context);
4749         propagateError();
4750         auto end = m_lastTokenEndPosition;
4751         type = ArgumentType::Spread;
4752         return context.createSpreadExpression(spreadLocation, spreadExpr, start, divot, end);
4753     }
4754 
4755     type = ArgumentType::Normal;
4756     return parseAssignmentExpression(context);
4757 }
4758 
4759 template &lt;typename TreeBuilder, typename ParserType, typename = typename std::enable_if&lt;std::is_same&lt;TreeBuilder, ASTBuilder&gt;::value&gt;::type&gt;
4760 static inline void recordCallOrApplyDepth(ParserType* parser, VM&amp; vm, Optional&lt;typename ParserType::CallOrApplyDepthScope&gt;&amp; callOrApplyDepthScope, ExpressionNode* expression)
4761 {
4762     if (expression-&gt;isDotAccessorNode()) {
4763         DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(expression);
4764         bool isCallOrApply = dot-&gt;identifier() == vm.propertyNames-&gt;builtinNames().callPublicName() || dot-&gt;identifier() == vm.propertyNames-&gt;builtinNames().applyPublicName();
4765         if (isCallOrApply)
4766             callOrApplyDepthScope.emplace(parser);
4767     }
4768 }
4769 
4770 template &lt;typename TreeBuilder, typename ParserType, typename = typename std::enable_if&lt;std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value&gt;::type&gt;
4771 static inline void recordCallOrApplyDepth(ParserType*, VM&amp;, Optional&lt;typename ParserType::CallOrApplyDepthScope&gt;&amp;, SyntaxChecker::Expression)
4772 {
4773 }
4774 
4775 template &lt;typename LexerType&gt;
4776 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseMemberExpression(TreeBuilder&amp; context)
4777 {
4778     TreeExpression base = 0;
4779     JSTextPosition expressionStart = tokenStartPosition();
4780     int newCount = 0;
4781     JSTokenLocation startLocation = tokenLocation();
4782     JSTokenLocation lastNewTokenLocation;
4783     while (match(NEW)) {
4784         lastNewTokenLocation = tokenLocation();
4785         next();
4786         newCount++;
4787     }
4788     JSTokenLocation location = tokenLocation();
4789 
4790     bool baseIsSuper = match(SUPER);
4791     bool previousBaseWasSuper = false;
4792     bool baseIsImport = match(IMPORT);
4793     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4794 
4795     bool baseIsNewTarget = false;
4796     if (newCount &amp;&amp; match(DOT)) {
4797         next();
4798         if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {
4799             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4800             ScopeRef classScope = closestClassScopeOrTopLevelScope();
4801             bool isClassFieldInitializer = classScope.index() &gt; closestOrdinaryFunctionScope.index();
4802             bool isFunctionEvalContextType = closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext;
4803             semanticFailIfFalse(currentScope()-&gt;isFunction() || isFunctionEvalContextType || isClassFieldInitializer, &quot;new.target is only valid inside functions&quot;);
4804             baseIsNewTarget = true;
4805             if (currentScope()-&gt;isArrowFunction()) {
4806                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || isFunctionEvalContextType || isClassFieldInitializer, &quot;new.target is not valid inside arrow functions in global code&quot;);
4807                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4808             }
4809             ASSERT(lastNewTokenLocation.line);
4810             base = context.createNewTargetExpr(lastNewTokenLocation);
4811             newCount--;
4812             next();
4813         } else {
4814             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4815             failDueToUnexpectedToken();
4816         }
4817     }
4818 
4819     bool baseIsAsyncKeyword = false;
4820 
4821     if (baseIsSuper) {
4822         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4823         ScopeRef classScope = closestClassScopeOrTopLevelScope();
4824         bool isClassFieldInitializer = classScope.index() &gt; closestOrdinaryFunctionScope.index();
4825         semanticFailIfFalse(currentScope()-&gt;isFunction() || isClassFieldInitializer || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);
4826         base = context.createSuperExpr(location);
4827         next();
4828         failIfTrue(match(OPENPAREN) &amp;&amp; currentScope()-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext, &quot;super call is not valid in this context&quot;);
4829         ScopeRef functionScope = currentFunctionScope();
4830         if (!functionScope-&gt;setNeedsSuperBinding()) {
4831             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4832             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4833             // inside of the constructor or method.
4834             if (!m_lexer-&gt;isReparsingFunction()) {
4835                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4836                     ? functionScope-&gt;expectedSuperBinding()
4837                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
4838                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded &amp;&amp; !isClassFieldInitializer, &quot;super is not valid in this context&quot;);
4839             }
4840         }
4841     } else if (baseIsImport) {
4842         next();
4843         JSTextPosition expressionEnd = lastTokenEndPosition();
4844         if (consume(DOT)) {
4845             if (matchContextualKeyword(m_vm.propertyNames-&gt;builtinNames().metaPublicName())) {
4846                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
4847                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm.propertyNames-&gt;metaPrivateName, false, expressionStart, location));
4848                 next();
4849             } else {
4850                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4851                 failDueToUnexpectedToken();
4852             }
4853         } else {
4854             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4855             TreeExpression expr = parseAssignmentExpression(context);
4856             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4857             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4858             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
4859         }
4860     } else if (!baseIsNewTarget) {
4861         const bool isAsync = matchContextualKeyword(m_vm.propertyNames-&gt;async);
4862 
4863         base = parsePrimaryExpression(context);
4864         failIfFalse(base, &quot;Cannot parse base expression&quot;);
4865         if (UNLIKELY(isAsync &amp;&amp; context.isResolve(base) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
4866             if (matchSpecIdentifier()) {
4867                 // AsyncArrowFunction
4868                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4869                 failDueToUnexpectedToken();
4870             }
4871             baseIsAsyncKeyword = true;
4872         }
4873     }
4874 
4875     failIfFalse(base, &quot;Cannot parse base expression&quot;);
4876 
4877     do {
4878         TreeExpression optionalChainBase = 0;
4879         JSTokenLocation optionalChainLocation;
4880         JSTokenType type = m_token.m_type;
4881 
4882         if (match(QUESTIONDOT)) {
4883             semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);
4884             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);
4885             optionalChainBase = base;
4886             optionalChainLocation = tokenLocation();
4887 
4888             SavePoint savePoint = createSavePoint(context);
4889             next();
4890             if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))
4891                 type = m_token.m_type;
4892             else {
4893                 type = DOT;
4894                 restoreSavePoint(context, savePoint);
4895             }
4896         }
4897 
4898         while (true) {
4899             location = tokenLocation();
4900             switch (type) {
4901             case OPENBRACKET: {
4902                 m_parserState.nonTrivialExpressionCount++;
4903                 JSTextPosition expressionEnd = lastTokenEndPosition();
4904                 next();
4905                 int nonLHSCount = m_parserState.nonLHSCount;
4906                 int initialAssignments = m_parserState.assignmentCount;
4907                 TreeExpression property = parseExpression(context);
4908                 failIfFalse(property, &quot;Cannot parse subscript expression&quot;);
4909                 base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());
4910 
4911                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4912                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4913 
4914                 handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);
4915                 m_parserState.nonLHSCount = nonLHSCount;
4916                 break;
4917             }
4918             case OPENPAREN: {
4919                 if (baseIsSuper)
4920                     failIfTrue(m_parserState.isParsingClassFieldInitializer, &quot;super call is not valid in class field initializer context&quot;);
4921                 m_parserState.nonTrivialExpressionCount++;
4922                 int nonLHSCount = m_parserState.nonLHSCount;
4923                 if (newCount) {
4924                     newCount--;
4925                     JSTextPosition expressionEnd = lastTokenEndPosition();
4926                     TreeArguments arguments = parseArguments(context);
4927                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);
4928                     base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());
4929                 } else {
4930                     size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
4931                     JSTextPosition expressionEnd = lastTokenEndPosition();
4932                     Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;
4933                     recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, m_vm, callOrApplyDepthScope, base);
4934 
4935                     TreeArguments arguments = parseArguments(context);
4936 
4937                     if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {
4938                         currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
4939                         forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4940                         failDueToUnexpectedToken();
4941                     }
4942 
4943                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);
4944                     if (baseIsSuper) {
4945                         ScopeRef functionScope = currentFunctionScope();
4946                         if (!functionScope-&gt;setHasDirectSuper()) {
4947                             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4948                             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4949                             // inside of the constructor or method.
4950                             if (!m_lexer-&gt;isReparsingFunction()) {
4951                                 ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
4952                                 ConstructorKind functionConstructorKind = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4953                                     ? functionScope-&gt;constructorKind()
4954                                     : closestOrdinaryFunctionScope-&gt;constructorKind();
4955                                 semanticFailIfTrue(functionConstructorKind == ConstructorKind::None, &quot;super is not valid in this context&quot;);
4956                                 semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);
4957                             }
4958                         }
4959                         if (currentScope()-&gt;isArrowFunction())
4960                             functionScope-&gt;setInnerArrowFunctionUsesSuperCall();
4961                     }
4962 
4963                     bool isOptionalCall = optionalChainLocation.endOffset == static_cast&lt;unsigned&gt;(expressionEnd.offset);
4964                     base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,
4965                         expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0, isOptionalCall);
4966 
4967                     if (isOptionalCall)
4968                         optionalChainBase = base;
4969                 }
4970                 m_parserState.nonLHSCount = nonLHSCount;
4971                 break;
4972             }
4973             case DOT: {
4974                 m_parserState.nonTrivialExpressionCount++;
4975                 JSTextPosition expressionEnd = lastTokenEndPosition();
4976                 nextExpectIdentifier(TreeBuilder::DontBuildKeywords | LexerFlags::IgnoreReservedWords);
4977                 matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);
4978                 base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());
4979                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4980                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4981                 next();
4982                 break;
4983             }
4984             case BACKQUOTE: {
4985                 semanticFailIfTrue(optionalChainBase, &quot;Cannot use tagged templates in an optional chain&quot;);
4986                 semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);
4987                 JSTextPosition expressionEnd = lastTokenEndPosition();
4988                 int nonLHSCount = m_parserState.nonLHSCount;
4989                 typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);
4990                 failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);
4991                 base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());
4992                 m_parserState.nonLHSCount = nonLHSCount;
4993                 m_seenTaggedTemplate = true;
4994                 break;
4995             }
4996             default:
4997                 goto endOfChain;
4998             }
4999             previousBaseWasSuper = baseIsSuper;
5000             baseIsSuper = false;
5001             type = m_token.m_type;
5002         }
5003 endOfChain:
5004         if (optionalChainBase)
5005             base = context.createOptionalChain(optionalChainLocation, optionalChainBase, base, !match(QUESTIONDOT));
5006     } while (match(QUESTIONDOT));
5007 
5008     semanticFailIfTrue(baseIsSuper, &quot;super is not valid in this context&quot;);
5009     while (newCount--)
5010         base = context.createNewExpr(location, base, expressionStart, lastTokenEndPosition());
5011     return base;
5012 }
5013 
5014 template &lt;typename LexerType&gt;
5015 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseArrowFunctionExpression(TreeBuilder&amp; context, bool isAsync)
5016 {
5017     JSTokenLocation location;
5018 
5019     unsigned functionKeywordStart = tokenStart();
5020     location = tokenLocation();
5021     ParserFunctionInfo&lt;TreeBuilder&gt; info;
5022     info.name = &amp;m_vm.propertyNames-&gt;nullIdentifier;
5023 
5024     SourceParseMode parseMode = isAsync ? SourceParseMode::AsyncArrowFunctionMode : SourceParseMode::ArrowFunctionMode;
5025     failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, true, ConstructorKind::None, SuperBinding::NotNeeded, functionKeywordStart, info, FunctionDefinitionType::Expression)), &quot;Cannot parse arrow function expression&quot;);
5026 
5027     return context.createArrowFunctionExpr(location, info);
5028 }
5029 
5030 static const char* operatorString(bool prefix, unsigned tok)
5031 {
5032     switch (tok) {
5033     case MINUSMINUS:
5034     case AUTOMINUSMINUS:
5035         return prefix ? &quot;prefix-decrement&quot; : &quot;decrement&quot;;
5036 
5037     case PLUSPLUS:
5038     case AUTOPLUSPLUS:
5039         return prefix ? &quot;prefix-increment&quot; : &quot;increment&quot;;
5040 
5041     case EXCLAMATION:
5042         return &quot;logical-not&quot;;
5043 
5044     case TILDE:
5045         return &quot;bitwise-not&quot;;
5046 
5047     case TYPEOF:
5048         return &quot;typeof&quot;;
5049 
5050     case VOIDTOKEN:
5051         return &quot;void&quot;;
5052 
5053     case DELETETOKEN:
5054         return &quot;delete&quot;;
5055     }
5056     RELEASE_ASSERT_NOT_REACHED();
5057     return &quot;error&quot;;
5058 }
5059 
5060 template &lt;typename LexerType&gt;
5061 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
5062 {
5063     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
5064     AllowInOverride allowInOverride(this);
5065     int tokenStackDepth = 0;
5066     bool hasPrefixUpdateOp = false;
5067     unsigned lastOperator = 0;
5068 
5069     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
5070         return parseAwaitExpression(context);
5071 
5072     JSTokenLocation location(tokenLocation());
5073 
5074     int oldTokenStackDepth = context.unaryTokenStackDepth();
5075     makeScopeExit([&amp;] {
5076         ASSERT_UNUSED(oldTokenStackDepth, oldTokenStackDepth &lt;= context.unaryTokenStackDepth());
5077     });
5078 
5079     while (isUnaryOp(m_token.m_type)) {
5080         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);
5081         if (isUpdateOp(m_token.m_type))
5082             hasPrefixUpdateOp = true;
5083         lastOperator = m_token.m_type;
5084         m_parserState.nonLHSCount++;
5085         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
5086         next();
5087         m_parserState.nonTrivialExpressionCount++;
5088     }
5089     JSTextPosition subExprStart = tokenStartPosition();
5090     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
5091     TreeExpression expr = parseMemberExpression(context);
5092     if (!expr) {
5093         if (lastOperator)
5094             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
5095         failWithMessage(&quot;Cannot parse member expression&quot;);
5096     }
5097     if constexpr (std::is_same_v&lt;TreeBuilder, ASTBuilder&gt;)
5098         ASSERT(oldTokenStackDepth + tokenStackDepth == context.unaryTokenStackDepth());
5099     if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {
5100         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);
5101         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);
5102     }
5103     bool isEvalOrArguments = false;
5104     if (strictMode()) {
5105         if (context.isResolve(expr))
5106             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;arguments;
5107     }
5108     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; hasPrefixUpdateOp, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5109     switch (m_token.m_type) {
5110     case PLUSPLUS:
5111         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5112         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix ++ operator applied to value that is not a reference&quot;);
5113         m_parserState.nonTrivialExpressionCount++;
5114         m_parserState.nonLHSCount++;
5115         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5116         m_parserState.assignmentCount++;
5117         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5118         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5119         next();
5120         break;
5121     case MINUSMINUS:
5122         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5123         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix -- operator applied to value that is not a reference&quot;);
5124         m_parserState.nonTrivialExpressionCount++;
5125         m_parserState.nonLHSCount++;
5126         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5127         m_parserState.assignmentCount++;
5128         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
5129         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5130         next();
5131         break;
5132     default:
5133         break;
5134     }
5135 
5136     JSTextPosition end = lastTokenEndPosition();
5137     while (tokenStackDepth) {
5138         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);
5139         auto tokenType = context.unaryTokenStackLastType(tokenStackDepth);
5140         switch (tokenType) {
5141         case EXCLAMATION:
5142             expr = context.createLogicalNot(location, expr);
5143             break;
5144         case TILDE:
5145             expr = context.makeBitwiseNotNode(location, expr);
5146             break;
5147         case MINUS:
5148             expr = context.makeNegateNode(location, expr);
5149             break;
5150         case PLUS:
5151             expr = context.createUnaryPlus(location, expr);
5152             break;
5153         case PLUSPLUS:
5154         case AUTOPLUSPLUS:
5155             ASSERT(isSimpleAssignmentTarget(context, expr));
5156             expr = context.makePrefixNode(location, expr, OpPlusPlus, subExprStart, subExprStart + 2, end);
5157             m_parserState.assignmentCount++;
5158             break;
5159         case MINUSMINUS:
5160         case AUTOMINUSMINUS:
5161             ASSERT(isSimpleAssignmentTarget(context, expr));
5162             expr = context.makePrefixNode(location, expr, OpMinusMinus, subExprStart, subExprStart + 2, end);
5163             m_parserState.assignmentCount++;
5164             break;
5165         case TYPEOF:
5166             expr = context.makeTypeOfNode(location, expr);
5167             break;
5168         case VOIDTOKEN:
5169             expr = context.createVoid(location, expr);
5170             break;
5171         case DELETETOKEN:
5172             failIfTrueIfStrict(context.isResolve(expr), &quot;Cannot delete unqualified property &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5173             expr = context.makeDeleteNode(location, expr, context.unaryTokenStackLastStart(tokenStackDepth), end, end);
5174             break;
5175         default:
5176             // If we get here something has gone horribly horribly wrong
5177             CRASH();
5178         }
5179         context.unaryTokenStackRemoveLast(tokenStackDepth);
5180     }
5181     return expr;
5182 }
5183 
5184 template &lt;typename LexerType&gt; void Parser&lt;LexerType&gt;::printUnexpectedTokenText(WTF::PrintStream&amp; out)
5185 {
5186     switch (m_token.m_type) {
5187     case EOFTOK:
5188         out.print(&quot;Unexpected end of script&quot;);
5189         return;
5190     case UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK:
5191     case UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5192         out.print(&quot;Incomplete unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5193         return;
5194     case UNTERMINATED_MULTILINE_COMMENT_ERRORTOK:
5195         out.print(&quot;Unterminated multiline comment&quot;);
5196         return;
5197     case UNTERMINATED_NUMERIC_LITERAL_ERRORTOK:
5198         out.print(&quot;Unterminated numeric literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
5199         return;
5200     case UNTERMINATED_STRING_LITERAL_ERRORTOK:
5201         out.print(&quot;Unterminated string literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
5202         return;
5203     case INVALID_IDENTIFIER_ESCAPE_ERRORTOK:
5204         out.print(&quot;Invalid escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5205         return;
5206     case UNEXPECTED_ESCAPE_ERRORTOK:
5207         out.print(&quot;Unexpected escaped characters in keyword token: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5208         return;
5209     case INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5210         out.print(&quot;Invalid unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5211         return;
5212     case INVALID_NUMERIC_LITERAL_ERRORTOK:
5213         out.print(&quot;Invalid numeric literal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5214         return;
5215     case UNTERMINATED_OCTAL_NUMBER_ERRORTOK:
5216         out.print(&quot;Invalid use of octal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5217         return;
5218     case INVALID_STRING_LITERAL_ERRORTOK:
5219         out.print(&quot;Invalid string literal: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5220         return;
5221     case ERRORTOK:
5222         out.print(&quot;Unrecognized token &#39;&quot;, getToken(), &quot;&#39;&quot;);
5223         return;
5224     case STRING:
5225         out.print(&quot;Unexpected string literal &quot;, getToken());
5226         return;
5227     case INTEGER:
5228     case DOUBLE:
5229         out.print(&quot;Unexpected number &#39;&quot;, getToken(), &quot;&#39;&quot;);
5230         return;
5231 
5232     case RESERVED_IF_STRICT:
5233         out.print(&quot;Unexpected use of reserved word &#39;&quot;, getToken(), &quot;&#39; in strict mode&quot;);
5234         return;
5235 
5236     case RESERVED:
5237         out.print(&quot;Unexpected use of reserved word &#39;&quot;, getToken(), &quot;&#39;&quot;);
5238         return;
5239 
5240     case INVALID_PRIVATE_NAME_ERRORTOK:
5241         out.print(&quot;Invalid private name &#39;&quot;, getToken(), &quot;&#39;&quot;);
5242         return;
5243 
5244     case AWAIT:
5245     case IDENT:
5246         out.print(&quot;Unexpected identifier &#39;&quot;, getToken(), &quot;&#39;&quot;);
5247         return;
5248 
5249     default:
5250         break;
5251     }
5252 
5253     if (m_token.m_type &amp; KeywordTokenFlag) {
5254         out.print(&quot;Unexpected keyword &#39;&quot;, getToken(), &quot;&#39;&quot;);
5255         return;
5256     }
5257 
5258     out.print(&quot;Unexpected token &#39;&quot;, getToken(), &quot;&#39;&quot;);
5259 }
5260 
5261 // Instantiate the two flavors of Parser we need instead of putting most of this file in Parser.h
5262 template class Parser&lt;Lexer&lt;LChar&gt;&gt;;
5263 template class Parser&lt;Lexer&lt;UChar&gt;&gt;;
5264 
5265 } // namespace JSC
    </pre>
  </body>
</html>
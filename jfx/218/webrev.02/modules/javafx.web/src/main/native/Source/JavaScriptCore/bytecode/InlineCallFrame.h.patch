diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h
@@ -35,11 +35,11 @@
 #include <wtf/Vector.h>
 
 namespace JSC {
 
 struct InlineCallFrame;
-class ExecState;
+class CallFrame;
 class JSFunction;
 
 struct InlineCallFrame {
     enum Kind {
         Call,
@@ -177,11 +177,12 @@
 
     Vector<ValueRecovery> argumentsWithFixup; // Includes 'this' and arity fixups.
     WriteBarrier<CodeBlock> baselineCodeBlock;
     CodeOrigin directCaller;
 
-    unsigned argumentCountIncludingThis { 0 }; // Do not include fixups.
+    unsigned argumentCountIncludingThis : 22; // Do not include fixups.
+    unsigned tmpOffset : 10;
     signed stackOffset : 28;
     unsigned kind : 3; // real type is Kind
     bool isClosureCall : 1; // If false then we know that callee/scope are constants and the DFG won't treat them as variables, i.e. they have to be recovered manually.
     VirtualRegister argumentCountRegister; // Only set when we inline a varargs call.
 
@@ -189,11 +190,13 @@
 
     // There is really no good notion of a "default" set of values for
     // InlineCallFrame's fields. This constructor is here just to reduce confusion if
     // we forgot to initialize explicitly.
     InlineCallFrame()
-        : stackOffset(0)
+        : argumentCountIncludingThis(0)
+        , tmpOffset(0)
+        , stackOffset(0)
         , kind(Call)
         , isClosureCall(false)
     {
     }
 
@@ -205,11 +208,11 @@
     CodeSpecializationKind specializationKind() const { return specializationKindFor(static_cast<Kind>(kind)); }
 
     JSFunction* calleeConstant() const;
 
     // Get the callee given a machine call frame to which this InlineCallFrame belongs.
-    JSFunction* calleeForCallFrame(ExecState*) const;
+    JSFunction* calleeForCallFrame(CallFrame*) const;
 
     CString inferredName() const;
     CodeBlockHash hash() const;
     CString hashAsStringIfPossible() const;
 
@@ -217,10 +220,16 @@
     {
         stackOffset = offset;
         RELEASE_ASSERT(static_cast<signed>(stackOffset) == offset);
     }
 
+    void setTmpOffset(unsigned offset)
+    {
+        tmpOffset = offset;
+        RELEASE_ASSERT(static_cast<unsigned>(tmpOffset) == offset);
+    }
+
     ptrdiff_t callerFrameOffset() const { return stackOffset * sizeof(Register) + CallFrame::callerFrameOffset(); }
     ptrdiff_t returnPCOffset() const { return stackOffset * sizeof(Register) + CallFrame::returnPCOffset(); }
 
     bool isStrictMode() const { return baselineCodeBlock->isStrictMode(); }
 
@@ -238,20 +247,20 @@
     return inlineCallFrame->baselineCodeBlock.get();
 }
 
 inline CodeBlock* baselineCodeBlockForOriginAndBaselineCodeBlock(const CodeOrigin& codeOrigin, CodeBlock* baselineCodeBlock)
 {
-    ASSERT(baselineCodeBlock->jitType() == JITType::BaselineJIT);
+    ASSERT(JITCode::isBaselineCode(baselineCodeBlock->jitType()));
     auto* inlineCallFrame = codeOrigin.inlineCallFrame();
     if (inlineCallFrame)
         return baselineCodeBlockForInlineCallFrame(inlineCallFrame);
     return baselineCodeBlock;
 }
 
-// This function is defined here and not in CodeOrigin because it needs access to the directCaller field in InlineCallFrame
+// These function is defined here and not in CodeOrigin because it needs access to the directCaller field in InlineCallFrame
 template <typename Function>
-inline void CodeOrigin::walkUpInlineStack(const Function& function)
+inline void CodeOrigin::walkUpInlineStack(const Function& function) const
 {
     CodeOrigin codeOrigin = *this;
     while (true) {
         function(codeOrigin);
         auto* inlineCallFrame = codeOrigin.inlineCallFrame();
@@ -259,15 +268,42 @@
             break;
         codeOrigin = inlineCallFrame->directCaller;
     }
 }
 
-ALWAYS_INLINE VirtualRegister remapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)
+inline bool CodeOrigin::inlineStackContainsActiveCheckpoint() const
+{
+    bool result = false;
+    walkUpInlineStack([&] (CodeOrigin origin) {
+        if (origin.bytecodeIndex().checkpoint())
+            result = true;
+    });
+    return result;
+}
+
+ALWAYS_INLINE Operand remapOperand(InlineCallFrame* inlineCallFrame, Operand operand)
+{
+    if (inlineCallFrame)
+        return operand.isTmp() ? Operand::tmp(operand.value() + inlineCallFrame->tmpOffset) : operand.virtualRegister() + inlineCallFrame->stackOffset;
+    return operand;
+}
+
+ALWAYS_INLINE Operand remapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)
+{
+    return remapOperand(inlineCallFrame, Operand(reg));
+}
+
+ALWAYS_INLINE Operand unmapOperand(InlineCallFrame* inlineCallFrame, Operand operand)
 {
     if (inlineCallFrame)
-        return VirtualRegister(reg.offset() + inlineCallFrame->stackOffset);
-    return reg;
+        return operand.isTmp() ? Operand::tmp(operand.value() - inlineCallFrame->tmpOffset) : Operand(operand.virtualRegister() - inlineCallFrame->stackOffset);
+    return operand;
+}
+
+ALWAYS_INLINE Operand unmapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)
+{
+    return unmapOperand(inlineCallFrame, Operand(reg));
 }
 
 } // namespace JSC
 
 namespace WTF {

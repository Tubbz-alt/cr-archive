<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentThreadableLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentThreadableLoader.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentThreadableLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,22 ***</span>
  #include &quot;DOMWindow.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
  #include &quot;LoadTiming.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;Performance.h&quot;
  #include &quot;PlatformStrategies.h&quot;
  #include &quot;ProgressTracker.h&quot;
  #include &quot;ResourceError.h&quot;
  #include &quot;ResourceRequest.h&quot;
  #include &quot;ResourceTiming.h&quot;
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;SharedBuffer.h&quot;
  #include &quot;SubresourceIntegrity.h&quot;
  #include &quot;SubresourceLoader.h&quot;
  #include &quot;ThreadableLoaderClient.h&quot;
  #include &lt;wtf/Assertions.h&gt;
<span class="line-new-header">--- 41,23 ---</span>
  #include &quot;DOMWindow.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;LoadTiming.h&quot;
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;Performance.h&quot;
  #include &quot;PlatformStrategies.h&quot;
  #include &quot;ProgressTracker.h&quot;
  #include &quot;ResourceError.h&quot;
  #include &quot;ResourceRequest.h&quot;
  #include &quot;ResourceTiming.h&quot;
  #include &quot;RuntimeApplicationChecks.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;SecurityOrigin.h&quot;
<span class="line-added">+ #include &quot;Settings.h&quot;</span>
  #include &quot;SharedBuffer.h&quot;
  #include &quot;SubresourceIntegrity.h&quot;
  #include &quot;SubresourceLoader.h&quot;
  #include &quot;ThreadableLoaderClient.h&quot;
  #include &lt;wtf/Assertions.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,10 ***</span>
<span class="line-new-header">--- 130,16 ---</span>
      relaxAdoptionRequirement();
  
      // Setting a referrer header is only supported in the async code path.
      ASSERT(m_async || m_referrer.isEmpty());
  
<span class="line-added">+     if (document.settings().disallowSyncXHRDuringPageDismissalEnabled() &amp;&amp; !m_async &amp;&amp; (!document.page() || !document.page()-&gt;areSynchronousLoadsAllowed())) {</span>
<span class="line-added">+         document.didRejectSyncXHRDuringPageDismissal();</span>
<span class="line-added">+         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, request.url(), &quot;Synchronous loads are not allowed at this time&quot;));</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // Referrer and Origin headers should be set after the preflight if any.
      ASSERT(!request.hasHTTPReferrer() &amp;&amp; !request.hasHTTPOrigin());
  
      ASSERT_WITH_SECURITY_IMPLICATION(isAllowedByContentSecurityPolicy(request.url(), ContentSecurityPolicy::RedirectResponseReceived::No));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,11 ***</span>
          m_originalHeaders = request.httpHeaderFields();
  
      if (shouldSetHTTPHeadersToKeep())
          m_options.httpHeadersToKeep = httpHeadersToKeepFromCleaning(request.httpHeaderFields());
  
<span class="line-modified">!     if (document.isRunningUserScripts() &amp;&amp; SchemeRegistry::isUserExtensionScheme(request.url().protocol().toStringWithoutCopying())) {</span>
          m_options.mode = FetchOptions::Mode::NoCors;
          m_options.filteringPolicy = ResponseFilteringPolicy::Disable;
      }
  
      m_options.cspResponseHeaders = m_options.contentSecurityPolicyEnforcement != ContentSecurityPolicyEnforcement::DoNotEnforce ? this-&gt;contentSecurityPolicy().responseHeaders() : ContentSecurityPolicyResponseHeaders { };
<span class="line-new-header">--- 152,15 ---</span>
          m_originalHeaders = request.httpHeaderFields();
  
      if (shouldSetHTTPHeadersToKeep())
          m_options.httpHeadersToKeep = httpHeadersToKeepFromCleaning(request.httpHeaderFields());
  
<span class="line-modified">!     bool shouldDisableCORS = document.isRunningUserScripts() &amp;&amp; LegacySchemeRegistry::isUserExtensionScheme(request.url().protocol().toStringWithoutCopying());</span>
<span class="line-added">+     if (auto* page = document.page())</span>
<span class="line-added">+         shouldDisableCORS |= page-&gt;shouldDisableCorsForRequestTo(request.url());</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (shouldDisableCORS) {</span>
          m_options.mode = FetchOptions::Mode::NoCors;
          m_options.filteringPolicy = ResponseFilteringPolicy::Disable;
      }
  
      m_options.cspResponseHeaders = m_options.contentSecurityPolicyEnforcement != ContentSecurityPolicyEnforcement::DoNotEnforce ? this-&gt;contentSecurityPolicy().responseHeaders() : ContentSecurityPolicyResponseHeaders { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,11 ***</span>
  }
  
  bool DocumentThreadableLoader::checkURLSchemeAsCORSEnabled(const URL&amp; url)
  {
      // Cross-origin requests are only allowed for HTTP and registered schemes. We would catch this when checking response headers later, but there is no reason to send a request that&#39;s guaranteed to be denied.
<span class="line-modified">!     if (!SchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(url.protocol().toStringWithoutCopying())) {</span>
          logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross origin requests are only supported for HTTP.&quot;, ResourceError::Type::AccessControl));
          return false;
      }
      return true;
  }
<span class="line-new-header">--- 183,11 ---</span>
  }
  
  bool DocumentThreadableLoader::checkURLSchemeAsCORSEnabled(const URL&amp; url)
  {
      // Cross-origin requests are only allowed for HTTP and registered schemes. We would catch this when checking response headers later, but there is no reason to send a request that&#39;s guaranteed to be denied.
<span class="line-modified">!     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(url.protocol().toStringWithoutCopying())) {</span>
          logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross origin requests are only supported for HTTP.&quot;, ResourceError::Type::AccessControl));
          return false;
      }
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,11 ***</span>
  {
      ASSERT(m_client);
  
      if (m_delayCallbacksForIntegrityCheck) {
          if (!matchIntegrityMetadata(*m_resource, m_options.integrity)) {
<span class="line-modified">!             reportIntegrityMetadataError(m_resource-&gt;url());</span>
              return;
          }
  
          auto response = m_resource-&gt;response();
  
<span class="line-new-header">--- 451,11 ---</span>
  {
      ASSERT(m_client);
  
      if (m_delayCallbacksForIntegrityCheck) {
          if (!matchIntegrityMetadata(*m_resource, m_options.integrity)) {
<span class="line-modified">!             reportIntegrityMetadataError(*m_resource, m_options.integrity);</span>
              return;
          }
  
          auto response = m_resource-&gt;response();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,15 ***</span>
          return true;
  
      return m_sameOriginRequest &amp;&amp; securityOrigin().canRequest(url);
  }
  
<span class="line-removed">- bool DocumentThreadableLoader::isXMLHttpRequest() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_options.initiator == cachedResourceRequestInitiators().xmlhttprequest;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  SecurityOrigin&amp; DocumentThreadableLoader::securityOrigin() const
  {
      return m_origin ? *m_origin : m_document.securityOrigin();
  }
  
<span class="line-new-header">--- 664,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,13 ***</span>
  void DocumentThreadableLoader::reportCrossOriginResourceSharingError(const URL&amp; url)
  {
      logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross-origin redirection denied by Cross-Origin Resource Sharing policy.&quot;_s, ResourceError::Type::AccessControl));
  }
  
<span class="line-modified">! void DocumentThreadableLoader::reportIntegrityMetadataError(const URL&amp; url)</span>
  {
<span class="line-modified">!     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Failed integrity metadata check.&quot;_s, ResourceError::Type::General));</span>
  }
  
  void DocumentThreadableLoader::logErrorAndFail(const ResourceError&amp; error)
  {
      if (m_shouldLogError == ShouldLogError::Yes) {
<span class="line-new-header">--- 692,13 ---</span>
  void DocumentThreadableLoader::reportCrossOriginResourceSharingError(const URL&amp; url)
  {
      logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross-origin redirection denied by Cross-Origin Resource Sharing policy.&quot;_s, ResourceError::Type::AccessControl));
  }
  
<span class="line-modified">! void DocumentThreadableLoader::reportIntegrityMetadataError(const CachedResource&amp; resource, const String&amp; expectedMetadata)</span>
  {
<span class="line-modified">!     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, resource.url(), makeString(&quot;Failed integrity metadata check. &quot;_s, integrityMismatchDescription(resource, expectedMetadata)), ResourceError::Type::General));</span>
  }
  
  void DocumentThreadableLoader::logErrorAndFail(const ResourceError&amp; error)
  {
      if (m_shouldLogError == ShouldLogError::Yes) {
</pre>
<center><a href="DocumentLoader.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentThreadableLoader.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
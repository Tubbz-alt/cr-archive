<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderingContextBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;ActivityStateChangeObserver.h&quot;
 31 #include &quot;ExceptionOr.h&quot;
 32 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
<span class="line-modified"> 33 #include &quot;GraphicsContext3D.h&quot;</span>
 34 #include &quot;ImageBuffer.h&quot;

 35 #include &quot;Timer.h&quot;
 36 #include &quot;WebGLAny.h&quot;
 37 #include &quot;WebGLBuffer.h&quot;
 38 #include &quot;WebGLContextAttributes.h&quot;
 39 #include &quot;WebGLFramebuffer.h&quot;
 40 #include &quot;WebGLProgram.h&quot;
 41 #include &quot;WebGLRenderbuffer.h&quot;
 42 #include &quot;WebGLStateTracker.h&quot;
 43 #include &quot;WebGLTexture.h&quot;
 44 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 45 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 46 #include &lt;limits&gt;
 47 #include &lt;memory&gt;
 48 
 49 #if ENABLE(WEBGL2)
 50 #include &quot;WebGLVertexArrayObject.h&quot;
 51 #endif
 52 
 53 namespace WebCore {
 54 
 55 class ANGLEInstancedArrays;
 56 class EXTBlendMinMax;
 57 class EXTTextureFilterAnisotropic;
 58 class EXTShaderTextureLOD;
 59 class EXTsRGB;
 60 class EXTFragDepth;
 61 class HTMLImageElement;
 62 class ImageData;
 63 class IntSize;
 64 class OESStandardDerivatives;
 65 class OESTextureFloat;
 66 class OESTextureFloatLinear;
 67 class OESTextureHalfFloat;
 68 class OESTextureHalfFloatLinear;
 69 class OESVertexArrayObject;
 70 class OESElementIndexUint;

 71 class OffscreenCanvas;

 72 class WebGLActiveInfo;
 73 class WebGLContextGroup;
 74 class WebGLContextObject;
 75 class WebGLCompressedTextureASTC;
 76 class WebGLCompressedTextureATC;


 77 class WebGLCompressedTexturePVRTC;
 78 class WebGLCompressedTextureS3TC;
 79 class WebGLDebugRendererInfo;
 80 class WebGLDebugShaders;
 81 class WebGLDepthTexture;
 82 class WebGLDrawBuffers;
 83 class WebGLExtension;
 84 class WebGLLoseContext;
 85 class WebGLObject;
 86 class WebGLShader;
 87 class WebGLSharedObject;
 88 class WebGLShaderPrecisionFormat;
 89 class WebGLUniformLocation;
 90 
 91 #if ENABLE(VIDEO)
 92 class HTMLVideoElement;
 93 #endif
 94 

 95 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;



 96 
<span class="line-modified"> 97 class WebGLRenderingContextBase : public GraphicsContext3D::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {</span>
 98     WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
 99 public:
100     static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
101     virtual ~WebGLRenderingContextBase();
102 
103     WebGLCanvas canvas();
104 
105     int drawingBufferWidth() const;
106     int drawingBufferHeight() const;
107 
<span class="line-modified">108     void activeTexture(GC3Denum texture);</span>
109     void attachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">110     void bindAttribLocation(WebGLProgram*, GC3Duint index, const String&amp; name);</span>
<span class="line-modified">111     void bindBuffer(GC3Denum target, WebGLBuffer*);</span>
<span class="line-modified">112     void bindFramebuffer(GC3Denum target, WebGLFramebuffer*);</span>
<span class="line-modified">113     void bindRenderbuffer(GC3Denum target, WebGLRenderbuffer*);</span>
<span class="line-modified">114     void bindTexture(GC3Denum target, WebGLTexture*);</span>
<span class="line-modified">115     void blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha);</span>
<span class="line-modified">116     void blendEquation(GC3Denum mode);</span>
<span class="line-modified">117     void blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha);</span>
<span class="line-modified">118     void blendFunc(GC3Denum sfactor, GC3Denum dfactor);</span>
<span class="line-modified">119     void blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha);</span>
120 
121     using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
<span class="line-modified">122     void bufferData(GC3Denum target, long long size, GC3Denum usage);</span>
<span class="line-modified">123     void bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GC3Denum usage);</span>
<span class="line-modified">124     void bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);</span>
<span class="line-modified">125 </span>
<span class="line-modified">126     GC3Denum checkFramebufferStatus(GC3Denum target);</span>
<span class="line-modified">127     virtual void clear(GC3Dbitfield mask) = 0;</span>
<span class="line-modified">128     void clearColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha);</span>
<span class="line-modified">129     void clearDepth(GC3Dfloat);</span>
<span class="line-modified">130     void clearStencil(GC3Dint);</span>
<span class="line-modified">131     void colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha);</span>
132     void compileShader(WebGLShader*);
133 
<span class="line-modified">134     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data);</span>
<span class="line-modified">135     void compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data);</span>
136 
<span class="line-modified">137     void copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border);</span>
<span class="line-modified">138     void copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
139 
140     RefPtr&lt;WebGLBuffer&gt; createBuffer();
141     RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
142     RefPtr&lt;WebGLProgram&gt; createProgram();
143     RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
<span class="line-modified">144     RefPtr&lt;WebGLShader&gt; createShader(GC3Denum type);</span>
145     RefPtr&lt;WebGLTexture&gt; createTexture();
146 
<span class="line-modified">147     void cullFace(GC3Denum mode);</span>
148 
149     void deleteBuffer(WebGLBuffer*);
150     void deleteFramebuffer(WebGLFramebuffer*);
151     void deleteProgram(WebGLProgram*);
152     void deleteRenderbuffer(WebGLRenderbuffer*);
153     void deleteShader(WebGLShader*);
154     void deleteTexture(WebGLTexture*);
155 
<span class="line-modified">156     void depthFunc(GC3Denum);</span>
<span class="line-modified">157     void depthMask(GC3Dboolean);</span>
<span class="line-modified">158     void depthRange(GC3Dfloat zNear, GC3Dfloat zFar);</span>
159     void detachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">160     void disable(GC3Denum cap);</span>
<span class="line-modified">161     void disableVertexAttribArray(GC3Duint index);</span>
<span class="line-modified">162     void drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count);</span>
<span class="line-modified">163     void drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset);</span>
164 
<span class="line-modified">165     void enable(GC3Denum cap);</span>
<span class="line-modified">166     void enableVertexAttribArray(GC3Duint index);</span>
167     void finish();
168     void flush();
<span class="line-modified">169     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer*);</span>
<span class="line-modified">170     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture*, GC3Dint level);</span>
<span class="line-modified">171     void frontFace(GC3Denum mode);</span>
<span class="line-modified">172     void generateMipmap(GC3Denum target);</span>
173 
<span class="line-modified">174     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GC3Duint index);</span>
<span class="line-modified">175     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GC3Duint index);</span>
176     Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
<span class="line-modified">177     GC3Dint getAttribLocation(WebGLProgram*, const String&amp; name);</span>
<span class="line-modified">178     WebGLAny getBufferParameter(GC3Denum target, GC3Denum pname);</span>
179     Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
<span class="line-modified">180     GC3Denum getError();</span>
181     virtual WebGLExtension* getExtension(const String&amp; name) = 0;
<span class="line-modified">182     virtual WebGLAny getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname) = 0;</span>
<span class="line-modified">183     virtual WebGLAny getParameter(GC3Denum pname) = 0;</span>
<span class="line-modified">184     WebGLAny getProgramParameter(WebGLProgram*, GC3Denum pname);</span>
185     String getProgramInfoLog(WebGLProgram*);
<span class="line-modified">186     WebGLAny getRenderbufferParameter(GC3Denum target, GC3Denum pname);</span>
<span class="line-modified">187     WebGLAny getShaderParameter(WebGLShader*, GC3Denum pname);</span>
188     String getShaderInfoLog(WebGLShader*);
<span class="line-modified">189     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType);</span>
190     String getShaderSource(WebGLShader*);
191     virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
<span class="line-modified">192     WebGLAny getTexParameter(GC3Denum target, GC3Denum pname);</span>
193     WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
194     RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
<span class="line-modified">195     WebGLAny getVertexAttrib(GC3Duint index, GC3Denum pname);</span>
<span class="line-modified">196     long long getVertexAttribOffset(GC3Duint index, GC3Denum pname);</span>
197 
198     bool extensionIsEnabled(const String&amp;);
199 
200     bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
201     void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
202 
203     bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
204     void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
205 
<span class="line-modified">206     virtual void hint(GC3Denum target, GC3Denum mode) = 0;</span>
<span class="line-modified">207     GC3Dboolean isBuffer(WebGLBuffer*);</span>
208     bool isContextLost() const;
<span class="line-modified">209     GC3Dboolean isEnabled(GC3Denum cap);</span>
<span class="line-modified">210     GC3Dboolean isFramebuffer(WebGLFramebuffer*);</span>
<span class="line-modified">211     GC3Dboolean isProgram(WebGLProgram*);</span>
<span class="line-modified">212     GC3Dboolean isRenderbuffer(WebGLRenderbuffer*);</span>
<span class="line-modified">213     GC3Dboolean isShader(WebGLShader*);</span>
<span class="line-modified">214     GC3Dboolean isTexture(WebGLTexture*);</span>
<span class="line-modified">215 </span>
<span class="line-modified">216     void lineWidth(GC3Dfloat);</span>
217     void linkProgram(WebGLProgram*);
218     bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
<span class="line-modified">219     void pixelStorei(GC3Denum pname, GC3Dint param);</span>
<span class="line-modified">220     void polygonOffset(GC3Dfloat factor, GC3Dfloat units);</span>
<span class="line-modified">221     void readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels);</span>
222     void releaseShaderCompiler();
<span class="line-modified">223     virtual void renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height) = 0;</span>
<span class="line-modified">224     void sampleCoverage(GC3Dfloat value, GC3Dboolean invert);</span>
<span class="line-modified">225     void scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
226     void shaderSource(WebGLShader*, const String&amp;);
<span class="line-modified">227     void stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask);</span>
<span class="line-modified">228     void stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask);</span>
<span class="line-modified">229     void stencilMask(GC3Duint);</span>
<span class="line-modified">230     void stencilMaskSeparate(GC3Denum face, GC3Duint mask);</span>
<span class="line-modified">231     void stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass);</span>
<span class="line-modified">232     void stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass);</span>
233 
<span class="line-modified">234     void texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
235 
236 #if ENABLE(VIDEO)
237     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
238 #else
239     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
240 #endif
241 
<span class="line-modified">242     ExceptionOr&lt;void&gt; texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;);</span>
243 
<span class="line-modified">244     void texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param);</span>
<span class="line-modified">245     void texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param);</span>
246 
<span class="line-modified">247     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
<span class="line-modified">248     ExceptionOr&lt;void&gt; texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp;);</span>
249 
250     template &lt;class TypedArray, class DataType&gt;
251     class TypedList {
252     public:
253         using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
254 
255         TypedList(VariantType&amp;&amp; variant)
256             : m_variant(WTFMove(variant))
257         {
258         }
259 
260         const DataType* data() const
261         {
262             return WTF::switchOn(m_variant,
263                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
264                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
265             );
266         }
267 
<span class="line-modified">268         GC3Dsizei length() const</span>
269         {
270             return WTF::switchOn(m_variant,
<span class="line-modified">271                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GC3Dsizei { return typedArray-&gt;length(); },</span>
<span class="line-modified">272                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GC3Dsizei { return vector.size(); }</span>
273             );
274         }
275 
276     private:
277         VariantType m_variant;
278     };
279 
280     using Float32List = TypedList&lt;Float32Array, float&gt;;
281     using Int32List = TypedList&lt;Int32Array, int&gt;;
282 
<span class="line-modified">283     void uniform1f(const WebGLUniformLocation*, GC3Dfloat x);</span>
<span class="line-modified">284     void uniform2f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y);</span>
<span class="line-modified">285     void uniform3f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);</span>
<span class="line-modified">286     void uniform4f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);</span>
287 
<span class="line-modified">288     void uniform1i(const WebGLUniformLocation*, GC3Dint x);</span>
<span class="line-modified">289     void uniform2i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y);</span>
<span class="line-modified">290     void uniform3i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y, GC3Dint z);</span>
<span class="line-modified">291     void uniform4i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);</span>
292 
293     void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
294     void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
295     void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
296     void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
297 
298     void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
299     void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
300     void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
301     void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
302 
<span class="line-modified">303     void uniformMatrix2fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">304     void uniformMatrix3fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">305     void uniformMatrix4fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
306 
307     void useProgram(WebGLProgram*);
308     void validateProgram(WebGLProgram*);
309 
<span class="line-modified">310     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);</span>
<span class="line-modified">311     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);</span>
<span class="line-modified">312     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);</span>
<span class="line-modified">313     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);</span>
314 
<span class="line-modified">315     void vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">316     void vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">317     void vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">318     void vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp;);</span>
319 
<span class="line-modified">320     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,</span>
<span class="line-modified">321         GC3Dsizei stride, long long offset);</span>
322 
<span class="line-modified">323     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
324 
325     // WEBKIT_lose_context support
326     enum LostContextMode {
327         // Lost context occurred at the graphics system level.
328         RealLostContext,
329 
330         // Lost context provoked by WEBKIT_lose_context.
331         SyntheticLostContext
332     };
333     void forceLostContext(LostContextMode);
334     void forceRestoreContext();
335     void loseContextImpl(LostContextMode);
336     WEBCORE_EXPORT void simulateContextChanged();
337 
<span class="line-modified">338     GraphicsContext3D* graphicsContext3D() const { return m_context.get(); }</span>
339     WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
340     PlatformLayer* platformLayer() const override;
341 
342     void reshape(int width, int height) override;
343 
344     void markLayerComposited() final;
345     void paintRenderingResultsToCanvas() override;
346     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
347 
348     void removeSharedObject(WebGLSharedObject&amp;);
349     void removeContextObject(WebGLContextObject&amp;);
350 
351     unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
352 
353     // Instanced Array helper functions.
<span class="line-modified">354     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);</span>
<span class="line-modified">355     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount);</span>
<span class="line-modified">356     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);</span>
357 
358     // Used for testing only, from Internals.
359     WEBCORE_EXPORT void setFailNextGPUStatusCheck();
360 
<span class="line-modified">361     // GraphicsContext3D::Client</span>
362     void didComposite() override;
363     void forceContextLost() override;
364     void recycleContext() override;
365     void dispatchContextChangedNotification() override;
366 



367 protected:
368     WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
<span class="line-modified">369     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContext3D&gt;&amp;&amp;, WebGLContextAttributes);</span>
370 
371     friend class WebGLDrawBuffers;
372     friend class WebGLFramebuffer;
373     friend class WebGLObject;
374     friend class OESVertexArrayObject;
375     friend class WebGLDebugShaders;
376     friend class WebGLCompressedTextureASTC;
377     friend class WebGLCompressedTextureATC;


378     friend class WebGLCompressedTexturePVRTC;
379     friend class WebGLCompressedTextureS3TC;
380     friend class WebGLRenderingContextErrorMessageCallback;
381     friend class WebGLVertexArrayObjectOES;
382     friend class WebGLVertexArrayObject;
383     friend class WebGLVertexArrayObjectBase;
384 
385     virtual void initializeNewContext();
386     virtual void initializeVertexArrayObjects() = 0;
387     void setupFlags();
388 
389     // ActiveDOMObject
<span class="line-removed">390     bool hasPendingActivity() const override;</span>
391     void stop() override;
392     const char* activeDOMObjectName() const override;
<span class="line-modified">393     bool canSuspendForDocumentSuspension() const override;</span>

394 
395     void addSharedObject(WebGLSharedObject&amp;);
396     void addContextObject(WebGLContextObject&amp;);
397     void detachAndRemoveAllObjects();
398 
<span class="line-modified">399     void destroyGraphicsContext3D();</span>
400     void markContextChanged();
401     void markContextChangedAndNotifyCanvasObserver();
402 
403     void addActivityStateChangeObserverIfNecessary();
404     void removeActivityStateChangeObserver();
405 
406     // Query whether it is built on top of compliant GLES2 implementation.
407     bool isGLES2Compliant() { return m_isGLES2Compliant; }
408     // Query if the GL implementation is NPOT strict.
409     bool isGLES2NPOTStrict() { return m_isGLES2NPOTStrict; }
410     // Query if depth_stencil buffer is supported.
411     bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
412 
413     // Helper to return the size in bytes of OpenGL data types
414     // like GL_FLOAT, GL_INT, etc.
<span class="line-modified">415     unsigned int sizeInBytes(GC3Denum type);</span>
416 
417     // Basic validation of count and offset against number of elements in element array buffer
<span class="line-modified">418     bool validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset);</span>
419 
420     // Conservative but quick index validation
<span class="line-modified">421     virtual bool validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired) = 0;</span>
422 
423     // Precise but slow index validation -- only done if conservative checks fail
<span class="line-modified">424     bool validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired);</span>
425     bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
426 
427     bool validateWebGLObject(const char*, WebGLObject*);
428 
<span class="line-modified">429     bool validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);</span>
<span class="line-modified">430     bool validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primcount);</span>
<span class="line-modified">431     bool validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName);</span>
432 
433     // Adds a compressed texture format.
<span class="line-modified">434     void addCompressedTextureFormat(GC3Denum);</span>
435 
436     RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
437 
438 #if ENABLE(VIDEO)
439     RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
440 #endif
441 
442     WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
443 
444     bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
445 
<span class="line-modified">446     RefPtr&lt;GraphicsContext3D&gt; m_context;</span>


447     RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
448 
449     // Dispatches a context lost event once it is determined that one is needed.
450     // This is used both for synthetic and real context losses. For real ones, it&#39;s
451     // likely that there&#39;s no JavaScript on the stack, but that might be dependent
452     // on how exactly the platform discovers that the context was lost. For better
453     // portability we always defer the dispatch of the event.
<span class="line-modified">454     Timer m_dispatchContextLostEventTimer;</span>

455     bool m_restoreAllowed { false };
<span class="line-modified">456     Timer m_restoreTimer;</span>
457 
458     bool m_needsUpdate;
459     bool m_markedCanvasDirty;
460     HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
461 
462     // List of bound VBO&#39;s. Used to maintain info about sizes for ARRAY_BUFFER and stored values for ELEMENT_ARRAY_BUFFER
463     RefPtr&lt;WebGLBuffer&gt; m_boundArrayBuffer;
464     RefPtr&lt;WebGLBuffer&gt; m_boundCopyReadBuffer;
465     RefPtr&lt;WebGLBuffer&gt; m_boundCopyWriteBuffer;
466     RefPtr&lt;WebGLBuffer&gt; m_boundPixelPackBuffer;
467     RefPtr&lt;WebGLBuffer&gt; m_boundPixelUnpackBuffer;
468     RefPtr&lt;WebGLBuffer&gt; m_boundTransformFeedbackBuffer;
469     RefPtr&lt;WebGLBuffer&gt; m_boundUniformBuffer;
470 
471     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_defaultVertexArrayObject;
472     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_boundVertexArrayObject;
473 
474     void setBoundVertexArrayObject(WebGLVertexArrayObjectBase* arrayObject)
475     {
476         m_boundVertexArrayObject = arrayObject ? arrayObject : m_defaultVertexArrayObject;
477     }
478 
479     class VertexAttribValue {
480     public:
481         VertexAttribValue()
482         {
483             initValue();
484         }
485 
486         void initValue()
487         {
488             value[0] = 0.0f;
489             value[1] = 0.0f;
490             value[2] = 0.0f;
491             value[3] = 1.0f;
492         }
493 
<span class="line-modified">494         GC3Dfloat value[4];</span>
495     };
496     Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
497     unsigned m_maxVertexAttribs;
498     RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
499     long m_vertexAttrib0BufferSize { 0 };
<span class="line-modified">500     GC3Dfloat m_vertexAttrib0BufferValue[4];</span>
501     bool m_forceAttrib0BufferRefill { true };
502     bool m_vertexAttrib0UsedBefore { false };
503 
504     RefPtr&lt;WebGLProgram&gt; m_currentProgram;
505     RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
506     RefPtr&lt;WebGLFramebuffer&gt; m_readFramebufferBinding;
507     RefPtr&lt;WebGLRenderbuffer&gt; m_renderbufferBinding;
508     struct TextureUnitState {
509         RefPtr&lt;WebGLTexture&gt; texture2DBinding;
510         RefPtr&lt;WebGLTexture&gt; textureCubeMapBinding;
511     };
512     Vector&lt;TextureUnitState&gt; m_textureUnits;
513     HashSet&lt;unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; m_unrenderableTextureUnits;
514 
515     unsigned long m_activeTextureUnit;
516 
517     RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
518     RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
519 
<span class="line-modified">520     Vector&lt;GC3Denum&gt; m_compressedTextureFormats;</span>
521 
522     // Fixed-size cache of reusable image buffers for video texImage2D calls.
523     class LRUImageBufferCache {
524     public:
525         LRUImageBufferCache(int capacity);
526         // The pointer returned is owned by the image buffer map.
527         ImageBuffer* imageBuffer(const IntSize&amp; size);
528     private:
529         void bubbleToFront(size_t idx);
530         Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
531     };
532     LRUImageBufferCache m_generatedImageCache { 0 };
533 
<span class="line-modified">534     GC3Dint m_maxTextureSize;</span>
<span class="line-modified">535     GC3Dint m_maxCubeMapTextureSize;</span>
<span class="line-modified">536     GC3Dint m_maxRenderbufferSize;</span>
<span class="line-modified">537     GC3Dint m_maxViewportDims[2] { 0, 0 };</span>
<span class="line-modified">538     GC3Dint m_maxTextureLevel;</span>
<span class="line-modified">539     GC3Dint m_maxCubeMapTextureLevel;</span>
540 
<span class="line-modified">541     GC3Dint m_maxDrawBuffers;</span>
<span class="line-modified">542     GC3Dint m_maxColorAttachments;</span>
<span class="line-modified">543     GC3Denum m_backDrawBuffer;</span>
544     bool m_drawBuffersWebGLRequirementsChecked;
545     bool m_drawBuffersSupported;
546 
<span class="line-modified">547     GC3Dint m_packAlignment;</span>
<span class="line-modified">548     GC3Dint m_unpackAlignment;</span>
549     bool m_unpackFlipY;
550     bool m_unpackPremultiplyAlpha;
<span class="line-modified">551     GC3Denum m_unpackColorspaceConversion;</span>
552     bool m_contextLost { false };
553     LostContextMode m_contextLostMode { SyntheticLostContext };
554     WebGLContextAttributes m_attributes;
555 
556     bool m_layerCleared;
<span class="line-modified">557     GC3Dfloat m_clearColor[4];</span>
558     bool m_scissorEnabled;
<span class="line-modified">559     GC3Dfloat m_clearDepth;</span>
<span class="line-modified">560     GC3Dint m_clearStencil;</span>
<span class="line-modified">561     GC3Dboolean m_colorMask[4];</span>
<span class="line-modified">562     GC3Dboolean m_depthMask;</span>
563 
564     bool m_stencilEnabled;
<span class="line-modified">565     GC3Duint m_stencilMask, m_stencilMaskBack;</span>
<span class="line-modified">566     GC3Dint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.</span>
<span class="line-modified">567     GC3Duint m_stencilFuncMask, m_stencilFuncMaskBack;</span>
568 
569     bool m_isGLES2Compliant;
570     bool m_isGLES2NPOTStrict;
571     bool m_isDepthStencilSupported;
572     bool m_isRobustnessEXTSupported;
573 
574     bool m_synthesizedErrorsToConsole { true };
575     int m_numGLErrorsToConsoleAllowed;
576 
577     bool m_preventBufferClearForInspector { false };
578 
579     // A WebGLRenderingContext can be created in a state where it appears as
580     // a valid and active context, but will not execute any important operations
581     // until its load policy is completely resolved.
582     bool m_isPendingPolicyResolution { false };
583     bool m_hasRequestedPolicyResolution { false };
584     bool isContextLostOrPending();
585 
586     // Enabled extension objects.
587     // FIXME: Move some of these to WebGLRenderingContext, the ones not needed for WebGL2
588     std::unique_ptr&lt;EXTFragDepth&gt; m_extFragDepth;
589     std::unique_ptr&lt;EXTBlendMinMax&gt; m_extBlendMinMax;
590     std::unique_ptr&lt;EXTsRGB&gt; m_extsRGB;
591     std::unique_ptr&lt;EXTTextureFilterAnisotropic&gt; m_extTextureFilterAnisotropic;
592     std::unique_ptr&lt;EXTShaderTextureLOD&gt; m_extShaderTextureLOD;
593     std::unique_ptr&lt;OESTextureFloat&gt; m_oesTextureFloat;
594     std::unique_ptr&lt;OESTextureFloatLinear&gt; m_oesTextureFloatLinear;
595     std::unique_ptr&lt;OESTextureHalfFloat&gt; m_oesTextureHalfFloat;
596     std::unique_ptr&lt;OESTextureHalfFloatLinear&gt; m_oesTextureHalfFloatLinear;
597     std::unique_ptr&lt;OESStandardDerivatives&gt; m_oesStandardDerivatives;
598     std::unique_ptr&lt;OESVertexArrayObject&gt; m_oesVertexArrayObject;
599     std::unique_ptr&lt;OESElementIndexUint&gt; m_oesElementIndexUint;
600     std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
601     std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
602     std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
603     std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
604     std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;


605     std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
606     std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
607     std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
608     std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
609     std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
610 
611     // Helpers for getParameter and other similar functions.
<span class="line-modified">612     bool getBooleanParameter(GC3Denum);</span>
<span class="line-modified">613     Vector&lt;bool&gt; getBooleanArrayParameter(GC3Denum);</span>
<span class="line-modified">614     float getFloatParameter(GC3Denum);</span>
<span class="line-modified">615     int getIntParameter(GC3Denum);</span>
<span class="line-modified">616     unsigned getUnsignedIntParameter(GC3Denum);</span>
<span class="line-modified">617     long long getInt64Parameter(GC3Denum);</span>
<span class="line-modified">618     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GC3Denum);</span>
<span class="line-modified">619     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GC3Denum);</span>
620 
621     // Clear the backbuffer if it was composited since the last operation.
622     // clearMask is set to the bitfield of any clear that would happen anyway at this time
623     // and the function returns true if that clear is now unnecessary.
<span class="line-modified">624     bool clearIfComposited(GC3Dbitfield clearMask = 0);</span>
625 
626     // Helper to restore state that clearing the framebuffer may destroy.
627     void restoreStateAfterClear();
628 
<span class="line-modified">629     void texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);</span>
<span class="line-modified">630     void texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image*, GraphicsContext3D::ImageHtmlDomSource, bool flipY, bool premultiplyAlpha);</span>
<span class="line-modified">631     void texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalformat, GC3Denum format, GC3Denum type, const void* pixels);</span>
<span class="line-modified">632     void texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image*, GraphicsContext3D::ImageHtmlDomSource, bool flipY, bool premultiplyAlpha);</span>
633 
634     bool checkTextureCompleteness(const char*, bool);
635 
636     void createFallbackBlackTextures1x1();
637 
638     // Helper function for copyTex{Sub}Image, check whether the internalformat
639     // and the color buffer format of the current bound framebuffer combination
640     // is valid.
<span class="line-modified">641     bool isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,</span>
<span class="line-removed">642                                                         GC3Denum colorBufferFormat);</span>
643 
644     // Helper function to get the bound framebuffer&#39;s color buffer format.
<span class="line-modified">645     GC3Denum getBoundFramebufferColorFormat();</span>
646 
647     // Helper function to get the bound framebuffer&#39;s width.
648     int getBoundFramebufferWidth();
649 
650     // Helper function to get the bound framebuffer&#39;s height.
651     int getBoundFramebufferHeight();
652 
653     // Helper function to verify limits on the length of uniform and attribute locations.
654     bool validateLocationLength(const char* functionName, const String&amp;);
655 
656     // Helper function to check if size is non-negative.
657     // Generate GL error and return false for negative inputs; otherwise, return true.
<span class="line-modified">658     bool validateSize(const char* functionName, GC3Dint x, GC3Dint y);</span>
659 
660     // Helper function to check if all characters in the string belong to the
661     // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
662     bool validateString(const char* functionName, const String&amp;);
663 
664     // Helper function to check target and texture bound to the target.
665     // Generate GL errors and return 0 if target is invalid or texture bound is
666     // null.  Otherwise, return the texture bound to the target.
<span class="line-modified">667     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap);</span>
668 
669     // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
670     // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">671     bool validateTexFuncFormatAndType(const char* functionName, GC3Denum internalformat, GC3Denum format, GC3Denum type, GC3Dint level);</span>
672 
673     // Helper function to check input level for functions {copy}Tex{Sub}Image.
674     // Generates GL error and returns false if level is invalid.
<span class="line-modified">675     bool validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level);</span>
676 
677     enum TexFuncValidationFunctionType {
678         TexImage,
679         TexSubImage,
680         CopyTexImage
681     };
682 
683     enum TexFuncValidationSourceType {
684         SourceArrayBufferView,
685         SourceImageBitmap,
686         SourceImageData,
687         SourceHTMLImageElement,
688         SourceHTMLCanvasElement,
689 #if ENABLE(VIDEO)
690         SourceHTMLVideoElement,
691 #endif
692     };
693 
694     // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
695     // Otherwise, it would return quickly without doing other work.
<span class="line-modified">696     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width,</span>
<span class="line-modified">697         GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset);</span>
698 
699     // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
700     // Generates GL error and returns false if parameters are invalid.
701     bool validateTexFuncParameters(const char* functionName,
702         TexFuncValidationFunctionType,
<span class="line-modified">703         GC3Denum target, GC3Dint level,</span>
<span class="line-modified">704         GC3Denum internalformat,</span>
<span class="line-modified">705         GC3Dsizei width, GC3Dsizei height, GC3Dint border,</span>
<span class="line-modified">706         GC3Denum format, GC3Denum type);</span>
707 
708     enum NullDisposition {
709         NullAllowed,
710         NullNotAllowed
711     };
712 
713     // Helper function to validate that the given ArrayBufferView
714     // is of the correct type and contains enough data for the texImage call.
715     // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">716     bool validateTexFuncData(const char* functionName, GC3Dint level,</span>
<span class="line-modified">717         GC3Dsizei width, GC3Dsizei height,</span>
<span class="line-modified">718         GC3Denum internalformat, GC3Denum format, GC3Denum type,</span>
719         ArrayBufferView* pixels,
720         NullDisposition);
721 
722     // Helper function to validate a given texture format is settable as in
723     // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
724     // copyTexSubImage2D.
725     // Generates GL error and returns false if the format is not settable.
<span class="line-modified">726     bool validateSettableTexInternalFormat(const char* functionName, GC3Denum format);</span>
727 
728     // Helper function to validate compressed texture data is correct size
729     // for the given format and dimensions.
<span class="line-modified">730     bool validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels);</span>
731 
732     // Helper function for validating compressed texture formats.
<span class="line-modified">733     bool validateCompressedTexFormat(GC3Denum format);</span>
734 
735     // Helper function to validate compressed texture dimensions are valid for
736     // the given format.
<span class="line-modified">737     bool validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format);</span>
738 
739     // Helper function to validate compressed texture dimensions are valid for
740     // the given format.
<span class="line-modified">741     bool validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,</span>
<span class="line-modified">742                                             GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture*);</span>
743 
744     // Helper function to validate mode for draw{Arrays/Elements}.
<span class="line-modified">745     bool validateDrawMode(const char* functionName, GC3Denum);</span>
746 
747     // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
748     bool validateStencilSettings(const char* functionName);
749 
750     // Helper function to validate stencil func.
<span class="line-modified">751     bool validateStencilFunc(const char* functionName, GC3Denum);</span>
752 
753     // Helper function for texParameterf and texParameteri.
<span class="line-modified">754     void texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat parami, GC3Dint paramf, bool isFloat);</span>
755 
756     // Helper function to print errors and warnings to console.
757     void printToConsole(MessageLevel, const String&amp;);
758 
759     // Helper function to validate input parameters for framebuffer functions.
760     // Generate GL error if parameters are illegal.
<span class="line-modified">761     virtual bool validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment) = 0;</span>
762 
763     // Helper function to validate blend equation mode.
<span class="line-modified">764     virtual bool validateBlendEquation(const char* functionName, GC3Denum) = 0;</span>
765 
766     // Helper function to validate blend func factors.
<span class="line-modified">767     bool validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst);</span>
768 
769     // Helper function to validate a GL capability.
<span class="line-modified">770     virtual bool validateCapability(const char* functionName, GC3Denum) = 0;</span>
771 
772     // Helper function to validate input parameters for uniform functions.
<span class="line-modified">773     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">774     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">775     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GC3Dsizei, GC3Dsizei mod);</span>
<span class="line-modified">776     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GC3Dboolean transpose, const Float32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">777     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GC3Dboolean transpose, const void*, GC3Dsizei, GC3Dsizei mod);</span>
778 
779     // Helper function to validate parameters for bufferData.
780     // Return the current bound buffer to target, or 0 if parameters are invalid.
<span class="line-modified">781     WebGLBuffer* validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage);</span>
782 
783     // Helper function for tex{Sub}Image2D to make sure image is ready.
784     ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
785     ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
786 #if ENABLE(VIDEO)
787     ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
788 #endif
789 
790     // Helper functions for vertexAttribNf{v}.
<span class="line-modified">791     void vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat, GC3Dfloat, GC3Dfloat, GC3Dfloat);</span>
<span class="line-modified">792     void vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp;, GC3Dsizei expectedSize);</span>
793 
794     // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
795     // Return false if caller should return without further processing.
796     bool deleteObject(WebGLObject*);
797 
798     // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
799     // If the object has already been deleted, set deleted to true upon return.
800     // Return false if caller should return without further processing.
801     bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
802 


803     // Helpers for simulating vertexAttrib0.
804     void initVertexAttrib0();
<span class="line-modified">805     Optional&lt;bool&gt; simulateVertexAttrib0(GC3Duint numVertex);</span>
<span class="line-modified">806     bool validateSimulatedVertexAttrib0(GC3Duint numVertex);</span>
807     void restoreStatesAfterVertexAttrib0Simulation();
808 
<span class="line-modified">809     void dispatchContextLostEvent();</span>
<span class="line-removed">810     // Helper for restoration after context lost.</span>
<span class="line-removed">811     void maybeRestoreContext();</span>
<span class="line-removed">812 </span>
<span class="line-removed">813     // Wrapper for GraphicsContext3D::synthesizeGLError that sends a message to the JavaScript console.</span>
814     enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
<span class="line-modified">815     void synthesizeGLError(GC3Denum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);</span>
816 
817     String ensureNotNull(const String&amp;) const;
818 
819     // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
820     void applyStencilTest();
821 
822     // Helper for enabling or disabling a capability.
<span class="line-modified">823     void enableOrDisable(GC3Denum capability, bool enable);</span>
824 
825     // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
826     IntSize clampedCanvasSize();
827 
<span class="line-modified">828     virtual GC3Dint getMaxDrawBuffers() = 0;</span>
<span class="line-modified">829     virtual GC3Dint getMaxColorAttachments() = 0;</span>
830 
<span class="line-modified">831     void setBackDrawBuffer(GC3Denum);</span>
832 
833     void restoreCurrentFramebuffer();
834     void restoreCurrentTexture2D();
835 
836     // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
837     bool supportsDrawBuffers();
838 

839     OffscreenCanvas* offscreenCanvas();

840 
841     template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
<span class="line-modified">842     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GC3Dintptr uoffset, GC3Dsizei n);</span>
843 
844 private:
<span class="line-modified">845     bool validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt;);</span>





846     void registerWithWebGLStateTracker();
847     void checkForContextLossHandling();
848 
849     void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
850 
851     WebGLStateTracker::Token m_trackerToken;
852     Timer m_checkForContextLossHandlingTimer;

853 };
854 
855 template &lt;typename T&gt;
856 inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
857 {
858     Checked&lt;T, RecordOverflow&gt; checkedResult = Checked&lt;T&gt;(value);
859     checkedResult += Checked&lt;T&gt;(add);
860     checkedResult *= Checked&lt;T&gt;(multiply);
861     if (checkedResult.hasOverflowed())
862         return WTF::nullopt;
863 
864     return checkedResult.unsafeGet();
865 }
866 
867 template&lt;typename T&gt;
<span class="line-modified">868 inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GC3Dintptr uoffset, GC3Dsizei n)</span>
869 {
870     unsigned maxIndex = 0;
871     T restartIndex = 0;
872 
873 #if ENABLE(WEBGL2)
874     // WebGL 2 spec enforces that GL_PRIMITIVE_RESTART_FIXED_INDEX is always enabled, so ignore the restart index.
875     if (isWebGL2())
876         restartIndex = std::numeric_limits&lt;T&gt;::max();
877 #endif
878 
879     // Make uoffset an element offset.
880     uoffset /= sizeof(T);
881     const T* p = static_cast&lt;const T*&gt;(elementArrayBuffer-&gt;data()) + uoffset;
882     while (n-- &gt; 0) {
883         if (*p != restartIndex &amp;&amp; *p &gt; maxIndex)
884             maxIndex = *p;
885         ++p;
886     }
887 
888     return maxIndex;
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;ActivityStateChangeObserver.h&quot;
 31 #include &quot;ExceptionOr.h&quot;
 32 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
<span class="line-modified"> 33 #include &quot;GraphicsContextGLOpenGL.h&quot;</span>
 34 #include &quot;ImageBuffer.h&quot;
<span class="line-added"> 35 #include &quot;SuspendableTimer.h&quot;</span>
 36 #include &quot;Timer.h&quot;
 37 #include &quot;WebGLAny.h&quot;
 38 #include &quot;WebGLBuffer.h&quot;
 39 #include &quot;WebGLContextAttributes.h&quot;
 40 #include &quot;WebGLFramebuffer.h&quot;
 41 #include &quot;WebGLProgram.h&quot;
 42 #include &quot;WebGLRenderbuffer.h&quot;
 43 #include &quot;WebGLStateTracker.h&quot;
 44 #include &quot;WebGLTexture.h&quot;
 45 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 46 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 47 #include &lt;limits&gt;
 48 #include &lt;memory&gt;
 49 
 50 #if ENABLE(WEBGL2)
 51 #include &quot;WebGLVertexArrayObject.h&quot;
 52 #endif
 53 
 54 namespace WebCore {
 55 
 56 class ANGLEInstancedArrays;
 57 class EXTBlendMinMax;
 58 class EXTTextureFilterAnisotropic;
 59 class EXTShaderTextureLOD;
 60 class EXTsRGB;
 61 class EXTFragDepth;
 62 class HTMLImageElement;
 63 class ImageData;
 64 class IntSize;
 65 class OESStandardDerivatives;
 66 class OESTextureFloat;
 67 class OESTextureFloatLinear;
 68 class OESTextureHalfFloat;
 69 class OESTextureHalfFloatLinear;
 70 class OESVertexArrayObject;
 71 class OESElementIndexUint;
<span class="line-added"> 72 #if ENABLE(OFFSCREEN_CANVAS)</span>
 73 class OffscreenCanvas;
<span class="line-added"> 74 #endif</span>
 75 class WebGLActiveInfo;
 76 class WebGLContextGroup;
 77 class WebGLContextObject;
 78 class WebGLCompressedTextureASTC;
 79 class WebGLCompressedTextureATC;
<span class="line-added"> 80 class WebGLCompressedTextureETC;</span>
<span class="line-added"> 81 class WebGLCompressedTextureETC1;</span>
 82 class WebGLCompressedTexturePVRTC;
 83 class WebGLCompressedTextureS3TC;
 84 class WebGLDebugRendererInfo;
 85 class WebGLDebugShaders;
 86 class WebGLDepthTexture;
 87 class WebGLDrawBuffers;
 88 class WebGLExtension;
 89 class WebGLLoseContext;
 90 class WebGLObject;
 91 class WebGLShader;
 92 class WebGLSharedObject;
 93 class WebGLShaderPrecisionFormat;
 94 class WebGLUniformLocation;
 95 
 96 #if ENABLE(VIDEO)
 97 class HTMLVideoElement;
 98 #endif
 99 
<span class="line-added">100 #if ENABLE(OFFSCREEN_CANVAS)</span>
101 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;
<span class="line-added">102 #else</span>
<span class="line-added">103 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;&gt;;</span>
<span class="line-added">104 #endif</span>
105 
<span class="line-modified">106 class WebGLRenderingContextBase : public GraphicsContextGLOpenGL::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {</span>
107     WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
108 public:
109     static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
110     virtual ~WebGLRenderingContextBase();
111 
112     WebGLCanvas canvas();
113 
114     int drawingBufferWidth() const;
115     int drawingBufferHeight() const;
116 
<span class="line-modified">117     void activeTexture(GCGLenum texture);</span>
118     void attachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">119     void bindAttribLocation(WebGLProgram*, GCGLuint index, const String&amp; name);</span>
<span class="line-modified">120     void bindBuffer(GCGLenum target, WebGLBuffer*);</span>
<span class="line-modified">121     void bindFramebuffer(GCGLenum target, WebGLFramebuffer*);</span>
<span class="line-modified">122     void bindRenderbuffer(GCGLenum target, WebGLRenderbuffer*);</span>
<span class="line-modified">123     void bindTexture(GCGLenum target, WebGLTexture*);</span>
<span class="line-modified">124     void blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);</span>
<span class="line-modified">125     void blendEquation(GCGLenum mode);</span>
<span class="line-modified">126     void blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha);</span>
<span class="line-modified">127     void blendFunc(GCGLenum sfactor, GCGLenum dfactor);</span>
<span class="line-modified">128     void blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha);</span>
129 
130     using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
<span class="line-modified">131     void bufferData(GCGLenum target, long long size, GCGLenum usage);</span>
<span class="line-modified">132     void bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GCGLenum usage);</span>
<span class="line-modified">133     void bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);</span>
<span class="line-modified">134 </span>
<span class="line-modified">135     GCGLenum checkFramebufferStatus(GCGLenum target);</span>
<span class="line-modified">136     virtual void clear(GCGLbitfield mask) = 0;</span>
<span class="line-modified">137     void clearColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha);</span>
<span class="line-modified">138     void clearDepth(GCGLfloat);</span>
<span class="line-modified">139     void clearStencil(GCGLint);</span>
<span class="line-modified">140     void colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha);</span>
141     void compileShader(WebGLShader*);
142 
<span class="line-modified">143     void compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data);</span>
<span class="line-modified">144     void compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data);</span>
145 
<span class="line-modified">146     void copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border);</span>
<span class="line-modified">147     void copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
148 
149     RefPtr&lt;WebGLBuffer&gt; createBuffer();
150     RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
151     RefPtr&lt;WebGLProgram&gt; createProgram();
152     RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
<span class="line-modified">153     RefPtr&lt;WebGLShader&gt; createShader(GCGLenum type);</span>
154     RefPtr&lt;WebGLTexture&gt; createTexture();
155 
<span class="line-modified">156     void cullFace(GCGLenum mode);</span>
157 
158     void deleteBuffer(WebGLBuffer*);
159     void deleteFramebuffer(WebGLFramebuffer*);
160     void deleteProgram(WebGLProgram*);
161     void deleteRenderbuffer(WebGLRenderbuffer*);
162     void deleteShader(WebGLShader*);
163     void deleteTexture(WebGLTexture*);
164 
<span class="line-modified">165     void depthFunc(GCGLenum);</span>
<span class="line-modified">166     void depthMask(GCGLboolean);</span>
<span class="line-modified">167     void depthRange(GCGLfloat zNear, GCGLfloat zFar);</span>
168     void detachShader(WebGLProgram*, WebGLShader*);
<span class="line-modified">169     void disable(GCGLenum cap);</span>
<span class="line-modified">170     void disableVertexAttribArray(GCGLuint index);</span>
<span class="line-modified">171     void drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count);</span>
<span class="line-modified">172     void drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset);</span>
173 
<span class="line-modified">174     void enable(GCGLenum cap);</span>
<span class="line-modified">175     void enableVertexAttribArray(GCGLuint index);</span>
176     void finish();
177     void flush();
<span class="line-modified">178     void framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer*);</span>
<span class="line-modified">179     void framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture*, GCGLint level);</span>
<span class="line-modified">180     void frontFace(GCGLenum mode);</span>
<span class="line-modified">181     void generateMipmap(GCGLenum target);</span>
182 
<span class="line-modified">183     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GCGLuint index);</span>
<span class="line-modified">184     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GCGLuint index);</span>
185     Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
<span class="line-modified">186     GCGLint getAttribLocation(WebGLProgram*, const String&amp; name);</span>
<span class="line-modified">187     WebGLAny getBufferParameter(GCGLenum target, GCGLenum pname);</span>
188     Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
<span class="line-modified">189     GCGLenum getError();</span>
190     virtual WebGLExtension* getExtension(const String&amp; name) = 0;
<span class="line-modified">191     virtual WebGLAny getFramebufferAttachmentParameter(GCGLenum target, GCGLenum attachment, GCGLenum pname) = 0;</span>
<span class="line-modified">192     virtual WebGLAny getParameter(GCGLenum pname) = 0;</span>
<span class="line-modified">193     WebGLAny getProgramParameter(WebGLProgram*, GCGLenum pname);</span>
194     String getProgramInfoLog(WebGLProgram*);
<span class="line-modified">195     WebGLAny getRenderbufferParameter(GCGLenum target, GCGLenum pname);</span>
<span class="line-modified">196     WebGLAny getShaderParameter(WebGLShader*, GCGLenum pname);</span>
197     String getShaderInfoLog(WebGLShader*);
<span class="line-modified">198     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType);</span>
199     String getShaderSource(WebGLShader*);
200     virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
<span class="line-modified">201     WebGLAny getTexParameter(GCGLenum target, GCGLenum pname);</span>
202     WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
203     RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
<span class="line-modified">204     WebGLAny getVertexAttrib(GCGLuint index, GCGLenum pname);</span>
<span class="line-modified">205     long long getVertexAttribOffset(GCGLuint index, GCGLenum pname);</span>
206 
207     bool extensionIsEnabled(const String&amp;);
208 
209     bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
210     void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
211 
212     bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
213     void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
214 
<span class="line-modified">215     virtual void hint(GCGLenum target, GCGLenum mode) = 0;</span>
<span class="line-modified">216     GCGLboolean isBuffer(WebGLBuffer*);</span>
217     bool isContextLost() const;
<span class="line-modified">218     GCGLboolean isEnabled(GCGLenum cap);</span>
<span class="line-modified">219     GCGLboolean isFramebuffer(WebGLFramebuffer*);</span>
<span class="line-modified">220     GCGLboolean isProgram(WebGLProgram*);</span>
<span class="line-modified">221     GCGLboolean isRenderbuffer(WebGLRenderbuffer*);</span>
<span class="line-modified">222     GCGLboolean isShader(WebGLShader*);</span>
<span class="line-modified">223     GCGLboolean isTexture(WebGLTexture*);</span>
<span class="line-modified">224 </span>
<span class="line-modified">225     void lineWidth(GCGLfloat);</span>
226     void linkProgram(WebGLProgram*);
227     bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
<span class="line-modified">228     void pixelStorei(GCGLenum pname, GCGLint param);</span>
<span class="line-modified">229     void polygonOffset(GCGLfloat factor, GCGLfloat units);</span>
<span class="line-modified">230     void readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels);</span>
231     void releaseShaderCompiler();
<span class="line-modified">232     virtual void renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height) = 0;</span>
<span class="line-modified">233     void sampleCoverage(GCGLfloat value, GCGLboolean invert);</span>
<span class="line-modified">234     void scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
235     void shaderSource(WebGLShader*, const String&amp;);
<span class="line-modified">236     void stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask);</span>
<span class="line-modified">237     void stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask);</span>
<span class="line-modified">238     void stencilMask(GCGLuint);</span>
<span class="line-modified">239     void stencilMaskSeparate(GCGLenum face, GCGLuint mask);</span>
<span class="line-modified">240     void stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass);</span>
<span class="line-modified">241     void stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass);</span>
242 
<span class="line-modified">243     void texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
244 
245 #if ENABLE(VIDEO)
246     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
247 #else
248     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
249 #endif
250 
<span class="line-modified">251     ExceptionOr&lt;void&gt; texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;);</span>
252 
<span class="line-modified">253     void texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param);</span>
<span class="line-modified">254     void texParameteri(GCGLenum target, GCGLenum pname, GCGLint param);</span>
255 
<span class="line-modified">256     void texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
<span class="line-modified">257     ExceptionOr&lt;void&gt; texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp;);</span>
258 
259     template &lt;class TypedArray, class DataType&gt;
260     class TypedList {
261     public:
262         using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
263 
264         TypedList(VariantType&amp;&amp; variant)
265             : m_variant(WTFMove(variant))
266         {
267         }
268 
269         const DataType* data() const
270         {
271             return WTF::switchOn(m_variant,
272                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
273                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
274             );
275         }
276 
<span class="line-modified">277         GCGLsizei length() const</span>
278         {
279             return WTF::switchOn(m_variant,
<span class="line-modified">280                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GCGLsizei { return typedArray-&gt;length(); },</span>
<span class="line-modified">281                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GCGLsizei { return vector.size(); }</span>
282             );
283         }
284 
285     private:
286         VariantType m_variant;
287     };
288 
289     using Float32List = TypedList&lt;Float32Array, float&gt;;
290     using Int32List = TypedList&lt;Int32Array, int&gt;;
291 
<span class="line-modified">292     void uniform1f(const WebGLUniformLocation*, GCGLfloat x);</span>
<span class="line-modified">293     void uniform2f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y);</span>
<span class="line-modified">294     void uniform3f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z);</span>
<span class="line-modified">295     void uniform4f(const WebGLUniformLocation*, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);</span>
296 
<span class="line-modified">297     void uniform1i(const WebGLUniformLocation*, GCGLint x);</span>
<span class="line-modified">298     void uniform2i(const WebGLUniformLocation*, GCGLint x, GCGLint y);</span>
<span class="line-modified">299     void uniform3i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z);</span>
<span class="line-modified">300     void uniform4i(const WebGLUniformLocation*, GCGLint x, GCGLint y, GCGLint z, GCGLint w);</span>
301 
302     void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
303     void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
304     void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
305     void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
306 
307     void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
308     void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
309     void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
310     void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
311 
<span class="line-modified">312     void uniformMatrix2fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">313     void uniformMatrix3fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">314     void uniformMatrix4fv(const WebGLUniformLocation*, GCGLboolean transpose, Float32List&amp;&amp;);</span>
315 
316     void useProgram(WebGLProgram*);
317     void validateProgram(WebGLProgram*);
318 
<span class="line-modified">319     void vertexAttrib1f(GCGLuint index, GCGLfloat x);</span>
<span class="line-modified">320     void vertexAttrib2f(GCGLuint index, GCGLfloat x, GCGLfloat y);</span>
<span class="line-modified">321     void vertexAttrib3f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z);</span>
<span class="line-modified">322     void vertexAttrib4f(GCGLuint index, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w);</span>
323 
<span class="line-modified">324     void vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">325     void vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">326     void vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp;);</span>
<span class="line-modified">327     void vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp;);</span>
328 
<span class="line-modified">329     void vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized,</span>
<span class="line-modified">330         GCGLsizei stride, long long offset);</span>
331 
<span class="line-modified">332     void viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height);</span>
333 
334     // WEBKIT_lose_context support
335     enum LostContextMode {
336         // Lost context occurred at the graphics system level.
337         RealLostContext,
338 
339         // Lost context provoked by WEBKIT_lose_context.
340         SyntheticLostContext
341     };
342     void forceLostContext(LostContextMode);
343     void forceRestoreContext();
344     void loseContextImpl(LostContextMode);
345     WEBCORE_EXPORT void simulateContextChanged();
346 
<span class="line-modified">347     GraphicsContextGLOpenGL* graphicsContextGL() const { return m_context.get(); }</span>
348     WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
349     PlatformLayer* platformLayer() const override;
350 
351     void reshape(int width, int height) override;
352 
353     void markLayerComposited() final;
354     void paintRenderingResultsToCanvas() override;
355     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
356 
357     void removeSharedObject(WebGLSharedObject&amp;);
358     void removeContextObject(WebGLContextObject&amp;);
359 
360     unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
361 
362     // Instanced Array helper functions.
<span class="line-modified">363     void drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);</span>
<span class="line-modified">364     void drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount);</span>
<span class="line-modified">365     void vertexAttribDivisor(GCGLuint index, GCGLuint divisor);</span>
366 
367     // Used for testing only, from Internals.
368     WEBCORE_EXPORT void setFailNextGPUStatusCheck();
369 
<span class="line-modified">370     // GraphicsContextGL::Client</span>
371     void didComposite() override;
372     void forceContextLost() override;
373     void recycleContext() override;
374     void dispatchContextChangedNotification() override;
375 
<span class="line-added">376     // ActiveDOMObject</span>
<span class="line-added">377     bool hasPendingActivity() const final;</span>
<span class="line-added">378 </span>
379 protected:
380     WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
<span class="line-modified">381     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp;, WebGLContextAttributes);</span>
382 
383     friend class WebGLDrawBuffers;
384     friend class WebGLFramebuffer;
385     friend class WebGLObject;
386     friend class OESVertexArrayObject;
387     friend class WebGLDebugShaders;
388     friend class WebGLCompressedTextureASTC;
389     friend class WebGLCompressedTextureATC;
<span class="line-added">390     friend class WebGLCompressedTextureETC;</span>
<span class="line-added">391     friend class WebGLCompressedTextureETC1;</span>
392     friend class WebGLCompressedTexturePVRTC;
393     friend class WebGLCompressedTextureS3TC;
394     friend class WebGLRenderingContextErrorMessageCallback;
395     friend class WebGLVertexArrayObjectOES;
396     friend class WebGLVertexArrayObject;
397     friend class WebGLVertexArrayObjectBase;
398 
399     virtual void initializeNewContext();
400     virtual void initializeVertexArrayObjects() = 0;
401     void setupFlags();
402 
403     // ActiveDOMObject

404     void stop() override;
405     const char* activeDOMObjectName() const override;
<span class="line-modified">406     void suspend(ReasonForSuspension) override;</span>
<span class="line-added">407     void resume() override;</span>
408 
409     void addSharedObject(WebGLSharedObject&amp;);
410     void addContextObject(WebGLContextObject&amp;);
411     void detachAndRemoveAllObjects();
412 
<span class="line-modified">413     void destroyGraphicsContextGL();</span>
414     void markContextChanged();
415     void markContextChangedAndNotifyCanvasObserver();
416 
417     void addActivityStateChangeObserverIfNecessary();
418     void removeActivityStateChangeObserver();
419 
420     // Query whether it is built on top of compliant GLES2 implementation.
421     bool isGLES2Compliant() { return m_isGLES2Compliant; }
422     // Query if the GL implementation is NPOT strict.
423     bool isGLES2NPOTStrict() { return m_isGLES2NPOTStrict; }
424     // Query if depth_stencil buffer is supported.
425     bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
426 
427     // Helper to return the size in bytes of OpenGL data types
428     // like GL_FLOAT, GL_INT, etc.
<span class="line-modified">429     unsigned sizeInBytes(GCGLenum type);</span>
430 
431     // Basic validation of count and offset against number of elements in element array buffer
<span class="line-modified">432     bool validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset);</span>
433 
434     // Conservative but quick index validation
<span class="line-modified">435     virtual bool validateIndexArrayConservative(GCGLenum type, unsigned&amp; numElementsRequired) = 0;</span>
436 
437     // Precise but slow index validation -- only done if conservative checks fail
<span class="line-modified">438     bool validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired);</span>
439     bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
440 
441     bool validateWebGLObject(const char*, WebGLObject*);
442 
<span class="line-modified">443     bool validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount);</span>
<span class="line-modified">444     bool validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primcount);</span>
<span class="line-modified">445     bool validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName);</span>
446 
447     // Adds a compressed texture format.
<span class="line-modified">448     void addCompressedTextureFormat(GCGLenum);</span>
449 
450     RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
451 
452 #if ENABLE(VIDEO)
453     RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
454 #endif
455 
456     WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
457 
458     bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
459 
<span class="line-modified">460     virtual void uncacheDeletedBuffer(WebGLBuffer*);</span>
<span class="line-added">461 </span>
<span class="line-added">462     RefPtr&lt;GraphicsContextGLOpenGL&gt; m_context;</span>
463     RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
464 
465     // Dispatches a context lost event once it is determined that one is needed.
466     // This is used both for synthetic and real context losses. For real ones, it&#39;s
467     // likely that there&#39;s no JavaScript on the stack, but that might be dependent
468     // on how exactly the platform discovers that the context was lost. For better
469     // portability we always defer the dispatch of the event.
<span class="line-modified">470     SuspendableTimer m_dispatchContextLostEventTimer;</span>
<span class="line-added">471     SuspendableTimer m_dispatchContextChangedEventTimer;</span>
472     bool m_restoreAllowed { false };
<span class="line-modified">473     SuspendableTimer m_restoreTimer;</span>
474 
475     bool m_needsUpdate;
476     bool m_markedCanvasDirty;
477     HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
478 
479     // List of bound VBO&#39;s. Used to maintain info about sizes for ARRAY_BUFFER and stored values for ELEMENT_ARRAY_BUFFER
480     RefPtr&lt;WebGLBuffer&gt; m_boundArrayBuffer;
481     RefPtr&lt;WebGLBuffer&gt; m_boundCopyReadBuffer;
482     RefPtr&lt;WebGLBuffer&gt; m_boundCopyWriteBuffer;
483     RefPtr&lt;WebGLBuffer&gt; m_boundPixelPackBuffer;
484     RefPtr&lt;WebGLBuffer&gt; m_boundPixelUnpackBuffer;
485     RefPtr&lt;WebGLBuffer&gt; m_boundTransformFeedbackBuffer;
486     RefPtr&lt;WebGLBuffer&gt; m_boundUniformBuffer;
487 
488     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_defaultVertexArrayObject;
489     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_boundVertexArrayObject;
490 
491     void setBoundVertexArrayObject(WebGLVertexArrayObjectBase* arrayObject)
492     {
493         m_boundVertexArrayObject = arrayObject ? arrayObject : m_defaultVertexArrayObject;
494     }
495 
496     class VertexAttribValue {
497     public:
498         VertexAttribValue()
499         {
500             initValue();
501         }
502 
503         void initValue()
504         {
505             value[0] = 0.0f;
506             value[1] = 0.0f;
507             value[2] = 0.0f;
508             value[3] = 1.0f;
509         }
510 
<span class="line-modified">511         GCGLfloat value[4];</span>
512     };
513     Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
514     unsigned m_maxVertexAttribs;
515     RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
516     long m_vertexAttrib0BufferSize { 0 };
<span class="line-modified">517     GCGLfloat m_vertexAttrib0BufferValue[4];</span>
518     bool m_forceAttrib0BufferRefill { true };
519     bool m_vertexAttrib0UsedBefore { false };
520 
521     RefPtr&lt;WebGLProgram&gt; m_currentProgram;
522     RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
523     RefPtr&lt;WebGLFramebuffer&gt; m_readFramebufferBinding;
524     RefPtr&lt;WebGLRenderbuffer&gt; m_renderbufferBinding;
525     struct TextureUnitState {
526         RefPtr&lt;WebGLTexture&gt; texture2DBinding;
527         RefPtr&lt;WebGLTexture&gt; textureCubeMapBinding;
528     };
529     Vector&lt;TextureUnitState&gt; m_textureUnits;
530     HashSet&lt;unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; m_unrenderableTextureUnits;
531 
532     unsigned long m_activeTextureUnit;
533 
534     RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
535     RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
536 
<span class="line-modified">537     Vector&lt;GCGLenum&gt; m_compressedTextureFormats;</span>
538 
539     // Fixed-size cache of reusable image buffers for video texImage2D calls.
540     class LRUImageBufferCache {
541     public:
542         LRUImageBufferCache(int capacity);
543         // The pointer returned is owned by the image buffer map.
544         ImageBuffer* imageBuffer(const IntSize&amp; size);
545     private:
546         void bubbleToFront(size_t idx);
547         Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
548     };
549     LRUImageBufferCache m_generatedImageCache { 0 };
550 
<span class="line-modified">551     GCGLint m_maxTextureSize;</span>
<span class="line-modified">552     GCGLint m_maxCubeMapTextureSize;</span>
<span class="line-modified">553     GCGLint m_maxRenderbufferSize;</span>
<span class="line-modified">554     GCGLint m_maxViewportDims[2] { 0, 0 };</span>
<span class="line-modified">555     GCGLint m_maxTextureLevel;</span>
<span class="line-modified">556     GCGLint m_maxCubeMapTextureLevel;</span>
557 
<span class="line-modified">558     GCGLint m_maxDrawBuffers;</span>
<span class="line-modified">559     GCGLint m_maxColorAttachments;</span>
<span class="line-modified">560     GCGLenum m_backDrawBuffer;</span>
561     bool m_drawBuffersWebGLRequirementsChecked;
562     bool m_drawBuffersSupported;
563 
<span class="line-modified">564     GCGLint m_packAlignment;</span>
<span class="line-modified">565     GCGLint m_unpackAlignment;</span>
566     bool m_unpackFlipY;
567     bool m_unpackPremultiplyAlpha;
<span class="line-modified">568     GCGLenum m_unpackColorspaceConversion;</span>
569     bool m_contextLost { false };
570     LostContextMode m_contextLostMode { SyntheticLostContext };
571     WebGLContextAttributes m_attributes;
572 
573     bool m_layerCleared;
<span class="line-modified">574     GCGLfloat m_clearColor[4];</span>
575     bool m_scissorEnabled;
<span class="line-modified">576     GCGLfloat m_clearDepth;</span>
<span class="line-modified">577     GCGLint m_clearStencil;</span>
<span class="line-modified">578     GCGLboolean m_colorMask[4];</span>
<span class="line-modified">579     GCGLboolean m_depthMask;</span>
580 
581     bool m_stencilEnabled;
<span class="line-modified">582     GCGLuint m_stencilMask, m_stencilMaskBack;</span>
<span class="line-modified">583     GCGLint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.</span>
<span class="line-modified">584     GCGLuint m_stencilFuncMask, m_stencilFuncMaskBack;</span>
585 
586     bool m_isGLES2Compliant;
587     bool m_isGLES2NPOTStrict;
588     bool m_isDepthStencilSupported;
589     bool m_isRobustnessEXTSupported;
590 
591     bool m_synthesizedErrorsToConsole { true };
592     int m_numGLErrorsToConsoleAllowed;
593 
594     bool m_preventBufferClearForInspector { false };
595 
596     // A WebGLRenderingContext can be created in a state where it appears as
597     // a valid and active context, but will not execute any important operations
598     // until its load policy is completely resolved.
599     bool m_isPendingPolicyResolution { false };
600     bool m_hasRequestedPolicyResolution { false };
601     bool isContextLostOrPending();
602 
603     // Enabled extension objects.
604     // FIXME: Move some of these to WebGLRenderingContext, the ones not needed for WebGL2
605     std::unique_ptr&lt;EXTFragDepth&gt; m_extFragDepth;
606     std::unique_ptr&lt;EXTBlendMinMax&gt; m_extBlendMinMax;
607     std::unique_ptr&lt;EXTsRGB&gt; m_extsRGB;
608     std::unique_ptr&lt;EXTTextureFilterAnisotropic&gt; m_extTextureFilterAnisotropic;
609     std::unique_ptr&lt;EXTShaderTextureLOD&gt; m_extShaderTextureLOD;
610     std::unique_ptr&lt;OESTextureFloat&gt; m_oesTextureFloat;
611     std::unique_ptr&lt;OESTextureFloatLinear&gt; m_oesTextureFloatLinear;
612     std::unique_ptr&lt;OESTextureHalfFloat&gt; m_oesTextureHalfFloat;
613     std::unique_ptr&lt;OESTextureHalfFloatLinear&gt; m_oesTextureHalfFloatLinear;
614     std::unique_ptr&lt;OESStandardDerivatives&gt; m_oesStandardDerivatives;
615     std::unique_ptr&lt;OESVertexArrayObject&gt; m_oesVertexArrayObject;
616     std::unique_ptr&lt;OESElementIndexUint&gt; m_oesElementIndexUint;
617     std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
618     std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
619     std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
620     std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
621     std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;
<span class="line-added">622     std::unique_ptr&lt;WebGLCompressedTextureETC&gt; m_webglCompressedTextureETC;</span>
<span class="line-added">623     std::unique_ptr&lt;WebGLCompressedTextureETC1&gt; m_webglCompressedTextureETC1;</span>
624     std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
625     std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
626     std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
627     std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
628     std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
629 
630     // Helpers for getParameter and other similar functions.
<span class="line-modified">631     bool getBooleanParameter(GCGLenum);</span>
<span class="line-modified">632     Vector&lt;bool&gt; getBooleanArrayParameter(GCGLenum);</span>
<span class="line-modified">633     float getFloatParameter(GCGLenum);</span>
<span class="line-modified">634     int getIntParameter(GCGLenum);</span>
<span class="line-modified">635     unsigned getUnsignedIntParameter(GCGLenum);</span>
<span class="line-modified">636     long long getInt64Parameter(GCGLenum);</span>
<span class="line-modified">637     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GCGLenum);</span>
<span class="line-modified">638     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GCGLenum);</span>
639 
640     // Clear the backbuffer if it was composited since the last operation.
641     // clearMask is set to the bitfield of any clear that would happen anyway at this time
642     // and the function returns true if that clear is now unnecessary.
<span class="line-modified">643     bool clearIfComposited(GCGLbitfield clearMask = 0);</span>
644 
645     // Helper to restore state that clearing the framebuffer may destroy.
646     void restoreStateAfterClear();
647 
<span class="line-modified">648     void texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels);</span>
<span class="line-modified">649     void texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);</span>
<span class="line-modified">650     void texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalformat, GCGLenum format, GCGLenum type, const void* pixels);</span>
<span class="line-modified">651     void texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image*, GraphicsContextGL::DOMSource, bool flipY, bool premultiplyAlpha);</span>
652 
653     bool checkTextureCompleteness(const char*, bool);
654 
655     void createFallbackBlackTextures1x1();
656 
657     // Helper function for copyTex{Sub}Image, check whether the internalformat
658     // and the color buffer format of the current bound framebuffer combination
659     // is valid.
<span class="line-modified">660     bool isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat);</span>

661 
662     // Helper function to get the bound framebuffer&#39;s color buffer format.
<span class="line-modified">663     GCGLenum getBoundFramebufferColorFormat();</span>
664 
665     // Helper function to get the bound framebuffer&#39;s width.
666     int getBoundFramebufferWidth();
667 
668     // Helper function to get the bound framebuffer&#39;s height.
669     int getBoundFramebufferHeight();
670 
671     // Helper function to verify limits on the length of uniform and attribute locations.
672     bool validateLocationLength(const char* functionName, const String&amp;);
673 
674     // Helper function to check if size is non-negative.
675     // Generate GL error and return false for negative inputs; otherwise, return true.
<span class="line-modified">676     bool validateSize(const char* functionName, GCGLint x, GCGLint y);</span>
677 
678     // Helper function to check if all characters in the string belong to the
679     // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
680     bool validateString(const char* functionName, const String&amp;);
681 
682     // Helper function to check target and texture bound to the target.
683     // Generate GL errors and return 0 if target is invalid or texture bound is
684     // null.  Otherwise, return the texture bound to the target.
<span class="line-modified">685     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap);</span>
686 
687     // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
688     // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">689     bool validateTexFuncFormatAndType(const char* functionName, GCGLenum internalformat, GCGLenum format, GCGLenum type, GCGLint level);</span>
690 
691     // Helper function to check input level for functions {copy}Tex{Sub}Image.
692     // Generates GL error and returns false if level is invalid.
<span class="line-modified">693     bool validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level);</span>
694 
695     enum TexFuncValidationFunctionType {
696         TexImage,
697         TexSubImage,
698         CopyTexImage
699     };
700 
701     enum TexFuncValidationSourceType {
702         SourceArrayBufferView,
703         SourceImageBitmap,
704         SourceImageData,
705         SourceHTMLImageElement,
706         SourceHTMLCanvasElement,
707 #if ENABLE(VIDEO)
708         SourceHTMLVideoElement,
709 #endif
710     };
711 
712     // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
713     // Otherwise, it would return quickly without doing other work.
<span class="line-modified">714     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width,</span>
<span class="line-modified">715         GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset);</span>
716 
717     // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
718     // Generates GL error and returns false if parameters are invalid.
719     bool validateTexFuncParameters(const char* functionName,
720         TexFuncValidationFunctionType,
<span class="line-modified">721         GCGLenum target, GCGLint level,</span>
<span class="line-modified">722         GCGLenum internalformat,</span>
<span class="line-modified">723         GCGLsizei width, GCGLsizei height, GCGLint border,</span>
<span class="line-modified">724         GCGLenum format, GCGLenum type);</span>
725 
726     enum NullDisposition {
727         NullAllowed,
728         NullNotAllowed
729     };
730 
731     // Helper function to validate that the given ArrayBufferView
732     // is of the correct type and contains enough data for the texImage call.
733     // Generates GL error and returns false if parameters are invalid.
<span class="line-modified">734     bool validateTexFuncData(const char* functionName, GCGLint level,</span>
<span class="line-modified">735         GCGLsizei width, GCGLsizei height,</span>
<span class="line-modified">736         GCGLenum internalformat, GCGLenum format, GCGLenum type,</span>
737         ArrayBufferView* pixels,
738         NullDisposition);
739 
740     // Helper function to validate a given texture format is settable as in
741     // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
742     // copyTexSubImage2D.
743     // Generates GL error and returns false if the format is not settable.
<span class="line-modified">744     bool validateSettableTexInternalFormat(const char* functionName, GCGLenum format);</span>
745 
746     // Helper function to validate compressed texture data is correct size
747     // for the given format and dimensions.
<span class="line-modified">748     bool validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels);</span>
749 
750     // Helper function for validating compressed texture formats.
<span class="line-modified">751     bool validateCompressedTexFormat(GCGLenum format);</span>
752 
753     // Helper function to validate compressed texture dimensions are valid for
754     // the given format.
<span class="line-modified">755     bool validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format);</span>
756 
757     // Helper function to validate compressed texture dimensions are valid for
758     // the given format.
<span class="line-modified">759     bool validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset,</span>
<span class="line-modified">760         GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture*);</span>
761 
762     // Helper function to validate mode for draw{Arrays/Elements}.
<span class="line-modified">763     bool validateDrawMode(const char* functionName, GCGLenum);</span>
764 
765     // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
766     bool validateStencilSettings(const char* functionName);
767 
768     // Helper function to validate stencil func.
<span class="line-modified">769     bool validateStencilFunc(const char* functionName, GCGLenum);</span>
770 
771     // Helper function for texParameterf and texParameteri.
<span class="line-modified">772     void texParameter(GCGLenum target, GCGLenum pname, GCGLfloat parami, GCGLint paramf, bool isFloat);</span>
773 
774     // Helper function to print errors and warnings to console.
775     void printToConsole(MessageLevel, const String&amp;);
776 
777     // Helper function to validate input parameters for framebuffer functions.
778     // Generate GL error if parameters are illegal.
<span class="line-modified">779     virtual bool validateFramebufferFuncParameters(const char* functionName, GCGLenum target, GCGLenum attachment) = 0;</span>
780 
781     // Helper function to validate blend equation mode.
<span class="line-modified">782     virtual bool validateBlendEquation(const char* functionName, GCGLenum) = 0;</span>
783 
784     // Helper function to validate blend func factors.
<span class="line-modified">785     bool validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst);</span>
786 
787     // Helper function to validate a GL capability.
<span class="line-modified">788     virtual bool validateCapability(const char* functionName, GCGLenum) = 0;</span>
789 
790     // Helper function to validate input parameters for uniform functions.
<span class="line-modified">791     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">792     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">793     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GCGLsizei, GCGLsizei mod);</span>
<span class="line-modified">794     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const Float32List&amp;, GCGLsizei mod);</span>
<span class="line-modified">795     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GCGLboolean transpose, const void*, GCGLsizei, GCGLsizei mod);</span>
796 
797     // Helper function to validate parameters for bufferData.
798     // Return the current bound buffer to target, or 0 if parameters are invalid.
<span class="line-modified">799     WebGLBuffer* validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage);</span>
800 
801     // Helper function for tex{Sub}Image2D to make sure image is ready.
802     ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
803     ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
804 #if ENABLE(VIDEO)
805     ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
806 #endif
807 
808     // Helper functions for vertexAttribNf{v}.
<span class="line-modified">809     void vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat, GCGLfloat, GCGLfloat, GCGLfloat);</span>
<span class="line-modified">810     void vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp;, GCGLsizei expectedSize);</span>
811 
812     // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
813     // Return false if caller should return without further processing.
814     bool deleteObject(WebGLObject*);
815 
816     // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
817     // If the object has already been deleted, set deleted to true upon return.
818     // Return false if caller should return without further processing.
819     bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
820 
<span class="line-added">821     bool validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer*);</span>
<span class="line-added">822 </span>
823     // Helpers for simulating vertexAttrib0.
824     void initVertexAttrib0();
<span class="line-modified">825     Optional&lt;bool&gt; simulateVertexAttrib0(GCGLuint numVertex);</span>
<span class="line-modified">826     bool validateSimulatedVertexAttrib0(GCGLuint numVertex);</span>
827     void restoreStatesAfterVertexAttrib0Simulation();
828 
<span class="line-modified">829     // Wrapper for GraphicsContextGLOpenGL::synthesizeGLError that sends a message to the JavaScript console.</span>




830     enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
<span class="line-modified">831     void synthesizeGLError(GCGLenum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);</span>
832 
833     String ensureNotNull(const String&amp;) const;
834 
835     // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
836     void applyStencilTest();
837 
838     // Helper for enabling or disabling a capability.
<span class="line-modified">839     void enableOrDisable(GCGLenum capability, bool enable);</span>
840 
841     // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
842     IntSize clampedCanvasSize();
843 
<span class="line-modified">844     virtual GCGLint getMaxDrawBuffers() = 0;</span>
<span class="line-modified">845     virtual GCGLint getMaxColorAttachments() = 0;</span>
846 
<span class="line-modified">847     void setBackDrawBuffer(GCGLenum);</span>
848 
849     void restoreCurrentFramebuffer();
850     void restoreCurrentTexture2D();
851 
852     // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
853     bool supportsDrawBuffers();
854 
<span class="line-added">855 #if ENABLE(OFFSCREEN_CANVAS)</span>
856     OffscreenCanvas* offscreenCanvas();
<span class="line-added">857 #endif</span>
858 
859     template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
<span class="line-modified">860     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n);</span>
861 
862 private:
<span class="line-modified">863     void dispatchContextLostEvent();</span>
<span class="line-added">864     void dispatchContextChangedEvent();</span>
<span class="line-added">865     // Helper for restoration after context lost.</span>
<span class="line-added">866     void maybeRestoreContext();</span>
<span class="line-added">867 </span>
<span class="line-added">868     bool validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt;);</span>
869     void registerWithWebGLStateTracker();
870     void checkForContextLossHandling();
871 
872     void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
873 
874     WebGLStateTracker::Token m_trackerToken;
875     Timer m_checkForContextLossHandlingTimer;
<span class="line-added">876     bool m_isSuspended { false };</span>
877 };
878 
879 template &lt;typename T&gt;
880 inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
881 {
882     Checked&lt;T, RecordOverflow&gt; checkedResult = Checked&lt;T&gt;(value);
883     checkedResult += Checked&lt;T&gt;(add);
884     checkedResult *= Checked&lt;T&gt;(multiply);
885     if (checkedResult.hasOverflowed())
886         return WTF::nullopt;
887 
888     return checkedResult.unsafeGet();
889 }
890 
891 template&lt;typename T&gt;
<span class="line-modified">892 inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GCGLintptr uoffset, GCGLsizei n)</span>
893 {
894     unsigned maxIndex = 0;
895     T restartIndex = 0;
896 
897 #if ENABLE(WEBGL2)
898     // WebGL 2 spec enforces that GL_PRIMITIVE_RESTART_FIXED_INDEX is always enabled, so ignore the restart index.
899     if (isWebGL2())
900         restartIndex = std::numeric_limits&lt;T&gt;::max();
901 #endif
902 
903     // Make uoffset an element offset.
904     uoffset /= sizeof(T);
905     const T* p = static_cast&lt;const T*&gt;(elementArrayBuffer-&gt;data()) + uoffset;
906     while (n-- &gt; 0) {
907         if (*p != restartIndex &amp;&amp; *p &gt; maxIndex)
908             maxIndex = *p;
909         ++p;
910     }
911 
912     return maxIndex;
</pre>
</td>
</tr>
</table>
<center><a href="WebGLRenderingContextBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
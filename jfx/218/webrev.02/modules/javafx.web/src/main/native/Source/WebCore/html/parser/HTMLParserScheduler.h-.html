<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLParserScheduler.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google, Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;NestingLevelIncrementer.h&quot;
 29 #include &quot;Timer.h&quot;
 30 #include &lt;wtf/RefPtr.h&gt;
 31 
 32 #if PLATFORM(IOS_FAMILY)
 33 #include &quot;WebCoreThread.h&quot;
 34 #endif
 35 
 36 namespace WebCore {
 37 
 38 class Document;
 39 class HTMLDocumentParser;
 40 
 41 class ActiveParserSession {
 42 public:
 43     explicit ActiveParserSession(Document*);
 44     ~ActiveParserSession();
 45 
 46 private:
 47     RefPtr&lt;Document&gt; m_document;
 48 };
 49 
 50 class PumpSession : public NestingLevelIncrementer, public ActiveParserSession {
 51 public:
 52     PumpSession(unsigned&amp; nestingLevel, Document*);
 53     ~PumpSession();
 54 
 55     unsigned processedTokens;
 56     MonotonicTime startTime;
 57     bool didSeeScript;
 58 };
 59 
 60 class HTMLParserScheduler {
 61     WTF_MAKE_NONCOPYABLE(HTMLParserScheduler); WTF_MAKE_FAST_ALLOCATED;
 62 public:
 63     explicit HTMLParserScheduler(HTMLDocumentParser&amp;);
 64     ~HTMLParserScheduler();
 65 
 66     bool shouldYieldBeforeToken(PumpSession&amp; session)
 67     {
 68 #if PLATFORM(IOS_FAMILY)
 69         if (WebThreadShouldYield())
 70             return true;
 71 #endif
 72         if (UNLIKELY(m_documentHasActiveParserYieldTokens))
 73             return true;
 74 
 75         if (UNLIKELY(session.processedTokens &gt; numberOfTokensBeforeCheckingForYield || session.didSeeScript))
 76             return checkForYield(session);
 77 
 78         ++session.processedTokens;
 79         return false;
 80     }
 81     bool shouldYieldBeforeExecutingScript(PumpSession&amp;);
 82 
 83     void scheduleForResume();
 84     bool isScheduledForResume() const { return m_isSuspendedWithActiveTimer || m_continueNextChunkTimer.isActive() || m_documentHasActiveParserYieldTokens; }
 85 
 86     void suspend();
 87     void resume();
 88 
 89     void didBeginYieldingParser()
 90     {
 91         ASSERT(!m_documentHasActiveParserYieldTokens);
 92         m_documentHasActiveParserYieldTokens = true;
 93     }
 94 
 95     void didEndYieldingParser()
 96     {
 97         ASSERT(m_documentHasActiveParserYieldTokens);
 98         m_documentHasActiveParserYieldTokens = false;
 99 
100         if (!isScheduledForResume())
101             scheduleForResume();
102     }
103 
104 private:
105     static const unsigned numberOfTokensBeforeCheckingForYield = 4096; // Performance optimization
106 
107     void continueNextChunkTimerFired();
108 
109     bool checkForYield(PumpSession&amp; session)
110     {
111         session.processedTokens = 1;
112         session.didSeeScript = false;
113 
114         // MonotonicTime::now() can be expensive. By delaying, we avoided calling
115         // MonotonicTime::now() when constructing non-yielding PumpSessions.
116         if (!session.startTime) {
117             session.startTime = MonotonicTime::now();
118             return false;
119         }
120 
121         Seconds elapsedTime = MonotonicTime::now() - session.startTime;
122         return elapsedTime &gt; m_parserTimeLimit;
123     }
124 
125     HTMLDocumentParser&amp; m_parser;
126 
127     Seconds m_parserTimeLimit;
128     Timer m_continueNextChunkTimer;
129     bool m_isSuspendedWithActiveTimer;
130 #if !ASSERT_DISABLED
131     bool m_suspended;
132 #endif
133     bool m_documentHasActiveParserYieldTokens { false };
134 };
135 
136 } // namespace WebCore
    </pre>
  </body>
</html>
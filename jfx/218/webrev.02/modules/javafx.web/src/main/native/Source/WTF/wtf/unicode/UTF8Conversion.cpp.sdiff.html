<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/unicode/UTF8Conversion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../text/icu/UTextProviderLatin1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../win/MainThreadWin.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/unicode/UTF8Conversion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 75             }
 76             ch = replacementCharacter;
 77         }
 78         U8_APPEND(reinterpret_cast&lt;uint8_t*&gt;(target), i, targetEnd - target, ch, sawError);
 79         if (sawError) {
 80             result = TargetExhausted;
 81             break;
 82         }
 83         source += j;
 84     }
 85     *sourceStart = source;
 86     *targetStart = target + i;
 87     return result;
 88 }
 89 
 90 bool convertUTF8ToUTF16(const char* source, const char* sourceEnd, UChar** targetStart, UChar* targetEnd, bool* sourceAllASCII)
 91 {
 92     RELEASE_ASSERT(sourceEnd - source &lt;= std::numeric_limits&lt;int&gt;::max());
 93     UBool error = false;
 94     UChar* target = *targetStart;

 95     UChar32 orAllData = 0;
 96     int targetOffset = 0;
 97     for (int sourceOffset = 0; sourceOffset &lt; sourceEnd - source; ) {
 98         UChar32 character;
 99         U8_NEXT(reinterpret_cast&lt;const uint8_t*&gt;(source), sourceOffset, sourceEnd - source, character);
100         if (character &lt; 0)
101             return false;
102         U16_APPEND(target, targetOffset, targetEnd - target, character, error);
103         if (error)
104             return false;
105         orAllData |= character;
106     }

107     *targetStart = target + targetOffset;
108     if (sourceAllASCII)
109         *sourceAllASCII = isASCII(orAllData);
110     return true;
111 }
112 
113 unsigned calculateStringHashAndLengthFromUTF8MaskingTop8Bits(const char* data, const char* dataEnd, unsigned&amp; dataLength, unsigned&amp; utf16Length)
114 {
115     StringHasher stringHasher;
116     utf16Length = 0;
117 
118     int inputOffset = 0;
119     int inputLength = dataEnd - data;
120     while (inputOffset &lt; inputLength) {
121         UChar32 character;
122         U8_NEXT(reinterpret_cast&lt;const uint8_t*&gt;(data), inputOffset, inputLength, character);
123         if (character &lt; 0)
124             return 0;
125 
126         if (U_IS_BMP(character)) {
</pre>
</td>
<td>
<hr />
<pre>
 75             }
 76             ch = replacementCharacter;
 77         }
 78         U8_APPEND(reinterpret_cast&lt;uint8_t*&gt;(target), i, targetEnd - target, ch, sawError);
 79         if (sawError) {
 80             result = TargetExhausted;
 81             break;
 82         }
 83         source += j;
 84     }
 85     *sourceStart = source;
 86     *targetStart = target + i;
 87     return result;
 88 }
 89 
 90 bool convertUTF8ToUTF16(const char* source, const char* sourceEnd, UChar** targetStart, UChar* targetEnd, bool* sourceAllASCII)
 91 {
 92     RELEASE_ASSERT(sourceEnd - source &lt;= std::numeric_limits&lt;int&gt;::max());
 93     UBool error = false;
 94     UChar* target = *targetStart;
<span class="line-added"> 95     RELEASE_ASSERT(targetEnd - target &lt;= std::numeric_limits&lt;int&gt;::max());</span>
 96     UChar32 orAllData = 0;
 97     int targetOffset = 0;
 98     for (int sourceOffset = 0; sourceOffset &lt; sourceEnd - source; ) {
 99         UChar32 character;
100         U8_NEXT(reinterpret_cast&lt;const uint8_t*&gt;(source), sourceOffset, sourceEnd - source, character);
101         if (character &lt; 0)
102             return false;
103         U16_APPEND(target, targetOffset, targetEnd - target, character, error);
104         if (error)
105             return false;
106         orAllData |= character;
107     }
<span class="line-added">108     RELEASE_ASSERT(target + targetOffset &lt;= targetEnd);</span>
109     *targetStart = target + targetOffset;
110     if (sourceAllASCII)
111         *sourceAllASCII = isASCII(orAllData);
112     return true;
113 }
114 
115 unsigned calculateStringHashAndLengthFromUTF8MaskingTop8Bits(const char* data, const char* dataEnd, unsigned&amp; dataLength, unsigned&amp; utf16Length)
116 {
117     StringHasher stringHasher;
118     utf16Length = 0;
119 
120     int inputOffset = 0;
121     int inputLength = dataEnd - data;
122     while (inputOffset &lt; inputLength) {
123         UChar32 character;
124         U8_NEXT(reinterpret_cast&lt;const uint8_t*&gt;(data), inputOffset, inputLength, character);
125         if (character &lt; 0)
126             return 0;
127 
128         if (U_IS_BMP(character)) {
</pre>
</td>
</tr>
</table>
<center><a href="../text/icu/UTextProviderLatin1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../win/MainThreadWin.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
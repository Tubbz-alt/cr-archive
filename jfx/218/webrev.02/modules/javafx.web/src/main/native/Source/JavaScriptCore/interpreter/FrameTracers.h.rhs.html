<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CatchScope.h&quot;
 29 #include &quot;StackAlignment.h&quot;
 30 #include &quot;VM.h&quot;
 31 
 32 namespace JSC {
 33 
 34 struct EntryFrame;
 35 
 36 class SuspendExceptionScope {
 37 public:
 38     SuspendExceptionScope(VM* vm)
 39         : m_vm(vm)
 40     {
 41         auto scope = DECLARE_CATCH_SCOPE(*vm);
 42         oldException = scope.exception();
 43         scope.clearException();
 44     }
 45     ~SuspendExceptionScope()
 46     {
 47         m_vm-&gt;restorePreviousException(oldException);
 48     }
 49 private:
 50     Exception* oldException;
 51     VM* m_vm;
 52 };
 53 
 54 class TopCallFrameSetter {
 55 public:
 56     TopCallFrameSetter(VM&amp; currentVM, CallFrame* callFrame)
 57         : vm(currentVM)
 58         , oldCallFrame(currentVM.topCallFrame)
 59     {
 60         currentVM.topCallFrame = callFrame;
 61     }
 62 
 63     ~TopCallFrameSetter()
 64     {
 65         vm.topCallFrame = oldCallFrame;
 66     }
 67 private:
 68     VM&amp; vm;
 69     CallFrame* oldCallFrame;
 70 };
 71 
 72 ALWAYS_INLINE static void assertStackPointerIsAligned()
 73 {
 74 #ifndef NDEBUG
 75 #if CPU(X86) &amp;&amp; !OS(WINDOWS)
 76     uintptr_t stackPointer;
 77 
 78     asm(&quot;movl %%esp,%0&quot; : &quot;=r&quot;(stackPointer));
 79     ASSERT(!(stackPointer % stackAlignmentBytes()));
 80 #endif
 81 #endif
 82 }
 83 
<a name="1" id="anc1"></a><span class="line-added"> 84 class SlowPathFrameTracer {</span>
<span class="line-added"> 85 public:</span>
<span class="line-added"> 86     ALWAYS_INLINE SlowPathFrameTracer(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added"> 87     {</span>
<span class="line-added"> 88         ASSERT(callFrame);</span>
<span class="line-added"> 89         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));</span>
<span class="line-added"> 90         assertStackPointerIsAligned();</span>
<span class="line-added"> 91         vm.topCallFrame = callFrame;</span>
<span class="line-added"> 92     }</span>
<span class="line-added"> 93 };</span>
<span class="line-added"> 94 </span>
 95 class NativeCallFrameTracer {
 96 public:
 97     ALWAYS_INLINE NativeCallFrameTracer(VM&amp; vm, CallFrame* callFrame)
 98     {
<a name="2" id="anc2"></a>
 99         ASSERT(callFrame);
100         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));
101         assertStackPointerIsAligned();
102         vm.topCallFrame = callFrame;
103     }
104 };
105 
<a name="3" id="anc3"></a><span class="line-added">106 class JITOperationPrologueCallFrameTracer {</span>
<span class="line-added">107 public:</span>
<span class="line-added">108     ALWAYS_INLINE JITOperationPrologueCallFrameTracer(VM&amp; vm, CallFrame* callFrame)</span>
<span class="line-added">109 #if ASSERT_ENABLED</span>
<span class="line-added">110         : m_vm(vm)</span>
<span class="line-added">111 #endif</span>
<span class="line-added">112     {</span>
<span class="line-added">113         UNUSED_PARAM(vm);</span>
<span class="line-added">114         UNUSED_PARAM(callFrame);</span>
<span class="line-added">115         ASSERT(callFrame);</span>
<span class="line-added">116         ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) &lt; reinterpret_cast&lt;void*&gt;(vm.topEntryFrame));</span>
<span class="line-added">117         assertStackPointerIsAligned();</span>
<span class="line-added">118 #if USE(BUILTIN_FRAME_ADDRESS)</span>
<span class="line-added">119         // If ASSERT_ENABLED and USE(BUILTIN_FRAME_ADDRESS), prepareCallOperation() will put the frame pointer into vm.topCallFrame.</span>
<span class="line-added">120         // We can ensure here that a call to prepareCallOperation() (or its equivalent) is not missing by comparing vm.topCallFrame to</span>
<span class="line-added">121         // the result of __builtin_frame_address which is passed in as callFrame.</span>
<span class="line-added">122         ASSERT(vm.topCallFrame == callFrame);</span>
<span class="line-added">123         vm.topCallFrame = callFrame;</span>
<span class="line-added">124 #endif</span>
<span class="line-added">125     }</span>
<span class="line-added">126 </span>
<span class="line-added">127 #if ASSERT_ENABLED</span>
<span class="line-added">128     ~JITOperationPrologueCallFrameTracer()</span>
<span class="line-added">129     {</span>
<span class="line-added">130         // Fill vm.topCallFrame with invalid value when leaving from JIT operation functions.</span>
<span class="line-added">131         m_vm.topCallFrame = bitwise_cast&lt;CallFrame*&gt;(static_cast&lt;uintptr_t&gt;(0x0badbeef0badbeefULL));</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
<span class="line-added">134     VM&amp; m_vm;</span>
<span class="line-added">135 #endif</span>
<span class="line-added">136 };</span>
<span class="line-added">137 </span>
138 } // namespace JSC
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
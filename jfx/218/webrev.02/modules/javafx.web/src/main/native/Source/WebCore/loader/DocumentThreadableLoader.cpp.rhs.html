<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentThreadableLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011, 2012 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;DocumentThreadableLoader.h&quot;
 33 
 34 #include &quot;CachedRawResource.h&quot;
 35 #include &quot;CachedResourceLoader.h&quot;
 36 #include &quot;CachedResourceRequest.h&quot;
 37 #include &quot;CachedResourceRequestInitiators.h&quot;
 38 #include &quot;CrossOriginAccessControl.h&quot;
 39 #include &quot;CrossOriginPreflightChecker.h&quot;
 40 #include &quot;CrossOriginPreflightResultCache.h&quot;
 41 #include &quot;DOMWindow.h&quot;
 42 #include &quot;Document.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 46 #include &quot;LegacySchemeRegistry.h&quot;</span>
 47 #include &quot;LoadTiming.h&quot;
 48 #include &quot;LoaderStrategy.h&quot;
 49 #include &quot;Performance.h&quot;
 50 #include &quot;PlatformStrategies.h&quot;
 51 #include &quot;ProgressTracker.h&quot;
 52 #include &quot;ResourceError.h&quot;
 53 #include &quot;ResourceRequest.h&quot;
 54 #include &quot;ResourceTiming.h&quot;
 55 #include &quot;RuntimeApplicationChecks.h&quot;
 56 #include &quot;RuntimeEnabledFeatures.h&quot;
<a name="2" id="anc2"></a>
 57 #include &quot;SecurityOrigin.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 58 #include &quot;Settings.h&quot;</span>
 59 #include &quot;SharedBuffer.h&quot;
 60 #include &quot;SubresourceIntegrity.h&quot;
 61 #include &quot;SubresourceLoader.h&quot;
 62 #include &quot;ThreadableLoaderClient.h&quot;
 63 #include &lt;wtf/Assertions.h&gt;
 64 #include &lt;wtf/Ref.h&gt;
 65 
 66 #if PLATFORM(IOS_FAMILY)
 67 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 68 #endif
 69 
 70 namespace WebCore {
 71 
 72 void DocumentThreadableLoader::loadResourceSynchronously(Document&amp; document, ResourceRequest&amp;&amp; request, ThreadableLoaderClient&amp; client, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin, std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy)
 73 {
 74     // The loader will be deleted as soon as this function exits.
 75     Ref&lt;DocumentThreadableLoader&gt; loader = adoptRef(*new DocumentThreadableLoader(document, client, LoadSynchronously, WTFMove(request), options, WTFMove(origin), WTFMove(contentSecurityPolicy), String(), ShouldLogError::Yes));
 76     ASSERT(loader-&gt;hasOneRef());
 77 }
 78 
 79 void DocumentThreadableLoader::loadResourceSynchronously(Document&amp; document, ResourceRequest&amp;&amp; request, ThreadableLoaderClient&amp; client, const ThreadableLoaderOptions&amp; options)
 80 {
 81     loadResourceSynchronously(document, WTFMove(request), client, options, nullptr, nullptr);
 82 }
 83 
 84 RefPtr&lt;DocumentThreadableLoader&gt; DocumentThreadableLoader::create(Document&amp; document, ThreadableLoaderClient&amp; client,
 85 ResourceRequest&amp;&amp; request, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin,
 86 std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy, String&amp;&amp; referrer, ShouldLogError shouldLogError)
 87 {
 88     RefPtr&lt;DocumentThreadableLoader&gt; loader = adoptRef(new DocumentThreadableLoader(document, client, LoadAsynchronously, WTFMove(request), options, WTFMove(origin), WTFMove(contentSecurityPolicy), WTFMove(referrer), shouldLogError));
 89     if (!loader-&gt;isLoading())
 90         loader = nullptr;
 91     return loader;
 92 }
 93 
 94 RefPtr&lt;DocumentThreadableLoader&gt; DocumentThreadableLoader::create(Document&amp; document, ThreadableLoaderClient&amp; client, ResourceRequest&amp;&amp; request, const ThreadableLoaderOptions&amp; options, String&amp;&amp; referrer)
 95 {
 96     return create(document, client, WTFMove(request), options, nullptr, nullptr, WTFMove(referrer), ShouldLogError::Yes);
 97 }
 98 
 99 static inline bool shouldPerformSecurityChecks()
100 {
101     return platformStrategies()-&gt;loaderStrategy()-&gt;shouldPerformSecurityChecks();
102 }
103 
104 bool DocumentThreadableLoader::shouldSetHTTPHeadersToKeep() const
105 {
106     if (m_options.mode == FetchOptions::Mode::Cors &amp;&amp; shouldPerformSecurityChecks())
107         return true;
108 
109 #if ENABLE(SERVICE_WORKER)
110     if (m_options.serviceWorkersMode == ServiceWorkersMode::All &amp;&amp; m_async)
111         return m_options.serviceWorkerRegistrationIdentifier || m_document.activeServiceWorker();
112 #endif
113 
114     return false;
115 }
116 
117 DocumentThreadableLoader::DocumentThreadableLoader(Document&amp; document, ThreadableLoaderClient&amp; client, BlockingBehavior blockingBehavior, ResourceRequest&amp;&amp; request, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin, std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy, String&amp;&amp; referrer, ShouldLogError shouldLogError)
118     : m_client(&amp;client)
119     , m_document(document)
120     , m_options(options)
121     , m_origin(WTFMove(origin))
122     , m_referrer(WTFMove(referrer))
123     , m_sameOriginRequest(securityOrigin().canRequest(request.url()))
124     , m_simpleRequest(true)
125     , m_async(blockingBehavior == LoadAsynchronously)
126     , m_delayCallbacksForIntegrityCheck(!m_options.integrity.isEmpty())
127     , m_contentSecurityPolicy(WTFMove(contentSecurityPolicy))
128     , m_shouldLogError(shouldLogError)
129 {
130     relaxAdoptionRequirement();
131 
132     // Setting a referrer header is only supported in the async code path.
133     ASSERT(m_async || m_referrer.isEmpty());
134 
<a name="4" id="anc4"></a><span class="line-added">135     if (document.settings().disallowSyncXHRDuringPageDismissalEnabled() &amp;&amp; !m_async &amp;&amp; (!document.page() || !document.page()-&gt;areSynchronousLoadsAllowed())) {</span>
<span class="line-added">136         document.didRejectSyncXHRDuringPageDismissal();</span>
<span class="line-added">137         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, request.url(), &quot;Synchronous loads are not allowed at this time&quot;));</span>
<span class="line-added">138         return;</span>
<span class="line-added">139     }</span>
<span class="line-added">140 </span>
141     // Referrer and Origin headers should be set after the preflight if any.
142     ASSERT(!request.hasHTTPReferrer() &amp;&amp; !request.hasHTTPOrigin());
143 
144     ASSERT_WITH_SECURITY_IMPLICATION(isAllowedByContentSecurityPolicy(request.url(), ContentSecurityPolicy::RedirectResponseReceived::No));
145 
146     m_options.storedCredentialsPolicy = (m_options.credentials == FetchOptions::Credentials::Include || (m_options.credentials == FetchOptions::Credentials::SameOrigin &amp;&amp; m_sameOriginRequest)) ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse;
147 
148     ASSERT(!request.httpHeaderFields().contains(HTTPHeaderName::Origin));
149 
150     // Copy headers if we need to replay the request after a redirection.
151     if (m_options.mode == FetchOptions::Mode::Cors)
152         m_originalHeaders = request.httpHeaderFields();
153 
154     if (shouldSetHTTPHeadersToKeep())
155         m_options.httpHeadersToKeep = httpHeadersToKeepFromCleaning(request.httpHeaderFields());
156 
<a name="5" id="anc5"></a><span class="line-modified">157     bool shouldDisableCORS = document.isRunningUserScripts() &amp;&amp; LegacySchemeRegistry::isUserExtensionScheme(request.url().protocol().toStringWithoutCopying());</span>
<span class="line-added">158     if (auto* page = document.page())</span>
<span class="line-added">159         shouldDisableCORS |= page-&gt;shouldDisableCorsForRequestTo(request.url());</span>
<span class="line-added">160 </span>
<span class="line-added">161     if (shouldDisableCORS) {</span>
162         m_options.mode = FetchOptions::Mode::NoCors;
163         m_options.filteringPolicy = ResponseFilteringPolicy::Disable;
164     }
165 
166     m_options.cspResponseHeaders = m_options.contentSecurityPolicyEnforcement != ContentSecurityPolicyEnforcement::DoNotEnforce ? this-&gt;contentSecurityPolicy().responseHeaders() : ContentSecurityPolicyResponseHeaders { };
167 
168     // As per step 11 of https://fetch.spec.whatwg.org/#main-fetch, data scheme (if same-origin data-URL flag is set) and about scheme are considered same-origin.
169     if (request.url().protocolIsData())
170         m_sameOriginRequest = options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
171 
172     if (m_sameOriginRequest || m_options.mode == FetchOptions::Mode::NoCors || m_options.mode == FetchOptions::Mode::Navigate) {
173         loadRequest(WTFMove(request), SecurityCheckPolicy::DoSecurityCheck);
174         return;
175     }
176 
177     if (m_options.mode == FetchOptions::Mode::SameOrigin) {
178         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, request.url(), &quot;Cross origin requests are not allowed when using same-origin fetch mode.&quot;));
179         return;
180     }
181 
182     makeCrossOriginAccessRequest(WTFMove(request));
183 }
184 
185 bool DocumentThreadableLoader::checkURLSchemeAsCORSEnabled(const URL&amp; url)
186 {
187     // Cross-origin requests are only allowed for HTTP and registered schemes. We would catch this when checking response headers later, but there is no reason to send a request that&#39;s guaranteed to be denied.
<a name="6" id="anc6"></a><span class="line-modified">188     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(url.protocol().toStringWithoutCopying())) {</span>
189         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross origin requests are only supported for HTTP.&quot;, ResourceError::Type::AccessControl));
190         return false;
191     }
192     return true;
193 }
194 
195 void DocumentThreadableLoader::makeCrossOriginAccessRequest(ResourceRequest&amp;&amp; request)
196 {
197     ASSERT(m_options.mode == FetchOptions::Mode::Cors);
198 
199 #if PLATFORM(IOS_FAMILY)
200     bool needsPreflightQuirk = IOSApplication::isMoviStarPlus() &amp;&amp; applicationSDKVersion() &lt; DYLD_IOS_VERSION_12_0 &amp;&amp; (m_options.preflightPolicy == PreflightPolicy::Consider || m_options.preflightPolicy == PreflightPolicy::Force);
201 #else
202     bool needsPreflightQuirk = false;
203 #endif
204 
205     if ((m_options.preflightPolicy == PreflightPolicy::Consider &amp;&amp; isSimpleCrossOriginAccessRequest(request.httpMethod(), request.httpHeaderFields())) || m_options.preflightPolicy == PreflightPolicy::Prevent || (shouldPerformSecurityChecks() &amp;&amp; !needsPreflightQuirk)) {
206         if (checkURLSchemeAsCORSEnabled(request.url()))
207             makeSimpleCrossOriginAccessRequest(WTFMove(request));
208     } else {
209 #if ENABLE(SERVICE_WORKER)
210         if (m_options.serviceWorkersMode == ServiceWorkersMode::All &amp;&amp; m_async) {
211             if (m_options.serviceWorkerRegistrationIdentifier || document().activeServiceWorker()) {
212                 ASSERT(!m_bypassingPreflightForServiceWorkerRequest);
213                 m_bypassingPreflightForServiceWorkerRequest = WTFMove(request);
214                 m_options.serviceWorkersMode = ServiceWorkersMode::Only;
215                 loadRequest(ResourceRequest { m_bypassingPreflightForServiceWorkerRequest.value() }, SecurityCheckPolicy::SkipSecurityCheck);
216                 return;
217             }
218         }
219 #endif
220         if (!needsPreflightQuirk &amp;&amp; !checkURLSchemeAsCORSEnabled(request.url()))
221             return;
222 
223         m_simpleRequest = false;
224         if (CrossOriginPreflightResultCache::singleton().canSkipPreflight(securityOrigin().toString(), request.url(), m_options.storedCredentialsPolicy, request.httpMethod(), request.httpHeaderFields()))
225             preflightSuccess(WTFMove(request));
226         else
227             makeCrossOriginAccessRequestWithPreflight(WTFMove(request));
228     }
229 }
230 
231 void DocumentThreadableLoader::makeSimpleCrossOriginAccessRequest(ResourceRequest&amp;&amp; request)
232 {
233     ASSERT(m_options.preflightPolicy != PreflightPolicy::Force || shouldPerformSecurityChecks());
234     ASSERT(m_options.preflightPolicy == PreflightPolicy::Prevent || isSimpleCrossOriginAccessRequest(request.httpMethod(), request.httpHeaderFields()) || shouldPerformSecurityChecks());
235 
236     updateRequestForAccessControl(request, securityOrigin(), m_options.storedCredentialsPolicy);
237     loadRequest(WTFMove(request), SecurityCheckPolicy::DoSecurityCheck);
238 }
239 
240 void DocumentThreadableLoader::makeCrossOriginAccessRequestWithPreflight(ResourceRequest&amp;&amp; request)
241 {
242     if (m_async) {
243         m_preflightChecker.emplace(*this, WTFMove(request));
244         m_preflightChecker-&gt;startPreflight();
245         return;
246     }
247     CrossOriginPreflightChecker::doPreflight(*this, WTFMove(request));
248 }
249 
250 DocumentThreadableLoader::~DocumentThreadableLoader()
251 {
252     if (m_resource)
253         m_resource-&gt;removeClient(*this);
254 }
255 
256 void DocumentThreadableLoader::cancel()
257 {
258     Ref&lt;DocumentThreadableLoader&gt; protectedThis(*this);
259 
260     // Cancel can re-enter and m_resource might be null here as a result.
261     if (m_client &amp;&amp; m_resource) {
262         // FIXME: This error is sent to the client in didFail(), so it should not be an internal one. Use FrameLoaderClient::cancelledError() instead.
263         ResourceError error(errorDomainWebKitInternal, 0, m_resource-&gt;url(), &quot;Load cancelled&quot;, ResourceError::Type::Cancellation);
264         m_client-&gt;didFail(error);
265     }
266     clearResource();
267     m_client = nullptr;
268 }
269 
270 void DocumentThreadableLoader::setDefersLoading(bool value)
271 {
272     if (m_resource)
273         m_resource-&gt;setDefersLoading(value);
274     if (m_preflightChecker)
275         m_preflightChecker-&gt;setDefersLoading(value);
276 }
277 
278 void DocumentThreadableLoader::clearResource()
279 {
280     // Script can cancel and restart a request reentrantly within removeClient(),
281     // which could lead to calling CachedResource::removeClient() multiple times for
282     // this DocumentThreadableLoader. Save off a copy of m_resource and clear it to
283     // prevent the reentrancy.
284     if (CachedResourceHandle&lt;CachedRawResource&gt; resource = m_resource) {
285         m_resource = nullptr;
286         resource-&gt;removeClient(*this);
287     }
288     if (m_preflightChecker)
289         m_preflightChecker = WTF::nullopt;
290 }
291 
292 void DocumentThreadableLoader::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
293 {
294     ASSERT(m_client);
295     ASSERT_UNUSED(resource, &amp;resource == m_resource);
296 
297     Ref&lt;DocumentThreadableLoader&gt; protectedThis(*this);
298     --m_options.maxRedirectCount;
299 
300     // FIXME: We restrict this check to Fetch API for the moment, as this might disrupt WorkerScriptLoader.
301     // Reassess this check based on https://github.com/whatwg/fetch/issues/393 discussions.
302     // We should also disable that check in navigation mode.
303     if (!request.url().protocolIsInHTTPFamily() &amp;&amp; m_options.initiator == cachedResourceRequestInitiators().fetch) {
304         reportRedirectionWithBadScheme(request.url());
305         clearResource();
306         return completionHandler(WTFMove(request));
307     }
308 
309     if (platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(redirectResponse)) {
310         completionHandler(WTFMove(request));
311         return;
312     }
313 
314     if (!isAllowedByContentSecurityPolicy(request.url(), redirectResponse.isNull() ? ContentSecurityPolicy::RedirectResponseReceived::No : ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
315         reportContentSecurityPolicyError(redirectResponse.url());
316         clearResource();
317         return completionHandler(WTFMove(request));
318     }
319 
320     // Allow same origin requests to continue after allowing clients to audit the redirect.
321     if (isAllowedRedirect(request.url()))
322         return completionHandler(WTFMove(request));
323 
324     // Force any subsequent request to use these checks.
325     m_sameOriginRequest = false;
326 
327     ASSERT(m_resource);
328     ASSERT(m_originalHeaders);
329 
330     // Use a unique for subsequent loads if needed.
331     // https://fetch.spec.whatwg.org/#concept-http-redirect-fetch (Step 10).
332     ASSERT(m_options.mode == FetchOptions::Mode::Cors);
333     if (!securityOrigin().canRequest(redirectResponse.url()) &amp;&amp; !protocolHostAndPortAreEqual(redirectResponse.url(), request.url()))
334         m_origin = SecurityOrigin::createUnique();
335 
336     // Except in case where preflight is needed, loading should be able to continue on its own.
337     // But we also handle credentials here if it is restricted to SameOrigin.
338     if (m_options.credentials != FetchOptions::Credentials::SameOrigin &amp;&amp; m_simpleRequest &amp;&amp; isSimpleCrossOriginAccessRequest(request.httpMethod(), *m_originalHeaders))
339         return completionHandler(WTFMove(request));
340 
341     if (m_options.credentials == FetchOptions::Credentials::SameOrigin)
342         m_options.storedCredentialsPolicy = StoredCredentialsPolicy::DoNotUse;
343 
344     clearResource();
345 
346     m_referrer = request.httpReferrer();
347     if (m_referrer.isNull())
348         m_options.referrerPolicy = ReferrerPolicy::NoReferrer;
349 
350     // Let&#39;s fetch the request with the original headers (equivalent to request cloning specified by fetch algorithm).
351     // Do not copy the Authorization header if removed by the network layer.
352     if (!request.httpHeaderFields().contains(HTTPHeaderName::Authorization))
353         m_originalHeaders-&gt;remove(HTTPHeaderName::Authorization);
354     request.setHTTPHeaderFields(*m_originalHeaders);
355 
356 #if ENABLE(SERVICE_WORKER)
357     if (redirectResponse.source() != ResourceResponse::Source::ServiceWorker &amp;&amp; redirectResponse.source() != ResourceResponse::Source::MemoryCache)
358         m_options.serviceWorkersMode = ServiceWorkersMode::None;
359 #endif
360     makeCrossOriginAccessRequest(ResourceRequest(request));
361     completionHandler(WTFMove(request));
362 }
363 
364 void DocumentThreadableLoader::dataSent(CachedResource&amp; resource, unsigned long long bytesSent, unsigned long long totalBytesToBeSent)
365 {
366     ASSERT(m_client);
367     ASSERT_UNUSED(resource, &amp;resource == m_resource);
368     m_client-&gt;didSendData(bytesSent, totalBytesToBeSent);
369 }
370 
371 void DocumentThreadableLoader::responseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
372 {
373     ASSERT_UNUSED(resource, &amp;resource == m_resource);
374     didReceiveResponse(m_resource-&gt;identifier(), response);
375 
376     if (completionHandler)
377         completionHandler();
378 }
379 
380 void DocumentThreadableLoader::didReceiveResponse(unsigned long identifier, const ResourceResponse&amp; response)
381 {
382     ASSERT(m_client);
383     ASSERT(response.type() != ResourceResponse::Type::Error);
384 
385     InspectorInstrumentation::didReceiveThreadableLoaderResponse(*this, identifier);
386 
387     if (m_delayCallbacksForIntegrityCheck)
388         return;
389 
390     if (options().filteringPolicy == ResponseFilteringPolicy::Disable) {
391         m_client-&gt;didReceiveResponse(identifier, response);
392         return;
393     }
394 
395     if (response.type() == ResourceResponse::Type::Default) {
396         m_client-&gt;didReceiveResponse(identifier, ResourceResponseBase::filter(response));
397         if (response.tainting() == ResourceResponse::Tainting::Opaque) {
398             clearResource();
399             if (m_client)
400                 m_client-&gt;didFinishLoading(identifier);
401         }
402         return;
403     }
404     ASSERT(response.type() == ResourceResponse::Type::Opaqueredirect || response.source() == ResourceResponse::Source::ServiceWorker || response.source() == ResourceResponse::Source::MemoryCache);
405     m_client-&gt;didReceiveResponse(identifier, response);
406 }
407 
408 void DocumentThreadableLoader::dataReceived(CachedResource&amp; resource, const char* data, int dataLength)
409 {
410     ASSERT_UNUSED(resource, &amp;resource == m_resource);
411     didReceiveData(m_resource-&gt;identifier(), data, dataLength);
412 }
413 
414 void DocumentThreadableLoader::didReceiveData(unsigned long, const char* data, int dataLength)
415 {
416     ASSERT(m_client);
417 
418     if (m_delayCallbacksForIntegrityCheck)
419         return;
420 
421     m_client-&gt;didReceiveData(data, dataLength);
422 }
423 
424 void DocumentThreadableLoader::finishedTimingForWorkerLoad(CachedResource&amp; resource, const ResourceTiming&amp; resourceTiming)
425 {
426     ASSERT(m_client);
427     ASSERT_UNUSED(resource, &amp;resource == m_resource);
428 
429     finishedTimingForWorkerLoad(resourceTiming);
430 }
431 
432 void DocumentThreadableLoader::finishedTimingForWorkerLoad(const ResourceTiming&amp; resourceTiming)
433 {
434     ASSERT(m_options.initiatorContext == InitiatorContext::Worker);
435 
436     m_client-&gt;didFinishTiming(resourceTiming);
437 }
438 
439 void DocumentThreadableLoader::notifyFinished(CachedResource&amp; resource)
440 {
441     ASSERT(m_client);
442     ASSERT_UNUSED(resource, &amp;resource == m_resource);
443 
444     if (m_resource-&gt;errorOccurred())
445         didFail(m_resource-&gt;identifier(), m_resource-&gt;resourceError());
446     else
447         didFinishLoading(m_resource-&gt;identifier());
448 }
449 
450 void DocumentThreadableLoader::didFinishLoading(unsigned long identifier)
451 {
452     ASSERT(m_client);
453 
454     if (m_delayCallbacksForIntegrityCheck) {
455         if (!matchIntegrityMetadata(*m_resource, m_options.integrity)) {
<a name="7" id="anc7"></a><span class="line-modified">456             reportIntegrityMetadataError(*m_resource, m_options.integrity);</span>
457             return;
458         }
459 
460         auto response = m_resource-&gt;response();
461 
462         if (options().filteringPolicy == ResponseFilteringPolicy::Disable) {
463             m_client-&gt;didReceiveResponse(identifier, response);
464             if (m_resource-&gt;resourceBuffer())
465                 m_client-&gt;didReceiveData(m_resource-&gt;resourceBuffer()-&gt;data(), m_resource-&gt;resourceBuffer()-&gt;size());
466         } else {
467             ASSERT(response.type() == ResourceResponse::Type::Default);
468 
469             m_client-&gt;didReceiveResponse(identifier, ResourceResponseBase::filter(response));
470             if (m_resource-&gt;resourceBuffer())
471                 m_client-&gt;didReceiveData(m_resource-&gt;resourceBuffer()-&gt;data(), m_resource-&gt;resourceBuffer()-&gt;size());
472         }
473     }
474 
475     m_client-&gt;didFinishLoading(identifier);
476 }
477 
478 void DocumentThreadableLoader::didFail(unsigned long, const ResourceError&amp; error)
479 {
480     ASSERT(m_client);
481 #if ENABLE(SERVICE_WORKER)
482     if (m_bypassingPreflightForServiceWorkerRequest &amp;&amp; error.isCancellation()) {
483         clearResource();
484 
485         m_options.serviceWorkersMode = ServiceWorkersMode::None;
486         makeCrossOriginAccessRequestWithPreflight(WTFMove(m_bypassingPreflightForServiceWorkerRequest.value()));
487         ASSERT(m_bypassingPreflightForServiceWorkerRequest-&gt;isNull());
488         m_bypassingPreflightForServiceWorkerRequest = WTF::nullopt;
489         return;
490     }
491 #endif
492 
493     if (m_shouldLogError == ShouldLogError::Yes)
494         logError(m_document, error, m_options.initiator);
495 
496     m_client-&gt;didFail(error);
497 }
498 
499 void DocumentThreadableLoader::preflightSuccess(ResourceRequest&amp;&amp; request)
500 {
501     ResourceRequest actualRequest(WTFMove(request));
502     updateRequestForAccessControl(actualRequest, securityOrigin(), m_options.storedCredentialsPolicy);
503 
504     m_preflightChecker = WTF::nullopt;
505 
506     // It should be ok to skip the security check since we already asked about the preflight request.
507     loadRequest(WTFMove(actualRequest), SecurityCheckPolicy::SkipSecurityCheck);
508 }
509 
510 void DocumentThreadableLoader::preflightFailure(unsigned long identifier, const ResourceError&amp; error)
511 {
512     m_preflightChecker = WTF::nullopt;
513 
514     InspectorInstrumentation::didFailLoading(m_document.frame(), m_document.frame()-&gt;loader().documentLoader(), identifier, error);
515 
516     if (m_shouldLogError == ShouldLogError::Yes)
517         logError(m_document, error, m_options.initiator);
518 
519     m_client-&gt;didFail(error);
520 }
521 
522 void DocumentThreadableLoader::loadRequest(ResourceRequest&amp;&amp; request, SecurityCheckPolicy securityCheck)
523 {
524     Ref&lt;DocumentThreadableLoader&gt; protectedThis(*this);
525 
526     // Any credential should have been removed from the cross-site requests.
527     const URL&amp; requestURL = request.url();
528     m_options.securityCheck = securityCheck;
529     ASSERT(m_sameOriginRequest || requestURL.user().isEmpty());
530     ASSERT(m_sameOriginRequest || requestURL.pass().isEmpty());
531 
532     if (!m_referrer.isNull())
533         request.setHTTPReferrer(m_referrer);
534 
535     if (m_async) {
536         ResourceLoaderOptions options = m_options;
537         options.clientCredentialPolicy = m_sameOriginRequest ? ClientCredentialPolicy::MayAskClientForCredentials : ClientCredentialPolicy::CannotAskClientForCredentials;
538         options.contentSecurityPolicyImposition = ContentSecurityPolicyImposition::SkipPolicyCheck;
539 
540         // If there is integrity metadata to validate, we must buffer.
541         if (!m_options.integrity.isEmpty())
542             options.dataBufferingPolicy = DataBufferingPolicy::BufferData;
543 
544         request.setAllowCookies(m_options.storedCredentialsPolicy == StoredCredentialsPolicy::Use);
545         CachedResourceRequest newRequest(WTFMove(request), options);
546         if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
547             newRequest.setInitiator(m_options.initiator);
548         newRequest.setOrigin(securityOrigin());
549 
550         ASSERT(!m_resource);
551         if (m_resource) {
552             CachedResourceHandle&lt;CachedRawResource&gt; resource = std::exchange(m_resource, nullptr);
553             resource-&gt;removeClient(*this);
554         }
555 
556         auto cachedResource = m_document.cachedResourceLoader().requestRawResource(WTFMove(newRequest));
557         m_resource = cachedResource.value_or(nullptr);
558         if (m_resource)
559             m_resource-&gt;addClient(*this);
560         else
561             logErrorAndFail(cachedResource.error());
562         return;
563     }
564 
565     // If credentials mode is &#39;Omit&#39;, we should disable cookie sending.
566     ASSERT(m_options.credentials != FetchOptions::Credentials::Omit);
567 
568     LoadTiming loadTiming;
569     loadTiming.markStartTimeAndFetchStart();
570 
571     // FIXME: ThreadableLoaderOptions.sniffContent is not supported for synchronous requests.
572     RefPtr&lt;SharedBuffer&gt; data;
573     ResourceError error;
574     ResourceResponse response;
575     unsigned long identifier = std::numeric_limits&lt;unsigned long&gt;::max();
576     if (m_document.frame()) {
577         auto&amp; frameLoader = m_document.frame()-&gt;loader();
578         if (!frameLoader.mixedContentChecker().canRunInsecureContent(m_document.securityOrigin(), requestURL))
579             return;
580         identifier = frameLoader.loadResourceSynchronously(request, m_options.clientCredentialPolicy, m_options, *m_originalHeaders, error, response, data);
581     }
582 
583     loadTiming.setResponseEnd(MonotonicTime::now());
584 
585     if (!error.isNull() &amp;&amp; response.httpStatusCode() &lt;= 0) {
586         if (requestURL.isLocalFile()) {
587             // We don&#39;t want XMLHttpRequest to raise an exception for file:// resources, see &lt;rdar://problem/4962298&gt;.
588             // FIXME: XMLHttpRequest quirks should be in XMLHttpRequest code, not in DocumentThreadableLoader.cpp.
589             didReceiveResponse(identifier, response);
590             didFinishLoading(identifier);
591             return;
592         }
593         logErrorAndFail(error);
594         return;
595     }
596 
597     if (!shouldPerformSecurityChecks()) {
598         // FIXME: FrameLoader::loadSynchronously() does not tell us whether a redirect happened or not, so we guess by comparing the
599         // request and response URLs. This isn&#39;t a perfect test though, since a server can serve a redirect to the same URL that was
600         // requested. Also comparing the request and response URLs as strings will fail if the requestURL still has its credentials.
601         bool didRedirect = requestURL != response.url();
602         if (didRedirect) {
603             if (!isAllowedByContentSecurityPolicy(response.url(), ContentSecurityPolicy::RedirectResponseReceived::Yes)) {
604                 reportContentSecurityPolicyError(requestURL);
605                 return;
606             }
607             if (!isAllowedRedirect(response.url())) {
608                 reportCrossOriginResourceSharingError(requestURL);
609                 return;
610             }
611         }
612 
613         if (!m_sameOriginRequest) {
614             if (m_options.mode == FetchOptions::Mode::NoCors)
615                 response.setTainting(ResourceResponse::Tainting::Opaque);
616             else {
617                 ASSERT(m_options.mode == FetchOptions::Mode::Cors);
618                 response.setTainting(ResourceResponse::Tainting::Cors);
619                 String accessControlErrorDescription;
620                 if (!passesAccessControlCheck(response, m_options.storedCredentialsPolicy, securityOrigin(), accessControlErrorDescription)) {
621                     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, response.url(), accessControlErrorDescription, ResourceError::Type::AccessControl));
622                     return;
623                 }
624             }
625         }
626     }
627     didReceiveResponse(identifier, response);
628 
629     if (data)
630         didReceiveData(identifier, data-&gt;data(), data-&gt;size());
631 
632     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled()) {
633         auto resourceTiming = ResourceTiming::fromSynchronousLoad(requestURL, m_options.initiator, loadTiming, response.deprecatedNetworkLoadMetrics(), response, securityOrigin());
634         if (options().initiatorContext == InitiatorContext::Worker)
635             finishedTimingForWorkerLoad(resourceTiming);
636         else {
637             if (auto* window = document().domWindow())
638                 window-&gt;performance().addResourceTiming(WTFMove(resourceTiming));
639         }
640     }
641 
642     didFinishLoading(identifier);
643 }
644 
645 bool DocumentThreadableLoader::isAllowedByContentSecurityPolicy(const URL&amp; url, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived)
646 {
647     switch (m_options.contentSecurityPolicyEnforcement) {
648     case ContentSecurityPolicyEnforcement::DoNotEnforce:
649         return true;
650     case ContentSecurityPolicyEnforcement::EnforceChildSrcDirective:
651         return contentSecurityPolicy().allowChildContextFromSource(url, redirectResponseReceived);
652     case ContentSecurityPolicyEnforcement::EnforceConnectSrcDirective:
653         return contentSecurityPolicy().allowConnectToSource(url, redirectResponseReceived);
654     case ContentSecurityPolicyEnforcement::EnforceScriptSrcDirective:
655         return contentSecurityPolicy().allowScriptFromSource(url, redirectResponseReceived);
656     }
657     ASSERT_NOT_REACHED();
658     return false;
659 }
660 
661 bool DocumentThreadableLoader::isAllowedRedirect(const URL&amp; url)
662 {
663     if (m_options.mode == FetchOptions::Mode::NoCors)
664         return true;
665 
666     return m_sameOriginRequest &amp;&amp; securityOrigin().canRequest(url);
667 }
668 
<a name="8" id="anc8"></a>




669 SecurityOrigin&amp; DocumentThreadableLoader::securityOrigin() const
670 {
671     return m_origin ? *m_origin : m_document.securityOrigin();
672 }
673 
674 const ContentSecurityPolicy&amp; DocumentThreadableLoader::contentSecurityPolicy() const
675 {
676     if (m_contentSecurityPolicy)
677         return *m_contentSecurityPolicy.get();
678     ASSERT(m_document.contentSecurityPolicy());
679     return *m_document.contentSecurityPolicy();
680 }
681 
682 void DocumentThreadableLoader::reportRedirectionWithBadScheme(const URL&amp; url)
683 {
684     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Redirection to URL with a scheme that is not HTTP(S).&quot;_s, ResourceError::Type::AccessControl));
685 }
686 
687 void DocumentThreadableLoader::reportContentSecurityPolicyError(const URL&amp; url)
688 {
689     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Blocked by Content Security Policy.&quot;_s, ResourceError::Type::AccessControl));
690 }
691 
692 void DocumentThreadableLoader::reportCrossOriginResourceSharingError(const URL&amp; url)
693 {
694     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross-origin redirection denied by Cross-Origin Resource Sharing policy.&quot;_s, ResourceError::Type::AccessControl));
695 }
696 
<a name="9" id="anc9"></a><span class="line-modified">697 void DocumentThreadableLoader::reportIntegrityMetadataError(const CachedResource&amp; resource, const String&amp; expectedMetadata)</span>
698 {
<a name="10" id="anc10"></a><span class="line-modified">699     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, resource.url(), makeString(&quot;Failed integrity metadata check. &quot;_s, integrityMismatchDescription(resource, expectedMetadata)), ResourceError::Type::General));</span>
700 }
701 
702 void DocumentThreadableLoader::logErrorAndFail(const ResourceError&amp; error)
703 {
704     if (m_shouldLogError == ShouldLogError::Yes) {
705         if (error.isAccessControl() &amp;&amp; !error.localizedDescription().isEmpty())
706             m_document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
707         logError(m_document, error, m_options.initiator);
708     }
709     ASSERT(m_client);
710     m_client-&gt;didFail(error);
711 }
712 
713 } // namespace WebCore
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/cf/StringImplCF.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../WTFString.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../cocoa/TextBreakIteratorInternalICUCocoa.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/cf/StringImplCF.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &lt;wtf/text/StringImpl.h&gt;
 23 
 24 #if USE(CF)
 25 
 26 #include &lt;CoreFoundation/CoreFoundation.h&gt;

 27 #include &lt;wtf/MainThread.h&gt;

 28 #include &lt;wtf/RetainPtr.h&gt;
 29 #include &lt;wtf/Threading.h&gt;
 30 
 31 namespace WTF {
 32 
 33 namespace StringWrapperCFAllocator {
 34 



 35     static StringImpl* currentString;
 36 
 37     static const void* retain(const void* info)
 38     {
 39         return info;
 40     }
 41 
 42     NO_RETURN_DUE_TO_ASSERT
 43     static void release(const void*)
 44     {
 45         ASSERT_NOT_REACHED();
 46     }
 47 
 48     static CFStringRef copyDescription(const void*)
 49     {
 50         return CFSTR(&quot;WTF::String-based allocator&quot;);
 51     }
 52 
 53     static void* allocate(CFIndex size, CFOptionFlags, void*)
 54     {
 55         StringImpl* underlyingString = 0;
 56         if (isMainThread()) {
 57             underlyingString = currentString;
 58             if (underlyingString) {
 59                 currentString = 0;
 60                 underlyingString-&gt;ref(); // Balanced by call to deref in deallocate below.
 61             }
 62         }
<span class="line-modified"> 63         StringImpl** header = static_cast&lt;StringImpl**&gt;(fastMalloc(sizeof(StringImpl*) + size));</span>
 64         *header = underlyingString;
 65         return header + 1;
 66     }
 67 
 68     static void* reallocate(void* pointer, CFIndex newSize, CFOptionFlags, void*)
 69     {
 70         size_t newAllocationSize = sizeof(StringImpl*) + newSize;
 71         StringImpl** header = static_cast&lt;StringImpl**&gt;(pointer) - 1;
 72         ASSERT(!*header);
<span class="line-modified"> 73         header = static_cast&lt;StringImpl**&gt;(fastRealloc(header, newAllocationSize));</span>
 74         return header + 1;
 75     }
 76 
 77     static void deallocate(void* pointer, void*)
 78     {
 79         StringImpl** header = static_cast&lt;StringImpl**&gt;(pointer) - 1;
 80         StringImpl* underlyingString = *header;
 81         if (!underlyingString)
<span class="line-modified"> 82             fastFree(header);</span>
 83         else {
 84             if (isMainThread()) {
 85                 underlyingString-&gt;deref(); // Balanced by call to ref in allocate above.
<span class="line-modified"> 86                 fastFree(header);</span>
 87                 return;
 88             }
 89 
 90             callOnMainThread([header] {
 91                 StringImpl* underlyingString = *header;
 92                 ASSERT(underlyingString);
 93                 underlyingString-&gt;deref(); // Balanced by call to ref in allocate above.
<span class="line-modified"> 94                 fastFree(header);</span>
 95             });
 96         }
 97     }
 98 
 99     static CFIndex preferredSize(CFIndex size, CFOptionFlags, void*)
100     {
101         // FIXME: If FastMalloc provided a &quot;good size&quot; callback, we&#39;d want to use it here.
102         // Note that this optimization would help performance for strings created with the
103         // allocator that are mutable, and those typically are only created by callers who
104         // make a new string using the old string&#39;s allocator, such as some of the call
105         // sites in CFURL.
106         return size;
107     }
108 
109     static CFAllocatorRef create()
110     {
111         CFAllocatorContext context = { 0, 0, retain, release, copyDescription, allocate, reallocate, deallocate, preferredSize };
112         return CFAllocatorCreate(0, &amp;context);
113     }
114 
115     static CFAllocatorRef allocator()
116     {
117         static CFAllocatorRef allocator = create();
118         return allocator;
119     }
120 
121 }
122 
123 RetainPtr&lt;CFStringRef&gt; StringImpl::createCFString()
124 {
<span class="line-modified">125     if (!m_length || !isMainThreadIfInitialized()) {</span>
126         if (is8Bit())
127             return adoptCF(CFStringCreateWithBytes(0, reinterpret_cast&lt;const UInt8*&gt;(characters8()), m_length, kCFStringEncodingISOLatin1, false));
128         return adoptCF(CFStringCreateWithCharacters(0, reinterpret_cast&lt;const UniChar*&gt;(characters16()), m_length));
129     }
130     CFAllocatorRef allocator = StringWrapperCFAllocator::allocator();
131 
132     // Put pointer to the StringImpl in a global so the allocator can store it with the CFString.
133     ASSERT(!StringWrapperCFAllocator::currentString);
134     StringWrapperCFAllocator::currentString = this;
135 
136     CFStringRef string;
137     if (is8Bit())
138         string = CFStringCreateWithBytesNoCopy(allocator, reinterpret_cast&lt;const UInt8*&gt;(characters8()), m_length, kCFStringEncodingISOLatin1, false, kCFAllocatorNull);
139     else
140         string = CFStringCreateWithCharactersNoCopy(allocator, reinterpret_cast&lt;const UniChar*&gt;(characters16()), m_length, kCFAllocatorNull);
141     // CoreFoundation might not have to allocate anything, we clear currentString in case we did not execute allocate().
142     StringWrapperCFAllocator::currentString = 0;
143 
144     return adoptCF(string);
145 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &lt;wtf/text/StringImpl.h&gt;
 23 
 24 #if USE(CF)
 25 
 26 #include &lt;CoreFoundation/CoreFoundation.h&gt;
<span class="line-added"> 27 #include &lt;wtf/DebugHeap.h&gt;</span>
 28 #include &lt;wtf/MainThread.h&gt;
<span class="line-added"> 29 #include &lt;wtf/NeverDestroyed.h&gt;</span>
 30 #include &lt;wtf/RetainPtr.h&gt;
 31 #include &lt;wtf/Threading.h&gt;
 32 
 33 namespace WTF {
 34 
 35 namespace StringWrapperCFAllocator {
 36 
<span class="line-added"> 37     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringWrapperCFAllocator);</span>
<span class="line-added"> 38     DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringWrapperCFAllocator);</span>
<span class="line-added"> 39 </span>
 40     static StringImpl* currentString;
 41 
 42     static const void* retain(const void* info)
 43     {
 44         return info;
 45     }
 46 
 47     NO_RETURN_DUE_TO_ASSERT
 48     static void release(const void*)
 49     {
 50         ASSERT_NOT_REACHED();
 51     }
 52 
 53     static CFStringRef copyDescription(const void*)
 54     {
 55         return CFSTR(&quot;WTF::String-based allocator&quot;);
 56     }
 57 
 58     static void* allocate(CFIndex size, CFOptionFlags, void*)
 59     {
 60         StringImpl* underlyingString = 0;
 61         if (isMainThread()) {
 62             underlyingString = currentString;
 63             if (underlyingString) {
 64                 currentString = 0;
 65                 underlyingString-&gt;ref(); // Balanced by call to deref in deallocate below.
 66             }
 67         }
<span class="line-modified"> 68         StringImpl** header = static_cast&lt;StringImpl**&gt;(StringWrapperCFAllocatorMalloc::malloc(sizeof(StringImpl*) + size));</span>
 69         *header = underlyingString;
 70         return header + 1;
 71     }
 72 
 73     static void* reallocate(void* pointer, CFIndex newSize, CFOptionFlags, void*)
 74     {
 75         size_t newAllocationSize = sizeof(StringImpl*) + newSize;
 76         StringImpl** header = static_cast&lt;StringImpl**&gt;(pointer) - 1;
 77         ASSERT(!*header);
<span class="line-modified"> 78         header = static_cast&lt;StringImpl**&gt;(StringWrapperCFAllocatorMalloc::realloc(header, newAllocationSize));</span>
 79         return header + 1;
 80     }
 81 
 82     static void deallocate(void* pointer, void*)
 83     {
 84         StringImpl** header = static_cast&lt;StringImpl**&gt;(pointer) - 1;
 85         StringImpl* underlyingString = *header;
 86         if (!underlyingString)
<span class="line-modified"> 87             StringWrapperCFAllocatorMalloc::free(header);</span>
 88         else {
 89             if (isMainThread()) {
 90                 underlyingString-&gt;deref(); // Balanced by call to ref in allocate above.
<span class="line-modified"> 91                 StringWrapperCFAllocatorMalloc::free(header);</span>
 92                 return;
 93             }
 94 
 95             callOnMainThread([header] {
 96                 StringImpl* underlyingString = *header;
 97                 ASSERT(underlyingString);
 98                 underlyingString-&gt;deref(); // Balanced by call to ref in allocate above.
<span class="line-modified"> 99                 StringWrapperCFAllocatorMalloc::free(header);</span>
100             });
101         }
102     }
103 
104     static CFIndex preferredSize(CFIndex size, CFOptionFlags, void*)
105     {
106         // FIXME: If FastMalloc provided a &quot;good size&quot; callback, we&#39;d want to use it here.
107         // Note that this optimization would help performance for strings created with the
108         // allocator that are mutable, and those typically are only created by callers who
109         // make a new string using the old string&#39;s allocator, such as some of the call
110         // sites in CFURL.
111         return size;
112     }
113 
114     static CFAllocatorRef create()
115     {
116         CFAllocatorContext context = { 0, 0, retain, release, copyDescription, allocate, reallocate, deallocate, preferredSize };
117         return CFAllocatorCreate(0, &amp;context);
118     }
119 
120     static CFAllocatorRef allocator()
121     {
122         static CFAllocatorRef allocator = create();
123         return allocator;
124     }
125 
126 }
127 
128 RetainPtr&lt;CFStringRef&gt; StringImpl::createCFString()
129 {
<span class="line-modified">130     if (!m_length || !isMainThread()) {</span>
131         if (is8Bit())
132             return adoptCF(CFStringCreateWithBytes(0, reinterpret_cast&lt;const UInt8*&gt;(characters8()), m_length, kCFStringEncodingISOLatin1, false));
133         return adoptCF(CFStringCreateWithCharacters(0, reinterpret_cast&lt;const UniChar*&gt;(characters16()), m_length));
134     }
135     CFAllocatorRef allocator = StringWrapperCFAllocator::allocator();
136 
137     // Put pointer to the StringImpl in a global so the allocator can store it with the CFString.
138     ASSERT(!StringWrapperCFAllocator::currentString);
139     StringWrapperCFAllocator::currentString = this;
140 
141     CFStringRef string;
142     if (is8Bit())
143         string = CFStringCreateWithBytesNoCopy(allocator, reinterpret_cast&lt;const UInt8*&gt;(characters8()), m_length, kCFStringEncodingISOLatin1, false, kCFAllocatorNull);
144     else
145         string = CFStringCreateWithCharactersNoCopy(allocator, reinterpret_cast&lt;const UniChar*&gt;(characters16()), m_length, kCFAllocatorNull);
146     // CoreFoundation might not have to allocate anything, we clear currentString in case we did not execute allocate().
147     StringWrapperCFAllocator::currentString = 0;
148 
149     return adoptCF(string);
150 }
</pre>
</td>
</tr>
</table>
<center><a href="../WTFString.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../cocoa/TextBreakIteratorInternalICUCocoa.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
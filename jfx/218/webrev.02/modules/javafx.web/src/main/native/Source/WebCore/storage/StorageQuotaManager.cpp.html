<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/storage/StorageQuotaManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;StorageQuotaManager.h&quot;
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &lt;wtf/Ref.h&gt;
 31 #include &lt;wtf/RefCounted.h&gt;
 32 #include &lt;wtf/threads/BinarySemaphore.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 Ref&lt;StorageQuotaManager&gt; StorageQuotaManager::create(uint64_t quota, UsageGetter&amp;&amp; usageGetter, QuotaIncreaseRequester&amp;&amp; quotaIncreaseRequester)
 37 {
 38     return adoptRef(*new StorageQuotaManager(quota, WTFMove(usageGetter), WTFMove(quotaIncreaseRequester)));
 39 }
 40 
 41 StorageQuotaManager::StorageQuotaManager(uint64_t quota, UsageGetter&amp;&amp; usageGetter, QuotaIncreaseRequester&amp;&amp; quotaIncreaseRequester)
 42     : m_quota(quota)
 43     , m_usageGetter(WTFMove(usageGetter))
 44     , m_quotaIncreaseRequester(WTFMove(quotaIncreaseRequester))
 45     , m_workQueue(WorkQueue::create(&quot;StorageQuotaManager Background Queue&quot;, WorkQueue::Type::Serial))
 46     , m_initialQuota(quota)
 47 {
 48 }
 49 
 50 void StorageQuotaManager::requestSpaceOnMainThread(uint64_t spaceRequested, RequestCallback&amp;&amp; callback)
 51 {
 52     ASSERT(isMainThread());
 53 
 54     // Fast path.
 55     if (m_quotaCountDownLock.tryLock()) {
 56         if (tryGrantRequest(spaceRequested)) {
 57             m_quotaCountDownLock.unlock();
 58             callback(Decision::Grant);
 59             return;
 60         }
 61         m_quotaCountDownLock.unlock();
 62     }
 63 
 64     m_workQueue-&gt;dispatch([this, protectedThis = makeRef(*this), spaceRequested, callback = WTFMove(callback)]() mutable {
 65         auto decision = requestSpaceOnBackgroundThread(spaceRequested);
 66         callOnMainThread([callback = WTFMove(callback), decision]() mutable {
 67             callback(decision);
 68         });
 69     });
 70 }
 71 
 72 StorageQuotaManager::Decision StorageQuotaManager::requestSpaceOnBackgroundThread(uint64_t spaceRequested)
 73 {
 74     ASSERT(!isMainThread());
 75 
 76     LockHolder locker(m_quotaCountDownLock);
 77 
 78     if (tryGrantRequest(spaceRequested))
 79         return Decision::Grant;
 80 
 81     m_usage = m_usageGetter();
 82     updateQuotaBasedOnUsage();
 83     m_quotaCountDown = m_usage &lt; m_quota ? m_quota - m_usage : 0;
 84     if (tryGrantRequest(spaceRequested))
 85         return Decision::Grant;
 86 
 87     // Block this thread until getting decsion for quota increase.
 88     BinarySemaphore semaphore;
 89     callOnMainThread([this, protectedThis = makeRef(*this), spaceRequested, &amp;semaphore]() mutable {
 90         RELEASE_LOG(Storage, &quot;%p - StorageQuotaManager asks for quota increase %&quot; PRIu64, this, spaceRequested);
 91         m_quotaIncreaseRequester(m_quota, m_usage, spaceRequested, [this, protectedThis = WTFMove(protectedThis), &amp;semaphore](Optional&lt;uint64_t&gt; newQuota) mutable {
 92             RELEASE_LOG(Storage, &quot;%p - StorageQuotaManager receives quota increase response %&quot; PRIu64, this, newQuota ? *newQuota : 0);
 93             ASSERT(isMainThread());
 94 
 95             if (newQuota)
 96                 m_quota = *newQuota;
 97 
 98             semaphore.signal();
 99         });
100     });
101 
102     semaphore.wait();
103 
104     m_usage = m_usageGetter();
105     m_quotaCountDown = m_usage &lt; m_quota ? m_quota - m_usage : 0;
106     return tryGrantRequest(spaceRequested) ? Decision::Grant : Decision::Deny;
107 }
108 
109 bool StorageQuotaManager::tryGrantRequest(uint64_t spaceRequested)
110 {
111     ASSERT(m_quotaCountDownLock.isLocked());
112     if (spaceRequested &lt;= m_quotaCountDown) {
113         m_quotaCountDown -= spaceRequested;
114         return true;
115     }
116     return false;
117 }
118 
119 void StorageQuotaManager::updateQuotaBasedOnUsage()
120 {
121     // When StorageQuotaManager is used for the first time, we want to make sure its initial quota is bigger than current disk usage,
122     // based on the assumption that the quota was increased to at least the disk usage under user&#39;s permission before.
123     ASSERT(m_quotaCountDownLock.isLocked());
124     if (!m_quotaUpdatedBasedOnUsage) {
125         m_quotaUpdatedBasedOnUsage = true;
126         auto defaultQuotaStep = m_quota / 10;
127         m_quota = std::max(m_quota, defaultQuotaStep * ((m_usage / defaultQuotaStep) + 1));
128     }
129 }
130 
131 void StorageQuotaManager::resetQuotaUpdatedBasedOnUsageForTesting()
132 {
133     LockHolder locker(m_quotaCountDownLock);
134     m_quota = m_initialQuota;
135     m_quotaCountDown = 0;
136     m_quotaUpdatedBasedOnUsage = false;
137 }
138 
139 void StorageQuotaManager::resetQuotaForTesting()
140 {
141     LockHolder locker(m_quotaCountDownLock);
142     m_quota = m_initialQuota;
143     m_quotaCountDown = 0;
144 }
145 
146 } // namespace WebCore
    </pre>
  </body>
</html>
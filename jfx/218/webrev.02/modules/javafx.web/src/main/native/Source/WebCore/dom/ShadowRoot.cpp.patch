diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp
@@ -28,11 +28,15 @@
 #include "config.h"
 #include "ShadowRoot.h"
 
 #include "CSSStyleSheet.h"
 #include "ElementTraversal.h"
+#include "HTMLParserIdioms.h"
 #include "HTMLSlotElement.h"
+#if ENABLE(PICTURE_IN_PICTURE_API)
+#include "NotImplemented.h"
+#endif
 #include "RenderElement.h"
 #include "RuntimeEnabledFeatures.h"
 #include "SlotAssignment.h"
 #include "StyleResolver.h"
 #include "StyleScope.h"
@@ -43,22 +47,25 @@
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(ShadowRoot);
 
 struct SameSizeAsShadowRoot : public DocumentFragment, public TreeScope {
-    unsigned countersAndFlags[1];
+    bool flags[4];
+    uint8_t mode;
     void* styleScope;
     void* styleSheetList;
     void* host;
     void* slotAssignment;
+    Optional<HashMap<AtomString, AtomString>> partMappings;
 };
 
 COMPILE_ASSERT(sizeof(ShadowRoot) == sizeof(SameSizeAsShadowRoot), shadowroot_should_stay_small);
 
-ShadowRoot::ShadowRoot(Document& document, ShadowRootMode type)
+ShadowRoot::ShadowRoot(Document& document, ShadowRootMode type, DelegatesFocus delegatesFocus)
     : DocumentFragment(document, CreateShadowRoot)
     , TreeScope(*this, document)
+    , m_delegatesFocus(delegatesFocus == DelegatesFocus::Yes)
     , m_type(type)
     , m_styleScope(makeUnique<Style::Scope>(*this))
 {
 }
 
@@ -250,16 +257,114 @@
     if (!m_slotAssignment)
         return nullptr;
     return m_slotAssignment->assignedNodesForSlot(slot, *this);
 }
 
+static Optional<std::pair<AtomString, AtomString>> parsePartMapping(StringView mappingString)
+{
+    const auto end = mappingString.length();
+
+    auto skipWhitespace = [&](auto position) {
+        while (position < end && isHTMLSpace(mappingString[position]))
+            ++position;
+        return position;
+    };
+
+    auto collectValue = [&](auto position) {
+        while (position < end && (!isHTMLSpace(mappingString[position]) && mappingString[position] != ':'))
+            ++position;
+        return position;
+    };
+
+    size_t begin = 0;
+    begin = skipWhitespace(begin);
+
+    auto firstPartEnd = collectValue(begin);
+    if (firstPartEnd == begin)
+        return { };
+
+    auto firstPart = mappingString.substring(begin, firstPartEnd - begin).toAtomString();
+
+    begin = skipWhitespace(firstPartEnd);
+    if (begin == end)
+        return std::make_pair(firstPart, firstPart);
+
+    if (mappingString[begin] != ':')
+        return { };
+
+    begin = skipWhitespace(begin + 1);
+
+    auto secondPartEnd = collectValue(begin);
+    if (secondPartEnd == begin)
+        return { };
+
+    auto secondPart = mappingString.substring(begin, secondPartEnd - begin).toAtomString();
+
+    begin = skipWhitespace(secondPartEnd);
+    if (begin != end)
+        return { };
+
+    return std::make_pair(firstPart, secondPart);
+}
+
+static ShadowRoot::PartMappings parsePartMappingsList(StringView mappingsListString)
+{
+    if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())
+        return { };
+
+    ShadowRoot::PartMappings mappings;
+
+    const auto end = mappingsListString.length();
+
+    size_t begin = 0;
+    while (begin < end) {
+        size_t mappingEnd = begin;
+        while (mappingEnd < end && mappingsListString[mappingEnd] != ',')
+            ++mappingEnd;
+
+        auto result = parsePartMapping(mappingsListString.substring(begin, mappingEnd - begin));
+        if (result)
+            mappings.add(result->first, Vector<AtomString, 1>()).iterator->value.append(result->second);
+
+        if (mappingEnd == end)
+            break;
+
+        begin = mappingEnd + 1;
+    }
+
+    return mappings;
+}
+
+const ShadowRoot::PartMappings& ShadowRoot::partMappings() const
+{
+    if (!m_partMappings) {
+        auto exportpartsValue = host()->attributeWithoutSynchronization(HTMLNames::exportpartsAttr);
+        m_partMappings = parsePartMappingsList(exportpartsValue);
+    }
+
+    return *m_partMappings;
+}
+
+void ShadowRoot::invalidatePartMappings()
+{
+    m_partMappings = { };
+}
+
 Vector<ShadowRoot*> assignedShadowRootsIfSlotted(const Node& node)
 {
     Vector<ShadowRoot*> result;
     for (auto* slot = node.assignedSlot(); slot; slot = slot->assignedSlot()) {
         ASSERT(slot->containingShadowRoot());
         result.append(slot->containingShadowRoot());
     }
     return result;
 }
 
+#if ENABLE(PICTURE_IN_PICTURE_API)
+HTMLVideoElement* ShadowRoot::pictureInPictureElement() const
+{
+    notImplemented();
+    return nullptr;
+}
+#endif
+
 }

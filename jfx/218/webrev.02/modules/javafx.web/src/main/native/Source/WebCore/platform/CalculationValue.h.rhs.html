<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &quot;Length.h&quot;
 34 #include &lt;memory&gt;
 35 #include &lt;wtf/Ref.h&gt;
 36 #include &lt;wtf/RefCounted.h&gt;
 37 #include &lt;wtf/Vector.h&gt;
 38 
 39 namespace WTF {
 40 class TextStream;
 41 }
 42 
 43 namespace WebCore {
 44 
 45 // Don&#39;t change these values; parsing uses them.
 46 enum class CalcOperator : uint8_t {
 47     Add = &#39;+&#39;,
 48     Subtract = &#39;-&#39;,
 49     Multiply = &#39;*&#39;,
 50     Divide = &#39;/&#39;,
 51     Min = 0,
<a name="1" id="anc1"></a><span class="line-modified"> 52     Max,</span>
<span class="line-added"> 53     Clamp,</span>
 54 };
 55 
 56 enum class CalcExpressionNodeType : uint8_t {
 57     Undefined,
 58     Number,
 59     Length,
 60     Operation,
<a name="2" id="anc2"></a><span class="line-added"> 61     Negation,</span>
<span class="line-added"> 62     Inversion,</span>
 63     BlendLength,
 64 };
 65 
 66 class CalcExpressionNode {
 67     WTF_MAKE_FAST_ALLOCATED;
 68 public:
 69     explicit CalcExpressionNode(CalcExpressionNodeType = CalcExpressionNodeType::Undefined);
 70     virtual ~CalcExpressionNode() = default;
 71 
 72     CalcExpressionNodeType type() const { return m_type; }
 73 
 74     virtual float evaluate(float maxValue) const = 0;
 75     virtual bool operator==(const CalcExpressionNode&amp;) const = 0;
 76     virtual void dump(WTF::TextStream&amp;) const = 0;
 77 
 78 private:
 79     CalcExpressionNodeType m_type;
 80 };
 81 
 82 class CalcExpressionNumber final : public CalcExpressionNode {
 83 public:
 84     explicit CalcExpressionNumber(float);
 85 
 86     float value() const { return m_value; }
 87 
 88 private:
 89     float evaluate(float) const override;
 90     bool operator==(const CalcExpressionNode&amp;) const override;
 91     void dump(WTF::TextStream&amp;) const override;
 92 
 93     float m_value;
 94 };
 95 
 96 class CalcExpressionLength final : public CalcExpressionNode {
 97 public:
 98     explicit CalcExpressionLength(Length);
 99 
100     const Length&amp; length() const { return m_length; }
101 
102 private:
103     float evaluate(float maxValue) const override;
104     bool operator==(const CalcExpressionNode&amp;) const override;
105     void dump(WTF::TextStream&amp;) const override;
106 
107     Length m_length;
108 };
109 
<a name="3" id="anc3"></a><span class="line-added">110 class CalcExpressionNegation final : public CalcExpressionNode {</span>
<span class="line-added">111 public:</span>
<span class="line-added">112     CalcExpressionNegation(std::unique_ptr&lt;CalcExpressionNode&gt;&amp;&amp; node)</span>
<span class="line-added">113         : CalcExpressionNode(CalcExpressionNodeType::Negation)</span>
<span class="line-added">114         , m_child(WTFMove(node))</span>
<span class="line-added">115     {</span>
<span class="line-added">116         ASSERT(m_child);</span>
<span class="line-added">117     }</span>
<span class="line-added">118 </span>
<span class="line-added">119     float evaluate(float maxValue) const final;</span>
<span class="line-added">120     bool operator==(const CalcExpressionNode&amp;) const final;</span>
<span class="line-added">121     void dump(WTF::TextStream&amp;) const final;</span>
<span class="line-added">122 </span>
<span class="line-added">123     const CalcExpressionNode* child() const { return m_child.get(); }</span>
<span class="line-added">124 </span>
<span class="line-added">125 private:</span>
<span class="line-added">126     std::unique_ptr&lt;CalcExpressionNode&gt; m_child;</span>
<span class="line-added">127 };</span>
<span class="line-added">128 </span>
<span class="line-added">129 bool operator==(const CalcExpressionNegation&amp;, const CalcExpressionNegation&amp;);</span>
<span class="line-added">130 </span>
<span class="line-added">131 class CalcExpressionInversion final : public CalcExpressionNode {</span>
<span class="line-added">132 public:</span>
<span class="line-added">133     CalcExpressionInversion(std::unique_ptr&lt;CalcExpressionNode&gt;&amp;&amp; node)</span>
<span class="line-added">134         : CalcExpressionNode(CalcExpressionNodeType::Inversion)</span>
<span class="line-added">135         , m_child(WTFMove(node))</span>
<span class="line-added">136     {</span>
<span class="line-added">137         ASSERT(m_child);</span>
<span class="line-added">138     }</span>
<span class="line-added">139 </span>
<span class="line-added">140     float evaluate(float maxValue) const final;</span>
<span class="line-added">141     bool operator==(const CalcExpressionNode&amp;) const final;</span>
<span class="line-added">142     void dump(WTF::TextStream&amp;) const final;</span>
<span class="line-added">143 </span>
<span class="line-added">144     const CalcExpressionNode* child() const { return m_child.get(); }</span>
<span class="line-added">145 </span>
<span class="line-added">146 private:</span>
<span class="line-added">147     std::unique_ptr&lt;CalcExpressionNode&gt; m_child;</span>
<span class="line-added">148 };</span>
<span class="line-added">149 </span>
<span class="line-added">150 bool operator==(const CalcExpressionInversion&amp;, const CalcExpressionInversion&amp;);</span>
<span class="line-added">151 </span>
152 class CalcExpressionOperation final : public CalcExpressionNode {
153 public:
154     CalcExpressionOperation(Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt;&amp;&amp; children, CalcOperator);
155 
156     CalcOperator getOperator() const { return m_operator; }
157 
158     const Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt;&amp; children() const { return m_children; }
159 
160 private:
161     float evaluate(float maxValue) const override;
162     bool operator==(const CalcExpressionNode&amp;) const override;
163     void dump(WTF::TextStream&amp;) const override;
164 
165     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; m_children;
166     CalcOperator m_operator;
167 };
168 
169 class CalcExpressionBlendLength final : public CalcExpressionNode {
170 public:
171     CalcExpressionBlendLength(Length from, Length to, float progress);
172 
173     const Length&amp; from() const { return m_from; }
174     const Length&amp; to() const { return m_to; }
175     float progress() const { return m_progress; }
176 
177 private:
178     float evaluate(float maxValue) const override;
179     bool operator==(const CalcExpressionNode&amp;) const override;
180     void dump(WTF::TextStream&amp;) const override;
181 
182     Length m_from;
183     Length m_to;
184     float m_progress;
185 };
186 
187 class CalculationValue : public RefCounted&lt;CalculationValue&gt; {
188 public:
189     WEBCORE_EXPORT static Ref&lt;CalculationValue&gt; create(std::unique_ptr&lt;CalcExpressionNode&gt;, ValueRange);
190     float evaluate(float maxValue) const;
191 
192     bool shouldClampToNonNegative() const { return m_shouldClampToNonNegative; }
193     const CalcExpressionNode&amp; expression() const { return *m_expression; }
194 
195 private:
196     CalculationValue(std::unique_ptr&lt;CalcExpressionNode&gt;, ValueRange);
197 
198     std::unique_ptr&lt;CalcExpressionNode&gt; m_expression;
199     bool m_shouldClampToNonNegative;
200 };
201 
202 inline CalcExpressionNode::CalcExpressionNode(CalcExpressionNodeType type)
203     : m_type(type)
204 {
205 }
206 
207 inline CalculationValue::CalculationValue(std::unique_ptr&lt;CalcExpressionNode&gt; expression, ValueRange range)
208     : m_expression(WTFMove(expression))
209     , m_shouldClampToNonNegative(range == ValueRangeNonNegative)
210 {
211 }
212 
213 inline bool operator==(const CalculationValue&amp; a, const CalculationValue&amp; b)
214 {
215     return a.expression() == b.expression();
216 }
217 
218 inline CalcExpressionNumber::CalcExpressionNumber(float value)
219     : CalcExpressionNode(CalcExpressionNodeType::Number)
220     , m_value(value)
221 {
222 }
223 
224 inline bool operator==(const CalcExpressionNumber&amp; a, const CalcExpressionNumber&amp; b)
225 {
226     return a.value() == b.value();
227 }
228 
<a name="4" id="anc4"></a>





229 inline CalcExpressionLength::CalcExpressionLength(Length length)
230     : CalcExpressionNode(CalcExpressionNodeType::Length)
231     , m_length(length)
232 {
233 }
234 
235 inline bool operator==(const CalcExpressionLength&amp; a, const CalcExpressionLength&amp; b)
236 {
237     return a.length() == b.length();
238 }
239 
<a name="5" id="anc5"></a>





240 inline CalcExpressionOperation::CalcExpressionOperation(Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt;&amp;&amp; children, CalcOperator op)
241     : CalcExpressionNode(CalcExpressionNodeType::Operation)
242     , m_children(WTFMove(children))
243     , m_operator(op)
244 {
245 }
246 
247 bool operator==(const CalcExpressionOperation&amp;, const CalcExpressionOperation&amp;);
248 
<a name="6" id="anc6"></a>





249 inline bool operator==(const CalcExpressionBlendLength&amp; a, const CalcExpressionBlendLength&amp; b)
250 {
251     return a.progress() == b.progress() &amp;&amp; a.from() == b.from() &amp;&amp; a.to() == b.to();
252 }
253 
<a name="7" id="anc7"></a>





254 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const CalculationValue&amp;);
255 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const CalcExpressionNode&amp;);
256 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, CalcOperator);
257 
258 } // namespace WebCore
<a name="8" id="anc8"></a><span class="line-added">259 </span>
<span class="line-added">260 #define SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(ToValueTypeName, predicate) \</span>
<span class="line-added">261 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \</span>
<span class="line-added">262     static bool isType(const WebCore::CalcExpressionNode&amp; node) { return node.predicate; } \</span>
<span class="line-added">263 SPECIALIZE_TYPE_TRAITS_END()</span>
<span class="line-added">264 </span>
<span class="line-added">265 SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionNumber, type() == WebCore::CalcExpressionNodeType::Number)</span>
<span class="line-added">266 SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionLength, type() == WebCore::CalcExpressionNodeType::Length)</span>
<span class="line-added">267 SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionOperation, type() == WebCore::CalcExpressionNodeType::Operation)</span>
<span class="line-added">268 SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionNegation, type() == WebCore::CalcExpressionNodeType::Negation)</span>
<span class="line-added">269 SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionInversion, type() == WebCore::CalcExpressionNodeType::Inversion)</span>
<span class="line-added">270 SPECIALIZE_TYPE_TRAITS_CALCEXPRESSION_NODE(CalcExpressionBlendLength, type() == WebCore::CalcExpressionNodeType::BlendLength)</span>
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
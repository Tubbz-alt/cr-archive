<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSToWasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../generateWasmOpsHeader.py.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSToWasm.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSToWasm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,26 ***</span>
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;CCallHelpers.h&quot;
  #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyRuntimeError.h&quot;
  #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmContextInlines.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmToJS.h&quot;
  
  namespace JSC { namespace Wasm {
  
<span class="line-modified">! std::unique_ptr&lt;InternalFunction&gt; createJSToWasmWrapper(CompilationContext&amp; compilationContext, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, unsigned functionIndex)</span>
  {
<span class="line-modified">!     CCallHelpers&amp; jit = *compilationContext.embedderEntrypointJIT;</span>
  
      auto result = makeUnique&lt;InternalFunction&gt;();
      jit.emitFunctionPrologue();
  
      // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
      jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))));
<span class="line-new-header">--- 28,108 ---</span>
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;CCallHelpers.h&quot;
  #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
<span class="line-added">+ #include &quot;FrameTracers.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyRuntimeError.h&quot;
  #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
  #include &quot;WasmContextInlines.h&quot;
<span class="line-added">+ #include &quot;WasmOperations.h&quot;</span>
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmToJS.h&quot;
  
  namespace JSC { namespace Wasm {
  
<span class="line-modified">! inline void boxWasmResult(CCallHelpers&amp; jit, Wasm::Type type, Reg src, JSValueRegs dst)</span>
  {
<span class="line-modified">!     switch (type) {</span>
<span class="line-added">+     case Wasm::Void:</span>
<span class="line-added">+         jit.moveTrustedValue(jsUndefined(), dst);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::Anyref:</span>
<span class="line-added">+     case Wasm::Funcref:</span>
<span class="line-added">+         jit.move(src.gpr(), dst.payloadGPR());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::I32:</span>
<span class="line-added">+         jit.zeroExtend32ToPtr(src.gpr(), dst.payloadGPR());</span>
<span class="line-added">+         jit.boxInt32(dst.payloadGPR(), dst, DoNotHaveTagRegisters);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::F32:</span>
<span class="line-added">+         jit.convertFloatToDouble(src.fpr(), src.fpr());</span>
<span class="line-added">+         FALLTHROUGH;</span>
<span class="line-added">+     case Wasm::F64: {</span>
<span class="line-added">+         jit.moveTrustedValue(jsNumber(pureNaN()), dst);</span>
<span class="line-added">+         auto isNaN = jit.branchIfNaN(src.fpr());</span>
<span class="line-added">+         jit.boxDouble(src.fpr(), dst, DoNotHaveTagRegisters);</span>
<span class="line-added">+         isNaN.link(&amp;jit);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         jit.breakpoint();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void marshallJSResult(CCallHelpers&amp; jit, const Signature&amp; signature, const CallInformation&amp; wasmFrameConvention, const RegisterAtOffsetList&amp; savedResultRegisters)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (signature.returnsVoid())</span>
<span class="line-added">+         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added">+     else if (signature.returnCount() == 1)</span>
<span class="line-added">+         boxWasmResult(jit, signature.returnType(0), wasmFrameConvention.results[0].reg(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         IndexingType indexingType = ArrayWithUndecided;</span>
<span class="line-added">+         JSValueRegs scratch = JSValueRegs { wasmCallingConvention().prologueScratchGPRs[1] };</span>
<span class="line-added">+         // We can use the first floating point register as a scratch since it will always be moved onto the stack before other values.</span>
<span class="line-added">+         FPRReg fprScratch = wasmCallingConvention().fprArgs[0].fpr();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; signature.returnCount(); ++i) {</span>
<span class="line-added">+             B3::ValueRep rep = wasmFrameConvention.results[i];</span>
<span class="line-added">+             Type type = signature.returnType(i);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (rep.isReg()) {</span>
<span class="line-added">+                 boxWasmResult(jit, signature.returnType(i), rep.reg(), scratch);</span>
<span class="line-added">+                 jit.storeValue(scratch, CCallHelpers::Address(CCallHelpers::stackPointerRegister, savedResultRegisters.find(rep.reg())-&gt;offset() + wasmFrameConvention.headerAndArgumentStackSizeInBytes));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 auto location = CCallHelpers::Address(CCallHelpers::stackPointerRegister, rep.offsetFromSP());</span>
<span class="line-added">+                 Reg tmp = type == F32 || type == F64 ? Reg(fprScratch) : Reg(scratch.gpr());</span>
<span class="line-added">+                 jit.load64ToReg(location, tmp);</span>
<span class="line-added">+                 boxWasmResult(jit, signature.returnType(i), tmp, scratch);</span>
<span class="line-added">+                 jit.storeValue(scratch, location);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             switch (type) {</span>
<span class="line-added">+             case Wasm::I32:</span>
<span class="line-added">+                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithInt32);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case Wasm::F32:</span>
<span class="line-added">+             case Wasm::F64:</span>
<span class="line-added">+                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithDouble);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithContiguous);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         GPRReg wasmContextInstanceGPR = PinnedRegisterInfo::get().wasmContextInstancePointer;</span>
<span class="line-added">+         if (Context::useFastTLS()) {</span>
<span class="line-added">+             wasmContextInstanceGPR = GPRInfo::argumentGPR1;</span>
<span class="line-added">+             static_assert(std::is_same_v&lt;Wasm::Instance*, typename FunctionTraits&lt;decltype(operationAllocateResultsArray)&gt;::ArgumentType&lt;1&gt;&gt;);</span>
<span class="line-added">+             jit.loadWasmContextInstance(wasmContextInstanceGPR);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.setupArguments&lt;decltype(operationAllocateResultsArray)&gt;(wasmContextInstanceGPR, CCallHelpers::TrustedImmPtr(&amp;signature), indexingType, CCallHelpers::stackPointerRegister);</span>
<span class="line-added">+         jit.callOperation(FunctionPtr&lt;OperationPtrTag&gt;(operationAllocateResultsArray));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
  
<span class="line-added">+ std::unique_ptr&lt;InternalFunction&gt; createJSToWasmWrapper(CCallHelpers&amp; jit, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, unsigned functionIndex)</span>
<span class="line-added">+ {</span>
      auto result = makeUnique&lt;InternalFunction&gt;();
      jit.emitFunctionPrologue();
  
      // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
      jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,48 ***</span>
      });
  
      const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
      RegisterSet toSave = pinnedRegs.toSave(mode);
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      unsigned toSaveSize = toSave.numberOfSetGPRs();
      // They should all be callee saves.
      toSave.filter(RegisterSet::calleeSaveRegisters());
      ASSERT(toSave.numberOfSetGPRs() == toSaveSize);
  #endif
  
      RegisterAtOffsetList registersToSpill(toSave, RegisterAtOffsetList::OffsetBaseType::FramePointerBased);
      result-&gt;entrypoint.calleeSaveRegisters = registersToSpill;
  
<span class="line-modified">!     unsigned totalFrameSize = registersToSpill.size() * sizeof(void*);</span>
<span class="line-modified">!     totalFrameSize += WasmCallingConvention::headerSizeInBytes();</span>
<span class="line-modified">!     totalFrameSize -= sizeof(CallerFrameAndPC);</span>
<span class="line-modified">!     unsigned numGPRs = 0;</span>
<span class="line-modified">!     unsigned numFPRs = 0;</span>
<span class="line-removed">-     bool argumentsIncludeI64 = false;</span>
<span class="line-removed">-     for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-removed">-         switch (signature.argument(i)) {</span>
<span class="line-removed">-         case Wasm::I64:</span>
<span class="line-removed">-             argumentsIncludeI64 = true;</span>
<span class="line-removed">-             FALLTHROUGH;</span>
<span class="line-removed">-         case Wasm::I32:</span>
<span class="line-removed">-         case Wasm::Anyref:</span>
<span class="line-removed">-         case Wasm::Funcref:</span>
<span class="line-removed">-             if (numGPRs &gt;= wasmCallingConvention().m_gprArgs.size())</span>
<span class="line-removed">-                 totalFrameSize += sizeof(void*);</span>
<span class="line-removed">-             ++numGPRs;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case Wasm::F32:</span>
<span class="line-removed">-         case Wasm::F64:</span>
<span class="line-removed">-             if (numFPRs &gt;= wasmCallingConvention().m_fprArgs.size())</span>
<span class="line-removed">-                 totalFrameSize += sizeof(void*);</span>
<span class="line-removed">-             ++numFPRs;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
      totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
      jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
  
      // We save all these registers regardless of having a memory or not.
<span class="line-new-header">--- 141,25 ---</span>
      });
  
      const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
      RegisterSet toSave = pinnedRegs.toSave(mode);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      unsigned toSaveSize = toSave.numberOfSetGPRs();
      // They should all be callee saves.
      toSave.filter(RegisterSet::calleeSaveRegisters());
      ASSERT(toSave.numberOfSetGPRs() == toSaveSize);
  #endif
  
      RegisterAtOffsetList registersToSpill(toSave, RegisterAtOffsetList::OffsetBaseType::FramePointerBased);
      result-&gt;entrypoint.calleeSaveRegisters = registersToSpill;
  
<span class="line-modified">!     size_t totalFrameSize = registersToSpill.size() * sizeof(CPURegister);</span>
<span class="line-modified">!     CallInformation wasmFrameConvention = wasmCallingConvention().callInformationFor(signature);</span>
<span class="line-modified">!     RegisterAtOffsetList savedResultRegisters = wasmFrameConvention.computeResultsOffsetList();</span>
<span class="line-modified">!     totalFrameSize += wasmFrameConvention.headerAndArgumentStackSizeInBytes;</span>
<span class="line-modified">!     totalFrameSize += savedResultRegisters.size() * sizeof(CPURegister);</span>
  
      totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
      jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
  
      // We save all these registers regardless of having a memory or not.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,100 ***</span>
          GPRReg reg = regAtOffset.reg().gpr();
          ptrdiff_t offset = regAtOffset.offset();
          jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
      }
  
<span class="line-modified">!     if (argumentsIncludeI64 || signature.returnType() == Wasm::I64) {</span>
          if (Context::useFastTLS())
              jit.loadWasmContextInstance(GPRInfo::argumentGPR2);
          else {
              // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s
              // instance as the first JS argument when we&#39;re not using fast TLS to hold the
              // Wasm::Context*&#39;s instance.
              jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::thisArgument * sizeof(EncodedJSValue)), GPRInfo::argumentGPR2);
              jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSWebAssemblyInstance::offsetOfInstance()), GPRInfo::argumentGPR2);
          }
  
<span class="line-modified">!         emitThrowWasmToJSException(jit, GPRInfo::argumentGPR2, argumentsIncludeI64 ? ExceptionType::I64ArgumentType : ExceptionType::I64ReturnType);</span>
          return result;
      }
  
      GPRReg wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
  
      {
<span class="line-modified">!         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));</span>
<span class="line-modified">!         numGPRs = 0;</span>
<span class="line-modified">!         numFPRs = 0;</span>
          // We&#39;re going to set the pinned registers after this. So
          // we can use this as a scratch for now since we saved it above.
          GPRReg scratchReg = pinnedRegs.baseMemoryPointer;
  
<span class="line-removed">-         ptrdiff_t jsOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s</span>
<span class="line-removed">-         // instance as the first JS argument when we&#39;re not using fast TLS to hold the</span>
<span class="line-removed">-         // Wasm::Context*&#39;s instance.</span>
          if (!Context::useFastTLS()) {
<span class="line-modified">!             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmContextInstanceGPR);</span>
              jit.loadPtr(CCallHelpers::Address(wasmContextInstanceGPR, JSWebAssemblyInstance::offsetOfInstance()), wasmContextInstanceGPR);
<span class="line-removed">-             jsOffset += sizeof(EncodedJSValue);</span>
          }
  
<span class="line-removed">-         ptrdiff_t wasmOffset = CallFrame::headerSizeInRegisters * sizeof(void*);</span>
          for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {
<span class="line-modified">!             switch (signature.argument(i)) {</span>
<span class="line-modified">!             case Wasm::I32:</span>
<span class="line-modified">!             case Wasm::I64:</span>
<span class="line-modified">!             case Wasm::Funcref:</span>
<span class="line-modified">!             case Wasm::Anyref:</span>
<span class="line-modified">!                 if (numGPRs &gt;= wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-modified">!                     if (signature.argument(i) == Wasm::I32) {</span>
<span class="line-modified">!                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">-                         jit.store32(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">-                         jit.store64(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     wasmOffset += sizeof(void*);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     if (signature.argument(i) == Wasm::I32)</span>
<span class="line-removed">-                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 ++numGPRs;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case Wasm::F32:</span>
<span class="line-removed">-             case Wasm::F64:</span>
<span class="line-removed">-                 if (numFPRs &gt;= wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-removed">-                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-removed">-                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">-                         jit.store32(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">-                         jit.store64(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     wasmOffset += sizeof(void*);</span>
                  } else {
<span class="line-modified">!                     if (signature.argument(i) == Wasm::F32)</span>
<span class="line-modified">!                         jit.loadFloat(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_fprArgs[numFPRs].fpr());</span>
<span class="line-removed">-                     else</span>
<span class="line-removed">-                         jit.loadDouble(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_fprArgs[numFPRs].fpr());</span>
                  }
<span class="line-modified">!                 ++numFPRs;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 RELEASE_ASSERT_NOT_REACHED();</span>
              }
<span class="line-removed">- </span>
<span class="line-removed">-             jsOffset += sizeof(EncodedJSValue);</span>
          }
      }
  
      if (!!info.memory) {
          GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
<span class="line-modified">!         GPRReg scratchOrSize = wasmCallingConventionAir().prologueScratch(0);</span>
  
          if (Context::useFastTLS())
              jit.loadWasmContextInstance(baseMemory);
  
          GPRReg currentInstanceGPR = Context::useFastTLS() ? baseMemory : wasmContextInstanceGPR;
<span class="line-new-header">--- 170,66 ---</span>
          GPRReg reg = regAtOffset.reg().gpr();
          ptrdiff_t offset = regAtOffset.offset();
          jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
      }
  
<span class="line-modified">!     if (wasmFrameConvention.argumentsIncludeI64 || wasmFrameConvention.resultsIncludeI64) {</span>
          if (Context::useFastTLS())
              jit.loadWasmContextInstance(GPRInfo::argumentGPR2);
          else {
              // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s
              // instance as the first JS argument when we&#39;re not using fast TLS to hold the
              // Wasm::Context*&#39;s instance.
              jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::thisArgument * sizeof(EncodedJSValue)), GPRInfo::argumentGPR2);
              jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSWebAssemblyInstance::offsetOfInstance()), GPRInfo::argumentGPR2);
          }
  
<span class="line-modified">!         emitThrowWasmToJSException(jit, GPRInfo::argumentGPR2, wasmFrameConvention.argumentsIncludeI64 ? ExceptionType::I64ArgumentType : ExceptionType::I64ReturnType);</span>
          return result;
      }
  
      GPRReg wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
  
      {
<span class="line-modified">!         CallInformation jsFrameConvention = jsCallingConvention().callInformationFor(signature, CallRole::Callee);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, 0);</span>
<span class="line-added">+ </span>
          // We&#39;re going to set the pinned registers after this. So
          // we can use this as a scratch for now since we saved it above.
          GPRReg scratchReg = pinnedRegs.baseMemoryPointer;
  
          if (!Context::useFastTLS()) {
<span class="line-modified">!             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, JSCallingConvention::instanceStackOffset), wasmContextInstanceGPR);</span>
              jit.loadPtr(CCallHelpers::Address(wasmContextInstanceGPR, JSWebAssemblyInstance::offsetOfInstance()), wasmContextInstanceGPR);
          }
  
          for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {
<span class="line-modified">!             RELEASE_ASSERT(jsFrameConvention.params[i].isStack());</span>
<span class="line-modified">! </span>
<span class="line-modified">!             Type type = signature.argument(i);</span>
<span class="line-modified">!             CCallHelpers::Address jsParam(GPRInfo::callFrameRegister, jsFrameConvention.params[i].offsetFromFP());</span>
<span class="line-modified">!             if (wasmFrameConvention.params[i].isStackArgument()) {</span>
<span class="line-modified">!                 if (type == Wasm::I32 || type == Wasm::F32) {</span>
<span class="line-modified">!                     jit.load32(jsParam, scratchReg);</span>
<span class="line-modified">!                     jit.store32(scratchReg, calleeFrame.withOffset(wasmFrameConvention.params[i].offsetFromSP()));</span>
                  } else {
<span class="line-modified">!                     jit.load64(jsParam, scratchReg);</span>
<span class="line-modified">!                     jit.store64(scratchReg, calleeFrame.withOffset(wasmFrameConvention.params[i].offsetFromSP()));</span>
                  }
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 if (type == Wasm::I32 || type == Wasm::F32)</span>
<span class="line-modified">!                     jit.load32ToReg(jsParam, wasmFrameConvention.params[i].reg());</span>
<span class="line-modified">!                 else</span>
<span class="line-added">+                     jit.load64ToReg(jsParam, wasmFrameConvention.params[i].reg());</span>
              }
          }
      }
  
      if (!!info.memory) {
          GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
<span class="line-modified">!         GPRReg scratchOrSize = wasmCallingConvention().prologueScratchGPRs[0];</span>
  
          if (Context::useFastTLS())
              jit.loadWasmContextInstance(baseMemory);
  
          GPRReg currentInstanceGPR = Context::useFastTLS() ? baseMemory : wasmContextInstanceGPR;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,46 ***</span>
      ASSERT(functionIndexSpace &lt; info.functionIndexSpaceSize());
      jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndexSpace] (LinkBuffer&amp; linkBuffer) {
          unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndexSpace });
      });
  
      for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
          GPRReg reg = regAtOffset.reg().gpr();
          ASSERT(reg != GPRInfo::returnValueGPR);
          ptrdiff_t offset = regAtOffset.offset();
          jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
      }
  
<span class="line-removed">-     switch (signature.returnType()) {</span>
<span class="line-removed">-     case Wasm::Void:</span>
<span class="line-removed">-         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case Wasm::Anyref:</span>
<span class="line-removed">-     case Wasm::Funcref:</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case Wasm::I32:</span>
<span class="line-removed">-         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-removed">-         jit.boxInt32(GPRInfo::returnValueGPR, JSValueRegs { GPRInfo::returnValueGPR }, DoNotHaveTagRegisters);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case Wasm::F32:</span>
<span class="line-removed">-         jit.convertFloatToDouble(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">-         FALLTHROUGH;</span>
<span class="line-removed">-     case Wasm::F64: {</span>
<span class="line-removed">-         jit.moveTrustedValue(jsNumber(pureNaN()), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">-         auto isNaN = jit.branchIfNaN(FPRInfo::returnValueFPR);</span>
<span class="line-removed">-         jit.boxDouble(FPRInfo::returnValueFPR, JSValueRegs { GPRInfo::returnValueGPR }, DoNotHaveTagRegisters);</span>
<span class="line-removed">-         isNaN.link(&amp;jit);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     case Wasm::I64:</span>
<span class="line-removed">-     case Wasm::Func:</span>
<span class="line-removed">-         jit.breakpoint();</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      jit.emitFunctionEpilogue();
      jit.ret();
  
      return result;
  }
<span class="line-new-header">--- 251,19 ---</span>
      ASSERT(functionIndexSpace &lt; info.functionIndexSpaceSize());
      jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndexSpace] (LinkBuffer&amp; linkBuffer) {
          unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndexSpace });
      });
  
<span class="line-added">+     marshallJSResult(jit, signature, wasmFrameConvention, savedResultRegisters);</span>
<span class="line-added">+ </span>
      for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
          GPRReg reg = regAtOffset.reg().gpr();
          ASSERT(reg != GPRInfo::returnValueGPR);
          ptrdiff_t offset = regAtOffset.offset();
          jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
      }
  
      jit.emitFunctionEpilogue();
      jit.ret();
  
      return result;
  }
</pre>
<center><a href="../generateWasmOpsHeader.py.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSToWasm.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
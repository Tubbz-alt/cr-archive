<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSSourceCode.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSString.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -62,15 +62,10 @@</span>
      ASSERT(string-&gt;length() == m_length);
      m_strings.clear();
      m_strings.append(string);
  }
  
<span class="udiff-line-removed">- void JSString::destroy(JSCell* cell)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     static_cast&lt;JSString*&gt;(cell)-&gt;JSString::~JSString();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void JSString::dumpToStream(const JSCell* cell, PrintStream&amp; out)
  {
      VM&amp; vm = cell-&gt;vm();
      const JSString* thisObject = jsCast&lt;const JSString*&gt;(cell);
      out.printf(&quot;&lt;%p, %s, [%u], &quot;, thisObject, thisObject-&gt;className(vm), thisObject-&gt;length());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -89,17 +84,17 @@</span>
          }
      }
      out.printf(&quot;&gt;&quot;);
  }
  
<span class="udiff-line-modified-removed">- bool JSString::equalSlowCase(ExecState* exec, JSString* other) const</span>
<span class="udiff-line-modified-added">+ bool JSString::equalSlowCase(JSGlobalObject* globalObject, JSString* other) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     String str1 = value(exec);</span>
<span class="udiff-line-modified-added">+     String str1 = value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
<span class="udiff-line-modified-removed">-     String str2 = other-&gt;value(exec);</span>
<span class="udiff-line-modified-added">+     String str2 = other-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      return WTF::equal(*str1.impl(), *str2.impl());
  }
  
  size_t JSString::estimatedSize(JSCell* cell, VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -147,62 +142,44 @@</span>
      }
      if (StringImpl* impl = bitwise_cast&lt;StringImpl*&gt;(pointer))
          visitor.reportExtraMemoryVisited(impl-&gt;costDuringGC());
  }
  
<span class="udiff-line-modified-removed">- static const unsigned maxLengthForOnStackResolve = 2048;</span>
<span class="udiff-line-modified-added">+ static constexpr unsigned maxLengthForOnStackResolve = 2048;</span>
  
  void JSRopeString::resolveRopeInternal8(LChar* buffer) const
  {
      if (isSubstring()) {
          StringImpl::copyCharacters(buffer, substringBase()-&gt;valueInternal().characters8() + substringOffset(), length());
          return;
      }
  
<span class="udiff-line-modified-removed">-     resolveRopeInternal8NoSubstring(buffer);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JSRopeString::resolveRopeInternal8NoSubstring(LChar* buffer) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {</span>
<span class="udiff-line-removed">-         if (fiber(i)-&gt;isRope()) {</span>
<span class="udiff-line-removed">-             resolveRopeSlowCase8(buffer);</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     LChar* position = buffer;</span>
<span class="udiff-line-removed">-     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {</span>
<span class="udiff-line-removed">-         const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();</span>
<span class="udiff-line-removed">-         unsigned length = fiberString.length();</span>
<span class="udiff-line-removed">-         StringImpl::copyCharacters(position, fiberString.characters8(), length);</span>
<span class="udiff-line-removed">-         position += length;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     ASSERT((buffer + length()) == position);</span>
<span class="udiff-line-modified-added">+     resolveRopeInternalNoSubstring(buffer);</span>
  }
  
  void JSRopeString::resolveRopeInternal16(UChar* buffer) const
  {
      if (isSubstring()) {
          StringImpl::copyCharacters(
              buffer, substringBase()-&gt;valueInternal().characters16() + substringOffset(), length());
          return;
      }
  
<span class="udiff-line-modified-removed">-     resolveRopeInternal16NoSubstring(buffer);</span>
<span class="udiff-line-modified-added">+     resolveRopeInternalNoSubstring(buffer);</span>
  }
  
<span class="udiff-line-modified-removed">- void JSRopeString::resolveRopeInternal16NoSubstring(UChar* buffer) const</span>
<span class="udiff-line-modified-added">+ template&lt;typename CharacterType&gt;</span>
<span class="udiff-line-added">+ void JSRopeString::resolveRopeInternalNoSubstring(CharacterType* buffer) const</span>
  {
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
          if (fiber(i)-&gt;isRope()) {
              resolveRopeSlowCase(buffer);
              return;
          }
      }
  
<span class="udiff-line-modified-removed">-     UChar* position = buffer;</span>
<span class="udiff-line-modified-added">+     CharacterType* position = buffer;</span>
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
          const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();
          unsigned length = fiberString.length();
          if (fiberString.is8Bit())
              StringImpl::copyCharacters(position, fiberString.characters8(), length);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,18 +188,18 @@</span>
          position += length;
      }
      ASSERT((buffer + length()) == position);
  }
  
<span class="udiff-line-modified-removed">- AtomString JSRopeString::resolveRopeToAtomString(ExecState* exec) const</span>
<span class="udiff-line-modified-added">+ AtomString JSRopeString::resolveRopeToAtomString(JSGlobalObject* globalObject) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (length() &gt; maxLengthForOnStackResolve) {
          scope.release();
<span class="udiff-line-modified-removed">-         return resolveRopeWithFunction(exec, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
<span class="udiff-line-modified-added">+         return resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
              return AtomStringImpl::add(newImpl.ptr());
          });
      }
  
      if (is8Bit()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -251,18 +228,18 @@</span>
      static_assert(sizeof(String) == sizeof(RefPtr&lt;StringImpl&gt;), &quot;JSString&#39;s String initialization must be done in one pointer move.&quot;);
      // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
      ASSERT(!JSString::isRope());
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(ExecState* exec) const</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(JSGlobalObject* globalObject) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (length() &gt; maxLengthForOnStackResolve) {
          RefPtr&lt;AtomStringImpl&gt; existingAtomString;
<span class="udiff-line-modified-removed">-         resolveRopeWithFunction(exec, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
<span class="udiff-line-modified-added">+         resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
              existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
              if (existingAtomString)
                  return makeRef(*existingAtomString);
              return WTFMove(newImpl);
          });
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -288,11 +265,11 @@</span>
  
      return nullptr;
  }
  
  template&lt;typename Function&gt;
<span class="udiff-line-modified-removed">- const String&amp; JSRopeString::resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&amp;&amp; function) const</span>
<span class="udiff-line-modified-added">+ const String&amp; JSRopeString::resolveRopeWithFunction(JSGlobalObject* nullOrGlobalObjectForOOM, Function&amp;&amp; function) const</span>
  {
      ASSERT(isRope());
  
      VM&amp; vm = this-&gt;vm();
      if (isSubstring()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -304,36 +281,36 @@</span>
  
      if (is8Bit()) {
          LChar* buffer;
          auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
          if (!newImpl) {
<span class="udiff-line-modified-removed">-             outOfMemory(nullOrExecForOOM);</span>
<span class="udiff-line-modified-added">+             outOfMemory(nullOrGlobalObjectForOOM);</span>
              return nullString();
          }
          vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
  
<span class="udiff-line-modified-removed">-         resolveRopeInternal8NoSubstring(buffer);</span>
<span class="udiff-line-modified-added">+         resolveRopeInternalNoSubstring(buffer);</span>
          convertToNonRope(function(newImpl.releaseNonNull()));
          return valueInternal();
      }
  
      UChar* buffer;
      auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
      if (!newImpl) {
<span class="udiff-line-modified-removed">-         outOfMemory(nullOrExecForOOM);</span>
<span class="udiff-line-modified-added">+         outOfMemory(nullOrGlobalObjectForOOM);</span>
          return nullString();
      }
      vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
  
<span class="udiff-line-modified-removed">-     resolveRopeInternal16NoSubstring(buffer);</span>
<span class="udiff-line-modified-added">+     resolveRopeInternalNoSubstring(buffer);</span>
      convertToNonRope(function(newImpl.releaseNonNull()));
      return valueInternal();
  }
  
<span class="udiff-line-modified-removed">- const String&amp; JSRopeString::resolveRope(ExecState* nullOrExecForOOM) const</span>
<span class="udiff-line-modified-added">+ const String&amp; JSRopeString::resolveRope(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
  {
<span class="udiff-line-modified-removed">-     return resolveRopeWithFunction(nullOrExecForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
<span class="udiff-line-modified-added">+     return resolveRopeWithFunction(nullOrGlobalObjectForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
          return WTFMove(newImpl);
      });
  }
  
  // Overview: These functions convert a JSString from holding a string in rope form
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -344,49 +321,14 @@</span>
  // in this fashion should minimize work queue size.  (If we built the queue forwards
  // we would likely have to place all of the constituent StringImpls into the
  // Vector before performing any concatenation, but by working backwards we likely
  // only fill the queue with the number of substrings at any given level in a
  // rope-of-ropes.)
<span class="udiff-line-modified-removed">- void JSRopeString::resolveRopeSlowCase8(LChar* buffer) const</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-removed">-     LChar* position = buffer + length(); // We will be working backwards over the rope.</span>
<span class="udiff-line-removed">-     Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // Putting strings into a Vector is only OK because there are no GC points in this method.</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)</span>
<span class="udiff-line-removed">-         workQueue.append(fiber(i));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     while (!workQueue.isEmpty()) {</span>
<span class="udiff-line-removed">-         JSString* currentFiber = workQueue.last();</span>
<span class="udiff-line-removed">-         workQueue.removeLast();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         const LChar* characters;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (currentFiber-&gt;isRope()) {</span>
<span class="udiff-line-removed">-             JSRopeString* currentFiberAsRope = static_cast&lt;JSRopeString*&gt;(currentFiber);</span>
<span class="udiff-line-removed">-             if (!currentFiberAsRope-&gt;isSubstring()) {</span>
<span class="udiff-line-removed">-                 for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; currentFiberAsRope-&gt;fiber(i); ++i)</span>
<span class="udiff-line-removed">-                     workQueue.append(currentFiberAsRope-&gt;fiber(i));</span>
<span class="udiff-line-removed">-                 continue;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             ASSERT(!currentFiberAsRope-&gt;substringBase()-&gt;isRope());</span>
<span class="udiff-line-removed">-             characters =</span>
<span class="udiff-line-removed">-                 currentFiberAsRope-&gt;substringBase()-&gt;valueInternal().characters8() +</span>
<span class="udiff-line-removed">-                 currentFiberAsRope-&gt;substringOffset();</span>
<span class="udiff-line-removed">-         } else</span>
<span class="udiff-line-removed">-             characters = currentFiber-&gt;valueInternal().characters8();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         unsigned length = currentFiber-&gt;length();</span>
<span class="udiff-line-removed">-         position -= length;</span>
<span class="udiff-line-removed">-         StringImpl::copyCharacters(position, characters, length);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     ASSERT(buffer == position);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void JSRopeString::resolveRopeSlowCase(UChar* buffer) const</span>
<span class="udiff-line-modified-added">+ template&lt;typename CharacterType&gt;</span>
<span class="udiff-line-modified-added">+ void JSRopeString::resolveRopeSlowCase(CharacterType* buffer) const</span>
  {
<span class="udiff-line-modified-removed">-     UChar* position = buffer + length(); // We will be working backwards over the rope.</span>
<span class="udiff-line-modified-added">+     CharacterType* position = buffer + length(); // We will be working backwards over the rope.</span>
      Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
  
      for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)
          workQueue.append(fiber(i));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -424,41 +366,41 @@</span>
      }
  
      ASSERT(buffer == position);
  }
  
<span class="udiff-line-modified-removed">- void JSRopeString::outOfMemory(ExecState* nullOrExecForOOM) const</span>
<span class="udiff-line-modified-added">+ void JSRopeString::outOfMemory(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
  {
      ASSERT(isRope());
<span class="udiff-line-modified-removed">-     if (nullOrExecForOOM) {</span>
<span class="udiff-line-modified-removed">-         VM&amp; vm = nullOrExecForOOM-&gt;vm();</span>
<span class="udiff-line-modified-added">+     if (nullOrGlobalObjectForOOM) {</span>
<span class="udiff-line-modified-added">+         VM&amp; vm = nullOrGlobalObjectForOOM-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-         throwOutOfMemoryError(nullOrExecForOOM, scope);</span>
<span class="udiff-line-modified-added">+         throwOutOfMemoryError(nullOrGlobalObjectForOOM, scope);</span>
      }
  }
  
<span class="udiff-line-modified-removed">- JSValue JSString::toPrimitive(ExecState*, PreferredPrimitiveType) const</span>
<span class="udiff-line-modified-added">+ JSValue JSString::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
  {
      return const_cast&lt;JSString*&gt;(this);
  }
  
<span class="udiff-line-modified-removed">- bool JSString::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
<span class="udiff-line-modified-added">+ bool JSString::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     StringView view = unsafeView(exec);</span>
<span class="udiff-line-modified-added">+     StringView view = unsafeView(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      result = this;
      number = jsToNumber(view);
      return false;
  }
  
<span class="udiff-line-modified-removed">- double JSString::toNumber(ExecState* exec) const</span>
<span class="udiff-line-modified-added">+ double JSString::toNumber(JSGlobalObject* globalObject) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="udiff-line-modified-removed">-     StringView view = unsafeView(exec);</span>
<span class="udiff-line-modified-added">+     StringView view = unsafeView(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, 0);
      return jsToNumber(view);
  }
  
  inline StringObject* StringObject::create(VM&amp; vm, JSGlobalObject* globalObject, JSString* string)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,33 +408,33 @@</span>
      StringObject* object = new (NotNull, allocateCell&lt;StringObject&gt;(vm.heap)) StringObject(vm, globalObject-&gt;stringObjectStructure());
      object-&gt;finishCreation(vm, string);
      return object;
  }
  
<span class="udiff-line-modified-removed">- JSObject* JSString::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
<span class="udiff-line-modified-added">+ JSObject* JSString::toObject(JSGlobalObject* globalObject) const</span>
  {
<span class="udiff-line-modified-removed">-     return StringObject::create(exec-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
<span class="udiff-line-modified-added">+     return StringObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
  }
  
<span class="udiff-line-modified-removed">- JSValue JSString::toThis(JSCell* cell, ExecState* exec, ECMAMode ecmaMode)</span>
<span class="udiff-line-modified-added">+ JSValue JSString::toThis(JSCell* cell, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
  {
      if (ecmaMode == StrictMode)
          return cell;
<span class="udiff-line-modified-removed">-     return StringObject::create(exec-&gt;vm(), exec-&gt;lexicalGlobalObject(), asString(cell));</span>
<span class="udiff-line-modified-added">+     return StringObject::create(globalObject-&gt;vm(), globalObject, asString(cell));</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSString::getStringPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
<span class="udiff-line-modified-added">+ bool JSString::getStringPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      if (propertyName == vm.propertyNames-&gt;length) {
          descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
          return true;
      }
  
      Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
      if (index &amp;&amp; index.value() &lt; length()) {
<span class="udiff-line-modified-removed">-         descriptor.setDescriptor(getIndex(exec, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
<span class="udiff-line-modified-added">+         descriptor.setDescriptor(getIndex(globalObject, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
          return true;
      }
  
      return false;
  }
</pre>
<center><a href="JSSourceCode.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSString.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
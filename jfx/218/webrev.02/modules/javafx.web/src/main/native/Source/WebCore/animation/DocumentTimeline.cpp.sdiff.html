<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DeclarativeAnimation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentTimeline.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DocumentTimeline.h&quot;
 28 
<span class="line-modified"> 29 #include &quot;AnimationPlaybackEvent.h&quot;</span>
 30 #include &quot;CSSAnimation.h&quot;
<span class="line-removed"> 31 #include &quot;CSSPropertyAnimation.h&quot;</span>
 32 #include &quot;CSSTransition.h&quot;
 33 #include &quot;DOMWindow.h&quot;
 34 #include &quot;DeclarativeAnimation.h&quot;
 35 #include &quot;Document.h&quot;


 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;KeyframeEffect.h&quot;
<span class="line-modified"> 38 #include &quot;Microtasks.h&quot;</span>
 39 #include &quot;Node.h&quot;
 40 #include &quot;Page.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderElement.h&quot;
 43 #include &quot;RenderLayer.h&quot;
 44 #include &quot;RenderLayerBacking.h&quot;


 45 
 46 static const Seconds defaultAnimationInterval { 15_ms };
 47 static const Seconds throttledAnimationInterval { 30_ms };
 48 
 49 namespace WebCore {
 50 
 51 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document)
 52 {
 53     return adoptRef(*new DocumentTimeline(document, 0_s));
 54 }
 55 
 56 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document, DocumentTimelineOptions&amp;&amp; options)
 57 {
 58     return adoptRef(*new DocumentTimeline(document, Seconds::fromMilliseconds(options.originTime)));
 59 }
 60 
 61 DocumentTimeline::DocumentTimeline(Document&amp; document, Seconds originTime)
 62     : AnimationTimeline()
 63     , m_tickScheduleTimer(*this, &amp;DocumentTimeline::scheduleAnimationResolution)
<span class="line-modified"> 64     , m_document(&amp;document)</span>
 65     , m_originTime(originTime)
 66 {
<span class="line-modified"> 67     if (m_document &amp;&amp; m_document-&gt;page() &amp;&amp; !m_document-&gt;page()-&gt;isVisible())</span>
<span class="line-modified"> 68         suspendAnimations();</span>



 69 }
 70 
<span class="line-modified"> 71 DocumentTimeline::~DocumentTimeline() = default;</span>




 72 
 73 void DocumentTimeline::detachFromDocument()
 74 {





 75     m_currentTimeClearingTaskQueue.close();
 76     m_elementsWithRunningAcceleratedAnimations.clear();
 77 
 78     auto&amp; animationsToRemove = m_animations;
 79     while (!animationsToRemove.isEmpty())
 80         animationsToRemove.first()-&gt;remove();
 81 
<span class="line-modified"> 82     unscheduleAnimationResolution();</span>
 83     m_document = nullptr;
 84 }
 85 
 86 static inline bool compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(Element* lhsOwningElement, Element* rhsOwningElement)
 87 {
 88     // With regard to pseudo-elements, the sort order is as follows:
 89     //     - element
 90     //     - ::before
 91     //     - ::after
 92     //     - element children
 93 
 94     // We could be comparing two pseudo-elements that are hosted on the same element.
 95     if (is&lt;PseudoElement&gt;(lhsOwningElement) &amp;&amp; is&lt;PseudoElement&gt;(rhsOwningElement)) {
 96         auto* lhsPseudoElement = downcast&lt;PseudoElement&gt;(lhsOwningElement);
 97         auto* rhsPseudoElement = downcast&lt;PseudoElement&gt;(rhsOwningElement);
 98         if (lhsPseudoElement-&gt;hostElement() == rhsPseudoElement-&gt;hostElement())
 99             return lhsPseudoElement-&gt;isBeforePseudoElement();
100     }
101 
102     // Or comparing a pseudo-element that is compared to another non-pseudo element, in which case
</pre>
<hr />
<pre>
159         // Otherwise, if A and B have different transition generation values, sort by their corresponding transition generation in ascending order.
160         if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())
161             return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();
162 
163         // Otherwise, sort A and B in ascending order by the Unicode codepoints that make up the expanded transition property name of each transition
164         // (i.e. without attempting case conversion and such that ‘-moz-column-width’ sorts before ‘column-width’).
165         return lhsTransition-&gt;transitionProperty().utf8() &lt; rhsTransition-&gt;transitionProperty().utf8();
166     });
167 
168     // Now sort CSS Animations by their composite order.
169     std::sort(cssAnimations.begin(), cssAnimations.end(), [](auto&amp; lhs, auto&amp; rhs) {
170         // https://drafts.csswg.org/css-animations-2/#animation-composite-order
171         auto* lhsOwningElement = downcast&lt;CSSAnimation&gt;(lhs.get())-&gt;owningElement();
172         auto* rhsOwningElement = downcast&lt;CSSAnimation&gt;(rhs.get())-&gt;owningElement();
173 
174         // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
175         if (lhsOwningElement != rhsOwningElement)
176             return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
177 
178         // Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
<span class="line-modified">179         // In our case, this matches the time at which the animations were created and thus their relative position in m_allAnimations.</span>
<span class="line-modified">180         return false;</span>



181     });
182 
183     // Finally, we can concatenate the sorted CSS Transitions, CSS Animations and Web Animations in their relative composite order.
184     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
185     animations.appendRange(cssTransitions.begin(), cssTransitions.end());
186     animations.appendRange(cssAnimations.begin(), cssAnimations.end());
187     animations.appendRange(webAnimations.begin(), webAnimations.end());
188     return animations;
189 }
190 
191 void DocumentTimeline::updateThrottlingState()
192 {
193     scheduleAnimationResolution();
194 }
195 
196 Seconds DocumentTimeline::animationInterval() const
197 {
198     if (!m_document || !m_document-&gt;page())
199         return Seconds::infinity();
200     return m_document-&gt;page()-&gt;isLowPowerModeEnabled() ? throttledAnimationInterval : defaultAnimationInterval;
201 }
202 
203 void DocumentTimeline::suspendAnimations()
204 {
205     if (animationsAreSuspended())
206         return;
207 
208     if (!m_cachedCurrentTime)
209         m_cachedCurrentTime = Seconds(liveCurrentTime());
210 
211     for (const auto&amp; animation : m_animations)
212         animation-&gt;setSuspended(true);
213 
214     m_isSuspended = true;
215 
216     applyPendingAcceleratedAnimations();
217 
<span class="line-modified">218     unscheduleAnimationResolution();</span>
219 }
220 
221 void DocumentTimeline::resumeAnimations()
222 {
223     if (!animationsAreSuspended())
224         return;
225 
226     m_cachedCurrentTime = WTF::nullopt;
227 
228     m_isSuspended = false;
229 
230     for (const auto&amp; animation : m_animations)
231         animation-&gt;setSuspended(false);
232 
233     scheduleAnimationResolution();
234 }
235 
236 bool DocumentTimeline::animationsAreSuspended()
237 {
238     return m_isSuspended;
</pre>
<hr />
<pre>
256 Optional&lt;Seconds&gt; DocumentTimeline::currentTime()
257 {
258     if (!m_document || !m_document-&gt;domWindow())
259         return AnimationTimeline::currentTime();
260 
261     auto&amp; mainDocumentTimeline = m_document-&gt;timeline();
262     if (&amp;mainDocumentTimeline != this) {
263         if (auto mainDocumentTimelineCurrentTime = mainDocumentTimeline.currentTime())
264             return *mainDocumentTimelineCurrentTime - m_originTime;
265         return WTF::nullopt;
266     }
267 
268     if (!m_cachedCurrentTime)
269         cacheCurrentTime(liveCurrentTime());
270 
271     return m_cachedCurrentTime.value() - m_originTime;
272 }
273 
274 void DocumentTimeline::cacheCurrentTime(DOMHighResTimeStamp newCurrentTime)
275 {


276     m_cachedCurrentTime = Seconds(newCurrentTime);
277     // We want to be sure to keep this time cached until we&#39;ve both finished running JS and finished updating
278     // animations, so we schedule the invalidation task and register a whenIdle callback on the VM, which will
279     // fire syncronously if no JS is running.
280     m_waitingOnVMIdle = true;
281     if (!m_currentTimeClearingTaskQueue.hasPendingTasks())
282         m_currentTimeClearingTaskQueue.enqueueTask(std::bind(&amp;DocumentTimeline::maybeClearCachedCurrentTime, this));
283     m_document-&gt;vm().whenIdle([this, protectedThis = makeRefPtr(this)]() {
284         m_waitingOnVMIdle = false;
285         maybeClearCachedCurrentTime();
286     });
287 }
288 
289 void DocumentTimeline::maybeClearCachedCurrentTime()
290 {
291     // We want to make sure we only clear the cached current time if we&#39;re not currently running
292     // JS or waiting on all current animation updating code to have completed. This is so that
293     // we&#39;re guaranteed to have a consistent current time reported for all work happening in a given
294     // JS frame or throughout updating animations in WebCore.
295     if (!m_isSuspended &amp;&amp; !m_waitingOnVMIdle &amp;&amp; !m_currentTimeClearingTaskQueue.hasPendingTasks())
296         m_cachedCurrentTime = WTF::nullopt;
297 }
298 
299 void DocumentTimeline::animationTimingDidChange(WebAnimation&amp; animation)
300 {
301     AnimationTimeline::animationTimingDidChange(animation);
302     scheduleAnimationResolution();
303 }
304 
305 void DocumentTimeline::removeAnimation(WebAnimation&amp; animation)
306 {
307     AnimationTimeline::removeAnimation(animation);
308 
309     if (m_animations.isEmpty())
<span class="line-modified">310         unscheduleAnimationResolution();</span>
311 }
312 
313 void DocumentTimeline::scheduleAnimationResolution()
314 {
<span class="line-modified">315     if (m_isSuspended || m_animations.isEmpty() || m_animationResolutionScheduled)</span>
316         return;
317 
<span class="line-modified">318     if (!m_document || !m_document-&gt;page())</span>

319         return;
320 
321     m_document-&gt;page()-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
322     m_animationResolutionScheduled = true;
323 }
324 
<span class="line-modified">325 void DocumentTimeline::unscheduleAnimationResolution()</span>
326 {
327     m_tickScheduleTimer.stop();
<span class="line-removed">328     m_animationResolutionScheduled = false;</span>
329 }
330 
<span class="line-modified">331 void DocumentTimeline::updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp)</span>





332 {
333     // We need to freeze the current time even if no animation is running.
334     // document.timeline.currentTime may be called from a rAF callback and
335     // it has to match the rAF timestamp.
<span class="line-modified">336     if (!m_isSuspended)</span>
337         cacheCurrentTime(timestamp);

338 
<span class="line-modified">339     if (m_isSuspended || m_animations.isEmpty() || !m_animationResolutionScheduled)</span>










340         return;
341 
342     internalUpdateAnimationsAndSendEvents();
343     applyPendingAcceleratedAnimations();
344 
<span class="line-modified">345     m_animationResolutionScheduled = false;</span>
<span class="line-modified">346     scheduleNextTick();</span>
347 }
348 
349 void DocumentTimeline::internalUpdateAnimationsAndSendEvents()
350 {
351     m_numberOfAnimationTimelineInvalidationsForTesting++;
352 





353     // https://drafts.csswg.org/web-animations/#update-animations-and-send-events
354 
355     // 1. Update the current time of all timelines associated with doc passing now as the timestamp.
356 
357     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;
358     Vector&lt;RefPtr&lt;CSSTransition&gt;&gt; completedTransitions;
359 
360     for (auto&amp; animation : m_animations) {
361         if (animation-&gt;timeline() != this) {
362             ASSERT(!animation-&gt;timeline());
363             animationsToRemove.append(animation);
364             continue;
365         }
366 
367         // This will notify the animation that timing has changed and will call automatically
368         // schedule invalidation if required for this animation.
369         animation-&gt;tick();
370 
371         if (!animation-&gt;isRelevant() &amp;&amp; !animation-&gt;needsTick())
372             animationsToRemove.append(animation);
373 
374         if (!animation-&gt;needsTick() &amp;&amp; is&lt;CSSTransition&gt;(animation) &amp;&amp; animation-&gt;playState() == WebAnimation::PlayState::Finished) {
375             auto* transition = downcast&lt;CSSTransition&gt;(animation.get());
376             if (transition-&gt;owningElement())
377                 completedTransitions.append(transition);
378         }
379     }
380 
<span class="line-modified">381     // 2. Perform a microtask checkpoint.</span>
<span class="line-modified">382     MicrotaskQueue::mainThreadQueue().performMicrotaskCheckpoint();</span>
383 
<span class="line-modified">384     // 3. Let events to dispatch be a copy of doc&#39;s pending animation event queue.</span>
<span class="line-modified">385     // 4. Clear doc&#39;s pending animation event queue.</span>




386     auto pendingAnimationEvents = WTFMove(m_pendingAnimationEvents);

387 
<span class="line-modified">388     // 5. Perform a stable sort of the animation events in events to dispatch as follows.</span>
<span class="line-modified">389     std::stable_sort(pendingAnimationEvents.begin(), pendingAnimationEvents.end(), [] (const Ref&lt;AnimationPlaybackEvent&gt;&amp; lhs, const Ref&lt;AnimationPlaybackEvent&gt;&amp; rhs) {</span>
390         // 1. Sort the events by their scheduled event time such that events that were scheduled to occur earlier, sort before events scheduled to occur later
391         // and events whose scheduled event time is unresolved sort before events with a resolved scheduled event time.
392         // 2. Within events with equal scheduled event times, sort by their composite order. FIXME: We don&#39;t do this.
393         if (lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
394             return false;
395         if (!lhs-&gt;timelineTime() &amp;&amp; rhs-&gt;timelineTime())
396             return true;
397         if (!lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
398             return true;
399         return lhs-&gt;timelineTime().value() &lt; rhs-&gt;timelineTime().value();
400     });
401 
<span class="line-modified">402     // 6. Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.</span>
<span class="line-modified">403     for (auto&amp; pendingEvent : pendingAnimationEvents)</span>
<span class="line-modified">404         pendingEvent-&gt;target()-&gt;dispatchEvent(pendingEvent);</span>
405 
406     // This will cancel any scheduled invalidation if we end up removing all animations.
<span class="line-modified">407     for (auto&amp; animation : animationsToRemove)</span>
<span class="line-modified">408         removeAnimation(*animation);</span>




409 
410     // Now that animations that needed removal have been removed, let&#39;s update the list of completed transitions.
411     // This needs to happen after dealing with the list of animations to remove as the animation may have been
412     // removed from the list of completed transitions otherwise.
413     for (auto&amp; completedTransition : completedTransitions)
414         transitionDidComplete(completedTransition);
415 }
416 













































































417 void DocumentTimeline::transitionDidComplete(RefPtr&lt;CSSTransition&gt; transition)
418 {
419     ASSERT(transition);
420     removeAnimation(*transition);
421     if (is&lt;KeyframeEffect&gt;(transition-&gt;effect())) {
422         if (auto* target = downcast&lt;KeyframeEffect&gt;(transition-&gt;effect())-&gt;target()) {
423             m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(target, [] {
424                 return HashMap&lt;CSSPropertyID, RefPtr&lt;CSSTransition&gt;&gt; { };
425             }).iterator-&gt;value.set(transition-&gt;property(), transition);
426         }
427     }
428 }
429 
430 void DocumentTimeline::scheduleNextTick()
431 {




432     // There is no tick to schedule if we don&#39;t have any relevant animations.
433     if (m_animations.isEmpty())
434         return;
435 
<span class="line-removed">436     for (const auto&amp; animation : m_animations) {</span>
<span class="line-removed">437         if (!animation-&gt;isRunningAccelerated()) {</span>
<span class="line-removed">438             scheduleAnimationResolution();</span>
<span class="line-removed">439             return;</span>
<span class="line-removed">440         }</span>
<span class="line-removed">441     }</span>
<span class="line-removed">442 </span>
443     Seconds scheduleDelay = Seconds::infinity();
444 
445     for (const auto&amp; animation : m_animations) {


446         auto animationTimeToNextRequiredTick = animation-&gt;timeToNextTick();
447         if (animationTimeToNextRequiredTick &lt; animationInterval()) {
448             scheduleAnimationResolution();
449             return;
450         }
451         scheduleDelay = std::min(scheduleDelay, animationTimeToNextRequiredTick);
452     }
453 
454     if (scheduleDelay &lt; Seconds::infinity())
455         m_tickScheduleTimer.startOneShot(scheduleDelay);
456 }
457 
458 bool DocumentTimeline::computeExtentOfAnimation(RenderElement&amp; renderer, LayoutRect&amp; bounds) const
459 {
460     if (!renderer.element())
461         return true;
462 
463     KeyframeEffect* matchingEffect = nullptr;
464     for (const auto&amp; animation : animationsForElement(*renderer.element())) {
465         auto* effect = animation-&gt;effect();
</pre>
<hr />
<pre>
488         auto* effect = animation-&gt;effect();
489         if (is&lt;KeyframeEffect&gt;(effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(effect)-&gt;animatedProperties().contains(property))
490             return true;
491     }
492 
493     return false;
494 }
495 
496 bool DocumentTimeline::isRunningAcceleratedAnimationOnRenderer(RenderElement&amp; renderer, CSSPropertyID property) const
497 {
498     if (!renderer.element())
499         return false;
500 
501     for (const auto&amp; animation : animationsForElement(*renderer.element())) {
502         auto playState = animation-&gt;playState();
503         if (playState != WebAnimation::PlayState::Running &amp;&amp; playState != WebAnimation::PlayState::Paused)
504             continue;
505         auto* effect = animation-&gt;effect();
506         if (is&lt;KeyframeEffect&gt;(effect)) {
507             auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);
<span class="line-modified">508             if (keyframeEffect-&gt;isRunningAccelerated() &amp;&amp; keyframeEffect-&gt;animatedProperties().contains(property))</span>
509                 return true;
510         }
511     }
512 
513     return false;
514 }
515 
516 std::unique_ptr&lt;RenderStyle&gt; DocumentTimeline::animatedStyleForRenderer(RenderElement&amp; renderer)
517 {
518     std::unique_ptr&lt;RenderStyle&gt; result;
519 
520     if (auto* element = renderer.element()) {
521         for (const auto&amp; animation : animationsForElement(*element)) {
522             if (is&lt;KeyframeEffect&gt;(animation-&gt;effect()))
523                 downcast&lt;KeyframeEffect&gt;(animation-&gt;effect())-&gt;getAnimatedStyle(result);
524         }
525     }
526 
527     if (!result)
528         result = RenderStyle::clonePtr(renderer.style());
</pre>
<hr />
<pre>
533 void DocumentTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
534 {
535     AnimationTimeline::animationWasAddedToElement(animation, element);
536     updateListOfElementsWithRunningAcceleratedAnimationsForElement(element);
537 }
538 
539 void DocumentTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
540 {
541     AnimationTimeline::animationWasRemovedFromElement(animation, element);
542     updateListOfElementsWithRunningAcceleratedAnimationsForElement(element);
543 }
544 
545 void DocumentTimeline::animationAcceleratedRunningStateDidChange(WebAnimation&amp; animation)
546 {
547     m_acceleratedAnimationsPendingRunningStateChange.add(&amp;animation);
548 
549     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
550         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())
551             updateListOfElementsWithRunningAcceleratedAnimationsForElement(*target);
552     }





553 }
554 
555 void DocumentTimeline::updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp; element)
556 {
557     auto animations = animationsForElement(element);
558 
559     if (animations.isEmpty()) {
560         m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);
561         return;
562     }
563 
564     for (const auto&amp; animation : animations) {
565         if (!animation-&gt;isRunningAccelerated()) {
566             m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);
567             return;
568         }
569     }
570 
571     m_elementsWithRunningAcceleratedAnimations.add(&amp;element);
572 }
573 
574 void DocumentTimeline::applyPendingAcceleratedAnimations()
575 {
576     auto acceleratedAnimationsPendingRunningStateChange = m_acceleratedAnimationsPendingRunningStateChange;
577     m_acceleratedAnimationsPendingRunningStateChange.clear();
578 
579     bool hasForcedLayout = false;
580     for (auto&amp; animation : acceleratedAnimationsPendingRunningStateChange) {
581         if (!hasForcedLayout) {
582             auto* effect = animation-&gt;effect();
583             if (is&lt;KeyframeEffect&gt;(effect))
584                 hasForcedLayout |= downcast&lt;KeyframeEffect&gt;(effect)-&gt;forceLayoutIfNeeded();
585         }
586         animation-&gt;applyPendingAcceleratedActions();
587     }
588 }
589 
<span class="line-removed">590 bool DocumentTimeline::resolveAnimationsForElement(Element&amp; element, RenderStyle&amp; targetStyle)</span>
<span class="line-removed">591 {</span>
<span class="line-removed">592     bool hasNonAcceleratedAnimationProperty = false;</span>
<span class="line-removed">593 </span>
<span class="line-removed">594     for (const auto&amp; animation : animationsForElement(element)) {</span>
<span class="line-removed">595         animation-&gt;resolve(targetStyle);</span>
<span class="line-removed">596 </span>
<span class="line-removed">597         if (hasNonAcceleratedAnimationProperty)</span>
<span class="line-removed">598             continue;</span>
<span class="line-removed">599 </span>
<span class="line-removed">600         auto* effect = animation-&gt;effect();</span>
<span class="line-removed">601         if (!effect || !is&lt;KeyframeEffect&gt;(effect))</span>
<span class="line-removed">602             continue;</span>
<span class="line-removed">603 </span>
<span class="line-removed">604         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);</span>
<span class="line-removed">605         for (auto cssPropertyId : keyframeEffect-&gt;animatedProperties()) {</span>
<span class="line-removed">606             if (!CSSPropertyAnimation::animationOfPropertyIsAccelerated(cssPropertyId)) {</span>
<span class="line-removed">607                 hasNonAcceleratedAnimationProperty = true;</span>
<span class="line-removed">608                 break;</span>
<span class="line-removed">609             }</span>
<span class="line-removed">610         }</span>
<span class="line-removed">611     }</span>
<span class="line-removed">612 </span>
<span class="line-removed">613     return !hasNonAcceleratedAnimationProperty;</span>
<span class="line-removed">614 }</span>
<span class="line-removed">615 </span>
616 bool DocumentTimeline::runningAnimationsForElementAreAllAccelerated(Element&amp; element) const
617 {
618     return m_elementsWithRunningAcceleratedAnimations.contains(&amp;element);
619 }
620 
<span class="line-modified">621 void DocumentTimeline::enqueueAnimationPlaybackEvent(AnimationPlaybackEvent&amp; event)</span>
622 {
623     m_pendingAnimationEvents.append(event);


624 }
625 
626 Vector&lt;std::pair&lt;String, double&gt;&gt; DocumentTimeline::acceleratedAnimationsForElement(Element&amp; element) const
627 {
628     auto* renderer = element.renderer();
629     if (renderer &amp;&amp; renderer-&gt;isComposited()) {
630         auto* compositedRenderer = downcast&lt;RenderBoxModelObject&gt;(renderer);
631         if (auto* graphicsLayer = compositedRenderer-&gt;layer()-&gt;backing()-&gt;graphicsLayer())
632             return graphicsLayer-&gt;acceleratedAnimationsForTesting();
633     }
634     return { };
635 }
636 
637 unsigned DocumentTimeline::numberOfAnimationTimelineInvalidationsForTesting() const
638 {
639     return m_numberOfAnimationTimelineInvalidationsForTesting;
640 }
641 
642 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DocumentTimeline.h&quot;
 28 
<span class="line-modified"> 29 #include &quot;AnimationEventBase.h&quot;</span>
 30 #include &quot;CSSAnimation.h&quot;

 31 #include &quot;CSSTransition.h&quot;
 32 #include &quot;DOMWindow.h&quot;
 33 #include &quot;DeclarativeAnimation.h&quot;
 34 #include &quot;Document.h&quot;
<span class="line-added"> 35 #include &quot;EventLoop.h&quot;</span>
<span class="line-added"> 36 #include &quot;EventNames.h&quot;</span>
 37 #include &quot;GraphicsLayer.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;
<span class="line-modified"> 39 #include &quot;KeyframeEffectStack.h&quot;</span>
 40 #include &quot;Node.h&quot;
 41 #include &quot;Page.h&quot;
 42 #include &quot;PseudoElement.h&quot;
 43 #include &quot;RenderElement.h&quot;
 44 #include &quot;RenderLayer.h&quot;
 45 #include &quot;RenderLayerBacking.h&quot;
<span class="line-added"> 46 #include &quot;Settings.h&quot;</span>
<span class="line-added"> 47 #include &lt;JavaScriptCore/VM.h&gt;</span>
 48 
 49 static const Seconds defaultAnimationInterval { 15_ms };
 50 static const Seconds throttledAnimationInterval { 30_ms };
 51 
 52 namespace WebCore {
 53 
 54 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document)
 55 {
 56     return adoptRef(*new DocumentTimeline(document, 0_s));
 57 }
 58 
 59 Ref&lt;DocumentTimeline&gt; DocumentTimeline::create(Document&amp; document, DocumentTimelineOptions&amp;&amp; options)
 60 {
 61     return adoptRef(*new DocumentTimeline(document, Seconds::fromMilliseconds(options.originTime)));
 62 }
 63 
 64 DocumentTimeline::DocumentTimeline(Document&amp; document, Seconds originTime)
 65     : AnimationTimeline()
 66     , m_tickScheduleTimer(*this, &amp;DocumentTimeline::scheduleAnimationResolution)
<span class="line-modified"> 67     , m_document(makeWeakPtr(document))</span>
 68     , m_originTime(originTime)
 69 {
<span class="line-modified"> 70     document.addTimeline(*this);</span>
<span class="line-modified"> 71     if (auto* page = document.page()) {</span>
<span class="line-added"> 72         if (page-&gt;settings().hiddenPageCSSAnimationSuspensionEnabled() &amp;&amp; !page-&gt;isVisible())</span>
<span class="line-added"> 73             suspendAnimations();</span>
<span class="line-added"> 74     }</span>
 75 }
 76 
<span class="line-modified"> 77 DocumentTimeline::~DocumentTimeline()</span>
<span class="line-added"> 78 {</span>
<span class="line-added"> 79     if (m_document)</span>
<span class="line-added"> 80         m_document-&gt;removeTimeline(*this);</span>
<span class="line-added"> 81 }</span>
 82 
 83 void DocumentTimeline::detachFromDocument()
 84 {
<span class="line-added"> 85     Ref&lt;DocumentTimeline&gt; protectedThis(*this);</span>
<span class="line-added"> 86     if (m_document)</span>
<span class="line-added"> 87         m_document-&gt;removeTimeline(*this);</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89     m_pendingAnimationEvents.clear();</span>
 90     m_currentTimeClearingTaskQueue.close();
 91     m_elementsWithRunningAcceleratedAnimations.clear();
 92 
 93     auto&amp; animationsToRemove = m_animations;
 94     while (!animationsToRemove.isEmpty())
 95         animationsToRemove.first()-&gt;remove();
 96 
<span class="line-modified"> 97     clearTickScheduleTimer();</span>
 98     m_document = nullptr;
 99 }
100 
101 static inline bool compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(Element* lhsOwningElement, Element* rhsOwningElement)
102 {
103     // With regard to pseudo-elements, the sort order is as follows:
104     //     - element
105     //     - ::before
106     //     - ::after
107     //     - element children
108 
109     // We could be comparing two pseudo-elements that are hosted on the same element.
110     if (is&lt;PseudoElement&gt;(lhsOwningElement) &amp;&amp; is&lt;PseudoElement&gt;(rhsOwningElement)) {
111         auto* lhsPseudoElement = downcast&lt;PseudoElement&gt;(lhsOwningElement);
112         auto* rhsPseudoElement = downcast&lt;PseudoElement&gt;(rhsOwningElement);
113         if (lhsPseudoElement-&gt;hostElement() == rhsPseudoElement-&gt;hostElement())
114             return lhsPseudoElement-&gt;isBeforePseudoElement();
115     }
116 
117     // Or comparing a pseudo-element that is compared to another non-pseudo element, in which case
</pre>
<hr />
<pre>
174         // Otherwise, if A and B have different transition generation values, sort by their corresponding transition generation in ascending order.
175         if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())
176             return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();
177 
178         // Otherwise, sort A and B in ascending order by the Unicode codepoints that make up the expanded transition property name of each transition
179         // (i.e. without attempting case conversion and such that ‘-moz-column-width’ sorts before ‘column-width’).
180         return lhsTransition-&gt;transitionProperty().utf8() &lt; rhsTransition-&gt;transitionProperty().utf8();
181     });
182 
183     // Now sort CSS Animations by their composite order.
184     std::sort(cssAnimations.begin(), cssAnimations.end(), [](auto&amp; lhs, auto&amp; rhs) {
185         // https://drafts.csswg.org/css-animations-2/#animation-composite-order
186         auto* lhsOwningElement = downcast&lt;CSSAnimation&gt;(lhs.get())-&gt;owningElement();
187         auto* rhsOwningElement = downcast&lt;CSSAnimation&gt;(rhs.get())-&gt;owningElement();
188 
189         // If the owning element of A and B differs, sort A and B by tree order of their corresponding owning elements.
190         if (lhsOwningElement != rhsOwningElement)
191             return compareDeclarativeAnimationOwningElementPositionsInDocumentTreeOrder(lhsOwningElement, rhsOwningElement);
192 
193         // Otherwise, sort A and B based on their position in the computed value of the animation-name property of the (common) owning element.
<span class="line-modified">194         return compareAnimationsByCompositeOrder(*lhs, *rhs, lhsOwningElement-&gt;ensureKeyframeEffectStack().cssAnimationList());</span>
<span class="line-modified">195     });</span>
<span class="line-added">196 </span>
<span class="line-added">197     std::sort(webAnimations.begin(), webAnimations.end(), [](auto&amp; lhs, auto&amp; rhs) {</span>
<span class="line-added">198         return lhs-&gt;globalPosition() &lt; rhs-&gt;globalPosition();</span>
199     });
200 
201     // Finally, we can concatenate the sorted CSS Transitions, CSS Animations and Web Animations in their relative composite order.
202     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
203     animations.appendRange(cssTransitions.begin(), cssTransitions.end());
204     animations.appendRange(cssAnimations.begin(), cssAnimations.end());
205     animations.appendRange(webAnimations.begin(), webAnimations.end());
206     return animations;
207 }
208 
209 void DocumentTimeline::updateThrottlingState()
210 {
211     scheduleAnimationResolution();
212 }
213 
214 Seconds DocumentTimeline::animationInterval() const
215 {
216     if (!m_document || !m_document-&gt;page())
217         return Seconds::infinity();
218     return m_document-&gt;page()-&gt;isLowPowerModeEnabled() ? throttledAnimationInterval : defaultAnimationInterval;
219 }
220 
221 void DocumentTimeline::suspendAnimations()
222 {
223     if (animationsAreSuspended())
224         return;
225 
226     if (!m_cachedCurrentTime)
227         m_cachedCurrentTime = Seconds(liveCurrentTime());
228 
229     for (const auto&amp; animation : m_animations)
230         animation-&gt;setSuspended(true);
231 
232     m_isSuspended = true;
233 
234     applyPendingAcceleratedAnimations();
235 
<span class="line-modified">236     clearTickScheduleTimer();</span>
237 }
238 
239 void DocumentTimeline::resumeAnimations()
240 {
241     if (!animationsAreSuspended())
242         return;
243 
244     m_cachedCurrentTime = WTF::nullopt;
245 
246     m_isSuspended = false;
247 
248     for (const auto&amp; animation : m_animations)
249         animation-&gt;setSuspended(false);
250 
251     scheduleAnimationResolution();
252 }
253 
254 bool DocumentTimeline::animationsAreSuspended()
255 {
256     return m_isSuspended;
</pre>
<hr />
<pre>
274 Optional&lt;Seconds&gt; DocumentTimeline::currentTime()
275 {
276     if (!m_document || !m_document-&gt;domWindow())
277         return AnimationTimeline::currentTime();
278 
279     auto&amp; mainDocumentTimeline = m_document-&gt;timeline();
280     if (&amp;mainDocumentTimeline != this) {
281         if (auto mainDocumentTimelineCurrentTime = mainDocumentTimeline.currentTime())
282             return *mainDocumentTimelineCurrentTime - m_originTime;
283         return WTF::nullopt;
284     }
285 
286     if (!m_cachedCurrentTime)
287         cacheCurrentTime(liveCurrentTime());
288 
289     return m_cachedCurrentTime.value() - m_originTime;
290 }
291 
292 void DocumentTimeline::cacheCurrentTime(DOMHighResTimeStamp newCurrentTime)
293 {
<span class="line-added">294     ASSERT(m_document);</span>
<span class="line-added">295 </span>
296     m_cachedCurrentTime = Seconds(newCurrentTime);
297     // We want to be sure to keep this time cached until we&#39;ve both finished running JS and finished updating
298     // animations, so we schedule the invalidation task and register a whenIdle callback on the VM, which will
299     // fire syncronously if no JS is running.
300     m_waitingOnVMIdle = true;
301     if (!m_currentTimeClearingTaskQueue.hasPendingTasks())
302         m_currentTimeClearingTaskQueue.enqueueTask(std::bind(&amp;DocumentTimeline::maybeClearCachedCurrentTime, this));
303     m_document-&gt;vm().whenIdle([this, protectedThis = makeRefPtr(this)]() {
304         m_waitingOnVMIdle = false;
305         maybeClearCachedCurrentTime();
306     });
307 }
308 
309 void DocumentTimeline::maybeClearCachedCurrentTime()
310 {
311     // We want to make sure we only clear the cached current time if we&#39;re not currently running
312     // JS or waiting on all current animation updating code to have completed. This is so that
313     // we&#39;re guaranteed to have a consistent current time reported for all work happening in a given
314     // JS frame or throughout updating animations in WebCore.
315     if (!m_isSuspended &amp;&amp; !m_waitingOnVMIdle &amp;&amp; !m_currentTimeClearingTaskQueue.hasPendingTasks())
316         m_cachedCurrentTime = WTF::nullopt;
317 }
318 
319 void DocumentTimeline::animationTimingDidChange(WebAnimation&amp; animation)
320 {
321     AnimationTimeline::animationTimingDidChange(animation);
322     scheduleAnimationResolution();
323 }
324 
325 void DocumentTimeline::removeAnimation(WebAnimation&amp; animation)
326 {
327     AnimationTimeline::removeAnimation(animation);
328 
329     if (m_animations.isEmpty())
<span class="line-modified">330         clearTickScheduleTimer();</span>
331 }
332 
333 void DocumentTimeline::scheduleAnimationResolution()
334 {
<span class="line-modified">335     if (m_isSuspended || m_animationResolutionScheduled || !m_document || !m_document-&gt;page())</span>
336         return;
337 
<span class="line-modified">338     // We need some relevant animations or pending events to proceed.</span>
<span class="line-added">339     if (!shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
340         return;
341 
342     m_document-&gt;page()-&gt;renderingUpdateScheduler().scheduleTimedRenderingUpdate();
343     m_animationResolutionScheduled = true;
344 }
345 
<span class="line-modified">346 void DocumentTimeline::clearTickScheduleTimer()</span>
347 {
348     m_tickScheduleTimer.stop();

349 }
350 
<span class="line-modified">351 bool DocumentTimeline::shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState() const</span>
<span class="line-added">352 {</span>
<span class="line-added">353     return !m_animations.isEmpty() || !m_pendingAnimationEvents.isEmpty() || !m_acceleratedAnimationsPendingRunningStateChange.isEmpty();</span>
<span class="line-added">354 }</span>
<span class="line-added">355 </span>
<span class="line-added">356 void DocumentTimeline::updateCurrentTime(DOMHighResTimeStamp timestamp)</span>
357 {
358     // We need to freeze the current time even if no animation is running.
359     // document.timeline.currentTime may be called from a rAF callback and
360     // it has to match the rAF timestamp.
<span class="line-modified">361     if (!m_isSuspended || !shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
362         cacheCurrentTime(timestamp);
<span class="line-added">363 }</span>
364 
<span class="line-modified">365 void DocumentTimeline::updateAnimationsAndSendEvents()</span>
<span class="line-added">366 {</span>
<span class="line-added">367 </span>
<span class="line-added">368     // Updating animations and sending events may invalidate the timing of some animations, so we must set the m_animationResolutionScheduled</span>
<span class="line-added">369     // flag to false prior to running that procedure to allow animation with timing model updates to schedule updates.</span>
<span class="line-added">370     m_animationResolutionScheduled = false;</span>
<span class="line-added">371 </span>
<span class="line-added">372     if (m_isSuspended)</span>
<span class="line-added">373         return;</span>
<span class="line-added">374 </span>
<span class="line-added">375     if (!shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
376         return;
377 
378     internalUpdateAnimationsAndSendEvents();
379     applyPendingAcceleratedAnimations();
380 
<span class="line-modified">381     if (!m_animationResolutionScheduled)</span>
<span class="line-modified">382         scheduleNextTick();</span>
383 }
384 
385 void DocumentTimeline::internalUpdateAnimationsAndSendEvents()
386 {
387     m_numberOfAnimationTimelineInvalidationsForTesting++;
388 
<span class="line-added">389     // enqueueAnimationEvent() calls scheduleAnimationResolution() to ensure that the &quot;update animations and send events&quot;</span>
<span class="line-added">390     // procedure is run and enqueued events are dispatched in the next frame. However, events that are enqueued while</span>
<span class="line-added">391     // this procedure is running should not schedule animation resolution until the event queue has been cleared.</span>
<span class="line-added">392     m_shouldScheduleAnimationResolutionForNewPendingEvents = false;</span>
<span class="line-added">393 </span>
394     // https://drafts.csswg.org/web-animations/#update-animations-and-send-events
395 
396     // 1. Update the current time of all timelines associated with doc passing now as the timestamp.
397 
398     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;
399     Vector&lt;RefPtr&lt;CSSTransition&gt;&gt; completedTransitions;
400 
401     for (auto&amp; animation : m_animations) {
402         if (animation-&gt;timeline() != this) {
403             ASSERT(!animation-&gt;timeline());
404             animationsToRemove.append(animation);
405             continue;
406         }
407 
408         // This will notify the animation that timing has changed and will call automatically
409         // schedule invalidation if required for this animation.
410         animation-&gt;tick();
411 
412         if (!animation-&gt;isRelevant() &amp;&amp; !animation-&gt;needsTick())
413             animationsToRemove.append(animation);
414 
415         if (!animation-&gt;needsTick() &amp;&amp; is&lt;CSSTransition&gt;(animation) &amp;&amp; animation-&gt;playState() == WebAnimation::PlayState::Finished) {
416             auto* transition = downcast&lt;CSSTransition&gt;(animation.get());
417             if (transition-&gt;owningElement())
418                 completedTransitions.append(transition);
419         }
420     }
421 
<span class="line-modified">422     // 2. Remove replaced animations for doc.</span>
<span class="line-modified">423     removeReplacedAnimations();</span>
424 
<span class="line-modified">425     // 3. Perform a microtask checkpoint.</span>
<span class="line-modified">426     if (auto document = makeRefPtr(this-&gt;document()))</span>
<span class="line-added">427         document-&gt;eventLoop().performMicrotaskCheckpoint();</span>
<span class="line-added">428 </span>
<span class="line-added">429     // 4. Let events to dispatch be a copy of doc&#39;s pending animation event queue.</span>
<span class="line-added">430     // 5. Clear doc&#39;s pending animation event queue.</span>
431     auto pendingAnimationEvents = WTFMove(m_pendingAnimationEvents);
<span class="line-added">432     m_shouldScheduleAnimationResolutionForNewPendingEvents = true;</span>
433 
<span class="line-modified">434     // 6. Perform a stable sort of the animation events in events to dispatch as follows.</span>
<span class="line-modified">435     std::stable_sort(pendingAnimationEvents.begin(), pendingAnimationEvents.end(), [] (const Ref&lt;AnimationEventBase&gt;&amp; lhs, const Ref&lt;AnimationEventBase&gt;&amp; rhs) {</span>
436         // 1. Sort the events by their scheduled event time such that events that were scheduled to occur earlier, sort before events scheduled to occur later
437         // and events whose scheduled event time is unresolved sort before events with a resolved scheduled event time.
438         // 2. Within events with equal scheduled event times, sort by their composite order. FIXME: We don&#39;t do this.
439         if (lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
440             return false;
441         if (!lhs-&gt;timelineTime() &amp;&amp; rhs-&gt;timelineTime())
442             return true;
443         if (!lhs-&gt;timelineTime() &amp;&amp; !rhs-&gt;timelineTime())
444             return true;
445         return lhs-&gt;timelineTime().value() &lt; rhs-&gt;timelineTime().value();
446     });
447 
<span class="line-modified">448     // 7. Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.</span>
<span class="line-modified">449     for (auto&amp; pendingAnimationEvent : pendingAnimationEvents)</span>
<span class="line-modified">450         pendingAnimationEvent-&gt;target()-&gt;dispatchEvent(pendingAnimationEvent);</span>
451 
452     // This will cancel any scheduled invalidation if we end up removing all animations.
<span class="line-modified">453     for (auto&amp; animation : animationsToRemove) {</span>
<span class="line-modified">454         // An animation that was initially marked as irrelevant may have changed while we were sending events, so we run the same</span>
<span class="line-added">455         // check that we ran to add it to animationsToRemove in the first place.</span>
<span class="line-added">456         if (!animation-&gt;isRelevant() &amp;&amp; !animation-&gt;needsTick())</span>
<span class="line-added">457             removeAnimation(*animation);</span>
<span class="line-added">458     }</span>
459 
460     // Now that animations that needed removal have been removed, let&#39;s update the list of completed transitions.
461     // This needs to happen after dealing with the list of animations to remove as the animation may have been
462     // removed from the list of completed transitions otherwise.
463     for (auto&amp; completedTransition : completedTransitions)
464         transitionDidComplete(completedTransition);
465 }
466 
<span class="line-added">467 bool DocumentTimeline::animationCanBeRemoved(WebAnimation&amp; animation)</span>
<span class="line-added">468 {</span>
<span class="line-added">469     // https://drafts.csswg.org/web-animations/#removing-replaced-animations</span>
<span class="line-added">470 </span>
<span class="line-added">471     ASSERT(m_document);</span>
<span class="line-added">472 </span>
<span class="line-added">473     // - is replaceable, and</span>
<span class="line-added">474     if (!animation.isReplaceable())</span>
<span class="line-added">475         return false;</span>
<span class="line-added">476 </span>
<span class="line-added">477     // - has a replace state of active, and</span>
<span class="line-added">478     if (animation.replaceState() != WebAnimation::ReplaceState::Active)</span>
<span class="line-added">479         return false;</span>
<span class="line-added">480 </span>
<span class="line-added">481     // - has an associated animation effect whose target element is a descendant of doc, and</span>
<span class="line-added">482     auto* effect = animation.effect();</span>
<span class="line-added">483     if (!is&lt;KeyframeEffect&gt;(effect))</span>
<span class="line-added">484         return false;</span>
<span class="line-added">485 </span>
<span class="line-added">486     auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);</span>
<span class="line-added">487     auto* target = keyframeEffect-&gt;target();</span>
<span class="line-added">488     if (!target || !target-&gt;isDescendantOf(*m_document))</span>
<span class="line-added">489         return false;</span>
<span class="line-added">490 </span>
<span class="line-added">491     HashSet&lt;CSSPropertyID&gt; propertiesToMatch = keyframeEffect-&gt;animatedProperties();</span>
<span class="line-added">492     auto animations = animationsForElement(*target, AnimationTimeline::Ordering::Sorted);</span>
<span class="line-added">493     for (auto&amp; animationWithHigherCompositeOrder : WTF::makeReversedRange(animations)) {</span>
<span class="line-added">494         if (&amp;animation == animationWithHigherCompositeOrder)</span>
<span class="line-added">495             break;</span>
<span class="line-added">496 </span>
<span class="line-added">497         if (animationWithHigherCompositeOrder &amp;&amp; animationWithHigherCompositeOrder-&gt;isReplaceable()) {</span>
<span class="line-added">498             auto* effectWithHigherCompositeOrder = animationWithHigherCompositeOrder-&gt;effect();</span>
<span class="line-added">499             if (is&lt;KeyframeEffect&gt;(effectWithHigherCompositeOrder)) {</span>
<span class="line-added">500                 auto* keyframeEffectWithHigherCompositeOrder = downcast&lt;KeyframeEffect&gt;(effectWithHigherCompositeOrder);</span>
<span class="line-added">501                 for (auto cssPropertyId : keyframeEffectWithHigherCompositeOrder-&gt;animatedProperties()) {</span>
<span class="line-added">502                     if (propertiesToMatch.remove(cssPropertyId) &amp;&amp; propertiesToMatch.isEmpty())</span>
<span class="line-added">503                         break;</span>
<span class="line-added">504                 }</span>
<span class="line-added">505             }</span>
<span class="line-added">506         }</span>
<span class="line-added">507     }</span>
<span class="line-added">508 </span>
<span class="line-added">509     return propertiesToMatch.isEmpty();</span>
<span class="line-added">510 }</span>
<span class="line-added">511 </span>
<span class="line-added">512 void DocumentTimeline::removeReplacedAnimations()</span>
<span class="line-added">513 {</span>
<span class="line-added">514     // https://drafts.csswg.org/web-animations/#removing-replaced-animations</span>
<span class="line-added">515 </span>
<span class="line-added">516     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animationsToRemove;</span>
<span class="line-added">517 </span>
<span class="line-added">518     // When asked to remove replaced animations for a Document, doc, then for every animation, animation</span>
<span class="line-added">519     for (auto&amp; animation : m_allAnimations) {</span>
<span class="line-added">520         if (animation &amp;&amp; animationCanBeRemoved(*animation)) {</span>
<span class="line-added">521             // perform the following steps:</span>
<span class="line-added">522             // 1. Set animation&#39;s replace state to removed.</span>
<span class="line-added">523             animation-&gt;setReplaceState(WebAnimation::ReplaceState::Removed);</span>
<span class="line-added">524             // 2. Create an AnimationPlaybackEvent, removeEvent.</span>
<span class="line-added">525             // 3. Set removeEvent&#39;s type attribute to remove.</span>
<span class="line-added">526             // 4. Set removeEvent&#39;s currentTime attribute to the current time of animation.</span>
<span class="line-added">527             // 5. Set removeEvent&#39;s timelineTime attribute to the current time of the timeline with which animation is associated.</span>
<span class="line-added">528             // 6. If animation has a document for timing, then append removeEvent to its document for timing&#39;s pending animation</span>
<span class="line-added">529             //    event queue along with its target, animation. For the scheduled event time, use the result of applying the procedure</span>
<span class="line-added">530             //    to convert timeline time to origin-relative time to the current time of the timeline with which animation is associated.</span>
<span class="line-added">531             //    Otherwise, queue a task to dispatch removeEvent at animation. The task source for this task is the DOM manipulation task source.</span>
<span class="line-added">532             animation-&gt;enqueueAnimationPlaybackEvent(eventNames().removeEvent, animation-&gt;currentTime(), currentTime());</span>
<span class="line-added">533 </span>
<span class="line-added">534             animationsToRemove.append(animation.get());</span>
<span class="line-added">535         }</span>
<span class="line-added">536     }</span>
<span class="line-added">537 </span>
<span class="line-added">538     for (auto&amp; animation : animationsToRemove) {</span>
<span class="line-added">539         if (auto* timeline = animation-&gt;timeline())</span>
<span class="line-added">540             timeline-&gt;removeAnimation(*animation);</span>
<span class="line-added">541     }</span>
<span class="line-added">542 }</span>
<span class="line-added">543 </span>
544 void DocumentTimeline::transitionDidComplete(RefPtr&lt;CSSTransition&gt; transition)
545 {
546     ASSERT(transition);
547     removeAnimation(*transition);
548     if (is&lt;KeyframeEffect&gt;(transition-&gt;effect())) {
549         if (auto* target = downcast&lt;KeyframeEffect&gt;(transition-&gt;effect())-&gt;target()) {
550             m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(target, [] {
551                 return HashMap&lt;CSSPropertyID, RefPtr&lt;CSSTransition&gt;&gt; { };
552             }).iterator-&gt;value.set(transition-&gt;property(), transition);
553         }
554     }
555 }
556 
557 void DocumentTimeline::scheduleNextTick()
558 {
<span class="line-added">559     // If we have pending animation events, we need to schedule an update right away.</span>
<span class="line-added">560     if (!m_pendingAnimationEvents.isEmpty())</span>
<span class="line-added">561         scheduleAnimationResolution();</span>
<span class="line-added">562 </span>
563     // There is no tick to schedule if we don&#39;t have any relevant animations.
564     if (m_animations.isEmpty())
565         return;
566 







567     Seconds scheduleDelay = Seconds::infinity();
568 
569     for (const auto&amp; animation : m_animations) {
<span class="line-added">570         if (!animation-&gt;isRelevant())</span>
<span class="line-added">571             continue;</span>
572         auto animationTimeToNextRequiredTick = animation-&gt;timeToNextTick();
573         if (animationTimeToNextRequiredTick &lt; animationInterval()) {
574             scheduleAnimationResolution();
575             return;
576         }
577         scheduleDelay = std::min(scheduleDelay, animationTimeToNextRequiredTick);
578     }
579 
580     if (scheduleDelay &lt; Seconds::infinity())
581         m_tickScheduleTimer.startOneShot(scheduleDelay);
582 }
583 
584 bool DocumentTimeline::computeExtentOfAnimation(RenderElement&amp; renderer, LayoutRect&amp; bounds) const
585 {
586     if (!renderer.element())
587         return true;
588 
589     KeyframeEffect* matchingEffect = nullptr;
590     for (const auto&amp; animation : animationsForElement(*renderer.element())) {
591         auto* effect = animation-&gt;effect();
</pre>
<hr />
<pre>
614         auto* effect = animation-&gt;effect();
615         if (is&lt;KeyframeEffect&gt;(effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(effect)-&gt;animatedProperties().contains(property))
616             return true;
617     }
618 
619     return false;
620 }
621 
622 bool DocumentTimeline::isRunningAcceleratedAnimationOnRenderer(RenderElement&amp; renderer, CSSPropertyID property) const
623 {
624     if (!renderer.element())
625         return false;
626 
627     for (const auto&amp; animation : animationsForElement(*renderer.element())) {
628         auto playState = animation-&gt;playState();
629         if (playState != WebAnimation::PlayState::Running &amp;&amp; playState != WebAnimation::PlayState::Paused)
630             continue;
631         auto* effect = animation-&gt;effect();
632         if (is&lt;KeyframeEffect&gt;(effect)) {
633             auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(effect);
<span class="line-modified">634             if (keyframeEffect-&gt;isCurrentlyAffectingProperty(property, KeyframeEffect::Accelerated::Yes))</span>
635                 return true;
636         }
637     }
638 
639     return false;
640 }
641 
642 std::unique_ptr&lt;RenderStyle&gt; DocumentTimeline::animatedStyleForRenderer(RenderElement&amp; renderer)
643 {
644     std::unique_ptr&lt;RenderStyle&gt; result;
645 
646     if (auto* element = renderer.element()) {
647         for (const auto&amp; animation : animationsForElement(*element)) {
648             if (is&lt;KeyframeEffect&gt;(animation-&gt;effect()))
649                 downcast&lt;KeyframeEffect&gt;(animation-&gt;effect())-&gt;getAnimatedStyle(result);
650         }
651     }
652 
653     if (!result)
654         result = RenderStyle::clonePtr(renderer.style());
</pre>
<hr />
<pre>
659 void DocumentTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
660 {
661     AnimationTimeline::animationWasAddedToElement(animation, element);
662     updateListOfElementsWithRunningAcceleratedAnimationsForElement(element);
663 }
664 
665 void DocumentTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
666 {
667     AnimationTimeline::animationWasRemovedFromElement(animation, element);
668     updateListOfElementsWithRunningAcceleratedAnimationsForElement(element);
669 }
670 
671 void DocumentTimeline::animationAcceleratedRunningStateDidChange(WebAnimation&amp; animation)
672 {
673     m_acceleratedAnimationsPendingRunningStateChange.add(&amp;animation);
674 
675     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
676         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())
677             updateListOfElementsWithRunningAcceleratedAnimationsForElement(*target);
678     }
<span class="line-added">679 </span>
<span class="line-added">680     if (shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState())</span>
<span class="line-added">681         scheduleAnimationResolution();</span>
<span class="line-added">682     else</span>
<span class="line-added">683         clearTickScheduleTimer();</span>
684 }
685 
686 void DocumentTimeline::updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp; element)
687 {
688     auto animations = animationsForElement(element);
689 
690     if (animations.isEmpty()) {
691         m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);
692         return;
693     }
694 
695     for (const auto&amp; animation : animations) {
696         if (!animation-&gt;isRunningAccelerated()) {
697             m_elementsWithRunningAcceleratedAnimations.remove(&amp;element);
698             return;
699         }
700     }
701 
702     m_elementsWithRunningAcceleratedAnimations.add(&amp;element);
703 }
704 
705 void DocumentTimeline::applyPendingAcceleratedAnimations()
706 {
707     auto acceleratedAnimationsPendingRunningStateChange = m_acceleratedAnimationsPendingRunningStateChange;
708     m_acceleratedAnimationsPendingRunningStateChange.clear();
709 
710     bool hasForcedLayout = false;
711     for (auto&amp; animation : acceleratedAnimationsPendingRunningStateChange) {
712         if (!hasForcedLayout) {
713             auto* effect = animation-&gt;effect();
714             if (is&lt;KeyframeEffect&gt;(effect))
715                 hasForcedLayout |= downcast&lt;KeyframeEffect&gt;(effect)-&gt;forceLayoutIfNeeded();
716         }
717         animation-&gt;applyPendingAcceleratedActions();
718     }
719 }
720 


























721 bool DocumentTimeline::runningAnimationsForElementAreAllAccelerated(Element&amp; element) const
722 {
723     return m_elementsWithRunningAcceleratedAnimations.contains(&amp;element);
724 }
725 
<span class="line-modified">726 void DocumentTimeline::enqueueAnimationEvent(AnimationEventBase&amp; event)</span>
727 {
728     m_pendingAnimationEvents.append(event);
<span class="line-added">729     if (m_shouldScheduleAnimationResolutionForNewPendingEvents)</span>
<span class="line-added">730         scheduleAnimationResolution();</span>
731 }
732 
733 Vector&lt;std::pair&lt;String, double&gt;&gt; DocumentTimeline::acceleratedAnimationsForElement(Element&amp; element) const
734 {
735     auto* renderer = element.renderer();
736     if (renderer &amp;&amp; renderer-&gt;isComposited()) {
737         auto* compositedRenderer = downcast&lt;RenderBoxModelObject&gt;(renderer);
738         if (auto* graphicsLayer = compositedRenderer-&gt;layer()-&gt;backing()-&gt;graphicsLayer())
739             return graphicsLayer-&gt;acceleratedAnimationsForTesting();
740     }
741     return { };
742 }
743 
744 unsigned DocumentTimeline::numberOfAnimationTimelineInvalidationsForTesting() const
745 {
746     return m_numberOfAnimationTimelineInvalidationsForTesting;
747 }
748 
749 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DeclarativeAnimation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentTimeline.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
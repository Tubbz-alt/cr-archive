diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.h
@@ -26,35 +26,36 @@
 #pragma once
 
 #if ENABLE(WEBASSEMBLY)
 
 #include "MacroAssemblerCodeRef.h"
+#include "WasmCallee.h"
 #include "WasmEmbedder.h"
-#include "WasmTierUpCount.h"
+#include <wtf/CrossThreadCopier.h>
 #include <wtf/Lock.h>
 #include <wtf/RefPtr.h>
 #include <wtf/SharedTask.h>
 #include <wtf/ThreadSafeRefCounted.h>
 #include <wtf/text/WTFString.h>
 
 namespace JSC {
 
 namespace Wasm {
 
-class Callee;
 struct Context;
-class BBQPlan;
-class OMGPlan;
+class EntryPlan;
 struct ModuleInformation;
 struct UnlinkedWasmToWasmCall;
 enum class MemoryMode : uint8_t;
 
+// FIXME: Rename this, since it's not a CodeBlock
+// https://bugs.webkit.org/show_bug.cgi?id=203694
 class CodeBlock : public ThreadSafeRefCounted<CodeBlock> {
 public:
     typedef void CallbackType(Ref<CodeBlock>&&);
     using AsyncCompilationCallback = RefPtr<WTF::SharedTask<CallbackType>>;
-    static Ref<CodeBlock> create(Context*, MemoryMode, ModuleInformation&, CreateEmbedderWrapper&&, ThrowWasmException);
+    static Ref<CodeBlock> create(Context*, MemoryMode, ModuleInformation&, RefPtr<LLIntCallees>);
 
     void waitUntilFinished();
     void compileAsync(Context*, AsyncCompilationCallback&&);
 
     bool compilationFinished()
@@ -66,12 +67,11 @@
     // Note, we do this copy to ensure it's thread safe to have this
     // called from multiple threads simultaneously.
     String errorMessage()
     {
         ASSERT(!runnable());
-        CString cString = m_errorMessage.ascii();
-        return String(cString.data());
+        return crossThreadCopy(m_errorMessage);
     }
 
     unsigned functionImportCount() const { return m_wasmToWasmExitStubs.size(); }
 
     // These two callee getters are only valid once the callees have been populated.
@@ -89,50 +89,59 @@
     Callee& wasmEntrypointCalleeFromFunctionIndexSpace(unsigned functionIndexSpace)
     {
         ASSERT(runnable());
         RELEASE_ASSERT(functionIndexSpace >= functionImportCount());
         unsigned calleeIndex = functionIndexSpace - functionImportCount();
-        if (m_optimizedCallees[calleeIndex])
-            return *m_optimizedCallees[calleeIndex].get();
-        return *m_callees[calleeIndex].get();
+        if (m_omgCallees[calleeIndex])
+            return *m_omgCallees[calleeIndex].get();
+        if (m_bbqCallees[calleeIndex])
+            return *m_bbqCallees[calleeIndex].get();
+        return m_llintCallees->at(calleeIndex).get();
     }
 
-    Callee& wasmBBQCalleeFromFunctionIndexSpace(unsigned functionIndexSpace)
+    BBQCallee& wasmBBQCalleeFromFunctionIndexSpace(unsigned functionIndexSpace)
     {
         ASSERT(runnable());
         RELEASE_ASSERT(functionIndexSpace >= functionImportCount());
         unsigned calleeIndex = functionIndexSpace - functionImportCount();
-        return *m_callees[calleeIndex].get();
+        return *m_bbqCallees[calleeIndex].get();
     }
 
     MacroAssemblerCodePtr<WasmEntryPtrTag>* entrypointLoadLocationFromFunctionIndexSpace(unsigned functionIndexSpace)
     {
         RELEASE_ASSERT(functionIndexSpace >= functionImportCount());
         unsigned calleeIndex = functionIndexSpace - functionImportCount();
         return &m_wasmIndirectCallEntryPoints[calleeIndex];
     }
 
+    MacroAssemblerCodePtr<WasmEntryPtrTag> wasmToWasmExitStub(unsigned functionIndex)
+    {
+        return m_wasmToWasmExitStubs[functionIndex].code();
+    }
+
     bool isSafeToRun(MemoryMode);
 
     MemoryMode mode() const { return m_mode; }
 
     ~CodeBlock();
 private:
+    friend class BBQPlan;
     friend class OMGPlan;
     friend class OMGForOSREntryPlan;
 
-    CodeBlock(Context*, MemoryMode, ModuleInformation&, CreateEmbedderWrapper&&, ThrowWasmException);
+    CodeBlock(Context*, MemoryMode, ModuleInformation&, RefPtr<LLIntCallees>);
     void setCompilationFinished();
     unsigned m_calleeCount;
     MemoryMode m_mode;
-    Vector<RefPtr<Callee>> m_callees;
-    Vector<RefPtr<Callee>> m_optimizedCallees;
-    HashMap<uint32_t, RefPtr<Callee>, typename DefaultHash<uint32_t>::Hash, WTF::UnsignedWithZeroKeyHashTraits<uint32_t>> m_embedderCallees;
+    Vector<RefPtr<OMGCallee>> m_omgCallees;
+    Vector<RefPtr<BBQCallee>> m_bbqCallees;
+    RefPtr<LLIntCallees> m_llintCallees;
+    HashMap<uint32_t, RefPtr<EmbedderEntrypointCallee>, typename DefaultHash<uint32_t>::Hash, WTF::UnsignedWithZeroKeyHashTraits<uint32_t>> m_embedderCallees;
     Vector<MacroAssemblerCodePtr<WasmEntryPtrTag>> m_wasmIndirectCallEntryPoints;
     Vector<Vector<UnlinkedWasmToWasmCall>> m_wasmToWasmCallsites;
     Vector<MacroAssemblerCodeRef<WasmEntryPtrTag>> m_wasmToWasmExitStubs;
-    RefPtr<BBQPlan> m_plan;
+    RefPtr<EntryPlan> m_plan;
     std::atomic<bool> m_compilationFinished { false };
     String m_errorMessage;
     Lock m_lock;
 };
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCStatsCollector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCStatsCollector.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;JSDOMMapLike.h&quot;
 31 #include &quot;JSRTCStatsReport.h&quot;
 32 #include &quot;Performance.h&quot;
 33 #include &lt;wtf/MainThread.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 LibWebRTCStatsCollector::LibWebRTCStatsCollector(CollectorCallback&amp;&amp; callback)
 38     : m_callback(WTFMove(callback))
 39 {
 40 }
 41 
 42 LibWebRTCStatsCollector::~LibWebRTCStatsCollector()
 43 {
 44     if (!m_callback)
 45         return;
 46 
 47     callOnMainThread([callback = WTFMove(m_callback)]() mutable {
 48         callback(nullptr);
 49     });
 50 }
 51 
 52 static inline String fromStdString(const std::string&amp; value)
 53 {
 54     return String::fromUTF8(value.data(), value.length());
 55 }
 56 
 57 static inline void fillRTCStats(RTCStatsReport::Stats&amp; stats, const webrtc::RTCStats&amp; rtcStats)
 58 {
 59     stats.timestamp = Performance::reduceTimeResolution(Seconds::fromMicroseconds(rtcStats.timestamp_us())).milliseconds();
 60     stats.id = fromStdString(rtcStats.id());
 61 }
 62 
 63 static inline void fillRTCRTPStreamStats(RTCStatsReport::RTCRTPStreamStats&amp; stats, const webrtc::RTCRTPStreamStats&amp; rtcStats)
 64 {
 65     fillRTCStats(stats, rtcStats);
 66 
 67     if (rtcStats.ssrc.is_defined())
 68         stats.ssrc = *rtcStats.ssrc;
 69     if (rtcStats.associate_stats_id.is_defined())
 70         stats.associateStatsId = fromStdString(*rtcStats.associate_stats_id);
 71     if (rtcStats.is_remote.is_defined())
 72         stats.isRemote = *rtcStats.is_remote;
 73     if (rtcStats.media_type.is_defined())
 74         stats.mediaType = fromStdString(*rtcStats.media_type);
 75     if (rtcStats.track_id.is_defined())
 76         stats.trackId = fromStdString(*rtcStats.track_id);
 77     if (rtcStats.transport_id.is_defined())
 78         stats.transportId = fromStdString(*rtcStats.transport_id);
 79     if (rtcStats.codec_id.is_defined())
 80         stats.codecId = fromStdString(*rtcStats.codec_id);
 81     if (rtcStats.fir_count.is_defined())
 82         stats.firCount = *rtcStats.fir_count;
 83     if (rtcStats.pli_count.is_defined())
 84         stats.pliCount = *rtcStats.pli_count;
 85     if (rtcStats.nack_count.is_defined())
 86         stats.nackCount = *rtcStats.nack_count;
 87     if (rtcStats.sli_count.is_defined())
 88         stats.sliCount = *rtcStats.sli_count;
 89     if (rtcStats.qp_sum.is_defined())
 90         stats.qpSum = *rtcStats.qp_sum;
 91     stats.qpSum = 0;
 92 }
 93 
 94 static inline void fillInboundRTPStreamStats(RTCStatsReport::InboundRTPStreamStats&amp; stats, const webrtc::RTCInboundRTPStreamStats&amp; rtcStats)
 95 {
 96     fillRTCRTPStreamStats(stats, rtcStats);
 97 
 98     // FIXME: Add support for decoder_implementation
 99     if (rtcStats.packets_received.is_defined())
100         stats.packetsReceived = *rtcStats.packets_received;
101     if (rtcStats.bytes_received.is_defined())
102         stats.bytesReceived = *rtcStats.bytes_received;
103     if (rtcStats.packets_lost.is_defined())
104         stats.packetsLost = *rtcStats.packets_lost;
105     if (rtcStats.jitter.is_defined())
106         stats.jitter = *rtcStats.jitter;
107     // FIXME: Add support back for fractionLost.
108     if (rtcStats.packets_discarded.is_defined())
109         stats.packetsDiscarded = *rtcStats.packets_discarded;
110     if (rtcStats.packets_repaired.is_defined())
111         stats.packetsRepaired = *rtcStats.packets_repaired;
112     if (rtcStats.burst_packets_lost.is_defined())
113         stats.burstPacketsLost = *rtcStats.burst_packets_lost;
114     if (rtcStats.burst_packets_discarded.is_defined())
115         stats.burstPacketsDiscarded = *rtcStats.burst_packets_discarded;
116     if (rtcStats.burst_loss_count.is_defined())
117         stats.burstLossCount = *rtcStats.burst_loss_count;
118     if (rtcStats.burst_discard_count.is_defined())
119         stats.burstDiscardCount = *rtcStats.burst_discard_count;
120     if (rtcStats.burst_loss_rate.is_defined())
121         stats.burstLossRate = *rtcStats.burst_loss_rate;
122     if (rtcStats.burst_discard_rate.is_defined())
123         stats.burstDiscardRate = *rtcStats.burst_discard_rate;
124     if (rtcStats.gap_loss_rate.is_defined())
125         stats.gapLossRate = *rtcStats.gap_loss_rate;
126     if (rtcStats.gap_discard_rate.is_defined())
127         stats.gapDiscardRate = *rtcStats.gap_discard_rate;
128     if (rtcStats.frames_decoded.is_defined())
129         stats.framesDecoded = *rtcStats.frames_decoded;
130 }
131 
132 static inline void fillOutboundRTPStreamStats(RTCStatsReport::OutboundRTPStreamStats&amp; stats, const webrtc::RTCOutboundRTPStreamStats&amp; rtcStats)
133 {
134     fillRTCRTPStreamStats(stats, rtcStats);
135 
136     // FIXME: Add support for encoder_implementation
137     if (rtcStats.packets_sent.is_defined())
138         stats.packetsSent = *rtcStats.packets_sent;
139     if (rtcStats.bytes_sent.is_defined())
140         stats.bytesSent = *rtcStats.bytes_sent;
141     if (rtcStats.target_bitrate.is_defined())
142         stats.targetBitrate = *rtcStats.target_bitrate;
143     if (rtcStats.frames_encoded.is_defined())
144         stats.framesEncoded = *rtcStats.frames_encoded;
145 }
146 
147 static inline void fillRTCMediaStreamTrackStats(RTCStatsReport::MediaStreamTrackStats&amp; stats, const webrtc::RTCMediaStreamTrackStats&amp; rtcStats)
148 {
149     fillRTCStats(stats, rtcStats);
150 
151     if (rtcStats.track_identifier.is_defined())
152         stats.trackIdentifier = fromStdString(*rtcStats.track_identifier);
153     if (rtcStats.remote_source.is_defined())
154         stats.remoteSource = *rtcStats.remote_source;
155     if (rtcStats.ended.is_defined())
156         stats.ended = *rtcStats.ended;
157     if (rtcStats.detached.is_defined())
158         stats.detached = *rtcStats.detached;
159     if (rtcStats.frame_width.is_defined())
160         stats.frameWidth = *rtcStats.frame_width;
161     if (rtcStats.frame_height.is_defined())
162         stats.frameHeight = *rtcStats.frame_height;
163     if (rtcStats.frames_per_second.is_defined())
164         stats.framesPerSecond = *rtcStats.frames_per_second;
165     if (rtcStats.frames_sent.is_defined())
166         stats.framesSent = *rtcStats.frames_sent;
167     if (rtcStats.frames_received.is_defined())
168         stats.framesReceived = *rtcStats.frames_received;
169     if (rtcStats.frames_decoded.is_defined())
170         stats.framesDecoded = *rtcStats.frames_decoded;
171     if (rtcStats.frames_dropped.is_defined())
172         stats.framesDropped = *rtcStats.frames_dropped;
173     if (rtcStats.partial_frames_lost.is_defined())
174         stats.partialFramesLost = *rtcStats.partial_frames_lost;
175     if (rtcStats.full_frames_lost.is_defined())
176         stats.fullFramesLost = *rtcStats.full_frames_lost;
177     if (rtcStats.audio_level.is_defined())
178         stats.audioLevel = *rtcStats.audio_level;
179     if (rtcStats.echo_return_loss.is_defined())
180         stats.echoReturnLoss = *rtcStats.echo_return_loss;
181     if (rtcStats.echo_return_loss_enhancement.is_defined())
182         stats.echoReturnLossEnhancement = *rtcStats.echo_return_loss_enhancement;
183 }
184 
185 static inline void fillRTCDataChannelStats(RTCStatsReport::DataChannelStats&amp; stats, const webrtc::RTCDataChannelStats&amp; rtcStats)
186 {
187     fillRTCStats(stats, rtcStats);
188 
189     if (rtcStats.label.is_defined())
190         stats.label = fromStdString(*rtcStats.label);
191     if (rtcStats.protocol.is_defined())
192         stats.protocol = fromStdString(*rtcStats.protocol);
193     if (rtcStats.datachannelid.is_defined())
194         stats.datachannelid = *rtcStats.datachannelid;
195     if (rtcStats.state.is_defined())
196         stats.state = fromStdString(*rtcStats.state);
197     if (rtcStats.messages_sent.is_defined())
198         stats.messagesSent = *rtcStats.messages_sent;
199     if (rtcStats.bytes_sent.is_defined())
200         stats.bytesSent = *rtcStats.bytes_sent;
201     if (rtcStats.messages_received.is_defined())
202         stats.messagesReceived = *rtcStats.messages_received;
203     if (rtcStats.bytes_received.is_defined())
204         stats.bytesReceived = *rtcStats.bytes_received;
205 }
206 
207 static inline RTCStatsReport::IceCandidatePairState iceCandidatePairState(const std::string&amp; state)
208 {
209     if (state == &quot;frozen&quot;)
210         return RTCStatsReport::IceCandidatePairState::Frozen;
211     if (state == &quot;waiting&quot;)
212         return RTCStatsReport::IceCandidatePairState::Waiting;
213     if (state == &quot;in-progress&quot;)
214         return RTCStatsReport::IceCandidatePairState::Inprogress;
215     if (state == &quot;failed&quot;)
216         return RTCStatsReport::IceCandidatePairState::Failed;
217     if (state == &quot;succeeded&quot;)
218         return RTCStatsReport::IceCandidatePairState::Succeeded;
219     if (state == &quot;cancelled&quot;)
220         return RTCStatsReport::IceCandidatePairState::Cancelled;
221     ASSERT_NOT_REACHED();
222     return RTCStatsReport::IceCandidatePairState::Frozen;
223 }
224 
225 static inline void fillRTCIceCandidatePairStats(RTCStatsReport::IceCandidatePairStats&amp; stats, const webrtc::RTCIceCandidatePairStats&amp; rtcStats)
226 {
227     fillRTCStats(stats, rtcStats);
228 
229     if (rtcStats.transport_id.is_defined())
230         stats.transportId = fromStdString(*rtcStats.transport_id);
231     if (rtcStats.local_candidate_id.is_defined())
232         stats.localCandidateId = fromStdString(*rtcStats.local_candidate_id);
233     if (rtcStats.remote_candidate_id.is_defined())
234         stats.remoteCandidateId = fromStdString(*rtcStats.remote_candidate_id);
235     if (rtcStats.state.is_defined())
236         stats.state = iceCandidatePairState(*rtcStats.state);
237 
238     if (rtcStats.priority.is_defined())
239         stats.priority = *rtcStats.priority;
240     if (rtcStats.nominated.is_defined())
241         stats.nominated = *rtcStats.nominated;
242     if (rtcStats.writable.is_defined())
243         stats.writable = *rtcStats.writable;
244     if (rtcStats.readable.is_defined())
245         stats.readable = *rtcStats.readable;
246 
247     if (rtcStats.bytes_sent.is_defined())
248         stats.bytesSent = *rtcStats.bytes_sent;
249     if (rtcStats.bytes_received.is_defined())
250         stats.bytesReceived = *rtcStats.bytes_received;
251     if (rtcStats.total_round_trip_time.is_defined())
252         stats.totalRoundTripTime = *rtcStats.total_round_trip_time;
253     if (rtcStats.current_round_trip_time.is_defined())
254         stats.currentRoundTripTime = *rtcStats.current_round_trip_time;
255     if (rtcStats.available_outgoing_bitrate.is_defined())
256         stats.availableOutgoingBitrate = *rtcStats.available_outgoing_bitrate;
257     if (rtcStats.available_incoming_bitrate.is_defined())
258         stats.availableIncomingBitrate = *rtcStats.available_incoming_bitrate;
259 
260     if (rtcStats.requests_received.is_defined())
261         stats.requestsReceived = *rtcStats.requests_received;
262     if (rtcStats.requests_sent.is_defined())
263         stats.requestsSent = *rtcStats.requests_sent;
264     if (rtcStats.responses_received.is_defined())
265         stats.responsesReceived = *rtcStats.responses_received;
266     if (rtcStats.responses_sent.is_defined())
267         stats.responsesSent = *rtcStats.responses_sent;
268 
269     if (rtcStats.requests_received.is_defined())
270         stats.retransmissionsReceived = *rtcStats.requests_received;
271     if (rtcStats.requests_sent.is_defined())
272         stats.retransmissionsSent = *rtcStats.requests_sent;
273     if (rtcStats.responses_received.is_defined())
274         stats.consentRequestsReceived = *rtcStats.responses_received;
275     if (rtcStats.responses_sent.is_defined())
276         stats.consentRequestsSent = *rtcStats.responses_sent;
277     if (rtcStats.responses_received.is_defined())
278         stats.consentResponsesReceived = *rtcStats.responses_received;
279     if (rtcStats.responses_sent.is_defined())
280         stats.consentResponsesSent = *rtcStats.responses_sent;
281 }
282 
283 static inline Optional&lt;RTCStatsReport::IceCandidateType&gt; iceCandidateState(const std::string&amp; state)
284 {
285     if (state == &quot;host&quot;)
286         return RTCStatsReport::IceCandidateType::Host;
287     if (state == &quot;srflx&quot;)
288         return RTCStatsReport::IceCandidateType::Srflx;
289     if (state == &quot;prflx&quot;)
290         return RTCStatsReport::IceCandidateType::Prflx;
291     if (state == &quot;relay&quot;)
292         return RTCStatsReport::IceCandidateType::Relay;
293 
294     return { };
295 }
296 
297 static inline void fillRTCIceCandidateStats(RTCStatsReport::IceCandidateStats&amp; stats, const webrtc::RTCIceCandidateStats&amp; rtcStats)
298 {
299     stats.type = rtcStats.type() == webrtc::RTCRemoteIceCandidateStats::kType ? RTCStatsReport::Type::RemoteCandidate : RTCStatsReport::Type::LocalCandidate;
300 
301     fillRTCStats(stats, rtcStats);
302 
303     if (rtcStats.transport_id.is_defined())
304         stats.transportId = fromStdString(*rtcStats.transport_id);
305     if (rtcStats.ip.is_defined())
306         stats.address = fromStdString(*rtcStats.ip);
307     if (rtcStats.port.is_defined())
308         stats.port = *rtcStats.port;
309     if (rtcStats.protocol.is_defined())
310         stats.protocol = fromStdString(*rtcStats.protocol);
311 
312     if (rtcStats.candidate_type.is_defined())
313         stats.candidateType = iceCandidateState(*rtcStats.candidate_type);
314 
315     if (!stats.candidateType || stats.candidateType == RTCStatsReport::IceCandidateType::Prflx || stats.candidateType == RTCStatsReport::IceCandidateType::Host)
316         stats.address = { };
317 
318     if (rtcStats.priority.is_defined())
319         stats.priority = *rtcStats.priority;
320     if (rtcStats.url.is_defined())
321         stats.url = fromStdString(*rtcStats.url);
322     if (rtcStats.deleted.is_defined())
323         stats.deleted = *rtcStats.deleted;
324 }
325 
326 static inline void fillRTCCertificateStats(RTCStatsReport::CertificateStats&amp; stats, const webrtc::RTCCertificateStats&amp; rtcStats)
327 {
328     fillRTCStats(stats, rtcStats);
329 
330     if (rtcStats.fingerprint.is_defined())
331         stats.fingerprint = fromStdString(*rtcStats.fingerprint);
332     if (rtcStats.fingerprint_algorithm.is_defined())
333         stats.fingerprintAlgorithm = fromStdString(*rtcStats.fingerprint_algorithm);
334     if (rtcStats.base64_certificate.is_defined())
335         stats.base64Certificate = fromStdString(*rtcStats.base64_certificate);
336     if (rtcStats.issuer_certificate_id.is_defined())
337         stats.issuerCertificateId = fromStdString(*rtcStats.issuer_certificate_id);
338 }
339 
340 static inline void fillRTCCodecStats(RTCStatsReport::CodecStats&amp; stats, const webrtc::RTCCodecStats&amp; rtcStats)
341 {
342     fillRTCStats(stats, rtcStats);
343 
344     if (rtcStats.payload_type.is_defined())
345         stats.payloadType = *rtcStats.payload_type;
346     if (rtcStats.mime_type.is_defined())
347         stats.mimeType = fromStdString(*rtcStats.mime_type);
348     if (rtcStats.clock_rate.is_defined())
349         stats.clockRate = *rtcStats.clock_rate;
350     if (rtcStats.channels.is_defined())
351         stats.channels = *rtcStats.channels;
352     if (rtcStats.sdp_fmtp_line.is_defined())
353         stats.sdpFmtpLine = fromStdString(*rtcStats.sdp_fmtp_line);
354 }
355 
356 static inline void fillRTCTransportStats(RTCStatsReport::TransportStats&amp; stats, const webrtc::RTCTransportStats&amp; rtcStats)
357 {
358     fillRTCStats(stats, rtcStats);
359 
360     if (rtcStats.bytes_sent.is_defined())
361         stats.bytesSent = *rtcStats.bytes_sent;
362     if (rtcStats.bytes_received.is_defined())
363         stats.bytesReceived = *rtcStats.bytes_received;
364     if (rtcStats.rtcp_transport_stats_id.is_defined())
365         stats.rtcpTransportStatsId = fromStdString(*rtcStats.rtcp_transport_stats_id);
366     if (rtcStats.selected_candidate_pair_id.is_defined())
367         stats.selectedCandidatePairId = fromStdString(*rtcStats.selected_candidate_pair_id);
368     if (rtcStats.local_certificate_id.is_defined())
369         stats.localCertificateId = fromStdString(*rtcStats.local_certificate_id);
370     if (rtcStats.remote_certificate_id.is_defined())
371         stats.remoteCertificateId = fromStdString(*rtcStats.remote_certificate_id);
372 }
373 
374 static inline void fillRTCPeerConnectionStats(RTCStatsReport::PeerConnectionStats&amp; stats, const webrtc::RTCPeerConnectionStats&amp; rtcStats)
375 {
376     fillRTCStats(stats, rtcStats);
377 
378     if (rtcStats.data_channels_opened.is_defined())
379         stats.dataChannelsOpened = *rtcStats.data_channels_opened;
380     if (rtcStats.data_channels_closed.is_defined())
381         stats.dataChannelsClosed = *rtcStats.data_channels_closed;
382 }
383 
384 static inline void initializeRTCStatsReportBackingMap(DOMMapAdapter&amp; report, const webrtc::RTCStatsReport&amp; rtcReport)
385 {
386     for (const auto&amp; rtcStats : rtcReport) {
387         if (rtcStats.type() == webrtc::RTCInboundRTPStreamStats::kType) {
388             RTCStatsReport::InboundRTPStreamStats stats;
389             fillInboundRTPStreamStats(stats, static_cast&lt;const webrtc::RTCInboundRTPStreamStats&amp;&gt;(rtcStats));
390             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::InboundRTPStreamStats&gt;&gt;(stats.id, WTFMove(stats));
391         } else if (rtcStats.type() == webrtc::RTCOutboundRTPStreamStats::kType) {
392             RTCStatsReport::OutboundRTPStreamStats stats;
393             fillOutboundRTPStreamStats(stats, static_cast&lt;const webrtc::RTCOutboundRTPStreamStats&amp;&gt;(rtcStats));
394             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::OutboundRTPStreamStats&gt;&gt;(stats.id, WTFMove(stats));
395         } else if (rtcStats.type() == webrtc::RTCMediaStreamTrackStats::kType) {
396             RTCStatsReport::MediaStreamTrackStats stats;
397             fillRTCMediaStreamTrackStats(stats, static_cast&lt;const webrtc::RTCMediaStreamTrackStats&amp;&gt;(rtcStats));
398             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::MediaStreamTrackStats&gt;&gt;(stats.id, WTFMove(stats));
399         } else if (rtcStats.type() == webrtc::RTCDataChannelStats::kType) {
400             RTCStatsReport::DataChannelStats stats;
401             fillRTCDataChannelStats(stats, static_cast&lt;const webrtc::RTCDataChannelStats&amp;&gt;(rtcStats));
402             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::DataChannelStats&gt;&gt;(stats.id, WTFMove(stats));
403         } else if (rtcStats.type() == webrtc::RTCIceCandidatePairStats::kType) {
404             RTCStatsReport::IceCandidatePairStats stats;
405             fillRTCIceCandidatePairStats(stats, static_cast&lt;const webrtc::RTCIceCandidatePairStats&amp;&gt;(rtcStats));
406             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::IceCandidatePairStats&gt;&gt;(stats.id, WTFMove(stats));
407         } else if (rtcStats.type() == webrtc::RTCRemoteIceCandidateStats::kType || rtcStats.type() == webrtc::RTCLocalIceCandidateStats::kType) {
408             RTCStatsReport::IceCandidateStats stats;
409             fillRTCIceCandidateStats(stats, static_cast&lt;const webrtc::RTCIceCandidateStats&amp;&gt;(rtcStats));
410             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::IceCandidateStats&gt;&gt;(stats.id, WTFMove(stats));
411         } else if (rtcStats.type() == webrtc::RTCCertificateStats::kType) {
412             RTCStatsReport::CertificateStats stats;
413             fillRTCCertificateStats(stats, static_cast&lt;const webrtc::RTCCertificateStats&amp;&gt;(rtcStats));
414             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::CertificateStats&gt;&gt;(stats.id, WTFMove(stats));
415         } else if (rtcStats.type() == webrtc::RTCCodecStats::kType) {
416             RTCStatsReport::CodecStats stats;
417             fillRTCCodecStats(stats, static_cast&lt;const webrtc::RTCCodecStats&amp;&gt;(rtcStats));
418             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::CodecStats&gt;&gt;(stats.id, WTFMove(stats));
419         } else if (rtcStats.type() == webrtc::RTCTransportStats::kType) {
420             RTCStatsReport::TransportStats stats;
421             fillRTCTransportStats(stats, static_cast&lt;const webrtc::RTCTransportStats&amp;&gt;(rtcStats));
422             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::TransportStats&gt;&gt;(stats.id, WTFMove(stats));
423         } else if (rtcStats.type() == webrtc::RTCPeerConnectionStats::kType) {
424             RTCStatsReport::PeerConnectionStats stats;
425             fillRTCPeerConnectionStats(stats, static_cast&lt;const webrtc::RTCPeerConnectionStats&amp;&gt;(rtcStats));
426             report.set&lt;IDLDOMString, IDLDictionary&lt;RTCStatsReport::PeerConnectionStats&gt;&gt;(stats.id, WTFMove(stats));
427         }
428     }
429 }
430 
431 void LibWebRTCStatsCollector::OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; rtcReport)
432 {
433     callOnMainThread([this, protectedThis = rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt;(this), rtcReport]() {
434         m_callback(RTCStatsReport::create([rtcReport](auto&amp; mapAdapter) {
435             if (rtcReport)
436                 initializeRTCStatsReportBackingMap(mapAdapter, *rtcReport);
437         }));
438     });
439 }
440 
441 }; // namespace WTF
442 
443 
444 #endif // USE(LIBWEBRTC)
    </pre>
  </body>
</html>
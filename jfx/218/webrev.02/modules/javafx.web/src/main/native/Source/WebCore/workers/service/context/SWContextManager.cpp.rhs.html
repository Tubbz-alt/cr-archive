<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWContextManager.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;Logging.h&quot;
 31 #include &quot;MessageWithMessagePorts.h&quot;
 32 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 33 #include &quot;ServiceWorkerGlobalScope.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 SWContextManager&amp; SWContextManager::singleton()
 38 {
 39     static SWContextManager* sharedManager = new SWContextManager;
 40     return *sharedManager;
 41 }
 42 
 43 void SWContextManager::setConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
 44 {
<a name="1" id="anc1"></a><span class="line-modified"> 45     ASSERT(!m_connection || m_connection-&gt;isClosed());</span>
 46     m_connection = WTFMove(connection);
 47 }
 48 
 49 auto SWContextManager::connection() const -&gt; Connection*
 50 {
 51     return m_connection.get();
 52 }
 53 
 54 void SWContextManager::registerServiceWorkerThreadForInstall(Ref&lt;ServiceWorkerThreadProxy&gt;&amp;&amp; serviceWorkerThreadProxy)
 55 {
 56     auto serviceWorkerIdentifier = serviceWorkerThreadProxy-&gt;identifier();
 57     auto jobDataIdentifier = serviceWorkerThreadProxy-&gt;thread().contextData().jobDataIdentifier;
 58     auto* threadProxy = serviceWorkerThreadProxy.ptr();
 59     auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
 60     ASSERT_UNUSED(result, result.isNewEntry);
 61 
<a name="2" id="anc2"></a><span class="line-modified"> 62     threadProxy-&gt;thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String&amp; exceptionMessage, bool doesHandleFetch) {</span>
<span class="line-modified"> 63         SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage, doesHandleFetch);</span>
 64     });
 65 }
 66 
<a name="3" id="anc3"></a><span class="line-modified"> 67 void SWContextManager::startedServiceWorker(Optional&lt;ServiceWorkerJobDataIdentifier&gt; jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String&amp; exceptionMessage, bool doesHandleFetch)</span>
 68 {
<a name="4" id="anc4"></a>
 69     if (m_serviceWorkerCreationCallback)
 70         m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());
<a name="5" id="anc5"></a><span class="line-added"> 71     if (!exceptionMessage.isEmpty()) {</span>
<span class="line-added"> 72         connection()-&gt;serviceWorkerFailedToStart(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
<span class="line-added"> 73         return;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75     connection()-&gt;serviceWorkerStarted(jobDataIdentifier, serviceWorkerIdentifier, doesHandleFetch);</span>
 76 }
 77 
 78 ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
 79 {
 80     return m_workerMap.get(identifier);
 81 }
 82 
 83 void SWContextManager::postMessageToServiceWorker(ServiceWorkerIdentifier destination, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)
 84 {
 85     auto* serviceWorker = m_workerMap.get(destination);
 86     ASSERT(serviceWorker);
 87     ASSERT(!serviceWorker-&gt;isTerminatingOrTerminated());
 88 
 89     // FIXME: We should pass valid MessagePortChannels.
<a name="6" id="anc6"></a><span class="line-modified"> 90     serviceWorker-&gt;postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));</span>
 91 }
 92 
 93 void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
 94 {
 95     auto* serviceWorker = m_workerMap.get(identifier);
 96     if (!serviceWorker)
 97         return;
 98 
<a name="7" id="anc7"></a><span class="line-modified"> 99     serviceWorker-&gt;fireInstallEvent();</span>
100 }
101 
102 void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
103 {
104     auto* serviceWorker = m_workerMap.get(identifier);
105     if (!serviceWorker)
106         return;
107 
<a name="8" id="anc8"></a><span class="line-modified">108     serviceWorker-&gt;fireActivateEvent();</span>
109 }
110 
111 void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
112 {
113     auto serviceWorker = m_workerMap.take(identifier);
114     if (!serviceWorker) {
115         if (completionHandler)
116             completionHandler();
117         return;
118     }
<a name="9" id="anc9"></a><span class="line-added">119     stopWorker(*serviceWorker, timeout, WTFMove(completionHandler));</span>
<span class="line-added">120 }</span>
121 
<a name="10" id="anc10"></a><span class="line-modified">122 void SWContextManager::stopWorker(ServiceWorkerThreadProxy&amp; serviceWorker, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)</span>
<span class="line-added">123 {</span>
<span class="line-added">124     auto identifier = serviceWorker.identifier();</span>
<span class="line-added">125     serviceWorker.setAsTerminatingOrTerminated();</span>
126 
127     m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique&lt;ServiceWorkerTerminationRequest&gt;(*this, identifier, timeout));
128 
<a name="11" id="anc11"></a><span class="line-modified">129     auto&amp; thread = serviceWorker.thread();</span>
<span class="line-modified">130     thread.stop([this, identifier, serviceWorker = makeRef(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {</span>
131         m_pendingServiceWorkerTerminationRequests.remove(identifier);
132 
133         if (auto* connection = SWContextManager::singleton().connection())
134             connection-&gt;workerTerminated(identifier);
135 
136         if (completionHandler)
137             completionHandler();
138 
139         // Spin the runloop before releasing the worker thread proxy, as there would otherwise be
140         // a race towards its destruction.
141         callOnMainThread([serviceWorker = WTFMove(serviceWorker)] { });
142     });
143 }
144 
145 void SWContextManager::forEachServiceWorkerThread(const WTF::Function&lt;void(ServiceWorkerThreadProxy&amp;)&gt;&amp; apply)
146 {
147     for (auto&amp; workerThread : m_workerMap.values())
<a name="12" id="anc12"></a><span class="line-modified">148         apply(workerThread);</span>
149 }
150 
151 bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function&lt;void(ServiceWorkerGlobalScope&amp;)&gt;&amp;&amp; task)
152 {
153     auto* serviceWorker = m_workerMap.get(identifier);
154     if (!serviceWorker)
155         return false;
156 
157     serviceWorker-&gt;thread().runLoop().postTask([task = WTFMove(task)] (auto&amp; context) {
158         task(downcast&lt;ServiceWorkerGlobalScope&gt;(context));
159     });
160     return true;
161 }
162 
163 void SWContextManager::serviceWorkerFailedToTerminate(ServiceWorkerIdentifier serviceWorkerIdentifier)
164 {
165     UNUSED_PARAM(serviceWorkerIdentifier);
166     RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to terminate service worker with identifier %s, killing the service worker process&quot;, serviceWorkerIdentifier.loggingString().utf8().data());
<a name="13" id="anc13"></a><span class="line-added">167     ASSERT_NOT_REACHED();</span>
168     _exit(EXIT_FAILURE);
169 }
170 
171 SWContextManager::ServiceWorkerTerminationRequest::ServiceWorkerTerminationRequest(SWContextManager&amp; manager, ServiceWorkerIdentifier serviceWorkerIdentifier, Seconds timeout)
172     : m_timeoutTimer([&amp;manager, serviceWorkerIdentifier] { manager.serviceWorkerFailedToTerminate(serviceWorkerIdentifier); })
173 {
174     m_timeoutTimer.startOneShot(timeout);
175 }
176 
<a name="14" id="anc14"></a><span class="line-added">177 void SWContextManager::stopAllServiceWorkers()</span>
<span class="line-added">178 {</span>
<span class="line-added">179     auto serviceWorkers = WTFMove(m_workerMap);</span>
<span class="line-added">180     for (auto&amp; serviceWorker : serviceWorkers.values())</span>
<span class="line-added">181         stopWorker(serviceWorker, workerTerminationTimeout, [] { });</span>
<span class="line-added">182 }</span>
<span class="line-added">183 </span>
184 } // namespace WebCore
185 
186 #endif
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
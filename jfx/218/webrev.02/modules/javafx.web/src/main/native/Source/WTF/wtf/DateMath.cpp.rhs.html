<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/DateMath.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   4  * Copyright (C) 2009 Google Inc. All rights reserved.
   5  * Copyright (C) 2007-2009 Torch Mobile, Inc.
   6  * Copyright (C) 2010 &amp;yet, LLC. (nate@andyet.net)
   7  *
   8  * The Original Code is Mozilla Communicator client code, released
   9  * March 31, 1998.
  10  *
  11  * The Initial Developer of the Original Code is
  12  * Netscape Communications Corporation.
  13  * Portions created by the Initial Developer are Copyright (C) 1998
  14  * the Initial Developer. All Rights Reserved.
  15  *
  16  * This library is free software; you can redistribute it and/or
  17  * modify it under the terms of the GNU Lesser General Public
  18  * License as published by the Free Software Foundation; either
  19  * version 2.1 of the License, or (at your option) any later version.
  20  *
  21  * This library is distributed in the hope that it will be useful,
  22  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  23  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  24  * Lesser General Public License for more details.
  25  *
  26  * You should have received a copy of the GNU Lesser General Public
  27  * License along with this library; if not, write to the Free Software
  28  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  29  *
  30  * Alternatively, the contents of this file may be used under the terms
  31  * of either the Mozilla Public License Version 1.1, found at
  32  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
  33  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
  34  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
  35  * applicable instead of those above.  If you wish to allow use of your
  36  * version of this file only under the terms of one of those two
  37  * licenses (the MPL or the GPL) and not to allow others to use your
  38  * version of this file under the LGPL, indicate your decision by
  39  * deletingthe provisions above and replace them with the notice and
  40  * other provisions required by the MPL or the GPL, as the case may be.
  41  * If you do not delete the provisions above, a recipient may use your
  42  * version of this file under any of the LGPL, the MPL or the GPL.
  43 
  44  * Copyright 2006-2008 the V8 project authors. All rights reserved.
  45  * Redistribution and use in source and binary forms, with or without
  46  * modification, are permitted provided that the following conditions are
  47  * met:
  48  *
  49  *     * Redistributions of source code must retain the above copyright
  50  *       notice, this list of conditions and the following disclaimer.
  51  *     * Redistributions in binary form must reproduce the above
  52  *       copyright notice, this list of conditions and the following
  53  *       disclaimer in the documentation and/or other materials provided
  54  *       with the distribution.
  55  *     * Neither the name of Google Inc. nor the names of its
  56  *       contributors may be used to endorse or promote products derived
  57  *       from this software without specific prior written permission.
  58  *
  59  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  60  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  61  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  62  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  63  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  64  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  65  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  66  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  67  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  68  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  69  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  70  */
  71 
  72 #include &quot;config.h&quot;
  73 #include &lt;wtf/DateMath.h&gt;
  74 
  75 #include &lt;algorithm&gt;
  76 #include &lt;limits.h&gt;
  77 #include &lt;limits&gt;
  78 #include &lt;stdint.h&gt;
  79 #include &lt;time.h&gt;
  80 #include &lt;wtf/Assertions.h&gt;
  81 #include &lt;wtf/ASCIICType.h&gt;
  82 #include &lt;wtf/MathExtras.h&gt;
  83 #include &lt;wtf/StdLibExtras.h&gt;
  84 #include &lt;wtf/text/StringBuilder.h&gt;
  85 
  86 #if OS(WINDOWS)
  87 #include &lt;windows.h&gt;
  88 #endif
  89 
  90 #if HAVE(ERRNO_H)
  91 #include &lt;errno.h&gt;
  92 #endif
  93 
  94 #if HAVE(SYS_TIME_H)
  95 #include &lt;sys/time.h&gt;
  96 #endif
  97 
  98 #if HAVE(SYS_TIMEB_H)
  99 #include &lt;sys/timeb.h&gt;
 100 #endif
 101 
 102 namespace WTF {
 103 
 104 // FIXME: Should this function go into StringCommon.h or some other header?
 105 template&lt;unsigned length&gt; inline bool startsWithLettersIgnoringASCIICase(const char* string, const char (&amp;lowercaseLetters)[length])
 106 {
 107     return equalLettersIgnoringASCIICase(string, lowercaseLetters, length - 1);
 108 }
 109 
 110 /* Constants */
 111 
<a name="2" id="anc2"></a><span class="line-modified"> 112 const char* const weekdayName[7] = { &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot; };</span>
<span class="line-modified"> 113 const char* const monthName[12] = { &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; };</span>
<span class="line-modified"> 114 const char* const monthFullName[12] = { &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; };</span>


 115 
 116 // Day of year for the first day of each month, where index 0 is January, and day 0 is January 1.
 117 // First for non-leap years, then for leap years.
<a name="3" id="anc3"></a><span class="line-modified"> 118 const int firstDayOfMonth[2][12] = {</span>
 119     {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
 120     {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}
 121 };
 122 
 123 #if !OS(WINDOWS) || HAVE(TM_GMTOFF)
 124 static inline void getLocalTime(const time_t* localTime, struct tm* localTM)
 125 {
 126 #if HAVE(LOCALTIME_R)
 127     localtime_r(localTime, localTM);
 128 #else
 129     localtime_s(localTime, localTM);
 130 #endif
 131 }
 132 #endif
 133 
<a name="4" id="anc4"></a>







































 134 static void appendTwoDigitNumber(StringBuilder&amp; builder, int number)
 135 {
 136     ASSERT(number &gt;= 0);
 137     ASSERT(number &lt; 100);
 138     builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number / 10));
 139     builder.append(static_cast&lt;LChar&gt;(&#39;0&#39; + number % 10));
 140 }
 141 
<a name="5" id="anc5"></a>















 142 static inline double msToMilliseconds(double ms)
 143 {
 144     double result = fmod(ms, msPerDay);
 145     if (result &lt; 0)
 146         result += msPerDay;
 147     return result;
 148 }
 149 
<a name="6" id="anc6"></a>










































































































 150 // There is a hard limit at 2038 that we currently do not have a workaround
 151 // for (rdar://problem/5052975).
 152 static inline int maximumYearForDST()
 153 {
 154     return 2037;
 155 }
 156 
 157 static inline int minimumYearForDST()
 158 {
 159     // Because of the 2038 issue (see maximumYearForDST) if the current year is
 160     // greater than the max year minus 27 (2010), we want to use the max year
 161     // minus 27 instead, to ensure there is a range of 28 years that all years
 162     // can map to.
 163     return std::min(msToYear(jsCurrentTime()), maximumYearForDST() - 27) ;
 164 }
 165 
 166 /*
 167  * Find an equivalent year for the one given, where equivalence is deterined by
 168  * the two years having the same leapness and the first day of the year, falling
 169  * on the same day of the week.
 170  *
 171  * This function returns a year between this current year and 2037, however this
 172  * function will potentially return incorrect results if the current year is after
 173  * 2010, (rdar://problem/5052975), if the year passed in is before 1900 or after
 174  * 2100, (rdar://problem/5055038).
 175  */
 176 int equivalentYearForDST(int year)
 177 {
 178     // It is ok if the cached year is not the current year as long as the rules
 179     // for DST did not change between the two years; if they did the app would need
 180     // to be restarted.
 181     static int minYear = minimumYearForDST();
 182     int maxYear = maximumYearForDST();
 183 
 184     int difference;
 185     if (year &gt; maxYear)
 186         difference = minYear - year;
 187     else if (year &lt; minYear)
 188         difference = maxYear - year;
 189     else
 190         return year;
 191 
 192     int quotient = difference / 28;
 193     int product = (quotient) * 28;
 194 
 195     year += product;
 196     return year;
 197 }
 198 
 199 #if OS(WINDOWS)
 200 typedef BOOL(WINAPI* callGetTimeZoneInformationForYear_t)(USHORT, PDYNAMIC_TIME_ZONE_INFORMATION, LPTIME_ZONE_INFORMATION);
 201 
 202 static callGetTimeZoneInformationForYear_t timeZoneInformationForYearFunction()
 203 {
 204     static callGetTimeZoneInformationForYear_t getTimeZoneInformationForYear = nullptr;
 205 
 206     if (getTimeZoneInformationForYear)
 207         return getTimeZoneInformationForYear;
 208 
 209     HMODULE module = ::GetModuleHandleW(L&quot;kernel32.dll&quot;);
 210     if (!module)
 211         return nullptr;
 212 
 213     getTimeZoneInformationForYear = reinterpret_cast&lt;callGetTimeZoneInformationForYear_t&gt;(::GetProcAddress(module, &quot;GetTimeZoneInformationForYear&quot;));
 214 
 215     return getTimeZoneInformationForYear;
 216 }
 217 #endif
 218 
 219 static int32_t calculateUTCOffset()
 220 {
 221 #if OS(WINDOWS)
 222     TIME_ZONE_INFORMATION timeZoneInformation;
 223     DWORD rc = 0;
 224 
 225     if (callGetTimeZoneInformationForYear_t timeZoneFunction = timeZoneInformationForYearFunction()) {
 226         // If available, use the Windows API call that takes into account the varying DST from
 227         // year to year.
 228         SYSTEMTIME systemTime;
 229         ::GetSystemTime(&amp;systemTime);
 230         rc = timeZoneFunction(systemTime.wYear, nullptr, &amp;timeZoneInformation);
 231         if (rc == TIME_ZONE_ID_INVALID)
 232             return 0;
 233     } else {
 234         rc = ::GetTimeZoneInformation(&amp;timeZoneInformation);
 235         if (rc == TIME_ZONE_ID_INVALID)
 236             return 0;
 237     }
 238 
 239     int32_t bias = timeZoneInformation.Bias;
 240 
 241     if (rc == TIME_ZONE_ID_DAYLIGHT)
 242         bias += timeZoneInformation.DaylightBias;
 243     else if (rc == TIME_ZONE_ID_STANDARD || rc == TIME_ZONE_ID_UNKNOWN)
 244         bias += timeZoneInformation.StandardBias;
 245 
 246     return -bias * 60 * 1000;
 247 #else
 248     time_t localTime = time(0);
 249     tm localt;
 250     getLocalTime(&amp;localTime, &amp;localt);
 251 
 252     // Get the difference between this time zone and UTC on the 1st of January of this year.
 253     localt.tm_sec = 0;
 254     localt.tm_min = 0;
 255     localt.tm_hour = 0;
 256     localt.tm_mday = 1;
 257     localt.tm_mon = 0;
 258     // Not setting localt.tm_year!
 259     localt.tm_wday = 0;
 260     localt.tm_yday = 0;
 261     localt.tm_isdst = 0;
 262 #if HAVE(TM_GMTOFF)
 263     localt.tm_gmtoff = 0;
 264 #endif
 265 #if HAVE(TM_ZONE)
 266     localt.tm_zone = 0;
 267 #endif
 268 
 269 #if HAVE(TIMEGM)
 270     time_t utcOffset = timegm(&amp;localt) - mktime(&amp;localt);
 271 #else
<a name="7" id="anc7"></a><span class="line-modified"> 272     // Using a canned date of 01/01/2019 on platforms with weaker date-handling foo.</span>
<span class="line-modified"> 273     localt.tm_year = 119;</span>
<span class="line-modified"> 274     time_t utcOffset = 1546300800 - mktime(&amp;localt);</span>
 275 #endif
 276 
 277     return static_cast&lt;int32_t&gt;(utcOffset * 1000);
 278 #endif
 279 }
 280 
 281 #if !HAVE(TM_GMTOFF)
 282 
 283 #if OS(WINDOWS)
 284 // Code taken from http://support.microsoft.com/kb/167296
 285 static void UnixTimeToFileTime(time_t t, LPFILETIME pft)
 286 {
 287     // Note that LONGLONG is a 64-bit value
 288     LONGLONG ll;
 289 
 290     ll = Int32x32To64(t, 10000000) + 116444736000000000;
 291     pft-&gt;dwLowDateTime = (DWORD)ll;
 292     pft-&gt;dwHighDateTime = ll &gt;&gt; 32;
 293 }
 294 #endif
 295 
 296 /*
 297  * Get the DST offset for the time passed in.
 298  */
 299 static double calculateDSTOffset(time_t localTime, double utcOffset)
 300 {
 301     // input is UTC so we have to shift back to local time to determine DST thus the + getUTCOffset()
 302     double offsetTime = (localTime * msPerSecond) + utcOffset;
 303 
 304     // Offset from UTC but doesn&#39;t include DST obviously
 305     int offsetHour =  msToHours(offsetTime);
 306     int offsetMinute =  msToMinutes(offsetTime);
 307 
 308 #if OS(WINDOWS)
 309     FILETIME utcFileTime;
 310     UnixTimeToFileTime(localTime, &amp;utcFileTime);
 311     SYSTEMTIME utcSystemTime, localSystemTime;
 312     if (!::FileTimeToSystemTime(&amp;utcFileTime, &amp;utcSystemTime))
 313         return 0;
 314     if (!::SystemTimeToTzSpecificLocalTime(nullptr, &amp;utcSystemTime, &amp;localSystemTime))
 315         return 0;
 316 
 317     double diff = ((localSystemTime.wHour - offsetHour) * secondsPerHour) + ((localSystemTime.wMinute - offsetMinute) * 60);
 318 #else
 319     tm localTM;
 320     getLocalTime(&amp;localTime, &amp;localTM);
 321 
 322     double diff = ((localTM.tm_hour - offsetHour) * secondsPerHour) + ((localTM.tm_min - offsetMinute) * 60);
 323 #endif
 324 
 325     if (diff &lt; 0)
 326         diff += secondsPerDay;
 327 
 328     return (diff * msPerSecond);
 329 }
 330 
 331 #endif
 332 
 333 // Returns combined offset in millisecond (UTC + DST).
 334 LocalTimeOffset calculateLocalTimeOffset(double ms, TimeType inputTimeType)
 335 {
 336 #if HAVE(TM_GMTOFF)
 337     double localToUTCTimeOffset = inputTimeType == LocalTime ? calculateUTCOffset() : 0;
 338 #else
 339     double localToUTCTimeOffset = calculateUTCOffset();
 340 #endif
 341     if (inputTimeType == LocalTime)
 342         ms -= localToUTCTimeOffset;
 343 
 344     // On Mac OS X, the call to localtime (see calculateDSTOffset) will return historically accurate
 345     // DST information (e.g. New Zealand did not have DST from 1946 to 1974) however the JavaScript
 346     // standard explicitly dictates that historical information should not be considered when
 347     // determining DST. For this reason we shift away from years that localtime can handle but would
 348     // return historically accurate information.
 349     int year = msToYear(ms);
 350     int equivalentYear = equivalentYearForDST(year);
 351     if (year != equivalentYear) {
 352         bool leapYear = isLeapYear(year);
 353         int dayInYearLocal = dayInYear(ms, year);
 354         int dayInMonth = dayInMonthFromDayInYear(dayInYearLocal, leapYear);
 355         int month = monthFromDayInYear(dayInYearLocal, leapYear);
 356         double day = dateToDaysFrom1970(equivalentYear, month, dayInMonth);
 357         ms = (day * msPerDay) + msToMilliseconds(ms);
 358     }
 359 
 360     double localTimeSeconds = ms / msPerSecond;
 361     if (localTimeSeconds &gt; maxUnixTime)
 362         localTimeSeconds = maxUnixTime;
 363     else if (localTimeSeconds &lt; 0) // Go ahead a day to make localtime work (does not work with 0).
 364         localTimeSeconds += secondsPerDay;
 365     // FIXME: time_t has a potential problem in 2038.
 366     time_t localTime = static_cast&lt;time_t&gt;(localTimeSeconds);
 367 
 368 #if HAVE(TM_GMTOFF)
 369     tm localTM;
 370     getLocalTime(&amp;localTime, &amp;localTM);
 371     return LocalTimeOffset(localTM.tm_isdst, localTM.tm_gmtoff * msPerSecond);
 372 #else
 373     double dstOffset = calculateDSTOffset(localTime, localToUTCTimeOffset);
 374     return LocalTimeOffset(dstOffset, localToUTCTimeOffset + dstOffset);
 375 #endif
 376 }
 377 
 378 void initializeDates()
 379 {
<a name="8" id="anc8"></a><span class="line-modified"> 380 #if ASSERT_ENABLED</span>
 381     static bool alreadyInitialized;
 382     ASSERT(!alreadyInitialized);
 383     alreadyInitialized = true;
 384 #endif
 385 
 386     equivalentYearForDST(2000); // Need to call once to initialize a static used in this function.
 387 }
 388 
 389 static inline double ymdhmsToSeconds(int year, long mon, long day, long hour, long minute, double second)
 390 {
 391     int mday = firstDayOfMonth[isLeapYear(year)][mon - 1];
 392     double ydays = daysFrom1970ToYear(year);
 393 
 394     double dateSeconds = second + minute * secondsPerMinute + hour * secondsPerHour + (mday + day - 1 + ydays) * secondsPerDay;
 395 
 396     // Clamp to EcmaScript standard (ecma262/#sec-time-values-and-time-range) of
 397     //  +/- 100,000,000 days from 01 January, 1970.
 398     if (dateSeconds &lt; -8640000000000.0 || dateSeconds &gt; 8640000000000.0)
 399         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 400 
 401     return dateSeconds;
 402 }
 403 
 404 // We follow the recommendation of RFC 2822 to consider all
 405 // obsolete time zones not listed here equivalent to &quot;-0000&quot;.
 406 static const struct KnownZone {
 407 #if !OS(WINDOWS)
 408     const
 409 #endif
 410         char tzName[4];
 411     int tzOffset;
 412 } knownZones[] = {
 413     { &quot;ut&quot;, 0 },
 414     { &quot;gmt&quot;, 0 },
 415     { &quot;est&quot;, -300 },
 416     { &quot;edt&quot;, -240 },
 417     { &quot;cst&quot;, -360 },
 418     { &quot;cdt&quot;, -300 },
 419     { &quot;mst&quot;, -420 },
 420     { &quot;mdt&quot;, -360 },
 421     { &quot;pst&quot;, -480 },
 422     { &quot;pdt&quot;, -420 }
 423 };
 424 
 425 inline static void skipSpacesAndComments(const char*&amp; s)
 426 {
 427     int nesting = 0;
 428     char ch;
 429     while ((ch = *s)) {
 430         if (!isASCIISpace(ch)) {
 431             if (ch == &#39;(&#39;)
 432                 nesting++;
 433             else if (ch == &#39;)&#39; &amp;&amp; nesting &gt; 0)
 434                 nesting--;
 435             else if (nesting == 0)
 436                 break;
 437         }
 438         s++;
 439     }
 440 }
 441 
 442 // returns 0-11 (Jan-Dec); -1 on failure
 443 static int findMonth(const char* monthStr)
 444 {
 445     ASSERT(monthStr);
 446     char needle[4];
 447     for (int i = 0; i &lt; 3; ++i) {
 448         if (!*monthStr)
 449             return -1;
 450         needle[i] = static_cast&lt;char&gt;(toASCIILower(*monthStr++));
 451     }
 452     needle[3] = &#39;\0&#39;;
 453     const char *haystack = &quot;janfebmaraprmayjunjulaugsepoctnovdec&quot;;
 454     const char *str = strstr(haystack, needle);
 455     if (str) {
 456         int position = static_cast&lt;int&gt;(str - haystack);
 457         if (position % 3 == 0)
 458             return position / 3;
 459     }
 460     return -1;
 461 }
 462 
 463 static bool parseInt(const char* string, char** stopPosition, int base, int* result)
 464 {
 465     long longResult = strtol(string, stopPosition, base);
 466     // Avoid the use of errno as it is not available on Windows CE
 467     if (string == *stopPosition || longResult &lt;= std::numeric_limits&lt;int&gt;::min() || longResult &gt;= std::numeric_limits&lt;int&gt;::max())
 468         return false;
 469     *result = static_cast&lt;int&gt;(longResult);
 470     return true;
 471 }
 472 
 473 static bool parseLong(const char* string, char** stopPosition, int base, long* result)
 474 {
 475     *result = strtol(string, stopPosition, base);
 476     // Avoid the use of errno as it is not available on Windows CE
 477     if (string == *stopPosition || *result == std::numeric_limits&lt;long&gt;::min() || *result == std::numeric_limits&lt;long&gt;::max())
 478         return false;
 479     return true;
 480 }
 481 
 482 // Parses a date with the format YYYY[-MM[-DD]].
 483 // Year parsing is lenient, allows any number of digits, and +/-.
 484 // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
 485 static char* parseES5DatePortion(const char* currentPosition, int&amp; year, long&amp; month, long&amp; day)
 486 {
 487     char* postParsePosition;
 488 
 489     // This is a bit more lenient on the year string than ES5 specifies:
 490     // instead of restricting to 4 digits (or 6 digits with mandatory +/-),
 491     // it accepts any integer value. Consider this an implementation fallback.
 492     if (!parseInt(currentPosition, &amp;postParsePosition, 10, &amp;year))
 493         return 0;
 494 
 495     // Check for presence of -MM portion.
 496     if (*postParsePosition != &#39;-&#39;)
 497         return postParsePosition;
 498     currentPosition = postParsePosition + 1;
 499 
 500     if (!isASCIIDigit(*currentPosition))
 501         return 0;
 502     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;month))
 503         return 0;
 504     if ((postParsePosition - currentPosition) != 2)
 505         return 0;
 506 
 507     // Check for presence of -DD portion.
 508     if (*postParsePosition != &#39;-&#39;)
 509         return postParsePosition;
 510     currentPosition = postParsePosition + 1;
 511 
 512     if (!isASCIIDigit(*currentPosition))
 513         return 0;
 514     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;day))
 515         return 0;
 516     if ((postParsePosition - currentPosition) != 2)
 517         return 0;
 518     return postParsePosition;
 519 }
 520 
<a name="9" id="anc9"></a><span class="line-modified"> 521 // Parses a time with the format HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)].</span>
 522 // Fractional seconds parsing is lenient, allows any number of digits.
 523 // Returns 0 if a parse error occurs, else returns the end of the parsed portion of the string.
<a name="10" id="anc10"></a><span class="line-modified"> 524 static char* parseES5TimePortion(char* currentPosition, long&amp; hours, long&amp; minutes, double&amp; seconds, bool&amp; isLocalTime, long&amp; timeZoneSeconds)</span>
 525 {
<a name="11" id="anc11"></a><span class="line-added"> 526     isLocalTime = false;</span>
<span class="line-added"> 527 </span>
 528     char* postParsePosition;
 529     if (!isASCIIDigit(*currentPosition))
 530         return 0;
 531     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;hours))
 532         return 0;
 533     if (*postParsePosition != &#39;:&#39; || (postParsePosition - currentPosition) != 2)
 534         return 0;
 535     currentPosition = postParsePosition + 1;
 536 
 537     if (!isASCIIDigit(*currentPosition))
 538         return 0;
 539     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;minutes))
 540         return 0;
 541     if ((postParsePosition - currentPosition) != 2)
 542         return 0;
 543     currentPosition = postParsePosition;
 544 
 545     // Seconds are optional.
 546     if (*currentPosition == &#39;:&#39;) {
 547         ++currentPosition;
 548 
 549         long intSeconds;
 550         if (!isASCIIDigit(*currentPosition))
 551             return 0;
 552         if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;intSeconds))
 553             return 0;
 554         if ((postParsePosition - currentPosition) != 2)
 555             return 0;
 556         seconds = intSeconds;
 557         if (*postParsePosition == &#39;.&#39;) {
 558             currentPosition = postParsePosition + 1;
 559 
 560             // In ECMA-262-5 it&#39;s a bit unclear if &#39;.&#39; can be present without milliseconds, but
 561             // a reasonable interpretation guided by the given examples and RFC 3339 says &quot;no&quot;.
 562             // We check the next character to avoid reading +/- timezone hours after an invalid decimal.
 563             if (!isASCIIDigit(*currentPosition))
 564                 return 0;
 565 
 566             // We are more lenient than ES5 by accepting more or less than 3 fraction digits.
 567             long fracSeconds;
 568             if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;fracSeconds))
 569                 return 0;
 570 
 571             long numFracDigits = postParsePosition - currentPosition;
 572             seconds += fracSeconds * pow(10.0, static_cast&lt;double&gt;(-numFracDigits));
 573         }
 574         currentPosition = postParsePosition;
 575     }
 576 
 577     if (*currentPosition == &#39;Z&#39;)
 578         return currentPosition + 1;
 579 
<a name="12" id="anc12"></a><span class="line-added"> 580     // Parse (+|-)(00:00|0000|00).</span>
 581     bool tzNegative;
 582     if (*currentPosition == &#39;-&#39;)
 583         tzNegative = true;
 584     else if (*currentPosition == &#39;+&#39;)
 585         tzNegative = false;
<a name="13" id="anc13"></a><span class="line-modified"> 586     else {</span>
<span class="line-modified"> 587         isLocalTime = true;</span>
<span class="line-added"> 588         return currentPosition;</span>
<span class="line-added"> 589     }</span>
 590     ++currentPosition;
 591 
<a name="14" id="anc14"></a><span class="line-modified"> 592     long tzHours = 0;</span>
<span class="line-modified"> 593     long tzHoursAbs = 0;</span>
<span class="line-modified"> 594     long tzMinutes = 0;</span>
 595 
 596     if (!isASCIIDigit(*currentPosition))
 597         return 0;
 598     if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzHours))
 599         return 0;
<a name="15" id="anc15"></a><span class="line-modified"> 600     if (*postParsePosition != &#39;:&#39;) {</span>
<span class="line-modified"> 601         if ((postParsePosition - currentPosition) == 2) {</span>
<span class="line-modified"> 602             // &quot;00&quot; case.</span>
<span class="line-modified"> 603             tzHoursAbs = labs(tzHours);</span>
<span class="line-added"> 604         } else if ((postParsePosition - currentPosition) == 4) {</span>
<span class="line-added"> 605             // &quot;0000&quot; case.</span>
<span class="line-added"> 606             tzHoursAbs = labs(tzHours);</span>
<span class="line-added"> 607             tzMinutes = tzHoursAbs % 100;</span>
<span class="line-added"> 608             tzHoursAbs = tzHoursAbs / 100;</span>
<span class="line-added"> 609         } else</span>
<span class="line-added"> 610             return 0;</span>
<span class="line-added"> 611     } else {</span>
<span class="line-added"> 612         // &quot;00:00&quot; case.</span>
<span class="line-added"> 613         if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-added"> 614             return 0;</span>
<span class="line-added"> 615         tzHoursAbs = labs(tzHours);</span>
<span class="line-added"> 616         currentPosition = postParsePosition + 1; // Skip &quot;:&quot;.</span>
 617 
<a name="16" id="anc16"></a><span class="line-modified"> 618         if (!isASCIIDigit(*currentPosition))</span>
<span class="line-modified"> 619             return 0;</span>
<span class="line-modified"> 620         if (!parseLong(currentPosition, &amp;postParsePosition, 10, &amp;tzMinutes))</span>
<span class="line-modified"> 621             return 0;</span>
<span class="line-modified"> 622         if ((postParsePosition - currentPosition) != 2)</span>
<span class="line-modified"> 623             return 0;</span>
<span class="line-added"> 624     }</span>
 625     currentPosition = postParsePosition;
 626 
 627     if (tzHoursAbs &gt; 24)
 628         return 0;
 629     if (tzMinutes &lt; 0 || tzMinutes &gt; 59)
 630         return 0;
 631 
 632     timeZoneSeconds = 60 * (tzMinutes + (60 * tzHoursAbs));
 633     if (tzNegative)
 634         timeZoneSeconds = -timeZoneSeconds;
 635 
 636     return currentPosition;
 637 }
 638 
<a name="17" id="anc17"></a><span class="line-modified"> 639 double parseES5DateFromNullTerminatedCharacters(const char* dateString, bool&amp; isLocalTime)</span>
 640 {
<a name="18" id="anc18"></a><span class="line-added"> 641     isLocalTime = false;</span>
<span class="line-added"> 642 </span>
 643     // This parses a date of the form defined in ecma262/#sec-date-time-string-format
 644     // (similar to RFC 3339 / ISO 8601: YYYY-MM-DDTHH:mm:ss[.sss]Z).
 645     // In most cases it is intentionally strict (e.g. correct field widths, no stray whitespace).
 646 
 647     static const long daysPerMonth[12] = { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 648 
 649     // The year must be present, but the other fields may be omitted - see ES5.1 15.9.1.15.
 650     int year = 0;
 651     long month = 1;
 652     long day = 1;
 653     long hours = 0;
 654     long minutes = 0;
 655     double seconds = 0;
 656     long timeZoneSeconds = 0;
 657 
 658     // Parse the date YYYY[-MM[-DD]]
 659     char* currentPosition = parseES5DatePortion(dateString, year, month, day);
 660     if (!currentPosition)
 661         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 662     // Look for a time portion.
<a name="19" id="anc19"></a><span class="line-added"> 663     // Note: As of ES2016, when a UTC offset is missing, date-time forms are local time while date-only forms are UTC.</span>
 664     if (*currentPosition == &#39;T&#39;) {
<a name="20" id="anc20"></a><span class="line-modified"> 665         // Parse the time HH:mm[:ss[.sss]][Z|(+|-)(00:00|0000|00)]</span>
<span class="line-modified"> 666         currentPosition = parseES5TimePortion(currentPosition + 1, hours, minutes, seconds, isLocalTime, timeZoneSeconds);</span>
 667         if (!currentPosition)
 668             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 669     }
 670     // Check that we have parsed all characters in the string.
 671     if (*currentPosition)
 672         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 673 
 674     // A few of these checks could be done inline above, but since many of them are interrelated
 675     // we would be sacrificing readability to &quot;optimize&quot; the (presumably less common) failure path.
 676     if (month &lt; 1 || month &gt; 12)
 677         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 678     if (day &lt; 1 || day &gt; daysPerMonth[month - 1])
 679         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 680     if (month == 2 &amp;&amp; day &gt; 28 &amp;&amp; !isLeapYear(year))
 681         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 682     if (hours &lt; 0 || hours &gt; 24)
 683         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 684     if (hours == 24 &amp;&amp; (minutes || seconds))
 685         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 686     if (minutes &lt; 0 || minutes &gt; 59)
 687         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 688     if (seconds &lt; 0 || seconds &gt;= 61)
 689         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 690     if (seconds &gt; 60) {
 691         // Discard leap seconds by clamping to the end of a minute.
 692         seconds = 60;
 693     }
 694 
 695     double dateSeconds = ymdhmsToSeconds(year, month, day, hours, minutes, seconds) - timeZoneSeconds;
 696     return dateSeconds * msPerSecond;
 697 }
 698 
 699 // Odd case where &#39;exec&#39; is allowed to be 0, to accomodate a caller in WebCore.
<a name="21" id="anc21"></a><span class="line-modified"> 700 double parseDateFromNullTerminatedCharacters(const char* dateString, bool&amp; isLocalTime)</span>
 701 {
<a name="22" id="anc22"></a><span class="line-modified"> 702     isLocalTime = true;</span>
<span class="line-modified"> 703     int offset = 0;</span>
 704 
 705     // This parses a date in the form:
 706     //     Tuesday, 09-Nov-99 23:12:40 GMT
 707     // or
 708     //     Sat, 01-Jan-2000 08:00:00 GMT
 709     // or
 710     //     Sat, 01 Jan 2000 08:00:00 GMT
 711     // or
 712     //     01 Jan 99 22:00 +0100    (exceptions in rfc822/rfc2822)
 713     // ### non RFC formats, added for Javascript:
 714     //     [Wednesday] January 09 1999 23:12:40 GMT
 715     //     [Wednesday] January 09 23:12:40 GMT 1999
 716     //
 717     // We ignore the weekday.
 718 
 719     // Skip leading space
 720     skipSpacesAndComments(dateString);
 721 
 722     long month = -1;
 723     const char *wordStart = dateString;
 724     // Check contents of first words if not number
 725     while (*dateString &amp;&amp; !isASCIIDigit(*dateString)) {
 726         if (isASCIISpace(*dateString) || *dateString == &#39;(&#39;) {
 727             if (dateString - wordStart &gt;= 3)
 728                 month = findMonth(wordStart);
 729             skipSpacesAndComments(dateString);
 730             wordStart = dateString;
 731         } else
 732            dateString++;
 733     }
 734 
 735     // Missing delimiter between month and day (like &quot;January29&quot;)?
 736     if (month == -1 &amp;&amp; wordStart != dateString)
 737         month = findMonth(wordStart);
 738 
 739     skipSpacesAndComments(dateString);
 740 
 741     if (!*dateString)
 742         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 743 
 744     // &#39; 09-Nov-99 23:12:40 GMT&#39;
 745     char* newPosStr;
 746     long day;
 747     if (!parseLong(dateString, &amp;newPosStr, 10, &amp;day))
 748         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 749     dateString = newPosStr;
 750 
 751     if (day &lt; 0)
 752         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 753 
 754     Optional&lt;int&gt; year;
 755     if (day &gt; 31) {
 756         // ### where is the boundary and what happens below?
 757         if (*dateString != &#39;/&#39;)
 758             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 759         // looks like a YYYY/MM/DD date
 760         if (!*++dateString)
 761             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 762         if (day &lt;= std::numeric_limits&lt;int&gt;::min() || day &gt;= std::numeric_limits&lt;int&gt;::max())
 763             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 764         year = static_cast&lt;int&gt;(day);
 765         if (!parseLong(dateString, &amp;newPosStr, 10, &amp;month))
 766             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 767         month -= 1;
 768         dateString = newPosStr;
 769         if (*dateString++ != &#39;/&#39; || !*dateString)
 770             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 771         if (!parseLong(dateString, &amp;newPosStr, 10, &amp;day))
 772             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 773         dateString = newPosStr;
 774     } else if (*dateString == &#39;/&#39; &amp;&amp; month == -1) {
 775         dateString++;
 776         // This looks like a MM/DD/YYYY date, not an RFC date.
 777         month = day - 1; // 0-based
 778         if (!parseLong(dateString, &amp;newPosStr, 10, &amp;day))
 779             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 780         if (day &lt; 1 || day &gt; 31)
 781             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 782         dateString = newPosStr;
 783         if (*dateString == &#39;/&#39;)
 784             dateString++;
 785         if (!*dateString)
 786             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 787      } else {
 788         if (*dateString == &#39;-&#39;)
 789             dateString++;
 790 
 791         skipSpacesAndComments(dateString);
 792 
 793         if (*dateString == &#39;,&#39;)
 794             dateString++;
 795 
 796         if (month == -1) { // not found yet
 797             month = findMonth(dateString);
 798             if (month == -1)
 799                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 800 
 801             while (*dateString &amp;&amp; *dateString != &#39;-&#39; &amp;&amp; *dateString != &#39;,&#39; &amp;&amp; !isASCIISpace(*dateString))
 802                 dateString++;
 803 
 804             if (!*dateString)
 805                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 806 
 807             // &#39;-99 23:12:40 GMT&#39;
 808             if (*dateString != &#39;-&#39; &amp;&amp; *dateString != &#39;/&#39; &amp;&amp; *dateString != &#39;,&#39; &amp;&amp; !isASCIISpace(*dateString))
 809                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 810             dateString++;
 811         }
 812     }
 813 
 814     if (month &lt; 0 || month &gt; 11)
 815         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 816 
 817     // &#39;99 23:12:40 GMT&#39;
 818     if (*dateString &amp;&amp; !year) {
 819         int result = 0;
 820         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
 821             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 822         year = result;
 823     }
 824 
 825     // Don&#39;t fail if the time is missing.
 826     long hour = 0;
 827     long minute = 0;
 828     long second = 0;
 829     if (!*newPosStr)
 830         dateString = newPosStr;
 831     else {
 832         // &#39; 23:12:40 GMT&#39;
 833         if (!(isASCIISpace(*newPosStr) || *newPosStr == &#39;,&#39;)) {
 834             if (*newPosStr != &#39;:&#39;)
 835                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 836             // There was no year; the number was the hour.
 837             year = WTF::nullopt;
 838         } else {
 839             // in the normal case (we parsed the year), advance to the next number
 840             dateString = ++newPosStr;
 841             skipSpacesAndComments(dateString);
 842         }
 843 
 844         parseLong(dateString, &amp;newPosStr, 10, &amp;hour);
 845         // Do not check for errno here since we want to continue
 846         // even if errno was set becasue we are still looking
 847         // for the timezone!
 848 
 849         // Read a number? If not, this might be a timezone name.
 850         if (newPosStr != dateString) {
 851             dateString = newPosStr;
 852 
 853             if (hour &lt; 0 || hour &gt; 23)
 854                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 855 
 856             if (!*dateString)
 857                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 858 
 859             // &#39;:12:40 GMT&#39;
 860             if (*dateString++ != &#39;:&#39;)
 861                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 862 
 863             if (!parseLong(dateString, &amp;newPosStr, 10, &amp;minute))
 864                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 865             dateString = newPosStr;
 866 
 867             if (minute &lt; 0 || minute &gt; 59)
 868                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 869 
 870             // &#39;:40 GMT&#39;
 871             if (*dateString &amp;&amp; *dateString != &#39;:&#39; &amp;&amp; !isASCIISpace(*dateString))
 872                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 873 
 874             // seconds are optional in rfc822 + rfc2822
 875             if (*dateString ==&#39;:&#39;) {
 876                 dateString++;
 877 
 878                 if (!parseLong(dateString, &amp;newPosStr, 10, &amp;second))
 879                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
 880                 dateString = newPosStr;
 881 
 882                 if (second &lt; 0 || second &gt; 59)
 883                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
 884             }
 885 
 886             skipSpacesAndComments(dateString);
 887 
 888             if (startsWithLettersIgnoringASCIICase(dateString, &quot;am&quot;)) {
 889                 if (hour &gt; 12)
 890                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
 891                 if (hour == 12)
 892                     hour = 0;
 893                 dateString += 2;
 894                 skipSpacesAndComments(dateString);
 895             } else if (startsWithLettersIgnoringASCIICase(dateString, &quot;pm&quot;)) {
 896                 if (hour &gt; 12)
 897                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
 898                 if (hour != 12)
 899                     hour += 12;
 900                 dateString += 2;
 901                 skipSpacesAndComments(dateString);
 902             }
 903         }
 904     }
 905 
 906     // The year may be after the time but before the time zone.
 907     if (isASCIIDigit(*dateString) &amp;&amp; !year) {
 908         int result = 0;
 909         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
 910             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 911         year = result;
 912         dateString = newPosStr;
 913         skipSpacesAndComments(dateString);
 914     }
 915 
 916     // Don&#39;t fail if the time zone is missing.
 917     // Some websites omit the time zone (4275206).
 918     if (*dateString) {
 919         if (startsWithLettersIgnoringASCIICase(dateString, &quot;gmt&quot;) || startsWithLettersIgnoringASCIICase(dateString, &quot;utc&quot;)) {
 920             dateString += 3;
<a name="23" id="anc23"></a><span class="line-modified"> 921             isLocalTime = false;</span>
 922         }
 923 
 924         if (*dateString == &#39;+&#39; || *dateString == &#39;-&#39;) {
 925             int o;
 926             if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o))
 927                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 928             dateString = newPosStr;
 929 
 930             if (o &lt; -9959 || o &gt; 9959)
 931                 return std::numeric_limits&lt;double&gt;::quiet_NaN();
 932 
 933             int sgn = (o &lt; 0) ? -1 : 1;
 934             o = abs(o);
 935             if (*dateString != &#39;:&#39;) {
 936                 if (o &gt;= 24)
 937                     offset = ((o / 100) * 60 + (o % 100)) * sgn;
 938                 else
 939                     offset = o * 60 * sgn;
 940             } else { // GMT+05:00
 941                 ++dateString; // skip the &#39;:&#39;
 942                 int o2;
 943                 if (!parseInt(dateString, &amp;newPosStr, 10, &amp;o2))
 944                     return std::numeric_limits&lt;double&gt;::quiet_NaN();
 945                 dateString = newPosStr;
 946                 offset = (o * 60 + o2) * sgn;
 947             }
<a name="24" id="anc24"></a><span class="line-modified"> 948             isLocalTime = false;</span>
 949         } else {
 950             for (auto&amp; knownZone : knownZones) {
 951                 // Since the passed-in length is used for both strings, the following checks that
 952                 // dateString has the time zone name as a prefix, not that it is equal.
 953                 auto length = strlen(knownZone.tzName);
 954                 if (equalLettersIgnoringASCIICase(dateString, knownZone.tzName, length)) {
 955                     offset = knownZone.tzOffset;
 956                     dateString += length;
<a name="25" id="anc25"></a><span class="line-modified"> 957                     isLocalTime = false;</span>
 958                     break;
 959                 }
 960             }
 961         }
 962     }
 963 
 964     skipSpacesAndComments(dateString);
 965 
 966     if (*dateString &amp;&amp; !year) {
 967         int result = 0;
 968         if (!parseInt(dateString, &amp;newPosStr, 10, &amp;result))
 969             return std::numeric_limits&lt;double&gt;::quiet_NaN();
 970         year = result;
 971         dateString = newPosStr;
 972         skipSpacesAndComments(dateString);
 973     }
 974 
 975     // Trailing garbage
 976     if (*dateString)
 977         return std::numeric_limits&lt;double&gt;::quiet_NaN();
 978 
 979     // Y2K: Handle 2 digit years.
 980     if (year) {
 981         int yearValue = year.value();
 982         if (yearValue &gt;= 0 &amp;&amp; yearValue &lt; 100) {
 983             if (yearValue &lt; 50)
 984                 yearValue += 2000;
 985             else
 986                 yearValue += 1900;
 987         }
 988         year = yearValue;
 989     } else {
 990         // We select 2000 as default value. This is because of the following reasons.
 991         // 1. Year 2000 was used for the initial value of the variable `year`. While it won&#39;t be posed to users in WebKit,
 992         //    V8 used this 2000 as its default value. (As of April 2017, V8 is using the year 2001 and Spider Monkey is
 993         //    not doing this kind of fallback.)
 994         // 2. It is a leap year. When using `new Date(&quot;Feb 29&quot;)`, we assume that people want to save month and day.
 995         //    Leap year can save user inputs if they is valid. If we use the current year instead, the current year
 996         //    may not be a leap year. In that case, `new Date(&quot;Feb 29&quot;).getMonth()` becomes 2 (March).
 997         year = 2000;
 998     }
 999     ASSERT(year);
1000 
<a name="26" id="anc26"></a><span class="line-modified">1001     double dateSeconds = ymdhmsToSeconds(year.value(), month + 1, day, hour, minute, second) - offset * secondsPerMinute;</span>
<span class="line-added">1002     return dateSeconds * msPerSecond;</span>
1003 }
1004 
1005 double parseDateFromNullTerminatedCharacters(const char* dateString)
1006 {
<a name="27" id="anc27"></a><span class="line-modified">1007     bool isLocalTime;</span>
<span class="line-modified">1008     double value = parseDateFromNullTerminatedCharacters(dateString, isLocalTime);</span>







1009 
<a name="28" id="anc28"></a><span class="line-modified">1010     if (isLocalTime)</span>
<span class="line-modified">1011         value -= calculateLocalTimeOffset(value, LocalTime).offset;</span>
1012 
<a name="29" id="anc29"></a><span class="line-modified">1013     return value;</span>




1014 }
1015 
1016 // See http://tools.ietf.org/html/rfc2822#section-3.3 for more information.
1017 String makeRFC2822DateString(unsigned dayOfWeek, unsigned day, unsigned month, unsigned year, unsigned hours, unsigned minutes, unsigned seconds, int utcOffset)
1018 {
1019     StringBuilder stringBuilder;
1020     stringBuilder.append(weekdayName[dayOfWeek], &quot;, &quot;, day, &#39; &#39;, monthName[month], &#39; &#39;, year, &#39; &#39;);
1021 
1022     appendTwoDigitNumber(stringBuilder, hours);
1023     stringBuilder.append(&#39;:&#39;);
1024     appendTwoDigitNumber(stringBuilder, minutes);
1025     stringBuilder.append(&#39;:&#39;);
1026     appendTwoDigitNumber(stringBuilder, seconds);
1027     stringBuilder.append(&#39; &#39;);
1028 
1029     stringBuilder.append(utcOffset &gt; 0 ? &#39;+&#39; : &#39;-&#39;);
1030     int absoluteUTCOffset = abs(utcOffset);
1031     appendTwoDigitNumber(stringBuilder, absoluteUTCOffset / 60);
1032     appendTwoDigitNumber(stringBuilder, absoluteUTCOffset % 60);
1033 
1034     return stringBuilder.toString();
1035 }
1036 
1037 } // namespace WTF
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
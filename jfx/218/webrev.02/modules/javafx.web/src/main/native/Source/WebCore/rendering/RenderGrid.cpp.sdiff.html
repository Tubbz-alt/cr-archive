<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderGeometryMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderGrid.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGrid.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 202             // Grid&#39;s layout logic controls the grid item&#39;s override height, hence we need to
 203             // clear any override height set previously, so it doesn&#39;t interfere in current layout
 204             // execution. Grid never uses the override width, that&#39;s why we don&#39;t need to clear  it.
 205             child-&gt;clearOverrideContentLogicalHeight();
 206 
 207             // We may need to repeat the track sizing in case of any grid item was orthogonal.
 208             if (GridLayoutFunctions::isOrthogonalChild(*this, *child))
 209                 m_hasAnyOrthogonalItem = true;
 210 
 211             // We keep a cache of items with baseline as alignment values so
 212             // that we only compute the baseline shims for such items. This
 213             // cache is needed for performance related reasons due to the
 214             // cost of evaluating the item&#39;s participation in a baseline
 215             // context during the track sizing algorithm.
 216             if (isBaselineAlignmentForChild(*child, GridColumnAxis))
 217                 m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridColumnAxis);
 218             if (isBaselineAlignmentForChild(*child, GridRowAxis))
 219                 m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridRowAxis);
 220         }
 221         m_baselineItemsCached = true;
<span class="line-modified"> 222         setLogicalHeight(0);</span>
 223         updateLogicalWidth();
 224 
 225         // Fieldsets need to find their legend and position it inside the border of the object.
 226         // The legend then gets skipped during normal layout. The same is true for ruby text.
 227         // It doesn&#39;t get included in the normal layout process but is instead skipped.
 228         layoutExcludedChildren(relayoutChildren);
 229 
 230         LayoutUnit availableSpaceForColumns = availableLogicalWidth();
 231         placeItemsOnGrid(m_trackSizingAlgorithm, availableSpaceForColumns);
 232 
 233         performGridItemsPreLayout(m_trackSizingAlgorithm);
 234 
 235         // 1- First, the track sizing algorithm is used to resolve the sizes of the
 236         // grid columns.
 237         // At this point the logical width is always definite as the above call to
 238         // updateLogicalWidth() properly resolves intrinsic sizes. We cannot do the
 239         // same for heights though because many code paths inside
 240         // updateLogicalHeight() require a previous call to setLogicalHeight() to
 241         // resolve heights properly (like for positioned items for example).
 242         computeTrackSizesForDefiniteSize(ForColumns, availableSpaceForColumns);
</pre>
<hr />
<pre>
 616 
 617         GridArea area = grid.gridItemArea(*child);
 618         if (!area.rows.isIndefinite())
 619             area.rows.translate(std::abs(grid.smallestTrackStart(ForRows)));
 620         if (!area.columns.isIndefinite())
 621             area.columns.translate(std::abs(grid.smallestTrackStart(ForColumns)));
 622 
 623         if (area.rows.isIndefinite() || area.columns.isIndefinite()) {
 624             grid.setGridItemArea(*child, area);
 625             bool majorAxisDirectionIsForColumns = autoPlacementMajorAxisDirection() == ForColumns;
 626             if ((majorAxisDirectionIsForColumns &amp;&amp; area.columns.isIndefinite())
 627                 || (!majorAxisDirectionIsForColumns &amp;&amp; area.rows.isIndefinite()))
 628                 autoMajorAxisAutoGridItems.append(child);
 629             else
 630                 specifiedMajorAxisAutoGridItems.append(child);
 631             continue;
 632         }
 633         grid.insert(*child, { area.rows, area.columns });
 634     }
 635 
<span class="line-modified"> 636 #if !ASSERT_DISABLED</span>
 637     if (grid.hasGridItems()) {
 638         ASSERT(grid.numTracks(ForRows) &gt;= GridPositionsResolver::explicitGridRowCount(style(), grid.autoRepeatTracks(ForRows)));
 639         ASSERT(grid.numTracks(ForColumns) &gt;= GridPositionsResolver::explicitGridColumnCount(style(), grid.autoRepeatTracks(ForColumns)));
 640     }
 641 #endif
 642 
 643     placeSpecifiedMajorAxisItemsOnGrid(grid, specifiedMajorAxisAutoGridItems);
 644     placeAutoMajorAxisItemsOnGrid(grid, autoMajorAxisAutoGridItems);
 645 
 646     // Compute collapsible tracks for auto-fit.
 647     grid.setAutoRepeatEmptyColumns(computeEmptyTracksForAutoRepeat(grid, ForColumns));
 648     grid.setAutoRepeatEmptyRows(computeEmptyTracksForAutoRepeat(grid, ForRows));
 649 
 650     grid.setNeedsItemsPlacement(false);
 651 
<span class="line-modified"> 652 #if !ASSERT_DISABLED</span>
 653     for (auto* child = grid.orderIterator().first(); child; child = grid.orderIterator().next()) {
 654         if (grid.orderIterator().shouldSkipChild(*child))
 655             continue;
 656 
 657         GridArea area = grid.gridItemArea(*child);
 658         ASSERT(area.rows.isTranslatedDefinite() &amp;&amp; area.columns.isTranslatedDefinite());
 659     }
 660 #endif
 661 }
 662 
 663 void RenderGrid::performGridItemsPreLayout(const GridTrackSizingAlgorithm&amp; algorithm) const
 664 {
 665     ASSERT(!algorithm.grid().needsItemsPlacement());
 666     // FIXME: We need a way when we are calling this during intrinsic size compuation before performing
 667     // the layout. Maybe using the PreLayout phase ?
 668     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 669         if (child-&gt;isOutOfFlowPositioned())
 670             continue;
 671         // Orthogonal items should be laid out in order to properly compute content-sized tracks that may depend on item&#39;s intrinsic size.
 672         // We also need to properly estimate its grid area size, since it may affect to the baseline shims if such item particiaptes in baseline alignment.
</pre>
<hr />
<pre>
 849     if (m_grid.needsItemsPlacement())
 850         return;
 851 
 852     m_grid.setNeedsItemsPlacement(true);
 853 }
 854 
 855 Vector&lt;LayoutUnit&gt; RenderGrid::trackSizesForComputedStyle(GridTrackSizingDirection direction) const
 856 {
 857     bool isRowAxis = direction == ForColumns;
 858     auto&amp; positions = isRowAxis ? m_columnPositions : m_rowPositions;
 859     size_t numPositions = positions.size();
 860     LayoutUnit offsetBetweenTracks = isRowAxis ? m_offsetBetweenColumns.distributionOffset : m_offsetBetweenRows.distributionOffset;
 861 
 862     Vector&lt;LayoutUnit&gt; tracks;
 863     if (numPositions &lt; 2)
 864         return tracks;
 865 
 866     ASSERT(!m_grid.needsItemsPlacement());
 867     bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
 868     LayoutUnit gap = !hasCollapsedTracks ? gridGap(direction) : 0_lu;
<span class="line-modified"> 869     tracks.reserveCapacity(numPositions - 1);</span>
<span class="line-modified"> 870     for (size_t i = 0; i &lt; numPositions - 2; ++i)</span>





 871         tracks.append(positions[i + 1] - positions[i] - offsetBetweenTracks - gap);
<span class="line-modified"> 872     tracks.append(positions[numPositions - 1] - positions[numPositions - 2]);</span>

 873 
 874     if (!hasCollapsedTracks)
 875         return tracks;
 876 
 877     size_t remainingEmptyTracks = m_grid.autoRepeatEmptyTracks(direction)-&gt;size();
 878     size_t lastLine = tracks.size();
 879     gap = gridGap(direction);
 880     for (size_t i = 1; i &lt; lastLine; ++i) {
<span class="line-modified"> 881         if (m_grid.isEmptyAutoRepeatTrack(direction, i - 1))</span>
 882             --remainingEmptyTracks;
 883         else {
 884             // Remove the gap between consecutive non empty tracks. Remove it also just once for an
 885             // arbitrary number of empty tracks between two non empty ones.
 886             bool allRemainingTracksAreEmpty = remainingEmptyTracks == (lastLine - i);
<span class="line-modified"> 887             if (!allRemainingTracksAreEmpty || !m_grid.isEmptyAutoRepeatTrack(direction, i))</span>
 888                 tracks[i - 1] -= gap;
 889         }
 890     }
 891 
 892     return tracks;
 893 }
 894 
 895 static const StyleContentAlignmentData&amp; contentAlignmentNormalBehaviorGrid()
 896 {
 897     static const StyleContentAlignmentData normalBehavior = {ContentPosition::Normal, ContentDistribution::Stretch};
 898     return normalBehavior;
 899 }
 900 
 901 static bool overrideSizeChanged(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutSize size)
 902 {
 903     if (direction == ForColumns)
 904         return !child.hasOverrideContainingBlockContentLogicalWidth() || child.overrideContainingBlockContentLogicalWidth() != size.width();
 905     return !child.hasOverrideContainingBlockContentLogicalHeight() || child.overrideContainingBlockContentLogicalHeight() != size.height();
 906 }
 907 
</pre>
<hr />
<pre>
1211     return (direction == HorizontalLine ? box.size().height() : box.size().width()).toInt();
1212 }
1213 
1214 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child) const
1215 {
1216     return isBaselineAlignmentForChild(child, GridRowAxis) || isBaselineAlignmentForChild(child, GridColumnAxis);
1217 }
1218 
1219 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child, GridAxis baselineAxis) const
1220 {
1221     if (child.isOutOfFlowPositioned())
1222         return false;
1223     ItemPosition align = selfAlignmentForChild(baselineAxis, child).position();
1224     bool hasAutoMargins = baselineAxis == GridColumnAxis ? hasAutoMarginsInColumnAxis(child) : hasAutoMarginsInRowAxis(child);
1225     return isBaselinePosition(align) &amp;&amp; !hasAutoMargins;
1226 }
1227 
1228 // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
1229 int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
1230 {
<span class="line-modified">1231 #if !ASSERT_DISABLED</span>
<span class="line-removed">1232     ASSERT(mode == PositionOnContainingLine);</span>
<span class="line-removed">1233 #else</span>
<span class="line-removed">1234     UNUSED_PARAM(mode);</span>
<span class="line-removed">1235 #endif</span>
1236     auto baseline = firstLineBaseline();
1237     if (!baseline)
1238         return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();
1239 
1240     return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();
1241 }
1242 
1243 Optional&lt;int&gt; RenderGrid::firstLineBaseline() const
1244 {
1245     if (isWritingModeRoot() || !m_grid.hasGridItems())
1246         return WTF::nullopt;
1247 
1248     const RenderBox* baselineChild = nullptr;
1249     // Finding the first grid item in grid order.
1250     unsigned numColumns = m_grid.numTracks(ForColumns);
1251     for (size_t column = 0; column &lt; numColumns; column++) {
1252         for (auto&amp; child : m_grid.cell(0, column)) {
1253             ASSERT(child.get());
1254             // If an item participates in baseline alignment, we select such item.
1255             if (isBaselineAlignmentForChild(*child)) {
</pre>
</td>
<td>
<hr />
<pre>
 202             // Grid&#39;s layout logic controls the grid item&#39;s override height, hence we need to
 203             // clear any override height set previously, so it doesn&#39;t interfere in current layout
 204             // execution. Grid never uses the override width, that&#39;s why we don&#39;t need to clear  it.
 205             child-&gt;clearOverrideContentLogicalHeight();
 206 
 207             // We may need to repeat the track sizing in case of any grid item was orthogonal.
 208             if (GridLayoutFunctions::isOrthogonalChild(*this, *child))
 209                 m_hasAnyOrthogonalItem = true;
 210 
 211             // We keep a cache of items with baseline as alignment values so
 212             // that we only compute the baseline shims for such items. This
 213             // cache is needed for performance related reasons due to the
 214             // cost of evaluating the item&#39;s participation in a baseline
 215             // context during the track sizing algorithm.
 216             if (isBaselineAlignmentForChild(*child, GridColumnAxis))
 217                 m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridColumnAxis);
 218             if (isBaselineAlignmentForChild(*child, GridRowAxis))
 219                 m_trackSizingAlgorithm.cacheBaselineAlignedItem(*child, GridRowAxis);
 220         }
 221         m_baselineItemsCached = true;
<span class="line-modified"> 222         resetLogicalHeightBeforeLayoutIfNeeded();</span>
 223         updateLogicalWidth();
 224 
 225         // Fieldsets need to find their legend and position it inside the border of the object.
 226         // The legend then gets skipped during normal layout. The same is true for ruby text.
 227         // It doesn&#39;t get included in the normal layout process but is instead skipped.
 228         layoutExcludedChildren(relayoutChildren);
 229 
 230         LayoutUnit availableSpaceForColumns = availableLogicalWidth();
 231         placeItemsOnGrid(m_trackSizingAlgorithm, availableSpaceForColumns);
 232 
 233         performGridItemsPreLayout(m_trackSizingAlgorithm);
 234 
 235         // 1- First, the track sizing algorithm is used to resolve the sizes of the
 236         // grid columns.
 237         // At this point the logical width is always definite as the above call to
 238         // updateLogicalWidth() properly resolves intrinsic sizes. We cannot do the
 239         // same for heights though because many code paths inside
 240         // updateLogicalHeight() require a previous call to setLogicalHeight() to
 241         // resolve heights properly (like for positioned items for example).
 242         computeTrackSizesForDefiniteSize(ForColumns, availableSpaceForColumns);
</pre>
<hr />
<pre>
 616 
 617         GridArea area = grid.gridItemArea(*child);
 618         if (!area.rows.isIndefinite())
 619             area.rows.translate(std::abs(grid.smallestTrackStart(ForRows)));
 620         if (!area.columns.isIndefinite())
 621             area.columns.translate(std::abs(grid.smallestTrackStart(ForColumns)));
 622 
 623         if (area.rows.isIndefinite() || area.columns.isIndefinite()) {
 624             grid.setGridItemArea(*child, area);
 625             bool majorAxisDirectionIsForColumns = autoPlacementMajorAxisDirection() == ForColumns;
 626             if ((majorAxisDirectionIsForColumns &amp;&amp; area.columns.isIndefinite())
 627                 || (!majorAxisDirectionIsForColumns &amp;&amp; area.rows.isIndefinite()))
 628                 autoMajorAxisAutoGridItems.append(child);
 629             else
 630                 specifiedMajorAxisAutoGridItems.append(child);
 631             continue;
 632         }
 633         grid.insert(*child, { area.rows, area.columns });
 634     }
 635 
<span class="line-modified"> 636 #if ASSERT_ENABLED</span>
 637     if (grid.hasGridItems()) {
 638         ASSERT(grid.numTracks(ForRows) &gt;= GridPositionsResolver::explicitGridRowCount(style(), grid.autoRepeatTracks(ForRows)));
 639         ASSERT(grid.numTracks(ForColumns) &gt;= GridPositionsResolver::explicitGridColumnCount(style(), grid.autoRepeatTracks(ForColumns)));
 640     }
 641 #endif
 642 
 643     placeSpecifiedMajorAxisItemsOnGrid(grid, specifiedMajorAxisAutoGridItems);
 644     placeAutoMajorAxisItemsOnGrid(grid, autoMajorAxisAutoGridItems);
 645 
 646     // Compute collapsible tracks for auto-fit.
 647     grid.setAutoRepeatEmptyColumns(computeEmptyTracksForAutoRepeat(grid, ForColumns));
 648     grid.setAutoRepeatEmptyRows(computeEmptyTracksForAutoRepeat(grid, ForRows));
 649 
 650     grid.setNeedsItemsPlacement(false);
 651 
<span class="line-modified"> 652 #if ASSERT_ENABLED</span>
 653     for (auto* child = grid.orderIterator().first(); child; child = grid.orderIterator().next()) {
 654         if (grid.orderIterator().shouldSkipChild(*child))
 655             continue;
 656 
 657         GridArea area = grid.gridItemArea(*child);
 658         ASSERT(area.rows.isTranslatedDefinite() &amp;&amp; area.columns.isTranslatedDefinite());
 659     }
 660 #endif
 661 }
 662 
 663 void RenderGrid::performGridItemsPreLayout(const GridTrackSizingAlgorithm&amp; algorithm) const
 664 {
 665     ASSERT(!algorithm.grid().needsItemsPlacement());
 666     // FIXME: We need a way when we are calling this during intrinsic size compuation before performing
 667     // the layout. Maybe using the PreLayout phase ?
 668     for (auto* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 669         if (child-&gt;isOutOfFlowPositioned())
 670             continue;
 671         // Orthogonal items should be laid out in order to properly compute content-sized tracks that may depend on item&#39;s intrinsic size.
 672         // We also need to properly estimate its grid area size, since it may affect to the baseline shims if such item particiaptes in baseline alignment.
</pre>
<hr />
<pre>
 849     if (m_grid.needsItemsPlacement())
 850         return;
 851 
 852     m_grid.setNeedsItemsPlacement(true);
 853 }
 854 
 855 Vector&lt;LayoutUnit&gt; RenderGrid::trackSizesForComputedStyle(GridTrackSizingDirection direction) const
 856 {
 857     bool isRowAxis = direction == ForColumns;
 858     auto&amp; positions = isRowAxis ? m_columnPositions : m_rowPositions;
 859     size_t numPositions = positions.size();
 860     LayoutUnit offsetBetweenTracks = isRowAxis ? m_offsetBetweenColumns.distributionOffset : m_offsetBetweenRows.distributionOffset;
 861 
 862     Vector&lt;LayoutUnit&gt; tracks;
 863     if (numPositions &lt; 2)
 864         return tracks;
 865 
 866     ASSERT(!m_grid.needsItemsPlacement());
 867     bool hasCollapsedTracks = m_grid.hasAutoRepeatEmptyTracks(direction);
 868     LayoutUnit gap = !hasCollapsedTracks ? gridGap(direction) : 0_lu;
<span class="line-modified"> 869     size_t explicitStart = -m_grid.smallestTrackStart(direction);</span>
<span class="line-modified"> 870     size_t explicitEnd = explicitStart + (isRowAxis ? style().gridColumns() : style().gridRows()).size() + autoRepeatCountForDirection(direction);</span>
<span class="line-added"> 871     // Usually we have `explicitEnd &lt;= numPositions - 1`, but the latter may be smaller when the maximum number of tracks is reached.</span>
<span class="line-added"> 872     explicitEnd = std::min(explicitEnd, numPositions - 1);</span>
<span class="line-added"> 873     tracks.reserveCapacity(explicitEnd - explicitStart);</span>
<span class="line-added"> 874     size_t loopEnd = std::min(explicitEnd, numPositions - 2);</span>
<span class="line-added"> 875     for (size_t i = explicitStart; i &lt; loopEnd; ++i)</span>
 876         tracks.append(positions[i + 1] - positions[i] - offsetBetweenTracks - gap);
<span class="line-modified"> 877     if (loopEnd &lt; explicitEnd)</span>
<span class="line-added"> 878         tracks.append(positions[explicitEnd] - positions[explicitEnd - 1]);</span>
 879 
 880     if (!hasCollapsedTracks)
 881         return tracks;
 882 
 883     size_t remainingEmptyTracks = m_grid.autoRepeatEmptyTracks(direction)-&gt;size();
 884     size_t lastLine = tracks.size();
 885     gap = gridGap(direction);
 886     for (size_t i = 1; i &lt; lastLine; ++i) {
<span class="line-modified"> 887         if (m_grid.isEmptyAutoRepeatTrack(direction, i - 1 + explicitStart))</span>
 888             --remainingEmptyTracks;
 889         else {
 890             // Remove the gap between consecutive non empty tracks. Remove it also just once for an
 891             // arbitrary number of empty tracks between two non empty ones.
 892             bool allRemainingTracksAreEmpty = remainingEmptyTracks == (lastLine - i);
<span class="line-modified"> 893             if (!allRemainingTracksAreEmpty || !m_grid.isEmptyAutoRepeatTrack(direction, i + explicitStart))</span>
 894                 tracks[i - 1] -= gap;
 895         }
 896     }
 897 
 898     return tracks;
 899 }
 900 
 901 static const StyleContentAlignmentData&amp; contentAlignmentNormalBehaviorGrid()
 902 {
 903     static const StyleContentAlignmentData normalBehavior = {ContentPosition::Normal, ContentDistribution::Stretch};
 904     return normalBehavior;
 905 }
 906 
 907 static bool overrideSizeChanged(const RenderBox&amp; child, GridTrackSizingDirection direction, LayoutSize size)
 908 {
 909     if (direction == ForColumns)
 910         return !child.hasOverrideContainingBlockContentLogicalWidth() || child.overrideContainingBlockContentLogicalWidth() != size.width();
 911     return !child.hasOverrideContainingBlockContentLogicalHeight() || child.overrideContainingBlockContentLogicalHeight() != size.height();
 912 }
 913 
</pre>
<hr />
<pre>
1217     return (direction == HorizontalLine ? box.size().height() : box.size().width()).toInt();
1218 }
1219 
1220 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child) const
1221 {
1222     return isBaselineAlignmentForChild(child, GridRowAxis) || isBaselineAlignmentForChild(child, GridColumnAxis);
1223 }
1224 
1225 bool RenderGrid::isBaselineAlignmentForChild(const RenderBox&amp; child, GridAxis baselineAxis) const
1226 {
1227     if (child.isOutOfFlowPositioned())
1228         return false;
1229     ItemPosition align = selfAlignmentForChild(baselineAxis, child).position();
1230     bool hasAutoMargins = baselineAxis == GridColumnAxis ? hasAutoMarginsInColumnAxis(child) : hasAutoMarginsInRowAxis(child);
1231     return isBaselinePosition(align) &amp;&amp; !hasAutoMargins;
1232 }
1233 
1234 // FIXME: This logic is shared by RenderFlexibleBox, so it might be refactored somehow.
1235 int RenderGrid::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode mode) const
1236 {
<span class="line-modified">1237     ASSERT_UNUSED(mode, mode == PositionOnContainingLine);</span>




1238     auto baseline = firstLineBaseline();
1239     if (!baseline)
1240         return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();
1241 
1242     return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();
1243 }
1244 
1245 Optional&lt;int&gt; RenderGrid::firstLineBaseline() const
1246 {
1247     if (isWritingModeRoot() || !m_grid.hasGridItems())
1248         return WTF::nullopt;
1249 
1250     const RenderBox* baselineChild = nullptr;
1251     // Finding the first grid item in grid order.
1252     unsigned numColumns = m_grid.numTracks(ForColumns);
1253     for (size_t column = 0; column &lt; numColumns; column++) {
1254         for (auto&amp; child : m_grid.cell(0, column)) {
1255             ASSERT(child.get());
1256             // If an item participates in baseline alignment, we select such item.
1257             if (isBaselineAlignmentForChild(*child)) {
</pre>
</td>
</tr>
</table>
<center><a href="RenderGeometryMap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderGrid.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
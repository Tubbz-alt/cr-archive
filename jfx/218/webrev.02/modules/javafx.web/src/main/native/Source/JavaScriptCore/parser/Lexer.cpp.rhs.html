<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2006-2019 Apple Inc. All Rights Reserved.
   4  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   5  *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
   6  *  Copyright (C) 2012 Mathias Bynens (mathias@qiwi.be)
   7  *
   8  *  This library is free software; you can redistribute it and/or
   9  *  modify it under the terms of the GNU Library General Public
  10  *  License as published by the Free Software Foundation; either
  11  *  version 2 of the License, or (at your option) any later version.
  12  *
  13  *  This library is distributed in the hope that it will be useful,
  14  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  *  Library General Public License for more details.
  17  *
  18  *  You should have received a copy of the GNU Library General Public License
  19  *  along with this library; see the file COPYING.LIB.  If not, write to
  20  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  *  Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;Lexer.h&quot;
  27 
  28 #include &quot;BuiltinNames.h&quot;
  29 #include &quot;Identifier.h&quot;
  30 #include &quot;JSCInlines.h&quot;
  31 #include &quot;JSFunctionInlines.h&quot;
  32 #include &quot;KeywordLookup.h&quot;
  33 #include &quot;Lexer.lut.h&quot;
  34 #include &quot;Nodes.h&quot;
  35 #include &quot;ParseInt.h&quot;
  36 #include &quot;Parser.h&quot;
  37 #include &lt;ctype.h&gt;
  38 #include &lt;limits.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;wtf/Assertions.h&gt;
  41 #include &lt;wtf/HexNumber.h&gt;
  42 #include &lt;wtf/Variant.h&gt;
  43 #include &lt;wtf/dtoa.h&gt;
  44 
  45 namespace JSC {
  46 
  47 bool isLexerKeyword(const Identifier&amp; identifier)
  48 {
  49     return JSC::mainTable.entry(identifier);
  50 }
  51 
  52 enum CharacterType {
  53     // Types for the main switch
  54 
  55     // The first three types are fixed, and also used for identifying
  56     // ASCII alpha and alphanumeric characters (see isIdentStart and isIdentPart).
  57     CharacterIdentifierStart,
  58     CharacterZero,
  59     CharacterNumber,
  60 
  61     // For single-byte characters grandfathered into Other_ID_Continue -- namely just U+00B7 MIDDLE DOT.
  62     // (http://unicode.org/reports/tr31/#Backward_Compatibility)
  63     CharacterOtherIdentifierPart,
  64 
  65     CharacterInvalid,
  66     CharacterLineTerminator,
  67     CharacterExclamationMark,
  68     CharacterOpenParen,
  69     CharacterCloseParen,
  70     CharacterOpenBracket,
  71     CharacterCloseBracket,
  72     CharacterComma,
  73     CharacterColon,
  74     CharacterQuestion,
  75     CharacterTilde,
  76     CharacterQuote,
  77     CharacterBackQuote,
  78     CharacterDot,
  79     CharacterSlash,
  80     CharacterBackSlash,
  81     CharacterSemicolon,
  82     CharacterOpenBrace,
  83     CharacterCloseBrace,
  84 
  85     CharacterAdd,
  86     CharacterSub,
  87     CharacterMultiply,
  88     CharacterModulo,
  89     CharacterAnd,
  90     CharacterXor,
  91     CharacterOr,
  92     CharacterLess,
  93     CharacterGreater,
  94     CharacterEqual,
  95 
  96     // Other types (only one so far)
  97     CharacterWhiteSpace,
  98     CharacterHash,
  99     CharacterPrivateIdentifierStart
 100 };
 101 
 102 // 256 Latin-1 codes
 103 static constexpr const unsigned short typesOfLatin1Characters[256] = {
 104 /*   0 - Null               */ CharacterInvalid,
 105 /*   1 - Start of Heading   */ CharacterInvalid,
 106 /*   2 - Start of Text      */ CharacterInvalid,
 107 /*   3 - End of Text        */ CharacterInvalid,
 108 /*   4 - End of Transm.     */ CharacterInvalid,
 109 /*   5 - Enquiry            */ CharacterInvalid,
 110 /*   6 - Acknowledgment     */ CharacterInvalid,
 111 /*   7 - Bell               */ CharacterInvalid,
 112 /*   8 - Back Space         */ CharacterInvalid,
 113 /*   9 - Horizontal Tab     */ CharacterWhiteSpace,
 114 /*  10 - Line Feed          */ CharacterLineTerminator,
 115 /*  11 - Vertical Tab       */ CharacterWhiteSpace,
 116 /*  12 - Form Feed          */ CharacterWhiteSpace,
 117 /*  13 - Carriage Return    */ CharacterLineTerminator,
 118 /*  14 - Shift Out          */ CharacterInvalid,
 119 /*  15 - Shift In           */ CharacterInvalid,
 120 /*  16 - Data Line Escape   */ CharacterInvalid,
 121 /*  17 - Device Control 1   */ CharacterInvalid,
 122 /*  18 - Device Control 2   */ CharacterInvalid,
 123 /*  19 - Device Control 3   */ CharacterInvalid,
 124 /*  20 - Device Control 4   */ CharacterInvalid,
 125 /*  21 - Negative Ack.      */ CharacterInvalid,
 126 /*  22 - Synchronous Idle   */ CharacterInvalid,
 127 /*  23 - End of Transmit    */ CharacterInvalid,
 128 /*  24 - Cancel             */ CharacterInvalid,
 129 /*  25 - End of Medium      */ CharacterInvalid,
 130 /*  26 - Substitute         */ CharacterInvalid,
 131 /*  27 - Escape             */ CharacterInvalid,
 132 /*  28 - File Separator     */ CharacterInvalid,
 133 /*  29 - Group Separator    */ CharacterInvalid,
 134 /*  30 - Record Separator   */ CharacterInvalid,
 135 /*  31 - Unit Separator     */ CharacterInvalid,
 136 /*  32 - Space              */ CharacterWhiteSpace,
 137 /*  33 - !                  */ CharacterExclamationMark,
 138 /*  34 - &quot;                  */ CharacterQuote,
 139 /*  35 - #                  */ CharacterHash,
 140 /*  36 - $                  */ CharacterIdentifierStart,
 141 /*  37 - %                  */ CharacterModulo,
 142 /*  38 - &amp;                  */ CharacterAnd,
 143 /*  39 - &#39;                  */ CharacterQuote,
 144 /*  40 - (                  */ CharacterOpenParen,
 145 /*  41 - )                  */ CharacterCloseParen,
 146 /*  42 - *                  */ CharacterMultiply,
 147 /*  43 - +                  */ CharacterAdd,
 148 /*  44 - ,                  */ CharacterComma,
 149 /*  45 - -                  */ CharacterSub,
 150 /*  46 - .                  */ CharacterDot,
 151 /*  47 - /                  */ CharacterSlash,
 152 /*  48 - 0                  */ CharacterZero,
 153 /*  49 - 1                  */ CharacterNumber,
 154 /*  50 - 2                  */ CharacterNumber,
 155 /*  51 - 3                  */ CharacterNumber,
 156 /*  52 - 4                  */ CharacterNumber,
 157 /*  53 - 5                  */ CharacterNumber,
 158 /*  54 - 6                  */ CharacterNumber,
 159 /*  55 - 7                  */ CharacterNumber,
 160 /*  56 - 8                  */ CharacterNumber,
 161 /*  57 - 9                  */ CharacterNumber,
 162 /*  58 - :                  */ CharacterColon,
 163 /*  59 - ;                  */ CharacterSemicolon,
 164 /*  60 - &lt;                  */ CharacterLess,
 165 /*  61 - =                  */ CharacterEqual,
 166 /*  62 - &gt;                  */ CharacterGreater,
 167 /*  63 - ?                  */ CharacterQuestion,
 168 /*  64 - @                  */ CharacterPrivateIdentifierStart,
 169 /*  65 - A                  */ CharacterIdentifierStart,
 170 /*  66 - B                  */ CharacterIdentifierStart,
 171 /*  67 - C                  */ CharacterIdentifierStart,
 172 /*  68 - D                  */ CharacterIdentifierStart,
 173 /*  69 - E                  */ CharacterIdentifierStart,
 174 /*  70 - F                  */ CharacterIdentifierStart,
 175 /*  71 - G                  */ CharacterIdentifierStart,
 176 /*  72 - H                  */ CharacterIdentifierStart,
 177 /*  73 - I                  */ CharacterIdentifierStart,
 178 /*  74 - J                  */ CharacterIdentifierStart,
 179 /*  75 - K                  */ CharacterIdentifierStart,
 180 /*  76 - L                  */ CharacterIdentifierStart,
 181 /*  77 - M                  */ CharacterIdentifierStart,
 182 /*  78 - N                  */ CharacterIdentifierStart,
 183 /*  79 - O                  */ CharacterIdentifierStart,
 184 /*  80 - P                  */ CharacterIdentifierStart,
 185 /*  81 - Q                  */ CharacterIdentifierStart,
 186 /*  82 - R                  */ CharacterIdentifierStart,
 187 /*  83 - S                  */ CharacterIdentifierStart,
 188 /*  84 - T                  */ CharacterIdentifierStart,
 189 /*  85 - U                  */ CharacterIdentifierStart,
 190 /*  86 - V                  */ CharacterIdentifierStart,
 191 /*  87 - W                  */ CharacterIdentifierStart,
 192 /*  88 - X                  */ CharacterIdentifierStart,
 193 /*  89 - Y                  */ CharacterIdentifierStart,
 194 /*  90 - Z                  */ CharacterIdentifierStart,
 195 /*  91 - [                  */ CharacterOpenBracket,
 196 /*  92 - \                  */ CharacterBackSlash,
 197 /*  93 - ]                  */ CharacterCloseBracket,
 198 /*  94 - ^                  */ CharacterXor,
 199 /*  95 - _                  */ CharacterIdentifierStart,
 200 /*  96 - `                  */ CharacterBackQuote,
 201 /*  97 - a                  */ CharacterIdentifierStart,
 202 /*  98 - b                  */ CharacterIdentifierStart,
 203 /*  99 - c                  */ CharacterIdentifierStart,
 204 /* 100 - d                  */ CharacterIdentifierStart,
 205 /* 101 - e                  */ CharacterIdentifierStart,
 206 /* 102 - f                  */ CharacterIdentifierStart,
 207 /* 103 - g                  */ CharacterIdentifierStart,
 208 /* 104 - h                  */ CharacterIdentifierStart,
 209 /* 105 - i                  */ CharacterIdentifierStart,
 210 /* 106 - j                  */ CharacterIdentifierStart,
 211 /* 107 - k                  */ CharacterIdentifierStart,
 212 /* 108 - l                  */ CharacterIdentifierStart,
 213 /* 109 - m                  */ CharacterIdentifierStart,
 214 /* 110 - n                  */ CharacterIdentifierStart,
 215 /* 111 - o                  */ CharacterIdentifierStart,
 216 /* 112 - p                  */ CharacterIdentifierStart,
 217 /* 113 - q                  */ CharacterIdentifierStart,
 218 /* 114 - r                  */ CharacterIdentifierStart,
 219 /* 115 - s                  */ CharacterIdentifierStart,
 220 /* 116 - t                  */ CharacterIdentifierStart,
 221 /* 117 - u                  */ CharacterIdentifierStart,
 222 /* 118 - v                  */ CharacterIdentifierStart,
 223 /* 119 - w                  */ CharacterIdentifierStart,
 224 /* 120 - x                  */ CharacterIdentifierStart,
 225 /* 121 - y                  */ CharacterIdentifierStart,
 226 /* 122 - z                  */ CharacterIdentifierStart,
 227 /* 123 - {                  */ CharacterOpenBrace,
 228 /* 124 - |                  */ CharacterOr,
 229 /* 125 - }                  */ CharacterCloseBrace,
 230 /* 126 - ~                  */ CharacterTilde,
 231 /* 127 - Delete             */ CharacterInvalid,
 232 /* 128 - Cc category        */ CharacterInvalid,
 233 /* 129 - Cc category        */ CharacterInvalid,
 234 /* 130 - Cc category        */ CharacterInvalid,
 235 /* 131 - Cc category        */ CharacterInvalid,
 236 /* 132 - Cc category        */ CharacterInvalid,
 237 /* 133 - Cc category        */ CharacterInvalid,
 238 /* 134 - Cc category        */ CharacterInvalid,
 239 /* 135 - Cc category        */ CharacterInvalid,
 240 /* 136 - Cc category        */ CharacterInvalid,
 241 /* 137 - Cc category        */ CharacterInvalid,
 242 /* 138 - Cc category        */ CharacterInvalid,
 243 /* 139 - Cc category        */ CharacterInvalid,
 244 /* 140 - Cc category        */ CharacterInvalid,
 245 /* 141 - Cc category        */ CharacterInvalid,
 246 /* 142 - Cc category        */ CharacterInvalid,
 247 /* 143 - Cc category        */ CharacterInvalid,
 248 /* 144 - Cc category        */ CharacterInvalid,
 249 /* 145 - Cc category        */ CharacterInvalid,
 250 /* 146 - Cc category        */ CharacterInvalid,
 251 /* 147 - Cc category        */ CharacterInvalid,
 252 /* 148 - Cc category        */ CharacterInvalid,
 253 /* 149 - Cc category        */ CharacterInvalid,
 254 /* 150 - Cc category        */ CharacterInvalid,
 255 /* 151 - Cc category        */ CharacterInvalid,
 256 /* 152 - Cc category        */ CharacterInvalid,
 257 /* 153 - Cc category        */ CharacterInvalid,
 258 /* 154 - Cc category        */ CharacterInvalid,
 259 /* 155 - Cc category        */ CharacterInvalid,
 260 /* 156 - Cc category        */ CharacterInvalid,
 261 /* 157 - Cc category        */ CharacterInvalid,
 262 /* 158 - Cc category        */ CharacterInvalid,
 263 /* 159 - Cc category        */ CharacterInvalid,
 264 /* 160 - Zs category (nbsp) */ CharacterWhiteSpace,
 265 /* 161 - Po category        */ CharacterInvalid,
 266 /* 162 - Sc category        */ CharacterInvalid,
 267 /* 163 - Sc category        */ CharacterInvalid,
 268 /* 164 - Sc category        */ CharacterInvalid,
 269 /* 165 - Sc category        */ CharacterInvalid,
 270 /* 166 - So category        */ CharacterInvalid,
 271 /* 167 - So category        */ CharacterInvalid,
 272 /* 168 - Sk category        */ CharacterInvalid,
 273 /* 169 - So category        */ CharacterInvalid,
 274 /* 170 - Ll category        */ CharacterIdentifierStart,
 275 /* 171 - Pi category        */ CharacterInvalid,
 276 /* 172 - Sm category        */ CharacterInvalid,
 277 /* 173 - Cf category        */ CharacterInvalid,
 278 /* 174 - So category        */ CharacterInvalid,
 279 /* 175 - Sk category        */ CharacterInvalid,
 280 /* 176 - So category        */ CharacterInvalid,
 281 /* 177 - Sm category        */ CharacterInvalid,
 282 /* 178 - No category        */ CharacterInvalid,
 283 /* 179 - No category        */ CharacterInvalid,
 284 /* 180 - Sk category        */ CharacterInvalid,
 285 /* 181 - Ll category        */ CharacterIdentifierStart,
 286 /* 182 - So category        */ CharacterInvalid,
 287 /* 183 - Po category        */ CharacterOtherIdentifierPart,
 288 /* 184 - Sk category        */ CharacterInvalid,
 289 /* 185 - No category        */ CharacterInvalid,
 290 /* 186 - Ll category        */ CharacterIdentifierStart,
 291 /* 187 - Pf category        */ CharacterInvalid,
 292 /* 188 - No category        */ CharacterInvalid,
 293 /* 189 - No category        */ CharacterInvalid,
 294 /* 190 - No category        */ CharacterInvalid,
 295 /* 191 - Po category        */ CharacterInvalid,
 296 /* 192 - Lu category        */ CharacterIdentifierStart,
 297 /* 193 - Lu category        */ CharacterIdentifierStart,
 298 /* 194 - Lu category        */ CharacterIdentifierStart,
 299 /* 195 - Lu category        */ CharacterIdentifierStart,
 300 /* 196 - Lu category        */ CharacterIdentifierStart,
 301 /* 197 - Lu category        */ CharacterIdentifierStart,
 302 /* 198 - Lu category        */ CharacterIdentifierStart,
 303 /* 199 - Lu category        */ CharacterIdentifierStart,
 304 /* 200 - Lu category        */ CharacterIdentifierStart,
 305 /* 201 - Lu category        */ CharacterIdentifierStart,
 306 /* 202 - Lu category        */ CharacterIdentifierStart,
 307 /* 203 - Lu category        */ CharacterIdentifierStart,
 308 /* 204 - Lu category        */ CharacterIdentifierStart,
 309 /* 205 - Lu category        */ CharacterIdentifierStart,
 310 /* 206 - Lu category        */ CharacterIdentifierStart,
 311 /* 207 - Lu category        */ CharacterIdentifierStart,
 312 /* 208 - Lu category        */ CharacterIdentifierStart,
 313 /* 209 - Lu category        */ CharacterIdentifierStart,
 314 /* 210 - Lu category        */ CharacterIdentifierStart,
 315 /* 211 - Lu category        */ CharacterIdentifierStart,
 316 /* 212 - Lu category        */ CharacterIdentifierStart,
 317 /* 213 - Lu category        */ CharacterIdentifierStart,
 318 /* 214 - Lu category        */ CharacterIdentifierStart,
 319 /* 215 - Sm category        */ CharacterInvalid,
 320 /* 216 - Lu category        */ CharacterIdentifierStart,
 321 /* 217 - Lu category        */ CharacterIdentifierStart,
 322 /* 218 - Lu category        */ CharacterIdentifierStart,
 323 /* 219 - Lu category        */ CharacterIdentifierStart,
 324 /* 220 - Lu category        */ CharacterIdentifierStart,
 325 /* 221 - Lu category        */ CharacterIdentifierStart,
 326 /* 222 - Lu category        */ CharacterIdentifierStart,
 327 /* 223 - Ll category        */ CharacterIdentifierStart,
 328 /* 224 - Ll category        */ CharacterIdentifierStart,
 329 /* 225 - Ll category        */ CharacterIdentifierStart,
 330 /* 226 - Ll category        */ CharacterIdentifierStart,
 331 /* 227 - Ll category        */ CharacterIdentifierStart,
 332 /* 228 - Ll category        */ CharacterIdentifierStart,
 333 /* 229 - Ll category        */ CharacterIdentifierStart,
 334 /* 230 - Ll category        */ CharacterIdentifierStart,
 335 /* 231 - Ll category        */ CharacterIdentifierStart,
 336 /* 232 - Ll category        */ CharacterIdentifierStart,
 337 /* 233 - Ll category        */ CharacterIdentifierStart,
 338 /* 234 - Ll category        */ CharacterIdentifierStart,
 339 /* 235 - Ll category        */ CharacterIdentifierStart,
 340 /* 236 - Ll category        */ CharacterIdentifierStart,
 341 /* 237 - Ll category        */ CharacterIdentifierStart,
 342 /* 238 - Ll category        */ CharacterIdentifierStart,
 343 /* 239 - Ll category        */ CharacterIdentifierStart,
 344 /* 240 - Ll category        */ CharacterIdentifierStart,
 345 /* 241 - Ll category        */ CharacterIdentifierStart,
 346 /* 242 - Ll category        */ CharacterIdentifierStart,
 347 /* 243 - Ll category        */ CharacterIdentifierStart,
 348 /* 244 - Ll category        */ CharacterIdentifierStart,
 349 /* 245 - Ll category        */ CharacterIdentifierStart,
 350 /* 246 - Ll category        */ CharacterIdentifierStart,
 351 /* 247 - Sm category        */ CharacterInvalid,
 352 /* 248 - Ll category        */ CharacterIdentifierStart,
 353 /* 249 - Ll category        */ CharacterIdentifierStart,
 354 /* 250 - Ll category        */ CharacterIdentifierStart,
 355 /* 251 - Ll category        */ CharacterIdentifierStart,
 356 /* 252 - Ll category        */ CharacterIdentifierStart,
 357 /* 253 - Ll category        */ CharacterIdentifierStart,
 358 /* 254 - Ll category        */ CharacterIdentifierStart,
 359 /* 255 - Ll category        */ CharacterIdentifierStart
 360 };
 361 
 362 // This table provides the character that results from \X where X is the index in the table beginning
 363 // with SPACE. A table value of 0 means that more processing needs to be done.
 364 static constexpr const LChar singleCharacterEscapeValuesForASCII[128] = {
 365 /*   0 - Null               */ 0,
 366 /*   1 - Start of Heading   */ 0,
 367 /*   2 - Start of Text      */ 0,
 368 /*   3 - End of Text        */ 0,
 369 /*   4 - End of Transm.     */ 0,
 370 /*   5 - Enquiry            */ 0,
 371 /*   6 - Acknowledgment     */ 0,
 372 /*   7 - Bell               */ 0,
 373 /*   8 - Back Space         */ 0,
 374 /*   9 - Horizontal Tab     */ 0,
 375 /*  10 - Line Feed          */ 0,
 376 /*  11 - Vertical Tab       */ 0,
 377 /*  12 - Form Feed          */ 0,
 378 /*  13 - Carriage Return    */ 0,
 379 /*  14 - Shift Out          */ 0,
 380 /*  15 - Shift In           */ 0,
 381 /*  16 - Data Line Escape   */ 0,
 382 /*  17 - Device Control 1   */ 0,
 383 /*  18 - Device Control 2   */ 0,
 384 /*  19 - Device Control 3   */ 0,
 385 /*  20 - Device Control 4   */ 0,
 386 /*  21 - Negative Ack.      */ 0,
 387 /*  22 - Synchronous Idle   */ 0,
 388 /*  23 - End of Transmit    */ 0,
 389 /*  24 - Cancel             */ 0,
 390 /*  25 - End of Medium      */ 0,
 391 /*  26 - Substitute         */ 0,
 392 /*  27 - Escape             */ 0,
 393 /*  28 - File Separator     */ 0,
 394 /*  29 - Group Separator    */ 0,
 395 /*  30 - Record Separator   */ 0,
 396 /*  31 - Unit Separator     */ 0,
 397 /*  32 - Space              */ &#39; &#39;,
 398 /*  33 - !                  */ &#39;!&#39;,
 399 /*  34 - &quot;                  */ &#39;&quot;&#39;,
 400 /*  35 - #                  */ &#39;#&#39;,
 401 /*  36 - $                  */ &#39;$&#39;,
 402 /*  37 - %                  */ &#39;%&#39;,
 403 /*  38 - &amp;                  */ &#39;&amp;&#39;,
 404 /*  39 - &#39;                  */ &#39;\&#39;&#39;,
 405 /*  40 - (                  */ &#39;(&#39;,
 406 /*  41 - )                  */ &#39;)&#39;,
 407 /*  42 - *                  */ &#39;*&#39;,
 408 /*  43 - +                  */ &#39;+&#39;,
 409 /*  44 - ,                  */ &#39;,&#39;,
 410 /*  45 - -                  */ &#39;-&#39;,
 411 /*  46 - .                  */ &#39;.&#39;,
 412 /*  47 - /                  */ &#39;/&#39;,
 413 /*  48 - 0                  */ 0,
 414 /*  49 - 1                  */ 0,
 415 /*  50 - 2                  */ 0,
 416 /*  51 - 3                  */ 0,
 417 /*  52 - 4                  */ 0,
 418 /*  53 - 5                  */ 0,
 419 /*  54 - 6                  */ 0,
 420 /*  55 - 7                  */ 0,
 421 /*  56 - 8                  */ 0,
 422 /*  57 - 9                  */ 0,
 423 /*  58 - :                  */ &#39;:&#39;,
 424 /*  59 - ;                  */ &#39;;&#39;,
 425 /*  60 - &lt;                  */ &#39;&lt;&#39;,
 426 /*  61 - =                  */ &#39;=&#39;,
 427 /*  62 - &gt;                  */ &#39;&gt;&#39;,
 428 /*  63 - ?                  */ &#39;?&#39;,
 429 /*  64 - @                  */ &#39;@&#39;,
 430 /*  65 - A                  */ &#39;A&#39;,
 431 /*  66 - B                  */ &#39;B&#39;,
 432 /*  67 - C                  */ &#39;C&#39;,
 433 /*  68 - D                  */ &#39;D&#39;,
 434 /*  69 - E                  */ &#39;E&#39;,
 435 /*  70 - F                  */ &#39;F&#39;,
 436 /*  71 - G                  */ &#39;G&#39;,
 437 /*  72 - H                  */ &#39;H&#39;,
 438 /*  73 - I                  */ &#39;I&#39;,
 439 /*  74 - J                  */ &#39;J&#39;,
 440 /*  75 - K                  */ &#39;K&#39;,
 441 /*  76 - L                  */ &#39;L&#39;,
 442 /*  77 - M                  */ &#39;M&#39;,
 443 /*  78 - N                  */ &#39;N&#39;,
 444 /*  79 - O                  */ &#39;O&#39;,
 445 /*  80 - P                  */ &#39;P&#39;,
 446 /*  81 - Q                  */ &#39;Q&#39;,
 447 /*  82 - R                  */ &#39;R&#39;,
 448 /*  83 - S                  */ &#39;S&#39;,
 449 /*  84 - T                  */ &#39;T&#39;,
 450 /*  85 - U                  */ &#39;U&#39;,
 451 /*  86 - V                  */ &#39;V&#39;,
 452 /*  87 - W                  */ &#39;W&#39;,
 453 /*  88 - X                  */ &#39;X&#39;,
 454 /*  89 - Y                  */ &#39;Y&#39;,
 455 /*  90 - Z                  */ &#39;Z&#39;,
 456 /*  91 - [                  */ &#39;[&#39;,
 457 /*  92 - \                  */ &#39;\\&#39;,
 458 /*  93 - ]                  */ &#39;]&#39;,
 459 /*  94 - ^                  */ &#39;^&#39;,
 460 /*  95 - _                  */ &#39;_&#39;,
 461 /*  96 - `                  */ &#39;`&#39;,
 462 /*  97 - a                  */ &#39;a&#39;,
 463 /*  98 - b                  */ 0x08,
 464 /*  99 - c                  */ &#39;c&#39;,
 465 /* 100 - d                  */ &#39;d&#39;,
 466 /* 101 - e                  */ &#39;e&#39;,
 467 /* 102 - f                  */ 0x0C,
 468 /* 103 - g                  */ &#39;g&#39;,
 469 /* 104 - h                  */ &#39;h&#39;,
 470 /* 105 - i                  */ &#39;i&#39;,
 471 /* 106 - j                  */ &#39;j&#39;,
 472 /* 107 - k                  */ &#39;k&#39;,
 473 /* 108 - l                  */ &#39;l&#39;,
 474 /* 109 - m                  */ &#39;m&#39;,
 475 /* 110 - n                  */ 0x0A,
 476 /* 111 - o                  */ &#39;o&#39;,
 477 /* 112 - p                  */ &#39;p&#39;,
 478 /* 113 - q                  */ &#39;q&#39;,
 479 /* 114 - r                  */ 0x0D,
 480 /* 115 - s                  */ &#39;s&#39;,
 481 /* 116 - t                  */ 0x09,
 482 /* 117 - u                  */ 0,
 483 /* 118 - v                  */ 0x0B,
 484 /* 119 - w                  */ &#39;w&#39;,
 485 /* 120 - x                  */ 0,
 486 /* 121 - y                  */ &#39;y&#39;,
 487 /* 122 - z                  */ &#39;z&#39;,
 488 /* 123 - {                  */ &#39;{&#39;,
 489 /* 124 - |                  */ &#39;|&#39;,
 490 /* 125 - }                  */ &#39;}&#39;,
 491 /* 126 - ~                  */ &#39;~&#39;,
 492 /* 127 - Delete             */ 0
 493 };
 494 
 495 template &lt;typename T&gt;
 496 Lexer&lt;T&gt;::Lexer(VM&amp; vm, JSParserBuiltinMode builtinMode, JSParserScriptMode scriptMode)
<a name="1" id="anc1"></a><span class="line-modified"> 497     : m_positionBeforeLastNewline(0,0,0)</span>
<span class="line-added"> 498     , m_isReparsingFunction(false)</span>
 499     , m_vm(vm)
 500     , m_parsingBuiltinFunction(builtinMode == JSParserBuiltinMode::Builtin)
 501     , m_scriptMode(scriptMode)
 502 {
 503 }
 504 
 505 static inline JSTokenType tokenTypeForIntegerLikeToken(double doubleValue)
 506 {
 507     if ((doubleValue || !std::signbit(doubleValue)) &amp;&amp; static_cast&lt;int64_t&gt;(doubleValue) == doubleValue)
 508         return INTEGER;
 509     return DOUBLE;
 510 }
 511 
 512 template &lt;typename T&gt;
 513 Lexer&lt;T&gt;::~Lexer()
 514 {
 515 }
 516 
 517 template &lt;typename T&gt;
 518 String Lexer&lt;T&gt;::invalidCharacterMessage() const
 519 {
 520     switch (m_current) {
 521     case 0:
 522         return &quot;Invalid character: &#39;\\0&#39;&quot;_s;
 523     case 10:
 524         return &quot;Invalid character: &#39;\\n&#39;&quot;_s;
 525     case 11:
 526         return &quot;Invalid character: &#39;\\v&#39;&quot;_s;
 527     case 13:
 528         return &quot;Invalid character: &#39;\\r&#39;&quot;_s;
 529     case 35:
 530         return &quot;Invalid character: &#39;#&#39;&quot;_s;
 531     case 64:
 532         return &quot;Invalid character: &#39;@&#39;&quot;_s;
 533     case 96:
 534         return &quot;Invalid character: &#39;`&#39;&quot;_s;
 535     default:
 536         return makeString(&quot;Invalid character &#39;\\u&quot;, hex(m_current, 4, Lowercase), &#39;\&#39;&#39;);
 537     }
 538 }
 539 
 540 template &lt;typename T&gt;
 541 ALWAYS_INLINE const T* Lexer&lt;T&gt;::currentSourcePtr() const
 542 {
 543     ASSERT(m_code &lt;= m_codeEnd);
 544     return m_code;
 545 }
 546 
 547 template &lt;typename T&gt;
 548 void Lexer&lt;T&gt;::setCode(const SourceCode&amp; source, ParserArena* arena)
 549 {
 550     m_arena = &amp;arena-&gt;identifierArena();
 551 
 552     m_lineNumber = source.firstLine().oneBasedInt();
 553     m_lastToken = -1;
 554 
 555     StringView sourceString = source.provider()-&gt;source();
 556 
 557     if (!sourceString.isNull())
 558         setCodeStart(sourceString);
 559     else
 560         m_codeStart = 0;
 561 
 562     m_source = &amp;source;
 563     m_sourceOffset = source.startOffset();
 564     m_codeStartPlusOffset = m_codeStart + source.startOffset();
 565     m_code = m_codeStartPlusOffset;
 566     m_codeEnd = m_codeStart + source.endOffset();
 567     m_error = false;
 568     m_atLineStart = true;
 569     m_lineStart = m_code;
 570     m_lexErrorMessage = String();
 571     m_sourceURLDirective = String();
 572     m_sourceMappingURLDirective = String();
 573 
 574     m_buffer8.reserveInitialCapacity(initialReadBufferCapacity);
 575     m_buffer16.reserveInitialCapacity(initialReadBufferCapacity);
 576     m_bufferForRawTemplateString16.reserveInitialCapacity(initialReadBufferCapacity);
 577 
 578     if (LIKELY(m_code &lt; m_codeEnd))
 579         m_current = *m_code;
 580     else
 581         m_current = 0;
 582     ASSERT(currentOffset() == source.startOffset());
 583 }
 584 
 585 template &lt;typename T&gt;
 586 template &lt;int shiftAmount&gt; ALWAYS_INLINE void Lexer&lt;T&gt;::internalShift()
 587 {
 588     m_code += shiftAmount;
 589     ASSERT(currentOffset() &gt;= currentLineStartOffset());
 590     m_current = *m_code;
 591 }
 592 
 593 template &lt;typename T&gt;
 594 ALWAYS_INLINE void Lexer&lt;T&gt;::shift()
 595 {
 596     // At one point timing showed that setting m_current to 0 unconditionally was faster than an if-else sequence.
 597     m_current = 0;
 598     ++m_code;
 599     if (LIKELY(m_code &lt; m_codeEnd))
 600         m_current = *m_code;
 601 }
 602 
 603 template &lt;typename T&gt;
 604 ALWAYS_INLINE bool Lexer&lt;T&gt;::atEnd() const
 605 {
 606     ASSERT(!m_current || m_code &lt; m_codeEnd);
 607     return UNLIKELY(UNLIKELY(!m_current) &amp;&amp; m_code == m_codeEnd);
 608 }
 609 
 610 template &lt;typename T&gt;
 611 ALWAYS_INLINE T Lexer&lt;T&gt;::peek(int offset) const
 612 {
 613     ASSERT(offset &gt; 0 &amp;&amp; offset &lt; 5);
 614     const T* code = m_code + offset;
 615     return (code &lt; m_codeEnd) ? *code : 0;
 616 }
 617 
 618 struct ParsedUnicodeEscapeValue {
 619     ParsedUnicodeEscapeValue(UChar32 value)
 620         : m_value(value)
 621     {
 622         ASSERT(isValid());
 623     }
 624 
 625     enum SpecialValueType { Incomplete = -2, Invalid = -1 };
 626     ParsedUnicodeEscapeValue(SpecialValueType type)
 627         : m_value(type)
 628     {
 629     }
 630 
 631     bool isValid() const { return m_value &gt;= 0; }
 632     bool isIncomplete() const { return m_value == Incomplete; }
 633 
 634     UChar32 value() const
 635     {
 636         ASSERT(isValid());
 637         return m_value;
 638     }
 639 
 640 private:
 641     UChar32 m_value;
 642 };
 643 
 644 template&lt;typename CharacterType&gt;
 645 ParsedUnicodeEscapeValue Lexer&lt;CharacterType&gt;::parseUnicodeEscape()
 646 {
 647     if (m_current == &#39;{&#39;) {
 648         shift();
 649         UChar32 codePoint = 0;
 650         do {
 651             if (!isASCIIHexDigit(m_current))
 652                 return m_current ? ParsedUnicodeEscapeValue::Invalid : ParsedUnicodeEscapeValue::Incomplete;
 653             codePoint = (codePoint &lt;&lt; 4) | toASCIIHexValue(m_current);
 654             if (codePoint &gt; UCHAR_MAX_VALUE) {
 655                 // For raw template literal syntax, we consume `NotEscapeSequence`.
 656                 // Here, we consume NotCodePoint&#39;s HexDigits.
 657                 //
 658                 // NotEscapeSequence ::
 659                 //     u { [lookahread not one of HexDigit]
 660                 //     u { NotCodePoint
 661                 //     u { CodePoint [lookahead != }]
 662                 //
 663                 // NotCodePoint ::
 664                 //     HexDigits but not if MV of HexDigits &lt;= 0x10FFFF
 665                 //
 666                 // CodePoint ::
 667                 //     HexDigits but not if MV of HexDigits &gt; 0x10FFFF
 668                 shift();
 669                 while (isASCIIHexDigit(m_current))
 670                     shift();
 671 
 672                 return atEnd() ? ParsedUnicodeEscapeValue::Incomplete : ParsedUnicodeEscapeValue::Invalid;
 673             }
 674             shift();
 675         } while (m_current != &#39;}&#39;);
 676         shift();
 677         return codePoint;
 678     }
 679 
 680     auto character2 = peek(1);
 681     auto character3 = peek(2);
 682     auto character4 = peek(3);
 683     if (UNLIKELY(!isASCIIHexDigit(m_current) || !isASCIIHexDigit(character2) || !isASCIIHexDigit(character3) || !isASCIIHexDigit(character4))) {
 684         auto result = (m_code + 4) &gt;= m_codeEnd ? ParsedUnicodeEscapeValue::Incomplete : ParsedUnicodeEscapeValue::Invalid;
 685 
 686         // For raw template literal syntax, we consume `NotEscapeSequence`.
 687         //
 688         // NotEscapeSequence ::
 689         //     u [lookahead not one of HexDigit][lookahead != {]
 690         //     u HexDigit [lookahead not one of HexDigit]
 691         //     u HexDigit HexDigit [lookahead not one of HexDigit]
 692         //     u HexDigit HexDigit HexDigit [lookahead not one of HexDigit]
 693         while (isASCIIHexDigit(m_current))
 694             shift();
 695 
 696         return result;
 697     }
 698 
 699     auto result = convertUnicode(m_current, character2, character3, character4);
 700     shift();
 701     shift();
 702     shift();
 703     shift();
 704     return result;
 705 }
 706 
 707 template &lt;typename T&gt;
 708 void Lexer&lt;T&gt;::shiftLineTerminator()
 709 {
 710     ASSERT(isLineTerminator(m_current));
 711 
 712     m_positionBeforeLastNewline = currentPosition();
 713     T prev = m_current;
 714     shift();
 715 
 716     if (prev == &#39;\r&#39; &amp;&amp; m_current == &#39;\n&#39;)
 717         shift();
 718 
 719     ++m_lineNumber;
 720 }
 721 
 722 template &lt;typename T&gt;
 723 ALWAYS_INLINE bool Lexer&lt;T&gt;::lastTokenWasRestrKeyword() const
 724 {
 725     return m_lastToken == CONTINUE || m_lastToken == BREAK || m_lastToken == RETURN || m_lastToken == THROW;
 726 }
 727 
 728 template &lt;typename T&gt;
 729 ALWAYS_INLINE void Lexer&lt;T&gt;::skipWhitespace()
 730 {
 731     while (isWhiteSpace(m_current))
 732         shift();
 733 }
 734 
 735 static NEVER_INLINE bool isNonLatin1IdentStart(UChar c)
 736 {
 737     return u_hasBinaryProperty(c, UCHAR_ID_START);
 738 }
 739 
 740 static inline bool isIdentStart(LChar c)
 741 {
 742     return typesOfLatin1Characters[c] == CharacterIdentifierStart;
 743 }
 744 
 745 static inline bool isIdentStart(UChar32 c)
 746 {
 747     return isLatin1(c) ? isIdentStart(static_cast&lt;LChar&gt;(c)) : isNonLatin1IdentStart(c);
 748 }
 749 
 750 static NEVER_INLINE bool isNonLatin1IdentPart(UChar32 c)
 751 {
 752     return u_hasBinaryProperty(c, UCHAR_ID_CONTINUE) || c == 0x200C || c == 0x200D;
 753 }
 754 
 755 static ALWAYS_INLINE bool isIdentPart(LChar c)
 756 {
 757     // Character types are divided into two groups depending on whether they can be part of an
 758     // identifier or not. Those whose type value is less or equal than CharacterOtherIdentifierPart can be
 759     // part of an identifier. (See the CharacterType definition for more details.)
 760     return typesOfLatin1Characters[c] &lt;= CharacterOtherIdentifierPart;
 761 }
 762 
 763 static ALWAYS_INLINE bool isIdentPart(UChar32 c)
 764 {
 765     return isLatin1(c) ? isIdentPart(static_cast&lt;LChar&gt;(c)) : isNonLatin1IdentPart(c);
 766 }
 767 
 768 static ALWAYS_INLINE bool isIdentPart(UChar c)
 769 {
 770     return isIdentPart(static_cast&lt;UChar32&gt;(c));
 771 }
 772 
 773 template&lt;typename CharacterType&gt; ALWAYS_INLINE bool isIdentPartIncludingEscapeTemplate(const CharacterType* code, const CharacterType* codeEnd)
 774 {
 775     if (isIdentPart(code[0]))
 776         return true;
 777 
 778     // Shortest sequence handled below is \u{0}, which is 5 characters.
 779     if (!(code[0] == &#39;\\&#39; &amp;&amp; codeEnd - code &gt;= 5 &amp;&amp; code[1] == &#39;u&#39;))
 780         return false;
 781 
 782     if (code[2] == &#39;{&#39;) {
 783         UChar32 codePoint = 0;
 784         const CharacterType* pointer;
 785         for (pointer = &amp;code[3]; pointer &lt; codeEnd; ++pointer) {
 786             auto digit = *pointer;
 787             if (!isASCIIHexDigit(digit))
 788                 break;
 789             codePoint = (codePoint &lt;&lt; 4) | toASCIIHexValue(digit);
 790             if (codePoint &gt; UCHAR_MAX_VALUE)
 791                 return false;
 792         }
 793         return isIdentPart(codePoint) &amp;&amp; pointer &lt; codeEnd &amp;&amp; *pointer == &#39;}&#39;;
 794     }
 795 
 796     // Shortest sequence handled below is \uXXXX, which is 6 characters.
 797     if (codeEnd - code &lt; 6)
 798         return false;
 799 
 800     auto character1 = code[2];
 801     auto character2 = code[3];
 802     auto character3 = code[4];
 803     auto character4 = code[5];
 804     return isASCIIHexDigit(character1) &amp;&amp; isASCIIHexDigit(character2) &amp;&amp; isASCIIHexDigit(character3) &amp;&amp; isASCIIHexDigit(character4)
 805         &amp;&amp; isIdentPart(Lexer&lt;LChar&gt;::convertUnicode(character1, character2, character3, character4));
 806 }
 807 
 808 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const LChar* code, const LChar* codeEnd)
 809 {
 810     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 811 }
 812 
 813 static ALWAYS_INLINE bool isIdentPartIncludingEscape(const UChar* code, const UChar* codeEnd)
 814 {
 815     return isIdentPartIncludingEscapeTemplate(code, codeEnd);
 816 }
 817 
 818 template&lt;typename CharacterType&gt;
 819 static inline bool isASCIIDigitOrSeparator(CharacterType character)
 820 {
 821     return isASCIIDigit(character) || character == &#39;_&#39;;
 822 }
 823 
 824 template&lt;typename CharacterType&gt;
 825 static inline bool isASCIIHexDigitOrSeparator(CharacterType character)
 826 {
 827     return isASCIIHexDigit(character) || character == &#39;_&#39;;
 828 }
 829 
 830 template&lt;typename CharacterType&gt;
 831 static inline bool isASCIIBinaryDigitOrSeparator(CharacterType character)
 832 {
 833     return isASCIIBinaryDigit(character) || character == &#39;_&#39;;
 834 }
 835 
 836 template&lt;typename CharacterType&gt;
 837 static inline bool isASCIIOctalDigitOrSeparator(CharacterType character)
 838 {
 839     return isASCIIOctalDigit(character) || character == &#39;_&#39;;
 840 }
 841 
 842 static inline LChar singleEscape(int c)
 843 {
 844     if (c &lt; 128) {
 845         ASSERT(static_cast&lt;size_t&gt;(c) &lt; WTF_ARRAY_LENGTH(singleCharacterEscapeValuesForASCII));
 846         return singleCharacterEscapeValuesForASCII[c];
 847     }
 848     return 0;
 849 }
 850 
 851 template &lt;typename T&gt;
 852 inline void Lexer&lt;T&gt;::record8(int c)
 853 {
 854     ASSERT(isLatin1(c));
 855     m_buffer8.append(static_cast&lt;LChar&gt;(c));
 856 }
 857 
 858 template &lt;typename T&gt;
 859 inline void Lexer&lt;T&gt;::append8(const T* p, size_t length)
 860 {
 861     size_t currentSize = m_buffer8.size();
 862     m_buffer8.grow(currentSize + length);
 863     LChar* rawBuffer = m_buffer8.data() + currentSize;
 864 
 865     for (size_t i = 0; i &lt; length; i++) {
 866         T c = p[i];
 867         ASSERT(isLatin1(c));
 868         rawBuffer[i] = c;
 869     }
 870 }
 871 
 872 template &lt;typename T&gt;
 873 inline void Lexer&lt;T&gt;::append16(const LChar* p, size_t length)
 874 {
 875     size_t currentSize = m_buffer16.size();
 876     m_buffer16.grow(currentSize + length);
 877     UChar* rawBuffer = m_buffer16.data() + currentSize;
 878 
 879     for (size_t i = 0; i &lt; length; i++)
 880         rawBuffer[i] = p[i];
 881 }
 882 
 883 template &lt;typename T&gt;
 884 inline void Lexer&lt;T&gt;::record16(T c)
 885 {
 886     m_buffer16.append(c);
 887 }
 888 
 889 template &lt;typename T&gt;
 890 inline void Lexer&lt;T&gt;::record16(int c)
 891 {
 892     ASSERT(c &gt;= 0);
 893     ASSERT(c &lt;= static_cast&lt;int&gt;(USHRT_MAX));
 894     m_buffer16.append(static_cast&lt;UChar&gt;(c));
 895 }
 896 
 897 template&lt;typename CharacterType&gt; inline void Lexer&lt;CharacterType&gt;::recordUnicodeCodePoint(UChar32 codePoint)
 898 {
 899     ASSERT(codePoint &gt;= 0);
 900     ASSERT(codePoint &lt;= UCHAR_MAX_VALUE);
 901     if (U_IS_BMP(codePoint))
 902         record16(codePoint);
 903     else {
 904         UChar codeUnits[2] = { U16_LEAD(codePoint), U16_TRAIL(codePoint) };
 905         append16(codeUnits, 2);
 906     }
 907 }
 908 
<a name="2" id="anc2"></a><span class="line-modified"> 909 #if ASSERT_ENABLED</span>
 910 bool isSafeBuiltinIdentifier(VM&amp; vm, const Identifier* ident)
 911 {
 912     if (!ident)
 913         return true;
 914     /* Just block any use of suspicious identifiers.  This is intended to
 915      * be used as a safety net while implementing builtins.
 916      */
 917     // FIXME: How can a debug-only assertion be a safety net?
 918     if (*ident == vm.propertyNames-&gt;builtinNames().callPublicName())
 919         return false;
 920     if (*ident == vm.propertyNames-&gt;builtinNames().applyPublicName())
 921         return false;
 922     if (*ident == vm.propertyNames-&gt;eval)
 923         return false;
 924     if (*ident == vm.propertyNames-&gt;Function)
 925         return false;
 926     return true;
 927 }
<a name="3" id="anc3"></a><span class="line-modified"> 928 #endif // ASSERT_ENABLED</span>
 929 
 930 template &lt;&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 931 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;LChar&gt;::parseIdentifier(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
 932 {
 933     tokenData-&gt;escaped = false;
 934     const ptrdiff_t remaining = m_codeEnd - m_code;
<a name="5" id="anc5"></a><span class="line-modified"> 935     if ((remaining &gt;= maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) {</span>
 936         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
 937         if (keyword != IDENT) {
 938             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
 939             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
 940         }
 941     }
 942 
 943     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
 944     if (isPrivateName)
 945         shift();
 946 
 947     const LChar* identifierStart = currentSourcePtr();
 948     unsigned identifierLineStart = currentLineStartOffset();
 949 
 950     while (isIdentPart(m_current))
 951         shift();
 952 
 953     if (UNLIKELY(m_current == &#39;\\&#39;)) {
 954         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
 955         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
 956     }
 957 
 958     const Identifier* ident = nullptr;
 959 
 960     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
 961         int identifierLength = currentSourcePtr() - identifierStart;
 962         ident = makeIdentifier(identifierStart, identifierLength);
 963         if (m_parsingBuiltinFunction) {
 964             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {
 965                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
 966                 return ERRORTOK;
 967             }
 968             if (isPrivateName)
 969                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));
 970             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)
 971                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;
 972             if (!ident)
 973                 return INVALID_PRIVATE_NAME_ERRORTOK;
 974         }
 975         tokenData-&gt;ident = ident;
 976     } else
 977         tokenData-&gt;ident = nullptr;
 978 
<a name="6" id="anc6"></a><span class="line-modified"> 979     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) &amp;&amp; !isPrivateName) {</span>
 980         ASSERT(shouldCreateIdentifier);
 981         if (remaining &lt; maxTokenLength) {
 982             const HashTableValue* entry = JSC::mainTable.entry(*ident);
 983             ASSERT((remaining &lt; maxTokenLength) || !entry);
 984             if (!entry)
 985                 return IDENT;
 986             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
 987             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
 988         }
 989         return IDENT;
 990     }
 991 
 992     return IDENT;
 993 }
 994 
 995 template &lt;&gt;
<a name="7" id="anc7"></a><span class="line-modified"> 996 template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType Lexer&lt;UChar&gt;::parseIdentifier(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
 997 {
 998     tokenData-&gt;escaped = false;
 999     const ptrdiff_t remaining = m_codeEnd - m_code;
<a name="8" id="anc8"></a><span class="line-modified">1000     if ((remaining &gt;= maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) {</span>
1001         JSTokenType keyword = parseKeyword&lt;shouldCreateIdentifier&gt;(tokenData);
1002         if (keyword != IDENT) {
1003             ASSERT((!shouldCreateIdentifier) || tokenData-&gt;ident);
1004             return keyword == RESERVED_IF_STRICT &amp;&amp; !strictMode ? IDENT : keyword;
1005         }
1006     }
1007 
1008     bool isPrivateName = m_current == &#39;@&#39; &amp;&amp; m_parsingBuiltinFunction;
1009     if (isPrivateName)
1010         shift();
1011 
1012     const UChar* identifierStart = currentSourcePtr();
1013     int identifierLineStart = currentLineStartOffset();
1014 
1015     UChar orAllChars = 0;
1016 
1017     while (isIdentPart(m_current)) {
1018         orAllChars |= m_current;
1019         shift();
1020     }
1021 
1022     if (UNLIKELY(m_current == &#39;\\&#39;)) {
1023         ASSERT(!isPrivateName);
1024         setOffsetFromSourcePtr(identifierStart, identifierLineStart);
1025         return parseIdentifierSlowCase&lt;shouldCreateIdentifier&gt;(tokenData, lexerFlags, strictMode);
1026     }
1027 
1028     bool isAll8Bit = false;
1029 
1030     if (!(orAllChars &amp; ~0xff))
1031         isAll8Bit = true;
1032 
1033     const Identifier* ident = nullptr;
1034 
1035     if (shouldCreateIdentifier || m_parsingBuiltinFunction) {
1036         int identifierLength = currentSourcePtr() - identifierStart;
1037         if (isAll8Bit)
1038             ident = makeIdentifierLCharFromUChar(identifierStart, identifierLength);
1039         else
1040             ident = makeIdentifier(identifierStart, identifierLength);
1041         if (m_parsingBuiltinFunction) {
1042             if (!isSafeBuiltinIdentifier(m_vm, ident) &amp;&amp; !isPrivateName) {
1043                 m_lexErrorMessage = makeString(&quot;The use of &#39;&quot;, ident-&gt;string(), &quot;&#39; is disallowed in builtin functions.&quot;);
1044                 return ERRORTOK;
1045             }
1046             if (isPrivateName)
1047                 ident = &amp;m_arena-&gt;makeIdentifier(m_vm, m_vm.propertyNames-&gt;lookUpPrivateName(*ident));
1048             else if (*ident == m_vm.propertyNames-&gt;undefinedKeyword)
1049                 tokenData-&gt;ident = &amp;m_vm.propertyNames-&gt;undefinedPrivateName;
1050             if (!ident)
1051                 return INVALID_PRIVATE_NAME_ERRORTOK;
1052         }
1053         tokenData-&gt;ident = ident;
1054     } else
1055         tokenData-&gt;ident = nullptr;
1056 
<a name="9" id="anc9"></a><span class="line-modified">1057     if (UNLIKELY((remaining &lt; maxTokenLength) &amp;&amp; !lexerFlags.contains(LexerFlags::IgnoreReservedWords)) &amp;&amp; !isPrivateName) {</span>
1058         ASSERT(shouldCreateIdentifier);
1059         if (remaining &lt; maxTokenLength) {
1060             const HashTableValue* entry = JSC::mainTable.entry(*ident);
1061             ASSERT((remaining &lt; maxTokenLength) || !entry);
1062             if (!entry)
1063                 return IDENT;
1064             JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1065             return (token != RESERVED_IF_STRICT) || strictMode ? token : IDENT;
1066         }
1067         return IDENT;
1068     }
1069 
1070     return IDENT;
1071 }
1072 
<a name="10" id="anc10"></a><span class="line-modified">1073 template&lt;typename CharacterType&gt; template&lt;bool shouldCreateIdentifier&gt; JSTokenType Lexer&lt;CharacterType&gt;::parseIdentifierSlowCase(JSTokenData* tokenData, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
1074 {
1075     tokenData-&gt;escaped = true;
1076     auto identifierStart = currentSourcePtr();
1077     bool bufferRequired = false;
1078 
1079     while (true) {
1080         if (LIKELY(isIdentPart(m_current))) {
1081             shift();
1082             continue;
1083         }
1084         if (LIKELY(m_current != &#39;\\&#39;))
1085             break;
1086 
1087         // \uXXXX unicode characters.
1088         bufferRequired = true;
1089         if (identifierStart != currentSourcePtr())
1090             m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1091         shift();
1092         if (UNLIKELY(m_current != &#39;u&#39;))
1093             return atEnd() ? UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK : INVALID_IDENTIFIER_ESCAPE_ERRORTOK;
1094         shift();
1095         auto character = parseUnicodeEscape();
1096         if (UNLIKELY(!character.isValid()))
1097             return character.isIncomplete() ? UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK : INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK;
1098         if (UNLIKELY(m_buffer16.size() ? !isIdentPart(character.value()) : !isIdentStart(character.value())))
1099             return INVALID_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK;
1100         if (shouldCreateIdentifier)
1101             recordUnicodeCodePoint(character.value());
1102         identifierStart = currentSourcePtr();
1103     }
1104 
1105     int identifierLength;
1106     const Identifier* ident = nullptr;
1107     if (shouldCreateIdentifier) {
1108         if (!bufferRequired) {
1109             identifierLength = currentSourcePtr() - identifierStart;
1110             ident = makeIdentifier(identifierStart, identifierLength);
1111         } else {
1112             if (identifierStart != currentSourcePtr())
1113                 m_buffer16.append(identifierStart, currentSourcePtr() - identifierStart);
1114             ident = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1115         }
1116 
1117         tokenData-&gt;ident = ident;
1118     } else
1119         tokenData-&gt;ident = nullptr;
1120 
1121     m_buffer16.shrink(0);
1122 
<a name="11" id="anc11"></a><span class="line-modified">1123     if (LIKELY(!lexerFlags.contains(LexerFlags::IgnoreReservedWords))) {</span>
1124         ASSERT(shouldCreateIdentifier);
1125         const HashTableValue* entry = JSC::mainTable.entry(*ident);
1126         if (!entry)
1127             return IDENT;
1128         JSTokenType token = static_cast&lt;JSTokenType&gt;(entry-&gt;lexerValue());
1129         if ((token != RESERVED_IF_STRICT) || strictMode)
1130             return bufferRequired ? UNEXPECTED_ESCAPE_ERRORTOK : token;
1131     }
1132 
1133     return IDENT;
1134 }
1135 
1136 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(LChar character)
1137 {
1138     return character &lt; 0xE;
1139 }
1140 
1141 static ALWAYS_INLINE bool characterRequiresParseStringSlowCase(UChar character)
1142 {
1143     return character &lt; 0xE || !isLatin1(character);
1144 }
1145 
1146 template &lt;typename T&gt;
1147 template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseString(JSTokenData* tokenData, bool strictMode)
1148 {
1149     int startingOffset = currentOffset();
1150     int startingLineStartOffset = currentLineStartOffset();
1151     int startingLineNumber = lineNumber();
1152     T stringQuoteCharacter = m_current;
1153     shift();
1154 
1155     const T* stringStart = currentSourcePtr();
1156 
1157     while (m_current != stringQuoteCharacter) {
1158         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1159             if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings)
1160                 append8(stringStart, currentSourcePtr() - stringStart);
1161             shift();
1162 
1163             LChar escape = singleEscape(m_current);
1164 
1165             // Most common escape sequences first.
1166             if (escape) {
1167                 if (shouldBuildStrings)
1168                     record8(escape);
1169                 shift();
1170             } else if (UNLIKELY(isLineTerminator(m_current)))
1171                 shiftLineTerminator();
1172             else if (m_current == &#39;x&#39;) {
1173                 shift();
1174                 if (!isASCIIHexDigit(m_current) || !isASCIIHexDigit(peek(1))) {
1175                     m_lexErrorMessage = &quot;\\x can only be followed by a hex character sequence&quot;_s;
1176                     return (atEnd() || (isASCIIHexDigit(m_current) &amp;&amp; (m_code + 1 == m_codeEnd))) ? StringUnterminated : StringCannotBeParsed;
1177                 }
1178                 T prev = m_current;
1179                 shift();
1180                 if (shouldBuildStrings)
1181                     record8(convertHex(prev, m_current));
1182                 shift();
1183             } else {
1184                 setOffset(startingOffset, startingLineStartOffset);
1185                 setLineNumber(startingLineNumber);
1186                 m_buffer8.shrink(0);
1187                 return parseStringSlowCase&lt;shouldBuildStrings&gt;(tokenData, strictMode);
1188             }
1189             stringStart = currentSourcePtr();
1190             continue;
1191         }
1192 
1193         if (UNLIKELY(characterRequiresParseStringSlowCase(m_current))) {
1194             setOffset(startingOffset, startingLineStartOffset);
1195             setLineNumber(startingLineNumber);
1196             m_buffer8.shrink(0);
1197             return parseStringSlowCase&lt;shouldBuildStrings&gt;(tokenData, strictMode);
1198         }
1199 
1200         shift();
1201     }
1202 
1203     if (currentSourcePtr() != stringStart &amp;&amp; shouldBuildStrings)
1204         append8(stringStart, currentSourcePtr() - stringStart);
1205     if (shouldBuildStrings) {
1206         tokenData-&gt;ident = makeIdentifier(m_buffer8.data(), m_buffer8.size());
1207         m_buffer8.shrink(0);
1208     } else
1209         tokenData-&gt;ident = 0;
1210 
1211     return StringParsedSuccessfully;
1212 }
1213 
1214 template &lt;typename T&gt;
1215 template &lt;bool shouldBuildStrings, LexerEscapeParseMode escapeParseMode&gt; ALWAYS_INLINE auto Lexer&lt;T&gt;::parseComplexEscape(bool strictMode, T stringQuoteCharacter) -&gt; StringParseResult
1216 {
1217     if (m_current == &#39;x&#39;) {
1218         shift();
1219         if (!isASCIIHexDigit(m_current) || !isASCIIHexDigit(peek(1))) {
1220             // For raw template literal syntax, we consume `NotEscapeSequence`.
1221             //
1222             // NotEscapeSequence ::
1223             //     x [lookahread not one of HexDigit]
1224             //     x HexDigit [lookahread not one of HexDigit]
1225             if (isASCIIHexDigit(m_current))
1226                 shift();
1227             ASSERT(!isASCIIHexDigit(m_current));
1228 
1229             m_lexErrorMessage = &quot;\\x can only be followed by a hex character sequence&quot;_s;
1230             return atEnd() ? StringUnterminated : StringCannotBeParsed;
1231         }
1232 
1233         T prev = m_current;
1234         shift();
1235         if (shouldBuildStrings)
1236             record16(convertHex(prev, m_current));
1237         shift();
1238 
1239         return StringParsedSuccessfully;
1240     }
1241 
1242     if (m_current == &#39;u&#39;) {
1243         shift();
1244 
1245         if (escapeParseMode == LexerEscapeParseMode::String &amp;&amp; m_current == stringQuoteCharacter) {
1246             if (shouldBuildStrings)
1247                 record16(&#39;u&#39;);
1248             return StringParsedSuccessfully;
1249         }
1250 
1251         auto character = parseUnicodeEscape();
1252         if (character.isValid()) {
1253             if (shouldBuildStrings)
1254                 recordUnicodeCodePoint(character.value());
1255             return StringParsedSuccessfully;
1256         }
1257 
1258         m_lexErrorMessage = &quot;\\u can only be followed by a Unicode character sequence&quot;_s;
1259         return atEnd() ? StringUnterminated : StringCannotBeParsed;
1260     }
1261 
1262     if (strictMode) {
1263         if (isASCIIDigit(m_current)) {
1264             // The only valid numeric escape in strict mode is &#39;\0&#39;, and this must not be followed by a decimal digit.
1265             int character1 = m_current;
1266             shift();
1267             if (character1 != &#39;0&#39; || isASCIIDigit(m_current)) {
1268                 // For raw template literal syntax, we consume `NotEscapeSequence`.
1269                 //
1270                 // NotEscapeSequence ::
1271                 //     0 DecimalDigit
1272                 //     DecimalDigit but not 0
1273                 if (character1 == &#39;0&#39;)
1274                     shift();
1275 
1276                 m_lexErrorMessage = &quot;The only valid numeric escape in strict mode is &#39;\\0&#39;&quot;_s;
1277                 return atEnd() ? StringUnterminated : StringCannotBeParsed;
1278             }
1279             if (shouldBuildStrings)
1280                 record16(0);
1281             return StringParsedSuccessfully;
1282         }
1283     } else {
1284         if (isASCIIOctalDigit(m_current)) {
1285             // Octal character sequences
1286             T character1 = m_current;
1287             shift();
1288             if (isASCIIOctalDigit(m_current)) {
1289                 // Two octal characters
1290                 T character2 = m_current;
1291                 shift();
1292                 if (character1 &gt;= &#39;0&#39; &amp;&amp; character1 &lt;= &#39;3&#39; &amp;&amp; isASCIIOctalDigit(m_current)) {
1293                     if (shouldBuildStrings)
1294                         record16((character1 - &#39;0&#39;) * 64 + (character2 - &#39;0&#39;) * 8 + m_current - &#39;0&#39;);
1295                     shift();
1296                 } else {
1297                     if (shouldBuildStrings)
1298                         record16((character1 - &#39;0&#39;) * 8 + character2 - &#39;0&#39;);
1299                 }
1300             } else {
1301                 if (shouldBuildStrings)
1302                     record16(character1 - &#39;0&#39;);
1303             }
1304             return StringParsedSuccessfully;
1305         }
1306     }
1307 
1308     if (!atEnd()) {
1309         if (shouldBuildStrings)
1310             record16(m_current);
1311         shift();
1312         return StringParsedSuccessfully;
1313     }
1314 
1315     m_lexErrorMessage = &quot;Unterminated string constant&quot;_s;
1316     return StringUnterminated;
1317 }
1318 
1319 template &lt;typename T&gt;
1320 template &lt;bool shouldBuildStrings&gt; auto Lexer&lt;T&gt;::parseStringSlowCase(JSTokenData* tokenData, bool strictMode) -&gt; StringParseResult
1321 {
1322     T stringQuoteCharacter = m_current;
1323     shift();
1324 
1325     const T* stringStart = currentSourcePtr();
1326 
1327     while (m_current != stringQuoteCharacter) {
1328         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1329             if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings)
1330                 append16(stringStart, currentSourcePtr() - stringStart);
1331             shift();
1332 
1333             LChar escape = singleEscape(m_current);
1334 
1335             // Most common escape sequences first
1336             if (escape) {
1337                 if (shouldBuildStrings)
1338                     record16(escape);
1339                 shift();
1340             } else if (UNLIKELY(isLineTerminator(m_current)))
1341                 shiftLineTerminator();
1342             else {
1343                 StringParseResult result = parseComplexEscape&lt;shouldBuildStrings, LexerEscapeParseMode::String&gt;(strictMode, stringQuoteCharacter);
1344                 if (result != StringParsedSuccessfully)
1345                     return result;
1346             }
1347 
1348             stringStart = currentSourcePtr();
1349             continue;
1350         }
1351         // Fast check for characters that require special handling.
1352         // Catches 0, \n, and \r as efficiently as possible, and lets through all common ASCII characters.
1353         static_assert(std::is_unsigned&lt;T&gt;::value, &quot;Lexer expects an unsigned character type&quot;);
1354         if (UNLIKELY(m_current &lt; 0xE)) {
1355             // New-line or end of input is not allowed
1356             if (atEnd() || m_current == &#39;\r&#39; || m_current == &#39;\n&#39;) {
1357                 m_lexErrorMessage = &quot;Unexpected EOF&quot;_s;
1358                 return atEnd() ? StringUnterminated : StringCannotBeParsed;
1359             }
1360             // Anything else is just a normal character
1361         }
1362         shift();
1363     }
1364 
1365     if (currentSourcePtr() != stringStart &amp;&amp; shouldBuildStrings)
1366         append16(stringStart, currentSourcePtr() - stringStart);
1367     if (shouldBuildStrings)
1368         tokenData-&gt;ident = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1369     else
1370         tokenData-&gt;ident = 0;
1371 
1372     m_buffer16.shrink(0);
1373     return StringParsedSuccessfully;
1374 }
1375 
1376 template &lt;typename T&gt;
1377 typename Lexer&lt;T&gt;::StringParseResult Lexer&lt;T&gt;::parseTemplateLiteral(JSTokenData* tokenData, RawStringsBuildMode rawStringsBuildMode)
1378 {
1379     bool parseCookedFailed = false;
1380     const T* stringStart = currentSourcePtr();
1381     const T* rawStringStart = currentSourcePtr();
1382 
1383     while (m_current != &#39;`&#39;) {
1384         if (UNLIKELY(m_current == &#39;\\&#39;)) {
1385             if (stringStart != currentSourcePtr())
1386                 append16(stringStart, currentSourcePtr() - stringStart);
1387             shift();
1388 
1389             LChar escape = singleEscape(m_current);
1390 
1391             // Most common escape sequences first.
1392             if (escape) {
1393                 record16(escape);
1394                 shift();
1395             } else if (UNLIKELY(isLineTerminator(m_current))) {
1396                 // Normalize &lt;CR&gt;, &lt;CR&gt;&lt;LF&gt; to &lt;LF&gt;.
1397                 if (m_current == &#39;\r&#39;) {
1398                     ASSERT_WITH_MESSAGE(rawStringStart != currentSourcePtr(), &quot;We should have at least shifted the escape.&quot;);
1399 
1400                     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings) {
1401                         m_bufferForRawTemplateString16.append(rawStringStart, currentSourcePtr() - rawStringStart);
1402                         m_bufferForRawTemplateString16.append(&#39;\n&#39;);
1403                     }
1404 
1405                     shiftLineTerminator();
1406                     rawStringStart = currentSourcePtr();
1407                 } else
1408                     shiftLineTerminator();
1409             } else {
1410                 bool strictMode = true;
1411                 StringParseResult result = parseComplexEscape&lt;true, LexerEscapeParseMode::Template&gt;(strictMode, &#39;`&#39;);
1412                 if (result != StringParsedSuccessfully) {
1413                     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings &amp;&amp; result == StringCannotBeParsed)
1414                         parseCookedFailed = true;
1415                     else
1416                         return result;
1417                 }
1418             }
1419 
1420             stringStart = currentSourcePtr();
1421             continue;
1422         }
1423 
1424         if (m_current == &#39;$&#39; &amp;&amp; peek(1) == &#39;{&#39;)
1425             break;
1426 
1427         // Fast check for characters that require special handling.
1428         // Catches 0, \n, \r, 0x2028, and 0x2029 as efficiently
1429         // as possible, and lets through all common ASCII characters.
1430         if (UNLIKELY(((static_cast&lt;unsigned&gt;(m_current) - 0xE) &amp; 0x2000))) {
1431             // End of input is not allowed.
1432             // Unlike String, line terminator is allowed.
1433             if (atEnd()) {
1434                 m_lexErrorMessage = &quot;Unexpected EOF&quot;_s;
1435                 return StringUnterminated;
1436             }
1437 
1438             if (isLineTerminator(m_current)) {
1439                 if (m_current == &#39;\r&#39;) {
1440                     // Normalize &lt;CR&gt;, &lt;CR&gt;&lt;LF&gt; to &lt;LF&gt;.
1441                     if (stringStart != currentSourcePtr())
1442                         append16(stringStart, currentSourcePtr() - stringStart);
1443                     if (rawStringStart != currentSourcePtr() &amp;&amp; rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1444                         m_bufferForRawTemplateString16.append(rawStringStart, currentSourcePtr() - rawStringStart);
1445 
1446                     record16(&#39;\n&#39;);
1447                     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1448                         m_bufferForRawTemplateString16.append(&#39;\n&#39;);
1449                     shiftLineTerminator();
1450                     stringStart = currentSourcePtr();
1451                     rawStringStart = currentSourcePtr();
1452                 } else
1453                     shiftLineTerminator();
1454                 continue;
1455             }
1456             // Anything else is just a normal character
1457         }
1458 
1459         shift();
1460     }
1461 
1462     bool isTail = m_current == &#39;`&#39;;
1463 
1464     if (currentSourcePtr() != stringStart)
1465         append16(stringStart, currentSourcePtr() - stringStart);
1466     if (rawStringStart != currentSourcePtr() &amp;&amp; rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1467         m_bufferForRawTemplateString16.append(rawStringStart, currentSourcePtr() - rawStringStart);
1468 
1469     if (!parseCookedFailed)
1470         tokenData-&gt;cooked = makeIdentifier(m_buffer16.data(), m_buffer16.size());
1471     else
1472         tokenData-&gt;cooked = nullptr;
1473 
1474     // Line terminator normalization (e.g. &lt;CR&gt; =&gt; &lt;LF&gt;) should be applied to both the raw and cooked representations.
1475     if (rawStringsBuildMode == RawStringsBuildMode::BuildRawStrings)
1476         tokenData-&gt;raw = makeIdentifier(m_bufferForRawTemplateString16.data(), m_bufferForRawTemplateString16.size());
1477     else
1478         tokenData-&gt;raw = nullptr;
1479 
1480     tokenData-&gt;isTail = isTail;
1481 
1482     m_buffer16.shrink(0);
1483     m_bufferForRawTemplateString16.shrink(0);
1484 
1485     if (isTail) {
1486         // Skip `
1487         shift();
1488     } else {
1489         // Skip $ and {
1490         shift();
1491         shift();
1492     }
1493 
1494     return StringParsedSuccessfully;
1495 }
1496 
1497 template &lt;typename T&gt;
1498 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseHex() -&gt; Optional&lt;NumberParseResult&gt;
1499 {
1500     ASSERT(isASCIIHexDigit(m_current));
1501 
1502     // Optimization: most hexadecimal values fit into 4 bytes.
1503     uint32_t hexValue = 0;
1504     int maximumDigits = 7;
1505 
1506     do {
1507         if (m_current == &#39;_&#39;) {
1508             if (UNLIKELY(!isASCIIHexDigit(peek(1))))
1509                 return WTF::nullopt;
1510 
1511             shift();
1512         }
1513 
1514         hexValue = (hexValue &lt;&lt; 4) + toASCIIHexValue(m_current);
1515         shift();
1516         --maximumDigits;
1517     } while (isASCIIHexDigitOrSeparator(m_current) &amp;&amp; maximumDigits &gt;= 0);
1518 
1519     if (LIKELY(maximumDigits &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
1520         return NumberParseResult { hexValue };
1521 
1522     // No more place in the hexValue buffer.
1523     // The values are shifted out and placed into the m_buffer8 vector.
1524     for (int i = 0; i &lt; 8; ++i) {
1525          int digit = hexValue &gt;&gt; 28;
1526          if (digit &lt; 10)
1527              record8(digit + &#39;0&#39;);
1528          else
1529              record8(digit - 10 + &#39;a&#39;);
1530          hexValue &lt;&lt;= 4;
1531     }
1532 
1533     while (isASCIIHexDigitOrSeparator(m_current)) {
1534         if (m_current == &#39;_&#39;) {
1535             if (UNLIKELY(!isASCIIHexDigit(peek(1))))
1536                 return WTF::nullopt;
1537 
1538             shift();
1539         }
1540 
1541         record8(m_current);
1542         shift();
1543     }
1544 
1545     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
1546         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };
1547 
1548     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 16) };
1549 }
1550 
1551 template &lt;typename T&gt;
1552 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseBinary() -&gt; Optional&lt;NumberParseResult&gt;
1553 {
1554     ASSERT(isASCIIBinaryDigit(m_current));
1555 
1556     // Optimization: most binary values fit into 4 bytes.
1557     uint32_t binaryValue = 0;
1558     const unsigned maximumDigits = 32;
1559     int digit = maximumDigits - 1;
1560     // Temporary buffer for the digits. Makes easier
1561     // to reconstruct the input characters when needed.
1562     LChar digits[maximumDigits];
1563 
1564     do {
1565         if (m_current == &#39;_&#39;) {
1566             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))
1567                 return WTF::nullopt;
1568 
1569             shift();
1570         }
1571 
1572         binaryValue = (binaryValue &lt;&lt; 1) + (m_current - &#39;0&#39;);
1573         digits[digit] = m_current;
1574         shift();
1575         --digit;
1576     } while (isASCIIBinaryDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);
1577 
1578     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
1579         return NumberParseResult { binaryValue };
1580 
1581     for (int i = maximumDigits - 1; i &gt; digit; --i)
1582         record8(digits[i]);
1583 
1584     while (isASCIIBinaryDigitOrSeparator(m_current)) {
1585         if (m_current == &#39;_&#39;) {
1586             if (UNLIKELY(!isASCIIBinaryDigit(peek(1))))
1587                 return WTF::nullopt;
1588 
1589             shift();
1590         }
1591 
1592         record8(m_current);
1593         shift();
1594     }
1595 
1596     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;))
1597         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };
1598 
1599     if (isASCIIDigit(m_current))
1600         return WTF::nullopt;
1601 
1602     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 2) };
1603 }
1604 
1605 template &lt;typename T&gt;
1606 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseOctal() -&gt; Optional&lt;NumberParseResult&gt;
1607 {
1608     ASSERT(isASCIIOctalDigit(m_current));
1609     ASSERT(!m_buffer8.size() || (m_buffer8.size() == 1 &amp;&amp; m_buffer8[0] == &#39;0&#39;));
1610     bool isLegacyLiteral = m_buffer8.size();
1611 
1612     // Optimization: most octal values fit into 4 bytes.
1613     uint32_t octalValue = 0;
1614     const unsigned maximumDigits = 10;
1615     int digit = maximumDigits - 1;
1616     // Temporary buffer for the digits. Makes easier
1617     // to reconstruct the input characters when needed.
1618     LChar digits[maximumDigits];
1619 
1620     do {
1621         if (m_current == &#39;_&#39;) {
1622             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))
1623                 return WTF::nullopt;
1624 
1625             shift();
1626         }
1627 
1628         octalValue = octalValue * 8 + (m_current - &#39;0&#39;);
1629         digits[digit] = m_current;
1630         shift();
1631         --digit;
1632     } while (isASCIIOctalDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);
1633 
1634     if (LIKELY(!isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0 &amp;&amp; m_current != &#39;n&#39;))
1635         return NumberParseResult { octalValue };
1636 
1637     for (int i = maximumDigits - 1; i &gt; digit; --i)
1638          record8(digits[i]);
1639 
1640     while (isASCIIOctalDigitOrSeparator(m_current)) {
1641         if (m_current == &#39;_&#39;) {
1642             if (UNLIKELY(!isASCIIOctalDigit(peek(1)) || isLegacyLiteral))
1643                 return WTF::nullopt;
1644 
1645             shift();
1646         }
1647 
1648         record8(m_current);
1649         shift();
1650     }
1651 
1652     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39;) &amp;&amp; !isLegacyLiteral)
1653         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };
1654 
1655     if (isASCIIDigit(m_current))
1656         return WTF::nullopt;
1657 
1658     return NumberParseResult { parseIntOverflow(m_buffer8.data(), m_buffer8.size(), 8) };
1659 }
1660 
1661 template &lt;typename T&gt;
1662 ALWAYS_INLINE auto Lexer&lt;T&gt;::parseDecimal() -&gt; Optional&lt;NumberParseResult&gt;
1663 {
1664     ASSERT(isASCIIDigit(m_current) || m_buffer8.size());
1665     bool isLegacyLiteral = m_buffer8.size() &amp;&amp; isASCIIDigitOrSeparator(m_current);
1666 
1667     // Optimization: most decimal values fit into 4 bytes.
1668     uint32_t decimalValue = 0;
1669 
1670     // Since parseOctal may be executed before parseDecimal,
1671     // the m_buffer8 may hold ascii digits.
1672     if (!m_buffer8.size()) {
1673         const unsigned maximumDigits = 10;
1674         int digit = maximumDigits - 1;
1675         // Temporary buffer for the digits. Makes easier
1676         // to reconstruct the input characters when needed.
1677         LChar digits[maximumDigits];
1678 
1679         do {
1680             if (m_current == &#39;_&#39;) {
1681                 if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))
1682                     return WTF::nullopt;
1683 
1684                 shift();
1685             }
1686 
1687             decimalValue = decimalValue * 10 + (m_current - &#39;0&#39;);
1688             digits[digit] = m_current;
1689             shift();
1690             --digit;
1691         } while (isASCIIDigitOrSeparator(m_current) &amp;&amp; digit &gt;= 0);
1692 
1693         if (digit &gt;= 0 &amp;&amp; m_current != &#39;.&#39; &amp;&amp; !isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; m_current != &#39;n&#39;)
1694             return NumberParseResult { decimalValue };
1695 
1696         for (int i = maximumDigits - 1; i &gt; digit; --i)
1697             record8(digits[i]);
1698     }
1699 
1700     while (isASCIIDigitOrSeparator(m_current)) {
1701         if (m_current == &#39;_&#39;) {
1702             if (UNLIKELY(!isASCIIDigit(peek(1)) || isLegacyLiteral))
1703                 return WTF::nullopt;
1704 
1705             shift();
1706         }
1707 
1708         record8(m_current);
1709         shift();
1710     }
1711 
1712     if (UNLIKELY(Options::useBigInt() &amp;&amp; m_current == &#39;n&#39; &amp;&amp; !isLegacyLiteral))
1713         return NumberParseResult { makeIdentifier(m_buffer8.data(), m_buffer8.size()) };
1714 
1715     return WTF::nullopt;
1716 }
1717 
1718 template &lt;typename T&gt;
1719 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterDecimalPoint()
1720 {
1721     ASSERT(isASCIIDigit(m_current));
1722     record8(&#39;.&#39;);
1723 
1724     do {
1725         if (m_current == &#39;_&#39;) {
1726             if (UNLIKELY(!isASCIIDigit(peek(1))))
1727                 return false;
1728 
1729             shift();
1730         }
1731 
1732         record8(m_current);
1733         shift();
1734     } while (isASCIIDigitOrSeparator(m_current));
1735 
1736     return true;
1737 }
1738 
1739 template &lt;typename T&gt;
1740 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseNumberAfterExponentIndicator()
1741 {
1742     record8(&#39;e&#39;);
1743     shift();
1744     if (m_current == &#39;+&#39; || m_current == &#39;-&#39;) {
1745         record8(m_current);
1746         shift();
1747     }
1748 
1749     if (!isASCIIDigit(m_current))
1750         return false;
1751 
1752     do {
1753         if (m_current == &#39;_&#39;) {
1754             if (UNLIKELY(!isASCIIDigit(peek(1))))
1755                 return false;
1756 
1757             shift();
1758         }
1759 
1760         record8(m_current);
1761         shift();
1762     } while (isASCIIDigitOrSeparator(m_current));
1763 
1764     return true;
1765 }
1766 
1767 template &lt;typename T&gt;
1768 ALWAYS_INLINE bool Lexer&lt;T&gt;::parseMultilineComment()
1769 {
1770     while (true) {
1771         while (UNLIKELY(m_current == &#39;*&#39;)) {
1772             shift();
1773             if (m_current == &#39;/&#39;) {
1774                 shift();
1775                 return true;
1776             }
1777         }
1778 
1779         if (atEnd())
1780             return false;
1781 
1782         if (isLineTerminator(m_current)) {
1783             shiftLineTerminator();
1784             m_hasLineTerminatorBeforeToken = true;
1785         } else
1786             shift();
1787     }
1788 }
1789 
1790 template &lt;typename T&gt;
1791 ALWAYS_INLINE void Lexer&lt;T&gt;::parseCommentDirective()
1792 {
1793     // sourceURL and sourceMappingURL directives.
1794     if (!consume(&quot;source&quot;))
1795         return;
1796 
1797     if (consume(&quot;URL=&quot;)) {
1798         m_sourceURLDirective = parseCommentDirectiveValue();
1799         return;
1800     }
1801 
1802     if (consume(&quot;MappingURL=&quot;)) {
1803         m_sourceMappingURLDirective = parseCommentDirectiveValue();
1804         return;
1805     }
1806 }
1807 
1808 template &lt;typename T&gt;
1809 ALWAYS_INLINE String Lexer&lt;T&gt;::parseCommentDirectiveValue()
1810 {
1811     skipWhitespace();
1812     const T* stringStart = currentSourcePtr();
1813     while (!isWhiteSpace(m_current) &amp;&amp; !isLineTerminator(m_current) &amp;&amp; m_current != &#39;&quot;&#39; &amp;&amp; m_current != &#39;\&#39;&#39; &amp;&amp; !atEnd())
1814         shift();
1815     const T* stringEnd = currentSourcePtr();
1816     skipWhitespace();
1817 
1818     if (!isLineTerminator(m_current) &amp;&amp; !atEnd())
1819         return String();
1820 
1821     append8(stringStart, stringEnd - stringStart);
1822     String result = String(m_buffer8.data(), m_buffer8.size());
1823     m_buffer8.shrink(0);
1824     return result;
1825 }
1826 
1827 template &lt;typename T&gt;
1828 template &lt;unsigned length&gt;
1829 ALWAYS_INLINE bool Lexer&lt;T&gt;::consume(const char (&amp;input)[length])
1830 {
1831     unsigned lengthToCheck = length - 1; // Ignore the ending NULL byte in the string literal.
1832 
1833     unsigned i = 0;
1834     for (; i &lt; lengthToCheck &amp;&amp; m_current == input[i]; i++)
1835         shift();
1836 
1837     return i == lengthToCheck;
1838 }
1839 
1840 template &lt;typename T&gt;
1841 bool Lexer&lt;T&gt;::nextTokenIsColon()
1842 {
1843     const T* code = m_code;
1844     while (code &lt; m_codeEnd &amp;&amp; (isWhiteSpace(*code) || isLineTerminator(*code)))
1845         code++;
1846 
1847     return code &lt; m_codeEnd &amp;&amp; *code == &#39;:&#39;;
1848 }
1849 
1850 template &lt;typename T&gt;
1851 void Lexer&lt;T&gt;::fillTokenInfo(JSToken* tokenRecord, JSTokenType token, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition)
1852 {
1853     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1854     tokenLocation-&gt;line = lineNumber;
1855     tokenLocation-&gt;endOffset = endOffset;
1856     tokenLocation-&gt;lineStartOffset = lineStartOffset;
1857     ASSERT(tokenLocation-&gt;endOffset &gt;= tokenLocation-&gt;lineStartOffset);
1858     tokenRecord-&gt;m_endPosition = endPosition;
1859     m_lastToken = token;
1860 }
1861 
1862 template &lt;typename T&gt;
<a name="12" id="anc12"></a><span class="line-modified">1863 JSTokenType Lexer&lt;T&gt;::lexWithoutClearingLineTerminator(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
1864 {
1865     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
1866     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
1867     m_lastTokenLocation = JSTokenLocation(tokenRecord-&gt;m_location);
1868 
1869     ASSERT(!m_error);
1870     ASSERT(m_buffer8.isEmpty());
1871     ASSERT(m_buffer16.isEmpty());
1872 
1873     JSTokenType token = ERRORTOK;
1874 
1875 start:
1876     skipWhitespace();
1877 
1878     tokenLocation-&gt;startOffset = currentOffset();
1879     ASSERT(currentOffset() &gt;= currentLineStartOffset());
1880     tokenRecord-&gt;m_startPosition = currentPosition();
1881 
1882     if (atEnd()) {
1883         token = EOFTOK;
1884         goto returnToken;
1885     }
1886 
1887     CharacterType type;
1888     if (LIKELY(isLatin1(m_current)))
1889         type = static_cast&lt;CharacterType&gt;(typesOfLatin1Characters[m_current]);
1890     else if (isNonLatin1IdentStart(m_current))
1891         type = CharacterIdentifierStart;
1892     else if (isLineTerminator(m_current))
1893         type = CharacterLineTerminator;
1894     else
1895         type = CharacterInvalid;
1896 
1897     switch (type) {
1898     case CharacterGreater:
1899         shift();
1900         if (m_current == &#39;&gt;&#39;) {
1901             shift();
1902             if (m_current == &#39;&gt;&#39;) {
1903                 shift();
1904                 if (m_current == &#39;=&#39;) {
1905                     shift();
1906                     token = URSHIFTEQUAL;
1907                     break;
1908                 }
1909                 token = URSHIFT;
1910                 break;
1911             }
1912             if (m_current == &#39;=&#39;) {
1913                 shift();
1914                 token = RSHIFTEQUAL;
1915                 break;
1916             }
1917             token = RSHIFT;
1918             break;
1919         }
1920         if (m_current == &#39;=&#39;) {
1921             shift();
1922             token = GE;
1923             break;
1924         }
1925         token = GT;
1926         break;
1927     case CharacterEqual: {
1928         if (peek(1) == &#39;&gt;&#39;) {
1929             token = ARROWFUNCTION;
1930             tokenData-&gt;line = lineNumber();
1931             tokenData-&gt;offset = currentOffset();
1932             tokenData-&gt;lineStartOffset = currentLineStartOffset();
1933             ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
1934             shift();
1935             shift();
1936             break;
1937         }
1938 
1939         shift();
1940         if (m_current == &#39;=&#39;) {
1941             shift();
1942             if (m_current == &#39;=&#39;) {
1943                 shift();
1944                 token = STREQ;
1945                 break;
1946             }
1947             token = EQEQ;
1948             break;
1949         }
1950         token = EQUAL;
1951         break;
1952     }
1953     case CharacterLess:
1954         shift();
1955         if (m_current == &#39;!&#39; &amp;&amp; peek(1) == &#39;-&#39; &amp;&amp; peek(2) == &#39;-&#39;) {
1956             if (m_scriptMode == JSParserScriptMode::Classic) {
1957                 // &lt;!-- marks the beginning of a line comment (for www usage)
1958                 goto inSingleLineComment;
1959             }
1960         }
1961         if (m_current == &#39;&lt;&#39;) {
1962             shift();
1963             if (m_current == &#39;=&#39;) {
1964                 shift();
1965                 token = LSHIFTEQUAL;
1966                 break;
1967             }
1968             token = LSHIFT;
1969             break;
1970         }
1971         if (m_current == &#39;=&#39;) {
1972             shift();
1973             token = LE;
1974             break;
1975         }
1976         token = LT;
1977         break;
1978     case CharacterExclamationMark:
1979         shift();
1980         if (m_current == &#39;=&#39;) {
1981             shift();
1982             if (m_current == &#39;=&#39;) {
1983                 shift();
1984                 token = STRNEQ;
1985                 break;
1986             }
1987             token = NE;
1988             break;
1989         }
1990         token = EXCLAMATION;
1991         break;
1992     case CharacterAdd:
1993         shift();
1994         if (m_current == &#39;+&#39;) {
1995             shift();
1996             token = (!m_hasLineTerminatorBeforeToken) ? PLUSPLUS : AUTOPLUSPLUS;
1997             break;
1998         }
1999         if (m_current == &#39;=&#39;) {
2000             shift();
2001             token = PLUSEQUAL;
2002             break;
2003         }
2004         token = PLUS;
2005         break;
2006     case CharacterSub:
2007         shift();
2008         if (m_current == &#39;-&#39;) {
2009             shift();
2010             if ((m_atLineStart || m_hasLineTerminatorBeforeToken) &amp;&amp; m_current == &#39;&gt;&#39;) {
2011                 if (m_scriptMode == JSParserScriptMode::Classic) {
2012                     shift();
2013                     goto inSingleLineComment;
2014                 }
2015             }
2016             token = (!m_hasLineTerminatorBeforeToken) ? MINUSMINUS : AUTOMINUSMINUS;
2017             break;
2018         }
2019         if (m_current == &#39;=&#39;) {
2020             shift();
2021             token = MINUSEQUAL;
2022             break;
2023         }
2024         token = MINUS;
2025         break;
2026     case CharacterMultiply:
2027         shift();
2028         if (m_current == &#39;=&#39;) {
2029             shift();
2030             token = MULTEQUAL;
2031             break;
2032         }
2033         if (m_current == &#39;*&#39;) {
2034             shift();
2035             if (m_current == &#39;=&#39;) {
2036                 shift();
2037                 token = POWEQUAL;
2038                 break;
2039             }
2040             token = POW;
2041             break;
2042         }
2043         token = TIMES;
2044         break;
2045     case CharacterSlash:
2046         shift();
2047         if (m_current == &#39;/&#39;) {
2048             shift();
2049             goto inSingleLineCommentCheckForDirectives;
2050         }
2051         if (m_current == &#39;*&#39;) {
2052             shift();
2053             if (parseMultilineComment())
2054                 goto start;
2055             m_lexErrorMessage = &quot;Multiline comment was not closed properly&quot;_s;
2056             token = UNTERMINATED_MULTILINE_COMMENT_ERRORTOK;
2057             goto returnError;
2058         }
2059         if (m_current == &#39;=&#39;) {
2060             shift();
2061             token = DIVEQUAL;
2062             break;
2063         }
2064         token = DIVIDE;
2065         break;
2066     case CharacterAnd:
2067         shift();
2068         if (m_current == &#39;&amp;&#39;) {
2069             shift();
2070             token = AND;
2071             break;
2072         }
2073         if (m_current == &#39;=&#39;) {
2074             shift();
2075             token = ANDEQUAL;
2076             break;
2077         }
2078         token = BITAND;
2079         break;
2080     case CharacterXor:
2081         shift();
2082         if (m_current == &#39;=&#39;) {
2083             shift();
2084             token = XOREQUAL;
2085             break;
2086         }
2087         token = BITXOR;
2088         break;
2089     case CharacterModulo:
2090         shift();
2091         if (m_current == &#39;=&#39;) {
2092             shift();
2093             token = MODEQUAL;
2094             break;
2095         }
2096         token = MOD;
2097         break;
2098     case CharacterOr:
2099         shift();
2100         if (m_current == &#39;=&#39;) {
2101             shift();
2102             token = OREQUAL;
2103             break;
2104         }
2105         if (m_current == &#39;|&#39;) {
2106             shift();
2107             token = OR;
2108             break;
2109         }
2110         token = BITOR;
2111         break;
2112     case CharacterOpenParen:
2113         token = OPENPAREN;
2114         tokenData-&gt;line = lineNumber();
2115         tokenData-&gt;offset = currentOffset();
2116         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2117         shift();
2118         break;
2119     case CharacterCloseParen:
2120         token = CLOSEPAREN;
2121         shift();
2122         break;
2123     case CharacterOpenBracket:
2124         token = OPENBRACKET;
2125         shift();
2126         break;
2127     case CharacterCloseBracket:
2128         token = CLOSEBRACKET;
2129         shift();
2130         break;
2131     case CharacterComma:
2132         token = COMMA;
2133         shift();
2134         break;
2135     case CharacterColon:
2136         token = COLON;
2137         shift();
2138         break;
2139     case CharacterQuestion:
2140         shift();
<a name="13" id="anc13"></a><span class="line-modified">2141         if (m_current == &#39;?&#39;) {</span>
<span class="line-modified">2142             shift();</span>
<span class="line-modified">2143             token = COALESCE;</span>
<span class="line-modified">2144             break;</span>
<span class="line-modified">2145         }</span>
<span class="line-modified">2146         if (m_current == &#39;.&#39; &amp;&amp; !isASCIIDigit(peek(1))) {</span>
<span class="line-modified">2147             shift();</span>
<span class="line-modified">2148             token = QUESTIONDOT;</span>
<span class="line-modified">2149             break;</span>


2150         }
2151         token = QUESTION;
2152         break;
2153     case CharacterTilde:
2154         token = TILDE;
2155         shift();
2156         break;
2157     case CharacterSemicolon:
2158         shift();
2159         token = SEMICOLON;
2160         break;
2161     case CharacterBackQuote:
2162         shift();
2163         token = BACKQUOTE;
2164         break;
2165     case CharacterOpenBrace:
2166         tokenData-&gt;line = lineNumber();
2167         tokenData-&gt;offset = currentOffset();
2168         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2169         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2170         shift();
2171         token = OPENBRACE;
2172         break;
2173     case CharacterCloseBrace:
2174         tokenData-&gt;line = lineNumber();
2175         tokenData-&gt;offset = currentOffset();
2176         tokenData-&gt;lineStartOffset = currentLineStartOffset();
2177         ASSERT(tokenData-&gt;offset &gt;= tokenData-&gt;lineStartOffset);
2178         shift();
2179         token = CLOSEBRACE;
2180         break;
2181     case CharacterDot:
2182         shift();
2183         if (!isASCIIDigit(m_current)) {
2184             if (UNLIKELY((m_current == &#39;.&#39;) &amp;&amp; (peek(1) == &#39;.&#39;))) {
2185                 shift();
2186                 shift();
2187                 token = DOTDOTDOT;
2188                 break;
2189             }
2190             token = DOT;
2191             break;
2192         }
2193         if (UNLIKELY(!parseNumberAfterDecimalPoint())) {
2194             m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;
2195             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2196             goto returnError;
2197         }
2198         token = DOUBLE;
2199         if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {
2200             m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;
2201             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2202             goto returnError;
2203         }
2204         size_t parsedLength;
2205         tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2206         if (token == INTEGER)
2207             token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2208 
2209         if (UNLIKELY(isIdentStart(m_current))) {
2210             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2211             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2212             goto returnError;
2213         }
2214         m_buffer8.shrink(0);
2215         break;
2216     case CharacterZero:
2217         shift();
2218         if (isASCIIAlphaCaselessEqual(m_current, &#39;x&#39;)) {
2219             if (UNLIKELY(!isASCIIHexDigit(peek(1)))) {
2220                 m_lexErrorMessage = &quot;No hexadecimal digits after &#39;0x&#39;&quot;_s;
2221                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2222                 goto returnError;
2223             }
2224 
2225             // Shift out the &#39;x&#39; prefix.
2226             shift();
2227 
2228             auto parseNumberResult = parseHex();
2229             if (!parseNumberResult)
2230                 tokenData-&gt;doubleValue = 0;
2231             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2232                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2233             else {
2234                 token = BIGINT;
2235                 shift();
2236                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2237                 tokenData-&gt;radix = 16;
2238             }
2239 
2240             if (UNLIKELY(isIdentStart(m_current))) {
2241                 m_lexErrorMessage = &quot;No space between hexadecimal literal and identifier&quot;_s;
2242                 token = UNTERMINATED_HEX_NUMBER_ERRORTOK;
2243                 goto returnError;
2244             }
2245             if (LIKELY(token != BIGINT))
2246                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2247             m_buffer8.shrink(0);
2248             break;
2249         }
2250         if (isASCIIAlphaCaselessEqual(m_current, &#39;b&#39;)) {
2251             if (UNLIKELY(!isASCIIBinaryDigit(peek(1)))) {
2252                 m_lexErrorMessage = &quot;No binary digits after &#39;0b&#39;&quot;_s;
2253                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2254                 goto returnError;
2255             }
2256 
2257             // Shift out the &#39;b&#39; prefix.
2258             shift();
2259 
2260             auto parseNumberResult = parseBinary();
2261             if (!parseNumberResult)
2262                 tokenData-&gt;doubleValue = 0;
2263             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2264                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2265             else {
2266                 token = BIGINT;
2267                 shift();
2268                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2269                 tokenData-&gt;radix = 2;
2270             }
2271 
2272             if (UNLIKELY(isIdentStart(m_current))) {
2273                 m_lexErrorMessage = &quot;No space between binary literal and identifier&quot;_s;
2274                 token = UNTERMINATED_BINARY_NUMBER_ERRORTOK;
2275                 goto returnError;
2276             }
2277             if (LIKELY(token != BIGINT))
2278                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2279             m_buffer8.shrink(0);
2280             break;
2281         }
2282 
2283         if (isASCIIAlphaCaselessEqual(m_current, &#39;o&#39;)) {
2284             if (UNLIKELY(!isASCIIOctalDigit(peek(1)))) {
2285                 m_lexErrorMessage = &quot;No octal digits after &#39;0o&#39;&quot;_s;
2286                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2287                 goto returnError;
2288             }
2289 
2290             // Shift out the &#39;o&#39; prefix.
2291             shift();
2292 
2293             auto parseNumberResult = parseOctal();
2294             if (!parseNumberResult)
2295                 tokenData-&gt;doubleValue = 0;
2296             else if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult))
2297                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2298             else {
2299                 token = BIGINT;
2300                 shift();
2301                 tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2302                 tokenData-&gt;radix = 8;
2303             }
2304 
2305             if (UNLIKELY(isIdentStart(m_current))) {
2306                 m_lexErrorMessage = &quot;No space between octal literal and identifier&quot;_s;
2307                 token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2308                 goto returnError;
2309             }
2310             if (LIKELY(token != BIGINT))
2311                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2312             m_buffer8.shrink(0);
2313             break;
2314         }
2315 
2316         if (UNLIKELY(m_current == &#39;_&#39;)) {
2317             m_lexErrorMessage = &quot;Numeric literals may not begin with 0_&quot;_s;
2318             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2319             goto returnError;
2320         }
2321 
2322         record8(&#39;0&#39;);
2323         if (UNLIKELY(strictMode &amp;&amp; isASCIIDigit(m_current))) {
2324             m_lexErrorMessage = &quot;Decimal integer literals with a leading zero are forbidden in strict mode&quot;_s;
2325             token = UNTERMINATED_OCTAL_NUMBER_ERRORTOK;
2326             goto returnError;
2327         }
2328         if (isASCIIOctalDigit(m_current)) {
2329             auto parseNumberResult = parseOctal();
2330             if (parseNumberResult &amp;&amp; WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {
2331                 tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2332                 token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2333             }
2334         }
2335         FALLTHROUGH;
2336     case CharacterNumber:
2337         if (LIKELY(token != INTEGER &amp;&amp; token != DOUBLE)) {
2338             auto parseNumberResult = parseDecimal();
2339             if (parseNumberResult) {
2340                 if (WTF::holds_alternative&lt;double&gt;(*parseNumberResult)) {
2341                     tokenData-&gt;doubleValue = WTF::get&lt;double&gt;(*parseNumberResult);
2342                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2343                 } else {
2344                     token = BIGINT;
2345                     shift();
2346                     tokenData-&gt;bigIntString = WTF::get&lt;const Identifier*&gt;(*parseNumberResult);
2347                     tokenData-&gt;radix = 10;
2348                 }
2349             } else {
2350                 token = INTEGER;
2351                 if (m_current == &#39;.&#39;) {
2352                     shift();
2353                     if (UNLIKELY(isASCIIDigit(m_current) &amp;&amp; !parseNumberAfterDecimalPoint())) {
2354                         m_lexErrorMessage = &quot;Non-number found after decimal point&quot;_s;
2355                         token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2356                         goto returnError;
2357                     }
2358                     token = DOUBLE;
2359                 }
2360                 if (UNLIKELY(isASCIIAlphaCaselessEqual(m_current, &#39;e&#39;) &amp;&amp; !parseNumberAfterExponentIndicator())) {
2361                     m_lexErrorMessage = &quot;Non-number found after exponent indicator&quot;_s;
2362                     token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2363                     goto returnError;
2364                 }
2365                 size_t parsedLength;
2366                 tokenData-&gt;doubleValue = parseDouble(m_buffer8.data(), m_buffer8.size(), parsedLength);
2367                 if (token == INTEGER)
2368                     token = tokenTypeForIntegerLikeToken(tokenData-&gt;doubleValue);
2369             }
2370         }
2371 
2372         if (UNLIKELY(isIdentStart(m_current))) {
2373             m_lexErrorMessage = &quot;No identifiers allowed directly after numeric literal&quot;_s;
2374             token = atEnd() ? UNTERMINATED_NUMERIC_LITERAL_ERRORTOK : INVALID_NUMERIC_LITERAL_ERRORTOK;
2375             goto returnError;
2376         }
2377         m_buffer8.shrink(0);
2378         break;
2379     case CharacterQuote: {
2380         StringParseResult result = StringCannotBeParsed;
<a name="14" id="anc14"></a><span class="line-modified">2381         if (lexerFlags.contains(LexerFlags::DontBuildStrings))</span>
2382             result = parseString&lt;false&gt;(tokenData, strictMode);
2383         else
2384             result = parseString&lt;true&gt;(tokenData, strictMode);
2385 
2386         if (UNLIKELY(result != StringParsedSuccessfully)) {
2387             token = result == StringUnterminated ? UNTERMINATED_STRING_LITERAL_ERRORTOK : INVALID_STRING_LITERAL_ERRORTOK;
2388             goto returnError;
2389         }
2390         shift();
2391         token = STRING;
2392         break;
2393         }
2394     case CharacterIdentifierStart:
2395         ASSERT(isIdentStart(m_current));
2396         FALLTHROUGH;
2397     case CharacterBackSlash:
2398         parseIdent:
<a name="15" id="anc15"></a><span class="line-modified">2399         if (lexerFlags.contains(LexerFlags::DontBuildKeywords))</span>
2400             token = parseIdentifier&lt;false&gt;(tokenData, lexerFlags, strictMode);
2401         else
2402             token = parseIdentifier&lt;true&gt;(tokenData, lexerFlags, strictMode);
2403         break;
2404     case CharacterLineTerminator:
2405         ASSERT(isLineTerminator(m_current));
2406         shiftLineTerminator();
2407         m_atLineStart = true;
2408         m_hasLineTerminatorBeforeToken = true;
2409         m_lineStart = m_code;
2410         goto start;
2411     case CharacterHash:
2412         // Hashbang is only permitted at the start of the source text.
2413         if (peek(1) == &#39;!&#39; &amp;&amp; !currentOffset()) {
2414             shift();
2415             shift();
2416             goto inSingleLineComment;
2417         }
2418         goto invalidCharacter;
2419     case CharacterPrivateIdentifierStart:
2420         if (m_parsingBuiltinFunction)
2421             goto parseIdent;
2422         goto invalidCharacter;
2423     case CharacterOtherIdentifierPart:
2424     case CharacterInvalid:
2425         goto invalidCharacter;
2426     default:
2427         RELEASE_ASSERT_NOT_REACHED();
2428         m_lexErrorMessage = &quot;Internal Error&quot;_s;
2429         token = ERRORTOK;
2430         goto returnError;
2431     }
2432 
2433     m_atLineStart = false;
2434     goto returnToken;
2435 
2436 inSingleLineCommentCheckForDirectives:
2437     // Script comment directives like &quot;//# sourceURL=test.js&quot;.
2438     if (UNLIKELY((m_current == &#39;#&#39; || m_current == &#39;@&#39;) &amp;&amp; isWhiteSpace(peek(1)))) {
2439         shift();
2440         shift();
2441         parseCommentDirective();
2442     }
2443     // Fall through to complete single line comment parsing.
2444 
2445 inSingleLineComment:
2446     {
2447         auto lineNumber = m_lineNumber;
2448         auto endOffset = currentOffset();
2449         auto lineStartOffset = currentLineStartOffset();
2450         auto endPosition = currentPosition();
2451 
2452         while (!isLineTerminator(m_current)) {
2453             if (atEnd()) {
2454                 token = EOFTOK;
2455                 fillTokenInfo(tokenRecord, token, lineNumber, endOffset, lineStartOffset, endPosition);
2456                 return token;
2457             }
2458             shift();
2459         }
2460         shiftLineTerminator();
2461         m_atLineStart = true;
2462         m_hasLineTerminatorBeforeToken = true;
2463         m_lineStart = m_code;
2464         if (!lastTokenWasRestrKeyword())
2465             goto start;
2466 
2467         token = SEMICOLON;
2468         fillTokenInfo(tokenRecord, token, lineNumber, endOffset, lineStartOffset, endPosition);
2469         return token;
2470     }
2471 
2472 returnToken:
2473     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2474     return token;
2475 
2476 invalidCharacter:
2477     m_lexErrorMessage = invalidCharacterMessage();
2478     token = ERRORTOK;
2479     // Falls through to return error.
2480 
2481 returnError:
2482     m_error = true;
2483     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2484     RELEASE_ASSERT(token &amp; ErrorTokenFlag);
2485     return token;
2486 }
2487 
2488 template &lt;typename T&gt;
2489 static inline void orCharacter(UChar&amp;, UChar);
2490 
2491 template &lt;&gt;
2492 inline void orCharacter&lt;LChar&gt;(UChar&amp;, UChar) { }
2493 
2494 template &lt;&gt;
2495 inline void orCharacter&lt;UChar&gt;(UChar&amp; orAccumulator, UChar character)
2496 {
2497     orAccumulator |= character;
2498 }
2499 
2500 template &lt;typename T&gt;
2501 JSTokenType Lexer&lt;T&gt;::scanRegExp(JSToken* tokenRecord, UChar patternPrefix)
2502 {
2503     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
2504     ASSERT(m_buffer16.isEmpty());
2505 
2506     bool lastWasEscape = false;
2507     bool inBrackets = false;
2508     UChar charactersOredTogether = 0;
2509 
2510     if (patternPrefix) {
2511         ASSERT(!isLineTerminator(patternPrefix));
2512         ASSERT(patternPrefix != &#39;/&#39;);
2513         ASSERT(patternPrefix != &#39;[&#39;);
2514         record16(patternPrefix);
2515     }
2516 
2517     while (true) {
2518         if (isLineTerminator(m_current) || atEnd()) {
2519             m_buffer16.shrink(0);
2520             JSTokenType token = UNTERMINATED_REGEXP_LITERAL_ERRORTOK;
2521             fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2522             m_error = true;
2523             m_lexErrorMessage = makeString(&quot;Unterminated regular expression literal &#39;&quot;, getToken(*tokenRecord), &quot;&#39;&quot;);
2524             return token;
2525         }
2526 
2527         T prev = m_current;
2528 
2529         shift();
2530 
2531         if (prev == &#39;/&#39; &amp;&amp; !lastWasEscape &amp;&amp; !inBrackets)
2532             break;
2533 
2534         record16(prev);
2535         orCharacter&lt;T&gt;(charactersOredTogether, prev);
2536 
2537         if (lastWasEscape) {
2538             lastWasEscape = false;
2539             continue;
2540         }
2541 
2542         switch (prev) {
2543         case &#39;[&#39;:
2544             inBrackets = true;
2545             break;
2546         case &#39;]&#39;:
2547             inBrackets = false;
2548             break;
2549         case &#39;\\&#39;:
2550             lastWasEscape = true;
2551             break;
2552         }
2553     }
2554 
2555     tokenData-&gt;pattern = makeRightSizedIdentifier(m_buffer16.data(), m_buffer16.size(), charactersOredTogether);
2556 
2557     m_buffer16.shrink(0);
2558     charactersOredTogether = 0;
2559 
2560     while (isIdentPart(m_current)) {
2561         record16(m_current);
2562         orCharacter&lt;T&gt;(charactersOredTogether, m_current);
2563         shift();
2564     }
2565 
2566     tokenData-&gt;flags = makeRightSizedIdentifier(m_buffer16.data(), m_buffer16.size(), charactersOredTogether);
2567     m_buffer16.shrink(0);
2568 
2569     // Since RegExp always ends with /, m_atLineStart always becomes false.
2570     m_atLineStart = false;
2571 
2572     JSTokenType token = REGEXP;
2573     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2574     return token;
2575 }
2576 
2577 template &lt;typename T&gt;
2578 JSTokenType Lexer&lt;T&gt;::scanTemplateString(JSToken* tokenRecord, RawStringsBuildMode rawStringsBuildMode)
2579 {
2580     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
2581     ASSERT(!m_error);
2582     ASSERT(m_buffer16.isEmpty());
2583 
2584     // Leading backquote ` (for template head) or closing brace } (for template trailing) are already shifted in the previous token scan.
2585     // So in this re-scan phase, shift() is not needed here.
2586     StringParseResult result = parseTemplateLiteral(tokenData, rawStringsBuildMode);
2587     JSTokenType token = ERRORTOK;
2588     if (UNLIKELY(result != StringParsedSuccessfully)) {
2589         token = result == StringUnterminated ? UNTERMINATED_TEMPLATE_LITERAL_ERRORTOK : INVALID_TEMPLATE_LITERAL_ERRORTOK;
2590         m_error = true;
2591     } else
2592         token = TEMPLATE;
2593 
2594     // Since TemplateString always ends with ` or }, m_atLineStart always becomes false.
2595     m_atLineStart = false;
2596     fillTokenInfo(tokenRecord, token, m_lineNumber, currentOffset(), currentLineStartOffset(), currentPosition());
2597     return token;
2598 }
2599 
2600 template &lt;typename T&gt;
2601 void Lexer&lt;T&gt;::clear()
2602 {
2603     m_arena = 0;
2604 
2605     Vector&lt;LChar&gt; newBuffer8;
2606     m_buffer8.swap(newBuffer8);
2607 
2608     Vector&lt;UChar&gt; newBuffer16;
2609     m_buffer16.swap(newBuffer16);
2610 
2611     Vector&lt;UChar&gt; newBufferForRawTemplateString16;
2612     m_bufferForRawTemplateString16.swap(newBufferForRawTemplateString16);
2613 
2614     m_isReparsingFunction = false;
2615 }
2616 
2617 // Instantiate the two flavors of Lexer we need instead of putting most of this file in Lexer.h
2618 template class Lexer&lt;LChar&gt;;
2619 template class Lexer&lt;UChar&gt;;
2620 
2621 } // namespace JSC
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
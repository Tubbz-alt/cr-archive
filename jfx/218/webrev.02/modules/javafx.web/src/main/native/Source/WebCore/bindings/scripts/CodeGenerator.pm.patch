diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm b/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/CodeGenerator.pm
@@ -41,10 +41,11 @@
 my $preprocessor;
 my $idlAttributes;
 my $writeDependencies = 0;
 my $defines = "";
 my $targetIdlFilePath = "";
+my $supplementalDependencies;
 
 my $codeGenerator = 0;
 
 my $verbose = 0;
 
@@ -145,10 +146,11 @@
     $preprocessor = shift;
     $writeDependencies = shift;
     $verbose = shift;
     $targetIdlFilePath = shift;
     $idlAttributes = shift;
+    $supplementalDependencies = shift;
 
     bless($reference, $object);
     return $reference;
 }
 
@@ -156,10 +158,12 @@
 {
     my $object = shift;
     $useDocument = shift;
     $defines = shift;
 
+    $object->ProcessSupplementalDependencies($useDocument);
+
     my $ifaceName = "CodeGenerator" . $useGenerator;
     require $ifaceName . ".pm";
 
     foreach my $dictionary (@{$useDocument->dictionaries}) {
         if ($dictionary->extendedAttributes->{"ImplementedAs"}) {
@@ -241,10 +245,138 @@
     }
 
     die "Processing document " . $useDocument->fileName . " did not generate anything"
 }
 
+sub ProcessSupplementalDependencies
+{
+    my ($object, $targetDocument) = @_;
+    my $targetFileName = fileparse($targetDocument->fileName);
+    my $targetInterfaceName = fileparse($targetFileName, ".idl");
+
+    if (!$supplementalDependencies) {
+        return;
+    }
+
+    foreach my $idlFile (@{$supplementalDependencies->{$targetFileName}}) {
+        next if fileparse($idlFile) eq $targetFileName;
+
+        my $interfaceName = fileparse($idlFile, ".idl");
+        my $parser = IDLParser->new(!$verbose);
+        my $document = $parser->Parse($idlFile, $defines, $preprocessor, $idlAttributes);
+
+        foreach my $interface (@{$document->interfaces}) {
+            next unless !$interface->isPartial || $interface->type->name eq $targetInterfaceName;
+
+            my $targetDataNode;
+            my @targetGlobalContexts;
+            foreach my $interface (@{$targetDocument->interfaces}) {
+                if ($interface->type->name eq $targetInterfaceName) {
+                    $targetDataNode = $interface;
+                    my $exposedAttribute = $targetDataNode->extendedAttributes->{"Exposed"} || "Window";
+                    $exposedAttribute = substr($exposedAttribute, 1, -1) if substr($exposedAttribute, 0, 1) eq "(";
+                    @targetGlobalContexts = split(",", $exposedAttribute);
+                    last;
+                }
+            }
+            die "Not found an interface ${targetInterfaceName} in ${targetInterfaceName}.idl." unless defined $targetDataNode;
+
+            # Support for attributes of partial interfaces.
+            foreach my $attribute (@{$interface->attributes}) {
+                next unless shouldPropertyBeExposed($attribute, \@targetGlobalContexts);
+
+                # Record that this attribute is implemented by $interfaceName.
+                $attribute->extendedAttributes->{"ImplementedBy"} = $interfaceName if $interface->isPartial && !$attribute->extendedAttributes->{Reflect};
+
+                # Add interface-wide extended attributes to each attribute.
+                foreach my $extendedAttributeName (keys %{$interface->extendedAttributes}) {
+                    $attribute->extendedAttributes->{$extendedAttributeName} = $interface->extendedAttributes->{$extendedAttributeName};
+                }
+                push(@{$targetDataNode->attributes}, $attribute);
+            }
+
+            # Support for methods of partial interfaces.
+            foreach my $operation (@{$interface->operations}) {
+                next unless shouldPropertyBeExposed($operation, \@targetGlobalContexts);
+
+                # Record that this method is implemented by $interfaceName.
+                $operation->extendedAttributes->{"ImplementedBy"} = $interfaceName if $interface->isPartial;
+
+                # Add interface-wide extended attributes to each method.
+                foreach my $extendedAttributeName (keys %{$interface->extendedAttributes}) {
+                    $operation->extendedAttributes->{$extendedAttributeName} = $interface->extendedAttributes->{$extendedAttributeName};
+                }
+                push(@{$targetDataNode->operations}, $operation);
+            }
+
+            # Support for constants of partial interfaces.
+            foreach my $constant (@{$interface->constants}) {
+                next unless shouldPropertyBeExposed($constant, \@targetGlobalContexts);
+
+                # Record that this constant is implemented by $interfaceName.
+                $constant->extendedAttributes->{"ImplementedBy"} = $interfaceName if $interface->isPartial;
+
+                # Add interface-wide extended attributes to each constant.
+                foreach my $extendedAttributeName (keys %{$interface->extendedAttributes}) {
+                    $constant->extendedAttributes->{$extendedAttributeName} = $interface->extendedAttributes->{$extendedAttributeName};
+                }
+                push(@{$targetDataNode->constants}, $constant);
+            }
+        }
+
+        foreach my $dictionary (@{$document->dictionaries}) {
+            next unless $dictionary->isPartial && $dictionary->type->name eq $targetInterfaceName;
+
+            my $targetDataNode;
+            my @targetGlobalContexts;
+            foreach my $dictionary (@{$targetDocument->dictionaries}) {
+                if ($dictionary->type->name eq $targetInterfaceName) {
+                    $targetDataNode = $dictionary;
+                    my $exposedAttribute = $targetDataNode->extendedAttributes->{"Exposed"} || "Window";
+                    $exposedAttribute = substr($exposedAttribute, 1, -1) if substr($exposedAttribute, 0, 1) eq "(";
+                    @targetGlobalContexts = split(",", $exposedAttribute);
+                    last;
+                }
+            }
+            die "Could not find dictionary ${targetInterfaceName} in ${targetInterfaceName}.idl." unless defined $targetDataNode;
+
+            # Support for members of partial dictionaries
+            foreach my $member (@{$dictionary->members}) {
+                next unless shouldPropertyBeExposed($member, \@targetGlobalContexts);
+
+                # Record that this member is implemented by $interfaceName.
+                $member->extendedAttributes->{"ImplementedBy"} = $interfaceName;
+
+                # Add interface-wide extended attributes to each member.
+                foreach my $extendedAttributeName (keys %{$dictionary->extendedAttributes}) {
+                    $member->extendedAttributes->{$extendedAttributeName} = $dictionary->extendedAttributes->{$extendedAttributeName};
+                }
+                push(@{$targetDataNode->members}, $member);
+            }
+        }
+    }
+}
+
+# Attributes / Operations / Constants of supplemental interfaces can have an [Exposed=XX] attribute which restricts
+# on which global contexts they should be exposed.
+sub shouldPropertyBeExposed
+{
+    my ($context, $targetGlobalContexts) = @_;
+
+    my $exposed = $context->extendedAttributes->{Exposed};
+
+    return 1 unless $exposed;
+
+    $exposed = substr($exposed, 1, -1) if substr($exposed, 0, 1) eq "(";
+    my @sourceGlobalContexts = split(",", $exposed);
+
+    for my $targetGlobalContext (@$targetGlobalContexts) {
+        return 1 if grep(/^$targetGlobalContext$/, @sourceGlobalContexts);
+    }
+    return 0;
+}
+
 sub FileNamePrefix
 {
     my $object = shift;
 
     my $ifaceName = "CodeGenerator" . $useGenerator;
@@ -551,10 +683,12 @@
     if ($fileContents =~ /\bdictionary\s+$name/gs) {
         # Parse the IDL.
         my $parser = IDLParser->new(1);
         my $document = $parser->Parse($filename, $defines, $preprocessor, $idlAttributes);
 
+        $object->ProcessSupplementalDependencies($document);
+
         foreach my $dictionary (@{$document->dictionaries}) {
             next unless $dictionary->type->name eq $name;
 
             $cachedExternalDictionaries->{$name} = $dictionary;
             my $implementedAs = $dictionary->extendedAttributes->{ImplementedAs};
@@ -710,10 +844,12 @@
     $ret =~ s/Xml/XML/ if $ret =~ /^Xml[^a-z]/;
     $ret =~ s/Svg/SVG/ if $ret =~ /^Svg/;
     $ret =~ s/Srgb/SRGB/ if $ret =~ /^Srgb/;
     $ret =~ s/Cenc/cenc/ if $ret =~ /^Cenc/;
     $ret =~ s/Cbcs/cbcs/ if $ret =~ /^Cbcs/;
+    $ret =~ s/Pq/PQ/ if $ret =~ /^Pq$/;
+    $ret =~ s/Hlg/HLG/ if $ret =~ /^Hlg/;
 
     return $ret;
 }
 
 # Lowercase the first letter while respecting WebKit style guidelines.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/InsertListCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006, 2010 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InsertListCommand.h&quot;
 28 
 29 #include &quot;Editing.h&quot;
 30 #include &quot;ElementTraversal.h&quot;
 31 #include &quot;HTMLBRElement.h&quot;
 32 #include &quot;HTMLLIElement.h&quot;
 33 #include &quot;HTMLNames.h&quot;
 34 #include &quot;HTMLUListElement.h&quot;
 35 #include &quot;Range.h&quot;
 36 #include &quot;VisibleUnits.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 using namespace HTMLNames;
 41 
 42 static Node* enclosingListChild(Node* node, Node* listNode)
 43 {
 44     Node* listChild = enclosingListChild(node);
 45     while (listChild &amp;&amp; enclosingList(listChild) != listNode)
 46         listChild = enclosingListChild(listChild-&gt;parentNode());
 47     return listChild;
 48 }
 49 
 50 RefPtr&lt;HTMLElement&gt; InsertListCommand::insertList(Document&amp; document, Type type)
 51 {
 52     RefPtr&lt;InsertListCommand&gt; insertCommand = create(document, type);
 53     insertCommand-&gt;apply();
 54     return insertCommand-&gt;m_listElement;
 55 }
 56 
<a name="1" id="anc1"></a><span class="line-modified"> 57 HTMLElement* InsertListCommand::fixOrphanedListChild(Node&amp; node)</span>
 58 {
 59     auto listElement = HTMLUListElement::create(document());
 60     insertNodeBefore(listElement.copyRef(), node);
<a name="2" id="anc2"></a><span class="line-added"> 61     if (!listElement-&gt;hasEditableStyle())</span>
<span class="line-added"> 62         return nullptr;</span>
<span class="line-added"> 63 </span>
 64     removeNode(node);
 65     appendNode(node, listElement.copyRef());
 66     m_listElement = WTFMove(listElement);
<a name="3" id="anc3"></a><span class="line-modified"> 67     return m_listElement.get();</span>
 68 }
 69 
 70 Ref&lt;HTMLElement&gt; InsertListCommand::mergeWithNeighboringLists(HTMLElement&amp; list)
 71 {
 72     Ref&lt;HTMLElement&gt; protectedList = list;
 73     Element* previousList = list.previousElementSibling();
 74     if (canMergeLists(previousList, &amp;list))
 75         mergeIdenticalElements(*previousList, list);
 76 
 77     Element* sibling = ElementTraversal::nextSibling(list);
 78     if (!is&lt;HTMLElement&gt;(sibling))
 79         return protectedList;
 80 
 81     Ref&lt;HTMLElement&gt; nextList = downcast&lt;HTMLElement&gt;(*sibling);
 82     if (canMergeLists(&amp;list, nextList.ptr())) {
 83         mergeIdenticalElements(list, nextList);
 84         return nextList;
 85     }
 86     return protectedList;
 87 }
 88 
 89 bool InsertListCommand::selectionHasListOfType(const VisibleSelection&amp; selection, const QualifiedName&amp; listTag)
 90 {
 91     VisiblePosition start = selection.visibleStart();
 92 
 93     if (!enclosingList(start.deepEquivalent().deprecatedNode()))
 94         return false;
 95 
 96     VisiblePosition end = startOfParagraph(selection.visibleEnd());
 97     while (start.isNotNull() &amp;&amp; start != end) {
 98         Element* listNode = enclosingList(start.deepEquivalent().deprecatedNode());
 99         if (!listNode || !listNode-&gt;hasTagName(listTag))
100             return false;
101         start = startOfNextParagraph(start);
102     }
103 
104     return true;
105 }
106 
107 InsertListCommand::InsertListCommand(Document&amp; document, Type type)
108     : CompositeEditCommand(document)
109     , m_type(type)
110 {
111 }
112 
113 void InsertListCommand::doApply()
114 {
115     if (endingSelection().isNoneOrOrphaned() || !endingSelection().isContentRichlyEditable())
116         return;
117 
118     VisiblePosition visibleEnd = endingSelection().visibleEnd();
119     VisiblePosition visibleStart = endingSelection().visibleStart();
120     // When a selection ends at the start of a paragraph, we rarely paint
121     // the selection gap before that paragraph, because there often is no gap.
122     // In a case like this, it&#39;s not obvious to the user that the selection
123     // ends &quot;inside&quot; that paragraph, so it would be confusing if InsertUn{Ordered}List
124     // operated on that paragraph.
125     // FIXME: We paint the gap before some paragraphs that are indented with left
126     // margin/padding, but not others.  We should make the gap painting more consistent and
127     // then use a left margin/padding rule here.
128     if (visibleEnd != visibleStart &amp;&amp; isStartOfParagraph(visibleEnd, CanSkipOverEditingBoundary)) {
129         setEndingSelection(VisibleSelection(visibleStart, visibleEnd.previous(CannotCrossEditingBoundary), endingSelection().isDirectional()));
130         if (!endingSelection().rootEditableElement())
131             return;
132     }
133 
134     auto&amp; listTag = (m_type == Type::OrderedList) ? olTag : ulTag;
135     if (endingSelection().isRange()) {
136         VisibleSelection selection = selectionForParagraphIteration(endingSelection());
137         ASSERT(selection.isRange());
138         VisiblePosition startOfSelection = selection.visibleStart();
139         VisiblePosition endOfSelection = selection.visibleEnd();
140         VisiblePosition startOfLastParagraph = startOfParagraph(endOfSelection, CanSkipOverEditingBoundary);
141 
142         if (startOfParagraph(startOfSelection, CanSkipOverEditingBoundary) != startOfLastParagraph) {
143             bool forceCreateList = !selectionHasListOfType(selection, listTag);
144 
145             RefPtr&lt;Range&gt; currentSelection = endingSelection().firstRange();
146             VisiblePosition startOfCurrentParagraph = startOfSelection;
147             while (!inSameParagraph(startOfCurrentParagraph, startOfLastParagraph, CanCrossEditingBoundary)) {
148                 // doApply() may operate on and remove the last paragraph of the selection from the document
149                 // if it&#39;s in the same list item as startOfCurrentParagraph.  Return early to avoid an
150                 // infinite loop and because there is no more work to be done.
151                 // FIXME(&lt;rdar://problem/5983974&gt;): The endingSelection() may be incorrect here.  Compute
152                 // the new location of endOfSelection and use it as the end of the new selection.
153                 if (!startOfLastParagraph.deepEquivalent().anchorNode()-&gt;isConnected())
154                     return;
155                 setEndingSelection(startOfCurrentParagraph);
156 
157                 // Save and restore endOfSelection and startOfLastParagraph when necessary
158                 // since moveParagraph and movePragraphWithClones can remove nodes.
159                 // FIXME: This is an inefficient way to keep selection alive because indexForVisiblePosition walks from
160                 // the beginning of the document to the endOfSelection everytime this code is executed.
161                 // But not using index is hard because there are so many ways we can lose selection inside doApplyForSingleParagraph.
162                 RefPtr&lt;ContainerNode&gt; scope;
163                 int indexForEndOfSelection = indexForVisiblePosition(endOfSelection, scope);
164                 doApplyForSingleParagraph(forceCreateList, listTag, currentSelection.get());
165                 if (endOfSelection.isNull() || endOfSelection.isOrphan() || startOfLastParagraph.isNull() || startOfLastParagraph.isOrphan()) {
166                     endOfSelection = visiblePositionForIndex(indexForEndOfSelection, scope.get());
167                     // If endOfSelection is null, then some contents have been deleted from the document.
168                     // This should never happen and if it did, exit early immediately because we&#39;ve lost the loop invariant.
169                     ASSERT(endOfSelection.isNotNull());
170                     if (endOfSelection.isNull())
171                         return;
172                     startOfLastParagraph = startOfParagraph(endOfSelection, CanSkipOverEditingBoundary);
173                 }
174 
175                 // Fetch the start of the selection after moving the first paragraph,
176                 // because moving the paragraph will invalidate the original start.
177                 // We&#39;ll use the new start to restore the original selection after
178                 // we modified all selected paragraphs.
179                 if (startOfCurrentParagraph == startOfSelection)
180                     startOfSelection = endingSelection().visibleStart();
181 
182                 startOfCurrentParagraph = startOfNextParagraph(endingSelection().visibleStart());
183             }
184             setEndingSelection(endOfSelection);
185             doApplyForSingleParagraph(forceCreateList, listTag, currentSelection.get());
186             // Fetch the end of the selection, for the reason mentioned above.
187             endOfSelection = endingSelection().visibleEnd();
188             setEndingSelection(VisibleSelection(startOfSelection, endOfSelection, endingSelection().isDirectional()));
189             return;
190         }
191     }
192 
193     doApplyForSingleParagraph(false, listTag, endingSelection().firstRange().get());
194 }
195 
196 EditAction InsertListCommand::editingAction() const
197 {
198     return m_type == Type::OrderedList ? EditAction::InsertOrderedList : EditAction::InsertUnorderedList;
199 }
200 
201 void InsertListCommand::doApplyForSingleParagraph(bool forceCreateList, const HTMLQualifiedName&amp; listTag, Range* currentSelection)
202 {
203     // FIXME: This will produce unexpected results for a selection that starts just before a
204     // table and ends inside the first cell, selectionForParagraphIteration should probably
205     // be renamed and deployed inside setEndingSelection().
206     Node* selectionNode = endingSelection().start().deprecatedNode();
207     Node* listChildNode = enclosingListChild(selectionNode);
208     bool switchListType = false;
209     if (listChildNode) {
210         // Remove the list chlild.
211         RefPtr&lt;HTMLElement&gt; listNode = enclosingList(listChildNode);
<a name="4" id="anc4"></a><span class="line-modified">212         if (!listNode) {</span>
<span class="line-modified">213             RefPtr&lt;HTMLElement&gt; listElement = fixOrphanedListChild(*listChildNode);</span>
<span class="line-added">214             if (!listElement)</span>
<span class="line-added">215                 return;</span>
<span class="line-added">216 </span>
<span class="line-added">217             listNode = mergeWithNeighboringLists(*listElement);</span>
<span class="line-added">218         }</span>
219 
220         if (!listNode-&gt;hasTagName(listTag)) {
221             // listChildNode will be removed from the list and a list of type m_type will be created.
222             switchListType = true;
223         }
224 
225         // If the list is of the desired type, and we are not removing the list, then exit early.
226         if (!switchListType &amp;&amp; forceCreateList)
227             return;
228 
229         // If the entire list is selected, then convert the whole list.
230         if (switchListType &amp;&amp; isNodeVisiblyContainedWithin(*listNode, *currentSelection)) {
231             bool rangeStartIsInList = visiblePositionBeforeNode(*listNode) == currentSelection-&gt;startPosition();
232             bool rangeEndIsInList = visiblePositionAfterNode(*listNode) == currentSelection-&gt;endPosition();
233 
234             RefPtr&lt;HTMLElement&gt; newList = createHTMLElement(document(), listTag);
235             insertNodeBefore(*newList, *listNode);
<a name="5" id="anc5"></a><span class="line-added">236             if (!newList-&gt;hasEditableStyle())</span>
<span class="line-added">237                 return;</span>
238 
239             auto* firstChildInList = enclosingListChild(VisiblePosition(firstPositionInNode(listNode.get())).deepEquivalent().deprecatedNode(), listNode.get());
240             Node* outerBlock = firstChildInList &amp;&amp; isBlockFlowElement(*firstChildInList) ? firstChildInList : listNode.get();
241 
242             moveParagraphWithClones(firstPositionInNode(listNode.get()), lastPositionInNode(listNode.get()), newList.get(), outerBlock);
243 
244             // Manually remove listNode because moveParagraphWithClones sometimes leaves it behind in the document.
245             // See the bug 33668 and editing/execCommand/insert-list-orphaned-item-with-nested-lists.html.
246             // FIXME: This might be a bug in moveParagraphWithClones or deleteSelection.
247             if (listNode &amp;&amp; listNode-&gt;isConnected())
248                 removeNode(*listNode);
249 
250             newList = mergeWithNeighboringLists(*newList);
251 
252             // Restore the start and the end of current selection if they started inside listNode
253             // because moveParagraphWithClones could have removed them.
254             if (rangeStartIsInList &amp;&amp; newList)
255                 currentSelection-&gt;setStart(*newList, 0);
256             if (rangeEndIsInList &amp;&amp; newList)
257                 currentSelection-&gt;setEnd(*newList, lastOffsetInNode(newList.get()));
258 
259             setEndingSelection(VisiblePosition(firstPositionInNode(newList.get())));
260 
261             return;
262         }
263 
264         unlistifyParagraph(endingSelection().visibleStart(), listNode.get(), listChildNode);
265     }
266 
267     if (!listChildNode || switchListType || forceCreateList)
268         m_listElement = listifyParagraph(endingSelection().visibleStart(), listTag);
269 }
270 
271 void InsertListCommand::unlistifyParagraph(const VisiblePosition&amp; originalStart, HTMLElement* listNode, Node* listChildNode)
272 {
273     Node* nextListChild;
274     Node* previousListChild;
275     VisiblePosition start;
276     VisiblePosition end;
277     if (listChildNode-&gt;hasTagName(liTag)) {
278         start = firstPositionInNode(listChildNode);
279         end = lastPositionInNode(listChildNode);
280         nextListChild = listChildNode-&gt;nextSibling();
281         previousListChild = listChildNode-&gt;previousSibling();
282     } else {
283         // A paragraph is visually a list item minus a list marker.  The paragraph will be moved.
284         start = startOfParagraph(originalStart, CanSkipOverEditingBoundary);
285         end = endOfParagraph(start, CanSkipOverEditingBoundary);
286         nextListChild = enclosingListChild(end.next().deepEquivalent().deprecatedNode(), listNode);
287         ASSERT(nextListChild != listChildNode);
288         previousListChild = enclosingListChild(start.previous().deepEquivalent().deprecatedNode(), listNode);
289         ASSERT(previousListChild != listChildNode);
290     }
291     // When removing a list, we must always create a placeholder to act as a point of insertion
292     // for the list content being removed.
293     auto placeholder = HTMLBRElement::create(document());
294     RefPtr&lt;Element&gt; nodeToInsert = placeholder.copyRef();
295     // If the content of the list item will be moved into another list, put it in a list item
296     // so that we don&#39;t create an orphaned list child.
297     if (enclosingList(listNode)) {
298         nodeToInsert = HTMLLIElement::create(document());
299         appendNode(placeholder.copyRef(), *nodeToInsert);
300     }
301 
302     if (nextListChild &amp;&amp; previousListChild) {
303         // We want to pull listChildNode out of listNode, and place it before nextListChild
304         // and after previousListChild, so we split listNode and insert it between the two lists.
305         // But to split listNode, we must first split ancestors of listChildNode between it and listNode,
306         // if any exist.
307         // FIXME: We appear to split at nextListChild as opposed to listChildNode so that when we remove
308         // listChildNode below in moveParagraphs, previousListChild will be removed along with it if it is
309         // unrendered. But we ought to remove nextListChild too, if it is unrendered.
310         splitElement(*listNode, *splitTreeToNode(*nextListChild, *listNode));
311         insertNodeBefore(nodeToInsert.releaseNonNull(), *listNode);
312     } else if (nextListChild || listChildNode-&gt;parentNode() != listNode) {
313         // Just because listChildNode has no previousListChild doesn&#39;t mean there isn&#39;t any content
314         // in listNode that comes before listChildNode, as listChildNode could have ancestors
315         // between it and listNode. So, we split up to listNode before inserting the placeholder
316         // where we&#39;re about to move listChildNode to.
317         if (listChildNode-&gt;parentNode() != listNode)
318             splitElement(*listNode, *splitTreeToNode(*listChildNode, *listNode).get());
319         insertNodeBefore(nodeToInsert.releaseNonNull(), *listNode);
320     } else
321         insertNodeAfter(nodeToInsert.releaseNonNull(), *listNode);
322 
323     VisiblePosition insertionPoint = VisiblePosition(positionBeforeNode(placeholder.ptr()));
324     moveParagraphs(start, end, insertionPoint, true);
325 }
326 
327 static Element* adjacentEnclosingList(const VisiblePosition&amp; pos, const VisiblePosition&amp; adjacentPos, const QualifiedName&amp; listTag)
328 {
329     Element* listNode = outermostEnclosingList(adjacentPos.deepEquivalent().deprecatedNode());
330 
331     if (!listNode)
332         return 0;
333 
334     Node* previousCell = enclosingTableCell(pos.deepEquivalent());
335     Node* currentCell = enclosingTableCell(adjacentPos.deepEquivalent());
336 
337     if (!listNode-&gt;hasTagName(listTag)
338         || listNode-&gt;contains(pos.deepEquivalent().deprecatedNode())
339         || previousCell != currentCell
340         || enclosingList(listNode) != enclosingList(pos.deepEquivalent().deprecatedNode()))
341         return 0;
342 
343     return listNode;
344 }
345 
346 RefPtr&lt;HTMLElement&gt; InsertListCommand::listifyParagraph(const VisiblePosition&amp; originalStart, const QualifiedName&amp; listTag)
347 {
348     VisiblePosition start = startOfParagraph(originalStart, CanSkipOverEditingBoundary);
349     VisiblePosition end = endOfParagraph(start, CanSkipOverEditingBoundary);
350 
<a name="6" id="anc6"></a><span class="line-modified">351     if (start.isNull() || end.isNull() || !start.deepEquivalent().containerNode()-&gt;hasEditableStyle() || !end.deepEquivalent().containerNode()-&gt;hasEditableStyle())</span>
352         return 0;
353 
354     // Check for adjoining lists.
355     auto listItemElement = HTMLLIElement::create(document());
356     auto placeholder = HTMLBRElement::create(document());
357     appendNode(placeholder.copyRef(), listItemElement.copyRef());
358 
359     // Place list item into adjoining lists.
360     Element* previousList = adjacentEnclosingList(start.deepEquivalent(), start.previous(CannotCrossEditingBoundary), listTag);
361     Element* nextList = adjacentEnclosingList(start.deepEquivalent(), end.next(CannotCrossEditingBoundary), listTag);
362     RefPtr&lt;HTMLElement&gt; listElement;
363     if (previousList)
364         appendNode(WTFMove(listItemElement), *previousList);
365     else if (nextList)
366         insertNodeAt(WTFMove(listItemElement), positionBeforeNode(nextList));
367     else {
368         // Create the list.
369         listElement = createHTMLElement(document(), listTag);
370         appendNode(WTFMove(listItemElement), *listElement);
371 
372         if (start == end &amp;&amp; isBlock(start.deepEquivalent().deprecatedNode())) {
373             // Inserting the list into an empty paragraph that isn&#39;t held open
374             // by a br or a &#39;\n&#39;, will invalidate start and end.  Insert
375             // a placeholder and then recompute start and end.
376             auto blockPlaceholder = insertBlockPlaceholder(start.deepEquivalent());
377             start = positionBeforeNode(blockPlaceholder.get());
378             end = start;
379         }
380 
381         // Insert the list at a position visually equivalent to start of the
382         // paragraph that is being moved into the list.
383         // Try to avoid inserting it somewhere where it will be surrounded by
384         // inline ancestors of start, since it is easier for editing to produce
385         // clean markup when inline elements are pushed down as far as possible.
386         Position insertionPos(start.deepEquivalent().upstream());
387         // Also avoid the containing list item.
388         Node* listChild = enclosingListChild(insertionPos.deprecatedNode());
389         if (listChild &amp;&amp; listChild-&gt;hasTagName(liTag))
390             insertionPos = positionInParentBeforeNode(listChild);
391 
392         insertNodeAt(*listElement, insertionPos);
393 
394         // We inserted the list at the start of the content we&#39;re about to move
395         // Update the start of content, so we don&#39;t try to move the list into itself.  bug 19066
396         // Layout is necessary since start&#39;s node&#39;s inline renderers may have been destroyed by the insertion
397         // The end of the content may have changed after the insertion and layout so update it as well.
398         if (insertionPos == start.deepEquivalent()) {
399             listElement-&gt;document().updateLayoutIgnorePendingStylesheets();
400             start = startOfParagraph(originalStart, CanSkipOverEditingBoundary);
401             end = endOfParagraph(start, CanSkipOverEditingBoundary);
402         }
403     }
404 
405     moveParagraph(start, end, positionBeforeNode(placeholder.ptr()), true);
406 
407     if (listElement)
408         return mergeWithNeighboringLists(*listElement);
409 
410     if (canMergeLists(previousList, nextList))
411         mergeIdenticalElements(*previousList, *nextList);
412 
413     return listElement;
414 }
415 
416 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
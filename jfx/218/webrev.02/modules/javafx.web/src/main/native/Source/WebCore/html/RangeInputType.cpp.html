<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/RangeInputType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;RangeInputType.h&quot;
 34 
 35 #include &quot;AXObjectCache.h&quot;
 36 #include &quot;ElementChildIterator.h&quot;
 37 #include &quot;EventNames.h&quot;
 38 #include &quot;HTMLInputElement.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;InputTypeNames.h&quot;
 41 #include &quot;KeyboardEvent.h&quot;
 42 #include &quot;MouseEvent.h&quot;
 43 #include &quot;PlatformMouseEvent.h&quot;
 44 #include &quot;RenderSlider.h&quot;
 45 #include &quot;RuntimeEnabledFeatures.h&quot;
 46 #include &quot;ScopedEventQueue.h&quot;
 47 #include &quot;ShadowRoot.h&quot;
 48 #include &quot;SliderThumbElement.h&quot;
 49 #include &lt;limits&gt;
 50 #include &lt;wtf/MathExtras.h&gt;
 51 
 52 #if ENABLE(TOUCH_EVENTS)
 53 #include &quot;Touch.h&quot;
 54 #include &quot;TouchEvent.h&quot;
 55 #include &quot;TouchList.h&quot;
 56 #endif
 57 
 58 #if ENABLE(DATALIST_ELEMENT)
 59 #include &quot;HTMLDataListElement.h&quot;
 60 #include &quot;HTMLOptionElement.h&quot;
 61 #endif
 62 
 63 namespace WebCore {
 64 
 65 using namespace HTMLNames;
 66 
 67 static const int rangeDefaultMinimum = 0;
 68 static const int rangeDefaultMaximum = 100;
 69 static const int rangeDefaultStep = 1;
 70 static const int rangeDefaultStepBase = 0;
 71 static const int rangeStepScaleFactor = 1;
 72 static const StepRange::StepDescription rangeStepDescription { rangeDefaultStep, rangeDefaultStepBase, rangeStepScaleFactor };
 73 
 74 static Decimal ensureMaximum(const Decimal&amp; proposedValue, const Decimal&amp; minimum, const Decimal&amp; fallbackValue)
 75 {
 76     return proposedValue &gt;= minimum ? proposedValue : std::max(minimum, fallbackValue);
 77 }
 78 
 79 RangeInputType::RangeInputType(HTMLInputElement&amp; element)
 80     : InputType(element)
 81 {
 82 }
 83 
 84 bool RangeInputType::isRangeControl() const
 85 {
 86     return true;
 87 }
 88 
 89 const AtomString&amp; RangeInputType::formControlType() const
 90 {
 91     return InputTypeNames::range();
 92 }
 93 
 94 double RangeInputType::valueAsDouble() const
 95 {
 96     ASSERT(element());
 97     return parseToDoubleForNumberType(element()-&gt;value());
 98 }
 99 
100 ExceptionOr&lt;void&gt; RangeInputType::setValueAsDecimal(const Decimal&amp; newValue, TextFieldEventBehavior eventBehavior) const
101 {
102     ASSERT(element());
103     element()-&gt;setValue(serialize(newValue), eventBehavior);
104     return { };
105 }
106 
107 bool RangeInputType::typeMismatchFor(const String&amp; value) const
108 {
109     return !value.isEmpty() &amp;&amp; !std::isfinite(parseToDoubleForNumberType(value));
110 }
111 
112 bool RangeInputType::supportsRequired() const
113 {
114     return false;
115 }
116 
117 StepRange RangeInputType::createStepRange(AnyStepHandling anyStepHandling) const
118 {
119     ASSERT(element());
120     const Decimal minimum = parseToNumber(element()-&gt;attributeWithoutSynchronization(minAttr), rangeDefaultMinimum);
121     const Decimal maximum = ensureMaximum(parseToNumber(element()-&gt;attributeWithoutSynchronization(maxAttr), rangeDefaultMaximum), minimum, rangeDefaultMaximum);
122 
123     const AtomString&amp; precisionValue = element()-&gt;attributeWithoutSynchronization(precisionAttr);
124     if (!precisionValue.isNull()) {
125         const Decimal step = equalLettersIgnoringASCIICase(precisionValue, &quot;float&quot;) ? Decimal::nan() : 1;
126         return StepRange(minimum, RangeLimitations::Valid, minimum, maximum, step, rangeStepDescription);
127     }
128 
129     const Decimal step = StepRange::parseStep(anyStepHandling, rangeStepDescription, element()-&gt;attributeWithoutSynchronization(stepAttr));
130     return StepRange(minimum, RangeLimitations::Valid, minimum, maximum, step, rangeStepDescription);
131 }
132 
133 bool RangeInputType::isSteppable() const
134 {
135     return true;
136 }
137 
138 void RangeInputType::handleMouseDownEvent(MouseEvent&amp; event)
139 {
140     ASSERT(element());
141     if (element()-&gt;isDisabledFormControl())
142         return;
143 
144     if (event.button() != LeftButton || !is&lt;Node&gt;(event.target()))
145         return;
146     ASSERT(element()-&gt;shadowRoot());
147     auto&amp; targetNode = downcast&lt;Node&gt;(*event.target());
148     if (&amp;targetNode != element() &amp;&amp; !targetNode.isDescendantOf(element()-&gt;userAgentShadowRoot().get()))
149         return;
150     auto&amp; thumb = typedSliderThumbElement();
151     if (&amp;targetNode == &amp;thumb)
152         return;
153     thumb.dragFrom(event.absoluteLocation());
154 }
155 
156 #if ENABLE(TOUCH_EVENTS)
157 void RangeInputType::handleTouchEvent(TouchEvent&amp; event)
158 {
159 #if PLATFORM(IOS_FAMILY)
160     typedSliderThumbElement().handleTouchEvent(event);
161 #elif ENABLE(TOUCH_SLIDER)
162     ASSERT(element());
163     if (element()-&gt;isDisabledFormControl())
164         return;
165 
166     if (event.type() == eventNames().touchendEvent) {
167         event.setDefaultHandled();
168         return;
169     }
170 
171     RefPtr&lt;TouchList&gt; touches = event.targetTouches();
172     if (touches-&gt;length() == 1) {
173         typedSliderThumbElement().setPositionFromPoint(touches-&gt;item(0)-&gt;absoluteLocation());
174         event.setDefaultHandled();
175     }
176 #else
177     UNUSED_PARAM(event);
178 #endif
179 }
180 
181 #if ENABLE(TOUCH_SLIDER)
182 bool RangeInputType::hasTouchEventHandler() const
183 {
184     return true;
185 }
186 #endif
187 #endif // ENABLE(TOUCH_EVENTS)
188 
189 void RangeInputType::disabledStateChanged()
190 {
191     typedSliderThumbElement().hostDisabledStateChanged();
192 }
193 
194 auto RangeInputType::handleKeydownEvent(KeyboardEvent&amp; event) -&gt; ShouldCallBaseEventHandler
195 {
196     ASSERT(element());
197     if (element()-&gt;isDisabledFormControl())
198         return ShouldCallBaseEventHandler::Yes;
199 
200     const String&amp; key = event.keyIdentifier();
201 
202     const Decimal current = parseToNumberOrNaN(element()-&gt;value());
203     ASSERT(current.isFinite());
204 
205     StepRange stepRange(createStepRange(RejectAny));
206 
207     // FIXME: We can&#39;t use stepUp() for the step value &quot;any&quot;. So, we increase
208     // or decrease the value by 1/100 of the value range. Is it reasonable?
209     const Decimal step = equalLettersIgnoringASCIICase(element()-&gt;attributeWithoutSynchronization(stepAttr), &quot;any&quot;) ? (stepRange.maximum() - stepRange.minimum()) / 100 : stepRange.step();
210     const Decimal bigStep = std::max((stepRange.maximum() - stepRange.minimum()) / 10, step);
211 
212     bool isVertical = false;
213     if (auto* renderer = element()-&gt;renderer()) {
214         ControlPart part = renderer-&gt;style().appearance();
215         isVertical = part == SliderVerticalPart || part == MediaVolumeSliderPart;
216     }
217 
218     Decimal newValue;
219     if (key == &quot;Up&quot;)
220         newValue = current + step;
221     else if (key == &quot;Down&quot;)
222         newValue = current - step;
223     else if (key == &quot;Left&quot;)
224         newValue = isVertical ? current + step : current - step;
225     else if (key == &quot;Right&quot;)
226         newValue = isVertical ? current - step : current + step;
227     else if (key == &quot;PageUp&quot;)
228         newValue = current + bigStep;
229     else if (key == &quot;PageDown&quot;)
230         newValue = current - bigStep;
231     else if (key == &quot;Home&quot;)
232         newValue = isVertical ? stepRange.maximum() : stepRange.minimum();
233     else if (key == &quot;End&quot;)
234         newValue = isVertical ? stepRange.minimum() : stepRange.maximum();
235     else
236         return ShouldCallBaseEventHandler::Yes; // Did not match any key binding.
237 
238     newValue = stepRange.clampValue(newValue);
239 
240     if (newValue != current) {
241         EventQueueScope scope;
242         setValueAsDecimal(newValue, DispatchInputAndChangeEvent);
243 
244         if (AXObjectCache* cache = element()-&gt;document().existingAXObjectCache())
245             cache-&gt;postNotification(element(), AXObjectCache::AXValueChanged);
246     }
247 
248     event.setDefaultHandled();
249     return ShouldCallBaseEventHandler::Yes;
250 }
251 
252 void RangeInputType::createShadowSubtree()
253 {
254     ASSERT(element());
255     ASSERT(element()-&gt;userAgentShadowRoot());
256 
257     Document&amp; document = element()-&gt;document();
258     auto track = HTMLDivElement::create(document);
259     track-&gt;setPseudo(AtomString(&quot;-webkit-slider-runnable-track&quot;, AtomString::ConstructFromLiteral));
260     track-&gt;appendChild(SliderThumbElement::create(document));
261     auto container = SliderContainerElement::create(document);
262     container-&gt;appendChild(track);
263     element()-&gt;userAgentShadowRoot()-&gt;appendChild(container);
264 }
265 
266 HTMLElement* RangeInputType::sliderTrackElement() const
267 {
268     ASSERT(element());
269     ASSERT(element()-&gt;userAgentShadowRoot());
270     ASSERT(element()-&gt;userAgentShadowRoot()-&gt;firstChild()); // container
271     ASSERT(element()-&gt;userAgentShadowRoot()-&gt;firstChild()-&gt;isHTMLElement());
272     ASSERT(element()-&gt;userAgentShadowRoot()-&gt;firstChild()-&gt;firstChild()); // track
273 
274     RefPtr&lt;ShadowRoot&gt; root = element()-&gt;userAgentShadowRoot();
275     if (!root)
276         return nullptr;
277 
278     auto* container = childrenOfType&lt;SliderContainerElement&gt;(*root).first();
279     if (!container)
280         return nullptr;
281 
282     return childrenOfType&lt;HTMLElement&gt;(*container).first();
283 }
284 
285 SliderThumbElement&amp; RangeInputType::typedSliderThumbElement() const
286 {
287     ASSERT(sliderTrackElement()-&gt;firstChild()); // thumb
288     ASSERT(sliderTrackElement()-&gt;firstChild()-&gt;isHTMLElement());
289 
290     return static_cast&lt;SliderThumbElement&amp;&gt;(*sliderTrackElement()-&gt;firstChild());
291 }
292 
293 HTMLElement* RangeInputType::sliderThumbElement() const
294 {
295     return &amp;typedSliderThumbElement();
296 }
297 
298 RenderPtr&lt;RenderElement&gt; RangeInputType::createInputRenderer(RenderStyle&amp;&amp; style)
299 {
300     ASSERT(element());
301     return createRenderer&lt;RenderSlider&gt;(*element(), WTFMove(style));
302 }
303 
304 Decimal RangeInputType::parseToNumber(const String&amp; src, const Decimal&amp; defaultValue) const
305 {
306     return parseToDecimalForNumberType(src, defaultValue);
307 }
308 
309 String RangeInputType::serialize(const Decimal&amp; value) const
310 {
311     if (!value.isFinite())
312         return String();
313     return serializeForNumberType(value);
314 }
315 
316 // FIXME: Could share this with BaseClickableWithKeyInputType and BaseCheckableInputType if we had a common base class.
317 void RangeInputType::accessKeyAction(bool sendMouseEvents)
318 {
319     InputType::accessKeyAction(sendMouseEvents);
320 
321     if (auto* element = this-&gt;element())
322         element-&gt;dispatchSimulatedClick(0, sendMouseEvents ? SendMouseUpDownEvents : SendNoEvents);
323 }
324 
325 void RangeInputType::attributeChanged(const QualifiedName&amp; name)
326 {
327     // FIXME: Don&#39;t we need to do this work for precisionAttr too?
328     if (name == maxAttr || name == minAttr || name == valueAttr) {
329         // Sanitize the value.
330         if (auto* element = this-&gt;element()) {
331             if (element-&gt;hasDirtyValue())
332                 element-&gt;setValue(element-&gt;value());
333         }
334         typedSliderThumbElement().setPositionFromValue();
335     }
336     InputType::attributeChanged(name);
337 }
338 
339 void RangeInputType::setValue(const String&amp; value, bool valueChanged, TextFieldEventBehavior eventBehavior)
340 {
341     InputType::setValue(value, valueChanged, eventBehavior);
342 
343     if (!valueChanged)
344         return;
345 
346     if (eventBehavior == DispatchNoEvent) {
347         ASSERT(element());
348         element()-&gt;setTextAsOfLastFormControlChangeEvent(value);
349     }
350 
351     typedSliderThumbElement().setPositionFromValue();
352 }
353 
354 String RangeInputType::fallbackValue() const
355 {
356     return serializeForNumberType(createStepRange(RejectAny).defaultValue());
357 }
358 
359 String RangeInputType::sanitizeValue(const String&amp; proposedValue) const
360 {
361     StepRange stepRange(createStepRange(RejectAny));
362     const Decimal proposedNumericValue = parseToNumber(proposedValue, stepRange.defaultValue());
363     return serializeForNumberType(stepRange.clampValue(proposedNumericValue));
364 }
365 
366 bool RangeInputType::shouldRespectListAttribute()
367 {
368 #if ENABLE(DATALIST_ELEMENT)
369     return RuntimeEnabledFeatures::sharedFeatures().dataListElementEnabled();
370 #else
371     return InputType::themeSupportsDataListUI(this);
372 #endif
373 }
374 
375 #if ENABLE(DATALIST_ELEMENT)
376 void RangeInputType::listAttributeTargetChanged()
377 {
378     m_tickMarkValuesDirty = true;
379     RefPtr&lt;HTMLElement&gt; sliderTrackElement = this-&gt;sliderTrackElement();
380     if (sliderTrackElement-&gt;renderer())
381         sliderTrackElement-&gt;renderer()-&gt;setNeedsLayout();
382 }
383 
384 void RangeInputType::updateTickMarkValues()
385 {
386     if (!m_tickMarkValuesDirty)
387         return;
388     m_tickMarkValues.clear();
389     m_tickMarkValuesDirty = false;
390     ASSERT(element());
391     auto dataList = element()-&gt;dataList();
392     if (!dataList)
393         return;
394     Ref&lt;HTMLCollection&gt; options = dataList-&gt;options();
395     m_tickMarkValues.reserveCapacity(options-&gt;length());
396     for (unsigned i = 0; i &lt; options-&gt;length(); ++i) {
397         RefPtr&lt;Node&gt; node = options-&gt;item(i);
398         HTMLOptionElement&amp; optionElement = downcast&lt;HTMLOptionElement&gt;(*node);
399         String optionValue = optionElement.value();
400         if (!element()-&gt;isValidValue(optionValue))
401             continue;
402         m_tickMarkValues.append(parseToNumber(optionValue, Decimal::nan()));
403     }
404     m_tickMarkValues.shrinkToFit();
405     std::sort(m_tickMarkValues.begin(), m_tickMarkValues.end());
406 }
407 
408 Optional&lt;Decimal&gt; RangeInputType::findClosestTickMarkValue(const Decimal&amp; value)
409 {
410     updateTickMarkValues();
411     if (!m_tickMarkValues.size())
412         return WTF::nullopt;
413 
414     size_t left = 0;
415     size_t right = m_tickMarkValues.size();
416     size_t middle;
417     while (true) {
418         ASSERT(left &lt;= right);
419         middle = left + (right - left) / 2;
420         if (!middle)
421             break;
422         if (middle == m_tickMarkValues.size() - 1 &amp;&amp; m_tickMarkValues[middle] &lt; value) {
423             middle++;
424             break;
425         }
426         if (m_tickMarkValues[middle - 1] &lt;= value &amp;&amp; m_tickMarkValues[middle] &gt;= value)
427             break;
428 
429         if (m_tickMarkValues[middle] &lt; value)
430             left = middle;
431         else
432             right = middle;
433     }
434 
435     Optional&lt;Decimal&gt; closestLeft = middle ? makeOptional(m_tickMarkValues[middle - 1]) : WTF::nullopt;
436     Optional&lt;Decimal&gt; closestRight = middle != m_tickMarkValues.size() ? makeOptional(m_tickMarkValues[middle]) : WTF::nullopt;
437 
438     if (!closestLeft)
439         return closestRight;
440     if (!closestRight)
441         return closestLeft;
442 
443     if (*closestRight - value &lt; value - *closestLeft)
444         return closestRight;
445 
446     return closestLeft;
447 }
448 #endif
449 
450 } // namespace WebCore
    </pre>
  </body>
</html>
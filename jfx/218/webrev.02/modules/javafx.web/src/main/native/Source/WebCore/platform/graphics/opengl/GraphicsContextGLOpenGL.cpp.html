<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGL.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2010 Google Inc. All rights reserved.
  4  * Copyright (C) 2010 Mozilla Corporation. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;GraphicsContextGLOpenGL.h&quot;
 30 
 31 #if ENABLE(GRAPHICS_CONTEXT_GL)
 32 
 33 #include &quot;ExtensionsGL.h&quot;
 34 #include &quot;FormatConverter.h&quot;
 35 #include &quot;Image.h&quot;
 36 #include &quot;ImageData.h&quot;
 37 #include &quot;ImageObserver.h&quot;
 38 #include &lt;wtf/UniqueArray.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 namespace {
 43 
 44 GraphicsContextGL::DataFormat getDataFormat(GCGLenum destinationFormat, GCGLenum destinationType)
 45 {
 46     GraphicsContextGL::DataFormat dstFormat = GraphicsContextGL::DataFormat::RGBA8;
 47     switch (destinationType) {
 48     case GraphicsContextGL::UNSIGNED_BYTE:
 49         switch (destinationFormat) {
 50         case GraphicsContextGL::RGB:
 51             dstFormat = GraphicsContextGL::DataFormat::RGB8;
 52             break;
 53         case GraphicsContextGL::RGBA:
 54             dstFormat = GraphicsContextGL::DataFormat::RGBA8;
 55             break;
 56         case GraphicsContextGL::ALPHA:
 57             dstFormat = GraphicsContextGL::DataFormat::A8;
 58             break;
 59         case GraphicsContextGL::LUMINANCE:
 60             dstFormat = GraphicsContextGL::DataFormat::R8;
 61             break;
 62         case GraphicsContextGL::LUMINANCE_ALPHA:
 63             dstFormat = GraphicsContextGL::DataFormat::RA8;
 64             break;
 65         case GraphicsContextGL::SRGB:
 66             dstFormat = GraphicsContextGL::DataFormat::RGB8;
 67             break;
 68         case GraphicsContextGL::SRGB_ALPHA:
 69             dstFormat = GraphicsContextGL::DataFormat::RGBA8;
 70             break;
 71         default:
 72             ASSERT_NOT_REACHED();
 73         }
 74         break;
 75     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:
 76         dstFormat = GraphicsContextGL::DataFormat::RGBA4444;
 77         break;
 78     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:
 79         dstFormat = GraphicsContextGL::DataFormat::RGBA5551;
 80         break;
 81     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:
 82         dstFormat = GraphicsContextGL::DataFormat::RGB565;
 83         break;
 84     case GraphicsContextGL::HALF_FLOAT_OES: // OES_texture_half_float
 85         switch (destinationFormat) {
 86         case GraphicsContextGL::RGB:
 87             dstFormat = GraphicsContextGL::DataFormat::RGB16F;
 88             break;
 89         case GraphicsContextGL::RGBA:
 90             dstFormat = GraphicsContextGL::DataFormat::RGBA16F;
 91             break;
 92         case GraphicsContextGL::ALPHA:
 93             dstFormat = GraphicsContextGL::DataFormat::A16F;
 94             break;
 95         case GraphicsContextGL::LUMINANCE:
 96             dstFormat = GraphicsContextGL::DataFormat::R16F;
 97             break;
 98         case GraphicsContextGL::LUMINANCE_ALPHA:
 99             dstFormat = GraphicsContextGL::DataFormat::RA16F;
100             break;
101         case GraphicsContextGL::SRGB:
102             dstFormat = GraphicsContextGL::DataFormat::RGB16F;
103             break;
104         case GraphicsContextGL::SRGB_ALPHA:
105             dstFormat = GraphicsContextGL::DataFormat::RGBA16F;
106             break;
107         default:
108             ASSERT_NOT_REACHED();
109         }
110         break;
111     case GraphicsContextGL::FLOAT: // OES_texture_float
112         switch (destinationFormat) {
113         case GraphicsContextGL::RGB:
114             dstFormat = GraphicsContextGL::DataFormat::RGB32F;
115             break;
116         case GraphicsContextGL::RGBA:
117             dstFormat = GraphicsContextGL::DataFormat::RGBA32F;
118             break;
119         case GraphicsContextGL::ALPHA:
120             dstFormat = GraphicsContextGL::DataFormat::A32F;
121             break;
122         case GraphicsContextGL::LUMINANCE:
123             dstFormat = GraphicsContextGL::DataFormat::R32F;
124             break;
125         case GraphicsContextGL::LUMINANCE_ALPHA:
126             dstFormat = GraphicsContextGL::DataFormat::RA32F;
127             break;
128         case GraphicsContextGL::SRGB:
129             dstFormat = GraphicsContextGL::DataFormat::RGB32F;
130             break;
131         case GraphicsContextGL::SRGB_ALPHA:
132             dstFormat = GraphicsContextGL::DataFormat::RGBA32F;
133             break;
134         default:
135             ASSERT_NOT_REACHED();
136         }
137         break;
138     default:
139         ASSERT_NOT_REACHED();
140     }
141     return dstFormat;
142 }
143 
144 } // anonymous namespace
145 
146 bool GraphicsContextGLOpenGL::texImage2DResourceSafe(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint unpackAlignment)
147 {
148     ASSERT(unpackAlignment == 1 || unpackAlignment == 2 || unpackAlignment == 4 || unpackAlignment == 8);
149     UniqueArray&lt;unsigned char&gt; zero;
150     if (width &gt; 0 &amp;&amp; height &gt; 0) {
151         unsigned size;
152         GCGLenum error = computeImageSizeInBytes(format, type, width, height, unpackAlignment, &amp;size, nullptr);
153         if (error != GraphicsContextGL::NO_ERROR) {
154             synthesizeGLError(error);
155             return false;
156         }
157         zero = makeUniqueArray&lt;unsigned char&gt;(size);
158         if (!zero) {
159             synthesizeGLError(GraphicsContextGL::INVALID_VALUE);
160             return false;
161         }
162         memset(zero.get(), 0, size);
163     }
164     return texImage2D(target, level, internalformat, width, height, border, format, type, zero.get());
165 }
166 
167 bool GraphicsContextGLOpenGL::computeFormatAndTypeParameters(GCGLenum format, GCGLenum type, unsigned* componentsPerPixel, unsigned* bytesPerComponent)
168 {
169     switch (format) {
170     case GraphicsContextGL::RED:
171     case GraphicsContextGL::RED_INTEGER:
172     case GraphicsContextGL::ALPHA:
173     case GraphicsContextGL::LUMINANCE:
174     case GraphicsContextGL::DEPTH_COMPONENT:
175     case GraphicsContextGL::DEPTH_STENCIL:
176         *componentsPerPixel = 1;
177         break;
178     case GraphicsContextGL::RG:
179     case GraphicsContextGL::RG_INTEGER:
180     case GraphicsContextGL::LUMINANCE_ALPHA:
181         *componentsPerPixel = 2;
182         break;
183     case GraphicsContextGL::RGB:
184     case GraphicsContextGL::RGB_INTEGER:
185     case ExtensionsGL::SRGB_EXT:
186         *componentsPerPixel = 3;
187         break;
188     case GraphicsContextGL::RGBA:
189     case GraphicsContextGL::RGBA_INTEGER:
190     case ExtensionsGL::BGRA_EXT: // GL_EXT_texture_format_BGRA8888
191     case ExtensionsGL::SRGB_ALPHA_EXT:
192         *componentsPerPixel = 4;
193         break;
194     default:
195         return false;
196     }
197 
198     switch (type) {
199     case GraphicsContextGL::UNSIGNED_BYTE:
200         *bytesPerComponent = sizeof(GCGLubyte);
201         break;
202     case GraphicsContextGL::BYTE:
203         *bytesPerComponent = sizeof(GCGLbyte);
204         break;
205     case GraphicsContextGL::UNSIGNED_SHORT:
206         *bytesPerComponent = sizeof(GCGLushort);
207         break;
208     case GraphicsContextGL::SHORT:
209         *bytesPerComponent = sizeof(GCGLshort);
210         break;
211     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:
212     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:
213     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:
214         *componentsPerPixel = 1;
215         *bytesPerComponent = sizeof(GCGLushort);
216         break;
217     case GraphicsContextGL::UNSIGNED_INT_24_8:
218     case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:
219     case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:
220     case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:
221         *componentsPerPixel = 1;
222         *bytesPerComponent = sizeof(GCGLuint);
223         break;
224     case GraphicsContextGL::UNSIGNED_INT:
225         *bytesPerComponent = sizeof(GCGLuint);
226         break;
227     case GraphicsContextGL::INT:
228         *bytesPerComponent = sizeof(GCGLint);
229         break;
230     case GraphicsContextGL::FLOAT: // OES_texture_float
231         *bytesPerComponent = sizeof(GCGLfloat);
232         break;
233     case GraphicsContextGL::HALF_FLOAT:
234     case GraphicsContextGL::HALF_FLOAT_OES: // OES_texture_half_float
235         *bytesPerComponent = sizeof(GCGLhalffloat);
236         break;
237     case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:
238         *bytesPerComponent = sizeof(GCGLfloat) + sizeof(GCGLuint);
239         break;
240     default:
241         return false;
242     }
243     return true;
244 }
245 
246 bool GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(GCGLenum internalFormat, GCGLenum&amp; format, GCGLenum&amp; type)
247 {
248 #define POSSIBLE_FORMAT_TYPE_CASE(internalFormatMacro, formatMacro, typeMacro) case internalFormatMacro: \
249         format = formatMacro; \
250         type = GraphicsContextGLOpenGL::typeMacro; \
251         break;
252 
253     switch (internalFormat) {
254     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB               , GraphicsContextGL::RGB            , UNSIGNED_BYTE                 );
255     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA              , GraphicsContextGL::RGBA           , UNSIGNED_BYTE                 );
256     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::LUMINANCE_ALPHA   , GraphicsContextGL::LUMINANCE_ALPHA, UNSIGNED_BYTE                 );
257     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::LUMINANCE         , GraphicsContextGL::LUMINANCE      , UNSIGNED_BYTE                 );
258     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::ALPHA             , GraphicsContextGL::ALPHA          , UNSIGNED_BYTE                 );
259     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R8                , GraphicsContextGL::RED            , UNSIGNED_BYTE                 );
260     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R8_SNORM          , GraphicsContextGL::RED            , BYTE                          );
261     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R16F              , GraphicsContextGL::RED            , HALF_FLOAT                    );
262     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R32F              , GraphicsContextGL::RED            , FLOAT                         );
263     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R8UI              , GraphicsContextGL::RED_INTEGER    , UNSIGNED_BYTE                 );
264     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R8I               , GraphicsContextGL::RED_INTEGER    , BYTE                          );
265     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R16UI             , GraphicsContextGL::RED_INTEGER    , UNSIGNED_SHORT                );
266     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R16I              , GraphicsContextGL::RED_INTEGER    , SHORT                         );
267     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R32UI             , GraphicsContextGL::RED_INTEGER    , UNSIGNED_INT                  );
268     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R32I              , GraphicsContextGL::RED_INTEGER    , INT                           );
269     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG8               , GraphicsContextGL::RG             , UNSIGNED_BYTE                 );
270     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG8_SNORM         , GraphicsContextGL::RG             , BYTE                          );
271     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG16F             , GraphicsContextGL::RG             , HALF_FLOAT                    );
272     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG32F             , GraphicsContextGL::RG             , FLOAT                         );
273     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG8UI             , GraphicsContextGL::RG_INTEGER     , UNSIGNED_BYTE                 );
274     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG8I              , GraphicsContextGL::RG_INTEGER     , BYTE                          );
275     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG16UI            , GraphicsContextGL::RG_INTEGER     , UNSIGNED_SHORT                );
276     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG16I             , GraphicsContextGL::RG_INTEGER     , SHORT                         );
277     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG32UI            , GraphicsContextGL::RG_INTEGER     , UNSIGNED_INT                  );
278     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RG32I             , GraphicsContextGL::RG_INTEGER     , INT                           );
279     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB8              , GraphicsContextGL::RGB            , UNSIGNED_BYTE                 );
280     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::SRGB8             , GraphicsContextGL::RGB            , UNSIGNED_BYTE                 );
281     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB565            , GraphicsContextGL::RGB            , UNSIGNED_SHORT_5_6_5          );
282     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB8_SNORM        , GraphicsContextGL::RGB            , BYTE                          );
283     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::R11F_G11F_B10F    , GraphicsContextGL::RGB            , UNSIGNED_INT_10F_11F_11F_REV  );
284     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB9_E5           , GraphicsContextGL::RGB            , UNSIGNED_INT_5_9_9_9_REV      );
285     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB16F            , GraphicsContextGL::RGB            , HALF_FLOAT                    );
286     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB32F            , GraphicsContextGL::RGB            , FLOAT                         );
287     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB8UI            , GraphicsContextGL::RGB_INTEGER    , UNSIGNED_BYTE                 );
288     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB8I             , GraphicsContextGL::RGB_INTEGER    , BYTE                          );
289     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB16UI           , GraphicsContextGL::RGB_INTEGER    , UNSIGNED_SHORT                );
290     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB16I            , GraphicsContextGL::RGB_INTEGER    , SHORT                         );
291     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB32UI           , GraphicsContextGL::RGB_INTEGER    , UNSIGNED_INT                  );
292     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB32I            , GraphicsContextGL::RGB_INTEGER    , INT                           );
293     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA8             , GraphicsContextGL::RGBA           , UNSIGNED_BYTE                 );
294     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::SRGB8_ALPHA8      , GraphicsContextGL::RGBA           , UNSIGNED_BYTE                 );
295     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA8_SNORM       , GraphicsContextGL::RGBA           , BYTE                          );
296     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB5_A1           , GraphicsContextGL::RGBA           , UNSIGNED_SHORT_5_5_5_1        );
297     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA4             , GraphicsContextGL::RGBA           , UNSIGNED_SHORT_4_4_4_4        );
298     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB10_A2          , GraphicsContextGL::RGBA           , UNSIGNED_INT_2_10_10_10_REV   );
299     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA16F           , GraphicsContextGL::RGBA           , HALF_FLOAT                    );
300     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA32F           , GraphicsContextGL::RGBA           , FLOAT                         );
301     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA8UI           , GraphicsContextGL::RGBA_INTEGER   , UNSIGNED_BYTE                 );
302     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA8I            , GraphicsContextGL::RGBA_INTEGER   , BYTE                          );
303     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGB10_A2UI        , GraphicsContextGL::RGBA_INTEGER   , UNSIGNED_INT_2_10_10_10_REV   );
304     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA16UI          , GraphicsContextGL::RGBA_INTEGER   , UNSIGNED_SHORT                );
305     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA16I           , GraphicsContextGL::RGBA_INTEGER   , SHORT                         );
306     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA32I           , GraphicsContextGL::RGBA_INTEGER   , INT                           );
307     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::RGBA32UI          , GraphicsContextGL::RGBA_INTEGER   , UNSIGNED_INT                  );
308     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH_COMPONENT16 , GraphicsContextGL::DEPTH_COMPONENT, UNSIGNED_SHORT                );
309     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH_COMPONENT   , GraphicsContextGL::DEPTH_COMPONENT, UNSIGNED_SHORT                );
310     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH_COMPONENT24 , GraphicsContextGL::DEPTH_COMPONENT, UNSIGNED_INT                  );
311     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH_COMPONENT32F, GraphicsContextGL::DEPTH_COMPONENT, FLOAT                         );
312     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH_STENCIL     , GraphicsContextGL::DEPTH_STENCIL  , UNSIGNED_INT_24_8             );
313     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH24_STENCIL8  , GraphicsContextGL::DEPTH_STENCIL  , UNSIGNED_INT_24_8             );
314     POSSIBLE_FORMAT_TYPE_CASE(GraphicsContextGL::DEPTH32F_STENCIL8 , GraphicsContextGL::DEPTH_STENCIL  , FLOAT_32_UNSIGNED_INT_24_8_REV);
315     POSSIBLE_FORMAT_TYPE_CASE(ExtensionsGL::SRGB_EXT               , ExtensionsGL::SRGB_EXT            , UNSIGNED_BYTE                 );
316     POSSIBLE_FORMAT_TYPE_CASE(ExtensionsGL::SRGB_ALPHA_EXT         , ExtensionsGL::SRGB_ALPHA_EXT      , UNSIGNED_BYTE                 );
317     default:
318         return false;
319     }
320 #undef POSSIBLE_FORMAT_TYPE_CASE
321 
322     return true;
323 }
324 
325 GCGLenum GraphicsContextGLOpenGL::computeImageSizeInBytes(GCGLenum format, GCGLenum type, GCGLsizei width, GCGLsizei height, GCGLint alignment, unsigned* imageSizeInBytes, unsigned* paddingInBytes)
326 {
327     ASSERT(imageSizeInBytes);
328     ASSERT(alignment == 1 || alignment == 2 || alignment == 4 || alignment == 8);
329     if (width &lt; 0 || height &lt; 0)
330         return GraphicsContextGL::INVALID_VALUE;
331     unsigned bytesPerComponent;
332     unsigned componentsPerPixel;
333     if (!computeFormatAndTypeParameters(format, type, &amp;componentsPerPixel, &amp;bytesPerComponent))
334         return GraphicsContextGL::INVALID_ENUM;
335     if (!width || !height) {
336         *imageSizeInBytes = 0;
337         if (paddingInBytes)
338             *paddingInBytes = 0;
339         return GraphicsContextGL::NO_ERROR;
340     }
341     Checked&lt;uint32_t, RecordOverflow&gt; checkedValue = bytesPerComponent * componentsPerPixel;
342     checkedValue *=  width;
343     if (checkedValue.hasOverflowed())
344         return GraphicsContextGL::INVALID_VALUE;
345     unsigned validRowSize = checkedValue.unsafeGet();
346     unsigned padding = 0;
347     unsigned residual = validRowSize % alignment;
348     if (residual) {
349         padding = alignment - residual;
350         checkedValue += padding;
351     }
352     // Last row needs no padding.
353     checkedValue *= (height - 1);
354     checkedValue += validRowSize;
355     if (checkedValue.hasOverflowed())
356         return GraphicsContextGL::INVALID_VALUE;
357     *imageSizeInBytes = checkedValue.unsafeGet();
358     if (paddingInBytes)
359         *paddingInBytes = padding;
360     return GraphicsContextGL::NO_ERROR;
361 }
362 
363 GraphicsContextGLOpenGL::ImageExtractor::ImageExtractor(Image* image, DOMSource imageHtmlDomSource, bool premultiplyAlpha, bool ignoreGammaAndColorProfile)
364 {
365     m_image = image;
366     m_imageHtmlDomSource = imageHtmlDomSource;
367     m_extractSucceeded = extractImage(premultiplyAlpha, ignoreGammaAndColorProfile);
368 }
369 
370 bool GraphicsContextGLOpenGL::packImageData(Image* image, const void* pixels, GCGLenum format, GCGLenum type, bool flipY, AlphaOp alphaOp, DataFormat sourceFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, Vector&lt;uint8_t&gt;&amp; data)
371 {
372     if (!image || !pixels)
373         return false;
374 
375     unsigned packedSize;
376     // Output data is tightly packed (alignment == 1).
377     if (computeImageSizeInBytes(format, type, width, height, 1, &amp;packedSize, nullptr) != GraphicsContextGL::NO_ERROR)
378         return false;
379     data.resize(packedSize);
380 
381     if (!packPixels(reinterpret_cast&lt;const uint8_t*&gt;(pixels), sourceFormat, width, height, sourceUnpackAlignment, format, type, alphaOp, data.data(), flipY))
382         return false;
383     if (ImageObserver* observer = image-&gt;imageObserver())
384         observer-&gt;didDraw(*image);
385     return true;
386 }
387 
388 bool GraphicsContextGLOpenGL::extractImageData(ImageData* imageData, GCGLenum format, GCGLenum type, bool flipY, bool premultiplyAlpha, Vector&lt;uint8_t&gt;&amp; data)
389 {
390     if (!imageData)
391         return false;
392     int width = imageData-&gt;width();
393     int height = imageData-&gt;height();
394 
395     unsigned packedSize;
396     // Output data is tightly packed (alignment == 1).
397     if (computeImageSizeInBytes(format, type, width, height, 1, &amp;packedSize, nullptr) != GraphicsContextGL::NO_ERROR)
398         return false;
399     data.resize(packedSize);
400 
401     if (!packPixels(imageData-&gt;data()-&gt;data(), GraphicsContextGL::DataFormat::RGBA8, width, height, 0, format, type, premultiplyAlpha ? AlphaOp::DoPremultiply : AlphaOp::DoNothing, data.data(), flipY))
402         return false;
403 
404     return true;
405 }
406 
407 bool GraphicsContextGLOpenGL::extractTextureData(unsigned width, unsigned height, GCGLenum format, GCGLenum type, unsigned unpackAlignment, bool flipY, bool premultiplyAlpha, const void* pixels, Vector&lt;uint8_t&gt;&amp; data)
408 {
409     // Assumes format, type, etc. have already been validated.
410     DataFormat sourceDataFormat = getDataFormat(format, type);
411 
412     // Resize the output buffer.
413     unsigned componentsPerPixel, bytesPerComponent;
414     if (!computeFormatAndTypeParameters(format, type, &amp;componentsPerPixel, &amp;bytesPerComponent))
415         return false;
416     unsigned bytesPerPixel = componentsPerPixel * bytesPerComponent;
417     data.resize(width * height * bytesPerPixel);
418 
419     if (!packPixels(static_cast&lt;const uint8_t*&gt;(pixels), sourceDataFormat, width, height, unpackAlignment, format, type, (premultiplyAlpha ? AlphaOp::DoPremultiply : AlphaOp::DoNothing), data.data(), flipY))
420         return false;
421 
422     return true;
423 }
424 
425 ALWAYS_INLINE unsigned TexelBytesForFormat(GraphicsContextGL::DataFormat format)
426 {
427     switch (format) {
428     case GraphicsContextGL::DataFormat::R8:
429     case GraphicsContextGL::DataFormat::A8:
430         return 1;
431     case GraphicsContextGL::DataFormat::RA8:
432     case GraphicsContextGL::DataFormat::AR8:
433     case GraphicsContextGL::DataFormat::RGBA5551:
434     case GraphicsContextGL::DataFormat::RGBA4444:
435     case GraphicsContextGL::DataFormat::RGB565:
436     case GraphicsContextGL::DataFormat::A16F:
437     case GraphicsContextGL::DataFormat::R16F:
438         return 2;
439     case GraphicsContextGL::DataFormat::RGB8:
440     case GraphicsContextGL::DataFormat::BGR8:
441         return 3;
442     case GraphicsContextGL::DataFormat::RGBA8:
443     case GraphicsContextGL::DataFormat::ARGB8:
444     case GraphicsContextGL::DataFormat::ABGR8:
445     case GraphicsContextGL::DataFormat::BGRA8:
446     case GraphicsContextGL::DataFormat::R32F:
447     case GraphicsContextGL::DataFormat::A32F:
448     case GraphicsContextGL::DataFormat::RA16F:
449         return 4;
450     case GraphicsContextGL::DataFormat::RGB16F:
451         return 6;
452     case GraphicsContextGL::DataFormat::RA32F:
453     case GraphicsContextGL::DataFormat::RGBA16F:
454         return 8;
455     case GraphicsContextGL::DataFormat::RGB32F:
456         return 12;
457     case GraphicsContextGL::DataFormat::RGBA32F:
458         return 16;
459     default:
460         return 0;
461     }
462 }
463 
464 bool GraphicsContextGLOpenGL::packPixels(const uint8_t* sourceData, DataFormat sourceDataFormat, unsigned width, unsigned height, unsigned sourceUnpackAlignment, unsigned destinationFormat, unsigned destinationType, AlphaOp alphaOp, void* destinationData, bool flipY)
465 {
466     int validSrc = width * TexelBytesForFormat(sourceDataFormat);
467     int remainder = sourceUnpackAlignment ? (validSrc % sourceUnpackAlignment) : 0;
468     int srcStride = remainder ? (validSrc + sourceUnpackAlignment - remainder) : validSrc;
469 
470     // FIXME: Implement packing pixels to WebGL 2 formats
471     switch (destinationFormat) {
472     case GraphicsContextGL::RED:
473     case GraphicsContextGL::RED_INTEGER:
474     case GraphicsContextGL::RG:
475     case GraphicsContextGL::RG_INTEGER:
476     case GraphicsContextGL::RGB_INTEGER:
477     case GraphicsContextGL::RGBA_INTEGER:
478     case GraphicsContextGL::DEPTH_COMPONENT:
479     case GraphicsContextGL::DEPTH_STENCIL:
480         return false;
481     }
482     switch (destinationType) {
483     case GraphicsContextGL::BYTE:
484     case GraphicsContextGL::SHORT:
485     case GraphicsContextGL::INT:
486     case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:
487     case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:
488     case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:
489     case GraphicsContextGL::UNSIGNED_INT_24_8:
490         return false;
491     }
492 
493     DataFormat dstDataFormat = getDataFormat(destinationFormat, destinationType);
494     int dstStride = width * TexelBytesForFormat(dstDataFormat);
495     if (flipY) {
496         destinationData = static_cast&lt;uint8_t*&gt;(destinationData) + dstStride*(height - 1);
497         dstStride = -dstStride;
498     }
499     if (!hasAlpha(sourceDataFormat) || !hasColor(sourceDataFormat) || !hasColor(dstDataFormat))
500         alphaOp = AlphaOp::DoNothing;
501 
502     if (sourceDataFormat == dstDataFormat &amp;&amp; alphaOp == AlphaOp::DoNothing) {
503         const uint8_t* ptr = sourceData;
504         const uint8_t* ptrEnd = sourceData + srcStride * height;
505         unsigned rowSize = (dstStride &gt; 0) ? dstStride: -dstStride;
506         uint8_t* dst = static_cast&lt;uint8_t*&gt;(destinationData);
507         while (ptr &lt; ptrEnd) {
508             memcpy(dst, ptr, rowSize);
509             ptr += srcStride;
510             dst += dstStride;
511         }
512         return true;
513     }
514 
515     FormatConverter converter(width, height, sourceData, destinationData, srcStride, dstStride);
516     converter.convert(sourceDataFormat, dstDataFormat, alphaOp);
517     if (!converter.success())
518         return false;
519     return true;
520 }
521 
522 #if !(PLATFORM(COCOA) &amp;&amp; (USE(OPENGL) || USE(ANGLE)))
523 void GraphicsContextGLOpenGL::setContextVisibility(bool)
524 {
525 }
526 #endif
527 
528 #if !PLATFORM(COCOA)
529 void GraphicsContextGLOpenGL::simulateContextChanged()
530 {
531 }
532 #endif
533 
534 } // namespace WebCore
535 
536 #endif // ENABLE(GRAPHICS_CONTEXT_GL)
    </pre>
  </body>
</html>
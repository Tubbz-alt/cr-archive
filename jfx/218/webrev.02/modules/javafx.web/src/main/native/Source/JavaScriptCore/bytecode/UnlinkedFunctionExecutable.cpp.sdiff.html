<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedFunctionExecutable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnlinkedFunctionCodeBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedFunctionExecutable.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedFunctionExecutable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 #include &quot;SourceProvider.h&quot;
 41 #include &quot;Structure.h&quot;
 42 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
 43 #include &lt;wtf/Optional.h&gt;
 44 
 45 namespace JSC {
 46 
 47 static_assert(sizeof(UnlinkedFunctionExecutable) &lt;= 128, &quot;UnlinkedFunctionExecutable should fit in a 128-byte cell to keep allocated blocks count to only one after initializing JSGlobalObject.&quot;);
 48 
 49 const ClassInfo UnlinkedFunctionExecutable::s_info = { &quot;UnlinkedFunctionExecutable&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(UnlinkedFunctionExecutable) };
 50 
 51 static UnlinkedFunctionCodeBlock* generateUnlinkedFunctionCodeBlock(
 52     VM&amp; vm, UnlinkedFunctionExecutable* executable, const SourceCode&amp; source,
 53     CodeSpecializationKind kind, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode,
 54     UnlinkedFunctionKind functionKind, ParserError&amp; error, SourceParseMode parseMode)
 55 {
 56     JSParserBuiltinMode builtinMode = executable-&gt;isBuiltinFunction() ? JSParserBuiltinMode::Builtin : JSParserBuiltinMode::NotBuiltin;
 57     JSParserStrictMode strictMode = executable-&gt;isInStrictContext() ? JSParserStrictMode::Strict : JSParserStrictMode::NotStrict;
 58     JSParserScriptMode scriptMode = executable-&gt;scriptMode();
 59     ASSERT(isFunctionParseMode(executable-&gt;parseMode()));

 60     std::unique_ptr&lt;FunctionNode&gt; function = parse&lt;FunctionNode&gt;(
<span class="line-modified"> 61         vm, source, executable-&gt;name(), builtinMode, strictMode, scriptMode, executable-&gt;parseMode(), executable-&gt;superBinding(), error, nullptr);</span>
 62 
 63     if (!function) {
 64         ASSERT(error.isValid());
 65         return nullptr;
 66     }
 67 
 68     function-&gt;finishParsing(executable-&gt;name(), executable-&gt;functionMode());
 69     executable-&gt;recordParse(function-&gt;features(), function-&gt;hasCapturedVariables());
 70 
 71     bool isClassContext = executable-&gt;superBinding() == SuperBinding::Needed;
 72 
<span class="line-modified"> 73     UnlinkedFunctionCodeBlock* result = UnlinkedFunctionCodeBlock::create(vm, FunctionCode, ExecutableInfo(function-&gt;usesEval(), function-&gt;isStrictMode(), kind == CodeForConstruct, functionKind == UnlinkedBuiltinFunction, executable-&gt;constructorKind(), scriptMode, executable-&gt;superBinding(), parseMode, executable-&gt;derivedContextType(), false, isClassContext, EvalContextType::FunctionEvalContext), codeGenerationMode);</span>
 74 
 75     VariableEnvironment parentScopeTDZVariables = executable-&gt;parentScopeTDZVariables();
 76     error = BytecodeGenerator::generate(vm, function.get(), source, result, codeGenerationMode, &amp;parentScopeTDZVariables);
 77 
 78     if (error.isValid())
 79         return nullptr;
 80     vm.codeCache()-&gt;updateCache(executable, source, kind, result);
 81     return result;
 82 }
 83 
<span class="line-modified"> 84 UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(VM&amp; vm, Structure* structure, const SourceCode&amp; parentSource, FunctionMetadataNode* node, UnlinkedFunctionKind kind, ConstructAbility constructAbility, JSParserScriptMode scriptMode, Optional&lt;CompactVariableMap::Handle&gt; parentScopeTDZVariables, DerivedContextType derivedContextType, bool isBuiltinDefaultClassConstructor)</span>
 85     : Base(vm, structure)
 86     , m_firstLineOffset(node-&gt;firstLine() - parentSource.firstLine().oneBasedInt())
 87     , m_isInStrictContext(node-&gt;isInStrictContext())
 88     , m_lineCount(node-&gt;lastLine() - node-&gt;firstLine())
 89     , m_hasCapturedVariables(false)
 90     , m_unlinkedFunctionNameStart(node-&gt;functionNameStart() - parentSource.startOffset())
 91     , m_isBuiltinFunction(kind == UnlinkedBuiltinFunction)
 92     , m_unlinkedBodyStartColumn(node-&gt;startColumn())
 93     , m_isBuiltinDefaultClassConstructor(isBuiltinDefaultClassConstructor)
 94     , m_unlinkedBodyEndColumn(m_lineCount ? node-&gt;endColumn() : node-&gt;endColumn() - node-&gt;startColumn())
 95     , m_constructAbility(static_cast&lt;unsigned&gt;(constructAbility))
 96     , m_startOffset(node-&gt;source().startOffset() - parentSource.startOffset())
 97     , m_scriptMode(static_cast&lt;unsigned&gt;(scriptMode))
 98     , m_sourceLength(node-&gt;source().length())
 99     , m_superBinding(static_cast&lt;unsigned&gt;(node-&gt;superBinding()))
100     , m_parametersStartOffset(node-&gt;parametersStart())
101     , m_isCached(false)
102     , m_typeProfilingStartOffset(node-&gt;functionKeywordStart())
103     , m_typeProfilingEndOffset(node-&gt;startStartOffset() + node-&gt;source().length() - 1)
104     , m_parameterCount(node-&gt;parameterCount())
105     , m_features(0)
106     , m_sourceParseMode(node-&gt;parseMode())
107     , m_constructorKind(static_cast&lt;unsigned&gt;(node-&gt;constructorKind()))
108     , m_functionMode(static_cast&lt;unsigned&gt;(node-&gt;functionMode()))
109     , m_derivedContextType(static_cast&lt;unsigned&gt;(derivedContextType))
110     , m_isGeneratedFromCache(false)

111     , m_unlinkedCodeBlockForCall()
112     , m_unlinkedCodeBlockForConstruct()
113     , m_name(node-&gt;ident())
114     , m_ecmaName(node-&gt;ecmaName())
115 {
116     // Make sure these bitfields are adequately wide.
117     ASSERT(m_constructAbility == static_cast&lt;unsigned&gt;(constructAbility));
118     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(node-&gt;constructorKind()));
119     ASSERT(m_functionMode == static_cast&lt;unsigned&gt;(node-&gt;functionMode()));
120     ASSERT(m_scriptMode == static_cast&lt;unsigned&gt;(scriptMode));
121     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(node-&gt;superBinding()));
122     ASSERT(m_derivedContextType == static_cast&lt;unsigned&gt;(derivedContextType));
123     ASSERT(!(m_isBuiltinDefaultClassConstructor &amp;&amp; constructorKind() == ConstructorKind::None));

124     if (!node-&gt;classSource().isNull())
125         setClassSource(node-&gt;classSource());
126     if (parentScopeTDZVariables)
127         ensureRareData().m_parentScopeTDZVariables = WTFMove(*parentScopeTDZVariables);
128 }
129 
130 UnlinkedFunctionExecutable::~UnlinkedFunctionExecutable()
131 {
132     if (m_isCached)
133         m_decoder.~RefPtr();
134 }
135 
136 void UnlinkedFunctionExecutable::destroy(JSCell* cell)
137 {
138     static_cast&lt;UnlinkedFunctionExecutable*&gt;(cell)-&gt;~UnlinkedFunctionExecutable();
139 }
140 
141 void UnlinkedFunctionExecutable::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
142 {
143     UnlinkedFunctionExecutable* thisObject = jsCast&lt;UnlinkedFunctionExecutable*&gt;(cell);
</pre>
<hr />
<pre>
172 
173 FunctionExecutable* UnlinkedFunctionExecutable::link(VM&amp; vm, ScriptExecutable* topLevelExecutable, const SourceCode&amp; passedParentSource, Optional&lt;int&gt; overrideLineNumber, Intrinsic intrinsic)
174 {
175     SourceCode source = linkedSourceCode(passedParentSource);
176     FunctionOverrides::OverrideInfo overrideInfo;
177     bool hasFunctionOverride = false;
178     if (UNLIKELY(Options::functionOverrides()))
179         hasFunctionOverride = FunctionOverrides::initializeOverrideFor(source, overrideInfo);
180 
181     FunctionExecutable* result = FunctionExecutable::create(vm, topLevelExecutable, source, this, intrinsic);
182     if (overrideLineNumber)
183         result-&gt;setOverrideLineNumber(*overrideLineNumber);
184 
185     if (UNLIKELY(hasFunctionOverride))
186         result-&gt;overrideInfo(overrideInfo);
187 
188     return result;
189 }
190 
191 UnlinkedFunctionExecutable* UnlinkedFunctionExecutable::fromGlobalCode(
<span class="line-modified">192     const Identifier&amp; name, ExecState&amp; exec, const SourceCode&amp; source,</span>
193     JSObject*&amp; exception, int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition)
194 {
195     ParserError error;
<span class="line-modified">196     VM&amp; vm = exec.vm();</span>
<span class="line-removed">197     auto&amp; globalObject = *exec.lexicalGlobalObject();</span>
198     CodeCache* codeCache = vm.codeCache();
<span class="line-modified">199     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject.defaultCodeGenerationMode();</span>
200     UnlinkedFunctionExecutable* executable = codeCache-&gt;getUnlinkedGlobalFunctionExecutable(vm, name, source, codeGenerationMode, functionConstructorParametersEndPosition, error);
201 
<span class="line-modified">202     if (globalObject.hasDebugger())</span>
<span class="line-modified">203         globalObject.debugger()-&gt;sourceParsed(&amp;exec, source.provider(), error.line(), error.message());</span>
204 
205     if (error.isValid()) {
<span class="line-modified">206         exception = error.toErrorObject(&amp;globalObject, source, overrideLineNumber);</span>
207         return nullptr;
208     }
209 
210     return executable;
211 }
212 
213 UnlinkedFunctionCodeBlock* UnlinkedFunctionExecutable::unlinkedCodeBlockFor(
214     VM&amp; vm, const SourceCode&amp; source, CodeSpecializationKind specializationKind,
215     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, SourceParseMode parseMode)
216 {
217     if (m_isCached)
218         decodeCachedCodeBlocks(vm);
219     switch (specializationKind) {
220     case CodeForCall:
221         if (UnlinkedFunctionCodeBlock* codeBlock = m_unlinkedCodeBlockForCall.get())
222             return codeBlock;
223         break;
224     case CodeForConstruct:
225         if (UnlinkedFunctionCodeBlock* codeBlock = m_unlinkedCodeBlockForConstruct.get())
226             return codeBlock;
</pre>
</td>
<td>
<hr />
<pre>
 40 #include &quot;SourceProvider.h&quot;
 41 #include &quot;Structure.h&quot;
 42 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
 43 #include &lt;wtf/Optional.h&gt;
 44 
 45 namespace JSC {
 46 
 47 static_assert(sizeof(UnlinkedFunctionExecutable) &lt;= 128, &quot;UnlinkedFunctionExecutable should fit in a 128-byte cell to keep allocated blocks count to only one after initializing JSGlobalObject.&quot;);
 48 
 49 const ClassInfo UnlinkedFunctionExecutable::s_info = { &quot;UnlinkedFunctionExecutable&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(UnlinkedFunctionExecutable) };
 50 
 51 static UnlinkedFunctionCodeBlock* generateUnlinkedFunctionCodeBlock(
 52     VM&amp; vm, UnlinkedFunctionExecutable* executable, const SourceCode&amp; source,
 53     CodeSpecializationKind kind, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode,
 54     UnlinkedFunctionKind functionKind, ParserError&amp; error, SourceParseMode parseMode)
 55 {
 56     JSParserBuiltinMode builtinMode = executable-&gt;isBuiltinFunction() ? JSParserBuiltinMode::Builtin : JSParserBuiltinMode::NotBuiltin;
 57     JSParserStrictMode strictMode = executable-&gt;isInStrictContext() ? JSParserStrictMode::Strict : JSParserStrictMode::NotStrict;
 58     JSParserScriptMode scriptMode = executable-&gt;scriptMode();
 59     ASSERT(isFunctionParseMode(executable-&gt;parseMode()));
<span class="line-added"> 60     Vector&lt;JSTextPosition&gt;* instanceFieldLocations = executable-&gt;instanceFieldLocations();</span>
 61     std::unique_ptr&lt;FunctionNode&gt; function = parse&lt;FunctionNode&gt;(
<span class="line-modified"> 62         vm, source, executable-&gt;name(), builtinMode, strictMode, scriptMode, executable-&gt;parseMode(), executable-&gt;superBinding(), error, nullptr, ConstructorKind::None, DerivedContextType::None, EvalContextType::None, nullptr, instanceFieldLocations);</span>
 63 
 64     if (!function) {
 65         ASSERT(error.isValid());
 66         return nullptr;
 67     }
 68 
 69     function-&gt;finishParsing(executable-&gt;name(), executable-&gt;functionMode());
 70     executable-&gt;recordParse(function-&gt;features(), function-&gt;hasCapturedVariables());
 71 
 72     bool isClassContext = executable-&gt;superBinding() == SuperBinding::Needed;
 73 
<span class="line-modified"> 74     UnlinkedFunctionCodeBlock* result = UnlinkedFunctionCodeBlock::create(vm, FunctionCode, ExecutableInfo(function-&gt;usesEval(), function-&gt;isStrictMode(), kind == CodeForConstruct, functionKind == UnlinkedBuiltinFunction, executable-&gt;constructorKind(), scriptMode, executable-&gt;superBinding(), parseMode, executable-&gt;derivedContextType(), executable-&gt;needsClassFieldInitializer(), false, isClassContext, EvalContextType::FunctionEvalContext), codeGenerationMode);</span>
 75 
 76     VariableEnvironment parentScopeTDZVariables = executable-&gt;parentScopeTDZVariables();
 77     error = BytecodeGenerator::generate(vm, function.get(), source, result, codeGenerationMode, &amp;parentScopeTDZVariables);
 78 
 79     if (error.isValid())
 80         return nullptr;
 81     vm.codeCache()-&gt;updateCache(executable, source, kind, result);
 82     return result;
 83 }
 84 
<span class="line-modified"> 85 UnlinkedFunctionExecutable::UnlinkedFunctionExecutable(VM&amp; vm, Structure* structure, const SourceCode&amp; parentSource, FunctionMetadataNode* node, UnlinkedFunctionKind kind, ConstructAbility constructAbility, JSParserScriptMode scriptMode, Optional&lt;CompactVariableMap::Handle&gt; parentScopeTDZVariables, DerivedContextType derivedContextType, NeedsClassFieldInitializer needsClassFieldInitializer, bool isBuiltinDefaultClassConstructor)</span>
 86     : Base(vm, structure)
 87     , m_firstLineOffset(node-&gt;firstLine() - parentSource.firstLine().oneBasedInt())
 88     , m_isInStrictContext(node-&gt;isInStrictContext())
 89     , m_lineCount(node-&gt;lastLine() - node-&gt;firstLine())
 90     , m_hasCapturedVariables(false)
 91     , m_unlinkedFunctionNameStart(node-&gt;functionNameStart() - parentSource.startOffset())
 92     , m_isBuiltinFunction(kind == UnlinkedBuiltinFunction)
 93     , m_unlinkedBodyStartColumn(node-&gt;startColumn())
 94     , m_isBuiltinDefaultClassConstructor(isBuiltinDefaultClassConstructor)
 95     , m_unlinkedBodyEndColumn(m_lineCount ? node-&gt;endColumn() : node-&gt;endColumn() - node-&gt;startColumn())
 96     , m_constructAbility(static_cast&lt;unsigned&gt;(constructAbility))
 97     , m_startOffset(node-&gt;source().startOffset() - parentSource.startOffset())
 98     , m_scriptMode(static_cast&lt;unsigned&gt;(scriptMode))
 99     , m_sourceLength(node-&gt;source().length())
100     , m_superBinding(static_cast&lt;unsigned&gt;(node-&gt;superBinding()))
101     , m_parametersStartOffset(node-&gt;parametersStart())
102     , m_isCached(false)
103     , m_typeProfilingStartOffset(node-&gt;functionKeywordStart())
104     , m_typeProfilingEndOffset(node-&gt;startStartOffset() + node-&gt;source().length() - 1)
105     , m_parameterCount(node-&gt;parameterCount())
106     , m_features(0)
107     , m_sourceParseMode(node-&gt;parseMode())
108     , m_constructorKind(static_cast&lt;unsigned&gt;(node-&gt;constructorKind()))
109     , m_functionMode(static_cast&lt;unsigned&gt;(node-&gt;functionMode()))
110     , m_derivedContextType(static_cast&lt;unsigned&gt;(derivedContextType))
111     , m_isGeneratedFromCache(false)
<span class="line-added">112     , m_needsClassFieldInitializer(static_cast&lt;unsigned&gt;(needsClassFieldInitializer))</span>
113     , m_unlinkedCodeBlockForCall()
114     , m_unlinkedCodeBlockForConstruct()
115     , m_name(node-&gt;ident())
116     , m_ecmaName(node-&gt;ecmaName())
117 {
118     // Make sure these bitfields are adequately wide.
119     ASSERT(m_constructAbility == static_cast&lt;unsigned&gt;(constructAbility));
120     ASSERT(m_constructorKind == static_cast&lt;unsigned&gt;(node-&gt;constructorKind()));
121     ASSERT(m_functionMode == static_cast&lt;unsigned&gt;(node-&gt;functionMode()));
122     ASSERT(m_scriptMode == static_cast&lt;unsigned&gt;(scriptMode));
123     ASSERT(m_superBinding == static_cast&lt;unsigned&gt;(node-&gt;superBinding()));
124     ASSERT(m_derivedContextType == static_cast&lt;unsigned&gt;(derivedContextType));
125     ASSERT(!(m_isBuiltinDefaultClassConstructor &amp;&amp; constructorKind() == ConstructorKind::None));
<span class="line-added">126     ASSERT(!m_needsClassFieldInitializer || (isClassConstructorFunction() || derivedContextType == DerivedContextType::DerivedConstructorContext));</span>
127     if (!node-&gt;classSource().isNull())
128         setClassSource(node-&gt;classSource());
129     if (parentScopeTDZVariables)
130         ensureRareData().m_parentScopeTDZVariables = WTFMove(*parentScopeTDZVariables);
131 }
132 
133 UnlinkedFunctionExecutable::~UnlinkedFunctionExecutable()
134 {
135     if (m_isCached)
136         m_decoder.~RefPtr();
137 }
138 
139 void UnlinkedFunctionExecutable::destroy(JSCell* cell)
140 {
141     static_cast&lt;UnlinkedFunctionExecutable*&gt;(cell)-&gt;~UnlinkedFunctionExecutable();
142 }
143 
144 void UnlinkedFunctionExecutable::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
145 {
146     UnlinkedFunctionExecutable* thisObject = jsCast&lt;UnlinkedFunctionExecutable*&gt;(cell);
</pre>
<hr />
<pre>
175 
176 FunctionExecutable* UnlinkedFunctionExecutable::link(VM&amp; vm, ScriptExecutable* topLevelExecutable, const SourceCode&amp; passedParentSource, Optional&lt;int&gt; overrideLineNumber, Intrinsic intrinsic)
177 {
178     SourceCode source = linkedSourceCode(passedParentSource);
179     FunctionOverrides::OverrideInfo overrideInfo;
180     bool hasFunctionOverride = false;
181     if (UNLIKELY(Options::functionOverrides()))
182         hasFunctionOverride = FunctionOverrides::initializeOverrideFor(source, overrideInfo);
183 
184     FunctionExecutable* result = FunctionExecutable::create(vm, topLevelExecutable, source, this, intrinsic);
185     if (overrideLineNumber)
186         result-&gt;setOverrideLineNumber(*overrideLineNumber);
187 
188     if (UNLIKELY(hasFunctionOverride))
189         result-&gt;overrideInfo(overrideInfo);
190 
191     return result;
192 }
193 
194 UnlinkedFunctionExecutable* UnlinkedFunctionExecutable::fromGlobalCode(
<span class="line-modified">195     const Identifier&amp; name, JSGlobalObject* globalObject, const SourceCode&amp; source,</span>
196     JSObject*&amp; exception, int overrideLineNumber, Optional&lt;int&gt; functionConstructorParametersEndPosition)
197 {
198     ParserError error;
<span class="line-modified">199     VM&amp; vm = globalObject-&gt;vm();</span>

200     CodeCache* codeCache = vm.codeCache();
<span class="line-modified">201     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode = globalObject-&gt;defaultCodeGenerationMode();</span>
202     UnlinkedFunctionExecutable* executable = codeCache-&gt;getUnlinkedGlobalFunctionExecutable(vm, name, source, codeGenerationMode, functionConstructorParametersEndPosition, error);
203 
<span class="line-modified">204     if (globalObject-&gt;hasDebugger())</span>
<span class="line-modified">205         globalObject-&gt;debugger()-&gt;sourceParsed(globalObject, source.provider(), error.line(), error.message());</span>
206 
207     if (error.isValid()) {
<span class="line-modified">208         exception = error.toErrorObject(globalObject, source, overrideLineNumber);</span>
209         return nullptr;
210     }
211 
212     return executable;
213 }
214 
215 UnlinkedFunctionCodeBlock* UnlinkedFunctionExecutable::unlinkedCodeBlockFor(
216     VM&amp; vm, const SourceCode&amp; source, CodeSpecializationKind specializationKind,
217     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, ParserError&amp; error, SourceParseMode parseMode)
218 {
219     if (m_isCached)
220         decodeCachedCodeBlocks(vm);
221     switch (specializationKind) {
222     case CodeForCall:
223         if (UnlinkedFunctionCodeBlock* codeBlock = m_unlinkedCodeBlockForCall.get())
224             return codeBlock;
225         break;
226     case CodeForConstruct:
227         if (UnlinkedFunctionCodeBlock* codeBlock = m_unlinkedCodeBlockForConstruct.get())
228             return codeBlock;
</pre>
</td>
</tr>
</table>
<center><a href="UnlinkedFunctionCodeBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedFunctionExecutable.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
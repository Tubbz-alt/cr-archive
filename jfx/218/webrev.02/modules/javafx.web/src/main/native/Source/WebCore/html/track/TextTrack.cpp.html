<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/track/TextTrack.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011, 2013 Google Inc. All rights reserved.
  3  * Copyright (C) 2011-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;TextTrack.h&quot;
 34 
 35 #if ENABLE(VIDEO_TRACK)
 36 
 37 #include &quot;Document.h&quot;
 38 #include &quot;Event.h&quot;
 39 #include &quot;HTMLMediaElement.h&quot;
 40 #include &quot;SourceBuffer.h&quot;
 41 #include &quot;TextTrackCueList.h&quot;
 42 #include &quot;TextTrackList.h&quot;
 43 #include &quot;VTTRegion.h&quot;
 44 #include &quot;VTTRegionList.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 #include &lt;wtf/NeverDestroyed.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 WTF_MAKE_ISO_ALLOCATED_IMPL(TextTrack);
 51 
 52 const AtomString&amp; TextTrack::subtitlesKeyword()
 53 {
 54     static NeverDestroyed&lt;const AtomString&gt; subtitles(&quot;subtitles&quot;, AtomString::ConstructFromLiteral);
 55     return subtitles;
 56 }
 57 
 58 static const AtomString&amp; captionsKeyword()
 59 {
 60     static NeverDestroyed&lt;const AtomString&gt; captions(&quot;captions&quot;, AtomString::ConstructFromLiteral);
 61     return captions;
 62 }
 63 
 64 static const AtomString&amp; descriptionsKeyword()
 65 {
 66     static NeverDestroyed&lt;const AtomString&gt; descriptions(&quot;descriptions&quot;, AtomString::ConstructFromLiteral);
 67     return descriptions;
 68 }
 69 
 70 static const AtomString&amp; chaptersKeyword()
 71 {
 72     static NeverDestroyed&lt;const AtomString&gt; chapters(&quot;chapters&quot;, AtomString::ConstructFromLiteral);
 73     return chapters;
 74 }
 75 
 76 static const AtomString&amp; metadataKeyword()
 77 {
 78     static NeverDestroyed&lt;const AtomString&gt; metadata(&quot;metadata&quot;, AtomString::ConstructFromLiteral);
 79     return metadata;
 80 }
 81 
 82 static const AtomString&amp; forcedKeyword()
 83 {
 84     static NeverDestroyed&lt;const AtomString&gt; forced(&quot;forced&quot;, AtomString::ConstructFromLiteral);
 85     return forced;
 86 }
 87 
 88 TextTrack* TextTrack::captionMenuOffItem()
 89 {
 90     static TextTrack&amp; off = TextTrack::create(nullptr, nullptr, &quot;off menu item&quot;, emptyAtom(), emptyAtom(), emptyAtom()).leakRef();
 91     return &amp;off;
 92 }
 93 
 94 TextTrack* TextTrack::captionMenuAutomaticItem()
 95 {
 96     static TextTrack&amp; automatic = TextTrack::create(nullptr, nullptr, &quot;automatic menu item&quot;, emptyAtom(), emptyAtom(), emptyAtom()).leakRef();
 97     return &amp;automatic;
 98 }
 99 
100 TextTrack::TextTrack(ScriptExecutionContext* context, TextTrackClient* client, const AtomString&amp; kind, const AtomString&amp; id, const AtomString&amp; label, const AtomString&amp; language, TextTrackType type)
101     : TrackBase(TrackBase::TextTrack, id, label, language)
102     , ContextDestructionObserver(context)
103     , m_client(client)
104     , m_trackType(type)
105 {
106     if (kind == captionsKeyword())
107         m_kind = Kind::Captions;
108     else if (kind == chaptersKeyword())
109         m_kind = Kind::Chapters;
110     else if (kind == descriptionsKeyword())
111         m_kind = Kind::Descriptions;
112     else if (kind == forcedKeyword())
113         m_kind = Kind::Forced;
114     else if (kind == metadataKeyword())
115         m_kind = Kind::Metadata;
116 }
117 
118 TextTrack::~TextTrack()
119 {
120     if (m_cues) {
121         if (m_client)
122             m_client-&gt;textTrackRemoveCues(*this, *m_cues);
123         for (size_t i = 0; i &lt; m_cues-&gt;length(); ++i)
124             m_cues-&gt;item(i)-&gt;setTrack(nullptr);
125     }
126     if (m_regions) {
127         for (size_t i = 0; i &lt; m_regions-&gt;length(); ++i)
128             m_regions-&gt;item(i)-&gt;setTrack(nullptr);
129     }
130 }
131 
132 bool TextTrack::enabled() const
133 {
134     return m_mode != Mode::Disabled;
135 }
136 
137 bool TextTrack::isValidKindKeyword(const AtomString&amp; value)
138 {
139     if (value == subtitlesKeyword())
140         return true;
141     if (value == captionsKeyword())
142         return true;
143     if (value == descriptionsKeyword())
144         return true;
145     if (value == chaptersKeyword())
146         return true;
147     if (value == metadataKeyword())
148         return true;
149     if (value == forcedKeyword())
150         return true;
151 
152     return false;
153 }
154 
155 const AtomString&amp; TextTrack::kindKeyword() const
156 {
157     switch (m_kind) {
158     case Kind::Captions:
159         return captionsKeyword();
160     case Kind::Chapters:
161         return chaptersKeyword();
162     case Kind::Descriptions:
163         return descriptionsKeyword();
164     case Kind::Forced:
165         return forcedKeyword();
166     case Kind::Metadata:
167         return metadataKeyword();
168     case Kind::Subtitles:
169         return subtitlesKeyword();
170     }
171     ASSERT_NOT_REACHED();
172     return subtitlesKeyword();
173 }
174 
175 void TextTrack::setKind(Kind newKind)
176 {
177     auto oldKind = m_kind;
178 
179     // 10.1 kind, on setting:
180     // 1. If the value being assigned to this attribute does not match one of the text track kinds,
181     // then abort these steps.
182 
183     // 2. Update this attribute to the new value.
184     m_kind = newKind;
185 
186 #if ENABLE(MEDIA_SOURCE)
187     // 3. If the sourceBuffer attribute on this track is not null, then queue a task to fire a simple
188     // event named change at sourceBuffer.textTracks.
189     if (m_sourceBuffer)
190         m_sourceBuffer-&gt;textTracks().scheduleChangeEvent();
191 
192     // 4. Queue a task to fire a simple event named change at the TextTrackList object referenced by
193     // the textTracks attribute on the HTMLMediaElement.
194     if (mediaElement())
195         mediaElement()-&gt;ensureTextTracks().scheduleChangeEvent();
196 #endif
197 
198     if (m_client &amp;&amp; oldKind != m_kind)
199         m_client-&gt;textTrackKindChanged(*this);
200 }
201 
202 void TextTrack::setKindKeywordIgnoringASCIICase(StringView keyword)
203 {
204     if (keyword.isNull()) {
205         // The missing value default is the subtitles state.
206         setKind(Kind::Subtitles);
207         return;
208     }
209     if (equalLettersIgnoringASCIICase(keyword, &quot;captions&quot;))
210         setKind(Kind::Captions);
211     else if (equalLettersIgnoringASCIICase(keyword, &quot;chapters&quot;))
212         setKind(Kind::Chapters);
213     else if (equalLettersIgnoringASCIICase(keyword, &quot;descriptions&quot;))
214         setKind(Kind::Descriptions);
215     else if (equalLettersIgnoringASCIICase(keyword, &quot;forced&quot;))
216         setKind(Kind::Forced);
217     else if (equalLettersIgnoringASCIICase(keyword, &quot;metadata&quot;))
218         setKind(Kind::Metadata);
219     else if (equalLettersIgnoringASCIICase(keyword, &quot;subtitles&quot;))
220         setKind(Kind::Subtitles);
221     else {
222         // The invalid value default is the metadata state.
223         setKind(Kind::Metadata);
224     }
225 }
226 
227 void TextTrack::setMode(Mode mode)
228 {
229     // On setting, if the new value isn&#39;t equal to what the attribute would currently
230     // return, the new value must be processed as follows ...
231     if (m_mode == mode)
232         return;
233 
234     // If mode changes to disabled, remove this track&#39;s cues from the client
235     // because they will no longer be accessible from the cues() function.
236     if (mode == Mode::Disabled &amp;&amp; m_client &amp;&amp; m_cues)
237         m_client-&gt;textTrackRemoveCues(*this, *m_cues);
238 
239     if (mode != Mode::Showing &amp;&amp; m_cues) {
240         for (size_t i = 0; i &lt; m_cues-&gt;length(); ++i)
241             m_cues-&gt;item(i)-&gt;removeDisplayTree();
242     }
243 
244     m_mode = mode;
245 
246     if (m_client)
247         m_client-&gt;textTrackModeChanged(*this);
248 }
249 
250 TextTrackCueList* TextTrack::cues()
251 {
252     // 4.8.10.12.5 If the text track mode ... is not the text track disabled mode,
253     // then the cues attribute must return a live TextTrackCueList object ...
254     // Otherwise, it must return null. When an object is returned, the
255     // same object must be returned each time.
256     // http://www.whatwg.org/specs/web-apps/current-work/#dom-texttrack-cues
257     if (m_mode == Mode::Disabled)
258         return nullptr;
259     return &amp;ensureTextTrackCueList();
260 }
261 
262 void TextTrack::removeAllCues()
263 {
264     if (!m_cues)
265         return;
266 
267     if (m_client)
268         m_client-&gt;textTrackRemoveCues(*this, *m_cues);
269 
270     for (size_t i = 0; i &lt; m_cues-&gt;length(); ++i)
271         m_cues-&gt;item(i)-&gt;setTrack(nullptr);
272 
273     m_cues-&gt;clear();
274 }
275 
276 TextTrackCueList* TextTrack::activeCues() const
277 {
278     // 4.8.10.12.5 If the text track mode ... is not the text track disabled mode,
279     // then the activeCues attribute must return a live TextTrackCueList object ...
280     // ... whose active flag was set when the script started, in text track cue
281     // order. Otherwise, it must return null. When an object is returned, the
282     // same object must be returned each time.
283     // http://www.whatwg.org/specs/web-apps/current-work/#dom-texttrack-activecues
284     if (!m_cues || m_mode == Mode::Disabled)
285         return nullptr;
286     return &amp;m_cues-&gt;activeCues();
287 }
288 
289 ExceptionOr&lt;void&gt; TextTrack::addCue(Ref&lt;TextTrackCue&gt;&amp;&amp; cue)
290 {
291     // 4.7.10.12.6 Text tracks exposing in-band metadata
292     // The UA will use DataCue to expose only text track cue objects that belong to a text track that has a text
293     // track kind of metadata.
294     // If a DataCue is added to a TextTrack via the addCue() method but the text track does not have its text
295     // track kind set to metadata, throw a InvalidNodeTypeError exception and don&#39;t add the cue to the TextTrackList
296     // of the TextTrack.
297     if (cue-&gt;cueType() == TextTrackCue::Data &amp;&amp; m_kind != Kind::Metadata)
298         return Exception { InvalidNodeTypeError };
299 
300     // TODO(93143): Add spec-compliant behavior for negative time values.
301     if (!cue-&gt;startMediaTime().isValid() || !cue-&gt;endMediaTime().isValid() || cue-&gt;startMediaTime() &lt; MediaTime::zeroTime() || cue-&gt;endMediaTime() &lt; MediaTime::zeroTime())
302         return { };
303 
304     // 4.8.10.12.5 Text track API
305 
306     // The addCue(cue) method of TextTrack objects, when invoked, must run the following steps:
307 
308     auto cueTrack = makeRefPtr(cue-&gt;track());
309     if (cueTrack == this)
310         return { };
311 
312     // 1. If the given cue is in a text track list of cues, then remove cue from that text track
313     // list of cues.
314     if (cueTrack)
315         cueTrack-&gt;removeCue(cue.get());
316 
317     // 2. Add cue to the method&#39;s TextTrack object&#39;s text track&#39;s text track list of cues.
318     cue-&gt;setTrack(this);
319     ensureTextTrackCueList().add(cue.copyRef());
320 
321     if (m_client)
322         m_client-&gt;textTrackAddCue(*this, cue);
323 
324     return { };
325 }
326 
327 ExceptionOr&lt;void&gt; TextTrack::removeCue(TextTrackCue&amp; cue)
328 {
329     // 4.8.10.12.5 Text track API
330 
331     // The removeCue(cue) method of TextTrack objects, when invoked, must run the following steps:
332 
333     // 1. If the given cue is not currently listed in the method&#39;s TextTrack
334     // object&#39;s text track&#39;s text track list of cues, then throw a NotFoundError exception.
335     if (cue.track() != this)
336         return Exception { NotFoundError };
337     if (!m_cues)
338         return Exception { InvalidStateError };
339 
340     INFO_LOG(LOGIDENTIFIER, cue);
341 
342     // 2. Remove cue from the method&#39;s TextTrack object&#39;s text track&#39;s text track list of cues.
343     m_cues-&gt;remove(cue);
344     cue.setIsActive(false);
345     cue.setTrack(nullptr);
346     if (m_client)
347         m_client-&gt;textTrackRemoveCue(*this, cue);
348 
349     return { };
350 }
351 
352 VTTRegionList&amp; TextTrack::ensureVTTRegionList()
353 {
354     if (!m_regions)
355         m_regions = VTTRegionList::create();
356 
357     return *m_regions;
358 }
359 
360 VTTRegionList* TextTrack::regions()
361 {
362     // If the text track mode of the text track that the TextTrack object
363     // represents is not the text track disabled mode, then the regions
364     // attribute must return a live VTTRegionList object that represents
365     // the text track list of regions of the text track. Otherwise, it must
366     // return null. When an object is returned, the same object must be returned
367     // each time.
368     if (m_mode == Mode::Disabled)
369         return nullptr;
370     return &amp;ensureVTTRegionList();
371 }
372 
373 void TextTrack::addRegion(RefPtr&lt;VTTRegion&gt;&amp;&amp; region)
374 {
375     if (!region)
376         return;
377 
378     auto&amp; regionList = ensureVTTRegionList();
379 
380     // 1. If the given region is in a text track list of regions, then remove
381     // region from that text track list of regions.
382     auto regionTrack = makeRefPtr(region-&gt;track());
383     if (regionTrack &amp;&amp; regionTrack != this)
384         regionTrack-&gt;removeRegion(region.get());
385 
386     // 2. If the method&#39;s TextTrack object&#39;s text track list of regions contains
387     // a region with the same identifier as region replace the values of that
388     // region&#39;s width, height, anchor point, viewport anchor point and scroll
389     // attributes with those of region.
390     auto existingRegion = makeRefPtr(regionList.getRegionById(region-&gt;id()));
391     if (existingRegion) {
392         existingRegion-&gt;updateParametersFromRegion(*region);
393         return;
394     }
395 
396     // Otherwise: add region to the method&#39;s TextTrack object&#39;s text track list of regions.
397     region-&gt;setTrack(this);
398     regionList.add(region.releaseNonNull());
399 }
400 
401 ExceptionOr&lt;void&gt; TextTrack::removeRegion(VTTRegion* region)
402 {
403     if (!region)
404         return { };
405 
406     // 1. If the given region is not currently listed in the method&#39;s TextTrack
407     // object&#39;s text track list of regions, then throw a NotFoundError exception.
408     if (region-&gt;track() != this)
409         return Exception { NotFoundError };
410 
411     ASSERT(m_regions);
412     m_regions-&gt;remove(*region);
413     region-&gt;setTrack(nullptr);
414     return { };
415 }
416 
417 void TextTrack::cueWillChange(TextTrackCue* cue)
418 {
419     if (!m_client)
420         return;
421 
422     // The cue may need to be repositioned in the media element&#39;s interval tree, may need to
423     // be re-rendered, etc, so remove it before the modification...
424     m_client-&gt;textTrackRemoveCue(*this, *cue);
425 }
426 
427 void TextTrack::cueDidChange(TextTrackCue* cue)
428 {
429     if (!m_client)
430         return;
431 
432     // Make sure the TextTrackCueList order is up-to-date.
433     ensureTextTrackCueList().updateCueIndex(*cue);
434 
435     // ... and add it back again.
436     m_client-&gt;textTrackAddCue(*this, *cue);
437 }
438 
439 int TextTrack::trackIndex()
440 {
441     if (!m_trackIndex) {
442         if (!m_mediaElement)
443             return 0;
444         m_trackIndex = m_mediaElement-&gt;ensureTextTracks().getTrackIndex(*this);
445     }
446     return m_trackIndex.value();
447 }
448 
449 void TextTrack::invalidateTrackIndex()
450 {
451     m_trackIndex = WTF::nullopt;
452     m_renderedTrackIndex = WTF::nullopt;
453 }
454 
455 bool TextTrack::isRendered()
456 {
457     return (m_kind == Kind::Captions || m_kind == Kind::Subtitles || m_kind == Kind::Forced)
458         &amp;&amp; m_mode == Mode::Showing;
459 }
460 
461 TextTrackCueList&amp; TextTrack::ensureTextTrackCueList()
462 {
463     if (!m_cues)
464         m_cues = TextTrackCueList::create();
465     return *m_cues;
466 }
467 
468 int TextTrack::trackIndexRelativeToRenderedTracks()
469 {
470     if (!m_renderedTrackIndex) {
471         if (!m_mediaElement)
472             return 0;
473         m_renderedTrackIndex = m_mediaElement-&gt;ensureTextTracks().getTrackIndexRelativeToRenderedTracks(*this);
474     }
475     return m_renderedTrackIndex.value();
476 }
477 
478 bool TextTrack::hasCue(TextTrackCue* cue, TextTrackCue::CueMatchRules match)
479 {
480     if (cue-&gt;startMediaTime() &lt; MediaTime::zeroTime() || cue-&gt;endMediaTime() &lt; MediaTime::zeroTime())
481         return false;
482 
483     if (!m_cues || !m_cues-&gt;length())
484         return false;
485 
486     size_t searchStart = 0;
487     size_t searchEnd = m_cues-&gt;length();
488 
489     while (1) {
490         ASSERT(searchStart &lt;= m_cues-&gt;length());
491         ASSERT(searchEnd &lt;= m_cues-&gt;length());
492 
493         RefPtr&lt;TextTrackCue&gt; existingCue;
494 
495         // Cues in the TextTrackCueList are maintained in start time order.
496         if (searchStart == searchEnd) {
497             if (!searchStart)
498                 return false;
499 
500             // If there is more than one cue with the same start time, back up to first one so we
501             // consider all of them.
502             while (searchStart &gt;= 2 &amp;&amp; cue-&gt;hasEquivalentStartTime(*m_cues-&gt;item(searchStart - 2)))
503                 --searchStart;
504 
505             bool firstCompare = true;
506             while (1) {
507                 if (!firstCompare)
508                     ++searchStart;
509                 firstCompare = false;
510                 if (searchStart &gt; m_cues-&gt;length())
511                     return false;
512 
513                 existingCue = m_cues-&gt;item(searchStart - 1);
514                 if (!existingCue)
515                     return false;
516 
517                 if (cue-&gt;startMediaTime() &gt; (existingCue-&gt;startMediaTime() + startTimeVariance()))
518                     return false;
519 
520                 if (existingCue-&gt;isEqual(*cue, match))
521                     return true;
522             }
523         }
524 
525         size_t index = (searchStart + searchEnd) / 2;
526         existingCue = m_cues-&gt;item(index);
527         if ((cue-&gt;startMediaTime() + startTimeVariance()) &lt; existingCue-&gt;startMediaTime() || (match != TextTrackCue::IgnoreDuration &amp;&amp; cue-&gt;hasEquivalentStartTime(*existingCue) &amp;&amp; cue-&gt;endMediaTime() &gt; existingCue-&gt;endMediaTime()))
528             searchEnd = index;
529         else
530             searchStart = index + 1;
531     }
532 
533     ASSERT_NOT_REACHED();
534     return false;
535 }
536 
537 bool TextTrack::isMainProgramContent() const
538 {
539     // &quot;Main program&quot; content is intrinsic to the presentation of the media file, regardless of locale. Content such as
540     // directors commentary is not &quot;main program&quot; because it is not essential for the presentation. HTML5 doesn&#39;t have
541     // a way to express this in a machine-reable form, it is typically done with the track label, so we assume that caption
542     // tracks are main content and all other track types are not.
543     return m_kind == Kind::Captions;
544 }
545 
546 bool TextTrack::containsOnlyForcedSubtitles() const
547 {
548     return m_kind == Kind::Forced;
549 }
550 
551 #if ENABLE(MEDIA_SOURCE)
552 void TextTrack::setLanguage(const AtomString&amp; language)
553 {
554     // 11.1 language, on setting:
555     // 1. If the value being assigned to this attribute is not an empty string or a BCP 47 language
556     // tag[BCP47], then abort these steps.
557     // BCP 47 validation is done in TrackBase::setLanguage() which is
558     // shared between all tracks that support setting language.
559 
560     // 2. Update this attribute to the new value.
561     TrackBase::setLanguage(language);
562 
563     // 3. If the sourceBuffer attribute on this track is not null, then queue a task to fire a simple
564     // event named change at sourceBuffer.textTracks.
565     if (m_sourceBuffer)
566         m_sourceBuffer-&gt;textTracks().scheduleChangeEvent();
567 
568     // 4. Queue a task to fire a simple event named change at the TextTrackList object referenced by
569     // the textTracks attribute on the HTMLMediaElement.
570     if (mediaElement())
571         mediaElement()-&gt;ensureTextTracks().scheduleChangeEvent();
572 }
573 #endif
574 
575 } // namespace WebCore
576 
577 #endif
    </pre>
  </body>
</html>
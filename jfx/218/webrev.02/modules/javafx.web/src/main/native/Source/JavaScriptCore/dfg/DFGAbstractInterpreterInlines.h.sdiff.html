<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGAbstractInterpreter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
<span class="line-modified">  36 #include &quot;GetByIdStatus.h&quot;</span>
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;


  40 #include &quot;JSImmutableButterfly.h&quot;



  41 #include &quot;MathCommon.h&quot;
  42 #include &quot;NumberConstructor.h&quot;
  43 #include &quot;Operations.h&quot;
  44 #include &quot;PutByIdStatus.h&quot;
  45 #include &quot;StringObject.h&quot;
  46 #include &quot;StructureCache.h&quot;
  47 #include &quot;StructureRareDataInlines.h&quot;
  48 #include &lt;wtf/BooleanLattice.h&gt;
  49 #include &lt;wtf/CheckedArithmetic.h&gt;
  50 
  51 namespace JSC { namespace DFG {
  52 
  53 template&lt;typename AbstractStateType&gt;
  54 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  55     : m_codeBlock(graph.m_codeBlock)
  56     , m_graph(graph)
  57     , m_vm(m_graph.m_vm)
  58     , m_state(state)
  59 {
  60     if (m_graph.m_form == SSA)
  61         m_phiChildren = makeUnique&lt;PhiChildren&gt;(m_graph);
  62 }
  63 
  64 template&lt;typename AbstractStateType&gt;
  65 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  66 {
  67 }
  68 
  69 template&lt;typename AbstractStateType&gt;
  70 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  71 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  72     Node* node, AbstractValue&amp; value)
  73 {
  74     JSValue childConst = value.value();
  75     if (childConst) {
<span class="line-modified">  76         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;globalExec()))</span>
  77             return DefinitelyTrue;
  78         return DefinitelyFalse;
  79     }
  80 
  81     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
  82     if (isCellSpeculation(value.m_type) &amp;&amp; !value.m_structure.isTop()) {
  83         bool allTrue = true;
  84         for (unsigned i = value.m_structure.size(); i--;) {
  85             RegisteredStructure structure = value.m_structure[i];
  86             if (structure-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
  87                 || structure-&gt;typeInfo().type() == StringType) {
  88                 allTrue = false;
  89                 break;
  90             }
  91         }
  92         if (allTrue)
  93             return DefinitelyTrue;
  94     }
  95 
  96     return UnknownBooleanResult;
</pre>
<hr />
<pre>
 240     JSValue right = forNode(node-&gt;child2()).value();
 241     if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 242         int32_t a = left.asInt32();
 243         int32_t b = right.asInt32();
 244         if (node-&gt;isBinaryUseKind(UntypedUse))
 245             didFoldClobberWorld();
 246         NodeType op = node-&gt;op();
 247         switch (op) {
 248         case ValueBitAnd:
 249         case ArithBitAnd:
 250             setConstant(node, JSValue(a &amp; b));
 251             break;
 252         case ValueBitOr:
 253         case ArithBitOr:
 254             setConstant(node, JSValue(a | b));
 255             break;
 256         case ValueBitXor:
 257         case ArithBitXor:
 258             setConstant(node, JSValue(a ^ b));
 259             break;
<span class="line-modified"> 260         case BitRShift:</span>

 261             setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
 262             break;
 263         case ValueBitLShift:
 264         case ArithBitLShift:
 265             setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
 266             break;
 267         case BitURShift:
 268             setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));
 269             break;
 270         default:
 271             RELEASE_ASSERT_NOT_REACHED();
 272             break;
 273         }
 274 
 275         return true;
 276     }
 277 
 278     return false;
 279 }
 280 
</pre>
<hr />
<pre>
 300                 doubleResult = fmod(left.asNumber(), right.asNumber());
 301 
 302             if (node-&gt;hasArithMode()) {
 303                 if (!shouldCheckOverflow(node-&gt;arithMode()))
 304                     doubleResult = toInt32(doubleResult);
 305                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 306                     doubleResult += 0; // Sanitizes zero.
 307             }
 308 
 309             JSValue valueResult = jsNumber(doubleResult);
 310             if (valueResult.isInt32()) {
 311                 if (isClobbering)
 312                     didFoldClobberWorld();
 313                 setConstant(node, valueResult);
 314                 return true;
 315             }
 316         } else if (left.isNumber() &amp;&amp; right.isNumber()) {
 317             if (isClobbering)
 318                 didFoldClobberWorld();
 319 
<span class="line-modified"> 320             if (isDivOperation)</span>
<span class="line-modified"> 321                 setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-modified"> 322             else</span>
<span class="line-modified"> 323                 setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>







 324 
 325             return true;
 326         }
 327     }
 328 
 329     return false;
 330 }
 331 
 332 template&lt;typename AbstractStateType&gt;
 333 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 334 {
 335     verifyEdges(node);
 336 
 337     m_state.createValueForNode(node);
 338 
 339     switch (node-&gt;op()) {
 340     case JSConstant:
 341     case DoubleConstant:
 342     case Int52Constant: {
 343         setBuiltInConstant(node, *node-&gt;constant());
</pre>
<hr />
<pre>
 346 
 347     case LazyJSConstant: {
 348         LazyJSValue value = node-&gt;lazyJSValue();
 349         switch (value.kind()) {
 350         case LazyJSValue::KnownValue:
 351             setConstant(node, value.value()-&gt;value());
 352             break;
 353         case LazyJSValue::SingleCharacterString:
 354         case LazyJSValue::KnownStringImpl:
 355         case LazyJSValue::NewStringImpl:
 356             setTypeForNode(node, SpecString);
 357             break;
 358         }
 359         break;
 360     }
 361 
 362     case IdentityWithProfile:
 363     case Identity: {
 364         setForNode(node, forNode(node-&gt;child1()));
 365         if (forNode(node).value())
<span class="line-modified"> 366             m_state.setFoundConstants(true);</span>
 367         break;
 368     }
 369 
 370     case ExtractCatchLocal:
 371     case ExtractOSREntryLocal: {
 372         makeBytecodeTopForNode(node);
 373         break;
 374     }
 375 
 376     case GetLocal: {
 377         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
<span class="line-modified"> 378         AbstractValue value = m_state.operand(variableAccessData-&gt;local().offset());</span>
 379         // The value in the local should already be checked.
 380         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
 381         if (value.value())
<span class="line-modified"> 382             m_state.setFoundConstants(true);</span>
 383         setForNode(node, value);
 384         break;
 385     }
 386 
 387     case GetStack: {
 388         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified"> 389         AbstractValue value = m_state.operand(data-&gt;local);</span>
 390         // The value in the local should already be checked.
 391         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
 392         if (value.value())
<span class="line-modified"> 393             m_state.setFoundConstants(true);</span>
 394         setForNode(node, value);
 395         break;
 396     }
 397 
 398     case SetLocal: {
<span class="line-modified"> 399         m_state.operand(node-&gt;local()) = forNode(node-&gt;child1());</span>
 400         break;
 401     }
 402 
 403     case PutStack: {
<span class="line-modified"> 404         m_state.operand(node-&gt;stackAccessData()-&gt;local) = forNode(node-&gt;child1());</span>
 405         break;
 406     }
 407 
 408     case MovHint: {
 409         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 410         // in bytecode, but this code is just concerned with what is actually happening during
 411         // DFG execution.
 412         break;
 413     }
 414 
 415     case KillStack: {
 416         // This is just a hint telling us that the OSR state of the local is no longer inside the
 417         // flushed data.
 418         break;
 419     }
 420 
 421     case SetArgumentDefinitely:
 422     case SetArgumentMaybe:
 423         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means
 424         // that someone set the argument values out-of-band, and currently this always means setting to a
 425         // non-clear value.
<span class="line-modified"> 426         ASSERT(!m_state.operand(node-&gt;local()).isClear());</span>
 427         break;
 428 
 429     case InitializeEntrypointArguments: {
 430         unsigned entrypointIndex = node-&gt;entrypointIndex();
 431         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 432         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 433             AbstractValue&amp; value = m_state.argument(argument);
 434             switch (argumentFormats[argument]) {
 435             case FlushedInt32:
 436                 value.setNonCellType(SpecInt32Only);
 437                 break;
 438             case FlushedBoolean:
 439                 value.setNonCellType(SpecBoolean);
 440                 break;
 441             case FlushedCell:
 442                 value.setType(m_graph, SpecCellCheck);
 443                 break;
 444             case FlushedJSValue:
 445                 value.makeBytecodeTop();
 446                 break;
 447             default:
 448                 DFG_CRASH(m_graph, node, &quot;Bad flush format for argument&quot;);
 449                 break;
 450             }
 451         }
 452         break;
 453     }
 454 






 455     case LoadVarargs:
 456     case ForwardVarargs: {
 457         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 458         // itself into a straight-line sequence of GetStack/PutStack.
 459         // https://bugs.webkit.org/show_bug.cgi?id=143071
 460         switch (node-&gt;op()) {
 461         case LoadVarargs:
 462             clobberWorld();
 463             break;
 464         case ForwardVarargs:
 465             break;
 466         default:
 467             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 468             break;
 469         }
 470         LoadVarargsData* data = node-&gt;loadVarargsData();
 471         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 472         for (unsigned i = data-&gt;limit - 1; i--;)
<span class="line-modified"> 473             m_state.operand(data-&gt;start.offset() + i).makeHeapTop();</span>
 474         break;
 475     }
 476 
 477     case ValueBitNot: {
 478         JSValue operand = forNode(node-&gt;child1()).value();
 479         if (operand &amp;&amp; operand.isInt32()) {
 480             didFoldClobberWorld();
 481             int32_t a = operand.asInt32();
 482             setConstant(node, JSValue(~a));
 483             break;
 484         }
 485 
 486         if (node-&gt;child1().useKind() == BigIntUse)
 487             setTypeForNode(node, SpecBigInt);
 488         else {
 489             clobberWorld();
 490             setTypeForNode(node, SpecInt32Only | SpecBigInt);
 491         }
 492 
 493         break;
 494     }
 495 
 496     case ArithBitNot: {
 497         JSValue operand = forNode(node-&gt;child1()).value();
 498         if (operand &amp;&amp; operand.isInt32()) {
 499             int32_t a = operand.asInt32();
 500             setConstant(node, JSValue(~a));
 501             break;
 502         }
 503 
 504         setNonCellTypeForNode(node, SpecInt32Only);
 505         break;
 506     }
 507 
 508     case ValueBitXor:
 509     case ValueBitAnd:
 510     case ValueBitOr:

 511     case ValueBitLShift: {
 512         if (handleConstantBinaryBitwiseOp(node))
 513             break;
 514 
 515         if (node-&gt;binaryUseKind() == BigIntUse)
 516             setTypeForNode(node, SpecBigInt);
 517         else {
 518             clobberWorld();
 519             setTypeForNode(node, SpecInt32Only | SpecBigInt);
 520         }
 521         break;
 522     }
 523 
 524     case ArithBitAnd:
 525     case ArithBitOr:
 526     case ArithBitXor:
<span class="line-modified"> 527     case BitRShift:</span>
 528     case ArithBitLShift:
 529     case BitURShift: {
 530         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 531             clobberWorld();
 532             setNonCellTypeForNode(node, SpecInt32Only);
 533             break;
 534         }
 535 
 536         if (handleConstantBinaryBitwiseOp(node))
 537             break;
 538 
 539         if (node-&gt;op() == ArithBitAnd
 540             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 541                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 542             setNonCellTypeForNode(node, SpecBoolInt32);
 543             break;
 544         }
 545 
 546         setNonCellTypeForNode(node, SpecInt32Only);
 547         break;
</pre>
<hr />
<pre>
 573                 setConstant(node, jsNumber(value));
 574                 break;
 575             }
 576         }
 577         setNonCellTypeForNode(node, SpecInt32Only);
 578         break;
 579     }
 580 
 581     case BooleanToNumber: {
 582         JSValue concreteValue = forNode(node-&gt;child1()).value();
 583         if (concreteValue) {
 584             if (concreteValue.isBoolean())
 585                 setConstant(node, jsNumber(concreteValue.asBoolean()));
 586             else
 587                 setConstant(node, *m_graph.freeze(concreteValue));
 588             break;
 589         }
 590         AbstractValue&amp; value = forNode(node);
 591         value = forNode(node-&gt;child1());
 592         if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
<span class="line-modified"> 593             m_state.setFoundConstants(true);</span>
 594         if (value.m_type &amp; SpecBoolean) {
 595             value.merge(SpecBoolInt32);
 596             value.filter(~SpecBoolean);
 597         }
 598         break;
 599     }
 600 
 601     case DoubleAsInt32: {
 602         JSValue child = forNode(node-&gt;child1()).value();
 603         if (child &amp;&amp; child.isNumber()) {
 604             double asDouble = child.asNumber();
 605             int32_t asInt = JSC::toInt32(asDouble);
 606             if (bitwise_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(asInt)) == bitwise_cast&lt;int64_t&gt;(asDouble)) {
 607                 setConstant(node, JSValue(asInt));
 608                 break;
 609             }
 610         }
 611         setNonCellTypeForNode(node, SpecInt32Only);
 612         break;
 613     }
</pre>
<hr />
<pre>
 795         break;
 796     }
 797 
 798     case MakeRope: {
 799         unsigned numberOfRemovedChildren = 0;
 800         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 801             Edge&amp; edge = node-&gt;children.child(i);
 802             if (!edge)
 803                 break;
 804             JSValue childConstant = m_state.forNode(edge).value();
 805             if (!childConstant)
 806                 continue;
 807             if (!childConstant.isString())
 808                 continue;
 809             if (asString(childConstant)-&gt;length())
 810                 continue;
 811             ++numberOfRemovedChildren;
 812         }
 813 
 814         if (numberOfRemovedChildren)
<span class="line-modified"> 815             m_state.setFoundConstants(true);</span>
 816         setForNode(node, m_vm.stringStructure.get());
 817         break;
 818     }
 819 
 820     case ArithSub: {
 821         JSValue left = forNode(node-&gt;child1()).value();
 822         JSValue right = forNode(node-&gt;child2()).value();
 823         switch (node-&gt;binaryUseKind()) {
 824         case Int32Use:
 825             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 826                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 827                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 828                     break;
 829                 }
 830                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 831                 if (result.isInt32()) {
 832                     setConstant(node, result);
 833                     break;
 834                 }
 835             }
</pre>
<hr />
<pre>
 907                 }
 908             }
 909             setNonCellTypeForNode(node, SpecInt52Any);
 910             break;
 911         case DoubleRepUse:
 912             if (child &amp;&amp; child.isNumber()) {
 913                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 914                 break;
 915             }
 916             setNonCellTypeForNode(node,
 917                 typeOfDoubleNegation(
 918                     forNode(node-&gt;child1()).m_type));
 919             break;
 920         default:
 921             RELEASE_ASSERT_NOT_REACHED();
 922             break;
 923         }
 924         break;
 925     }
 926 

























 927     case ValuePow: {
 928         JSValue childX = forNode(node-&gt;child1()).value();
 929         JSValue childY = forNode(node-&gt;child2()).value();
 930         if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {
 931             // We need to call `didFoldClobberWorld` here because this path is only possible
 932             // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be
 933             // cleared by `AbstractInterpreter::executeEffects`.
 934             didFoldClobberWorld();
<span class="line-modified"> 935             setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>

 936             break;
 937         }
 938 
 939         if (node-&gt;binaryUseKind() == BigIntUse)
 940             setTypeForNode(node, SpecBigInt);
 941         else {
 942             clobberWorld();
 943             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 944         }
 945         break;
 946     }
 947 
 948     case ValueMul: {
 949         if (node-&gt;binaryUseKind() == BigIntUse)
 950             setTypeForNode(node, SpecBigInt);
 951         else {
 952             clobberWorld();
 953             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 954         }
 955         break;
</pre>
<hr />
<pre>
1246                 // Although C++ code uses uint32_t for the hash, the closest type in DFG IR is Int32
1247                 // and that&#39;s what MapHash returns. So, we have to cast to int32_t to avoid large
1248                 // unsigned values becoming doubles. This casting between signed and unsigned
1249                 // happens in the assembly code we emit when we don&#39;t constant fold this node.
1250                 setConstant(node, jsNumber(static_cast&lt;int32_t&gt;(*hash)));
1251                 break;
1252             }
1253         }
1254         setNonCellTypeForNode(node, SpecInt32Only);
1255         break;
1256     }
1257 
1258     case NormalizeMapKey: {
1259         if (JSValue key = forNode(node-&gt;child1()).value()) {
1260             setConstant(node, *m_graph.freeze(normalizeMapKey(key)));
1261             break;
1262         }
1263 
1264         SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
1265         if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
<span class="line-modified">1266             m_state.setFoundConstants(true);</span>
1267             forNode(node) = forNode(node-&gt;child1());
1268             break;
1269         }
1270 
1271         makeHeapTopForNode(node);
1272         break;
1273     }
1274 
1275     case StringValueOf: {
1276         clobberWorld();
1277         setTypeForNode(node, SpecString);
1278         break;
1279     }
1280 
1281     case StringSlice: {
1282         setTypeForNode(node, SpecString);
1283         break;
1284     }
1285 
1286     case ToLowerCase: {
</pre>
<hr />
<pre>
1395                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1396                         constantWasSet = false;
1397                     }
1398                 } else
1399                     setConstant(node, jsBoolean(false));
1400                 break;
1401             case IsEmpty:
1402                 setConstant(node, jsBoolean(child.value().isEmpty()));
1403                 break;
1404             case IsTypedArrayView:
1405                 setConstant(node, jsBoolean(child.value().isObject() &amp;&amp; isTypedView(child.value().getObject()-&gt;classInfo(m_vm)-&gt;typedArrayStorageType)));
1406                 break;
1407             default:
1408                 constantWasSet = false;
1409                 break;
1410             }
1411             if (constantWasSet)
1412                 break;
1413         }
1414 































1415         // FIXME: This code should really use AbstractValue::isType() and
1416         // AbstractValue::couldBeType().
1417         // https://bugs.webkit.org/show_bug.cgi?id=146870
1418 
1419         bool constantWasSet = false;
1420         switch (node-&gt;op()) {
1421         case IsEmpty: {
1422             if (child.m_type &amp;&amp; !(child.m_type &amp; SpecEmpty)) {
1423                 setConstant(node, jsBoolean(false));
1424                 constantWasSet = true;
1425                 break;
1426             }
1427 
1428             if (child.m_type &amp;&amp; !(child.m_type &amp; ~SpecEmpty)) {
1429                 setConstant(node, jsBoolean(true));
1430                 constantWasSet = true;
1431                 break;
1432             }
1433 
1434             break;
</pre>
<hr />
<pre>
1544                 setConstant(node, jsBoolean(false));
1545                 constantWasSet = true;
1546                 break;
1547             }
1548 
1549             break;
1550         case IsFunction:
1551             if (!(child.m_type &amp; ~SpecFunction)) {
1552                 setConstant(node, jsBoolean(true));
1553                 constantWasSet = true;
1554                 break;
1555             }
1556 
1557             if (!(child.m_type &amp; (SpecFunction | SpecObjectOther | SpecProxyObject))) {
1558                 setConstant(node, jsBoolean(false));
1559                 constantWasSet = true;
1560                 break;
1561             }
1562             break;
1563 
<span class="line-modified">1564         case IsCellWithType:</span>
<span class="line-modified">1565             if (!(child.m_type &amp; ~node-&gt;speculatedTypeForQuery())) {</span>








1566                 setConstant(node, jsBoolean(true));
1567                 constantWasSet = true;
1568                 break;
1569             }
<span class="line-modified">1570             if (!(child.m_type &amp; node-&gt;speculatedTypeForQuery())) {</span>
1571                 setConstant(node, jsBoolean(false));
1572                 constantWasSet = true;
1573                 break;
1574             }
1575             break;

1576 
1577         case IsTypedArrayView:
1578             if (!(child.m_type &amp; ~SpecTypedArrayView)) {
1579                 setConstant(node, jsBoolean(true));
1580                 constantWasSet = true;
1581                 break;
1582             }
1583             if (!(child.m_type &amp; SpecTypedArrayView)) {
1584                 setConstant(node, jsBoolean(false));
1585                 constantWasSet = true;
1586                 break;
1587             }
1588             break;
1589 
1590         default:
1591             break;
1592         }
1593         if (constantWasSet)
1594             break;
1595 
</pre>
<hr />
<pre>
1840                 if (a &amp;&amp; b) {
1841                     setConstant(node, jsBoolean(WTF::equal(a, b)));
1842                     break;
1843                 }
1844             } else {
1845                 if (node-&gt;op() == CompareStrictEq)
1846                     setConstant(node, jsBoolean(JSValue::strictEqual(nullptr, left, right)));
1847                 else
1848                     setConstant(node, jsBoolean(sameValue(nullptr, left, right)));
1849                 break;
1850             }
1851         }
1852 
1853         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1854             // FIXME: Revisit this condition when introducing BigInt to JSC.
1855             auto isNonStringCellConstant = [] (JSValue value) {
1856                 return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
1857             };
1858 
1859             if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
<span class="line-modified">1860                 m_state.setFoundConstants(true);</span>
1861                 setNonCellTypeForNode(node, SpecBoolean);
1862                 break;
1863             }
1864         }
1865 
1866         SpeculatedType leftLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(leftNode).m_type);
1867         SpeculatedType rightLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(rightNode).m_type);
1868         if (!(leftLUB &amp; rightLUB)) {
1869             setConstant(node, jsBoolean(false));
1870             break;
1871         }
1872 
1873         if (node-&gt;child1() == node-&gt;child2()) {
1874             if (node-&gt;isBinaryUseKind(BooleanUse) ||
1875                 node-&gt;isBinaryUseKind(Int32Use) ||
1876                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1877                 node-&gt;isBinaryUseKind(StringUse) ||
1878                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1879                 node-&gt;isBinaryUseKind(SymbolUse) ||
1880                 node-&gt;isBinaryUseKind(ObjectUse) ||
</pre>
<hr />
<pre>
1889             }
1890         }
1891 
1892         setNonCellTypeForNode(node, SpecBoolean);
1893         break;
1894     }
1895 
1896     case CompareEqPtr: {
1897         Node* childNode = node-&gt;child1().node();
1898         JSValue childValue = forNode(childNode).value();
1899         if (childValue) {
1900             setConstant(node, jsBoolean(childValue.isCell() &amp;&amp; childValue.asCell() == node-&gt;cellOperand()-&gt;cell()));
1901             break;
1902         }
1903 
1904         setNonCellTypeForNode(node, SpecBoolean);
1905         break;
1906     }
1907 
1908     case StringCharCodeAt:

1909         setNonCellTypeForNode(node, SpecInt32Only);
1910         break;
1911 
1912     case StringFromCharCode:
1913         switch (node-&gt;child1().useKind()) {
1914         case Int32Use:
1915             break;
1916         case UntypedUse:
1917             clobberWorld();
1918             break;
1919         default:
1920             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
1921             break;
1922         }
1923         setTypeForNode(node, SpecString);
1924         break;
1925 
1926     case StringCharAt:
1927         setForNode(node, m_vm.stringStructure.get());
1928         break;
</pre>
<hr />
<pre>
2267     case ArrayPop:
2268         clobberWorld();
2269         makeHeapTopForNode(node);
2270         break;
2271 
2272     case GetMyArgumentByVal:
2273     case GetMyArgumentByValOutOfBounds: {
2274         JSValue index = forNode(node-&gt;child2()).m_value;
2275         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
2276 
2277         if (index &amp;&amp; index.isUInt32()) {
2278             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2279             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2280             // paths as unreachable, or to return undefined. We could implement that eventually.
2281 
2282             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2283             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2284             unsigned argumentIndex;
2285             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2286                 if (inlineCallFrame) {
<span class="line-modified">2287                     if (argumentIndex &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1) {</span>
2288                         setForNode(node, m_state.operand(
<span class="line-modified">2289                             virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));</span>
<span class="line-modified">2290                         m_state.setFoundConstants(true);</span>
2291                         break;
2292                     }
2293                 } else {
2294                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2295                         setForNode(node, m_state.argument(argumentIndex + 1));
<span class="line-modified">2296                         m_state.setFoundConstants(true);</span>
2297                         break;
2298                     }
2299                 }
2300             }
2301         }
2302 
2303         if (inlineCallFrame) {
2304             // We have a bound on the types even though it&#39;s random access. Take advantage of this.
2305 
2306             AbstractValue result;
2307             for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
2308                 result.merge(
2309                     m_state.operand(
<span class="line-modified">2310                         virtualRegisterForArgument(i) + inlineCallFrame-&gt;stackOffset));</span>
2311             }
2312 
2313             if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
2314                 result.merge(SpecOther);
2315 
2316             if (result.value())
<span class="line-modified">2317                 m_state.setFoundConstants(true);</span>
2318 
2319             setForNode(node, result);
2320             break;
2321         }
2322 
2323         makeHeapTopForNode(node);
2324         break;
2325     }
2326 
2327     case RegExpExec:
2328     case RegExpExecNonGlobalOrSticky:
2329         if (node-&gt;op() == RegExpExec) {
2330             // Even if we&#39;ve proven known input types as RegExpObject and String,
2331             // accessing lastIndex is effectful if it&#39;s a global regexp.
2332             clobberWorld();
2333         }
2334 
2335         if (JSValue globalObjectValue = forNode(node-&gt;child1()).m_value) {
2336             if (JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(m_vm, globalObjectValue)) {
2337                 if (!globalObject-&gt;isHavingABadTime()) {
2338                     m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2339                     RegisteredStructureSet structureSet;
2340                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayStructure()));
<span class="line-removed">2341                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayWithGroupsStructure()));</span>
2342                     setForNode(node, structureSet);
2343                     forNode(node).merge(SpecOther);
2344                     break;
2345                 }
2346             }
2347         }
2348         setTypeForNode(node, SpecOther | SpecArray);
2349         break;
2350 
2351     case RegExpTest:
2352         // Even if we&#39;ve proven known input types as RegExpObject and String,
2353         // accessing lastIndex is effectful if it&#39;s a global regexp.
2354         clobberWorld();
2355         setNonCellTypeForNode(node, SpecBoolean);
2356         break;
2357 
2358     case RegExpMatchFast:
2359         ASSERT(node-&gt;child2().useKind() == RegExpObjectUse);
2360         ASSERT(node-&gt;child3().useKind() == StringUse || node-&gt;child3().useKind() == KnownStringUse);
2361         setTypeForNode(node, SpecOther | SpecArray);
</pre>
<hr />
<pre>
2416     case ThrowStaticError:
2417     case TailCall:
2418     case DirectTailCall:
2419     case TailCallVarargs:
2420     case TailCallForwardVarargs:
2421         clobberWorld();
2422         m_state.setIsValid(false);
2423         break;
2424 
2425     case ToPrimitive: {
2426         JSValue childConst = forNode(node-&gt;child1()).value();
2427         if (childConst &amp;&amp; childConst.isNumber()) {
2428             didFoldClobberWorld();
2429             setConstant(node, childConst);
2430             break;
2431         }
2432 
2433         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2434 
2435         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
<span class="line-modified">2436             m_state.setFoundConstants(true);</span>
2437             didFoldClobberWorld();
2438             setForNode(node, forNode(node-&gt;child1()));
2439             break;
2440         }
2441 
2442         clobberWorld();
2443 
2444         setTypeForNode(node, SpecHeapTop &amp; ~SpecObject);
2445         break;
2446     }
2447 














2448     case ToNumber: {
2449         JSValue childConst = forNode(node-&gt;child1()).value();
2450         if (childConst &amp;&amp; childConst.isNumber()) {
2451             didFoldClobberWorld();
2452             setConstant(node, childConst);
2453             break;
2454         }
2455 
2456         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2457 
2458         if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
<span class="line-modified">2459             m_state.setFoundConstants(true);</span>
2460             didFoldClobberWorld();
2461             setForNode(node, forNode(node-&gt;child1()));
2462             break;
2463         }
2464 
2465         clobberWorld();
2466         setNonCellTypeForNode(node, SpecBytecodeNumber);
2467         break;
2468     }
2469 






















2470     case ToString:
2471     case CallStringConstructor: {
2472         switch (node-&gt;child1().useKind()) {
2473         case StringObjectUse:
2474         case StringOrStringObjectUse:
2475         case Int32Use:
2476         case Int52RepUse:
2477         case DoubleRepUse:
2478         case NotCellUse:
2479             break;
2480         case CellUse:
2481         case UntypedUse:
2482             clobberWorld();
2483             break;
2484         default:
2485             RELEASE_ASSERT_NOT_REACHED();
2486             break;
2487         }
2488         setForNode(node, m_vm.stringStructure.get());
2489         break;
2490     }
2491 
2492     case NumberToStringWithRadix: {
2493         JSValue radixValue = forNode(node-&gt;child2()).m_value;
2494         if (radixValue &amp;&amp; radixValue.isInt32()) {
2495             int32_t radix = radixValue.asInt32();
2496             if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
<span class="line-modified">2497                 m_state.setFoundConstants(true);</span>
2498                 didFoldClobberWorld();
2499                 setForNode(node, m_graph.m_vm.stringStructure.get());
2500                 break;
2501             }
2502         }
2503         clobberWorld();
2504         setForNode(node, m_graph.m_vm.stringStructure.get());
2505         break;
2506     }
2507 
2508     case NumberToStringWithValidRadixConstant: {
2509         setForNode(node, m_graph.m_vm.stringStructure.get());
2510         break;
2511     }
2512 
2513     case NewStringObject: {
2514         ASSERT(node-&gt;structure()-&gt;classInfo() == StringObject::info());
2515         setForNode(node, node-&gt;structure());
2516         break;
2517     }
2518 
2519     case NewSymbol: {
2520         setForNode(node, m_vm.symbolStructure.get());
2521         break;
2522     }
2523 
2524     case NewArray:
2525         ASSERT(node-&gt;indexingMode() == node-&gt;indexingType()); // Copy on write arrays should only be created by NewArrayBuffer.
2526         setForNode(node,
2527             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
2528         break;
2529 
2530     case NewArrayWithSpread:
2531         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2532             // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
2533             // with StructureRegisterationPhase we must say we produce an original array
2534             // allocation structure.
<span class="line-modified">2535             setForNode(node,</span>
<span class="line-modified">2536                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));</span>


















2537         } else {
2538             setForNode(node,
2539                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
2540         }
2541 
2542         break;
2543 
2544     case Spread:
2545         switch (node-&gt;child1()-&gt;op()) {
2546         case PhantomNewArrayBuffer:
2547         case PhantomCreateRest:
2548             break;
2549         default:
2550             if (!m_graph.canDoFastSpread(node, forNode(node-&gt;child1())))
2551                 clobberWorld();
2552             else
2553                 didFoldClobberWorld();
2554             break;
2555         }
2556 
<span class="line-modified">2557         setForNode(node,</span>
<span class="line-removed">2558             m_vm.fixedArrayStructure.get());</span>
2559         break;
2560 
2561     case NewArrayBuffer:
2562         setForNode(node,
2563             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
2564         break;
2565 
2566     case NewArrayWithSize:
2567         setTypeForNode(node, SpecArray);
2568         break;
2569 
2570     case NewTypedArray:
2571         switch (node-&gt;child1().useKind()) {
2572         case Int32Use:
2573             break;
2574         case UntypedUse:
2575             clobberWorld();
2576             break;
2577         default:
2578             RELEASE_ASSERT_NOT_REACHED();
2579             break;
2580         }
2581         setForNode(node,
2582             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2583                 node-&gt;typedArrayType()));
2584         break;
2585 
2586     case NewRegexp:
2587         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2588         break;
2589 
2590     case ToThis: {
2591         AbstractValue&amp; source = forNode(node-&gt;child1());
2592         AbstractValue&amp; destination = forNode(node);
2593         bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
2594 
2595         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2596         switch (result) {
2597         case ToThisResult::Identity:
<span class="line-modified">2598             m_state.setFoundConstants(true);</span>
2599             destination = source;
2600             break;
2601         case ToThisResult::Undefined:
2602             setConstant(node, jsUndefined());
2603             break;
2604         case ToThisResult::GlobalThis:
<span class="line-modified">2605             m_state.setFoundConstants(true);</span>
2606             destination.setType(m_graph, SpecObject);
2607             break;
2608         case ToThisResult::Dynamic:
2609             if (strictMode)
2610                 destination.makeHeapTop();
2611             else {
2612                 destination = source;
2613                 destination.merge(SpecObject);
2614             }
2615             break;
2616         }
2617         break;
2618     }
2619 
2620     case CreateThis: {
2621         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2622             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2623                 if (FunctionRareData* rareData = function-&gt;rareData()) {
<span class="line-modified">2624                     if (Structure* structure = rareData-&gt;objectAllocationStructure()) {</span>
<span class="line-modified">2625                         m_graph.freeze(rareData);</span>
<span class="line-modified">2626                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-modified">2627                         m_state.setFoundConstants(true);</span>
<span class="line-modified">2628                         didFoldClobberWorld();</span>
<span class="line-modified">2629                         setForNode(node, structure);</span>
<span class="line-modified">2630                         break;</span>


2631                     }
2632                 }
2633             }
2634         }
2635         clobberWorld();
2636         setTypeForNode(node, SpecFinalObject);
2637         break;
2638     }
2639 



















































































2640     case NewObject:

2641         ASSERT(!!node-&gt;structure().get());
2642         setForNode(node, node-&gt;structure());
2643         break;
2644 
2645     case ObjectCreate: {
2646         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2647             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2648             Structure* structure = nullptr;
2649             if (base.isNull())
2650                 structure = globalObject-&gt;nullPrototypeObjectStructure();
2651             else if (base.isObject())
<span class="line-modified">2652                 structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
2653 
2654             if (structure) {
<span class="line-modified">2655                 m_state.setFoundConstants(true);</span>
2656                 if (node-&gt;child1().useKind() == UntypedUse)
2657                     didFoldClobberWorld();
2658                 setForNode(node, structure);
2659                 break;
2660             }
2661         }
2662         if (node-&gt;child1().useKind() == UntypedUse)
2663             clobberWorld();
2664         setTypeForNode(node, SpecFinalObject);
2665         break;
2666     }
2667 
2668     case ObjectKeys: {
2669         if (node-&gt;child1().useKind() == ObjectUse) {
2670             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2671             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2672                 RegisteredStructure structure = structureSet.onlyStructure();
2673                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2674                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2675                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
<span class="line-modified">2676                             m_state.setFoundConstants(true);</span>
2677                             didFoldClobberWorld();
2678                             setTypeForNode(node, SpecArray);
2679                             break;
2680                         }
2681                     }
2682                 }
2683             }
2684         }
2685 
2686         clobberWorld();
2687         setTypeForNode(node, SpecArray);
2688         break;
2689     }
2690 
2691     case ToObject:
2692     case CallObjectConstructor: {
2693         AbstractValue&amp; source = forNode(node-&gt;child1());
2694         AbstractValue&amp; destination = forNode(node);
2695 
2696         if (!(source.m_type &amp; ~SpecObject)) {
<span class="line-modified">2697             m_state.setFoundConstants(true);</span>
2698             if (node-&gt;op() == ToObject)
2699                 didFoldClobberWorld();
2700             destination = source;
2701             break;
2702         }
2703 
2704         if (node-&gt;op() == ToObject)
2705             clobberWorld();
2706         setTypeForNode(node, SpecObject);
2707         break;
2708     }
2709 
2710     case PhantomNewObject:
2711     case PhantomNewFunction:
2712     case PhantomNewGeneratorFunction:
2713     case PhantomNewAsyncGeneratorFunction:
2714     case PhantomNewAsyncFunction:
2715     case PhantomCreateActivation:
2716     case PhantomDirectArguments:
2717     case PhantomClonedArguments:
2718     case PhantomCreateRest:
2719     case PhantomSpread:
2720     case PhantomNewArrayWithSpread:
2721     case PhantomNewArrayBuffer:

2722     case PhantomNewRegexp:
2723     case BottomValue: {
2724         clearForNode(node);
2725         break;
2726     }
2727 
2728     case PutHint:
2729         break;
2730 
2731     case MaterializeNewObject: {
2732         setForNode(node, node-&gt;structureSet());
2733         break;
2734     }
2735 
2736     case PushWithScope:
2737         // We don&#39;t use the more precise withScopeStructure() here because it is a LazyProperty and may not yet be allocated.
2738         setTypeForNode(node, SpecObjectOther);
2739         break;
2740 
2741     case CreateActivation:
</pre>
<hr />
<pre>
2743         setForNode(node,
2744             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;activationStructure());
2745         break;
2746 
2747     case CreateDirectArguments:
2748         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
2749         break;
2750 
2751     case CreateScopedArguments:
2752         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure());
2753         break;
2754 
2755     case CreateClonedArguments:
2756         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2757             setTypeForNode(node, SpecObject);
2758             break;
2759         }
2760         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure());
2761         break;
2762 




2763     case NewGeneratorFunction:
2764         setForNode(node,
2765             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;generatorFunctionStructure());
2766         break;
2767 
2768     case NewAsyncGeneratorFunction:
2769         setForNode(node,
2770             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
2771         break;
2772 
2773     case NewAsyncFunction:
2774         setForNode(node,
2775             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
2776         break;
2777 
2778     case NewFunction: {
2779         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
2780         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
2781         setForNode(node, structure);
2782         break;
</pre>
<hr />
<pre>
2880         setTypeForNode(node, SpecObjectOther);
2881         break;
2882     }
2883 
2884     case GetGlobalThis: {
2885         setTypeForNode(node, SpecObject);
2886         break;
2887     }
2888 
2889     case GetClosureVar:
2890         if (JSValue value = m_graph.tryGetConstantClosureVar(forNode(node-&gt;child1()), node-&gt;scopeOffset())) {
2891             setConstant(node, *m_graph.freeze(value));
2892             break;
2893         }
2894         makeBytecodeTopForNode(node);
2895         break;
2896 
2897     case PutClosureVar:
2898         break;
2899 








2900     case GetRegExpObjectLastIndex:
2901         makeHeapTopForNode(node);
2902         break;
2903 
2904     case SetRegExpObjectLastIndex:
2905     case RecordRegExpCachedResult:
2906         break;
2907 
2908     case GetFromArguments:
2909         makeHeapTopForNode(node);
2910         break;
2911 
2912     case PutToArguments:
2913         break;
2914 
2915     case GetArgument:
2916         makeHeapTopForNode(node);
2917         break;
2918 
2919     case TryGetById:
2920         // FIXME: This should constant fold at least as well as the normal GetById case.
2921         // https://bugs.webkit.org/show_bug.cgi?id=156422
2922         makeHeapTopForNode(node);
2923         break;
2924 
2925     case GetByIdDirect:
2926     case GetByIdDirectFlush:
2927     case GetById:
2928     case GetByIdFlush: {
2929         AbstractValue&amp; value = forNode(node-&gt;child1());
2930         if (value.m_structure.isFinite()
2931             &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
2932             UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
<span class="line-modified">2933             GetByIdStatus status = GetByIdStatus::computeFor(value.m_structure.toStructureSet(), uid);</span>
2934             if (status.isSimple()) {
2935                 // Figure out what the result is going to be - is it TOP, a constant, or maybe
2936                 // something more subtle?
2937                 AbstractValue result;
2938                 for (unsigned i = status.numVariants(); i--;) {
2939                     // This thing won&#39;t give us a variant that involves prototypes. If it did, we&#39;d
2940                     // have more work to do here.
2941                     DFG_ASSERT(m_graph, node, status[i].conditionSet().isEmpty());
2942 
2943                     result.merge(
2944                         m_graph.inferredValueForProperty(
2945                             value, status[i].offset(), m_state.structureClobberState()));
2946                 }
2947 
<span class="line-modified">2948                 m_state.setFoundConstants(true);</span>
2949                 didFoldClobberWorld();
2950                 forNode(node) = result;
2951                 break;
2952             }
2953         }
2954 
2955         clobberWorld();
2956         makeHeapTopForNode(node);
2957         break;
2958     }
2959 
2960     case GetByValWithThis:
2961     case GetByIdWithThis:
2962         clobberWorld();
2963         makeHeapTopForNode(node);
2964         break;
2965 
2966     case GetArrayLength: {
2967         JSArrayBufferView* view = m_graph.tryGetFoldableView(
2968             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
</pre>
<hr />
<pre>
2981 
2982     case DeleteById:
2983     case DeleteByVal: {
2984         // FIXME: This could decide if the delete will be successful based on the set of structures that
2985         // we get from our base value. https://bugs.webkit.org/show_bug.cgi?id=156611
2986         clobberWorld();
2987         setNonCellTypeForNode(node, SpecBoolean);
2988         break;
2989     }
2990 
2991     case CheckStructure: {
2992         AbstractValue&amp; value = forNode(node-&gt;child1());
2993 
2994         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
2995 
2996         // It&#39;s interesting that we could have proven that the object has a larger structure set
2997         // that includes the set we&#39;re testing. In that case we could make the structure check
2998         // more efficient. We currently don&#39;t.
2999 
3000         if (value.m_structure.isSubsetOf(set))
<span class="line-modified">3001             m_state.setFoundConstants(true);</span>
3002 
3003         SpeculatedType admittedTypes = SpecNone;
3004         switch (node-&gt;child1().useKind()) {
3005         case CellUse:
3006         case KnownCellUse:
3007             admittedTypes = SpecNone;
3008             break;
3009         case CellOrOtherUse:
3010             admittedTypes = SpecOther;
3011             break;
3012         default:
3013             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
3014             break;
3015         }
3016 
3017         filter(value, set, admittedTypes);
3018         break;
3019     }
3020 
3021     case CheckStructureOrEmpty: {
3022         AbstractValue&amp; value = forNode(node-&gt;child1());
3023 
3024         bool mayBeEmpty = value.m_type &amp; SpecEmpty;
3025         if (!mayBeEmpty)
<span class="line-modified">3026             m_state.setFoundConstants(true);</span>
3027 
3028         SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
3029         filter(value, node-&gt;structureSet(), admittedTypes);
3030         break;
3031     }
3032 
3033     case CheckStructureImmediate: {
3034         // FIXME: This currently can only reason about one structure at a time.
3035         // https://bugs.webkit.org/show_bug.cgi?id=136988
3036 
3037         AbstractValue&amp; value = forNode(node-&gt;child1());
3038         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
3039 
3040         if (value.value()) {
3041             if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
3042                 if (set.contains(m_graph.registerStructure(structure))) {
<span class="line-modified">3043                     m_state.setFoundConstants(true);</span>
3044                     break;
3045                 }
3046             }
3047             m_state.setIsValid(false);
3048             break;
3049         }
3050 
3051         if (m_phiChildren) {
3052             bool allGood = true;
3053             m_phiChildren-&gt;forAllTransitiveIncomingValues(
3054                 node,
3055                 [&amp;] (Node* incoming) {
3056                     if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_vm)) {
3057                         if (set.contains(m_graph.registerStructure(structure)))
3058                             return;
3059                     }
3060                     allGood = false;
3061                 });
3062             if (allGood) {
<span class="line-modified">3063                 m_state.setFoundConstants(true);</span>
3064                 break;
3065             }
3066         }
3067 
3068         if (RegisteredStructure structure = set.onlyStructure()) {
3069             filterByValue(node-&gt;child1(), *m_graph.freeze(structure.get()));
3070             break;
3071         }
3072 
3073         // Aw shucks, we can&#39;t do anything!
3074         break;
3075     }
3076 
3077     case PutStructure:
3078         if (!forNode(node-&gt;child1()).m_structure.isClear()) {
3079             if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
3080                 didFoldClobberStructures();
<span class="line-modified">3081                 m_state.setFoundConstants(true);</span>
3082             } else {
3083                 observeTransition(
3084                     clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
3085                 forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
3086             }
3087         } else {
3088             // We&#39;re going to exit before we get here, but for the sake of validation, we&#39;ve folded our write to StructureID.
3089             didFoldClobberStructures();
3090         }
3091         break;
3092     case GetButterfly:
3093     case AllocatePropertyStorage:
3094     case ReallocatePropertyStorage:
3095     case NukeStructureAndSetButterfly:
3096         // FIXME: We don&#39;t model the fact that the structureID is nuked, simply because currently
3097         // nobody would currently benefit from having that information. But it&#39;s a bug nonetheless.
3098         if (node-&gt;op() == NukeStructureAndSetButterfly)
3099             didFoldClobberStructures();
3100         clearForNode(node); // The result is not a JS value.
3101         break;
3102     case CheckSubClass: {
3103         JSValue constant = forNode(node-&gt;child1()).value();
3104         if (constant) {
3105             if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
<span class="line-modified">3106                 m_state.setFoundConstants(true);</span>
3107                 ASSERT(constant);
3108                 break;
3109             }
3110         }
3111 
3112         AbstractValue&amp; value = forNode(node-&gt;child1());
3113 
3114         if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
<span class="line-modified">3115             m_state.setFoundConstants(true);</span>
3116 
3117         filterClassInfo(value, node-&gt;classInfo());
3118         break;
3119     }
3120     case CallDOMGetter: {
3121         CallDOMGetterData* callDOMGetterData = node-&gt;callDOMGetterData();
3122         DOMJIT::CallDOMGetterSnippet* snippet = callDOMGetterData-&gt;snippet;
3123         if (!snippet || snippet-&gt;effect.writes)
3124             clobberWorld();
3125         if (callDOMGetterData-&gt;domJIT)
3126             setTypeForNode(node, callDOMGetterData-&gt;domJIT-&gt;resultType());
3127         else
3128             makeBytecodeTopForNode(node);
3129         break;
3130     }
3131     case CallDOM: {
3132         const DOMJIT::Signature* signature = node-&gt;signature();
3133         if (signature-&gt;effect.writes)
3134             clobberWorld();
3135         setTypeForNode(node, signature-&gt;result);
3136         break;
3137     }


3138     case CheckArray: {
<span class="line-modified">3139         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {</span>
<span class="line-modified">3140             m_state.setFoundConstants(true);</span>











3141             break;
3142         }

3143         switch (node-&gt;arrayMode().type()) {
3144         case Array::String:
<span class="line-modified">3145             filter(node-&gt;child1(), SpecString);</span>
3146             break;
3147         case Array::Int32:
3148         case Array::Double:
3149         case Array::Contiguous:
3150         case Array::Undecided:
3151         case Array::ArrayStorage:
3152         case Array::SlowPutArrayStorage:
3153             break;
3154         case Array::DirectArguments:
<span class="line-modified">3155             filter(node-&gt;child1(), SpecDirectArguments);</span>
3156             break;
3157         case Array::ScopedArguments:
<span class="line-modified">3158             filter(node-&gt;child1(), SpecScopedArguments);</span>
3159             break;
3160         case Array::Int8Array:
<span class="line-modified">3161             filter(node-&gt;child1(), SpecInt8Array);</span>
3162             break;
3163         case Array::Int16Array:
<span class="line-modified">3164             filter(node-&gt;child1(), SpecInt16Array);</span>
3165             break;
3166         case Array::Int32Array:
<span class="line-modified">3167             filter(node-&gt;child1(), SpecInt32Array);</span>
3168             break;
3169         case Array::Uint8Array:
<span class="line-modified">3170             filter(node-&gt;child1(), SpecUint8Array);</span>
3171             break;
3172         case Array::Uint8ClampedArray:
<span class="line-modified">3173             filter(node-&gt;child1(), SpecUint8ClampedArray);</span>
3174             break;
3175         case Array::Uint16Array:
<span class="line-modified">3176             filter(node-&gt;child1(), SpecUint16Array);</span>
3177             break;
3178         case Array::Uint32Array:
<span class="line-modified">3179             filter(node-&gt;child1(), SpecUint32Array);</span>
3180             break;
3181         case Array::Float32Array:
<span class="line-modified">3182             filter(node-&gt;child1(), SpecFloat32Array);</span>
3183             break;
3184         case Array::Float64Array:
<span class="line-modified">3185             filter(node-&gt;child1(), SpecFloat64Array);</span>
3186             break;
3187         case Array::AnyTypedArray:
<span class="line-modified">3188             filter(node-&gt;child1(), SpecTypedArrayView);</span>
3189             break;
3190         default:
3191             RELEASE_ASSERT_NOT_REACHED();
3192             break;
3193         }
<span class="line-modified">3194         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());</span>
3195         break;
3196     }

3197     case Arrayify: {
3198         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3199             didFoldClobberStructures();
<span class="line-modified">3200             m_state.setFoundConstants(true);</span>
3201             break;
3202         }
3203         ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
3204         clobberStructures();
3205         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3206         break;
3207     }
3208     case ArrayifyToStructure: {
3209         AbstractValue&amp; value = forNode(node-&gt;child1());
3210         if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
<span class="line-modified">3211             m_state.setFoundConstants(true);</span>
3212         clobberStructures();
3213 
3214         // We have a bunch of options of how to express the abstract set at this point. Let set S
3215         // be the set of structures that the value had before clobbering and assume that all of
3216         // them are watchable. The new value should be the least expressible upper bound of the
3217         // intersection of &quot;values that currently have structure = node-&gt;structure()&quot; and &quot;values
3218         // that have structure in S plus any structure transition-reachable from S&quot;. Assume that
3219         // node-&gt;structure() is not in S but it is transition-reachable from S. Then we would
3220         // like to say that the result is &quot;values that have structure = node-&gt;structure() until
3221         // we invalidate&quot;, but there is no way to express this using the AbstractValue syntax. So
3222         // we must choose between:
3223         //
3224         // 1) &quot;values that currently have structure = node-&gt;structure()&quot;. This is a valid
3225         //    superset of the value that we really want, and it&#39;s specific enough to satisfy the
3226         //    preconditions of the array access that this is guarding. It&#39;s also specific enough
3227         //    to allow relevant optimizations in the case that we didn&#39;t have a contradiction
3228         //    like in this example. Notice that in the abscence of any contradiction, this result
3229         //    is precise rather than being a conservative LUB.
3230         //
3231         // 2) &quot;values that currently hava structure in S plus any structure transition-reachable
3232         //    from S&quot;. This is also a valid superset of the value that we really want, but it&#39;s
3233         //    not specific enough to satisfy the preconditions of the array access that this is
3234         //    guarding - so playing such shenanigans would preclude us from having assertions on
3235         //    the typing preconditions of any array accesses. This would also not be a desirable
3236         //    answer in the absence of a contradiction.
3237         //
3238         // Note that it&#39;s tempting to simply say that the resulting value is BOTTOM because of
3239         // the contradiction. That would be wrong, since we haven&#39;t hit an invalidation point,
3240         // yet.
3241         forNode(node-&gt;child1()).set(m_graph, node-&gt;structure());
3242         break;
3243     }
3244     case GetIndexedPropertyStorage: {
3245         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3246             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
3247         if (view)
<span class="line-modified">3248             m_state.setFoundConstants(true);</span>
3249         clearForNode(node);
3250         break;
3251     }
3252     case ConstantStoragePointer: {
3253         clearForNode(node);
3254         break;
3255     }
3256 
3257     case GetTypedArrayByteOffset: {
3258         JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
3259         if (view) {
<span class="line-modified">3260             setConstant(node, jsNumber(view-&gt;byteOffset()));</span>
<span class="line-modified">3261             break;</span>



3262         }
3263         setNonCellTypeForNode(node, SpecInt32Only);
3264         break;
3265     }
3266 
3267     case GetPrototypeOf: {
3268         AbstractValue&amp; value = forNode(node-&gt;child1());
3269         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
3270             bool canFold = !value.m_structure.isClear();
3271             JSValue prototype;
3272             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3273                 auto getPrototypeMethod = structure-&gt;classInfo()-&gt;methodTable.getPrototype;
3274                 MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
3275                 if (getPrototypeMethod != defaultGetPrototype) {
3276                     canFold = false;
3277                     return;
3278                 }
3279 
3280                 if (structure-&gt;hasPolyProto()) {
3281                     canFold = false;
</pre>
<hr />
<pre>
3316     }
3317 
3318     case GetByOffset: {
3319         StorageAccessData&amp; data = node-&gt;storageAccessData();
3320 
3321         // FIXME: The part of this that handles inferred property types relies on AI knowing the structure
3322         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3323         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3324         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3325         // on the type that ByteCodeParser was able to prove.
3326         AbstractValue value = m_graph.inferredValueForProperty(
3327             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3328 
3329         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3330         // because the compilation was already invalidated.
3331         if (value.isClear())
3332             m_state.setIsValid(false);
3333 
3334         setForNode(node, value);
3335         if (value.m_value)
<span class="line-modified">3336             m_state.setFoundConstants(true);</span>
3337         break;
3338     }
3339 
3340     case GetGetterSetterByOffset: {
3341         StorageAccessData&amp; data = node-&gt;storageAccessData();
3342         AbstractValue base = forNode(node-&gt;child2());
3343         JSValue result = m_graph.tryGetConstantProperty(base, data.offset);
3344         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3345             setConstant(node, *m_graph.freeze(result));
3346             break;
3347         }
3348 
<span class="line-modified">3349         if (base.value() &amp;&amp; base.value().isObject()) {</span>
<span class="line-removed">3350             setForNode(node, asObject(base.value())-&gt;globalObject()-&gt;getterSetterStructure());</span>
<span class="line-removed">3351             break;</span>
<span class="line-removed">3352         }</span>
<span class="line-removed">3353 </span>
<span class="line-removed">3354         setTypeForNode(node, SpecObjectOther);</span>
3355         break;
3356     }
3357 
3358     case MultiGetByOffset: {
3359         // This code will filter the base value in a manner that is possibly different (either more
3360         // or less precise) than the way it would be filtered if this was strength-reduced to a
3361         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3362         // different things about the code, so long as all of them are sound. That even includes
3363         // one guy proving that code should never execute (due to a contradiction) and another guy
3364         // not finding that contradiction. If someone ever proved that there would be a
3365         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3366         // realize it. This is the case here.
3367 
<span class="line-modified">3368         // Ordinarily you have to be careful with calling setFoundConstants()</span>
3369         // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">3370         m_state.setFoundConstants(true);</span>
3371 
3372         AbstractValue base = forNode(node-&gt;child1());
3373         RegisteredStructureSet baseSet;
3374         AbstractValue result;
3375         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
3376             RegisteredStructureSet set = getCase.set();
3377             set.filter(base);
3378             if (set.isEmpty())
3379                 continue;
3380             baseSet.merge(set);
3381 
3382             switch (getCase.method().kind()) {
3383             case GetByOffsetMethod::Constant: {
3384                 AbstractValue thisResult;
3385                 thisResult.set(
3386                     m_graph,
3387                     *getCase.method().constant(),
3388                     m_state.structureClobberState());
3389                 result.merge(thisResult);
3390                 break;
</pre>
<hr />
<pre>
3394                 result.makeHeapTop();
3395                 break;
3396             } }
3397         }
3398 
3399         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3400             m_state.setIsValid(false);
3401 
3402         setForNode(node, result);
3403         break;
3404     }
3405 
3406     case PutByOffset: {
3407         break;
3408     }
3409 
3410     case MultiPutByOffset: {
3411         RegisteredStructureSet newSet;
3412         TransitionVector transitions;
3413 
<span class="line-modified">3414         // Ordinarily you have to be careful with calling setFoundConstants()</span>
3415         // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">3416         m_state.setFoundConstants(true);</span>
3417 
3418         AbstractValue base = forNode(node-&gt;child1());
3419         AbstractValue originalValue = forNode(node-&gt;child2());
3420         AbstractValue resultingValue;
3421 
3422         if (node-&gt;multiPutByOffsetData().writesStructures())
3423             didFoldClobberStructures();
3424 
3425         for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
3426             const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
3427             RegisteredStructureSet thisSet = *m_graph.addStructureSet(variant.oldStructure());
3428             thisSet.filter(base);
3429             if (thisSet.isEmpty())
3430                 continue;
3431 
3432             AbstractValue thisValue = originalValue;
3433             resultingValue.merge(thisValue);
3434 
3435             if (variant.kind() == PutByIdVariant::Transition) {
3436                 RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
</pre>
<hr />
<pre>
3458             m_state.setIsValid(false);
3459         break;
3460     }
3461 
3462     case GetExecutable: {
3463         JSValue value = forNode(node-&gt;child1()).value();
3464         if (value) {
3465             JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, value);
3466             if (function) {
3467                 setConstant(node, *m_graph.freeze(function-&gt;executable()));
3468                 break;
3469             }
3470         }
3471         setTypeForNode(node, SpecCellOther);
3472         break;
3473     }
3474 
3475     case CheckCell: {
3476         JSValue value = forNode(node-&gt;child1()).value();
3477         if (value == node-&gt;cellOperand()-&gt;value()) {
<span class="line-modified">3478             m_state.setFoundConstants(true);</span>
3479             ASSERT(value);
3480             break;
3481         }
3482         filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
3483         break;
3484     }
3485 
3486     case AssertNotEmpty:
3487     case CheckNotEmpty: {
3488         AbstractValue&amp; value = forNode(node-&gt;child1());
3489         if (!(value.m_type &amp; SpecEmpty)) {
<span class="line-modified">3490             m_state.setFoundConstants(true);</span>
3491             break;
3492         }
3493 
3494         filter(value, ~SpecEmpty);
3495         break;
3496     }
3497 
<span class="line-modified">3498     case CheckStringIdent: {</span>
3499         AbstractValue&amp; value = forNode(node-&gt;child1());
3500         UniquedStringImpl* uid = node-&gt;uidOperand();
<span class="line-removed">3501         ASSERT(!(value.m_type &amp; ~SpecStringIdent)); // Edge filtering should have already ensured this.</span>
3502 
3503         JSValue childConstant = value.value();
3504         if (childConstant) {
<span class="line-modified">3505             ASSERT(childConstant.isString());</span>
<span class="line-modified">3506             if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {</span>
<span class="line-modified">3507                 m_state.setFoundConstants(true);</span>
<span class="line-modified">3508                 break;</span>






3509             }
3510         }
3511 
<span class="line-modified">3512         filter(value, SpecStringIdent);</span>



3513         break;
3514     }
3515 
3516     case CheckInBounds: {
3517         JSValue left = forNode(node-&gt;child1()).value();
3518         JSValue right = forNode(node-&gt;child2()).value();
3519         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
<span class="line-modified">3520             m_state.setFoundConstants(true);</span>
3521 
3522         // We claim we result in Int32. It&#39;s not really important what our result is (though we
3523         // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
3524         // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
3525         // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
3526         // thing to do here. We pick NodeResultJS because it makes converting this to an identity
3527         // easier.
3528         setNonCellTypeForNode(node, SpecInt32Only);
3529         break;
3530     }
3531 
3532     case PutById:
3533     case PutByIdFlush:
3534     case PutByIdDirect: {
3535         AbstractValue&amp; value = forNode(node-&gt;child1());
3536         if (value.m_structure.isFinite()) {
3537             PutByIdStatus status = PutByIdStatus::computeFor(
3538                 m_graph.globalObjectFor(node-&gt;origin.semantic),
3539                 value.m_structure.toStructureSet(),
3540                 m_graph.identifiers()[node-&gt;identifierNumber()],
3541                 node-&gt;op() == PutByIdDirect);
3542 

3543             if (status.isSimple()) {
3544                 RegisteredStructureSet newSet;
3545                 TransitionVector transitions;
3546 
<span class="line-modified">3547                 for (unsigned i = status.numVariants(); i--;) {</span>
<span class="line-modified">3548                     const PutByIdVariant&amp; variant = status[i];</span>









3549                     if (variant.kind() == PutByIdVariant::Transition) {
3550                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3551                         transitions.append(
3552                             Transition(
3553                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3554                         newSet.add(newStructure);
3555                     } else {
3556                         ASSERT(variant.kind() == PutByIdVariant::Replace);
3557                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
3558                     }
3559                 }
3560 
3561                 if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
<span class="line-modified">3562                     m_state.setFoundConstants(true);</span>
3563 
<span class="line-modified">3564                 didFoldClobberWorld();</span>
<span class="line-modified">3565                 observeTransitions(clobberLimit, transitions);</span>
<span class="line-modified">3566                 if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="line-modified">3567                     m_state.setIsValid(false);</span>
<span class="line-modified">3568                 break;</span>


3569             }
3570         }
3571 
3572         clobberWorld();
3573         break;
3574     }
3575 
3576     case PutByValWithThis:
3577     case PutByIdWithThis:
3578         clobberWorld();
3579         break;
3580 
3581     case PutGetterById:
3582     case PutSetterById:
3583     case PutGetterSetterById:
3584     case PutGetterByVal:
3585     case PutSetterByVal: {
3586         clobberWorld();
3587         break;
3588     }
</pre>
<hr />
<pre>
3591     case DefineAccessorProperty:
3592         clobberWorld();
3593         break;
3594 
3595     case InById: {
3596         // FIXME: We can determine when the property definitely exists based on abstract
3597         // value information.
3598         clobberWorld();
3599         filter(node-&gt;child1(), SpecObject);
3600         setNonCellTypeForNode(node, SpecBoolean);
3601         break;
3602     }
3603 
3604     case InByVal: {
3605         AbstractValue&amp; property = forNode(node-&gt;child2());
3606         if (JSValue constant = property.value()) {
3607             if (constant.isString()) {
3608                 JSString* string = asString(constant);
3609                 const StringImpl* impl = string-&gt;tryGetValueImpl();
3610                 if (impl &amp;&amp; impl-&gt;isAtom())
<span class="line-modified">3611                     m_state.setFoundConstants(true);</span>
3612             }
3613         }
3614 
3615         // FIXME: We can determine when the property definitely exists based on abstract
3616         // value information.
3617         clobberWorld();
3618         filter(node-&gt;child1(), SpecObject);
3619         setNonCellTypeForNode(node, SpecBoolean);
3620         break;
3621     }
3622 
3623     case HasOwnProperty: {
3624         clobberWorld();
3625         setNonCellTypeForNode(node, SpecBoolean);
3626         break;
3627     }
3628 
3629     case GetEnumerableLength: {
3630         setNonCellTypeForNode(node, SpecInt32Only);
3631         break;
</pre>
<hr />
<pre>
3716         break;
3717 
3718     case InstanceOf:
3719         clobberWorld();
3720         setNonCellTypeForNode(node, SpecBoolean);
3721         break;
3722 
3723     case InstanceOfCustom:
3724         clobberWorld();
3725         setNonCellTypeForNode(node, SpecBoolean);
3726         break;
3727 
3728     case MatchStructure: {
3729         AbstractValue base = forNode(node-&gt;child1());
3730         RegisteredStructureSet baseSet;
3731 
3732         BooleanLattice result = BooleanLattice::Bottom;
3733         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
3734             RegisteredStructure structure = variant.structure;
3735             if (!base.contains(structure)) {
<span class="line-modified">3736                 m_state.setFoundConstants(true);</span>
3737                 continue;
3738             }
3739 
3740             baseSet.add(structure);
3741             result = leastUpperBoundOfBooleanLattices(
3742                 result, variant.result ? BooleanLattice::True : BooleanLattice::False);
3743         }
3744 
3745         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3746             m_state.setIsValid(false);
3747 
3748         switch (result) {
3749         case BooleanLattice::False:
3750             setConstant(node, jsBoolean(false));
3751             break;
3752         case BooleanLattice::True:
3753             setConstant(node, jsBoolean(true));
3754             break;
3755         default:
3756             setNonCellTypeForNode(node, SpecBoolean);
3757             break;
3758         }
3759         break;
3760     }
3761 
3762     case Phi:
3763         RELEASE_ASSERT(m_graph.m_form == SSA);
3764         setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
3765         // The state of this node would have already been decided, but it may have become a
3766         // constant, in which case we&#39;d like to know.
3767         if (forNode(node).m_value)
<span class="line-modified">3768             m_state.setFoundConstants(true);</span>
3769         break;
3770 
3771     case Upsilon: {
3772         NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
3773         if (shadow.isStillValid()) {
3774             m_state.createValueForNode(shadow);
3775             setForNode(shadow, forNode(node-&gt;child1()));
3776         }
3777         break;
3778     }
3779 
3780     case Flush:
3781     case PhantomLocal:
3782         break;
3783 
3784     case Call:
3785     case TailCallInlinedCaller:
3786     case Construct:
3787     case CallVarargs:
3788     case CallForwardVarargs:
</pre>
<hr />
<pre>
3807         m_state.setStructureClobberState(StructuresAreWatched);
3808         m_state.observeInvalidationPoint();
3809         break;
3810 
3811     case CPUIntrinsic:
3812         if (node-&gt;intrinsic() == CPURdtscIntrinsic)
3813             setNonCellTypeForNode(node, SpecInt32Only);
3814         else
3815             setNonCellTypeForNode(node, SpecOther);
3816         break;
3817 
3818     case CheckTraps:
3819     case LogShadowChickenPrologue:
3820     case LogShadowChickenTail:
3821     case ProfileType:
3822     case ProfileControlFlow:
3823     case Phantom:
3824     case CountExecution:
3825     case CheckTierUpInLoop:
3826     case CheckTierUpAtReturn:

3827     case SuperSamplerBegin:
3828     case SuperSamplerEnd:
3829     case CheckTierUpAndOSREnter:
3830     case LoopHint:
3831     case ZombieHint:
3832     case ExitOK:
3833     case FilterCallLinkStatus:
<span class="line-modified">3834     case FilterGetByIdStatus:</span>
3835     case FilterPutByIdStatus:
3836     case FilterInByIdStatus:
3837     case ClearCatchLocals:
3838         break;
3839 
3840     case CheckTypeInfoFlags: {
3841         const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
3842         unsigned bits = node-&gt;typeInfoOperand();
3843         ASSERT(bits);
3844         if (bits == ImplementsDefaultHasInstance) {
3845             if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
<span class="line-modified">3846                 m_state.setFoundConstants(true);</span>
3847                 break;
3848             }
3849         }
3850 
3851         if (JSValue value = abstractValue.value()) {
3852             if (value.isCell()) {
3853                 // This works because if we see a cell here, we know it&#39;s fully constructed
3854                 // and we can read its inline type info flags. These flags don&#39;t change over the
3855                 // object&#39;s lifetime.
3856                 if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
<span class="line-modified">3857                     m_state.setFoundConstants(true);</span>
3858                     break;
3859                 }
3860             }
3861         }
3862 
3863         if (abstractValue.m_structure.isFinite()) {
3864             bool ok = true;
3865             abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3866                 ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
3867             });
3868             if (ok) {
<span class="line-modified">3869                 m_state.setFoundConstants(true);</span>
3870                 break;
3871             }
3872         }
3873 
3874         break;
3875     }
3876 
3877     case ParseInt: {
3878         AbstractValue value = forNode(node-&gt;child1());
3879         if (value.m_type &amp;&amp; !(value.m_type &amp; ~SpecInt32Only)) {
3880             JSValue radix;
3881             if (!node-&gt;child2())
3882                 radix = jsNumber(0);
3883             else
3884                 radix = forNode(node-&gt;child2()).m_value;
3885 
3886             if (radix.isNumber()
3887                 &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
<span class="line-modified">3888                 m_state.setFoundConstants(true);</span>
3889                 if (node-&gt;child1().useKind() == UntypedUse)
3890                     didFoldClobberWorld();
3891                 setNonCellTypeForNode(node, SpecInt32Only);
3892                 break;
3893             }
3894         }
3895 
3896         if (node-&gt;child1().useKind() == UntypedUse)
3897             clobberWorld();
3898         setNonCellTypeForNode(node, SpecBytecodeNumber);
3899         break;
3900     }
3901 
3902     case CreateRest:
3903         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
3904             // This means we&#39;re already having a bad time.
3905             clobberWorld();
3906             setTypeForNode(node, SpecArray);
3907             break;
3908         }
3909         setForNode(node,
3910             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure());
3911         break;
3912 
3913     case CheckVarargs:
3914     case Check: {
3915         // Simplify out checks that don&#39;t actually do checking.
3916         m_graph.doToChildren(node, [&amp;] (Edge edge) {
3917             if (!edge)
3918                 return;
3919             if (edge.isProved() || edge.willNotHaveCheck())
<span class="line-modified">3920                 m_state.setFoundConstants(true);</span>
3921         });
3922         break;
3923     }
3924 
3925     case SetFunctionName: {
3926         clobberWorld();
3927         break;
3928     }
3929 
3930     case StoreBarrier:
3931     case FencedStoreBarrier: {
3932         filter(node-&gt;child1(), SpecCell);
3933         break;
3934     }
3935 
3936     case DataViewGetInt: {
3937         DataViewData data = node-&gt;dataViewData();
3938         if (data.byteSize &lt; 4)
3939             setNonCellTypeForNode(node, SpecInt32Only);
3940         else {
3941             ASSERT(data.byteSize == 4);
3942             if (data.isSigned)
3943                 setNonCellTypeForNode(node, SpecInt32Only);
3944             else
3945                 setNonCellTypeForNode(node, SpecInt52Any);
3946         }
3947         break;
3948     }
3949 
3950     case DataViewGetFloat: {
3951         setNonCellTypeForNode(node, SpecFullDouble);
3952         break;
3953     }
3954 










3955     case DataViewSet: {
3956         break;
3957     }
3958 
3959     case Unreachable:
3960         // It may be that during a previous run of AI we proved that something was unreachable, but
3961         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
3962         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
3963         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
3964         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
3965         m_state.setIsValid(false);
3966         break;
3967 
3968     case LastNodeType:
3969     case ArithIMul:
3970     case FiatInt52:
3971         DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
3972         break;
3973     }
3974 
3975     return m_state.isValid();
3976 }
3977 
3978 template&lt;typename AbstractStateType&gt;
3979 void AbstractInterpreter&lt;AbstractStateType&gt;::filterICStatus(Node* node)
3980 {
3981     switch (node-&gt;op()) {
3982     case FilterCallLinkStatus:
3983         if (JSValue value = forNode(node-&gt;child1()).m_value)
3984             node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
3985         break;
3986 
<span class="line-modified">3987     case FilterGetByIdStatus: {</span>
3988         AbstractValue&amp; value = forNode(node-&gt;child1());
3989         if (value.m_structure.isFinite())
<span class="line-modified">3990             node-&gt;getByIdStatus()-&gt;filter(value.m_structure.toStructureSet());</span>
3991         break;
3992     }
3993 
3994     case FilterInByIdStatus: {
3995         AbstractValue&amp; value = forNode(node-&gt;child1());
3996         if (value.m_structure.isFinite())
3997             node-&gt;inByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
3998         break;
3999     }
4000 
4001     case FilterPutByIdStatus: {
4002         AbstractValue&amp; value = forNode(node-&gt;child1());
4003         if (value.m_structure.isFinite())
4004             node-&gt;putByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
4005         break;
4006     }
4007 
4008     default:
4009         RELEASE_ASSERT_NOT_REACHED();
4010         break;
</pre>
<hr />
<pre>
4111 }
4112 
4113 template&lt;typename AbstractStateType&gt;
4114 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4115     unsigned clobberLimit, const TransitionVector&amp; vector)
4116 {
4117     if (vector.isEmpty())
4118         return;
4119 
4120     // Stop performing precise structure transition tracking.
4121     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.
4122     // If it is too large, we conservatively clobber all the structures.
4123     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {
4124         clobberStructures();
4125         return;
4126     }
4127 
4128     AbstractValue::TransitionsObserver transitionsObserver(vector);
4129     forAllValues(clobberLimit, transitionsObserver);
4130 
<span class="line-modified">4131     if (!ASSERT_DISABLED) {</span>
4132         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4133         for (unsigned i = vector.size(); i--;)
4134             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4135     }
4136 
4137     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4138 }
4139 
4140 template&lt;typename AbstractStateType&gt;
4141 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4142 {
4143     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4144 }
4145 
4146 template&lt;typename AbstractStateType&gt;
4147 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
4148 {
4149     CommaPrinter comma(&quot; &quot;);
4150     HashSet&lt;NodeFlowProjection&gt; seen;
4151     if (m_graph.m_form == SSA) {
</pre>
<hr />
<pre>
4174             AbstractValue&amp; value = forNode(node);
4175             if (value.isClear())
4176                 continue;
4177             out.print(comma, node, &quot;:&quot;, value);
4178         }
4179     }
4180 }
4181 
4182 template&lt;typename AbstractStateType&gt;
4183 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4184     AbstractValue&amp; value, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes)
4185 {
4186     if (value.filter(m_graph, set, admittedTypes) == FiltrationOK)
4187         return FiltrationOK;
4188     m_state.setIsValid(false);
4189     return Contradiction;
4190 }
4191 
4192 template&lt;typename AbstractStateType&gt;
4193 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
<span class="line-modified">4194     AbstractValue&amp; value, ArrayModes arrayModes)</span>
4195 {
<span class="line-modified">4196     if (value.filterArrayModes(arrayModes) == FiltrationOK)</span>
4197         return FiltrationOK;
4198     m_state.setIsValid(false);
4199     return Contradiction;
4200 }
4201 
4202 template&lt;typename AbstractStateType&gt;
4203 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4204     AbstractValue&amp; value, SpeculatedType type)
4205 {
4206     if (value.filter(type) == FiltrationOK)
4207         return FiltrationOK;
4208     m_state.setIsValid(false);
4209     return Contradiction;
4210 }
4211 
4212 template&lt;typename AbstractStateType&gt;
4213 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterByValue(
4214     AbstractValue&amp; abstractValue, FrozenValue concreteValue)
4215 {
4216     if (abstractValue.filterByValue(concreteValue) == FiltrationOK)
</pre>
</td>
<td>
<hr />
<pre>
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
<span class="line-modified">  36 #include &quot;GetByStatus.h&quot;</span>
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;
<span class="line-added">  40 #include &quot;JSAsyncGenerator.h&quot;</span>
<span class="line-added">  41 #include &quot;JSGenerator.h&quot;</span>
  42 #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">  43 #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">  44 #include &quot;JSInternalPromiseConstructor.h&quot;</span>
<span class="line-added">  45 #include &quot;JSPromiseConstructor.h&quot;</span>
  46 #include &quot;MathCommon.h&quot;
  47 #include &quot;NumberConstructor.h&quot;
  48 #include &quot;Operations.h&quot;
  49 #include &quot;PutByIdStatus.h&quot;
  50 #include &quot;StringObject.h&quot;
  51 #include &quot;StructureCache.h&quot;
  52 #include &quot;StructureRareDataInlines.h&quot;
  53 #include &lt;wtf/BooleanLattice.h&gt;
  54 #include &lt;wtf/CheckedArithmetic.h&gt;
  55 
  56 namespace JSC { namespace DFG {
  57 
  58 template&lt;typename AbstractStateType&gt;
  59 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  60     : m_codeBlock(graph.m_codeBlock)
  61     , m_graph(graph)
  62     , m_vm(m_graph.m_vm)
  63     , m_state(state)
  64 {
  65     if (m_graph.m_form == SSA)
  66         m_phiChildren = makeUnique&lt;PhiChildren&gt;(m_graph);
  67 }
  68 
  69 template&lt;typename AbstractStateType&gt;
  70 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  71 {
  72 }
  73 
  74 template&lt;typename AbstractStateType&gt;
  75 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  76 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  77     Node* node, AbstractValue&amp; value)
  78 {
  79     JSValue childConst = value.value();
  80     if (childConst) {
<span class="line-modified">  81         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)))</span>
  82             return DefinitelyTrue;
  83         return DefinitelyFalse;
  84     }
  85 
  86     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
  87     if (isCellSpeculation(value.m_type) &amp;&amp; !value.m_structure.isTop()) {
  88         bool allTrue = true;
  89         for (unsigned i = value.m_structure.size(); i--;) {
  90             RegisteredStructure structure = value.m_structure[i];
  91             if (structure-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
  92                 || structure-&gt;typeInfo().type() == StringType) {
  93                 allTrue = false;
  94                 break;
  95             }
  96         }
  97         if (allTrue)
  98             return DefinitelyTrue;
  99     }
 100 
 101     return UnknownBooleanResult;
</pre>
<hr />
<pre>
 245     JSValue right = forNode(node-&gt;child2()).value();
 246     if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 247         int32_t a = left.asInt32();
 248         int32_t b = right.asInt32();
 249         if (node-&gt;isBinaryUseKind(UntypedUse))
 250             didFoldClobberWorld();
 251         NodeType op = node-&gt;op();
 252         switch (op) {
 253         case ValueBitAnd:
 254         case ArithBitAnd:
 255             setConstant(node, JSValue(a &amp; b));
 256             break;
 257         case ValueBitOr:
 258         case ArithBitOr:
 259             setConstant(node, JSValue(a | b));
 260             break;
 261         case ValueBitXor:
 262         case ArithBitXor:
 263             setConstant(node, JSValue(a ^ b));
 264             break;
<span class="line-modified"> 265         case ArithBitRShift:</span>
<span class="line-added"> 266         case ValueBitRShift:</span>
 267             setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
 268             break;
 269         case ValueBitLShift:
 270         case ArithBitLShift:
 271             setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
 272             break;
 273         case BitURShift:
 274             setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));
 275             break;
 276         default:
 277             RELEASE_ASSERT_NOT_REACHED();
 278             break;
 279         }
 280 
 281         return true;
 282     }
 283 
 284     return false;
 285 }
 286 
</pre>
<hr />
<pre>
 306                 doubleResult = fmod(left.asNumber(), right.asNumber());
 307 
 308             if (node-&gt;hasArithMode()) {
 309                 if (!shouldCheckOverflow(node-&gt;arithMode()))
 310                     doubleResult = toInt32(doubleResult);
 311                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 312                     doubleResult += 0; // Sanitizes zero.
 313             }
 314 
 315             JSValue valueResult = jsNumber(doubleResult);
 316             if (valueResult.isInt32()) {
 317                 if (isClobbering)
 318                     didFoldClobberWorld();
 319                 setConstant(node, valueResult);
 320                 return true;
 321             }
 322         } else if (left.isNumber() &amp;&amp; right.isNumber()) {
 323             if (isClobbering)
 324                 didFoldClobberWorld();
 325 
<span class="line-modified"> 326             if (isDivOperation) {</span>
<span class="line-modified"> 327                 if (op == ValueDiv)</span>
<span class="line-modified"> 328                     setConstant(node, jsNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-modified"> 329                 else</span>
<span class="line-added"> 330                     setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));</span>
<span class="line-added"> 331             } else {</span>
<span class="line-added"> 332                 if (op == ValueMod)</span>
<span class="line-added"> 333                     setConstant(node, jsNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-added"> 334                 else</span>
<span class="line-added"> 335                     setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));</span>
<span class="line-added"> 336             }</span>
 337 
 338             return true;
 339         }
 340     }
 341 
 342     return false;
 343 }
 344 
 345 template&lt;typename AbstractStateType&gt;
 346 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 347 {
 348     verifyEdges(node);
 349 
 350     m_state.createValueForNode(node);
 351 
 352     switch (node-&gt;op()) {
 353     case JSConstant:
 354     case DoubleConstant:
 355     case Int52Constant: {
 356         setBuiltInConstant(node, *node-&gt;constant());
</pre>
<hr />
<pre>
 359 
 360     case LazyJSConstant: {
 361         LazyJSValue value = node-&gt;lazyJSValue();
 362         switch (value.kind()) {
 363         case LazyJSValue::KnownValue:
 364             setConstant(node, value.value()-&gt;value());
 365             break;
 366         case LazyJSValue::SingleCharacterString:
 367         case LazyJSValue::KnownStringImpl:
 368         case LazyJSValue::NewStringImpl:
 369             setTypeForNode(node, SpecString);
 370             break;
 371         }
 372         break;
 373     }
 374 
 375     case IdentityWithProfile:
 376     case Identity: {
 377         setForNode(node, forNode(node-&gt;child1()));
 378         if (forNode(node).value())
<span class="line-modified"> 379             m_state.setShouldTryConstantFolding(true);</span>
 380         break;
 381     }
 382 
 383     case ExtractCatchLocal:
 384     case ExtractOSREntryLocal: {
 385         makeBytecodeTopForNode(node);
 386         break;
 387     }
 388 
 389     case GetLocal: {
 390         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
<span class="line-modified"> 391         AbstractValue value = m_state.operand(variableAccessData-&gt;operand());</span>
 392         // The value in the local should already be checked.
 393         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
 394         if (value.value())
<span class="line-modified"> 395             m_state.setShouldTryConstantFolding(true);</span>
 396         setForNode(node, value);
 397         break;
 398     }
 399 
 400     case GetStack: {
 401         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified"> 402         AbstractValue value = m_state.operand(data-&gt;operand);</span>
 403         // The value in the local should already be checked.
 404         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
 405         if (value.value())
<span class="line-modified"> 406             m_state.setShouldTryConstantFolding(true);</span>
 407         setForNode(node, value);
 408         break;
 409     }
 410 
 411     case SetLocal: {
<span class="line-modified"> 412         m_state.operand(node-&gt;operand()) = forNode(node-&gt;child1());</span>
 413         break;
 414     }
 415 
 416     case PutStack: {
<span class="line-modified"> 417         m_state.operand(node-&gt;stackAccessData()-&gt;operand) = forNode(node-&gt;child1());</span>
 418         break;
 419     }
 420 
 421     case MovHint: {
 422         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 423         // in bytecode, but this code is just concerned with what is actually happening during
 424         // DFG execution.
 425         break;
 426     }
 427 
 428     case KillStack: {
 429         // This is just a hint telling us that the OSR state of the local is no longer inside the
 430         // flushed data.
 431         break;
 432     }
 433 
 434     case SetArgumentDefinitely:
 435     case SetArgumentMaybe:
 436         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means
 437         // that someone set the argument values out-of-band, and currently this always means setting to a
 438         // non-clear value.
<span class="line-modified"> 439         ASSERT(!m_state.operand(node-&gt;operand()).isClear());</span>
 440         break;
 441 
 442     case InitializeEntrypointArguments: {
 443         unsigned entrypointIndex = node-&gt;entrypointIndex();
 444         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 445         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 446             AbstractValue&amp; value = m_state.argument(argument);
 447             switch (argumentFormats[argument]) {
 448             case FlushedInt32:
 449                 value.setNonCellType(SpecInt32Only);
 450                 break;
 451             case FlushedBoolean:
 452                 value.setNonCellType(SpecBoolean);
 453                 break;
 454             case FlushedCell:
 455                 value.setType(m_graph, SpecCellCheck);
 456                 break;
 457             case FlushedJSValue:
 458                 value.makeBytecodeTop();
 459                 break;
 460             default:
 461                 DFG_CRASH(m_graph, node, &quot;Bad flush format for argument&quot;);
 462                 break;
 463             }
 464         }
 465         break;
 466     }
 467 
<span class="line-added"> 468     case VarargsLength: {</span>
<span class="line-added"> 469         clobberWorld();</span>
<span class="line-added"> 470         setTypeForNode(node, SpecInt32Only);</span>
<span class="line-added"> 471         break;</span>
<span class="line-added"> 472     }</span>
<span class="line-added"> 473 </span>
 474     case LoadVarargs:
 475     case ForwardVarargs: {
 476         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 477         // itself into a straight-line sequence of GetStack/PutStack.
 478         // https://bugs.webkit.org/show_bug.cgi?id=143071
 479         switch (node-&gt;op()) {
 480         case LoadVarargs:
 481             clobberWorld();
 482             break;
 483         case ForwardVarargs:
 484             break;
 485         default:
 486             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 487             break;
 488         }
 489         LoadVarargsData* data = node-&gt;loadVarargsData();
 490         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 491         for (unsigned i = data-&gt;limit - 1; i--;)
<span class="line-modified"> 492             m_state.operand(data-&gt;start + i).makeHeapTop();</span>
 493         break;
 494     }
 495 
 496     case ValueBitNot: {
 497         JSValue operand = forNode(node-&gt;child1()).value();
 498         if (operand &amp;&amp; operand.isInt32()) {
 499             didFoldClobberWorld();
 500             int32_t a = operand.asInt32();
 501             setConstant(node, JSValue(~a));
 502             break;
 503         }
 504 
 505         if (node-&gt;child1().useKind() == BigIntUse)
 506             setTypeForNode(node, SpecBigInt);
 507         else {
 508             clobberWorld();
 509             setTypeForNode(node, SpecInt32Only | SpecBigInt);
 510         }
 511 
 512         break;
 513     }
 514 
 515     case ArithBitNot: {
 516         JSValue operand = forNode(node-&gt;child1()).value();
 517         if (operand &amp;&amp; operand.isInt32()) {
 518             int32_t a = operand.asInt32();
 519             setConstant(node, JSValue(~a));
 520             break;
 521         }
 522 
 523         setNonCellTypeForNode(node, SpecInt32Only);
 524         break;
 525     }
 526 
 527     case ValueBitXor:
 528     case ValueBitAnd:
 529     case ValueBitOr:
<span class="line-added"> 530     case ValueBitRShift:</span>
 531     case ValueBitLShift: {
 532         if (handleConstantBinaryBitwiseOp(node))
 533             break;
 534 
 535         if (node-&gt;binaryUseKind() == BigIntUse)
 536             setTypeForNode(node, SpecBigInt);
 537         else {
 538             clobberWorld();
 539             setTypeForNode(node, SpecInt32Only | SpecBigInt);
 540         }
 541         break;
 542     }
 543 
 544     case ArithBitAnd:
 545     case ArithBitOr:
 546     case ArithBitXor:
<span class="line-modified"> 547     case ArithBitRShift:</span>
 548     case ArithBitLShift:
 549     case BitURShift: {
 550         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 551             clobberWorld();
 552             setNonCellTypeForNode(node, SpecInt32Only);
 553             break;
 554         }
 555 
 556         if (handleConstantBinaryBitwiseOp(node))
 557             break;
 558 
 559         if (node-&gt;op() == ArithBitAnd
 560             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 561                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 562             setNonCellTypeForNode(node, SpecBoolInt32);
 563             break;
 564         }
 565 
 566         setNonCellTypeForNode(node, SpecInt32Only);
 567         break;
</pre>
<hr />
<pre>
 593                 setConstant(node, jsNumber(value));
 594                 break;
 595             }
 596         }
 597         setNonCellTypeForNode(node, SpecInt32Only);
 598         break;
 599     }
 600 
 601     case BooleanToNumber: {
 602         JSValue concreteValue = forNode(node-&gt;child1()).value();
 603         if (concreteValue) {
 604             if (concreteValue.isBoolean())
 605                 setConstant(node, jsNumber(concreteValue.asBoolean()));
 606             else
 607                 setConstant(node, *m_graph.freeze(concreteValue));
 608             break;
 609         }
 610         AbstractValue&amp; value = forNode(node);
 611         value = forNode(node-&gt;child1());
 612         if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
<span class="line-modified"> 613             m_state.setShouldTryConstantFolding(true);</span>
 614         if (value.m_type &amp; SpecBoolean) {
 615             value.merge(SpecBoolInt32);
 616             value.filter(~SpecBoolean);
 617         }
 618         break;
 619     }
 620 
 621     case DoubleAsInt32: {
 622         JSValue child = forNode(node-&gt;child1()).value();
 623         if (child &amp;&amp; child.isNumber()) {
 624             double asDouble = child.asNumber();
 625             int32_t asInt = JSC::toInt32(asDouble);
 626             if (bitwise_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(asInt)) == bitwise_cast&lt;int64_t&gt;(asDouble)) {
 627                 setConstant(node, JSValue(asInt));
 628                 break;
 629             }
 630         }
 631         setNonCellTypeForNode(node, SpecInt32Only);
 632         break;
 633     }
</pre>
<hr />
<pre>
 815         break;
 816     }
 817 
 818     case MakeRope: {
 819         unsigned numberOfRemovedChildren = 0;
 820         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 821             Edge&amp; edge = node-&gt;children.child(i);
 822             if (!edge)
 823                 break;
 824             JSValue childConstant = m_state.forNode(edge).value();
 825             if (!childConstant)
 826                 continue;
 827             if (!childConstant.isString())
 828                 continue;
 829             if (asString(childConstant)-&gt;length())
 830                 continue;
 831             ++numberOfRemovedChildren;
 832         }
 833 
 834         if (numberOfRemovedChildren)
<span class="line-modified"> 835             m_state.setShouldTryConstantFolding(true);</span>
 836         setForNode(node, m_vm.stringStructure.get());
 837         break;
 838     }
 839 
 840     case ArithSub: {
 841         JSValue left = forNode(node-&gt;child1()).value();
 842         JSValue right = forNode(node-&gt;child2()).value();
 843         switch (node-&gt;binaryUseKind()) {
 844         case Int32Use:
 845             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 846                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 847                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 848                     break;
 849                 }
 850                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 851                 if (result.isInt32()) {
 852                     setConstant(node, result);
 853                     break;
 854                 }
 855             }
</pre>
<hr />
<pre>
 927                 }
 928             }
 929             setNonCellTypeForNode(node, SpecInt52Any);
 930             break;
 931         case DoubleRepUse:
 932             if (child &amp;&amp; child.isNumber()) {
 933                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 934                 break;
 935             }
 936             setNonCellTypeForNode(node,
 937                 typeOfDoubleNegation(
 938                     forNode(node-&gt;child1()).m_type));
 939             break;
 940         default:
 941             RELEASE_ASSERT_NOT_REACHED();
 942             break;
 943         }
 944         break;
 945     }
 946 
<span class="line-added"> 947     case Inc:</span>
<span class="line-added"> 948     case Dec: {</span>
<span class="line-added"> 949         // FIXME: support some form of constant folding here.</span>
<span class="line-added"> 950         // https://bugs.webkit.org/show_bug.cgi?id=204258</span>
<span class="line-added"> 951         switch (node-&gt;child1().useKind()) {</span>
<span class="line-added"> 952         case Int32Use:</span>
<span class="line-added"> 953             setNonCellTypeForNode(node, SpecInt32Only);</span>
<span class="line-added"> 954             break;</span>
<span class="line-added"> 955         case Int52RepUse:</span>
<span class="line-added"> 956             setNonCellTypeForNode(node, SpecInt52Any);</span>
<span class="line-added"> 957             break;</span>
<span class="line-added"> 958         case DoubleRepUse:</span>
<span class="line-added"> 959             setNonCellTypeForNode(node, typeOfDoubleIncOrDec(forNode(node-&gt;child1()).m_type));</span>
<span class="line-added"> 960             break;</span>
<span class="line-added"> 961         case BigIntUse:</span>
<span class="line-added"> 962             setTypeForNode(node, SpecBigInt);</span>
<span class="line-added"> 963             break;</span>
<span class="line-added"> 964         default:</span>
<span class="line-added"> 965             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="line-added"> 966             clobberWorld(); // Because of the call to ToNumeric()</span>
<span class="line-added"> 967             break;</span>
<span class="line-added"> 968         }</span>
<span class="line-added"> 969         break;</span>
<span class="line-added"> 970     }</span>
<span class="line-added"> 971 </span>
 972     case ValuePow: {
 973         JSValue childX = forNode(node-&gt;child1()).value();
 974         JSValue childY = forNode(node-&gt;child2()).value();
 975         if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {
 976             // We need to call `didFoldClobberWorld` here because this path is only possible
 977             // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be
 978             // cleared by `AbstractInterpreter::executeEffects`.
 979             didFoldClobberWorld();
<span class="line-modified"> 980             // Our boxing scheme here matches what we do in operationValuePow.</span>
<span class="line-added"> 981             setConstant(node, jsNumber(operationMathPow(childX.asNumber(), childY.asNumber())));</span>
 982             break;
 983         }
 984 
 985         if (node-&gt;binaryUseKind() == BigIntUse)
 986             setTypeForNode(node, SpecBigInt);
 987         else {
 988             clobberWorld();
 989             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 990         }
 991         break;
 992     }
 993 
 994     case ValueMul: {
 995         if (node-&gt;binaryUseKind() == BigIntUse)
 996             setTypeForNode(node, SpecBigInt);
 997         else {
 998             clobberWorld();
 999             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
1000         }
1001         break;
</pre>
<hr />
<pre>
1292                 // Although C++ code uses uint32_t for the hash, the closest type in DFG IR is Int32
1293                 // and that&#39;s what MapHash returns. So, we have to cast to int32_t to avoid large
1294                 // unsigned values becoming doubles. This casting between signed and unsigned
1295                 // happens in the assembly code we emit when we don&#39;t constant fold this node.
1296                 setConstant(node, jsNumber(static_cast&lt;int32_t&gt;(*hash)));
1297                 break;
1298             }
1299         }
1300         setNonCellTypeForNode(node, SpecInt32Only);
1301         break;
1302     }
1303 
1304     case NormalizeMapKey: {
1305         if (JSValue key = forNode(node-&gt;child1()).value()) {
1306             setConstant(node, *m_graph.freeze(normalizeMapKey(key)));
1307             break;
1308         }
1309 
1310         SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
1311         if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
<span class="line-modified">1312             m_state.setShouldTryConstantFolding(true);</span>
1313             forNode(node) = forNode(node-&gt;child1());
1314             break;
1315         }
1316 
1317         makeHeapTopForNode(node);
1318         break;
1319     }
1320 
1321     case StringValueOf: {
1322         clobberWorld();
1323         setTypeForNode(node, SpecString);
1324         break;
1325     }
1326 
1327     case StringSlice: {
1328         setTypeForNode(node, SpecString);
1329         break;
1330     }
1331 
1332     case ToLowerCase: {
</pre>
<hr />
<pre>
1441                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1442                         constantWasSet = false;
1443                     }
1444                 } else
1445                     setConstant(node, jsBoolean(false));
1446                 break;
1447             case IsEmpty:
1448                 setConstant(node, jsBoolean(child.value().isEmpty()));
1449                 break;
1450             case IsTypedArrayView:
1451                 setConstant(node, jsBoolean(child.value().isObject() &amp;&amp; isTypedView(child.value().getObject()-&gt;classInfo(m_vm)-&gt;typedArrayStorageType)));
1452                 break;
1453             default:
1454                 constantWasSet = false;
1455                 break;
1456             }
1457             if (constantWasSet)
1458                 break;
1459         }
1460 
<span class="line-added">1461         if (!(child.m_type &amp; ~SpecCell)) {</span>
<span class="line-added">1462             if (child.m_structure.isFinite()) {</span>
<span class="line-added">1463                 bool constantWasSet = false;</span>
<span class="line-added">1464                 switch (node-&gt;op()) {</span>
<span class="line-added">1465                 case IsCellWithType: {</span>
<span class="line-added">1466                     bool ok = true;</span>
<span class="line-added">1467                     Optional&lt;bool&gt; result;</span>
<span class="line-added">1468                     child.m_structure.forEach(</span>
<span class="line-added">1469                         [&amp;] (RegisteredStructure structure) {</span>
<span class="line-added">1470                             bool matched = structure-&gt;typeInfo().type() == node-&gt;queriedType();</span>
<span class="line-added">1471                             if (!result)</span>
<span class="line-added">1472                                 result = matched;</span>
<span class="line-added">1473                             else {</span>
<span class="line-added">1474                                 if (result.value() != matched)</span>
<span class="line-added">1475                                     ok = false;</span>
<span class="line-added">1476                             }</span>
<span class="line-added">1477                         });</span>
<span class="line-added">1478                     if (ok &amp;&amp; result) {</span>
<span class="line-added">1479                         setConstant(node, jsBoolean(result.value()));</span>
<span class="line-added">1480                         constantWasSet = true;</span>
<span class="line-added">1481                     }</span>
<span class="line-added">1482                     break;</span>
<span class="line-added">1483                 }</span>
<span class="line-added">1484                 default:</span>
<span class="line-added">1485                     break;</span>
<span class="line-added">1486                 }</span>
<span class="line-added">1487                 if (constantWasSet)</span>
<span class="line-added">1488                     break;</span>
<span class="line-added">1489             }</span>
<span class="line-added">1490         }</span>
<span class="line-added">1491 </span>
1492         // FIXME: This code should really use AbstractValue::isType() and
1493         // AbstractValue::couldBeType().
1494         // https://bugs.webkit.org/show_bug.cgi?id=146870
1495 
1496         bool constantWasSet = false;
1497         switch (node-&gt;op()) {
1498         case IsEmpty: {
1499             if (child.m_type &amp;&amp; !(child.m_type &amp; SpecEmpty)) {
1500                 setConstant(node, jsBoolean(false));
1501                 constantWasSet = true;
1502                 break;
1503             }
1504 
1505             if (child.m_type &amp;&amp; !(child.m_type &amp; ~SpecEmpty)) {
1506                 setConstant(node, jsBoolean(true));
1507                 constantWasSet = true;
1508                 break;
1509             }
1510 
1511             break;
</pre>
<hr />
<pre>
1621                 setConstant(node, jsBoolean(false));
1622                 constantWasSet = true;
1623                 break;
1624             }
1625 
1626             break;
1627         case IsFunction:
1628             if (!(child.m_type &amp; ~SpecFunction)) {
1629                 setConstant(node, jsBoolean(true));
1630                 constantWasSet = true;
1631                 break;
1632             }
1633 
1634             if (!(child.m_type &amp; (SpecFunction | SpecObjectOther | SpecProxyObject))) {
1635                 setConstant(node, jsBoolean(false));
1636                 constantWasSet = true;
1637                 break;
1638             }
1639             break;
1640 
<span class="line-modified">1641         case IsCellWithType: {</span>
<span class="line-modified">1642             Optional&lt;SpeculatedType&gt; filter = node-&gt;speculatedTypeForQuery();</span>
<span class="line-added">1643             if (!filter) {</span>
<span class="line-added">1644                 if (!(child.m_type &amp; SpecCell)) {</span>
<span class="line-added">1645                     setConstant(node, jsBoolean(false));</span>
<span class="line-added">1646                     constantWasSet = true;</span>
<span class="line-added">1647                 }</span>
<span class="line-added">1648                 break;</span>
<span class="line-added">1649             }</span>
<span class="line-added">1650             if (!(child.m_type &amp; ~filter.value())) {</span>
1651                 setConstant(node, jsBoolean(true));
1652                 constantWasSet = true;
1653                 break;
1654             }
<span class="line-modified">1655             if (!(child.m_type &amp; filter.value())) {</span>
1656                 setConstant(node, jsBoolean(false));
1657                 constantWasSet = true;
1658                 break;
1659             }
1660             break;
<span class="line-added">1661         }</span>
1662 
1663         case IsTypedArrayView:
1664             if (!(child.m_type &amp; ~SpecTypedArrayView)) {
1665                 setConstant(node, jsBoolean(true));
1666                 constantWasSet = true;
1667                 break;
1668             }
1669             if (!(child.m_type &amp; SpecTypedArrayView)) {
1670                 setConstant(node, jsBoolean(false));
1671                 constantWasSet = true;
1672                 break;
1673             }
1674             break;
1675 
1676         default:
1677             break;
1678         }
1679         if (constantWasSet)
1680             break;
1681 
</pre>
<hr />
<pre>
1926                 if (a &amp;&amp; b) {
1927                     setConstant(node, jsBoolean(WTF::equal(a, b)));
1928                     break;
1929                 }
1930             } else {
1931                 if (node-&gt;op() == CompareStrictEq)
1932                     setConstant(node, jsBoolean(JSValue::strictEqual(nullptr, left, right)));
1933                 else
1934                     setConstant(node, jsBoolean(sameValue(nullptr, left, right)));
1935                 break;
1936             }
1937         }
1938 
1939         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1940             // FIXME: Revisit this condition when introducing BigInt to JSC.
1941             auto isNonStringCellConstant = [] (JSValue value) {
1942                 return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
1943             };
1944 
1945             if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
<span class="line-modified">1946                 m_state.setShouldTryConstantFolding(true);</span>
1947                 setNonCellTypeForNode(node, SpecBoolean);
1948                 break;
1949             }
1950         }
1951 
1952         SpeculatedType leftLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(leftNode).m_type);
1953         SpeculatedType rightLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(rightNode).m_type);
1954         if (!(leftLUB &amp; rightLUB)) {
1955             setConstant(node, jsBoolean(false));
1956             break;
1957         }
1958 
1959         if (node-&gt;child1() == node-&gt;child2()) {
1960             if (node-&gt;isBinaryUseKind(BooleanUse) ||
1961                 node-&gt;isBinaryUseKind(Int32Use) ||
1962                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1963                 node-&gt;isBinaryUseKind(StringUse) ||
1964                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1965                 node-&gt;isBinaryUseKind(SymbolUse) ||
1966                 node-&gt;isBinaryUseKind(ObjectUse) ||
</pre>
<hr />
<pre>
1975             }
1976         }
1977 
1978         setNonCellTypeForNode(node, SpecBoolean);
1979         break;
1980     }
1981 
1982     case CompareEqPtr: {
1983         Node* childNode = node-&gt;child1().node();
1984         JSValue childValue = forNode(childNode).value();
1985         if (childValue) {
1986             setConstant(node, jsBoolean(childValue.isCell() &amp;&amp; childValue.asCell() == node-&gt;cellOperand()-&gt;cell()));
1987             break;
1988         }
1989 
1990         setNonCellTypeForNode(node, SpecBoolean);
1991         break;
1992     }
1993 
1994     case StringCharCodeAt:
<span class="line-added">1995     case StringCodePointAt:</span>
1996         setNonCellTypeForNode(node, SpecInt32Only);
1997         break;
1998 
1999     case StringFromCharCode:
2000         switch (node-&gt;child1().useKind()) {
2001         case Int32Use:
2002             break;
2003         case UntypedUse:
2004             clobberWorld();
2005             break;
2006         default:
2007             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
2008             break;
2009         }
2010         setTypeForNode(node, SpecString);
2011         break;
2012 
2013     case StringCharAt:
2014         setForNode(node, m_vm.stringStructure.get());
2015         break;
</pre>
<hr />
<pre>
2354     case ArrayPop:
2355         clobberWorld();
2356         makeHeapTopForNode(node);
2357         break;
2358 
2359     case GetMyArgumentByVal:
2360     case GetMyArgumentByValOutOfBounds: {
2361         JSValue index = forNode(node-&gt;child2()).m_value;
2362         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
2363 
2364         if (index &amp;&amp; index.isUInt32()) {
2365             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2366             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2367             // paths as unreachable, or to return undefined. We could implement that eventually.
2368 
2369             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2370             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2371             unsigned argumentIndex;
2372             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2373                 if (inlineCallFrame) {
<span class="line-modified">2374                     if (argumentIndex &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1)) {</span>
2375                         setForNode(node, m_state.operand(
<span class="line-modified">2376                             virtualRegisterForArgumentIncludingThis(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));</span>
<span class="line-modified">2377                         m_state.setShouldTryConstantFolding(true);</span>
2378                         break;
2379                     }
2380                 } else {
2381                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2382                         setForNode(node, m_state.argument(argumentIndex + 1));
<span class="line-modified">2383                         m_state.setShouldTryConstantFolding(true);</span>
2384                         break;
2385                     }
2386                 }
2387             }
2388         }
2389 
2390         if (inlineCallFrame) {
2391             // We have a bound on the types even though it&#39;s random access. Take advantage of this.
2392 
2393             AbstractValue result;
2394             for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
2395                 result.merge(
2396                     m_state.operand(
<span class="line-modified">2397                         virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset));</span>
2398             }
2399 
2400             if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
2401                 result.merge(SpecOther);
2402 
2403             if (result.value())
<span class="line-modified">2404                 m_state.setShouldTryConstantFolding(true);</span>
2405 
2406             setForNode(node, result);
2407             break;
2408         }
2409 
2410         makeHeapTopForNode(node);
2411         break;
2412     }
2413 
2414     case RegExpExec:
2415     case RegExpExecNonGlobalOrSticky:
2416         if (node-&gt;op() == RegExpExec) {
2417             // Even if we&#39;ve proven known input types as RegExpObject and String,
2418             // accessing lastIndex is effectful if it&#39;s a global regexp.
2419             clobberWorld();
2420         }
2421 
2422         if (JSValue globalObjectValue = forNode(node-&gt;child1()).m_value) {
2423             if (JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(m_vm, globalObjectValue)) {
2424                 if (!globalObject-&gt;isHavingABadTime()) {
2425                     m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2426                     RegisteredStructureSet structureSet;
2427                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayStructure()));

2428                     setForNode(node, structureSet);
2429                     forNode(node).merge(SpecOther);
2430                     break;
2431                 }
2432             }
2433         }
2434         setTypeForNode(node, SpecOther | SpecArray);
2435         break;
2436 
2437     case RegExpTest:
2438         // Even if we&#39;ve proven known input types as RegExpObject and String,
2439         // accessing lastIndex is effectful if it&#39;s a global regexp.
2440         clobberWorld();
2441         setNonCellTypeForNode(node, SpecBoolean);
2442         break;
2443 
2444     case RegExpMatchFast:
2445         ASSERT(node-&gt;child2().useKind() == RegExpObjectUse);
2446         ASSERT(node-&gt;child3().useKind() == StringUse || node-&gt;child3().useKind() == KnownStringUse);
2447         setTypeForNode(node, SpecOther | SpecArray);
</pre>
<hr />
<pre>
2502     case ThrowStaticError:
2503     case TailCall:
2504     case DirectTailCall:
2505     case TailCallVarargs:
2506     case TailCallForwardVarargs:
2507         clobberWorld();
2508         m_state.setIsValid(false);
2509         break;
2510 
2511     case ToPrimitive: {
2512         JSValue childConst = forNode(node-&gt;child1()).value();
2513         if (childConst &amp;&amp; childConst.isNumber()) {
2514             didFoldClobberWorld();
2515             setConstant(node, childConst);
2516             break;
2517         }
2518 
2519         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2520 
2521         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
<span class="line-modified">2522             m_state.setShouldTryConstantFolding(true);</span>
2523             didFoldClobberWorld();
2524             setForNode(node, forNode(node-&gt;child1()));
2525             break;
2526         }
2527 
2528         clobberWorld();
2529 
2530         setTypeForNode(node, SpecHeapTop &amp; ~SpecObject);
2531         break;
2532     }
2533 
<span class="line-added">2534     case ToPropertyKey: {</span>
<span class="line-added">2535         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecString | SpecSymbol))) {</span>
<span class="line-added">2536             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">2537             didFoldClobberWorld();</span>
<span class="line-added">2538             setForNode(node, forNode(node-&gt;child1()));</span>
<span class="line-added">2539             break;</span>
<span class="line-added">2540         }</span>
<span class="line-added">2541 </span>
<span class="line-added">2542         clobberWorld();</span>
<span class="line-added">2543 </span>
<span class="line-added">2544         setTypeForNode(node, SpecString | SpecSymbol);</span>
<span class="line-added">2545         break;</span>
<span class="line-added">2546     }</span>
<span class="line-added">2547 </span>
2548     case ToNumber: {
2549         JSValue childConst = forNode(node-&gt;child1()).value();
2550         if (childConst &amp;&amp; childConst.isNumber()) {
2551             didFoldClobberWorld();
2552             setConstant(node, childConst);
2553             break;
2554         }
2555 
2556         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2557 
2558         if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
<span class="line-modified">2559             m_state.setShouldTryConstantFolding(true);</span>
2560             didFoldClobberWorld();
2561             setForNode(node, forNode(node-&gt;child1()));
2562             break;
2563         }
2564 
2565         clobberWorld();
2566         setNonCellTypeForNode(node, SpecBytecodeNumber);
2567         break;
2568     }
2569 
<span class="line-added">2570     case ToNumeric: {</span>
<span class="line-added">2571         JSValue childConst = forNode(node-&gt;child1()).value();</span>
<span class="line-added">2572         if (childConst &amp;&amp; (childConst.isNumber() || childConst.isBigInt())) {</span>
<span class="line-added">2573             didFoldClobberWorld();</span>
<span class="line-added">2574             setConstant(node, childConst);</span>
<span class="line-added">2575             break;</span>
<span class="line-added">2576         }</span>
<span class="line-added">2577 </span>
<span class="line-added">2578         ASSERT(node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added">2579 </span>
<span class="line-added">2580         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecBytecodeNumber | SpecBigInt))) {</span>
<span class="line-added">2581             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">2582             didFoldClobberWorld();</span>
<span class="line-added">2583             setForNode(node, forNode(node-&gt;child1()));</span>
<span class="line-added">2584             break;</span>
<span class="line-added">2585         }</span>
<span class="line-added">2586 </span>
<span class="line-added">2587         clobberWorld();</span>
<span class="line-added">2588         setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);</span>
<span class="line-added">2589         break;</span>
<span class="line-added">2590     }</span>
<span class="line-added">2591 </span>
2592     case ToString:
2593     case CallStringConstructor: {
2594         switch (node-&gt;child1().useKind()) {
2595         case StringObjectUse:
2596         case StringOrStringObjectUse:
2597         case Int32Use:
2598         case Int52RepUse:
2599         case DoubleRepUse:
2600         case NotCellUse:
2601             break;
2602         case CellUse:
2603         case UntypedUse:
2604             clobberWorld();
2605             break;
2606         default:
2607             RELEASE_ASSERT_NOT_REACHED();
2608             break;
2609         }
2610         setForNode(node, m_vm.stringStructure.get());
2611         break;
2612     }
2613 
2614     case NumberToStringWithRadix: {
2615         JSValue radixValue = forNode(node-&gt;child2()).m_value;
2616         if (radixValue &amp;&amp; radixValue.isInt32()) {
2617             int32_t radix = radixValue.asInt32();
2618             if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
<span class="line-modified">2619                 m_state.setShouldTryConstantFolding(true);</span>
2620                 didFoldClobberWorld();
2621                 setForNode(node, m_graph.m_vm.stringStructure.get());
2622                 break;
2623             }
2624         }
2625         clobberWorld();
2626         setForNode(node, m_graph.m_vm.stringStructure.get());
2627         break;
2628     }
2629 
2630     case NumberToStringWithValidRadixConstant: {
2631         setForNode(node, m_graph.m_vm.stringStructure.get());
2632         break;
2633     }
2634 
2635     case NewStringObject: {
2636         ASSERT(node-&gt;structure()-&gt;classInfo() == StringObject::info());
2637         setForNode(node, node-&gt;structure());
2638         break;
2639     }
2640 
2641     case NewSymbol: {
2642         setForNode(node, m_vm.symbolStructure.get());
2643         break;
2644     }
2645 
2646     case NewArray:
2647         ASSERT(node-&gt;indexingMode() == node-&gt;indexingType()); // Copy on write arrays should only be created by NewArrayBuffer.
2648         setForNode(node,
2649             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
2650         break;
2651 
2652     case NewArrayWithSpread:
2653         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2654             // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
2655             // with StructureRegisterationPhase we must say we produce an original array
2656             // allocation structure.
<span class="line-modified">2657 #if USE(JSVALUE64)</span>
<span class="line-modified">2658             BitVector* bitVector = node-&gt;bitVector();</span>
<span class="line-added">2659             if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added">2660                 Edge use = m_graph.varArgChild(node, 0);</span>
<span class="line-added">2661                 if (use-&gt;op() == PhantomSpread) {</span>
<span class="line-added">2662                     if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-added">2663                         auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added">2664                         if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added">2665                             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">2666                             setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added">2667                             break;</span>
<span class="line-added">2668                         }</span>
<span class="line-added">2669                     }</span>
<span class="line-added">2670                 } else {</span>
<span class="line-added">2671                     setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added">2672                     break;</span>
<span class="line-added">2673                 }</span>
<span class="line-added">2674             }</span>
<span class="line-added">2675 #endif</span>
<span class="line-added">2676             setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));</span>
2677         } else {
2678             setForNode(node,
2679                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
2680         }
2681 
2682         break;
2683 
2684     case Spread:
2685         switch (node-&gt;child1()-&gt;op()) {
2686         case PhantomNewArrayBuffer:
2687         case PhantomCreateRest:
2688             break;
2689         default:
2690             if (!m_graph.canDoFastSpread(node, forNode(node-&gt;child1())))
2691                 clobberWorld();
2692             else
2693                 didFoldClobberWorld();
2694             break;
2695         }
2696 
<span class="line-modified">2697         setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());</span>

2698         break;
2699 
2700     case NewArrayBuffer:
2701         setForNode(node,
2702             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
2703         break;
2704 
2705     case NewArrayWithSize:
2706         setTypeForNode(node, SpecArray);
2707         break;
2708 
2709     case NewTypedArray:
2710         switch (node-&gt;child1().useKind()) {
2711         case Int32Use:
2712             break;
2713         case UntypedUse:
2714             clobberWorld();
2715             break;
2716         default:
2717             RELEASE_ASSERT_NOT_REACHED();
2718             break;
2719         }
2720         setForNode(node,
2721             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2722                 node-&gt;typedArrayType()));
2723         break;
2724 
2725     case NewRegexp:
2726         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2727         break;
2728 
2729     case ToThis: {
2730         AbstractValue&amp; source = forNode(node-&gt;child1());
2731         AbstractValue&amp; destination = forNode(node);
2732         bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
2733 
2734         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2735         switch (result) {
2736         case ToThisResult::Identity:
<span class="line-modified">2737             m_state.setShouldTryConstantFolding(true);</span>
2738             destination = source;
2739             break;
2740         case ToThisResult::Undefined:
2741             setConstant(node, jsUndefined());
2742             break;
2743         case ToThisResult::GlobalThis:
<span class="line-modified">2744             m_state.setShouldTryConstantFolding(true);</span>
2745             destination.setType(m_graph, SpecObject);
2746             break;
2747         case ToThisResult::Dynamic:
2748             if (strictMode)
2749                 destination.makeHeapTop();
2750             else {
2751                 destination = source;
2752                 destination.merge(SpecObject);
2753             }
2754             break;
2755         }
2756         break;
2757     }
2758 
2759     case CreateThis: {
2760         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2761             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2762                 if (FunctionRareData* rareData = function-&gt;rareData()) {
<span class="line-modified">2763                     if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-modified">2764                         if (Structure* structure = rareData-&gt;objectAllocationStructure()) {</span>
<span class="line-modified">2765                             m_graph.freeze(rareData);</span>
<span class="line-modified">2766                             m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-modified">2767                             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-modified">2768                             didFoldClobberWorld();</span>
<span class="line-modified">2769                             setForNode(node, structure);</span>
<span class="line-added">2770                             break;</span>
<span class="line-added">2771                         }</span>
2772                     }
2773                 }
2774             }
2775         }
2776         clobberWorld();
2777         setTypeForNode(node, SpecFinalObject);
2778         break;
2779     }
2780 
<span class="line-added">2781     case CreatePromise: {</span>
<span class="line-added">2782         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">2783         if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added">2784             if (base == (node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="line-added">2785                 m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">2786                 didFoldClobberWorld();</span>
<span class="line-added">2787                 setForNode(node, node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure());</span>
<span class="line-added">2788                 break;</span>
<span class="line-added">2789             }</span>
<span class="line-added">2790             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added">2791                 if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added">2792                     if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">2793                         Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">2794                         if (structure</span>
<span class="line-added">2795                             &amp;&amp; structure-&gt;classInfo() == (node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())</span>
<span class="line-added">2796                             &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added">2797                             &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">2798                             m_graph.freeze(rareData);</span>
<span class="line-added">2799                             m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added">2800                             m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">2801                             didFoldClobberWorld();</span>
<span class="line-added">2802                             setForNode(node, structure);</span>
<span class="line-added">2803                             break;</span>
<span class="line-added">2804                         }</span>
<span class="line-added">2805                     }</span>
<span class="line-added">2806                 }</span>
<span class="line-added">2807             }</span>
<span class="line-added">2808         }</span>
<span class="line-added">2809         clobberWorld();</span>
<span class="line-added">2810         setTypeForNode(node, SpecPromiseObject);</span>
<span class="line-added">2811         break;</span>
<span class="line-added">2812     }</span>
<span class="line-added">2813 </span>
<span class="line-added">2814     case CreateGenerator:</span>
<span class="line-added">2815     case CreateAsyncGenerator: {</span>
<span class="line-added">2816         auto tryToFold = [&amp;] (const ClassInfo* classInfo) -&gt; bool {</span>
<span class="line-added">2817             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">2818             if (JSValue base = forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added">2819                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added">2820                     if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added">2821                         if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">2822                             Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added">2823                             if (structure</span>
<span class="line-added">2824                                 &amp;&amp; structure-&gt;classInfo() == classInfo</span>
<span class="line-added">2825                                 &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added">2826                                 &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added">2827                                 m_graph.freeze(rareData);</span>
<span class="line-added">2828                                 m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added">2829                                 m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">2830                                 didFoldClobberWorld();</span>
<span class="line-added">2831                                 setForNode(node, structure);</span>
<span class="line-added">2832                                 return true;</span>
<span class="line-added">2833                             }</span>
<span class="line-added">2834                         }</span>
<span class="line-added">2835                     }</span>
<span class="line-added">2836                 }</span>
<span class="line-added">2837             }</span>
<span class="line-added">2838             return false;</span>
<span class="line-added">2839         };</span>
<span class="line-added">2840 </span>
<span class="line-added">2841         bool found = false;</span>
<span class="line-added">2842         switch (node-&gt;op()) {</span>
<span class="line-added">2843         case CreateGenerator:</span>
<span class="line-added">2844             found = tryToFold(JSGenerator::info());</span>
<span class="line-added">2845             break;</span>
<span class="line-added">2846         case CreateAsyncGenerator:</span>
<span class="line-added">2847             found = tryToFold(JSAsyncGenerator::info());</span>
<span class="line-added">2848             break;</span>
<span class="line-added">2849         default:</span>
<span class="line-added">2850             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">2851             break;</span>
<span class="line-added">2852         }</span>
<span class="line-added">2853         if (found)</span>
<span class="line-added">2854             break;</span>
<span class="line-added">2855         clobberWorld();</span>
<span class="line-added">2856         setTypeForNode(node, SpecObjectOther);</span>
<span class="line-added">2857         break;</span>
<span class="line-added">2858     }</span>
<span class="line-added">2859 </span>
<span class="line-added">2860     case NewPromise:</span>
<span class="line-added">2861     case NewGenerator:</span>
<span class="line-added">2862     case NewAsyncGenerator:</span>
<span class="line-added">2863     case NewArrayIterator:</span>
2864     case NewObject:
<span class="line-added">2865     case MaterializeNewInternalFieldObject:</span>
2866         ASSERT(!!node-&gt;structure().get());
2867         setForNode(node, node-&gt;structure());
2868         break;
2869 
2870     case ObjectCreate: {
2871         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2872             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2873             Structure* structure = nullptr;
2874             if (base.isNull())
2875                 structure = globalObject-&gt;nullPrototypeObjectStructure();
2876             else if (base.isObject())
<span class="line-modified">2877                 structure = m_vm.structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());</span>
2878 
2879             if (structure) {
<span class="line-modified">2880                 m_state.setShouldTryConstantFolding(true);</span>
2881                 if (node-&gt;child1().useKind() == UntypedUse)
2882                     didFoldClobberWorld();
2883                 setForNode(node, structure);
2884                 break;
2885             }
2886         }
2887         if (node-&gt;child1().useKind() == UntypedUse)
2888             clobberWorld();
2889         setTypeForNode(node, SpecFinalObject);
2890         break;
2891     }
2892 
2893     case ObjectKeys: {
2894         if (node-&gt;child1().useKind() == ObjectUse) {
2895             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2896             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2897                 RegisteredStructure structure = structureSet.onlyStructure();
2898                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2899                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2900                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
<span class="line-modified">2901                             m_state.setShouldTryConstantFolding(true);</span>
2902                             didFoldClobberWorld();
2903                             setTypeForNode(node, SpecArray);
2904                             break;
2905                         }
2906                     }
2907                 }
2908             }
2909         }
2910 
2911         clobberWorld();
2912         setTypeForNode(node, SpecArray);
2913         break;
2914     }
2915 
2916     case ToObject:
2917     case CallObjectConstructor: {
2918         AbstractValue&amp; source = forNode(node-&gt;child1());
2919         AbstractValue&amp; destination = forNode(node);
2920 
2921         if (!(source.m_type &amp; ~SpecObject)) {
<span class="line-modified">2922             m_state.setShouldTryConstantFolding(true);</span>
2923             if (node-&gt;op() == ToObject)
2924                 didFoldClobberWorld();
2925             destination = source;
2926             break;
2927         }
2928 
2929         if (node-&gt;op() == ToObject)
2930             clobberWorld();
2931         setTypeForNode(node, SpecObject);
2932         break;
2933     }
2934 
2935     case PhantomNewObject:
2936     case PhantomNewFunction:
2937     case PhantomNewGeneratorFunction:
2938     case PhantomNewAsyncGeneratorFunction:
2939     case PhantomNewAsyncFunction:
2940     case PhantomCreateActivation:
2941     case PhantomDirectArguments:
2942     case PhantomClonedArguments:
2943     case PhantomCreateRest:
2944     case PhantomSpread:
2945     case PhantomNewArrayWithSpread:
2946     case PhantomNewArrayBuffer:
<span class="line-added">2947     case PhantomNewArrayIterator:</span>
2948     case PhantomNewRegexp:
2949     case BottomValue: {
2950         clearForNode(node);
2951         break;
2952     }
2953 
2954     case PutHint:
2955         break;
2956 
2957     case MaterializeNewObject: {
2958         setForNode(node, node-&gt;structureSet());
2959         break;
2960     }
2961 
2962     case PushWithScope:
2963         // We don&#39;t use the more precise withScopeStructure() here because it is a LazyProperty and may not yet be allocated.
2964         setTypeForNode(node, SpecObjectOther);
2965         break;
2966 
2967     case CreateActivation:
</pre>
<hr />
<pre>
2969         setForNode(node,
2970             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;activationStructure());
2971         break;
2972 
2973     case CreateDirectArguments:
2974         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
2975         break;
2976 
2977     case CreateScopedArguments:
2978         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure());
2979         break;
2980 
2981     case CreateClonedArguments:
2982         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2983             setTypeForNode(node, SpecObject);
2984             break;
2985         }
2986         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure());
2987         break;
2988 
<span class="line-added">2989     case CreateArgumentsButterfly:</span>
<span class="line-added">2990         setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());</span>
<span class="line-added">2991         break;</span>
<span class="line-added">2992 </span>
2993     case NewGeneratorFunction:
2994         setForNode(node,
2995             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;generatorFunctionStructure());
2996         break;
2997 
2998     case NewAsyncGeneratorFunction:
2999         setForNode(node,
3000             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
3001         break;
3002 
3003     case NewAsyncFunction:
3004         setForNode(node,
3005             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
3006         break;
3007 
3008     case NewFunction: {
3009         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
3010         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
3011         setForNode(node, structure);
3012         break;
</pre>
<hr />
<pre>
3110         setTypeForNode(node, SpecObjectOther);
3111         break;
3112     }
3113 
3114     case GetGlobalThis: {
3115         setTypeForNode(node, SpecObject);
3116         break;
3117     }
3118 
3119     case GetClosureVar:
3120         if (JSValue value = m_graph.tryGetConstantClosureVar(forNode(node-&gt;child1()), node-&gt;scopeOffset())) {
3121             setConstant(node, *m_graph.freeze(value));
3122             break;
3123         }
3124         makeBytecodeTopForNode(node);
3125         break;
3126 
3127     case PutClosureVar:
3128         break;
3129 
<span class="line-added">3130     case GetInternalField:</span>
<span class="line-added">3131         makeBytecodeTopForNode(node);</span>
<span class="line-added">3132         break;</span>
<span class="line-added">3133 </span>
<span class="line-added">3134     case PutInternalField:</span>
<span class="line-added">3135         break;</span>
<span class="line-added">3136 </span>
<span class="line-added">3137 </span>
3138     case GetRegExpObjectLastIndex:
3139         makeHeapTopForNode(node);
3140         break;
3141 
3142     case SetRegExpObjectLastIndex:
3143     case RecordRegExpCachedResult:
3144         break;
3145 
3146     case GetFromArguments:
3147         makeHeapTopForNode(node);
3148         break;
3149 
3150     case PutToArguments:
3151         break;
3152 
3153     case GetArgument:
3154         makeHeapTopForNode(node);
3155         break;
3156 
3157     case TryGetById:
3158         // FIXME: This should constant fold at least as well as the normal GetById case.
3159         // https://bugs.webkit.org/show_bug.cgi?id=156422
3160         makeHeapTopForNode(node);
3161         break;
3162 
3163     case GetByIdDirect:
3164     case GetByIdDirectFlush:
3165     case GetById:
3166     case GetByIdFlush: {
3167         AbstractValue&amp; value = forNode(node-&gt;child1());
3168         if (value.m_structure.isFinite()
3169             &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
3170             UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
<span class="line-modified">3171             GetByStatus status = GetByStatus::computeFor(value.m_structure.toStructureSet(), uid);</span>
3172             if (status.isSimple()) {
3173                 // Figure out what the result is going to be - is it TOP, a constant, or maybe
3174                 // something more subtle?
3175                 AbstractValue result;
3176                 for (unsigned i = status.numVariants(); i--;) {
3177                     // This thing won&#39;t give us a variant that involves prototypes. If it did, we&#39;d
3178                     // have more work to do here.
3179                     DFG_ASSERT(m_graph, node, status[i].conditionSet().isEmpty());
3180 
3181                     result.merge(
3182                         m_graph.inferredValueForProperty(
3183                             value, status[i].offset(), m_state.structureClobberState()));
3184                 }
3185 
<span class="line-modified">3186                 m_state.setShouldTryConstantFolding(true);</span>
3187                 didFoldClobberWorld();
3188                 forNode(node) = result;
3189                 break;
3190             }
3191         }
3192 
3193         clobberWorld();
3194         makeHeapTopForNode(node);
3195         break;
3196     }
3197 
3198     case GetByValWithThis:
3199     case GetByIdWithThis:
3200         clobberWorld();
3201         makeHeapTopForNode(node);
3202         break;
3203 
3204     case GetArrayLength: {
3205         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3206             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
</pre>
<hr />
<pre>
3219 
3220     case DeleteById:
3221     case DeleteByVal: {
3222         // FIXME: This could decide if the delete will be successful based on the set of structures that
3223         // we get from our base value. https://bugs.webkit.org/show_bug.cgi?id=156611
3224         clobberWorld();
3225         setNonCellTypeForNode(node, SpecBoolean);
3226         break;
3227     }
3228 
3229     case CheckStructure: {
3230         AbstractValue&amp; value = forNode(node-&gt;child1());
3231 
3232         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
3233 
3234         // It&#39;s interesting that we could have proven that the object has a larger structure set
3235         // that includes the set we&#39;re testing. In that case we could make the structure check
3236         // more efficient. We currently don&#39;t.
3237 
3238         if (value.m_structure.isSubsetOf(set))
<span class="line-modified">3239             m_state.setShouldTryConstantFolding(true);</span>
3240 
3241         SpeculatedType admittedTypes = SpecNone;
3242         switch (node-&gt;child1().useKind()) {
3243         case CellUse:
3244         case KnownCellUse:
3245             admittedTypes = SpecNone;
3246             break;
3247         case CellOrOtherUse:
3248             admittedTypes = SpecOther;
3249             break;
3250         default:
3251             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
3252             break;
3253         }
3254 
3255         filter(value, set, admittedTypes);
3256         break;
3257     }
3258 
3259     case CheckStructureOrEmpty: {
3260         AbstractValue&amp; value = forNode(node-&gt;child1());
3261 
3262         bool mayBeEmpty = value.m_type &amp; SpecEmpty;
3263         if (!mayBeEmpty)
<span class="line-modified">3264             m_state.setShouldTryConstantFolding(true);</span>
3265 
3266         SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
3267         filter(value, node-&gt;structureSet(), admittedTypes);
3268         break;
3269     }
3270 
3271     case CheckStructureImmediate: {
3272         // FIXME: This currently can only reason about one structure at a time.
3273         // https://bugs.webkit.org/show_bug.cgi?id=136988
3274 
3275         AbstractValue&amp; value = forNode(node-&gt;child1());
3276         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
3277 
3278         if (value.value()) {
3279             if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
3280                 if (set.contains(m_graph.registerStructure(structure))) {
<span class="line-modified">3281                     m_state.setShouldTryConstantFolding(true);</span>
3282                     break;
3283                 }
3284             }
3285             m_state.setIsValid(false);
3286             break;
3287         }
3288 
3289         if (m_phiChildren) {
3290             bool allGood = true;
3291             m_phiChildren-&gt;forAllTransitiveIncomingValues(
3292                 node,
3293                 [&amp;] (Node* incoming) {
3294                     if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_vm)) {
3295                         if (set.contains(m_graph.registerStructure(structure)))
3296                             return;
3297                     }
3298                     allGood = false;
3299                 });
3300             if (allGood) {
<span class="line-modified">3301                 m_state.setShouldTryConstantFolding(true);</span>
3302                 break;
3303             }
3304         }
3305 
3306         if (RegisteredStructure structure = set.onlyStructure()) {
3307             filterByValue(node-&gt;child1(), *m_graph.freeze(structure.get()));
3308             break;
3309         }
3310 
3311         // Aw shucks, we can&#39;t do anything!
3312         break;
3313     }
3314 
3315     case PutStructure:
3316         if (!forNode(node-&gt;child1()).m_structure.isClear()) {
3317             if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
3318                 didFoldClobberStructures();
<span class="line-modified">3319                 m_state.setShouldTryConstantFolding(true);</span>
3320             } else {
3321                 observeTransition(
3322                     clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
3323                 forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
3324             }
3325         } else {
3326             // We&#39;re going to exit before we get here, but for the sake of validation, we&#39;ve folded our write to StructureID.
3327             didFoldClobberStructures();
3328         }
3329         break;
3330     case GetButterfly:
3331     case AllocatePropertyStorage:
3332     case ReallocatePropertyStorage:
3333     case NukeStructureAndSetButterfly:
3334         // FIXME: We don&#39;t model the fact that the structureID is nuked, simply because currently
3335         // nobody would currently benefit from having that information. But it&#39;s a bug nonetheless.
3336         if (node-&gt;op() == NukeStructureAndSetButterfly)
3337             didFoldClobberStructures();
3338         clearForNode(node); // The result is not a JS value.
3339         break;
3340     case CheckSubClass: {
3341         JSValue constant = forNode(node-&gt;child1()).value();
3342         if (constant) {
3343             if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
<span class="line-modified">3344                 m_state.setShouldTryConstantFolding(true);</span>
3345                 ASSERT(constant);
3346                 break;
3347             }
3348         }
3349 
3350         AbstractValue&amp; value = forNode(node-&gt;child1());
3351 
3352         if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
<span class="line-modified">3353             m_state.setShouldTryConstantFolding(true);</span>
3354 
3355         filterClassInfo(value, node-&gt;classInfo());
3356         break;
3357     }
3358     case CallDOMGetter: {
3359         CallDOMGetterData* callDOMGetterData = node-&gt;callDOMGetterData();
3360         DOMJIT::CallDOMGetterSnippet* snippet = callDOMGetterData-&gt;snippet;
3361         if (!snippet || snippet-&gt;effect.writes)
3362             clobberWorld();
3363         if (callDOMGetterData-&gt;domJIT)
3364             setTypeForNode(node, callDOMGetterData-&gt;domJIT-&gt;resultType());
3365         else
3366             makeBytecodeTopForNode(node);
3367         break;
3368     }
3369     case CallDOM: {
3370         const DOMJIT::Signature* signature = node-&gt;signature();
3371         if (signature-&gt;effect.writes)
3372             clobberWorld();
3373         setTypeForNode(node, signature-&gt;result);
3374         break;
3375     }
<span class="line-added">3376 </span>
<span class="line-added">3377     case CheckArrayOrEmpty:</span>
3378     case CheckArray: {
<span class="line-modified">3379         AbstractValue&amp; value = forNode(node-&gt;child1());</span>
<span class="line-modified">3380 </span>
<span class="line-added">3381         SpeculatedType admittedTypes = SpecNone;</span>
<span class="line-added">3382         if (node-&gt;op() == CheckArrayOrEmpty) {</span>
<span class="line-added">3383             bool mayBeEmpty = value.m_type &amp; SpecEmpty;</span>
<span class="line-added">3384             if (!mayBeEmpty)</span>
<span class="line-added">3385                 m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">3386             else</span>
<span class="line-added">3387                 admittedTypes = SpecEmpty;</span>
<span class="line-added">3388         }</span>
<span class="line-added">3389 </span>
<span class="line-added">3390         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, value)) {</span>
<span class="line-added">3391             m_state.setShouldTryConstantFolding(true);</span>
3392             break;
3393         }
<span class="line-added">3394 </span>
3395         switch (node-&gt;arrayMode().type()) {
3396         case Array::String:
<span class="line-modified">3397             filter(node-&gt;child1(), SpecString | admittedTypes);</span>
3398             break;
3399         case Array::Int32:
3400         case Array::Double:
3401         case Array::Contiguous:
3402         case Array::Undecided:
3403         case Array::ArrayStorage:
3404         case Array::SlowPutArrayStorage:
3405             break;
3406         case Array::DirectArguments:
<span class="line-modified">3407             filter(node-&gt;child1(), SpecDirectArguments | admittedTypes);</span>
3408             break;
3409         case Array::ScopedArguments:
<span class="line-modified">3410             filter(node-&gt;child1(), SpecScopedArguments | admittedTypes);</span>
3411             break;
3412         case Array::Int8Array:
<span class="line-modified">3413             filter(node-&gt;child1(), SpecInt8Array | admittedTypes);</span>
3414             break;
3415         case Array::Int16Array:
<span class="line-modified">3416             filter(node-&gt;child1(), SpecInt16Array | admittedTypes);</span>
3417             break;
3418         case Array::Int32Array:
<span class="line-modified">3419             filter(node-&gt;child1(), SpecInt32Array | admittedTypes);</span>
3420             break;
3421         case Array::Uint8Array:
<span class="line-modified">3422             filter(node-&gt;child1(), SpecUint8Array | admittedTypes);</span>
3423             break;
3424         case Array::Uint8ClampedArray:
<span class="line-modified">3425             filter(node-&gt;child1(), SpecUint8ClampedArray | admittedTypes);</span>
3426             break;
3427         case Array::Uint16Array:
<span class="line-modified">3428             filter(node-&gt;child1(), SpecUint16Array | admittedTypes);</span>
3429             break;
3430         case Array::Uint32Array:
<span class="line-modified">3431             filter(node-&gt;child1(), SpecUint32Array | admittedTypes);</span>
3432             break;
3433         case Array::Float32Array:
<span class="line-modified">3434             filter(node-&gt;child1(), SpecFloat32Array | admittedTypes);</span>
3435             break;
3436         case Array::Float64Array:
<span class="line-modified">3437             filter(node-&gt;child1(), SpecFloat64Array | admittedTypes);</span>
3438             break;
3439         case Array::AnyTypedArray:
<span class="line-modified">3440             filter(node-&gt;child1(), SpecTypedArrayView | admittedTypes);</span>
3441             break;
3442         default:
3443             RELEASE_ASSERT_NOT_REACHED();
3444             break;
3445         }
<span class="line-modified">3446         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering(), admittedTypes);</span>
3447         break;
3448     }
<span class="line-added">3449 </span>
3450     case Arrayify: {
3451         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3452             didFoldClobberStructures();
<span class="line-modified">3453             m_state.setShouldTryConstantFolding(true);</span>
3454             break;
3455         }
3456         ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
3457         clobberStructures();
3458         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3459         break;
3460     }
3461     case ArrayifyToStructure: {
3462         AbstractValue&amp; value = forNode(node-&gt;child1());
3463         if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
<span class="line-modified">3464             m_state.setShouldTryConstantFolding(true);</span>
3465         clobberStructures();
3466 
3467         // We have a bunch of options of how to express the abstract set at this point. Let set S
3468         // be the set of structures that the value had before clobbering and assume that all of
3469         // them are watchable. The new value should be the least expressible upper bound of the
3470         // intersection of &quot;values that currently have structure = node-&gt;structure()&quot; and &quot;values
3471         // that have structure in S plus any structure transition-reachable from S&quot;. Assume that
3472         // node-&gt;structure() is not in S but it is transition-reachable from S. Then we would
3473         // like to say that the result is &quot;values that have structure = node-&gt;structure() until
3474         // we invalidate&quot;, but there is no way to express this using the AbstractValue syntax. So
3475         // we must choose between:
3476         //
3477         // 1) &quot;values that currently have structure = node-&gt;structure()&quot;. This is a valid
3478         //    superset of the value that we really want, and it&#39;s specific enough to satisfy the
3479         //    preconditions of the array access that this is guarding. It&#39;s also specific enough
3480         //    to allow relevant optimizations in the case that we didn&#39;t have a contradiction
3481         //    like in this example. Notice that in the abscence of any contradiction, this result
3482         //    is precise rather than being a conservative LUB.
3483         //
3484         // 2) &quot;values that currently hava structure in S plus any structure transition-reachable
3485         //    from S&quot;. This is also a valid superset of the value that we really want, but it&#39;s
3486         //    not specific enough to satisfy the preconditions of the array access that this is
3487         //    guarding - so playing such shenanigans would preclude us from having assertions on
3488         //    the typing preconditions of any array accesses. This would also not be a desirable
3489         //    answer in the absence of a contradiction.
3490         //
3491         // Note that it&#39;s tempting to simply say that the resulting value is BOTTOM because of
3492         // the contradiction. That would be wrong, since we haven&#39;t hit an invalidation point,
3493         // yet.
3494         forNode(node-&gt;child1()).set(m_graph, node-&gt;structure());
3495         break;
3496     }
3497     case GetIndexedPropertyStorage: {
3498         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3499             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
3500         if (view)
<span class="line-modified">3501             m_state.setShouldTryConstantFolding(true);</span>
3502         clearForNode(node);
3503         break;
3504     }
3505     case ConstantStoragePointer: {
3506         clearForNode(node);
3507         break;
3508     }
3509 
3510     case GetTypedArrayByteOffset: {
3511         JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
3512         if (view) {
<span class="line-modified">3513             Optional&lt;unsigned&gt; byteOffset = view-&gt;byteOffsetConcurrently();</span>
<span class="line-modified">3514             if (byteOffset) {</span>
<span class="line-added">3515                 setConstant(node, jsNumber(*byteOffset));</span>
<span class="line-added">3516                 break;</span>
<span class="line-added">3517             }</span>
3518         }
3519         setNonCellTypeForNode(node, SpecInt32Only);
3520         break;
3521     }
3522 
3523     case GetPrototypeOf: {
3524         AbstractValue&amp; value = forNode(node-&gt;child1());
3525         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
3526             bool canFold = !value.m_structure.isClear();
3527             JSValue prototype;
3528             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3529                 auto getPrototypeMethod = structure-&gt;classInfo()-&gt;methodTable.getPrototype;
3530                 MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
3531                 if (getPrototypeMethod != defaultGetPrototype) {
3532                     canFold = false;
3533                     return;
3534                 }
3535 
3536                 if (structure-&gt;hasPolyProto()) {
3537                     canFold = false;
</pre>
<hr />
<pre>
3572     }
3573 
3574     case GetByOffset: {
3575         StorageAccessData&amp; data = node-&gt;storageAccessData();
3576 
3577         // FIXME: The part of this that handles inferred property types relies on AI knowing the structure
3578         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3579         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3580         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3581         // on the type that ByteCodeParser was able to prove.
3582         AbstractValue value = m_graph.inferredValueForProperty(
3583             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3584 
3585         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3586         // because the compilation was already invalidated.
3587         if (value.isClear())
3588             m_state.setIsValid(false);
3589 
3590         setForNode(node, value);
3591         if (value.m_value)
<span class="line-modified">3592             m_state.setShouldTryConstantFolding(true);</span>
3593         break;
3594     }
3595 
3596     case GetGetterSetterByOffset: {
3597         StorageAccessData&amp; data = node-&gt;storageAccessData();
3598         AbstractValue base = forNode(node-&gt;child2());
3599         JSValue result = m_graph.tryGetConstantProperty(base, data.offset);
3600         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3601             setConstant(node, *m_graph.freeze(result));
3602             break;
3603         }
3604 
<span class="line-modified">3605         setForNode(node, m_vm.getterSetterStructure.get());</span>





3606         break;
3607     }
3608 
3609     case MultiGetByOffset: {
3610         // This code will filter the base value in a manner that is possibly different (either more
3611         // or less precise) than the way it would be filtered if this was strength-reduced to a
3612         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3613         // different things about the code, so long as all of them are sound. That even includes
3614         // one guy proving that code should never execute (due to a contradiction) and another guy
3615         // not finding that contradiction. If someone ever proved that there would be a
3616         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3617         // realize it. This is the case here.
3618 
<span class="line-modified">3619         // Ordinarily you have to be careful with calling setShouldTryConstantFolding()</span>
3620         // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">3621         m_state.setShouldTryConstantFolding(true);</span>
3622 
3623         AbstractValue base = forNode(node-&gt;child1());
3624         RegisteredStructureSet baseSet;
3625         AbstractValue result;
3626         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
3627             RegisteredStructureSet set = getCase.set();
3628             set.filter(base);
3629             if (set.isEmpty())
3630                 continue;
3631             baseSet.merge(set);
3632 
3633             switch (getCase.method().kind()) {
3634             case GetByOffsetMethod::Constant: {
3635                 AbstractValue thisResult;
3636                 thisResult.set(
3637                     m_graph,
3638                     *getCase.method().constant(),
3639                     m_state.structureClobberState());
3640                 result.merge(thisResult);
3641                 break;
</pre>
<hr />
<pre>
3645                 result.makeHeapTop();
3646                 break;
3647             } }
3648         }
3649 
3650         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3651             m_state.setIsValid(false);
3652 
3653         setForNode(node, result);
3654         break;
3655     }
3656 
3657     case PutByOffset: {
3658         break;
3659     }
3660 
3661     case MultiPutByOffset: {
3662         RegisteredStructureSet newSet;
3663         TransitionVector transitions;
3664 
<span class="line-modified">3665         // Ordinarily you have to be careful with calling setShouldTryConstantFolding()</span>
3666         // because of the effect on compile times, but this node is FTL-only.
<span class="line-modified">3667         m_state.setShouldTryConstantFolding(true);</span>
3668 
3669         AbstractValue base = forNode(node-&gt;child1());
3670         AbstractValue originalValue = forNode(node-&gt;child2());
3671         AbstractValue resultingValue;
3672 
3673         if (node-&gt;multiPutByOffsetData().writesStructures())
3674             didFoldClobberStructures();
3675 
3676         for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
3677             const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
3678             RegisteredStructureSet thisSet = *m_graph.addStructureSet(variant.oldStructure());
3679             thisSet.filter(base);
3680             if (thisSet.isEmpty())
3681                 continue;
3682 
3683             AbstractValue thisValue = originalValue;
3684             resultingValue.merge(thisValue);
3685 
3686             if (variant.kind() == PutByIdVariant::Transition) {
3687                 RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
</pre>
<hr />
<pre>
3709             m_state.setIsValid(false);
3710         break;
3711     }
3712 
3713     case GetExecutable: {
3714         JSValue value = forNode(node-&gt;child1()).value();
3715         if (value) {
3716             JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, value);
3717             if (function) {
3718                 setConstant(node, *m_graph.freeze(function-&gt;executable()));
3719                 break;
3720             }
3721         }
3722         setTypeForNode(node, SpecCellOther);
3723         break;
3724     }
3725 
3726     case CheckCell: {
3727         JSValue value = forNode(node-&gt;child1()).value();
3728         if (value == node-&gt;cellOperand()-&gt;value()) {
<span class="line-modified">3729             m_state.setShouldTryConstantFolding(true);</span>
3730             ASSERT(value);
3731             break;
3732         }
3733         filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
3734         break;
3735     }
3736 
3737     case AssertNotEmpty:
3738     case CheckNotEmpty: {
3739         AbstractValue&amp; value = forNode(node-&gt;child1());
3740         if (!(value.m_type &amp; SpecEmpty)) {
<span class="line-modified">3741             m_state.setShouldTryConstantFolding(true);</span>
3742             break;
3743         }
3744 
3745         filter(value, ~SpecEmpty);
3746         break;
3747     }
3748 
<span class="line-modified">3749     case CheckIdent: {</span>
3750         AbstractValue&amp; value = forNode(node-&gt;child1());
3751         UniquedStringImpl* uid = node-&gt;uidOperand();

3752 
3753         JSValue childConstant = value.value();
3754         if (childConstant) {
<span class="line-modified">3755             if (childConstant.isString()) {</span>
<span class="line-modified">3756                 if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {</span>
<span class="line-modified">3757                     m_state.setShouldTryConstantFolding(true);</span>
<span class="line-modified">3758                     break;</span>
<span class="line-added">3759                 }</span>
<span class="line-added">3760             } else if (childConstant.isSymbol()) {</span>
<span class="line-added">3761                 if (&amp;jsCast&lt;Symbol*&gt;(childConstant)-&gt;uid() == uid) {</span>
<span class="line-added">3762                     m_state.setShouldTryConstantFolding(true);</span>
<span class="line-added">3763                     break;</span>
<span class="line-added">3764                 }</span>
3765             }
3766         }
3767 
<span class="line-modified">3768         if (node-&gt;child1().useKind() == StringIdentUse)</span>
<span class="line-added">3769             filter(value, SpecStringIdent);</span>
<span class="line-added">3770         else</span>
<span class="line-added">3771             filter(value, SpecSymbol);</span>
3772         break;
3773     }
3774 
3775     case CheckInBounds: {
3776         JSValue left = forNode(node-&gt;child1()).value();
3777         JSValue right = forNode(node-&gt;child2()).value();
3778         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
<span class="line-modified">3779             m_state.setShouldTryConstantFolding(true);</span>
3780 
3781         // We claim we result in Int32. It&#39;s not really important what our result is (though we
3782         // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
3783         // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
3784         // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
3785         // thing to do here. We pick NodeResultJS because it makes converting this to an identity
3786         // easier.
3787         setNonCellTypeForNode(node, SpecInt32Only);
3788         break;
3789     }
3790 
3791     case PutById:
3792     case PutByIdFlush:
3793     case PutByIdDirect: {
3794         AbstractValue&amp; value = forNode(node-&gt;child1());
3795         if (value.m_structure.isFinite()) {
3796             PutByIdStatus status = PutByIdStatus::computeFor(
3797                 m_graph.globalObjectFor(node-&gt;origin.semantic),
3798                 value.m_structure.toStructureSet(),
3799                 m_graph.identifiers()[node-&gt;identifierNumber()],
3800                 node-&gt;op() == PutByIdDirect);
3801 
<span class="line-added">3802             bool allGood = true;</span>
3803             if (status.isSimple()) {
3804                 RegisteredStructureSet newSet;
3805                 TransitionVector transitions;
3806 
<span class="line-modified">3807                 for (const PutByIdVariant&amp; variant : status.variants()) {</span>
<span class="line-modified">3808                     for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {</span>
<span class="line-added">3809                         if (!m_graph.watchCondition(condition)) {</span>
<span class="line-added">3810                             allGood = false;</span>
<span class="line-added">3811                             break;</span>
<span class="line-added">3812                         }</span>
<span class="line-added">3813                     }</span>
<span class="line-added">3814 </span>
<span class="line-added">3815                     if (!allGood)</span>
<span class="line-added">3816                         break;</span>
<span class="line-added">3817 </span>
3818                     if (variant.kind() == PutByIdVariant::Transition) {
3819                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3820                         transitions.append(
3821                             Transition(
3822                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3823                         newSet.add(newStructure);
3824                     } else {
3825                         ASSERT(variant.kind() == PutByIdVariant::Replace);
3826                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
3827                     }
3828                 }
3829 
3830                 if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
<span class="line-modified">3831                     m_state.setShouldTryConstantFolding(true);</span>
3832 
<span class="line-modified">3833                 if (allGood) {</span>
<span class="line-modified">3834                     didFoldClobberWorld();</span>
<span class="line-modified">3835                     observeTransitions(clobberLimit, transitions);</span>
<span class="line-modified">3836                     if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="line-modified">3837                         m_state.setIsValid(false);</span>
<span class="line-added">3838                     break;</span>
<span class="line-added">3839                 }</span>
3840             }
3841         }
3842 
3843         clobberWorld();
3844         break;
3845     }
3846 
3847     case PutByValWithThis:
3848     case PutByIdWithThis:
3849         clobberWorld();
3850         break;
3851 
3852     case PutGetterById:
3853     case PutSetterById:
3854     case PutGetterSetterById:
3855     case PutGetterByVal:
3856     case PutSetterByVal: {
3857         clobberWorld();
3858         break;
3859     }
</pre>
<hr />
<pre>
3862     case DefineAccessorProperty:
3863         clobberWorld();
3864         break;
3865 
3866     case InById: {
3867         // FIXME: We can determine when the property definitely exists based on abstract
3868         // value information.
3869         clobberWorld();
3870         filter(node-&gt;child1(), SpecObject);
3871         setNonCellTypeForNode(node, SpecBoolean);
3872         break;
3873     }
3874 
3875     case InByVal: {
3876         AbstractValue&amp; property = forNode(node-&gt;child2());
3877         if (JSValue constant = property.value()) {
3878             if (constant.isString()) {
3879                 JSString* string = asString(constant);
3880                 const StringImpl* impl = string-&gt;tryGetValueImpl();
3881                 if (impl &amp;&amp; impl-&gt;isAtom())
<span class="line-modified">3882                     m_state.setShouldTryConstantFolding(true);</span>
3883             }
3884         }
3885 
3886         // FIXME: We can determine when the property definitely exists based on abstract
3887         // value information.
3888         clobberWorld();
3889         filter(node-&gt;child1(), SpecObject);
3890         setNonCellTypeForNode(node, SpecBoolean);
3891         break;
3892     }
3893 
3894     case HasOwnProperty: {
3895         clobberWorld();
3896         setNonCellTypeForNode(node, SpecBoolean);
3897         break;
3898     }
3899 
3900     case GetEnumerableLength: {
3901         setNonCellTypeForNode(node, SpecInt32Only);
3902         break;
</pre>
<hr />
<pre>
3987         break;
3988 
3989     case InstanceOf:
3990         clobberWorld();
3991         setNonCellTypeForNode(node, SpecBoolean);
3992         break;
3993 
3994     case InstanceOfCustom:
3995         clobberWorld();
3996         setNonCellTypeForNode(node, SpecBoolean);
3997         break;
3998 
3999     case MatchStructure: {
4000         AbstractValue base = forNode(node-&gt;child1());
4001         RegisteredStructureSet baseSet;
4002 
4003         BooleanLattice result = BooleanLattice::Bottom;
4004         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
4005             RegisteredStructure structure = variant.structure;
4006             if (!base.contains(structure)) {
<span class="line-modified">4007                 m_state.setShouldTryConstantFolding(true);</span>
4008                 continue;
4009             }
4010 
4011             baseSet.add(structure);
4012             result = leastUpperBoundOfBooleanLattices(
4013                 result, variant.result ? BooleanLattice::True : BooleanLattice::False);
4014         }
4015 
4016         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
4017             m_state.setIsValid(false);
4018 
4019         switch (result) {
4020         case BooleanLattice::False:
4021             setConstant(node, jsBoolean(false));
4022             break;
4023         case BooleanLattice::True:
4024             setConstant(node, jsBoolean(true));
4025             break;
4026         default:
4027             setNonCellTypeForNode(node, SpecBoolean);
4028             break;
4029         }
4030         break;
4031     }
4032 
4033     case Phi:
4034         RELEASE_ASSERT(m_graph.m_form == SSA);
4035         setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
4036         // The state of this node would have already been decided, but it may have become a
4037         // constant, in which case we&#39;d like to know.
4038         if (forNode(node).m_value)
<span class="line-modified">4039             m_state.setShouldTryConstantFolding(true);</span>
4040         break;
4041 
4042     case Upsilon: {
4043         NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
4044         if (shadow.isStillValid()) {
4045             m_state.createValueForNode(shadow);
4046             setForNode(shadow, forNode(node-&gt;child1()));
4047         }
4048         break;
4049     }
4050 
4051     case Flush:
4052     case PhantomLocal:
4053         break;
4054 
4055     case Call:
4056     case TailCallInlinedCaller:
4057     case Construct:
4058     case CallVarargs:
4059     case CallForwardVarargs:
</pre>
<hr />
<pre>
4078         m_state.setStructureClobberState(StructuresAreWatched);
4079         m_state.observeInvalidationPoint();
4080         break;
4081 
4082     case CPUIntrinsic:
4083         if (node-&gt;intrinsic() == CPURdtscIntrinsic)
4084             setNonCellTypeForNode(node, SpecInt32Only);
4085         else
4086             setNonCellTypeForNode(node, SpecOther);
4087         break;
4088 
4089     case CheckTraps:
4090     case LogShadowChickenPrologue:
4091     case LogShadowChickenTail:
4092     case ProfileType:
4093     case ProfileControlFlow:
4094     case Phantom:
4095     case CountExecution:
4096     case CheckTierUpInLoop:
4097     case CheckTierUpAtReturn:
<span class="line-added">4098     case CheckNeutered:</span>
4099     case SuperSamplerBegin:
4100     case SuperSamplerEnd:
4101     case CheckTierUpAndOSREnter:
4102     case LoopHint:
4103     case ZombieHint:
4104     case ExitOK:
4105     case FilterCallLinkStatus:
<span class="line-modified">4106     case FilterGetByStatus:</span>
4107     case FilterPutByIdStatus:
4108     case FilterInByIdStatus:
4109     case ClearCatchLocals:
4110         break;
4111 
4112     case CheckTypeInfoFlags: {
4113         const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
4114         unsigned bits = node-&gt;typeInfoOperand();
4115         ASSERT(bits);
4116         if (bits == ImplementsDefaultHasInstance) {
4117             if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
<span class="line-modified">4118                 m_state.setShouldTryConstantFolding(true);</span>
4119                 break;
4120             }
4121         }
4122 
4123         if (JSValue value = abstractValue.value()) {
4124             if (value.isCell()) {
4125                 // This works because if we see a cell here, we know it&#39;s fully constructed
4126                 // and we can read its inline type info flags. These flags don&#39;t change over the
4127                 // object&#39;s lifetime.
4128                 if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
<span class="line-modified">4129                     m_state.setShouldTryConstantFolding(true);</span>
4130                     break;
4131                 }
4132             }
4133         }
4134 
4135         if (abstractValue.m_structure.isFinite()) {
4136             bool ok = true;
4137             abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
4138                 ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
4139             });
4140             if (ok) {
<span class="line-modified">4141                 m_state.setShouldTryConstantFolding(true);</span>
4142                 break;
4143             }
4144         }
4145 
4146         break;
4147     }
4148 
4149     case ParseInt: {
4150         AbstractValue value = forNode(node-&gt;child1());
4151         if (value.m_type &amp;&amp; !(value.m_type &amp; ~SpecInt32Only)) {
4152             JSValue radix;
4153             if (!node-&gt;child2())
4154                 radix = jsNumber(0);
4155             else
4156                 radix = forNode(node-&gt;child2()).m_value;
4157 
4158             if (radix.isNumber()
4159                 &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
<span class="line-modified">4160                 m_state.setShouldTryConstantFolding(true);</span>
4161                 if (node-&gt;child1().useKind() == UntypedUse)
4162                     didFoldClobberWorld();
4163                 setNonCellTypeForNode(node, SpecInt32Only);
4164                 break;
4165             }
4166         }
4167 
4168         if (node-&gt;child1().useKind() == UntypedUse)
4169             clobberWorld();
4170         setNonCellTypeForNode(node, SpecBytecodeNumber);
4171         break;
4172     }
4173 
4174     case CreateRest:
4175         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
4176             // This means we&#39;re already having a bad time.
4177             clobberWorld();
4178             setTypeForNode(node, SpecArray);
4179             break;
4180         }
4181         setForNode(node,
4182             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure());
4183         break;
4184 
4185     case CheckVarargs:
4186     case Check: {
4187         // Simplify out checks that don&#39;t actually do checking.
4188         m_graph.doToChildren(node, [&amp;] (Edge edge) {
4189             if (!edge)
4190                 return;
4191             if (edge.isProved() || edge.willNotHaveCheck())
<span class="line-modified">4192                 m_state.setShouldTryConstantFolding(true);</span>
4193         });
4194         break;
4195     }
4196 
4197     case SetFunctionName: {
4198         clobberWorld();
4199         break;
4200     }
4201 
4202     case StoreBarrier:
4203     case FencedStoreBarrier: {
4204         filter(node-&gt;child1(), SpecCell);
4205         break;
4206     }
4207 
4208     case DataViewGetInt: {
4209         DataViewData data = node-&gt;dataViewData();
4210         if (data.byteSize &lt; 4)
4211             setNonCellTypeForNode(node, SpecInt32Only);
4212         else {
4213             ASSERT(data.byteSize == 4);
4214             if (data.isSigned)
4215                 setNonCellTypeForNode(node, SpecInt32Only);
4216             else
4217                 setNonCellTypeForNode(node, SpecInt52Any);
4218         }
4219         break;
4220     }
4221 
4222     case DataViewGetFloat: {
4223         setNonCellTypeForNode(node, SpecFullDouble);
4224         break;
4225     }
4226 
<span class="line-added">4227     case DateGetInt32OrNaN: {</span>
<span class="line-added">4228         setNonCellTypeForNode(node, SpecInt32Only | SpecDoublePureNaN);</span>
<span class="line-added">4229         break;</span>
<span class="line-added">4230     }</span>
<span class="line-added">4231 </span>
<span class="line-added">4232     case DateGetTime: {</span>
<span class="line-added">4233         setNonCellTypeForNode(node, SpecFullDouble);</span>
<span class="line-added">4234         break;</span>
<span class="line-added">4235     }</span>
<span class="line-added">4236 </span>
4237     case DataViewSet: {
4238         break;
4239     }
4240 
4241     case Unreachable:
4242         // It may be that during a previous run of AI we proved that something was unreachable, but
4243         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
4244         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
4245         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
4246         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
4247         m_state.setIsValid(false);
4248         break;
4249 
4250     case LastNodeType:
4251     case ArithIMul:
4252     case FiatInt52:
4253         DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
4254         break;
4255     }
4256 
4257     return m_state.isValid();
4258 }
4259 
4260 template&lt;typename AbstractStateType&gt;
4261 void AbstractInterpreter&lt;AbstractStateType&gt;::filterICStatus(Node* node)
4262 {
4263     switch (node-&gt;op()) {
4264     case FilterCallLinkStatus:
4265         if (JSValue value = forNode(node-&gt;child1()).m_value)
4266             node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
4267         break;
4268 
<span class="line-modified">4269     case FilterGetByStatus: {</span>
4270         AbstractValue&amp; value = forNode(node-&gt;child1());
4271         if (value.m_structure.isFinite())
<span class="line-modified">4272             node-&gt;getByStatus()-&gt;filter(value.m_structure.toStructureSet());</span>
4273         break;
4274     }
4275 
4276     case FilterInByIdStatus: {
4277         AbstractValue&amp; value = forNode(node-&gt;child1());
4278         if (value.m_structure.isFinite())
4279             node-&gt;inByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
4280         break;
4281     }
4282 
4283     case FilterPutByIdStatus: {
4284         AbstractValue&amp; value = forNode(node-&gt;child1());
4285         if (value.m_structure.isFinite())
4286             node-&gt;putByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
4287         break;
4288     }
4289 
4290     default:
4291         RELEASE_ASSERT_NOT_REACHED();
4292         break;
</pre>
<hr />
<pre>
4393 }
4394 
4395 template&lt;typename AbstractStateType&gt;
4396 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4397     unsigned clobberLimit, const TransitionVector&amp; vector)
4398 {
4399     if (vector.isEmpty())
4400         return;
4401 
4402     // Stop performing precise structure transition tracking.
4403     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.
4404     // If it is too large, we conservatively clobber all the structures.
4405     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {
4406         clobberStructures();
4407         return;
4408     }
4409 
4410     AbstractValue::TransitionsObserver transitionsObserver(vector);
4411     forAllValues(clobberLimit, transitionsObserver);
4412 
<span class="line-modified">4413     if (ASSERT_ENABLED) {</span>
4414         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4415         for (unsigned i = vector.size(); i--;)
4416             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4417     }
4418 
4419     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4420 }
4421 
4422 template&lt;typename AbstractStateType&gt;
4423 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4424 {
4425     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4426 }
4427 
4428 template&lt;typename AbstractStateType&gt;
4429 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
4430 {
4431     CommaPrinter comma(&quot; &quot;);
4432     HashSet&lt;NodeFlowProjection&gt; seen;
4433     if (m_graph.m_form == SSA) {
</pre>
<hr />
<pre>
4456             AbstractValue&amp; value = forNode(node);
4457             if (value.isClear())
4458                 continue;
4459             out.print(comma, node, &quot;:&quot;, value);
4460         }
4461     }
4462 }
4463 
4464 template&lt;typename AbstractStateType&gt;
4465 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4466     AbstractValue&amp; value, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes)
4467 {
4468     if (value.filter(m_graph, set, admittedTypes) == FiltrationOK)
4469         return FiltrationOK;
4470     m_state.setIsValid(false);
4471     return Contradiction;
4472 }
4473 
4474 template&lt;typename AbstractStateType&gt;
4475 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
<span class="line-modified">4476     AbstractValue&amp; value, ArrayModes arrayModes, SpeculatedType admittedTypes)</span>
4477 {
<span class="line-modified">4478     if (value.filterArrayModes(arrayModes, admittedTypes) == FiltrationOK)</span>
4479         return FiltrationOK;
4480     m_state.setIsValid(false);
4481     return Contradiction;
4482 }
4483 
4484 template&lt;typename AbstractStateType&gt;
4485 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4486     AbstractValue&amp; value, SpeculatedType type)
4487 {
4488     if (value.filter(type) == FiltrationOK)
4489         return FiltrationOK;
4490     m_state.setIsValid(false);
4491     return Contradiction;
4492 }
4493 
4494 template&lt;typename AbstractStateType&gt;
4495 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterByValue(
4496     AbstractValue&amp; abstractValue, FrozenValue concreteValue)
4497 {
4498     if (abstractValue.filterByValue(concreteValue) == FiltrationOK)
</pre>
</td>
</tr>
</table>
<center><a href="DFGAbstractInterpreter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGAbstractValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/FrameTracers.h
@@ -79,18 +79,60 @@
     ASSERT(!(stackPointer % stackAlignmentBytes()));
 #endif
 #endif
 }
 
+class SlowPathFrameTracer {
+public:
+    ALWAYS_INLINE SlowPathFrameTracer(VM& vm, CallFrame* callFrame)
+    {
+        ASSERT(callFrame);
+        ASSERT(reinterpret_cast<void*>(callFrame) < reinterpret_cast<void*>(vm.topEntryFrame));
+        assertStackPointerIsAligned();
+        vm.topCallFrame = callFrame;
+    }
+};
+
 class NativeCallFrameTracer {
 public:
     ALWAYS_INLINE NativeCallFrameTracer(VM& vm, CallFrame* callFrame)
     {
-        ASSERT(&vm);
         ASSERT(callFrame);
         ASSERT(reinterpret_cast<void*>(callFrame) < reinterpret_cast<void*>(vm.topEntryFrame));
         assertStackPointerIsAligned();
         vm.topCallFrame = callFrame;
     }
 };
 
+class JITOperationPrologueCallFrameTracer {
+public:
+    ALWAYS_INLINE JITOperationPrologueCallFrameTracer(VM& vm, CallFrame* callFrame)
+#if ASSERT_ENABLED
+        : m_vm(vm)
+#endif
+    {
+        UNUSED_PARAM(vm);
+        UNUSED_PARAM(callFrame);
+        ASSERT(callFrame);
+        ASSERT(reinterpret_cast<void*>(callFrame) < reinterpret_cast<void*>(vm.topEntryFrame));
+        assertStackPointerIsAligned();
+#if USE(BUILTIN_FRAME_ADDRESS)
+        // If ASSERT_ENABLED and USE(BUILTIN_FRAME_ADDRESS), prepareCallOperation() will put the frame pointer into vm.topCallFrame.
+        // We can ensure here that a call to prepareCallOperation() (or its equivalent) is not missing by comparing vm.topCallFrame to
+        // the result of __builtin_frame_address which is passed in as callFrame.
+        ASSERT(vm.topCallFrame == callFrame);
+        vm.topCallFrame = callFrame;
+#endif
+    }
+
+#if ASSERT_ENABLED
+    ~JITOperationPrologueCallFrameTracer()
+    {
+        // Fill vm.topCallFrame with invalid value when leaving from JIT operation functions.
+        m_vm.topCallFrame = bitwise_cast<CallFrame*>(static_cast<uintptr_t>(0x0badbeef0badbeefULL));
+    }
+
+    VM& m_vm;
+#endif
+};
+
 } // namespace JSC

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBox.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -51,11 +51,11 @@</span>
      // position:static elements that are not flex-items get their z-index coerced to auto.
      bool requiresLayer() const override
      {
          return isDocumentElementRenderer() || isPositioned() || createsGroup() || hasClipPath() || hasOverflowClip()
              || hasTransformRelatedProperty() || hasHiddenBackface() || hasReflection() || style().specifiesColumns()
<span class="udiff-line-modified-removed">-             || !style().hasAutoZIndex() || hasRunningAcceleratedAnimations();</span>
<span class="udiff-line-modified-added">+             || !style().hasAutoUsedZIndex() || hasRunningAcceleratedAnimations();</span>
      }
  
      bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const final;
  
      // Returns false for the body renderer if its background is propagated to the root.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,12 +215,12 @@</span>
      LayoutUnit contentWidth() const { return paddingBoxWidth() - paddingLeft() - paddingRight(); }
      LayoutUnit contentHeight() const { return paddingBoxHeight() - paddingTop() - paddingBottom(); }
      LayoutUnit contentLogicalWidth() const { return style().isHorizontalWritingMode() ? contentWidth() : contentHeight(); }
      LayoutUnit contentLogicalHeight() const { return style().isHorizontalWritingMode() ? contentHeight() : contentWidth(); }
  
<span class="udiff-line-modified-removed">-     LayoutUnit paddingBoxWidth() const { return width() - borderLeft() - borderRight() - verticalScrollbarWidth(); }</span>
<span class="udiff-line-modified-removed">-     LayoutUnit paddingBoxHeight() const { return height() - borderTop() - borderBottom() - horizontalScrollbarHeight(); }</span>
<span class="udiff-line-modified-added">+     LayoutUnit paddingBoxWidth() const { return std::max(0_lu, width() - borderLeft() - borderRight() - verticalScrollbarWidth()); }</span>
<span class="udiff-line-modified-added">+     LayoutUnit paddingBoxHeight() const { return std::max(0_lu, height() - borderTop() - borderBottom() - horizontalScrollbarHeight()); }</span>
      LayoutRect paddingBoxRect() const;
      LayoutRect paddingBoxRectIncludingScrollbar() const { return LayoutRect(borderLeft(), borderTop(), width() - borderLeft() - borderRight(), height() - borderTop() - borderBottom()); }
  
      // IE extensions. Used to calculate offsetWidth/Height.  Overridden by inlines (RenderFlow)
      // to return the remaining width on a given line (and the height of a single line).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -652,21 +652,24 @@</span>
  
      void willBeDestroyed() override;
  
      bool createsNewFormattingContext() const;
  
<span class="udiff-line-added">+     virtual bool shouldResetLogicalHeightBeforeLayout() const { return false; }</span>
<span class="udiff-line-added">+     void resetLogicalHeightBeforeLayoutIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      virtual ItemPosition selfAlignmentNormalBehavior(const RenderBox* = nullptr) const { return ItemPosition::Stretch; }
  
      // Returns false if it could not cheaply compute the extent (e.g. fixed background), in which case the returned rect may be incorrect.
      bool getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp;) const;
      virtual bool foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const;
      bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset) override;
  
      void paintBackground(const PaintInfo&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone);
  
      void paintFillLayer(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance, CompositeOperator, RenderElement* backgroundObject, BaseBackgroundColorUsage = BaseBackgroundColorUse);
<span class="udiff-line-modified-removed">-     void paintFillLayers(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone, CompositeOperator = CompositeSourceOver, RenderElement* backgroundObject = nullptr);</span>
<span class="udiff-line-modified-added">+     void paintFillLayers(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone, CompositeOperator = CompositeOperator::SourceOver, RenderElement* backgroundObject = nullptr);</span>
  
      void paintMaskImages(const PaintInfo&amp;, const LayoutRect&amp;);
  
      BackgroundBleedAvoidance determineBackgroundBleedAvoidance(GraphicsContext&amp;) const;
      bool backgroundHasOpaqueTopLayer() const;
</pre>
<center><a href="RenderBox.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2006-2017 Apple Inc. All rights reserved
+ * Copyright (C) 2006-2019 Apple Inc. All rights reserved
  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
@@ -54,10 +54,11 @@
         {
             return WTF::equal(*a, *b);
         }
 
         static unsigned hash(const RefPtr<StringImpl>& key) { return key->hash(); }
+        static unsigned hash(const PackedPtr<StringImpl>& key) { return key->hash(); }
         static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
         {
             return equal(a.get(), b.get());
         }
         static bool equal(const RefPtr<StringImpl>& a, const StringImpl* b)
@@ -67,17 +68,30 @@
         static bool equal(const StringImpl* a, const RefPtr<StringImpl>& b)
         {
             return equal(a, b.get());
         }
 
+        static bool equal(const PackedPtr<StringImpl>& a, const PackedPtr<StringImpl>& b)
+        {
+            return equal(a.get(), b.get());
+        }
+        static bool equal(const PackedPtr<StringImpl>& a, const StringImpl* b)
+        {
+            return equal(a.get(), b);
+        }
+        static bool equal(const StringImpl* a, const PackedPtr<StringImpl>& b)
+        {
+            return equal(a, b.get());
+        }
+
         static unsigned hash(const String& key) { return key.impl()->hash(); }
         static bool equal(const String& a, const String& b)
         {
             return equal(a.impl(), b.impl());
         }
 
-        static const bool safeToCompareToEmptyOrDeleted = false;
+        static constexpr bool safeToCompareToEmptyOrDeleted = false;
     };
 
     struct ASCIICaseInsensitiveHash {
         template<typename T>
         struct FoldCase {
@@ -133,10 +147,20 @@
         static bool equal(const RefPtr<StringImpl>& a, const RefPtr<StringImpl>& b)
         {
             return equal(a.get(), b.get());
         }
 
+        static unsigned hash(const PackedPtr<StringImpl>& key)
+        {
+            return hash(key.get());
+        }
+
+        static bool equal(const PackedPtr<StringImpl>& a, const PackedPtr<StringImpl>& b)
+        {
+            return equal(a.get(), b.get());
+        }
+
         static unsigned hash(const String& key)
         {
             return hash(key.impl());
         }
         static unsigned hash(const AtomString& key)
@@ -152,11 +176,11 @@
             // FIXME: Is the "a == b" here a helpful optimization?
             // It makes all cases where the strings are not identical slightly slower.
             return a == b || equal(a.impl(), b.impl());
         }
 
-        static const bool safeToCompareToEmptyOrDeleted = false;
+        static constexpr bool safeToCompareToEmptyOrDeleted = false;
     };
 
     // This hash can be used in cases where the key is a hash of a string, but we don't
     // want to store the string. It's not really specific to string hashing, but all our
     // current uses of it are for strings.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/Verification.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutState.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #ifndef NDEBUG
 32 #include &quot;DisplayBox.h&quot;
 33 #include &quot;InlineFormattingState.h&quot;
 34 #include &quot;InlineTextBox.h&quot;
 35 #include &quot;LayoutBox.h&quot;
 36 #include &quot;LayoutContainer.h&quot;
 37 #include &quot;LayoutContext.h&quot;
 38 #include &quot;LayoutTreeBuilder.h&quot;
 39 #include &quot;RenderBox.h&quot;
 40 #include &quot;RenderInline.h&quot;
 41 #include &quot;RenderLineBreak.h&quot;
 42 #include &quot;RenderView.h&quot;
 43 #include &lt;wtf/text/TextStream.h&gt;
 44 
 45 namespace WebCore {
 46 namespace Layout {
 47 
 48 static bool areEssentiallyEqual(LayoutUnit a, LayoutUnit b)
 49 {
 50     if (a == b)
 51         return true;
 52     // 1/4th CSS pixel.
 53     constexpr float epsilon = kFixedPointDenominator / 4;
 54     return abs(a.rawValue() - b.rawValue()) &lt;= epsilon;
 55 }
 56 
 57 static bool areEssentiallyEqual(float a, InlineLayoutUnit b)
 58 {
 59     return areEssentiallyEqual(LayoutUnit { a }, LayoutUnit { b });
 60 }
 61 
 62 static bool areEssentiallyEqual(LayoutRect a, LayoutRect b)
 63 {
 64     return areEssentiallyEqual(a.x(), b.x())
 65         &amp;&amp; areEssentiallyEqual(a.y(), b.y())
 66         &amp;&amp; areEssentiallyEqual(a.width(), b.width())
 67         &amp;&amp; areEssentiallyEqual(a.height(), b.height());
 68 }
 69 
 70 static bool outputMismatchingSimpleLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
 71 {
 72     auto* lineLayoutData = blockFlow.simpleLineLayout();
 73     if (!lineLayoutData) {
 74         ASSERT_NOT_REACHED();
 75         return true;
 76     }
 77 
 78     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
 79     auto* displayInlineContent = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).displayInlineContent();
 80     if (!displayInlineContent) {
 81         ASSERT_NOT_REACHED();
 82         return true;
 83     }
 84 
 85     auto&amp; displayRuns = displayInlineContent-&gt;runs;
 86 
 87     if (displayRuns.size() != lineLayoutData-&gt;runCount()) {
 88         stream &lt;&lt; &quot;Mismatching number of runs: simple runs(&quot; &lt;&lt; lineLayoutData-&gt;runCount() &lt;&lt; &quot;) inline runs(&quot; &lt;&lt; displayRuns.size() &lt;&lt; &quot;)&quot;;
 89         stream.nextLine();
 90         return true;
 91     }
 92 
 93     auto mismatched = false;
 94     for (unsigned i = 0; i &lt; lineLayoutData-&gt;runCount(); ++i) {
 95         auto&amp; simpleRun = lineLayoutData-&gt;runAt(i);
 96         auto&amp; displayRun = displayRuns[i];
 97 
 98         auto matchingRuns = areEssentiallyEqual(simpleRun.logicalLeft, displayRun.left()) &amp;&amp; areEssentiallyEqual(simpleRun.logicalRight, displayRun.right());
 99         if (matchingRuns &amp;&amp; displayRun.textContext()) {
100             matchingRuns = simpleRun.start == displayRun.textContext()-&gt;start() &amp;&amp; simpleRun.end == displayRun.textContext()-&gt;end();
101             // SLL handles strings in a more concatenated format &lt;div&gt;foo&lt;br&gt;bar&lt;/div&gt; -&gt; foo -&gt; 0,3 bar -&gt; 3,6 vs. 0,3 and 0,3
102             if (!matchingRuns)
103                 matchingRuns = (simpleRun.end - simpleRun.start) == (displayRun.textContext()-&gt;end() - displayRun.textContext()-&gt;start());
104         }
105         if (matchingRuns)
106             continue;
107 
108         stream &lt;&lt; &quot;Mismatching: simple run(&quot; &lt;&lt; simpleRun.start &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.end &lt;&lt; &quot;) (&quot; &lt;&lt; simpleRun.logicalLeft &lt;&lt; &quot;, &quot; &lt;&lt; simpleRun.logicalRight &lt;&lt; &quot;)&quot;;
109         stream &lt;&lt; &quot; inline run&quot;;
110         if (displayRun.textContext())
111             stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.textContext()-&gt;end() &lt;&lt; &quot;)&quot;;
112         stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.left() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.top() &lt;&lt; &quot;) (&quot; &lt;&lt; displayRun.width() &lt;&lt; &quot;x&quot; &lt;&lt; displayRun.height() &lt;&lt; &quot;)&quot;;
113         stream.nextLine();
114         mismatched = true;
115     }
116     return mismatched;
117 }
118 
119 static bool checkForMatchingNonTextRuns(const Display::Run&amp; inlineRun, const WebCore::InlineBox&amp; inlineBox)
120 {
121     return areEssentiallyEqual(inlineBox.left(), inlineRun.left())
122         &amp;&amp; areEssentiallyEqual(inlineBox.right(), inlineRun.right())
123         &amp;&amp; areEssentiallyEqual(inlineBox.top(), inlineRun.top())
124         &amp;&amp; areEssentiallyEqual(inlineBox.bottom(), inlineRun.bottom());
125 }
126 
127 
128 static bool checkForMatchingTextRuns(const Display::Run&amp; inlineRun, const InlineTextBox&amp; inlineTextBox)
129 {
130     return areEssentiallyEqual(inlineTextBox.left(), inlineRun.left())
131         &amp;&amp; areEssentiallyEqual(inlineTextBox.right(), inlineRun.right())
132         &amp;&amp; areEssentiallyEqual(inlineTextBox.top(), inlineRun.top())
133         &amp;&amp; areEssentiallyEqual(inlineTextBox.bottom(), inlineRun.bottom())
134         &amp;&amp; (inlineTextBox.isLineBreak() || (inlineTextBox.start() == inlineRun.textContext()-&gt;start() &amp;&amp; inlineTextBox.end() == inlineRun.textContext()-&gt;end()));
135 }
136 
137 static void collectFlowBoxSubtree(const InlineFlowBox&amp; flowbox, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
138 {
139     auto* inlineBox = flowbox.firstLeafDescendant();
140     auto* lastLeafDescendant = flowbox.lastLeafDescendant();
141     while (inlineBox) {
142         inlineBoxes.append(inlineBox);
143         if (inlineBox == lastLeafDescendant)
144             break;
145         inlineBox = inlineBox-&gt;nextLeafOnLine();
146     }
147 }
148 
149 static void collectInlineBoxes(const RenderBlockFlow&amp; root, Vector&lt;WebCore::InlineBox*&gt;&amp; inlineBoxes)
150 {
151     for (auto* rootLine = root.firstRootBox(); rootLine; rootLine = rootLine-&gt;nextRootBox()) {
152         for (auto* inlineBox = rootLine-&gt;firstChild(); inlineBox; inlineBox = inlineBox-&gt;nextOnLine()) {
153             if (!is&lt;InlineFlowBox&gt;(inlineBox)) {
154                 inlineBoxes.append(inlineBox);
155                 continue;
156             }
157             collectFlowBoxSubtree(downcast&lt;InlineFlowBox&gt;(*inlineBox), inlineBoxes);
158         }
159     }
160 }
161 
162 static bool outputMismatchingComplexLineInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; layoutState, const RenderBlockFlow&amp; blockFlow, const Container&amp; inlineFormattingRoot)
163 {
164     auto&amp; inlineFormattingState = layoutState.establishedFormattingState(inlineFormattingRoot);
165 
166     auto* displayInlineContent = downcast&lt;InlineFormattingState&gt;(inlineFormattingState).displayInlineContent();
167     if (!displayInlineContent) {
168         ASSERT_NOT_REACHED();
169         return true;
170     }
171     auto&amp; displayRuns = displayInlineContent-&gt;runs;
172 
173     // Collect inlineboxes.
174     Vector&lt;WebCore::InlineBox*&gt; inlineBoxes;
175     collectInlineBoxes(blockFlow, inlineBoxes);
176 
177     auto mismatched = false;
178     unsigned runIndex = 0;
179 
180     if (inlineBoxes.size() != displayRuns.size()) {
181         stream &lt;&lt; &quot;Warning: mismatching number of runs: inlineboxes(&quot; &lt;&lt; inlineBoxes.size() &lt;&lt; &quot;) vs. inline runs(&quot; &lt;&lt; displayRuns.size() &lt;&lt; &quot;)&quot;;
182         stream.nextLine();
183     }
184 
185     for (unsigned inlineBoxIndex = 0; inlineBoxIndex &lt; inlineBoxes.size() &amp;&amp; runIndex &lt; displayRuns.size(); ++inlineBoxIndex) {
186         auto&amp; displayRun = displayRuns[runIndex];
187         auto* inlineBox = inlineBoxes[inlineBoxIndex];
188         auto* inlineTextBox = is&lt;InlineTextBox&gt;(inlineBox) ? downcast&lt;InlineTextBox&gt;(inlineBox) : nullptr;
189         bool matchingRuns = inlineTextBox ? checkForMatchingTextRuns(displayRun, *inlineTextBox) : matchingRuns = checkForMatchingNonTextRuns(displayRun, *inlineBox);
190 
191         if (!matchingRuns) {
192 
193             if (is&lt;RenderLineBreak&gt;(inlineBox-&gt;renderer())) {
194                 // &lt;br&gt; positioning is weird at this point. It needs proper baseline.
195                 matchingRuns = true;
196                 ++runIndex;
197                 continue;
198             }
199 
200             stream &lt;&lt; &quot;Mismatching: run&quot;;
201 
202             if (inlineTextBox)
203                 stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineTextBox-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; inlineTextBox-&gt;end() &lt;&lt; &quot;)&quot;;
204             stream &lt;&lt; &quot; (&quot; &lt;&lt; inlineBox-&gt;logicalLeft() &lt;&lt; &quot;, &quot; &lt;&lt; inlineBox-&gt;logicalTop() &lt;&lt; &quot;) (&quot; &lt;&lt; inlineBox-&gt;logicalWidth() &lt;&lt; &quot;x&quot; &lt;&lt; inlineBox-&gt;logicalHeight() &lt;&lt; &quot;)&quot;;
205 
206             stream &lt;&lt; &quot; inline run&quot;;
207             if (displayRun.textContext())
208                 stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.textContext()-&gt;start() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.textContext()-&gt;end() &lt;&lt; &quot;)&quot;;
209             stream &lt;&lt; &quot; (&quot; &lt;&lt; displayRun.left() &lt;&lt; &quot;, &quot; &lt;&lt; displayRun.top() &lt;&lt; &quot;) (&quot; &lt;&lt; displayRun.width() &lt;&lt; &quot;x&quot; &lt;&lt; displayRun.height() &lt;&lt; &quot;)&quot;;
210             stream.nextLine();
211             mismatched = true;
212         }
213         ++runIndex;
214     }
215     return mismatched;
216 }
217 
218 static bool outputMismatchingBlockBoxInformationIfNeeded(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
219 {
220     bool firstMismatchingRect = true;
221     auto outputRect = [&amp;] (const String&amp; prefix, const LayoutRect&amp; rendererRect, const LayoutRect&amp; layoutRect) {
222         if (firstMismatchingRect) {
223             stream &lt;&lt; (renderer.element() ? renderer.element()-&gt;nodeName().utf8().data() : &quot;&quot;) &lt;&lt; &quot; &quot; &lt;&lt; renderer.renderName() &lt;&lt; &quot;(&quot; &lt;&lt; &amp;renderer &lt;&lt; &quot;) layoutBox(&quot; &lt;&lt; &amp;layoutBox &lt;&lt; &quot;)&quot;;
224             stream.nextLine();
225             firstMismatchingRect = false;
226         }
227 
228         stream  &lt;&lt; prefix.utf8().data() &lt;&lt; &quot;\trenderer-&gt;(&quot; &lt;&lt; rendererRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; rendererRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; rendererRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; rendererRect.height() &lt;&lt; &quot;)&quot;
229             &lt;&lt; &quot;\tlayout-&gt;(&quot; &lt;&lt; layoutRect.x() &lt;&lt; &quot;,&quot; &lt;&lt; layoutRect.y() &lt;&lt; &quot;) (&quot; &lt;&lt; layoutRect.width() &lt;&lt; &quot;x&quot; &lt;&lt; layoutRect.height() &lt;&lt; &quot;)&quot;;
230         stream.nextLine();
231     };
232 
233     auto renderBoxLikeMarginBox = [](auto&amp; displayBox) {
234         // Produce a RenderBox matching margin box.
235         auto borderBox = displayBox.borderBox();
236 
237         return Display::Rect {
238             borderBox.top() - displayBox.nonCollapsedMarginBefore(),
239             borderBox.left() - displayBox.computedMarginStart().valueOr(0),
240             displayBox.computedMarginStart().valueOr(0) + borderBox.width() + displayBox.computedMarginEnd().valueOr(0),
241             displayBox.nonCollapsedMarginBefore() + borderBox.height() + displayBox.nonCollapsedMarginAfter()
242         };
243     };
244 
245     auto&amp; displayBox = context.displayBoxForLayoutBox(layoutBox);
246 
247     auto frameRect = renderer.frameRect();
248     // rendering does not offset for relative positioned boxes.
249     if (renderer.isInFlowPositioned())
250         frameRect.move(renderer.offsetForInFlowPosition());
251 
252     if (!areEssentiallyEqual(frameRect, displayBox.rect())) {
253         outputRect(&quot;frameBox&quot;, renderer.frameRect(), displayBox.rect());
254         return true;
255     }
256 
257     if (!areEssentiallyEqual(renderer.borderBoxRect(), displayBox.borderBox())) {
258         outputRect(&quot;borderBox&quot;, renderer.borderBoxRect(), displayBox.borderBox());
259         return true;
260     }
261 
262     if (!areEssentiallyEqual(renderer.paddingBoxRect(), displayBox.paddingBox())) {
263         outputRect(&quot;paddingBox&quot;, renderer.paddingBoxRect(), displayBox.paddingBox());
264         return true;
265     }
266 
267     if (!areEssentiallyEqual(renderer.contentBoxRect(), displayBox.contentBox())) {
268         outputRect(&quot;contentBox&quot;, renderer.contentBoxRect(), displayBox.contentBox());
269         return true;
270     }
271 
272     if (!areEssentiallyEqual(renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox))) {
273         // In certain cases, like out-of-flow boxes with margin auto, marginBoxRect() returns 0. It&#39;s clearly incorrect,
274         // so let&#39;s check the individual margin values instead (and at this point we know that all other boxes match).
275         auto marginsMatch = displayBox.marginBefore() == renderer.marginBefore()
276             &amp;&amp; displayBox.marginAfter() == renderer.marginAfter()
277             &amp;&amp; displayBox.marginStart() == renderer.marginStart()
278             &amp;&amp; displayBox.marginEnd() == renderer.marginEnd();
279 
280         if (!marginsMatch) {
281             outputRect(&quot;marginBox&quot;, renderer.marginBoxRect(), renderBoxLikeMarginBox(displayBox));
282             return true;
283         }
284     }
285 
286     return false;
287 }
288 
289 static bool verifyAndOutputSubtree(TextStream&amp; stream, const LayoutState&amp; context, const RenderBox&amp; renderer, const Box&amp; layoutBox)
290 {
291     // Rendering code does not have the concept of table wrapper box. Skip it by verifying the first child(table box) instead.
292     if (layoutBox.isTableWrapperBox())
293         return verifyAndOutputSubtree(stream, context, renderer, *downcast&lt;Container&gt;(layoutBox).firstChild());
294 
295     auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, renderer, layoutBox);
296 
297     if (!is&lt;Container&gt;(layoutBox))
298         return mismtachingGeometry;
299 
300     auto&amp; container = downcast&lt;Container&gt;(layoutBox);
301     auto* childLayoutBox = container.firstChild();
302     auto* childRenderer = renderer.firstChild();
303 
304     while (childRenderer) {
305         if (!is&lt;RenderBox&gt;(*childRenderer)) {
306             childRenderer = childRenderer-&gt;nextSibling();
307             continue;
308         }
309 
310         if (!childLayoutBox) {
311             stream  &lt;&lt; &quot;Trees are out of sync!&quot;;
312             stream.nextLine();
313             return true;
314         }
315 
316         if (is&lt;RenderBlockFlow&gt;(*childRenderer) &amp;&amp; childLayoutBox-&gt;establishesInlineFormattingContext()) {
317             ASSERT(childRenderer-&gt;childrenInline());
318             auto mismtachingGeometry = outputMismatchingBlockBoxInformationIfNeeded(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
319             if (mismtachingGeometry)
320                 return true;
321 
322             auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*childRenderer);
323             auto&amp; formattingRoot = downcast&lt;Container&gt;(*childLayoutBox);
324             mismtachingGeometry |= blockFlow.lineLayoutPath() == RenderBlockFlow::SimpleLinesPath ? outputMismatchingSimpleLineInformationIfNeeded(stream, context, blockFlow, formattingRoot) : outputMismatchingComplexLineInformationIfNeeded(stream, context, blockFlow, formattingRoot);
325         } else {
326             auto mismatchingSubtreeGeometry = verifyAndOutputSubtree(stream, context, downcast&lt;RenderBox&gt;(*childRenderer), *childLayoutBox);
327             mismtachingGeometry |= mismatchingSubtreeGeometry;
328         }
329 
330         childLayoutBox = childLayoutBox-&gt;nextSibling();
331         childRenderer = childRenderer-&gt;nextSibling();
332     }
333 
334     return mismtachingGeometry;
335 }
336 
337 void LayoutContext::verifyAndOutputMismatchingLayoutTree(const LayoutState&amp; layoutState, const RenderView&amp; rootRenderer)
338 {
339     TextStream stream;
340     auto&amp; layoutRoot = layoutState.root();
341     auto mismatchingGeometry = verifyAndOutputSubtree(stream, layoutState, rootRenderer, layoutRoot);
342     if (!mismatchingGeometry)
343         return;
344 #if ENABLE(TREE_DEBUGGING)
345     showRenderTree(&amp;rootRenderer);
346     showLayoutTree(layoutRoot, &amp;layoutState);
347 #endif
348     WTFLogAlways(&quot;%s&quot;, stream.release().utf8().data());
349     ASSERT_NOT_REACHED();
350 }
351 
352 }
353 }
354 
355 #endif
356 
357 #endif
    </pre>
  </body>
</html>
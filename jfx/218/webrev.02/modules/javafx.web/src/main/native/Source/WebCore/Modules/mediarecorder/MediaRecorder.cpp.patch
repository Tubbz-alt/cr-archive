diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediarecorder/MediaRecorder.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediarecorder/MediaRecorder.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediarecorder/MediaRecorder.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediarecorder/MediaRecorder.cpp
@@ -32,46 +32,53 @@
 #include "BlobEvent.h"
 #include "Document.h"
 #include "EventNames.h"
 #include "MediaRecorderErrorEvent.h"
 #include "MediaRecorderPrivate.h"
+#include "MediaRecorderProvider.h"
+#include "Page.h"
 #include "SharedBuffer.h"
+#include "WindowEventLoop.h"
 #include <wtf/IsoMallocInlines.h>
 
-#if PLATFORM(COCOA)
-#include "MediaRecorderPrivateAVFImpl.h"
-#endif
-
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaRecorder);
 
 creatorFunction MediaRecorder::m_customCreator = nullptr;
 
 ExceptionOr<Ref<MediaRecorder>> MediaRecorder::create(Document& document, Ref<MediaStream>&& stream, Options&& options)
 {
-    auto privateInstance = MediaRecorder::getPrivateImpl(stream->privateStream());
+    auto privateInstance = MediaRecorder::createMediaRecorderPrivate(document, stream->privateStream());
     if (!privateInstance)
         return Exception { NotSupportedError, "The MediaRecorder is unsupported on this platform"_s };
     auto recorder = adoptRef(*new MediaRecorder(document, WTFMove(stream), WTFMove(privateInstance), WTFMove(options)));
     recorder->suspendIfNeeded();
+    recorder->m_private->setErrorCallback([recorder = recorder.copyRef()](auto&& exception) mutable {
+        recorder->dispatchError(WTFMove(*exception));
+    });
     return recorder;
 }
 
 void MediaRecorder::setCustomPrivateRecorderCreator(creatorFunction creator)
 {
     m_customCreator = creator;
 }
 
-std::unique_ptr<MediaRecorderPrivate> MediaRecorder::getPrivateImpl(const MediaStreamPrivate& stream)
+std::unique_ptr<MediaRecorderPrivate> MediaRecorder::createMediaRecorderPrivate(Document& document, const MediaStreamPrivate& stream)
 {
     if (m_customCreator)
         return m_customCreator();
 
 #if PLATFORM(COCOA)
-    return MediaRecorderPrivateAVFImpl::create(stream);
+    auto* page = document.page();
+    if (!page)
+        return nullptr;
+
+    return page->mediaRecorderProvider().createMediaRecorderPrivate(stream);
 #else
+    UNUSED_PARAM(document);
     UNUSED_PARAM(stream);
     return nullptr;
 #endif
 }
 
@@ -91,24 +98,39 @@
 {
     m_stream->removeObserver(this);
     stopRecordingInternal();
 }
 
+Document* MediaRecorder::document() const
+{
+    return downcast<Document>(scriptExecutionContext());
+}
+
 void MediaRecorder::stop()
 {
     m_isActive = false;
     stopRecordingInternal();
 }
 
-const char* MediaRecorder::activeDOMObjectName() const
+void MediaRecorder::suspend(ReasonForSuspension reason)
 {
-    return "MediaRecorder";
+    if (reason != ReasonForSuspension::BackForwardCache)
+        return;
+
+    if (!m_isActive || state() == RecordingState::Inactive)
+        return;
+
+    stopRecordingInternal();
+
+    scheduleDeferredTask([this] {
+        dispatchEvent(MediaRecorderErrorEvent::create(eventNames().errorEvent, Exception { UnknownError, "MediaStream recording was interrupted"_s }));
+    });
 }
 
-bool MediaRecorder::canSuspendForDocumentSuspension() const
+const char* MediaRecorder::activeDOMObjectName() const
 {
-    return false; // FIXME: We should do better here as this prevents entering PageCache.
+    return "MediaRecorder";
 }
 
 ExceptionOr<void> MediaRecorder::startRecording(Optional<int> timeslice)
 {
     UNUSED_PARAM(timeslice);
@@ -131,14 +153,35 @@
         if (!m_isActive || state() == RecordingState::Inactive)
             return;
 
         stopRecordingInternal();
         ASSERT(m_state == RecordingState::Inactive);
-        dispatchEvent(BlobEvent::create(eventNames().dataavailableEvent, Event::CanBubble::No, Event::IsCancelable::No, createRecordingDataBlob()));
+        m_private->fetchData([this, protectedThis = makeRef(*this)](auto&& buffer, auto& mimeType) {
+            if (!m_isActive)
+                return;
+
+            dispatchEvent(BlobEvent::create(eventNames().dataavailableEvent, Event::CanBubble::No, Event::IsCancelable::No, buffer ? Blob::create(buffer.releaseNonNull(), mimeType) : Blob::create()));
+
+            if (!m_isActive)
+                return;
+
+            dispatchEvent(Event::create(eventNames().stopEvent, Event::CanBubble::No, Event::IsCancelable::No));
+        });
+    });
+    return { };
+}
+
+ExceptionOr<void> MediaRecorder::requestData()
+{
+    if (state() == RecordingState::Inactive)
+        return Exception { InvalidStateError, "The MediaRecorder's state cannot be inactive"_s };
+
+    m_private->fetchData([this, protectedThis = makeRef(*this)](auto&& buffer, auto& mimeType) {
         if (!m_isActive)
             return;
-        dispatchEvent(Event::create(eventNames().stopEvent, Event::CanBubble::No, Event::IsCancelable::No));
+
+        dispatchEvent(BlobEvent::create(eventNames().dataavailableEvent, Event::CanBubble::No, Event::IsCancelable::No, buffer ? Blob::create(buffer.releaseNonNull(), mimeType) : Blob::create()));
     });
     return { };
 }
 
 void MediaRecorder::stopRecordingInternal()
@@ -151,29 +194,27 @@
 
     m_state = RecordingState::Inactive;
     m_private->stopRecording();
 }
 
-Ref<Blob> MediaRecorder::createRecordingDataBlob()
-{
-    auto data = m_private->fetchData();
-    if (!data)
-        return Blob::create(scriptExecutionContext()->sessionID());
-    return Blob::create(scriptExecutionContext()->sessionID(), *data, m_private->mimeType());
-}
-
 void MediaRecorder::didAddOrRemoveTrack()
 {
     scheduleDeferredTask([this] {
         if (!m_isActive || state() == RecordingState::Inactive)
             return;
         stopRecordingInternal();
-        auto event = MediaRecorderErrorEvent::create(eventNames().errorEvent, Exception { UnknownError, "Track cannot be added to or removed from the MediaStream while recording is happening"_s });
-        dispatchEvent(WTFMove(event));
+        dispatchError(Exception { UnknownError, "Track cannot be added to or removed from the MediaStream while recording is happening"_s });
     });
 }
 
+void MediaRecorder::dispatchError(Exception&& exception)
+{
+    if (!m_isActive)
+        return;
+    dispatchEvent(MediaRecorderErrorEvent::create(eventNames().errorEvent, WTFMove(exception)));
+}
+
 void MediaRecorder::trackEnded(MediaStreamTrackPrivate&)
 {
     auto position = m_tracks.findMatching([](auto& track) {
         return !track->ended();
     });
@@ -194,15 +235,15 @@
 }
 
 void MediaRecorder::scheduleDeferredTask(Function<void()>&& function)
 {
     ASSERT(function);
-    auto* scriptExecutionContext = this->scriptExecutionContext();
-    if (!scriptExecutionContext)
+    auto* document = this->document();
+    if (!document)
         return;
 
-    scriptExecutionContext->postTask([protectedThis = makeRef(*this), function = WTFMove(function)] (auto&) {
+    document->eventLoop().queueTask(TaskSource::Networking, [pendingActivity = makePendingActivity(*this), function = WTFMove(function)] {
         function();
     });
 }
 
 } // namespace WebCore

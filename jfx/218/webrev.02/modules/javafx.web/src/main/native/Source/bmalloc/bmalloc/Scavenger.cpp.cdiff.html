<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PerThread.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Scavenger.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;AllIsoHeapsInlines.h&quot;
  #include &quot;AvailableMemory.h&quot;
  #include &quot;BulkDecommit.h&quot;
  #include &quot;Environment.h&quot;
  #include &quot;Heap.h&quot;
<span class="line-added">+ #include &quot;IsoHeapImplInlines.h&quot;</span>
  #if BOS(DARWIN)
  #import &lt;dispatch/dispatch.h&gt;
  #import &lt;mach/host_info.h&gt;
  #import &lt;mach/mach.h&gt;
  #import &lt;mach/mach_error.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,11 ***</span>
      bool printed { false };
  };
  
  DEFINE_STATIC_PER_PROCESS_STORAGE(Scavenger);
  
<span class="line-modified">! Scavenger::Scavenger(std::lock_guard&lt;Mutex&gt;&amp;)</span>
  {
      BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
  
  #if BOS(DARWIN)
      auto queue = dispatch_queue_create(&quot;WebKit Malloc Memory Pressure Handler&quot;, DISPATCH_QUEUE_SERIAL);
<span class="line-new-header">--- 66,11 ---</span>
      bool printed { false };
  };
  
  DEFINE_STATIC_PER_PROCESS_STORAGE(Scavenger);
  
<span class="line-modified">! Scavenger::Scavenger(const LockHolder&amp;)</span>
  {
      BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
  
  #if BOS(DARWIN)
      auto queue = dispatch_queue_create(&quot;WebKit Malloc Memory Pressure Handler&quot;, DISPATCH_QUEUE_SERIAL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 78,34 ***</span>
          scavenge();
      });
      dispatch_resume(m_pressureHandlerDispatchSource);
      dispatch_release(queue);
  #endif
      m_waitTime = std::chrono::milliseconds(10);
  
      m_thread = std::thread(&amp;threadEntryPoint, this);
  }
  
  void Scavenger::run()
  {
<span class="line-modified">!     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">!     runHoldingLock();</span>
  }
  
<span class="line-modified">! void Scavenger::runHoldingLock()</span>
  {
      m_state = State::Run;
      m_condition.notify_all();
  }
  
  void Scavenger::runSoon()
  {
<span class="line-modified">!     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">!     runSoonHoldingLock();</span>
  }
  
<span class="line-modified">! void Scavenger::runSoonHoldingLock()</span>
  {
      if (willRunSoon())
          return;
      m_state = State::RunSoon;
      m_condition.notify_all();
<span class="line-new-header">--- 79,38 ---</span>
          scavenge();
      });
      dispatch_resume(m_pressureHandlerDispatchSource);
      dispatch_release(queue);
  #endif
<span class="line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">+     m_waitTime = std::chrono::milliseconds(m_isInMiniMode ? 200 : 2000);</span>
<span class="line-added">+ #else</span>
      m_waitTime = std::chrono::milliseconds(10);
<span class="line-added">+ #endif</span>
  
      m_thread = std::thread(&amp;threadEntryPoint, this);
  }
  
  void Scavenger::run()
  {
<span class="line-modified">!     LockHolder lock(mutex());</span>
<span class="line-modified">!     run(lock);</span>
  }
  
<span class="line-modified">! void Scavenger::run(const LockHolder&amp;)</span>
  {
      m_state = State::Run;
      m_condition.notify_all();
  }
  
  void Scavenger::runSoon()
  {
<span class="line-modified">!     LockHolder lock(mutex());</span>
<span class="line-modified">!     runSoon(lock);</span>
  }
  
<span class="line-modified">! void Scavenger::runSoon(const LockHolder&amp;)</span>
  {
      if (willRunSoon())
          return;
      m_state = State::RunSoon;
      m_condition.notify_all();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,15 ***</span>
      m_isProbablyGrowing = true;
  }
  
  void Scavenger::scheduleIfUnderMemoryPressure(size_t bytes)
  {
<span class="line-modified">!     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">!     scheduleIfUnderMemoryPressureHoldingLock(bytes);</span>
  }
  
<span class="line-modified">! void Scavenger::scheduleIfUnderMemoryPressureHoldingLock(size_t bytes)</span>
  {
      m_scavengerBytes += bytes;
      if (m_scavengerBytes &lt; scavengerBytesPerMemoryPressureCheck)
          return;
  
<span class="line-new-header">--- 122,15 ---</span>
      m_isProbablyGrowing = true;
  }
  
  void Scavenger::scheduleIfUnderMemoryPressure(size_t bytes)
  {
<span class="line-modified">!     LockHolder lock(mutex());</span>
<span class="line-modified">!     scheduleIfUnderMemoryPressure(lock, bytes);</span>
  }
  
<span class="line-modified">! void Scavenger::scheduleIfUnderMemoryPressure(const LockHolder&amp; lock, size_t bytes)</span>
  {
      m_scavengerBytes += bytes;
      if (m_scavengerBytes &lt; scavengerBytesPerMemoryPressureCheck)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,23 ***</span>
  
      if (!isUnderMemoryPressure())
          return;
  
      m_isProbablyGrowing = false;
<span class="line-modified">!     runHoldingLock();</span>
  }
  
  void Scavenger::schedule(size_t bytes)
  {
<span class="line-modified">!     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">!     scheduleIfUnderMemoryPressureHoldingLock(bytes);</span>
  
      if (willRunSoon())
          return;
  
      m_isProbablyGrowing = false;
<span class="line-modified">!     runSoonHoldingLock();</span>
  }
  
  inline void dumpStats()
  {
      auto dump = [] (auto* string, auto size) {
<span class="line-new-header">--- 141,23 ---</span>
  
      if (!isUnderMemoryPressure())
          return;
  
      m_isProbablyGrowing = false;
<span class="line-modified">!     run(lock);</span>
  }
  
  void Scavenger::schedule(size_t bytes)
  {
<span class="line-modified">!     LockHolder lock(mutex());</span>
<span class="line-modified">!     scheduleIfUnderMemoryPressure(lock, bytes);</span>
  
      if (willRunSoon())
          return;
  
      m_isProbablyGrowing = false;
<span class="line-modified">!     runSoon(lock);</span>
  }
  
  inline void dumpStats()
  {
      auto dump = [] (auto* string, auto size) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,24 ***</span>
      dump(&quot;bmalloc-footprint&quot;, Scavenger::get()-&gt;footprint());
  }
  
  std::chrono::milliseconds Scavenger::timeSinceLastFullScavenge()
  {
<span class="line-modified">!     std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
      return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::steady_clock::now() - m_lastFullScavengeTime);
  }
  
  void Scavenger::enableMiniMode()
  {
      m_isInMiniMode = true; // We just store to this racily. The scavenger thread will eventually pick up the right value.
      if (m_state == State::RunSoon)
          run();
  }
  
  void Scavenger::scavenge()
  {
<span class="line-modified">!     std::unique_lock&lt;Mutex&gt; lock(m_scavengingMutex);</span>
  
      if (verbose) {
          fprintf(stderr, &quot;--------------------------------\n&quot;);
          fprintf(stderr, &quot;--before scavenging--\n&quot;);
          dumpStats();
<span class="line-new-header">--- 177,32 ---</span>
      dump(&quot;bmalloc-footprint&quot;, Scavenger::get()-&gt;footprint());
  }
  
  std::chrono::milliseconds Scavenger::timeSinceLastFullScavenge()
  {
<span class="line-modified">!     UniqueLockHolder lock(mutex());</span>
      return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::steady_clock::now() - m_lastFullScavengeTime);
  }
  
<span class="line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">+ std::chrono::milliseconds Scavenger::timeSinceLastPartialScavenge()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     UniqueLockHolder lock(mutex());</span>
<span class="line-added">+     return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::steady_clock::now() - m_lastPartialScavengeTime);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  void Scavenger::enableMiniMode()
  {
      m_isInMiniMode = true; // We just store to this racily. The scavenger thread will eventually pick up the right value.
      if (m_state == State::RunSoon)
          run();
  }
  
  void Scavenger::scavenge()
  {
<span class="line-modified">!     UniqueLockHolder lock(m_scavengingMutex);</span>
  
      if (verbose) {
          fprintf(stderr, &quot;--------------------------------\n&quot;);
          fprintf(stderr, &quot;--before scavenging--\n&quot;);
          dumpStats();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,31 ***</span>
      {
          BulkDecommit decommitter;
  
          {
              PrintTime printTime(&quot;\nfull scavenge under lock time&quot;);
              size_t deferredDecommits = 0;
<span class="line-modified">!             std::lock_guard&lt;Mutex&gt; lock(Heap::mutex());</span>
              for (unsigned i = numHeaps; i--;) {
                  if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
                      continue;
                  PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).scavenge(lock, decommitter, deferredDecommits);
              }
              decommitter.processEager();
  
              if (deferredDecommits)
                  m_state = State::RunSoon;
          }
  
          {
              PrintTime printTime(&quot;full scavenge lazy decommit time&quot;);
              decommitter.processLazy();
          }
  
          {
              PrintTime printTime(&quot;full scavenge mark all as eligible time&quot;);
<span class="line-modified">!             std::lock_guard&lt;Mutex&gt; lock(Heap::mutex());</span>
              for (unsigned i = numHeaps; i--;) {
                  if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
                      continue;
                  PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).markAllLargeAsEligibile(lock);
              }
<span class="line-new-header">--- 211,39 ---</span>
      {
          BulkDecommit decommitter;
  
          {
              PrintTime printTime(&quot;\nfull scavenge under lock time&quot;);
<span class="line-added">+ #if !BUSE(PARTIAL_SCAVENGE)</span>
              size_t deferredDecommits = 0;
<span class="line-modified">! #endif</span>
<span class="line-added">+             LockHolder lock(Heap::mutex());</span>
              for (unsigned i = numHeaps; i--;) {
                  if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
                      continue;
<span class="line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">+                 PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).scavenge(lock, decommitter);</span>
<span class="line-added">+ #else</span>
                  PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).scavenge(lock, decommitter, deferredDecommits);
<span class="line-added">+ #endif</span>
              }
              decommitter.processEager();
  
<span class="line-added">+ #if !BUSE(PARTIAL_SCAVENGE)</span>
              if (deferredDecommits)
                  m_state = State::RunSoon;
<span class="line-added">+ #endif</span>
          }
  
          {
              PrintTime printTime(&quot;full scavenge lazy decommit time&quot;);
              decommitter.processLazy();
          }
  
          {
              PrintTime printTime(&quot;full scavenge mark all as eligible time&quot;);
<span class="line-modified">!             LockHolder lock(Heap::mutex());</span>
              for (unsigned i = numHeaps; i--;) {
                  if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
                      continue;
                  PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).markAllLargeAsEligibile(lock);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,20 ***</span>
          dumpStats();
          fprintf(stderr, &quot;--------------------------------\n&quot;);
      }
  
      {
<span class="line-modified">!         std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
          m_lastFullScavengeTime = std::chrono::steady_clock::now();
      }
  }
  
  size_t Scavenger::freeableMemory()
  {
      size_t result = 0;
      {
<span class="line-modified">!         std::lock_guard&lt;Mutex&gt; lock(Heap::mutex());</span>
          for (unsigned i = numHeaps; i--;) {
              if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
                  continue;
              result += PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).freeableMemory(lock);
          }
<span class="line-new-header">--- 265,89 ---</span>
          dumpStats();
          fprintf(stderr, &quot;--------------------------------\n&quot;);
      }
  
      {
<span class="line-modified">!         UniqueLockHolder lock(mutex());</span>
          m_lastFullScavengeTime = std::chrono::steady_clock::now();
      }
  }
  
<span class="line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">+ void Scavenger::partialScavenge()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     UniqueLockHolder lock(m_scavengingMutex);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (verbose) {</span>
<span class="line-added">+         fprintf(stderr, &quot;--------------------------------\n&quot;);</span>
<span class="line-added">+         fprintf(stderr, &quot;--before partial scavenging--\n&quot;);</span>
<span class="line-added">+         dumpStats();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         BulkDecommit decommitter;</span>
<span class="line-added">+         {</span>
<span class="line-added">+             PrintTime printTime(&quot;\npartialScavenge under lock time&quot;);</span>
<span class="line-added">+             LockHolder lock(Heap::mutex());</span>
<span class="line-added">+             for (unsigned i = numHeaps; i--;) {</span>
<span class="line-added">+                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 Heap&amp; heap = PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i);</span>
<span class="line-added">+                 size_t freeableMemory = heap.freeableMemory(lock);</span>
<span class="line-added">+                 if (freeableMemory &lt; 4 * MB)</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 heap.scavengeToHighWatermark(lock, decommitter);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             decommitter.processEager();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         {</span>
<span class="line-added">+             PrintTime printTime(&quot;partialScavenge lazy decommit time&quot;);</span>
<span class="line-added">+             decommitter.processLazy();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         {</span>
<span class="line-added">+             PrintTime printTime(&quot;partialScavenge mark all as eligible time&quot;);</span>
<span class="line-added">+             LockHolder lock(Heap::mutex());</span>
<span class="line-added">+             for (unsigned i = numHeaps; i--;) {</span>
<span class="line-added">+                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 Heap&amp; heap = PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i);</span>
<span class="line-added">+                 heap.markAllLargeAsEligibile(lock);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         RELEASE_BASSERT(!m_deferredDecommits.size());</span>
<span class="line-added">+         AllIsoHeaps::get()-&gt;forEach(</span>
<span class="line-added">+             [&amp;] (IsoHeapImplBase&amp; heap) {</span>
<span class="line-added">+                 heap.scavengeToHighWatermark(m_deferredDecommits);</span>
<span class="line-added">+             });</span>
<span class="line-added">+         IsoHeapImplBase::finishScavenging(m_deferredDecommits);</span>
<span class="line-added">+         m_deferredDecommits.shrink(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (verbose) {</span>
<span class="line-added">+         fprintf(stderr, &quot;--after partial scavenging--\n&quot;);</span>
<span class="line-added">+         dumpStats();</span>
<span class="line-added">+         fprintf(stderr, &quot;--------------------------------\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         UniqueLockHolder lock(mutex());</span>
<span class="line-added">+         m_lastPartialScavengeTime = std::chrono::steady_clock::now();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  size_t Scavenger::freeableMemory()
  {
      size_t result = 0;
      {
<span class="line-modified">!         LockHolder lock(Heap::mutex());</span>
          for (unsigned i = numHeaps; i--;) {
              if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
                  continue;
              result += PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).freeableMemory(lock);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,16 ***</span>
      // We require any state change while we are sleeping to signal to our
      // condition variable and wake us up.
  
      while (true) {
          if (m_state == State::Sleep) {
<span class="line-modified">!             std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
              m_condition.wait(lock, [&amp;]() { return m_state != State::Sleep; });
          }
  
          if (m_state == State::RunSoon) {
<span class="line-modified">!             std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
              m_condition.wait_for(lock, m_waitTime, [&amp;]() { return m_state != State::RunSoon; });
          }
  
          m_state = State::Sleep;
  
<span class="line-new-header">--- 400,16 ---</span>
      // We require any state change while we are sleeping to signal to our
      // condition variable and wake us up.
  
      while (true) {
          if (m_state == State::Sleep) {
<span class="line-modified">!             UniqueLockHolder lock(mutex());</span>
              m_condition.wait(lock, [&amp;]() { return m_state != State::Sleep; });
          }
  
          if (m_state == State::RunSoon) {
<span class="line-modified">!             UniqueLockHolder lock(mutex());</span>
              m_condition.wait_for(lock, m_waitTime, [&amp;]() { return m_state != State::RunSoon; });
          }
  
          m_state = State::Sleep;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 330,10 ***</span>
<span class="line-new-header">--- 420,73 ---</span>
              fprintf(stderr, &quot;considering running scavenger\n&quot;);
              dumpStats();
              fprintf(stderr, &quot;--------------------------------\n&quot;);
          }
  
<span class="line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">+         enum class ScavengeMode {</span>
<span class="line-added">+             None,</span>
<span class="line-added">+             Partial,</span>
<span class="line-added">+             Full</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         size_t freeableMemory = this-&gt;freeableMemory();</span>
<span class="line-added">+ </span>
<span class="line-added">+         ScavengeMode scavengeMode = [&amp;] {</span>
<span class="line-added">+             auto timeSinceLastFullScavenge = this-&gt;timeSinceLastFullScavenge();</span>
<span class="line-added">+             auto timeSinceLastPartialScavenge = this-&gt;timeSinceLastPartialScavenge();</span>
<span class="line-added">+             auto timeSinceLastScavenge = std::min(timeSinceLastPartialScavenge, timeSinceLastFullScavenge);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (isUnderMemoryPressure() &amp;&amp; freeableMemory &gt; 1 * MB &amp;&amp; timeSinceLastScavenge &gt; std::chrono::milliseconds(5))</span>
<span class="line-added">+                 return ScavengeMode::Full;</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (!m_isProbablyGrowing) {</span>
<span class="line-added">+                 if (timeSinceLastFullScavenge &lt; std::chrono::milliseconds(1000) &amp;&amp; !m_isInMiniMode)</span>
<span class="line-added">+                     return ScavengeMode::Partial;</span>
<span class="line-added">+                 return ScavengeMode::Full;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (m_isInMiniMode) {</span>
<span class="line-added">+                 if (timeSinceLastFullScavenge &lt; std::chrono::milliseconds(200))</span>
<span class="line-added">+                     return ScavengeMode::Partial;</span>
<span class="line-added">+                 return ScavengeMode::Full;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if BCPU(X86_64)</span>
<span class="line-added">+             auto partialScavengeInterval = std::chrono::milliseconds(12000);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+             auto partialScavengeInterval = std::chrono::milliseconds(8000);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             if (timeSinceLastScavenge &lt; partialScavengeInterval) {</span>
<span class="line-added">+                 // Rate limit partial scavenges.</span>
<span class="line-added">+                 return ScavengeMode::None;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (freeableMemory &lt; 25 * MB)</span>
<span class="line-added">+                 return ScavengeMode::None;</span>
<span class="line-added">+             if (5 * freeableMemory &lt; footprint())</span>
<span class="line-added">+                 return ScavengeMode::None;</span>
<span class="line-added">+             return ScavengeMode::Partial;</span>
<span class="line-added">+         }();</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_isProbablyGrowing = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (scavengeMode) {</span>
<span class="line-added">+         case ScavengeMode::None: {</span>
<span class="line-added">+             runSoon();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case ScavengeMode::Partial: {</span>
<span class="line-added">+             partialScavenge();</span>
<span class="line-added">+             runSoon();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case ScavengeMode::Full: {</span>
<span class="line-added">+             scavenge();</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ #else</span>
          std::chrono::steady_clock::time_point start { std::chrono::steady_clock::now() };
  
          scavenge();
  
          auto timeSpentScavenging = std::chrono::steady_clock::now() - start;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,24 ***</span>
          if (verbose) {
              fprintf(stderr, &quot;time spent scavenging %lfms\n&quot;,
                  static_cast&lt;double&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(timeSpentScavenging).count()) / 1000);
          }
  
<span class="line-modified">!         std::chrono::milliseconds newWaitTime;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (m_isInMiniMode) {</span>
<span class="line-removed">-             timeSpentScavenging *= 50;</span>
<span class="line-removed">-             newWaitTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeSpentScavenging);</span>
<span class="line-removed">-             newWaitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(25)), std::chrono::milliseconds(500));</span>
<span class="line-removed">-         } else {</span>
              timeSpentScavenging *= 150;
<span class="line-modified">!             newWaitTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeSpentScavenging);</span>
              m_waitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(100)), std::chrono::milliseconds(10000));
          }
  
          if (verbose)
              fprintf(stderr, &quot;new wait time %lldms\n&quot;, static_cast&lt;long long int&gt;(m_waitTime.count()));
      }
  }
  
  void Scavenger::setThreadName(const char* name)
  {
<span class="line-new-header">--- 494,21 ---</span>
          if (verbose) {
              fprintf(stderr, &quot;time spent scavenging %lfms\n&quot;,
                  static_cast&lt;double&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(timeSpentScavenging).count()) / 1000);
          }
  
<span class="line-modified">!         // FIXME: We need to investigate mini-mode&#39;s adjustment.</span>
<span class="line-modified">!         // https://bugs.webkit.org/show_bug.cgi?id=203987</span>
<span class="line-modified">!         if (!m_isInMiniMode) {</span>
              timeSpentScavenging *= 150;
<span class="line-modified">!             std::chrono::milliseconds newWaitTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeSpentScavenging);</span>
              m_waitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(100)), std::chrono::milliseconds(10000));
          }
  
          if (verbose)
              fprintf(stderr, &quot;new wait time %lldms\n&quot;, static_cast&lt;long long int&gt;(m_waitTime.count()));
<span class="line-added">+ #endif</span>
      }
  }
  
  void Scavenger::setThreadName(const char* name)
  {
</pre>
<center><a href="PerThread.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Scavenger.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
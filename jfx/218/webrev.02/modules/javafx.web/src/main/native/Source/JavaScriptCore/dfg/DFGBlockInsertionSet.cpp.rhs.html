<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBlockInsertionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGBlockInsertionSet.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;JSCInlines.h&quot;
 32 
 33 namespace JSC { namespace DFG {
 34 
 35 BlockInsertionSet::BlockInsertionSet(Graph&amp; graph)
 36     : m_graph(graph)
 37 {
 38 }
 39 
 40 BlockInsertionSet::~BlockInsertionSet() { }
 41 
 42 void BlockInsertionSet::insert(const BlockInsertion&amp; insertion)
 43 {
 44     m_insertions.append(insertion);
 45 }
 46 
 47 void BlockInsertionSet::insert(size_t index, Ref&lt;BasicBlock&gt;&amp;&amp; block)
 48 {
 49     insert(BlockInsertion(index, WTFMove(block)));
 50 }
 51 
 52 BasicBlock* BlockInsertionSet::insert(size_t index, float executionCount)
 53 {
<a name="1" id="anc1"></a><span class="line-modified"> 54     Ref&lt;BasicBlock&gt; block = adoptRef(*new BasicBlock(BytecodeIndex(), m_graph.block(0)-&gt;variablesAtHead.numberOfArguments(), m_graph.block(0)-&gt;variablesAtHead.numberOfLocals(), m_graph.block(0)-&gt;variablesAtHead.numberOfTmps(), executionCount));</span>




 55     block-&gt;isReachable = true;
 56     auto* result = block.ptr();
 57     insert(index, WTFMove(block));
 58     return result;
 59 }
 60 
 61 BasicBlock* BlockInsertionSet::insertBefore(BasicBlock* before, float executionCount)
 62 {
 63     return insert(before-&gt;index, executionCount);
 64 }
 65 
 66 bool BlockInsertionSet::execute()
 67 {
 68     if (m_insertions.isEmpty())
 69         return false;
 70 
 71     // We allow insertions to be given to us in any order. So, we need to sort them before
 72     // running WTF::executeInsertions. Also, we don&#39;t really care if the sort is stable since
 73     // basic block order doesn&#39;t have semantics - it&#39;s just to make code easier to read.
 74     std::sort(m_insertions.begin(), m_insertions.end());
 75 
 76     executeInsertions(m_graph.m_blocks, m_insertions);
 77 
 78     // Prune out empty entries. This isn&#39;t strictly necessary but it&#39;s
 79     // healthy to keep the block list from growing.
 80     unsigned targetIndex = 0;
 81     for (unsigned sourceIndex = 0; sourceIndex &lt; m_graph.m_blocks.size();) {
 82         RefPtr&lt;BasicBlock&gt; block = m_graph.m_blocks[sourceIndex++];
 83         if (!block)
 84             continue;
 85         m_graph.m_blocks[targetIndex++] = block;
 86     }
 87     m_graph.m_blocks.shrink(targetIndex);
 88 
 89     // Make sure that the blocks know their new indices.
 90     for (unsigned i = 0; i &lt; m_graph.m_blocks.size(); ++i)
 91         m_graph.m_blocks[i]-&gt;index = i;
 92 
 93     // And finally, invalidate all analyses that rely on the CFG.
 94     m_graph.invalidateCFG();
 95     m_graph.dethread();
 96 
 97     return true;
 98 }
 99 
100 } } // namespace JSC::DFG
101 
102 #endif // ENABLE(DFG_JIT)
103 
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
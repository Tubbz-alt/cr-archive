<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontSelectionAlgorithm.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontPlatformData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontTaggedSettings.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontSelectionAlgorithm.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 49     // Explicit because it won&#39;t work correctly for values outside the representable range and because precision can be lost.
 50     explicit constexpr FontSelectionValue(float);
 51 
 52     // Precision can be lost, but value will be clamped to the representable range.
 53     static constexpr FontSelectionValue clampFloat(float);
 54 
 55     // Since floats have 23 mantissa bits, every value can be represented losslessly.
 56     constexpr operator float() const;
 57 
 58     static constexpr FontSelectionValue maximumValue();
 59     static constexpr FontSelectionValue minimumValue();
 60 
 61     friend constexpr FontSelectionValue operator+(FontSelectionValue, FontSelectionValue);
 62     friend constexpr FontSelectionValue operator-(FontSelectionValue, FontSelectionValue);
 63     friend constexpr FontSelectionValue operator*(FontSelectionValue, FontSelectionValue);
 64     friend constexpr FontSelectionValue operator/(FontSelectionValue, FontSelectionValue);
 65     friend constexpr FontSelectionValue operator-(FontSelectionValue);
 66 
 67     constexpr BackingType rawValue() const { return m_backing; }
 68 






 69 private:
 70     enum class RawTag { RawTag };
 71     constexpr FontSelectionValue(int, RawTag);
 72 
 73     static constexpr int fractionalEntropy = 4;
 74     BackingType m_backing { 0 };
 75 };
 76 



















 77 constexpr FontSelectionValue::FontSelectionValue(int x)
 78     : m_backing(x * fractionalEntropy)
 79 {
 80     // FIXME: Should we assert the passed in value was in range?
 81 }
 82 
 83 constexpr FontSelectionValue::FontSelectionValue(float x)
 84     : m_backing(x * fractionalEntropy)
 85 {
 86     // FIXME: Should we assert the passed in value was in range?
 87 }
 88 
 89 constexpr FontSelectionValue::operator float() const
 90 {
 91     return m_backing / static_cast&lt;float&gt;(fractionalEntropy);
 92 }
 93 
 94 constexpr FontSelectionValue FontSelectionValue::maximumValue()
 95 {
 96     return { std::numeric_limits&lt;BackingType&gt;::max(), RawTag::RawTag };
</pre>
<hr />
<pre>
300         else {
301             minimum = std::min(minimum, other.minimum);
302             maximum = std::max(maximum, other.maximum);
303         }
304         ASSERT(isValid());
305     }
306 
307     constexpr bool includes(Value target) const
308     {
309         return target &gt;= minimum &amp;&amp; target &lt;= maximum;
310     }
311 
312     // FIXME: This name is not so great. Move this into the add function below
313     // once we move FontPlatformDataCacheKeyHash from IntegerHasher to Hasher,
314     // and then it doesn&#39;t need to have a name.
315     constexpr uint32_t uniqueValue() const
316     {
317         return minimum.rawValue() &lt;&lt; 16 | maximum.rawValue();
318     }
319 






320     Value minimum { 1 };
321     Value maximum { 0 };
322 };
323 























324 inline void add(Hasher&amp; hasher, const FontSelectionRange&amp; range)
325 {
326     add(hasher, range.uniqueValue());
327 }
328 
329 struct FontSelectionRequest {
330     using Value = FontSelectionValue;
331 
332     Value weight;
333     Value width;
334     // FIXME: We are using an optional here to be able to distinguish between an explicit
335     // or implicit slope (for &quot;italic&quot; and &quot;oblique&quot;) and the &quot;normal&quot; value which has no
336     // slope. The &quot;italic&quot; and &quot;oblique&quot; values can be distinguished by looking at the
337     // &quot;fontStyleAxis&quot; on the FontDescription. We should come up with a tri-state member
338     // so that it&#39;s a lot clearer whether we&#39;re dealing with a &quot;normal&quot;, &quot;italic&quot; or explicit
339     // &quot;oblique&quot; font style. See webkit.org/b/187774.
340     Optional&lt;Value&gt; slope;
341 
342     std::tuple&lt;Value, Value, Optional&lt;Value&gt;&gt; tied() const
343     {
</pre>
<hr />
<pre>
428     {
429         tied() = other.tied();
430         return *this;
431     }
432 
433     constexpr Range computeWeight() const
434     {
435         return weight.valueOr(Range { normalWeightValue() });
436     }
437 
438     constexpr Range computeWidth() const
439     {
440         return width.valueOr(Range { normalStretchValue() });
441     }
442 
443     constexpr Range computeSlope() const
444     {
445         return slope.valueOr(Range { normalItalicValue() });
446     }
447 






448     OptionalRange weight;
449     OptionalRange width;
450     OptionalRange slope;
451 };
452 





























453 constexpr bool operator==(const FontSelectionSpecifiedCapabilities&amp; a, const FontSelectionSpecifiedCapabilities&amp; b)
454 {
455     return a.tied() == b.tied();
456 }
457 
458 constexpr bool operator!=(const FontSelectionSpecifiedCapabilities&amp; a, const FontSelectionSpecifiedCapabilities&amp; b)
459 {
460     return !(a == b);
461 }
462 
463 class FontSelectionAlgorithm {
464 public:
465     using Capabilities = FontSelectionCapabilities;
466 
467     FontSelectionAlgorithm() = delete;
468     FontSelectionAlgorithm(FontSelectionRequest, const Vector&lt;Capabilities&gt;&amp;, Optional&lt;Capabilities&gt; capabilitiesBounds = WTF::nullopt);
469 
470     struct DistanceResult {
471         FontSelectionValue distance;
472         FontSelectionValue value;
</pre>
</td>
<td>
<hr />
<pre>
 49     // Explicit because it won&#39;t work correctly for values outside the representable range and because precision can be lost.
 50     explicit constexpr FontSelectionValue(float);
 51 
 52     // Precision can be lost, but value will be clamped to the representable range.
 53     static constexpr FontSelectionValue clampFloat(float);
 54 
 55     // Since floats have 23 mantissa bits, every value can be represented losslessly.
 56     constexpr operator float() const;
 57 
 58     static constexpr FontSelectionValue maximumValue();
 59     static constexpr FontSelectionValue minimumValue();
 60 
 61     friend constexpr FontSelectionValue operator+(FontSelectionValue, FontSelectionValue);
 62     friend constexpr FontSelectionValue operator-(FontSelectionValue, FontSelectionValue);
 63     friend constexpr FontSelectionValue operator*(FontSelectionValue, FontSelectionValue);
 64     friend constexpr FontSelectionValue operator/(FontSelectionValue, FontSelectionValue);
 65     friend constexpr FontSelectionValue operator-(FontSelectionValue);
 66 
 67     constexpr BackingType rawValue() const { return m_backing; }
 68 
<span class="line-added"> 69     template&lt;class Encoder&gt;</span>
<span class="line-added"> 70     void encode(Encoder&amp;) const;</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72     template&lt;class Decoder&gt;</span>
<span class="line-added"> 73     static Optional&lt;FontSelectionValue&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 74 </span>
 75 private:
 76     enum class RawTag { RawTag };
 77     constexpr FontSelectionValue(int, RawTag);
 78 
 79     static constexpr int fractionalEntropy = 4;
 80     BackingType m_backing { 0 };
 81 };
 82 
<span class="line-added"> 83 template&lt;class Encoder&gt;</span>
<span class="line-added"> 84 void FontSelectionValue::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     encoder &lt;&lt; m_backing;</span>
<span class="line-added"> 87 }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 template&lt;class Decoder&gt;</span>
<span class="line-added"> 90 Optional&lt;FontSelectionValue&gt; FontSelectionValue::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 91 {</span>
<span class="line-added"> 92     Optional&lt;FontSelectionValue::BackingType&gt; backing;</span>
<span class="line-added"> 93     decoder &gt;&gt; backing;</span>
<span class="line-added"> 94     if (!backing)</span>
<span class="line-added"> 95         return WTF::nullopt;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     FontSelectionValue result;</span>
<span class="line-added"> 98     result.m_backing = *backing;</span>
<span class="line-added"> 99     return result;</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
102 constexpr FontSelectionValue::FontSelectionValue(int x)
103     : m_backing(x * fractionalEntropy)
104 {
105     // FIXME: Should we assert the passed in value was in range?
106 }
107 
108 constexpr FontSelectionValue::FontSelectionValue(float x)
109     : m_backing(x * fractionalEntropy)
110 {
111     // FIXME: Should we assert the passed in value was in range?
112 }
113 
114 constexpr FontSelectionValue::operator float() const
115 {
116     return m_backing / static_cast&lt;float&gt;(fractionalEntropy);
117 }
118 
119 constexpr FontSelectionValue FontSelectionValue::maximumValue()
120 {
121     return { std::numeric_limits&lt;BackingType&gt;::max(), RawTag::RawTag };
</pre>
<hr />
<pre>
325         else {
326             minimum = std::min(minimum, other.minimum);
327             maximum = std::max(maximum, other.maximum);
328         }
329         ASSERT(isValid());
330     }
331 
332     constexpr bool includes(Value target) const
333     {
334         return target &gt;= minimum &amp;&amp; target &lt;= maximum;
335     }
336 
337     // FIXME: This name is not so great. Move this into the add function below
338     // once we move FontPlatformDataCacheKeyHash from IntegerHasher to Hasher,
339     // and then it doesn&#39;t need to have a name.
340     constexpr uint32_t uniqueValue() const
341     {
342         return minimum.rawValue() &lt;&lt; 16 | maximum.rawValue();
343     }
344 
<span class="line-added">345     template&lt;class Encoder&gt;</span>
<span class="line-added">346     void encode(Encoder&amp;) const;</span>
<span class="line-added">347 </span>
<span class="line-added">348     template&lt;class Decoder&gt;</span>
<span class="line-added">349     static Optional&lt;FontSelectionRange&gt; decode(Decoder&amp;);</span>
<span class="line-added">350 </span>
351     Value minimum { 1 };
352     Value maximum { 0 };
353 };
354 
<span class="line-added">355 template&lt;class Encoder&gt;</span>
<span class="line-added">356 void FontSelectionRange::encode(Encoder&amp; encoder) const</span>
<span class="line-added">357 {</span>
<span class="line-added">358     encoder &lt;&lt; minimum;</span>
<span class="line-added">359     encoder &lt;&lt; maximum;</span>
<span class="line-added">360 }</span>
<span class="line-added">361 </span>
<span class="line-added">362 template&lt;class Decoder&gt;</span>
<span class="line-added">363 Optional&lt;FontSelectionRange&gt; FontSelectionRange::decode(Decoder&amp; decoder)</span>
<span class="line-added">364 {</span>
<span class="line-added">365     Optional&lt;FontSelectionRange::Value&gt; minimum;</span>
<span class="line-added">366     decoder &gt;&gt; minimum;</span>
<span class="line-added">367     if (!minimum)</span>
<span class="line-added">368         return WTF::nullopt;</span>
<span class="line-added">369 </span>
<span class="line-added">370     Optional&lt;FontSelectionRange::Value&gt; maximum;</span>
<span class="line-added">371     decoder &gt;&gt; maximum;</span>
<span class="line-added">372     if (!maximum)</span>
<span class="line-added">373         return WTF::nullopt;</span>
<span class="line-added">374 </span>
<span class="line-added">375     return {{ *minimum, *maximum }};</span>
<span class="line-added">376 }</span>
<span class="line-added">377 </span>
378 inline void add(Hasher&amp; hasher, const FontSelectionRange&amp; range)
379 {
380     add(hasher, range.uniqueValue());
381 }
382 
383 struct FontSelectionRequest {
384     using Value = FontSelectionValue;
385 
386     Value weight;
387     Value width;
388     // FIXME: We are using an optional here to be able to distinguish between an explicit
389     // or implicit slope (for &quot;italic&quot; and &quot;oblique&quot;) and the &quot;normal&quot; value which has no
390     // slope. The &quot;italic&quot; and &quot;oblique&quot; values can be distinguished by looking at the
391     // &quot;fontStyleAxis&quot; on the FontDescription. We should come up with a tri-state member
392     // so that it&#39;s a lot clearer whether we&#39;re dealing with a &quot;normal&quot;, &quot;italic&quot; or explicit
393     // &quot;oblique&quot; font style. See webkit.org/b/187774.
394     Optional&lt;Value&gt; slope;
395 
396     std::tuple&lt;Value, Value, Optional&lt;Value&gt;&gt; tied() const
397     {
</pre>
<hr />
<pre>
482     {
483         tied() = other.tied();
484         return *this;
485     }
486 
487     constexpr Range computeWeight() const
488     {
489         return weight.valueOr(Range { normalWeightValue() });
490     }
491 
492     constexpr Range computeWidth() const
493     {
494         return width.valueOr(Range { normalStretchValue() });
495     }
496 
497     constexpr Range computeSlope() const
498     {
499         return slope.valueOr(Range { normalItalicValue() });
500     }
501 
<span class="line-added">502     template&lt;class Encoder&gt;</span>
<span class="line-added">503     void encode(Encoder&amp;) const;</span>
<span class="line-added">504 </span>
<span class="line-added">505     template&lt;class Decoder&gt;</span>
<span class="line-added">506     static Optional&lt;FontSelectionSpecifiedCapabilities&gt; decode(Decoder&amp;);</span>
<span class="line-added">507 </span>
508     OptionalRange weight;
509     OptionalRange width;
510     OptionalRange slope;
511 };
512 
<span class="line-added">513 template&lt;class Encoder&gt;</span>
<span class="line-added">514 void FontSelectionSpecifiedCapabilities::encode(Encoder&amp; encoder) const</span>
<span class="line-added">515 {</span>
<span class="line-added">516     encoder &lt;&lt; weight;</span>
<span class="line-added">517     encoder &lt;&lt; width;</span>
<span class="line-added">518     encoder &lt;&lt; slope;</span>
<span class="line-added">519 }</span>
<span class="line-added">520 </span>
<span class="line-added">521 template&lt;class Decoder&gt;</span>
<span class="line-added">522 Optional&lt;FontSelectionSpecifiedCapabilities&gt; FontSelectionSpecifiedCapabilities::decode(Decoder&amp; decoder)</span>
<span class="line-added">523 {</span>
<span class="line-added">524     Optional&lt;OptionalRange&gt; weight;</span>
<span class="line-added">525     decoder &gt;&gt; weight;</span>
<span class="line-added">526     if (!weight)</span>
<span class="line-added">527         return WTF::nullopt;</span>
<span class="line-added">528 </span>
<span class="line-added">529     Optional&lt;OptionalRange&gt; width;</span>
<span class="line-added">530     decoder &gt;&gt; width;</span>
<span class="line-added">531     if (!width)</span>
<span class="line-added">532         return WTF::nullopt;</span>
<span class="line-added">533 </span>
<span class="line-added">534     Optional&lt;OptionalRange&gt; slope;</span>
<span class="line-added">535     decoder &gt;&gt; slope;</span>
<span class="line-added">536     if (!slope)</span>
<span class="line-added">537         return WTF::nullopt;</span>
<span class="line-added">538 </span>
<span class="line-added">539     return {{ *weight, *width, *slope }};</span>
<span class="line-added">540 }</span>
<span class="line-added">541 </span>
542 constexpr bool operator==(const FontSelectionSpecifiedCapabilities&amp; a, const FontSelectionSpecifiedCapabilities&amp; b)
543 {
544     return a.tied() == b.tied();
545 }
546 
547 constexpr bool operator!=(const FontSelectionSpecifiedCapabilities&amp; a, const FontSelectionSpecifiedCapabilities&amp; b)
548 {
549     return !(a == b);
550 }
551 
552 class FontSelectionAlgorithm {
553 public:
554     using Capabilities = FontSelectionCapabilities;
555 
556     FontSelectionAlgorithm() = delete;
557     FontSelectionAlgorithm(FontSelectionRequest, const Vector&lt;Capabilities&gt;&amp;, Optional&lt;Capabilities&gt; capabilitiesBounds = WTF::nullopt);
558 
559     struct DistanceResult {
560         FontSelectionValue distance;
561         FontSelectionValue value;
</pre>
</td>
</tr>
</table>
<center><a href="FontPlatformData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontTaggedSettings.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
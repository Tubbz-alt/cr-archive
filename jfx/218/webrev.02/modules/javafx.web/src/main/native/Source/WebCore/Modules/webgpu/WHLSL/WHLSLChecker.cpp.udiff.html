<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLCheckTextureReferences.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLHighZombieFinder.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -197,80 +197,10 @@</span>
      String m_name;
      Vector&lt;std::reference_wrapper&lt;AST::UnnamedType&gt;&gt; m_types;
      AST::NamedType* m_castReturnType;
  };
  
<span class="udiff-line-removed">- class AndOverloadTypeKey {</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-     AndOverloadTypeKey() = default;</span>
<span class="udiff-line-removed">-     AndOverloadTypeKey(WTF::HashTableDeletedValueType)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         m_type = bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     AndOverloadTypeKey(AST::UnnamedType&amp; type, AST::AddressSpace addressSpace)</span>
<span class="udiff-line-removed">-         : m_type(&amp;type)</span>
<span class="udiff-line-removed">-         , m_addressSpace(addressSpace)</span>
<span class="udiff-line-removed">-     { }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bool isEmptyValue() const { return !m_type; }</span>
<span class="udiff-line-removed">-     bool isHashTableDeletedValue() const { return m_type == bitwise_cast&lt;AST::UnnamedType*&gt;(static_cast&lt;uintptr_t&gt;(1)); }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     unsigned hash() const</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return IntHash&lt;uint8_t&gt;::hash(static_cast&lt;uint8_t&gt;(m_addressSpace)) ^ m_type-&gt;hash();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     bool operator==(const AndOverloadTypeKey&amp; other) const</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         return m_addressSpace == other.m_addressSpace</span>
<span class="udiff-line-removed">-             &amp;&amp; *m_type == *other.m_type;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     struct Hash {</span>
<span class="udiff-line-removed">-         static unsigned hash(const AndOverloadTypeKey&amp; key)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             return key.hash();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         static bool equal(const AndOverloadTypeKey&amp; a, const AndOverloadTypeKey&amp; b)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             return a == b;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         static const bool safeToCompareToEmptyOrDeleted = false;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     struct Traits : public WTF::SimpleClassHashTraits&lt;AndOverloadTypeKey&gt; {</span>
<span class="udiff-line-removed">-         static const bool hasIsEmptyValueFunction = true;</span>
<span class="udiff-line-removed">-         static bool isEmptyValue(const AndOverloadTypeKey&amp; key) { return key.isEmptyValue(); }</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-     AST::UnnamedType* m_type { nullptr };</span>
<span class="udiff-line-removed">-     AST::AddressSpace m_addressSpace;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static AST::NativeFunctionDeclaration resolveWithOperatorAnderIndexer(CodeLocation location, AST::ArrayReferenceType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     const bool isOperator = true;</span>
<span class="udiff-line-removed">-     auto returnType = AST::PointerType::create(location, firstArgument.addressSpace(), firstArgument.elementType());</span>
<span class="udiff-line-removed">-     AST::VariableDeclarations parameters;</span>
<span class="udiff-line-removed">-     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="udiff-line-removed">-     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), AST::TypeReference::wrap(location, intrinsics.uintType()), String(), nullptr, nullptr));</span>
<span class="udiff-line-removed">-     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator&amp;[]&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static AST::NativeFunctionDeclaration resolveWithOperatorLength(CodeLocation location, AST::UnnamedType&amp; firstArgument, const Intrinsics&amp; intrinsics)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     const bool isOperator = true;</span>
<span class="udiff-line-removed">-     auto returnType = AST::TypeReference::wrap(location, intrinsics.uintType());</span>
<span class="udiff-line-removed">-     AST::VariableDeclarations parameters;</span>
<span class="udiff-line-removed">-     parameters.append(makeUniqueRef&lt;AST::VariableDeclaration&gt;(location, AST::Qualifiers(), &amp;firstArgument, String(), nullptr, nullptr));</span>
<span class="udiff-line-removed">-     return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator.length&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static AST::NativeFunctionDeclaration resolveWithReferenceComparator(CodeLocation location, ResolvingType&amp; firstArgument, ResolvingType&amp; secondArgument, const Intrinsics&amp; intrinsics)
  {
      const bool isOperator = true;
      auto returnType = AST::TypeReference::wrap(location, intrinsics.boolType());
      auto argumentType = firstArgument.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Ref&lt;AST::UnnamedType&gt; {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,60 +221,32 @@</span>
      return AST::NativeFunctionDeclaration(AST::FunctionDeclaration(location, AST::AttributeBlock(), WTF::nullopt, WTFMove(returnType), String(&quot;operator==&quot;, String::ConstructFromLiteral), WTFMove(parameters), nullptr, isOperator, ParsingMode::StandardLibrary));
  }
  
  enum class Acceptability {
      Yes,
<span class="udiff-line-removed">-     Maybe,</span>
      No
  };
  
  static Optional&lt;AST::NativeFunctionDeclaration&gt; resolveByInstantiation(const String&amp; name, CodeLocation location, const Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const Intrinsics&amp; intrinsics)
  {
<span class="udiff-line-modified-removed">-     if (name == &quot;operator&amp;[]&quot; &amp;&amp; types.size() == 2) {</span>
<span class="udiff-line-removed">-         auto* firstArgumentArrayRef = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::ArrayReferenceType* {</span>
<span class="udiff-line-removed">-             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))</span>
<span class="udiff-line-removed">-                 return &amp;downcast&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType));</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-removed">-         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::ArrayReferenceType* {</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-removed">-         }));</span>
<span class="udiff-line-removed">-         bool secondArgumentIsUint = types[1].get().visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; bool {</span>
<span class="udiff-line-removed">-             return matches(unnamedType, intrinsics.uintType());</span>
<span class="udiff-line-removed">-         }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; bool {</span>
<span class="udiff-line-removed">-             return resolvableTypeReference-&gt;resolvableType().canResolve(intrinsics.uintType());</span>
<span class="udiff-line-removed">-         }));</span>
<span class="udiff-line-removed">-         if (firstArgumentArrayRef &amp;&amp; secondArgumentIsUint)</span>
<span class="udiff-line-removed">-             return resolveWithOperatorAnderIndexer(location, *firstArgumentArrayRef, intrinsics);</span>
<span class="udiff-line-removed">-     } else if (name == &quot;operator.length&quot; &amp;&amp; types.size() == 1) {</span>
<span class="udiff-line-removed">-         auto* firstArgumentReference = types[0].get().visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; AST::UnnamedType* {</span>
<span class="udiff-line-removed">-             if (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)) || is&lt;AST::ArrayType&gt;(static_cast&lt;AST::UnnamedType&amp;&gt;(unnamedType)))</span>
<span class="udiff-line-removed">-                 return unnamedType.ptr();</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-removed">-         }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; AST::UnnamedType* {</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-removed">-         }));</span>
<span class="udiff-line-removed">-         if (firstArgumentReference)</span>
<span class="udiff-line-removed">-             return resolveWithOperatorLength(location, *firstArgumentReference, intrinsics);</span>
<span class="udiff-line-removed">-     } else if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
<span class="udiff-line-modified-added">+     if (name == &quot;operator==&quot; &amp;&amp; types.size() == 2) {</span>
          auto acceptability = [](ResolvingType&amp; resolvingType) -&gt; Acceptability {
              return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; Acceptability {
                  auto&amp; unifyNode = unnamedType-&gt;unifyNode();
                  return is&lt;AST::UnnamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(unifyNode)) ? Acceptability::Yes : Acceptability::No;
<span class="udiff-line-modified-removed">-             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; Acceptability {</span>
<span class="udiff-line-modified-removed">-                 return is&lt;AST::NullLiteralType&gt;(resolvableTypeReference-&gt;resolvableType()) ? Acceptability::Maybe : Acceptability::No;</span>
<span class="udiff-line-modified-added">+             }, [](RefPtr&lt;ResolvableTypeReference&gt;&amp;) -&gt; Acceptability {</span>
<span class="udiff-line-modified-added">+                 return Acceptability::No;</span>
              }));
          };
          auto leftAcceptability = acceptability(types[0].get());
          auto rightAcceptability = acceptability(types[1].get());
          bool success = false;
          if (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Yes) {
              auto&amp; unnamedType1 = *types[0].get().getUnnamedType();
              auto&amp; unnamedType2 = *types[1].get().getUnnamedType();
              success = matches(unnamedType1, unnamedType2);
<span class="udiff-line-modified-removed">-         } else if ((leftAcceptability == Acceptability::Maybe &amp;&amp; rightAcceptability == Acceptability::Yes)</span>
<span class="udiff-line-removed">-             || (leftAcceptability == Acceptability::Yes &amp;&amp; rightAcceptability == Acceptability::Maybe))</span>
<span class="udiff-line-removed">-             success = true;</span>
<span class="udiff-line-modified-added">+         }</span>
          if (success)
              return resolveWithReferenceComparator(location, types[0].get(), types[1].get(), intrinsics);
      }
      return WTF::nullopt;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -425,101 +327,17 @@</span>
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition, NameContext&amp; nameContext, AST::NameSpace currentNameSpace)</span>
<span class="udiff-line-modified-added">+ static bool checkOperatorOverload(const AST::FunctionDefinition&amp; functionDefinition)</span>
  {
      enum class CheckKind {
          Index,
          Dot
      };
  
<span class="udiff-line-removed">-     auto checkGetter = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="udiff-line-removed">-         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;</span>
<span class="udiff-line-removed">-         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         auto&amp; firstParameterUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="udiff-line-removed">-         if (is&lt;AST::UnnamedType&gt;(firstParameterUnifyNode)) {</span>
<span class="udiff-line-removed">-             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstParameterUnifyNode);</span>
<span class="udiff-line-removed">-             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (kind == CheckKind::Index) {</span>
<span class="udiff-line-removed">-             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="udiff-line-removed">-             if (!nativeTypeDeclaration.isInt())</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto checkSetter = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="udiff-line-removed">-         size_t numExpectedParameters = kind == CheckKind::Index ? 3 : 2;</span>
<span class="udiff-line-removed">-         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         auto&amp; firstArgumentUnifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="udiff-line-removed">-         if (is&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode)) {</span>
<span class="udiff-line-removed">-             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(firstArgumentUnifyNode);</span>
<span class="udiff-line-removed">-             if (is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType) || is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (kind == CheckKind::Index) {</span>
<span class="udiff-line-removed">-             auto&amp; secondParameterUnifyNode = functionDefinition.parameters()[1]-&gt;type()-&gt;unifyNode();</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::NamedType&gt;(secondParameterUnifyNode))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(secondParameterUnifyNode);</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::NativeTypeDeclaration&gt;(namedType))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(namedType);</span>
<span class="udiff-line-removed">-             if (!nativeTypeDeclaration.isInt())</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         if (!matches(functionDefinition.type(), *functionDefinition.parameters()[0]-&gt;type()))</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         auto&amp; valueType = *functionDefinition.parameters()[numExpectedParameters - 1]-&gt;type();</span>
<span class="udiff-line-removed">-         auto getterName = functionDefinition.name().substring(0, functionDefinition.name().length() - 1);</span>
<span class="udiff-line-removed">-         auto getterFuncs = nameContext.getFunctions(getterName, currentNameSpace);</span>
<span class="udiff-line-removed">-         Vector&lt;ResolvingType&gt; argumentTypes;</span>
<span class="udiff-line-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; argumentTypeReferences;</span>
<span class="udiff-line-removed">-         for (size_t i = 0; i &lt; numExpectedParameters - 1; ++i)</span>
<span class="udiff-line-removed">-             argumentTypes.append(*functionDefinition.parameters()[i]-&gt;type());</span>
<span class="udiff-line-removed">-         for (auto&amp; argumentType : argumentTypes)</span>
<span class="udiff-line-removed">-             argumentTypeReferences.append(argumentType);</span>
<span class="udiff-line-removed">-         auto* overload = resolveFunctionOverload(getterFuncs, argumentTypeReferences, currentNameSpace);</span>
<span class="udiff-line-removed">-         if (!overload)</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         auto&amp; resultType = overload-&gt;type();</span>
<span class="udiff-line-removed">-         return matches(resultType, valueType);</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto checkAnder = [&amp;](CheckKind kind) -&gt; bool {</span>
<span class="udiff-line-removed">-         size_t numExpectedParameters = kind == CheckKind::Index ? 2 : 1;</span>
<span class="udiff-line-removed">-         if (functionDefinition.parameters().size() != numExpectedParameters)</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             auto&amp; unifyNode = functionDefinition.type().unifyNode();</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::UnnamedType&gt;(unifyNode))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             auto&amp; unifyNode = functionDefinition.parameters()[0]-&gt;type()-&gt;unifyNode();</span>
<span class="udiff-line-removed">-             if (!is&lt;AST::UnnamedType&gt;(unifyNode))</span>
<span class="udiff-line-removed">-                 return false;</span>
<span class="udiff-line-removed">-             auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="udiff-line-removed">-             return is&lt;AST::PointerType&gt;(unnamedType) || is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
      if (!functionDefinition.isOperator())
          return true;
      if (functionDefinition.isCast())
          return true;
      if (functionDefinition.name() == &quot;operator++&quot; || functionDefinition.name() == &quot;operator--&quot;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -537,23 +355,10 @@</span>
          || functionDefinition.name() == &quot;operator&lt;&lt;&quot;
          || functionDefinition.name() == &quot;operator&gt;&gt;&quot;)
          return functionDefinition.parameters().size() == 2;
      if (functionDefinition.name() == &quot;operator~&quot;)
          return functionDefinition.parameters().size() == 1;
<span class="udiff-line-removed">-     if (functionDefinition.name() == &quot;operator[]&quot;)</span>
<span class="udiff-line-removed">-         return checkGetter(CheckKind::Index);</span>
<span class="udiff-line-removed">-     if (functionDefinition.name() == &quot;operator[]=&quot;)</span>
<span class="udiff-line-removed">-         return checkSetter(CheckKind::Index);</span>
<span class="udiff-line-removed">-     if (functionDefinition.name() == &quot;operator&amp;[]&quot;)</span>
<span class="udiff-line-removed">-         return checkAnder(CheckKind::Index);</span>
<span class="udiff-line-removed">-     if (functionDefinition.name().startsWith(&quot;operator.&quot;)) {</span>
<span class="udiff-line-removed">-         if (functionDefinition.name().endsWith(&quot;=&quot;))</span>
<span class="udiff-line-removed">-             return checkSetter(CheckKind::Dot);</span>
<span class="udiff-line-removed">-         return checkGetter(CheckKind::Dot);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     if (functionDefinition.name().startsWith(&quot;operator&amp;.&quot;))</span>
<span class="udiff-line-removed">-         return checkAnder(CheckKind::Dot);</span>
      return false;
  }
  
  class Checker : public Visitor {
  public:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -598,14 +403,16 @@</span>
      Optional&lt;RecurseInfo&gt; recurseAndGetInfo(AST::Expression&amp;, bool requiresLeftValue = false);
      Optional&lt;RecurseInfo&gt; getInfo(AST::Expression&amp;, bool requiresLeftValue = false);
      RefPtr&lt;AST::UnnamedType&gt; recurseAndWrapBaseType(AST::PropertyAccessExpression&amp;);
      bool recurseAndRequireBoolType(AST::Expression&amp;);
      void assignConcreteType(AST::Expression&amp;, Ref&lt;AST::UnnamedType&gt;, AST::TypeAnnotation);
<span class="udiff-line-added">+     void assignConcreteType(AST::Expression&amp;, AST::NamedType&amp;, AST::TypeAnnotation);</span>
      void assignType(AST::Expression&amp;, RefPtr&lt;ResolvableTypeReference&gt;, AST::TypeAnnotation);
      void forwardType(AST::Expression&amp;, ResolvingType&amp;, AST::TypeAnnotation);
  
      void visit(AST::FunctionDefinition&amp;) override;
<span class="udiff-line-added">+     void visit(AST::FunctionDeclaration&amp;) override;</span>
      void visit(AST::EnumerationDefinition&amp;) override;
      void visit(AST::TypeReference&amp;) override;
      void visit(AST::VariableDeclaration&amp;) override;
      void visit(AST::AssignmentExpression&amp;) override;
      void visit(AST::ReadModifyWriteExpression&amp;) override;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -619,11 +426,10 @@</span>
      void visit(AST::PointerType&amp;) override;
      void visit(AST::ArrayReferenceType&amp;) override;
      void visit(AST::IntegerLiteral&amp;) override;
      void visit(AST::UnsignedIntegerLiteral&amp;) override;
      void visit(AST::FloatLiteral&amp;) override;
<span class="udiff-line-removed">-     void visit(AST::NullLiteral&amp;) override;</span>
      void visit(AST::BooleanLiteral&amp;) override;
      void visit(AST::EnumerationMemberLiteral&amp;) override;
      void visit(AST::LogicalNotExpression&amp;) override;
      void visit(AST::LogicalExpression&amp;) override;
      void visit(AST::IfStatement&amp;) override;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -633,54 +439,47 @@</span>
      void visit(AST::SwitchStatement&amp;) override;
      void visit(AST::CommaExpression&amp;) override;
      void visit(AST::TernaryExpression&amp;) override;
      void visit(AST::CallExpression&amp;) override;
  
<span class="udiff-line-removed">-     void finishVisiting(AST::PropertyAccessExpression&amp;, ResolvingType* additionalArgumentType = nullptr);</span>
<span class="udiff-line-removed">- </span>
      AST::FunctionDeclaration* resolveFunction(Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt;&amp; types, const String&amp; name, CodeLocation, AST::NamedType* castReturnType = nullptr);
  
<span class="udiff-line-removed">-     RefPtr&lt;AST::UnnamedType&gt; argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace);</span>
<span class="udiff-line-removed">- </span>
      AST::UnnamedType&amp; wrappedFloatType()
      {
          if (!m_wrappedFloatType)
              m_wrappedFloatType = AST::TypeReference::wrap({ }, m_intrinsics.floatType());
          return *m_wrappedFloatType;
      }
  
<span class="udiff-line-modified-removed">-     AST::UnnamedType&amp; genericPointerType()</span>
<span class="udiff-line-modified-added">+     AST::UnnamedType&amp; wrappedUintType()</span>
      {
<span class="udiff-line-modified-removed">-         if (!m_genericPointerType)</span>
<span class="udiff-line-modified-removed">-             m_genericPointerType = AST::PointerType::create({ }, AST::AddressSpace::Thread, AST::TypeReference::wrap({ }, m_intrinsics.floatType()));</span>
<span class="udiff-line-modified-removed">-         return *m_genericPointerType;</span>
<span class="udiff-line-modified-added">+         if (!m_wrappedUintType)</span>
<span class="udiff-line-modified-added">+             m_wrappedUintType = AST::TypeReference::wrap({ }, m_intrinsics.uintType());</span>
<span class="udiff-line-modified-added">+         return *m_wrappedUintType;</span>
      }
  
      AST::UnnamedType&amp; normalizedTypeForFunctionKey(AST::UnnamedType&amp; type)
      {
          auto* unifyNode = &amp;type.unifyNode();
          if (unifyNode == &amp;m_intrinsics.uintType() || unifyNode == &amp;m_intrinsics.intType())
              return wrappedFloatType();
  
<span class="udiff-line-removed">-         if (is&lt;AST::ReferenceType&gt;(type))</span>
<span class="udiff-line-removed">-             return genericPointerType();</span>
<span class="udiff-line-removed">- </span>
          return type;
      }
  
      RefPtr&lt;AST::TypeReference&gt; m_wrappedFloatType;
<span class="udiff-line-modified-removed">-     RefPtr&lt;AST::UnnamedType&gt; m_genericPointerType;</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;AST::TypeReference&gt; m_wrappedUintType;</span>
      HashMap&lt;AST::Expression*, std::unique_ptr&lt;ResolvingType&gt;&gt; m_typeMap;
      HashSet&lt;String&gt; m_vertexEntryPoints[AST::nameSpaceCount];
      HashSet&lt;String&gt; m_fragmentEntryPoints[AST::nameSpaceCount];
      HashSet&lt;String&gt; m_computeEntryPoints[AST::nameSpaceCount];
      const Intrinsics&amp; m_intrinsics;
      Program&amp; m_program;
      AST::FunctionDefinition* m_currentFunction { nullptr };
      HashMap&lt;FunctionKey, Vector&lt;std::reference_wrapper&lt;AST::FunctionDeclaration&gt;, 1&gt;, FunctionKey::Hash, FunctionKey::Traits&gt; m_functions;
<span class="udiff-line-removed">-     HashMap&lt;AndOverloadTypeKey, RefPtr&lt;AST::UnnamedType&gt;, AndOverloadTypeKey::Hash, AndOverloadTypeKey::Traits&gt; m_andOverloadTypeMap;</span>
      AST::NameSpace m_currentNameSpace { AST::NameSpace::StandardLibrary };
<span class="udiff-line-added">+     bool m_isVisitingParameters { false };</span>
  };
  
  void Checker::visit(Program&amp; program)
  {
      // These visiting functions might add new global statements, so don&#39;t use foreach syntax.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -731,10 +530,17 @@</span>
      case AST::EntryPointType::Compute:
          return static_cast&lt;bool&gt;(m_computeEntryPoints[index].add(functionDefinition.name()));
      }
  }
  
<span class="udiff-line-added">+ void Checker::visit(AST::FunctionDeclaration&amp; functionDeclaration)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_isVisitingParameters = true;</span>
<span class="udiff-line-added">+     Visitor::visit(functionDeclaration);</span>
<span class="udiff-line-added">+     m_isVisitingParameters = false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Checker::visit(AST::FunctionDefinition&amp; functionDefinition)
  {
      m_currentNameSpace = functionDefinition.nameSpace();
      m_currentFunction = &amp;functionDefinition;
      if (functionDefinition.entryPointType()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -750,11 +556,11 @@</span>
          if (!checkSemantics(entryPointItems-&gt;inputs, entryPointItems-&gt;outputs, functionDefinition.entryPointType(), m_intrinsics)) {
              setError(Error(&quot;Bad semantics for entrypoint.&quot;, functionDefinition.codeLocation()));
              return;
          }
      }
<span class="udiff-line-modified-removed">-     if (!checkOperatorOverload(functionDefinition, m_program.nameContext(), m_currentNameSpace)) {</span>
<span class="udiff-line-modified-added">+     if (!checkOperatorOverload(functionDefinition)) {</span>
          setError(Error(&quot;Operator does not match expected signature.&quot;, functionDefinition.codeLocation()));
          return;
      }
  
      Visitor::visit(functionDefinition);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -788,10 +594,21 @@</span>
      }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
          return matchAndCommit(unnamedType, resolvingType-&gt;resolvableType());
      }));
  }
  
<span class="udiff-line-added">+ static bool matchAndCommit(ResolvingType&amp; resolvingType, AST::NamedType&amp; namedType)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; resolvingType) {</span>
<span class="udiff-line-added">+         if (matches(resolvingType, namedType))</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvingType) -&gt; bool {</span>
<span class="udiff-line-added">+         return matchAndCommit(namedType, resolvingType-&gt;resolvableType());</span>
<span class="udiff-line-added">+     }));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static RefPtr&lt;AST::UnnamedType&gt; commit(ResolvingType&amp; resolvingType)
  {
      return resolvingType.visit(WTF::makeVisitor([&amp;](Ref&lt;AST::UnnamedType&gt;&amp; unnamedType) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
          return unnamedType.copyRef();
      }, [&amp;](RefPtr&lt;ResolvableTypeReference&gt;&amp; resolvableTypeReference) -&gt; RefPtr&lt;AST::UnnamedType&gt; {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -816,13 +633,10 @@</span>
              if (resolvableTypeReference-&gt;resolvableType().isFloatLiteralType()
                  || resolvableTypeReference-&gt;resolvableType().isIntegerLiteralType()
                  || resolvableTypeReference-&gt;resolvableType().isUnsignedIntegerLiteralType())
                  return &amp;wrappedFloatType();
  
<span class="udiff-line-removed">-             if (resolvableTypeReference-&gt;resolvableType().isNullLiteralType())</span>
<span class="udiff-line-removed">-                 return &amp;genericPointerType();</span>
<span class="udiff-line-removed">- </span>
              return commit(resolvableTypeReference-&gt;resolvableType()).get();
          }));
  
          if (!type) {
              setError(Error(&quot;Could not resolve the type of a constant.&quot;));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -956,20 +770,35 @@</span>
              return;
          if (!matchAndCommit(initializerInfo-&gt;resolvingType, lhsType)) {
              setError(Error(&quot;Declared variable type does not match its initializer&#39;s type.&quot;, variableDeclaration.codeLocation()));
              return;
          }
<span class="udiff-line-added">+     } else if (!m_isVisitingParameters &amp;&amp; is&lt;AST::ReferenceType&gt;(variableDeclaration.type()-&gt;unifyNode())) {</span>
<span class="udiff-line-added">+         if (is&lt;AST::PointerType&gt;(variableDeclaration.type()-&gt;unifyNode()))</span>
<span class="udiff-line-added">+             setError(Error(&quot;Must assign to a pointer variable declaration in its initializer.&quot;, variableDeclaration.codeLocation()));</span>
<span class="udiff-line-added">+         else {</span>
<span class="udiff-line-added">+             ASSERT(is&lt;AST::ArrayReferenceType&gt;(variableDeclaration.type()-&gt;unifyNode()));</span>
<span class="udiff-line-added">+             setError(Error(&quot;Must assign to an array reference variable declaration in its initializer.&quot;, variableDeclaration.codeLocation()));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return;</span>
      }
  }
  
  void Checker::assignConcreteType(AST::Expression&amp; expression, Ref&lt;AST::UnnamedType&gt; unnamedType, AST::TypeAnnotation typeAnnotation = AST::RightValue())
  {
      auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(unnamedType)));
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
      expression.setTypeAnnotation(WTFMove(typeAnnotation));
  }
  
<span class="udiff-line-added">+ void Checker::assignConcreteType(AST::Expression&amp; expression, AST::NamedType&amp; type, AST::TypeAnnotation annotation)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto unnamedType = AST::TypeReference::wrap(type.codeLocation(), type);</span>
<span class="udiff-line-added">+     Visitor::visit(unnamedType);</span>
<span class="udiff-line-added">+     assignConcreteType(expression, WTFMove(unnamedType), annotation);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void Checker::assignType(AST::Expression&amp; expression, RefPtr&lt;ResolvableTypeReference&gt; resolvableTypeReference, AST::TypeAnnotation typeAnnotation = AST::RightValue())
  {
      auto addResult = m_typeMap.add(&amp;expression, makeUnique&lt;ResolvingType&gt;(WTFMove(resolvableTypeReference)));
      ASSERT_UNUSED(addResult, addResult.isNewEntry);
      expression.setTypeAnnotation(WTFMove(typeAnnotation));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1027,11 +856,11 @@</span>
  
      auto resultInfo = recurseAndGetInfo(readModifyWriteExpression.resultExpression());
      if (!resultInfo)
          return;
  
<span class="udiff-line-modified-removed">-     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType);</span>
<span class="udiff-line-modified-added">+     forwardType(readModifyWriteExpression, resultInfo-&gt;resolvingType, AST::RightValue());</span>
  }
  
  static AST::UnnamedType* getUnnamedType(ResolvingType&amp; resolvingType)
  {
      return resolvingType.visit(WTF::makeVisitor([](Ref&lt;AST::UnnamedType&gt;&amp; type) -&gt; AST::UnnamedType* {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1105,11 +934,10 @@</span>
      auto&amp; unifyNode = leftValueType-&gt;unifyNode();
      if (is&lt;AST::UnnamedType&gt;(unifyNode)) {
          auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);
          if (is&lt;AST::PointerType&gt;(unnamedType)) {
              auto&amp; pointerType = downcast&lt;AST::PointerType&gt;(unnamedType);
<span class="udiff-line-removed">-             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198163 Save the fact that we&#39;re not targetting the item; we&#39;re targetting the item&#39;s inner element.</span>
              assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), pointerType.addressSpace(), pointerType.elementType()));
              return;
          }
  
          auto leftAddressSpace = leftValueInfo-&gt;typeAnnotation.leftAddressSpace();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1133,183 +961,119 @@</span>
      }
  
      assignConcreteType(makeArrayReferenceExpression, AST::ArrayReferenceType::create(makeArrayReferenceExpression.codeLocation(), *leftAddressSpace, *leftValueType));
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;AST::UnnamedType&gt; Checker::argumentTypeForAndOverload(AST::UnnamedType&amp; baseType, AST::AddressSpace addressSpace)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     AndOverloadTypeKey key { baseType, addressSpace };</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         auto iter = m_andOverloadTypeMap.find(key);</span>
<span class="udiff-line-removed">-         if (iter != m_andOverloadTypeMap.end())</span>
<span class="udiff-line-removed">-             return iter-&gt;value;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto createArgumentType = [&amp;] () -&gt; RefPtr&lt;AST::UnnamedType&gt; {</span>
<span class="udiff-line-removed">-         auto&amp; unifyNode = baseType.unifyNode();</span>
<span class="udiff-line-removed">-         if (is&lt;AST::NamedType&gt;(unifyNode)) {</span>
<span class="udiff-line-removed">-             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);</span>
<span class="udiff-line-removed">-             return { AST::PointerType::create(namedType.codeLocation(), addressSpace, AST::TypeReference::wrap(namedType.codeLocation(), namedType)) };</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (is&lt;AST::ArrayReferenceType&gt;(unnamedType))</span>
<span class="udiff-line-removed">-             return &amp;unnamedType;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (is&lt;AST::ArrayType&gt;(unnamedType))</span>
<span class="udiff-line-removed">-             return { AST::ArrayReferenceType::create(unnamedType.codeLocation(), addressSpace, downcast&lt;AST::ArrayType&gt;(unnamedType).type()) };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (is&lt;AST::PointerType&gt;(unnamedType))</span>
<span class="udiff-line-removed">-             return nullptr;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return { AST::PointerType::create(unnamedType.codeLocation(), addressSpace, unnamedType) };</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     auto result = createArgumentType();</span>
<span class="udiff-line-removed">-     m_andOverloadTypeMap.add(key, result);</span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Checker::finishVisiting(AST::PropertyAccessExpression&amp; propertyAccessExpression, ResolvingType* additionalArgumentType)</span>
<span class="udiff-line-modified-added">+ void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
  {
<span class="udiff-line-modified-removed">-     auto baseInfo = recurseAndGetInfo(propertyAccessExpression.base());</span>
<span class="udiff-line-modified-added">+     auto baseInfo = recurseAndGetInfo(dotExpression.base());</span>
      if (!baseInfo)
          return;
<span class="udiff-line-added">+ </span>
      auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);
      if (!baseUnnamedType) {
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Cannot resolve the type of the base of a property access expression.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-added">+         setError(Error(&quot;Cannot resolve the type of the base of a dot expression.&quot;, dotExpression.codeLocation()));</span>
          return;
      }
  
<span class="udiff-line-modified-removed">-     AST::FunctionDeclaration* getterFunction = nullptr;</span>
<span class="udiff-line-modified-removed">-     RefPtr&lt;AST::UnnamedType&gt; getterReturnType = nullptr;</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; getterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="udiff-line-modified-removed">-         if (additionalArgumentType)</span>
<span class="udiff-line-modified-removed">-             getterArgumentTypes.append(*additionalArgumentType);</span>
<span class="udiff-line-modified-removed">-         auto getterName = propertyAccessExpression.getterFunctionName();</span>
<span class="udiff-line-removed">-         getterFunction = resolveFunction(getterArgumentTypes, getterName, propertyAccessExpression.codeLocation());</span>
<span class="udiff-line-removed">-         if (hasError())</span>
<span class="udiff-line-modified-added">+     auto&amp; type = baseUnnamedType-&gt;unifyNode();</span>
<span class="udiff-line-modified-added">+     if (is&lt;AST::StructureDefinition&gt;(type)) {</span>
<span class="udiff-line-modified-added">+         auto&amp; structure = downcast&lt;AST::StructureDefinition&gt;(type);</span>
<span class="udiff-line-modified-added">+         if (AST::StructureElement* element = structure.find(dotExpression.fieldName()))</span>
<span class="udiff-line-modified-added">+             assignConcreteType(dotExpression, element-&gt;type(), baseInfo-&gt;typeAnnotation);</span>
<span class="udiff-line-modified-added">+         else {</span>
<span class="udiff-line-modified-added">+             setError(Error(makeString(&quot;Field name: &#39;&quot;, dotExpression.fieldName(), &quot;&#39; does not exist on structure: &quot;, structure.name()), dotExpression.codeLocation()));</span>
              return;
<span class="udiff-line-removed">-         if (getterFunction)</span>
<span class="udiff-line-removed">-             getterReturnType = &amp;getterFunction-&gt;type();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     AST::FunctionDeclaration* anderFunction = nullptr;</span>
<span class="udiff-line-removed">-     RefPtr&lt;AST::UnnamedType&gt; anderReturnType = nullptr;</span>
<span class="udiff-line-removed">-     auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace();</span>
<span class="udiff-line-removed">-     if (leftAddressSpace) {</span>
<span class="udiff-line-removed">-         if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, *leftAddressSpace)) {</span>
<span class="udiff-line-removed">-             ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(*argumentTypeForAndOverload) };</span>
<span class="udiff-line-removed">-             Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; anderArgumentTypes { argumentType };</span>
<span class="udiff-line-removed">-             if (additionalArgumentType)</span>
<span class="udiff-line-removed">-                 anderArgumentTypes.append(*additionalArgumentType);</span>
<span class="udiff-line-removed">-             auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="udiff-line-removed">-             anderFunction = resolveFunction(anderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="udiff-line-removed">-             if (hasError())</span>
<span class="udiff-line-removed">-                 return;</span>
<span class="udiff-line-removed">-             if (anderFunction)</span>
<span class="udiff-line-removed">-                 anderReturnType = &amp;downcast&lt;AST::PointerType&gt;(anderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
          }
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     AST::FunctionDeclaration* threadAnderFunction = nullptr;</span>
<span class="udiff-line-modified-removed">-     RefPtr&lt;AST::UnnamedType&gt; threadAnderReturnType = nullptr;</span>
<span class="udiff-line-modified-removed">-     if (auto argumentTypeForAndOverload = this-&gt;argumentTypeForAndOverload(*baseUnnamedType, AST::AddressSpace::Thread)) {</span>
<span class="udiff-line-modified-removed">-         ResolvingType argumentType = { Ref&lt;AST::UnnamedType&gt;(AST::PointerType::create(propertyAccessExpression.codeLocation(), AST::AddressSpace::Thread, *baseUnnamedType)) };</span>
<span class="udiff-line-modified-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; threadAnderArgumentTypes { argumentType };</span>
<span class="udiff-line-removed">-         if (additionalArgumentType)</span>
<span class="udiff-line-removed">-             threadAnderArgumentTypes.append(*additionalArgumentType);</span>
<span class="udiff-line-removed">-         auto anderName = propertyAccessExpression.anderFunctionName();</span>
<span class="udiff-line-removed">-         threadAnderFunction = resolveFunction(threadAnderArgumentTypes, anderName, propertyAccessExpression.codeLocation());</span>
<span class="udiff-line-removed">-         if (hasError())</span>
<span class="udiff-line-modified-added">+     } else if (dotExpression.fieldName() == &quot;length&quot;) {</span>
<span class="udiff-line-modified-added">+         if (is&lt;AST::ArrayReferenceType&gt;(type)</span>
<span class="udiff-line-modified-added">+             || is&lt;AST::ArrayType&gt;(type)</span>
<span class="udiff-line-modified-added">+             || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector())) {</span>
<span class="udiff-line-modified-added">+             assignConcreteType(dotExpression, wrappedUintType(), AST::RightValue());</span>
<span class="udiff-line-modified-added">+         } else {</span>
<span class="udiff-line-modified-added">+             setError(Error(&quot;.length field is only available on arrays, array references, or vectors.&quot;, dotExpression.codeLocation()));</span>
              return;
<span class="udiff-line-modified-removed">-         if (threadAnderFunction)</span>
<span class="udiff-line-modified-removed">-             threadAnderReturnType = &amp;downcast&lt;AST::PointerType&gt;(threadAnderFunction-&gt;type()).elementType(); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198164 Enforce the return of anders will always be a pointer</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (leftAddressSpace &amp;&amp; !anderFunction &amp;&amp; !getterFunction) {</span>
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Property access instruction must either have an ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()) {</span>
<span class="udiff-line-modified-added">+         if (!m_program.isValidVectorProperty(dotExpression.fieldName())) {</span>
<span class="udiff-line-modified-added">+             setError(Error(makeString(&quot;&#39;.&quot;, dotExpression.fieldName(), &quot;&#39; is not a valid property on a vector.&quot;), dotExpression.codeLocation()));</span>
<span class="udiff-line-modified-added">+             return;</span>
<span class="udiff-line-modified-added">+         }</span>
  
<span class="udiff-line-modified-removed">-     if (!leftAddressSpace &amp;&amp; !threadAnderFunction &amp;&amp; !getterFunction) {</span>
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Property access instruction must either have a thread ander or a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         auto typeAnnotation = baseInfo-&gt;typeAnnotation.isRightValue() ? AST::TypeAnnotation { AST::RightValue() } : AST::TypeAnnotation { AST::AbstractLeftValue() };</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         size_t fieldLength = dotExpression.fieldName().length();</span>
<span class="udiff-line-modified-added">+         auto&amp; innerType = downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorTypeArgument();</span>
<span class="udiff-line-added">+         if (fieldLength == 1)</span>
<span class="udiff-line-added">+             assignConcreteType(dotExpression, innerType, typeAnnotation);</span>
<span class="udiff-line-added">+         else {</span>
<span class="udiff-line-added">+             if (matches(innerType, m_intrinsics.boolType()))</span>
<span class="udiff-line-added">+                 assignConcreteType(dotExpression, m_intrinsics.boolVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="udiff-line-added">+             else if (matches(innerType, m_intrinsics.intType()))</span>
<span class="udiff-line-added">+                 assignConcreteType(dotExpression, m_intrinsics.intVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="udiff-line-added">+             else if (matches(innerType, m_intrinsics.uintType()))</span>
<span class="udiff-line-added">+                 assignConcreteType(dotExpression, m_intrinsics.uintVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="udiff-line-added">+             else if (matches(innerType, m_intrinsics.floatType()))</span>
<span class="udiff-line-added">+                 assignConcreteType(dotExpression, m_intrinsics.floatVectorTypeForSize(fieldLength), typeAnnotation);</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     } else</span>
<span class="udiff-line-added">+         setError(Error(&quot;Base value of dot expression must be a structure, array, or vector.&quot;, dotExpression.codeLocation()));</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (threadAnderFunction &amp;&amp; getterFunction) {</span>
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Cannot have both a thread ander and a getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+         auto indexInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="udiff-line-added">+         if (!indexInfo)</span>
<span class="udiff-line-added">+             return;</span>
  
<span class="udiff-line-modified-removed">-     if (anderFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*anderReturnType, *threadAnderReturnType)) {</span>
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Return type of ander must match the return type of the thread ander.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+         if (!matchAndCommit(indexInfo-&gt;resolvingType, m_intrinsics.uintType())) {</span>
<span class="udiff-line-modified-added">+             setError(Error(&quot;Index in an index expression must be a uint.&quot;, indexExpression.codeLocation()));</span>
<span class="udiff-line-modified-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
      }
  
<span class="udiff-line-modified-removed">-     if (getterFunction &amp;&amp; anderFunction &amp;&amp; !matches(*getterReturnType, *anderReturnType)) {</span>
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Return type of ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-added">+     auto baseInfo = recurseAndGetInfo(indexExpression.base());</span>
<span class="udiff-line-modified-added">+     if (!baseInfo)</span>
          return;
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-     if (getterFunction &amp;&amp; threadAnderFunction &amp;&amp; !matches(*getterReturnType, *threadAnderReturnType)) {</span>
<span class="udiff-line-modified-removed">-         setError(Error(&quot;Return type of the thread ander must match the return type of the getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-added">+     auto baseUnnamedType = commit(baseInfo-&gt;resolvingType);</span>
<span class="udiff-line-modified-added">+     if (!baseUnnamedType) {</span>
<span class="udiff-line-added">+         setError(Error(&quot;Cannot resolve the type of the base of an index expression.&quot;, indexExpression.codeLocation()));</span>
          return;
      }
  
<span class="udiff-line-modified-removed">-     Ref&lt;AST::UnnamedType&gt; fieldType = getterReturnType ? *getterReturnType : anderReturnType ? *anderReturnType : *threadAnderReturnType;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     AST::FunctionDeclaration* setterFunction = nullptr;</span>
<span class="udiff-line-modified-removed">-     AST::UnnamedType* setterReturnType = nullptr;</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-         ResolvingType fieldResolvingType(fieldType.copyRef());</span>
<span class="udiff-line-modified-removed">-         Vector&lt;std::reference_wrapper&lt;ResolvingType&gt;&gt; setterArgumentTypes { baseInfo-&gt;resolvingType };</span>
<span class="udiff-line-modified-removed">-         if (additionalArgumentType)</span>
<span class="udiff-line-modified-removed">-             setterArgumentTypes.append(*additionalArgumentType);</span>
<span class="udiff-line-modified-removed">-         setterArgumentTypes.append(fieldResolvingType);</span>
<span class="udiff-line-modified-removed">-         auto setterName = propertyAccessExpression.setterFunctionName();</span>
<span class="udiff-line-modified-removed">-         setterFunction = resolveFunction(setterArgumentTypes, setterName, propertyAccessExpression.codeLocation());</span>
<span class="udiff-line-modified-removed">-         if (hasError())</span>
<span class="udiff-line-modified-added">+     auto&amp; type = baseUnnamedType-&gt;unifyNode();</span>
<span class="udiff-line-modified-added">+     if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="udiff-line-modified-added">+         auto&amp; arrayReferenceType = downcast&lt;AST::ArrayReferenceType&gt;(type);</span>
<span class="udiff-line-modified-added">+         assignConcreteType(indexExpression, arrayReferenceType.elementType(), AST::LeftValue { arrayReferenceType.addressSpace() });</span>
<span class="udiff-line-modified-added">+     } else if (is&lt;AST::ArrayType&gt;(type))</span>
<span class="udiff-line-modified-added">+         assignConcreteType(indexExpression, downcast&lt;AST::ArrayType&gt;(type).type(), baseInfo-&gt;typeAnnotation);</span>
<span class="udiff-line-modified-added">+     else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {</span>
<span class="udiff-line-modified-added">+         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);</span>
<span class="udiff-line-modified-added">+         auto typeAnnotation = baseInfo-&gt;typeAnnotation.isRightValue() ? AST::TypeAnnotation { AST::RightValue() } : AST::TypeAnnotation { AST::AbstractLeftValue() };</span>
<span class="udiff-line-modified-added">+         if (nativeType.isVector())</span>
<span class="udiff-line-modified-added">+             assignConcreteType(indexExpression, nativeType.vectorTypeArgument(), typeAnnotation);</span>
<span class="udiff-line-modified-added">+         else if (nativeType.isMatrix()) {</span>
<span class="udiff-line-modified-added">+             auto&amp; innerType = nativeType.matrixTypeArgument();</span>
<span class="udiff-line-added">+             unsigned numRows = nativeType.numberOfMatrixRows();</span>
<span class="udiff-line-added">+             if (matches(innerType, m_intrinsics.boolType()))</span>
<span class="udiff-line-added">+                 assignConcreteType(indexExpression, m_intrinsics.boolVectorTypeForSize(numRows), typeAnnotation);</span>
<span class="udiff-line-added">+             else if (matches(innerType, m_intrinsics.floatType()))</span>
<span class="udiff-line-added">+                 assignConcreteType(indexExpression, m_intrinsics.floatVectorTypeForSize(numRows), typeAnnotation);</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             setError(Error(&quot;Index expression on unknown type.&quot;, indexExpression.codeLocation()));</span>
              return;
<span class="udiff-line-modified-removed">-         if (setterFunction)</span>
<span class="udiff-line-modified-removed">-             setterReturnType = &amp;setterFunction-&gt;type();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (setterFunction &amp;&amp; !getterFunction) {</span>
<span class="udiff-line-removed">-         setError(Error(&quot;Cannot define a setter function without a corresponding getter.&quot;, propertyAccessExpression.codeLocation()));</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     } else {</span>
<span class="udiff-line-modified-added">+         setError(Error(&quot;Index expression on an unknown base type. Base type must be an array, array reference, vector, or matrix.&quot;, indexExpression.codeLocation()));</span>
          return;
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     propertyAccessExpression.setGetterFunction(getterFunction);</span>
<span class="udiff-line-removed">-     propertyAccessExpression.setAnderFunction(anderFunction);</span>
<span class="udiff-line-removed">-     propertyAccessExpression.setThreadAnderFunction(threadAnderFunction);</span>
<span class="udiff-line-removed">-     propertyAccessExpression.setSetterFunction(setterFunction);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     AST::TypeAnnotation typeAnnotation = AST::RightValue();</span>
<span class="udiff-line-removed">-     if (auto leftAddressSpace = baseInfo-&gt;typeAnnotation.leftAddressSpace()) {</span>
<span class="udiff-line-removed">-         if (anderFunction)</span>
<span class="udiff-line-removed">-             typeAnnotation = AST::LeftValue { downcast&lt;AST::ReferenceType&gt;(anderFunction-&gt;type()).addressSpace() };</span>
<span class="udiff-line-removed">-         else if (setterFunction)</span>
<span class="udiff-line-removed">-             typeAnnotation = AST::AbstractLeftValue();</span>
<span class="udiff-line-removed">-     } else if (!baseInfo-&gt;typeAnnotation.isRightValue() &amp;&amp; (setterFunction || threadAnderFunction))</span>
<span class="udiff-line-removed">-         typeAnnotation = AST::AbstractLeftValue();</span>
<span class="udiff-line-removed">-     assignConcreteType(propertyAccessExpression, WTFMove(fieldType), WTFMove(typeAnnotation));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Checker::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     finishVisiting(dotExpression);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Checker::visit(AST::IndexExpression&amp; indexExpression)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     auto baseInfo = recurseAndGetInfo(indexExpression.indexExpression());</span>
<span class="udiff-line-removed">-     if (!baseInfo)</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-     finishVisiting(indexExpression, &amp;baseInfo-&gt;resolvingType);</span>
  }
  
  void Checker::visit(AST::VariableReference&amp; variableReference)
  {
      ASSERT(variableReference.variable());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1360,15 +1124,10 @@</span>
  void Checker::visit(AST::FloatLiteral&amp; floatLiteral)
  {
      assignType(floatLiteral, adoptRef(*new ResolvableTypeReference(floatLiteral.type())));
  }
  
<span class="udiff-line-removed">- void Checker::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     assignType(nullLiteral, adoptRef(*new ResolvableTypeReference(nullLiteral.type())));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void Checker::visit(AST::BooleanLiteral&amp; booleanLiteral)
  {
      assignConcreteType(booleanLiteral, AST::TypeReference::wrap(booleanLiteral.codeLocation(), m_intrinsics.boolType()));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1486,12 +1245,10 @@</span>
              return static_cast&lt;bool&gt;(matchAndCommit(*valueType, integerLiteral.type()));
          }, [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) -&gt; bool {
              return static_cast&lt;bool&gt;(matchAndCommit(*valueType, unsignedIntegerLiteral.type()));
          }, [&amp;](AST::FloatLiteral&amp; floatLiteral) -&gt; bool {
              return static_cast&lt;bool&gt;(matchAndCommit(*valueType, floatLiteral.type()));
<span class="udiff-line-removed">-         }, [&amp;](AST::NullLiteral&amp; nullLiteral) -&gt; bool {</span>
<span class="udiff-line-removed">-             return static_cast&lt;bool&gt;(matchAndCommit(*valueType, nullLiteral.type()));</span>
          }, [&amp;](AST::BooleanLiteral&amp;) -&gt; bool {
              return matches(*valueType, m_intrinsics.boolType());
          }, [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) -&gt; bool {
              ASSERT(enumerationMemberLiteral.enumerationDefinition());
              return matches(*valueType, *enumerationMemberLiteral.enumerationDefinition());
</pre>
<center><a href="WHLSLCheckTextureReferences.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLHighZombieFinder.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
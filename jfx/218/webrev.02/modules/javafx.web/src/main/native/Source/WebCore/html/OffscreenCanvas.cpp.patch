diff a/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp
@@ -24,123 +24,313 @@
  */
 
 #include "config.h"
 #include "OffscreenCanvas.h"
 
+#if ENABLE(OFFSCREEN_CANVAS)
+
+#include "CSSValuePool.h"
 #include "CanvasRenderingContext.h"
 #include "ImageBitmap.h"
+#include "JSBlob.h"
+#include "JSDOMPromiseDeferred.h"
+#include "MIMETypeRegistry.h"
+#include "OffscreenCanvasRenderingContext2D.h"
 #include "WebGLRenderingContext.h"
+#include "WorkerGlobalScope.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
 
+DetachedOffscreenCanvas::DetachedOffscreenCanvas(std::unique_ptr<ImageBuffer>&& buffer, const IntSize& size, bool originClean)
+    : m_buffer(WTFMove(buffer))
+    , m_size(size)
+    , m_originClean(originClean)
+{
+}
+
+std::unique_ptr<ImageBuffer> DetachedOffscreenCanvas::takeImageBuffer()
+{
+    return WTFMove(m_buffer);
+}
+
 Ref<OffscreenCanvas> OffscreenCanvas::create(ScriptExecutionContext& context, unsigned width, unsigned height)
 {
     return adoptRef(*new OffscreenCanvas(context, width, height));
 }
 
+Ref<OffscreenCanvas> OffscreenCanvas::create(ScriptExecutionContext& context, std::unique_ptr<DetachedOffscreenCanvas>&& detachedCanvas)
+{
+    Ref<OffscreenCanvas> clone = adoptRef(*new OffscreenCanvas(context, detachedCanvas->size().width(), detachedCanvas->size().height()));
+    clone->setImageBuffer(detachedCanvas->takeImageBuffer());
+    if (!detachedCanvas->originClean())
+        clone->setOriginTainted();
+
+    return clone;
+}
+
 OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext& context, unsigned width, unsigned height)
-    : ContextDestructionObserver(&context)
-    , m_size(width, height)
+    : CanvasBase(IntSize(width, height))
+    , ContextDestructionObserver(&context)
 {
 }
 
 OffscreenCanvas::~OffscreenCanvas()
 {
     notifyObserversCanvasDestroyed();
 
-    m_context = nullptr;
+    m_context = nullptr; // Ensure this goes away before the ImageBuffer.
+    setImageBuffer(nullptr);
 }
 
 unsigned OffscreenCanvas::width() const
 {
-    return m_size.width();
-}
-
-void OffscreenCanvas::setWidth(unsigned newWidth)
-{
-    return m_size.setWidth(newWidth);
+    if (m_detached)
+        return 0;
+    return CanvasBase::width();
 }
 
 unsigned OffscreenCanvas::height() const
 {
-    return m_size.height();
+    if (m_detached)
+        return 0;
+    return CanvasBase::height();
 }
 
-void OffscreenCanvas::setHeight(unsigned newHeight)
+void OffscreenCanvas::setWidth(unsigned newWidth)
 {
-    return m_size.setHeight(newHeight);
+    if (m_detached)
+        return;
+    setSize(IntSize(newWidth, height()));
 }
 
-const IntSize& OffscreenCanvas::size() const
+void OffscreenCanvas::setHeight(unsigned newHeight)
 {
-    return m_size;
+    if (m_detached)
+        return;
+    setSize(IntSize(width(), newHeight));
 }
 
 void OffscreenCanvas::setSize(const IntSize& newSize)
 {
-    m_size = newSize;
+    CanvasBase::setSize(newSize);
+    reset();
 }
 
-#if ENABLE(WEBGL)
-ExceptionOr<OffscreenRenderingContext> OffscreenCanvas::getContext(JSC::ExecState& state, RenderingContextType contextType, Vector<JSC::Strong<JSC::Unknown>>&& arguments)
+ExceptionOr<OffscreenRenderingContext> OffscreenCanvas::getContext(JSC::JSGlobalObject& state, RenderingContextType contextType, Vector<JSC::Strong<JSC::Unknown>>&& arguments)
 {
-    if (m_context && contextType == RenderingContextType::Webgl)
-        return { RefPtr<WebGLRenderingContext> { &downcast<WebGLRenderingContext>(*m_context) } };
+    if (m_detached)
+        return Exception { InvalidStateError };
+
+    if (contextType == RenderingContextType::_2d) {
+        if (m_context) {
+            if (!is<OffscreenCanvasRenderingContext2D>(*m_context))
+                return Exception { InvalidStateError };
+            return { RefPtr<OffscreenCanvasRenderingContext2D> { &downcast<OffscreenCanvasRenderingContext2D>(*m_context) } };
+        }
+
+        m_context = makeUnique<OffscreenCanvasRenderingContext2D>(*this);
+        if (!m_context)
+            return { RefPtr<OffscreenCanvasRenderingContext2D> { nullptr } };
 
+        return { RefPtr<OffscreenCanvasRenderingContext2D> { &downcast<OffscreenCanvasRenderingContext2D>(*m_context) } };
+    }
+#if ENABLE(WEBGL)
     if (contextType == RenderingContextType::Webgl) {
+        if (m_context) {
+            if (!is<WebGLRenderingContext>(*m_context))
+                return Exception { InvalidStateError };
+            return { RefPtr<WebGLRenderingContext> { &downcast<WebGLRenderingContext>(*m_context) } };
+        }
+
         auto scope = DECLARE_THROW_SCOPE(state.vm());
         auto attributes = convert<IDLDictionary<WebGLContextAttributes>>(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 
         m_context = WebGLRenderingContextBase::create(*this, attributes, "webgl");
         if (!m_context)
-            return { nullptr };
+            return { RefPtr<WebGLRenderingContext> { nullptr } };
 
         return { RefPtr<WebGLRenderingContext> { &downcast<WebGLRenderingContext>(*m_context) } };
     }
+#endif
 
-    return { nullptr };
+    return Exception { NotSupportedError };
 }
-#endif
 
-RefPtr<ImageBitmap> OffscreenCanvas::transferToImageBitmap()
+ExceptionOr<RefPtr<ImageBitmap>> OffscreenCanvas::transferToImageBitmap()
 {
-    if (!m_context)
-        return nullptr;
+    if (m_detached || !m_context)
+        return Exception { InvalidStateError };
+
+    if (is<OffscreenCanvasRenderingContext2D>(*m_context)) {
+        if (!width() || !height())
+            return { RefPtr<ImageBitmap> { nullptr } };
+
+        if (!m_hasCreatedImageBuffer)
+            return { ImageBitmap::create({ ImageBuffer::create(size(), RenderingMode::Unaccelerated), true }) };
+
+        auto buffer = takeImageBuffer();
+        if (!buffer)
+            return { RefPtr<ImageBitmap> { nullptr } };
+
+        return { ImageBitmap::create({ WTFMove(buffer), originClean() }) };
+    }
 
 #if ENABLE(WEBGL)
-    if (!is<WebGLRenderingContext>(*m_context))
+    if (is<WebGLRenderingContext>(*m_context)) {
+        auto webGLContext = &downcast<WebGLRenderingContext>(*m_context);
+
+        // FIXME: We're supposed to create an ImageBitmap using the backing
+        // store from this canvas (or its context), but for now we'll just
+        // create a new bitmap and paint into it.
+
+        auto imageBitmap = ImageBitmap::create(size());
+        if (!imageBitmap->buffer())
+            return { RefPtr<ImageBitmap> { nullptr } };
+
+        auto* gc3d = webGLContext->graphicsContextGL();
+        gc3d->paintRenderingResultsToCanvas(imageBitmap->buffer());
+
+        // FIXME: The transfer algorithm requires that the canvas effectively
+        // creates a new backing store. Since we're not doing that yet, we
+        // need to erase what's there.
+
+        GCGLfloat clearColor[4];
+        gc3d->getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, clearColor);
+        gc3d->clearColor(0, 0, 0, 0);
+        gc3d->clear(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT);
+        gc3d->clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
+
+        return { WTFMove(imageBitmap) };
+    }
+#endif
+
+    return Exception { NotSupportedError };
+}
+
+static String toEncodingMimeType(const String& mimeType)
+{
+    if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))
+        return "image/png"_s;
+    return mimeType.convertToASCIILowercase();
+}
+
+static Optional<double> qualityFromDouble(double qualityNumber)
+{
+    if (!(qualityNumber >= 0 && qualityNumber <= 1))
+        return WTF::nullopt;
+
+    return qualityNumber;
+}
+
+void OffscreenCanvas::convertToBlob(ImageEncodeOptions&& options, Ref<DeferredPromise>&& promise)
+{
+    if (!originClean()) {
+        promise->reject(SecurityError);
+        return;
+    }
+    if (size().isEmpty()) {
+        promise->reject(IndexSizeError);
+        return;
+    }
+    if (m_detached || !buffer()) {
+        promise->reject(InvalidStateError);
+        return;
+    }
+
+    makeRenderingResultsAvailable();
+
+    auto encodingMIMEType = toEncodingMimeType(options.type);
+    auto quality = qualityFromDouble(options.quality);
+
+    Vector<uint8_t> blobData = buffer()->toData(encodingMIMEType, quality);
+    if (blobData.isEmpty()) {
+        promise->reject(EncodingError);
+        return;
+    }
+
+    Ref<Blob> blob = Blob::create(WTFMove(blobData), encodingMIMEType);
+    promise->resolveWithNewlyCreated<IDLInterface<Blob>>(WTFMove(blob));
+}
+
+void OffscreenCanvas::didDraw(const FloatRect& rect)
+{
+    notifyObserversCanvasChanged(rect);
+}
+
+SecurityOrigin* OffscreenCanvas::securityOrigin() const
+{
+    auto& context = *canvasBaseScriptExecutionContext();
+    if (is<WorkerGlobalScope>(context))
+        return &downcast<WorkerGlobalScope>(context).topOrigin();
+
+    return &downcast<Document>(context).securityOrigin();
+}
+
+bool OffscreenCanvas::canDetach() const
+{
+    return !m_detached && !m_context;
+}
+
+std::unique_ptr<DetachedOffscreenCanvas> OffscreenCanvas::detach()
+{
+    if (!canDetach())
         return nullptr;
 
-    auto webGLContext = &downcast<WebGLRenderingContext>(*m_context);
+    m_detached = true;
+
+    return makeUnique<DetachedOffscreenCanvas>(takeImageBuffer(), size(), originClean());
+}
+
+CSSValuePool& OffscreenCanvas::cssValuePool()
+{
+    auto* context = canvasBaseScriptExecutionContext();
+    if (context->isWorkerGlobalScope())
+        return downcast<WorkerGlobalScope>(*context).cssValuePool();
+
+    ASSERT(context->isDocument());
+    return CSSValuePool::singleton();
+}
+
+void OffscreenCanvas::createImageBuffer() const
+{
+    m_hasCreatedImageBuffer = true;
+
+    if (!width() || !height())
+        return;
 
-    // FIXME: We're supposed to create an ImageBitmap using the backing
-    // store from this canvas (or its context), but for now we'll just
-    // create a new bitmap and paint into it.
+    setImageBuffer(ImageBuffer::create(size(), RenderingMode::Unaccelerated));
+}
+
+std::unique_ptr<ImageBuffer> OffscreenCanvas::takeImageBuffer() const
+{
+    if (!m_detached)
+        m_hasCreatedImageBuffer = true;
 
-    auto imageBitmap = ImageBitmap::create(m_size);
-    if (!imageBitmap->buffer())
+    // This function is primarily for use with transferToImageBitmap, which
+    // requires that the canvas bitmap refer to a new, blank bitmap of the same
+    // size after the existing bitmap is taken. In the case of a zero-size
+    // bitmap, our buffer is null, so returning early here is valid.
+    if (size().isEmpty())
         return nullptr;
 
-    auto* gc3d = webGLContext->graphicsContext3D();
-    gc3d->paintRenderingResultsToCanvas(imageBitmap->buffer());
+    return setImageBuffer(m_detached ? nullptr : ImageBuffer::create(size(), RenderingMode::Unaccelerated));
+}
 
-    // FIXME: The transfer algorithm requires that the canvas effectively
-    // creates a new backing store. Since we're not doing that yet, we
-    // need to erase what's there.
+void OffscreenCanvas::reset()
+{
+    resetGraphicsContextState();
+    if (is<OffscreenCanvasRenderingContext2D>(m_context.get()))
+        downcast<OffscreenCanvasRenderingContext2D>(*m_context).reset();
 
-    GC3Dfloat clearColor[4];
-    gc3d->getFloatv(GraphicsContext3D::COLOR_CLEAR_VALUE, clearColor);
-    gc3d->clearColor(0, 0, 0, 0);
-    gc3d->clear(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT);
-    gc3d->clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
+    m_hasCreatedImageBuffer = false;
+    setImageBuffer(nullptr);
 
-    return imageBitmap;
-#else
-    return nullptr;
-#endif
+    notifyObserversCanvasResized();
 }
 
 }
+
+#endif

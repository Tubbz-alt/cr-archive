<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/async-clipboard/ClipboardItemBindingsDataSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ClipboardItemBindingsDataSource.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;Blob.h&quot;
 31 #include &quot;Clipboard.h&quot;
 32 #include &quot;ClipboardItem.h&quot;
 33 #include &quot;Document.h&quot;
 34 #include &quot;FileReaderLoader.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;GraphicsContext.h&quot;
 37 #include &quot;ImageBuffer.h&quot;
 38 #include &quot;JSBlob.h&quot;
 39 #include &quot;JSDOMPromise.h&quot;
 40 #include &quot;JSDOMPromiseDeferred.h&quot;
 41 #include &quot;PasteboardCustomData.h&quot;
 42 #include &quot;SharedBuffer.h&quot;
 43 #include &quot;markup.h&quot;
 44 #include &lt;wtf/Function.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 static RefPtr&lt;Document&gt; documentFromClipboard(const Clipboard* clipboard)
 49 {
 50     if (!clipboard)
 51         return nullptr;
 52 
 53     auto* frame = clipboard-&gt;frame();
 54     if (!frame)
 55         return nullptr;
 56 
 57     return frame-&gt;document();
 58 }
 59 
 60 static FileReaderLoader::ReadType readTypeForMIMEType(const String&amp; type)
 61 {
 62     if (type == &quot;text/uri-list&quot;_s || type == &quot;text/plain&quot;_s || type == &quot;text/html&quot;_s)
 63         return FileReaderLoader::ReadAsText;
 64     return FileReaderLoader::ReadAsArrayBuffer;
 65 }
 66 
 67 ClipboardItemBindingsDataSource::ClipboardItemBindingsDataSource(ClipboardItem&amp; item, Vector&lt;KeyValuePair&lt;String, RefPtr&lt;DOMPromise&gt;&gt;&gt;&amp;&amp; itemPromises)
 68     : ClipboardItemDataSource(item)
 69     , m_itemPromises(WTFMove(itemPromises))
 70 {
 71 }
 72 
 73 ClipboardItemBindingsDataSource::~ClipboardItemBindingsDataSource() = default;
 74 
 75 Vector&lt;String&gt; ClipboardItemBindingsDataSource::types() const
 76 {
 77     return m_itemPromises.map([&amp;] (auto&amp; typeAndItem) {
 78         return typeAndItem.key;
 79     });
 80 }
 81 
 82 void ClipboardItemBindingsDataSource::getType(const String&amp; type, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
 83 {
 84     auto matchIndex = m_itemPromises.findMatching([&amp;] (auto&amp; item) {
 85         return type == item.key;
 86     });
 87 
 88     if (matchIndex == notFound) {
 89         promise-&gt;reject(NotFoundError);
 90         return;
 91     }
 92 
 93     auto itemPromise = m_itemPromises[matchIndex].value;
 94     itemPromise-&gt;whenSettled([itemPromise, promise = makeRefPtr(promise.get()), type] () mutable {
 95         if (itemPromise-&gt;status() != DOMPromise::Status::Fulfilled) {
 96             promise-&gt;reject(AbortError);
 97             return;
 98         }
 99 
100         auto result = itemPromise-&gt;result();
101         if (!result) {
102             promise-&gt;reject(TypeError);
103             return;
104         }
105 
106         String string;
107         result.getString(itemPromise-&gt;globalObject(), string);
108         if (!string.isNull()) {
109             promise-&gt;resolve&lt;IDLInterface&lt;Blob&gt;&gt;(ClipboardItem::blobFromString(string, type));
110             return;
111         }
112 
113         if (!result.isObject()) {
114             promise-&gt;reject(TypeError);
115             return;
116         }
117 
118         if (auto blob = JSBlob::toWrapped(result.getObject()-&gt;vm(), result.getObject()))
119             promise-&gt;resolve&lt;IDLInterface&lt;Blob&gt;&gt;(*blob);
120         else
121             promise-&gt;reject(TypeError);
122     });
123 }
124 
125 void ClipboardItemBindingsDataSource::collectDataForWriting(Clipboard&amp; destination, CompletionHandler&lt;void(Optional&lt;PasteboardCustomData&gt;)&gt;&amp;&amp; completion)
126 {
127     m_itemTypeLoaders.clear();
128     ASSERT(!m_completionHandler);
129     m_completionHandler = WTFMove(completion);
130     m_writingDestination = makeWeakPtr(destination);
131     m_numberOfPendingClipboardTypes = m_itemPromises.size();
132     m_itemTypeLoaders = m_itemPromises.map([&amp;] (auto&amp; typeAndItem) {
133         auto type = typeAndItem.key;
134         auto itemTypeLoader = ClipboardItemTypeLoader::create(type, [this, protectedItem = makeRef(m_item)] {
135             ASSERT(m_numberOfPendingClipboardTypes);
136             if (!--m_numberOfPendingClipboardTypes)
137                 invokeCompletionHandler();
138         });
139 
140         auto promise = typeAndItem.value;
141         promise-&gt;whenSettled([this, protectedItem = makeRefPtr(m_item), destination = m_writingDestination, promise, type, weakItemTypeLoader = makeWeakPtr(itemTypeLoader.ptr())] () mutable {
142             if (!weakItemTypeLoader)
143                 return;
144 
145             auto itemTypeLoader = makeRef(*weakItemTypeLoader);
146             ASSERT_UNUSED(this, notFound != m_itemTypeLoaders.findMatching([&amp;] (auto&amp; loader) { return loader.ptr() == itemTypeLoader.ptr(); }));
147 
148             auto result = promise-&gt;result();
149             if (!result) {
150                 itemTypeLoader-&gt;didFailToResolve();
151                 return;
152             }
153 
154             auto clipboard = makeRefPtr(destination.get());
155             if (!clipboard) {
156                 itemTypeLoader-&gt;didFailToResolve();
157                 return;
158             }
159 
160             if (!clipboard-&gt;scriptExecutionContext()) {
161                 itemTypeLoader-&gt;didFailToResolve();
162                 return;
163             }
164 
165             String text;
166             result.getString(promise-&gt;globalObject(), text);
167             if (!text.isNull()) {
168                 itemTypeLoader-&gt;didResolveToString(text);
169                 return;
170             }
171 
172             if (!result.isObject()) {
173                 itemTypeLoader-&gt;didFailToResolve();
174                 return;
175             }
176 
177             if (auto blob = makeRefPtr(JSBlob::toWrapped(result.getObject()-&gt;vm(), result.getObject())))
178                 itemTypeLoader-&gt;didResolveToBlob(*clipboard-&gt;scriptExecutionContext(), blob.releaseNonNull());
179             else
180                 itemTypeLoader-&gt;didFailToResolve();
181         });
182 
183         return itemTypeLoader;
184     });
185 
186     if (!m_numberOfPendingClipboardTypes)
187         invokeCompletionHandler();
188 }
189 
190 void ClipboardItemBindingsDataSource::invokeCompletionHandler()
191 {
192     if (!m_completionHandler) {
193         ASSERT_NOT_REACHED();
194         return;
195     }
196 
197     auto completionHandler = std::exchange(m_completionHandler, { });
198     auto itemTypeLoaders = std::exchange(m_itemTypeLoaders, { });
199     auto clipboard = makeRefPtr(m_writingDestination.get());
200     m_writingDestination = nullptr;
201 
202     auto document = documentFromClipboard(clipboard.get());
203     if (!document) {
204         completionHandler(WTF::nullopt);
205         return;
206     }
207 
208     PasteboardCustomData customData;
209     for (auto&amp; itemTypeLoader : itemTypeLoaders) {
210         auto type = itemTypeLoader-&gt;type();
211         auto&amp; data = itemTypeLoader-&gt;data();
212         if (WTF::holds_alternative&lt;String&gt;(data) &amp;&amp; !!WTF::get&lt;String&gt;(data))
213             customData.writeString(type, WTF::get&lt;String&gt;(data));
214         else if (WTF::holds_alternative&lt;Ref&lt;SharedBuffer&gt;&gt;(data))
215             customData.writeData(type, WTF::get&lt;Ref&lt;SharedBuffer&gt;&gt;(data).copyRef());
216         else {
217             completionHandler(WTF::nullopt);
218             return;
219         }
220     }
221 
222     customData.setOrigin(document-&gt;originIdentifierForPasteboard());
223     completionHandler(WTFMove(customData));
224 }
225 
226 ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::ClipboardItemTypeLoader(const String&amp; type, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
227     : m_type(type)
228     , m_completionHandler(WTFMove(completionHandler))
229 {
230 }
231 
232 ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::~ClipboardItemTypeLoader()
233 {
234     if (m_blobLoader)
235         m_blobLoader-&gt;cancel();
236 
237     invokeCompletionHandler();
238 }
239 
240 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::didFinishLoading()
241 {
242     ASSERT(m_blobLoader);
243     auto stringResult = readTypeForMIMEType(m_type) == FileReaderLoader::ReadAsText ? m_blobLoader-&gt;stringResult() : nullString();
244     if (!stringResult.isNull())
245         m_data = { stringResult };
246     else if (auto arrayBuffer = m_blobLoader-&gt;arrayBufferResult())
247         m_data = { SharedBuffer::create(static_cast&lt;const char*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength()) };
248     m_blobLoader = nullptr;
249     invokeCompletionHandler();
250 }
251 
252 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::didFail(int)
253 {
254     ASSERT(m_blobLoader);
255     m_blobLoader = nullptr;
256     invokeCompletionHandler();
257 }
258 
259 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::sanitizeDataIfNeeded()
260 {
261     if (m_type == &quot;text/html&quot;_s) {
262         String markupToSanitize;
263         if (WTF::holds_alternative&lt;Ref&lt;SharedBuffer&gt;&gt;(m_data)) {
264             auto&amp; buffer = WTF::get&lt;Ref&lt;SharedBuffer&gt;&gt;(m_data);
265             markupToSanitize = String::fromUTF8(buffer-&gt;data(), buffer-&gt;size());
266         } else if (WTF::holds_alternative&lt;String&gt;(m_data))
267             markupToSanitize = WTF::get&lt;String&gt;(m_data);
268 
269         if (markupToSanitize.isEmpty())
270             return;
271 
272         m_data = { sanitizeMarkup(markupToSanitize) };
273     }
274 
275     if (m_type == &quot;image/png&quot;_s) {
276         RefPtr&lt;SharedBuffer&gt; bufferToSanitize;
277         if (WTF::holds_alternative&lt;Ref&lt;SharedBuffer&gt;&gt;(m_data))
278             bufferToSanitize = WTF::get&lt;Ref&lt;SharedBuffer&gt;&gt;(m_data).ptr();
279         else if (WTF::holds_alternative&lt;String&gt;(m_data))
280             bufferToSanitize = utf8Buffer(WTF::get&lt;String&gt;(m_data));
281 
282         if (!bufferToSanitize || bufferToSanitize-&gt;isEmpty())
283             return;
284 
285         auto bitmapImage = BitmapImage::create();
286         bitmapImage-&gt;setData(WTFMove(bufferToSanitize), true);
287         auto imageBuffer = ImageBuffer::create(bitmapImage-&gt;size(), RenderingMode::Unaccelerated);
288         if (!imageBuffer) {
289             m_data = { nullString() };
290             return;
291         }
292 
293         imageBuffer-&gt;context().drawImage(bitmapImage.get(), FloatPoint::zero());
294         m_data = { SharedBuffer::create(imageBuffer-&gt;toData(&quot;image/png&quot;_s)) };
295     }
296 }
297 
298 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::invokeCompletionHandler()
299 {
300     if (auto completion = WTFMove(m_completionHandler)) {
301         sanitizeDataIfNeeded();
302         completion();
303     }
304 }
305 
306 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::didResolveToBlob(ScriptExecutionContext&amp; context, Ref&lt;Blob&gt;&amp;&amp; blob)
307 {
308     ASSERT(!m_blobLoader);
309     m_blobLoader = makeUnique&lt;FileReaderLoader&gt;(readTypeForMIMEType(m_type), this);
310     m_blobLoader-&gt;start(&amp;context, WTFMove(blob));
311 }
312 
313 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::didFailToResolve()
314 {
315     ASSERT(!m_blobLoader);
316     invokeCompletionHandler();
317 }
318 
319 void ClipboardItemBindingsDataSource::ClipboardItemTypeLoader::didResolveToString(const String&amp; text)
320 {
321     ASSERT(!m_blobLoader);
322     m_data = { text };
323     invokeCompletionHandler();
324 }
325 
326 } // namespace WebCore
    </pre>
  </body>
</html>
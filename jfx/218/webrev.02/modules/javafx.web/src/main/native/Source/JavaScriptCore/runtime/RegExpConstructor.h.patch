diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpConstructor.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpConstructor.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpConstructor.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpConstructor.h
@@ -1,8 +1,8 @@
 /*
  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
- *  Copyright (C) 2003-2018 Apple Inc. All Rights Reserved.
+ *  Copyright (C) 2003-2019 Apple Inc. All Rights Reserved.
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
  *  License as published by the Free Software Foundation; either
  *  version 2 of the License, or (at your option) any later version.
@@ -31,11 +31,11 @@
 class GetterSetter;
 
 class RegExpConstructor final : public InternalFunction {
 public:
     typedef InternalFunction Base;
-    static const unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable;
 
     static RegExpConstructor* create(VM& vm, Structure* structure, RegExpPrototype* regExpPrototype, GetterSetter* species)
     {
         RegExpConstructor* constructor = new (NotNull, allocateCell<RegExpConstructor>(vm.heap)) RegExpConstructor(vm, structure);
         constructor->finishCreation(vm, regExpPrototype, species);
@@ -53,28 +53,28 @@
     void finishCreation(VM&, RegExpPrototype*, GetterSetter* species);
 
 private:
     RegExpConstructor(VM&, Structure*);
 };
+STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(RegExpConstructor, InternalFunction);
 
-static_assert(sizeof(RegExpConstructor) == sizeof(InternalFunction), "");
+JSObject* constructRegExp(JSGlobalObject*, const ArgList&, JSObject* callee = nullptr, JSValue newTarget = jsUndefined());
 
-JSObject* constructRegExp(ExecState*, JSGlobalObject*, const ArgList&, JSObject* callee = nullptr, JSValue newTarget = jsUndefined());
-
-ALWAYS_INLINE bool isRegExp(VM& vm, ExecState* exec, JSValue value)
+ALWAYS_INLINE bool isRegExp(VM& vm, JSGlobalObject* globalObject, JSValue value)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
     if (!value.isObject())
         return false;
 
     JSObject* object = asObject(value);
-    JSValue matchValue = object->get(exec, vm.propertyNames->matchSymbol);
+    JSValue matchValue = object->get(globalObject, vm.propertyNames->matchSymbol);
     RETURN_IF_EXCEPTION(scope, false);
     if (!matchValue.isUndefined())
-        return matchValue.toBoolean(exec);
+        return matchValue.toBoolean(globalObject);
 
     return object->inherits<RegExpObject>(vm);
 }
 
-EncodedJSValue JSC_HOST_CALL esSpecRegExpCreate(ExecState*);
+EncodedJSValue JSC_HOST_CALL esSpecRegExpCreate(JSGlobalObject*, CallFrame*);
+EncodedJSValue JSC_HOST_CALL esSpecIsRegExp(JSGlobalObject*, CallFrame*);
 
 } // namespace JSC

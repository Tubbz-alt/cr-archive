diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceRequestConverter.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceRequestConverter.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceRequestConverter.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceRequestConverter.cpp
@@ -85,11 +85,11 @@
     cborDescriptorMap[CBORValue(kCredentialTypeKey)] = CBORValue(publicKeyCredentialTypeToString(descriptor.type));
     cborDescriptorMap[CBORValue(kCredentialIdKey)] = CBORValue(descriptor.idVector);
     return CBORValue(WTFMove(cborDescriptorMap));
 }
 
-Vector<uint8_t> encodeMakeCredenitalRequestAsCBOR(const Vector<uint8_t>& hash, const PublicKeyCredentialCreationOptions& options, UVAvailability uvCapability)
+Vector<uint8_t> encodeMakeCredenitalRequestAsCBOR(const Vector<uint8_t>& hash, const PublicKeyCredentialCreationOptions& options, UVAvailability uvCapability, Optional<PinParameters> pin)
 {
     CBORValue::MapValue cborMap;
     cborMap[CBORValue(1)] = CBORValue(hash);
     cborMap[CBORValue(2)] = convertRpEntityToCBOR(options.rp);
     cborMap[CBORValue(3)] = convertUserEntityToCBOR(options.user);
@@ -117,24 +117,31 @@
             requireUserVerification = uvCapability == UVAvailability::kNotSupported ? false : true;
             break;
         case UserVerificationRequirement::Discouraged:
             requireUserVerification = false;
         }
-        optionMap[CBORValue(kUserVerificationMapKey)] = CBORValue(requireUserVerification);
+        if (requireUserVerification)
+            optionMap[CBORValue(kUserVerificationMapKey)] = CBORValue(requireUserVerification);
     }
     if (!optionMap.empty())
         cborMap[CBORValue(7)] = CBORValue(WTFMove(optionMap));
 
+    if (pin) {
+        ASSERT(pin->protocol >= 0);
+        cborMap[CBORValue(8)] = CBORValue(WTFMove(pin->auth));
+        cborMap[CBORValue(9)] = CBORValue(pin->protocol);
+    }
+
     auto serializedParam = CBORWriter::write(CBORValue(WTFMove(cborMap)));
     ASSERT(serializedParam);
 
     Vector<uint8_t> cborRequest({ static_cast<uint8_t>(CtapRequestCommand::kAuthenticatorMakeCredential) });
     cborRequest.appendVector(*serializedParam);
     return cborRequest;
 }
 
-Vector<uint8_t> encodeGetAssertionRequestAsCBOR(const Vector<uint8_t>& hash, const PublicKeyCredentialRequestOptions& options, UVAvailability uvCapability)
+Vector<uint8_t> encodeGetAssertionRequestAsCBOR(const Vector<uint8_t>& hash, const PublicKeyCredentialRequestOptions& options, UVAvailability uvCapability, Optional<PinParameters> pin)
 {
     CBORValue::MapValue cborMap;
     cborMap[CBORValue(1)] = CBORValue(options.rpId);
     cborMap[CBORValue(2)] = CBORValue(hash);
 
@@ -156,16 +163,23 @@
         requireUserVerification = uvCapability == UVAvailability::kNotSupported ? false : true;
         break;
     case UserVerificationRequirement::Discouraged:
         requireUserVerification = false;
     }
-    optionMap[CBORValue(kUserVerificationMapKey)] = CBORValue(requireUserVerification);
+    if (requireUserVerification)
+        optionMap[CBORValue(kUserVerificationMapKey)] = CBORValue(requireUserVerification);
     optionMap[CBORValue(kUserPresenceMapKey)] = CBORValue(true);
 
     if (!optionMap.empty())
         cborMap[CBORValue(5)] = CBORValue(WTFMove(optionMap));
 
+    if (pin) {
+        ASSERT(pin->protocol >= 0);
+        cborMap[CBORValue(6)] = CBORValue(WTFMove(pin->auth));
+        cborMap[CBORValue(7)] = CBORValue(pin->protocol);
+    }
+
     auto serializedParam = CBORWriter::write(CBORValue(WTFMove(cborMap)));
     ASSERT(serializedParam);
 
     Vector<uint8_t> cborRequest({ static_cast<uint8_t>(CtapRequestCommand::kAuthenticatorGetAssertion) });
     cborRequest.appendVector(*serializedParam);

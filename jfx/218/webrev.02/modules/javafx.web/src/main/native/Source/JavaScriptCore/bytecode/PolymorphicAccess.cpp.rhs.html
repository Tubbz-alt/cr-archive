<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PolymorphicAccess.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;BinarySwitch.h&quot;
 32 #include &quot;CCallHelpers.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 33 #include &quot;CacheableIdentifierInlines.h&quot;</span>
 34 #include &quot;CodeBlock.h&quot;
 35 #include &quot;FullCodeOrigin.h&quot;
 36 #include &quot;Heap.h&quot;
 37 #include &quot;JITOperations.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;LinkBuffer.h&quot;
 40 #include &quot;StructureStubClearingWatchpoint.h&quot;
 41 #include &quot;StructureStubInfo.h&quot;
 42 #include &quot;SuperSampler.h&quot;
 43 #include &lt;wtf/CommaPrinter.h&gt;
 44 #include &lt;wtf/ListDump.h&gt;
 45 
 46 namespace JSC {
 47 
 48 namespace PolymorphicAccessInternal {
<a name="3" id="anc3"></a><span class="line-modified"> 49 static constexpr bool verbose = false;</span>
 50 }
 51 
<a name="4" id="anc4"></a><span class="line-added"> 52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
<span class="line-added"> 53 </span>
 54 void AccessGenerationResult::dump(PrintStream&amp; out) const
 55 {
 56     out.print(m_kind);
 57     if (m_code)
 58         out.print(&quot;:&quot;, m_code);
 59 }
 60 
<a name="5" id="anc5"></a><span class="line-modified"> 61 void AccessGenerationState::installWatchpoint(const ObjectPropertyCondition&amp; condition)</span>
 62 {
<a name="6" id="anc6"></a><span class="line-modified"> 63     WatchpointsOnStructureStubInfo::ensureReferenceAndInstallWatchpoint(</span>
 64         watchpoints, jit-&gt;codeBlock(), stubInfo, condition);
 65 }
 66 
 67 void AccessGenerationState::restoreScratch()
 68 {
 69     allocator-&gt;restoreReusedRegistersByPopping(*jit, preservedReusedRegisterState);
 70 }
 71 
 72 void AccessGenerationState::succeed()
 73 {
 74     restoreScratch();
 75     success.append(jit-&gt;jump());
 76 }
 77 
 78 const RegisterSet&amp; AccessGenerationState::liveRegistersForCall()
 79 {
 80     if (!m_calculatedRegistersForCallAndExceptionHandling)
 81         calculateLiveRegistersForCallAndExceptionHandling();
 82     return m_liveRegistersForCall;
 83 }
 84 
 85 const RegisterSet&amp; AccessGenerationState::liveRegistersToPreserveAtExceptionHandlingCallSite()
 86 {
 87     if (!m_calculatedRegistersForCallAndExceptionHandling)
 88         calculateLiveRegistersForCallAndExceptionHandling();
 89     return m_liveRegistersToPreserveAtExceptionHandlingCallSite;
 90 }
 91 
 92 static RegisterSet calleeSaveRegisters()
 93 {
 94     RegisterSet result = RegisterSet::registersToNotSaveForJSCall();
 95     result.filter(RegisterSet::registersToNotSaveForCCall());
 96     return result;
 97 }
 98 
 99 const RegisterSet&amp; AccessGenerationState::calculateLiveRegistersForCallAndExceptionHandling()
100 {
101     if (!m_calculatedRegistersForCallAndExceptionHandling) {
102         m_calculatedRegistersForCallAndExceptionHandling = true;
103 
104         m_liveRegistersToPreserveAtExceptionHandlingCallSite = jit-&gt;codeBlock()-&gt;jitCode()-&gt;liveRegistersToPreserveAtExceptionHandlingCallSite(jit-&gt;codeBlock(), stubInfo-&gt;callSiteIndex);
105         m_needsToRestoreRegistersIfException = m_liveRegistersToPreserveAtExceptionHandlingCallSite.numberOfSetRegisters() &gt; 0;
106         if (m_needsToRestoreRegistersIfException)
107             RELEASE_ASSERT(JITCode::isOptimizingJIT(jit-&gt;codeBlock()-&gt;jitType()));
108 
109         m_liveRegistersForCall = RegisterSet(m_liveRegistersToPreserveAtExceptionHandlingCallSite, allocator-&gt;usedRegisters());
110         m_liveRegistersForCall.exclude(calleeSaveRegisters());
111     }
112     return m_liveRegistersForCall;
113 }
114 
115 auto AccessGenerationState::preserveLiveRegistersToStackForCall(const RegisterSet&amp; extra) -&gt; SpillState
116 {
117     RegisterSet liveRegisters = liveRegistersForCall();
118     liveRegisters.merge(extra);
119 
120     unsigned extraStackPadding = 0;
121     unsigned numberOfStackBytesUsedForRegisterPreservation = ScratchRegisterAllocator::preserveRegistersToStackForCall(*jit, liveRegisters, extraStackPadding);
122     return SpillState {
123         WTFMove(liveRegisters),
124         numberOfStackBytesUsedForRegisterPreservation
125     };
126 }
127 
128 void AccessGenerationState::restoreLiveRegistersFromStackForCallWithThrownException(const SpillState&amp; spillState)
129 {
130     // Even if we&#39;re a getter, we don&#39;t want to ignore the result value like we normally do
131     // because the getter threw, and therefore, didn&#39;t return a value that means anything.
132     // Instead, we want to restore that register to what it was upon entering the getter
133     // inline cache. The subtlety here is if the base and the result are the same register,
134     // and the getter threw, we want OSR exit to see the original base value, not the result
135     // of the getter call.
136     RegisterSet dontRestore = spillState.spilledRegisters;
137     // As an optimization here, we only need to restore what is live for exception handling.
138     // We can construct the dontRestore set to accomplish this goal by having it contain only
139     // what is live for call but not live for exception handling. By ignoring things that are
140     // only live at the call but not the exception handler, we will only restore things live
141     // at the exception handler.
142     dontRestore.exclude(liveRegistersToPreserveAtExceptionHandlingCallSite());
143     restoreLiveRegistersFromStackForCall(spillState, dontRestore);
144 }
145 
146 void AccessGenerationState::restoreLiveRegistersFromStackForCall(const SpillState&amp; spillState, const RegisterSet&amp; dontRestore)
147 {
148     unsigned extraStackPadding = 0;
149     ScratchRegisterAllocator::restoreRegistersFromStackForCall(*jit, spillState.spilledRegisters, dontRestore, spillState.numberOfStackBytesUsedForRegisterPreservation, extraStackPadding);
150 }
151 
152 CallSiteIndex AccessGenerationState::callSiteIndexForExceptionHandlingOrOriginal()
153 {
154     if (!m_calculatedRegistersForCallAndExceptionHandling)
155         calculateLiveRegistersForCallAndExceptionHandling();
156 
157     if (!m_calculatedCallSiteIndex) {
158         m_calculatedCallSiteIndex = true;
159 
160         if (m_needsToRestoreRegistersIfException)
161             m_callSiteIndex = jit-&gt;codeBlock()-&gt;newExceptionHandlingCallSiteIndex(stubInfo-&gt;callSiteIndex);
162         else
163             m_callSiteIndex = originalCallSiteIndex();
164     }
165 
166     return m_callSiteIndex;
167 }
168 
169 DisposableCallSiteIndex AccessGenerationState::callSiteIndexForExceptionHandling()
170 {
171     RELEASE_ASSERT(m_calculatedRegistersForCallAndExceptionHandling);
172     RELEASE_ASSERT(m_needsToRestoreRegistersIfException);
173     RELEASE_ASSERT(m_calculatedCallSiteIndex);
174     return DisposableCallSiteIndex::fromCallSiteIndex(m_callSiteIndex);
175 }
176 
177 const HandlerInfo&amp; AccessGenerationState::originalExceptionHandler()
178 {
179     if (!m_calculatedRegistersForCallAndExceptionHandling)
180         calculateLiveRegistersForCallAndExceptionHandling();
181 
182     RELEASE_ASSERT(m_needsToRestoreRegistersIfException);
183     HandlerInfo* exceptionHandler = jit-&gt;codeBlock()-&gt;handlerForIndex(stubInfo-&gt;callSiteIndex.bits());
184     RELEASE_ASSERT(exceptionHandler);
185     return *exceptionHandler;
186 }
187 
188 CallSiteIndex AccessGenerationState::originalCallSiteIndex() const { return stubInfo-&gt;callSiteIndex; }
189 
190 void AccessGenerationState::emitExplicitExceptionHandler()
191 {
192     restoreScratch();
193     jit-&gt;pushToSave(GPRInfo::regT0);
194     jit-&gt;loadPtr(&amp;m_vm.topEntryFrame, GPRInfo::regT0);
195     jit-&gt;copyCalleeSavesToEntryFrameCalleeSavesBuffer(GPRInfo::regT0);
196     jit-&gt;popToRestore(GPRInfo::regT0);
197 
198     if (needsToRestoreRegistersIfException()) {
199         // To the JIT that produces the original exception handling
200         // call site, they will expect the OSR exit to be arrived
201         // at from genericUnwind. Therefore we must model what genericUnwind
202         // does here. I.e, set callFrameForCatch and copy callee saves.
203 
204         jit-&gt;storePtr(GPRInfo::callFrameRegister, m_vm.addressOfCallFrameForCatch());
205         CCallHelpers::Jump jumpToOSRExitExceptionHandler = jit-&gt;jump();
206 
207         // We don&#39;t need to insert a new exception handler in the table
208         // because we&#39;re doing a manual exception check here. i.e, we&#39;ll
209         // never arrive here from genericUnwind().
210         HandlerInfo originalHandler = originalExceptionHandler();
211         jit-&gt;addLinkTask(
212             [=] (LinkBuffer&amp; linkBuffer) {
213                 linkBuffer.link(jumpToOSRExitExceptionHandler, originalHandler.nativeCode);
214             });
215     } else {
<a name="7" id="anc7"></a><span class="line-modified">216         jit-&gt;setupArguments&lt;decltype(operationLookupExceptionHandler)&gt;(CCallHelpers::TrustedImmPtr(&amp;m_vm));</span>
<span class="line-added">217         jit-&gt;prepareCallOperation(m_vm);</span>
218         CCallHelpers::Call lookupExceptionHandlerCall = jit-&gt;call(OperationPtrTag);
219         jit-&gt;addLinkTask(
220             [=] (LinkBuffer&amp; linkBuffer) {
<a name="8" id="anc8"></a><span class="line-modified">221                 linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandler));</span>
222             });
223         jit-&gt;jumpToExceptionHandler(m_vm);
224     }
225 }
226 
<a name="9" id="anc9"></a>
227 PolymorphicAccess::PolymorphicAccess() { }
228 PolymorphicAccess::~PolymorphicAccess() { }
229 
230 AccessGenerationResult PolymorphicAccess::addCases(
231     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo,
<a name="10" id="anc10"></a><span class="line-modified">232     Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; originalCasesToAdd)</span>
233 {
234     SuperSamplerScope superSamplerScope(false);
235 
236     // This method will add the originalCasesToAdd to the list one at a time while preserving the
237     // invariants:
238     // - If a newly added case canReplace() any existing case, then the existing case is removed before
239     //   the new case is added. Removal doesn&#39;t change order of the list. Any number of existing cases
240     //   can be removed via the canReplace() rule.
241     // - Cases in the list always appear in ascending order of time of addition. Therefore, if you
242     //   cascade through the cases in reverse order, you will get the most recent cases first.
243     // - If this method fails (returns null, doesn&#39;t add the cases), then both the previous case list
244     //   and the previous stub are kept intact and the new cases are destroyed. It&#39;s OK to attempt to
245     //   add more things after failure.
246 
247     // First ensure that the originalCasesToAdd doesn&#39;t contain duplicates.
248     Vector&lt;std::unique_ptr&lt;AccessCase&gt;&gt; casesToAdd;
249     for (unsigned i = 0; i &lt; originalCasesToAdd.size(); ++i) {
250         std::unique_ptr&lt;AccessCase&gt; myCase = WTFMove(originalCasesToAdd[i]);
251 
252         // Add it only if it is not replaced by the subsequent cases in the list.
253         bool found = false;
254         for (unsigned j = i + 1; j &lt; originalCasesToAdd.size(); ++j) {
255             if (originalCasesToAdd[j]-&gt;canReplace(*myCase)) {
256                 found = true;
257                 break;
258             }
259         }
260 
261         if (found)
262             continue;
263 
264         casesToAdd.append(WTFMove(myCase));
265     }
266 
267     if (PolymorphicAccessInternal::verbose)
268         dataLog(&quot;casesToAdd: &quot;, listDump(casesToAdd), &quot;\n&quot;);
269 
270     // If there aren&#39;t any cases to add, then fail on the grounds that there&#39;s no point to generating a
271     // new stub that will be identical to the old one. Returning null should tell the caller to just
272     // keep doing what they were doing before.
273     if (casesToAdd.isEmpty())
274         return AccessGenerationResult::MadeNoChanges;
275 
276     if (stubInfo.accessType != AccessType::InstanceOf) {
277         bool shouldReset = false;
278         AccessGenerationResult resetResult(AccessGenerationResult::ResetStubAndFireWatchpoints);
279         auto considerPolyProtoReset = [&amp;] (Structure* a, Structure* b) {
280             if (Structure::shouldConvertToPolyProto(a, b)) {
281                 // For now, we only reset if this is our first time invalidating this watchpoint.
282                 // The reason we don&#39;t immediately fire this watchpoint is that we may be already
283                 // watching the poly proto watchpoint, which if fired, would destroy us. We let
284                 // the person handling the result to do a delayed fire.
285                 ASSERT(a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get() == b-&gt;rareData()-&gt;sharedPolyProtoWatchpoint().get());
286                 if (a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint()-&gt;isStillValid()) {
287                     shouldReset = true;
288                     resetResult.addWatchpointToFire(*a-&gt;rareData()-&gt;sharedPolyProtoWatchpoint(), StringFireDetail(&quot;Detected poly proto optimization opportunity.&quot;));
289                 }
290             }
291         };
292 
293         for (auto&amp; caseToAdd : casesToAdd) {
294             for (auto&amp; existingCase : m_list) {
295                 Structure* a = caseToAdd-&gt;structure();
296                 Structure* b = existingCase-&gt;structure();
297                 considerPolyProtoReset(a, b);
298             }
299         }
300         for (unsigned i = 0; i &lt; casesToAdd.size(); ++i) {
301             for (unsigned j = i + 1; j &lt; casesToAdd.size(); ++j) {
302                 Structure* a = casesToAdd[i]-&gt;structure();
303                 Structure* b = casesToAdd[j]-&gt;structure();
304                 considerPolyProtoReset(a, b);
305             }
306         }
307 
308         if (shouldReset)
309             return resetResult;
310     }
311 
312     // Now add things to the new list. Note that at this point, we will still have old cases that
313     // may be replaced by the new ones. That&#39;s fine. We will sort that out when we regenerate.
314     for (auto&amp; caseToAdd : casesToAdd) {
<a name="11" id="anc11"></a><span class="line-modified">315         commit(locker, vm, m_watchpoints, codeBlock, stubInfo, *caseToAdd);</span>
316         m_list.append(WTFMove(caseToAdd));
317     }
318 
319     if (PolymorphicAccessInternal::verbose)
320         dataLog(&quot;After addCases: m_list: &quot;, listDump(m_list), &quot;\n&quot;);
321 
322     return AccessGenerationResult::Buffered;
323 }
324 
325 AccessGenerationResult PolymorphicAccess::addCase(
<a name="12" id="anc12"></a><span class="line-modified">326     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo, std::unique_ptr&lt;AccessCase&gt; newAccess)</span>

327 {
328     Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; newAccesses;
329     newAccesses.append(WTFMove(newAccess));
<a name="13" id="anc13"></a><span class="line-modified">330     return addCases(locker, vm, codeBlock, stubInfo, WTFMove(newAccesses));</span>
331 }
332 
333 bool PolymorphicAccess::visitWeak(VM&amp; vm) const
334 {
335     for (unsigned i = 0; i &lt; size(); ++i) {
336         if (!at(i).visitWeak(vm))
337             return false;
338     }
339     if (Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;* weakReferences = m_weakReferences.get()) {
340         for (WriteBarrier&lt;JSCell&gt;&amp; weakReference : *weakReferences) {
341             if (!vm.heap.isMarked(weakReference.get()))
342                 return false;
343         }
344     }
345     return true;
346 }
347 
348 bool PolymorphicAccess::propagateTransitions(SlotVisitor&amp; visitor) const
349 {
350     bool result = true;
351     for (unsigned i = 0; i &lt; size(); ++i)
352         result &amp;= at(i).propagateTransitions(visitor);
353     return result;
354 }
355 
<a name="14" id="anc14"></a><span class="line-added">356 void PolymorphicAccess::visitAggregate(SlotVisitor&amp; visitor)</span>
<span class="line-added">357 {</span>
<span class="line-added">358     for (unsigned i = 0; i &lt; size(); ++i)</span>
<span class="line-added">359         at(i).visitAggregate(visitor);</span>
<span class="line-added">360 }</span>
<span class="line-added">361 </span>
362 void PolymorphicAccess::dump(PrintStream&amp; out) const
363 {
364     out.print(RawPointer(this), &quot;:[&quot;);
365     CommaPrinter comma;
366     for (auto&amp; entry : m_list)
367         out.print(comma, *entry);
368     out.print(&quot;]&quot;);
369 }
370 
371 void PolymorphicAccess::commit(
372     const GCSafeConcurrentJSLocker&amp;, VM&amp; vm, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp; watchpoints, CodeBlock* codeBlock,
<a name="15" id="anc15"></a><span class="line-modified">373     StructureStubInfo&amp; stubInfo, AccessCase&amp; accessCase)</span>
374 {
375     // NOTE: We currently assume that this is relatively rare. It mainly arises for accesses to
376     // properties on DOM nodes. For sure we cache many DOM node accesses, but even in
377     // Real Pages (TM), we appear to spend most of our time caching accesses to properties on
378     // vanilla objects or exotic objects from within JSC (like Arguments, those are super popular).
379     // Those common kinds of JSC object accesses don&#39;t hit this case.
380 
<a name="16" id="anc16"></a><span class="line-modified">381     for (WatchpointSet* set : accessCase.commit(vm)) {</span>
382         Watchpoint* watchpoint =
383             WatchpointsOnStructureStubInfo::ensureReferenceAndAddWatchpoint(
<a name="17" id="anc17"></a><span class="line-modified">384                 watchpoints, codeBlock, &amp;stubInfo);</span>
385 
386         set-&gt;add(watchpoint);
387     }
388 }
389 
390 AccessGenerationResult PolymorphicAccess::regenerate(
<a name="18" id="anc18"></a><span class="line-modified">391     const GCSafeConcurrentJSLocker&amp; locker, VM&amp; vm, CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)</span>
392 {
393     SuperSamplerScope superSamplerScope(false);
394 
395     if (PolymorphicAccessInternal::verbose)
396         dataLog(&quot;Regenerate with m_list: &quot;, listDump(m_list), &quot;\n&quot;);
397 
398     AccessGenerationState state(vm, codeBlock-&gt;globalObject());
399 
400     state.access = this;
401     state.stubInfo = &amp;stubInfo;
<a name="19" id="anc19"></a>
402 
<a name="20" id="anc20"></a><span class="line-modified">403     state.baseGPR = stubInfo.baseGPR;</span>
<span class="line-modified">404     state.u.thisGPR = stubInfo.regs.thisGPR;</span>
405     state.valueRegs = stubInfo.valueRegs();
406 
<a name="21" id="anc21"></a>

















407     // Regenerating is our opportunity to figure out what our list of cases should look like. We
408     // do this here. The newly produced &#39;cases&#39; list may be smaller than m_list. We don&#39;t edit
409     // m_list in-place because we may still fail, in which case we want the PolymorphicAccess object
410     // to be unmutated. For sure, we want it to hang onto any data structures that may be referenced
411     // from the code of the current stub (aka previous).
412     ListType cases;
413     unsigned srcIndex = 0;
414     unsigned dstIndex = 0;
415     while (srcIndex &lt; m_list.size()) {
416         std::unique_ptr&lt;AccessCase&gt; someCase = WTFMove(m_list[srcIndex++]);
417 
418         // If the case had been generated, then we have to keep the original in m_list in case we
419         // fail to regenerate. That case may have data structures that are used by the code that it
420         // had generated. If the case had not been generated, then we want to remove it from m_list.
421         bool isGenerated = someCase-&gt;state() == AccessCase::Generated;
422 
423         [&amp;] () {
424             if (!someCase-&gt;couldStillSucceed())
425                 return;
426 
427             // Figure out if this is replaced by any later case. Given two cases A and B where A
428             // comes first in the case list, we know that A would have triggered first if we had
429             // generated the cases in a cascade. That&#39;s why this loop asks B-&gt;canReplace(A) but not
430             // A-&gt;canReplace(B). If A-&gt;canReplace(B) was true then A would never have requested
431             // repatching in cases where Repatch.cpp would have then gone on to generate B. If that
432             // did happen by some fluke, then we&#39;d just miss the redundancy here, which wouldn&#39;t be
433             // incorrect - just slow. However, if A&#39;s checks failed and Repatch.cpp concluded that
434             // this new condition could be handled by B and B-&gt;canReplace(A), then this says that we
435             // don&#39;t need A anymore.
436             //
437             // If we can generate a binary switch, then A-&gt;canReplace(B) == B-&gt;canReplace(A). So,
438             // it doesn&#39;t matter that we only do the check in one direction.
439             for (unsigned j = srcIndex; j &lt; m_list.size(); ++j) {
440                 if (m_list[j]-&gt;canReplace(*someCase))
441                     return;
442             }
443 
444             if (isGenerated)
445                 cases.append(someCase-&gt;clone());
446             else
447                 cases.append(WTFMove(someCase));
448         }();
449 
450         if (isGenerated)
451             m_list[dstIndex++] = WTFMove(someCase);
452     }
453     m_list.resize(dstIndex);
454 
<a name="22" id="anc22"></a><span class="line-added">455     ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="line-added">456     state.allocator = &amp;allocator;</span>
<span class="line-added">457     allocator.lock(state.baseGPR);</span>
<span class="line-added">458     if (state.u.thisGPR != InvalidGPRReg)</span>
<span class="line-added">459         allocator.lock(state.u.thisGPR);</span>
<span class="line-added">460     allocator.lock(state.valueRegs);</span>
<span class="line-added">461 #if USE(JSVALUE32_64)</span>
<span class="line-added">462     allocator.lock(stubInfo.baseTagGPR);</span>
<span class="line-added">463     if (stubInfo.v.thisTagGPR != InvalidGPRReg)</span>
<span class="line-added">464         allocator.lock(stubInfo.v.thisTagGPR);</span>
<span class="line-added">465 #endif</span>
<span class="line-added">466 </span>
<span class="line-added">467     state.scratchGPR = allocator.allocateScratchGPR();</span>
<span class="line-added">468 </span>
<span class="line-added">469     for (auto&amp; accessCase : cases) {</span>
<span class="line-added">470         if (accessCase-&gt;needsScratchFPR()) {</span>
<span class="line-added">471             state.scratchFPR = allocator.allocateScratchFPR();</span>
<span class="line-added">472             break;</span>
<span class="line-added">473         }</span>
<span class="line-added">474     }</span>
<span class="line-added">475 </span>
<span class="line-added">476     CCallHelpers jit(codeBlock);</span>
<span class="line-added">477     state.jit = &amp;jit;</span>
<span class="line-added">478 </span>
<span class="line-added">479     state.preservedReusedRegisterState =</span>
<span class="line-added">480         allocator.preserveReusedRegistersByPushing(jit, ScratchRegisterAllocator::ExtraStackSpace::NoExtraSpace);</span>
<span class="line-added">481 </span>
482     bool generatedFinalCode = false;
483 
484     // If the resulting set of cases is so big that we would stop caching and this is InstanceOf,
485     // then we want to generate the generic InstanceOf and then stop.
486     if (cases.size() &gt;= Options::maxAccessVariantListSize()
487         &amp;&amp; stubInfo.accessType == AccessType::InstanceOf) {
488         while (!cases.isEmpty())
489             m_list.append(cases.takeLast());
<a name="23" id="anc23"></a><span class="line-modified">490         cases.append(AccessCase::create(vm, codeBlock, AccessCase::InstanceOfGeneric, nullptr));</span>
491         generatedFinalCode = true;
492     }
493 
494     if (PolymorphicAccessInternal::verbose)
495         dataLog(&quot;Optimized cases: &quot;, listDump(cases), &quot;\n&quot;);
496 
497     // At this point we&#39;re convinced that &#39;cases&#39; contains the cases that we want to JIT now and we
498     // won&#39;t change that set anymore.
499 
500     bool allGuardedByStructureCheck = true;
501     bool hasJSGetterSetterCall = false;
<a name="24" id="anc24"></a><span class="line-added">502     bool needsInt32PropertyCheck = false;</span>
<span class="line-added">503     bool needsStringPropertyCheck = false;</span>
<span class="line-added">504     bool needsSymbolPropertyCheck = false;</span>
505     for (auto&amp; newCase : cases) {
<a name="25" id="anc25"></a><span class="line-modified">506         if (!stubInfo.hasConstantIdentifier) {</span>
<span class="line-modified">507             if (newCase-&gt;requiresIdentifierNameMatch()) {</span>
<span class="line-added">508                 if (newCase-&gt;uid()-&gt;isSymbol())</span>
<span class="line-added">509                     needsSymbolPropertyCheck = true;</span>
<span class="line-added">510                 else</span>
<span class="line-added">511                     needsStringPropertyCheck = true;</span>
<span class="line-added">512             } else if (newCase-&gt;requiresInt32PropertyCheck())</span>
<span class="line-added">513                 needsInt32PropertyCheck = true;</span>
<span class="line-added">514         }</span>
<span class="line-added">515         commit(locker, vm, state.watchpoints, codeBlock, stubInfo, *newCase);</span>
<span class="line-added">516         allGuardedByStructureCheck &amp;= newCase-&gt;guardedByStructureCheck(stubInfo);</span>
517         if (newCase-&gt;type() == AccessCase::Getter || newCase-&gt;type() == AccessCase::Setter)
518             hasJSGetterSetterCall = true;
519     }
520 
521     if (cases.isEmpty()) {
522         // This is super unlikely, but we make it legal anyway.
523         state.failAndRepatch.append(jit.jump());
524     } else if (!allGuardedByStructureCheck || cases.size() == 1) {
525         // If there are any proxies in the list, we cannot just use a binary switch over the structure.
526         // We need to resort to a cascade. A cascade also happens to be optimal if we only have just
527         // one case.
528         CCallHelpers::JumpList fallThrough;
<a name="26" id="anc26"></a><span class="line-added">529         if (needsInt32PropertyCheck || needsStringPropertyCheck || needsSymbolPropertyCheck) {</span>
<span class="line-added">530             if (needsInt32PropertyCheck) {</span>
<span class="line-added">531                 CCallHelpers::Jump notInt32;</span>
<span class="line-added">532 </span>
<span class="line-added">533                 if (!stubInfo.propertyIsInt32) {</span>
<span class="line-added">534 #if USE(JSVALUE64)</span>
<span class="line-added">535                     notInt32 = jit.branchIfNotInt32(state.u.propertyGPR);</span>
<span class="line-added">536 #else</span>
<span class="line-added">537                     notInt32 = jit.branchIfNotInt32(state.stubInfo-&gt;v.propertyTagGPR);</span>
<span class="line-added">538 #endif</span>
<span class="line-added">539                 }</span>
<span class="line-added">540                 for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">541                     fallThrough.link(&amp;jit);</span>
<span class="line-added">542                     fallThrough.clear();</span>
<span class="line-added">543                     if (cases[i]-&gt;requiresInt32PropertyCheck())</span>
<span class="line-added">544                         cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">545                 }</span>
<span class="line-added">546 </span>
<span class="line-added">547                 if (needsStringPropertyCheck || needsSymbolPropertyCheck) {</span>
<span class="line-added">548                     if (notInt32.isSet())</span>
<span class="line-added">549                         notInt32.link(&amp;jit);</span>
<span class="line-added">550                     fallThrough.link(&amp;jit);</span>
<span class="line-added">551                     fallThrough.clear();</span>
<span class="line-added">552                 } else {</span>
<span class="line-added">553                     if (notInt32.isSet())</span>
<span class="line-added">554                         state.failAndRepatch.append(notInt32);</span>
<span class="line-added">555                 }</span>
<span class="line-added">556             }</span>
<span class="line-added">557 </span>
<span class="line-added">558             if (needsStringPropertyCheck) {</span>
<span class="line-added">559                 CCallHelpers::JumpList notString;</span>
<span class="line-added">560                 GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">561                 if (!stubInfo.propertyIsString) {</span>
<span class="line-added">562 #if USE(JSVALUE32_64)</span>
<span class="line-added">563                     GPRReg propertyTagGPR = state.stubInfo-&gt;v.propertyTagGPR;</span>
<span class="line-added">564                     notString.append(jit.branchIfNotCell(propertyTagGPR));</span>
<span class="line-added">565 #else</span>
<span class="line-added">566                     notString.append(jit.branchIfNotCell(propertyGPR));</span>
<span class="line-added">567 #endif</span>
<span class="line-added">568                     notString.append(jit.branchIfNotString(propertyGPR));</span>
<span class="line-added">569                 }</span>
<span class="line-added">570 </span>
<span class="line-added">571                 jit.loadPtr(MacroAssembler::Address(propertyGPR, JSString::offsetOfValue()), state.scratchGPR);</span>
<span class="line-added">572 </span>
<span class="line-added">573                 state.failAndRepatch.append(jit.branchIfRopeStringImpl(state.scratchGPR));</span>
<span class="line-added">574 </span>
<span class="line-added">575                 for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">576                     fallThrough.link(&amp;jit);</span>
<span class="line-added">577                     fallThrough.clear();</span>
<span class="line-added">578                     if (cases[i]-&gt;requiresIdentifierNameMatch() &amp;&amp; !cases[i]-&gt;uid()-&gt;isSymbol())</span>
<span class="line-added">579                         cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">580                 }</span>
<span class="line-added">581 </span>
<span class="line-added">582                 if (needsSymbolPropertyCheck) {</span>
<span class="line-added">583                     notString.link(&amp;jit);</span>
<span class="line-added">584                     fallThrough.link(&amp;jit);</span>
<span class="line-added">585                     fallThrough.clear();</span>
<span class="line-added">586                 } else</span>
<span class="line-added">587                     state.failAndRepatch.append(notString);</span>
<span class="line-added">588             }</span>
<span class="line-added">589 </span>
<span class="line-added">590             if (needsSymbolPropertyCheck) {</span>
<span class="line-added">591                 CCallHelpers::JumpList notSymbol;</span>
<span class="line-added">592                 if (!stubInfo.propertyIsSymbol) {</span>
<span class="line-added">593                     GPRReg propertyGPR = state.u.propertyGPR;</span>
<span class="line-added">594 #if USE(JSVALUE32_64)</span>
<span class="line-added">595                     GPRReg propertyTagGPR = state.stubInfo-&gt;v.propertyTagGPR;</span>
<span class="line-added">596                     notSymbol.append(jit.branchIfNotCell(propertyTagGPR));</span>
<span class="line-added">597 #else</span>
<span class="line-added">598                     notSymbol.append(jit.branchIfNotCell(propertyGPR));</span>
<span class="line-added">599 #endif</span>
<span class="line-added">600                     notSymbol.append(jit.branchIfNotSymbol(propertyGPR));</span>
<span class="line-added">601                 }</span>
<span class="line-added">602 </span>
<span class="line-added">603                 for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">604                     fallThrough.link(&amp;jit);</span>
<span class="line-added">605                     fallThrough.clear();</span>
<span class="line-added">606                     if (cases[i]-&gt;requiresIdentifierNameMatch() &amp;&amp; cases[i]-&gt;uid()-&gt;isSymbol())</span>
<span class="line-added">607                         cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">608                 }</span>
609 
<a name="27" id="anc27"></a><span class="line-modified">610                 state.failAndRepatch.append(notSymbol);</span>
<span class="line-modified">611             }</span>
<span class="line-modified">612         } else {</span>
<span class="line-modified">613             // Cascade through the list, preferring newer entries.</span>
<span class="line-modified">614             for (unsigned i = cases.size(); i--;) {</span>
<span class="line-added">615                 fallThrough.link(&amp;jit);</span>
<span class="line-added">616                 fallThrough.clear();</span>
<span class="line-added">617                 cases[i]-&gt;generateWithGuard(state, fallThrough);</span>
<span class="line-added">618             }</span>
619         }
<a name="28" id="anc28"></a><span class="line-added">620 </span>
621         state.failAndRepatch.append(fallThrough);
<a name="29" id="anc29"></a><span class="line-added">622 </span>
623     } else {
624         jit.load32(
625             CCallHelpers::Address(state.baseGPR, JSCell::structureIDOffset()),
626             state.scratchGPR);
627 
628         Vector&lt;int64_t&gt; caseValues(cases.size());
629         for (unsigned i = 0; i &lt; cases.size(); ++i)
630             caseValues[i] = bitwise_cast&lt;int32_t&gt;(cases[i]-&gt;structure()-&gt;id());
631 
632         BinarySwitch binarySwitch(state.scratchGPR, caseValues, BinarySwitch::Int32);
633         while (binarySwitch.advance(jit))
634             cases[binarySwitch.caseIndex()]-&gt;generate(state);
635         state.failAndRepatch.append(binarySwitch.fallThrough());
636     }
637 
638     if (!state.failAndIgnore.empty()) {
639         state.failAndIgnore.link(&amp;jit);
640 
641         // Make sure that the inline cache optimization code knows that we are taking slow path because
642         // of something that isn&#39;t patchable. The slow path will decrement &quot;countdown&quot; and will only
643         // patch things if the countdown reaches zero. We increment the slow path count here to ensure
644         // that the slow path does not try to patch.
645 #if CPU(X86) || CPU(X86_64)
646         jit.move(CCallHelpers::TrustedImmPtr(&amp;stubInfo.countdown), state.scratchGPR);
647         jit.add8(CCallHelpers::TrustedImm32(1), CCallHelpers::Address(state.scratchGPR));
648 #else
649         jit.load8(&amp;stubInfo.countdown, state.scratchGPR);
650         jit.add32(CCallHelpers::TrustedImm32(1), state.scratchGPR);
651         jit.store8(state.scratchGPR, &amp;stubInfo.countdown);
652 #endif
653     }
654 
655     CCallHelpers::JumpList failure;
656     if (allocator.didReuseRegisters()) {
657         state.failAndRepatch.link(&amp;jit);
658         state.restoreScratch();
659     } else
660         failure = state.failAndRepatch;
661     failure.append(jit.jump());
662 
663     CodeBlock* codeBlockThatOwnsExceptionHandlers = nullptr;
664     DisposableCallSiteIndex callSiteIndexForExceptionHandling;
665     if (state.needsToRestoreRegistersIfException() &amp;&amp; hasJSGetterSetterCall) {
666         // Emit the exception handler.
667         // Note that this code is only reachable when doing genericUnwind from a pure JS getter/setter .
668         // Note also that this is not reachable from custom getter/setter. Custom getter/setters will have
669         // their own exception handling logic that doesn&#39;t go through genericUnwind.
670         MacroAssembler::Label makeshiftCatchHandler = jit.label();
671 
672         int stackPointerOffset = codeBlock-&gt;stackPointerOffset() * sizeof(EncodedJSValue);
673         AccessGenerationState::SpillState spillStateForJSGetterSetter = state.spillStateForJSGetterSetter();
674         ASSERT(!spillStateForJSGetterSetter.isEmpty());
675         stackPointerOffset -= state.preservedReusedRegisterState.numberOfBytesPreserved;
676         stackPointerOffset -= spillStateForJSGetterSetter.numberOfStackBytesUsedForRegisterPreservation;
677 
678         jit.loadPtr(vm.addressOfCallFrameForCatch(), GPRInfo::callFrameRegister);
679         jit.addPtr(CCallHelpers::TrustedImm32(stackPointerOffset), GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
680 
681         state.restoreLiveRegistersFromStackForCallWithThrownException(spillStateForJSGetterSetter);
682         state.restoreScratch();
683         CCallHelpers::Jump jumpToOSRExitExceptionHandler = jit.jump();
684 
685         HandlerInfo oldHandler = state.originalExceptionHandler();
686         DisposableCallSiteIndex newExceptionHandlingCallSite = state.callSiteIndexForExceptionHandling();
687         jit.addLinkTask(
688             [=] (LinkBuffer&amp; linkBuffer) {
689                 linkBuffer.link(jumpToOSRExitExceptionHandler, oldHandler.nativeCode);
690 
691                 HandlerInfo handlerToRegister = oldHandler;
692                 handlerToRegister.nativeCode = linkBuffer.locationOf&lt;ExceptionHandlerPtrTag&gt;(makeshiftCatchHandler);
693                 handlerToRegister.start = newExceptionHandlingCallSite.bits();
694                 handlerToRegister.end = newExceptionHandlingCallSite.bits() + 1;
695                 codeBlock-&gt;appendExceptionHandler(handlerToRegister);
696             });
697 
698         // We set these to indicate to the stub to remove itself from the CodeBlock&#39;s
699         // exception handler table when it is deallocated.
700         codeBlockThatOwnsExceptionHandlers = codeBlock;
701         ASSERT(JITCode::isOptimizingJIT(codeBlockThatOwnsExceptionHandlers-&gt;jitType()));
702         callSiteIndexForExceptionHandling = state.callSiteIndexForExceptionHandling();
703     }
704 
705     LinkBuffer linkBuffer(jit, codeBlock, JITCompilationCanFail);
706     if (linkBuffer.didFailToAllocate()) {
707         if (PolymorphicAccessInternal::verbose)
708             dataLog(&quot;Did fail to allocate.\n&quot;);
709         return AccessGenerationResult::GaveUp;
710     }
711 
<a name="30" id="anc30"></a><span class="line-modified">712     CodeLocationLabel&lt;JSInternalPtrTag&gt; successLabel = stubInfo.doneLocation;</span>
713 
714     linkBuffer.link(state.success, successLabel);
715 
<a name="31" id="anc31"></a><span class="line-modified">716     linkBuffer.link(failure, stubInfo.slowPathStartLocation);</span>
717 
718     if (PolymorphicAccessInternal::verbose)
719         dataLog(FullCodeOrigin(codeBlock, stubInfo.codeOrigin), &quot;: Generating polymorphic access stub for &quot;, listDump(cases), &quot;\n&quot;);
720 
721     MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; code = FINALIZE_CODE_FOR(
722         codeBlock, linkBuffer, JITStubRoutinePtrTag,
723         &quot;%s&quot;, toCString(&quot;Access stub for &quot;, *codeBlock, &quot; &quot;, stubInfo.codeOrigin, &quot; with return point &quot;, successLabel, &quot;: &quot;, listDump(cases)).data());
724 
725     bool doesCalls = false;
726     Vector&lt;JSCell*&gt; cellsToMark;
727     for (auto&amp; entry : cases)
<a name="32" id="anc32"></a><span class="line-modified">728         doesCalls |= entry-&gt;doesCalls(vm, &amp;cellsToMark);</span>
729 
<a name="33" id="anc33"></a><span class="line-modified">730     m_stubRoutine = createJITStubRoutine(code, vm, codeBlock, doesCalls, cellsToMark, WTFMove(state.m_callLinkInfos), codeBlockThatOwnsExceptionHandlers, callSiteIndexForExceptionHandling);</span>
731     m_watchpoints = WTFMove(state.watchpoints);
<a name="34" id="anc34"></a><span class="line-modified">732     if (!state.weakReferences.isEmpty()) {</span>
<span class="line-added">733         state.weakReferences.shrinkToFit();</span>
734         m_weakReferences = makeUnique&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt;(WTFMove(state.weakReferences));
<a name="35" id="anc35"></a><span class="line-added">735     }</span>
736     if (PolymorphicAccessInternal::verbose)
737         dataLog(&quot;Returning: &quot;, code.code(), &quot;\n&quot;);
738 
739     m_list = WTFMove(cases);
<a name="36" id="anc36"></a><span class="line-added">740     m_list.shrinkToFit();</span>
741 
742     AccessGenerationResult::Kind resultKind;
743     if (m_list.size() &gt;= Options::maxAccessVariantListSize() || generatedFinalCode)
744         resultKind = AccessGenerationResult::GeneratedFinalCode;
745     else
746         resultKind = AccessGenerationResult::GeneratedNewCode;
747 
748     return AccessGenerationResult(resultKind, code.code());
749 }
750 
751 void PolymorphicAccess::aboutToDie()
752 {
753     if (m_stubRoutine)
754         m_stubRoutine-&gt;aboutToDie();
755 }
756 
757 } // namespace JSC
758 
759 namespace WTF {
760 
761 using namespace JSC;
762 
763 void printInternal(PrintStream&amp; out, AccessGenerationResult::Kind kind)
764 {
765     switch (kind) {
766     case AccessGenerationResult::MadeNoChanges:
767         out.print(&quot;MadeNoChanges&quot;);
768         return;
769     case AccessGenerationResult::GaveUp:
770         out.print(&quot;GaveUp&quot;);
771         return;
772     case AccessGenerationResult::Buffered:
773         out.print(&quot;Buffered&quot;);
774         return;
775     case AccessGenerationResult::GeneratedNewCode:
776         out.print(&quot;GeneratedNewCode&quot;);
777         return;
778     case AccessGenerationResult::GeneratedFinalCode:
779         out.print(&quot;GeneratedFinalCode&quot;);
780         return;
781     case AccessGenerationResult::ResetStubAndFireWatchpoints:
782         out.print(&quot;ResetStubAndFireWatchpoints&quot;);
783         return;
784     }
785 
786     RELEASE_ASSERT_NOT_REACHED();
787 }
788 
789 void printInternal(PrintStream&amp; out, AccessCase::AccessType type)
790 {
791     switch (type) {
792     case AccessCase::Load:
793         out.print(&quot;Load&quot;);
794         return;
795     case AccessCase::Transition:
796         out.print(&quot;Transition&quot;);
797         return;
798     case AccessCase::Replace:
799         out.print(&quot;Replace&quot;);
800         return;
801     case AccessCase::Miss:
802         out.print(&quot;Miss&quot;);
803         return;
804     case AccessCase::GetGetter:
805         out.print(&quot;GetGetter&quot;);
806         return;
807     case AccessCase::Getter:
808         out.print(&quot;Getter&quot;);
809         return;
810     case AccessCase::Setter:
811         out.print(&quot;Setter&quot;);
812         return;
813     case AccessCase::CustomValueGetter:
814         out.print(&quot;CustomValueGetter&quot;);
815         return;
816     case AccessCase::CustomAccessorGetter:
817         out.print(&quot;CustomAccessorGetter&quot;);
818         return;
819     case AccessCase::CustomValueSetter:
820         out.print(&quot;CustomValueSetter&quot;);
821         return;
822     case AccessCase::CustomAccessorSetter:
823         out.print(&quot;CustomAccessorSetter&quot;);
824         return;
825     case AccessCase::IntrinsicGetter:
826         out.print(&quot;IntrinsicGetter&quot;);
827         return;
828     case AccessCase::InHit:
829         out.print(&quot;InHit&quot;);
830         return;
831     case AccessCase::InMiss:
832         out.print(&quot;InMiss&quot;);
833         return;
834     case AccessCase::ArrayLength:
835         out.print(&quot;ArrayLength&quot;);
836         return;
837     case AccessCase::StringLength:
838         out.print(&quot;StringLength&quot;);
839         return;
840     case AccessCase::DirectArgumentsLength:
841         out.print(&quot;DirectArgumentsLength&quot;);
842         return;
843     case AccessCase::ScopedArgumentsLength:
844         out.print(&quot;ScopedArgumentsLength&quot;);
845         return;
846     case AccessCase::ModuleNamespaceLoad:
847         out.print(&quot;ModuleNamespaceLoad&quot;);
848         return;
849     case AccessCase::InstanceOfHit:
850         out.print(&quot;InstanceOfHit&quot;);
851         return;
852     case AccessCase::InstanceOfMiss:
853         out.print(&quot;InstanceOfMiss&quot;);
854         return;
855     case AccessCase::InstanceOfGeneric:
856         out.print(&quot;InstanceOfGeneric&quot;);
857         return;
<a name="37" id="anc37"></a><span class="line-added">858     case AccessCase::IndexedInt32Load:</span>
<span class="line-added">859         out.print(&quot;IndexedInt32Load&quot;);</span>
<span class="line-added">860         return;</span>
<span class="line-added">861     case AccessCase::IndexedDoubleLoad:</span>
<span class="line-added">862         out.print(&quot;IndexedDoubleLoad&quot;);</span>
<span class="line-added">863         return;</span>
<span class="line-added">864     case AccessCase::IndexedContiguousLoad:</span>
<span class="line-added">865         out.print(&quot;IndexedContiguousLoad&quot;);</span>
<span class="line-added">866         return;</span>
<span class="line-added">867     case AccessCase::IndexedArrayStorageLoad:</span>
<span class="line-added">868         out.print(&quot;IndexedArrayStorageLoad&quot;);</span>
<span class="line-added">869         return;</span>
<span class="line-added">870     case AccessCase::IndexedScopedArgumentsLoad:</span>
<span class="line-added">871         out.print(&quot;IndexedScopedArgumentsLoad&quot;);</span>
<span class="line-added">872         return;</span>
<span class="line-added">873     case AccessCase::IndexedDirectArgumentsLoad:</span>
<span class="line-added">874         out.print(&quot;IndexedDirectArgumentsLoad&quot;);</span>
<span class="line-added">875         return;</span>
<span class="line-added">876     case AccessCase::IndexedTypedArrayInt8Load:</span>
<span class="line-added">877         out.print(&quot;IndexedTypedArrayInt8Load&quot;);</span>
<span class="line-added">878         return;</span>
<span class="line-added">879     case AccessCase::IndexedTypedArrayUint8Load:</span>
<span class="line-added">880         out.print(&quot;IndexedTypedArrayUint8Load&quot;);</span>
<span class="line-added">881         return;</span>
<span class="line-added">882     case AccessCase::IndexedTypedArrayUint8ClampedLoad:</span>
<span class="line-added">883         out.print(&quot;IndexedTypedArrayUint8ClampedLoad&quot;);</span>
<span class="line-added">884         return;</span>
<span class="line-added">885     case AccessCase::IndexedTypedArrayInt16Load:</span>
<span class="line-added">886         out.print(&quot;IndexedTypedArrayInt16Load&quot;);</span>
<span class="line-added">887         return;</span>
<span class="line-added">888     case AccessCase::IndexedTypedArrayUint16Load:</span>
<span class="line-added">889         out.print(&quot;IndexedTypedArrayUint16Load&quot;);</span>
<span class="line-added">890         return;</span>
<span class="line-added">891     case AccessCase::IndexedTypedArrayInt32Load:</span>
<span class="line-added">892         out.print(&quot;IndexedTypedArrayInt32Load&quot;);</span>
<span class="line-added">893         return;</span>
<span class="line-added">894     case AccessCase::IndexedTypedArrayUint32Load:</span>
<span class="line-added">895         out.print(&quot;IndexedTypedArrayUint32Load&quot;);</span>
<span class="line-added">896         return;</span>
<span class="line-added">897     case AccessCase::IndexedTypedArrayFloat32Load:</span>
<span class="line-added">898         out.print(&quot;IndexedTypedArrayFloat32Load&quot;);</span>
<span class="line-added">899         return;</span>
<span class="line-added">900     case AccessCase::IndexedTypedArrayFloat64Load:</span>
<span class="line-added">901         out.print(&quot;IndexedTypedArrayFloat64Load&quot;);</span>
<span class="line-added">902         return;</span>
<span class="line-added">903     case AccessCase::IndexedStringLoad:</span>
<span class="line-added">904         out.print(&quot;IndexedStringLoad&quot;);</span>
<span class="line-added">905         return;</span>
906     }
907 
908     RELEASE_ASSERT_NOT_REACHED();
909 }
910 
911 void printInternal(PrintStream&amp; out, AccessCase::State state)
912 {
913     switch (state) {
914     case AccessCase::Primordial:
915         out.print(&quot;Primordial&quot;);
916         return;
917     case AccessCase::Committed:
918         out.print(&quot;Committed&quot;);
919         return;
920     case AccessCase::Generated:
921         out.print(&quot;Generated&quot;);
922         return;
923     }
924 
925     RELEASE_ASSERT_NOT_REACHED();
926 }
927 
928 } // namespace WTF
929 
930 #endif // ENABLE(JIT)
931 
932 
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
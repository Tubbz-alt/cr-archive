<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Font.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatSize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Font.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Font.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;Font.h&quot;
 32 
 33 #if PLATFORM(COCOA)
 34 #include &lt;pal/spi/cocoa/CoreTextSPI.h&gt;
 35 #endif

 36 #include &quot;CharacterProperties.h&quot;
 37 #include &quot;FontCache.h&quot;
 38 #include &quot;FontCascade.h&quot;

 39 #include &quot;OpenTypeMathData.h&quot;

 40 #include &lt;wtf/MathExtras.h&gt;
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/text/AtomStringHash.h&gt;
 43 
 44 #if ENABLE(OPENTYPE_VERTICAL)
 45 #include &quot;OpenTypeVerticalData.h&quot;
 46 #endif
 47 
 48 namespace WebCore {
 49 
 50 unsigned GlyphPage::s_count = 0;
 51 
 52 const float smallCapsFontSizeMultiplier = 0.7f;
 53 const float emphasisMarkFontSizeMultiplier = 0.5f;
 54 


 55 Font::Font(const FontPlatformData&amp; platformData, Origin origin, Interstitial interstitial, Visibility visibility, OrientationFallback orientationFallback)
 56     : m_platformData(platformData)
 57     , m_origin(origin)
 58     , m_visibility(visibility)
 59     , m_treatAsFixedPitch(false)
 60     , m_isInterstitial(interstitial == Interstitial::Yes)
 61     , m_isTextOrientationFallback(orientationFallback == OrientationFallback::Yes)
 62     , m_isBrokenIdeographFallback(false)
 63     , m_hasVerticalGlyphs(false)
 64     , m_isUsedInSystemFallbackCache(false)

 65 #if PLATFORM(IOS_FAMILY)
 66     , m_shouldNotBeUsedForArabic(false)
 67 #endif
 68 {
 69     platformInit();
 70     platformGlyphInit();
 71     platformCharWidthInit();
 72 #if ENABLE(OPENTYPE_VERTICAL)
 73     if (platformData.orientation() == FontOrientation::Vertical &amp;&amp; orientationFallback == OrientationFallback::No) {
 74         m_verticalData = FontCache::singleton().verticalData(platformData);
 75         m_hasVerticalGlyphs = m_verticalData.get() &amp;&amp; m_verticalData-&gt;hasVerticalMetrics();
 76     }
 77 #endif
 78 }
 79 
 80 // Estimates of avgCharWidth and maxCharWidth for platforms that don&#39;t support accessing these values from the font.
 81 void Font::initCharWidths()
 82 {
 83     auto* glyphPageZero = glyphPage(GlyphPage::pageNumberForCodePoint(&#39;0&#39;));
 84 
</pre>
<hr />
<pre>
102 #if USE(FREETYPE)
103     auto* glyphPageZeroWidthSpace = glyphPage(GlyphPage::pageNumberForCodePoint(zeroWidthSpace));
104     UChar32 zeroWidthSpaceCharacter = zeroWidthSpace;
105 #else
106     // Ask for the glyph for 0 to avoid paging in ZERO WIDTH SPACE. Control characters, including 0,
107     // are mapped to the ZERO WIDTH SPACE glyph for non FreeType based ports.
108     auto* glyphPageZeroWidthSpace = glyphPage(0);
109     UChar32 zeroWidthSpaceCharacter = 0;
110 #endif
111     auto* glyphPageCharacterZero = glyphPage(GlyphPage::pageNumberForCodePoint(&#39;0&#39;));
112     auto* glyphPageSpace = glyphPage(GlyphPage::pageNumberForCodePoint(space));
113 
114     if (glyphPageZeroWidthSpace)
115         m_zeroWidthSpaceGlyph = glyphPageZeroWidthSpace-&gt;glyphDataForCharacter(zeroWidthSpaceCharacter).glyph;
116 
117     // Nasty hack to determine if we should round or ceil space widths.
118     // If the font is monospace or fake monospace we ceil to ensure that
119     // every character and the space are the same width. Otherwise we round.
120     if (glyphPageSpace)
121         m_spaceGlyph = glyphPageSpace-&gt;glyphDataForCharacter(space).glyph;
<span class="line-removed">122     float width = widthForGlyph(m_spaceGlyph);</span>
<span class="line-removed">123     m_spaceWidth = width;</span>
124     if (glyphPageCharacterZero)
125         m_zeroGlyph = glyphPageCharacterZero-&gt;glyphDataForCharacter(&#39;0&#39;).glyph;
<span class="line-removed">126     m_fontMetrics.setZeroWidth(widthForGlyph(m_zeroGlyph));</span>
<span class="line-removed">127     determinePitch();</span>
<span class="line-removed">128     m_adjustedSpaceWidth = m_treatAsFixedPitch ? ceilf(width) : roundf(width);</span>
129 
130     // Force the glyph for ZERO WIDTH SPACE to have zero width, unless it is shared with SPACE.
131     // Helvetica is an example of a non-zero width ZERO WIDTH SPACE glyph.
132     // See &lt;http://bugs.webkit.org/show_bug.cgi?id=13178&gt; and Font::isZeroWidthSpaceGlyph()
133     if (m_zeroWidthSpaceGlyph == m_spaceGlyph)
134         m_zeroWidthSpaceGlyph = 0;






135 }
136 
137 Font::~Font()
138 {
139     removeFromSystemFallbackCache();
140 }
141 
142 static bool fillGlyphPage(GlyphPage&amp; pageToFill, UChar* buffer, unsigned bufferLength, const Font&amp; font)
143 {
144     bool hasGlyphs = pageToFill.fill(buffer, bufferLength);
145 #if ENABLE(OPENTYPE_VERTICAL)
146     if (hasGlyphs &amp;&amp; font.verticalData())
147         font.verticalData()-&gt;substituteWithVerticalGlyphs(&amp;font, &amp;pageToFill);
148 #else
149     UNUSED_PARAM(font);
150 #endif
151     return hasGlyphs;
152 }
153 
154 static Optional&lt;size_t&gt; codePointSupportIndex(UChar32 codePoint)
</pre>
<hr />
<pre>
475 }
476 #endif
477 
478 const OpenTypeMathData* Font::mathData() const
479 {
480     if (isInterstitial())
481         return nullptr;
482     if (!m_mathData) {
483         m_mathData = OpenTypeMathData::create(m_platformData);
484         if (!m_mathData-&gt;hasMathData())
485             m_mathData = nullptr;
486     }
487     return m_mathData.get();
488 }
489 
490 RefPtr&lt;Font&gt; Font::createScaledFont(const FontDescription&amp; fontDescription, float scaleFactor) const
491 {
492     return platformCreateScaledFont(fontDescription, scaleFactor);
493 }
494 
<span class="line-modified">495 bool Font::applyTransforms(GlyphBufferGlyph* glyphs, GlyphBufferAdvance* advances, size_t glyphCount, bool enableKerning, bool requiresShaping) const</span>

496 {
<span class="line-removed">497 #if PLATFORM(COCOA)</span>
<span class="line-removed">498     CTFontTransformOptions options = (enableKerning ? kCTFontTransformApplyPositioning : 0) | (requiresShaping ? kCTFontTransformApplyShaping : 0);</span>
<span class="line-removed">499     return CTFontTransformGlyphs(m_platformData.ctFont(), glyphs, reinterpret_cast&lt;CGSize*&gt;(advances), glyphCount, options);</span>
<span class="line-removed">500 #else</span>
<span class="line-removed">501     UNUSED_PARAM(glyphs);</span>
<span class="line-removed">502     UNUSED_PARAM(advances);</span>
<span class="line-removed">503     UNUSED_PARAM(glyphCount);</span>
<span class="line-removed">504     UNUSED_PARAM(enableKerning);</span>
<span class="line-removed">505     UNUSED_PARAM(requiresShaping);</span>
<span class="line-removed">506     return false;</span>
<span class="line-removed">507 #endif</span>
508 }

509 
510 class CharacterFallbackMapKey {
511 public:
512     CharacterFallbackMapKey()
513     {
514     }
515 
516     CharacterFallbackMapKey(const AtomString&amp; locale, UChar32 character, IsForPlatformFont isForPlatformFont)
517         : locale(locale)
518         , character(character)
519         , isForPlatformFont(isForPlatformFont == IsForPlatformFont::Yes)
520     {
521     }
522 
523     CharacterFallbackMapKey(WTF::HashTableDeletedValueType)
524         : character(-1)
525     {
526     }
527 
528     bool isHashTableDeletedValue() const { return character == -1; }
</pre>
<hr />
<pre>
684             ++it;
685             continue;
686         }
687 
688         if (!supportsCodePoint(codePoint))
689             return false;
690     }
691     return true;
692 }
693 
694 // Don&#39;t store the result of this! The hash map is free to rehash at any point, leaving this reference dangling.
695 const Path&amp; Font::pathForGlyph(Glyph glyph) const
696 {
697     if (const auto&amp; path = m_glyphPathMap.existingMetricsForGlyph(glyph))
698         return *path;
699     auto path = platformPathForGlyph(glyph);
700     m_glyphPathMap.setMetricsForGlyph(glyph, path);
701     return *m_glyphPathMap.existingMetricsForGlyph(glyph);
702 }
703 














704 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;Font.h&quot;
 32 
 33 #if PLATFORM(COCOA)
 34 #include &lt;pal/spi/cocoa/CoreTextSPI.h&gt;
 35 #endif
<span class="line-added"> 36 #include &quot;CachedFont.h&quot;</span>
 37 #include &quot;CharacterProperties.h&quot;
 38 #include &quot;FontCache.h&quot;
 39 #include &quot;FontCascade.h&quot;
<span class="line-added"> 40 #include &quot;FontCustomPlatformData.h&quot;</span>
 41 #include &quot;OpenTypeMathData.h&quot;
<span class="line-added"> 42 #include &quot;SharedBuffer.h&quot;</span>
 43 #include &lt;wtf/MathExtras.h&gt;
 44 #include &lt;wtf/NeverDestroyed.h&gt;
 45 #include &lt;wtf/text/AtomStringHash.h&gt;
 46 
 47 #if ENABLE(OPENTYPE_VERTICAL)
 48 #include &quot;OpenTypeVerticalData.h&quot;
 49 #endif
 50 
 51 namespace WebCore {
 52 
 53 unsigned GlyphPage::s_count = 0;
 54 
 55 const float smallCapsFontSizeMultiplier = 0.7f;
 56 const float emphasisMarkFontSizeMultiplier = 0.5f;
 57 
<span class="line-added"> 58 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Font);</span>
<span class="line-added"> 59 </span>
 60 Font::Font(const FontPlatformData&amp; platformData, Origin origin, Interstitial interstitial, Visibility visibility, OrientationFallback orientationFallback)
 61     : m_platformData(platformData)
 62     , m_origin(origin)
 63     , m_visibility(visibility)
 64     , m_treatAsFixedPitch(false)
 65     , m_isInterstitial(interstitial == Interstitial::Yes)
 66     , m_isTextOrientationFallback(orientationFallback == OrientationFallback::Yes)
 67     , m_isBrokenIdeographFallback(false)
 68     , m_hasVerticalGlyphs(false)
 69     , m_isUsedInSystemFallbackCache(false)
<span class="line-added"> 70     , m_allowsAntialiasing(true)</span>
 71 #if PLATFORM(IOS_FAMILY)
 72     , m_shouldNotBeUsedForArabic(false)
 73 #endif
 74 {
 75     platformInit();
 76     platformGlyphInit();
 77     platformCharWidthInit();
 78 #if ENABLE(OPENTYPE_VERTICAL)
 79     if (platformData.orientation() == FontOrientation::Vertical &amp;&amp; orientationFallback == OrientationFallback::No) {
 80         m_verticalData = FontCache::singleton().verticalData(platformData);
 81         m_hasVerticalGlyphs = m_verticalData.get() &amp;&amp; m_verticalData-&gt;hasVerticalMetrics();
 82     }
 83 #endif
 84 }
 85 
 86 // Estimates of avgCharWidth and maxCharWidth for platforms that don&#39;t support accessing these values from the font.
 87 void Font::initCharWidths()
 88 {
 89     auto* glyphPageZero = glyphPage(GlyphPage::pageNumberForCodePoint(&#39;0&#39;));
 90 
</pre>
<hr />
<pre>
108 #if USE(FREETYPE)
109     auto* glyphPageZeroWidthSpace = glyphPage(GlyphPage::pageNumberForCodePoint(zeroWidthSpace));
110     UChar32 zeroWidthSpaceCharacter = zeroWidthSpace;
111 #else
112     // Ask for the glyph for 0 to avoid paging in ZERO WIDTH SPACE. Control characters, including 0,
113     // are mapped to the ZERO WIDTH SPACE glyph for non FreeType based ports.
114     auto* glyphPageZeroWidthSpace = glyphPage(0);
115     UChar32 zeroWidthSpaceCharacter = 0;
116 #endif
117     auto* glyphPageCharacterZero = glyphPage(GlyphPage::pageNumberForCodePoint(&#39;0&#39;));
118     auto* glyphPageSpace = glyphPage(GlyphPage::pageNumberForCodePoint(space));
119 
120     if (glyphPageZeroWidthSpace)
121         m_zeroWidthSpaceGlyph = glyphPageZeroWidthSpace-&gt;glyphDataForCharacter(zeroWidthSpaceCharacter).glyph;
122 
123     // Nasty hack to determine if we should round or ceil space widths.
124     // If the font is monospace or fake monospace we ceil to ensure that
125     // every character and the space are the same width. Otherwise we round.
126     if (glyphPageSpace)
127         m_spaceGlyph = glyphPageSpace-&gt;glyphDataForCharacter(space).glyph;


128     if (glyphPageCharacterZero)
129         m_zeroGlyph = glyphPageCharacterZero-&gt;glyphDataForCharacter(&#39;0&#39;).glyph;



130 
131     // Force the glyph for ZERO WIDTH SPACE to have zero width, unless it is shared with SPACE.
132     // Helvetica is an example of a non-zero width ZERO WIDTH SPACE glyph.
133     // See &lt;http://bugs.webkit.org/show_bug.cgi?id=13178&gt; and Font::isZeroWidthSpaceGlyph()
134     if (m_zeroWidthSpaceGlyph == m_spaceGlyph)
135         m_zeroWidthSpaceGlyph = 0;
<span class="line-added">136 </span>
<span class="line-added">137     float width = widthForGlyph(m_spaceGlyph);</span>
<span class="line-added">138     m_spaceWidth = width;</span>
<span class="line-added">139     m_fontMetrics.setZeroWidth(widthForGlyph(m_zeroGlyph));</span>
<span class="line-added">140     determinePitch();</span>
<span class="line-added">141     m_adjustedSpaceWidth = m_treatAsFixedPitch ? ceilf(width) : roundf(width);</span>
142 }
143 
144 Font::~Font()
145 {
146     removeFromSystemFallbackCache();
147 }
148 
149 static bool fillGlyphPage(GlyphPage&amp; pageToFill, UChar* buffer, unsigned bufferLength, const Font&amp; font)
150 {
151     bool hasGlyphs = pageToFill.fill(buffer, bufferLength);
152 #if ENABLE(OPENTYPE_VERTICAL)
153     if (hasGlyphs &amp;&amp; font.verticalData())
154         font.verticalData()-&gt;substituteWithVerticalGlyphs(&amp;font, &amp;pageToFill);
155 #else
156     UNUSED_PARAM(font);
157 #endif
158     return hasGlyphs;
159 }
160 
161 static Optional&lt;size_t&gt; codePointSupportIndex(UChar32 codePoint)
</pre>
<hr />
<pre>
482 }
483 #endif
484 
485 const OpenTypeMathData* Font::mathData() const
486 {
487     if (isInterstitial())
488         return nullptr;
489     if (!m_mathData) {
490         m_mathData = OpenTypeMathData::create(m_platformData);
491         if (!m_mathData-&gt;hasMathData())
492             m_mathData = nullptr;
493     }
494     return m_mathData.get();
495 }
496 
497 RefPtr&lt;Font&gt; Font::createScaledFont(const FontDescription&amp; fontDescription, float scaleFactor) const
498 {
499     return platformCreateScaledFont(fontDescription, scaleFactor);
500 }
501 
<span class="line-modified">502 #if !PLATFORM(COCOA)</span>
<span class="line-added">503 void Font::applyTransforms(GlyphBuffer&amp;, unsigned, bool, bool, const AtomString&amp;) const</span>
504 {











505 }
<span class="line-added">506 #endif</span>
507 
508 class CharacterFallbackMapKey {
509 public:
510     CharacterFallbackMapKey()
511     {
512     }
513 
514     CharacterFallbackMapKey(const AtomString&amp; locale, UChar32 character, IsForPlatformFont isForPlatformFont)
515         : locale(locale)
516         , character(character)
517         , isForPlatformFont(isForPlatformFont == IsForPlatformFont::Yes)
518     {
519     }
520 
521     CharacterFallbackMapKey(WTF::HashTableDeletedValueType)
522         : character(-1)
523     {
524     }
525 
526     bool isHashTableDeletedValue() const { return character == -1; }
</pre>
<hr />
<pre>
682             ++it;
683             continue;
684         }
685 
686         if (!supportsCodePoint(codePoint))
687             return false;
688     }
689     return true;
690 }
691 
692 // Don&#39;t store the result of this! The hash map is free to rehash at any point, leaving this reference dangling.
693 const Path&amp; Font::pathForGlyph(Glyph glyph) const
694 {
695     if (const auto&amp; path = m_glyphPathMap.existingMetricsForGlyph(glyph))
696         return *path;
697     auto path = platformPathForGlyph(glyph);
698     m_glyphPathMap.setMetricsForGlyph(glyph, path);
699     return *m_glyphPathMap.existingMetricsForGlyph(glyph);
700 }
701 
<span class="line-added">702 void Font::setFontFaceData(RefPtr&lt;SharedBuffer&gt;&amp;&amp; fontFaceData)</span>
<span class="line-added">703 {</span>
<span class="line-added">704     m_fontFaceData = WTFMove(fontFaceData);</span>
<span class="line-added">705 }</span>
<span class="line-added">706 </span>
<span class="line-added">707 FontHandle::FontHandle(Ref&lt;SharedBuffer&gt;&amp;&amp; fontFaceData, Font::Origin origin, float fontSize, bool syntheticBold, bool syntheticItalic)</span>
<span class="line-added">708 {</span>
<span class="line-added">709     bool wrapping;</span>
<span class="line-added">710     auto customFontData = CachedFont::createCustomFontData(fontFaceData.get(), { }, wrapping);</span>
<span class="line-added">711     FontDescription description;</span>
<span class="line-added">712     description.setComputedSize(fontSize);</span>
<span class="line-added">713     font = Font::create(CachedFont::platformDataFromCustomData(*customFontData, description, syntheticBold, syntheticItalic, { }, { }), origin);</span>
<span class="line-added">714 }</span>
<span class="line-added">715 </span>
716 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FloatSize.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Font.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
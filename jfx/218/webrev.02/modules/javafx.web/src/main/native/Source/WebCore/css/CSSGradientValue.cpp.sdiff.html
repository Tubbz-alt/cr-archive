<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSFontVariationValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSGradientValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CSSGradientValue.h&quot;
  28 
  29 #include &quot;CSSCalculationValue.h&quot;
  30 #include &quot;CSSToLengthConversionData.h&quot;
  31 #include &quot;CSSValueKeywords.h&quot;
  32 #include &quot;FloatSize.h&quot;
  33 #include &quot;Gradient.h&quot;
  34 #include &quot;GradientImage.h&quot;
  35 #include &quot;NodeRenderStyle.h&quot;
  36 #include &quot;Pair.h&quot;
  37 #include &quot;RenderElement.h&quot;
  38 #include &quot;RenderView.h&quot;
<span class="line-modified">  39 #include &quot;StyleResolver.h&quot;</span>
  40 #include &lt;wtf/text/StringBuilder.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 static inline Ref&lt;Gradient&gt; createGradient(CSSGradientValue&amp; value, RenderElement&amp; renderer, FloatSize size)
  45 {
  46     if (is&lt;CSSLinearGradientValue&gt;(value))
  47         return downcast&lt;CSSLinearGradientValue&gt;(value).createGradient(renderer, size);
  48     if (is&lt;CSSRadialGradientValue&gt;(value))
  49         return downcast&lt;CSSRadialGradientValue&gt;(value).createGradient(renderer, size);
  50     return downcast&lt;CSSConicGradientValue&gt;(value).createGradient(renderer, size);
  51 }
  52 
  53 RefPtr&lt;Image&gt; CSSGradientValue::image(RenderElement&amp; renderer, const FloatSize&amp; size)
  54 {
  55     if (size.isEmpty())
  56         return nullptr;
  57     bool cacheable = isCacheable() &amp;&amp; !renderer.style().hasAppleColorFilter();
  58     if (cacheable) {
  59         if (!clients().contains(&amp;renderer))
  60             return nullptr;
  61         if (auto* result = cachedImageForSize(size))
  62             return result;
  63     }
  64     auto newImage = GradientImage::create(createGradient(*this, renderer, size), size);
  65     if (cacheable)
  66         saveCachedImageForSize(size, newImage.get());
  67     return newImage;
  68 }
  69 
  70 // Should only ever be called for deprecated gradients.
  71 static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  72 {
<span class="line-modified">  73     double aVal = a.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
<span class="line-modified">  74     double bVal = b.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
  75 
  76     return aVal &lt; bVal;
  77 }
  78 
  79 void CSSGradientValue::sortStopsIfNeeded()
  80 {
  81     ASSERT(m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient);
  82     if (!m_stopsSorted) {
  83         if (m_stops.size())
  84             std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
  85         m_stopsSorted = true;
  86     }
  87 }
  88 
  89 struct GradientStop {
  90     Color color;
  91     float offset { 0 };
  92     bool specified { false };
  93     bool isMidpoint { false };
  94 };
  95 
  96 static inline Ref&lt;CSSGradientValue&gt; clone(CSSGradientValue&amp; value)
  97 {
  98     if (is&lt;CSSLinearGradientValue&gt;(value))
  99         return downcast&lt;CSSLinearGradientValue&gt;(value).clone();
 100     if (is&lt;CSSRadialGradientValue&gt;(value))
 101         return downcast&lt;CSSRadialGradientValue&gt;(value).clone();
 102     ASSERT(is&lt;CSSConicGradientValue&gt;(value));
 103     return downcast&lt;CSSConicGradientValue&gt;(value).clone();
 104 }
 105 
<span class="line-modified"> 106 Ref&lt;CSSGradientValue&gt; CSSGradientValue::gradientWithStylesResolved(const StyleResolver&amp; styleResolver)</span>


















 107 {
 108     bool colorIsDerivedFromElement = false;
 109     for (auto&amp; stop : m_stops) {
<span class="line-modified"> 110         if (!stop.isMidpoint &amp;&amp; styleResolver.colorFromPrimitiveValueIsDerivedFromElement(*stop.m_color)) {</span>
 111             stop.m_colorIsDerivedFromElement = true;
 112             colorIsDerivedFromElement = true;
 113             break;
 114         }
 115     }
 116     auto result = colorIsDerivedFromElement ? clone(*this) : makeRef(*this);
<span class="line-modified"> 117     for (auto&amp; stop : result-&gt;m_stops) {</span>
<span class="line-modified"> 118         if (!stop.isMidpoint)</span>
<span class="line-modified"> 119             stop.m_resolvedColor = styleResolver.colorFromPrimitiveValue(*stop.m_color);</span>
<span class="line-removed"> 120     }</span>
 121     return result;
 122 }
 123 








 124 class LinearGradientAdapter {
 125 public:
 126     explicit LinearGradientAdapter(Gradient::LinearData&amp; data)
 127         : m_data(data)
 128     {
 129     }
 130 
 131     float gradientLength() const
 132     {
 133         auto gradientSize = m_data.point0 - m_data.point1;
 134         return gradientSize.diagonalLength();
 135     }
 136     float maxExtent(float, float) const { return 1; }
 137 
 138     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 139     {
 140         float firstOffset = stops.first().offset;
 141         float lastOffset = stops.last().offset;
 142         if (firstOffset != lastOffset) {
 143             float scale = lastOffset - firstOffset;
</pre>
<hr />
<pre>
 292                 // All stops are above 1; just clamp them.
 293                 for (size_t i = lastOneOrLessIndex; i &lt; numStops; ++i)
 294                     stops[i].offset = 1;
 295             }
 296         }
 297     }
 298 };
 299 
 300 template&lt;typename GradientAdapter&gt;
 301 Gradient::ColorStopVector CSSGradientValue::computeStops(GradientAdapter&amp; gradientAdapter, const CSSToLengthConversionData&amp; conversionData, const RenderStyle&amp; style, float maxLengthForRepeat)
 302 {
 303     if (m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient) {
 304         sortStopsIfNeeded();
 305 
 306         Gradient::ColorStopVector result;
 307         result.reserveInitialCapacity(m_stops.size());
 308 
 309         for (auto&amp; stop : m_stops) {
 310             float offset;
 311             if (stop.m_position-&gt;isPercentage())
<span class="line-modified"> 312                 offset = stop.m_position-&gt;floatValue(CSSPrimitiveValue::CSS_PERCENTAGE) / 100;</span>
 313             else
<span class="line-modified"> 314                 offset = stop.m_position-&gt;floatValue(CSSPrimitiveValue::CSS_NUMBER);</span>
 315 
 316             Color color = stop.m_resolvedColor;
 317             if (style.hasAppleColorFilter())
 318                 style.appleColorFilter().transformColor(color);
 319             result.uncheckedAppend({ offset, color });
 320         }
 321 
 322         return result;
 323     }
 324 
 325     size_t numStops = m_stops.size();
 326     Vector&lt;GradientStop&gt; stops(numStops);
 327 
 328     float gradientLength = gradientAdapter.gradientLength();
 329 
 330     for (size_t i = 0; i &lt; numStops; ++i) {
 331         auto&amp; stop = m_stops[i];
 332 
 333         stops[i].isMidpoint = stop.isMidpoint;
 334 
 335         Color color = stop.m_resolvedColor;
 336         if (style.hasAppleColorFilter())
 337             style.appleColorFilter().transformColor(color);
 338 
 339         stops[i].color = color;
 340 
 341         if (stop.m_position) {
 342             auto&amp; positionValue = *stop.m_position;
 343             if (positionValue.isPercentage())
<span class="line-modified"> 344                 stops[i].offset = positionValue.floatValue(CSSPrimitiveValue::CSS_PERCENTAGE) / 100;</span>
 345             else if (positionValue.isLength() || positionValue.isViewportPercentageLength() || positionValue.isCalculatedPercentageWithLength()) {
 346                 float length;
 347                 if (positionValue.isLength())
 348                     length = positionValue.computeLength&lt;float&gt;(conversionData);
 349                 else {
 350                     Ref&lt;CalculationValue&gt; calculationValue { positionValue.cssCalcValue()-&gt;createCalculationValue(conversionData) };
 351                     length = calculationValue-&gt;evaluate(gradientLength);
 352                 }
 353                 stops[i].offset = (gradientLength &gt; 0) ? length / gradientLength : 0;
 354             } else if (positionValue.isAngle())
<span class="line-modified"> 355                 stops[i].offset = positionValue.floatValue(CSSPrimitiveValue::CSS_DEG) / 360;</span>
 356             else {
 357                 ASSERT_NOT_REACHED();
 358                 stops[i].offset = 0;
 359             }
 360             stops[i].specified = true;
 361         } else {
 362             // If the first color-stop does not have a position, its position defaults to 0%.
 363             // If the last color-stop does not have a position, its position defaults to 100%.
 364             if (!i) {
 365                 stops[i].offset = 0;
 366                 stops[i].specified = true;
 367             } else if (numStops &gt; 1 &amp;&amp; i == numStops - 1) {
 368                 stops[i].offset = 1;
 369                 stops[i].specified = true;
 370             }
 371         }
 372 
 373         // If a color-stop has a position that is less than the specified position of any
 374         // color-stop before it in the list, its position is changed to be equal to the
 375         // largest specified position of any color-stop before it.
</pre>
<hr />
<pre>
 652 {
 653     bool hasColorFilter = renderer.style().hasAppleColorFilter();
 654 
 655     for (auto&amp; stop : m_stops) {
 656         if (hasColorFilter) {
 657             Color stopColor = stop.m_resolvedColor;
 658             renderer.style().appleColorFilter().transformColor(stopColor);
 659             if (!stopColor.isOpaque())
 660                 return false;
 661         }
 662 
 663         if (!stop.m_resolvedColor.isOpaque())
 664             return false;
 665     }
 666     return true;
 667 }
 668 
 669 static void appendGradientStops(StringBuilder&amp; builder, const Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops)
 670 {
 671     for (auto&amp; stop : stops) {
<span class="line-modified"> 672         double position = stop.m_position-&gt;doubleValue(CSSPrimitiveValue::CSS_NUMBER);</span>
 673         if (!position)
 674             builder.append(&quot;, from(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 675         else if (position == 1)
 676             builder.append(&quot;, to(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 677         else
<span class="line-modified"> 678             builder.append(&quot;, color-stop(&quot;, FormattedNumber::fixedPrecision(position), &quot;, &quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>












 679     }
 680 }
 681 
 682 String CSSLinearGradientValue::customCSSText() const
 683 {
 684     StringBuilder result;
 685     if (m_gradientType == CSSDeprecatedLinearGradient) {
 686         result.append(&quot;-webkit-gradient(linear, &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText(), &quot;, &quot;, m_secondX-&gt;cssText(), &#39; &#39;, m_secondY-&gt;cssText());
 687         appendGradientStops(result, m_stops);
 688     } else if (m_gradientType == CSSPrefixedLinearGradient) {
 689         if (m_repeating)
 690             result.appendLiteral(&quot;-webkit-repeating-linear-gradient(&quot;);
 691         else
 692             result.appendLiteral(&quot;-webkit-linear-gradient(&quot;);
 693 
 694         if (m_angle)
 695             result.append(m_angle-&gt;cssText());
 696         else {
 697             if (m_firstX &amp;&amp; m_firstY)
 698                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 699             else if (m_firstX)
 700                 result.append(m_firstX-&gt;cssText());
 701             else if (m_firstY)
 702                 result.append(m_firstY-&gt;cssText());
 703         }
 704 
 705         for (auto&amp; stop : m_stops) {
<span class="line-modified"> 706             result.append(&quot;, &quot;, stop.m_color-&gt;cssText());</span>
<span class="line-modified"> 707             if (stop.m_position)</span>
<span class="line-removed"> 708                 result.append(&#39; &#39;, stop.m_position-&gt;cssText());</span>
 709         }
 710     } else {
 711         if (m_repeating)
 712             result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
 713         else
 714             result.appendLiteral(&quot;linear-gradient(&quot;);
 715 
 716         bool wroteSomething = false;
 717 
 718         if (m_angle &amp;&amp; m_angle-&gt;computeDegrees() != 180) {
 719             result.append(m_angle-&gt;cssText());
 720             wroteSomething = true;
 721         } else if ((m_firstX || m_firstY) &amp;&amp; !(!m_firstX &amp;&amp; m_firstY &amp;&amp; m_firstY-&gt;valueID() == CSSValueBottom)) {
 722             result.appendLiteral(&quot;to &quot;);
 723             if (m_firstX &amp;&amp; m_firstY)
 724                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 725             else if (m_firstX)
 726                 result.append(m_firstX-&gt;cssText());
 727             else
 728                 result.append(m_firstY-&gt;cssText());
 729             wroteSomething = true;
 730         }
 731 
 732         if (wroteSomething)
 733             result.appendLiteral(&quot;, &quot;);
 734 
 735         bool wroteFirstStop = false;
 736         for (auto&amp; stop : m_stops) {
 737             if (wroteFirstStop)
 738                 result.appendLiteral(&quot;, &quot;);
 739             wroteFirstStop = true;
<span class="line-modified"> 740             if (!stop.isMidpoint)</span>
<span class="line-removed"> 741                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed"> 742             if (stop.m_position) {</span>
<span class="line-removed"> 743                 if (!stop.isMidpoint)</span>
<span class="line-removed"> 744                     result.append(&#39; &#39;);</span>
<span class="line-removed"> 745                 result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed"> 746             }</span>
 747         }
 748     }
 749 
 750     result.append(&#39;)&#39;);
 751     return result.toString();
 752 }
 753 
 754 // Compute the endpoints so that a gradient of the given angle covers a box of the given size.
 755 static void endPointsFromAngle(float angleDeg, const FloatSize&amp; size, FloatPoint&amp; firstPoint, FloatPoint&amp; secondPoint, CSSGradientType type)
 756 {
 757     // Prefixed gradients use &quot;polar coordinate&quot; angles, rather than &quot;bearing&quot; angles.
 758     if (type == CSSPrefixedLinearGradient)
 759         angleDeg = 90 - angleDeg;
 760 
 761     angleDeg = fmodf(angleDeg, 360);
 762     if (angleDeg &lt; 0)
 763         angleDeg += 360;
 764 
 765     if (!angleDeg) {
 766         firstPoint.set(0, size.height());
</pre>
<hr />
<pre>
 811     float c = endCorner.y() - perpendicularSlope * endCorner.x();
 812     float endX = c / (slope - perpendicularSlope);
 813     float endY = perpendicularSlope * endX + c;
 814 
 815     // We computed the end point, so set the second point,
 816     // taking into account the moved origin and the fact that we&#39;re in drawing space (+y = down).
 817     secondPoint.set(halfWidth + endX, halfHeight - endY);
 818     // Reflect around the center for the start point.
 819     firstPoint.set(halfWidth - endX, halfHeight + endY);
 820 }
 821 
 822 Ref&lt;Gradient&gt; CSSLinearGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
 823 {
 824     ASSERT(!size.isEmpty());
 825 
 826     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
 827 
 828     FloatPoint firstPoint;
 829     FloatPoint secondPoint;
 830     if (m_angle) {
<span class="line-modified"> 831         float angle = m_angle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG);</span>
 832         endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
 833     } else {
 834         switch (m_gradientType) {
 835         case CSSDeprecatedLinearGradient:
 836             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 837             if (m_secondX || m_secondY)
 838                 secondPoint = computeEndPoint(m_secondX.get(), m_secondY.get(), conversionData, size);
 839             else {
 840                 if (m_firstX)
 841                     secondPoint.setX(size.width() - firstPoint.x());
 842                 if (m_firstY)
 843                     secondPoint.setY(size.height() - firstPoint.y());
 844             }
 845             break;
 846         case CSSPrefixedLinearGradient:
 847             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 848             if (m_firstX)
 849                 secondPoint.setX(size.width() - firstPoint.x());
 850             if (m_firstY)
 851                 secondPoint.setY(size.height() - firstPoint.y());
</pre>
<hr />
<pre>
 878 
 879     Gradient::LinearData data { firstPoint, secondPoint };
 880     LinearGradientAdapter adapter { data };
 881     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
 882 
 883     auto gradient = Gradient::create(WTFMove(data));
 884     gradient-&gt;setSortedColorStops(WTFMove(stops));
 885     return gradient;
 886 }
 887 
 888 bool CSSLinearGradientValue::equals(const CSSLinearGradientValue&amp; other) const
 889 {
 890     if (m_gradientType == CSSDeprecatedLinearGradient)
 891         return other.m_gradientType == m_gradientType
 892             &amp;&amp; compareCSSValuePtr(m_firstX, other.m_firstX)
 893             &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
 894             &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
 895             &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
 896             &amp;&amp; m_stops == other.m_stops;
 897 



 898     if (m_repeating != other.m_repeating)
 899         return false;
 900 
 901     if (m_angle)
 902         return compareCSSValuePtr(m_angle, other.m_angle) &amp;&amp; m_stops == other.m_stops;
 903 
 904     if (other.m_angle)
 905         return false;
 906 
 907     bool equalXandY = false;
 908     if (m_firstX &amp;&amp; m_firstY)
 909         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
 910     else if (m_firstX)
 911         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
 912     else if (m_firstY)
 913         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
 914     else
 915         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
 916 
 917     return equalXandY &amp;&amp; m_stops == other.m_stops;
</pre>
<hr />
<pre>
 937             result.append(m_firstX-&gt;cssText());
 938         else if (m_firstY)
 939             result.append(m_firstY-&gt;cssText());
 940         else
 941             result.appendLiteral(&quot;center&quot;);
 942 
 943         if (m_shape || m_sizingBehavior) {
 944             result.appendLiteral(&quot;, &quot;);
 945             if (m_shape)
 946                 result.append(m_shape-&gt;cssText(), &#39; &#39;);
 947             else
 948                 result.appendLiteral(&quot;ellipse &quot;);
 949             if (m_sizingBehavior)
 950                 result.append(m_sizingBehavior-&gt;cssText());
 951             else
 952                 result.appendLiteral(&quot;cover&quot;);
 953         } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)
 954             result.append(&quot;, &quot;, m_endHorizontalSize-&gt;cssText(), &#39; &#39;, m_endVerticalSize-&gt;cssText());
 955 
 956         for (auto&amp; stop : m_stops) {
<span class="line-modified"> 957             result.append(&quot;, &quot;, stop.m_color-&gt;cssText());</span>
<span class="line-modified"> 958             if (stop.m_position)</span>
<span class="line-removed"> 959                 result.append(&#39; &#39;, stop.m_position-&gt;cssText());</span>
 960         }
 961     } else {
 962         if (m_repeating)
 963             result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
 964         else
 965             result.appendLiteral(&quot;radial-gradient(&quot;);
 966 
 967         bool wroteSomething = false;
 968 
 969         // The only ambiguous case that needs an explicit shape to be provided
 970         // is when a sizing keyword is used (or all sizing is omitted).
 971         if (m_shape &amp;&amp; m_shape-&gt;valueID() != CSSValueEllipse &amp;&amp; (m_sizingBehavior || (!m_sizingBehavior &amp;&amp; !m_endHorizontalSize))) {
 972             result.appendLiteral(&quot;circle&quot;);
 973             wroteSomething = true;
 974         }
 975 
 976         if (m_sizingBehavior &amp;&amp; m_sizingBehavior-&gt;valueID() != CSSValueFarthestCorner) {
 977             if (wroteSomething)
 978                 result.append(&#39; &#39;);
 979             result.append(m_sizingBehavior-&gt;cssText());
</pre>
<hr />
<pre>
 986                 result.append(&#39; &#39;, m_endVerticalSize-&gt;cssText());
 987             wroteSomething = true;
 988         }
 989 
 990         if (m_firstX || m_firstY) {
 991             if (wroteSomething)
 992                 result.append(&#39; &#39;);
 993             result.appendLiteral(&quot;at &quot;);
 994             if (m_firstX &amp;&amp; m_firstY)
 995                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 996             else if (m_firstX)
 997                 result.append(m_firstX-&gt;cssText());
 998             else
 999                 result.append(m_firstY-&gt;cssText());
1000             wroteSomething = true;
1001         }
1002 
1003         if (wroteSomething)
1004             result.appendLiteral(&quot;, &quot;);
1005 
<span class="line-modified">1006         for (unsigned i = 0; i &lt; m_stops.size(); i++) {</span>
<span class="line-modified">1007             const CSSGradientColorStop&amp; stop = m_stops[i];</span>
<span class="line-modified">1008             if (i)</span>
1009                 result.appendLiteral(&quot;, &quot;);
<span class="line-modified">1010             if (!stop.isMidpoint)</span>
<span class="line-modified">1011                 result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed">1012             if (stop.m_position) {</span>
<span class="line-removed">1013                 if (!stop.isMidpoint)</span>
<span class="line-removed">1014                     result.append(&#39; &#39;);</span>
<span class="line-removed">1015                 result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed">1016             }</span>
1017         }
<span class="line-removed">1018 </span>
1019     }
1020 
1021     result.append(&#39;)&#39;);
1022     return result.toString();
1023 }
1024 
1025 float CSSRadialGradientValue::resolveRadius(CSSPrimitiveValue&amp; radius, const CSSToLengthConversionData&amp; conversionData, float* widthOrHeight)
1026 {
1027     float result = 0;
1028     if (radius.isNumber())
1029         result = radius.floatValue() * conversionData.zoom();
1030     else if (widthOrHeight &amp;&amp; radius.isPercentage())
1031         result = *widthOrHeight * radius.floatValue() / 100;
1032     else
1033         result = radius.computeLength&lt;float&gt;(conversionData);
1034     return result;
1035 }
1036 
1037 static float distanceToClosestCorner(const FloatPoint&amp; p, const FloatSize&amp; size, FloatPoint&amp; corner)
1038 {
</pre>
<hr />
<pre>
1090 
1091     if (bottomLeftDistance &gt; maxDistance) {
1092         maxDistance = bottomLeftDistance;
1093         corner = bottomLeft;
1094     }
1095 
1096     if (bottomRightDistance &gt; maxDistance) {
1097         maxDistance = bottomRightDistance;
1098         corner = bottomRight;
1099     }
1100     return maxDistance;
1101 }
1102 
1103 // Compute horizontal radius of ellipse with center at 0,0 which passes through p, and has
1104 // width/height given by aspectRatio.
1105 static inline float horizontalEllipseRadius(const FloatSize&amp; p, float aspectRatio)
1106 {
1107     // x^2/a^2 + y^2/b^2 = 1
1108     // a/b = aspectRatio, b = a/aspectRatio
1109     // a = sqrt(x^2 + y^2/(1/r^2))
<span class="line-modified">1110     return sqrtf(p.width() * p.width() + (p.height() * p.height()) / (1 / (aspectRatio * aspectRatio)));</span>
1111 }
1112 
1113 // FIXME: share code with the linear version
1114 Ref&lt;Gradient&gt; CSSRadialGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
1115 {
1116     ASSERT(!size.isEmpty());
1117 
1118     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
1119 
1120     FloatPoint firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
1121     if (!m_firstX)
1122         firstPoint.setX(size.width() / 2);
1123     if (!m_firstY)
1124         firstPoint.setY(size.height() / 2);
1125 
1126     FloatPoint secondPoint = computeEndPoint(m_secondX.get(), m_secondY.get(), conversionData, size);
1127     if (!m_secondX)
1128         secondPoint.setX(size.width() / 2);
1129     if (!m_secondY)
1130         secondPoint.setY(size.height() / 2);
</pre>
<hr />
<pre>
1249     RadialGradientAdapter adapter { data };
1250     auto stops = computeStops(adapter, conversionData, renderer.style(), maxExtent);
1251 
1252     auto gradient = Gradient::create(WTFMove(data));
1253     gradient-&gt;setSortedColorStops(WTFMove(stops));
1254     return gradient;
1255 }
1256 
1257 bool CSSRadialGradientValue::equals(const CSSRadialGradientValue&amp; other) const
1258 {
1259     if (m_gradientType == CSSDeprecatedRadialGradient)
1260         return other.m_gradientType == m_gradientType
1261             &amp;&amp; compareCSSValuePtr(m_firstX, other.m_firstX)
1262             &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
1263             &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
1264             &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
1265             &amp;&amp; compareCSSValuePtr(m_firstRadius, other.m_firstRadius)
1266             &amp;&amp; compareCSSValuePtr(m_secondRadius, other.m_secondRadius)
1267             &amp;&amp; m_stops == other.m_stops;
1268 



1269     if (m_repeating != other.m_repeating)
1270         return false;
1271 
1272     bool equalXandY = false;
1273     if (m_firstX &amp;&amp; m_firstY)
1274         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
1275     else if (m_firstX)
1276         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
1277     else if (m_firstY)
1278         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
1279     else
1280         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
1281 
1282     if (!equalXandY)
1283         return false;
1284 
1285     bool equalShape = true;
1286     bool equalSizingBehavior = true;
1287     bool equalHorizontalAndVerticalSize = true;
1288 
</pre>
<hr />
<pre>
1315     if (m_angle) {
1316         result.append(&quot;from &quot;, m_angle-&gt;cssText());
1317         wroteSomething = true;
1318     }
1319 
1320     if (m_firstX &amp;&amp; m_firstY) {
1321         if (wroteSomething)
1322             result.append(&#39; &#39;);
1323         result.append(&quot;at &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
1324         wroteSomething = true;
1325     }
1326 
1327     if (wroteSomething)
1328         result.appendLiteral(&quot;, &quot;);
1329 
1330     bool wroteFirstStop = false;
1331     for (auto&amp; stop : m_stops) {
1332         if (wroteFirstStop)
1333             result.appendLiteral(&quot;, &quot;);
1334         wroteFirstStop = true;
<span class="line-modified">1335         if (!stop.isMidpoint)</span>
<span class="line-removed">1336             result.append(stop.m_color-&gt;cssText());</span>
<span class="line-removed">1337         if (stop.m_position) {</span>
<span class="line-removed">1338             if (!stop.isMidpoint)</span>
<span class="line-removed">1339                 result.append(&#39; &#39;);</span>
<span class="line-removed">1340             result.append(stop.m_position-&gt;cssText());</span>
<span class="line-removed">1341         }</span>
1342     }
1343 
1344     result.append(&#39;)&#39;);
1345     return result.toString();
1346 }
1347 
1348 Ref&lt;Gradient&gt; CSSConicGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
1349 {
1350     ASSERT(!size.isEmpty());
1351 
1352     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
1353 
1354     FloatPoint centerPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
1355     if (!m_firstX)
1356         centerPoint.setX(size.width() / 2);
1357     if (!m_firstY)
1358         centerPoint.setY(size.height() / 2);
1359 
1360     float angleRadians = 0;
1361     if (m_angle)
<span class="line-modified">1362         angleRadians = m_angle-&gt;floatValue(CSSPrimitiveValue::CSS_RAD);</span>
1363 
1364     Gradient::ConicData data { centerPoint, angleRadians };
1365     ConicGradientAdapter adapter;
1366     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
1367 
1368     auto gradient = Gradient::create(WTFMove(data));
1369     gradient-&gt;setSortedColorStops(WTFMove(stops));
1370     return gradient;
1371 }
1372 
1373 bool CSSConicGradientValue::equals(const CSSConicGradientValue&amp; other) const
1374 {
1375     if (m_repeating != other.m_repeating)
1376         return false;
1377 
1378     if (!compareCSSValuePtr(m_angle, other.m_angle))
1379         return false;
1380 
1381     bool equalXandY = false;
1382     if (m_firstX &amp;&amp; m_firstY)
</pre>
</td>
<td>
<hr />
<pre>
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CSSGradientValue.h&quot;
  28 
  29 #include &quot;CSSCalculationValue.h&quot;
  30 #include &quot;CSSToLengthConversionData.h&quot;
  31 #include &quot;CSSValueKeywords.h&quot;
  32 #include &quot;FloatSize.h&quot;
  33 #include &quot;Gradient.h&quot;
  34 #include &quot;GradientImage.h&quot;
  35 #include &quot;NodeRenderStyle.h&quot;
  36 #include &quot;Pair.h&quot;
  37 #include &quot;RenderElement.h&quot;
  38 #include &quot;RenderView.h&quot;
<span class="line-modified">  39 #include &quot;StyleBuilderState.h&quot;</span>
  40 #include &lt;wtf/text/StringBuilder.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 static inline Ref&lt;Gradient&gt; createGradient(CSSGradientValue&amp; value, RenderElement&amp; renderer, FloatSize size)
  45 {
  46     if (is&lt;CSSLinearGradientValue&gt;(value))
  47         return downcast&lt;CSSLinearGradientValue&gt;(value).createGradient(renderer, size);
  48     if (is&lt;CSSRadialGradientValue&gt;(value))
  49         return downcast&lt;CSSRadialGradientValue&gt;(value).createGradient(renderer, size);
  50     return downcast&lt;CSSConicGradientValue&gt;(value).createGradient(renderer, size);
  51 }
  52 
  53 RefPtr&lt;Image&gt; CSSGradientValue::image(RenderElement&amp; renderer, const FloatSize&amp; size)
  54 {
  55     if (size.isEmpty())
  56         return nullptr;
  57     bool cacheable = isCacheable() &amp;&amp; !renderer.style().hasAppleColorFilter();
  58     if (cacheable) {
  59         if (!clients().contains(&amp;renderer))
  60             return nullptr;
  61         if (auto* result = cachedImageForSize(size))
  62             return result;
  63     }
  64     auto newImage = GradientImage::create(createGradient(*this, renderer, size), size);
  65     if (cacheable)
  66         saveCachedImageForSize(size, newImage.get());
  67     return newImage;
  68 }
  69 
  70 // Should only ever be called for deprecated gradients.
  71 static inline bool compareStops(const CSSGradientColorStop&amp; a, const CSSGradientColorStop&amp; b)
  72 {
<span class="line-modified">  73     double aVal = a.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
<span class="line-modified">  74     double bVal = b.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
  75 
  76     return aVal &lt; bVal;
  77 }
  78 
  79 void CSSGradientValue::sortStopsIfNeeded()
  80 {
  81     ASSERT(m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient);
  82     if (!m_stopsSorted) {
  83         if (m_stops.size())
  84             std::stable_sort(m_stops.begin(), m_stops.end(), compareStops);
  85         m_stopsSorted = true;
  86     }
  87 }
  88 
  89 struct GradientStop {
  90     Color color;
  91     float offset { 0 };
  92     bool specified { false };
  93     bool isMidpoint { false };
  94 };
  95 
  96 static inline Ref&lt;CSSGradientValue&gt; clone(CSSGradientValue&amp; value)
  97 {
  98     if (is&lt;CSSLinearGradientValue&gt;(value))
  99         return downcast&lt;CSSLinearGradientValue&gt;(value).clone();
 100     if (is&lt;CSSRadialGradientValue&gt;(value))
 101         return downcast&lt;CSSRadialGradientValue&gt;(value).clone();
 102     ASSERT(is&lt;CSSConicGradientValue&gt;(value));
 103     return downcast&lt;CSSConicGradientValue&gt;(value).clone();
 104 }
 105 
<span class="line-modified"> 106 template&lt;typename Function&gt;</span>
<span class="line-added"> 107 void resolveStopColors(Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops, Function&amp;&amp; colorResolveFunction)</span>
<span class="line-added"> 108 {</span>
<span class="line-added"> 109     for (size_t i = 0; i &lt; stops.size(); ++i) {</span>
<span class="line-added"> 110         auto&amp; stop = stops[i];</span>
<span class="line-added"> 111         if (stop.isMidpoint)</span>
<span class="line-added"> 112             continue;</span>
<span class="line-added"> 113         if (stop.m_color)</span>
<span class="line-added"> 114             stop.m_resolvedColor = colorResolveFunction(*stop.m_color);</span>
<span class="line-added"> 115         else if (i) {</span>
<span class="line-added"> 116             auto&amp; previousStop = stops[i - 1];</span>
<span class="line-added"> 117             ASSERT(previousStop.m_color);</span>
<span class="line-added"> 118             stop.m_color = previousStop.m_color;</span>
<span class="line-added"> 119             stop.m_resolvedColor = previousStop.m_resolvedColor;</span>
<span class="line-added"> 120         }</span>
<span class="line-added"> 121     }</span>
<span class="line-added"> 122 }</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124 Ref&lt;CSSGradientValue&gt; CSSGradientValue::gradientWithStylesResolved(Style::BuilderState&amp; builderState)</span>
 125 {
 126     bool colorIsDerivedFromElement = false;
 127     for (auto&amp; stop : m_stops) {
<span class="line-modified"> 128         if (!stop.isMidpoint &amp;&amp; stop.m_color &amp;&amp; Style::BuilderState::isColorFromPrimitiveValueDerivedFromElement(*stop.m_color)) {</span>
 129             stop.m_colorIsDerivedFromElement = true;
 130             colorIsDerivedFromElement = true;
 131             break;
 132         }
 133     }
 134     auto result = colorIsDerivedFromElement ? clone(*this) : makeRef(*this);
<span class="line-modified"> 135     resolveStopColors(result-&gt;m_stops, [&amp;](const CSSPrimitiveValue&amp; colorValue) {</span>
<span class="line-modified"> 136         return builderState.colorFromPrimitiveValue(colorValue);</span>
<span class="line-modified"> 137     });</span>

 138     return result;
 139 }
 140 
<span class="line-added"> 141 void CSSGradientValue::resolveRGBColors()</span>
<span class="line-added"> 142 {</span>
<span class="line-added"> 143     resolveStopColors(m_stops, [&amp;](const CSSPrimitiveValue&amp; colorValue) {</span>
<span class="line-added"> 144         ASSERT(colorValue.isRGBColor());</span>
<span class="line-added"> 145         return colorValue.color();</span>
<span class="line-added"> 146     });</span>
<span class="line-added"> 147 }</span>
<span class="line-added"> 148 </span>
 149 class LinearGradientAdapter {
 150 public:
 151     explicit LinearGradientAdapter(Gradient::LinearData&amp; data)
 152         : m_data(data)
 153     {
 154     }
 155 
 156     float gradientLength() const
 157     {
 158         auto gradientSize = m_data.point0 - m_data.point1;
 159         return gradientSize.diagonalLength();
 160     }
 161     float maxExtent(float, float) const { return 1; }
 162 
 163     void normalizeStopsAndEndpointsOutsideRange(Vector&lt;GradientStop&gt;&amp; stops)
 164     {
 165         float firstOffset = stops.first().offset;
 166         float lastOffset = stops.last().offset;
 167         if (firstOffset != lastOffset) {
 168             float scale = lastOffset - firstOffset;
</pre>
<hr />
<pre>
 317                 // All stops are above 1; just clamp them.
 318                 for (size_t i = lastOneOrLessIndex; i &lt; numStops; ++i)
 319                     stops[i].offset = 1;
 320             }
 321         }
 322     }
 323 };
 324 
 325 template&lt;typename GradientAdapter&gt;
 326 Gradient::ColorStopVector CSSGradientValue::computeStops(GradientAdapter&amp; gradientAdapter, const CSSToLengthConversionData&amp; conversionData, const RenderStyle&amp; style, float maxLengthForRepeat)
 327 {
 328     if (m_gradientType == CSSDeprecatedLinearGradient || m_gradientType == CSSDeprecatedRadialGradient) {
 329         sortStopsIfNeeded();
 330 
 331         Gradient::ColorStopVector result;
 332         result.reserveInitialCapacity(m_stops.size());
 333 
 334         for (auto&amp; stop : m_stops) {
 335             float offset;
 336             if (stop.m_position-&gt;isPercentage())
<span class="line-modified"> 337                 offset = stop.m_position-&gt;floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;</span>
 338             else
<span class="line-modified"> 339                 offset = stop.m_position-&gt;floatValue(CSSUnitType::CSS_NUMBER);</span>
 340 
 341             Color color = stop.m_resolvedColor;
 342             if (style.hasAppleColorFilter())
 343                 style.appleColorFilter().transformColor(color);
 344             result.uncheckedAppend({ offset, color });
 345         }
 346 
 347         return result;
 348     }
 349 
 350     size_t numStops = m_stops.size();
 351     Vector&lt;GradientStop&gt; stops(numStops);
 352 
 353     float gradientLength = gradientAdapter.gradientLength();
 354 
 355     for (size_t i = 0; i &lt; numStops; ++i) {
 356         auto&amp; stop = m_stops[i];
 357 
 358         stops[i].isMidpoint = stop.isMidpoint;
 359 
 360         Color color = stop.m_resolvedColor;
 361         if (style.hasAppleColorFilter())
 362             style.appleColorFilter().transformColor(color);
 363 
 364         stops[i].color = color;
 365 
 366         if (stop.m_position) {
 367             auto&amp; positionValue = *stop.m_position;
 368             if (positionValue.isPercentage())
<span class="line-modified"> 369                 stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;</span>
 370             else if (positionValue.isLength() || positionValue.isViewportPercentageLength() || positionValue.isCalculatedPercentageWithLength()) {
 371                 float length;
 372                 if (positionValue.isLength())
 373                     length = positionValue.computeLength&lt;float&gt;(conversionData);
 374                 else {
 375                     Ref&lt;CalculationValue&gt; calculationValue { positionValue.cssCalcValue()-&gt;createCalculationValue(conversionData) };
 376                     length = calculationValue-&gt;evaluate(gradientLength);
 377                 }
 378                 stops[i].offset = (gradientLength &gt; 0) ? length / gradientLength : 0;
 379             } else if (positionValue.isAngle())
<span class="line-modified"> 380                 stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_DEG) / 360;</span>
 381             else {
 382                 ASSERT_NOT_REACHED();
 383                 stops[i].offset = 0;
 384             }
 385             stops[i].specified = true;
 386         } else {
 387             // If the first color-stop does not have a position, its position defaults to 0%.
 388             // If the last color-stop does not have a position, its position defaults to 100%.
 389             if (!i) {
 390                 stops[i].offset = 0;
 391                 stops[i].specified = true;
 392             } else if (numStops &gt; 1 &amp;&amp; i == numStops - 1) {
 393                 stops[i].offset = 1;
 394                 stops[i].specified = true;
 395             }
 396         }
 397 
 398         // If a color-stop has a position that is less than the specified position of any
 399         // color-stop before it in the list, its position is changed to be equal to the
 400         // largest specified position of any color-stop before it.
</pre>
<hr />
<pre>
 677 {
 678     bool hasColorFilter = renderer.style().hasAppleColorFilter();
 679 
 680     for (auto&amp; stop : m_stops) {
 681         if (hasColorFilter) {
 682             Color stopColor = stop.m_resolvedColor;
 683             renderer.style().appleColorFilter().transformColor(stopColor);
 684             if (!stopColor.isOpaque())
 685                 return false;
 686         }
 687 
 688         if (!stop.m_resolvedColor.isOpaque())
 689             return false;
 690     }
 691     return true;
 692 }
 693 
 694 static void appendGradientStops(StringBuilder&amp; builder, const Vector&lt;CSSGradientColorStop, 2&gt;&amp; stops)
 695 {
 696     for (auto&amp; stop : stops) {
<span class="line-modified"> 697         double position = stop.m_position-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
 698         if (!position)
 699             builder.append(&quot;, from(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 700         else if (position == 1)
 701             builder.append(&quot;, to(&quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);
 702         else
<span class="line-modified"> 703             builder.append(&quot;, color-stop(&quot;, position, &quot;, &quot;, stop.m_color-&gt;cssText(), &#39;)&#39;);</span>
<span class="line-added"> 704     }</span>
<span class="line-added"> 705 }</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707 void CSSGradientValue::writeColorStop(StringBuilder&amp; builder, const CSSGradientColorStop&amp; stop) const</span>
<span class="line-added"> 708 {</span>
<span class="line-added"> 709     if (!stop.isMidpoint &amp;&amp; stop.m_color)</span>
<span class="line-added"> 710         builder.append(stop.m_color-&gt;cssText());</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712     if (stop.m_position) {</span>
<span class="line-added"> 713         if (!stop.isMidpoint)</span>
<span class="line-added"> 714             builder.append(&#39; &#39;);</span>
<span class="line-added"> 715         builder.append(stop.m_position-&gt;cssText());</span>
 716     }
 717 }
 718 
 719 String CSSLinearGradientValue::customCSSText() const
 720 {
 721     StringBuilder result;
 722     if (m_gradientType == CSSDeprecatedLinearGradient) {
 723         result.append(&quot;-webkit-gradient(linear, &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText(), &quot;, &quot;, m_secondX-&gt;cssText(), &#39; &#39;, m_secondY-&gt;cssText());
 724         appendGradientStops(result, m_stops);
 725     } else if (m_gradientType == CSSPrefixedLinearGradient) {
 726         if (m_repeating)
 727             result.appendLiteral(&quot;-webkit-repeating-linear-gradient(&quot;);
 728         else
 729             result.appendLiteral(&quot;-webkit-linear-gradient(&quot;);
 730 
 731         if (m_angle)
 732             result.append(m_angle-&gt;cssText());
 733         else {
 734             if (m_firstX &amp;&amp; m_firstY)
 735                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 736             else if (m_firstX)
 737                 result.append(m_firstX-&gt;cssText());
 738             else if (m_firstY)
 739                 result.append(m_firstY-&gt;cssText());
 740         }
 741 
 742         for (auto&amp; stop : m_stops) {
<span class="line-modified"> 743             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-modified"> 744             writeColorStop(result, stop);</span>

 745         }
 746     } else {
 747         if (m_repeating)
 748             result.appendLiteral(&quot;repeating-linear-gradient(&quot;);
 749         else
 750             result.appendLiteral(&quot;linear-gradient(&quot;);
 751 
 752         bool wroteSomething = false;
 753 
 754         if (m_angle &amp;&amp; m_angle-&gt;computeDegrees() != 180) {
 755             result.append(m_angle-&gt;cssText());
 756             wroteSomething = true;
 757         } else if ((m_firstX || m_firstY) &amp;&amp; !(!m_firstX &amp;&amp; m_firstY &amp;&amp; m_firstY-&gt;valueID() == CSSValueBottom)) {
 758             result.appendLiteral(&quot;to &quot;);
 759             if (m_firstX &amp;&amp; m_firstY)
 760                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
 761             else if (m_firstX)
 762                 result.append(m_firstX-&gt;cssText());
 763             else
 764                 result.append(m_firstY-&gt;cssText());
 765             wroteSomething = true;
 766         }
 767 
 768         if (wroteSomething)
 769             result.appendLiteral(&quot;, &quot;);
 770 
 771         bool wroteFirstStop = false;
 772         for (auto&amp; stop : m_stops) {
 773             if (wroteFirstStop)
 774                 result.appendLiteral(&quot;, &quot;);
 775             wroteFirstStop = true;
<span class="line-modified"> 776             writeColorStop(result, stop);</span>






 777         }
 778     }
 779 
 780     result.append(&#39;)&#39;);
 781     return result.toString();
 782 }
 783 
 784 // Compute the endpoints so that a gradient of the given angle covers a box of the given size.
 785 static void endPointsFromAngle(float angleDeg, const FloatSize&amp; size, FloatPoint&amp; firstPoint, FloatPoint&amp; secondPoint, CSSGradientType type)
 786 {
 787     // Prefixed gradients use &quot;polar coordinate&quot; angles, rather than &quot;bearing&quot; angles.
 788     if (type == CSSPrefixedLinearGradient)
 789         angleDeg = 90 - angleDeg;
 790 
 791     angleDeg = fmodf(angleDeg, 360);
 792     if (angleDeg &lt; 0)
 793         angleDeg += 360;
 794 
 795     if (!angleDeg) {
 796         firstPoint.set(0, size.height());
</pre>
<hr />
<pre>
 841     float c = endCorner.y() - perpendicularSlope * endCorner.x();
 842     float endX = c / (slope - perpendicularSlope);
 843     float endY = perpendicularSlope * endX + c;
 844 
 845     // We computed the end point, so set the second point,
 846     // taking into account the moved origin and the fact that we&#39;re in drawing space (+y = down).
 847     secondPoint.set(halfWidth + endX, halfHeight - endY);
 848     // Reflect around the center for the start point.
 849     firstPoint.set(halfWidth - endX, halfHeight + endY);
 850 }
 851 
 852 Ref&lt;Gradient&gt; CSSLinearGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
 853 {
 854     ASSERT(!size.isEmpty());
 855 
 856     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
 857 
 858     FloatPoint firstPoint;
 859     FloatPoint secondPoint;
 860     if (m_angle) {
<span class="line-modified"> 861         float angle = m_angle-&gt;floatValue(CSSUnitType::CSS_DEG);</span>
 862         endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
 863     } else {
 864         switch (m_gradientType) {
 865         case CSSDeprecatedLinearGradient:
 866             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 867             if (m_secondX || m_secondY)
 868                 secondPoint = computeEndPoint(m_secondX.get(), m_secondY.get(), conversionData, size);
 869             else {
 870                 if (m_firstX)
 871                     secondPoint.setX(size.width() - firstPoint.x());
 872                 if (m_firstY)
 873                     secondPoint.setY(size.height() - firstPoint.y());
 874             }
 875             break;
 876         case CSSPrefixedLinearGradient:
 877             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
 878             if (m_firstX)
 879                 secondPoint.setX(size.width() - firstPoint.x());
 880             if (m_firstY)
 881                 secondPoint.setY(size.height() - firstPoint.y());
</pre>
<hr />
<pre>
 908 
 909     Gradient::LinearData data { firstPoint, secondPoint };
 910     LinearGradientAdapter adapter { data };
 911     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
 912 
 913     auto gradient = Gradient::create(WTFMove(data));
 914     gradient-&gt;setSortedColorStops(WTFMove(stops));
 915     return gradient;
 916 }
 917 
 918 bool CSSLinearGradientValue::equals(const CSSLinearGradientValue&amp; other) const
 919 {
 920     if (m_gradientType == CSSDeprecatedLinearGradient)
 921         return other.m_gradientType == m_gradientType
 922             &amp;&amp; compareCSSValuePtr(m_firstX, other.m_firstX)
 923             &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
 924             &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
 925             &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
 926             &amp;&amp; m_stops == other.m_stops;
 927 
<span class="line-added"> 928     if (m_gradientType != other.m_gradientType)</span>
<span class="line-added"> 929         return false;</span>
<span class="line-added"> 930 </span>
 931     if (m_repeating != other.m_repeating)
 932         return false;
 933 
 934     if (m_angle)
 935         return compareCSSValuePtr(m_angle, other.m_angle) &amp;&amp; m_stops == other.m_stops;
 936 
 937     if (other.m_angle)
 938         return false;
 939 
 940     bool equalXandY = false;
 941     if (m_firstX &amp;&amp; m_firstY)
 942         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
 943     else if (m_firstX)
 944         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
 945     else if (m_firstY)
 946         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
 947     else
 948         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
 949 
 950     return equalXandY &amp;&amp; m_stops == other.m_stops;
</pre>
<hr />
<pre>
 970             result.append(m_firstX-&gt;cssText());
 971         else if (m_firstY)
 972             result.append(m_firstY-&gt;cssText());
 973         else
 974             result.appendLiteral(&quot;center&quot;);
 975 
 976         if (m_shape || m_sizingBehavior) {
 977             result.appendLiteral(&quot;, &quot;);
 978             if (m_shape)
 979                 result.append(m_shape-&gt;cssText(), &#39; &#39;);
 980             else
 981                 result.appendLiteral(&quot;ellipse &quot;);
 982             if (m_sizingBehavior)
 983                 result.append(m_sizingBehavior-&gt;cssText());
 984             else
 985                 result.appendLiteral(&quot;cover&quot;);
 986         } else if (m_endHorizontalSize &amp;&amp; m_endVerticalSize)
 987             result.append(&quot;, &quot;, m_endHorizontalSize-&gt;cssText(), &#39; &#39;, m_endVerticalSize-&gt;cssText());
 988 
 989         for (auto&amp; stop : m_stops) {
<span class="line-modified"> 990             result.appendLiteral(&quot;, &quot;);</span>
<span class="line-modified"> 991             writeColorStop(result, stop);</span>

 992         }
 993     } else {
 994         if (m_repeating)
 995             result.appendLiteral(&quot;repeating-radial-gradient(&quot;);
 996         else
 997             result.appendLiteral(&quot;radial-gradient(&quot;);
 998 
 999         bool wroteSomething = false;
1000 
1001         // The only ambiguous case that needs an explicit shape to be provided
1002         // is when a sizing keyword is used (or all sizing is omitted).
1003         if (m_shape &amp;&amp; m_shape-&gt;valueID() != CSSValueEllipse &amp;&amp; (m_sizingBehavior || (!m_sizingBehavior &amp;&amp; !m_endHorizontalSize))) {
1004             result.appendLiteral(&quot;circle&quot;);
1005             wroteSomething = true;
1006         }
1007 
1008         if (m_sizingBehavior &amp;&amp; m_sizingBehavior-&gt;valueID() != CSSValueFarthestCorner) {
1009             if (wroteSomething)
1010                 result.append(&#39; &#39;);
1011             result.append(m_sizingBehavior-&gt;cssText());
</pre>
<hr />
<pre>
1018                 result.append(&#39; &#39;, m_endVerticalSize-&gt;cssText());
1019             wroteSomething = true;
1020         }
1021 
1022         if (m_firstX || m_firstY) {
1023             if (wroteSomething)
1024                 result.append(&#39; &#39;);
1025             result.appendLiteral(&quot;at &quot;);
1026             if (m_firstX &amp;&amp; m_firstY)
1027                 result.append(m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
1028             else if (m_firstX)
1029                 result.append(m_firstX-&gt;cssText());
1030             else
1031                 result.append(m_firstY-&gt;cssText());
1032             wroteSomething = true;
1033         }
1034 
1035         if (wroteSomething)
1036             result.appendLiteral(&quot;, &quot;);
1037 
<span class="line-modified">1038         bool wroteFirstStop = false;</span>
<span class="line-modified">1039         for (auto&amp; stop : m_stops) {</span>
<span class="line-modified">1040             if (wroteFirstStop)</span>
1041                 result.appendLiteral(&quot;, &quot;);
<span class="line-modified">1042             wroteFirstStop = true;</span>
<span class="line-modified">1043             writeColorStop(result, stop);</span>





1044         }

1045     }
1046 
1047     result.append(&#39;)&#39;);
1048     return result.toString();
1049 }
1050 
1051 float CSSRadialGradientValue::resolveRadius(CSSPrimitiveValue&amp; radius, const CSSToLengthConversionData&amp; conversionData, float* widthOrHeight)
1052 {
1053     float result = 0;
1054     if (radius.isNumber())
1055         result = radius.floatValue() * conversionData.zoom();
1056     else if (widthOrHeight &amp;&amp; radius.isPercentage())
1057         result = *widthOrHeight * radius.floatValue() / 100;
1058     else
1059         result = radius.computeLength&lt;float&gt;(conversionData);
1060     return result;
1061 }
1062 
1063 static float distanceToClosestCorner(const FloatPoint&amp; p, const FloatSize&amp; size, FloatPoint&amp; corner)
1064 {
</pre>
<hr />
<pre>
1116 
1117     if (bottomLeftDistance &gt; maxDistance) {
1118         maxDistance = bottomLeftDistance;
1119         corner = bottomLeft;
1120     }
1121 
1122     if (bottomRightDistance &gt; maxDistance) {
1123         maxDistance = bottomRightDistance;
1124         corner = bottomRight;
1125     }
1126     return maxDistance;
1127 }
1128 
1129 // Compute horizontal radius of ellipse with center at 0,0 which passes through p, and has
1130 // width/height given by aspectRatio.
1131 static inline float horizontalEllipseRadius(const FloatSize&amp; p, float aspectRatio)
1132 {
1133     // x^2/a^2 + y^2/b^2 = 1
1134     // a/b = aspectRatio, b = a/aspectRatio
1135     // a = sqrt(x^2 + y^2/(1/r^2))
<span class="line-modified">1136     return std::hypot(p.width(), p.height() * aspectRatio);</span>
1137 }
1138 
1139 // FIXME: share code with the linear version
1140 Ref&lt;Gradient&gt; CSSRadialGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
1141 {
1142     ASSERT(!size.isEmpty());
1143 
1144     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
1145 
1146     FloatPoint firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
1147     if (!m_firstX)
1148         firstPoint.setX(size.width() / 2);
1149     if (!m_firstY)
1150         firstPoint.setY(size.height() / 2);
1151 
1152     FloatPoint secondPoint = computeEndPoint(m_secondX.get(), m_secondY.get(), conversionData, size);
1153     if (!m_secondX)
1154         secondPoint.setX(size.width() / 2);
1155     if (!m_secondY)
1156         secondPoint.setY(size.height() / 2);
</pre>
<hr />
<pre>
1275     RadialGradientAdapter adapter { data };
1276     auto stops = computeStops(adapter, conversionData, renderer.style(), maxExtent);
1277 
1278     auto gradient = Gradient::create(WTFMove(data));
1279     gradient-&gt;setSortedColorStops(WTFMove(stops));
1280     return gradient;
1281 }
1282 
1283 bool CSSRadialGradientValue::equals(const CSSRadialGradientValue&amp; other) const
1284 {
1285     if (m_gradientType == CSSDeprecatedRadialGradient)
1286         return other.m_gradientType == m_gradientType
1287             &amp;&amp; compareCSSValuePtr(m_firstX, other.m_firstX)
1288             &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY)
1289             &amp;&amp; compareCSSValuePtr(m_secondX, other.m_secondX)
1290             &amp;&amp; compareCSSValuePtr(m_secondY, other.m_secondY)
1291             &amp;&amp; compareCSSValuePtr(m_firstRadius, other.m_firstRadius)
1292             &amp;&amp; compareCSSValuePtr(m_secondRadius, other.m_secondRadius)
1293             &amp;&amp; m_stops == other.m_stops;
1294 
<span class="line-added">1295     if (m_gradientType != other.m_gradientType)</span>
<span class="line-added">1296         return false;</span>
<span class="line-added">1297 </span>
1298     if (m_repeating != other.m_repeating)
1299         return false;
1300 
1301     bool equalXandY = false;
1302     if (m_firstX &amp;&amp; m_firstY)
1303         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; compareCSSValuePtr(m_firstY, other.m_firstY);
1304     else if (m_firstX)
1305         equalXandY = compareCSSValuePtr(m_firstX, other.m_firstX) &amp;&amp; !other.m_firstY;
1306     else if (m_firstY)
1307         equalXandY = compareCSSValuePtr(m_firstY, other.m_firstY) &amp;&amp; !other.m_firstX;
1308     else
1309         equalXandY = !other.m_firstX &amp;&amp; !other.m_firstY;
1310 
1311     if (!equalXandY)
1312         return false;
1313 
1314     bool equalShape = true;
1315     bool equalSizingBehavior = true;
1316     bool equalHorizontalAndVerticalSize = true;
1317 
</pre>
<hr />
<pre>
1344     if (m_angle) {
1345         result.append(&quot;from &quot;, m_angle-&gt;cssText());
1346         wroteSomething = true;
1347     }
1348 
1349     if (m_firstX &amp;&amp; m_firstY) {
1350         if (wroteSomething)
1351             result.append(&#39; &#39;);
1352         result.append(&quot;at &quot;, m_firstX-&gt;cssText(), &#39; &#39;, m_firstY-&gt;cssText());
1353         wroteSomething = true;
1354     }
1355 
1356     if (wroteSomething)
1357         result.appendLiteral(&quot;, &quot;);
1358 
1359     bool wroteFirstStop = false;
1360     for (auto&amp; stop : m_stops) {
1361         if (wroteFirstStop)
1362             result.appendLiteral(&quot;, &quot;);
1363         wroteFirstStop = true;
<span class="line-modified">1364         writeColorStop(result, stop);</span>






1365     }
1366 
1367     result.append(&#39;)&#39;);
1368     return result.toString();
1369 }
1370 
1371 Ref&lt;Gradient&gt; CSSConicGradientValue::createGradient(RenderElement&amp; renderer, const FloatSize&amp; size)
1372 {
1373     ASSERT(!size.isEmpty());
1374 
1375     CSSToLengthConversionData conversionData(&amp;renderer.style(), renderer.document().documentElement()-&gt;renderStyle(), &amp;renderer.view());
1376 
1377     FloatPoint centerPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
1378     if (!m_firstX)
1379         centerPoint.setX(size.width() / 2);
1380     if (!m_firstY)
1381         centerPoint.setY(size.height() / 2);
1382 
1383     float angleRadians = 0;
1384     if (m_angle)
<span class="line-modified">1385         angleRadians = m_angle-&gt;floatValue(CSSUnitType::CSS_RAD);</span>
1386 
1387     Gradient::ConicData data { centerPoint, angleRadians };
1388     ConicGradientAdapter adapter;
1389     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
1390 
1391     auto gradient = Gradient::create(WTFMove(data));
1392     gradient-&gt;setSortedColorStops(WTFMove(stops));
1393     return gradient;
1394 }
1395 
1396 bool CSSConicGradientValue::equals(const CSSConicGradientValue&amp; other) const
1397 {
1398     if (m_repeating != other.m_repeating)
1399         return false;
1400 
1401     if (!compareCSSValuePtr(m_angle, other.m_angle))
1402         return false;
1403 
1404     bool equalXandY = false;
1405     if (m_firstX &amp;&amp; m_firstY)
</pre>
</td>
</tr>
</table>
<center><a href="CSSFontVariationValue.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSGradientValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
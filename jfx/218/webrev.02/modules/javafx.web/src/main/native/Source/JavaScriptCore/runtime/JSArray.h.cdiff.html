<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSArray.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBuffer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArray.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 20,12 ***</span>
  
  #pragma once
  
  #include &quot;ArgList.h&quot;
  #include &quot;ArrayConventions.h&quot;
<span class="line-modified">! #include &quot;ButterflyInlines.h&quot;</span>
<span class="line-modified">! #include &quot;JSCellInlines.h&quot;</span>
  #include &quot;JSObject.h&quot;
  
  namespace JSC {
  
  class JSArray;
<span class="line-new-header">--- 20,12 ---</span>
  
  #pragma once
  
  #include &quot;ArgList.h&quot;
  #include &quot;ArrayConventions.h&quot;
<span class="line-modified">! #include &quot;Butterfly.h&quot;</span>
<span class="line-modified">! #include &quot;JSCell.h&quot;</span>
  #include &quot;JSObject.h&quot;
  
  namespace JSC {
  
  class JSArray;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,11 ***</span>
      friend class Walker;
      friend class JIT;
  
  public:
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | OverridesGetPropertyNames;</span>
  
      static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
      {
          ASSERT_UNUSED(inlineCapacity, !inlineCapacity);
          return sizeof(JSArray);
<span class="line-new-header">--- 38,11 ---</span>
      friend class Walker;
      friend class JIT;
  
  public:
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | OverridesGetPropertyNames;</span>
  
      static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
      {
          ASSERT_UNUSED(inlineCapacity, !inlineCapacity);
          return sizeof(JSArray);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,33 ***</span>
          return tryCreateUninitializedRestricted(scope, nullptr, structure, initialLength);
      }
  
      static void eagerlyInitializeButterfly(ObjectInitializationScope&amp;, JSArray*, unsigned initialLength);
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool throwException);</span>
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
  
      DECLARE_EXPORT_INFO;
  
      // OK if we know this is a JSArray, but not if it could be an object of a derived class; for RuntimeArray this always returns 0.
      unsigned length() const { return getArrayLength(); }
  
      // OK to use on new arrays, but not if it might be a RegExpMatchArray or RuntimeArray.
<span class="line-modified">!     JS_EXPORT_PRIVATE bool setLength(ExecState*, unsigned, bool throwException = false);</span>
  
<span class="line-modified">!     void pushInline(ExecState*, JSValue);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE void push(ExecState*, JSValue);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE JSValue pop(ExecState*);</span>
  
<span class="line-modified">!     JSArray* fastSlice(ExecState&amp;, unsigned startIndex, unsigned count);</span>
  
      bool canFastCopy(VM&amp;, JSArray* otherArray);
      bool canDoFastIndexedAccess(VM&amp;);
      // This function returns NonArray if the indexing types are not compatable for copying.
      IndexingType mergeIndexingTypeForCopying(IndexingType other);
<span class="line-modified">!     bool appendMemcpy(ExecState*, VM&amp;, unsigned startIndex, JSArray* otherArray);</span>
  
      enum ShiftCountMode {
          // This form of shift hints that we&#39;re doing queueing. With this assumption in hand,
          // we convert to ArrayStorage, which has queue optimizations.
          ShiftCountForShift,
<span class="line-new-header">--- 80,33 ---</span>
          return tryCreateUninitializedRestricted(scope, nullptr, structure, initialLength);
      }
  
      static void eagerlyInitializeButterfly(ObjectInitializationScope&amp;, JSArray*, unsigned initialLength);
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool throwException);</span>
  
<span class="line-modified">!     JS_EXPORT_PRIVATE static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
  
      DECLARE_EXPORT_INFO;
  
      // OK if we know this is a JSArray, but not if it could be an object of a derived class; for RuntimeArray this always returns 0.
      unsigned length() const { return getArrayLength(); }
  
      // OK to use on new arrays, but not if it might be a RegExpMatchArray or RuntimeArray.
<span class="line-modified">!     JS_EXPORT_PRIVATE bool setLength(JSGlobalObject*, unsigned, bool throwException = false);</span>
  
<span class="line-modified">!     void pushInline(JSGlobalObject*, JSValue);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE void push(JSGlobalObject*, JSValue);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE JSValue pop(JSGlobalObject*);</span>
  
<span class="line-modified">!     JSArray* fastSlice(JSGlobalObject*, unsigned startIndex, unsigned count);</span>
  
      bool canFastCopy(VM&amp;, JSArray* otherArray);
      bool canDoFastIndexedAccess(VM&amp;);
      // This function returns NonArray if the indexing types are not compatable for copying.
      IndexingType mergeIndexingTypeForCopying(IndexingType other);
<span class="line-modified">!     bool appendMemcpy(JSGlobalObject*, VM&amp;, unsigned startIndex, JSArray* otherArray);</span>
  
      enum ShiftCountMode {
          // This form of shift hints that we&#39;re doing queueing. With this assumption in hand,
          // we convert to ArrayStorage, which has queue optimizations.
          ShiftCountForShift,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,57 ***</span>
          // is probably typically used for ordinary accesses. With this assumption in hand,
          // we try to preserve whatever indexing type it has already.
          ShiftCountForSplice
      };
  
<span class="line-modified">!     bool shiftCountForShift(ExecState* exec, unsigned startIndex, unsigned count)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
      }
<span class="line-modified">!     bool shiftCountForSplice(ExecState* exec, unsigned&amp; startIndex, unsigned count)</span>
      {
<span class="line-modified">!         return shiftCountWithAnyIndexingType(exec, startIndex, count);</span>
      }
      template&lt;ShiftCountMode shiftCountMode&gt;
<span class="line-modified">!     bool shiftCount(ExecState* exec, unsigned&amp; startIndex, unsigned count)</span>
      {
          switch (shiftCountMode) {
          case ShiftCountForShift:
<span class="line-modified">!             return shiftCountForShift(exec, startIndex, count);</span>
          case ShiftCountForSplice:
<span class="line-modified">!             return shiftCountForSplice(exec, startIndex, count);</span>
          default:
              CRASH();
              return false;
          }
      }
  
<span class="line-modified">!     bool unshiftCountForShift(ExecState* exec, unsigned startIndex, unsigned count)</span>
      {
<span class="line-modified">!         return unshiftCountWithArrayStorage(exec, startIndex, count, ensureArrayStorage(exec-&gt;vm()));</span>
      }
<span class="line-modified">!     bool unshiftCountForSplice(ExecState* exec, unsigned startIndex, unsigned count)</span>
      {
<span class="line-modified">!         return unshiftCountWithAnyIndexingType(exec, startIndex, count);</span>
      }
      template&lt;ShiftCountMode shiftCountMode&gt;
<span class="line-modified">!     bool unshiftCount(ExecState* exec, unsigned startIndex, unsigned count)</span>
      {
          switch (shiftCountMode) {
          case ShiftCountForShift:
<span class="line-modified">!             return unshiftCountForShift(exec, startIndex, count);</span>
          case ShiftCountForSplice:
<span class="line-modified">!             return unshiftCountForSplice(exec, startIndex, count);</span>
          default:
              CRASH();
              return false;
          }
      }
  
<span class="line-modified">!     JS_EXPORT_PRIVATE void fillArgList(ExecState*, MarkedArgumentBuffer&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE void copyToArguments(ExecState*, VirtualRegister firstElementDest, unsigned offset, unsigned length);</span>
  
      JS_EXPORT_PRIVATE bool isIteratorProtocolFastAndNonObservable();
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, IndexingType indexingType)
      {
<span class="line-new-header">--- 115,57 ---</span>
          // is probably typically used for ordinary accesses. With this assumption in hand,
          // we try to preserve whatever indexing type it has already.
          ShiftCountForSplice
      };
  
<span class="line-modified">!     bool shiftCountForShift(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          return shiftCountWithArrayStorage(vm, startIndex, count, ensureArrayStorage(vm));
      }
<span class="line-modified">!     bool shiftCountForSplice(JSGlobalObject* globalObject, unsigned&amp; startIndex, unsigned count)</span>
      {
<span class="line-modified">!         return shiftCountWithAnyIndexingType(globalObject, startIndex, count);</span>
      }
      template&lt;ShiftCountMode shiftCountMode&gt;
<span class="line-modified">!     bool shiftCount(JSGlobalObject* globalObject, unsigned&amp; startIndex, unsigned count)</span>
      {
          switch (shiftCountMode) {
          case ShiftCountForShift:
<span class="line-modified">!             return shiftCountForShift(globalObject, startIndex, count);</span>
          case ShiftCountForSplice:
<span class="line-modified">!             return shiftCountForSplice(globalObject, startIndex, count);</span>
          default:
              CRASH();
              return false;
          }
      }
  
<span class="line-modified">!     bool unshiftCountForShift(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
      {
<span class="line-modified">!         return unshiftCountWithArrayStorage(globalObject, startIndex, count, ensureArrayStorage(getVM(globalObject)));</span>
      }
<span class="line-modified">!     bool unshiftCountForSplice(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
      {
<span class="line-modified">!         return unshiftCountWithAnyIndexingType(globalObject, startIndex, count);</span>
      }
      template&lt;ShiftCountMode shiftCountMode&gt;
<span class="line-modified">!     bool unshiftCount(JSGlobalObject* globalObject, unsigned startIndex, unsigned count)</span>
      {
          switch (shiftCountMode) {
          case ShiftCountForShift:
<span class="line-modified">!             return unshiftCountForShift(globalObject, startIndex, count);</span>
          case ShiftCountForSplice:
<span class="line-modified">!             return unshiftCountForSplice(globalObject, startIndex, count);</span>
          default:
              CRASH();
              return false;
          }
      }
  
<span class="line-modified">!     JS_EXPORT_PRIVATE void fillArgList(JSGlobalObject*, MarkedArgumentBuffer&amp;);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE void copyToArguments(JSGlobalObject*, JSValue* firstElementDest, unsigned offset, unsigned length);</span>
  
      JS_EXPORT_PRIVATE bool isIteratorProtocolFastAndNonObservable();
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, IndexingType indexingType)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 178,14 ***</span>
          Base::finishCreation(vm);
          ASSERT(jsDynamicCast&lt;JSArray*&gt;(vm, this));
          ASSERT_WITH_MESSAGE(type() == ArrayType || type() == DerivedArrayType, &quot;Instance inheriting JSArray should have either ArrayType or DerivedArrayType&quot;);
      }
  
<span class="line-modified">!     static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="line-modified">!     static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
  
  private:
      bool isLengthWritable()
      {
          ArrayStorage* storage = arrayStorageOrNull();
<span class="line-new-header">--- 178,14 ---</span>
          Base::finishCreation(vm);
          ASSERT(jsDynamicCast&lt;JSArray*&gt;(vm, this));
          ASSERT_WITH_MESSAGE(type() == ArrayType || type() == DerivedArrayType, &quot;Instance inheriting JSArray should have either ArrayType or DerivedArrayType&quot;);
      }
  
<span class="line-modified">!     static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="line-modified">!     static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
  
  private:
      bool isLengthWritable()
      {
          ArrayStorage* storage = arrayStorageOrNull();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,19 ***</span>
              return true;
          SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
          return !map || !map-&gt;lengthIsReadOnly();
      }
  
<span class="line-modified">!     bool shiftCountWithAnyIndexingType(ExecState*, unsigned&amp; startIndex, unsigned count);</span>
      JS_EXPORT_PRIVATE bool shiftCountWithArrayStorage(VM&amp;, unsigned startIndex, unsigned count, ArrayStorage*);
  
<span class="line-modified">!     bool unshiftCountWithAnyIndexingType(ExecState*, unsigned startIndex, unsigned count);</span>
<span class="line-modified">!     bool unshiftCountWithArrayStorage(ExecState*, unsigned startIndex, unsigned count, ArrayStorage*);</span>
      bool unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp;, DeferGC&amp;, bool, unsigned);
  
<span class="line-modified">!     bool setLengthWithArrayStorage(ExecState*, unsigned newLength, bool throwException, ArrayStorage*);</span>
<span class="line-modified">!     void setLengthWritable(ExecState*, bool writable);</span>
  };
  
  inline Butterfly* tryCreateArrayButterfly(VM&amp; vm, JSObject* intendedOwner, unsigned initialLength)
  {
      Butterfly* butterfly = Butterfly::tryCreate(
<span class="line-new-header">--- 193,19 ---</span>
              return true;
          SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
          return !map || !map-&gt;lengthIsReadOnly();
      }
  
<span class="line-modified">!     bool shiftCountWithAnyIndexingType(JSGlobalObject*, unsigned&amp; startIndex, unsigned count);</span>
      JS_EXPORT_PRIVATE bool shiftCountWithArrayStorage(VM&amp;, unsigned startIndex, unsigned count, ArrayStorage*);
  
<span class="line-modified">!     bool unshiftCountWithAnyIndexingType(JSGlobalObject*, unsigned startIndex, unsigned count);</span>
<span class="line-modified">!     bool unshiftCountWithArrayStorage(JSGlobalObject*, unsigned startIndex, unsigned count, ArrayStorage*);</span>
      bool unshiftCountSlowCase(const AbstractLocker&amp;, VM&amp;, DeferGC&amp;, bool, unsigned);
  
<span class="line-modified">!     bool setLengthWithArrayStorage(JSGlobalObject*, unsigned newLength, bool throwException, ArrayStorage*);</span>
<span class="line-modified">!     void setLengthWritable(JSGlobalObject*, bool writable);</span>
  };
  
  inline Butterfly* tryCreateArrayButterfly(VM&amp; vm, JSObject* intendedOwner, unsigned initialLength)
  {
      Butterfly* butterfly = Butterfly::tryCreate(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,10 ***</span>
      return cell-&gt;type() == ArrayType;
  }
  
  inline bool isJSArray(JSValue v) { return v.isCell() &amp;&amp; isJSArray(v.asCell()); }
  
<span class="line-modified">! JS_EXPORT_PRIVATE JSArray* constructArray(ExecState*, Structure*, const ArgList&amp; values);</span>
<span class="line-modified">! JS_EXPORT_PRIVATE JSArray* constructArray(ExecState*, Structure*, const JSValue* values, unsigned length);</span>
<span class="line-modified">! JS_EXPORT_PRIVATE JSArray* constructArrayNegativeIndexed(ExecState*, Structure*, const JSValue* values, unsigned length);</span>
  
  } // namespace JSC
<span class="line-new-header">--- 304,10 ---</span>
      return cell-&gt;type() == ArrayType;
  }
  
  inline bool isJSArray(JSValue v) { return v.isCell() &amp;&amp; isJSArray(v.asCell()); }
  
<span class="line-modified">! JS_EXPORT_PRIVATE JSArray* constructArray(JSGlobalObject*, Structure*, const ArgList&amp; values);</span>
<span class="line-modified">! JS_EXPORT_PRIVATE JSArray* constructArray(JSGlobalObject*, Structure*, const JSValue* values, unsigned length);</span>
<span class="line-modified">! JS_EXPORT_PRIVATE JSArray* constructArrayNegativeIndexed(JSGlobalObject*, Structure*, const JSValue* values, unsigned length);</span>
  
  } // namespace JSC
</pre>
<center><a href="JSArray.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBuffer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
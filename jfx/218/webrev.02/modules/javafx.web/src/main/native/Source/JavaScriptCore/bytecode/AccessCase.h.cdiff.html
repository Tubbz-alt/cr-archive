<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessCase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCaseSnippetParams.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/AccessCase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,19 ***</span>
<span class="line-new-header">--- 25,22 ---</span>
  
  #pragma once
  
  #if ENABLE(JIT)
  
<span class="line-added">+ #include &quot;CacheableIdentifier.h&quot;</span>
  #include &quot;JSFunctionInlines.h&quot;
  #include &quot;ObjectPropertyConditionSet.h&quot;
  #include &quot;PolyProtoAccessChain.h&quot;
  #include &lt;wtf/CommaPrinter.h&gt;
  
  namespace JSC {
  
  struct AccessGenerationState;
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(AccessCase);</span>
<span class="line-added">+ </span>
  // An AccessCase describes one of the cases of a PolymorphicAccess. A PolymorphicAccess represents a
  // planned (to generate in future) or generated stub for some inline cache. That stub contains fast
  // path code for some finite number of fast cases, each described by an AccessCase object.
  //
  // An AccessCase object has a lifecycle that proceeds through several states. Note that the states
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,11 ***</span>
  //
  // We will sometimes buffer committed AccessCases in the PolymorphicAccess object before generating
  // code. This allows us to only regenerate once we&#39;ve accumulated (hopefully) more than one new
  // AccessCase.
  class AccessCase {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED;</span>
  public:
      enum AccessType : uint8_t {
          Load,
          Transition,
          Replace,
<span class="line-new-header">--- 78,11 ---</span>
  //
  // We will sometimes buffer committed AccessCases in the PolymorphicAccess object before generating
  // code. This allows us to only regenerate once we&#39;ve accumulated (hopefully) more than one new
  // AccessCase.
  class AccessCase {
<span class="line-modified">!     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(AccessCase);</span>
  public:
      enum AccessType : uint8_t {
          Load,
          Transition,
          Replace,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,11 ***</span>
          DirectArgumentsLength,
          ScopedArgumentsLength,
          ModuleNamespaceLoad,
          InstanceOfHit,
          InstanceOfMiss,
<span class="line-modified">!         InstanceOfGeneric</span>
      };
  
      enum State : uint8_t {
          Primordial,
          Committed,
<span class="line-new-header">--- 102,27 ---</span>
          DirectArgumentsLength,
          ScopedArgumentsLength,
          ModuleNamespaceLoad,
          InstanceOfHit,
          InstanceOfMiss,
<span class="line-modified">!         InstanceOfGeneric,</span>
<span class="line-added">+         IndexedInt32Load,</span>
<span class="line-added">+         IndexedDoubleLoad,</span>
<span class="line-added">+         IndexedContiguousLoad,</span>
<span class="line-added">+         IndexedArrayStorageLoad,</span>
<span class="line-added">+         IndexedScopedArgumentsLoad,</span>
<span class="line-added">+         IndexedDirectArgumentsLoad,</span>
<span class="line-added">+         IndexedTypedArrayInt8Load,</span>
<span class="line-added">+         IndexedTypedArrayUint8Load,</span>
<span class="line-added">+         IndexedTypedArrayUint8ClampedLoad,</span>
<span class="line-added">+         IndexedTypedArrayInt16Load,</span>
<span class="line-added">+         IndexedTypedArrayUint16Load,</span>
<span class="line-added">+         IndexedTypedArrayInt32Load,</span>
<span class="line-added">+         IndexedTypedArrayUint32Load,</span>
<span class="line-added">+         IndexedTypedArrayFloat32Load,</span>
<span class="line-added">+         IndexedTypedArrayFloat64Load,</span>
<span class="line-added">+         IndexedStringLoad</span>
      };
  
      enum State : uint8_t {
          Primordial,
          Committed,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,18 ***</span>
      static std::unique_ptr&lt;AccessCaseType&gt; create(Arguments... arguments)
      {
          return std::unique_ptr&lt;AccessCaseType&gt;(new AccessCaseType(arguments...));
      }
  
<span class="line-modified">!     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, AccessType, PropertyOffset = invalidOffset,</span>
          Structure* = nullptr, const ObjectPropertyConditionSet&amp; = ObjectPropertyConditionSet(), std::unique_ptr&lt;PolyProtoAccessChain&gt; = nullptr);
  
      // This create method should be used for transitions.
<span class="line-modified">!     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, PropertyOffset, Structure* oldStructure,</span>
          Structure* newStructure, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);
  
<span class="line-modified">!     static std::unique_ptr&lt;AccessCase&gt; fromStructureStubInfo(VM&amp;, JSCell* owner, StructureStubInfo&amp;);</span>
  
      AccessType type() const { return m_type; }
      State state() const { return m_state; }
      PropertyOffset offset() const { return m_offset; }
  
<span class="line-new-header">--- 140,18 ---</span>
      static std::unique_ptr&lt;AccessCaseType&gt; create(Arguments... arguments)
      {
          return std::unique_ptr&lt;AccessCaseType&gt;(new AccessCaseType(arguments...));
      }
  
<span class="line-modified">!     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset = invalidOffset,</span>
          Structure* = nullptr, const ObjectPropertyConditionSet&amp; = ObjectPropertyConditionSet(), std::unique_ptr&lt;PolyProtoAccessChain&gt; = nullptr);
  
      // This create method should be used for transitions.
<span class="line-modified">!     static std::unique_ptr&lt;AccessCase&gt; create(VM&amp;, JSCell* owner, CacheableIdentifier, PropertyOffset, Structure* oldStructure,</span>
          Structure* newStructure, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);
  
<span class="line-modified">!     static std::unique_ptr&lt;AccessCase&gt; fromStructureStubInfo(VM&amp;, JSCell* owner, CacheableIdentifier, StructureStubInfo&amp;);</span>
  
      AccessType type() const { return m_type; }
      State state() const { return m_state; }
      PropertyOffset offset() const { return m_offset; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,11 ***</span>
      {
          if (m_type == Transition)
              return m_structure-&gt;previousID();
          return m_structure.get();
      }
<span class="line-modified">!     bool guardedByStructureCheck() const;</span>
  
      Structure* newStructure() const
      {
          ASSERT(m_type == Transition);
          return m_structure.get();
<span class="line-new-header">--- 159,11 ---</span>
      {
          if (m_type == Transition)
              return m_structure-&gt;previousID();
          return m_structure.get();
      }
<span class="line-modified">!     bool guardedByStructureCheck(const StructureStubInfo&amp;) const;</span>
  
      Structure* newStructure() const
      {
          ASSERT(m_type == Transition);
          return m_structure.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,11 ***</span>
      virtual WatchpointSet* additionalSet() const { return nullptr; }
      bool viaProxy() const { return m_viaProxy; }
  
      // If you supply the optional vector, this will append the set of cells that this will need to keep alive
      // past the call.
<span class="line-modified">!     bool doesCalls(Vector&lt;JSCell*&gt;* cellsToMark = nullptr) const;</span>
  
      bool isGetter() const
      {
          switch (type()) {
          case Getter:
<span class="line-new-header">--- 177,24 ---</span>
      virtual WatchpointSet* additionalSet() const { return nullptr; }
      bool viaProxy() const { return m_viaProxy; }
  
      // If you supply the optional vector, this will append the set of cells that this will need to keep alive
      // past the call.
<span class="line-modified">!     bool doesCalls(VM&amp;, Vector&lt;JSCell*&gt;* cellsToMark = nullptr) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool isCustom() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         switch (type()) {</span>
<span class="line-added">+         case CustomValueGetter:</span>
<span class="line-added">+         case CustomAccessorGetter:</span>
<span class="line-added">+         case CustomValueSetter:</span>
<span class="line-added">+         case CustomAccessorSetter:</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      bool isGetter() const
      {
          switch (type()) {
          case Getter:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,20 ***</span>
      bool usesPolyProto() const
      {
          return !!m_polyProtoAccessChain;
      }
  
  protected:
<span class="line-modified">!     AccessCase(VM&amp;, JSCell* owner, AccessType, PropertyOffset, Structure*, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);</span>
      AccessCase(AccessCase&amp;&amp;) = default;
      AccessCase(const AccessCase&amp; other)
          : m_type(other.m_type)
          , m_state(other.m_state)
          , m_viaProxy(other.m_viaProxy)
          , m_offset(other.m_offset)
          , m_structure(other.m_structure)
          , m_conditionSet(other.m_conditionSet)
      {
          if (other.m_polyProtoAccessChain)
              m_polyProtoAccessChain = other.m_polyProtoAccessChain-&gt;clone();
      }
  
<span class="line-new-header">--- 227,36 ---</span>
      bool usesPolyProto() const
      {
          return !!m_polyProtoAccessChain;
      }
  
<span class="line-added">+     bool requiresIdentifierNameMatch() const;</span>
<span class="line-added">+     bool requiresInt32PropertyCheck() const;</span>
<span class="line-added">+     bool needsScratchFPR() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static TypedArrayType toTypedArrayType(AccessType);</span>
<span class="line-added">+ </span>
<span class="line-added">+     UniquedStringImpl* uid() const { return m_identifier.uid(); }</span>
<span class="line-added">+     CacheableIdentifier identifier() const { return m_identifier; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
<span class="line-added">+     void checkConsistency(StructureStubInfo&amp;);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     ALWAYS_INLINE void checkConsistency(StructureStubInfo&amp;) { }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  protected:
<span class="line-modified">!     AccessCase(VM&amp;, JSCell* owner, AccessType, CacheableIdentifier, PropertyOffset, Structure*, const ObjectPropertyConditionSet&amp;, std::unique_ptr&lt;PolyProtoAccessChain&gt;);</span>
      AccessCase(AccessCase&amp;&amp;) = default;
      AccessCase(const AccessCase&amp; other)
          : m_type(other.m_type)
          , m_state(other.m_state)
          , m_viaProxy(other.m_viaProxy)
          , m_offset(other.m_offset)
          , m_structure(other.m_structure)
          , m_conditionSet(other.m_conditionSet)
<span class="line-added">+         , m_identifier(other.m_identifier)</span>
      {
          if (other.m_polyProtoAccessChain)
              m_polyProtoAccessChain = other.m_polyProtoAccessChain-&gt;clone();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 217,20 ***</span>
  
  private:
      friend class CodeBlock;
      friend class PolymorphicAccess;
  
      bool visitWeak(VM&amp;) const;
      bool propagateTransitions(SlotVisitor&amp;) const;
  
      // FIXME: This only exists because of how AccessCase puts post-generation things into itself.
      // https://bugs.webkit.org/show_bug.cgi?id=156456
      virtual std::unique_ptr&lt;AccessCase&gt; clone() const;
  
      // Perform any action that must be performed before the end of the epoch in which the case
      // was created. Returns a set of watchpoint sets that will need to be watched.
<span class="line-modified">!     Vector&lt;WatchpointSet*, 2&gt; commit(VM&amp;, const Identifier&amp;);</span>
  
      // Fall through on success. Two kinds of failures are supported: fall-through, which means that we
      // should try a different case; and failure, which means that this was the right case but it needs
      // help from the slow path.
      void generateWithGuard(AccessGenerationState&amp;, MacroAssembler::JumpList&amp; fallThrough);
<span class="line-new-header">--- 265,24 ---</span>
  
  private:
      friend class CodeBlock;
      friend class PolymorphicAccess;
  
<span class="line-added">+     template&lt;typename Functor&gt;</span>
<span class="line-added">+     void forEachDependentCell(VM&amp;, const Functor&amp;) const;</span>
<span class="line-added">+ </span>
<span class="line-added">+     void visitAggregate(SlotVisitor&amp;) const;</span>
      bool visitWeak(VM&amp;) const;
      bool propagateTransitions(SlotVisitor&amp;) const;
  
      // FIXME: This only exists because of how AccessCase puts post-generation things into itself.
      // https://bugs.webkit.org/show_bug.cgi?id=156456
      virtual std::unique_ptr&lt;AccessCase&gt; clone() const;
  
      // Perform any action that must be performed before the end of the epoch in which the case
      // was created. Returns a set of watchpoint sets that will need to be watched.
<span class="line-modified">!     Vector&lt;WatchpointSet*, 2&gt; commit(VM&amp;);</span>
  
      // Fall through on success. Two kinds of failures are supported: fall-through, which means that we
      // should try a different case; and failure, which means that this was the right case but it needs
      // help from the slow path.
      void generateWithGuard(AccessGenerationState&amp;, MacroAssembler::JumpList&amp; fallThrough);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,10 ***</span>
<span class="line-new-header">--- 290,12 ---</span>
      // Fall through on success, add a jump to the failure list on failure.
      void generate(AccessGenerationState&amp;);
  
      void generateImpl(AccessGenerationState&amp;);
  
<span class="line-added">+     bool guardedByStructureCheckSkippingConstantIdentifierCheck() const;</span>
<span class="line-added">+ </span>
      AccessType m_type;
      State m_state { Primordial };
  protected:
      // m_viaProxy is true only if the instance inherits (or it is) ProxyableAccessCase.
      // We put this value here instead of ProxyableAccessCase to reduce the size of ProxyableAccessCase and its
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,10 ***</span>
<span class="line-new-header">--- 310,12 ---</span>
      WriteBarrier&lt;Structure&gt; m_structure;
  
      ObjectPropertyConditionSet m_conditionSet;
  
      std::unique_ptr&lt;PolyProtoAccessChain&gt; m_polyProtoAccessChain;
<span class="line-added">+ </span>
<span class="line-added">+     CacheableIdentifier m_identifier;</span>
  };
  
  } // namespace JSC
  
  #endif
</pre>
<center><a href="AccessCase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessCaseSnippetParams.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGNodeType.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSREntry.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 
 37 namespace JSC { namespace DFG {
<span class="line-removed"> 38 namespace DFGOSRAvailabilityAnalysisPhaseInternal {</span>
<span class="line-removed"> 39 static constexpr bool verbose = false;</span>
<span class="line-removed"> 40 }</span>
 41 
 42 class OSRAvailabilityAnalysisPhase : public Phase {

 43 public:
 44     OSRAvailabilityAnalysisPhase(Graph&amp; graph)
 45         : Phase(graph, &quot;OSR availability analysis&quot;)
 46     {
 47     }
 48 
 49     bool run()
 50     {
 51         ASSERT(m_graph.m_form == SSA);
 52 
 53         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 54             BasicBlock* block = m_graph.block(blockIndex);
 55             if (!block)
 56                 continue;
 57             block-&gt;ssa-&gt;availabilityAtHead.clear();
 58             block-&gt;ssa-&gt;availabilityAtTail.clear();
 59         }
 60 
 61         BasicBlock* root = m_graph.block(0);
 62         root-&gt;ssa-&gt;availabilityAtHead.m_locals.fill(Availability::unavailable());
 63 
 64         for (unsigned argument = 0; argument &lt; m_graph.block(0)-&gt;valuesAtHead.numberOfArguments(); ++argument)
 65             root-&gt;ssa-&gt;availabilityAtHead.m_locals.argument(argument) = Availability::unavailable();
 66 
 67         // This could be made more efficient by processing blocks in reverse postorder.
 68 
 69         auto dumpAvailability = [] (BasicBlock* block) {
 70             dataLogLn(block-&gt;ssa-&gt;availabilityAtHead);
 71             dataLogLn(block-&gt;ssa-&gt;availabilityAtTail);
 72         };
 73 
 74         auto dumpBytecodeLivenessAtHead = [&amp;] (BasicBlock* block) {
 75             dataLog(&quot;Live: &quot;);
 76             m_graph.forAllLiveInBytecode(
 77                 block-&gt;at(0)-&gt;origin.forExit,
<span class="line-modified"> 78                 [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified"> 79                     dataLog(reg, &quot; &quot;);</span>
 80                 });
 81             dataLogLn(&quot;&quot;);
 82         };
 83 
 84         LocalOSRAvailabilityCalculator calculator(m_graph);
 85         bool changed;
 86         do {
 87             changed = false;
 88 
 89             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 90                 BasicBlock* block = m_graph.block(blockIndex);
 91                 if (!block)
 92                     continue;
 93 
<span class="line-modified"> 94                 if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {</span>
 95                     dataLogLn(&quot;Before changing Block #&quot;, block-&gt;index);
 96                     dumpAvailability(block);
 97                 }
 98                 calculator.beginBlock(block);
 99 
100                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex)
101                     calculator.executeNode(block-&gt;at(nodeIndex));
102 
103                 if (calculator.m_availability == block-&gt;ssa-&gt;availabilityAtTail)
104                     continue;
105 
106                 block-&gt;ssa-&gt;availabilityAtTail = calculator.m_availability;
107                 changed = true;
108 
<span class="line-modified">109                 if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {</span>
110                     dataLogLn(&quot;After changing Block #&quot;, block-&gt;index);
111                     dumpAvailability(block);
112                 }
113 
114                 for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
115                     BasicBlock* successor = block-&gt;successor(successorIndex);
116                     successor-&gt;ssa-&gt;availabilityAtHead.merge(calculator.m_availability);
117                 }
118 
119                 for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
120                     BasicBlock* successor = block-&gt;successor(successorIndex);
121                     successor-&gt;ssa-&gt;availabilityAtHead.pruneByLiveness(
122                         m_graph, successor-&gt;at(0)-&gt;origin.forExit);
<span class="line-modified">123                     if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {</span>
124                         dataLogLn(&quot;After pruning Block #&quot;, successor-&gt;index);
125                         dumpAvailability(successor);
126                         dumpBytecodeLivenessAtHead(successor);
127                     }
128                 }
129             }
130         } while (changed);
131 
132         if (validationEnabled()) {
133 
134             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
135                 BasicBlock* block = m_graph.block(blockIndex);
136                 if (!block)
137                     continue;
138 
139                 calculator.beginBlock(block);
140 
141                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
142                     if (block-&gt;at(nodeIndex)-&gt;origin.exitOK) {
143                         // If we&#39;re allowed to exit here, the heap must be in a state
</pre>
<hr />
<pre>
191 
192 LocalOSRAvailabilityCalculator::~LocalOSRAvailabilityCalculator()
193 {
194 }
195 
196 void LocalOSRAvailabilityCalculator::beginBlock(BasicBlock* block)
197 {
198     m_availability = block-&gt;ssa-&gt;availabilityAtHead;
199 }
200 
201 void LocalOSRAvailabilityCalculator::endBlock(BasicBlock* block)
202 {
203     m_availability = block-&gt;ssa-&gt;availabilityAtTail;
204 }
205 
206 void LocalOSRAvailabilityCalculator::executeNode(Node* node)
207 {
208     switch (node-&gt;op()) {
209     case PutStack: {
210         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">211         m_availability.m_locals.operand(data-&gt;local).setFlush(data-&gt;flushedAt());</span>
212         break;
213     }
214 
215     case KillStack: {
<span class="line-modified">216         m_availability.m_locals.operand(node-&gt;unlinkedLocal()).setFlush(FlushedAt(ConflictingFlush));</span>
217         break;
218     }
219 
220     case GetStack: {
221         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">222         m_availability.m_locals.operand(data-&gt;local) = Availability(node, data-&gt;flushedAt());</span>
223         break;
224     }
225 
226     case MovHint: {
<span class="line-modified">227         m_availability.m_locals.operand(node-&gt;unlinkedLocal()).setNode(node-&gt;child1().node());</span>
228         break;
229     }
230 
231     case ZombieHint: {
<span class="line-modified">232         m_availability.m_locals.operand(node-&gt;unlinkedLocal()).setNodeUnavailable();</span>
233         break;
234     }
235 
236     case InitializeEntrypointArguments: {
237         unsigned entrypointIndex = node-&gt;entrypointIndex();
238         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
239         for (unsigned argument = argumentFormats.size(); argument--; ) {
<span class="line-modified">240             FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgument(argument));</span>
241             m_availability.m_locals.argument(argument) = Availability(flushedAt);
242         }
243         break;
244     }
245 




246     case LoadVarargs:
247     case ForwardVarargs: {
248         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">249         m_availability.m_locals.operand(data-&gt;count) =</span>
<span class="line-removed">250             Availability(FlushedAt(FlushedInt32, data-&gt;machineCount));</span>
251         for (unsigned i = data-&gt;limit; i--;) {
<span class="line-modified">252             m_availability.m_locals.operand(VirtualRegister(data-&gt;start.offset() + i)) =</span>
<span class="line-modified">253                 Availability(FlushedAt(FlushedJSValue, VirtualRegister(data-&gt;machineStart.offset() + i)));</span>
254         }
255         break;
256     }
257 
258     case PhantomCreateRest:
259     case PhantomDirectArguments:
260     case PhantomClonedArguments: {
261         InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
262         if (!inlineCallFrame) {
263             // We don&#39;t need to record anything about how the arguments are to be recovered. It&#39;s just a
264             // given that we can read them from the stack.
265             break;
266         }
267 
268         unsigned numberOfArgumentsToSkip = 0;
269         if (node-&gt;op() == PhantomCreateRest)
270             numberOfArgumentsToSkip = node-&gt;numberOfArgumentsToSkip();
271 
272         if (inlineCallFrame-&gt;isVarargs()) {
273             // Record how to read each argument and the argument count.
274             Availability argumentCount =
<span class="line-modified">275                 m_availability.m_locals.operand(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
276 
277             m_availability.m_heap.set(PromotedHeapLocation(ArgumentCountPLoc, node), argumentCount);
278         }
279 
280         if (inlineCallFrame-&gt;isClosureCall) {
281             Availability callee = m_availability.m_locals.operand(
<span class="line-modified">282                 inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
283             m_availability.m_heap.set(PromotedHeapLocation(ArgumentsCalleePLoc, node), callee);
284         }
285 
<span class="line-modified">286         for (unsigned i = numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
287             Availability argument = m_availability.m_locals.operand(
<span class="line-modified">288                 inlineCallFrame-&gt;stackOffset + CallFrame::argumentOffset(i));</span>
289 
290             m_availability.m_heap.set(PromotedHeapLocation(ArgumentPLoc, node, i), argument);
291         }
292         break;
293     }
294 
295     case PutHint: {
296         m_availability.m_heap.set(
297             PromotedHeapLocation(node-&gt;child1().node(), node-&gt;promotedLocationDescriptor()),
298             Availability(node-&gt;child2().node()));
299         break;
300     }
301 
302     case PhantomSpread:
303         m_availability.m_heap.set(PromotedHeapLocation(SpreadPLoc, node), Availability(node-&gt;child1().node()));
304         break;
305 
306     case PhantomNewArrayWithSpread:
307         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
308             Node* child = m_graph.varArgChild(node, i).node();
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGBasicBlockInlines.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGInsertionSet.h&quot;
 34 #include &quot;DFGPhase.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 
 37 namespace JSC { namespace DFG {



 38 
 39 class OSRAvailabilityAnalysisPhase : public Phase {
<span class="line-added"> 40     static constexpr bool verbose = false;</span>
 41 public:
 42     OSRAvailabilityAnalysisPhase(Graph&amp; graph)
 43         : Phase(graph, &quot;OSR availability analysis&quot;)
 44     {
 45     }
 46 
 47     bool run()
 48     {
 49         ASSERT(m_graph.m_form == SSA);
 50 
 51         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
 52             BasicBlock* block = m_graph.block(blockIndex);
 53             if (!block)
 54                 continue;
 55             block-&gt;ssa-&gt;availabilityAtHead.clear();
 56             block-&gt;ssa-&gt;availabilityAtTail.clear();
 57         }
 58 
 59         BasicBlock* root = m_graph.block(0);
 60         root-&gt;ssa-&gt;availabilityAtHead.m_locals.fill(Availability::unavailable());
 61 
 62         for (unsigned argument = 0; argument &lt; m_graph.block(0)-&gt;valuesAtHead.numberOfArguments(); ++argument)
 63             root-&gt;ssa-&gt;availabilityAtHead.m_locals.argument(argument) = Availability::unavailable();
 64 
 65         // This could be made more efficient by processing blocks in reverse postorder.
 66 
 67         auto dumpAvailability = [] (BasicBlock* block) {
 68             dataLogLn(block-&gt;ssa-&gt;availabilityAtHead);
 69             dataLogLn(block-&gt;ssa-&gt;availabilityAtTail);
 70         };
 71 
 72         auto dumpBytecodeLivenessAtHead = [&amp;] (BasicBlock* block) {
 73             dataLog(&quot;Live: &quot;);
 74             m_graph.forAllLiveInBytecode(
 75                 block-&gt;at(0)-&gt;origin.forExit,
<span class="line-modified"> 76                 [&amp;] (Operand operand) {</span>
<span class="line-modified"> 77                     dataLog(operand, &quot; &quot;);</span>
 78                 });
 79             dataLogLn(&quot;&quot;);
 80         };
 81 
 82         LocalOSRAvailabilityCalculator calculator(m_graph);
 83         bool changed;
 84         do {
 85             changed = false;
 86 
 87             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
 88                 BasicBlock* block = m_graph.block(blockIndex);
 89                 if (!block)
 90                     continue;
 91 
<span class="line-modified"> 92                 if (verbose) {</span>
 93                     dataLogLn(&quot;Before changing Block #&quot;, block-&gt;index);
 94                     dumpAvailability(block);
 95                 }
 96                 calculator.beginBlock(block);
 97 
 98                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex)
 99                     calculator.executeNode(block-&gt;at(nodeIndex));
100 
101                 if (calculator.m_availability == block-&gt;ssa-&gt;availabilityAtTail)
102                     continue;
103 
104                 block-&gt;ssa-&gt;availabilityAtTail = calculator.m_availability;
105                 changed = true;
106 
<span class="line-modified">107                 if (verbose) {</span>
108                     dataLogLn(&quot;After changing Block #&quot;, block-&gt;index);
109                     dumpAvailability(block);
110                 }
111 
112                 for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
113                     BasicBlock* successor = block-&gt;successor(successorIndex);
114                     successor-&gt;ssa-&gt;availabilityAtHead.merge(calculator.m_availability);
115                 }
116 
117                 for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
118                     BasicBlock* successor = block-&gt;successor(successorIndex);
119                     successor-&gt;ssa-&gt;availabilityAtHead.pruneByLiveness(
120                         m_graph, successor-&gt;at(0)-&gt;origin.forExit);
<span class="line-modified">121                     if (verbose) {</span>
122                         dataLogLn(&quot;After pruning Block #&quot;, successor-&gt;index);
123                         dumpAvailability(successor);
124                         dumpBytecodeLivenessAtHead(successor);
125                     }
126                 }
127             }
128         } while (changed);
129 
130         if (validationEnabled()) {
131 
132             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
133                 BasicBlock* block = m_graph.block(blockIndex);
134                 if (!block)
135                     continue;
136 
137                 calculator.beginBlock(block);
138 
139                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
140                     if (block-&gt;at(nodeIndex)-&gt;origin.exitOK) {
141                         // If we&#39;re allowed to exit here, the heap must be in a state
</pre>
<hr />
<pre>
189 
190 LocalOSRAvailabilityCalculator::~LocalOSRAvailabilityCalculator()
191 {
192 }
193 
194 void LocalOSRAvailabilityCalculator::beginBlock(BasicBlock* block)
195 {
196     m_availability = block-&gt;ssa-&gt;availabilityAtHead;
197 }
198 
199 void LocalOSRAvailabilityCalculator::endBlock(BasicBlock* block)
200 {
201     m_availability = block-&gt;ssa-&gt;availabilityAtTail;
202 }
203 
204 void LocalOSRAvailabilityCalculator::executeNode(Node* node)
205 {
206     switch (node-&gt;op()) {
207     case PutStack: {
208         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">209         m_availability.m_locals.operand(data-&gt;operand).setFlush(data-&gt;flushedAt());</span>
210         break;
211     }
212 
213     case KillStack: {
<span class="line-modified">214         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setFlush(FlushedAt(ConflictingFlush));</span>
215         break;
216     }
217 
218     case GetStack: {
219         StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">220         m_availability.m_locals.operand(data-&gt;operand) = Availability(node, data-&gt;flushedAt());</span>
221         break;
222     }
223 
224     case MovHint: {
<span class="line-modified">225         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setNode(node-&gt;child1().node());</span>
226         break;
227     }
228 
229     case ZombieHint: {
<span class="line-modified">230         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setNodeUnavailable();</span>
231         break;
232     }
233 
234     case InitializeEntrypointArguments: {
235         unsigned entrypointIndex = node-&gt;entrypointIndex();
236         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
237         for (unsigned argument = argumentFormats.size(); argument--; ) {
<span class="line-modified">238             FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgumentIncludingThis(argument));</span>
239             m_availability.m_locals.argument(argument) = Availability(flushedAt);
240         }
241         break;
242     }
243 
<span class="line-added">244     case VarargsLength: {</span>
<span class="line-added">245         break;</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
248     case LoadVarargs:
249     case ForwardVarargs: {
250         LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">251         m_availability.m_locals.operand(data-&gt;count) = Availability(FlushedAt(FlushedInt32, data-&gt;machineCount));</span>

252         for (unsigned i = data-&gt;limit; i--;) {
<span class="line-modified">253             m_availability.m_locals.operand(data-&gt;start + i) =</span>
<span class="line-modified">254                 Availability(FlushedAt(FlushedJSValue, data-&gt;machineStart + i));</span>
255         }
256         break;
257     }
258 
259     case PhantomCreateRest:
260     case PhantomDirectArguments:
261     case PhantomClonedArguments: {
262         InlineCallFrame* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
263         if (!inlineCallFrame) {
264             // We don&#39;t need to record anything about how the arguments are to be recovered. It&#39;s just a
265             // given that we can read them from the stack.
266             break;
267         }
268 
269         unsigned numberOfArgumentsToSkip = 0;
270         if (node-&gt;op() == PhantomCreateRest)
271             numberOfArgumentsToSkip = node-&gt;numberOfArgumentsToSkip();
272 
273         if (inlineCallFrame-&gt;isVarargs()) {
274             // Record how to read each argument and the argument count.
275             Availability argumentCount =
<span class="line-modified">276                 m_availability.m_locals.operand(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
277 
278             m_availability.m_heap.set(PromotedHeapLocation(ArgumentCountPLoc, node), argumentCount);
279         }
280 
281         if (inlineCallFrame-&gt;isClosureCall) {
282             Availability callee = m_availability.m_locals.operand(
<span class="line-modified">283                 VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
284             m_availability.m_heap.set(PromotedHeapLocation(ArgumentsCalleePLoc, node), callee);
285         }
286 
<span class="line-modified">287         for (unsigned i = numberOfArgumentsToSkip; i &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1); ++i) {</span>
288             Availability argument = m_availability.m_locals.operand(
<span class="line-modified">289                 VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrame::argumentOffset(i)));</span>
290 
291             m_availability.m_heap.set(PromotedHeapLocation(ArgumentPLoc, node, i), argument);
292         }
293         break;
294     }
295 
296     case PutHint: {
297         m_availability.m_heap.set(
298             PromotedHeapLocation(node-&gt;child1().node(), node-&gt;promotedLocationDescriptor()),
299             Availability(node-&gt;child2().node()));
300         break;
301     }
302 
303     case PhantomSpread:
304         m_availability.m_heap.set(PromotedHeapLocation(SpreadPLoc, node), Availability(node-&gt;child1().node()));
305         break;
306 
307     case PhantomNewArrayWithSpread:
308         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
309             Node* child = m_graph.varArgChild(node, i).node();
</pre>
</td>
</tr>
</table>
<center><a href="DFGNodeType.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSREntry.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Operations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  * Copyright (C) 2008, 2016 Apple Inc. All Rights Reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Library General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Library General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Library General Public License
 16  *  along with this library; see the file COPYING.LIB.  If not, write to
 17  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  *  Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;Operations.h&quot;
 24 
 25 #include &quot;Error.h&quot;
 26 #include &quot;JSBigInt.h&quot;
 27 #include &quot;JSCInlines.h&quot;
 28 #include &quot;JSObject.h&quot;
 29 #include &quot;JSString.h&quot;
 30 #include &lt;wtf/MathExtras.h&gt;
 31 
 32 namespace JSC {
 33 
 34 bool JSValue::equalSlowCase(ExecState* exec, JSValue v1, JSValue v2)
 35 {
 36     return equalSlowCaseInline(exec, v1, v2);
 37 }
 38 
 39 bool JSValue::strictEqualSlowCase(ExecState* exec, JSValue v1, JSValue v2)
 40 {
 41     return strictEqualSlowCaseInline(exec, v1, v2);
 42 }
 43 
 44 NEVER_INLINE JSValue jsAddSlowCase(CallFrame* callFrame, JSValue v1, JSValue v2)
 45 {
 46     // exception for the Date exception in defaultValue()
 47     VM&amp; vm = callFrame-&gt;vm();
 48     auto scope = DECLARE_THROW_SCOPE(vm);
 49     JSValue p1 = v1.toPrimitive(callFrame);
 50     RETURN_IF_EXCEPTION(scope, { });
 51     JSValue p2 = v2.toPrimitive(callFrame);
 52     RETURN_IF_EXCEPTION(scope, { });
 53 
 54     if (p1.isString()) {
 55         if (p2.isCell()) {
 56             JSString* p2String = p2.toString(callFrame);
 57             RETURN_IF_EXCEPTION(scope, { });
 58             RELEASE_AND_RETURN(scope, jsString(callFrame, asString(p1), p2String));
 59         }
 60         String p2String = p2.toWTFString(callFrame);
 61         RETURN_IF_EXCEPTION(scope, { });
 62         RELEASE_AND_RETURN(scope, jsString(callFrame, asString(p1), p2String));
 63     }
 64 
 65     if (p2.isString()) {
 66         if (p1.isCell()) {
 67             JSString* p1String = p1.toString(callFrame);
 68             RETURN_IF_EXCEPTION(scope, { });
 69             RELEASE_AND_RETURN(scope, jsString(callFrame, p1String, asString(p2)));
 70         }
 71         String p1String = p1.toWTFString(callFrame);
 72         RETURN_IF_EXCEPTION(scope, { });
 73         RELEASE_AND_RETURN(scope, jsString(callFrame, p1String, asString(p2)));
 74     }
 75 
 76     auto leftNumeric = p1.toNumeric(callFrame);
 77     RETURN_IF_EXCEPTION(scope, { });
 78     auto rightNumeric = p2.toNumeric(callFrame);
 79     RETURN_IF_EXCEPTION(scope, { });
 80 
 81     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 82         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 83             scope.release();
 84             return JSBigInt::add(callFrame, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));
 85         }
 86 
 87         return throwTypeError(callFrame, scope, &quot;Invalid mix of BigInt and other type in addition.&quot;_s);
 88     }
 89 
 90     return jsNumber(WTF::get&lt;double&gt;(leftNumeric) + WTF::get&lt;double&gt;(rightNumeric));
 91 }
 92 
 93 JSValue jsTypeStringForValue(VM&amp; vm, JSGlobalObject* globalObject, JSValue v)
 94 {
 95     if (v.isUndefined())
 96         return vm.smallStrings.undefinedString();
 97     if (v.isBoolean())
 98         return vm.smallStrings.booleanString();
 99     if (v.isNumber())
100         return vm.smallStrings.numberString();
101     if (v.isString())
102         return vm.smallStrings.stringString();
103     if (v.isSymbol())
104         return vm.smallStrings.symbolString();
105     if (v.isBigInt())
106         return vm.smallStrings.bigintString();
107     if (v.isObject()) {
108         JSObject* object = asObject(v);
109         // Return &quot;undefined&quot; for objects that should be treated
110         // as null when doing comparisons.
111         if (object-&gt;structure(vm)-&gt;masqueradesAsUndefined(globalObject))
112             return vm.smallStrings.undefinedString();
113         if (object-&gt;isFunction(vm))
114             return vm.smallStrings.functionString();
115     }
116     return vm.smallStrings.objectString();
117 }
118 
119 JSValue jsTypeStringForValue(CallFrame* callFrame, JSValue v)
120 {
121     return jsTypeStringForValue(callFrame-&gt;vm(), callFrame-&gt;lexicalGlobalObject(), v);
122 }
123 
124 bool jsIsObjectTypeOrNull(CallFrame* callFrame, JSValue v)
125 {
126     VM&amp; vm = callFrame-&gt;vm();
127     if (!v.isCell())
128         return v.isNull();
129 
130     JSType type = v.asCell()-&gt;type();
131     if (type == StringType || type == SymbolType || type == BigIntType)
132         return false;
133     if (type &gt;= ObjectType) {
134         if (asObject(v)-&gt;structure(vm)-&gt;masqueradesAsUndefined(callFrame-&gt;lexicalGlobalObject()))
135             return false;
136         JSObject* object = asObject(v);
137         if (object-&gt;isFunction(vm))
138             return false;
139     }
140     return true;
141 }
142 
143 size_t normalizePrototypeChain(CallFrame* callFrame, JSCell* base, bool&amp; sawPolyProto)
144 {
145     VM&amp; vm = callFrame-&gt;vm();
146     size_t count = 0;
147     sawPolyProto = false;
148     JSCell* current = base;
149     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();
150     while (1) {
151         Structure* structure = current-&gt;structure(vm);
152         if (structure-&gt;isProxy())
153             return InvalidPrototypeChain;
154 
155         sawPolyProto |= structure-&gt;hasPolyProto();
156 
157         JSValue prototype = structure-&gt;prototypeForLookup(globalObject, current);
158         if (prototype.isNull())
159             return count;
160 
161         current = prototype.asCell();
162         structure = current-&gt;structure(vm);
163         if (structure-&gt;isDictionary()) {
164             if (structure-&gt;hasBeenFlattenedBefore())
165                 return InvalidPrototypeChain;
166             structure-&gt;flattenDictionaryStructure(vm, asObject(current));
167         }
168 
169         ++count;
170     }
171 }
172 
173 } // namespace JSC
    </pre>
  </body>
</html>
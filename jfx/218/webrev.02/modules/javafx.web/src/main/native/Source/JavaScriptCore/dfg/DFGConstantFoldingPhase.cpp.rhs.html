<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGConstantFoldingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGConstantFoldingPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  33 #include &quot;DFGArgumentsUtilities.h&quot;
  34 #include &quot;DFGBasicBlockInlines.h&quot;
  35 #include &quot;DFGGraph.h&quot;
  36 #include &quot;DFGInPlaceAbstractState.h&quot;
  37 #include &quot;DFGInsertionSet.h&quot;
  38 #include &quot;DFGPhase.h&quot;
<a name="1" id="anc1"></a><span class="line-modified">  39 #include &quot;GetByStatus.h&quot;</span>
  40 #include &quot;JSCInlines.h&quot;
  41 #include &quot;PutByIdStatus.h&quot;
  42 #include &quot;StructureCache.h&quot;
  43 
  44 namespace JSC { namespace DFG {
  45 
  46 class ConstantFoldingPhase : public Phase {
  47 public:
  48     ConstantFoldingPhase(Graph&amp; graph)
  49         : Phase(graph, &quot;constant folding&quot;)
  50         , m_state(graph)
  51         , m_interpreter(graph, m_state)
  52         , m_insertionSet(graph)
  53     {
  54     }
  55 
  56     bool run()
  57     {
  58         bool changed = false;
  59 
  60         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
<a name="2" id="anc2"></a><span class="line-modified">  61             if (block-&gt;cfaThinksShouldTryConstantFolding)</span>
  62                 changed |= foldConstants(block);
  63         }
  64 
  65         if (changed &amp;&amp; m_graph.m_form == SSA) {
  66             // It&#39;s now possible that we have Upsilons pointed at JSConstants. Fix that.
  67             for (BasicBlock* block : m_graph.blocksInNaturalOrder())
  68                 fixUpsilons(block);
  69         }
  70 
  71         if (m_graph.m_form == SSA) {
  72             // It&#39;s now possible to simplify basic blocks by placing an Unreachable terminator right
  73             // after anything that invalidates AI.
  74             bool didClipBlock = false;
  75             Vector&lt;Node*&gt; nodesToDelete;
  76             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
  77                 m_state.beginBasicBlock(block);
  78                 for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
  79                     if (block-&gt;at(nodeIndex)-&gt;isTerminal()) {
  80                         // It&#39;s possible that we have something after the terminal. It could be a
  81                         // no-op Check node, for example. We don&#39;t want the logic below to turn that
  82                         // node into Unreachable, since then we&#39;d have two terminators.
  83                         break;
  84                     }
  85                     if (!m_state.isValid()) {
  86                         NodeOrigin origin = block-&gt;at(nodeIndex)-&gt;origin;
  87                         for (unsigned killIndex = nodeIndex; killIndex &lt; block-&gt;size(); ++killIndex)
  88                             nodesToDelete.append(block-&gt;at(killIndex));
  89                         block-&gt;resize(nodeIndex);
  90                         block-&gt;appendNode(m_graph, SpecNone, Unreachable, origin);
  91                         didClipBlock = true;
  92                         break;
  93                     }
  94                     m_interpreter.execute(nodeIndex);
  95                 }
  96                 m_state.reset();
  97             }
  98 
  99             if (didClipBlock) {
 100                 changed = true;
 101 
 102                 m_graph.invalidateNodeLiveness();
 103 
 104                 for (Node* node : nodesToDelete)
 105                     m_graph.deleteNode(node);
 106 
 107                 m_graph.invalidateCFG();
 108                 m_graph.resetReachability();
 109                 m_graph.killUnreachableBlocks();
 110             }
 111         }
 112 
 113         return changed;
 114     }
 115 
 116 private:
 117     bool foldConstants(BasicBlock* block)
 118     {
 119         bool changed = false;
 120         m_state.beginBasicBlock(block);
 121         for (unsigned indexInBlock = 0; indexInBlock &lt; block-&gt;size(); ++indexInBlock) {
 122             if (!m_state.isValid())
 123                 break;
 124 
 125             Node* node = block-&gt;at(indexInBlock);
 126 
 127             bool alreadyHandled = false;
 128             bool eliminated = false;
 129 
 130             switch (node-&gt;op()) {
 131             case BooleanToNumber: {
 132                 if (node-&gt;child1().useKind() == UntypedUse
 133                     &amp;&amp; !m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolean))
 134                     node-&gt;child1().setUseKind(BooleanUse);
 135                 break;
 136             }
 137 
 138             case CompareEq: {
 139                 // FIXME: We should add back the broken folding phase here for comparisions where we prove at least one side has type SpecOther.
 140                 // See: https://bugs.webkit.org/show_bug.cgi?id=174844
 141                 break;
 142             }
 143 
 144             case CompareStrictEq:
 145             case SameValue: {
 146                 if (node-&gt;isBinaryUseKind(UntypedUse)) {
 147                     JSValue child1Constant = m_state.forNode(node-&gt;child1().node()).value();
 148                     JSValue child2Constant = m_state.forNode(node-&gt;child2().node()).value();
 149 
 150                     // FIXME: Revisit this condition when introducing BigInt to JSC.
 151                     auto isNonStringOrBigIntCellConstant = [] (JSValue value) {
 152                         return value &amp;&amp; value.isCell() &amp;&amp; !value.isString() &amp;&amp; !value.isBigInt();
 153                     };
 154 
 155                     if (isNonStringOrBigIntCellConstant(child1Constant)) {
 156                         node-&gt;convertToCompareEqPtr(m_graph.freezeStrong(child1Constant.asCell()), node-&gt;child2());
 157                         changed = true;
 158                     } else if (isNonStringOrBigIntCellConstant(child2Constant)) {
 159                         node-&gt;convertToCompareEqPtr(m_graph.freezeStrong(child2Constant.asCell()), node-&gt;child1());
 160                         changed = true;
 161                     }
 162                 }
 163                 break;
 164             }
 165 
 166             case CheckStructureOrEmpty: {
 167                 const AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 168                 if (value.m_type &amp; SpecEmpty)
 169                     break;
 170                 node-&gt;convertCheckStructureOrEmptyToCheckStructure();
 171                 changed = true;
 172                 FALLTHROUGH;
 173             }
 174             case CheckStructure:
 175             case ArrayifyToStructure: {
 176                 AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 177                 RegisteredStructureSet set;
 178                 if (node-&gt;op() == ArrayifyToStructure) {
 179                     set = node-&gt;structure();
 180                     ASSERT(!isCopyOnWrite(node-&gt;structure()-&gt;indexingMode()));
 181                 }
 182                 else {
 183                     set = node-&gt;structureSet();
 184                     if ((SpecCellCheck &amp; SpecEmpty) &amp;&amp; node-&gt;child1().useKind() == CellUse &amp;&amp; m_state.forNode(node-&gt;child1()).m_type &amp; SpecEmpty) {
 185                         m_insertionSet.insertNode(
 186                             indexInBlock, SpecNone, AssertNotEmpty, node-&gt;origin, Edge(node-&gt;child1().node(), UntypedUse));
 187                     }
 188                 }
 189                 if (value.m_structure.isSubsetOf(set)) {
 190                     m_interpreter.execute(indexInBlock); // Catch the fact that we may filter on cell.
 191                     node-&gt;remove(m_graph);
 192                     eliminated = true;
 193                     break;
 194                 }
 195                 break;
 196             }
 197 
 198             case CheckSubClass: {
 199                 JSValue constant = m_state.forNode(node-&gt;child1()).value();
 200                 if (constant) {
 201                     if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_graph.m_vm, node-&gt;classInfo())) {
 202                         m_interpreter.execute(indexInBlock);
 203                         node-&gt;remove(m_graph);
 204                         eliminated = true;
 205                         break;
 206                     }
 207                 }
 208 
 209                 AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 210 
 211                 if (value.m_structure.isSubClassOf(node-&gt;classInfo())) {
 212                     m_interpreter.execute(indexInBlock);
 213                     node-&gt;remove(m_graph);
 214                     eliminated = true;
 215                     break;
 216                 }
 217                 break;
 218             }
 219 
 220             case GetIndexedPropertyStorage: {
 221                 JSArrayBufferView* view = m_graph.tryGetFoldableView(
 222                     m_state.forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
 223                 if (!view)
 224                     break;
 225 
 226                 if (view-&gt;mode() == FastTypedArray) {
 227                     // FIXME: It would be awesome to be able to fold the property storage for
 228                     // these GC-allocated typed arrays. For now it doesn&#39;t matter because the
 229                     // most common use-cases for constant typed arrays involve large arrays with
 230                     // aliased buffer views.
 231                     // https://bugs.webkit.org/show_bug.cgi?id=125425
 232                     break;
 233                 }
 234 
 235                 m_interpreter.execute(indexInBlock);
 236                 eliminated = true;
 237 
 238                 m_insertionSet.insertCheck(indexInBlock, node-&gt;origin, node-&gt;children);
 239                 node-&gt;convertToConstantStoragePointer(view-&gt;vector());
 240                 break;
 241             }
 242 
 243             case CheckStructureImmediate: {
 244                 AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 245                 const RegisteredStructureSet&amp; set = node-&gt;structureSet();
 246 
 247                 if (value.value()) {
 248                     if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_graph.m_vm, value.value())) {
 249                         if (set.contains(m_graph.registerStructure(structure))) {
 250                             m_interpreter.execute(indexInBlock);
 251                             node-&gt;remove(m_graph);
 252                             eliminated = true;
 253                             break;
 254                         }
 255                     }
 256                 }
 257 
 258                 if (PhiChildren* phiChildren = m_interpreter.phiChildren()) {
 259                     bool allGood = true;
 260                     phiChildren-&gt;forAllTransitiveIncomingValues(
 261                         node,
 262                         [&amp;] (Node* incoming) {
 263                             if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_graph.m_vm)) {
 264                                 if (set.contains(m_graph.registerStructure(structure)))
 265                                     return;
 266                             }
 267                             allGood = false;
 268                         });
 269                     if (allGood) {
 270                         m_interpreter.execute(indexInBlock);
 271                         node-&gt;remove(m_graph);
 272                         eliminated = true;
 273                         break;
 274                     }
 275                 }
 276                 break;
 277             }
 278 
<a name="3" id="anc3"></a><span class="line-added"> 279             case CheckArrayOrEmpty: {</span>
<span class="line-added"> 280                 const AbstractValue&amp; value = m_state.forNode(node-&gt;child1());</span>
<span class="line-added"> 281                 if (!(value.m_type &amp; SpecEmpty)) {</span>
<span class="line-added"> 282                     node-&gt;convertCheckArrayOrEmptyToCheckArray();</span>
<span class="line-added"> 283                     changed = true;</span>
<span class="line-added"> 284                 }</span>
<span class="line-added"> 285                 // Even if the input includes SpecEmpty, we can fall through to CheckArray and remove the node.</span>
<span class="line-added"> 286                 // CheckArrayOrEmpty can be removed when arrayMode meets the requirement. In that case, CellUse&#39;s</span>
<span class="line-added"> 287                 // check just remains, and it works as CheckArrayOrEmpty without ArrayMode checking.</span>
<span class="line-added"> 288                 ASSERT(typeFilterFor(node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
<span class="line-added"> 289                 FALLTHROUGH;</span>
<span class="line-added"> 290             }</span>
<span class="line-added"> 291 </span>
 292             case CheckArray:
 293             case Arrayify: {
 294                 if (!node-&gt;arrayMode().alreadyChecked(m_graph, node, m_state.forNode(node-&gt;child1())))
 295                     break;
 296                 node-&gt;remove(m_graph);
 297                 eliminated = true;
 298                 break;
 299             }
 300 
 301             case PutStructure: {
 302                 if (m_state.forNode(node-&gt;child1()).m_structure.onlyStructure() != node-&gt;transition()-&gt;next)
 303                     break;
 304 
 305                 node-&gt;remove(m_graph);
 306                 eliminated = true;
 307                 break;
 308             }
 309 
 310             case CheckCell: {
 311                 if (m_state.forNode(node-&gt;child1()).value() != node-&gt;cellOperand()-&gt;value())
 312                     break;
 313                 node-&gt;remove(m_graph);
 314                 eliminated = true;
 315                 break;
 316             }
 317 
 318             case AssertNotEmpty:
 319             case CheckNotEmpty: {
 320                 if (m_state.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
 321                     break;
 322                 node-&gt;remove(m_graph);
 323                 eliminated = true;
 324                 break;
 325             }
 326 
<a name="4" id="anc4"></a><span class="line-modified"> 327             case CheckIdent: {</span>
 328                 UniquedStringImpl* uid = node-&gt;uidOperand();
 329                 const UniquedStringImpl* constantUid = nullptr;
 330 
 331                 JSValue childConstant = m_state.forNode(node-&gt;child1()).value();
 332                 if (childConstant) {
 333                     if (childConstant.isString()) {
 334                         if (const auto* impl = asString(childConstant)-&gt;tryGetValueImpl()) {
 335                             // Edge filtering requires that a value here should be StringIdent.
 336                             // However, a constant value propagated in DFG is not filtered.
 337                             // So here, we check the propagated value is actually an atomic string.
 338                             // And if it&#39;s not, we just ignore.
 339                             if (impl-&gt;isAtom())
 340                                 constantUid = static_cast&lt;const UniquedStringImpl*&gt;(impl);
 341                         }
<a name="5" id="anc5"></a><span class="line-added"> 342                     } else if (childConstant.isSymbol()) {</span>
<span class="line-added"> 343                         Symbol* symbol = jsCast&lt;Symbol*&gt;(childConstant);</span>
<span class="line-added"> 344                         constantUid = &amp;symbol-&gt;uid();</span>
 345                     }
 346                 }
 347 
 348                 if (constantUid == uid) {
 349                     node-&gt;remove(m_graph);
 350                     eliminated = true;
 351                 }
 352                 break;
 353             }
 354 
 355             case CheckInBounds: {
 356                 JSValue left = m_state.forNode(node-&gt;child1()).value();
 357                 JSValue right = m_state.forNode(node-&gt;child2()).value();
 358                 if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()
 359                     &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32())) {
 360 
 361                     Node* zero = m_insertionSet.insertConstant(indexInBlock, node-&gt;origin, jsNumber(0));
 362                     node-&gt;convertToIdentityOn(zero);
 363                     eliminated = true;
 364                     break;
 365                 }
 366 
 367                 break;
 368             }
 369 
 370             case GetMyArgumentByVal:
 371             case GetMyArgumentByValOutOfBounds: {
 372                 JSValue indexValue = m_state.forNode(node-&gt;child2()).value();
 373                 if (!indexValue || !indexValue.isUInt32())
 374                     break;
 375 
 376                 Checked&lt;unsigned, RecordOverflow&gt; checkedIndex = indexValue.asUInt32();
 377                 checkedIndex += node-&gt;numberOfArgumentsToSkip();
 378                 if (checkedIndex.hasOverflowed())
 379                     break;
 380 
 381                 unsigned index = checkedIndex.unsafeGet();
 382                 Node* arguments = node-&gt;child1().node();
 383                 InlineCallFrame* inlineCallFrame = arguments-&gt;origin.semantic.inlineCallFrame();
 384 
 385                 // Don&#39;t try to do anything if the index is known to be outside our static bounds. Note
 386                 // that our static bounds are usually strictly larger than the dynamic bounds. The
 387                 // exception is something like this, assuming foo() is not inlined:
 388                 //
 389                 // function foo() { return arguments[5]; }
 390                 //
 391                 // Here the static bound on number of arguments is 0, and we&#39;re accessing index 5. We
 392                 // will not strength-reduce this to GetStack because GetStack is otherwise assumed by the
 393                 // compiler to access those variables that are statically accounted for; for example if
 394                 // we emitted a GetStack on arg6 we would have out-of-bounds access crashes anywhere that
 395                 // uses an Operands&lt;&gt; map. There is not much cost to continuing to use a
 396                 // GetMyArgumentByVal in such statically-out-of-bounds accesses; we just lose CFA unless
 397                 // GCSE removes the access entirely.
 398                 if (inlineCallFrame) {
<a name="6" id="anc6"></a><span class="line-modified"> 399                     if (index &gt;= static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1))</span>
 400                         break;
 401                 } else {
 402                     if (index &gt;= m_state.numberOfArguments() - 1)
 403                         break;
 404                 }
 405 
 406                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 407 
 408                 StackAccessData* data;
 409                 if (inlineCallFrame) {
 410                     data = m_graph.m_stackAccessData.add(
 411                         VirtualRegister(
 412                             inlineCallFrame-&gt;stackOffset +
 413                             CallFrame::argumentOffset(index)),
 414                         FlushedJSValue);
 415                 } else {
 416                     data = m_graph.m_stackAccessData.add(
<a name="7" id="anc7"></a><span class="line-modified"> 417                         virtualRegisterForArgumentIncludingThis(index + 1), FlushedJSValue);</span>
 418                 }
 419 
<a name="8" id="anc8"></a><span class="line-modified"> 420                 if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs() &amp;&amp; index &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1)) {</span>
 421                     node-&gt;convertToGetStack(data);
 422                     eliminated = true;
 423                     break;
 424                 }
 425 
 426                 if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
 427                     break;
 428 
 429                 Node* length = emitCodeToGetArgumentsArrayLength(
 430                     m_insertionSet, arguments, indexInBlock, node-&gt;origin);
 431                 Node* check = m_insertionSet.insertNode(
 432                     indexInBlock, SpecNone, CheckInBounds, node-&gt;origin,
 433                     node-&gt;child2(), Edge(length, Int32Use));
 434                 node-&gt;convertToGetStack(data);
 435                 node-&gt;child1() = Edge(check, UntypedUse);
 436                 eliminated = true;
 437                 break;
 438             }
 439 
 440             case MultiGetByOffset: {
 441                 Edge baseEdge = node-&gt;child1();
 442                 Node* base = baseEdge.node();
 443                 MultiGetByOffsetData&amp; data = node-&gt;multiGetByOffsetData();
 444 
 445                 // First prune the variants, then check if the MultiGetByOffset can be
 446                 // strength-reduced to a GetByOffset.
 447 
 448                 AbstractValue baseValue = m_state.forNode(base);
 449 
 450                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 451                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.
 452 
 453                 for (unsigned i = 0; i &lt; data.cases.size(); ++i) {
 454                     MultiGetByOffsetCase&amp; getCase = data.cases[i];
 455                     getCase.set().filter(baseValue);
 456                     if (getCase.set().isEmpty()) {
 457                         data.cases[i--] = data.cases.last();
 458                         data.cases.removeLast();
 459                         changed = true;
 460                     }
 461                 }
 462 
 463                 if (data.cases.size() != 1)
 464                     break;
 465 
 466                 emitGetByOffset(indexInBlock, node, baseValue, data.cases[0], data.identifierNumber);
 467                 changed = true;
 468                 break;
 469             }
 470 
 471             case MultiPutByOffset: {
 472                 Edge baseEdge = node-&gt;child1();
 473                 Node* base = baseEdge.node();
 474                 MultiPutByOffsetData&amp; data = node-&gt;multiPutByOffsetData();
 475 
 476                 AbstractValue baseValue = m_state.forNode(base);
 477 
 478                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 479                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.
 480 
 481 
 482                 for (unsigned i = 0; i &lt; data.variants.size(); ++i) {
 483                     PutByIdVariant&amp; variant = data.variants[i];
 484                     variant.oldStructure().genericFilter([&amp;] (Structure* structure) -&gt; bool {
 485                         return baseValue.contains(m_graph.registerStructure(structure));
 486                     });
 487 
 488                     if (variant.oldStructure().isEmpty()) {
 489                         data.variants[i--] = data.variants.last();
 490                         data.variants.removeLast();
 491                         changed = true;
 492                         continue;
 493                     }
 494 
 495                     if (variant.kind() == PutByIdVariant::Transition
 496                         &amp;&amp; variant.oldStructure().onlyStructure() == variant.newStructure()) {
 497                         variant = PutByIdVariant::replace(
 498                             variant.oldStructure(),
 499                             variant.offset());
 500                         changed = true;
 501                     }
 502                 }
 503 
 504                 if (data.variants.size() != 1)
 505                     break;
 506 
 507                 emitPutByOffset(
 508                     indexInBlock, node, baseValue, data.variants[0], data.identifierNumber);
 509                 changed = true;
 510                 break;
 511             }
 512 
 513             case MatchStructure: {
 514                 Edge baseEdge = node-&gt;child1();
 515                 Node* base = baseEdge.node();
 516                 MatchStructureData&amp; data = node-&gt;matchStructureData();
 517 
 518                 AbstractValue baseValue = m_state.forNode(base);
 519 
 520                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 521                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.
 522 
 523                 BooleanLattice result = BooleanLattice::Bottom;
 524                 for (unsigned i = 0; i &lt; data.variants.size(); ++i) {
 525                     if (!baseValue.contains(data.variants[i].structure)) {
 526                         data.variants[i--] = data.variants.last();
 527                         data.variants.removeLast();
 528                         changed = true;
 529                         continue;
 530                     }
 531                     result = leastUpperBoundOfBooleanLattices(
 532                         result,
 533                         data.variants[i].result ? BooleanLattice::True : BooleanLattice::False);
 534                 }
 535 
 536                 if (result == BooleanLattice::False || result == BooleanLattice::True) {
 537                     RegisteredStructureSet structureSet;
 538                     for (MatchStructureVariant&amp; variant : data.variants)
 539                         structureSet.add(variant.structure);
 540                     addBaseCheck(indexInBlock, node, baseValue, structureSet);
 541                     m_graph.convertToConstant(
 542                         node, m_graph.freeze(jsBoolean(result == BooleanLattice::True)));
 543                     changed = true;
 544                 }
 545                 break;
 546             }
 547 
 548             case GetByIdDirect:
 549             case GetByIdDirectFlush:
 550             case GetById:
 551             case GetByIdFlush: {
 552                 Edge childEdge = node-&gt;child1();
 553                 Node* child = childEdge.node();
 554                 unsigned identifierNumber = node-&gt;identifierNumber();
 555 
 556                 AbstractValue baseValue = m_state.forNode(child);
 557 
 558                 m_interpreter.execute(indexInBlock); // Push CFA over this node after we get the state before.
 559                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.
 560 
 561                 if (!baseValue.m_structure.isFinite()
 562                     || (node-&gt;child1().useKind() == UntypedUse || (baseValue.m_type &amp; ~SpecCell)))
 563                     break;
 564 
<a name="9" id="anc9"></a><span class="line-modified"> 565                 GetByStatus status = GetByStatus::computeFor(</span>
 566                     baseValue.m_structure.toStructureSet(), m_graph.identifiers()[identifierNumber]);
 567                 if (!status.isSimple())
 568                     break;
 569 
 570                 for (unsigned i = status.numVariants(); i--;) {
 571                     if (!status[i].conditionSet().isEmpty()) {
 572                         // FIXME: We could handle prototype cases.
 573                         // https://bugs.webkit.org/show_bug.cgi?id=110386
 574                         break;
 575                     }
 576                 }
 577 
 578                 auto addFilterStatus = [&amp;] () {
 579                     m_insertionSet.insertNode(
<a name="10" id="anc10"></a><span class="line-modified"> 580                         indexInBlock, SpecNone, FilterGetByStatus, node-&gt;origin,</span>
<span class="line-modified"> 581                         OpInfo(m_graph.m_plan.recordedStatuses().addGetByStatus(node-&gt;origin.semantic, status)),</span>
 582                         Edge(child));
 583                 };
 584 
 585                 if (status.numVariants() == 1) {
 586                     addFilterStatus();
 587                     emitGetByOffset(indexInBlock, node, baseValue, status[0], identifierNumber);
 588                     changed = true;
 589                     break;
 590                 }
 591 
 592                 if (!m_graph.m_plan.isFTL())
 593                     break;
 594 
 595                 addFilterStatus();
 596                 MultiGetByOffsetData* data = m_graph.m_multiGetByOffsetData.add();
 597                 for (const GetByIdVariant&amp; variant : status.variants()) {
 598                     data-&gt;cases.append(
 599                         MultiGetByOffsetCase(
 600                             *m_graph.addStructureSet(variant.structureSet()),
 601                             GetByOffsetMethod::load(variant.offset())));
 602                 }
 603                 data-&gt;identifierNumber = identifierNumber;
 604                 node-&gt;convertToMultiGetByOffset(data);
 605                 changed = true;
 606                 break;
 607             }
 608 
 609             case PutById:
 610             case PutByIdDirect:
 611             case PutByIdFlush: {
 612                 NodeOrigin origin = node-&gt;origin;
 613                 Edge childEdge = node-&gt;child1();
 614                 Node* child = childEdge.node();
 615                 unsigned identifierNumber = node-&gt;identifierNumber();
 616 
 617                 ASSERT(childEdge.useKind() == CellUse);
 618 
 619                 AbstractValue baseValue = m_state.forNode(child);
 620                 AbstractValue valueValue = m_state.forNode(node-&gt;child2());
 621 
<a name="11" id="anc11"></a>


 622                 if (!baseValue.m_structure.isFinite())
 623                     break;
 624 
 625                 PutByIdStatus status = PutByIdStatus::computeFor(
 626                     m_graph.globalObjectFor(origin.semantic),
 627                     baseValue.m_structure.toStructureSet(),
 628                     m_graph.identifiers()[identifierNumber],
 629                     node-&gt;op() == PutByIdDirect);
 630 
 631                 if (!status.isSimple())
 632                     break;
 633 
 634                 ASSERT(status.numVariants());
 635 
 636                 if (status.numVariants() &gt; 1 &amp;&amp; !m_graph.m_plan.isFTL())
 637                     break;
 638 
 639                 changed = true;
 640 
 641                 bool allGood = true;
<a name="12" id="anc12"></a><span class="line-added"> 642                 RegisteredStructureSet newSet;</span>
<span class="line-added"> 643                 TransitionVector transitions;</span>
 644                 for (const PutByIdVariant&amp; variant : status.variants()) {
<a name="13" id="anc13"></a>

 645                     for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {
 646                         if (m_graph.watchCondition(condition))
 647                             continue;
 648 
 649                         Structure* structure = condition.object()-&gt;structure(m_graph.m_vm);
 650                         if (!condition.structureEnsuresValidity(structure)) {
 651                             allGood = false;
 652                             break;
 653                         }
 654 
 655                         m_insertionSet.insertNode(
 656                             indexInBlock, SpecNone, CheckStructure, node-&gt;origin,
 657                             OpInfo(m_graph.addStructureSet(structure)),
 658                             m_insertionSet.insertConstantForUse(
 659                                 indexInBlock, node-&gt;origin, condition.object(), KnownCellUse));
 660                     }
<a name="14" id="anc14"></a><span class="line-added"> 661 </span>
<span class="line-added"> 662                     if (!allGood)</span>
<span class="line-added"> 663                         break;</span>
<span class="line-added"> 664 </span>
<span class="line-added"> 665                     if (variant.kind() == PutByIdVariant::Transition) {</span>
<span class="line-added"> 666                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());</span>
<span class="line-added"> 667                         transitions.append(</span>
<span class="line-added"> 668                             Transition(</span>
<span class="line-added"> 669                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));</span>
<span class="line-added"> 670                         newSet.add(newStructure);</span>
<span class="line-added"> 671                     } else {</span>
<span class="line-added"> 672                         ASSERT(variant.kind() == PutByIdVariant::Replace);</span>
<span class="line-added"> 673                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));</span>
<span class="line-added"> 674                     }</span>
 675                 }
 676 
 677                 if (!allGood)
 678                     break;
 679 
<a name="15" id="anc15"></a><span class="line-added"> 680                 // Push CFA over this node after we get the state before.</span>
<span class="line-added"> 681                 m_interpreter.didFoldClobberWorld();</span>
<span class="line-added"> 682                 m_interpreter.observeTransitions(indexInBlock, transitions);</span>
<span class="line-added"> 683                 if (m_state.forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)</span>
<span class="line-added"> 684                     m_state.setIsValid(false);</span>
<span class="line-added"> 685 </span>
<span class="line-added"> 686                 alreadyHandled = true; // Don&#39;t allow the default constant folder to do things to this.</span>
<span class="line-added"> 687 </span>
 688                 m_insertionSet.insertNode(
 689                     indexInBlock, SpecNone, FilterPutByIdStatus, node-&gt;origin,
 690                     OpInfo(m_graph.m_plan.recordedStatuses().addPutByIdStatus(node-&gt;origin.semantic, status)),
 691                     Edge(child));
 692 
 693                 if (status.numVariants() == 1) {
 694                     emitPutByOffset(indexInBlock, node, baseValue, status[0], identifierNumber);
 695                     break;
 696                 }
 697 
 698                 ASSERT(m_graph.m_plan.isFTL());
 699 
 700                 MultiPutByOffsetData* data = m_graph.m_multiPutByOffsetData.add();
 701                 data-&gt;variants = status.variants();
 702                 data-&gt;identifierNumber = identifierNumber;
 703                 node-&gt;convertToMultiPutByOffset(data);
 704                 break;
 705             }
 706 
 707             case InByVal: {
 708                 AbstractValue&amp; property = m_state.forNode(node-&gt;child2());
 709                 if (JSValue constant = property.value()) {
 710                     if (constant.isString()) {
 711                         JSString* string = asString(constant);
 712                         const StringImpl* impl = string-&gt;tryGetValueImpl();
 713                         if (impl &amp;&amp; impl-&gt;isAtom()) {
 714                             unsigned identifierNumber = m_graph.identifiers().ensure(const_cast&lt;UniquedStringImpl*&gt;(static_cast&lt;const UniquedStringImpl*&gt;(impl)));
 715                             node-&gt;convertToInById(identifierNumber);
 716                             changed = true;
 717                             break;
 718                         }
 719                     }
 720                 }
 721                 break;
 722             }
 723 
 724             case ToPrimitive: {
 725                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))
 726                     break;
 727 
 728                 node-&gt;convertToIdentity();
 729                 changed = true;
 730                 break;
 731             }
 732 
<a name="16" id="anc16"></a><span class="line-added"> 733             case ToPropertyKey: {</span>
<span class="line-added"> 734                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecString | SpecSymbol))</span>
<span class="line-added"> 735                     break;</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737                 node-&gt;convertToIdentity();</span>
<span class="line-added"> 738                 changed = true;</span>
<span class="line-added"> 739                 break;</span>
<span class="line-added"> 740             }</span>
<span class="line-added"> 741 </span>
 742             case ToThis: {
 743                 ToThisResult result = isToThisAnIdentity(m_graph.m_vm, m_graph.isStrictModeFor(node-&gt;origin.semantic), m_state.forNode(node-&gt;child1()));
 744                 if (result == ToThisResult::Identity) {
 745                     node-&gt;convertToIdentity();
 746                     changed = true;
 747                     break;
 748                 }
 749                 if (result == ToThisResult::GlobalThis) {
 750                     node-&gt;convertToGetGlobalThis();
 751                     changed = true;
 752                     break;
 753                 }
 754                 break;
 755             }
 756 
 757             case CreateThis: {
 758                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
 759                     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {
 760                         if (FunctionRareData* rareData = function-&gt;rareData()) {
 761                             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
 762                                 Structure* structure = rareData-&gt;objectAllocationStructure();
 763                                 JSObject* prototype = rareData-&gt;objectAllocationPrototype();
 764                                 if (structure
 765                                     &amp;&amp; (structure-&gt;hasMonoProto() || prototype)
 766                                     &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
 767 
 768                                     m_graph.freeze(rareData);
 769                                     m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
 770                                     node-&gt;convertToNewObject(m_graph.registerStructure(structure));
 771 
 772                                     if (structure-&gt;hasPolyProto()) {
 773                                         StorageAccessData* data = m_graph.m_storageAccessData.add();
 774                                         data-&gt;offset = knownPolyProtoOffset;
 775                                         data-&gt;identifierNumber = m_graph.identifiers().ensure(m_graph.m_vm.propertyNames-&gt;builtinNames().polyProtoName().impl());
 776                                         NodeOrigin origin = node-&gt;origin.withInvalidExit();
 777                                         Node* prototypeNode = m_insertionSet.insertConstant(
 778                                             indexInBlock + 1, origin, m_graph.freeze(prototype));
 779 
 780                                         ASSERT(isInlineOffset(knownPolyProtoOffset));
 781                                         m_insertionSet.insertNode(
 782                                             indexInBlock + 1, SpecNone, PutByOffset, origin, OpInfo(data),
 783                                             Edge(node, KnownCellUse), Edge(node, KnownCellUse), Edge(prototypeNode, UntypedUse));
 784                                     }
 785                                     changed = true;
 786                                     break;
 787 
 788                                 }
 789                             }
 790                         }
 791                     }
 792                 }
 793                 break;
 794             }
 795 
<a name="17" id="anc17"></a><span class="line-added"> 796             case CreatePromise: {</span>
<span class="line-added"> 797                 JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 798                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added"> 799                     if (base == (node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {</span>
<span class="line-added"> 800                         node-&gt;convertToNewPromise(m_graph.registerStructure(node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure()));</span>
<span class="line-added"> 801                         changed = true;</span>
<span class="line-added"> 802                         break;</span>
<span class="line-added"> 803                     }</span>
<span class="line-added"> 804                     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added"> 805                         if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added"> 806                             if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 807                                 Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added"> 808                                 if (structure</span>
<span class="line-added"> 809                                     &amp;&amp; structure-&gt;classInfo() == (node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())</span>
<span class="line-added"> 810                                     &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added"> 811                                     &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 812                                     m_graph.freeze(rareData);</span>
<span class="line-added"> 813                                     m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added"> 814                                     node-&gt;convertToNewPromise(m_graph.registerStructure(structure));</span>
<span class="line-added"> 815                                     changed = true;</span>
<span class="line-added"> 816                                     break;</span>
<span class="line-added"> 817                                 }</span>
<span class="line-added"> 818                             }</span>
<span class="line-added"> 819                         }</span>
<span class="line-added"> 820                     }</span>
<span class="line-added"> 821                 }</span>
<span class="line-added"> 822                 break;</span>
<span class="line-added"> 823             }</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825             case CreateGenerator:</span>
<span class="line-added"> 826             case CreateAsyncGenerator: {</span>
<span class="line-added"> 827                 auto foldConstant = [&amp;] (NodeType newOp, const ClassInfo* classInfo) {</span>
<span class="line-added"> 828                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 829                     if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {</span>
<span class="line-added"> 830                         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {</span>
<span class="line-added"> 831                             if (FunctionRareData* rareData = function-&gt;rareData()) {</span>
<span class="line-added"> 832                                 if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 833                                     Structure* structure = rareData-&gt;internalFunctionAllocationStructure();</span>
<span class="line-added"> 834                                     if (structure</span>
<span class="line-added"> 835                                         &amp;&amp; structure-&gt;classInfo() == classInfo</span>
<span class="line-added"> 836                                         &amp;&amp; structure-&gt;globalObject() == globalObject</span>
<span class="line-added"> 837                                         &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {</span>
<span class="line-added"> 838                                         m_graph.freeze(rareData);</span>
<span class="line-added"> 839                                         m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());</span>
<span class="line-added"> 840                                         node-&gt;convertToNewInternalFieldObject(newOp, m_graph.registerStructure(structure));</span>
<span class="line-added"> 841                                         changed = true;</span>
<span class="line-added"> 842                                         return;</span>
<span class="line-added"> 843                                     }</span>
<span class="line-added"> 844                                 }</span>
<span class="line-added"> 845                             }</span>
<span class="line-added"> 846                         }</span>
<span class="line-added"> 847                     }</span>
<span class="line-added"> 848                 };</span>
<span class="line-added"> 849 </span>
<span class="line-added"> 850                 switch (node-&gt;op()) {</span>
<span class="line-added"> 851                 case CreateGenerator:</span>
<span class="line-added"> 852                     foldConstant(NewGenerator, JSGenerator::info());</span>
<span class="line-added"> 853                     break;</span>
<span class="line-added"> 854                 case CreateAsyncGenerator:</span>
<span class="line-added"> 855                     foldConstant(NewAsyncGenerator, JSAsyncGenerator::info());</span>
<span class="line-added"> 856                     break;</span>
<span class="line-added"> 857                 default:</span>
<span class="line-added"> 858                     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 859                     break;</span>
<span class="line-added"> 860                 }</span>
<span class="line-added"> 861                 break;</span>
<span class="line-added"> 862             }</span>
<span class="line-added"> 863 </span>
 864             case ObjectCreate: {
 865                 if (JSValue base = m_state.forNode(node-&gt;child1()).m_value) {
 866                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 867                     Structure* structure = nullptr;
 868                     if (base.isNull())
 869                         structure = globalObject-&gt;nullPrototypeObjectStructure();
 870                     else if (base.isObject())
 871                         structure = globalObject-&gt;vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());
 872 
 873                     if (structure) {
 874                         node-&gt;convertToNewObject(m_graph.registerStructure(structure));
 875                         changed = true;
 876                         break;
 877                     }
 878                 }
 879                 break;
 880             }
 881 
 882             case ObjectKeys: {
 883                 if (node-&gt;child1().useKind() == ObjectUse) {
 884                     auto&amp; structureSet = m_state.forNode(node-&gt;child1()).m_structure;
 885                     if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
 886                         RegisteredStructure structure = structureSet.onlyStructure();
 887                         if (auto* rareData = structure-&gt;rareDataConcurrently()) {
 888                             if (auto* immutableButterfly = rareData-&gt;cachedOwnKeysConcurrently()) {
 889                                 if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 890                                     node-&gt;convertToNewArrayBuffer(m_graph.freeze(immutableButterfly));
 891                                     changed = true;
 892                                     break;
 893                                 }
 894                             }
 895                         }
 896                     }
 897                 }
 898                 break;
 899             }
 900 
<a name="18" id="anc18"></a><span class="line-added"> 901             case NewArrayWithSpread: {</span>
<span class="line-added"> 902                 if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {</span>
<span class="line-added"> 903                     BitVector* bitVector = node-&gt;bitVector();</span>
<span class="line-added"> 904                     if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added"> 905                         Edge use = m_graph.varArgChild(node, 0);</span>
<span class="line-added"> 906                         if (use-&gt;op() == PhantomSpread) {</span>
<span class="line-added"> 907                             if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-added"> 908                                 auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added"> 909                                 if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added"> 910                                     node-&gt;convertToNewArrayBuffer(m_graph.freeze(immutableButterfly));</span>
<span class="line-added"> 911                                     changed = true;</span>
<span class="line-added"> 912                                     break;</span>
<span class="line-added"> 913                                 }</span>
<span class="line-added"> 914                             }</span>
<span class="line-added"> 915                         }</span>
<span class="line-added"> 916                     }</span>
<span class="line-added"> 917                 }</span>
<span class="line-added"> 918                 break;</span>
<span class="line-added"> 919             }</span>
<span class="line-added"> 920 </span>
 921             case ToNumber: {
 922                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)
 923                     break;
 924 
 925                 node-&gt;convertToIdentity();
 926                 changed = true;
 927                 break;
 928             }
 929 
<a name="19" id="anc19"></a><span class="line-added"> 930             case ToNumeric: {</span>
<span class="line-added"> 931                 if (m_state.forNode(node-&gt;child1()).m_type &amp; ~(SpecBytecodeNumber | SpecBigInt))</span>
<span class="line-added"> 932                     break;</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934                 node-&gt;convertToIdentity();</span>
<span class="line-added"> 935                 changed = true;</span>
<span class="line-added"> 936                 break;</span>
<span class="line-added"> 937             }</span>
<span class="line-added"> 938 </span>
 939             case NormalizeMapKey: {
 940                 SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
 941                 if (m_state.forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)
 942                     break;
 943 
 944                 node-&gt;convertToIdentity();
 945                 changed = true;
 946                 break;
 947             }
 948 
 949             case ParseInt: {
 950                 AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
 951                 if (!value.m_type || (value.m_type &amp; ~SpecInt32Only))
 952                     break;
 953 
 954                 JSValue radix;
 955                 if (!node-&gt;child2())
 956                     radix = jsNumber(0);
 957                 else
 958                     radix = m_state.forNode(node-&gt;child2()).m_value;
 959 
 960                 if (!radix.isNumber())
 961                     break;
 962 
 963                 if (radix.asNumber() == 0 || radix.asNumber() == 10) {
 964                     node-&gt;child2() = Edge();
 965                     node-&gt;convertToIdentity();
 966                     changed = true;
 967                 }
 968 
 969                 break;
 970             }
 971 
 972             case NumberToStringWithRadix: {
 973                 JSValue radixValue = m_state.forNode(node-&gt;child2()).m_value;
 974                 if (radixValue &amp;&amp; radixValue.isInt32()) {
 975                     int32_t radix = radixValue.asInt32();
 976                     if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
 977                         if (radix == 10) {
 978                             node-&gt;setOpAndDefaultFlags(ToString);
 979                             node-&gt;clearFlags(NodeMustGenerate);
 980                             node-&gt;child2() = Edge();
 981                         } else
 982                             node-&gt;convertToNumberToStringWithValidRadixConstant(radix);
 983                         changed = true;
 984                         break;
 985                     }
 986                 }
 987                 break;
 988             }
 989 
 990             case Check: {
 991                 alreadyHandled = true;
 992                 m_interpreter.execute(indexInBlock);
 993                 for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 994                     Edge edge = node-&gt;children.child(i);
 995                     if (!edge)
 996                         break;
 997                     if (edge.isProved() || edge.willNotHaveCheck()) {
 998                         node-&gt;children.removeEdge(i--);
 999                         changed = true;
1000                     }
1001                 }
1002                 break;
1003             }
1004 
1005             case CheckVarargs: {
1006                 alreadyHandled = true;
1007                 m_interpreter.execute(indexInBlock);
1008                 unsigned targetIndex = 0;
1009                 for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
1010                     Edge&amp; edge = m_graph.varArgChild(node, i);
1011                     if (!edge)
1012                         continue;
1013                     if (edge.isProved() || edge.willNotHaveCheck()) {
1014                         edge = Edge();
1015                         changed = true;
1016                         continue;
1017                     }
1018                     Edge&amp; dst = m_graph.varArgChild(node, targetIndex++);
1019                     std::swap(dst, edge);
1020                 }
1021                 node-&gt;children.setNumChildren(targetIndex);
1022                 break;
1023             }
1024 
1025             case MakeRope: {
1026                 for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
1027                     Edge&amp; edge = node-&gt;children.child(i);
1028                     if (!edge)
1029                         break;
1030                     JSValue childConstant = m_state.forNode(edge).value();
1031                     if (!childConstant)
1032                         continue;
1033                     if (!childConstant.isString())
1034                         continue;
1035                     if (asString(childConstant)-&gt;length())
1036                         continue;
1037 
1038                     // Don&#39;t allow the MakeRope to have zero children.
1039                     if (!i &amp;&amp; !node-&gt;child2())
1040                         break;
1041 
1042                     node-&gt;children.removeEdge(i--);
1043                     changed = true;
1044                 }
1045 
1046                 if (!node-&gt;child2()) {
1047                     ASSERT(!node-&gt;child3());
1048                     node-&gt;convertToIdentity();
1049                     changed = true;
1050                 }
1051                 break;
1052             }
1053 
1054             case CheckTypeInfoFlags: {
1055                 const AbstractValue&amp; abstractValue = m_state.forNode(node-&gt;child1());
1056                 unsigned bits = node-&gt;typeInfoOperand();
1057                 ASSERT(bits);
1058                 if (bits == ImplementsDefaultHasInstance) {
1059                     if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
1060                         eliminated = true;
1061                         node-&gt;remove(m_graph);
1062                         break;
1063                     }
1064                 }
1065 
1066                 if (JSValue value = abstractValue.value()) {
1067                     if (value.isCell()) {
1068                         // This works because if we see a cell here, we know it&#39;s fully constructed
1069                         // and we can read its inline type info flags. These flags don&#39;t change over the
1070                         // object&#39;s lifetime.
1071                         if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
1072                             eliminated = true;
1073                             node-&gt;remove(m_graph);
1074                             break;
1075                         }
1076                     }
1077                 }
1078 
1079                 if (abstractValue.m_structure.isFinite()) {
1080                     bool ok = true;
1081                     abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
1082                         ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
1083                     });
1084                     if (ok) {
1085                         eliminated = true;
1086                         node-&gt;remove(m_graph);
1087                         break;
1088                     }
1089                 }
1090 
1091                 break;
1092             }
1093 
1094             case PhantomNewObject:
1095             case PhantomNewFunction:
1096             case PhantomNewGeneratorFunction:
1097             case PhantomNewAsyncGeneratorFunction:
1098             case PhantomNewAsyncFunction:
<a name="20" id="anc20"></a><span class="line-added">1099             case PhantomNewArrayIterator:</span>
1100             case PhantomCreateActivation:
1101             case PhantomDirectArguments:
1102             case PhantomClonedArguments:
1103             case PhantomCreateRest:
1104             case PhantomSpread:
1105             case PhantomNewArrayWithSpread:
1106             case PhantomNewArrayBuffer:
1107             case PhantomNewRegexp:
1108             case BottomValue:
1109                 alreadyHandled = true;
1110                 break;
1111 
1112             default:
1113                 break;
1114             }
1115 
1116             if (eliminated) {
1117                 changed = true;
1118                 continue;
1119             }
1120 
1121             if (alreadyHandled)
1122                 continue;
1123 
1124             m_interpreter.execute(indexInBlock);
1125             if (!m_state.isValid()) {
1126                 // If we invalidated then we shouldn&#39;t attempt to constant-fold. Here&#39;s an
1127                 // example:
1128                 //
1129                 //     c: JSConstant(4.2)
1130                 //     x: ValueToInt32(Check:Int32:@const)
1131                 //
1132                 // It would be correct for an analysis to assume that execution cannot
1133                 // proceed past @x. Therefore, constant-folding @x could be rather bad. But,
1134                 // the CFA may report that it found a constant even though it also reported
1135                 // that everything has been invalidated. This will only happen in a couple of
1136                 // the constant folding cases; most of them are also separately defensive
1137                 // about such things.
1138                 break;
1139             }
1140             if (!node-&gt;shouldGenerate() || m_state.didClobber() || node-&gt;hasConstant() || !node-&gt;result())
1141                 continue;
1142 
1143             // Interesting fact: this freezing that we do right here may turn an fragile value into
1144             // a weak value. See DFGValueStrength.h.
1145             FrozenValue* value = m_graph.freeze(m_state.forNode(node).value());
1146             if (!*value)
1147                 continue;
1148 
1149             if (node-&gt;op() == GetLocal) {
1150                 // Need to preserve bytecode liveness in ThreadedCPS form. This wouldn&#39;t be necessary
1151                 // if it wasn&#39;t for https://bugs.webkit.org/show_bug.cgi?id=144086.
1152                 m_insertionSet.insertNode(
1153                     indexInBlock, SpecNone, PhantomLocal, node-&gt;origin,
1154                     OpInfo(node-&gt;variableAccessData()));
1155                 m_graph.dethread();
1156             } else
1157                 m_insertionSet.insertCheck(m_graph, indexInBlock, node);
1158             m_graph.convertToConstant(node, value);
1159 
1160             changed = true;
1161         }
1162         m_state.reset();
1163         m_insertionSet.execute(block);
1164 
1165         return changed;
1166     }
1167 
1168     void emitGetByOffset(unsigned indexInBlock, Node* node, const AbstractValue&amp; baseValue, const MultiGetByOffsetCase&amp; getCase, unsigned identifierNumber)
1169     {
1170         // When we get to here we have already emitted all of the requisite checks for everything.
1171         // So, we just need to emit what the method object tells us to emit.
1172 
1173         addBaseCheck(indexInBlock, node, baseValue, getCase.set());
1174 
1175         GetByOffsetMethod method = getCase.method();
1176 
1177         switch (method.kind()) {
1178         case GetByOffsetMethod::Invalid:
1179             RELEASE_ASSERT_NOT_REACHED();
1180             return;
1181 
1182         case GetByOffsetMethod::Constant:
1183             m_graph.convertToConstant(node, method.constant());
1184             return;
1185 
1186         case GetByOffsetMethod::Load:
1187             emitGetByOffset(indexInBlock, node, node-&gt;child1(), identifierNumber, method.offset());
1188             return;
1189 
1190         case GetByOffsetMethod::LoadFromPrototype: {
1191             Node* child = m_insertionSet.insertConstant(
1192                 indexInBlock, node-&gt;origin, method.prototype());
1193             emitGetByOffset(
1194                 indexInBlock, node, Edge(child, KnownCellUse), identifierNumber, method.offset());
1195             return;
1196         } }
1197 
1198         RELEASE_ASSERT_NOT_REACHED();
1199     }
1200 
1201     void emitGetByOffset(unsigned indexInBlock, Node* node, const AbstractValue&amp; baseValue, const GetByIdVariant&amp; variant, unsigned identifierNumber)
1202     {
1203         Edge childEdge = node-&gt;child1();
1204 
1205         addBaseCheck(indexInBlock, node, baseValue, variant.structureSet());
1206 
1207         // We aren&#39;t set up to handle prototype stuff.
1208         DFG_ASSERT(m_graph, node, variant.conditionSet().isEmpty());
1209 
1210         if (JSValue value = m_graph.tryGetConstantProperty(baseValue.m_value, *m_graph.addStructureSet(variant.structureSet()), variant.offset())) {
1211             m_graph.convertToConstant(node, m_graph.freeze(value));
1212             return;
1213         }
1214 
1215         emitGetByOffset(indexInBlock, node, childEdge, identifierNumber, variant.offset());
1216     }
1217 
1218     void emitGetByOffset(
1219         unsigned indexInBlock, Node* node, Edge childEdge, unsigned identifierNumber,
1220         PropertyOffset offset)
1221     {
1222         childEdge.setUseKind(KnownCellUse);
1223 
1224         Edge propertyStorage;
1225 
1226         if (isInlineOffset(offset))
1227             propertyStorage = childEdge;
1228         else {
1229             propertyStorage = Edge(m_insertionSet.insertNode(
1230                 indexInBlock, SpecNone, GetButterfly, node-&gt;origin, childEdge));
1231         }
1232 
1233         StorageAccessData&amp; data = *m_graph.m_storageAccessData.add();
1234         data.offset = offset;
1235         data.identifierNumber = identifierNumber;
1236 
1237         node-&gt;convertToGetByOffset(data, propertyStorage, childEdge);
1238     }
1239 
1240     void emitPutByOffset(unsigned indexInBlock, Node* node, const AbstractValue&amp; baseValue, const PutByIdVariant&amp; variant, unsigned identifierNumber)
1241     {
1242         NodeOrigin origin = node-&gt;origin;
1243         Edge childEdge = node-&gt;child1();
1244 
1245         addBaseCheck(indexInBlock, node, baseValue, variant.oldStructure());
1246 
1247         node-&gt;child1().setUseKind(KnownCellUse);
1248         childEdge.setUseKind(KnownCellUse);
1249 
1250         Transition* transition = 0;
1251         if (variant.kind() == PutByIdVariant::Transition) {
1252             transition = m_graph.m_transitions.add(
1253                 m_graph.registerStructure(variant.oldStructureForTransition()), m_graph.registerStructure(variant.newStructure()));
1254         }
1255 
1256         Edge propertyStorage;
1257 
1258         DFG_ASSERT(m_graph, node, origin.exitOK);
1259         bool canExit = true;
1260         bool didAllocateStorage = false;
1261 
1262         if (isInlineOffset(variant.offset()))
1263             propertyStorage = childEdge;
1264         else if (!variant.reallocatesStorage()) {
1265             propertyStorage = Edge(m_insertionSet.insertNode(
1266                 indexInBlock, SpecNone, GetButterfly, origin, childEdge));
1267         } else if (!variant.oldStructureForTransition()-&gt;outOfLineCapacity()) {
1268             ASSERT(variant.newStructure()-&gt;outOfLineCapacity());
1269             ASSERT(!isInlineOffset(variant.offset()));
1270             Node* allocatePropertyStorage = m_insertionSet.insertNode(
1271                 indexInBlock, SpecNone, AllocatePropertyStorage,
1272                 origin, OpInfo(transition), childEdge);
1273             propertyStorage = Edge(allocatePropertyStorage);
1274             didAllocateStorage = true;
1275         } else {
1276             ASSERT(variant.oldStructureForTransition()-&gt;outOfLineCapacity());
1277             ASSERT(variant.newStructure()-&gt;outOfLineCapacity() &gt; variant.oldStructureForTransition()-&gt;outOfLineCapacity());
1278             ASSERT(!isInlineOffset(variant.offset()));
1279 
1280             Node* reallocatePropertyStorage = m_insertionSet.insertNode(
1281                 indexInBlock, SpecNone, ReallocatePropertyStorage, origin,
1282                 OpInfo(transition), childEdge,
1283                 Edge(m_insertionSet.insertNode(
1284                     indexInBlock, SpecNone, GetButterfly, origin, childEdge)));
1285             propertyStorage = Edge(reallocatePropertyStorage);
1286             didAllocateStorage = true;
1287         }
1288 
1289         StorageAccessData&amp; data = *m_graph.m_storageAccessData.add();
1290         data.offset = variant.offset();
1291         data.identifierNumber = identifierNumber;
1292 
1293         node-&gt;convertToPutByOffset(data, propertyStorage, childEdge);
1294         node-&gt;origin.exitOK = canExit;
1295 
1296         if (variant.kind() == PutByIdVariant::Transition) {
1297             if (didAllocateStorage) {
1298                 m_insertionSet.insertNode(
1299                     indexInBlock + 1, SpecNone, NukeStructureAndSetButterfly,
1300                     origin.withInvalidExit(), childEdge, propertyStorage);
1301             }
1302 
1303             // FIXME: PutStructure goes last until we fix either
1304             // https://bugs.webkit.org/show_bug.cgi?id=142921 or
1305             // https://bugs.webkit.org/show_bug.cgi?id=142924.
1306             m_insertionSet.insertNode(
1307                 indexInBlock + 1, SpecNone, PutStructure, origin.withInvalidExit(), OpInfo(transition),
1308                 childEdge);
1309         }
1310     }
1311 
1312     void addBaseCheck(
1313         unsigned indexInBlock, Node* node, const AbstractValue&amp; baseValue, const StructureSet&amp; set)
1314     {
1315         addBaseCheck(indexInBlock, node, baseValue, *m_graph.addStructureSet(set));
1316     }
1317 
1318     void addBaseCheck(
1319         unsigned indexInBlock, Node* node, const AbstractValue&amp; baseValue, const RegisteredStructureSet&amp; set)
1320     {
1321         if (!baseValue.m_structure.isSubsetOf(set)) {
1322             // Arises when we prune MultiGetByOffset. We could have a
1323             // MultiGetByOffset with a single variant that checks for structure S,
1324             // and the input has structures S and T, for example.
1325             ASSERT(node-&gt;child1());
1326             m_insertionSet.insertNode(
1327                 indexInBlock, SpecNone, CheckStructure, node-&gt;origin,
1328                 OpInfo(m_graph.addStructureSet(set.toStructureSet())), node-&gt;child1());
1329             return;
1330         }
1331 
1332         if (baseValue.m_type &amp; ~SpecCell)
1333             m_insertionSet.insertCheck(indexInBlock, node-&gt;origin, node-&gt;child1());
1334     }
1335 
1336     void addStructureTransitionCheck(NodeOrigin origin, unsigned indexInBlock, JSCell* cell, Structure* structure)
1337     {
1338         {
1339             StructureRegistrationResult result;
1340             m_graph.registerStructure(cell-&gt;structure(m_graph.m_vm), result);
1341             if (result == StructureRegisteredAndWatched)
1342                 return;
1343         }
1344 
1345         m_graph.registerStructure(structure);
1346 
1347         Node* weakConstant = m_insertionSet.insertNode(
1348             indexInBlock, speculationFromValue(cell), JSConstant, origin,
1349             OpInfo(m_graph.freeze(cell)));
1350 
1351         m_insertionSet.insertNode(
1352             indexInBlock, SpecNone, CheckStructure, origin,
1353             OpInfo(m_graph.addStructureSet(structure)), Edge(weakConstant, CellUse));
1354     }
1355 
1356     void fixUpsilons(BasicBlock* block)
1357     {
1358         for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
1359             Node* node = block-&gt;at(nodeIndex);
1360             if (node-&gt;op() != Upsilon)
1361                 continue;
1362             switch (node-&gt;phi()-&gt;op()) {
1363             case Phi:
1364                 break;
1365             case JSConstant:
1366             case DoubleConstant:
1367             case Int52Constant:
1368                 node-&gt;remove(m_graph);
1369                 break;
1370             default:
1371                 DFG_CRASH(m_graph, node, &quot;Bad Upsilon phi() pointer&quot;);
1372                 break;
1373             }
1374         }
1375     }
1376 
1377     InPlaceAbstractState m_state;
1378     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
1379     InsertionSet m_insertionSet;
1380 };
1381 
1382 bool performConstantFolding(Graph&amp; graph)
1383 {
1384     return runPhase&lt;ConstantFoldingPhase&gt;(graph);
1385 }
1386 
1387 } } // namespace JSC::DFG
1388 
1389 #endif // ENABLE(DFG_JIT)
1390 
1391 
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
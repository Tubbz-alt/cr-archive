<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/ParsedContentType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NetworkStorageSession.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceHandle.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/ParsedContentType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 namespace WebCore {
 40 
 41 static void skipSpaces(StringView input, unsigned&amp; startIndex)
 42 {
 43     while (startIndex &lt; input.length() &amp;&amp; isHTTPSpace(input[startIndex]))
 44         ++startIndex;
 45 }
 46 
 47 static bool isQuotedStringTokenCharacter(UChar c)
 48 {
 49     return (c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;) || (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF) || c == &#39;\t&#39;;
 50 }
 51 
 52 static bool isTokenCharacter(UChar c)
 53 {
 54     return isASCII(c) &amp;&amp; c &gt; &#39; &#39; &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;(&#39; &amp;&amp; c != &#39;)&#39; &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;/&#39; &amp;&amp; (c &lt; &#39;:&#39; || c &gt; &#39;@&#39;) &amp;&amp; (c &lt; &#39;[&#39; || c &gt; &#39;]&#39;);
 55 }
 56 
 57 using CharacterMeetsCondition = bool (*)(UChar);
 58 
<span class="line-modified"> 59 static Optional&lt;StringView&gt; parseToken(StringView input, unsigned&amp; startIndex, CharacterMeetsCondition characterMeetsCondition, Mode mode, bool skipTrailingWhitespace = false)</span>
 60 {
 61     unsigned inputLength = input.length();
 62     unsigned tokenStart = startIndex;
 63     unsigned&amp; tokenEnd = startIndex;
 64 
 65     if (tokenEnd &gt;= inputLength)
<span class="line-modified"> 66         return WTF::nullopt;</span>
 67 
 68     while (tokenEnd &lt; inputLength &amp;&amp; characterMeetsCondition(input[tokenEnd])) {
 69         if (mode == Mode::Rfc2045 &amp;&amp; !isTokenCharacter(input[tokenEnd]))
 70             break;
 71         ++tokenEnd;
 72     }
 73 
 74     if (tokenEnd == tokenStart)
<span class="line-modified"> 75         return WTF::nullopt;</span>
 76     if (skipTrailingWhitespace) {
 77         while (input[tokenEnd - 1] == &#39; &#39;)
 78             --tokenEnd;
 79     }
 80     return input.substring(tokenStart, tokenEnd - tokenStart);
 81 }
 82 
 83 static bool isNotQuoteOrBackslash(UChar ch)
 84 {
 85     return ch != &#39;&quot;&#39; &amp;&amp; ch != &#39;\\&#39;;
 86 }
 87 
 88 static String collectHTTPQuotedString(StringView input, unsigned&amp; startIndex)
 89 {
 90     ASSERT(input[startIndex] == &#39;&quot;&#39;);
 91     unsigned inputLength = input.length();
 92     unsigned&amp; position = startIndex;
 93     position++;
 94     StringBuilder builder;
 95     while (true) {
</pre>
<hr />
<pre>
108         } else {
109             ASSERT(quoteOrBackslash == &#39;&quot;&#39;);
110             break;
111         }
112 
113     }
114     return builder.toString();
115 }
116 
117 static bool containsNonTokenCharacters(StringView input, Mode mode)
118 {
119     if (mode == Mode::MimeSniff)
120         return !isValidHTTPToken(input.toStringWithoutCopying());
121     for (unsigned index = 0; index &lt; input.length(); ++index) {
122         if (!isTokenCharacter(input[index]))
123             return true;
124     }
125     return false;
126 }
127 
<span class="line-modified">128 static Optional&lt;StringView&gt; parseQuotedString(StringView input, unsigned&amp; startIndex)</span>
129 {
130     unsigned inputLength = input.length();
131     unsigned quotedStringStart = startIndex + 1;
132     unsigned&amp; quotedStringEnd = startIndex;
133 
134     if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">135         return WTF::nullopt;</span>
136 
137     if (input[quotedStringEnd++] != &#39;&quot;&#39; || quotedStringEnd &gt;= inputLength)
<span class="line-modified">138         return WTF::nullopt;</span>
139 
140     bool lastCharacterWasBackslash = false;
141     char currentCharacter;
142     while ((currentCharacter = input[quotedStringEnd++]) != &#39;&quot;&#39; || lastCharacterWasBackslash) {
143         if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">144             return WTF::nullopt;</span>
145         if (currentCharacter == &#39;\\&#39; &amp;&amp; !lastCharacterWasBackslash) {
146             lastCharacterWasBackslash = true;
147             continue;
148         }
149         if (lastCharacterWasBackslash)
150             lastCharacterWasBackslash = false;
151     }
152     if (input[quotedStringEnd - 1] == &#39;&quot;&#39;)
153         quotedStringEnd++;
154     return input.substring(quotedStringStart, quotedStringEnd - quotedStringStart);
155 }
156 
157 // From http://tools.ietf.org/html/rfc2045#section-5.1:
158 //
159 // content := &quot;Content-Type&quot; &quot;:&quot; type &quot;/&quot; subtype
160 //            *(&quot;;&quot; parameter)
161 //            ; Matching of media type and subtype
162 //            ; is ALWAYS case-insensitive.
163 //
164 // type := discrete-type / composite-type
</pre>
<hr />
<pre>
217 
218 static bool containsNewline(UChar ch)
219 {
220     return ch == &#39;\r&#39; || ch == &#39;\n&#39;;
221 }
222 
223 bool ParsedContentType::parseContentType(Mode mode)
224 {
225     if (mode == Mode::Rfc2045 &amp;&amp; m_contentType.find(containsNewline) != notFound)
226         return false;
227     unsigned index = 0;
228     unsigned contentTypeLength = m_contentType.length();
229     skipSpaces(m_contentType, index);
230     if (index &gt;= contentTypeLength)  {
231         LOG_ERROR(&quot;Invalid Content-Type string &#39;%s&#39;&quot;, m_contentType.ascii().data());
232         return false;
233     }
234 
235     unsigned contentTypeStart = index;
236     auto typeRange = parseToken(m_contentType, index, isNotForwardSlash, mode);
<span class="line-modified">237     if (!typeRange || containsNonTokenCharacters(*typeRange, mode)) {</span>
238         LOG_ERROR(&quot;Invalid Content-Type, invalid type value.&quot;);
239         return false;
240     }
241 
242     if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;/&#39;) {
243         LOG_ERROR(&quot;Invalid Content-Type, missing &#39;/&#39;.&quot;);
244         return false;
245     }
246 
247     auto subTypeRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
<span class="line-modified">248     if (!subTypeRange || containsNonTokenCharacters(*subTypeRange, mode)) {</span>
249         LOG_ERROR(&quot;Invalid Content-Type, invalid subtype value.&quot;);
250         return false;
251     }
252 
253     // There should not be any quoted strings until we reach the parameters.
254     size_t semiColonIndex = m_contentType.find(&#39;;&#39;, contentTypeStart);
255     if (semiColonIndex == notFound) {
256         setContentType(m_contentType.substring(contentTypeStart, contentTypeLength - contentTypeStart), mode);
257         return true;
258     }
259 
260     setContentType(m_contentType.substring(contentTypeStart, semiColonIndex - contentTypeStart), mode);
261     index = semiColonIndex + 1;
262     while (true) {
263         skipSpaces(m_contentType, index);
264         auto keyRange = parseToken(m_contentType, index, isNotSemicolonOrEqualSign, mode);
<span class="line-modified">265         if (mode == Mode::Rfc2045 &amp;&amp; (!keyRange || index &gt;= contentTypeLength)) {</span>
266             LOG_ERROR(&quot;Invalid Content-Type parameter name.&quot;);
267             return false;
268         }
269 
270         // Should we tolerate spaces here?
271         if (mode == Mode::Rfc2045) {
272             if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;=&#39;) {
273                 LOG_ERROR(&quot;Invalid Content-Type malformed parameter.&quot;);
274                 return false;
275             }
276         } else {
277             if (index &gt;= contentTypeLength)
278                 break;
279             if (m_contentType[index] != &#39;=&#39; &amp;&amp; m_contentType[index] != &#39;;&#39;) {
280                 LOG_ERROR(&quot;Invalid Content-Type malformed parameter.&quot;);
281                 return false;
282             }
283             if (m_contentType[index++] == &#39;;&#39;)
284                 continue;
285         }
<span class="line-removed">286         String parameterName = keyRange-&gt;toString();</span>
287 
288         // Should we tolerate spaces here?
289         String parameterValue;
<span class="line-modified">290         Optional&lt;StringView&gt; valueRange;</span>
291         if (index &lt; contentTypeLength &amp;&amp; m_contentType[index] == &#39;&quot;&#39;) {
292             if (mode == Mode::MimeSniff) {
293                 parameterValue = collectHTTPQuotedString(m_contentType, index);
294                 parseToken(m_contentType, index, isNotSemicolon, mode);
295             } else
296                 valueRange = parseQuotedString(m_contentType, index);
297         } else
298             valueRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
299 
<span class="line-removed">300 </span>
301         if (parameterValue.isNull()) {
<span class="line-modified">302             if (!valueRange) {</span>
303                 if (mode == Mode::MimeSniff)
304                     continue;
305                 LOG_ERROR(&quot;Invalid Content-Type, invalid parameter value.&quot;);
306                 return false;
307             }
<span class="line-modified">308             parameterValue = valueRange-&gt;toString();</span>
309         }
310 
311         // Should we tolerate spaces here?
312         if (mode == Mode::Rfc2045 &amp;&amp; index &lt; contentTypeLength &amp;&amp; m_contentType[index++] != &#39;;&#39;) {
313             LOG_ERROR(&quot;Invalid Content-Type, invalid character at the end of key/value parameter.&quot;);
314             return false;
315         }
316 
<span class="line-modified">317         setContentTypeParameter(parameterName, parameterValue, mode);</span>

318 
319         if (index &gt;= contentTypeLength)
320             return true;
321     }
322 
323     return true;
324 }
325 
326 Optional&lt;ParsedContentType&gt; ParsedContentType::create(const String&amp; contentType, Mode mode)
327 {
328     ParsedContentType parsedContentType(mode == Mode::Rfc2045 ? contentType : stripLeadingAndTrailingHTTPSpaces(contentType));
329     if (!parsedContentType.parseContentType(mode))
330         return WTF::nullopt;
331     return { WTFMove(parsedContentType) };
332 }
333 
334 bool isValidContentType(const String&amp; contentType, Mode mode)
335 {
336     return ParsedContentType::create(contentType, mode) != WTF::nullopt;
337 }
</pre>
</td>
<td>
<hr />
<pre>
 39 namespace WebCore {
 40 
 41 static void skipSpaces(StringView input, unsigned&amp; startIndex)
 42 {
 43     while (startIndex &lt; input.length() &amp;&amp; isHTTPSpace(input[startIndex]))
 44         ++startIndex;
 45 }
 46 
 47 static bool isQuotedStringTokenCharacter(UChar c)
 48 {
 49     return (c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;) || (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF) || c == &#39;\t&#39;;
 50 }
 51 
 52 static bool isTokenCharacter(UChar c)
 53 {
 54     return isASCII(c) &amp;&amp; c &gt; &#39; &#39; &amp;&amp; c != &#39;&quot;&#39; &amp;&amp; c != &#39;(&#39; &amp;&amp; c != &#39;)&#39; &amp;&amp; c != &#39;,&#39; &amp;&amp; c != &#39;/&#39; &amp;&amp; (c &lt; &#39;:&#39; || c &gt; &#39;@&#39;) &amp;&amp; (c &lt; &#39;[&#39; || c &gt; &#39;]&#39;);
 55 }
 56 
 57 using CharacterMeetsCondition = bool (*)(UChar);
 58 
<span class="line-modified"> 59 static StringView parseToken(StringView input, unsigned&amp; startIndex, CharacterMeetsCondition characterMeetsCondition, Mode mode, bool skipTrailingWhitespace = false)</span>
 60 {
 61     unsigned inputLength = input.length();
 62     unsigned tokenStart = startIndex;
 63     unsigned&amp; tokenEnd = startIndex;
 64 
 65     if (tokenEnd &gt;= inputLength)
<span class="line-modified"> 66         return StringView();</span>
 67 
 68     while (tokenEnd &lt; inputLength &amp;&amp; characterMeetsCondition(input[tokenEnd])) {
 69         if (mode == Mode::Rfc2045 &amp;&amp; !isTokenCharacter(input[tokenEnd]))
 70             break;
 71         ++tokenEnd;
 72     }
 73 
 74     if (tokenEnd == tokenStart)
<span class="line-modified"> 75         return StringView();</span>
 76     if (skipTrailingWhitespace) {
 77         while (input[tokenEnd - 1] == &#39; &#39;)
 78             --tokenEnd;
 79     }
 80     return input.substring(tokenStart, tokenEnd - tokenStart);
 81 }
 82 
 83 static bool isNotQuoteOrBackslash(UChar ch)
 84 {
 85     return ch != &#39;&quot;&#39; &amp;&amp; ch != &#39;\\&#39;;
 86 }
 87 
 88 static String collectHTTPQuotedString(StringView input, unsigned&amp; startIndex)
 89 {
 90     ASSERT(input[startIndex] == &#39;&quot;&#39;);
 91     unsigned inputLength = input.length();
 92     unsigned&amp; position = startIndex;
 93     position++;
 94     StringBuilder builder;
 95     while (true) {
</pre>
<hr />
<pre>
108         } else {
109             ASSERT(quoteOrBackslash == &#39;&quot;&#39;);
110             break;
111         }
112 
113     }
114     return builder.toString();
115 }
116 
117 static bool containsNonTokenCharacters(StringView input, Mode mode)
118 {
119     if (mode == Mode::MimeSniff)
120         return !isValidHTTPToken(input.toStringWithoutCopying());
121     for (unsigned index = 0; index &lt; input.length(); ++index) {
122         if (!isTokenCharacter(input[index]))
123             return true;
124     }
125     return false;
126 }
127 
<span class="line-modified">128 static StringView parseQuotedString(StringView input, unsigned&amp; startIndex)</span>
129 {
130     unsigned inputLength = input.length();
131     unsigned quotedStringStart = startIndex + 1;
132     unsigned&amp; quotedStringEnd = startIndex;
133 
134     if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">135         return StringView();</span>
136 
137     if (input[quotedStringEnd++] != &#39;&quot;&#39; || quotedStringEnd &gt;= inputLength)
<span class="line-modified">138         return StringView();</span>
139 
140     bool lastCharacterWasBackslash = false;
141     char currentCharacter;
142     while ((currentCharacter = input[quotedStringEnd++]) != &#39;&quot;&#39; || lastCharacterWasBackslash) {
143         if (quotedStringEnd &gt;= inputLength)
<span class="line-modified">144             return StringView();</span>
145         if (currentCharacter == &#39;\\&#39; &amp;&amp; !lastCharacterWasBackslash) {
146             lastCharacterWasBackslash = true;
147             continue;
148         }
149         if (lastCharacterWasBackslash)
150             lastCharacterWasBackslash = false;
151     }
152     if (input[quotedStringEnd - 1] == &#39;&quot;&#39;)
153         quotedStringEnd++;
154     return input.substring(quotedStringStart, quotedStringEnd - quotedStringStart);
155 }
156 
157 // From http://tools.ietf.org/html/rfc2045#section-5.1:
158 //
159 // content := &quot;Content-Type&quot; &quot;:&quot; type &quot;/&quot; subtype
160 //            *(&quot;;&quot; parameter)
161 //            ; Matching of media type and subtype
162 //            ; is ALWAYS case-insensitive.
163 //
164 // type := discrete-type / composite-type
</pre>
<hr />
<pre>
217 
218 static bool containsNewline(UChar ch)
219 {
220     return ch == &#39;\r&#39; || ch == &#39;\n&#39;;
221 }
222 
223 bool ParsedContentType::parseContentType(Mode mode)
224 {
225     if (mode == Mode::Rfc2045 &amp;&amp; m_contentType.find(containsNewline) != notFound)
226         return false;
227     unsigned index = 0;
228     unsigned contentTypeLength = m_contentType.length();
229     skipSpaces(m_contentType, index);
230     if (index &gt;= contentTypeLength)  {
231         LOG_ERROR(&quot;Invalid Content-Type string &#39;%s&#39;&quot;, m_contentType.ascii().data());
232         return false;
233     }
234 
235     unsigned contentTypeStart = index;
236     auto typeRange = parseToken(m_contentType, index, isNotForwardSlash, mode);
<span class="line-modified">237     if (typeRange.isNull() || containsNonTokenCharacters(typeRange, mode)) {</span>
238         LOG_ERROR(&quot;Invalid Content-Type, invalid type value.&quot;);
239         return false;
240     }
241 
242     if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;/&#39;) {
243         LOG_ERROR(&quot;Invalid Content-Type, missing &#39;/&#39;.&quot;);
244         return false;
245     }
246 
247     auto subTypeRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
<span class="line-modified">248     if (subTypeRange.isNull() || containsNonTokenCharacters(subTypeRange, mode)) {</span>
249         LOG_ERROR(&quot;Invalid Content-Type, invalid subtype value.&quot;);
250         return false;
251     }
252 
253     // There should not be any quoted strings until we reach the parameters.
254     size_t semiColonIndex = m_contentType.find(&#39;;&#39;, contentTypeStart);
255     if (semiColonIndex == notFound) {
256         setContentType(m_contentType.substring(contentTypeStart, contentTypeLength - contentTypeStart), mode);
257         return true;
258     }
259 
260     setContentType(m_contentType.substring(contentTypeStart, semiColonIndex - contentTypeStart), mode);
261     index = semiColonIndex + 1;
262     while (true) {
263         skipSpaces(m_contentType, index);
264         auto keyRange = parseToken(m_contentType, index, isNotSemicolonOrEqualSign, mode);
<span class="line-modified">265         if (mode == Mode::Rfc2045 &amp;&amp; (keyRange.isNull() || index &gt;= contentTypeLength)) {</span>
266             LOG_ERROR(&quot;Invalid Content-Type parameter name.&quot;);
267             return false;
268         }
269 
270         // Should we tolerate spaces here?
271         if (mode == Mode::Rfc2045) {
272             if (index &gt;= contentTypeLength || m_contentType[index++] != &#39;=&#39;) {
273                 LOG_ERROR(&quot;Invalid Content-Type malformed parameter.&quot;);
274                 return false;
275             }
276         } else {
277             if (index &gt;= contentTypeLength)
278                 break;
279             if (m_contentType[index] != &#39;=&#39; &amp;&amp; m_contentType[index] != &#39;;&#39;) {
280                 LOG_ERROR(&quot;Invalid Content-Type malformed parameter.&quot;);
281                 return false;
282             }
283             if (m_contentType[index++] == &#39;;&#39;)
284                 continue;
285         }

286 
287         // Should we tolerate spaces here?
288         String parameterValue;
<span class="line-modified">289         StringView valueRange;</span>
290         if (index &lt; contentTypeLength &amp;&amp; m_contentType[index] == &#39;&quot;&#39;) {
291             if (mode == Mode::MimeSniff) {
292                 parameterValue = collectHTTPQuotedString(m_contentType, index);
293                 parseToken(m_contentType, index, isNotSemicolon, mode);
294             } else
295                 valueRange = parseQuotedString(m_contentType, index);
296         } else
297             valueRange = parseToken(m_contentType, index, isNotSemicolon, mode, mode == Mode::MimeSniff);
298 

299         if (parameterValue.isNull()) {
<span class="line-modified">300             if (valueRange.isNull()) {</span>
301                 if (mode == Mode::MimeSniff)
302                     continue;
303                 LOG_ERROR(&quot;Invalid Content-Type, invalid parameter value.&quot;);
304                 return false;
305             }
<span class="line-modified">306             parameterValue = valueRange.toString();</span>
307         }
308 
309         // Should we tolerate spaces here?
310         if (mode == Mode::Rfc2045 &amp;&amp; index &lt; contentTypeLength &amp;&amp; m_contentType[index++] != &#39;;&#39;) {
311             LOG_ERROR(&quot;Invalid Content-Type, invalid character at the end of key/value parameter.&quot;);
312             return false;
313         }
314 
<span class="line-modified">315         if (!keyRange.isNull())</span>
<span class="line-added">316             setContentTypeParameter(keyRange.toString(), parameterValue, mode);</span>
317 
318         if (index &gt;= contentTypeLength)
319             return true;
320     }
321 
322     return true;
323 }
324 
325 Optional&lt;ParsedContentType&gt; ParsedContentType::create(const String&amp; contentType, Mode mode)
326 {
327     ParsedContentType parsedContentType(mode == Mode::Rfc2045 ? contentType : stripLeadingAndTrailingHTTPSpaces(contentType));
328     if (!parsedContentType.parseContentType(mode))
329         return WTF::nullopt;
330     return { WTFMove(parsedContentType) };
331 }
332 
333 bool isValidContentType(const String&amp; contentType, Mode mode)
334 {
335     return ParsedContentType::create(contentType, mode) != WTF::nullopt;
336 }
</pre>
</td>
</tr>
</table>
<center><a href="NetworkStorageSession.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ResourceHandle.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
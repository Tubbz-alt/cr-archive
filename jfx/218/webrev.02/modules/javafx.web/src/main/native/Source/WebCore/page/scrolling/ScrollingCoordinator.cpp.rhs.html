<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #include &quot;ScrollingCoordinator.h&quot;
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;EventNames.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;GraphicsLayer.h&quot;
 35 #include &quot;Page.h&quot;
 36 #include &quot;PlatformWheelEvent.h&quot;
 37 #include &quot;PluginViewBase.h&quot;
 38 #include &quot;Region.h&quot;
 39 #include &quot;RenderLayerCompositor.h&quot;
 40 #include &quot;RenderView.h&quot;
<a name="1" id="anc1"></a>
 41 #include &quot;ScrollAnimator.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &lt;wtf/MainThread.h&gt;
 44 #include &lt;wtf/text/StringBuilder.h&gt;
 45 #include &lt;wtf/text/TextStream.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 #if PLATFORM(IOS_FAMILY) || !ENABLE(ASYNC_SCROLLING)
 50 Ref&lt;ScrollingCoordinator&gt; ScrollingCoordinator::create(Page* page)
 51 {
 52     return adoptRef(*new ScrollingCoordinator(page));
 53 }
 54 #endif
 55 
 56 ScrollingCoordinator::ScrollingCoordinator(Page* page)
 57     : m_page(page)
 58 {
 59 }
 60 
 61 ScrollingCoordinator::~ScrollingCoordinator()
 62 {
 63     ASSERT(!m_page);
 64 }
 65 
 66 void ScrollingCoordinator::pageDestroyed()
 67 {
 68     ASSERT(m_page);
 69     m_page = nullptr;
 70 }
 71 
 72 bool ScrollingCoordinator::coordinatesScrollingForFrameView(const FrameView&amp; frameView) const
 73 {
 74     ASSERT(isMainThread());
 75     ASSERT(m_page);
 76 
 77     if (!frameView.frame().isMainFrame() &amp;&amp; !m_page-&gt;settings().scrollingTreeIncludesFrames()
<a name="2" id="anc2"></a><span class="line-modified"> 78 #if PLATFORM(MAC) || USE(NICOSIA)</span>
 79         &amp;&amp; !m_page-&gt;settings().asyncFrameScrollingEnabled()
 80 #endif
 81     )
 82         return false;
 83 
 84     auto* renderView = frameView.frame().contentRenderer();
 85     if (!renderView)
 86         return false;
 87     return renderView-&gt;usesCompositing();
 88 }
 89 
 90 bool ScrollingCoordinator::coordinatesScrollingForOverflowLayer(const RenderLayer&amp; layer) const
 91 {
 92     ASSERT(isMainThread());
 93     ASSERT(m_page);
 94 
 95     return layer.hasCompositedScrollableOverflow();
 96 }
 97 
 98 ScrollingNodeID ScrollingCoordinator::scrollableContainerNodeID(const RenderObject&amp;) const
 99 {
100     return 0;
101 }
102 
103 EventTrackingRegions ScrollingCoordinator::absoluteEventTrackingRegionsForFrame(const Frame&amp; frame) const
104 {
105     auto* renderView = frame.contentRenderer();
106     if (!renderView || renderView-&gt;renderTreeBeingDestroyed())
107         return EventTrackingRegions();
108 
109 #if ENABLE(IOS_TOUCH_EVENTS)
110     // On iOS, we use nonFastScrollableRegion to represent the region covered by elements with touch event handlers.
111     ASSERT(frame.isMainFrame());
112     auto* document = frame.document();
113     if (!document)
114         return EventTrackingRegions();
115     return document-&gt;eventTrackingRegions();
116 #else
117     auto* frameView = frame.view();
118     if (!frameView)
119         return EventTrackingRegions();
120 
121     Region nonFastScrollableRegion;
122 
123     // FIXME: should ASSERT(!frameView-&gt;needsLayout()) here, but need to fix DebugPageOverlays
124     // to not ask for regions at bad times.
125 
126     if (auto* scrollableAreas = frameView-&gt;scrollableAreas()) {
127         for (auto&amp; scrollableArea : *scrollableAreas) {
128             // Composited scrollable areas can be scrolled off the main thread.
129             if (scrollableArea-&gt;usesAsyncScrolling())
130                 continue;
131 
132             bool isInsideFixed;
133             IntRect box = scrollableArea-&gt;scrollableAreaBoundingBox(&amp;isInsideFixed);
134             if (isInsideFixed)
135                 box = IntRect(frameView-&gt;fixedScrollableAreaBoundsInflatedForScrolling(LayoutRect(box)));
136 
137             nonFastScrollableRegion.unite(box);
138         }
139     }
140 
141     for (auto&amp; widget : frameView-&gt;widgetsInRenderTree()) {
142         if (!is&lt;PluginViewBase&gt;(*widget))
143             continue;
144         if (!downcast&lt;PluginViewBase&gt;(*widget).wantsWheelEvents())
145             continue;
146         auto* renderWidget = RenderWidget::find(*widget);
147         if (!renderWidget)
148             continue;
149         nonFastScrollableRegion.unite(renderWidget-&gt;absoluteBoundingBoxRect());
150     }
151 
152     EventTrackingRegions eventTrackingRegions;
153 
154     // FIXME: if we&#39;ve already accounted for this subframe as a scrollable area, we can avoid recursing into it here.
155     for (auto* subframe = frame.tree().firstChild(); subframe; subframe = subframe-&gt;tree().nextSibling()) {
156         auto* subframeView = subframe-&gt;view();
157         if (!subframeView)
158             continue;
159 
160         EventTrackingRegions subframeRegion = absoluteEventTrackingRegionsForFrame(*subframe);
161         // Map from the frame document to our document.
162         IntPoint offset = subframeView-&gt;contentsToContainingViewContents(IntPoint());
163 
164         // FIXME: this translation ignores non-trival transforms on the frame.
165         subframeRegion.translate(toIntSize(offset));
166         eventTrackingRegions.unite(subframeRegion);
167     }
168 
169     auto wheelHandlerRegion = frame.document()-&gt;absoluteRegionForEventTargets(frame.document()-&gt;wheelEventTargets());
170     bool wheelHandlerInFixedContent = wheelHandlerRegion.second;
171     if (wheelHandlerInFixedContent) {
172         // FIXME: need to handle position:sticky here too.
173         LayoutRect inflatedWheelHandlerBounds = frameView-&gt;fixedScrollableAreaBoundsInflatedForScrolling(LayoutRect(wheelHandlerRegion.first.bounds()));
174         wheelHandlerRegion.first.unite(enclosingIntRect(inflatedWheelHandlerBounds));
175     }
176 
177     nonFastScrollableRegion.unite(wheelHandlerRegion.first);
178 
179     // FIXME: If this is not the main frame, we could clip the region to the frame&#39;s bounds.
180     eventTrackingRegions.uniteSynchronousRegion(eventNames().wheelEvent, nonFastScrollableRegion);
181 
182     return eventTrackingRegions;
183 #endif
184 }
185 
186 EventTrackingRegions ScrollingCoordinator::absoluteEventTrackingRegions() const
187 {
188     return absoluteEventTrackingRegionsForFrame(m_page-&gt;mainFrame());
189 }
190 
191 void ScrollingCoordinator::frameViewHasSlowRepaintObjectsDidChange(FrameView&amp; frameView)
192 {
193     ASSERT(isMainThread());
194     ASSERT(m_page);
195 
196     if (!coordinatesScrollingForFrameView(frameView))
197         return;
198 
199     updateSynchronousScrollingReasons(frameView);
200 }
201 
202 void ScrollingCoordinator::frameViewFixedObjectsDidChange(FrameView&amp; frameView)
203 {
204     ASSERT(isMainThread());
205     ASSERT(m_page);
206 
207     if (!coordinatesScrollingForFrameView(frameView))
208         return;
209 
210     updateSynchronousScrollingReasons(frameView);
211 }
212 
213 GraphicsLayer* ScrollingCoordinator::scrollContainerLayerForFrameView(FrameView&amp; frameView)
214 {
215     if (auto* renderView = frameView.frame().contentRenderer())
216         return renderView-&gt;compositor().scrollContainerLayer();
217     return nullptr;
218 }
219 
220 GraphicsLayer* ScrollingCoordinator::scrolledContentsLayerForFrameView(FrameView&amp; frameView)
221 {
222     if (auto* renderView = frameView.frame().contentRenderer())
223         return renderView-&gt;compositor().scrolledContentsLayer();
224     return nullptr;
225 }
226 
227 GraphicsLayer* ScrollingCoordinator::headerLayerForFrameView(FrameView&amp; frameView)
228 {
229 #if ENABLE(RUBBER_BANDING)
230     if (auto* renderView = frameView.frame().contentRenderer())
231         return renderView-&gt;compositor().headerLayer();
232     return nullptr;
233 #else
234     UNUSED_PARAM(frameView);
235     return nullptr;
236 #endif
237 }
238 
239 GraphicsLayer* ScrollingCoordinator::footerLayerForFrameView(FrameView&amp; frameView)
240 {
241 #if ENABLE(RUBBER_BANDING)
242     if (auto* renderView = frameView.frame().contentRenderer())
243         return renderView-&gt;compositor().footerLayer();
244     return nullptr;
245 #else
246     UNUSED_PARAM(frameView);
247     return nullptr;
248 #endif
249 }
250 
251 GraphicsLayer* ScrollingCoordinator::counterScrollingLayerForFrameView(FrameView&amp; frameView)
252 {
253     if (auto* renderView = frameView.frame().contentRenderer())
254         return renderView-&gt;compositor().fixedRootBackgroundLayer();
255     return nullptr;
256 }
257 
258 GraphicsLayer* ScrollingCoordinator::insetClipLayerForFrameView(FrameView&amp; frameView)
259 {
260     if (auto* renderView = frameView.frame().contentRenderer())
261         return renderView-&gt;compositor().clipLayer();
262     return nullptr;
263 }
264 
265 GraphicsLayer* ScrollingCoordinator::contentShadowLayerForFrameView(FrameView&amp; frameView)
266 {
267 #if ENABLE(RUBBER_BANDING)
268     if (auto* renderView = frameView.frame().contentRenderer())
269         return renderView-&gt;compositor().layerForContentShadow();
270 
271     return nullptr;
272 #else
273     UNUSED_PARAM(frameView);
274     return nullptr;
275 #endif
276 }
277 
278 GraphicsLayer* ScrollingCoordinator::rootContentsLayerForFrameView(FrameView&amp; frameView)
279 {
280     if (auto* renderView = frameView.frame().contentRenderer())
281         return renderView-&gt;compositor().rootContentsLayer();
282     return nullptr;
283 }
284 
285 void ScrollingCoordinator::frameViewRootLayerDidChange(FrameView&amp; frameView)
286 {
287     ASSERT(isMainThread());
288     ASSERT(m_page);
289 
290     if (!coordinatesScrollingForFrameView(frameView))
291         return;
292 
293     frameViewLayoutUpdated(frameView);
294     updateSynchronousScrollingReasons(frameView);
295 }
296 
297 #if PLATFORM(COCOA)
298 void ScrollingCoordinator::handleWheelEventPhase(PlatformWheelEventPhase phase)
299 {
300     ASSERT(isMainThread());
301 
302     if (!m_page)
303         return;
304 
305     auto* frameView = m_page-&gt;mainFrame().view();
306     if (!frameView)
307         return;
308 
309     frameView-&gt;scrollAnimator().handleWheelEventPhase(phase);
310 }
311 #endif
312 
313 bool ScrollingCoordinator::hasVisibleSlowRepaintViewportConstrainedObjects(const FrameView&amp; frameView) const
314 {
315     const FrameView::ViewportConstrainedObjectSet* viewportConstrainedObjects = frameView.viewportConstrainedObjects();
316     if (!viewportConstrainedObjects)
317         return false;
318 
319     for (auto&amp; viewportConstrainedObject : *viewportConstrainedObjects) {
320         if (!is&lt;RenderBoxModelObject&gt;(*viewportConstrainedObject) || !viewportConstrainedObject-&gt;hasLayer())
321             return true;
322         auto&amp; layer = *downcast&lt;RenderBoxModelObject&gt;(*viewportConstrainedObject).layer();
323         // Any explicit reason that a fixed position element is not composited shouldn&#39;t cause slow scrolling.
324         if (!layer.isComposited() &amp;&amp; layer.viewportConstrainedNotCompositedReason() == RenderLayer::NoNotCompositedReason)
325             return true;
326     }
327     return false;
328 }
329 
330 SynchronousScrollingReasons ScrollingCoordinator::synchronousScrollingReasons(const FrameView&amp; frameView) const
331 {
332     SynchronousScrollingReasons synchronousScrollingReasons = (SynchronousScrollingReasons)0;
333 
334     if (m_forceSynchronousScrollLayerPositionUpdates)
335         synchronousScrollingReasons |= ForcedOnMainThread;
336     if (frameView.hasSlowRepaintObjects())
337         synchronousScrollingReasons |= HasSlowRepaintObjects;
338     if (hasVisibleSlowRepaintViewportConstrainedObjects(frameView))
339         synchronousScrollingReasons |= HasNonLayerViewportConstrainedObjects;
340     if (frameView.frame().mainFrame().document() &amp;&amp; frameView.frame().document()-&gt;isImageDocument())
341         synchronousScrollingReasons |= IsImageDocument;
342 
343     return synchronousScrollingReasons;
344 }
345 
346 void ScrollingCoordinator::updateSynchronousScrollingReasons(FrameView&amp; frameView)
347 {
348     ASSERT(coordinatesScrollingForFrameView(frameView));
349     setSynchronousScrollingReasons(frameView, synchronousScrollingReasons(frameView));
350 }
351 
352 void ScrollingCoordinator::updateSynchronousScrollingReasonsForAllFrames()
353 {
354     for (Frame* frame = &amp;m_page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
355         if (auto* frameView = frame-&gt;view()) {
356             if (coordinatesScrollingForFrameView(*frameView))
357                 updateSynchronousScrollingReasons(*frameView);
358         }
359     }
360 }
361 
362 void ScrollingCoordinator::setForceSynchronousScrollLayerPositionUpdates(bool forceSynchronousScrollLayerPositionUpdates)
363 {
364     if (m_forceSynchronousScrollLayerPositionUpdates == forceSynchronousScrollLayerPositionUpdates)
365         return;
366 
367     m_forceSynchronousScrollLayerPositionUpdates = forceSynchronousScrollLayerPositionUpdates;
368     updateSynchronousScrollingReasonsForAllFrames();
369 }
370 
371 bool ScrollingCoordinator::shouldUpdateScrollLayerPositionSynchronously(const FrameView&amp; frameView) const
372 {
373     if (&amp;frameView == m_page-&gt;mainFrame().view())
374         return synchronousScrollingReasons(frameView);
375 
376     return true;
377 }
378 
379 ScrollingNodeID ScrollingCoordinator::uniqueScrollingNodeID()
380 {
381     static ScrollingNodeID uniqueScrollingNodeID = 1;
382     return uniqueScrollingNodeID++;
383 }
384 
385 String ScrollingCoordinator::scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior) const
386 {
387     return String();
388 }
389 
390 String ScrollingCoordinator::synchronousScrollingReasonsAsText(SynchronousScrollingReasons reasons)
391 {
392     StringBuilder stringBuilder;
393 
394     if (reasons &amp; ScrollingCoordinator::ForcedOnMainThread)
395         stringBuilder.appendLiteral(&quot;Forced on main thread, &quot;);
396     if (reasons &amp; ScrollingCoordinator::HasSlowRepaintObjects)
397         stringBuilder.appendLiteral(&quot;Has slow repaint objects, &quot;);
398     if (reasons &amp; ScrollingCoordinator::HasViewportConstrainedObjectsWithoutSupportingFixedLayers)
399         stringBuilder.appendLiteral(&quot;Has viewport constrained objects without supporting fixed layers, &quot;);
400     if (reasons &amp; ScrollingCoordinator::HasNonLayerViewportConstrainedObjects)
401         stringBuilder.appendLiteral(&quot;Has non-layer viewport-constrained objects, &quot;);
402     if (reasons &amp; ScrollingCoordinator::IsImageDocument)
403         stringBuilder.appendLiteral(&quot;Is image document, &quot;);
404 
405     if (stringBuilder.length())
406         stringBuilder.resize(stringBuilder.length() - 2);
407     return stringBuilder.toString();
408 }
409 
410 String ScrollingCoordinator::synchronousScrollingReasonsAsText() const
411 {
412     if (auto* frameView = m_page-&gt;mainFrame().view())
413         return synchronousScrollingReasonsAsText(synchronousScrollingReasons(*frameView));
414 
415     return String();
416 }
417 
418 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ScrollableAreaParameters scrollableAreaParameters)
419 {
420     ts.dumpProperty(&quot;horizontal scroll elasticity&quot;, scrollableAreaParameters.horizontalScrollElasticity);
421     ts.dumpProperty(&quot;vertical scroll elasticity&quot;, scrollableAreaParameters.verticalScrollElasticity);
422     ts.dumpProperty(&quot;horizontal scrollbar mode&quot;, scrollableAreaParameters.horizontalScrollbarMode);
423     ts.dumpProperty(&quot;vertical scrollbar mode&quot;, scrollableAreaParameters.verticalScrollbarMode);
424 
425     if (scrollableAreaParameters.hasEnabledHorizontalScrollbar)
426         ts.dumpProperty(&quot;has enabled horizontal scrollbar&quot;, scrollableAreaParameters.hasEnabledHorizontalScrollbar);
427     if (scrollableAreaParameters.hasEnabledVerticalScrollbar)
428         ts.dumpProperty(&quot;has enabled vertical scrollbar&quot;, scrollableAreaParameters.hasEnabledVerticalScrollbar);
429 
430     if (scrollableAreaParameters.horizontalScrollbarHiddenByStyle)
431         ts.dumpProperty(&quot;horizontal scrollbar hidden by style&quot;, scrollableAreaParameters.horizontalScrollbarHiddenByStyle);
432     if (scrollableAreaParameters.verticalScrollbarHiddenByStyle)
433         ts.dumpProperty(&quot;vertical scrollbar hidden by style&quot;, scrollableAreaParameters.verticalScrollbarHiddenByStyle);
434 
435     return ts;
436 }
437 
438 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ScrollingNodeType nodeType)
439 {
440     switch (nodeType) {
441     case ScrollingNodeType::MainFrame:
442         ts &lt;&lt; &quot;main-frame-scrolling&quot;;
443         break;
444     case ScrollingNodeType::Subframe:
445         ts &lt;&lt; &quot;subframe-scrolling&quot;;
446         break;
447     case ScrollingNodeType::FrameHosting:
448         ts &lt;&lt; &quot;frame-hosting&quot;;
449         break;
450     case ScrollingNodeType::Overflow:
451         ts &lt;&lt; &quot;overflow-scrolling&quot;;
452         break;
453     case ScrollingNodeType::OverflowProxy:
454         ts &lt;&lt; &quot;overflow-scroll-proxy&quot;;
455         break;
456     case ScrollingNodeType::Fixed:
457         ts &lt;&lt; &quot;fixed&quot;;
458         break;
459     case ScrollingNodeType::Sticky:
460         ts &lt;&lt; &quot;sticky&quot;;
461         break;
462     case ScrollingNodeType::Positioned:
463         ts &lt;&lt; &quot;positioned&quot;;
464         break;
465     }
466     return ts;
467 }
468 
469 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ScrollingLayerPositionAction action)
470 {
471     switch (action) {
472     case ScrollingLayerPositionAction::Set:
473         ts &lt;&lt; &quot;set&quot;;
474         break;
475     case ScrollingLayerPositionAction::SetApproximate:
476         ts &lt;&lt; &quot;set approximate&quot;;
477         break;
478     case ScrollingLayerPositionAction::Sync:
479         ts &lt;&lt; &quot;sync&quot;;
480         break;
481     }
482     return ts;
483 }
484 
485 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ViewportRectStability stability)
486 {
487     switch (stability) {
488     case ViewportRectStability::Stable:
489         ts &lt;&lt; &quot;stable&quot;;
490         break;
491     case ViewportRectStability::Unstable:
492         ts &lt;&lt; &quot;unstable&quot;;
493         break;
494     case ViewportRectStability::ChangingObscuredInsetsInteractively:
495         ts &lt;&lt; &quot;changing obscured insets interactively&quot;;
496         break;
497     }
498     return ts;
499 }
500 
<a name="3" id="anc3"></a>








501 } // namespace WebCore
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
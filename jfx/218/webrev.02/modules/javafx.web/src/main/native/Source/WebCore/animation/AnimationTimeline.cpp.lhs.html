<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) Canon Inc. 2016
  3  * Copyright (C) 2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;AnimationTimeline.h&quot;
 29 
 30 #include &quot;Animation.h&quot;
 31 #include &quot;AnimationEffect.h&quot;
 32 #include &quot;AnimationList.h&quot;
 33 #include &quot;CSSAnimation.h&quot;
 34 #include &quot;CSSPropertyAnimation.h&quot;
 35 #include &quot;CSSTransition.h&quot;
 36 #include &quot;DocumentTimeline.h&quot;
 37 #include &quot;Element.h&quot;
 38 #include &quot;KeyframeEffect.h&quot;
<a name="1" id="anc1"></a>
 39 #include &quot;RenderStyle.h&quot;
 40 #include &quot;RenderView.h&quot;
 41 #include &quot;StylePropertyShorthand.h&quot;
 42 #include &quot;StyleResolver.h&quot;
 43 #include &quot;WebAnimationUtilities.h&quot;
 44 #include &lt;wtf/text/TextStream.h&gt;
 45 #include &lt;wtf/text/WTFString.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 AnimationTimeline::AnimationTimeline()
 50 {
 51 }
 52 
 53 AnimationTimeline::~AnimationTimeline()
 54 {
 55 }
 56 
 57 void AnimationTimeline::forgetAnimation(WebAnimation* animation)
 58 {
 59     m_allAnimations.removeFirst(animation);
 60 }
 61 
 62 void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
 63 {
<a name="2" id="anc2"></a>

 64     if (m_animations.add(&amp;animation)) {
 65         m_allAnimations.append(makeWeakPtr(&amp;animation));
 66         auto* timeline = animation.timeline();
 67         if (timeline &amp;&amp; timeline != this)
 68             timeline-&gt;removeAnimation(animation);
 69     }
 70 }
 71 
<a name="3" id="anc3"></a>






 72 void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
 73 {
 74     ASSERT(!animation.timeline() || animation.timeline() == this);
 75     m_animations.remove(&amp;animation);
 76     if (is&lt;KeyframeEffect&gt;(animation.effect())) {
<a name="4" id="anc4"></a><span class="line-modified"> 77         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())</span>
 78             animationWasRemovedFromElement(animation, *target);
<a name="5" id="anc5"></a>

 79     }
 80 }
 81 
 82 Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
 83 {
 84     auto time = currentTime();
 85     if (!time)
 86         return WTF::nullopt;
 87     return secondsToWebAnimationsAPITime(*time);
 88 }
 89 
 90 void AnimationTimeline::animationWasAddedToElement(WebAnimation&amp; animation, Element&amp; element)
 91 {
 92     [&amp;] () -&gt; ElementToAnimationsMap&amp; {
 93         if (is&lt;CSSTransition&gt;(animation) &amp;&amp; downcast&lt;CSSTransition&gt;(animation).owningElement())
 94             return m_elementToCSSTransitionsMap;
 95         if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
 96             return m_elementToCSSAnimationsMap;
 97         return m_elementToAnimationsMap;
 98     }().ensure(&amp;element, [] {
<a name="6" id="anc6"></a><span class="line-modified"> 99         return ListHashSet&lt;RefPtr&lt;WebAnimation&gt;&gt; { };</span>
100     }).iterator-&gt;value.add(&amp;animation);
101 }
102 
103 static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
104 {
105     auto iterator = map.find(&amp;element);
106     if (iterator == map.end())
107         return false;
108 
109     auto&amp; cssTransitionsByProperty = iterator-&gt;value;
110 
111     auto transitionIterator = cssTransitionsByProperty.find(transition.property());
112     if (transitionIterator == cssTransitionsByProperty.end() || transitionIterator-&gt;value != &amp;transition)
113         return false;
114 
115     cssTransitionsByProperty.remove(transitionIterator);
116 
117     if (cssTransitionsByProperty.isEmpty())
118         map.remove(&amp;element);
119     return true;
120 }
121 
122 static inline void removeAnimationFromMapForElement(WebAnimation&amp; animation, AnimationTimeline::ElementToAnimationsMap&amp; map, Element&amp; element)
123 {
124     auto iterator = map.find(&amp;element);
125     if (iterator == map.end())
126         return;
127 
128     auto&amp; animations = iterator-&gt;value;
129     animations.remove(&amp;animation);
130     if (!animations.size())
131         map.remove(iterator);
132 }
133 
134 void AnimationTimeline::animationWasRemovedFromElement(WebAnimation&amp; animation, Element&amp; element)
135 {
136     removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
137     removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
138     removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
139 
<a name="7" id="anc7"></a><span class="line-modified">140     // Now, if we&#39;re dealing with a declarative animation, we remove it from either the m_elementToCSSAnimationByName</span>
<span class="line-modified">141     // or the m_elementToRunningCSSTransitionByCSSPropertyID map, whichever is relevant to this type of animation.</span>
<span class="line-modified">142     if (is&lt;DeclarativeAnimation&gt;(animation))</span>


143         removeDeclarativeAnimationFromListsForOwningElement(animation, element);
144 }
145 
146 void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
147 {
148     ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
149 
<a name="8" id="anc8"></a><span class="line-modified">150     if (is&lt;CSSAnimation&gt;(animation)) {</span>
<span class="line-removed">151         auto iterator = m_elementToCSSAnimationByName.find(&amp;element);</span>
<span class="line-removed">152         if (iterator != m_elementToCSSAnimationByName.end()) {</span>
<span class="line-removed">153             auto&amp; cssAnimationsByName = iterator-&gt;value;</span>
<span class="line-removed">154             auto&amp; name = downcast&lt;CSSAnimation&gt;(animation).animationName();</span>
<span class="line-removed">155             cssAnimationsByName.remove(name);</span>
<span class="line-removed">156             if (cssAnimationsByName.isEmpty())</span>
<span class="line-removed">157                 m_elementToCSSAnimationByName.remove(&amp;element);</span>
<span class="line-removed">158         }</span>
<span class="line-removed">159     } else if (is&lt;CSSTransition&gt;(animation)) {</span>
160         auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
161         if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
162             removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
163     }
164 }
165 
166 Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
167 {
168     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
<a name="9" id="anc9"></a><span class="line-modified">169     if (m_elementToCSSTransitionsMap.contains(&amp;element)) {</span>
<span class="line-modified">170         const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);</span>
<span class="line-modified">171         if (ordering == Ordering::Sorted) {</span>
<span class="line-modified">172             Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; sortedCSSTransitions;</span>
<span class="line-modified">173             sortedCSSTransitions.appendRange(cssTransitions.begin(), cssTransitions.end());</span>
<span class="line-modified">174             std::sort(sortedCSSTransitions.begin(), sortedCSSTransitions.end(), [](auto&amp; lhs, auto&amp; rhs) {</span>
<span class="line-modified">175                 // Sort transitions first by their generation time, and then by transition-property.</span>
<span class="line-modified">176                 // https://drafts.csswg.org/css-transitions-2/#animation-composite-order</span>
<span class="line-modified">177                 auto* lhsTransition = downcast&lt;CSSTransition&gt;(lhs.get());</span>
<span class="line-removed">178                 auto* rhsTransition = downcast&lt;CSSTransition&gt;(rhs.get());</span>
<span class="line-removed">179                 if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())</span>
<span class="line-removed">180                     return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();</span>
<span class="line-removed">181                 return lhsTransition-&gt;transitionProperty().utf8() &lt; rhsTransition-&gt;transitionProperty().utf8();</span>
<span class="line-removed">182             });</span>
<span class="line-removed">183             animations.appendVector(sortedCSSTransitions);</span>
<span class="line-removed">184         } else</span>
185             animations.appendRange(cssTransitions.begin(), cssTransitions.end());
<a name="10" id="anc10"></a>








186     }
<a name="11" id="anc11"></a><span class="line-modified">187     if (m_elementToCSSAnimationsMap.contains(&amp;element)) {</span>
<span class="line-modified">188         const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);</span>
<span class="line-modified">189         animations.appendRange(cssAnimations.begin(), cssAnimations.end());</span>









190     }
<a name="12" id="anc12"></a><span class="line-modified">191     if (m_elementToAnimationsMap.contains(&amp;element)) {</span>
<span class="line-modified">192         const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);</span>
<span class="line-modified">193         animations.appendRange(webAnimations.begin(), webAnimations.end());</span>


























194     }
<a name="13" id="anc13"></a><span class="line-removed">195     return animations;</span>
196 }
197 
198 void AnimationTimeline::elementWasRemoved(Element&amp; element)
199 {
<a name="14" id="anc14"></a><span class="line-modified">200     for (auto&amp; animation : animationsForElement(element))</span>
<span class="line-modified">201         animation-&gt;cancel(WebAnimation::Silently::Yes);</span>





202 }
203 
204 void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
205 {
206     for (auto&amp; animation : animationsForElement(element))
207         animation-&gt;remove();
208 }
209 
<a name="15" id="anc15"></a>





210 void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
211 {
212     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
213         cssTransition-&gt;cancel();
<a name="16" id="anc16"></a><span class="line-modified">214     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element))</span>


215         cssAnimation-&gt;cancel();
<a name="17" id="anc17"></a>
216 }
217 
218 static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
219 {
220     if (!animation.isValidAnimation())
221         return false;
222 
223     static NeverDestroyed&lt;const String&gt; animationNameNone(MAKE_STATIC_STRING_IMPL(&quot;none&quot;));
224 
225     auto&amp; name = animation.name();
226     if (name == animationNameNone || name.isEmpty())
227         return false;
228 
229     if (auto* styleScope = Style::Scope::forOrdinal(element, animation.nameStyleScopeOrdinal()))
230         return styleScope-&gt;resolver().isAnimationNameValid(name);
231 
232     return false;
233 }
234 
235 void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
236 {
<a name="18" id="anc18"></a>

237     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
<a name="19" id="anc19"></a><span class="line-modified">238     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">239         if (m_elementToCSSAnimationByName.contains(&amp;element)) {</span>
<span class="line-modified">240             for (const auto&amp; cssAnimationsByNameMapItem : m_elementToCSSAnimationByName.take(&amp;element))</span>
<span class="line-modified">241                 cancelDeclarativeAnimation(*cssAnimationsByNameMapItem.value);</span>



242         }
<a name="20" id="anc20"></a>
243         return;
244     }
245 
<a name="21" id="anc21"></a><span class="line-modified">246     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(currentStyle-&gt;animations()) == *(afterChangeStyle.animations()))</span>


247         return;
248 
<a name="22" id="anc22"></a><span class="line-modified">249     // First, compile the list of animation names that were applied to this element up to this point.</span>
<span class="line-modified">250     HashSet&lt;String&gt; namesOfPreviousAnimations;</span>
<span class="line-modified">251     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations()) {</span>
<span class="line-removed">252         auto* previousAnimations = currentStyle-&gt;animations();</span>
<span class="line-removed">253         for (size_t i = 0; i &lt; previousAnimations-&gt;size(); ++i) {</span>
<span class="line-removed">254             auto&amp; previousAnimation = previousAnimations-&gt;animation(i);</span>
<span class="line-removed">255             if (shouldConsiderAnimation(element, previousAnimation))</span>
<span class="line-removed">256                 namesOfPreviousAnimations.add(previousAnimation.name());</span>
<span class="line-removed">257         }</span>
<span class="line-removed">258     }</span>
<span class="line-removed">259 </span>
<span class="line-removed">260     // Create or get the CSSAnimations by animation name map for this element.</span>
<span class="line-removed">261     auto&amp; cssAnimationsByName = m_elementToCSSAnimationByName.ensure(&amp;element, [] {</span>
<span class="line-removed">262         return HashMap&lt;String, RefPtr&lt;CSSAnimation&gt;&gt; { };</span>
263     }).iterator-&gt;value;
264 
<a name="23" id="anc23"></a><span class="line-modified">265     if (auto* currentAnimations = afterChangeStyle.animations()) {</span>
<span class="line-modified">266         for (size_t i = 0; i &lt; currentAnimations-&gt;size(); ++i) {</span>
<span class="line-modified">267             auto&amp; currentAnimation = currentAnimations-&gt;animation(i);</span>
<span class="line-modified">268             auto&amp; name = currentAnimation.name();</span>
<span class="line-modified">269             if (namesOfPreviousAnimations.contains(name)) {</span>
<span class="line-modified">270                 // We&#39;ve found the name of this animation in our list of previous animations, this means we&#39;ve already</span>
<span class="line-modified">271                 // created a CSSAnimation object for it and need to ensure that this CSSAnimation is backed by the current</span>
<span class="line-modified">272                 // animation object for this animation name.</span>
<span class="line-modified">273                 if (auto cssAnimation = cssAnimationsByName.get(name))</span>
<span class="line-modified">274                     cssAnimation-&gt;setBackingAnimation(currentAnimation);</span>
<span class="line-modified">275             } else if (shouldConsiderAnimation(element, currentAnimation)) {</span>
<span class="line-modified">276                 // Otherwise we are dealing with a new animation name and must create a CSSAnimation for it.</span>
<span class="line-modified">277                 cssAnimationsByName.set(name, CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));</span>














278             }
<a name="24" id="anc24"></a><span class="line-modified">279             // Remove the name of this animation from our list since it&#39;s now known to be current.</span>
<span class="line-modified">280             namesOfPreviousAnimations.remove(name);</span>

281         }
282     }
283 
<a name="25" id="anc25"></a><span class="line-modified">284     // The animations names left in namesOfPreviousAnimations are now known to no longer apply so we need to</span>
<span class="line-modified">285     // remove the CSSAnimation object created for them.</span>
<span class="line-modified">286     for (const auto&amp; nameOfAnimationToRemove : namesOfPreviousAnimations) {</span>
<span class="line-modified">287         if (auto animation = cssAnimationsByName.take(nameOfAnimationToRemove))</span>
<span class="line-modified">288             cancelDeclarativeAnimation(*animation);</span>

289     }
<a name="26" id="anc26"></a>






290 }
291 
<a name="27" id="anc27"></a><span class="line-modified">292 RefPtr&lt;WebAnimation&gt; AnimationTimeline::cssAnimationForElementAndProperty(Element&amp; element, CSSPropertyID property)</span>
293 {
<a name="28" id="anc28"></a><span class="line-modified">294     RefPtr&lt;WebAnimation&gt; matchingAnimation;</span>
<span class="line-modified">295     for (const auto&amp; animation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-modified">296         auto* effect = animation-&gt;effect();</span>
<span class="line-modified">297         if (is&lt;KeyframeEffect&gt;(effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(effect)-&gt;animatedProperties().contains(property))</span>
<span class="line-modified">298             matchingAnimation = animation;</span>

299     }
<a name="29" id="anc29"></a><span class="line-modified">300     return matchingAnimation;</span>

301 }
302 
303 static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
304 {
305     if (auto* transition = transitions.get(property)) {
306         if (CSSPropertyAnimation::propertiesEqual(property, &amp;style, &amp;transition-&gt;targetStyle()))
307             return true;
308     }
309     return false;
310 }
311 
312 static double transitionCombinedDuration(const Animation* transition)
313 {
314     return std::max(0.0, transition-&gt;duration()) + transition-&gt;delay();
315 }
316 
317 static bool transitionMatchesProperty(const Animation&amp; transition, CSSPropertyID property)
318 {
319     auto mode = transition.animationMode();
320     if (mode == Animation::AnimateNone || mode == Animation::AnimateUnknownProperty)
321         return false;
322     if (mode == Animation::AnimateSingleProperty) {
323         auto transitionProperty = transition.property();
324         if (transitionProperty != property) {
325             auto shorthand = shorthandForProperty(transitionProperty);
326             for (size_t i = 0; i &lt; shorthand.length(); ++i) {
327                 if (shorthand.properties()[i] == property)
328                     return true;
329             }
330             return false;
331         }
332     }
333     return true;
334 }
335 
336 AnimationTimeline::PropertyToTransitionMap&amp; AnimationTimeline::ensureRunningTransitionsByProperty(Element&amp; element)
337 {
338     return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
339         return PropertyToTransitionMap { };
340     }).iterator-&gt;value;
341 }
342 
<a name="30" id="anc30"></a><span class="line-modified">343 void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)</span>
344 {
<a name="31" id="anc31"></a><span class="line-modified">345     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.</span>
<span class="line-removed">346     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-removed">347         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {</span>
<span class="line-removed">348             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))</span>
<span class="line-removed">349                 cancelDeclarativeAnimation(*cssTransitionsByCSSPropertyIDMapItem.value);</span>
<span class="line-removed">350         }</span>
351         return;
<a name="32" id="anc32"></a><span class="line-removed">352     }</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.</span>
<span class="line-removed">355     // https://drafts.csswg.org/css-transitions-1/#starting</span>
356 
<a name="33" id="anc33"></a><span class="line-modified">357     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);</span>


358 
<a name="34" id="anc34"></a><span class="line-modified">359     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {</span>
<span class="line-modified">360         return PropertyToTransitionMap { };</span>
<span class="line-modified">361     }).iterator-&gt;value;</span>














362 
<a name="35" id="anc35"></a><span class="line-modified">363     auto generationTime = MonotonicTime::now();</span>









364 
<a name="36" id="anc36"></a><span class="line-modified">365     auto numberOfProperties = CSSPropertyAnimation::getNumProperties();</span>
<span class="line-modified">366     for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {</span>
<span class="line-modified">367         Optional&lt;bool&gt; isShorthand;</span>
<span class="line-modified">368         auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);</span>
<span class="line-modified">369         if (isShorthand &amp;&amp; *isShorthand)</span>
<span class="line-modified">370             continue;</span>
<span class="line-modified">371 </span>
<span class="line-modified">372         const Animation* matchingBackingAnimation = nullptr;</span>
<span class="line-modified">373         if (auto* transitions = afterChangeStyle.transitions()) {</span>
<span class="line-modified">374             for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-modified">375                 auto&amp; backingAnimation = transitions-&gt;animation(i);</span>
<span class="line-modified">376                 if (transitionMatchesProperty(backingAnimation, property))</span>
<span class="line-modified">377                     matchingBackingAnimation = &amp;backingAnimation;</span>



378             }
379         }
380 
<a name="37" id="anc37"></a><span class="line-modified">381         // https://drafts.csswg.org/css-transitions-1/#before-change-style</span>
<span class="line-modified">382         // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with</span>
<span class="line-modified">383         // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.</span>
<span class="line-modified">384         auto existingAnimation = cssAnimationForElementAndProperty(element, property);</span>
<span class="line-modified">385         const auto&amp; beforeChangeStyle = existingAnimation ? downcast&lt;CSSAnimation&gt;(existingAnimation.get())-&gt;unanimatedStyle() : currentStyle;</span>
<span class="line-modified">386 </span>
<span class="line-modified">387         if (!runningTransitionsByProperty.contains(property)</span>
<span class="line-modified">388             &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-modified">389             &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-modified">390             &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)</span>
<span class="line-modified">391             &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {</span>
<span class="line-modified">392             // 1. If all of the following are true:</span>
<span class="line-modified">393             //   - the element does not have a running transition for the property,</span>
<span class="line-modified">394             //   - the before-change style is different from and can be interpolated with the after-change style for that property,</span>
<span class="line-modified">395             //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,</span>
<span class="line-modified">396             //   - there is a matching transition-property value, and</span>
<span class="line-modified">397             //   - the combined duration is greater than 0s,</span>
<span class="line-modified">398 </span>
<span class="line-modified">399             // then implementations must remove the completed transition (if present) from the set of completed transitions</span>







































400             completedTransitionsByProperty.remove(property);
<a name="38" id="anc38"></a>












































401 
<a name="39" id="anc39"></a><span class="line-modified">402             // and start a transition whose:</span>
403             //   - start time is the time of the style change event plus the matching transition delay,
404             //   - end time is the start time plus the matching transition duration,
<a name="40" id="anc40"></a><span class="line-modified">405             //   - start value is the value of the transitioning property in the before-change style,</span>
<span class="line-modified">406             //   - end value is the value of the transitioning property in the after-change style,</span>
407             //   - reversing-adjusted start value is the same as the start value, and
408             //   - reversing shortening factor is 1.
409             auto delay = Seconds(matchingBackingAnimation-&gt;delay());
410             auto duration = Seconds(matchingBackingAnimation-&gt;duration());
<a name="41" id="anc41"></a><span class="line-modified">411             auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;</span>
412             auto reversingShorteningFactor = 1;
<a name="42" id="anc42"></a><span class="line-modified">413             runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">414         } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {</span>
<span class="line-removed">415             // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from</span>
<span class="line-removed">416             //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.</span>
<span class="line-removed">417             completedTransitionsByProperty.remove(property);</span>
418         }
<a name="43" id="anc43"></a>

419 
<a name="44" id="anc44"></a><span class="line-modified">420         bool hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-modified">421         if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {</span>
<span class="line-modified">422             // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property</span>
<span class="line-modified">423             //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.</span>
<span class="line-modified">424             if (hasRunningTransition)</span>
<span class="line-modified">425                 runningTransitionsByProperty.take(property)-&gt;cancel();</span>
<span class="line-modified">426             else</span>
<span class="line-removed">427                 completedTransitionsByProperty.remove(property);</span>
428         }
<a name="45" id="anc45"></a>

429 
<a name="46" id="anc46"></a><span class="line-modified">430         if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {</span>
<span class="line-modified">431             auto previouslyRunningTransition = runningTransitionsByProperty.take(property);</span>
<span class="line-modified">432             auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();</span>
<span class="line-modified">433             // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running</span>
<span class="line-modified">434             //    transition is not equal to the value of the property in the after-change style, then:</span>
<span class="line-modified">435             if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-modified">436                 // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,</span>
<span class="line-modified">437                 //    or if these two values cannot be interpolated, then implementations must cancel the running transition.</span>
<span class="line-modified">438                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">439             } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-modified">440                 // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition</span>
<span class="line-modified">441                 //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.</span>
<span class="line-modified">442                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">443             } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {</span>
<span class="line-modified">444                 // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change</span>
<span class="line-modified">445                 //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition</span>
<span class="line-modified">446                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">447 </span>
<span class="line-modified">448                 // and start a new transition whose:</span>
<span class="line-modified">449                 //   - reversing-adjusted start value is the end value of the running transition,</span>
<span class="line-modified">450                 //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:</span>
<span class="line-modified">451                 //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition</span>
<span class="line-modified">452                 //       2. 1 minus the reversing shortening factor of the old transition.</span>
<span class="line-modified">453                 //   - start time is the time of the style change event plus:</span>
<span class="line-modified">454                 //       1. if the matching transition delay is nonnegative, the matching transition delay, or</span>
<span class="line-removed">455                 //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,</span>
<span class="line-removed">456                 //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,</span>
<span class="line-removed">457                 //   - start value is the current value of the property in the running transition,</span>
<span class="line-removed">458                 //   - end value is the value of the property in the after-change style</span>
<span class="line-removed">459                 auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();</span>
<span class="line-removed">460                 double transformedProgress = 1;</span>
<span class="line-removed">461                 if (auto* effect = previouslyRunningTransition-&gt;effect()) {</span>
<span class="line-removed">462                     if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)</span>
<span class="line-removed">463                         transformedProgress = *computedTimingProgress;</span>
<span class="line-removed">464                 }</span>
<span class="line-removed">465                 auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);</span>
<span class="line-removed">466                 auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-removed">467                 auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;</span>
<span class="line-removed">468 </span>
<span class="line-removed">469                 ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">470             } else {</span>
<span class="line-removed">471                 // 4. Otherwise, implementations must cancel the running transition</span>
<span class="line-removed">472                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-removed">473 </span>
<span class="line-removed">474                 // and start a new transition whose:</span>
<span class="line-removed">475                 //   - start time is the time of the style change event plus the matching transition delay,</span>
<span class="line-removed">476                 //   - end time is the start time plus the matching transition duration,</span>
<span class="line-removed">477                 //   - start value is the current value of the property in the running transition,</span>
<span class="line-removed">478                 //   - end value is the value of the property in the after-change style,</span>
<span class="line-removed">479                 //   - reversing-adjusted start value is the same as the start value, and</span>
<span class="line-removed">480                 //   - reversing shortening factor is 1.</span>
<span class="line-removed">481                 auto delay = Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-removed">482                 auto duration = Seconds(matchingBackingAnimation-&gt;duration());</span>
<span class="line-removed">483                 auto&amp; reversingAdjustedStartStyle = currentStyle;</span>
<span class="line-removed">484                 auto reversingShorteningFactor = 1;</span>
<span class="line-removed">485                 ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">486             }</span>
487         }
<a name="47" id="anc47"></a>
488     }
<a name="48" id="anc48"></a><span class="line-removed">489 }</span>
490 
<a name="49" id="anc49"></a><span class="line-modified">491 void AnimationTimeline::cancelDeclarativeAnimation(DeclarativeAnimation&amp; animation)</span>
<span class="line-modified">492 {</span>
<span class="line-removed">493     animation.cancelFromStyle();</span>
<span class="line-removed">494     removeAnimation(animation);</span>
<span class="line-removed">495     m_allAnimations.removeFirst(&amp;animation);</span>
496 }
497 
498 } // namespace WebCore
<a name="50" id="anc50"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="50" type="hidden" />
</body>
</html>
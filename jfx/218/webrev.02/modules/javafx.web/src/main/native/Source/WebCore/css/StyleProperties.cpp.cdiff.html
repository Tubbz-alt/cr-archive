<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleColor.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleProperties.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 47,23 ***</span>
  #include &lt;wtf/text/CString.h&gt;
  #endif
  
  namespace WebCore {
  
  static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
  {
<span class="line-modified">!     return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(CSSValue*) * count + sizeof(StylePropertyMetadata) * count;</span>
  }
  
  static bool isInitialOrInherit(const String&amp; value)
  {
      return value.length() == 7 &amp;&amp; (value == &quot;initial&quot; || value == &quot;inherit&quot;);
  }
  
  Ref&lt;ImmutableStyleProperties&gt; ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
  {
<span class="line-modified">!     void* slot = WTF::fastMalloc(sizeForImmutableStylePropertiesWithPropertyCount(count));</span>
      return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
  }
  
  Ref&lt;ImmutableStyleProperties&gt; StyleProperties::immutableCopyIfNeeded() const
  {
<span class="line-new-header">--- 47,27 ---</span>
  #include &lt;wtf/text/CString.h&gt;
  #endif
  
  namespace WebCore {
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);</span>
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);</span>
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);</span>
<span class="line-added">+ </span>
  static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
  {
<span class="line-modified">!     return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(StylePropertyMetadata) * count + sizeof(PackedPtr&lt;const CSSValue&gt;) * count;</span>
  }
  
  static bool isInitialOrInherit(const String&amp; value)
  {
      return value.length() == 7 &amp;&amp; (value == &quot;initial&quot; || value == &quot;inherit&quot;);
  }
  
  Ref&lt;ImmutableStyleProperties&gt; ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
  {
<span class="line-modified">!     void* slot = ImmutableStylePropertiesMalloc::malloc(sizeForImmutableStylePropertiesWithPropertyCount(count));</span>
      return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
  }
  
  Ref&lt;ImmutableStyleProperties&gt; StyleProperties::immutableCopyIfNeeded() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 76,35 ***</span>
  MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
      : StyleProperties(cssParserMode, MutablePropertiesType)
  {
  }
  
<span class="line-modified">! MutableStyleProperties::MutableStyleProperties(const CSSProperty* properties, unsigned length)</span>
      : StyleProperties(HTMLStandardMode, MutablePropertiesType)
  {
<span class="line-removed">-     m_propertyVector.reserveInitialCapacity(length);</span>
<span class="line-removed">-     for (unsigned i = 0; i &lt; length; ++i)</span>
<span class="line-removed">-         m_propertyVector.uncheckedAppend(properties[i]);</span>
  }
  
  MutableStyleProperties::~MutableStyleProperties() = default;
  
  ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
      : StyleProperties(cssParserMode, length)
  {
      StylePropertyMetadata* metadataArray = const_cast&lt;StylePropertyMetadata*&gt;(this-&gt;metadataArray());
<span class="line-modified">!     CSSValue** valueArray = const_cast&lt;CSSValue**&gt;(this-&gt;valueArray());</span>
      for (unsigned i = 0; i &lt; length; ++i) {
          metadataArray[i] = properties[i].metadata();
<span class="line-modified">!         valueArray[i] = properties[i].value();</span>
<span class="line-modified">!         valueArray[i]-&gt;ref();</span>
      }
  }
  
  ImmutableStyleProperties::~ImmutableStyleProperties()
  {
<span class="line-modified">!     CSSValue** valueArray = const_cast&lt;CSSValue**&gt;(this-&gt;valueArray());</span>
      for (unsigned i = 0; i &lt; m_arraySize; ++i)
          valueArray[i]-&gt;deref();
  }
  
  MutableStyleProperties::MutableStyleProperties(const StyleProperties&amp; other)
<span class="line-new-header">--- 80,34 ---</span>
  MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
      : StyleProperties(cssParserMode, MutablePropertiesType)
  {
  }
  
<span class="line-modified">! MutableStyleProperties::MutableStyleProperties(Vector&lt;CSSProperty&gt;&amp;&amp; properties)</span>
      : StyleProperties(HTMLStandardMode, MutablePropertiesType)
<span class="line-added">+     , m_propertyVector(WTFMove(properties))</span>
  {
  }
  
  MutableStyleProperties::~MutableStyleProperties() = default;
  
  ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
      : StyleProperties(cssParserMode, length)
  {
      StylePropertyMetadata* metadataArray = const_cast&lt;StylePropertyMetadata*&gt;(this-&gt;metadataArray());
<span class="line-modified">!     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());</span>
      for (unsigned i = 0; i &lt; length; ++i) {
          metadataArray[i] = properties[i].metadata();
<span class="line-modified">!         auto* value = properties[i].value();</span>
<span class="line-modified">!         valueArray[i] = value;</span>
<span class="line-added">+         value-&gt;ref();</span>
      }
  }
  
  ImmutableStyleProperties::~ImmutableStyleProperties()
  {
<span class="line-modified">!     PackedPtr&lt;CSSValue&gt;* valueArray = bitwise_cast&lt;PackedPtr&lt;CSSValue&gt;*&gt;(this-&gt;valueArray());</span>
      for (unsigned i = 0; i &lt; m_arraySize; ++i)
          valueArray[i]-&gt;deref();
  }
  
  MutableStyleProperties::MutableStyleProperties(const StyleProperties&amp; other)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,12 ***</span>
  }
  
  String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
  {
      RefPtr&lt;CSSValue&gt; value = getPropertyCSSValue(propertyID);
<span class="line-modified">!     if (value)</span>
<span class="line-modified">!         return value-&gt;cssText();</span>
  
      const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
      if (shorthand.length()) {
          RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
          if (!value || value-&gt;isPendingSubstitutionValue())
<span class="line-new-header">--- 126,27 ---</span>
  }
  
  String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
  {
      RefPtr&lt;CSSValue&gt; value = getPropertyCSSValue(propertyID);
<span class="line-modified">!     if (value) {</span>
<span class="line-modified">!         switch (propertyID) {</span>
<span class="line-added">+         case CSSPropertyFillOpacity:</span>
<span class="line-added">+         case CSSPropertyFloodOpacity:</span>
<span class="line-added">+         case CSSPropertyOpacity:</span>
<span class="line-added">+         case CSSPropertyStopOpacity:</span>
<span class="line-added">+         case CSSPropertyStrokeOpacity:</span>
<span class="line-added">+             // Opacity values always serializes as a number.</span>
<span class="line-added">+             if (value-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;isPercentage()) {</span>
<span class="line-added">+                 auto doubleValue = downcast&lt;CSSPrimitiveValue&gt;(value.get())-&gt;doubleValue();</span>
<span class="line-added">+                 return makeString(doubleValue / 100.0);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             FALLTHROUGH;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             return value-&gt;cssText();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      const StylePropertyShorthand&amp; shorthand = shorthandForProperty(propertyID);
      if (shorthand.length()) {
          RefPtr&lt;CSSValue&gt; value = getPropertyCSSValueInternal(shorthand.properties()[0]);
          if (!value || value-&gt;isPendingSubstitutionValue())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 203,19 ***</span>
      case CSSPropertyFlex:
          return getShorthandValue(flexShorthand());
      case CSSPropertyFlexFlow:
          return getShorthandValue(flexFlowShorthand());
      case CSSPropertyGridArea:
<span class="line-modified">!         return getShorthandValue(gridAreaShorthand());</span>
      case CSSPropertyGridTemplate:
<span class="line-modified">!         return getShorthandValue(gridTemplateShorthand());</span>
      case CSSPropertyGrid:
<span class="line-modified">!         return getShorthandValue(gridShorthand());</span>
      case CSSPropertyGridColumn:
<span class="line-modified">!         return getShorthandValue(gridColumnShorthand());</span>
      case CSSPropertyGridRow:
<span class="line-modified">!         return getShorthandValue(gridRowShorthand());</span>
      case CSSPropertyPageBreakAfter:
          return pageBreakPropertyValue(pageBreakAfterShorthand());
      case CSSPropertyPageBreakBefore:
          return pageBreakPropertyValue(pageBreakBeforeShorthand());
      case CSSPropertyPageBreakInside:
<span class="line-new-header">--- 221,19 ---</span>
      case CSSPropertyFlex:
          return getShorthandValue(flexShorthand());
      case CSSPropertyFlexFlow:
          return getShorthandValue(flexFlowShorthand());
      case CSSPropertyGridArea:
<span class="line-modified">!         return getGridShorthandValue(gridAreaShorthand());</span>
      case CSSPropertyGridTemplate:
<span class="line-modified">!         return getGridShorthandValue(gridTemplateShorthand());</span>
      case CSSPropertyGrid:
<span class="line-modified">!         return getGridShorthandValue(gridShorthand());</span>
      case CSSPropertyGridColumn:
<span class="line-modified">!         return getGridShorthandValue(gridColumnShorthand());</span>
      case CSSPropertyGridRow:
<span class="line-modified">!         return getGridShorthandValue(gridRowShorthand());</span>
      case CSSPropertyPageBreakAfter:
          return pageBreakPropertyValue(pageBreakAfterShorthand());
      case CSSPropertyPageBreakBefore:
          return pageBreakPropertyValue(pageBreakBeforeShorthand());
      case CSSPropertyPageBreakInside:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,23 ***</span>
      case CSSPropertyMarginInline:
          return get2Values(marginInlineShorthand());
      case CSSPropertyWebkitMarginCollapse:
          return getShorthandValue(webkitMarginCollapseShorthand());
      case CSSPropertyOverflow:
<span class="line-modified">!         return getCommonValue(overflowShorthand());</span>
      case CSSPropertyPadding:
          return get4Values(paddingShorthand());
      case CSSPropertyPaddingBlock:
          return get2Values(paddingBlockShorthand());
      case CSSPropertyPaddingInline:
          return get2Values(paddingInlineShorthand());
      case CSSPropertyTransition:
          return getLayeredShorthandValue(transitionShorthand());
      case CSSPropertyListStyle:
          return getShorthandValue(listStyleShorthand());
<span class="line-removed">-     case CSSPropertyWebkitMarquee:</span>
<span class="line-removed">-         return getShorthandValue(webkitMarqueeShorthand());</span>
      case CSSPropertyWebkitMaskPosition:
          return getLayeredShorthandValue(webkitMaskPositionShorthand());
      case CSSPropertyWebkitMaskRepeat:
          return getLayeredShorthandValue(webkitMaskRepeatShorthand());
      case CSSPropertyWebkitMask:
<span class="line-new-header">--- 259,21 ---</span>
      case CSSPropertyMarginInline:
          return get2Values(marginInlineShorthand());
      case CSSPropertyWebkitMarginCollapse:
          return getShorthandValue(webkitMarginCollapseShorthand());
      case CSSPropertyOverflow:
<span class="line-modified">!         return get2Values(overflowShorthand());</span>
      case CSSPropertyPadding:
          return get4Values(paddingShorthand());
      case CSSPropertyPaddingBlock:
          return get2Values(paddingBlockShorthand());
      case CSSPropertyPaddingInline:
          return get2Values(paddingInlineShorthand());
      case CSSPropertyTransition:
          return getLayeredShorthandValue(transitionShorthand());
      case CSSPropertyListStyle:
          return getShorthandValue(listStyleShorthand());
      case CSSPropertyWebkitMaskPosition:
          return getLayeredShorthandValue(webkitMaskPositionShorthand());
      case CSSPropertyWebkitMaskRepeat:
          return getLayeredShorthandValue(webkitMaskRepeatShorthand());
      case CSSPropertyWebkitMask:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,11 ***</span>
      if (result.isEmpty())
          return String();
      return result.toString();
  }
  
<span class="line-modified">! String StyleProperties::getShorthandValue(const StylePropertyShorthand&amp; shorthand) const</span>
  {
      String commonValue;
      StringBuilder result;
      for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
          if (!isPropertyImplicit(shorthand.properties()[i])) {
<span class="line-new-header">--- 651,16 ---</span>
      if (result.isEmpty())
          return String();
      return result.toString();
  }
  
<span class="line-modified">! String StyleProperties::getGridShorthandValue(const StylePropertyShorthand&amp; shorthand) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return getShorthandValue(shorthand, &quot; / &quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ String StyleProperties::getShorthandValue(const StylePropertyShorthand&amp; shorthand, const char* separator) const</span>
  {
      String commonValue;
      StringBuilder result;
      for (unsigned i = 0; i &lt; shorthand.length(); ++i) {
          if (!isPropertyImplicit(shorthand.properties()[i])) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,11 ***</span>
              else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
                  commonValue = String();
              if (value-&gt;isInitialValue())
                  continue;
              if (!result.isEmpty())
<span class="line-modified">!                 result.append(&#39; &#39;);</span>
              result.append(valueText);
          } else
              commonValue = String();
      }
      if (isInitialOrInherit(commonValue))
<span class="line-new-header">--- 673,11 ---</span>
              else if (!commonValue.isNull() &amp;&amp; commonValue != valueText)
                  commonValue = String();
              if (value-&gt;isInitialValue())
                  continue;
              if (!result.isEmpty())
<span class="line-modified">!                 result.append(separator);</span>
              result.append(valueText);
          } else
              commonValue = String();
      }
      if (isInitialOrInherit(commonValue))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,11 ***</span>
      }
  
      // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
      // It is required because background-position-x/y are non-standard properties and WebKit generated output
      // would not work in Firefox (&lt;rdar://problem/5143183&gt;)
<span class="line-modified">!     // It would be a better solution if background-position was CSS_PAIR.</span>
      if (positionXPropertyIndex != -1 &amp;&amp; positionYPropertyIndex != -1 &amp;&amp; propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
          PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
          PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
  
          if (numDecls++)
<span class="line-new-header">--- 1289,11 ---</span>
      }
  
      // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
      // It is required because background-position-x/y are non-standard properties and WebKit generated output
      // would not work in Firefox (&lt;rdar://problem/5143183&gt;)
<span class="line-modified">!     // It would be a better solution if background-position was CSSUnitType::CSS_PAIR.</span>
      if (positionXPropertyIndex != -1 &amp;&amp; positionYPropertyIndex != -1 &amp;&amp; propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
          PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
          PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
  
          if (numDecls++)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1449,13 ***</span>
      // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
      // the compiler converting it to an int multiple times in the loop.
      for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
          if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
              // We found a custom property. See if the name matches.
<span class="line-modified">!             if (!valueArray()[n])</span>
                  continue;
<span class="line-modified">!             if (downcast&lt;CSSCustomPropertyValue&gt;(*valueArray()[n]).name() == propertyName)</span>
                  return n;
          }
      }
  
      return -1;
<span class="line-new-header">--- 1470,14 ---</span>
      // Convert the propertyID into an uint16_t to compare it with the metadata&#39;s m_propertyID to avoid
      // the compiler converting it to an int multiple times in the loop.
      for (int n = m_arraySize - 1 ; n &gt;= 0; --n) {
          if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
              // We found a custom property. See if the name matches.
<span class="line-modified">!             auto* value = valueArray()[n].get();</span>
<span class="line-added">+             if (!value)</span>
                  continue;
<span class="line-modified">!             if (downcast&lt;CSSCustomPropertyValue&gt;(*value).name() == propertyName)</span>
                  return n;
          }
      }
  
      return -1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1507,17 ***</span>
      return adoptRef(*new MutableStyleProperties(*this));
  }
  
  Ref&lt;MutableStyleProperties&gt; StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
  {
<span class="line-modified">!     Vector&lt;CSSProperty, 256&gt; list;</span>
      list.reserveInitialCapacity(length);
      for (unsigned i = 0; i &lt; length; ++i) {
          if (auto value = getPropertyCSSValueInternal(set[i]))
              list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
      }
<span class="line-modified">!     return MutableStyleProperties::create(list.data(), list.size());</span>
  }
  
  PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
  {
      return m_cssomWrapper.get();
<span class="line-new-header">--- 1529,17 ---</span>
      return adoptRef(*new MutableStyleProperties(*this));
  }
  
  Ref&lt;MutableStyleProperties&gt; StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
  {
<span class="line-modified">!     Vector&lt;CSSProperty&gt; list;</span>
      list.reserveInitialCapacity(length);
      for (unsigned i = 0; i &lt; length; ++i) {
          if (auto value = getPropertyCSSValueInternal(set[i]))
              list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
      }
<span class="line-modified">!     return MutableStyleProperties::create(WTFMove(list));</span>
  }
  
  PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
  {
      return m_cssomWrapper.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1566,13 ***</span>
  Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(CSSParserMode cssParserMode)
  {
      return adoptRef(*new MutableStyleProperties(cssParserMode));
  }
  
<span class="line-modified">! Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(const CSSProperty* properties, unsigned count)</span>
  {
<span class="line-modified">!     return adoptRef(*new MutableStyleProperties(properties, count));</span>
  }
  
  String StyleProperties::PropertyReference::cssName() const
  {
      if (id() == CSSPropertyCustom)
<span class="line-new-header">--- 1588,13 ---</span>
  Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(CSSParserMode cssParserMode)
  {
      return adoptRef(*new MutableStyleProperties(cssParserMode));
  }
  
<span class="line-modified">! Ref&lt;MutableStyleProperties&gt; MutableStyleProperties::create(Vector&lt;CSSProperty&gt;&amp;&amp; properties)</span>
  {
<span class="line-modified">!     return adoptRef(*new MutableStyleProperties(WTFMove(properties)));</span>
  }
  
  String StyleProperties::PropertyReference::cssName() const
  {
      if (id() == CSSPropertyCustom)
</pre>
<center><a href="StyleColor.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleProperties.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
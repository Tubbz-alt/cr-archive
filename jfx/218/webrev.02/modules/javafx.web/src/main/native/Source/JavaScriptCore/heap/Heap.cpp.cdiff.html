<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HandleSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,19 ***</span>
  #include &quot;VisitCounter.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WeakMapImplInlines.h&quot;
  #include &quot;WeakSetInlines.h&quot;
  #include &lt;algorithm&gt;
  #include &lt;wtf/ListDump.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/ParallelVectorIterator.h&gt;
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/RAMSize.h&gt;
  #include &lt;wtf/SimpleStats.h&gt;
  #include &lt;wtf/Threading.h&gt;
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
  #include &lt;bmalloc/bmalloc.h&gt;
  #endif
  
  #if USE(FOUNDATION)
  #include &lt;wtf/spi/cocoa/objcSPI.h&gt;
<span class="line-new-header">--- 78,20 ---</span>
  #include &quot;VisitCounter.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WeakMapImplInlines.h&quot;
  #include &quot;WeakSetInlines.h&quot;
  #include &lt;algorithm&gt;
<span class="line-added">+ #include &lt;wtf/CryptographicallyRandomNumber.h&gt;</span>
  #include &lt;wtf/ListDump.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/ParallelVectorIterator.h&gt;
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/RAMSize.h&gt;
  #include &lt;wtf/SimpleStats.h&gt;
  #include &lt;wtf/Threading.h&gt;
  
<span class="line-modified">! #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
  #include &lt;bmalloc/bmalloc.h&gt;
  #endif
  
  #if USE(FOUNDATION)
  #include &lt;wtf/spi/cocoa/objcSPI.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,11 ***</span>
  size_t proportionalHeapSize(size_t heapSize, size_t ramSize)
  {
      if (VM::isInMiniMode())
          return Options::miniVMHeapGrowthFactor() * heapSize;
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
      size_t memoryFootprint = bmalloc::api::memoryFootprint();
      if (memoryFootprint &lt; ramSize * Options::smallHeapRAMFraction())
          return Options::smallHeapGrowthFactor() * heapSize;
      if (memoryFootprint &lt; ramSize * Options::mediumHeapRAMFraction())
          return Options::mediumHeapGrowthFactor() * heapSize;
<span class="line-new-header">--- 128,11 ---</span>
  size_t proportionalHeapSize(size_t heapSize, size_t ramSize)
  {
      if (VM::isInMiniMode())
          return Options::miniVMHeapGrowthFactor() * heapSize;
  
<span class="line-modified">! #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
      size_t memoryFootprint = bmalloc::api::memoryFootprint();
      if (memoryFootprint &lt; ramSize * Options::smallHeapRAMFraction())
          return Options::smallHeapGrowthFactor() * heapSize;
      if (memoryFootprint &lt; ramSize * Options::mediumHeapRAMFraction())
          return Options::mediumHeapGrowthFactor() * heapSize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 369,17 ***</span>
  void Heap::dumpHeapStatisticsAtVMDestruction()
  {
      unsigned counter = 0;
      m_objectSpace.forEachBlock([&amp;] (MarkedBlock::Handle* block) {
          unsigned live = 0;
<span class="line-modified">!         block-&gt;forEachCell([&amp;] (HeapCell* cell, HeapCell::Kind) {</span>
              if (cell-&gt;isLive())
                  live++;
              return IterationStatus::Continue;
          });
          dataLogLn(&quot;[&quot;, counter++, &quot;] &quot;, block-&gt;cellSize(), &quot;, &quot;, live, &quot; / &quot;, block-&gt;cellsPerBlock(), &quot; &quot;, static_cast&lt;double&gt;(live) / block-&gt;cellsPerBlock() * 100, &quot;% &quot;, block-&gt;attributes(), &quot; &quot;, block-&gt;subspace()-&gt;name());
<span class="line-modified">!         block-&gt;forEachCell([&amp;] (HeapCell* heapCell, HeapCell::Kind kind) {</span>
              if (heapCell-&gt;isLive() &amp;&amp; kind == HeapCell::Kind::JSCell) {
                  auto* cell = static_cast&lt;JSCell*&gt;(heapCell);
                  if (cell-&gt;isObject())
                      dataLogLn(&quot;    &quot;, JSValue((JSObject*)cell));
                  else
<span class="line-new-header">--- 370,17 ---</span>
  void Heap::dumpHeapStatisticsAtVMDestruction()
  {
      unsigned counter = 0;
      m_objectSpace.forEachBlock([&amp;] (MarkedBlock::Handle* block) {
          unsigned live = 0;
<span class="line-modified">!         block-&gt;forEachCell([&amp;] (size_t, HeapCell* cell, HeapCell::Kind) {</span>
              if (cell-&gt;isLive())
                  live++;
              return IterationStatus::Continue;
          });
          dataLogLn(&quot;[&quot;, counter++, &quot;] &quot;, block-&gt;cellSize(), &quot;, &quot;, live, &quot; / &quot;, block-&gt;cellsPerBlock(), &quot; &quot;, static_cast&lt;double&gt;(live) / block-&gt;cellsPerBlock() * 100, &quot;% &quot;, block-&gt;attributes(), &quot; &quot;, block-&gt;subspace()-&gt;name());
<span class="line-modified">!         block-&gt;forEachCell([&amp;] (size_t, HeapCell* heapCell, HeapCell::Kind kind) {</span>
              if (heapCell-&gt;isLive() &amp;&amp; kind == HeapCell::Kind::JSCell) {
                  auto* cell = static_cast&lt;JSCell*&gt;(heapCell);
                  if (cell-&gt;isObject())
                      dataLogLn(&quot;    &quot;, JSValue((JSObject*)cell));
                  else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 393,11 ***</span>
  // The VM is being destroyed and the collector will never run again.
  // Run all pending finalizers now because we won&#39;t get another chance.
  void Heap::lastChanceToFinalize()
  {
      MonotonicTime before;
<span class="line-modified">!     if (Options::logGC()) {</span>
          before = MonotonicTime::now();
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: shutdown &quot;);
      }
  
      m_isShuttingDown = true;
<span class="line-new-header">--- 394,11 ---</span>
  // The VM is being destroyed and the collector will never run again.
  // Run all pending finalizers now because we won&#39;t get another chance.
  void Heap::lastChanceToFinalize()
  {
      MonotonicTime before;
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          before = MonotonicTime::now();
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: shutdown &quot;);
      }
  
      m_isShuttingDown = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,43 ***</span>
              m_collectContinuouslyCondition.notifyOne();
          }
          m_collectContinuouslyThread-&gt;waitForCompletion();
      }
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;1&quot;);</span>
  
      // Prevent new collections from being started. This is probably not even necessary, since we&#39;re not
      // going to call into anything that starts collections. Still, this makes the algorithm more
      // obviously sound.
      m_isSafeToCollect = false;
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;2&quot;);</span>
  
      bool isCollecting;
      {
          auto locker = holdLock(*m_threadLock);
          RELEASE_ASSERT(m_lastServedTicket &lt;= m_lastGrantedTicket);
          isCollecting = m_lastServedTicket &lt; m_lastGrantedTicket;
      }
      if (isCollecting) {
<span class="line-modified">!         if (Options::logGC())</span>
<span class="line-removed">-             dataLog(&quot;...]\n&quot;);</span>
  
          // Wait for the current collection to finish.
          waitForCollector(
              [&amp;] (const AbstractLocker&amp;) -&gt; bool {
                  RELEASE_ASSERT(m_lastServedTicket &lt;= m_lastGrantedTicket);
                  return m_lastServedTicket == m_lastGrantedTicket;
              });
  
<span class="line-modified">!         if (Options::logGC())</span>
<span class="line-removed">-             dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: shutdown &quot;);</span>
      }
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;3&quot;);</span>
  
      RELEASE_ASSERT(m_requests.isEmpty());
      RELEASE_ASSERT(m_lastServedTicket == m_lastGrantedTicket);
  
      // Carefully bring the thread down.
<span class="line-new-header">--- 413,38 ---</span>
              m_collectContinuouslyCondition.notifyOne();
          }
          m_collectContinuouslyThread-&gt;waitForCompletion();
      }
  
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;1&quot;);</span>
  
      // Prevent new collections from being started. This is probably not even necessary, since we&#39;re not
      // going to call into anything that starts collections. Still, this makes the algorithm more
      // obviously sound.
      m_isSafeToCollect = false;
  
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;2&quot;);</span>
  
      bool isCollecting;
      {
          auto locker = holdLock(*m_threadLock);
          RELEASE_ASSERT(m_lastServedTicket &lt;= m_lastGrantedTicket);
          isCollecting = m_lastServedTicket &lt; m_lastGrantedTicket;
      }
      if (isCollecting) {
<span class="line-modified">!         dataLogIf(Options::logGC(), &quot;...]\n&quot;);</span>
  
          // Wait for the current collection to finish.
          waitForCollector(
              [&amp;] (const AbstractLocker&amp;) -&gt; bool {
                  RELEASE_ASSERT(m_lastServedTicket &lt;= m_lastGrantedTicket);
                  return m_lastServedTicket == m_lastGrantedTicket;
              });
  
<span class="line-modified">!         dataLogIf(Options::logGC(), &quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: shutdown &quot;);</span>
      }
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;3&quot;);</span>
  
      RELEASE_ASSERT(m_requests.isEmpty());
      RELEASE_ASSERT(m_lastServedTicket == m_lastGrantedTicket);
  
      // Carefully bring the thread down.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 459,18 ***</span>
          m_threadShouldStop = true;
          if (!stopped)
              m_threadCondition-&gt;notifyOne(locker);
      }
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;4&quot;);</span>
  
      if (!stopped)
          m_thread-&gt;join();
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;5 &quot;);</span>
  
      if (UNLIKELY(Options::dumpHeapStatisticsAtVMDestruction()))
          dumpHeapStatisticsAtVMDestruction();
  
      m_arrayBuffers.lastChanceToFinalize();
<span class="line-new-header">--- 455,16 ---</span>
          m_threadShouldStop = true;
          if (!stopped)
              m_threadCondition-&gt;notifyOne(locker);
      }
  
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;4&quot;);</span>
  
      if (!stopped)
          m_thread-&gt;join();
  
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;5 &quot;);</span>
  
      if (UNLIKELY(Options::dumpHeapStatisticsAtVMDestruction()))
          dumpHeapStatisticsAtVMDestruction();
  
      m_arrayBuffers.lastChanceToFinalize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 480,12 ***</span>
  
      sweepAllLogicallyEmptyWeakBlocks();
  
      m_objectSpace.freeMemory();
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog((MonotonicTime::now() - before).milliseconds(), &quot;ms]\n&quot;);</span>
  }
  
  void Heap::releaseDelayedReleasedObjects()
  {
  #if USE(FOUNDATION) || defined(JSC_GLIB_API_ENABLED)
<span class="line-new-header">--- 474,11 ---</span>
  
      sweepAllLogicallyEmptyWeakBlocks();
  
      m_objectSpace.freeMemory();
  
<span class="line-modified">!     dataLogIf(Options::logGC(), (MonotonicTime::now() - before).milliseconds(), &quot;ms]\n&quot;);</span>
  }
  
  void Heap::releaseDelayedReleasedObjects()
  {
  #if USE(FOUNDATION) || defined(JSC_GLIB_API_ENABLED)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,14 ***</span>
      reportExtraMemoryAllocatedSlowCase(size);
  }
  
  bool Heap::overCriticalMemoryThreshold(MemoryThresholdCallType memoryThresholdCallType)
  {
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">!     if (memoryThresholdCallType == MemoryThresholdCallType::Direct || ++m_precentAvailableMemoryCachedCallCount &gt;= 100) {</span>
          m_overCriticalMemoryThreshold = bmalloc::api::percentAvailableMemoryInUse() &gt; Options::criticalGCMemoryThreshold();
<span class="line-modified">!         m_precentAvailableMemoryCachedCallCount = 0;</span>
      }
  
      return m_overCriticalMemoryThreshold;
  #else
      UNUSED_PARAM(memoryThresholdCallType);
<span class="line-new-header">--- 529,14 ---</span>
      reportExtraMemoryAllocatedSlowCase(size);
  }
  
  bool Heap::overCriticalMemoryThreshold(MemoryThresholdCallType memoryThresholdCallType)
  {
<span class="line-modified">! #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
<span class="line-modified">!     if (memoryThresholdCallType == MemoryThresholdCallType::Direct || ++m_percentAvailableMemoryCachedCallCount &gt;= 100) {</span>
          m_overCriticalMemoryThreshold = bmalloc::api::percentAvailableMemoryInUse() &gt; Options::criticalGCMemoryThreshold();
<span class="line-modified">!         m_percentAvailableMemoryCachedCallCount = 0;</span>
      }
  
      return m_overCriticalMemoryThreshold;
  #else
      UNUSED_PARAM(memoryThresholdCallType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 610,15 ***</span>
  void Heap::finalizeUnconditionalFinalizers()
  {
      vm().builtinExecutables()-&gt;finalizeUnconditionally();
      finalizeMarkedUnconditionalFinalizers&lt;FunctionExecutable&gt;(vm().functionExecutableSpace.space);
      finalizeMarkedUnconditionalFinalizers&lt;SymbolTable&gt;(vm().symbolTableSpace);
      vm().forEachCodeBlockSpace(
          [&amp;] (auto&amp; space) {
              this-&gt;finalizeMarkedUnconditionalFinalizers&lt;CodeBlock&gt;(space.set);
          });
<span class="line-removed">-     finalizeMarkedUnconditionalFinalizers&lt;ExecutableToCodeBlockEdge&gt;(vm().executableToCodeBlockEdgesWithFinalizers);</span>
      finalizeMarkedUnconditionalFinalizers&lt;StructureRareData&gt;(vm().structureRareDataSpace);
      finalizeMarkedUnconditionalFinalizers&lt;UnlinkedFunctionExecutable&gt;(vm().unlinkedFunctionExecutableSpace.set);
      if (vm().m_weakSetSpace)
          finalizeMarkedUnconditionalFinalizers&lt;JSWeakSet&gt;(*vm().m_weakSetSpace);
      if (vm().m_weakMapSpace)
<span class="line-new-header">--- 603,15 ---</span>
  void Heap::finalizeUnconditionalFinalizers()
  {
      vm().builtinExecutables()-&gt;finalizeUnconditionally();
      finalizeMarkedUnconditionalFinalizers&lt;FunctionExecutable&gt;(vm().functionExecutableSpace.space);
      finalizeMarkedUnconditionalFinalizers&lt;SymbolTable&gt;(vm().symbolTableSpace);
<span class="line-added">+     finalizeMarkedUnconditionalFinalizers&lt;ExecutableToCodeBlockEdge&gt;(vm().executableToCodeBlockEdgesWithFinalizers); // We run this before CodeBlock&#39;s unconditional finalizer since CodeBlock looks at the owner executable&#39;s installed CodeBlock in its finalizeUnconditionally.</span>
      vm().forEachCodeBlockSpace(
          [&amp;] (auto&amp; space) {
              this-&gt;finalizeMarkedUnconditionalFinalizers&lt;CodeBlock&gt;(space.set);
          });
      finalizeMarkedUnconditionalFinalizers&lt;StructureRareData&gt;(vm().structureRareDataSpace);
      finalizeMarkedUnconditionalFinalizers&lt;UnlinkedFunctionExecutable&gt;(vm().unlinkedFunctionExecutableSpace.set);
      if (vm().m_weakSetSpace)
          finalizeMarkedUnconditionalFinalizers&lt;JSWeakSet&gt;(*vm().m_weakSetSpace);
      if (vm().m_weakMapSpace)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 718,10 ***</span>
<span class="line-new-header">--- 711,11 ---</span>
  {
  #if ENABLE(DFG_JIT)
      if (!VM::canUseJIT())
          return;
      m_vm.gatherScratchBufferRoots(roots);
<span class="line-added">+     m_vm.scanSideState(roots);</span>
  #else
      UNUSED_PARAM(roots);
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1047,17 ***</span>
  }
  
  void Heap::sweepSynchronously()
  {
      MonotonicTime before { };
<span class="line-modified">!     if (Options::logGC()) {</span>
          dataLog(&quot;Full sweep: &quot;, capacity() / 1024, &quot;kb &quot;);
          before = MonotonicTime::now();
      }
<span class="line-modified">!     m_objectSpace.sweep();</span>
      m_objectSpace.shrink();
<span class="line-modified">!     if (Options::logGC()) {</span>
          MonotonicTime after = MonotonicTime::now();
          dataLog(&quot;=&gt; &quot;, capacity() / 1024, &quot;kb, &quot;, (after - before).milliseconds(), &quot;ms&quot;);
      }
  }
  
<span class="line-new-header">--- 1041,17 ---</span>
  }
  
  void Heap::sweepSynchronously()
  {
      MonotonicTime before { };
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          dataLog(&quot;Full sweep: &quot;, capacity() / 1024, &quot;kb &quot;);
          before = MonotonicTime::now();
      }
<span class="line-modified">!     m_objectSpace.sweepBlocks();</span>
      m_objectSpace.shrink();
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          MonotonicTime after = MonotonicTime::now();
          dataLog(&quot;=&gt; &quot;, capacity() / 1024, &quot;kb, &quot;, (after - before).milliseconds(), &quot;ms&quot;);
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1093,15 ***</span>
          if (UNLIKELY(Options::useImmortalObjects()))
              sweeper().stopSweeping();
  
          bool alreadySweptInCollectSync = shouldSweepSynchronously();
          if (!alreadySweptInCollectSync) {
<span class="line-modified">!             if (Options::logGC())</span>
<span class="line-removed">-                 dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: &quot;);</span>
              sweepSynchronously();
<span class="line-modified">!             if (Options::logGC())</span>
<span class="line-removed">-                 dataLog(&quot;]\n&quot;);</span>
          }
          m_objectSpace.assertNoUnswept();
  
          sweepAllLogicallyEmptyWeakBlocks();
          return;
<span class="line-new-header">--- 1087,13 ---</span>
          if (UNLIKELY(Options::useImmortalObjects()))
              sweeper().stopSweeping();
  
          bool alreadySweptInCollectSync = shouldSweepSynchronously();
          if (!alreadySweptInCollectSync) {
<span class="line-modified">!             dataLogIf(Options::logGC(), &quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: &quot;);</span>
              sweepSynchronously();
<span class="line-modified">!             dataLogIf(Options::logGC(), &quot;]\n&quot;);</span>
          }
          m_objectSpace.assertNoUnswept();
  
          sweepAllLogicallyEmptyWeakBlocks();
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1261,17 ***</span>
          LockHolder locker(*m_threadLock);
          RELEASE_ASSERT(!m_requests.isEmpty());
          m_currentRequest = m_requests.first();
      }
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: START &quot;, gcConductorShortName(conn), &quot; &quot;, capacity() / 1024, &quot;kb &quot;);</span>
  
      m_beforeGC = MonotonicTime::now();
  
      if (m_collectionScope) {
<span class="line-modified">!         dataLog(&quot;Collection scope already set during GC: &quot;, *m_collectionScope, &quot;\n&quot;);</span>
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      willStartCollection();
  
<span class="line-new-header">--- 1253,19 ---</span>
          LockHolder locker(*m_threadLock);
          RELEASE_ASSERT(!m_requests.isEmpty());
          m_currentRequest = m_requests.first();
      }
  
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: START &quot;, gcConductorShortName(conn), &quot; &quot;, capacity() / 1024, &quot;kb &quot;);</span>
  
      m_beforeGC = MonotonicTime::now();
  
<span class="line-added">+     if (!Options::seedOfVMRandomForFuzzer())</span>
<span class="line-added">+         vm().random().setSeed(cryptographicallyRandomNumber());</span>
<span class="line-added">+ </span>
      if (m_collectionScope) {
<span class="line-modified">!         dataLogLn(&quot;Collection scope already set during GC: &quot;, *m_collectionScope);</span>
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      willStartCollection();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1328,11 ***</span>
      SlotVisitor&amp; slotVisitor = *m_collectorSlotVisitor;
  
      m_constraintSet-&gt;didStartMarking();
  
      m_scheduler-&gt;beginCollection();
<span class="line-modified">!     if (Options::logGC())</span>
          m_scheduler-&gt;log();
  
      // After this, we will almost certainly fall through all of the &quot;slotVisitor.isEmpty()&quot;
      // checks because bootstrap would have put things into the visitor. So, we should fall
      // through to draining.
<span class="line-new-header">--- 1322,11 ---</span>
      SlotVisitor&amp; slotVisitor = *m_collectorSlotVisitor;
  
      m_constraintSet-&gt;didStartMarking();
  
      m_scheduler-&gt;beginCollection();
<span class="line-modified">!     if (UNLIKELY(Options::logGC()))</span>
          m_scheduler-&gt;log();
  
      // After this, we will almost certainly fall through all of the &quot;slotVisitor.isEmpty()&quot;
      // checks because bootstrap would have put things into the visitor. So, we should fall
      // through to draining.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1356,11 ***</span>
  {
      RELEASE_ASSERT(conn == GCConductor::Collector || m_currentThreadState);
  
      SlotVisitor&amp; slotVisitor = *m_collectorSlotVisitor;
  
<span class="line-modified">!     if (Options::logGC()) {</span>
          HashMap&lt;const char*, size_t&gt; visitMap;
          forEachSlotVisitor(
              [&amp;] (SlotVisitor&amp; slotVisitor) {
                  visitMap.add(slotVisitor.codeName(), slotVisitor.bytesVisited() / 1024);
              });
<span class="line-new-header">--- 1350,11 ---</span>
  {
      RELEASE_ASSERT(conn == GCConductor::Collector || m_currentThreadState);
  
      SlotVisitor&amp; slotVisitor = *m_collectorSlotVisitor;
  
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          HashMap&lt;const char*, size_t&gt; visitMap;
          forEachSlotVisitor(
              [&amp;] (SlotVisitor&amp; slotVisitor) {
                  visitMap.add(slotVisitor.codeName(), slotVisitor.bytesVisited() / 1024);
              });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1400,12 ***</span>
          }
  
          m_scheduler-&gt;didExecuteConstraints();
      }
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(slotVisitor.collectorMarkStack().size(), &quot;+&quot;, m_mutatorMarkStack-&gt;size() + slotVisitor.mutatorMarkStack().size(), &quot; &quot;);</span>
  
      {
          ParallelModeEnabler enabler(slotVisitor);
          slotVisitor.drainInParallel(m_scheduler-&gt;timeToResume());
      }
<span class="line-new-header">--- 1394,11 ---</span>
          }
  
          m_scheduler-&gt;didExecuteConstraints();
      }
  
<span class="line-modified">!     dataLogIf(Options::logGC(), slotVisitor.collectorMarkStack().size(), &quot;+&quot;, m_mutatorMarkStack-&gt;size() + slotVisitor.mutatorMarkStack().size(), &quot; &quot;);</span>
  
      {
          ParallelModeEnabler enabler(slotVisitor);
          slotVisitor.drainInParallel(m_scheduler-&gt;timeToResume());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1427,11 ***</span>
      if (!m_scheduler-&gt;shouldResume())
          return true;
  
      m_scheduler-&gt;willResume();
  
<span class="line-modified">!     if (Options::logGC()) {</span>
          double thisPauseMS = (MonotonicTime::now() - m_stopTime).milliseconds();
          dataLog(&quot;p=&quot;, thisPauseMS, &quot;ms (max &quot;, maxPauseMS(thisPauseMS), &quot;)...]\n&quot;);
      }
  
      // Forgive the mutator for its past failures to keep up.
<span class="line-new-header">--- 1420,11 ---</span>
      if (!m_scheduler-&gt;shouldResume())
          return true;
  
      m_scheduler-&gt;willResume();
  
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          double thisPauseMS = (MonotonicTime::now() - m_stopTime).milliseconds();
          dataLog(&quot;p=&quot;, thisPauseMS, &quot;ms (max &quot;, maxPauseMS(thisPauseMS), &quot;)...]\n&quot;);
      }
  
      // Forgive the mutator for its past failures to keep up.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1471,16 ***</span>
      return false;
  }
  
  NEVER_INLINE bool Heap::runReloopPhase(GCConductor conn)
  {
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: &quot;, gcConductorShortName(conn), &quot; &quot;);</span>
  
      m_scheduler-&gt;didStop();
  
<span class="line-modified">!     if (Options::logGC())</span>
          m_scheduler-&gt;log();
  
      return changePhase(conn, CollectorPhase::Fixpoint);
  }
  
<span class="line-new-header">--- 1464,15 ---</span>
      return false;
  }
  
  NEVER_INLINE bool Heap::runReloopPhase(GCConductor conn)
  {
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: &quot;, gcConductorShortName(conn), &quot; &quot;);</span>
  
      m_scheduler-&gt;didStop();
  
<span class="line-modified">!     if (UNLIKELY(Options::logGC()))</span>
          m_scheduler-&gt;log();
  
      return changePhase(conn, CollectorPhase::Fixpoint);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1509,15 ***</span>
      }
  
      if (vm().typeProfiler())
          vm().typeProfiler()-&gt;invalidateTypeSetCache(vm());
  
      reapWeakHandles();
      pruneStaleEntriesFromWeakGCMaps();
      sweepArrayBuffers();
      snapshotUnswept();
<span class="line-modified">!     finalizeUnconditionalFinalizers();</span>
      removeDeadCompilerWorklistEntries();
      notifyIncrementalSweeper();
  
      m_codeBlocks-&gt;iterateCurrentlyExecuting(
          [&amp;] (CodeBlock* codeBlock) {
<span class="line-new-header">--- 1501,17 ---</span>
      }
  
      if (vm().typeProfiler())
          vm().typeProfiler()-&gt;invalidateTypeSetCache(vm());
  
<span class="line-added">+     m_structureIDTable.flushOldTables();</span>
<span class="line-added">+ </span>
      reapWeakHandles();
      pruneStaleEntriesFromWeakGCMaps();
      sweepArrayBuffers();
      snapshotUnswept();
<span class="line-modified">!     finalizeUnconditionalFinalizers(); // We rely on these unconditional finalizers running before clearCurrentlyExecuting since CodeBlock&#39;s finalizer relies on querying currently executing.</span>
      removeDeadCompilerWorklistEntries();
      notifyIncrementalSweeper();
  
      m_codeBlocks-&gt;iterateCurrentlyExecuting(
          [&amp;] (CodeBlock* codeBlock) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1541,11 ***</span>
      if (false) {
          dataLog(&quot;Heap state after GC:\n&quot;);
          m_objectSpace.dumpBits();
      }
  
<span class="line-modified">!     if (Options::logGC()) {</span>
          double thisPauseMS = (m_afterGC - m_stopTime).milliseconds();
          dataLog(&quot;p=&quot;, thisPauseMS, &quot;ms (max &quot;, maxPauseMS(thisPauseMS), &quot;), cycle &quot;, (m_afterGC - m_beforeGC).milliseconds(), &quot;ms END]\n&quot;);
      }
  
      {
<span class="line-new-header">--- 1535,11 ---</span>
      if (false) {
          dataLog(&quot;Heap state after GC:\n&quot;);
          m_objectSpace.dumpBits();
      }
  
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          double thisPauseMS = (m_afterGC - m_stopTime).milliseconds();
          dataLog(&quot;p=&quot;, thisPauseMS, &quot;ms (max &quot;, maxPauseMS(thisPauseMS), &quot;), cycle &quot;, (m_afterGC - m_beforeGC).milliseconds(), &quot;ms END]\n&quot;);
      }
  
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1554,12 ***</span>
          m_lastServedTicket++;
          clearMutatorWaiting();
      }
      ParkingLot::unparkAll(&amp;m_worldState);
  
<span class="line-modified">!     if (false)</span>
<span class="line-removed">-         dataLog(&quot;GC END!\n&quot;);</span>
  
      setNeedFinalize();
  
      m_lastGCStartTime = m_currentGCStartTime;
      m_lastGCEndTime = MonotonicTime::now();
<span class="line-new-header">--- 1548,11 ---</span>
          m_lastServedTicket++;
          clearMutatorWaiting();
      }
      ParkingLot::unparkAll(&amp;m_worldState);
  
<span class="line-modified">!     dataLogLnIf(Options::logGC(), &quot;GC END!&quot;);</span>
  
      setNeedFinalize();
  
      m_lastGCStartTime = m_currentGCStartTime;
      m_lastGCEndTime = MonotonicTime::now();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1656,11 ***</span>
      UNUSED_PARAM(conn);
  
      if (auto* shadowChicken = vm().shadowChicken())
          shadowChicken-&gt;update(vm(), vm().topCallFrame);
  
<span class="line-removed">-     m_structureIDTable.flushOldTables();</span>
      m_objectSpace.stopAllocating();
  
      m_stopTime = MonotonicTime::now();
  }
  
<span class="line-new-header">--- 1649,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2083,11 ***</span>
  }
  
  void Heap::finalize()
  {
      MonotonicTime before;
<span class="line-modified">!     if (Options::logGC()) {</span>
          before = MonotonicTime::now();
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: finalize &quot;);
      }
  
      {
<span class="line-new-header">--- 2075,11 ---</span>
  }
  
  void Heap::finalize()
  {
      MonotonicTime before;
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          before = MonotonicTime::now();
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: finalize &quot;);
      }
  
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2106,11 ***</span>
          callback.run(vm());
  
      if (shouldSweepSynchronously())
          sweepSynchronously();
  
<span class="line-modified">!     if (Options::logGC()) {</span>
          MonotonicTime after = MonotonicTime::now();
          dataLog((after - before).milliseconds(), &quot;ms]\n&quot;);
      }
  }
  
<span class="line-new-header">--- 2098,11 ---</span>
          callback.run(vm());
  
      if (shouldSweepSynchronously())
          sweepSynchronously();
  
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          MonotonicTime after = MonotonicTime::now();
          dataLog((after - before).milliseconds(), &quot;ms]\n&quot;);
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2147,12 ***</span>
          });
  }
  
  void Heap::sweepInFinalize()
  {
<span class="line-modified">!     m_objectSpace.sweepLargeAllocations();</span>
<span class="line-modified">!     vm().eagerlySweptDestructibleObjectSpace.sweep();</span>
  }
  
  void Heap::suspendCompilerThreads()
  {
  #if ENABLE(DFG_JIT)
<span class="line-new-header">--- 2139,16 ---</span>
          });
  }
  
  void Heap::sweepInFinalize()
  {
<span class="line-modified">!     m_objectSpace.sweepPreciseAllocations();</span>
<span class="line-modified">! #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+     // We hold onto a lot of memory, so it makes a lot of sense to be swept eagerly.</span>
<span class="line-added">+     if (vm().m_webAssemblyMemorySpace)</span>
<span class="line-added">+         vm().m_webAssemblyMemorySpace-&gt;sweep();</span>
<span class="line-added">+ #endif</span>
  }
  
  void Heap::suspendCompilerThreads()
  {
  #if ENABLE(DFG_JIT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2166,26 ***</span>
  #endif
  }
  
  void Heap::willStartCollection()
  {
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;=&gt; &quot;);</span>
  
      if (shouldDoFullCollection()) {
          m_collectionScope = CollectionScope::Full;
          m_shouldDoFullCollection = false;
<span class="line-modified">!         if (Options::logGC())</span>
<span class="line-removed">-             dataLog(&quot;FullCollection, &quot;);</span>
<span class="line-removed">-         if (false)</span>
<span class="line-removed">-             dataLog(&quot;Full collection!\n&quot;);</span>
      } else {
          m_collectionScope = CollectionScope::Eden;
<span class="line-modified">!         if (Options::logGC())</span>
<span class="line-removed">-             dataLog(&quot;EdenCollection, &quot;);</span>
<span class="line-removed">-         if (false)</span>
<span class="line-removed">-             dataLog(&quot;Eden collection!\n&quot;);</span>
      }
      if (m_collectionScope &amp;&amp; m_collectionScope.value() == CollectionScope::Full) {
          m_sizeBeforeLastFullCollect = m_sizeAfterLastCollect + m_bytesAllocatedThisCycle;
          m_extraMemorySize = 0;
          m_deprecatedExtraMemorySize = 0;
<span class="line-new-header">--- 2162,19 ---</span>
  #endif
  }
  
  void Heap::willStartCollection()
  {
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;=&gt; &quot;);</span>
  
      if (shouldDoFullCollection()) {
          m_collectionScope = CollectionScope::Full;
          m_shouldDoFullCollection = false;
<span class="line-modified">!         dataLogIf(Options::logGC(), &quot;FullCollection, &quot;);</span>
      } else {
          m_collectionScope = CollectionScope::Eden;
<span class="line-modified">!         dataLogIf(Options::logGC(), &quot;EdenCollection, &quot;);</span>
      }
      if (m_collectionScope &amp;&amp; m_collectionScope.value() == CollectionScope::Full) {
          m_sizeBeforeLastFullCollect = m_sizeAfterLastCollect + m_bytesAllocatedThisCycle;
          m_extraMemorySize = 0;
          m_deprecatedExtraMemorySize = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,11 ***</span>
      m_sweeper-&gt;startSweeping(*this);
  }
  
  void Heap::updateAllocationLimits()
  {
<span class="line-modified">!     static const bool verbose = false;</span>
  
      if (verbose) {
          dataLog(&quot;\n&quot;);
          dataLog(&quot;bytesAllocatedThisCycle = &quot;, m_bytesAllocatedThisCycle, &quot;\n&quot;);
      }
<span class="line-new-header">--- 2241,11 ---</span>
      m_sweeper-&gt;startSweeping(*this);
  }
  
  void Heap::updateAllocationLimits()
  {
<span class="line-modified">!     static constexpr bool verbose = false;</span>
  
      if (verbose) {
          dataLog(&quot;\n&quot;);
          dataLog(&quot;bytesAllocatedThisCycle = &quot;, m_bytesAllocatedThisCycle, &quot;\n&quot;);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2278,11 ***</span>
          dataLog(&quot;totalBytesVisited = &quot;, m_totalBytesVisited, &quot;, currentHeapSize = &quot;, currentHeapSize, &quot;\n&quot;);
  
      // It&#39;s up to the user to ensure that extraMemorySize() ends up corresponding to allocation-time
      // extra memory reporting.
      currentHeapSize += extraMemorySize();
<span class="line-modified">!     if (!ASSERT_DISABLED) {</span>
          Checked&lt;size_t, RecordOverflow&gt; checkedCurrentHeapSize = m_totalBytesVisited;
          checkedCurrentHeapSize += extraMemorySize();
          ASSERT(!checkedCurrentHeapSize.hasOverflowed() &amp;&amp; checkedCurrentHeapSize.unsafeGet() == currentHeapSize);
      }
  
<span class="line-new-header">--- 2267,11 ---</span>
          dataLog(&quot;totalBytesVisited = &quot;, m_totalBytesVisited, &quot;, currentHeapSize = &quot;, currentHeapSize, &quot;\n&quot;);
  
      // It&#39;s up to the user to ensure that extraMemorySize() ends up corresponding to allocation-time
      // extra memory reporting.
      currentHeapSize += extraMemorySize();
<span class="line-modified">!     if (ASSERT_ENABLED) {</span>
          Checked&lt;size_t, RecordOverflow&gt; checkedCurrentHeapSize = m_totalBytesVisited;
          checkedCurrentHeapSize += extraMemorySize();
          ASSERT(!checkedCurrentHeapSize.hasOverflowed() &amp;&amp; checkedCurrentHeapSize.unsafeGet() == currentHeapSize);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2330,22 ***</span>
              ASSERT(currentHeapSize &gt;= m_sizeAfterLastFullCollect);
              m_fullActivityCallback-&gt;didAllocate(*this, currentHeapSize - m_sizeAfterLastFullCollect);
          }
      }
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
      // Get critical memory threshold for next cycle.
      overCriticalMemoryThreshold(MemoryThresholdCallType::Direct);
  #endif
  
      m_sizeAfterLastCollect = currentHeapSize;
      if (verbose)
          dataLog(&quot;sizeAfterLastCollect = &quot;, m_sizeAfterLastCollect, &quot;\n&quot;);
      m_bytesAllocatedThisCycle = 0;
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog(&quot;=&gt; &quot;, currentHeapSize / 1024, &quot;kb, &quot;);</span>
  }
  
  void Heap::didFinishCollection()
  {
      m_afterGC = MonotonicTime::now();
<span class="line-new-header">--- 2319,21 ---</span>
              ASSERT(currentHeapSize &gt;= m_sizeAfterLastFullCollect);
              m_fullActivityCallback-&gt;didAllocate(*this, currentHeapSize - m_sizeAfterLastFullCollect);
          }
      }
  
<span class="line-modified">! #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
      // Get critical memory threshold for next cycle.
      overCriticalMemoryThreshold(MemoryThresholdCallType::Direct);
  #endif
  
      m_sizeAfterLastCollect = currentHeapSize;
      if (verbose)
          dataLog(&quot;sizeAfterLastCollect = &quot;, m_sizeAfterLastCollect, &quot;\n&quot;);
      m_bytesAllocatedThisCycle = 0;
  
<span class="line-modified">!     dataLogIf(Options::logGC(), &quot;=&gt; &quot;, currentHeapSize / 1024, &quot;kb, &quot;);</span>
  }
  
  void Heap::didFinishCollection()
  {
      m_afterGC = MonotonicTime::now();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2425,19 ***</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! void Heap::addFinalizer(JSCell* cell, Finalizer finalizer)</span>
  {
<span class="line-modified">!     WeakSet::allocate(cell, &amp;m_finalizerOwner, reinterpret_cast&lt;void*&gt;(finalizer)); // Balanced by FinalizerOwner::finalize().</span>
  }
  
<span class="line-modified">! void Heap::FinalizerOwner::finalize(Handle&lt;Unknown&gt; handle, void* context)</span>
  {
      HandleSlot slot = handle.slot();
<span class="line-removed">-     Finalizer finalizer = reinterpret_cast&lt;Finalizer&gt;(context);</span>
      finalizer(slot-&gt;asCell());
      WeakSet::deallocate(WeakImpl::asWeakImpl(slot));
  }
  
  void Heap::collectNowFullIfNotDoneRecently(Synchronousness synchronousness)
<span class="line-new-header">--- 2413,33 ---</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! void Heap::addFinalizer(JSCell* cell, CFinalizer finalizer)</span>
  {
<span class="line-modified">!     WeakSet::allocate(cell, &amp;m_cFinalizerOwner, bitwise_cast&lt;void*&gt;(finalizer)); // Balanced by CFinalizerOwner::finalize().</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Heap::addFinalizer(JSCell* cell, LambdaFinalizer function)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     WeakSet::allocate(cell, &amp;m_lambdaFinalizerOwner, function.leakImpl()); // Balanced by LambdaFinalizerOwner::finalize().</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Heap::CFinalizerOwner::finalize(Handle&lt;Unknown&gt; handle, void* context)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     HandleSlot slot = handle.slot();</span>
<span class="line-added">+     CFinalizer finalizer = bitwise_cast&lt;CFinalizer&gt;(context);</span>
<span class="line-added">+     finalizer(slot-&gt;asCell());</span>
<span class="line-added">+     WeakSet::deallocate(WeakImpl::asWeakImpl(slot));</span>
  }
  
<span class="line-modified">! void Heap::LambdaFinalizerOwner::finalize(Handle&lt;Unknown&gt; handle, void* context)</span>
  {
<span class="line-added">+     LambdaFinalizer::Impl* impl = bitwise_cast&lt;LambdaFinalizer::Impl*&gt;(context);</span>
<span class="line-added">+     LambdaFinalizer finalizer(impl);</span>
      HandleSlot slot = handle.slot();
      finalizer(slot-&gt;asCell());
      WeakSet::deallocate(WeakImpl::asWeakImpl(slot));
  }
  
  void Heap::collectNowFullIfNotDoneRecently(Synchronousness synchronousness)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2627,11 ***</span>
          if (m_bytesAllocatedThisCycle &lt;= Options::gcMaxHeapSize())
              return;
      } else {
          size_t bytesAllowedThisCycle = m_maxEdenSize;
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
          if (overCriticalMemoryThreshold())
              bytesAllowedThisCycle = std::min(m_maxEdenSizeWhenCritical, bytesAllowedThisCycle);
  #endif
  
          if (m_bytesAllocatedThisCycle &lt;= bytesAllowedThisCycle)
<span class="line-new-header">--- 2629,11 ---</span>
          if (m_bytesAllocatedThisCycle &lt;= Options::gcMaxHeapSize())
              return;
      } else {
          size_t bytesAllowedThisCycle = m_maxEdenSize;
  
<span class="line-modified">! #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
          if (overCriticalMemoryThreshold())
              bytesAllowedThisCycle = std::min(m_maxEdenSizeWhenCritical, bytesAllowedThisCycle);
  #endif
  
          if (m_bytesAllocatedThisCycle &lt;= bytesAllowedThisCycle)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2768,12 ***</span>
          [this] (SlotVisitor&amp; slotVisitor) {
              SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::Debugger);
  
  #if ENABLE(SAMPLING_PROFILER)
              if (SamplingProfiler* samplingProfiler = m_vm.samplingProfiler()) {
<span class="line-modified">!                 LockHolder locker(samplingProfiler-&gt;getLock());</span>
<span class="line-modified">!                 samplingProfiler-&gt;processUnverifiedStackTraces();</span>
                  samplingProfiler-&gt;visit(slotVisitor);
                  if (Options::logGC() == GCLogging::Verbose)
                      dataLog(&quot;Sampling Profiler data:\n&quot;, slotVisitor);
              }
  #endif // ENABLE(SAMPLING_PROFILER)
<span class="line-new-header">--- 2770,12 ---</span>
          [this] (SlotVisitor&amp; slotVisitor) {
              SetRootMarkReasonScope rootScope(slotVisitor, SlotVisitor::RootMarkReason::Debugger);
  
  #if ENABLE(SAMPLING_PROFILER)
              if (SamplingProfiler* samplingProfiler = m_vm.samplingProfiler()) {
<span class="line-modified">!                 auto locker = holdLock(samplingProfiler-&gt;getLock());</span>
<span class="line-modified">!                 samplingProfiler-&gt;processUnverifiedStackTraces(locker);</span>
                  samplingProfiler-&gt;visit(slotVisitor);
                  if (Options::logGC() == GCLogging::Verbose)
                      dataLog(&quot;Sampling Profiler data:\n&quot;, slotVisitor);
              }
  #endif // ENABLE(SAMPLING_PROFILER)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2866,11 ***</span>
  }
  
  void Heap::notifyIsSafeToCollect()
  {
      MonotonicTime before;
<span class="line-modified">!     if (Options::logGC()) {</span>
          before = MonotonicTime::now();
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: starting &quot;);
      }
  
      addCoreConstraints();
<span class="line-new-header">--- 2868,11 ---</span>
  }
  
  void Heap::notifyIsSafeToCollect()
  {
      MonotonicTime before;
<span class="line-modified">!     if (UNLIKELY(Options::logGC())) {</span>
          before = MonotonicTime::now();
          dataLog(&quot;[GC&lt;&quot;, RawPointer(this), &quot;&gt;: starting &quot;);
      }
  
      addCoreConstraints();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2906,12 ***</span>
                      }
                  }
              });
      }
  
<span class="line-modified">!     if (Options::logGC())</span>
<span class="line-removed">-         dataLog((MonotonicTime::now() - before).milliseconds(), &quot;ms]\n&quot;);</span>
  }
  
  void Heap::preventCollection()
  {
      if (!m_isSafeToCollect)
<span class="line-new-header">--- 2908,11 ---</span>
                      }
                  }
              });
      }
  
<span class="line-modified">!     dataLogIf(Options::logGC(), (MonotonicTime::now() - before).milliseconds(), &quot;ms]\n&quot;);</span>
  }
  
  void Heap::preventCollection()
  {
      if (!m_isSafeToCollect)
</pre>
<center><a href="HandleSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
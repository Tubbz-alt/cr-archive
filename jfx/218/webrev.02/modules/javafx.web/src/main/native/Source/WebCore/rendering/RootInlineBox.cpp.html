<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public License
  15  * along with this library; see the file COPYING.LIB.  If not, write to
  16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;RootInlineBox.h&quot;
  22 
  23 #include &quot;BidiResolver.h&quot;
  24 #include &quot;Chrome.h&quot;
  25 #include &quot;ChromeClient.h&quot;
  26 #include &quot;Document.h&quot;
  27 #include &quot;EllipsisBox.h&quot;
  28 #include &quot;Frame.h&quot;
  29 #include &quot;GraphicsContext.h&quot;
  30 #include &quot;HitTestResult.h&quot;
  31 #include &quot;InlineTextBox.h&quot;
  32 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  33 #include &quot;PaintInfo.h&quot;
  34 #include &quot;RenderFragmentedFlow.h&quot;
  35 #include &quot;RenderInline.h&quot;
  36 #include &quot;RenderLayoutState.h&quot;
  37 #include &quot;RenderRubyBase.h&quot;
  38 #include &quot;RenderRubyRun.h&quot;
  39 #include &quot;RenderRubyText.h&quot;
  40 #include &quot;RenderView.h&quot;
  41 #include &quot;VerticalPositionCache.h&quot;
  42 #include &lt;wtf/IsoMallocInlines.h&gt;
  43 
  44 namespace WebCore {
  45 
  46 WTF_MAKE_ISO_ALLOCATED_IMPL(RootInlineBox);
  47 
  48 struct SameSizeAsRootInlineBox : public InlineFlowBox, public CanMakeWeakPtr&lt;RootInlineBox&gt; {
  49     unsigned variables[7];
  50     void* pointers[3];
  51 };
  52 
  53 COMPILE_ASSERT(sizeof(RootInlineBox) == sizeof(SameSizeAsRootInlineBox), RootInlineBox_should_stay_small);
  54 
  55 typedef WTF::HashMap&lt;const RootInlineBox*, std::unique_ptr&lt;EllipsisBox&gt;&gt; EllipsisBoxMap;
  56 static EllipsisBoxMap* gEllipsisBoxMap;
  57 
  58 static ContainingFragmentMap&amp; containingFragmentMap(RenderBlockFlow&amp; block)
  59 {
  60     ASSERT(block.enclosingFragmentedFlow());
  61     return block.enclosingFragmentedFlow()-&gt;containingFragmentMap();
  62 }
  63 
  64 RootInlineBox::RootInlineBox(RenderBlockFlow&amp; block)
  65     : InlineFlowBox(block)
  66 {
  67     setIsHorizontal(block.isHorizontalWritingMode());
  68 }
  69 
  70 RootInlineBox::~RootInlineBox()
  71 {
  72     detachEllipsisBox();
  73 
  74     if (blockFlow().enclosingFragmentedFlow())
  75         containingFragmentMap(blockFlow()).remove(this);
  76 }
  77 
  78 void RootInlineBox::detachEllipsisBox()
  79 {
  80     if (hasEllipsisBox()) {
  81         auto box = gEllipsisBoxMap-&gt;take(this);
  82         box-&gt;setParent(nullptr);
  83         setHasEllipsisBox(false);
  84     }
  85 }
  86 
  87 void RootInlineBox::clearTruncation()
  88 {
  89     if (hasEllipsisBox()) {
  90         detachEllipsisBox();
  91         InlineFlowBox::clearTruncation();
  92     }
  93 }
  94 
  95 bool RootInlineBox::isHyphenated() const
  96 {
  97     for (InlineBox* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {
  98         if (is&lt;InlineTextBox&gt;(*box) &amp;&amp; downcast&lt;InlineTextBox&gt;(*box).hasHyphen())
  99             return true;
 100     }
 101     return false;
 102 }
 103 
 104 int RootInlineBox::baselinePosition(FontBaseline baselineType) const
 105 {
 106     return renderer().baselinePosition(baselineType, isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
 107 }
 108 
 109 LayoutUnit RootInlineBox::lineHeight() const
 110 {
 111     return renderer().lineHeight(isFirstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes);
 112 }
 113 
 114 bool RootInlineBox::lineCanAccommodateEllipsis(bool ltr, int blockEdge, int lineBoxEdge, int ellipsisWidth)
 115 {
 116     // First sanity-check the unoverflowed width of the whole line to see if there is sufficient room.
 117     int delta = ltr ? lineBoxEdge - blockEdge : blockEdge - lineBoxEdge;
 118     if (logicalWidth() - delta &lt; ellipsisWidth)
 119         return false;
 120 
 121     // Next iterate over all the line boxes on the line.  If we find a replaced element that intersects
 122     // then we refuse to accommodate the ellipsis.  Otherwise we&#39;re ok.
 123     return InlineFlowBox::canAccommodateEllipsis(ltr, blockEdge, ellipsisWidth);
 124 }
 125 
 126 float RootInlineBox::placeEllipsis(const AtomString&amp; ellipsisStr,  bool ltr, float blockLeftEdge, float blockRightEdge, float ellipsisWidth, InlineBox* markupBox)
 127 {
 128     if (!gEllipsisBoxMap)
 129         gEllipsisBoxMap = new EllipsisBoxMap();
 130 
 131     ASSERT(!hasEllipsisBox());
 132     auto* ellipsisBox = gEllipsisBoxMap-&gt;set(this, makeUnique&lt;EllipsisBox&gt;(blockFlow(), ellipsisStr, this, ellipsisWidth - (markupBox ? markupBox-&gt;logicalWidth() : 0), logicalHeight(), y(), !prevRootBox(), isHorizontal(), markupBox)).iterator-&gt;value.get();
 133     setHasEllipsisBox(true);
 134     // FIXME: Do we need an RTL version of this?
 135     if (ltr &amp;&amp; (x() + logicalWidth() + ellipsisWidth) &lt;= blockRightEdge) {
 136         ellipsisBox-&gt;setX(x() + logicalWidth());
 137         return logicalWidth() + ellipsisWidth;
 138     }
 139 
 140     // Now attempt to find the nearest glyph horizontally and place just to the right (or left in RTL)
 141     // of that glyph. Mark all of the objects that intersect the ellipsis box as not painting (as being
 142     // truncated).
 143     bool foundBox = false;
 144     float truncatedWidth = 0;
 145     float position = placeEllipsisBox(ltr, blockLeftEdge, blockRightEdge, ellipsisWidth, truncatedWidth, foundBox);
 146     ellipsisBox-&gt;setX(position);
 147     return truncatedWidth;
 148 }
 149 
 150 float RootInlineBox::placeEllipsisBox(bool ltr, float blockLeftEdge, float blockRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox)
 151 {
 152     float result = InlineFlowBox::placeEllipsisBox(ltr, blockLeftEdge, blockRightEdge, ellipsisWidth, truncatedWidth, foundBox);
 153     if (result == -1) {
 154         result = ltr ? blockRightEdge - ellipsisWidth : blockLeftEdge;
 155         truncatedWidth = blockRightEdge - blockLeftEdge;
 156     }
 157     return result;
 158 }
 159 
 160 void RootInlineBox::paintEllipsisBox(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, LayoutUnit lineTop, LayoutUnit lineBottom) const
 161 {
 162     if (hasEllipsisBox() &amp;&amp; paintInfo.shouldPaintWithinRoot(renderer()) &amp;&amp; renderer().style().visibility() == Visibility::Visible &amp;&amp; paintInfo.phase == PaintPhase::Foreground)
 163         ellipsisBox()-&gt;paint(paintInfo, paintOffset, lineTop, lineBottom);
 164 }
 165 
 166 void RootInlineBox::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, LayoutUnit lineTop, LayoutUnit lineBottom)
 167 {
 168     InlineFlowBox::paint(paintInfo, paintOffset, lineTop, lineBottom);
 169     paintEllipsisBox(paintInfo, paintOffset, lineTop, lineBottom);
 170 }
 171 
 172 bool RootInlineBox::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction hitTestAction)
 173 {
 174     if (hasEllipsisBox() &amp;&amp; visibleToHitTesting()) {
 175         if (ellipsisBox()-&gt;nodeAtPoint(request, result, locationInContainer, accumulatedOffset, lineTop, lineBottom, hitTestAction)) {
 176             renderer().updateHitTestResult(result, locationInContainer.point() - toLayoutSize(accumulatedOffset));
 177             return true;
 178         }
 179     }
 180     return InlineFlowBox::nodeAtPoint(request, result, locationInContainer, accumulatedOffset, lineTop, lineBottom, hitTestAction);
 181 }
 182 
 183 void RootInlineBox::adjustPosition(float dx, float dy)
 184 {
 185     InlineFlowBox::adjustPosition(dx, dy);
 186     LayoutUnit blockDirectionDelta { isHorizontal() ? dy : dx }; // The block direction delta is a LayoutUnit.
 187     m_lineTop += blockDirectionDelta;
 188     m_lineBottom += blockDirectionDelta;
 189     m_lineTopWithLeading += blockDirectionDelta;
 190     m_lineBottomWithLeading += blockDirectionDelta;
 191     if (hasEllipsisBox())
 192         ellipsisBox()-&gt;adjustPosition(dx, dy);
 193 }
 194 
 195 void RootInlineBox::childRemoved(InlineBox* box)
 196 {
 197     if (&amp;box-&gt;renderer() == m_lineBreakObj)
 198         setLineBreakInfo(nullptr, 0, BidiStatus());
 199 
 200     for (RootInlineBox* prev = prevRootBox(); prev &amp;&amp; prev-&gt;lineBreakObj() == &amp;box-&gt;renderer(); prev = prev-&gt;prevRootBox()) {
 201         prev-&gt;setLineBreakInfo(nullptr, 0, BidiStatus());
 202         prev-&gt;markDirty();
 203     }
 204 }
 205 
 206 RenderFragmentContainer* RootInlineBox::containingFragment() const
 207 {
 208     ContainingFragmentMap&amp; fragmentMap = containingFragmentMap(blockFlow());
 209     bool hasContainingFragment = fragmentMap.contains(this);
 210     RenderFragmentContainer* fragment = hasContainingFragment ? fragmentMap.get(this) : nullptr;
 211 
 212 #ifndef NDEBUG
 213     if (hasContainingFragment) {
 214         RenderFragmentedFlow* fragmentedFlow = blockFlow().enclosingFragmentedFlow();
 215         const RenderFragmentContainerList&amp; fragmentList = fragmentedFlow-&gt;renderFragmentContainerList();
 216         ASSERT_WITH_SECURITY_IMPLICATION(fragmentList.contains(fragment));
 217     }
 218 #endif
 219 
 220     return fragment;
 221 }
 222 
 223 void RootInlineBox::clearContainingFragment()
 224 {
 225     ASSERT(!isDirty());
 226 
 227     if (!containingFragmentMap(blockFlow()).contains(this))
 228         return;
 229 
 230     containingFragmentMap(blockFlow()).remove(this);
 231 }
 232 
 233 void RootInlineBox::setContainingFragment(RenderFragmentContainer&amp; fragment)
 234 {
 235     ASSERT(!isDirty());
 236 
 237     containingFragmentMap(blockFlow()).set(this, &amp;fragment);
 238 }
 239 
 240 LayoutUnit RootInlineBox::alignBoxesInBlockDirection(LayoutUnit heightOfBlock, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, VerticalPositionCache&amp; verticalPositionCache)
 241 {
 242     // SVG will handle vertical alignment on its own.
 243     if (isSVGRootInlineBox())
 244         return 0;
 245 
 246     LayoutUnit maxPositionTop;
 247     LayoutUnit maxPositionBottom;
 248     int maxAscent = 0;
 249     int maxDescent = 0;
 250     bool setMaxAscent = false;
 251     bool setMaxDescent = false;
 252 
 253     // Figure out if we&#39;re in no-quirks mode.
 254     bool noQuirksMode = renderer().document().inNoQuirksMode();
 255 
 256     m_baselineType = requiresIdeographicBaseline(textBoxDataMap) ? IdeographicBaseline : AlphabeticBaseline;
 257 
 258     computeLogicalBoxHeights(*this, maxPositionTop, maxPositionBottom, maxAscent, maxDescent, setMaxAscent, setMaxDescent, noQuirksMode,
 259                              textBoxDataMap, baselineType(), verticalPositionCache);
 260 
 261     if (maxAscent + maxDescent &lt; std::max(maxPositionTop, maxPositionBottom))
 262         adjustMaxAscentAndDescent(maxAscent, maxDescent, maxPositionTop, maxPositionBottom);
 263 
 264     LayoutUnit maxHeight = maxAscent + maxDescent;
 265     LayoutUnit lineTop = heightOfBlock;
 266     LayoutUnit lineBottom = heightOfBlock;
 267     LayoutUnit lineTopIncludingMargins = heightOfBlock;
 268     LayoutUnit lineBottomIncludingMargins = heightOfBlock;
 269     bool setLineTop = false;
 270     bool hasAnnotationsBefore = false;
 271     bool hasAnnotationsAfter = false;
 272     placeBoxesInBlockDirection(heightOfBlock, maxHeight, maxAscent, noQuirksMode, lineTop, lineBottom, setLineTop,
 273                                lineTopIncludingMargins, lineBottomIncludingMargins, hasAnnotationsBefore, hasAnnotationsAfter, baselineType());
 274     m_hasAnnotationsBefore = hasAnnotationsBefore;
 275     m_hasAnnotationsAfter = hasAnnotationsAfter;
 276 
 277     maxHeight = std::max&lt;LayoutUnit&gt;(0, maxHeight); // FIXME: Is this really necessary?
 278 
 279     LayoutUnit lineTopWithLeading = heightOfBlock;
 280     LayoutUnit lineBottomWithLeading = heightOfBlock + maxHeight;
 281     setLineTopBottomPositions(lineTop, lineBottom, lineTopWithLeading, lineBottomWithLeading);
 282     setPaginatedLineWidth(blockFlow().availableLogicalWidthForContent(heightOfBlock));
 283 
 284     LayoutUnit annotationsAdjustment = beforeAnnotationsAdjustment();
 285     if (annotationsAdjustment) {
 286         // FIXME: Need to handle pagination here. We might have to move to the next page/column as a result of the
 287         // ruby expansion.
 288         adjustBlockDirectionPosition(annotationsAdjustment);
 289         heightOfBlock += annotationsAdjustment;
 290     }
 291 
 292     LayoutUnit gridSnapAdjustment = lineSnapAdjustment();
 293     if (gridSnapAdjustment) {
 294         adjustBlockDirectionPosition(gridSnapAdjustment);
 295         heightOfBlock += gridSnapAdjustment;
 296     }
 297 
 298     return heightOfBlock + maxHeight;
 299 }
 300 
 301 LayoutUnit RootInlineBox::beforeAnnotationsAdjustment() const
 302 {
 303     LayoutUnit result;
 304 
 305     if (!renderer().style().isFlippedLinesWritingMode()) {
 306         // Annotations under the previous line may push us down.
 307         if (prevRootBox() &amp;&amp; prevRootBox()-&gt;hasAnnotationsAfter())
 308             result = prevRootBox()-&gt;computeUnderAnnotationAdjustment(lineTop());
 309 
 310         if (!hasAnnotationsBefore())
 311             return result;
 312 
 313         // Annotations over this line may push us further down.
 314         LayoutUnit highestAllowedPosition = prevRootBox() ? std::min(prevRootBox()-&gt;lineBottom(), lineTop()) + result : blockFlow().borderBefore();
 315         result = computeOverAnnotationAdjustment(highestAllowedPosition);
 316     } else {
 317         // Annotations under this line may push us up.
 318         if (hasAnnotationsBefore())
 319             result = computeUnderAnnotationAdjustment(prevRootBox() ? prevRootBox()-&gt;lineBottom() : blockFlow().borderBefore());
 320 
 321         if (!prevRootBox() || !prevRootBox()-&gt;hasAnnotationsAfter())
 322             return result;
 323 
 324         // We have to compute the expansion for annotations over the previous line to see how much we should move.
 325         LayoutUnit lowestAllowedPosition = std::max(prevRootBox()-&gt;lineBottom(), lineTop()) - result;
 326         result = prevRootBox()-&gt;computeOverAnnotationAdjustment(lowestAllowedPosition);
 327     }
 328 
 329     return result;
 330 }
 331 
 332 LayoutUnit RootInlineBox::lineSnapAdjustment(LayoutUnit delta) const
 333 {
 334     // If our block doesn&#39;t have snapping turned on, do nothing.
 335     // FIXME: Implement bounds snapping.
 336     if (blockFlow().style().lineSnap() == LineSnap::None)
 337         return 0;
 338 
 339     // Get the current line grid and offset.
 340     auto* layoutState = blockFlow().view().frameView().layoutContext().layoutState();
 341     RenderBlockFlow* lineGrid = layoutState-&gt;lineGrid();
 342     LayoutSize lineGridOffset = layoutState-&gt;lineGridOffset();
 343     if (!lineGrid || lineGrid-&gt;style().writingMode() != blockFlow().style().writingMode())
 344         return 0;
 345 
 346     // Get the hypothetical line box used to establish the grid.
 347     RootInlineBox* lineGridBox = lineGrid-&gt;lineGridBox();
 348     if (!lineGridBox)
 349         return 0;
 350 
 351     LayoutUnit lineGridBlockOffset = lineGrid-&gt;isHorizontalWritingMode() ? lineGridOffset.height() : lineGridOffset.width();
 352     LayoutUnit blockOffset = blockFlow().isHorizontalWritingMode() ? layoutState-&gt;layoutOffset().height() : layoutState-&gt;layoutOffset().width();
 353 
 354     // Now determine our position on the grid. Our baseline needs to be adjusted to the nearest baseline multiple
 355     // as established by the line box.
 356     // FIXME: Need to handle crazy line-box-contain values that cause the root line box to not be considered. I assume
 357     // the grid should honor line-box-contain.
 358     LayoutUnit gridLineHeight = lineGridBox-&gt;lineBottomWithLeading() - lineGridBox-&gt;lineTopWithLeading();
 359     if (!gridLineHeight)
 360         return 0;
 361 
 362     LayoutUnit lineGridFontAscent = lineGrid-&gt;style().fontMetrics().ascent(baselineType());
 363     LayoutUnit lineGridFontHeight { lineGridBox-&gt;logicalHeight() };
 364     LayoutUnit firstTextTop { lineGridBlockOffset + lineGridBox-&gt;logicalTop() };
 365     LayoutUnit firstLineTopWithLeading = lineGridBlockOffset + lineGridBox-&gt;lineTopWithLeading();
 366     LayoutUnit firstBaselinePosition = firstTextTop + lineGridFontAscent;
 367 
 368     LayoutUnit currentTextTop { blockOffset + logicalTop() + delta };
 369     LayoutUnit currentFontAscent = blockFlow().style().fontMetrics().ascent(baselineType());
 370     LayoutUnit currentBaselinePosition = currentTextTop + currentFontAscent;
 371 
 372     LayoutUnit lineGridPaginationOrigin = isHorizontal() ? layoutState-&gt;lineGridPaginationOrigin().height() : layoutState-&gt;lineGridPaginationOrigin().width();
 373 
 374     // If we&#39;re paginated, see if we&#39;re on a page after the first one. If so, the grid resets on subsequent pages.
 375     // FIXME: If the grid is an ancestor of the pagination establisher, then this is incorrect.
 376     LayoutUnit pageLogicalTop;
 377     if (layoutState-&gt;isPaginated() &amp;&amp; layoutState-&gt;pageLogicalHeight()) {
 378         pageLogicalTop = blockFlow().pageLogicalTopForOffset(lineTopWithLeading() + delta);
 379         if (pageLogicalTop &gt; firstLineTopWithLeading)
 380             firstTextTop = pageLogicalTop + lineGridBox-&gt;logicalTop() - lineGrid-&gt;borderAndPaddingBefore() + lineGridPaginationOrigin;
 381     }
 382 
 383     if (blockFlow().style().lineSnap() == LineSnap::Contain) {
 384         // Compute the desired offset from the text-top of a grid line.
 385         // Look at our height (logicalHeight()).
 386         // Look at the total available height. It&#39;s going to be (textBottom - textTop) + (n-1)*(multiple with leading)
 387         // where n is number of grid lines required to enclose us.
 388         if (logicalHeight() &lt;= lineGridFontHeight)
 389             firstTextTop += (lineGridFontHeight - logicalHeight()) / 2;
 390         else {
 391             LayoutUnit numberOfLinesWithLeading { ceilf(static_cast&lt;float&gt;(logicalHeight() - lineGridFontHeight) / gridLineHeight) };
 392             LayoutUnit totalHeight = lineGridFontHeight + numberOfLinesWithLeading * gridLineHeight;
 393             firstTextTop += (totalHeight - logicalHeight()) / 2;
 394         }
 395         firstBaselinePosition = firstTextTop + currentFontAscent;
 396     } else
 397         firstBaselinePosition = firstTextTop + lineGridFontAscent;
 398 
 399     // If we&#39;re above the first line, just push to the first line.
 400     if (currentBaselinePosition &lt; firstBaselinePosition)
 401         return delta + firstBaselinePosition - currentBaselinePosition;
 402 
 403     // Otherwise we&#39;re in the middle of the grid somewhere. Just push to the next line.
 404     LayoutUnit baselineOffset = currentBaselinePosition - firstBaselinePosition;
 405     LayoutUnit remainder = roundToInt(baselineOffset) % roundToInt(gridLineHeight);
 406     LayoutUnit result = delta;
 407     if (remainder)
 408         result += gridLineHeight - remainder;
 409 
 410     // If we aren&#39;t paginated we can return the result.
 411     if (!layoutState-&gt;isPaginated() || !layoutState-&gt;pageLogicalHeight() || result == delta)
 412         return result;
 413 
 414     // We may end up shifted to a new page. We need to do a re-snap when that happens.
 415     LayoutUnit newPageLogicalTop = blockFlow().pageLogicalTopForOffset(lineBottomWithLeading() + result);
 416     if (newPageLogicalTop == pageLogicalTop)
 417         return result;
 418 
 419     // Put ourselves at the top of the next page to force a snap onto the new grid established by that page.
 420     return lineSnapAdjustment(newPageLogicalTop - (blockOffset + lineTopWithLeading()));
 421 }
 422 
 423 GapRects RootInlineBox::lineSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
 424     LayoutUnit selTop, LayoutUnit selHeight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
 425 {
 426     RenderObject::SelectionState lineState = selectionState();
 427 
 428     bool leftGap, rightGap;
 429     blockFlow().getSelectionGapInfo(lineState, leftGap, rightGap);
 430 
 431     GapRects result;
 432 
 433     InlineBox* firstBox = firstSelectedBox();
 434     InlineBox* lastBox = lastSelectedBox();
 435     if (leftGap) {
 436         result.uniteLeft(blockFlow().logicalLeftSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, &amp;firstBox-&gt;parent()-&gt;renderer(), LayoutUnit(firstBox-&gt;logicalLeft()),
 437             selTop, selHeight, cache, paintInfo));
 438     }
 439     if (rightGap) {
 440         result.uniteRight(blockFlow().logicalRightSelectionGap(rootBlock, rootBlockPhysicalPosition, offsetFromRootBlock, &amp;lastBox-&gt;parent()-&gt;renderer(), LayoutUnit(lastBox-&gt;logicalRight()),
 441             selTop, selHeight, cache, paintInfo));
 442     }
 443 
 444     // When dealing with bidi text, a non-contiguous selection region is possible.
 445     // e.g. The logical text aaaAAAbbb (capitals denote RTL text and non-capitals LTR) is layed out
 446     // visually as 3 text runs |aaa|bbb|AAA| if we select 4 characters from the start of the text the
 447     // selection will look like (underline denotes selection):
 448     // |aaa|bbb|AAA|
 449     //  ___       _
 450     // We can see that the |bbb| run is not part of the selection while the runs around it are.
 451     if (firstBox &amp;&amp; firstBox != lastBox) {
 452         // Now fill in any gaps on the line that occurred between two selected elements.
 453         LayoutUnit lastLogicalLeft { firstBox-&gt;logicalRight() };
 454         bool isPreviousBoxSelected = firstBox-&gt;selectionState() != RenderObject::SelectionNone;
 455         for (InlineBox* box = firstBox-&gt;nextLeafOnLine(); box; box = box-&gt;nextLeafOnLine()) {
 456             if (box-&gt;selectionState() != RenderObject::SelectionNone) {
 457                 LayoutRect logicalRect { lastLogicalLeft, selTop, LayoutUnit(box-&gt;logicalLeft() - lastLogicalLeft), selHeight };
 458                 logicalRect.move(renderer().isHorizontalWritingMode() ? offsetFromRootBlock : LayoutSize(offsetFromRootBlock.height(), offsetFromRootBlock.width()));
 459                 LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
 460                 if (isPreviousBoxSelected &amp;&amp; gapRect.width() &gt; 0 &amp;&amp; gapRect.height() &gt; 0) {
 461                     if (paintInfo &amp;&amp; box-&gt;parent()-&gt;renderer().style().visibility() == Visibility::Visible)
 462                         paintInfo-&gt;context().fillRect(gapRect, box-&gt;parent()-&gt;renderer().selectionBackgroundColor());
 463                     // VisibleSelection may be non-contiguous, see comment above.
 464                     result.uniteCenter(gapRect);
 465                 }
 466                 lastLogicalLeft = box-&gt;logicalRight();
 467             }
 468             if (box == lastBox)
 469                 break;
 470             isPreviousBoxSelected = box-&gt;selectionState() != RenderObject::SelectionNone;
 471         }
 472     }
 473 
 474     return result;
 475 }
 476 
 477 IntRect RootInlineBox::computeCaretRect(float logicalLeftPosition, unsigned caretWidth, LayoutUnit* extraWidthToEndOfLine) const
 478 {
 479     int height = selectionHeight();
 480     int top = selectionTop();
 481 
 482     // Distribute the caret&#39;s width to either side of the offset.
 483     float left = logicalLeftPosition;
 484     int caretWidthLeftOfOffset = caretWidth / 2;
 485     left -= caretWidthLeftOfOffset;
 486     int caretWidthRightOfOffset = caretWidth - caretWidthLeftOfOffset;
 487     left = roundf(left);
 488 
 489     float rootLeft = logicalLeft();
 490     float rootRight = logicalRight();
 491 
 492     if (extraWidthToEndOfLine)
 493         *extraWidthToEndOfLine = (logicalWidth() + rootLeft) - (left + caretWidth);
 494 
 495     const RenderStyle&amp; blockStyle = blockFlow().style();
 496 
 497     bool rightAligned = false;
 498     switch (blockStyle.textAlign()) {
 499     case TextAlignMode::Right:
 500     case TextAlignMode::WebKitRight:
 501         rightAligned = true;
 502         break;
 503     case TextAlignMode::Left:
 504     case TextAlignMode::WebKitLeft:
 505     case TextAlignMode::Center:
 506     case TextAlignMode::WebKitCenter:
 507         break;
 508     case TextAlignMode::Justify:
 509     case TextAlignMode::Start:
 510         rightAligned = !blockStyle.isLeftToRightDirection();
 511         break;
 512     case TextAlignMode::End:
 513         rightAligned = blockStyle.isLeftToRightDirection();
 514         break;
 515     }
 516 
 517     float leftEdge = std::min&lt;float&gt;(0, rootLeft);
 518     float rightEdge = std::max&lt;float&gt;(blockFlow().logicalWidth(), rootRight);
 519 
 520     if (rightAligned) {
 521         left = std::max(left, leftEdge);
 522         left = std::min(left, rootRight - caretWidth);
 523     } else {
 524         left = std::min(left, rightEdge - caretWidthRightOfOffset);
 525         left = std::max(left, rootLeft);
 526     }
 527     return blockStyle.isHorizontalWritingMode() ? IntRect(left, top, caretWidth, height) : IntRect(top, left, height, caretWidth);
 528 }
 529 
 530 RenderObject::SelectionState RootInlineBox::selectionState()
 531 {
 532     // Walk over all of the selected boxes.
 533     RenderObject::SelectionState state = RenderObject::SelectionNone;
 534     for (InlineBox* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {
 535         RenderObject::SelectionState boxState = box-&gt;selectionState();
 536         if ((boxState == RenderObject::SelectionStart &amp;&amp; state == RenderObject::SelectionEnd) ||
 537             (boxState == RenderObject::SelectionEnd &amp;&amp; state == RenderObject::SelectionStart))
 538             state = RenderObject::SelectionBoth;
 539         else if (state == RenderObject::SelectionNone ||
 540                  ((boxState == RenderObject::SelectionStart || boxState == RenderObject::SelectionEnd) &amp;&amp;
 541                   (state == RenderObject::SelectionNone || state == RenderObject::SelectionInside)))
 542             state = boxState;
 543         else if (boxState == RenderObject::SelectionNone &amp;&amp; state == RenderObject::SelectionStart) {
 544             // We are past the end of the selection.
 545             state = RenderObject::SelectionBoth;
 546         }
 547         if (state == RenderObject::SelectionBoth)
 548             break;
 549     }
 550 
 551     return state;
 552 }
 553 
 554 InlineBox* RootInlineBox::firstSelectedBox()
 555 {
 556     for (auto* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {
 557         if (box-&gt;selectionState() != RenderObject::SelectionNone)
 558             return box;
 559     }
 560     return nullptr;
 561 }
 562 
 563 InlineBox* RootInlineBox::lastSelectedBox()
 564 {
 565     for (auto* box = lastLeafDescendant(); box; box = box-&gt;previousLeafOnLine()) {
 566         if (box-&gt;selectionState() != RenderObject::SelectionNone)
 567             return box;
 568     }
 569     return nullptr;
 570 }
 571 
 572 LayoutUnit RootInlineBox::selectionTop() const
 573 {
 574     LayoutUnit selectionTop = m_lineTop;
 575 
 576     if (m_hasAnnotationsBefore)
 577         selectionTop -= !renderer().style().isFlippedLinesWritingMode() ? computeOverAnnotationAdjustment(m_lineTop) : computeUnderAnnotationAdjustment(m_lineTop);
 578 
 579     if (renderer().style().isFlippedLinesWritingMode())
 580         return selectionTop;
 581 
 582 #if !PLATFORM(IOS_FAMILY)
 583     // See rdar://problem/19692206 ... don&#39;t want to do this adjustment for iOS where overlap is ok and handled.
 584     if (renderer().isRubyBase()) {
 585         // The ruby base selection should avoid intruding into the ruby text. This is only the case if there is an actual ruby text above us.
 586         RenderRubyBase* base = &amp;downcast&lt;RenderRubyBase&gt;(renderer());
 587         RenderRubyRun* run = base-&gt;rubyRun();
 588         if (run) {
 589             RenderRubyText* text = run-&gt;rubyText();
 590             if (text &amp;&amp; text-&gt;logicalTop() &lt; base-&gt;logicalTop()) {
 591                 // The ruby text is above the ruby base. Just return now in order to avoid painting on top of the ruby text.
 592                 return selectionTop;
 593             }
 594         }
 595     } else if (renderer().isRubyText()) {
 596         // The ruby text selection should go all the way to the selection top of the containing line.
 597         RenderRubyText* text = &amp;downcast&lt;RenderRubyText&gt;(renderer());
 598         RenderRubyRun* run = text-&gt;rubyRun();
 599         if (run &amp;&amp; run-&gt;inlineBoxWrapper()) {
 600             RenderRubyBase* base = run-&gt;rubyBase();
 601             if (base &amp;&amp; text-&gt;logicalTop() &lt; base-&gt;logicalTop()) {
 602                 // The ruby text is above the ruby base.
 603                 const RootInlineBox&amp; containingLine = run-&gt;inlineBoxWrapper()-&gt;root();
 604                 LayoutUnit enclosingSelectionTop = containingLine.selectionTop();
 605                 LayoutUnit deltaBetweenObjects = text-&gt;logicalTop() + run-&gt;logicalTop();
 606                 LayoutUnit selectionTopInRubyTextCoords = enclosingSelectionTop - deltaBetweenObjects;
 607                 return std::min(selectionTop, selectionTopInRubyTextCoords);
 608             }
 609         }
 610     }
 611 #endif
 612 
 613     LayoutUnit prevBottom = prevRootBox() ? prevRootBox()-&gt;selectionBottom() : blockFlow().borderAndPaddingBefore();
 614     if (prevBottom &lt; selectionTop &amp;&amp; blockFlow().containsFloats()) {
 615         // This line has actually been moved further down, probably from a large line-height, but possibly because the
 616         // line was forced to clear floats.  If so, let&#39;s check the offsets, and only be willing to use the previous
 617         // line&#39;s bottom if the offsets are greater on both sides.
 618         LayoutUnit prevLeft = blockFlow().logicalLeftOffsetForLine(prevBottom, DoNotIndentText);
 619         LayoutUnit prevRight = blockFlow().logicalRightOffsetForLine(prevBottom, DoNotIndentText);
 620         LayoutUnit newLeft = blockFlow().logicalLeftOffsetForLine(selectionTop, DoNotIndentText);
 621         LayoutUnit newRight = blockFlow().logicalRightOffsetForLine(selectionTop, DoNotIndentText);
 622         if (prevLeft &gt; newLeft || prevRight &lt; newRight)
 623             return selectionTop;
 624     }
 625 
 626     return prevBottom;
 627 }
 628 
 629 static RenderBlock* blockBeforeWithinSelectionRoot(const RenderBlockFlow&amp; blockFlow, LayoutSize&amp; offset)
 630 {
 631     if (blockFlow.isSelectionRoot())
 632         return nullptr;
 633 
 634     const RenderElement* object = &amp;blockFlow;
 635     RenderObject* sibling;
 636     do {
 637         sibling = object-&gt;previousSibling();
 638         while (sibling &amp;&amp; (!is&lt;RenderBlock&gt;(*sibling) || downcast&lt;RenderBlock&gt;(*sibling).isSelectionRoot()))
 639             sibling = sibling-&gt;previousSibling();
 640 
 641         offset -= LayoutSize(downcast&lt;RenderBlock&gt;(*object).logicalLeft(), downcast&lt;RenderBlock&gt;(*object).logicalTop());
 642         object = object-&gt;parent();
 643     } while (!sibling &amp;&amp; is&lt;RenderBlock&gt;(object) &amp;&amp; !downcast&lt;RenderBlock&gt;(*object).isSelectionRoot());
 644 
 645     if (!sibling)
 646         return nullptr;
 647 
 648     RenderBlock* beforeBlock = downcast&lt;RenderBlock&gt;(sibling);
 649 
 650     offset += LayoutSize(beforeBlock-&gt;logicalLeft(), beforeBlock-&gt;logicalTop());
 651 
 652     RenderObject* child = beforeBlock-&gt;lastChild();
 653     while (is&lt;RenderBlock&gt;(child)) {
 654         beforeBlock = downcast&lt;RenderBlock&gt;(child);
 655         offset += LayoutSize(beforeBlock-&gt;logicalLeft(), beforeBlock-&gt;logicalTop());
 656         child = beforeBlock-&gt;lastChild();
 657     }
 658     return beforeBlock;
 659 }
 660 
 661 LayoutUnit RootInlineBox::selectionTopAdjustedForPrecedingBlock() const
 662 {
 663     const RootInlineBox&amp; rootBox = root();
 664     LayoutUnit top = selectionTop();
 665 
 666     auto blockSelectionState = rootBox.blockFlow().selectionState();
 667     if (blockSelectionState != RenderObject::SelectionInside &amp;&amp; blockSelectionState != RenderObject::SelectionEnd)
 668         return top;
 669 
 670     LayoutSize offsetToBlockBefore;
 671     auto* blockBefore = blockBeforeWithinSelectionRoot(rootBox.blockFlow(), offsetToBlockBefore);
 672     if (!is&lt;RenderBlockFlow&gt;(blockBefore))
 673         return top;
 674 
 675     // Do not adjust blocks sharing the same line.
 676     if (!offsetToBlockBefore.height())
 677         return top;
 678 
 679     if (auto* lastLine = downcast&lt;RenderBlockFlow&gt;(*blockBefore).lastRootBox()) {
 680         RenderObject::SelectionState lastLineSelectionState = lastLine-&gt;selectionState();
 681         if (lastLineSelectionState != RenderObject::SelectionInside &amp;&amp; lastLineSelectionState != RenderObject::SelectionStart)
 682             return top;
 683 
 684         LayoutUnit lastLineSelectionBottom = lastLine-&gt;selectionBottom() + offsetToBlockBefore.height();
 685         top = std::max(top, lastLineSelectionBottom);
 686     }
 687     return top;
 688 }
 689 
 690 LayoutUnit RootInlineBox::selectionBottom() const
 691 {
 692     LayoutUnit selectionBottom = m_lineBottom;
 693 
 694     if (m_hasAnnotationsAfter)
 695         selectionBottom += !renderer().style().isFlippedLinesWritingMode() ? computeUnderAnnotationAdjustment(m_lineBottom) : computeOverAnnotationAdjustment(m_lineBottom);
 696 
 697     if (!renderer().style().isFlippedLinesWritingMode() || !nextRootBox())
 698         return selectionBottom;
 699 
 700 #if !PLATFORM(IOS_FAMILY)
 701     // See rdar://problem/19692206 ... don&#39;t want to do this adjustment for iOS where overlap is ok and handled.
 702     if (renderer().isRubyBase()) {
 703         // The ruby base selection should avoid intruding into the ruby text. This is only the case if there is an actual ruby text below us.
 704         RenderRubyBase* base = &amp;downcast&lt;RenderRubyBase&gt;(renderer());
 705         RenderRubyRun* run = base-&gt;rubyRun();
 706         if (run) {
 707             RenderRubyText* text = run-&gt;rubyText();
 708             if (text &amp;&amp; text-&gt;logicalTop() &gt; base-&gt;logicalTop()) {
 709                 // The ruby text is below the ruby base. Just return now in order to avoid painting on top of the ruby text.
 710                 return selectionBottom;
 711             }
 712         }
 713     } else if (renderer().isRubyText()) {
 714         // The ruby text selection should go all the way to the selection bottom of the containing line.
 715         RenderRubyText* text = &amp;downcast&lt;RenderRubyText&gt;(renderer());
 716         RenderRubyRun* run = text-&gt;rubyRun();
 717         if (run &amp;&amp; run-&gt;inlineBoxWrapper()) {
 718             RenderRubyBase* base = run-&gt;rubyBase();
 719             if (base &amp;&amp; text-&gt;logicalTop() &gt; base-&gt;logicalTop()) {
 720                 // The ruby text is above the ruby base.
 721                 const RootInlineBox&amp; containingLine = run-&gt;inlineBoxWrapper()-&gt;root();
 722                 LayoutUnit enclosingSelectionBottom = containingLine.selectionBottom();
 723                 LayoutUnit deltaBetweenObjects = text-&gt;logicalTop() + run-&gt;logicalTop();
 724                 LayoutUnit selectionBottomInRubyTextCoords = enclosingSelectionBottom - deltaBetweenObjects;
 725                 return std::min(selectionBottom, selectionBottomInRubyTextCoords);
 726             }
 727         }
 728     }
 729 #endif
 730 
 731     LayoutUnit nextTop = nextRootBox()-&gt;selectionTop();
 732     if (nextTop &gt; selectionBottom &amp;&amp; blockFlow().containsFloats()) {
 733         // The next line has actually been moved further over, probably from a large line-height, but possibly because the
 734         // line was forced to clear floats.  If so, let&#39;s check the offsets, and only be willing to use the next
 735         // line&#39;s top if the offsets are greater on both sides.
 736         LayoutUnit nextLeft = blockFlow().logicalLeftOffsetForLine(nextTop, DoNotIndentText);
 737         LayoutUnit nextRight = blockFlow().logicalRightOffsetForLine(nextTop, DoNotIndentText);
 738         LayoutUnit newLeft = blockFlow().logicalLeftOffsetForLine(selectionBottom, DoNotIndentText);
 739         LayoutUnit newRight = blockFlow().logicalRightOffsetForLine(selectionBottom, DoNotIndentText);
 740         if (nextLeft &gt; newLeft || nextRight &lt; newRight)
 741             return selectionBottom;
 742     }
 743 
 744     return nextTop;
 745 }
 746 
 747 int RootInlineBox::blockDirectionPointInLine() const
 748 {
 749     return !blockFlow().style().isFlippedBlocksWritingMode() ? std::max(lineTop(), selectionTop()) : std::min(lineBottom(), selectionBottom());
 750 }
 751 
 752 RenderBlockFlow&amp; RootInlineBox::blockFlow() const
 753 {
 754     return downcast&lt;RenderBlockFlow&gt;(renderer());
 755 }
 756 
 757 static bool isEditableLeaf(InlineBox* leaf)
 758 {
 759     return leaf &amp;&amp; leaf-&gt;renderer().node() &amp;&amp; leaf-&gt;renderer().node()-&gt;hasEditableStyle();
 760 }
 761 
 762 InlineBox* RootInlineBox::closestLeafChildForPoint(const IntPoint&amp; pointInContents, bool onlyEditableLeaves)
 763 {
 764     return closestLeafChildForLogicalLeftPosition(blockFlow().isHorizontalWritingMode() ? pointInContents.x() : pointInContents.y(), onlyEditableLeaves);
 765 }
 766 
 767 InlineBox* RootInlineBox::closestLeafChildForLogicalLeftPosition(int leftPosition, bool onlyEditableLeaves)
 768 {
 769     InlineBox* firstLeaf = firstLeafDescendant();
 770     InlineBox* lastLeaf = lastLeafDescendant();
 771 
 772     if (firstLeaf != lastLeaf) {
 773         if (firstLeaf-&gt;isLineBreak())
 774             firstLeaf = firstLeaf-&gt;nextLeafOnLineIgnoringLineBreak();
 775         else if (lastLeaf-&gt;isLineBreak())
 776             lastLeaf = lastLeaf-&gt;previousLeafOnLineIgnoringLineBreak();
 777     }
 778 
 779     if (firstLeaf == lastLeaf &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
 780         return firstLeaf;
 781 
 782     // Avoid returning a list marker when possible.
 783     if (firstLeaf &amp;&amp; leftPosition &lt;= firstLeaf-&gt;logicalLeft() &amp;&amp; !firstLeaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
 784         // The leftPosition coordinate is less or equal to left edge of the firstLeaf.
 785         // Return it.
 786         return firstLeaf;
 787 
 788     if (lastLeaf &amp;&amp; leftPosition &gt;= lastLeaf-&gt;logicalRight() &amp;&amp; !lastLeaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(lastLeaf)))
 789         // The leftPosition coordinate is greater or equal to right edge of the lastLeaf.
 790         // Return it.
 791         return lastLeaf;
 792 
 793     InlineBox* closestLeaf = nullptr;
 794     for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf-&gt;nextLeafOnLineIgnoringLineBreak()) {
 795         if (!leaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(leaf))) {
 796             closestLeaf = leaf;
 797             if (leftPosition &lt; leaf-&gt;logicalRight())
 798                 // The x coordinate is less than the right edge of the box.
 799                 // Return it.
 800                 return leaf;
 801         }
 802     }
 803 
 804     return closestLeaf ? closestLeaf : lastLeaf;
 805 }
 806 
 807 BidiStatus RootInlineBox::lineBreakBidiStatus() const
 808 {
 809     return { static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusEor), static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusLastStrong), static_cast&lt;UCharDirection&gt;(m_lineBreakBidiStatusLast), m_lineBreakContext.copyRef() };
 810 }
 811 
 812 void RootInlineBox::setLineBreakInfo(RenderObject* object, unsigned breakPosition, const BidiStatus&amp; status)
 813 {
 814     m_lineBreakObj = makeWeakPtr(object);
 815     m_lineBreakPos = breakPosition;
 816     m_lineBreakBidiStatusEor = status.eor;
 817     m_lineBreakBidiStatusLastStrong = status.lastStrong;
 818     m_lineBreakBidiStatusLast = status.last;
 819     m_lineBreakContext = status.context;
 820 }
 821 
 822 EllipsisBox* RootInlineBox::ellipsisBox() const
 823 {
 824     if (!hasEllipsisBox())
 825         return nullptr;
 826     return gEllipsisBoxMap-&gt;get(this);
 827 }
 828 
 829 void RootInlineBox::removeLineBoxFromRenderObject()
 830 {
 831     // Null if we are destroying ComplexLineLayout.
 832     if (auto* complexLineLayout = blockFlow().complexLineLayout())
 833         complexLineLayout-&gt;lineBoxes().removeLineBox(this);
 834 }
 835 
 836 void RootInlineBox::extractLineBoxFromRenderObject()
 837 {
 838     blockFlow().complexLineLayout()-&gt;lineBoxes().extractLineBox(this);
 839 }
 840 
 841 void RootInlineBox::attachLineBoxToRenderObject()
 842 {
 843     blockFlow().complexLineLayout()-&gt;lineBoxes().attachLineBox(this);
 844 }
 845 
 846 LayoutRect RootInlineBox::paddedLayoutOverflowRect(LayoutUnit endPadding) const
 847 {
 848     LayoutRect lineLayoutOverflow = layoutOverflowRect(lineTop(), lineBottom());
 849     if (!endPadding)
 850         return lineLayoutOverflow;
 851 
 852     if (isHorizontal()) {
 853         if (isLeftToRightDirection())
 854             lineLayoutOverflow.shiftMaxXEdgeTo(std::max(lineLayoutOverflow.maxX(), LayoutUnit(logicalRight() + endPadding)));
 855         else
 856             lineLayoutOverflow.shiftXEdgeTo(std::min(lineLayoutOverflow.x(), LayoutUnit(logicalLeft() - endPadding)));
 857     } else {
 858         if (isLeftToRightDirection())
 859             lineLayoutOverflow.shiftMaxYEdgeTo(std::max(lineLayoutOverflow.maxY(), LayoutUnit(logicalRight() + endPadding)));
 860         else
 861             lineLayoutOverflow.shiftYEdgeTo(std::min(lineLayoutOverflow.y(), LayoutUnit(logicalLeft() - endPadding)));
 862     }
 863 
 864     return lineLayoutOverflow;
 865 }
 866 
 867 static void setAscentAndDescent(int&amp; ascent, int&amp; descent, int newAscent, int newDescent, bool&amp; ascentDescentSet)
 868 {
 869     if (!ascentDescentSet) {
 870         ascentDescentSet = true;
 871         ascent = newAscent;
 872         descent = newDescent;
 873     } else {
 874         ascent = std::max(ascent, newAscent);
 875         descent = std::max(descent, newDescent);
 876     }
 877 }
 878 
 879 void RootInlineBox::ascentAndDescentForBox(InlineBox&amp; box, GlyphOverflowAndFallbackFontsMap&amp; textBoxDataMap, int&amp; ascent, int&amp; descent,
 880                                            bool&amp; affectsAscent, bool&amp; affectsDescent) const
 881 {
 882     bool ascentDescentSet = false;
 883 
 884     // Replaced boxes will return 0 for the line-height if line-box-contain says they are
 885     // not to be included.
 886     if (box.renderer().isReplaced()) {
 887         if (lineStyle().lineBoxContain().contains(LineBoxContain::Replaced)) {
 888             ascent = box.baselinePosition(baselineType());
 889             descent = box.lineHeight() - ascent;
 890 
 891             // Replaced elements always affect both the ascent and descent.
 892             affectsAscent = true;
 893             affectsDescent = true;
 894         }
 895         return;
 896     }
 897 
 898     Vector&lt;const Font*&gt;* usedFonts = nullptr;
 899     GlyphOverflow* glyphOverflow = nullptr;
 900     if (is&lt;InlineTextBox&gt;(box)) {
 901         GlyphOverflowAndFallbackFontsMap::iterator it = textBoxDataMap.find(&amp;downcast&lt;InlineTextBox&gt;(box));
 902         usedFonts = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.first;
 903         glyphOverflow = it == textBoxDataMap.end() ? nullptr : &amp;it-&gt;value.second;
 904     }
 905 
 906     bool includeLeading = includeLeadingForBox(box);
 907     bool includeFont = includeFontForBox(box);
 908 
 909     bool setUsedFont = false;
 910     bool setUsedFontWithLeading = false;
 911 
 912     const RenderStyle&amp; boxLineStyle = box.lineStyle();
 913     if (usedFonts &amp;&amp; !usedFonts-&gt;isEmpty() &amp;&amp; (includeFont || (boxLineStyle.lineHeight().isNegative() &amp;&amp; includeLeading))) {
 914         usedFonts-&gt;append(&amp;boxLineStyle.fontCascade().primaryFont());
 915         for (auto&amp; font : *usedFonts) {
 916             auto&amp; fontMetrics = font-&gt;fontMetrics();
 917             int usedFontAscent = fontMetrics.ascent(baselineType());
 918             int usedFontDescent = fontMetrics.descent(baselineType());
 919             int halfLeading = (fontMetrics.lineSpacing() - fontMetrics.height()) / 2;
 920             int usedFontAscentAndLeading = usedFontAscent + halfLeading;
 921             int usedFontDescentAndLeading = fontMetrics.lineSpacing() - usedFontAscentAndLeading;
 922             if (includeFont) {
 923                 setAscentAndDescent(ascent, descent, usedFontAscent, usedFontDescent, ascentDescentSet);
 924                 setUsedFont = true;
 925             }
 926             if (includeLeading) {
 927                 setAscentAndDescent(ascent, descent, usedFontAscentAndLeading, usedFontDescentAndLeading, ascentDescentSet);
 928                 setUsedFontWithLeading = true;
 929             }
 930             if (!affectsAscent)
 931                 affectsAscent = usedFontAscent - box.logicalTop() &gt; 0;
 932             if (!affectsDescent)
 933                 affectsDescent = usedFontDescent + box.logicalTop() &gt; 0;
 934         }
 935     }
 936 
 937     // If leading is included for the box, then we compute that box.
 938     if (includeLeading &amp;&amp; !setUsedFontWithLeading) {
 939         int ascentWithLeading = box.baselinePosition(baselineType());
 940         int descentWithLeading = box.lineHeight() - ascentWithLeading;
 941         setAscentAndDescent(ascent, descent, ascentWithLeading, descentWithLeading, ascentDescentSet);
 942 
 943         // Examine the font box for inline flows and text boxes to see if any part of it is above the baseline.
 944         // If the top of our font box relative to the root box baseline is above the root box baseline, then
 945         // we are contributing to the maxAscent value. Descent is similar. If any part of our font box is below
 946         // the root box&#39;s baseline, then we contribute to the maxDescent value.
 947         affectsAscent = ascentWithLeading - box.logicalTop() &gt; 0;
 948         affectsDescent = descentWithLeading + box.logicalTop() &gt; 0;
 949     }
 950 
 951     if (includeFontForBox(box) &amp;&amp; !setUsedFont) {
 952         int fontAscent = boxLineStyle.fontMetrics().ascent(baselineType());
 953         int fontDescent = boxLineStyle.fontMetrics().descent(baselineType());
 954         setAscentAndDescent(ascent, descent, fontAscent, fontDescent, ascentDescentSet);
 955         affectsAscent = fontAscent - box.logicalTop() &gt; 0;
 956         affectsDescent = fontDescent + box.logicalTop() &gt; 0;
 957     }
 958 
 959     if (includeGlyphsForBox(box) &amp;&amp; glyphOverflow &amp;&amp; glyphOverflow-&gt;computeBounds) {
 960         setAscentAndDescent(ascent, descent, glyphOverflow-&gt;top, glyphOverflow-&gt;bottom, ascentDescentSet);
 961         affectsAscent = glyphOverflow-&gt;top - box.logicalTop() &gt; 0;
 962         affectsDescent = glyphOverflow-&gt;bottom + box.logicalTop() &gt; 0;
 963         glyphOverflow-&gt;top = std::min(glyphOverflow-&gt;top, std::max(0, glyphOverflow-&gt;top - boxLineStyle.fontMetrics().ascent(baselineType())));
 964         glyphOverflow-&gt;bottom = std::min(glyphOverflow-&gt;bottom, std::max(0, glyphOverflow-&gt;bottom - boxLineStyle.fontMetrics().descent(baselineType())));
 965     }
 966 
 967     if (includeInitialLetterForBox(box)) {
 968         bool canUseGlyphs = glyphOverflow &amp;&amp; glyphOverflow-&gt;computeBounds;
 969         int letterAscent = baselineType() == AlphabeticBaseline ? boxLineStyle.fontMetrics().capHeight() : (canUseGlyphs ? glyphOverflow-&gt;top : boxLineStyle.fontMetrics().ascent(baselineType()));
 970         int letterDescent = canUseGlyphs ? glyphOverflow-&gt;bottom : (box.isRootInlineBox() ? 0 : boxLineStyle.fontMetrics().descent(baselineType()));
 971         setAscentAndDescent(ascent, descent, letterAscent, letterDescent, ascentDescentSet);
 972         affectsAscent = letterAscent - box.logicalTop() &gt; 0;
 973         affectsDescent = letterDescent + box.logicalTop() &gt; 0;
 974         if (canUseGlyphs) {
 975             glyphOverflow-&gt;top = std::min(glyphOverflow-&gt;top, std::max(0, glyphOverflow-&gt;top - boxLineStyle.fontMetrics().ascent(baselineType())));
 976             glyphOverflow-&gt;bottom = std::min(glyphOverflow-&gt;bottom, std::max(0, glyphOverflow-&gt;bottom - boxLineStyle.fontMetrics().descent(baselineType())));
 977         }
 978     }
 979 
 980     if (includeMarginForBox(box)) {
 981         LayoutUnit ascentWithMargin = boxLineStyle.fontMetrics().ascent(baselineType());
 982         LayoutUnit descentWithMargin = boxLineStyle.fontMetrics().descent(baselineType());
 983         if (box.parent() &amp;&amp; !box.renderer().isTextOrLineBreak()) {
 984             ascentWithMargin += box.boxModelObject()-&gt;borderAndPaddingBefore() + box.boxModelObject()-&gt;marginBefore();
 985             descentWithMargin += box.boxModelObject()-&gt;borderAndPaddingAfter() + box.boxModelObject()-&gt;marginAfter();
 986         }
 987         setAscentAndDescent(ascent, descent, ascentWithMargin, descentWithMargin, ascentDescentSet);
 988 
 989         // Treat like a replaced element, since we&#39;re using the margin box.
 990         affectsAscent = true;
 991         affectsDescent = true;
 992     }
 993 }
 994 
 995 LayoutUnit RootInlineBox::verticalPositionForBox(InlineBox* box, VerticalPositionCache&amp; verticalPositionCache)
 996 {
 997     if (box-&gt;renderer().isTextOrLineBreak())
 998         return LayoutUnit(box-&gt;parent()-&gt;logicalTop());
 999 
1000     RenderBoxModelObject* renderer = box-&gt;boxModelObject();
1001     ASSERT(renderer-&gt;isInline());
1002     if (!renderer-&gt;isInline())
1003         return 0;
1004 
1005     // This method determines the vertical position for inline elements.
1006     bool firstLine = isFirstLine();
1007     if (firstLine &amp;&amp; !blockFlow().view().usesFirstLineRules())
1008         firstLine = false;
1009 
1010     // Check the cache.
1011     bool isRenderInline = renderer-&gt;isRenderInline();
1012     if (isRenderInline &amp;&amp; !firstLine) {
1013         LayoutUnit cachedPosition;
1014         if (verticalPositionCache.get(renderer, baselineType(), cachedPosition))
1015             return cachedPosition;
1016     }
1017 
1018     LayoutUnit verticalPosition;
1019     VerticalAlign verticalAlign = renderer-&gt;style().verticalAlign();
1020     if (verticalAlign == VerticalAlign::Top || verticalAlign == VerticalAlign::Bottom)
1021         return 0;
1022 
1023     RenderElement* parent = renderer-&gt;parent();
1024     if (parent-&gt;isRenderInline() &amp;&amp; parent-&gt;style().verticalAlign() != VerticalAlign::Top &amp;&amp; parent-&gt;style().verticalAlign() != VerticalAlign::Bottom)
1025         verticalPosition = box-&gt;parent()-&gt;logicalTop();
1026 
1027     if (verticalAlign != VerticalAlign::Baseline) {
1028         const RenderStyle&amp; parentLineStyle = firstLine ? parent-&gt;firstLineStyle() : parent-&gt;style();
1029         const FontCascade&amp; font = parentLineStyle.fontCascade();
1030         const FontMetrics&amp; fontMetrics = font.fontMetrics();
1031         int fontSize = font.pixelSize();
1032 
1033         LineDirectionMode lineDirection = parent-&gt;isHorizontalWritingMode() ? HorizontalLine : VerticalLine;
1034 
1035         if (verticalAlign == VerticalAlign::Sub)
1036             verticalPosition += fontSize / 5 + 1;
1037         else if (verticalAlign == VerticalAlign::Super)
1038             verticalPosition -= fontSize / 3 + 1;
1039         else if (verticalAlign == VerticalAlign::TextTop)
1040             verticalPosition += renderer-&gt;baselinePosition(baselineType(), firstLine, lineDirection) - fontMetrics.ascent(baselineType());
1041         else if (verticalAlign == VerticalAlign::Middle)
1042             verticalPosition = (verticalPosition - LayoutUnit(fontMetrics.xHeight() / 2) - renderer-&gt;lineHeight(firstLine, lineDirection) / 2 + renderer-&gt;baselinePosition(baselineType(), firstLine, lineDirection)).round();
1043         else if (verticalAlign == VerticalAlign::TextBottom) {
1044             verticalPosition += fontMetrics.descent(baselineType());
1045             // lineHeight - baselinePosition is always 0 for replaced elements (except inline blocks), so don&#39;t bother wasting time in that case.
1046             if (!renderer-&gt;isReplaced() || renderer-&gt;isInlineBlockOrInlineTable())
1047                 verticalPosition -= (renderer-&gt;lineHeight(firstLine, lineDirection) - renderer-&gt;baselinePosition(baselineType(), firstLine, lineDirection));
1048         } else if (verticalAlign == VerticalAlign::BaselineMiddle)
1049             verticalPosition += -renderer-&gt;lineHeight(firstLine, lineDirection) / 2 + renderer-&gt;baselinePosition(baselineType(), firstLine, lineDirection);
1050         else if (verticalAlign == VerticalAlign::Length) {
1051             LayoutUnit lineHeight;
1052             //Per http://www.w3.org/TR/CSS21/visudet.html#propdef-vertical-align: &#39;Percentages: refer to the &#39;line-height&#39; of the element itself&#39;.
1053             if (renderer-&gt;style().verticalAlignLength().isPercentOrCalculated())
1054                 lineHeight = renderer-&gt;style().computedLineHeight();
1055             else
1056                 lineHeight = renderer-&gt;lineHeight(firstLine, lineDirection);
1057             verticalPosition -= valueForLength(renderer-&gt;style().verticalAlignLength(), lineHeight);
1058         }
1059     }
1060 
1061     // Store the cached value.
1062     if (isRenderInline &amp;&amp; !firstLine)
1063         verticalPositionCache.set(renderer, baselineType(), verticalPosition);
1064 
1065     return verticalPosition;
1066 }
1067 
1068 bool RootInlineBox::includeLeadingForBox(InlineBox&amp; box) const
1069 {
1070     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1071         return false;
1072 
1073     auto lineBoxContain = renderer().style().lineBoxContain();
1074     return lineBoxContain.contains(LineBoxContain::Inline) || (&amp;box == this &amp;&amp; lineBoxContain.contains(LineBoxContain::Block));
1075 }
1076 
1077 bool RootInlineBox::includeFontForBox(InlineBox&amp; box) const
1078 {
1079     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1080         return false;
1081 
1082     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1083         return false;
1084 
1085     return renderer().style().lineBoxContain().contains(LineBoxContain::Font);
1086 }
1087 
1088 bool RootInlineBox::includeGlyphsForBox(InlineBox&amp; box) const
1089 {
1090     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1091         return false;
1092 
1093     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1094         return false;
1095 
1096     return renderer().style().lineBoxContain().contains(LineBoxContain::Glyphs);
1097 }
1098 
1099 bool RootInlineBox::includeInitialLetterForBox(InlineBox&amp; box) const
1100 {
1101     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1102         return false;
1103 
1104     if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
1105         return false;
1106 
1107     return renderer().style().lineBoxContain().contains(LineBoxContain::InitialLetter);
1108 }
1109 
1110 bool RootInlineBox::includeMarginForBox(InlineBox&amp; box) const
1111 {
1112     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
1113         return false;
1114 
1115     return renderer().style().lineBoxContain().contains(LineBoxContain::InlineBox);
1116 }
1117 
1118 bool RootInlineBox::fitsToGlyphs() const
1119 {
1120     return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Glyphs, LineBoxContain::InitialLetter });
1121 }
1122 
1123 bool RootInlineBox::includesRootLineBoxFontOrLeading() const
1124 {
1125     return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Block, LineBoxContain::Inline, LineBoxContain::Font });
1126 }
1127 
1128 Node* RootInlineBox::getLogicalStartBoxWithNode(InlineBox*&amp; startBox) const
1129 {
1130     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
1131     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder);
1132     for (size_t i = 0; i &lt; leafBoxesInLogicalOrder.size(); ++i) {
1133         if (leafBoxesInLogicalOrder[i]-&gt;renderer().node()) {
1134             startBox = leafBoxesInLogicalOrder[i];
1135             return startBox-&gt;renderer().node();
1136         }
1137     }
1138     startBox = nullptr;
1139     return nullptr;
1140 }
1141 
1142 Node* RootInlineBox::getLogicalEndBoxWithNode(InlineBox*&amp; endBox) const
1143 {
1144     Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
1145     collectLeafBoxesInLogicalOrder(leafBoxesInLogicalOrder);
1146     for (size_t i = leafBoxesInLogicalOrder.size(); i &gt; 0; --i) {
1147         if (leafBoxesInLogicalOrder[i - 1]-&gt;renderer().node()) {
1148             endBox = leafBoxesInLogicalOrder[i - 1];
1149             return endBox-&gt;renderer().node();
1150         }
1151     }
1152     endBox = nullptr;
1153     return nullptr;
1154 }
1155 
1156 #if ENABLE(TREE_DEBUGGING)
1157 const char* RootInlineBox::boxName() const
1158 {
1159     return &quot;RootInlineBox&quot;;
1160 }
1161 #endif
1162 
1163 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/track/TrackListBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011, 2012 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(VIDEO_TRACK)
 29 
 30 #include &quot;TrackListBase.h&quot;
 31 
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;HTMLMediaElement.h&quot;
 34 #include &quot;ScriptExecutionContext.h&quot;
 35 #include &quot;TrackEvent.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 WTF_MAKE_ISO_ALLOCATED_IMPL(TrackListBase);
 41 
 42 TrackListBase::TrackListBase(WeakPtr&lt;HTMLMediaElement&gt; element, ScriptExecutionContext* context)
 43     : ContextDestructionObserver(context)
 44     , m_element(element)
 45     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))
 46 {
 47     ASSERT(!context || is&lt;Document&gt;(context));
 48 }
 49 
 50 TrackListBase::~TrackListBase()
 51 {
 52     clearElement();
 53 }
 54 
 55 void TrackListBase::clearElement()
 56 {
 57     m_element = nullptr;
 58     for (auto&amp; track : m_inbandTracks) {
 59         track-&gt;setMediaElement(nullptr);
 60         track-&gt;clearClient();
 61     }
 62 }
 63 
 64 Element* TrackListBase::element() const
 65 {
 66     return m_element.get();
 67 }
 68 
 69 unsigned TrackListBase::length() const
 70 {
 71     return m_inbandTracks.size();
 72 }
 73 
 74 void TrackListBase::remove(TrackBase&amp; track, bool scheduleEvent)
 75 {
 76     size_t index = m_inbandTracks.find(&amp;track);
 77     if (index == notFound)
 78         return;
 79 
 80     if (track.mediaElement()) {
 81         ASSERT(track.mediaElement() == m_element);
 82         track.setMediaElement(nullptr);
 83     }
 84 
 85     Ref&lt;TrackBase&gt; trackRef = *m_inbandTracks[index];
 86 
 87     m_inbandTracks.remove(index);
 88 
 89     if (scheduleEvent)
 90         scheduleRemoveTrackEvent(WTFMove(trackRef));
 91 }
 92 
 93 bool TrackListBase::contains(TrackBase&amp; track) const
 94 {
 95     return m_inbandTracks.find(&amp;track) != notFound;
 96 }
 97 
 98 void TrackListBase::scheduleTrackEvent(const AtomString&amp; eventName, Ref&lt;TrackBase&gt;&amp;&amp; track)
 99 {
100     m_asyncEventQueue-&gt;enqueueEvent(TrackEvent::create(eventName, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(track)));
101 }
102 
103 void TrackListBase::scheduleAddTrackEvent(Ref&lt;TrackBase&gt;&amp;&amp; track)
104 {
105     // 4.8.10.5 Loading the media resource
106     // ...
107     // Fire a trusted event with the name addtrack, that does not bubble and is
108     // not cancelable, and that uses the TrackEvent interface, with the track
109     // attribute initialized to the new AudioTrack object, at this
110     // AudioTrackList object.
111     // ...
112     // Fire a trusted event with the name addtrack, that does not bubble and is
113     // not cancelable, and that uses the TrackEvent interface, with the track
114     // attribute initialized to the new VideoTrack object, at this
115     // VideoTrackList object.
116 
117     // 4.8.10.12.3 Sourcing out-of-band text tracks
118     // 4.8.10.12.4 Text track API
119     // ... then queue a task to fire an event with the name addtrack, that does not
120     // bubble and is not cancelable, and that uses the TrackEvent interface, with
121     // the track attribute initialized to the text track&#39;s TextTrack object, at
122     // the media element&#39;s textTracks attribute&#39;s TextTrackList object.
123     scheduleTrackEvent(eventNames().addtrackEvent, WTFMove(track));
124 }
125 
126 void TrackListBase::scheduleRemoveTrackEvent(Ref&lt;TrackBase&gt;&amp;&amp; track)
127 {
128     // 4.8.10.6 Offsets into the media resource
129     // If at any time the user agent learns that an audio or video track has
130     // ended and all media data relating to that track corresponds to parts of
131     // the media timeline that are before the earliest possible position, the
132     // user agent may queue a task to remove the track from the audioTracks
133     // attribute&#39;s AudioTrackList object or the videoTracks attribute&#39;s
134     // VideoTrackList object as appropriate and then fire a trusted event
135     // with the name removetrack, that does not bubble and is not cancelable,
136     // and that uses the TrackEvent interface, with the track attribute
137     // initialized to the AudioTrack or VideoTrack object representing the
138     // track, at the media element&#39;s aforementioned AudioTrackList or
139     // VideoTrackList object.
140 
141     // 4.8.10.12.3 Sourcing out-of-band text tracks
142     // When a track element&#39;s parent element changes and the old parent was a
143     // media element, then the user agent must remove the track element&#39;s
144     // corresponding text track from the media element&#39;s list of text tracks,
145     // and then queue a task to fire a trusted event with the name removetrack,
146     // that does not bubble and is not cancelable, and that uses the TrackEvent
147     // interface, with the track attribute initialized to the text track&#39;s
148     // TextTrack object, at the media element&#39;s textTracks attribute&#39;s
149     // TextTrackList object.
150     scheduleTrackEvent(eventNames().removetrackEvent, WTFMove(track));
151 }
152 
153 void TrackListBase::scheduleChangeEvent()
154 {
155     // 4.8.10.6 Offsets into the media resource
156     // Whenever an audio track in an AudioTrackList is enabled or disabled, the
157     // user agent must queue a task to fire a simple event named change at the
158     // AudioTrackList object.
159     // ...
160     // Whenever a track in a VideoTrackList that was previously not selected is
161     // selected, the user agent must queue a task to fire a simple event named
162     // change at the VideoTrackList object.
163     m_asyncEventQueue-&gt;enqueueEvent(Event::create(eventNames().changeEvent, Event::CanBubble::No, Event::IsCancelable::No));
164 }
165 
166 bool TrackListBase::isChangeEventScheduled() const
167 {
168     return m_asyncEventQueue-&gt;hasPendingEventsOfType(eventNames().changeEvent);
169 }
170 
171 bool TrackListBase::isAnyTrackEnabled() const
172 {
173     for (auto&amp; track : m_inbandTracks) {
174         if (track-&gt;enabled())
175             return true;
176     }
177     return false;
178 }
179 
180 } // namespace WebCore
181 
182 #endif
    </pre>
  </body>
</html>
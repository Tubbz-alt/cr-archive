diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeOrigin.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeOrigin.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeOrigin.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeOrigin.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -23,10 +23,12 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "BytecodeIndex.h"
+
 #include <limits.h>
 #include <wtf/HashMap.h>
 #include <wtf/PrintStream.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/Vector.h>
@@ -39,37 +41,36 @@
 
 class CodeOrigin {
 public:
     CodeOrigin()
 #if CPU(ADDRESS64)
-        : m_compositeValue(buildCompositeValue(nullptr, s_invalidBytecodeIndex))
+        : m_compositeValue(buildCompositeValue(nullptr, BytecodeIndex()))
 #else
-        : m_bytecodeIndex(s_invalidBytecodeIndex)
-        , m_inlineCallFrame(nullptr)
+        : m_inlineCallFrame(nullptr)
 #endif
     {
     }
 
     CodeOrigin(WTF::HashTableDeletedValueType)
 #if CPU(ADDRESS64)
-        : m_compositeValue(buildCompositeValue(deletedMarker(), s_invalidBytecodeIndex))
+        : m_compositeValue(buildCompositeValue(deletedMarker(), BytecodeIndex()))
 #else
-        : m_bytecodeIndex(s_invalidBytecodeIndex)
+        : m_bytecodeIndex(WTF::HashTableDeletedValue)
         , m_inlineCallFrame(deletedMarker())
 #endif
     {
     }
 
-    explicit CodeOrigin(unsigned bytecodeIndex, InlineCallFrame* inlineCallFrame = nullptr)
+    explicit CodeOrigin(BytecodeIndex bytecodeIndex, InlineCallFrame* inlineCallFrame = nullptr)
 #if CPU(ADDRESS64)
         : m_compositeValue(buildCompositeValue(inlineCallFrame, bytecodeIndex))
 #else
         : m_bytecodeIndex(bytecodeIndex)
         , m_inlineCallFrame(inlineCallFrame)
 #endif
     {
-        ASSERT(bytecodeIndex < s_invalidBytecodeIndex);
+        ASSERT(!!bytecodeIndex);
 #if CPU(ADDRESS64)
         ASSERT(!(bitwise_cast<uintptr_t>(inlineCallFrame) & ~s_maskCompositeValueForPointer));
 #endif
     }
 
@@ -122,21 +123,21 @@
     bool isSet() const
     {
 #if CPU(ADDRESS64)
         return !(m_compositeValue & s_maskIsBytecodeIndexInvalid);
 #else
-        return m_bytecodeIndex != s_invalidBytecodeIndex;
+        return !!m_bytecodeIndex;
 #endif
     }
     explicit operator bool() const { return isSet(); }
 
     bool isHashTableDeletedValue() const
     {
 #if CPU(ADDRESS64)
         return !isSet() && (m_compositeValue & s_maskCompositeValueForPointer);
 #else
-        return m_bytecodeIndex == s_invalidBytecodeIndex && !!m_inlineCallFrame;
+        return m_bytecodeIndex.isHashTableDeletedValue() && !!m_inlineCallFrame;
 #endif
     }
 
     // The inline depth is the depth of the inline stack, so 1 = not inlined,
     // 2 = inlined one deep, etc.
@@ -157,26 +158,28 @@
     bool isApproximatelyEqualTo(const CodeOrigin& other, InlineCallFrame* terminal = nullptr) const;
 
     unsigned approximateHash(InlineCallFrame* terminal = nullptr) const;
 
     template <typename Function>
-    void walkUpInlineStack(const Function&);
+    void walkUpInlineStack(const Function&) const;
+
+    inline bool inlineStackContainsActiveCheckpoint() const;
 
     // Get the inline stack. This is slow, and is intended for debugging only.
     Vector<CodeOrigin> inlineStack() const;
 
     JS_EXPORT_PRIVATE void dump(PrintStream&) const;
     void dumpInContext(PrintStream&, DumpContext*) const;
 
-    unsigned bytecodeIndex() const
+    BytecodeIndex bytecodeIndex() const
     {
 #if CPU(ADDRESS64)
         if (!isSet())
-            return s_invalidBytecodeIndex;
+            return BytecodeIndex();
         if (UNLIKELY(isOutOfLine()))
             return outOfLineCodeOrigin()->bytecodeIndex;
-        return m_compositeValue >> (64 - s_freeBitsAtTop);
+        return BytecodeIndex::fromBits(m_compositeValue >> (64 - s_freeBitsAtTop));
 #else
         return m_bytecodeIndex;
 #endif
     }
 
@@ -190,23 +193,21 @@
         return m_inlineCallFrame;
 #endif
     }
 
 private:
-    static constexpr unsigned s_invalidBytecodeIndex = UINT_MAX;
-
 #if CPU(ADDRESS64)
     static constexpr uintptr_t s_maskIsOutOfLine = 1;
     static constexpr uintptr_t s_maskIsBytecodeIndexInvalid = 2;
 
     struct OutOfLineCodeOrigin {
         WTF_MAKE_FAST_ALLOCATED;
     public:
         InlineCallFrame* inlineCallFrame;
-        unsigned bytecodeIndex;
+        BytecodeIndex bytecodeIndex;
 
-        OutOfLineCodeOrigin(InlineCallFrame* inlineCallFrame, unsigned bytecodeIndex)
+        OutOfLineCodeOrigin(InlineCallFrame* inlineCallFrame, BytecodeIndex bytecodeIndex)
             : inlineCallFrame(inlineCallFrame)
             , bytecodeIndex(bytecodeIndex)
         {
         }
     };
@@ -231,23 +232,23 @@
 #endif
         return bitwise_cast<InlineCallFrame*>(value);
     }
 
 #if CPU(ADDRESS64)
-    static constexpr unsigned s_freeBitsAtTop = 64 - WTF_CPU_EFFECTIVE_ADDRESS_WIDTH;
-    static constexpr uintptr_t s_maskCompositeValueForPointer = ((1ULL << WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) - 1) & ~(8ULL - 1);
-    static uintptr_t buildCompositeValue(InlineCallFrame* inlineCallFrame, unsigned bytecodeIndex)
+    static constexpr unsigned s_freeBitsAtTop = 64 - OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH);
+    static constexpr uintptr_t s_maskCompositeValueForPointer = ((1ULL << OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) - 1) & ~(8ULL - 1);
+    static uintptr_t buildCompositeValue(InlineCallFrame* inlineCallFrame, BytecodeIndex bytecodeIndex)
     {
-        if (bytecodeIndex == s_invalidBytecodeIndex)
+        if (!bytecodeIndex)
             return bitwise_cast<uintptr_t>(inlineCallFrame) | s_maskIsBytecodeIndexInvalid;
 
-        if (UNLIKELY(bytecodeIndex >= 1 << s_freeBitsAtTop)) {
+        if (UNLIKELY(bytecodeIndex.asBits() >= 1 << s_freeBitsAtTop)) {
             auto* outOfLine = new OutOfLineCodeOrigin(inlineCallFrame, bytecodeIndex);
             return bitwise_cast<uintptr_t>(outOfLine) | s_maskIsOutOfLine;
         }
 
-        uintptr_t encodedBytecodeIndex = static_cast<uintptr_t>(bytecodeIndex) << (64 - s_freeBitsAtTop);
+        uintptr_t encodedBytecodeIndex = static_cast<uintptr_t>(bytecodeIndex.asBits()) << (64 - s_freeBitsAtTop);
         ASSERT(!(encodedBytecodeIndex & bitwise_cast<uintptr_t>(inlineCallFrame)));
         return encodedBytecodeIndex | bitwise_cast<uintptr_t>(inlineCallFrame);
     }
 
     // The bottom bit indicates whether to look at an out-of-line implementation (because of a bytecode index which is too big for us to store).
@@ -256,18 +257,18 @@
     // The next bit is free
     // The next 64-s_freeBitsAtTop-3 are the InlineCallFrame* or the OutOfLineCodeOrigin*
     // Finally the last s_freeBitsAtTop are the bytecodeIndex if it is inline
     uintptr_t m_compositeValue;
 #else
-    unsigned m_bytecodeIndex;
+    BytecodeIndex m_bytecodeIndex;
     InlineCallFrame* m_inlineCallFrame;
 #endif
 };
 
 inline unsigned CodeOrigin::hash() const
 {
-    return WTF::IntHash<unsigned>::hash(bytecodeIndex()) +
+    return WTF::IntHash<unsigned>::hash(bytecodeIndex().asBits()) +
         WTF::PtrHash<InlineCallFrame*>::hash(inlineCallFrame());
 }
 
 inline bool CodeOrigin::operator==(const CodeOrigin& other) const
 {
@@ -280,17 +281,17 @@
 }
 
 struct CodeOriginHash {
     static unsigned hash(const CodeOrigin& key) { return key.hash(); }
     static bool equal(const CodeOrigin& a, const CodeOrigin& b) { return a == b; }
-    static const bool safeToCompareToEmptyOrDeleted = true;
+    static constexpr bool safeToCompareToEmptyOrDeleted = true;
 };
 
 struct CodeOriginApproximateHash {
     static unsigned hash(const CodeOrigin& key) { return key.approximateHash(); }
     static bool equal(const CodeOrigin& a, const CodeOrigin& b) { return a.isApproximatelyEqualTo(b); }
-    static const bool safeToCompareToEmptyOrDeleted = true;
+    static constexpr bool safeToCompareToEmptyOrDeleted = true;
 };
 
 } // namespace JSC
 
 namespace WTF {
@@ -300,9 +301,9 @@
     typedef JSC::CodeOriginHash Hash;
 };
 
 template<typename T> struct HashTraits;
 template<> struct HashTraits<JSC::CodeOrigin> : SimpleClassHashTraits<JSC::CodeOrigin> {
-    static const bool emptyValueIsZero = false;
+    static constexpr bool emptyValueIsZero = false;
 };
 
 } // namespace WTF

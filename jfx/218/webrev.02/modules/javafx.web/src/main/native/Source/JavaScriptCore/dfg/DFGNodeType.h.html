<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNodeType.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGNodeFlags.h&quot;
 31 
 32 namespace JSC { namespace DFG {
 33 
 34 // This macro defines a set of information about all known node types, used to populate NodeId, NodeType below.
 35 #define FOR_EACH_DFG_OP(macro) \
 36     /* A constant in the CodeBlock&#39;s constant pool. */\
 37     macro(JSConstant, NodeResultJS) \
 38     \
 39     /* Constants with specific representations. */\
 40     macro(DoubleConstant, NodeResultDouble) \
 41     macro(Int52Constant, NodeResultInt52) \
 42     \
 43     /* Lazy JSValue constant. We don&#39;t know the JSValue bits of it yet. */\
 44     macro(LazyJSConstant, NodeResultJS) \
 45     \
 46     /* Marker to indicate that an operation was optimized entirely and all that is left */\
 47     /* is to make one node alias another. CSE will later usually eliminate this node, */\
 48     /* though it may choose not to if it would corrupt predictions (very rare). */\
 49     macro(Identity, NodeResultJS) \
 50     /* Used for debugging to force a profile to appear as anything we want. */ \
 51     macro(IdentityWithProfile, NodeResultJS | NodeMustGenerate) \
 52     \
 53     /* Nodes for handling functions (both as call and as construct). */\
 54     macro(ToThis, NodeResultJS) \
 55     macro(CreateThis, NodeResultJS) /* Note this is not MustGenerate since we&#39;re returning it anyway. */ \
 56     macro(CreatePromise, NodeResultJS | NodeMustGenerate) \
 57     macro(CreateGenerator, NodeResultJS | NodeMustGenerate) \
 58     macro(CreateAsyncGenerator, NodeResultJS | NodeMustGenerate) \
 59     macro(GetCallee, NodeResultJS) \
 60     macro(SetCallee, NodeMustGenerate) \
 61     macro(GetArgumentCountIncludingThis, NodeResultInt32) \
 62     macro(SetArgumentCountIncludingThis, NodeMustGenerate) \
 63     \
 64     /* Nodes for local variable access. These nodes are linked together using Phi nodes. */\
 65     /* Any two nodes that are part of the same Phi graph will share the same */\
 66     /* VariableAccessData, and thus will share predictions. FIXME: We should come up with */\
 67     /* better names for a lot of these. https://bugs.webkit.org/show_bug.cgi?id=137307. */\
 68     /* Note that GetLocal is MustGenerate because it&#39;s our only way of knowing that some other */\
 69     /* basic block might have read a local variable in bytecode. We only remove GetLocals if it */\
 70     /* is redundant because of an earlier GetLocal or SetLocal in the same block. We could make */\
 71     /* these not MustGenerate and use a more sophisticated analysis to insert PhantomLocals in */\
 72     /* the same way that we insert Phantoms. That&#39;s hard and probably not profitable. See */\
 73     /* https://bugs.webkit.org/show_bug.cgi?id=144086 */\
 74     macro(GetLocal, NodeResultJS | NodeMustGenerate) \
 75     macro(SetLocal, 0) \
 76     \
 77     /* These are used in SSA form to represent to track */\
 78     macro(PutStack, NodeMustGenerate) \
 79     macro(KillStack, NodeMustGenerate) \
 80     macro(GetStack, NodeResultJS) \
 81     \
 82     macro(MovHint, NodeMustGenerate) \
 83     macro(ZombieHint, NodeMustGenerate) \
 84     macro(ExitOK, NodeMustGenerate) /* Indicates that exit state is intact. */ \
 85     macro(Phantom, NodeMustGenerate) \
 86     macro(Check, NodeMustGenerate) /* Used if we want just a type check but not liveness. Non-checking uses will be removed. */\
 87     macro(CheckVarargs, NodeMustGenerate | NodeHasVarArgs) /* Used if we want just a type check but not liveness. Non-checking uses will be removed. */\
 88     macro(Upsilon, 0) \
 89     macro(Phi, 0) \
 90     macro(Flush, NodeMustGenerate) \
 91     macro(PhantomLocal, NodeMustGenerate) \
 92     \
 93     /* Hint that this is where bytecode thinks is a good place to OSR. Note that this */\
 94     /* will exist even in inlined loops. This has no execution semantics but it must */\
 95     /* survive all DCE. We treat this as being a can-exit because tier-up to FTL may */\
 96     /* want all state. */\
 97     macro(LoopHint, NodeMustGenerate) \
 98     \
 99     /* Special node for OSR entry into the FTL. Indicates that we&#39;re loading a local */\
100     /* variable from the scratch buffer. */\
101     macro(ExtractOSREntryLocal, NodeResultJS) \
102     macro(ExtractCatchLocal, NodeResultJS) \
103     macro(ClearCatchLocals, NodeMustGenerate) \
104     \
105     /* Tier-up checks from the DFG to the FTL. */\
106     macro(CheckTierUpInLoop, NodeMustGenerate) \
107     macro(CheckTierUpAndOSREnter, NodeMustGenerate) \
108     macro(CheckTierUpAtReturn, NodeMustGenerate) \
109     \
110     /* Marker for an argument being set at the prologue of a function. The argument is guaranteed to be set after this node. */\
111     macro(SetArgumentDefinitely, 0) \
112     /* A marker like the above that we use to track variable liveness and OSR exit state. However, it&#39;s not guaranteed to be set. To verify it was set, you&#39;d need to check the actual argument length. We use this for varargs when we&#39;re unsure how many argument may actually end up on the stack. */\
113     macro(SetArgumentMaybe, 0) \
114     \
115     /* Marker of location in the IR where we may possibly perform jump replacement to */\
116     /* invalidate this code block. */\
117     macro(InvalidationPoint, NodeMustGenerate) \
118     \
119     /* Nodes for bitwise operations. */\
120     macro(ValueBitNot, NodeResultJS | NodeMustGenerate) \
121     macro(ArithBitNot, NodeResultInt32) \
122     macro(ValueBitAnd, NodeResultJS | NodeMustGenerate) \
123     macro(ArithBitAnd, NodeResultInt32) \
124     macro(ValueBitOr, NodeResultJS | NodeMustGenerate) \
125     macro(ArithBitOr, NodeResultInt32) \
126     macro(ValueBitXor, NodeResultJS | NodeMustGenerate) \
127     macro(ArithBitXor, NodeResultInt32) \
128     macro(ArithBitLShift, NodeResultInt32) \
129     macro(ValueBitLShift, NodeResultJS | NodeMustGenerate) \
130     macro(ArithBitRShift, NodeResultInt32) \
131     macro(ValueBitRShift, NodeResultJS | NodeMustGenerate) \
132     macro(BitURShift, NodeResultInt32) \
133     /* Bitwise operators call ToInt32 on their operands. */\
134     macro(ValueToInt32, NodeResultInt32) \
135     /* Used to box the result of URShift nodes (result has range 0..2^32-1). */\
136     macro(UInt32ToNumber, NodeResultNumber) \
137     /* Converts booleans to numbers but passes everything else through. */\
138     macro(BooleanToNumber, NodeResultJS) \
139     \
140     /* Attempt to truncate a double to int32; this will exit if it can&#39;t do it. */\
141     macro(DoubleAsInt32, NodeResultInt32) \
142     \
143     /* Change the representation of a value. */\
144     macro(DoubleRep, NodeResultDouble) \
145     macro(Int52Rep, NodeResultInt52) \
146     macro(ValueRep, NodeResultJS) \
147     \
148     /* Bogus type asserting node. Useful for testing, disappears during Fixup. */\
149     macro(FiatInt52, NodeResultJS) \
150     \
151     /* Nodes for arithmetic operations. Note that if they do checks other than just type checks, */\
152     /* then they are MustGenerate. This is probably stricter than it needs to be - for example */\
153     /* they won&#39;t do checks if they are speculated double. Also, we could kill these if we do it */\
154     /* before AI starts eliminating downstream operations based on proofs, for example in the */\
155     /* case of &quot;var tmp = a + b; return (tmp | 0) == tmp;&quot;. If a, b are speculated integer then */\
156     /* this is only true if we do the overflow check - hence the need to keep it alive. More */\
157     /* generally, we need to keep alive any operation whose checks cause filtration in AI. */\
158     macro(ArithAdd, NodeResultNumber | NodeMustGenerate) \
159     macro(ArithClz32, NodeResultInt32 | NodeMustGenerate) \
160     macro(ArithSub, NodeResultNumber | NodeMustGenerate) \
161     macro(ArithNegate, NodeResultNumber | NodeMustGenerate) \
162     macro(ArithMul, NodeResultNumber | NodeMustGenerate) \
163     macro(ArithIMul, NodeResultInt32) \
164     macro(ArithDiv, NodeResultNumber | NodeMustGenerate) \
165     macro(ArithMod, NodeResultNumber | NodeMustGenerate) \
166     macro(ArithAbs, NodeResultNumber | NodeMustGenerate) \
167     macro(ArithMin, NodeResultNumber) \
168     macro(ArithMax, NodeResultNumber) \
169     macro(ArithFRound, NodeResultDouble | NodeMustGenerate) \
170     macro(ArithPow, NodeResultDouble) \
171     macro(ArithRandom, NodeResultDouble | NodeMustGenerate) \
172     macro(ArithRound, NodeResultNumber | NodeMustGenerate) \
173     macro(ArithFloor, NodeResultNumber | NodeMustGenerate) \
174     macro(ArithCeil, NodeResultNumber | NodeMustGenerate) \
175     macro(ArithTrunc, NodeResultNumber | NodeMustGenerate) \
176     macro(ArithSqrt, NodeResultDouble | NodeMustGenerate) \
177     macro(ArithUnary, NodeResultDouble | NodeMustGenerate) \
178     \
179     /* BigInt is a valid operand for these three operations */\
180     /* Inc and Dec don&#39;t update their operand in-place, they are typically combined with some form of SetLocal */\
181     macro(Inc, NodeResultJS | NodeMustGenerate) \
182     macro(Dec, NodeResultJS | NodeMustGenerate) \
183     macro(ValueNegate, NodeResultJS | NodeMustGenerate) \
184     \
185     /* Add of values may either be arithmetic, or result in string concatenation. */\
186     macro(ValueAdd, NodeResultJS | NodeMustGenerate) \
187     \
188     macro(ValueSub, NodeResultJS | NodeMustGenerate) \
189     macro(ValueMul, NodeResultJS | NodeMustGenerate) \
190     macro(ValueDiv, NodeResultJS | NodeMustGenerate) \
191     macro(ValuePow, NodeResultJS | NodeMustGenerate) \
192     macro(ValueMod, NodeResultJS | NodeMustGenerate) \
193     \
194     /* Add of values that always convers its inputs to strings. May have two or three kids. */\
195     macro(StrCat, NodeResultJS | NodeMustGenerate) \
196     \
197     /* Property access. */\
198     /* PutByValAlias indicates a &#39;put&#39; aliases a prior write to the same property. */\
199     /* Since a put to &#39;length&#39; may invalidate optimizations here, */\
200     /* this must be the directly subsequent property put. Note that PutByVal */\
201     /* opcodes use VarArgs beause they may have up to 4 children. */\
202     macro(GetByVal, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
203     macro(GetByValWithThis, NodeResultJS | NodeMustGenerate) \
204     macro(GetMyArgumentByVal, NodeResultJS | NodeMustGenerate) \
205     macro(GetMyArgumentByValOutOfBounds, NodeResultJS | NodeMustGenerate) \
206     macro(VarargsLength, NodeMustGenerate | NodeResultInt32) \
207     macro(LoadVarargs, NodeMustGenerate) \
208     macro(ForwardVarargs, NodeMustGenerate) \
209     macro(PutByValDirect, NodeMustGenerate | NodeHasVarArgs) \
210     macro(PutByVal, NodeMustGenerate | NodeHasVarArgs) \
211     macro(PutByValAlias, NodeMustGenerate | NodeHasVarArgs) \
212     macro(TryGetById, NodeResultJS) \
213     macro(GetById, NodeResultJS | NodeMustGenerate) \
214     macro(GetByIdFlush, NodeResultJS | NodeMustGenerate) \
215     macro(GetByIdWithThis, NodeResultJS | NodeMustGenerate) \
216     macro(GetByIdDirect, NodeResultJS | NodeMustGenerate) \
217     macro(GetByIdDirectFlush, NodeResultJS | NodeMustGenerate) \
218     macro(PutById, NodeMustGenerate) \
219     macro(PutByIdFlush, NodeMustGenerate) \
220     macro(PutByIdDirect, NodeMustGenerate) \
221     macro(PutByIdWithThis, NodeMustGenerate) \
222     macro(PutByValWithThis, NodeMustGenerate | NodeHasVarArgs) \
223     macro(PutGetterById, NodeMustGenerate) \
224     macro(PutSetterById, NodeMustGenerate) \
225     macro(PutGetterSetterById, NodeMustGenerate) \
226     macro(PutGetterByVal, NodeMustGenerate) \
227     macro(PutSetterByVal, NodeMustGenerate) \
228     macro(DefineDataProperty, NodeMustGenerate | NodeHasVarArgs) \
229     macro(DefineAccessorProperty, NodeMustGenerate | NodeHasVarArgs) \
230     macro(DeleteById, NodeResultBoolean | NodeMustGenerate) \
231     macro(DeleteByVal, NodeResultBoolean | NodeMustGenerate) \
232     macro(CheckStructure, NodeMustGenerate) \
233     macro(CheckStructureOrEmpty, NodeMustGenerate) \
234     macro(GetExecutable, NodeResultJS) \
235     macro(PutStructure, NodeMustGenerate) \
236     macro(AllocatePropertyStorage, NodeMustGenerate | NodeResultStorage) \
237     macro(ReallocatePropertyStorage, NodeMustGenerate | NodeResultStorage) \
238     macro(GetButterfly, NodeResultStorage) \
239     macro(NukeStructureAndSetButterfly, NodeMustGenerate) \
240     macro(CheckArray, NodeMustGenerate) \
241     macro(CheckArrayOrEmpty, NodeMustGenerate) \
242     /* This checks if the edge is a typed array and if it is neutered. */ \
243     macro(CheckNeutered, NodeMustGenerate) \
244     macro(Arrayify, NodeMustGenerate) \
245     macro(ArrayifyToStructure, NodeMustGenerate) \
246     macro(GetIndexedPropertyStorage, NodeResultStorage) \
247     macro(ConstantStoragePointer, NodeResultStorage) \
248     macro(GetGetter, NodeResultJS) \
249     macro(GetSetter, NodeResultJS) \
250     macro(GetByOffset, NodeResultJS) \
251     macro(GetGetterSetterByOffset, NodeResultJS) \
252     macro(MultiGetByOffset, NodeResultJS | NodeMustGenerate) \
253     macro(PutByOffset, NodeMustGenerate) \
254     macro(MultiPutByOffset, NodeMustGenerate) \
255     macro(GetArrayLength, NodeResultInt32) \
256     macro(GetVectorLength, NodeResultInt32) \
257     macro(GetTypedArrayByteOffset, NodeResultInt32) \
258     macro(GetScope, NodeResultJS) \
259     macro(SkipScope, NodeResultJS) \
260     macro(ResolveScope, NodeResultJS | NodeMustGenerate) \
261     macro(ResolveScopeForHoistingFuncDeclInEval, NodeResultJS | NodeMustGenerate) \
262     macro(GetGlobalObject, NodeResultJS) \
263     macro(GetGlobalThis, NodeResultJS) \
264     macro(GetClosureVar, NodeResultJS) \
265     macro(PutClosureVar, NodeMustGenerate) \
266     macro(GetGlobalVar, NodeResultJS) \
267     macro(GetGlobalLexicalVariable, NodeResultJS) \
268     macro(PutGlobalVariable, NodeMustGenerate) \
269     macro(GetDynamicVar, NodeResultJS | NodeMustGenerate) \
270     macro(PutDynamicVar, NodeMustGenerate) \
271     macro(NotifyWrite, NodeMustGenerate) \
272     macro(GetRegExpObjectLastIndex, NodeResultJS) \
273     macro(SetRegExpObjectLastIndex, NodeMustGenerate) \
274     macro(RecordRegExpCachedResult, NodeMustGenerate | NodeHasVarArgs) \
275     macro(CheckCell, NodeMustGenerate) \
276     macro(CheckNotEmpty, NodeMustGenerate) \
277     macro(AssertNotEmpty, NodeMustGenerate) \
278     macro(CheckBadCell, NodeMustGenerate) \
279     macro(CheckInBounds, NodeMustGenerate | NodeResultJS) \
280     macro(CheckIdent, NodeMustGenerate) \
281     macro(CheckTypeInfoFlags, NodeMustGenerate) /* Takes an OpInfo with the flags you want to test are set */\
282     macro(CheckSubClass, NodeMustGenerate) \
283     macro(ParseInt, NodeMustGenerate | NodeResultJS) \
284     macro(GetPrototypeOf, NodeMustGenerate | NodeResultJS) \
285     macro(ObjectCreate, NodeMustGenerate | NodeResultJS) \
286     macro(ObjectKeys, NodeMustGenerate | NodeResultJS) \
287     \
288     /* Atomics object functions. */\
289     macro(AtomicsAdd, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
290     macro(AtomicsAnd, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
291     macro(AtomicsCompareExchange, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
292     macro(AtomicsExchange, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
293     macro(AtomicsIsLockFree, NodeResultBoolean) \
294     macro(AtomicsLoad, NodeResultJS | NodeMustGenerate) \
295     macro(AtomicsOr, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
296     macro(AtomicsStore, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
297     macro(AtomicsSub, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
298     macro(AtomicsXor, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
299     \
300     /* Optimizations for array mutation. */\
301     macro(ArrayPush, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
302     macro(ArrayPop, NodeResultJS | NodeMustGenerate) \
303     macro(ArraySlice, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
304     macro(ArrayIndexOf, NodeResultInt32 | NodeHasVarArgs) \
305     \
306     /* Optimizations for regular expression matching. */\
307     macro(RegExpExec, NodeResultJS | NodeMustGenerate) \
308     macro(RegExpExecNonGlobalOrSticky, NodeResultJS) \
309     macro(RegExpTest, NodeResultJS | NodeMustGenerate) \
310     macro(RegExpMatchFast, NodeResultJS | NodeMustGenerate) \
311     macro(RegExpMatchFastGlobal, NodeResultJS) \
312     macro(StringReplace, NodeResultJS | NodeMustGenerate) \
313     macro(StringReplaceRegExp, NodeResultJS | NodeMustGenerate) \
314     \
315     /* Optimizations for string access */ \
316     macro(StringCharCodeAt, NodeResultInt32) \
317     macro(StringCodePointAt, NodeResultInt32) \
318     macro(StringCharAt, NodeResultJS) \
319     macro(StringFromCharCode, NodeResultJS | NodeMustGenerate) \
320     \
321     /* Nodes for comparison operations. */\
322     macro(CompareLess, NodeResultBoolean | NodeMustGenerate) \
323     macro(CompareLessEq, NodeResultBoolean | NodeMustGenerate) \
324     macro(CompareGreater, NodeResultBoolean | NodeMustGenerate) \
325     macro(CompareGreaterEq, NodeResultBoolean | NodeMustGenerate) \
326     macro(CompareBelow, NodeResultBoolean) \
327     macro(CompareBelowEq, NodeResultBoolean) \
328     macro(CompareEq, NodeResultBoolean | NodeMustGenerate) \
329     macro(CompareStrictEq, NodeResultBoolean) \
330     macro(CompareEqPtr, NodeResultBoolean) \
331     macro(SameValue, NodeResultBoolean) \
332     \
333     /* Calls. */\
334     macro(Call, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
335     macro(DirectCall, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
336     macro(Construct, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
337     macro(DirectConstruct, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
338     macro(CallVarargs, NodeResultJS | NodeMustGenerate) \
339     macro(CallForwardVarargs, NodeResultJS | NodeMustGenerate) \
340     macro(ConstructVarargs, NodeResultJS | NodeMustGenerate) \
341     macro(ConstructForwardVarargs, NodeResultJS | NodeMustGenerate) \
342     macro(TailCallInlinedCaller, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
343     macro(DirectTailCallInlinedCaller, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
344     macro(TailCallVarargsInlinedCaller, NodeResultJS | NodeMustGenerate) \
345     macro(TailCallForwardVarargsInlinedCaller, NodeResultJS | NodeMustGenerate) \
346     macro(CallEval, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
347     \
348     /* Shadow Chicken */\
349     macro(LogShadowChickenPrologue, NodeMustGenerate) \
350     macro(LogShadowChickenTail, NodeMustGenerate) \
351     \
352     /* Allocations. */\
353     macro(NewObject, NodeResultJS) \
354     macro(NewPromise, NodeResultJS) \
355     macro(NewGenerator, NodeResultJS) \
356     macro(NewAsyncGenerator, NodeResultJS) \
357     macro(NewArray, NodeResultJS | NodeHasVarArgs) \
358     macro(NewArrayWithSpread, NodeResultJS | NodeHasVarArgs) \
359     macro(NewArrayWithSize, NodeResultJS | NodeMustGenerate) \
360     macro(NewArrayBuffer, NodeResultJS) \
361     macro(NewArrayIterator, NodeResultJS) \
362     macro(NewTypedArray, NodeResultJS | NodeMustGenerate) \
363     macro(NewRegexp, NodeResultJS) \
364     macro(NewSymbol, NodeResultJS) \
365     macro(NewStringObject, NodeResultJS) \
366     /* Rest Parameter */\
367     macro(GetRestLength, NodeResultInt32) \
368     macro(CreateRest, NodeResultJS | NodeMustGenerate) \
369     \
370     macro(Spread, NodeResultJS | NodeMustGenerate) \
371     /* Support for allocation sinking. */\
372     macro(PhantomNewObject, NodeResultJS | NodeMustGenerate) \
373     macro(PutHint, NodeMustGenerate) \
374     macro(CheckStructureImmediate, NodeMustGenerate) \
375     macro(MaterializeNewObject, NodeResultJS | NodeHasVarArgs) \
376     macro(PhantomNewFunction, NodeResultJS | NodeMustGenerate) \
377     macro(PhantomNewGeneratorFunction, NodeResultJS | NodeMustGenerate) \
378     macro(PhantomNewAsyncFunction, NodeResultJS | NodeMustGenerate) \
379     macro(PhantomNewAsyncGeneratorFunction, NodeResultJS | NodeMustGenerate) \
380     macro(PhantomNewArrayIterator, NodeResultJS | NodeMustGenerate) \
381     macro(MaterializeNewInternalFieldObject, NodeResultJS | NodeHasVarArgs) \
382     macro(PhantomCreateActivation, NodeResultJS | NodeMustGenerate) \
383     macro(MaterializeCreateActivation, NodeResultJS | NodeHasVarArgs) \
384     macro(PhantomNewRegexp, NodeResultJS | NodeMustGenerate) \
385     \
386     /* Nodes for misc operations. */\
387     macro(OverridesHasInstance, NodeMustGenerate | NodeResultBoolean) \
388     macro(InstanceOf, NodeMustGenerate | NodeResultBoolean) \
389     macro(InstanceOfCustom, NodeMustGenerate | NodeResultBoolean) \
390     macro(MatchStructure, NodeMustGenerate | NodeResultBoolean) \
391     \
392     macro(IsCellWithType, NodeResultBoolean) \
393     macro(IsEmpty, NodeResultBoolean) \
394     macro(IsUndefined, NodeResultBoolean) \
395     macro(IsUndefinedOrNull, NodeResultBoolean) \
396     macro(IsBoolean, NodeResultBoolean) \
397     macro(IsNumber, NodeResultBoolean) \
398     macro(NumberIsInteger, NodeResultBoolean) \
399     macro(IsObject, NodeResultBoolean) \
400     macro(IsObjectOrNull, NodeResultBoolean) \
401     macro(IsFunction, NodeResultBoolean) \
402     macro(IsTypedArrayView, NodeResultBoolean) \
403     macro(TypeOf, NodeResultJS) \
404     macro(LogicalNot, NodeResultBoolean) \
405     macro(ToPrimitive, NodeResultJS | NodeMustGenerate) \
406     macro(ToPropertyKey, NodeResultJS | NodeMustGenerate) \
407     macro(ToString, NodeResultJS | NodeMustGenerate) \
408     macro(ToNumber, NodeResultJS | NodeMustGenerate) \
409     macro(ToNumeric, NodeResultJS | NodeMustGenerate) \
410     macro(ToObject, NodeResultJS | NodeMustGenerate) \
411     macro(CallObjectConstructor, NodeResultJS) \
412     macro(CallStringConstructor, NodeResultJS | NodeMustGenerate) \
413     macro(NumberToStringWithRadix, NodeResultJS | NodeMustGenerate) \
414     macro(NumberToStringWithValidRadixConstant, NodeResultJS) \
415     macro(MakeRope, NodeResultJS) \
416     macro(InByVal, NodeResultBoolean | NodeMustGenerate) \
417     macro(InById, NodeResultBoolean | NodeMustGenerate) \
418     macro(ProfileType, NodeMustGenerate) \
419     macro(ProfileControlFlow, NodeMustGenerate) \
420     macro(SetFunctionName, NodeMustGenerate) \
421     macro(HasOwnProperty, NodeResultBoolean) \
422     \
423     macro(GetInternalField, NodeResultJS) \
424     macro(PutInternalField, NodeMustGenerate) \
425     \
426     macro(CreateActivation, NodeResultJS) \
427     macro(PushWithScope, NodeResultJS | NodeMustGenerate) \
428     \
429     macro(CreateDirectArguments, NodeResultJS) \
430     macro(PhantomDirectArguments, NodeResultJS | NodeMustGenerate) \
431     macro(PhantomCreateRest, NodeResultJS | NodeMustGenerate) \
432     macro(PhantomSpread, NodeResultJS | NodeMustGenerate) \
433     macro(PhantomNewArrayWithSpread, NodeResultJS | NodeMustGenerate | NodeHasVarArgs) \
434     macro(PhantomNewArrayBuffer, NodeResultJS | NodeMustGenerate) \
435     macro(CreateScopedArguments, NodeResultJS) \
436     macro(CreateClonedArguments, NodeResultJS) \
437     macro(PhantomClonedArguments, NodeResultJS | NodeMustGenerate) \
438     macro(CreateArgumentsButterfly, NodeResultJS) \
439     macro(GetFromArguments, NodeResultJS) \
440     macro(PutToArguments, NodeMustGenerate) \
441     macro(GetArgument, NodeResultJS) \
442     \
443     macro(NewFunction, NodeResultJS) \
444     macro(NewGeneratorFunction, NodeResultJS) \
445     macro(NewAsyncGeneratorFunction, NodeResultJS) \
446     macro(NewAsyncFunction, NodeResultJS) \
447     \
448     /* Block terminals. */\
449     macro(Jump, NodeMustGenerate) \
450     macro(Branch, NodeMustGenerate) \
451     macro(Switch, NodeMustGenerate) \
452     macro(EntrySwitch, NodeMustGenerate) \
453     macro(Return, NodeMustGenerate) \
454     macro(TailCall, NodeMustGenerate | NodeHasVarArgs) \
455     macro(DirectTailCall, NodeMustGenerate | NodeHasVarArgs) \
456     macro(TailCallVarargs, NodeMustGenerate) \
457     macro(TailCallForwardVarargs, NodeMustGenerate) \
458     macro(Unreachable, NodeMustGenerate) \
459     macro(Throw, NodeMustGenerate) \
460     macro(ThrowStaticError, NodeMustGenerate) \
461     \
462     /* Count execution. */\
463     macro(CountExecution, NodeMustGenerate) \
464     /* Super sampler. */\
465     macro(SuperSamplerBegin, NodeMustGenerate) \
466     macro(SuperSamplerEnd, NodeMustGenerate) \
467     \
468     /* This is a pseudo-terminal. It means that execution should fall out of DFG at */\
469     /* this point, but execution does continue in the basic block - just in a */\
470     /* different compiler. */\
471     macro(ForceOSRExit, NodeMustGenerate) \
472     \
473     /* Vends a bottom JS value. It is invalid to ever execute this. Useful for cases */\
474     /* where we know that we would have exited but we&#39;d like to still track the control */\
475     /* flow. */\
476     macro(BottomValue, NodeResultJS) \
477     \
478     /* Checks for VM traps. If there is a trap, we&#39;ll jettison or call operation operationHandleTraps. */ \
479     macro(CheckTraps, NodeMustGenerate) \
480     /* Write barriers */\
481     macro(StoreBarrier, NodeMustGenerate) \
482     macro(FencedStoreBarrier, NodeMustGenerate) \
483     \
484     /* For-in enumeration opcodes */\
485     macro(GetEnumerableLength, NodeMustGenerate | NodeResultJS) \
486     macro(HasIndexedProperty, NodeResultBoolean | NodeHasVarArgs) \
487     macro(HasStructureProperty, NodeResultBoolean) \
488     macro(HasGenericProperty, NodeResultBoolean) \
489     macro(GetDirectPname, NodeMustGenerate | NodeHasVarArgs | NodeResultJS) \
490     macro(GetPropertyEnumerator, NodeMustGenerate | NodeResultJS) \
491     macro(GetEnumeratorStructurePname, NodeMustGenerate | NodeResultJS) \
492     macro(GetEnumeratorGenericPname, NodeMustGenerate | NodeResultJS) \
493     macro(ToIndexString, NodeResultJS) \
494     /* Nodes for JSMap and JSSet */ \
495     macro(MapHash, NodeResultInt32) \
496     macro(NormalizeMapKey, NodeResultJS) \
497     macro(GetMapBucket, NodeResultJS) \
498     macro(GetMapBucketHead, NodeResultJS) \
499     macro(GetMapBucketNext, NodeResultJS) \
500     macro(LoadKeyFromMapBucket, NodeResultJS) \
501     macro(LoadValueFromMapBucket, NodeResultJS) \
502     macro(SetAdd, NodeMustGenerate | NodeResultJS) \
503     macro(MapSet, NodeMustGenerate | NodeHasVarArgs | NodeResultJS) \
504     /* Nodes for JSWeakMap and JSWeakSet */ \
505     macro(WeakMapGet, NodeResultJS) \
506     macro(WeakSetAdd, NodeMustGenerate) \
507     macro(WeakMapSet, NodeMustGenerate | NodeHasVarArgs) \
508     macro(ExtractValueFromWeakMapGet, NodeResultJS) \
509     \
510     macro(StringValueOf, NodeMustGenerate | NodeResultJS) \
511     macro(StringSlice, NodeResultJS) \
512     macro(ToLowerCase, NodeResultJS) \
513     /* Nodes for DOM JIT */\
514     macro(CallDOMGetter, NodeResultJS | NodeMustGenerate) \
515     macro(CallDOM, NodeResultJS | NodeMustGenerate) \
516     /* Metadata node that initializes the state for flushed argument types at an entrypoint in the program. */ \
517     /* Currently, we only use this for the blocks an EntrySwitch branches to at the root of the program. */ \
518     /* This is only used in SSA. */ \
519     macro(InitializeEntrypointArguments, NodeMustGenerate) \
520     \
521     /* Used for $vm performance debugging */ \
522     macro(CPUIntrinsic, NodeResultJS | NodeMustGenerate) \
523     \
524     /* Used to provide feedback to the IC profiler. */ \
525     macro(FilterCallLinkStatus, NodeMustGenerate) \
526     macro(FilterGetByStatus, NodeMustGenerate) \
527     macro(FilterInByIdStatus, NodeMustGenerate) \
528     macro(FilterPutByIdStatus, NodeMustGenerate) \
529     /* Data view access */ \
530     macro(DataViewGetInt, NodeMustGenerate | NodeResultJS) /* The gets are must generate for now because they do bounds checks */ \
531     macro(DataViewGetFloat, NodeMustGenerate | NodeResultDouble) \
532     macro(DataViewSet, NodeMustGenerate | NodeMustGenerate | NodeHasVarArgs) \
533     /* Date access */ \
534     macro(DateGetInt32OrNaN, NodeResultJS) \
535     macro(DateGetTime, NodeResultDouble) \
536 
537 
538 // This enum generates a monotonically increasing id for all Node types,
539 // and is used by the subsequent enum to fill out the id (as accessed via the NodeIdMask).
540 enum NodeType {
541 #define DFG_OP_ENUM(opcode, flags) opcode,
542     FOR_EACH_DFG_OP(DFG_OP_ENUM)
543 #undef DFG_OP_ENUM
544     LastNodeType
545 };
546 
547 // Specifies the default flags for each node.
548 inline NodeFlags defaultFlags(NodeType op)
549 {
550     switch (op) {
551 #define DFG_OP_ENUM(opcode, flags) case opcode: return flags;
552     FOR_EACH_DFG_OP(DFG_OP_ENUM)
553 #undef DFG_OP_ENUM
554     default:
555         RELEASE_ASSERT_NOT_REACHED();
556         return 0;
557     }
558 }
559 
560 inline bool isAtomicsIntrinsic(NodeType op)
561 {
562     switch (op) {
563     case AtomicsAdd:
564     case AtomicsAnd:
565     case AtomicsCompareExchange:
566     case AtomicsExchange:
567     case AtomicsLoad:
568     case AtomicsOr:
569     case AtomicsStore:
570     case AtomicsSub:
571     case AtomicsXor:
572     case AtomicsIsLockFree:
573         return true;
574     default:
575         return false;
576     }
577 }
578 
579 static constexpr unsigned maxNumExtraAtomicsArgs = 2;
580 
581 inline unsigned numExtraAtomicsArgs(NodeType op)
582 {
583     switch (op) {
584     case AtomicsLoad:
585         return 0;
586     case AtomicsAdd:
587     case AtomicsAnd:
588     case AtomicsExchange:
589     case AtomicsOr:
590     case AtomicsStore:
591     case AtomicsSub:
592     case AtomicsXor:
593         return 1;
594     case AtomicsCompareExchange:
595         return 2;
596     default:
597         RELEASE_ASSERT_NOT_REACHED();
598         return 0;
599     }
600 }
601 
602 } } // namespace JSC::DFG
603 
604 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
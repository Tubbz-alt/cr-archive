diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMAbstractOperations.h b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMAbstractOperations.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMAbstractOperations.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMAbstractOperations.h
@@ -38,11 +38,11 @@
 };
 
 // An implementation of the 'named property visibility algorithm'
 // https://heycam.github.io/webidl/#dfn-named-property-visibility
 template<OverrideBuiltins overrideBuiltins, class JSClass>
-static bool isVisibleNamedProperty(JSC::ExecState& state, JSClass& thisObject, JSC::PropertyName propertyName)
+static bool isVisibleNamedProperty(JSC::JSGlobalObject& lexicalGlobalObject, JSClass& thisObject, JSC::PropertyName propertyName)
 {
     // FIXME: It seems unfortunate that have to do two lookups for the property name,
     // one for isSupportedPropertyName and one by the user of this algorithm to access
     // that property. It would be nice if we could smuggle the result, or an iterator
     // out so the duplicate lookup could be avoided.
@@ -58,11 +58,11 @@
     if (!impl.isSupportedPropertyName(propertyNameToString(propertyName)))
         return false;
 
     // 2. If O has an own property named P, then return false.
     JSC::PropertySlot slot { &thisObject, JSC::PropertySlot::InternalMethodType::VMInquiry };
-    if (JSC::JSObject::getOwnPropertySlot(&thisObject, &state, propertyName, slot))
+    if (JSC::JSObject::getOwnPropertySlot(&thisObject, &lexicalGlobalObject, propertyName, slot))
         return false;
 
     // 3. If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
     if (overrideBuiltins == OverrideBuiltins::Yes)
         return true;
@@ -70,12 +70,12 @@
     // 4. Initialize prototype to be the value of the internal [[Prototype]] property of O.
     // 5. While prototype is not null:
     //    1. If prototype is not a named properties object, and prototype has an own property named P, then return false.
     // FIXME: Implement checking for 'named properties object'.
     //    2. Set prototype to be the value of the internal [[Prototype]] property of prototype.
-    auto prototype = thisObject.getPrototypeDirect(state.vm());
-    if (prototype.isObject() && JSC::asObject(prototype)->getPropertySlot(&state, propertyName, slot))
+    auto prototype = thisObject.getPrototypeDirect(JSC::getVM(&lexicalGlobalObject));
+    if (prototype.isObject() && JSC::asObject(prototype)->getPropertySlot(&lexicalGlobalObject, propertyName, slot))
         return false;
 
     // 6. Return true.
     return true;
 }
@@ -84,11 +84,11 @@
 // 'supported property name' check with direct access to the implementation value returned
 // for the property name, via passed in functor. This allows us to avoid two looking up the
 // the property name twice; once for 'named property visibility algorithm' check, and then
 // again when the value is needed.
 template<OverrideBuiltins overrideBuiltins, class JSClass, class Functor>
-static auto accessVisibleNamedProperty(JSC::ExecState& state, JSClass& thisObject, JSC::PropertyName propertyName, Functor&& itemAccessor) -> decltype(itemAccessor(thisObject, propertyName))
+static auto accessVisibleNamedProperty(JSC::JSGlobalObject& lexicalGlobalObject, JSClass& thisObject, JSC::PropertyName propertyName, Functor&& itemAccessor) -> decltype(itemAccessor(thisObject, propertyName))
 {
     // NOTE: While it is not specified, a Symbol can never be a 'supported property
     // name' so we check that first.
     if (propertyName.isSymbol())
         return WTF::nullopt;
@@ -98,11 +98,11 @@
     if (!result)
         return WTF::nullopt;
 
     // 2. If O has an own property named P, then return false.
     JSC::PropertySlot slot { &thisObject, JSC::PropertySlot::InternalMethodType::VMInquiry };
-    if (JSC::JSObject::getOwnPropertySlot(&thisObject, &state, propertyName, slot))
+    if (JSC::JSObject::getOwnPropertySlot(&thisObject, &lexicalGlobalObject, propertyName, slot))
         return WTF::nullopt;
 
     // 3. If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
     if (overrideBuiltins == OverrideBuiltins::Yes && !worldForDOMObject(thisObject).shouldDisableOverrideBuiltinsBehavior())
         return result;
@@ -110,12 +110,12 @@
     // 4. Initialize prototype to be the value of the internal [[Prototype]] property of O.
     // 5. While prototype is not null:
     //    1. If prototype is not a named properties object, and prototype has an own property named P, then return false.
     // FIXME: Implement checking for 'named properties object'.
     //    2. Set prototype to be the value of the internal [[Prototype]] property of prototype.
-    auto prototype = thisObject.getPrototypeDirect(state.vm());
-    if (prototype.isObject() && JSC::asObject(prototype)->getPropertySlot(&state, propertyName, slot))
+    auto prototype = thisObject.getPrototypeDirect(JSC::getVM(&lexicalGlobalObject));
+    if (prototype.isObject() && JSC::asObject(prototype)->getPropertySlot(&lexicalGlobalObject, propertyName, slot))
         return WTF::nullopt;
 
     // 6. Return true.
     return result;
 }

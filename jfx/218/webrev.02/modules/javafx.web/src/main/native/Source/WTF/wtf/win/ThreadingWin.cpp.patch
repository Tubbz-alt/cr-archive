diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/win/ThreadingWin.cpp
@@ -157,11 +157,10 @@
 {
     size_t stackSize = 0;
 #if PLATFORM(JAVA) && USE(JSVALUE32_64)
     stackSize = 1024 * 1024;
 #endif
-
     unsigned threadIdentifier = 0;
     unsigned initFlag = stackSize ? STACK_SIZE_PARAM_IS_A_RESERVATION : 0;
 
     HANDLE threadHandle = reinterpret_cast<HANDLE>(_beginthreadex(0, stackSize, wtfThreadEntryPoint, data, initFlag, &threadIdentifier));
     if (!threadHandle) {
@@ -268,101 +267,70 @@
     auto locker = holdLock(m_mutex);
     m_handle = handle;
     m_id = threadID;
 }
 
-#define InvalidThread reinterpret_cast<Thread*>(static_cast<uintptr_t>(0xbbadbeef))
+struct Thread::ThreadHolder {
+    ~ThreadHolder()
+    {
+        if (thread) {
+            thread->specificStorage().destroySlots();
+            thread->didExit();
+        }
+    }
+
+    RefPtr<Thread> thread;
+};
 
-static WordLock threadMapMutex;
+thread_local static Thread::ThreadHolder s_threadHolder;
 
-static HashMap<ThreadIdentifier, Thread*>& threadMap()
+Thread* Thread::currentMayBeNull()
 {
-    static NeverDestroyed<HashMap<ThreadIdentifier, Thread*>> map;
-    return map.get();
+    return s_threadHolder.thread.get();
 }
 
-void Thread::initializeTLSKey()
+Thread& Thread::initializeTLS(Ref<Thread>&& thread)
 {
-    threadMap();
-    threadSpecificKeyCreate(&s_key, destructTLS);
+    s_threadHolder.thread = WTFMove(thread);
+    return *s_threadHolder.thread;
 }
 
-Thread* Thread::currentDying()
+Atomic<int> Thread::SpecificStorage::s_numberOfKeys;
+std::array<Atomic<Thread::SpecificStorage::DestroyFunction>, Thread::SpecificStorage::s_maxKeys> Thread::SpecificStorage::s_destroyFunctions;
+
+bool Thread::SpecificStorage::allocateKey(int& key, DestroyFunction destroy)
 {
-    ASSERT(s_key != InvalidThreadSpecificKey);
-    // After FLS is destroyed, this map offers the value until the second thread exit callback is called.
-    auto locker = holdLock(threadMapMutex);
-    return threadMap().get(currentID());
+    int k = s_numberOfKeys.exchangeAdd(1);
+    if (k >= s_maxKeys) {
+        s_numberOfKeys.exchangeSub(1);
+        return false;
+    }
+    key = k;
+    s_destroyFunctions[key].store(destroy);
+    return true;
 }
 
-RefPtr<Thread> Thread::get(ThreadIdentifier id)
+void* Thread::SpecificStorage::get(int key)
 {
-    auto locker = holdLock(threadMapMutex);
-    Thread* thread = threadMap().get(id);
-    if (thread)
-        return thread;
-    return nullptr;
+    return m_slots[key];
 }
 
-Thread& Thread::initializeTLS(Ref<Thread>&& thread)
+void Thread::SpecificStorage::set(int key, void* value)
 {
-    ASSERT(s_key != InvalidThreadSpecificKey);
-    // FIXME: Remove this workaround code once <rdar://problem/31793213> is fixed.
-    auto id = thread->id();
-    // We leak the ref to keep the Thread alive while it is held in TLS. destructTLS will deref it later at thread destruction time.
-    auto& threadInTLS = thread.leakRef();
-    threadSpecificSet(s_key, &threadInTLS);
-    {
-        auto locker = holdLock(threadMapMutex);
-        threadMap().add(id, &threadInTLS);
-    }
-    return threadInTLS;
+    m_slots[key] = value;
 }
 
-void Thread::destructTLS(void* data)
+void Thread::SpecificStorage::destroySlots()
 {
-    if (data == InvalidThread)
-        return;
-
-    Thread* thread = static_cast<Thread*>(data);
-    ASSERT(thread);
-
-    // Delay the deallocation of Thread more.
-    // It defers Thread deallocation after the other ThreadSpecific values are deallocated.
-    static thread_local class ThreadExitCallback {
-    public:
-        ThreadExitCallback(Thread* thread)
-            : m_thread(thread)
-        {
-        }
-
-        ~ThreadExitCallback()
-        {
-            Thread::destructTLS(m_thread);
-        }
-
-    private:
-        Thread* m_thread;
-    } callback(thread);
-
-    if (thread->m_isDestroyedOnce) {
-        {
-            auto locker = holdLock(threadMapMutex);
-            ASSERT(threadMap().contains(thread->id()));
-            threadMap().remove(thread->id());
+    auto numberOfKeys = s_numberOfKeys.load();
+    for (size_t i = 0; i < numberOfKeys; i++) {
+        auto destroy = s_destroyFunctions[i].load();
+        if (destroy && m_slots[i]) {
+            destroy(m_slots[i]);
+            m_slots[i] = nullptr;
         }
-        thread->didExit();
-        thread->deref();
-
-        // Fill the FLS with the non-nullptr value. While FLS destructor won't be called for that,
-        // non-nullptr value tells us that we already destructed Thread. This allows us to
-        // detect incorrect use of Thread::current() after this point because it will crash.
-        threadSpecificSet(s_key, InvalidThread);
-        return;
     }
-    threadSpecificSet(s_key, InvalidThread);
-    thread->m_isDestroyedOnce = true;
 }
 
 Mutex::~Mutex()
 {
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 24  */
 25 
 26 @globalPrivate
 27 @constructor
 28 function RegExpStringIterator(regExp, string, global, fullUnicode)
 29 {
 30     &quot;use strict&quot;;
 31 
 32     @putByIdDirectPrivate(this, &quot;regExpStringIteratorRegExp&quot;, regExp);
 33     @putByIdDirectPrivate(this, &quot;regExpStringIteratorString&quot;, string);
 34     @putByIdDirectPrivate(this, &quot;regExpStringIteratorGlobal&quot;, global);
 35     @putByIdDirectPrivate(this, &quot;regExpStringIteratorUnicode&quot;, fullUnicode);
 36     @putByIdDirectPrivate(this, &quot;regExpStringIteratorDone&quot;, false);
 37 }
 38 
 39 @globalPrivate
 40 function advanceStringIndex(string, index, unicode)
 41 {
 42     // This function implements AdvanceStringIndex described in ES6 21.2.5.2.3.
 43     &quot;use strict&quot;;
 44 
 45     if (!unicode)
 46         return index + 1;
 47 
 48     if (index + 1 &gt;= string.length)
 49         return index + 1;
 50 
 51     var first = string.@charCodeAt(index);
 52     if (first &lt; 0xD800 || first &gt; 0xDBFF)
 53         return index + 1;
 54 
 55     var second = string.@charCodeAt(index + 1);
 56     if (second &lt; 0xDC00 || second &gt; 0xDFFF)
 57         return index + 1;
 58 
 59     return index + 2;
 60 }
 61 
 62 @globalPrivate
 63 function regExpExec(regexp, str)
 64 {
 65     &quot;use strict&quot;;
 66 
 67     var exec = regexp.exec;
 68     var builtinExec = @regExpBuiltinExec;
 69     if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
 70         var result = exec.@call(regexp, str);
 71         if (result !== null &amp;&amp; !@isObject(result))
 72             @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
 73         return result;
 74     }
 75     return builtinExec.@call(regexp, str);
 76 }
 77 
 78 @globalPrivate
 79 function hasObservableSideEffectsForRegExpMatch(regexp)
 80 {
 81     &quot;use strict&quot;;
 82 
 83     if (!@isRegExpObject(regexp))
 84         return true;
 85 
 86     // This is accessed by the RegExpExec internal function.
 87     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);
 88     if (regexpExec !== @regExpBuiltinExec)
 89         return true;
 90 
 91     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);
 92     if (regexpGlobal !== @regExpProtoGlobalGetter)
 93         return true;
 94     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);
 95     if (regexpUnicode !== @regExpProtoUnicodeGetter)
 96         return true;
 97 
 98     return typeof regexp.lastIndex !== &quot;number&quot;;
 99 }
100 
101 @globalPrivate
102 function matchSlow(regexp, str)
103 {
104     &quot;use strict&quot;;
105 
106     if (!regexp.global)
107         return @regExpExec(regexp, str);
108     
109     var unicode = regexp.unicode;
110     regexp.lastIndex = 0;
111     var resultList = [];
112 
113     // FIXME: It would be great to implement a solution similar to what we do in
114     // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
115     // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
116     var maximumReasonableMatchSize = 100000000;
117 
118     while (true) {
119         var result = @regExpExec(regexp, str);
120         
121         if (result === null) {
122             if (resultList.length === 0)
123                 return null;
124             return resultList;
125         }
126 
127         if (resultList.length &gt; maximumReasonableMatchSize)
128             @throwOutOfMemoryError();
129 
130         var resultString = @toString(result[0]);
131 
132         if (!resultString.length)
133             regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
134 
135         resultList.@push(resultString);
136     }
137 }
138 
139 @overriddenName=&quot;[Symbol.match]&quot;
140 function match(strArg)
141 {
142     &quot;use strict&quot;;
143 
144     if (!@isObject(this))
145         @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
146 
147     var str = @toString(strArg);
148 
149     // Check for observable side effects and call the fast path if there aren&#39;t any.
150     if (!@hasObservableSideEffectsForRegExpMatch(this))
151         return @regExpMatchFast.@call(this, str);
152     return @matchSlow(this, str);
153 }
154 
155 @overriddenName=&quot;[Symbol.matchAll]&quot;
156 function matchAll(strArg)
157 {
158     &quot;use strict&quot;;
159 
160     var regExp = this;
161     if (!@isObject(regExp))
162         @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
163 
164     var string = @toString(strArg);
165     var Matcher = @speciesConstructor(regExp, @RegExp);
166 
167     var flags = @toString(regExp.flags);
168     var matcher = new Matcher(regExp, flags);
169     matcher.lastIndex = @toLength(regExp.lastIndex);
170 
171     var global = @stringIncludesInternal.@call(flags, &quot;g&quot;);
172     var fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);
173 
174     return new @RegExpStringIterator(matcher, string, global, fullUnicode);
175 }
176 
177 @overriddenName=&quot;[Symbol.replace]&quot;
178 function replace(strArg, replace)
179 {
180     &quot;use strict&quot;;
181 
182     function getSubstitution(matched, str, position, captures, namedCaptures, replacement)
183     {
184         &quot;use strict&quot;;
185 
186         var matchLength = matched.length;
187         var stringLength = str.length;
188         var tailPos = position + matchLength;
189         var m = captures.length;
190         var replacementLength = replacement.length;
191         var result = &quot;&quot;;
192         var lastStart = 0;
193 
194         for (var start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {
195             if (start - lastStart &gt; 0)
196                 result = result + replacement.substring(lastStart, start);
197             start++;
198             var ch = replacement.charAt(start);
199             if (ch === &quot;&quot;)
200                 result = result + &quot;$&quot;;
201             else {
202                 switch (ch)
203                 {
204                 case &quot;$&quot;:
205                     result = result + &quot;$&quot;;
206                     start++;
207                     break;
208                 case &quot;&amp;&quot;:
209                     result = result + matched;
210                     start++;
211                     break;
212                 case &quot;`&quot;:
213                     if (position &gt; 0)
214                         result = result + str.substring(0, position);
215                     start++;
216                     break;
217                 case &quot;&#39;&quot;:
218                     if (tailPos &lt; stringLength)
219                         result = result + str.substring(tailPos);
220                     start++;
221                     break;
222                 case &quot;&lt;&quot;:
223                     if (namedCaptures !== @undefined) {
224                         var groupNameStartIndex = start + 1;
225                         var groupNameEndIndex = replacement.indexOf(&quot;&gt;&quot;, groupNameStartIndex);
226                         if (groupNameEndIndex !== -1) {
227                             var groupName = replacement.substring(groupNameStartIndex, groupNameEndIndex);
228                             var capture = namedCaptures[groupName];
229                             if (capture !== @undefined)
230                                 result = result + @toString(capture);
231 
232                             start = groupNameEndIndex + 1;
233                             break;
234                         }
235                     }
236 
237                     result = result + &quot;$&lt;&quot;;
238                     start++;
239                     break;
240                 default:
241                     var chCode = ch.charCodeAt(0);
242                     if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {
243                         var originalStart = start - 1;
244                         start++;
245 
246                         var n = chCode - 0x30;
247                         if (n &gt; m) {
248                             result = result + replacement.substring(originalStart, start);
249                             break;
250                         }
251 
252                         if (start &lt; replacementLength) {
253                             var nextChCode = replacement.charCodeAt(start);
254                             if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
255                                 var nn = 10 * n + nextChCode - 0x30;
256                                 if (nn &lt;= m) {
257                                     n = nn;
258                                     start++;
259                                 }
260                             }
261                         }
262 
263                         if (n == 0) {
264                             result = result + replacement.substring(originalStart, start);
265                             break;
266                         }
267 
268                         var capture = captures[n - 1];
269                         if (capture !== @undefined)
270                             result = result + capture;
271                     } else
272                         result = result + &quot;$&quot;;
273                     break;
274                 }
275             }
276         }
277 
278         return result + replacement.substring(lastStart);
279     }
280 
281     if (!@isObject(this))
282         @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
283 
284     var regexp = this;
285 
286     var str = @toString(strArg);
287     var stringLength = str.length;
288     var functionalReplace = typeof replace === &#39;function&#39;;
289 
290     if (!functionalReplace)
291         replace = @toString(replace);
292 
293     var global = regexp.global;
294     var unicode = false;
295 
296     if (global) {
297         unicode = regexp.unicode;
298         regexp.lastIndex = 0;
299     }
300 
301     var resultList = [];
302     var result;
303     var done = false;
304     while (!done) {
305         result = @regExpExec(regexp, str);
306 
307         if (result === null)
308             done = true;
309         else {
310             resultList.@push(result);
311             if (!global)
312                 done = true;
313             else {
314                 var matchStr = @toString(result[0]);
315 
316                 if (!matchStr.length)
317                     regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
318             }
319         }
320     }
321 
322     var accumulatedResult = &quot;&quot;;
323     var nextSourcePosition = 0;
324     var lastPosition = 0;
325 
326     for (var i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {
327         var result = resultList[i];
328         var nCaptures = result.length - 1;
329         if (nCaptures &lt; 0)
330             nCaptures = 0;
331         var matched = @toString(result[0]);
332         var matchLength = matched.length;
333         var position = result.index;
334         position = (position &gt; stringLength) ? stringLength : position;
335         position = (position &lt; 0) ? 0 : position;
336 
337         var captures = [];
338         for (var n = 1; n &lt;= nCaptures; n++) {
339             var capN = result[n];
340             if (capN !== @undefined)
341                 capN = @toString(capN);
342             captures.@push(capN);
343         }
344 
345         var replacement;
346         var namedCaptures = result.groups;
347 
348         if (functionalReplace) {
349             var replacerArgs = [ matched ].concat(captures);
350             replacerArgs.@push(position);
351             replacerArgs.@push(str);
352 
353             if (namedCaptures !== @undefined)
354                 replacerArgs.@push(namedCaptures);
355 
356             var replValue = replace.@apply(@undefined, replacerArgs);
357             replacement = @toString(replValue);
358         } else {
359             if (namedCaptures !== @undefined)
360                 namedCaptures = @toObject(namedCaptures, &quot;RegExp.prototype[Symbol.replace] requires &#39;groups&#39; property of a match not be null&quot;);
361 
362             replacement = getSubstitution(matched, str, position, captures, namedCaptures, replace);
363         }
364 
365         if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
366             accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
367             nextSourcePosition = position + matchLength;
368             lastPosition = position;
369         }
370     }
371 
372     if (nextSourcePosition &gt;= stringLength)
373         return  accumulatedResult;
374 
375     return accumulatedResult + str.substring(nextSourcePosition);
376 }
377 
378 // 21.2.5.9 RegExp.prototype[@@search] (string)
379 @overriddenName=&quot;[Symbol.search]&quot;
380 function search(strArg)
381 {
382     &quot;use strict&quot;;
383 
384     var regexp = this;
385 
386     // Check for observable side effects and call the fast path if there aren&#39;t any.
387     if (@isRegExpObject(regexp)
388         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
389         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
390         return @regExpSearchFast.@call(regexp, strArg);
391 
392     // 1. Let rx be the this value.
393     // 2. If Type(rx) is not Object, throw a TypeError exception.
394     if (!@isObject(this))
395         @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
396 
397     // 3. Let S be ? ToString(string).
398     var str = @toString(strArg)
399 
400     // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
401     var previousLastIndex = regexp.lastIndex;
402 
403     // 5.If SameValue(previousLastIndex, 0) is false, then
404     // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
405     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
406     if (previousLastIndex !== 0)
407         regexp.lastIndex = 0;
408 
409     // 6. Let result be ? RegExpExec(rx, S).
410     var result = @regExpExec(regexp, str);
411 
412     // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
413     // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
414     // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
415     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
416     if (regexp.lastIndex !== previousLastIndex)
417         regexp.lastIndex = previousLastIndex;
418 
419     // 9. If result is null, return -1.
420     if (result === null)
421         return -1;
422 
423     // 10. Return ? Get(result, &quot;index&quot;).
424     return result.index;
425 }
426 
427 @globalPrivate
428 function hasObservableSideEffectsForRegExpSplit(regexp)
429 {
430     &quot;use strict&quot;;
431 
432     if (!@isRegExpObject(regexp))
433         return true;
434 
435     // This is accessed by the RegExpExec internal function.
436     var regexpExec = @tryGetById(regexp, &quot;exec&quot;);
437     if (regexpExec !== @regExpBuiltinExec)
438         return true;
439     
440     // This is accessed by step 5 below.
441     var regexpFlags = @tryGetById(regexp, &quot;flags&quot;);
442     if (regexpFlags !== @regExpProtoFlagsGetter)
443         return true;
444     
445     // These are accessed by the builtin flags getter.
446     var regexpGlobal = @tryGetById(regexp, &quot;global&quot;);
447     if (regexpGlobal !== @regExpProtoGlobalGetter)
448         return true;
449     var regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);
450     if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
451         return true;
452     var regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);
453     if (regexpMultiline !== @regExpProtoMultilineGetter)
454         return true;
455     var regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);
456     if (regexpSticky !== @regExpProtoStickyGetter)
457         return true;
458     var regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);
459     if (regexpUnicode !== @regExpProtoUnicodeGetter)
460         return true;
461     
462     // This is accessed by the RegExp species constructor.
463     var regexpSource = @tryGetById(regexp, &quot;source&quot;);
464     if (regexpSource !== @regExpProtoSourceGetter)
465         return true;
466 
467     return typeof regexp.lastIndex !== &quot;number&quot;;
468 }
469 
470 // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
471 @overriddenName=&quot;[Symbol.split]&quot;
472 function split(string, limit)
473 {
474     &quot;use strict&quot;;
475 
476     // 1. Let rx be the this value.
477     // 2. If Type(rx) is not Object, throw a TypeError exception.
478     if (!@isObject(this))
479         @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
480     var regexp = this;
481 
482     // 3. Let S be ? ToString(string).
483     var str = @toString(string);
484 
485     // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
486     var speciesConstructor = @speciesConstructor(regexp, @RegExp);
487 
488     if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
489         return @regExpSplitFast.@call(regexp, str, limit);
490 
491     // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
492     var flags = @toString(regexp.flags);
493 
494     // 6. If flags contains &quot;u&quot;, var unicodeMatching be true.
495     // 7. Else, let unicodeMatching be false.
496     var unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);
497     // 8. If flags contains &quot;y&quot;, var newFlags be flags.
498     // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
499     var newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;
500 
501     // 10. Let splitter be ? Construct(C, « rx, newFlags »).
502     var splitter = new speciesConstructor(regexp, newFlags);
503 
504     // We need to check again for RegExp subclasses that will fail the speciesConstructor test
505     // but can still use the fast path after we invoke the constructor above.
506     if (!@hasObservableSideEffectsForRegExpSplit(splitter))
507         return @regExpSplitFast.@call(splitter, str, limit);
508 
509     // 11. Let A be ArrayCreate(0).
510     // 12. Let lengthA be 0.
511     var result = [];
512 
513     // 13. If limit is undefined, let lim be 2^32-1; else var lim be ? ToUint32(limit).
514     limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
515 
516     // 16. If lim = 0, return A.
517     if (!limit)
518         return result;
519 
520     // 14. [Defered from above] Let size be the number of elements in S.
521     var size = str.length;
522 
523     // 17. If size = 0, then
524     if (!size) {
525         // a. Let z be ? RegExpExec(splitter, S).
526         var z = @regExpExec(splitter, str);
527         // b. If z is not null, return A.
528         if (z != null)
529             return result;
530         // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
531         @putByValDirect(result, 0, str);
532         // d. Return A.
533         return result;
534     }
535 
536     // 15. [Defered from above] Let p be 0.
537     var position = 0;
538     // 18. Let q be p.
539     var matchPosition = 0;
540 
541     // 19. Repeat, while q &lt; size
542     while (matchPosition &lt; size) {
543         // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
544         splitter.lastIndex = matchPosition;
545         // b. Let z be ? RegExpExec(splitter, S).
546         var matches = @regExpExec(splitter, str);
547         // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
548         if (matches === null)
549             matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
550         // d. Else z is not null,
551         else {
552             // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
553             var endPosition = @toLength(splitter.lastIndex);
554             // ii. Let e be min(e, size).
555             endPosition = (endPosition &lt;= size) ? endPosition : size;
556             // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
557             if (endPosition === position)
558                 matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
559             // iv. Else e != p,
560             else {
561                 // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
562                 var subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);
563                 // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
564                 // 3. Let lengthA be lengthA + 1.
565                 @putByValDirect(result, result.length, subStr);
566                 // 4. If lengthA = lim, return A.
567                 if (result.length == limit)
568                     return result;
569 
570                 // 5. Let p be e.
571                 position = endPosition;
572                 // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
573                 // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
574                 var numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;
575 
576                 // 8. Let i be 1.
577                 var i = 1;
578                 // 9. Repeat, while i &lt;= numberOfCaptures,
579                 while (i &lt;= numberOfCaptures) {
580                     // a. Let nextCapture be ? Get(z, ! ToString(i)).
581                     var nextCapture = matches[i];
582                     // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
583                     // d. Let lengthA be lengthA + 1.
584                     @putByValDirect(result, result.length, nextCapture);
585                     // e. If lengthA = lim, return A.
586                     if (result.length == limit)
587                         return result;
588                     // c. Let i be i + 1.
589                     i++;
590                 }
591                 // 10. Let q be p.
592                 matchPosition = position;
593             }
594         }
595     }
596     // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
597     var remainingStr = @stringSubstrInternal.@call(str, position, size);
598     // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
599     @putByValDirect(result, result.length, remainingStr);
600     // 22. Return A.
601     return result;
602 }
603 
604 // ES 21.2.5.13 RegExp.prototype.test(string)
605 @intrinsic=RegExpTestIntrinsic
606 function test(strArg)
607 {
608     &quot;use strict&quot;;
609 
610     var regexp = this;
611 
612     // Check for observable side effects and call the fast path if there aren&#39;t any.
613     if (@isRegExpObject(regexp)
614         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
615         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
616         return @regExpTestFast.@call(regexp, strArg);
617 
618     // 1. Let R be the this value.
619     // 2. If Type(R) is not Object, throw a TypeError exception.
620     if (!@isObject(regexp))
621         @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
622 
623     // 3. Let string be ? ToString(S).
624     var str = @toString(strArg);
625 
626     // 4. Let match be ? RegExpExec(R, string).
627     var match = @regExpExec(regexp, str);
628 
629     // 5. If match is not null, return true; else return false.
630     if (match !== null)
631         return true;
632     return false;
633 }
    </pre>
  </body>
</html>
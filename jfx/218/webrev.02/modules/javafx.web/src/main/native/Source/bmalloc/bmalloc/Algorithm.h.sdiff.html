<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Algorithm.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../CMakeLists.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AllIsoHeaps.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Algorithm.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef Algorithm_h
 27 #define Algorithm_h
 28 
 29 #include &quot;BAssert.h&quot;
 30 #include &lt;algorithm&gt;

 31 #include &lt;cstdint&gt;
 32 #include &lt;cstddef&gt;
 33 #include &lt;limits&gt;
 34 #include &lt;string.h&gt;
 35 #include &lt;type_traits&gt;
 36 #include &lt;chrono&gt;
 37 
 38 namespace bmalloc {
 39 
 40 // Versions of min and max that are compatible with compile-time constants.
 41 template&lt;typename T&gt; constexpr T max(T a, T b)
 42 {
 43     return a &gt; b ? a : b;
 44 }
 45 
 46 template&lt;typename T&gt; constexpr T min(T a, T b)
 47 {
 48     return a &lt; b ? a : b;
 49 }
 50 
</pre>
<hr />
<pre>
112 {
113     BASSERT(isPowerOfTwo(divisor));
114     return reinterpret_cast&lt;T*&gt;(mask(reinterpret_cast&lt;uintptr_t&gt;(x), ~(divisor - 1ul)));
115 }
116 
117 template&lt;size_t divisor, typename T&gt; constexpr T roundDownToMultipleOf(T x)
118 {
119     static_assert(isPowerOfTwo(divisor), &quot;&#39;divisor&#39; must be a power of two.&quot;);
120     return roundDownToMultipleOf(divisor, x);
121 }
122 
123 template&lt;typename T&gt; inline void divideRoundingUp(T numerator, T denominator, T&amp; quotient, T&amp; remainder)
124 {
125     // We expect the compiler to emit a single divide instruction to extract both the quotient and the remainder.
126     quotient = numerator / denominator;
127     remainder = numerator % denominator;
128     if (remainder)
129         quotient += 1;
130 }
131 
<span class="line-modified">132 template&lt;typename T&gt; inline T divideRoundingUp(T numerator, T denominator)</span>
133 {
134     return (numerator + denominator - 1) / denominator;
135 }
136 
137 template&lt;typename T&gt; inline T roundUpToMultipleOfNonPowerOfTwo(size_t divisor, T x)
138 {
139     return divideRoundingUp(x, divisor) * divisor;
140 }
141 
142 // Version of sizeof that returns 0 for empty classes.
143 
144 template&lt;typename T&gt; constexpr size_t sizeOf()
145 {
146     return std::is_empty&lt;T&gt;::value ? 0 : sizeof(T);
147 }
148 
149 template&lt;typename T&gt; constexpr size_t bitCount()
150 {
151     return sizeof(T) * 8;
152 }
</pre>
<hr />
<pre>
176 #define BOFFSETOF(class, field) (reinterpret_cast&lt;ptrdiff_t&gt;(&amp;(reinterpret_cast&lt;class*&gt;(0x4000)-&gt;field)) - 0x4000)
177 
178 template&lt;typename T&gt;
179 bool findBitInWord(T word, size_t&amp; index, size_t endIndex, bool value)
180 {
181     static_assert(std::is_unsigned&lt;T&gt;::value, &quot;Type used in findBitInWord must be unsigned&quot;);
182 
183     word &gt;&gt;= index;
184 
185     while (index &lt; endIndex) {
186         if ((word &amp; 1) == static_cast&lt;T&gt;(value))
187             return true;
188         index++;
189         word &gt;&gt;= 1;
190     }
191 
192     index = endIndex;
193     return false;
194 }
195 

























196 } // namespace bmalloc
197 
198 #endif // Algorithm_h
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef Algorithm_h
 27 #define Algorithm_h
 28 
 29 #include &quot;BAssert.h&quot;
 30 #include &lt;algorithm&gt;
<span class="line-added"> 31 #include &lt;climits&gt;</span>
 32 #include &lt;cstdint&gt;
 33 #include &lt;cstddef&gt;
 34 #include &lt;limits&gt;
 35 #include &lt;string.h&gt;
 36 #include &lt;type_traits&gt;
 37 #include &lt;chrono&gt;
 38 
 39 namespace bmalloc {
 40 
 41 // Versions of min and max that are compatible with compile-time constants.
 42 template&lt;typename T&gt; constexpr T max(T a, T b)
 43 {
 44     return a &gt; b ? a : b;
 45 }
 46 
 47 template&lt;typename T&gt; constexpr T min(T a, T b)
 48 {
 49     return a &lt; b ? a : b;
 50 }
 51 
</pre>
<hr />
<pre>
113 {
114     BASSERT(isPowerOfTwo(divisor));
115     return reinterpret_cast&lt;T*&gt;(mask(reinterpret_cast&lt;uintptr_t&gt;(x), ~(divisor - 1ul)));
116 }
117 
118 template&lt;size_t divisor, typename T&gt; constexpr T roundDownToMultipleOf(T x)
119 {
120     static_assert(isPowerOfTwo(divisor), &quot;&#39;divisor&#39; must be a power of two.&quot;);
121     return roundDownToMultipleOf(divisor, x);
122 }
123 
124 template&lt;typename T&gt; inline void divideRoundingUp(T numerator, T denominator, T&amp; quotient, T&amp; remainder)
125 {
126     // We expect the compiler to emit a single divide instruction to extract both the quotient and the remainder.
127     quotient = numerator / denominator;
128     remainder = numerator % denominator;
129     if (remainder)
130         quotient += 1;
131 }
132 
<span class="line-modified">133 template&lt;typename T&gt; constexpr T divideRoundingUp(T numerator, T denominator)</span>
134 {
135     return (numerator + denominator - 1) / denominator;
136 }
137 
138 template&lt;typename T&gt; inline T roundUpToMultipleOfNonPowerOfTwo(size_t divisor, T x)
139 {
140     return divideRoundingUp(x, divisor) * divisor;
141 }
142 
143 // Version of sizeof that returns 0 for empty classes.
144 
145 template&lt;typename T&gt; constexpr size_t sizeOf()
146 {
147     return std::is_empty&lt;T&gt;::value ? 0 : sizeof(T);
148 }
149 
150 template&lt;typename T&gt; constexpr size_t bitCount()
151 {
152     return sizeof(T) * 8;
153 }
</pre>
<hr />
<pre>
177 #define BOFFSETOF(class, field) (reinterpret_cast&lt;ptrdiff_t&gt;(&amp;(reinterpret_cast&lt;class*&gt;(0x4000)-&gt;field)) - 0x4000)
178 
179 template&lt;typename T&gt;
180 bool findBitInWord(T word, size_t&amp; index, size_t endIndex, bool value)
181 {
182     static_assert(std::is_unsigned&lt;T&gt;::value, &quot;Type used in findBitInWord must be unsigned&quot;);
183 
184     word &gt;&gt;= index;
185 
186     while (index &lt; endIndex) {
187         if ((word &amp; 1) == static_cast&lt;T&gt;(value))
188             return true;
189         index++;
190         word &gt;&gt;= 1;
191     }
192 
193     index = endIndex;
194     return false;
195 }
196 
<span class="line-added">197 template &lt;typename T&gt;</span>
<span class="line-added">198 constexpr unsigned ctzConstexpr(T value)</span>
<span class="line-added">199 {</span>
<span class="line-added">200     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;</span>
<span class="line-added">201 </span>
<span class="line-added">202     using UT = typename std::make_unsigned&lt;T&gt;::type;</span>
<span class="line-added">203     UT uValue = value;</span>
<span class="line-added">204 </span>
<span class="line-added">205     unsigned zeroCount = 0;</span>
<span class="line-added">206     for (unsigned i = 0; i &lt; bitSize; i++) {</span>
<span class="line-added">207         if (uValue &amp; 1)</span>
<span class="line-added">208             break;</span>
<span class="line-added">209 </span>
<span class="line-added">210         zeroCount++;</span>
<span class="line-added">211         uValue &gt;&gt;= 1;</span>
<span class="line-added">212     }</span>
<span class="line-added">213     return zeroCount;</span>
<span class="line-added">214 }</span>
<span class="line-added">215 </span>
<span class="line-added">216 template&lt;typename T&gt;</span>
<span class="line-added">217 constexpr unsigned getLSBSetNonZeroConstexpr(T t)</span>
<span class="line-added">218 {</span>
<span class="line-added">219     return ctzConstexpr(t);</span>
<span class="line-added">220 }</span>
<span class="line-added">221 </span>
222 } // namespace bmalloc
223 
224 #endif // Algorithm_h
</pre>
</td>
</tr>
</table>
<center><a href="../CMakeLists.txt.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AllIsoHeaps.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Igalia S.L.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TextureMapperPlatformLayerProxy.h&quot;
 28 
 29 #if USE(COORDINATED_GRAPHICS)
 30 
 31 #include &quot;BitmapTextureGL.h&quot;
 32 #include &quot;TextureMapperGL.h&quot;
 33 #include &quot;TextureMapperLayer.h&quot;
 34 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 35 
 36 #if USE(GLIB_EVENT_LOOP)
 37 #include &lt;wtf/glib/RunLoopSourcePriority.h&gt;
 38 #endif
 39 #include &lt;wtf/Scope.h&gt;
 40 
 41 static const Seconds releaseUnusedSecondsTolerance { 1_s };
 42 static const Seconds releaseUnusedBuffersTimerInterval = { 500_ms };
 43 
 44 namespace WebCore {
 45 
 46 TextureMapperPlatformLayerProxy::TextureMapperPlatformLayerProxy()
 47     : m_compositor(nullptr)
 48     , m_targetLayer(nullptr)
 49 {
 50 }
 51 
 52 TextureMapperPlatformLayerProxy::~TextureMapperPlatformLayerProxy()
 53 {
 54     LockHolder locker(m_lock);
 55     if (m_targetLayer)
 56         m_targetLayer-&gt;setContentsLayer(nullptr);
 57 }
 58 
 59 void TextureMapperPlatformLayerProxy::activateOnCompositingThread(Compositor* compositor, TextureMapperLayer* targetLayer)
 60 {
 61 #ifndef NDEBUG
 62     if (!m_compositorThread)
 63         m_compositorThread = &amp;Thread::current();
 64 #endif
 65     ASSERT(m_compositorThread == &amp;Thread::current());
 66     ASSERT(compositor);
 67     ASSERT(targetLayer);
 68     LockHolder locker(m_lock);
 69     m_compositor = compositor;
 70     m_targetLayer = targetLayer;
 71     if (m_targetLayer &amp;&amp; m_currentBuffer)
 72         m_targetLayer-&gt;setContentsLayer(m_currentBuffer.get());
 73 
 74     m_releaseUnusedBuffersTimer = makeUnique&lt;RunLoop::Timer&lt;TextureMapperPlatformLayerProxy&gt;&gt;(RunLoop::current(), this, &amp;TextureMapperPlatformLayerProxy::releaseUnusedBuffersTimerFired);
 75     m_compositorThreadUpdateTimer = makeUnique&lt;RunLoop::Timer&lt;TextureMapperPlatformLayerProxy&gt;&gt;(RunLoop::current(), this, &amp;TextureMapperPlatformLayerProxy::compositorThreadUpdateTimerFired);
 76 
 77 #if USE(GLIB_EVENT_LOOP)
 78     m_compositorThreadUpdateTimer-&gt;setPriority(RunLoopSourcePriority::CompositingThreadUpdateTimer);
 79     m_releaseUnusedBuffersTimer-&gt;setPriority(RunLoopSourcePriority::ReleaseUnusedResourcesTimer);
 80 #endif
 81 }
 82 
 83 void TextureMapperPlatformLayerProxy::invalidate()
 84 {
 85     ASSERT(m_compositorThread == &amp;Thread::current());
 86     Function&lt;void()&gt; updateFunction;
 87     {
 88         LockHolder locker(m_lock);
 89         m_compositor = nullptr;
 90         m_targetLayer = nullptr;
 91 
 92         m_currentBuffer = nullptr;
 93         m_pendingBuffer = nullptr;
 94         m_releaseUnusedBuffersTimer = nullptr;
 95         m_usedBuffers.clear();
 96 
 97         // Clear the timer and dispatch the update function manually now.
 98         m_compositorThreadUpdateTimer = nullptr;
 99         if (!m_compositorThreadUpdateFunction)
100             return;
101         updateFunction = WTFMove(m_compositorThreadUpdateFunction);
102     }
103 
104     updateFunction();
105 }
106 
107 bool TextureMapperPlatformLayerProxy::isActive()
108 {
109     ASSERT(m_lock.isHeld());
110     return !!m_targetLayer &amp;&amp; !!m_compositor;
111 }
112 
113 void TextureMapperPlatformLayerProxy::pushNextBuffer(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt;&amp;&amp; newBuffer)
114 {
115     ASSERT(m_lock.isHeld());
116 #if USE(ANGLE)
117     // When the newBuffer overwrites m_pendingBuffer that is not swapped yet,
118     // the layer related to m_pendingBuffer is flickering since its texture is destroyed.
119     if (m_pendingBuffer &amp;&amp; m_pendingBuffer-&gt;hasManagedTexture())
120         return;
121 #endif
122     m_pendingBuffer = WTFMove(newBuffer);
123     m_wasBufferDropped = false;
124 
125     if (m_compositor)
126         m_compositor-&gt;onNewBufferAvailable();
127 }
128 
129 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerProxy::getAvailableBuffer(const IntSize&amp; size, GLint internalFormat)
130 {
131     ASSERT(m_lock.isHeld());
132     ASSERT(m_compositorThread == &amp;Thread::current());
133     std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; availableBuffer;
134 
135     auto buffers = WTFMove(m_usedBuffers);
136     for (auto&amp; buffer : buffers) {
137         if (!buffer)
138             continue;
139 
140         if (!availableBuffer &amp;&amp; buffer-&gt;canReuseWithoutReset(size, internalFormat)) {
141             availableBuffer = WTFMove(buffer);
142             availableBuffer-&gt;markUsed();
143             continue;
144         }
145         m_usedBuffers.append(WTFMove(buffer));
146     }
147 
148     if (!m_usedBuffers.isEmpty())
149         scheduleReleaseUnusedBuffers();
150     return availableBuffer;
151 }
152 
153 void TextureMapperPlatformLayerProxy::appendToUnusedBuffers(std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; buffer)
154 {
155     ASSERT(m_lock.isHeld());
156     ASSERT(m_compositorThread == &amp;Thread::current());
157     m_usedBuffers.append(WTFMove(buffer));
158     scheduleReleaseUnusedBuffers();
159 }
160 
161 void TextureMapperPlatformLayerProxy::scheduleReleaseUnusedBuffers()
162 {
163     if (!m_releaseUnusedBuffersTimer-&gt;isActive())
164         m_releaseUnusedBuffersTimer-&gt;startOneShot(releaseUnusedBuffersTimerInterval);
165 }
166 
167 void TextureMapperPlatformLayerProxy::releaseUnusedBuffersTimerFired()
168 {
169     LockHolder locker(m_lock);
170     if (m_usedBuffers.isEmpty())
171         return;
172 
173     auto buffers = WTFMove(m_usedBuffers);
174     MonotonicTime minUsedTime = MonotonicTime::now() - releaseUnusedSecondsTolerance;
175 
176     for (auto&amp; buffer : buffers) {
177         if (buffer &amp;&amp; buffer-&gt;lastUsedTime() &gt;= minUsedTime)
178             m_usedBuffers.append(WTFMove(buffer));
179     }
180 }
181 
182 void TextureMapperPlatformLayerProxy::swapBuffer()
183 {
184     ASSERT(m_compositorThread == &amp;Thread::current());
185     LockHolder locker(m_lock);
186     if (!m_targetLayer || !m_pendingBuffer)
187         return;
188 
189     auto prevBuffer = WTFMove(m_currentBuffer);
190 
191     m_currentBuffer = WTFMove(m_pendingBuffer);
192     m_targetLayer-&gt;setContentsLayer(m_currentBuffer.get());
193 
194     if (prevBuffer &amp;&amp; prevBuffer-&gt;hasManagedTexture())
195         appendToUnusedBuffers(WTFMove(prevBuffer));
196 }
197 
198 void TextureMapperPlatformLayerProxy::dropCurrentBufferWhilePreservingTexture(bool shouldWait)
199 {
200     if (!shouldWait)
201         ASSERT(m_lock.isHeld());
202 
203     if (m_pendingBuffer &amp;&amp; m_pendingBuffer-&gt;hasManagedTexture()) {
204         m_usedBuffers.append(WTFMove(m_pendingBuffer));
205         scheduleReleaseUnusedBuffers();
206     }
207 
208     if (!m_compositorThreadUpdateTimer)
209         return;
210 
211     m_compositorThreadUpdateFunction =
212         [this, shouldWait] {
213             LockHolder locker(m_lock);
214 
215             auto maybeNotifySynchronousOperation = WTF::makeScopeExit([this, shouldWait]() {
216                 if (shouldWait) {
217                     LockHolder holder(m_wasBufferDroppedLock);
218                     m_wasBufferDropped = true;
219                     m_wasBufferDroppedCondition.notifyAll();
220                 }
221             });
222 
223             if (!m_compositor || !m_targetLayer || !m_currentBuffer)
224                 return;
225 
226             m_pendingBuffer = m_currentBuffer-&gt;clone();
227             auto prevBuffer = WTFMove(m_currentBuffer);
228             m_currentBuffer = WTFMove(m_pendingBuffer);
229             m_targetLayer-&gt;setContentsLayer(m_currentBuffer.get());
230 
231             if (prevBuffer-&gt;hasManagedTexture())
232                 appendToUnusedBuffers(WTFMove(prevBuffer));
233         };
234 
235     if (shouldWait) {
236         LockHolder holder(m_wasBufferDroppedLock);
237         m_wasBufferDropped = false;
238     }
239 
240     m_compositorThreadUpdateTimer-&gt;startOneShot(0_s);
241     if (shouldWait) {
242         LockHolder holder(m_wasBufferDroppedLock);
243         m_wasBufferDroppedCondition.wait(m_wasBufferDroppedLock, [this] {
244             return m_wasBufferDropped;
245         });
246     }
247 }
248 
249 bool TextureMapperPlatformLayerProxy::scheduleUpdateOnCompositorThread(Function&lt;void()&gt;&amp;&amp; updateFunction)
250 {
251     LockHolder locker(m_lock);
252     if (!m_compositorThreadUpdateTimer)
253         return false;
254 
255     m_compositorThreadUpdateFunction = WTFMove(updateFunction);
256     m_compositorThreadUpdateTimer-&gt;startOneShot(0_s);
257     return true;
258 }
259 
260 void TextureMapperPlatformLayerProxy::compositorThreadUpdateTimerFired()
261 {
262     Function&lt;void()&gt; updateFunction;
263     {
264         LockHolder locker(m_lock);
265         if (!m_compositorThreadUpdateFunction)
266             return;
267         updateFunction = WTFMove(m_compositorThreadUpdateFunction);
268     }
269 
270     updateFunction();
271 }
272 
273 } // namespace WebCore
274 
275 #endif // USE(COORDINATED_GRAPHICS)
    </pre>
  </body>
</html>
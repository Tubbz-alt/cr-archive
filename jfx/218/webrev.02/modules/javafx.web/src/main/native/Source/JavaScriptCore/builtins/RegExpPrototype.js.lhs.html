<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/RegExpPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 24  */
 25 
 26 @globalPrivate
 27 @constructor
 28 function RegExpStringIterator(regExp, string, global, fullUnicode)
 29 {
 30     &quot;use strict&quot;;
 31 
 32     @putByIdDirectPrivate(this, &quot;regExpStringIteratorRegExp&quot;, regExp);
 33     @putByIdDirectPrivate(this, &quot;regExpStringIteratorString&quot;, string);
 34     @putByIdDirectPrivate(this, &quot;regExpStringIteratorGlobal&quot;, global);
 35     @putByIdDirectPrivate(this, &quot;regExpStringIteratorUnicode&quot;, fullUnicode);
 36     @putByIdDirectPrivate(this, &quot;regExpStringIteratorDone&quot;, false);
 37 }
 38 
 39 @globalPrivate
 40 function advanceStringIndex(string, index, unicode)
 41 {
 42     // This function implements AdvanceStringIndex described in ES6 21.2.5.2.3.
 43     &quot;use strict&quot;;
 44 
 45     if (!unicode)
 46         return index + 1;
 47 
 48     if (index + 1 &gt;= string.length)
 49         return index + 1;
 50 
<a name="1" id="anc1"></a><span class="line-modified"> 51     let first = string.@charCodeAt(index);</span>
 52     if (first &lt; 0xD800 || first &gt; 0xDBFF)
 53         return index + 1;
 54 
<a name="2" id="anc2"></a><span class="line-modified"> 55     let second = string.@charCodeAt(index + 1);</span>
 56     if (second &lt; 0xDC00 || second &gt; 0xDFFF)
 57         return index + 1;
 58 
 59     return index + 2;
 60 }
 61 
 62 @globalPrivate
 63 function regExpExec(regexp, str)
 64 {
 65     &quot;use strict&quot;;
 66 
<a name="3" id="anc3"></a><span class="line-modified"> 67     let exec = regexp.exec;</span>
<span class="line-modified"> 68     let builtinExec = @regExpBuiltinExec;</span>
 69     if (exec !== builtinExec &amp;&amp; typeof exec === &quot;function&quot;) {
<a name="4" id="anc4"></a><span class="line-modified"> 70         let result = exec.@call(regexp, str);</span>
 71         if (result !== null &amp;&amp; !@isObject(result))
 72             @throwTypeError(&quot;The result of a RegExp exec must be null or an object&quot;);
 73         return result;
 74     }
 75     return builtinExec.@call(regexp, str);
 76 }
 77 
 78 @globalPrivate
 79 function hasObservableSideEffectsForRegExpMatch(regexp)
 80 {
 81     &quot;use strict&quot;;
 82 
 83     if (!@isRegExpObject(regexp))
 84         return true;
 85 
 86     // This is accessed by the RegExpExec internal function.
<a name="5" id="anc5"></a><span class="line-modified"> 87     let regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
 88     if (regexpExec !== @regExpBuiltinExec)
 89         return true;
 90 
<a name="6" id="anc6"></a><span class="line-modified"> 91     let regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
 92     if (regexpGlobal !== @regExpProtoGlobalGetter)
 93         return true;
<a name="7" id="anc7"></a><span class="line-modified"> 94     let regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
 95     if (regexpUnicode !== @regExpProtoUnicodeGetter)
 96         return true;
 97 
 98     return typeof regexp.lastIndex !== &quot;number&quot;;
 99 }
100 
101 @globalPrivate
102 function matchSlow(regexp, str)
103 {
104     &quot;use strict&quot;;
105 
106     if (!regexp.global)
107         return @regExpExec(regexp, str);
108     
<a name="8" id="anc8"></a><span class="line-modified">109     let unicode = regexp.unicode;</span>
110     regexp.lastIndex = 0;
<a name="9" id="anc9"></a><span class="line-modified">111     let resultList = [];</span>
112 
113     // FIXME: It would be great to implement a solution similar to what we do in
114     // RegExpObject::matchGlobal(). It&#39;s not clear if this is possible, since this loop has
115     // effects. https://bugs.webkit.org/show_bug.cgi?id=158145
<a name="10" id="anc10"></a><span class="line-modified">116     const maximumReasonableMatchSize = 100000000;</span>
117 
118     while (true) {
<a name="11" id="anc11"></a><span class="line-modified">119         let result = @regExpExec(regexp, str);</span>
120         
121         if (result === null) {
122             if (resultList.length === 0)
123                 return null;
124             return resultList;
125         }
126 
127         if (resultList.length &gt; maximumReasonableMatchSize)
128             @throwOutOfMemoryError();
129 
<a name="12" id="anc12"></a><span class="line-modified">130         let resultString = @toString(result[0]);</span>
131 
132         if (!resultString.length)
133             regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
134 
135         resultList.@push(resultString);
136     }
137 }
138 
139 @overriddenName=&quot;[Symbol.match]&quot;
140 function match(strArg)
141 {
142     &quot;use strict&quot;;
143 
144     if (!@isObject(this))
145         @throwTypeError(&quot;RegExp.prototype.@@match requires that |this| be an Object&quot;);
146 
<a name="13" id="anc13"></a><span class="line-modified">147     let str = @toString(strArg);</span>
148 
149     // Check for observable side effects and call the fast path if there aren&#39;t any.
150     if (!@hasObservableSideEffectsForRegExpMatch(this))
151         return @regExpMatchFast.@call(this, str);
152     return @matchSlow(this, str);
153 }
154 
155 @overriddenName=&quot;[Symbol.matchAll]&quot;
156 function matchAll(strArg)
157 {
158     &quot;use strict&quot;;
159 
<a name="14" id="anc14"></a><span class="line-modified">160     let regExp = this;</span>
161     if (!@isObject(regExp))
162         @throwTypeError(&quot;RegExp.prototype.@@matchAll requires |this| to be an Object&quot;);
163 
<a name="15" id="anc15"></a><span class="line-modified">164     let string = @toString(strArg);</span>
<span class="line-modified">165     let Matcher = @speciesConstructor(regExp, @RegExp);</span>
166 
<a name="16" id="anc16"></a><span class="line-modified">167     let flags = @toString(regExp.flags);</span>
<span class="line-modified">168     let matcher = new Matcher(regExp, flags);</span>
169     matcher.lastIndex = @toLength(regExp.lastIndex);
170 
<a name="17" id="anc17"></a><span class="line-modified">171     let global = @stringIncludesInternal.@call(flags, &quot;g&quot;);</span>
<span class="line-modified">172     let fullUnicode = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
173 
174     return new @RegExpStringIterator(matcher, string, global, fullUnicode);
175 }
176 
177 @overriddenName=&quot;[Symbol.replace]&quot;
178 function replace(strArg, replace)
179 {
180     &quot;use strict&quot;;
181 
<a name="18" id="anc18"></a><span class="line-modified">182     function getSubstitution(matched, str, position, captures, replacement)</span>
183     {
184         &quot;use strict&quot;;
185 
<a name="19" id="anc19"></a><span class="line-modified">186         let matchLength = matched.length;</span>
<span class="line-modified">187         let stringLength = str.length;</span>
<span class="line-modified">188         let tailPos = position + matchLength;</span>
<span class="line-modified">189         let m = captures.length;</span>
<span class="line-modified">190         let replacementLength = replacement.length;</span>
<span class="line-modified">191         let result = &quot;&quot;;</span>
<span class="line-modified">192         let lastStart = 0;</span>
193 
<a name="20" id="anc20"></a><span class="line-modified">194         for (let start = 0; start = replacement.indexOf(&quot;$&quot;, lastStart), start !== -1; lastStart = start) {</span>
195             if (start - lastStart &gt; 0)
196                 result = result + replacement.substring(lastStart, start);
197             start++;
<a name="21" id="anc21"></a><span class="line-modified">198             let ch = replacement.charAt(start);</span>
199             if (ch === &quot;&quot;)
200                 result = result + &quot;$&quot;;
201             else {
202                 switch (ch)
203                 {
204                 case &quot;$&quot;:
205                     result = result + &quot;$&quot;;
206                     start++;
207                     break;
208                 case &quot;&amp;&quot;:
209                     result = result + matched;
210                     start++;
211                     break;
212                 case &quot;`&quot;:
213                     if (position &gt; 0)
214                         result = result + str.substring(0, position);
215                     start++;
216                     break;
217                 case &quot;&#39;&quot;:
218                     if (tailPos &lt; stringLength)
219                         result = result + str.substring(tailPos);
220                     start++;
221                     break;
<a name="22" id="anc22"></a>

















222                 default:
<a name="23" id="anc23"></a><span class="line-modified">223                     let chCode = ch.charCodeAt(0);</span>
224                     if (chCode &gt;= 0x30 &amp;&amp; chCode &lt;= 0x39) {
<a name="24" id="anc24"></a>
225                         start++;
<a name="25" id="anc25"></a><span class="line-modified">226                         let n = chCode - 0x30;</span>
<span class="line-modified">227                         if (n &gt; m)</span>


228                             break;
<a name="26" id="anc26"></a>

229                         if (start &lt; replacementLength) {
<a name="27" id="anc27"></a><span class="line-modified">230                             let nextChCode = replacement.charCodeAt(start);</span>
231                             if (nextChCode &gt;= 0x30 &amp;&amp; nextChCode &lt;= 0x39) {
<a name="28" id="anc28"></a><span class="line-modified">232                                 let nn = 10 * n + nextChCode - 0x30;</span>
233                                 if (nn &lt;= m) {
234                                     n = nn;
235                                     start++;
236                                 }
237                             }
238                         }
239 
<a name="29" id="anc29"></a><span class="line-modified">240                         if (n == 0)</span>

241                             break;
<a name="30" id="anc30"></a>
242 
<a name="31" id="anc31"></a><span class="line-modified">243                         if (captures[n] != @undefined)</span>
<span class="line-modified">244                             result = result + captures[n];</span>

245                     } else
246                         result = result + &quot;$&quot;;
247                     break;
248                 }
249             }
250         }
251 
252         return result + replacement.substring(lastStart);
253     }
254 
255     if (!@isObject(this))
256         @throwTypeError(&quot;RegExp.prototype.@@replace requires that |this| be an Object&quot;);
257 
<a name="32" id="anc32"></a><span class="line-modified">258     let regexp = this;</span>
259 
<a name="33" id="anc33"></a><span class="line-modified">260     let str = @toString(strArg);</span>
<span class="line-modified">261     let stringLength = str.length;</span>
<span class="line-modified">262     let functionalReplace = typeof replace === &#39;function&#39;;</span>
263 
264     if (!functionalReplace)
265         replace = @toString(replace);
266 
<a name="34" id="anc34"></a><span class="line-modified">267     let global = regexp.global;</span>
<span class="line-modified">268     let unicode = false;</span>
269 
270     if (global) {
271         unicode = regexp.unicode;
272         regexp.lastIndex = 0;
273     }
274 
<a name="35" id="anc35"></a><span class="line-modified">275     let resultList = [];</span>
<span class="line-modified">276     let result;</span>
<span class="line-modified">277     let done = false;</span>
278     while (!done) {
279         result = @regExpExec(regexp, str);
280 
281         if (result === null)
282             done = true;
283         else {
284             resultList.@push(result);
285             if (!global)
286                 done = true;
287             else {
<a name="36" id="anc36"></a><span class="line-modified">288                 let matchStr = @toString(result[0]);</span>
289 
290                 if (!matchStr.length)
291                     regexp.lastIndex = @advanceStringIndex(str, regexp.lastIndex, unicode);
292             }
293         }
294     }
295 
<a name="37" id="anc37"></a><span class="line-modified">296     let accumulatedResult = &quot;&quot;;</span>
<span class="line-modified">297     let nextSourcePosition = 0;</span>
<span class="line-modified">298     let lastPosition = 0;</span>
299 
<a name="38" id="anc38"></a><span class="line-modified">300     for (let i = 0, resultListLength = resultList.length; i &lt; resultListLength; ++i) {</span>
<span class="line-modified">301         let result = resultList[i];</span>
<span class="line-modified">302         let nCaptures = result.length - 1;</span>
303         if (nCaptures &lt; 0)
304             nCaptures = 0;
<a name="39" id="anc39"></a><span class="line-modified">305         let matched = @toString(result[0]);</span>
<span class="line-modified">306         let matchLength = matched.length;</span>
<span class="line-modified">307         let position = result.index;</span>
308         position = (position &gt; stringLength) ? stringLength : position;
309         position = (position &lt; 0) ? 0 : position;
310 
<a name="40" id="anc40"></a><span class="line-modified">311         let captures = [];</span>
<span class="line-modified">312         for (let n = 1; n &lt;= nCaptures; n++) {</span>
<span class="line-modified">313             let capN = result[n];</span>
314             if (capN !== @undefined)
315                 capN = @toString(capN);
<a name="41" id="anc41"></a><span class="line-modified">316             captures[n] = capN;</span>
317         }
318 
<a name="42" id="anc42"></a><span class="line-modified">319         let replacement;</span>

320 
321         if (functionalReplace) {
<a name="43" id="anc43"></a><span class="line-modified">322             let replacerArgs = [ matched ].concat(captures.slice(1));</span>
323             replacerArgs.@push(position);
324             replacerArgs.@push(str);
325 
<a name="44" id="anc44"></a><span class="line-modified">326             let replValue = replace.@apply(@undefined, replacerArgs);</span>



327             replacement = @toString(replValue);
<a name="45" id="anc45"></a><span class="line-modified">328         } else</span>
<span class="line-modified">329             replacement = getSubstitution(matched, str, position, captures, replace);</span>




330 
331         if (position &gt;= nextSourcePosition &amp;&amp; position &gt;= lastPosition) {
332             accumulatedResult = accumulatedResult + str.substring(nextSourcePosition, position) + replacement;
333             nextSourcePosition = position + matchLength;
334             lastPosition = position;
335         }
336     }
337 
338     if (nextSourcePosition &gt;= stringLength)
339         return  accumulatedResult;
340 
341     return accumulatedResult + str.substring(nextSourcePosition);
342 }
343 
344 // 21.2.5.9 RegExp.prototype[@@search] (string)
345 @overriddenName=&quot;[Symbol.search]&quot;
346 function search(strArg)
347 {
348     &quot;use strict&quot;;
349 
<a name="46" id="anc46"></a><span class="line-modified">350     let regexp = this;</span>
351 
352     // Check for observable side effects and call the fast path if there aren&#39;t any.
353     if (@isRegExpObject(regexp)
354         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
355         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
356         return @regExpSearchFast.@call(regexp, strArg);
357 
358     // 1. Let rx be the this value.
359     // 2. If Type(rx) is not Object, throw a TypeError exception.
360     if (!@isObject(this))
361         @throwTypeError(&quot;RegExp.prototype.@@search requires that |this| be an Object&quot;);
362 
363     // 3. Let S be ? ToString(string).
<a name="47" id="anc47"></a><span class="line-modified">364     let str = @toString(strArg)</span>
365 
366     // 4. Let previousLastIndex be ? Get(rx, &quot;lastIndex&quot;).
<a name="48" id="anc48"></a><span class="line-modified">367     let previousLastIndex = regexp.lastIndex;</span>
368 
369     // 5.If SameValue(previousLastIndex, 0) is false, then
370     // 5.a. Perform ? Set(rx, &quot;lastIndex&quot;, 0, true).
371     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
372     if (previousLastIndex !== 0)
373         regexp.lastIndex = 0;
374 
375     // 6. Let result be ? RegExpExec(rx, S).
<a name="49" id="anc49"></a><span class="line-modified">376     let result = @regExpExec(regexp, str);</span>
377 
378     // 7. Let currentLastIndex be ? Get(rx, &quot;lastIndex&quot;).
379     // 8. If SameValue(currentLastIndex, previousLastIndex) is false, then
380     // 8.a. Perform ? Set(rx, &quot;lastIndex&quot;, previousLastIndex, true).
381     // FIXME: Add SameValue support. https://bugs.webkit.org/show_bug.cgi?id=173226
382     if (regexp.lastIndex !== previousLastIndex)
383         regexp.lastIndex = previousLastIndex;
384 
385     // 9. If result is null, return -1.
386     if (result === null)
387         return -1;
388 
389     // 10. Return ? Get(result, &quot;index&quot;).
390     return result.index;
391 }
392 
393 @globalPrivate
394 function hasObservableSideEffectsForRegExpSplit(regexp)
395 {
396     &quot;use strict&quot;;
397 
398     if (!@isRegExpObject(regexp))
399         return true;
400 
401     // This is accessed by the RegExpExec internal function.
<a name="50" id="anc50"></a><span class="line-modified">402     let regexpExec = @tryGetById(regexp, &quot;exec&quot;);</span>
403     if (regexpExec !== @regExpBuiltinExec)
404         return true;
405     
406     // This is accessed by step 5 below.
<a name="51" id="anc51"></a><span class="line-modified">407     let regexpFlags = @tryGetById(regexp, &quot;flags&quot;);</span>
408     if (regexpFlags !== @regExpProtoFlagsGetter)
409         return true;
410     
411     // These are accessed by the builtin flags getter.
<a name="52" id="anc52"></a><span class="line-modified">412     let regexpGlobal = @tryGetById(regexp, &quot;global&quot;);</span>
413     if (regexpGlobal !== @regExpProtoGlobalGetter)
414         return true;
<a name="53" id="anc53"></a><span class="line-modified">415     let regexpIgnoreCase = @tryGetById(regexp, &quot;ignoreCase&quot;);</span>
416     if (regexpIgnoreCase !== @regExpProtoIgnoreCaseGetter)
417         return true;
<a name="54" id="anc54"></a><span class="line-modified">418     let regexpMultiline = @tryGetById(regexp, &quot;multiline&quot;);</span>
419     if (regexpMultiline !== @regExpProtoMultilineGetter)
420         return true;
<a name="55" id="anc55"></a><span class="line-modified">421     let regexpSticky = @tryGetById(regexp, &quot;sticky&quot;);</span>
422     if (regexpSticky !== @regExpProtoStickyGetter)
423         return true;
<a name="56" id="anc56"></a><span class="line-modified">424     let regexpUnicode = @tryGetById(regexp, &quot;unicode&quot;);</span>
425     if (regexpUnicode !== @regExpProtoUnicodeGetter)
426         return true;
427     
428     // This is accessed by the RegExp species constructor.
<a name="57" id="anc57"></a><span class="line-modified">429     let regexpSource = @tryGetById(regexp, &quot;source&quot;);</span>
430     if (regexpSource !== @regExpProtoSourceGetter)
431         return true;
432 
433     return typeof regexp.lastIndex !== &quot;number&quot;;
434 }
435 
436 // ES 21.2.5.11 RegExp.prototype[@@split](string, limit)
437 @overriddenName=&quot;[Symbol.split]&quot;
438 function split(string, limit)
439 {
440     &quot;use strict&quot;;
441 
442     // 1. Let rx be the this value.
443     // 2. If Type(rx) is not Object, throw a TypeError exception.
444     if (!@isObject(this))
445         @throwTypeError(&quot;RegExp.prototype.@@split requires that |this| be an Object&quot;);
<a name="58" id="anc58"></a><span class="line-modified">446     let regexp = this;</span>
447 
448     // 3. Let S be ? ToString(string).
<a name="59" id="anc59"></a><span class="line-modified">449     let str = @toString(string);</span>
450 
451     // 4. Let C be ? SpeciesConstructor(rx, %RegExp%).
<a name="60" id="anc60"></a><span class="line-modified">452     let speciesConstructor = @speciesConstructor(regexp, @RegExp);</span>
453 
454     if (speciesConstructor === @RegExp &amp;&amp; !@hasObservableSideEffectsForRegExpSplit(regexp))
455         return @regExpSplitFast.@call(regexp, str, limit);
456 
457     // 5. Let flags be ? ToString(? Get(rx, &quot;flags&quot;)).
<a name="61" id="anc61"></a><span class="line-modified">458     let flags = @toString(regexp.flags);</span>
459 
<a name="62" id="anc62"></a><span class="line-modified">460     // 6. If flags contains &quot;u&quot;, let unicodeMatching be true.</span>
461     // 7. Else, let unicodeMatching be false.
<a name="63" id="anc63"></a><span class="line-modified">462     let unicodeMatching = @stringIncludesInternal.@call(flags, &quot;u&quot;);</span>
<span class="line-modified">463     // 8. If flags contains &quot;y&quot;, let newFlags be flags.</span>
464     // 9. Else, let newFlags be the string that is the concatenation of flags and &quot;y&quot;.
<a name="64" id="anc64"></a><span class="line-modified">465     let newFlags = @stringIncludesInternal.@call(flags, &quot;y&quot;) ? flags : flags + &quot;y&quot;;</span>
466 
467     // 10. Let splitter be ? Construct(C, « rx, newFlags »).
<a name="65" id="anc65"></a><span class="line-modified">468     let splitter = new speciesConstructor(regexp, newFlags);</span>
469 
470     // We need to check again for RegExp subclasses that will fail the speciesConstructor test
471     // but can still use the fast path after we invoke the constructor above.
472     if (!@hasObservableSideEffectsForRegExpSplit(splitter))
473         return @regExpSplitFast.@call(splitter, str, limit);
474 
475     // 11. Let A be ArrayCreate(0).
476     // 12. Let lengthA be 0.
<a name="66" id="anc66"></a><span class="line-modified">477     let result = [];</span>
478 
<a name="67" id="anc67"></a><span class="line-modified">479     // 13. If limit is undefined, let lim be 2^32-1; else let lim be ? ToUint32(limit).</span>
480     limit = (limit === @undefined) ? 0xffffffff : limit &gt;&gt;&gt; 0;
481 
482     // 16. If lim = 0, return A.
483     if (!limit)
484         return result;
485 
486     // 14. [Defered from above] Let size be the number of elements in S.
<a name="68" id="anc68"></a><span class="line-modified">487     let size = str.length;</span>
488 
489     // 17. If size = 0, then
490     if (!size) {
491         // a. Let z be ? RegExpExec(splitter, S).
<a name="69" id="anc69"></a><span class="line-modified">492         let z = @regExpExec(splitter, str);</span>
493         // b. If z is not null, return A.
494         if (z != null)
495             return result;
496         // c. Perform ! CreateDataProperty(A, &quot;0&quot;, S).
497         @putByValDirect(result, 0, str);
498         // d. Return A.
499         return result;
500     }
501 
502     // 15. [Defered from above] Let p be 0.
<a name="70" id="anc70"></a><span class="line-modified">503     let position = 0;</span>
504     // 18. Let q be p.
<a name="71" id="anc71"></a><span class="line-modified">505     let matchPosition = 0;</span>
506 
507     // 19. Repeat, while q &lt; size
508     while (matchPosition &lt; size) {
509         // a. Perform ? Set(splitter, &quot;lastIndex&quot;, q, true).
510         splitter.lastIndex = matchPosition;
511         // b. Let z be ? RegExpExec(splitter, S).
<a name="72" id="anc72"></a><span class="line-modified">512         let matches = @regExpExec(splitter, str);</span>
513         // c. If z is null, let q be AdvanceStringIndex(S, q, unicodeMatching).
514         if (matches === null)
515             matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
516         // d. Else z is not null,
517         else {
518             // i. Let e be ? ToLength(? Get(splitter, &quot;lastIndex&quot;)).
<a name="73" id="anc73"></a><span class="line-modified">519             let endPosition = @toLength(splitter.lastIndex);</span>
520             // ii. Let e be min(e, size).
521             endPosition = (endPosition &lt;= size) ? endPosition : size;
522             // iii. If e = p, let q be AdvanceStringIndex(S, q, unicodeMatching).
523             if (endPosition === position)
524                 matchPosition = @advanceStringIndex(str, matchPosition, unicodeMatching);
525             // iv. Else e != p,
526             else {
527                 // 1. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through q (exclusive).
<a name="74" id="anc74"></a><span class="line-modified">528                 let subStr = @stringSubstrInternal.@call(str, position, matchPosition - position);</span>
529                 // 2. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
530                 // 3. Let lengthA be lengthA + 1.
531                 @putByValDirect(result, result.length, subStr);
532                 // 4. If lengthA = lim, return A.
533                 if (result.length == limit)
534                     return result;
535 
536                 // 5. Let p be e.
537                 position = endPosition;
538                 // 6. Let numberOfCaptures be ? ToLength(? Get(z, &quot;length&quot;)).
539                 // 7. Let numberOfCaptures be max(numberOfCaptures-1, 0).
<a name="75" id="anc75"></a><span class="line-modified">540                 let numberOfCaptures = matches.length &gt; 1 ? matches.length - 1 : 0;</span>
541 
542                 // 8. Let i be 1.
<a name="76" id="anc76"></a><span class="line-modified">543                 let i = 1;</span>
544                 // 9. Repeat, while i &lt;= numberOfCaptures,
545                 while (i &lt;= numberOfCaptures) {
546                     // a. Let nextCapture be ? Get(z, ! ToString(i)).
<a name="77" id="anc77"></a><span class="line-modified">547                     let nextCapture = matches[i];</span>
548                     // b. Perform ! CreateDataProperty(A, ! ToString(lengthA), nextCapture).
549                     // d. Let lengthA be lengthA + 1.
550                     @putByValDirect(result, result.length, nextCapture);
551                     // e. If lengthA = lim, return A.
552                     if (result.length == limit)
553                         return result;
554                     // c. Let i be i + 1.
555                     i++;
556                 }
557                 // 10. Let q be p.
558                 matchPosition = position;
559             }
560         }
561     }
562     // 20. Let T be a String value equal to the substring of S consisting of the elements at indices p (inclusive) through size (exclusive).
<a name="78" id="anc78"></a><span class="line-modified">563     let remainingStr = @stringSubstrInternal.@call(str, position, size);</span>
564     // 21. Perform ! CreateDataProperty(A, ! ToString(lengthA), T).
565     @putByValDirect(result, result.length, remainingStr);
566     // 22. Return A.
567     return result;
568 }
569 
570 // ES 21.2.5.13 RegExp.prototype.test(string)
571 @intrinsic=RegExpTestIntrinsic
572 function test(strArg)
573 {
574     &quot;use strict&quot;;
575 
<a name="79" id="anc79"></a><span class="line-modified">576     let regexp = this;</span>
577 
578     // Check for observable side effects and call the fast path if there aren&#39;t any.
579     if (@isRegExpObject(regexp)
580         &amp;&amp; @tryGetById(regexp, &quot;exec&quot;) === @regExpBuiltinExec
581         &amp;&amp; typeof regexp.lastIndex === &quot;number&quot;)
582         return @regExpTestFast.@call(regexp, strArg);
583 
584     // 1. Let R be the this value.
585     // 2. If Type(R) is not Object, throw a TypeError exception.
586     if (!@isObject(regexp))
587         @throwTypeError(&quot;RegExp.prototype.test requires that |this| be an Object&quot;);
588 
589     // 3. Let string be ? ToString(S).
<a name="80" id="anc80"></a><span class="line-modified">590     let str = @toString(strArg);</span>
591 
592     // 4. Let match be ? RegExpExec(R, string).
<a name="81" id="anc81"></a><span class="line-modified">593     let match = @regExpExec(regexp, str);</span>
594 
595     // 5. If match is not null, return true; else return false.
596     if (match !== null)
597         return true;
598     return false;
599 }
<a name="82" id="anc82"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="82" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptWrappable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedScriptValue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/SerializedScriptValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  72 #include &lt;JavaScriptCore/JSMap.h&gt;
  73 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  74 #include &lt;JavaScriptCore/JSSet.h&gt;
  75 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  76 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  77 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  78 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  79 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  80 #include &lt;JavaScriptCore/RegExp.h&gt;
  81 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  82 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  84 #include &lt;JavaScriptCore/WasmModule.h&gt;
  85 #include &lt;JavaScriptCore/YarrFlags.h&gt;
  86 #include &lt;limits&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/MainThread.h&gt;
  89 #include &lt;wtf/RunLoop.h&gt;
  90 #include &lt;wtf/Vector.h&gt;
  91 





  92 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  93 #define ASSUME_LITTLE_ENDIAN 0
  94 #else
  95 #define ASSUME_LITTLE_ENDIAN 1
  96 #endif
  97 
  98 namespace WebCore {
  99 using namespace JSC;
 100 


 101 static const unsigned maximumFilterRecursion = 40000;
 102 
 103 enum class SerializationReturnCode {
 104     SuccessfullyCompleted,
 105     StackOverflowError,
 106     InterruptedExecutionError,
 107     ValidationError,
 108     ExistingExceptionError,
 109     DataCloneError,
 110     UnspecifiedError
 111 };
 112 
 113 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
 114     ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember,
 115     MapDataStartVisitEntry, MapDataEndVisitKey, MapDataEndVisitValue,
 116     SetDataStartVisitEntry, SetDataEndVisitKey };
 117 
 118 // These can&#39;t be reordered, and any new types must be added to the end of the list
 119 // When making changes to these lists please cover your new type(s) in the API test &quot;IndexedDB.StructuredCloneBackwardCompatibility&quot;
 120 enum SerializationTag {
</pre>
<hr />
<pre>
 150     MapObjectTag = 30,
 151     NonMapPropertiesTag = 31,
 152     NonSetPropertiesTag = 32,
 153 #if ENABLE(WEB_CRYPTO)
 154     CryptoKeyTag = 33,
 155 #endif
 156     SharedArrayBufferTag = 34,
 157 #if ENABLE(WEBASSEMBLY)
 158     WasmModuleTag = 35,
 159 #endif
 160     DOMPointReadOnlyTag = 36,
 161     DOMPointTag = 37,
 162     DOMRectReadOnlyTag = 38,
 163     DOMRectTag = 39,
 164     DOMMatrixReadOnlyTag = 40,
 165     DOMMatrixTag = 41,
 166     DOMQuadTag = 42,
 167     ImageBitmapTransferTag = 43,
 168 #if ENABLE(WEB_RTC)
 169     RTCCertificateTag = 44,




 170 #endif
 171     ErrorTag = 255
 172 };
 173 
 174 enum ArrayBufferViewSubtag {
 175     DataViewTag = 0,
 176     Int8ArrayTag = 1,
 177     Uint8ArrayTag = 2,
 178     Uint8ClampedArrayTag = 3,
 179     Int16ArrayTag = 4,
 180     Uint16ArrayTag = 5,
 181     Int32ArrayTag = 6,
 182     Uint32ArrayTag = 7,
 183     Float32ArrayTag = 8,
 184     Float64ArrayTag = 9
 185 };
 186 
 187 static unsigned typedArrayElementSize(ArrayBufferViewSubtag tag)
 188 {
 189     switch (tag) {
</pre>
<hr />
<pre>
 333  *    | DateTag &lt;value:double&gt;
 334  *    | String
 335  *    | EmptyStringTag
 336  *    | EmptyStringObjectTag
 337  *    | File
 338  *    | FileList
 339  *    | ImageData
 340  *    | Blob
 341  *    | ObjectReference
 342  *    | MessagePortReferenceTag &lt;value:uint32_t&gt;
 343  *    | ArrayBuffer
 344  *    | ArrayBufferViewTag ArrayBufferViewSubtag &lt;byteOffset:uint32_t&gt; &lt;byteLength:uint32_t&gt; (ArrayBuffer | ObjectReference)
 345  *    | ArrayBufferTransferTag &lt;value:uint32_t&gt;
 346  *    | CryptoKeyTag &lt;wrappedKeyLength:uint32_t&gt; &lt;factor:byte{wrappedKeyLength}&gt;
 347  *    | DOMPoint
 348  *    | DOMRect
 349  *    | DOMMatrix
 350  *    | DOMQuad
 351  *    | ImageBitmapTransferTag &lt;value:uint32_t&gt;
 352  *    | RTCCertificateTag


 353  *
 354  * Inside certificate, data is serialized in this format as per spec:
 355  *
 356  * &lt;expires:double&gt; &lt;certificate:StringData&gt; &lt;origin:StringData&gt; &lt;keyingMaterial:StringData&gt;
 357  * We also add fingerprints to make sure we expose to JavaScript the same information.
 358  *
 359  * Inside wrapped crypto key, data is serialized in this format:
 360  *
 361  * &lt;keyFormatVersion:uint32_t&gt; &lt;extractable:int32_t&gt; &lt;usagesCount:uint32_t&gt; &lt;usages:byte{usagesCount}&gt; CryptoKeyClassSubtag (CryptoKeyHMAC | CryptoKeyAES | CryptoKeyRSA)
 362  *
 363  * String :-
 364  *      EmptyStringTag
 365  *      StringTag StringData
 366  *
 367  * StringObject:
 368  *      EmptyStringObjectTag
 369  *      StringObjectTag StringData
 370  *
 371  * StringData :-
 372  *      StringPoolTag &lt;cpIndex:IndexType&gt;
</pre>
<hr />
<pre>
 441  * DOMMatrix :-
 442  *        DOMMatrixReadOnlyTag DOMMatrixData
 443  *      | DOMMatrixTag DOMMatrixData
 444  *
 445  * DOMMatrixData :-
 446  *        &lt;is2D:uint8_t:true&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m41:double&gt; &lt;m42:double&gt;
 447  *      | &lt;is2D:uint8_t:false&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m13:double&gt; &lt;m14:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m23:double&gt; &lt;m24:double&gt; &lt;m31:double&gt; &lt;m32:double&gt; &lt;m33:double&gt; &lt;m34:double&gt; &lt;m41:double&gt; &lt;m42:double&gt; &lt;m43:double&gt; &lt;m44:double&gt;
 448  *
 449  * DOMQuad :-
 450  *      DOMQuadTag DOMQuadData
 451  *
 452  * DOMQuadData :-
 453  *      &lt;p1:DOMPointData&gt; &lt;p2:DOMPointData&gt; &lt;p3:DOMPointData&gt; &lt;p4:DOMPointData&gt;
 454  *
 455  */
 456 
 457 using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
 458 
 459 class CloneBase {
 460 protected:
<span class="line-modified"> 461     CloneBase(ExecState* exec)</span>
<span class="line-modified"> 462         : m_exec(exec)</span>
 463         , m_failed(false)
 464     {
 465     }
 466 
 467     bool shouldTerminate()
 468     {
<span class="line-modified"> 469         VM&amp; vm = m_exec-&gt;vm();</span>
 470         auto scope = DECLARE_THROW_SCOPE(vm);
 471         return scope.exception();
 472     }
 473 
 474     void fail()
 475     {
 476         m_failed = true;
 477     }
 478 
<span class="line-modified"> 479     ExecState* m_exec;</span>
 480     bool m_failed;
 481     MarkedArgumentBuffer m_gcBuffer;
 482 };
 483 
 484 #if ENABLE(WEB_CRYPTO)
<span class="line-modified"> 485 static bool wrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)</span>
 486 {
<span class="line-modified"> 487     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);</span>
 488     if (!scriptExecutionContext)
 489         return false;
 490     return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
 491 }
 492 
<span class="line-modified"> 493 static bool unwrapCryptoKey(ExecState* exec, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)</span>
 494 {
<span class="line-modified"> 495     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(exec);</span>
 496     if (!scriptExecutionContext)
 497         return false;
 498     return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
 499 }
 500 #endif
 501 
 502 #if ASSUME_LITTLE_ENDIAN
 503 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 504 {
 505     buffer.append(reinterpret_cast&lt;uint8_t*&gt;(&amp;value), sizeof(value));
 506 }
 507 #else
 508 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 509 {
 510     for (unsigned i = 0; i &lt; sizeof(T); i++) {
 511         buffer.append(value &amp; 0xFF);
 512         value &gt;&gt;= 8;
 513     }
 514 }
 515 #endif
</pre>
<hr />
<pre>
 529 #else
 530     for (unsigned i = 0; i &lt; length; i++) {
 531         T value = values[i];
 532         for (unsigned j = 0; j &lt; sizeof(T); j++) {
 533             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 534             value &gt;&gt;= 8;
 535         }
 536     }
 537 #endif
 538     return true;
 539 }
 540 
 541 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 542 {
 543     buffer.append(values, length);
 544     return true;
 545 }
 546 
 547 class CloneSerializer : CloneBase {
 548 public:
<span class="line-modified"> 549     static SerializationReturnCode serialize(ExecState* exec, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>



 550 #if ENABLE(WEBASSEMBLY)
 551             WasmModuleArray&amp; wasmModules,
 552 #endif
 553         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
 554     {
<span class="line-modified"> 555         CloneSerializer serializer(exec, messagePorts, arrayBuffers, imageBitmaps,</span>



 556 #if ENABLE(WEBASSEMBLY)
 557             wasmModules,
 558 #endif
 559             blobURLs, out, context, sharedBuffers);
 560         return serializer.serialize(value);
 561     }
 562 
 563     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 564     {
 565         writeLittleEndian(out, CurrentVersion);
 566         if (string.isEmpty()) {
 567             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 568             return true;
 569         }
 570         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 571         if (string.is8Bit()) {
 572             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 573             return writeLittleEndian(out, string.characters8(), string.length());
 574         }
 575         writeLittleEndian(out, string.length());
 576         return writeLittleEndian(out, string.characters16(), string.length());
 577     }
 578 
 579 private:
 580     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 581 
<span class="line-modified"> 582     CloneSerializer(ExecState* exec, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>



 583 #if ENABLE(WEBASSEMBLY)
 584             WasmModuleArray&amp; wasmModules,
 585 #endif
 586         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
<span class="line-modified"> 587         : CloneBase(exec)</span>
 588         , m_buffer(out)
 589         , m_blobURLs(blobURLs)
<span class="line-modified"> 590         , m_emptyIdentifier(Identifier::fromString(exec-&gt;vm(), emptyString()))</span>
 591         , m_context(context)
 592         , m_sharedBuffers(sharedBuffers)
 593 #if ENABLE(WEBASSEMBLY)
 594         , m_wasmModules(wasmModules)
 595 #endif
 596     {
 597         write(CurrentVersion);
 598         fillTransferMap(messagePorts, m_transferredMessagePorts);
 599         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 600         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);



 601     }
 602 
 603     template &lt;class T&gt;
 604     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 605     {
 606         if (input.isEmpty())
 607             return;
<span class="line-modified"> 608         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_exec-&gt;lexicalGlobalObject());</span>
 609         for (size_t i = 0; i &lt; input.size(); i++) {
<span class="line-modified"> 610             JSC::JSValue value = toJS(m_exec, globalObject, input[i].get());</span>
 611             JSC::JSObject* obj = value.getObject();
 612             if (obj &amp;&amp; !result.contains(obj))
 613                 result.add(obj, i);
 614         }
 615     }
 616 
 617     SerializationReturnCode serialize(JSValue in);
 618 
 619     bool isArray(VM&amp; vm, JSValue value)
 620     {
 621         if (!value.isObject())
 622             return false;
 623         JSObject* object = asObject(value);
 624         return object-&gt;inherits&lt;JSArray&gt;(vm);
 625     }
 626 
 627     bool isMap(VM&amp; vm, JSValue value)
 628     {
 629         if (!value.isObject())
 630             return false;
</pre>
<hr />
<pre>
 697         return true;
 698     }
 699 
 700     bool startMap(JSMap* map)
 701     {
 702         if (!startObjectInternal(map))
 703             return false;
 704 
 705         write(MapObjectTag);
 706         return true;
 707     }
 708 
 709     void endObject()
 710     {
 711         write(TerminatorTag);
 712     }
 713 
 714     JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
 715     {
 716         PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 717         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_exec, propertyName, slot))</span>
<span class="line-modified"> 718             return slot.getValue(m_exec, propertyName);</span>
 719         return JSValue();
 720     }
 721 
 722     void dumpImmediate(JSValue value)
 723     {
 724         if (value.isNull())
 725             write(NullTag);
 726         else if (value.isUndefined())
 727             write(UndefinedTag);
 728         else if (value.isNumber()) {
 729             if (value.isInt32()) {
 730                 if (!value.asInt32())
 731                     write(ZeroTag);
 732                 else if (value.asInt32() == 1)
 733                     write(OneTag);
 734                 else {
 735                     write(IntTag);
 736                     write(static_cast&lt;uint32_t&gt;(value.asInt32()));
 737                 }
 738             } else {
</pre>
<hr />
<pre>
 752         if (string.isEmpty())
 753             write(EmptyStringTag);
 754         else {
 755             write(StringTag);
 756             write(string);
 757         }
 758     }
 759 
 760     void dumpStringObject(const String&amp; string)
 761     {
 762         if (string.isEmpty())
 763             write(EmptyStringObjectTag);
 764         else {
 765             write(StringObjectTag);
 766             write(string);
 767         }
 768     }
 769 
 770     JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
 771     {
<span class="line-modified"> 772         auto&amp; vm = m_exec-&gt;vm();</span>
<span class="line-modified"> 773         auto* globalObject = m_exec-&gt;lexicalGlobalObject();</span>
 774         if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
<span class="line-modified"> 775             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);</span>
 776 
 777         if (auto* buffer = arrayBuffer.m_wrapper.get())
 778             return buffer;
 779 
 780         return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
 781     }
 782 
 783     bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
 784     {
<span class="line-modified"> 785         VM&amp; vm = m_exec-&gt;vm();</span>
 786         write(ArrayBufferViewTag);
 787         if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
 788             write(DataViewTag);
 789         else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
 790             write(Uint8ClampedArrayTag);
 791         else if (obj-&gt;inherits&lt;JSInt8Array&gt;(vm))
 792             write(Int8ArrayTag);
 793         else if (obj-&gt;inherits&lt;JSUint8Array&gt;(vm))
 794             write(Uint8ArrayTag);
 795         else if (obj-&gt;inherits&lt;JSInt16Array&gt;(vm))
 796             write(Int16ArrayTag);
 797         else if (obj-&gt;inherits&lt;JSUint16Array&gt;(vm))
 798             write(Uint16ArrayTag);
 799         else if (obj-&gt;inherits&lt;JSInt32Array&gt;(vm))
 800             write(Int32ArrayTag);
 801         else if (obj-&gt;inherits&lt;JSUint32Array&gt;(vm))
 802             write(Uint32ArrayTag);
 803         else if (obj-&gt;inherits&lt;JSFloat32Array&gt;(vm))
 804             write(Float32ArrayTag);
 805         else if (obj-&gt;inherits&lt;JSFloat64Array&gt;(vm))
</pre>
<hr />
<pre>
 812         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteLength()));
 813         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = arrayBufferView-&gt;possiblySharedBuffer();
 814         if (!arrayBuffer) {
 815             code = SerializationReturnCode::ValidationError;
 816             return true;
 817         }
 818 
 819         return dumpIfTerminal(toJSArrayBuffer(*arrayBuffer), code);
 820     }
 821 
 822     void dumpDOMPoint(const DOMPointReadOnly&amp; point)
 823     {
 824         write(point.x());
 825         write(point.y());
 826         write(point.z());
 827         write(point.w());
 828     }
 829 
 830     void dumpDOMPoint(JSObject* obj)
 831     {
<span class="line-modified"> 832         VM&amp; vm = m_exec-&gt;vm();</span>
 833         if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
 834             write(DOMPointTag);
 835         else
 836             write(DOMPointReadOnlyTag);
 837 
 838         dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
 839     }
 840 
 841     void dumpDOMRect(JSObject* obj)
 842     {
<span class="line-modified"> 843         VM&amp; vm = m_exec-&gt;vm();</span>
 844         if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
 845             write(DOMRectTag);
 846         else
 847             write(DOMRectReadOnlyTag);
 848 
 849         auto&amp; rect = jsCast&lt;JSDOMRectReadOnly*&gt;(obj)-&gt;wrapped();
 850         write(rect.x());
 851         write(rect.y());
 852         write(rect.width());
 853         write(rect.height());
 854     }
 855 
 856     void dumpDOMMatrix(JSObject* obj)
 857     {
<span class="line-modified"> 858         VM&amp; vm = m_exec-&gt;vm();</span>
 859         if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
 860             write(DOMMatrixTag);
 861         else
 862             write(DOMMatrixReadOnlyTag);
 863 
 864         auto&amp; matrix = jsCast&lt;JSDOMMatrixReadOnly*&gt;(obj)-&gt;wrapped();
 865         bool is2D = matrix.is2D();
 866         write(static_cast&lt;uint8_t&gt;(is2D));
 867         if (is2D) {
 868             write(matrix.m11());
 869             write(matrix.m12());
 870             write(matrix.m21());
 871             write(matrix.m22());
 872             write(matrix.m41());
 873             write(matrix.m42());
 874         } else {
 875             write(matrix.m11());
 876             write(matrix.m12());
 877             write(matrix.m13());
 878             write(matrix.m14());
</pre>
<hr />
<pre>
 894     void dumpDOMQuad(JSObject* obj)
 895     {
 896         write(DOMQuadTag);
 897 
 898         auto&amp; quad = jsCast&lt;JSDOMQuad*&gt;(obj)-&gt;wrapped();
 899         dumpDOMPoint(quad.p1());
 900         dumpDOMPoint(quad.p2());
 901         dumpDOMPoint(quad.p3());
 902         dumpDOMPoint(quad.p4());
 903     }
 904 
 905     void dumpImageBitmap(JSObject* obj, SerializationReturnCode&amp; code)
 906     {
 907         auto index = m_transferredImageBitmaps.find(obj);
 908         if (index != m_transferredImageBitmaps.end()) {
 909             write(ImageBitmapTransferTag);
 910             write(index-&gt;value);
 911             return;
 912         }
 913 
<span class="line-modified"> 914         // Copying ImageBitmaps is not yet supported.</span>
<span class="line-modified"> 915         code = SerializationReturnCode::ValidationError;</span>



























 916     }
 917 














 918     bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
 919     {
 920         if (!value.isCell()) {
 921             dumpImmediate(value);
 922             return true;
 923         }
 924         ASSERT(value.isCell());
 925 
 926         if (value.isString()) {
<span class="line-modified"> 927             dumpString(asString(value)-&gt;value(m_exec));</span>
 928             return true;
 929         }
 930 
 931         if (value.isSymbol()) {
 932             code = SerializationReturnCode::DataCloneError;
 933             return true;
 934         }
 935 
<span class="line-modified"> 936         VM&amp; vm = m_exec-&gt;vm();</span>
 937         if (isArray(vm, value))
 938             return false;
 939 
 940         if (value.isObject()) {
 941             auto* obj = asObject(value);
 942             if (auto* dateObject = jsDynamicCast&lt;DateInstance*&gt;(vm, obj)) {
 943                 write(DateTag);
 944                 write(dateObject-&gt;internalNumber());
 945                 return true;
 946             }
 947             if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
 948                 if (!startObjectInternal(booleanObject)) // handle duplicates
 949                     return true;
<span class="line-modified"> 950                 write(booleanObject-&gt;internalValue().toBoolean(m_exec) ? TrueObjectTag : FalseObjectTag);</span>
 951                 return true;
 952             }
 953             if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
 954                 if (!startObjectInternal(stringObject)) // handle duplicates
 955                     return true;
<span class="line-modified"> 956                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_exec);</span>
 957                 dumpStringObject(str);
 958                 return true;
 959             }
 960             if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
 961                 if (!startObjectInternal(numberObject)) // handle duplicates
 962                     return true;
 963                 write(NumberObjectTag);
 964                 write(numberObject-&gt;internalValue().asNumber());
 965                 return true;
 966             }
 967             if (auto* file = JSFile::toWrapped(vm, obj)) {
 968                 write(FileTag);
 969                 write(*file);
 970                 return true;
 971             }
 972             if (auto* list = JSFileList::toWrapped(vm, obj)) {
 973                 write(FileListTag);
 974                 write(list-&gt;length());
 975                 for (auto&amp; file : list-&gt;files())
 976                     write(file.get());
</pre>
<hr />
<pre>
1048                 return true;
1049             }
1050             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1051                 if (checkForDuplicate(obj))
1052                     return true;
1053                 bool success = dumpArrayBufferView(obj, code);
1054                 recordObject(obj);
1055                 return success;
1056             }
1057 #if ENABLE(WEB_CRYPTO)
1058             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1059                 write(CryptoKeyTag);
1060                 Vector&lt;uint8_t&gt; serializedKey;
1061                 Vector&lt;String&gt; dummyBlobURLs;
1062                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1063                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1064 #if ENABLE(WEBASSEMBLY)
1065                 WasmModuleArray dummyModules;
1066 #endif
1067                 ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">1068                 CloneSerializer rawKeySerializer(m_exec, dummyMessagePorts, dummyArrayBuffers, { },</span>



1069 #if ENABLE(WEBASSEMBLY)
1070                     dummyModules,
1071 #endif
1072                     dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
1073                 rawKeySerializer.write(key);
1074                 Vector&lt;uint8_t&gt; wrappedKey;
<span class="line-modified">1075                 if (!wrapCryptoKey(m_exec, serializedKey, wrappedKey))</span>
1076                     return false;
1077                 write(wrappedKey);
1078                 return true;
1079             }
1080 #endif
1081 #if ENABLE(WEB_RTC)
1082             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1083                 write(RTCCertificateTag);
1084                 write(rtcCertificate-&gt;expires());
1085                 write(rtcCertificate-&gt;pemCertificate());
1086                 write(rtcCertificate-&gt;origin().toString());
1087                 write(rtcCertificate-&gt;pemPrivateKey());
1088                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1089                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1090                     write(fingerprint.algorithm);
1091                     write(fingerprint.value);
1092                 }
1093                 return true;
1094             }
1095 #endif
</pre>
<hr />
<pre>
1108             if (obj-&gt;inherits&lt;JSDOMPointReadOnly&gt;(vm)) {
1109                 dumpDOMPoint(obj);
1110                 return true;
1111             }
1112             if (obj-&gt;inherits&lt;JSDOMRectReadOnly&gt;(vm)) {
1113                 dumpDOMRect(obj);
1114                 return true;
1115             }
1116             if (obj-&gt;inherits&lt;JSDOMMatrixReadOnly&gt;(vm)) {
1117                 dumpDOMMatrix(obj);
1118                 return true;
1119             }
1120             if (obj-&gt;inherits&lt;JSDOMQuad&gt;(vm)) {
1121                 dumpDOMQuad(obj);
1122                 return true;
1123             }
1124             if (obj-&gt;inherits(vm, JSImageBitmap::info())) {
1125                 dumpImageBitmap(obj, code);
1126                 return true;
1127             }






1128             return false;
1129         }
1130         // Any other types are expected to serialize as null.
1131         write(NullTag);
1132         return true;
1133     }
1134 
1135     void write(SerializationTag tag)
1136     {
1137         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1138     }
1139 
1140     void write(ArrayBufferViewSubtag tag)
1141     {
1142         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1143     }
1144 
1145 #if ENABLE(WEB_CRYPTO)
1146     void write(CryptoKeyClassSubtag tag)
1147     {
</pre>
<hr />
<pre>
1242             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1243         else
1244             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1245 
1246         if (!length)
1247             return;
1248         if (str.is8Bit()) {
1249             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1250                 fail();
1251             return;
1252         }
1253         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1254             fail();
1255     }
1256 
1257     void write(const String&amp; str)
1258     {
1259         if (str.isNull())
1260             write(m_emptyIdentifier);
1261         else
<span class="line-modified">1262             write(Identifier::fromString(m_exec-&gt;vm(), str));</span>
1263     }
1264 
1265     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1266     {
1267         uint32_t size = vector.size();
1268         write(size);
1269         writeLittleEndian(m_buffer, vector.data(), size);
1270     }
1271 
1272     void write(const File&amp; file)
1273     {
1274         m_blobURLs.append(file.url());
1275         write(file.path());
1276         write(file.url());
1277         write(file.type());
1278         write(file.name());
1279         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1280     }
1281 
1282 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
1455             write(isRestrictedToHash);
1456             if (isRestrictedToHash)
1457                 write(hash);
1458             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1459             break;
1460         }
1461     }
1462 #endif
1463 
1464     void write(const uint8_t* data, unsigned length)
1465     {
1466         m_buffer.append(data, length);
1467     }
1468 
1469     Vector&lt;uint8_t&gt;&amp; m_buffer;
1470     Vector&lt;String&gt;&amp; m_blobURLs;
1471     ObjectPool m_objectPool;
1472     ObjectPool m_transferredMessagePorts;
1473     ObjectPool m_transferredArrayBuffers;
1474     ObjectPool m_transferredImageBitmaps;



1475     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1476     StringConstantPool m_constantPool;
1477     Identifier m_emptyIdentifier;
1478     SerializationContext m_context;
1479     ArrayBufferContentsArray&amp; m_sharedBuffers;
1480 #if ENABLE(WEBASSEMBLY)
1481     WasmModuleArray&amp; m_wasmModules;
1482 #endif
1483 };
1484 
1485 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1486 {
<span class="line-modified">1487     VM&amp; vm = m_exec-&gt;vm();</span>
1488     Vector&lt;uint32_t, 16&gt; indexStack;
1489     Vector&lt;uint32_t, 16&gt; lengthStack;
1490     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
1491     Vector&lt;JSObject*, 32&gt; inputObjectStack;
1492     Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
1493     Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
1494     Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
1495     Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">1496     WalkerState state = StateUnknown;</span>
1497     JSValue inValue = in;
1498     while (1) {
<span class="line-modified">1499         switch (state) {</span>
1500             arrayStartState:
1501             case ArrayStartState: {
1502                 ASSERT(isArray(vm, inValue));
1503                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1504                     return SerializationReturnCode::StackOverflowError;
1505 
1506                 JSArray* inArray = asArray(inValue);
1507                 unsigned length = inArray-&gt;length();
1508                 if (!startArray(inArray))
1509                     break;
1510                 inputObjectStack.append(inArray);
1511                 indexStack.append(0);
1512                 lengthStack.append(length);
1513             }
1514             arrayStartVisitMember:
1515             FALLTHROUGH;
1516             case ArrayStartVisitMember: {
1517                 JSObject* array = inputObjectStack.last();
1518                 uint32_t index = indexStack.last();
1519                 if (index == lengthStack.last()) {
1520                     indexStack.removeLast();
1521                     lengthStack.removeLast();
1522 
1523                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1524                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_exec, propertyStack.last(), EnumerationMode());</span>
1525                     if (propertyStack.last().size()) {
1526                         write(NonIndexPropertiesTag);
1527                         indexStack.append(0);
1528                         goto objectStartVisitMember;
1529                     }
1530                     propertyStack.removeLast();
1531 
1532                     endObject();
1533                     inputObjectStack.removeLast();
1534                     break;
1535                 }
<span class="line-modified">1536                 inValue = array-&gt;getDirectIndex(m_exec, index);</span>
1537                 if (!inValue) {
1538                     indexStack.last()++;
1539                     goto arrayStartVisitMember;
1540                 }
1541 
1542                 write(index);
1543                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1544                 if (dumpIfTerminal(inValue, terminalCode)) {
1545                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1546                         return terminalCode;
1547                     indexStack.last()++;
1548                     goto arrayStartVisitMember;
1549                 }
1550                 stateStack.append(ArrayEndVisitMember);
1551                 goto stateUnknown;
1552             }
1553             case ArrayEndVisitMember: {
1554                 indexStack.last()++;
1555                 goto arrayStartVisitMember;
1556             }
1557             objectStartState:
1558             case ObjectStartState: {
1559                 ASSERT(inValue.isObject());
1560                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1561                     return SerializationReturnCode::StackOverflowError;
1562                 JSObject* inObject = asObject(inValue);
1563                 if (!startObject(inObject))
1564                     break;
1565                 // At this point, all supported objects other than Object
1566                 // objects have been handled. If we reach this point and
1567                 // the input is not an Object object then we should throw
1568                 // a DataCloneError.
1569                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1570                     return SerializationReturnCode::DataCloneError;
1571                 inputObjectStack.append(inObject);
1572                 indexStack.append(0);
1573                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1574                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_exec, propertyStack.last(), EnumerationMode());</span>
1575             }
1576             objectStartVisitMember:
1577             FALLTHROUGH;
1578             case ObjectStartVisitMember: {
1579                 JSObject* object = inputObjectStack.last();
1580                 uint32_t index = indexStack.last();
1581                 PropertyNameArray&amp; properties = propertyStack.last();
1582                 if (index == properties.size()) {
1583                     endObject();
1584                     inputObjectStack.removeLast();
1585                     indexStack.removeLast();
1586                     propertyStack.removeLast();
1587                     break;
1588                 }
1589                 inValue = getProperty(vm, object, properties[index]);
1590                 if (shouldTerminate())
1591                     return SerializationReturnCode::ExistingExceptionError;
1592 
1593                 if (!inValue) {
1594                     // Property was removed during serialisation
</pre>
<hr />
<pre>
1606                     goto stateUnknown;
1607                 }
1608                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1609                     return terminalCode;
1610                 FALLTHROUGH;
1611             }
1612             case ObjectEndVisitMember: {
1613                 if (shouldTerminate())
1614                     return SerializationReturnCode::ExistingExceptionError;
1615 
1616                 indexStack.last()++;
1617                 goto objectStartVisitMember;
1618             }
1619             mapStartState: {
1620                 ASSERT(inValue.isObject());
1621                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1622                     return SerializationReturnCode::StackOverflowError;
1623                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1624                 if (!startMap(inMap))
1625                     break;
<span class="line-modified">1626                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterateKeyValue);</span>
1627                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1628                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1629                 mapIteratorStack.append(iterator);
1630                 inputObjectStack.append(inMap);
1631                 goto mapDataStartVisitEntry;
1632             }
1633             mapDataStartVisitEntry:
1634             case MapDataStartVisitEntry: {
1635                 JSMapIterator* iterator = mapIteratorStack.last();
1636                 JSValue key, value;
<span class="line-modified">1637                 if (!iterator-&gt;nextKeyValue(m_exec, key, value)) {</span>
1638                     mapIteratorStack.removeLast();
1639                     JSObject* object = inputObjectStack.last();
1640                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
1641                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1642                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());</span>
1643                     write(NonMapPropertiesTag);
1644                     indexStack.append(0);
1645                     goto objectStartVisitMember;
1646                 }
1647                 inValue = key;
1648                 m_gcBuffer.appendWithCrashOnOverflow(value);
1649                 mapIteratorValueStack.append(value);
1650                 stateStack.append(MapDataEndVisitKey);
1651                 goto stateUnknown;
1652             }
1653             case MapDataEndVisitKey: {
1654                 inValue = mapIteratorValueStack.last();
1655                 mapIteratorValueStack.removeLast();
1656                 stateStack.append(MapDataEndVisitValue);
1657                 goto stateUnknown;
1658             }
1659             case MapDataEndVisitValue: {
1660                 goto mapDataStartVisitEntry;
1661             }
1662 
1663             setStartState: {
1664                 ASSERT(inValue.isObject());
1665                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1666                     return SerializationReturnCode::StackOverflowError;
1667                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1668                 if (!startSet(inSet))
1669                     break;
<span class="line-modified">1670                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterateKey);</span>
1671                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1672                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1673                 setIteratorStack.append(iterator);
1674                 inputObjectStack.append(inSet);
1675                 goto setDataStartVisitEntry;
1676             }
1677             setDataStartVisitEntry:
1678             case SetDataStartVisitEntry: {
1679                 JSSetIterator* iterator = setIteratorStack.last();
1680                 JSValue key;
<span class="line-modified">1681                 if (!iterator-&gt;next(m_exec, key)) {</span>
1682                     setIteratorStack.removeLast();
1683                     JSObject* object = inputObjectStack.last();
1684                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
1685                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1686                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_exec, propertyStack.last(), EnumerationMode());</span>
1687                     write(NonSetPropertiesTag);
1688                     indexStack.append(0);
1689                     goto objectStartVisitMember;
1690                 }
1691                 inValue = key;
1692                 stateStack.append(SetDataEndVisitKey);
1693                 goto stateUnknown;
1694             }
1695             case SetDataEndVisitKey: {
1696                 goto setDataStartVisitEntry;
1697             }
1698 
1699             stateUnknown:
1700             case StateUnknown: {
1701                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1702                 if (dumpIfTerminal(inValue, terminalCode)) {
1703                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1704                         return terminalCode;
1705                     break;
1706                 }
1707 
1708                 if (isArray(vm, inValue))
1709                     goto arrayStartState;
1710                 if (isMap(vm, inValue))
1711                     goto mapStartState;
1712                 if (isSet(vm, inValue))
1713                     goto setStartState;
1714                 goto objectStartState;
1715             }
1716         }
1717         if (stateStack.isEmpty())
1718             break;
1719 
<span class="line-modified">1720         state = stateStack.last();</span>
1721         stateStack.removeLast();
1722     }
1723     if (m_failed)
1724         return SerializationReturnCode::UnspecifiedError;
1725 
1726     return SerializationReturnCode::SuccessfullyCompleted;
1727 }
1728 
1729 class CloneDeserializer : CloneBase {
1730 public:
1731     static String deserializeString(const Vector&lt;uint8_t&gt;&amp; buffer)
1732     {
1733         if (buffer.isEmpty())
1734             return String();
1735         const uint8_t* ptr = buffer.begin();
1736         const uint8_t* end = buffer.end();
1737         uint32_t version;
1738         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1739             return String();
1740         uint8_t tag;
1741         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1742             return String();
1743         uint32_t length;
1744         if (!readLittleEndian(ptr, end, length))
1745             return String();
1746         bool is8Bit = length &amp; StringDataIs8BitFlag;
1747         length &amp;= ~StringDataIs8BitFlag;
1748         String str;
1749         if (!readString(ptr, end, str, length, is8Bit))
1750             return String();
1751         return str;
1752     }
1753 
<span class="line-modified">1754     static DeserializationResult deserialize(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>




1755 #if ENABLE(WEBASSEMBLY)
1756         , WasmModuleArray* wasmModules
1757 #endif
1758         )
1759     {
1760         if (!buffer.size())
1761             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<span class="line-modified">1762         CloneDeserializer deserializer(exec, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>



1763 #if ENABLE(WEBASSEMBLY)
1764             , wasmModules
1765 #endif
1766             );
1767         if (!deserializer.isValid())
1768             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1769         return deserializer.deserialize();
1770     }
1771 
1772 private:
1773     struct CachedString {
1774         CachedString(const String&amp; string)
1775             : m_string(string)
1776         {
1777         }
1778 
<span class="line-modified">1779         JSValue jsString(ExecState* exec)</span>
1780         {
1781             if (!m_jsString)
<span class="line-modified">1782                 m_jsString = JSC::jsString(exec-&gt;vm(), m_string);</span>
1783             return m_jsString;
1784         }
1785         const String&amp; string() { return m_string; }
1786         String takeString() { return WTFMove(m_string); }
1787 
1788     private:
1789         String m_string;
1790         JSValue m_jsString;
1791     };
1792 
1793     struct CachedStringRef {
1794         CachedStringRef()
1795             : m_base(0)
1796             , m_index(0)
1797         {
1798         }
1799         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1800             : m_base(base)
1801             , m_index(index)
1802         {
1803         }
1804 
1805         CachedString* operator-&gt;() { ASSERT(m_base); return &amp;m_base-&gt;at(m_index); }
1806 
1807     private:
1808         Vector&lt;CachedString&gt;* m_base;
1809         size_t m_index;
1810     };
1811 
<span class="line-modified">1812     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers,</span>



1813 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">1814         WasmModuleArray* wasmModules,</span>
1815 #endif
<span class="line-modified">1816         const Vector&lt;uint8_t&gt;&amp; buffer)</span>
<span class="line-modified">1817         : CloneBase(exec)</span>
1818         , m_globalObject(globalObject)
1819         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1820         , m_ptr(buffer.data())
1821         , m_end(buffer.data() + buffer.size())
1822         , m_version(0xFFFFFFFF)
1823         , m_messagePorts(messagePorts)
1824         , m_arrayBufferContents(arrayBufferContents)
1825         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1826         , m_imageBuffers(WTFMove(imageBuffers))
1827         , m_imageBitmaps(m_imageBuffers.size())




1828 #if ENABLE(WEBASSEMBLY)
1829         , m_wasmModules(wasmModules)
1830 #endif
1831     {
1832         if (!read(m_version))
1833             m_version = 0xFFFFFFFF;
1834     }
1835 
<span class="line-modified">1836     CloneDeserializer(ExecState* exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>



1837 #if ENABLE(WEBASSEMBLY)
1838         , WasmModuleArray* wasmModules
1839 #endif
1840         )
<span class="line-modified">1841         : CloneBase(exec)</span>
1842         , m_globalObject(globalObject)
1843         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1844         , m_ptr(buffer.data())
1845         , m_end(buffer.data() + buffer.size())
1846         , m_version(0xFFFFFFFF)
1847         , m_messagePorts(messagePorts)
1848         , m_arrayBufferContents(arrayBufferContents)
1849         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1850         , m_blobURLs(blobURLs)
1851         , m_blobFilePaths(blobFilePaths)
1852         , m_sharedBuffers(sharedBuffers)
1853         , m_imageBuffers(WTFMove(imageBuffers))
1854         , m_imageBitmaps(m_imageBuffers.size())




1855 #if ENABLE(WEBASSEMBLY)
1856         , m_wasmModules(wasmModules)
1857 #endif
1858     {
1859         if (!read(m_version))
1860             m_version = 0xFFFFFFFF;
1861     }
1862 
1863     DeserializationResult deserialize();
1864 
1865     bool isValid() const { return m_version &lt;= CurrentVersion; }
1866 
1867     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1868     {
1869         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1870             fail();
1871             return false;
1872         }
1873         return true;
1874     }
</pre>
<hr />
<pre>
2039         return true;
2040     }
2041 
2042     SerializationTag readTag()
2043     {
2044         if (m_ptr &gt;= m_end)
2045             return ErrorTag;
2046         return static_cast&lt;SerializationTag&gt;(*m_ptr++);
2047     }
2048 
2049     bool readArrayBufferViewSubtag(ArrayBufferViewSubtag&amp; tag)
2050     {
2051         if (m_ptr &gt;= m_end)
2052             return false;
2053         tag = static_cast&lt;ArrayBufferViewSubtag&gt;(*m_ptr++);
2054         return true;
2055     }
2056 
2057     void putProperty(JSObject* object, unsigned index, JSValue value)
2058     {
<span class="line-modified">2059         object-&gt;putDirectIndex(m_exec, index, value);</span>
2060     }
2061 
2062     void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
2063     {
<span class="line-modified">2064         object-&gt;putDirectMayBeIndex(m_exec, property, value);</span>
2065     }
2066 
2067     bool readFile(RefPtr&lt;File&gt;&amp; file)
2068     {
2069         CachedStringRef path;
2070         if (!readStringData(path))
2071             return false;
2072         CachedStringRef url;
2073         if (!readStringData(url))
2074             return false;
2075         CachedStringRef type;
2076         if (!readStringData(type))
2077             return false;
2078         CachedStringRef name;
2079         if (!readStringData(name))
2080             return false;
2081         Optional&lt;int64_t&gt; optionalLastModified;
2082         if (m_version &gt; 6) {
2083             double lastModified;
2084             if (!read(lastModified))
2085                 return false;
2086             if (lastModified &gt;= 0)
2087                 optionalLastModified = lastModified;
2088         }
2089 
2090         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2091         String filePath = blobFilePathForBlobURL(url-&gt;string());
2092         if (filePath.isEmpty())
2093             filePath = path-&gt;string();
2094 
2095         if (m_isDOMGlobalObject)
<span class="line-modified">2096             file = File::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
2097         return true;
2098     }
2099 
2100     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2101     {
2102         uint32_t length;
2103         if (!read(length))
2104             return false;
2105         if (m_ptr + length &gt; m_end)
2106             return false;
2107         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2108         m_ptr += length;
2109         return true;
2110     }
2111 
2112     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2113     {
2114         ArrayBufferViewSubtag arrayBufferViewSubtag;
2115         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2116             return false;
2117         uint32_t byteOffset;
2118         if (!read(byteOffset))
2119             return false;
2120         uint32_t byteLength;
2121         if (!read(byteLength))
2122             return false;
2123         JSObject* arrayBufferObj = asObject(readTerminal());
2124         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2125             return false;
2126 
2127         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2128         if (!elementSize)
2129             return false;
2130         unsigned length = byteLength / elementSize;
2131         if (length * elementSize != byteLength)
2132             return false;
2133 
2134         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2135         switch (arrayBufferViewSubtag) {
2136         case DataViewTag:
<span class="line-modified">2137             arrayBufferView = toJS(m_exec, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2138             return true;
2139         case Int8ArrayTag:
<span class="line-modified">2140             arrayBufferView = toJS(m_exec, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2141             return true;
2142         case Uint8ArrayTag:
<span class="line-modified">2143             arrayBufferView = toJS(m_exec, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2144             return true;
2145         case Uint8ClampedArrayTag:
<span class="line-modified">2146             arrayBufferView = toJS(m_exec, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2147             return true;
2148         case Int16ArrayTag:
<span class="line-modified">2149             arrayBufferView = toJS(m_exec, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2150             return true;
2151         case Uint16ArrayTag:
<span class="line-modified">2152             arrayBufferView = toJS(m_exec, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2153             return true;
2154         case Int32ArrayTag:
<span class="line-modified">2155             arrayBufferView = toJS(m_exec, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2156             return true;
2157         case Uint32ArrayTag:
<span class="line-modified">2158             arrayBufferView = toJS(m_exec, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2159             return true;
2160         case Float32ArrayTag:
<span class="line-modified">2161             arrayBufferView = toJS(m_exec, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2162             return true;
2163         case Float64ArrayTag:
<span class="line-modified">2164             arrayBufferView = toJS(m_exec, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2165             return true;
2166         default:
2167             return false;
2168         }
2169     }
2170 
2171     bool read(Vector&lt;uint8_t&gt;&amp; result)
2172     {
2173         ASSERT(result.isEmpty());
2174         uint32_t size;
2175         if (!read(size))
2176             return false;
2177         if (m_ptr + size &gt; m_end)
2178             return false;
2179         result.append(m_ptr, size);
2180         m_ptr += size;
2181         return true;
2182     }
2183 
2184 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
2300     {
2301         CryptoAlgorithmIdentifier algorithm;
2302         if (!read(algorithm))
2303             return false;
2304         if (!CryptoKeyAES::isValidAESAlgorithm(algorithm))
2305             return false;
2306         Vector&lt;uint8_t&gt; keyData;
2307         if (!read(keyData))
2308             return false;
2309         result = CryptoKeyAES::importRaw(algorithm, WTFMove(keyData), extractable, usages);
2310         return true;
2311     }
2312 
2313     bool readRSAKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2314     {
2315         CryptoAlgorithmIdentifier algorithm;
2316         if (!read(algorithm))
2317             return false;
2318 
2319         int32_t isRestrictedToHash;
<span class="line-modified">2320         CryptoAlgorithmIdentifier hash;</span>
2321         if (!read(isRestrictedToHash))
2322             return false;
2323         if (isRestrictedToHash &amp;&amp; !read(hash))
2324             return false;
2325 
2326         CryptoKeyAsymmetricTypeSubtag type;
2327         if (!read(type))
2328             return false;
2329 
2330         Vector&lt;uint8_t&gt; modulus;
2331         if (!read(modulus))
2332             return false;
2333         Vector&lt;uint8_t&gt; exponent;
2334         if (!read(exponent))
2335             return false;
2336 
2337         if (type == CryptoKeyAsymmetricTypeSubtag::Public) {
2338             auto keyData = CryptoKeyRSAComponents::createPublic(modulus, exponent);
2339             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2340             result = WTFMove(key);
</pre>
<hr />
<pre>
2493             if (!readRSAKey(extractable, usages, result))
2494                 return false;
2495             break;
2496         case CryptoKeyClassSubtag::EC:
2497             if (!readECKey(extractable, usages, result))
2498                 return false;
2499             break;
2500         case CryptoKeyClassSubtag::Raw:
2501             if (!readRawKey(usages, result))
2502                 return false;
2503             break;
2504         }
2505         cryptoKey = getJSValue(result.get());
2506         return true;
2507     }
2508 #endif
2509 
2510     template&lt;class T&gt;
2511     JSValue getJSValue(T* nativeObj)
2512     {
<span class="line-modified">2513         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
2514     }
2515 
2516     template&lt;class T&gt;
2517     JSValue getJSValue(T&amp; nativeObj)
2518     {
<span class="line-modified">2519         return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
2520     }
2521 
2522     template&lt;class T&gt;
2523     JSValue readDOMPoint()
2524     {
2525         double x;
2526         if (!read(x))
2527             return { };
2528         double y;
2529         if (!read(y))
2530             return { };
2531         double z;
2532         if (!read(z))
2533             return { };
2534         double w;
2535         if (!read(w))
2536             return { };
2537 
<span class="line-modified">2538         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));</span>
2539     }
2540 
2541     template&lt;class T&gt;
2542     JSValue readDOMMatrix()
2543     {
2544         uint8_t is2D;
2545         if (!read(is2D))
2546             return { };
2547 
2548         if (is2D) {
2549             double m11;
2550             if (!read(m11))
2551                 return { };
2552             double m12;
2553             if (!read(m12))
2554                 return { };
2555             double m21;
2556             if (!read(m21))
2557                 return { };
2558             double m22;
2559             if (!read(m22))
2560                 return { };
2561             double m41;
2562             if (!read(m41))
2563                 return { };
2564             double m42;
2565             if (!read(m42))
2566                 return { };
2567 
2568             TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
<span class="line-modified">2569             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));</span>
2570         } else {
2571             double m11;
2572             if (!read(m11))
2573                 return { };
2574             double m12;
2575             if (!read(m12))
2576                 return { };
2577             double m13;
2578             if (!read(m13))
2579                 return { };
2580             double m14;
2581             if (!read(m14))
2582                 return { };
2583             double m21;
2584             if (!read(m21))
2585                 return { };
2586             double m22;
2587             if (!read(m22))
2588                 return { };
2589             double m23;
</pre>
<hr />
<pre>
2601             double m33;
2602             if (!read(m33))
2603                 return { };
2604             double m34;
2605             if (!read(m34))
2606                 return { };
2607             double m41;
2608             if (!read(m41))
2609                 return { };
2610             double m42;
2611             if (!read(m42))
2612                 return { };
2613             double m43;
2614             if (!read(m43))
2615                 return { };
2616             double m44;
2617             if (!read(m44))
2618                 return { };
2619 
2620             TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
<span class="line-modified">2621             return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));</span>
2622         }
2623     }
2624 
2625     template&lt;class T&gt;
2626     JSValue readDOMRect()
2627     {
2628         double x;
2629         if (!read(x))
2630             return { };
2631         double y;
2632         if (!read(y))
2633             return { };
2634         double width;
2635         if (!read(width))
2636             return { };
2637         double height;
2638         if (!read(height))
2639             return { };
2640 
<span class="line-modified">2641         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));</span>
2642     }
2643 
2644     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2645     {
2646         DOMPointInit point;
2647         if (!read(point.x))
2648             return WTF::nullopt;
2649         if (!read(point.y))
2650             return WTF::nullopt;
2651         if (!read(point.z))
2652             return WTF::nullopt;
2653         if (!read(point.w))
2654             return WTF::nullopt;
2655 
2656         return point;
2657     }
2658 
2659     JSValue readDOMQuad()
2660     {
2661         auto p1 = readDOMPointInit();
2662         if (!p1)
2663             return JSValue();
2664         auto p2 = readDOMPointInit();
2665         if (!p2)
2666             return JSValue();
2667         auto p3 = readDOMPointInit();
2668         if (!p3)
2669             return JSValue();
2670         auto p4 = readDOMPointInit();
2671         if (!p4)
2672             return JSValue();
2673 
<span class="line-modified">2674         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));</span>
2675     }
2676 
<span class="line-modified">2677     JSValue readImageBitmap()</span>
2678     {
2679         uint32_t index;
2680         bool indexSuccessfullyRead = read(index);
2681         if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
2682             fail();
2683             return JSValue();
2684         }
2685 
2686         if (!m_imageBitmaps[index])
2687             m_imageBitmaps[index] = ImageBitmap::create(WTFMove(m_imageBuffers.at(index)));
2688 
2689         auto bitmap = m_imageBitmaps[index].get();
2690         return getJSValue(bitmap);
2691     }
2692 


















2693 #if ENABLE(WEB_RTC)
2694     JSValue readRTCCertificate()
2695     {
2696         double expires;
2697         if (!read(expires)) {
2698             fail();
2699             return JSValue();
2700         }
2701         CachedStringRef certificate;
2702         if (!readStringData(certificate)) {
2703             fail();
2704             return JSValue();
2705         }
2706         CachedStringRef origin;
2707         if (!readStringData(origin)) {
2708             fail();
2709             return JSValue();
2710         }
2711         CachedStringRef keyedMaterial;
2712         if (!readStringData(keyedMaterial)) {
2713             fail();
2714             return JSValue();
2715         }
2716         unsigned size = 0;
2717         if (!read(size))
2718             return JSValue();
2719 
2720         Vector&lt;RTCCertificate::DtlsFingerprint&gt; fingerprints;
2721         fingerprints.reserveInitialCapacity(size);
2722         for (unsigned i = 0; i &lt; size; i++) {
2723             CachedStringRef algorithm;
2724             if (!readStringData(algorithm))
2725                 return JSValue();
2726             CachedStringRef value;
2727             if (!readStringData(value))
2728                 return JSValue();
2729             fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
2730         }
2731 
2732         if (!m_isDOMGlobalObject)
<span class="line-modified">2733             return constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());</span>
2734 
2735         auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
<span class="line-modified">2736         return toJSNewlyCreated(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));</span>
2737     }
2738 #endif
2739 































2740     JSValue readTerminal()
2741     {
2742         SerializationTag tag = readTag();
2743         switch (tag) {
2744         case UndefinedTag:
2745             return jsUndefined();
2746         case NullTag:
2747             return jsNull();
2748         case IntTag: {
2749             int32_t i;
2750             if (!read(i))
2751                 return JSValue();
2752             return jsNumber(i);
2753         }
2754         case ZeroTag:
2755             return jsNumber(0);
2756         case OneTag:
2757             return jsNumber(1);
2758         case FalseTag:
2759             return jsBoolean(false);
2760         case TrueTag:
2761             return jsBoolean(true);
2762         case FalseObjectTag: {
<span class="line-modified">2763             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">2764             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(false));</span>
2765             m_gcBuffer.appendWithCrashOnOverflow(obj);
2766             return obj;
2767         }
2768         case TrueObjectTag: {
<span class="line-modified">2769             BooleanObject* obj = BooleanObject::create(m_exec-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">2770             obj-&gt;setInternalValue(m_exec-&gt;vm(), jsBoolean(true));</span>
2771             m_gcBuffer.appendWithCrashOnOverflow(obj);
2772             return obj;
2773         }
2774         case DoubleTag: {
2775             double d;
2776             if (!read(d))
2777                 return JSValue();
2778             return jsNumber(d);
2779         }
2780         case NumberObjectTag: {
2781             double d;
2782             if (!read(d))
2783                 return JSValue();
<span class="line-modified">2784             NumberObject* obj = constructNumber(m_exec, m_globalObject, jsNumber(d));</span>
2785             m_gcBuffer.appendWithCrashOnOverflow(obj);
2786             return obj;
2787         }
2788         case DateTag: {
2789             double d;
2790             if (!read(d))
2791                 return JSValue();
<span class="line-modified">2792             return DateInstance::create(m_exec-&gt;vm(), m_globalObject-&gt;dateStructure(), d);</span>
2793         }
2794         case FileTag: {
2795             RefPtr&lt;File&gt; file;
2796             if (!readFile(file))
2797                 return JSValue();
2798             if (!m_isDOMGlobalObject)
2799                 return jsNull();
<span class="line-modified">2800             return toJS(m_exec, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());</span>
2801         }
2802         case FileListTag: {
2803             unsigned length = 0;
2804             if (!read(length))
2805                 return JSValue();
2806             Vector&lt;Ref&lt;File&gt;&gt; files;
2807             for (unsigned i = 0; i &lt; length; i++) {
2808                 RefPtr&lt;File&gt; file;
2809                 if (!readFile(file))
2810                     return JSValue();
2811                 if (m_isDOMGlobalObject)
2812                     files.append(file.releaseNonNull());
2813             }
2814             if (!m_isDOMGlobalObject)
2815                 return jsNull();
2816             return getJSValue(FileList::create(WTFMove(files)).get());
2817         }
2818         case ImageDataTag: {
2819             uint32_t width;
2820             if (!read(width))
</pre>
<hr />
<pre>
2842             }
2843             if (length)
2844                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2845             else
2846                 result-&gt;data()-&gt;zeroFill();
2847             m_ptr += length;
2848             return getJSValue(result.get());
2849         }
2850         case BlobTag: {
2851             CachedStringRef url;
2852             if (!readStringData(url))
2853                 return JSValue();
2854             CachedStringRef type;
2855             if (!readStringData(type))
2856                 return JSValue();
2857             unsigned long long size = 0;
2858             if (!read(size))
2859                 return JSValue();
2860             if (!m_isDOMGlobalObject)
2861                 return jsNull();
<span class="line-modified">2862             return getJSValue(Blob::deserialize(jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject)-&gt;scriptExecutionContext()-&gt;sessionID(), URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
2863         }
2864         case StringTag: {
2865             CachedStringRef cachedString;
2866             if (!readStringData(cachedString))
2867                 return JSValue();
<span class="line-modified">2868             return cachedString-&gt;jsString(m_exec);</span>
2869         }
2870         case EmptyStringTag:
<span class="line-modified">2871             return jsEmptyString(m_exec-&gt;vm());</span>
2872         case StringObjectTag: {
2873             CachedStringRef cachedString;
2874             if (!readStringData(cachedString))
2875                 return JSValue();
<span class="line-modified">2876             StringObject* obj = constructString(m_exec-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_exec));</span>
2877             m_gcBuffer.appendWithCrashOnOverflow(obj);
2878             return obj;
2879         }
2880         case EmptyStringObjectTag: {
<span class="line-modified">2881             VM&amp; vm = m_exec-&gt;vm();</span>
2882             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
2883             m_gcBuffer.appendWithCrashOnOverflow(obj);
2884             return obj;
2885         }
2886         case RegExpTag: {
2887             CachedStringRef pattern;
2888             if (!readStringData(pattern))
2889                 return JSValue();
2890             CachedStringRef flags;
2891             if (!readStringData(flags))
2892                 return JSValue();
2893             auto reFlags = Yarr::parseFlags(flags-&gt;string());
2894             ASSERT(reFlags.hasValue());
<span class="line-modified">2895             VM&amp; vm = m_exec-&gt;vm();</span>
2896             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());
2897             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
2898         }
2899         case ObjectReferenceTag: {
2900             unsigned index = 0;
2901             if (!readConstantPoolIndex(m_gcBuffer, index)) {
2902                 fail();
2903                 return JSValue();
2904             }
2905             return m_gcBuffer.at(index);
2906         }
2907         case MessagePortReferenceTag: {
2908             uint32_t index;
2909             bool indexSuccessfullyRead = read(index);
2910             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
2911                 fail();
2912                 return JSValue();
2913             }
2914             return getJSValue(m_messagePorts[index].get());
2915         }
2916 #if ENABLE(WEBASSEMBLY)
2917         case WasmModuleTag: {
2918             uint32_t index;
2919             bool indexSuccessfullyRead = read(index);
2920             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
2921                 fail();
2922                 return JSValue();
2923             }
<span class="line-modified">2924             auto scope = DECLARE_THROW_SCOPE(m_exec-&gt;vm());</span>
<span class="line-modified">2925             JSValue result = JSC::JSWebAssemblyModule::createStub(m_exec-&gt;vm(), m_exec, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
2926             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
2927             // module to not have been a valid module. Therefore, createStub should
2928             // not trow.
2929             scope.releaseAssertNoException();
2930             m_gcBuffer.appendWithCrashOnOverflow(result);
2931             return result;
2932         }
2933 #endif
2934         case ArrayBufferTag: {
2935             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
2936             if (!readArrayBuffer(arrayBuffer)) {
2937                 fail();
2938                 return JSValue();
2939             }
2940             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
2941             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
2942             // array buffers while the sender is. In that case, we would see a null structure here.
2943             if (!structure) {
2944                 fail();
2945                 return JSValue();
2946             }
<span class="line-modified">2947             JSValue result = JSArrayBuffer::create(m_exec-&gt;vm(), structure, WTFMove(arrayBuffer));</span>
2948             m_gcBuffer.appendWithCrashOnOverflow(result);
2949             return result;
2950         }
2951         case ArrayBufferTransferTag: {
2952             uint32_t index;
2953             bool indexSuccessfullyRead = read(index);
2954             if (!indexSuccessfullyRead || index &gt;= m_arrayBuffers.size()) {
2955                 fail();
2956                 return JSValue();
2957             }
2958 
2959             if (!m_arrayBuffers[index])
2960                 m_arrayBuffers[index] = ArrayBuffer::create(WTFMove(m_arrayBufferContents-&gt;at(index)));
2961 
2962             return getJSValue(m_arrayBuffers[index].get());
2963         }
2964         case SharedArrayBufferTag: {
2965             uint32_t index = UINT_MAX;
2966             bool indexSuccessfullyRead = read(index);
2967             if (!indexSuccessfullyRead || !m_sharedBuffers || index &gt;= m_sharedBuffers-&gt;size()) {
2968                 fail();
2969                 return JSValue();
2970             }
2971 
2972             RELEASE_ASSERT(m_sharedBuffers-&gt;at(index));
2973             auto buffer = ArrayBuffer::create(WTFMove(m_sharedBuffers-&gt;at(index)));
2974             JSValue result = getJSValue(buffer.get());
2975             m_gcBuffer.appendWithCrashOnOverflow(result);
2976             return result;
2977         }
2978         case ArrayBufferViewTag: {
2979             JSValue arrayBufferView;
<span class="line-modified">2980             if (!readArrayBufferView(m_exec-&gt;vm(), arrayBufferView)) {</span>
2981                 fail();
2982                 return JSValue();
2983             }
2984             m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
2985             return arrayBufferView;
2986         }
2987 #if ENABLE(WEB_CRYPTO)
2988         case CryptoKeyTag: {
2989             Vector&lt;uint8_t&gt; wrappedKey;
2990             if (!read(wrappedKey)) {
2991                 fail();
2992                 return JSValue();
2993             }
2994             Vector&lt;uint8_t&gt; serializedKey;
<span class="line-modified">2995             if (!unwrapCryptoKey(m_exec, wrappedKey, serializedKey)) {</span>
2996                 fail();
2997                 return JSValue();
2998             }
2999             JSValue cryptoKey;
3000             Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
<span class="line-modified">3001             CloneDeserializer rawKeyDeserializer(m_exec, m_globalObject, dummyMessagePorts, nullptr, { },</span>
<span class="line-removed">3002 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-removed">3003                 nullptr,</span>
<span class="line-removed">3004 #endif</span>
<span class="line-removed">3005                 serializedKey);</span>
3006             if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
3007                 fail();
3008                 return JSValue();
3009             }
3010             m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
3011             return cryptoKey;
3012         }
3013 #endif
3014         case DOMPointReadOnlyTag:
3015             return readDOMPoint&lt;DOMPointReadOnly&gt;();
3016         case DOMPointTag:
3017             return readDOMPoint&lt;DOMPoint&gt;();
3018         case DOMRectReadOnlyTag:
3019             return readDOMRect&lt;DOMRectReadOnly&gt;();
3020         case DOMRectTag:
3021             return readDOMRect&lt;DOMRect&gt;();
3022         case DOMMatrixReadOnlyTag:
3023             return readDOMMatrix&lt;DOMMatrixReadOnly&gt;();
3024         case DOMMatrixTag:
3025             return readDOMMatrix&lt;DOMMatrix&gt;();
3026         case DOMQuadTag:
3027             return readDOMQuad();
3028         case ImageBitmapTransferTag:
<span class="line-modified">3029             return readImageBitmap();</span>
3030 #if ENABLE(WEB_RTC)
3031         case RTCCertificateTag:
3032             return readRTCCertificate();
3033 






3034 #endif
3035         default:
3036             m_ptr--; // Push the tag back
3037             return JSValue();
3038         }
3039     }
3040 
3041     template&lt;SerializationTag Tag&gt;
3042     bool consumeCollectionDataTerminationIfPossible()
3043     {
3044         if (readTag() == Tag)
3045             return true;
3046         m_ptr--;
3047         return false;
3048     }
3049 
3050     JSGlobalObject* m_globalObject;
3051     bool m_isDOMGlobalObject;
3052     const uint8_t* m_ptr;
3053     const uint8_t* m_end;
3054     unsigned m_version;
3055     Vector&lt;CachedString&gt; m_constantPool;
3056     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3057     ArrayBufferContentsArray* m_arrayBufferContents;
3058     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3059     Vector&lt;String&gt; m_blobURLs;
3060     Vector&lt;String&gt; m_blobFilePaths;
3061     ArrayBufferContentsArray* m_sharedBuffers;
3062     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3063     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;




3064 #if ENABLE(WEBASSEMBLY)
3065     WasmModuleArray* m_wasmModules;
3066 #endif
3067 
3068     String blobFilePathForBlobURL(const String&amp; blobURL)
3069     {
3070         size_t i = 0;
3071         for (; i &lt; m_blobURLs.size(); ++i) {
3072             if (m_blobURLs[i] == blobURL)
3073                 break;
3074         }
3075 
3076         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3077     }
3078 };
3079 
3080 DeserializationResult CloneDeserializer::deserialize()
3081 {
<span class="line-modified">3082     VM&amp; vm = m_exec-&gt;vm();</span>
3083     auto scope = DECLARE_THROW_SCOPE(vm);
3084 
3085     Vector&lt;uint32_t, 16&gt; indexStack;
3086     Vector&lt;Identifier, 16&gt; propertyNameStack;
3087     Vector&lt;JSObject*, 32&gt; outputObjectStack;
3088     Vector&lt;JSValue, 4&gt; mapKeyStack;
3089     Vector&lt;JSMap*, 4&gt; mapStack;
3090     Vector&lt;JSSet*, 4&gt; setStack;
3091     Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">3092     WalkerState state = StateUnknown;</span>
3093     JSValue outValue;
3094 
3095     while (1) {
<span class="line-modified">3096         switch (state) {</span>
3097         arrayStartState:
3098         case ArrayStartState: {
3099             uint32_t length;
3100             if (!read(length)) {
3101                 fail();
3102                 goto error;
3103             }
<span class="line-modified">3104             JSArray* outArray = constructEmptyArray(m_exec, 0, m_globalObject, length);</span>
3105             if (UNLIKELY(scope.exception()))
3106                 goto error;
3107             m_gcBuffer.appendWithCrashOnOverflow(outArray);
3108             outputObjectStack.append(outArray);
3109         }
3110         arrayStartVisitMember:
3111         FALLTHROUGH;
3112         case ArrayStartVisitMember: {
3113             uint32_t index;
3114             if (!read(index)) {
3115                 fail();
3116                 goto error;
3117             }
3118             if (index == TerminatorTag) {
3119                 JSObject* outArray = outputObjectStack.last();
3120                 outValue = outArray;
3121                 outputObjectStack.removeLast();
3122                 break;
3123             } else if (index == NonIndexPropertiesTag) {
3124                 goto objectStartVisitMember;
</pre>
<hr />
<pre>
3127             if (JSValue terminal = readTerminal()) {
3128                 putProperty(outputObjectStack.last(), index, terminal);
3129                 goto arrayStartVisitMember;
3130             }
3131             if (m_failed)
3132                 goto error;
3133             indexStack.append(index);
3134             stateStack.append(ArrayEndVisitMember);
3135             goto stateUnknown;
3136         }
3137         case ArrayEndVisitMember: {
3138             JSObject* outArray = outputObjectStack.last();
3139             putProperty(outArray, indexStack.last(), outValue);
3140             indexStack.removeLast();
3141             goto arrayStartVisitMember;
3142         }
3143         objectStartState:
3144         case ObjectStartState: {
3145             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3146                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">3147             JSObject* outObject = constructEmptyObject(m_exec, m_globalObject-&gt;objectPrototype());</span>
3148             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3149             outputObjectStack.append(outObject);
3150         }
3151         objectStartVisitMember:
3152         FALLTHROUGH;
3153         case ObjectStartVisitMember: {
3154             CachedStringRef cachedString;
3155             bool wasTerminator = false;
3156             if (!readStringData(cachedString, wasTerminator)) {
3157                 if (!wasTerminator)
3158                     goto error;
3159 
3160                 JSObject* outObject = outputObjectStack.last();
3161                 outValue = outObject;
3162                 outputObjectStack.removeLast();
3163                 break;
3164             }
3165 
3166             if (JSValue terminal = readTerminal()) {
3167                 putProperty(outputObjectStack.last(), Identifier::fromString(vm, cachedString-&gt;string()), terminal);
3168                 goto objectStartVisitMember;
3169             }
3170             stateStack.append(ObjectEndVisitMember);
3171             propertyNameStack.append(Identifier::fromString(vm, cachedString-&gt;string()));
3172             goto stateUnknown;
3173         }
3174         case ObjectEndVisitMember: {
3175             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3176             propertyNameStack.removeLast();
3177             goto objectStartVisitMember;
3178         }
3179         mapObjectStartState: {
3180             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3181                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">3182             JSMap* map = JSMap::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;mapStructure());</span>
3183             if (UNLIKELY(scope.exception()))
3184                 goto error;
3185             m_gcBuffer.appendWithCrashOnOverflow(map);
3186             outputObjectStack.append(map);
3187             mapStack.append(map);
3188             goto mapDataStartVisitEntry;
3189         }
3190         mapDataStartVisitEntry:
3191         case MapDataStartVisitEntry: {
3192             if (consumeCollectionDataTerminationIfPossible&lt;NonMapPropertiesTag&gt;()) {
3193                 mapStack.removeLast();
3194                 goto objectStartVisitMember;
3195             }
3196             stateStack.append(MapDataEndVisitKey);
3197             goto stateUnknown;
3198         }
3199         case MapDataEndVisitKey: {
3200             mapKeyStack.append(outValue);
3201             stateStack.append(MapDataEndVisitValue);
3202             goto stateUnknown;
3203         }
3204         case MapDataEndVisitValue: {
<span class="line-modified">3205             mapStack.last()-&gt;set(m_exec, mapKeyStack.last(), outValue);</span>
3206             mapKeyStack.removeLast();
3207             goto mapDataStartVisitEntry;
3208         }
3209 
3210         setObjectStartState: {
3211             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3212                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">3213             JSSet* set = JSSet::create(m_exec, m_exec-&gt;vm(), m_globalObject-&gt;setStructure());</span>
3214             if (UNLIKELY(scope.exception()))
3215                 goto error;
3216             m_gcBuffer.appendWithCrashOnOverflow(set);
3217             outputObjectStack.append(set);
3218             setStack.append(set);
3219             goto setDataStartVisitEntry;
3220         }
3221         setDataStartVisitEntry:
3222         case SetDataStartVisitEntry: {
3223             if (consumeCollectionDataTerminationIfPossible&lt;NonSetPropertiesTag&gt;()) {
3224                 setStack.removeLast();
3225                 goto objectStartVisitMember;
3226             }
3227             stateStack.append(SetDataEndVisitKey);
3228             goto stateUnknown;
3229         }
3230         case SetDataEndVisitKey: {
3231             JSSet* set = setStack.last();
<span class="line-modified">3232             set-&gt;add(m_exec, outValue);</span>
3233             goto setDataStartVisitEntry;
3234         }
3235 
3236         stateUnknown:
3237         case StateUnknown:
3238             if (JSValue terminal = readTerminal()) {
3239                 outValue = terminal;
3240                 break;
3241             }
3242             SerializationTag tag = readTag();
3243             if (tag == ArrayTag)
3244                 goto arrayStartState;
3245             if (tag == ObjectTag)
3246                 goto objectStartState;
3247             if (tag == MapObjectTag)
3248                 goto mapObjectStartState;
3249             if (tag == SetObjectTag)
3250                 goto setObjectStartState;
3251             goto error;
3252         }
3253         if (stateStack.isEmpty())
3254             break;
3255 
<span class="line-modified">3256         state = stateStack.last();</span>
3257         stateStack.removeLast();
3258     }
3259     ASSERT(outValue);
3260     ASSERT(!m_failed);
3261     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3262 error:
3263     fail();
3264     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3265 }
3266 
3267 SerializedScriptValue::~SerializedScriptValue() = default;
3268 
3269 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3270     : m_data(WTFMove(buffer))
3271 {
3272 }
3273 
3274 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3275     : m_data(WTFMove(buffer))
3276     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3277 {
3278 }
3279 
3280 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers



3281 #if ENABLE(WEBASSEMBLY)
3282         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3283 #endif
3284         )
3285     : m_data(WTFMove(buffer))
3286     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3287     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3288     , m_imageBuffers(WTFMove(imageBuffers))



3289 #if ENABLE(WEBASSEMBLY)
3290     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3291 #endif
3292 {
3293     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3294     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3295     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3296     for (auto&amp; url : blobURLs)
3297         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3298 }
3299 
3300 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3301 {
3302     if (arrayBuffers.isEmpty())
3303         return nullptr;
3304 
3305     auto contents = makeUnique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());
3306 
3307     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3308     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3309         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3310             continue;
3311         visited.add(arrayBuffers[arrayBufferIndex].get());
3312 
3313         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3314         if (!result)
3315             return Exception { TypeError };
3316     }
3317 
3318     return contents;
3319 }
3320 
<span class="line-modified">3321 static void maybeThrowExceptionIfSerializationFailed(ExecState&amp; state, SerializationReturnCode code)</span>
3322 {
<span class="line-modified">3323     auto&amp; vm = state.vm();</span>
3324     auto scope = DECLARE_THROW_SCOPE(vm);
3325 
3326     switch (code) {
3327     case SerializationReturnCode::SuccessfullyCompleted:
3328         break;
3329     case SerializationReturnCode::StackOverflowError:
<span class="line-modified">3330         throwException(&amp;state, scope, createStackOverflowError(&amp;state));</span>
3331         break;
3332     case SerializationReturnCode::ValidationError:
<span class="line-modified">3333         throwTypeError(&amp;state, scope, &quot;Unable to deserialize data.&quot;_s);</span>
3334         break;
3335     case SerializationReturnCode::DataCloneError:
<span class="line-modified">3336         throwDataCloneError(state, scope);</span>
3337         break;
3338     case SerializationReturnCode::ExistingExceptionError:
3339     case SerializationReturnCode::UnspecifiedError:
3340         break;
3341     case SerializationReturnCode::InterruptedExecutionError:
3342         ASSERT_NOT_REACHED();
3343     }
3344 }
3345 
3346 static Exception exceptionForSerializationFailure(SerializationReturnCode code)
3347 {
3348     ASSERT(code != SerializationReturnCode::SuccessfullyCompleted);
3349 
3350     switch (code) {
3351     case SerializationReturnCode::StackOverflowError:
3352         return Exception { StackOverflowError };
3353     case SerializationReturnCode::ValidationError:
3354         return Exception { TypeError };
3355     case SerializationReturnCode::DataCloneError:
3356         return Exception { DataCloneError };
3357     case SerializationReturnCode::ExistingExceptionError:
3358         return Exception { ExistingExceptionError };
3359     case SerializationReturnCode::UnspecifiedError:
3360         return Exception { TypeError };
3361     case SerializationReturnCode::SuccessfullyCompleted:
3362     case SerializationReturnCode::InterruptedExecutionError:
3363         ASSERT_NOT_REACHED();
3364         return Exception { TypeError };
3365     }
3366     ASSERT_NOT_REACHED();
3367     return Exception { TypeError };
3368 }
3369 
<span class="line-modified">3370 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(ExecState&amp; exec, JSValue value, SerializationErrorMode throwExceptions)</span>
3371 {
3372     Vector&lt;uint8_t&gt; buffer;
3373     Vector&lt;String&gt; blobURLs;
3374     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3375     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;



3376     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3377 #if ENABLE(WEBASSEMBLY)
3378     WasmModuleArray dummyModules;
3379 #endif
3380     ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">3381     auto code = CloneSerializer::serialize(&amp;exec, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,</span>



3382 #if ENABLE(WEBASSEMBLY)
3383         dummyModules,
3384 #endif
3385         blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
3386 
3387 #if ENABLE(WEBASSEMBLY)
3388     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3389 #endif
3390 
3391     if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">3392         maybeThrowExceptionIfSerializationFailed(exec, code);</span>
3393 
3394     if (code != SerializationReturnCode::SuccessfullyCompleted)
3395         return nullptr;
3396 
<span class="line-modified">3397     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }</span>
<span class="line-removed">3398 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-removed">3399         , nullptr</span>
<span class="line-removed">3400 #endif</span>
<span class="line-removed">3401             ));</span>
3402 }
3403 
3404 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3405 {
3406     HashSet&lt;ImageBitmap*&gt; visited;
3407     for (auto&amp; imageBitmap : imageBitmaps) {
3408         if (!visited.add(imageBitmap.get()))
3409             return true;
3410     }
3411     return false;
3412 }
3413 
<span class="line-modified">3414 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(ExecState&amp; state, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)</span>















3415 {
<span class="line-modified">3416     VM&amp; vm = state.vm();</span>
3417     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
3418     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;



3419     for (auto&amp; transferable : transferList) {
3420         if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
3421             if (arrayBuffer-&gt;isNeutered())
3422                 return Exception { DataCloneError };
3423             if (arrayBuffer-&gt;isLocked()) {
3424                 auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3425                 throwVMTypeError(&amp;state, scope, errorMesasgeForTransfer(arrayBuffer));</span>
3426                 return Exception { ExistingExceptionError };
3427             }
3428             arrayBuffers.append(WTFMove(arrayBuffer));
3429             continue;
3430         }
3431         if (auto port = JSMessagePort::toWrapped(vm, transferable.get())) {
3432             // FIXME: This should check if the port is detached as per https://html.spec.whatwg.org/multipage/infrastructure.html#istransferable.
3433             messagePorts.append(WTFMove(port));
3434             continue;
3435         }
3436 
3437         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3438             if (imageBitmap-&gt;isDetached())
3439                 return Exception { DataCloneError };
3440 
3441             imageBitmaps.append(WTFMove(imageBitmap));
3442             continue;
3443         }
3444 







3445         return Exception { DataCloneError };
3446     }
3447 
3448     if (containsDuplicates(imageBitmaps))
3449         return Exception { DataCloneError };




3450 
3451     Vector&lt;uint8_t&gt; buffer;
3452     Vector&lt;String&gt; blobURLs;
3453 #if ENABLE(WEBASSEMBLY)
3454     WasmModuleArray wasmModules;
3455 #endif
3456     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();
<span class="line-modified">3457     auto code = CloneSerializer::serialize(&amp;state, value, messagePorts, arrayBuffers, imageBitmaps,</span>



3458 #if ENABLE(WEBASSEMBLY)
3459         wasmModules,
3460 #endif
3461         blobURLs, buffer, context, *sharedBuffers);
3462 
3463     if (code != SerializationReturnCode::SuccessfullyCompleted)
3464         return exceptionForSerializationFailure(code);
3465 
3466     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3467     if (arrayBufferContentsArray.hasException())
3468         return arrayBufferContentsArray.releaseException();
3469 
3470     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3471 






3472     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)



3473 #if ENABLE(WEBASSEMBLY)
3474                 , makeUnique&lt;WasmModuleArray&gt;(wasmModules)
3475 #endif
3476                 ));
3477 }
3478 
3479 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3480 {
3481     Vector&lt;uint8_t&gt; buffer;
3482     if (!CloneSerializer::serialize(string, buffer))
3483         return nullptr;
3484     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3485 }
3486 
3487 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3488 {
<span class="line-modified">3489     ExecState* exec = toJS(originContext);</span>
<span class="line-modified">3490     VM&amp; vm = exec-&gt;vm();</span>
3491     JSLockHolder locker(vm);
3492     auto scope = DECLARE_CATCH_SCOPE(vm);
3493 
<span class="line-modified">3494     JSValue value = toJS(exec, apiValue);</span>
<span class="line-modified">3495     auto serializedValue = SerializedScriptValue::create(*exec, value);</span>
3496     if (UNLIKELY(scope.exception())) {
3497         if (exception)
<span class="line-modified">3498             *exception = toRef(exec, scope.exception()-&gt;value());</span>
3499         scope.clearException();
3500         return nullptr;
3501     }
3502     ASSERT(serializedValue);
3503     return serializedValue;
3504 }
3505 
3506 String SerializedScriptValue::toString()
3507 {
3508     return CloneDeserializer::deserializeString(m_data);
3509 }
3510 
<span class="line-modified">3511 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)</span>
3512 {
<span class="line-modified">3513     return deserialize(exec, globalObject, { }, throwExceptions);</span>
3514 }
3515 
<span class="line-modified">3516 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)</span>
3517 {
3518     Vector&lt;String&gt; dummyBlobs;
3519     Vector&lt;String&gt; dummyPaths;
<span class="line-modified">3520     return deserialize(exec, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);</span>
3521 }
3522 
<span class="line-modified">3523 JSValue SerializedScriptValue::deserialize(ExecState&amp; exec, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
3524 {
<span class="line-modified">3525     DeserializationResult result = CloneDeserializer::deserialize(&amp;exec, globalObject, messagePorts, WTFMove(m_imageBuffers), m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()</span>




3526 #if ENABLE(WEBASSEMBLY)
3527         , m_wasmModulesArray.get()
3528 #endif
3529         );
3530     if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">3531         maybeThrowExceptionIfSerializationFailed(exec, result.second);</span>
3532     return result.first ? result.first : jsNull();
3533 }
3534 
3535 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3536 {
<span class="line-modified">3537     ExecState* exec = toJS(destinationContext);</span>
<span class="line-modified">3538     VM&amp; vm = exec-&gt;vm();</span>
3539     JSLockHolder locker(vm);
3540     auto scope = DECLARE_CATCH_SCOPE(vm);
3541 
<span class="line-modified">3542     JSValue value = deserialize(*exec, exec-&gt;lexicalGlobalObject());</span>
3543     if (UNLIKELY(scope.exception())) {
3544         if (exception)
<span class="line-modified">3545             *exception = toRef(exec, scope.exception()-&gt;value());</span>
3546         scope.clearException();
3547         return nullptr;
3548     }
3549     ASSERT(value);
<span class="line-modified">3550     return toRef(exec, value);</span>
3551 }
3552 
3553 Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
3554 {
3555     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3556 }
3557 
3558 uint32_t SerializedScriptValue::wireFormatVersion()
3559 {
3560     return CurrentVersion;
3561 }
3562 
3563 #if ENABLE(INDEXED_DATABASE)
3564 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3565 {
3566     Vector&lt;String&gt; result;
3567     result.reserveInitialCapacity(m_blobURLs.size());
3568     for (auto&amp; url : m_blobURLs)
3569         result.uncheckedAppend(url.isolatedCopy());
3570 
3571     return result;
3572 }
3573 
<span class="line-modified">3574 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(PAL::SessionID sessionID, CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
3575 {
3576     ASSERT(isMainThread());
3577     ASSERT(hasBlobURLs());
3578 
<span class="line-modified">3579     blobRegistry().writeBlobsToTemporaryFiles(sessionID, m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>
3580         ASSERT(isMainThread());
3581 
3582         if (blobFilePaths.isEmpty()) {
3583             // We should have successfully written blobs to temporary files.
3584             // If we failed, then we can&#39;t successfully store this record.
3585             completionHandler({ });
3586             return;
3587         }
3588 
3589         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3590 
3591         completionHandler({ *this, m_blobURLs, blobFilePaths });
3592     });
3593 }
3594 
<span class="line-modified">3595 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously(PAL::SessionID sessionID)</span>
3596 {
3597     ASSERT(!isMainThread());
3598 
3599     IDBValue value;
3600     Lock lock;
3601     Condition condition;
3602     lock.lock();
3603 
<span class="line-modified">3604     RunLoop::main().dispatch([this, sessionID, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">3605         writeBlobsToDiskForIndexedDB(sessionID, [conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
3606             ASSERT(isMainThread());
3607             valuePtr-&gt;setAsIsolatedCopy(result);
3608 
3609             conditionPtr-&gt;notifyAll();
3610         });
3611     });
3612 
3613     condition.wait(lock);
3614 
3615     return value;
3616 }
3617 
3618 #endif // ENABLE(INDEXED_DATABASE)
3619 
3620 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  72 #include &lt;JavaScriptCore/JSMap.h&gt;
  73 #include &lt;JavaScriptCore/JSMapIterator.h&gt;
  74 #include &lt;JavaScriptCore/JSSet.h&gt;
  75 #include &lt;JavaScriptCore/JSSetIterator.h&gt;
  76 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
  77 #include &lt;JavaScriptCore/JSWebAssemblyModule.h&gt;
  78 #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  79 #include &lt;JavaScriptCore/PropertyNameArray.h&gt;
  80 #include &lt;JavaScriptCore/RegExp.h&gt;
  81 #include &lt;JavaScriptCore/RegExpObject.h&gt;
  82 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
  83 #include &lt;JavaScriptCore/TypedArrays.h&gt;
  84 #include &lt;JavaScriptCore/WasmModule.h&gt;
  85 #include &lt;JavaScriptCore/YarrFlags.h&gt;
  86 #include &lt;limits&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/MainThread.h&gt;
  89 #include &lt;wtf/RunLoop.h&gt;
  90 #include &lt;wtf/Vector.h&gt;
  91 
<span class="line-added">  92 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">  93 #include &quot;JSOffscreenCanvas.h&quot;</span>
<span class="line-added">  94 #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added">  95 #endif</span>
<span class="line-added">  96 </span>
  97 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN) || CPU(NEEDS_ALIGNED_ACCESS)
  98 #define ASSUME_LITTLE_ENDIAN 0
  99 #else
 100 #define ASSUME_LITTLE_ENDIAN 1
 101 #endif
 102 
 103 namespace WebCore {
 104 using namespace JSC;
 105 
<span class="line-added"> 106 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SerializedScriptValue);</span>
<span class="line-added"> 107 </span>
 108 static const unsigned maximumFilterRecursion = 40000;
 109 
 110 enum class SerializationReturnCode {
 111     SuccessfullyCompleted,
 112     StackOverflowError,
 113     InterruptedExecutionError,
 114     ValidationError,
 115     ExistingExceptionError,
 116     DataCloneError,
 117     UnspecifiedError
 118 };
 119 
 120 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
 121     ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember,
 122     MapDataStartVisitEntry, MapDataEndVisitKey, MapDataEndVisitValue,
 123     SetDataStartVisitEntry, SetDataEndVisitKey };
 124 
 125 // These can&#39;t be reordered, and any new types must be added to the end of the list
 126 // When making changes to these lists please cover your new type(s) in the API test &quot;IndexedDB.StructuredCloneBackwardCompatibility&quot;
 127 enum SerializationTag {
</pre>
<hr />
<pre>
 157     MapObjectTag = 30,
 158     NonMapPropertiesTag = 31,
 159     NonSetPropertiesTag = 32,
 160 #if ENABLE(WEB_CRYPTO)
 161     CryptoKeyTag = 33,
 162 #endif
 163     SharedArrayBufferTag = 34,
 164 #if ENABLE(WEBASSEMBLY)
 165     WasmModuleTag = 35,
 166 #endif
 167     DOMPointReadOnlyTag = 36,
 168     DOMPointTag = 37,
 169     DOMRectReadOnlyTag = 38,
 170     DOMRectTag = 39,
 171     DOMMatrixReadOnlyTag = 40,
 172     DOMMatrixTag = 41,
 173     DOMQuadTag = 42,
 174     ImageBitmapTransferTag = 43,
 175 #if ENABLE(WEB_RTC)
 176     RTCCertificateTag = 44,
<span class="line-added"> 177 #endif</span>
<span class="line-added"> 178     ImageBitmapTag = 45,</span>
<span class="line-added"> 179 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 180     OffscreenCanvasTransferTag = 46,</span>
 181 #endif
 182     ErrorTag = 255
 183 };
 184 
 185 enum ArrayBufferViewSubtag {
 186     DataViewTag = 0,
 187     Int8ArrayTag = 1,
 188     Uint8ArrayTag = 2,
 189     Uint8ClampedArrayTag = 3,
 190     Int16ArrayTag = 4,
 191     Uint16ArrayTag = 5,
 192     Int32ArrayTag = 6,
 193     Uint32ArrayTag = 7,
 194     Float32ArrayTag = 8,
 195     Float64ArrayTag = 9
 196 };
 197 
 198 static unsigned typedArrayElementSize(ArrayBufferViewSubtag tag)
 199 {
 200     switch (tag) {
</pre>
<hr />
<pre>
 344  *    | DateTag &lt;value:double&gt;
 345  *    | String
 346  *    | EmptyStringTag
 347  *    | EmptyStringObjectTag
 348  *    | File
 349  *    | FileList
 350  *    | ImageData
 351  *    | Blob
 352  *    | ObjectReference
 353  *    | MessagePortReferenceTag &lt;value:uint32_t&gt;
 354  *    | ArrayBuffer
 355  *    | ArrayBufferViewTag ArrayBufferViewSubtag &lt;byteOffset:uint32_t&gt; &lt;byteLength:uint32_t&gt; (ArrayBuffer | ObjectReference)
 356  *    | ArrayBufferTransferTag &lt;value:uint32_t&gt;
 357  *    | CryptoKeyTag &lt;wrappedKeyLength:uint32_t&gt; &lt;factor:byte{wrappedKeyLength}&gt;
 358  *    | DOMPoint
 359  *    | DOMRect
 360  *    | DOMMatrix
 361  *    | DOMQuad
 362  *    | ImageBitmapTransferTag &lt;value:uint32_t&gt;
 363  *    | RTCCertificateTag
<span class="line-added"> 364  *    | ImageBitmapTag &lt;originClean:uint8_t&gt; &lt;logicalWidth:int32_t&gt; &lt;logicalHeight:int32_t&gt; &lt;resolutionScale:double&gt; &lt;byteLength:uint32_t&gt;(&lt;imageByteData:uint8_t&gt;)</span>
<span class="line-added"> 365  *    | OffscreenCanvasTransferTag &lt;value:uint32_t&gt;</span>
 366  *
 367  * Inside certificate, data is serialized in this format as per spec:
 368  *
 369  * &lt;expires:double&gt; &lt;certificate:StringData&gt; &lt;origin:StringData&gt; &lt;keyingMaterial:StringData&gt;
 370  * We also add fingerprints to make sure we expose to JavaScript the same information.
 371  *
 372  * Inside wrapped crypto key, data is serialized in this format:
 373  *
 374  * &lt;keyFormatVersion:uint32_t&gt; &lt;extractable:int32_t&gt; &lt;usagesCount:uint32_t&gt; &lt;usages:byte{usagesCount}&gt; CryptoKeyClassSubtag (CryptoKeyHMAC | CryptoKeyAES | CryptoKeyRSA)
 375  *
 376  * String :-
 377  *      EmptyStringTag
 378  *      StringTag StringData
 379  *
 380  * StringObject:
 381  *      EmptyStringObjectTag
 382  *      StringObjectTag StringData
 383  *
 384  * StringData :-
 385  *      StringPoolTag &lt;cpIndex:IndexType&gt;
</pre>
<hr />
<pre>
 454  * DOMMatrix :-
 455  *        DOMMatrixReadOnlyTag DOMMatrixData
 456  *      | DOMMatrixTag DOMMatrixData
 457  *
 458  * DOMMatrixData :-
 459  *        &lt;is2D:uint8_t:true&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m41:double&gt; &lt;m42:double&gt;
 460  *      | &lt;is2D:uint8_t:false&gt; &lt;m11:double&gt; &lt;m12:double&gt; &lt;m13:double&gt; &lt;m14:double&gt; &lt;m21:double&gt; &lt;m22:double&gt; &lt;m23:double&gt; &lt;m24:double&gt; &lt;m31:double&gt; &lt;m32:double&gt; &lt;m33:double&gt; &lt;m34:double&gt; &lt;m41:double&gt; &lt;m42:double&gt; &lt;m43:double&gt; &lt;m44:double&gt;
 461  *
 462  * DOMQuad :-
 463  *      DOMQuadTag DOMQuadData
 464  *
 465  * DOMQuadData :-
 466  *      &lt;p1:DOMPointData&gt; &lt;p2:DOMPointData&gt; &lt;p3:DOMPointData&gt; &lt;p4:DOMPointData&gt;
 467  *
 468  */
 469 
 470 using DeserializationResult = std::pair&lt;JSC::JSValue, SerializationReturnCode&gt;;
 471 
 472 class CloneBase {
 473 protected:
<span class="line-modified"> 474     CloneBase(JSGlobalObject* lexicalGlobalObject)</span>
<span class="line-modified"> 475         : m_lexicalGlobalObject(lexicalGlobalObject)</span>
 476         , m_failed(false)
 477     {
 478     }
 479 
 480     bool shouldTerminate()
 481     {
<span class="line-modified"> 482         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
 483         auto scope = DECLARE_THROW_SCOPE(vm);
 484         return scope.exception();
 485     }
 486 
 487     void fail()
 488     {
 489         m_failed = true;
 490     }
 491 
<span class="line-modified"> 492     JSGlobalObject* m_lexicalGlobalObject;</span>
 493     bool m_failed;
 494     MarkedArgumentBuffer m_gcBuffer;
 495 };
 496 
 497 #if ENABLE(WEB_CRYPTO)
<span class="line-modified"> 498 static bool wrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)</span>
 499 {
<span class="line-modified"> 500     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);</span>
 501     if (!scriptExecutionContext)
 502         return false;
 503     return scriptExecutionContext-&gt;wrapCryptoKey(key, wrappedKey);
 504 }
 505 
<span class="line-modified"> 506 static bool unwrapCryptoKey(JSGlobalObject* lexicalGlobalObject, const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)</span>
 507 {
<span class="line-modified"> 508     ScriptExecutionContext* scriptExecutionContext = scriptExecutionContextFromExecState(lexicalGlobalObject);</span>
 509     if (!scriptExecutionContext)
 510         return false;
 511     return scriptExecutionContext-&gt;unwrapCryptoKey(wrappedKey, key);
 512 }
 513 #endif
 514 
 515 #if ASSUME_LITTLE_ENDIAN
 516 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 517 {
 518     buffer.append(reinterpret_cast&lt;uint8_t*&gt;(&amp;value), sizeof(value));
 519 }
 520 #else
 521 template &lt;typename T&gt; static void writeLittleEndian(Vector&lt;uint8_t&gt;&amp; buffer, T value)
 522 {
 523     for (unsigned i = 0; i &lt; sizeof(T); i++) {
 524         buffer.append(value &amp; 0xFF);
 525         value &gt;&gt;= 8;
 526     }
 527 }
 528 #endif
</pre>
<hr />
<pre>
 542 #else
 543     for (unsigned i = 0; i &lt; length; i++) {
 544         T value = values[i];
 545         for (unsigned j = 0; j &lt; sizeof(T); j++) {
 546             buffer.append(static_cast&lt;uint8_t&gt;(value &amp; 0xFF));
 547             value &gt;&gt;= 8;
 548         }
 549     }
 550 #endif
 551     return true;
 552 }
 553 
 554 template &lt;&gt; bool writeLittleEndian&lt;uint8_t&gt;(Vector&lt;uint8_t&gt;&amp; buffer, const uint8_t* values, uint32_t length)
 555 {
 556     buffer.append(values, length);
 557     return true;
 558 }
 559 
 560 class CloneSerializer : CloneBase {
 561 public:
<span class="line-modified"> 562     static SerializationReturnCode serialize(JSGlobalObject* lexicalGlobalObject, JSValue value, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>
<span class="line-added"> 563 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 564             const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases,</span>
<span class="line-added"> 565 #endif</span>
 566 #if ENABLE(WEBASSEMBLY)
 567             WasmModuleArray&amp; wasmModules,
 568 #endif
 569         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
 570     {
<span class="line-modified"> 571         CloneSerializer serializer(lexicalGlobalObject, messagePorts, arrayBuffers, imageBitmaps,</span>
<span class="line-added"> 572 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 573             offscreenCanvases,</span>
<span class="line-added"> 574 #endif</span>
 575 #if ENABLE(WEBASSEMBLY)
 576             wasmModules,
 577 #endif
 578             blobURLs, out, context, sharedBuffers);
 579         return serializer.serialize(value);
 580     }
 581 
 582     static bool serialize(StringView string, Vector&lt;uint8_t&gt;&amp; out)
 583     {
 584         writeLittleEndian(out, CurrentVersion);
 585         if (string.isEmpty()) {
 586             writeLittleEndian&lt;uint8_t&gt;(out, EmptyStringTag);
 587             return true;
 588         }
 589         writeLittleEndian&lt;uint8_t&gt;(out, StringTag);
 590         if (string.is8Bit()) {
 591             writeLittleEndian(out, string.length() | StringDataIs8BitFlag);
 592             return writeLittleEndian(out, string.characters8(), string.length());
 593         }
 594         writeLittleEndian(out, string.length());
 595         return writeLittleEndian(out, string.characters16(), string.length());
 596     }
 597 
 598 private:
 599     typedef HashMap&lt;JSObject*, uint32_t&gt; ObjectPool;
 600 
<span class="line-modified"> 601     CloneSerializer(JSGlobalObject* lexicalGlobalObject, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers, const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps,</span>
<span class="line-added"> 602 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 603             const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases,</span>
<span class="line-added"> 604 #endif</span>
 605 #if ENABLE(WEBASSEMBLY)
 606             WasmModuleArray&amp; wasmModules,
 607 #endif
 608         Vector&lt;String&gt;&amp; blobURLs, Vector&lt;uint8_t&gt;&amp; out, SerializationContext context, ArrayBufferContentsArray&amp; sharedBuffers)
<span class="line-modified"> 609         : CloneBase(lexicalGlobalObject)</span>
 610         , m_buffer(out)
 611         , m_blobURLs(blobURLs)
<span class="line-modified"> 612         , m_emptyIdentifier(Identifier::fromString(lexicalGlobalObject-&gt;vm(), emptyString()))</span>
 613         , m_context(context)
 614         , m_sharedBuffers(sharedBuffers)
 615 #if ENABLE(WEBASSEMBLY)
 616         , m_wasmModules(wasmModules)
 617 #endif
 618     {
 619         write(CurrentVersion);
 620         fillTransferMap(messagePorts, m_transferredMessagePorts);
 621         fillTransferMap(arrayBuffers, m_transferredArrayBuffers);
 622         fillTransferMap(imageBitmaps, m_transferredImageBitmaps);
<span class="line-added"> 623 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 624         fillTransferMap(offscreenCanvases, m_transferredOffscreenCanvases);</span>
<span class="line-added"> 625 #endif</span>
 626     }
 627 
 628     template &lt;class T&gt;
 629     void fillTransferMap(const Vector&lt;RefPtr&lt;T&gt;&gt;&amp; input, ObjectPool&amp; result)
 630     {
 631         if (input.isEmpty())
 632             return;
<span class="line-modified"> 633         JSDOMGlobalObject* globalObject = jsCast&lt;JSDOMGlobalObject*&gt;(m_lexicalGlobalObject);</span>
 634         for (size_t i = 0; i &lt; input.size(); i++) {
<span class="line-modified"> 635             JSC::JSValue value = toJS(m_lexicalGlobalObject, globalObject, input[i].get());</span>
 636             JSC::JSObject* obj = value.getObject();
 637             if (obj &amp;&amp; !result.contains(obj))
 638                 result.add(obj, i);
 639         }
 640     }
 641 
 642     SerializationReturnCode serialize(JSValue in);
 643 
 644     bool isArray(VM&amp; vm, JSValue value)
 645     {
 646         if (!value.isObject())
 647             return false;
 648         JSObject* object = asObject(value);
 649         return object-&gt;inherits&lt;JSArray&gt;(vm);
 650     }
 651 
 652     bool isMap(VM&amp; vm, JSValue value)
 653     {
 654         if (!value.isObject())
 655             return false;
</pre>
<hr />
<pre>
 722         return true;
 723     }
 724 
 725     bool startMap(JSMap* map)
 726     {
 727         if (!startObjectInternal(map))
 728             return false;
 729 
 730         write(MapObjectTag);
 731         return true;
 732     }
 733 
 734     void endObject()
 735     {
 736         write(TerminatorTag);
 737     }
 738 
 739     JSValue getProperty(VM&amp; vm, JSObject* object, const Identifier&amp; propertyName)
 740     {
 741         PropertySlot slot(object, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 742         if (object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, m_lexicalGlobalObject, propertyName, slot))</span>
<span class="line-modified"> 743             return slot.getValue(m_lexicalGlobalObject, propertyName);</span>
 744         return JSValue();
 745     }
 746 
 747     void dumpImmediate(JSValue value)
 748     {
 749         if (value.isNull())
 750             write(NullTag);
 751         else if (value.isUndefined())
 752             write(UndefinedTag);
 753         else if (value.isNumber()) {
 754             if (value.isInt32()) {
 755                 if (!value.asInt32())
 756                     write(ZeroTag);
 757                 else if (value.asInt32() == 1)
 758                     write(OneTag);
 759                 else {
 760                     write(IntTag);
 761                     write(static_cast&lt;uint32_t&gt;(value.asInt32()));
 762                 }
 763             } else {
</pre>
<hr />
<pre>
 777         if (string.isEmpty())
 778             write(EmptyStringTag);
 779         else {
 780             write(StringTag);
 781             write(string);
 782         }
 783     }
 784 
 785     void dumpStringObject(const String&amp; string)
 786     {
 787         if (string.isEmpty())
 788             write(EmptyStringObjectTag);
 789         else {
 790             write(StringObjectTag);
 791             write(string);
 792         }
 793     }
 794 
 795     JSC::JSValue toJSArrayBuffer(ArrayBuffer&amp; arrayBuffer)
 796     {
<span class="line-modified"> 797         auto&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
<span class="line-modified"> 798         auto* globalObject = m_lexicalGlobalObject;</span>
 799         if (globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(vm))
<span class="line-modified"> 800             return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(globalObject), &amp;arrayBuffer);</span>
 801 
 802         if (auto* buffer = arrayBuffer.m_wrapper.get())
 803             return buffer;
 804 
 805         return JSC::JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(arrayBuffer.sharingMode()), &amp;arrayBuffer);
 806     }
 807 
 808     bool dumpArrayBufferView(JSObject* obj, SerializationReturnCode&amp; code)
 809     {
<span class="line-modified"> 810         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
 811         write(ArrayBufferViewTag);
 812         if (obj-&gt;inherits&lt;JSDataView&gt;(vm))
 813             write(DataViewTag);
 814         else if (obj-&gt;inherits&lt;JSUint8ClampedArray&gt;(vm))
 815             write(Uint8ClampedArrayTag);
 816         else if (obj-&gt;inherits&lt;JSInt8Array&gt;(vm))
 817             write(Int8ArrayTag);
 818         else if (obj-&gt;inherits&lt;JSUint8Array&gt;(vm))
 819             write(Uint8ArrayTag);
 820         else if (obj-&gt;inherits&lt;JSInt16Array&gt;(vm))
 821             write(Int16ArrayTag);
 822         else if (obj-&gt;inherits&lt;JSUint16Array&gt;(vm))
 823             write(Uint16ArrayTag);
 824         else if (obj-&gt;inherits&lt;JSInt32Array&gt;(vm))
 825             write(Int32ArrayTag);
 826         else if (obj-&gt;inherits&lt;JSUint32Array&gt;(vm))
 827             write(Uint32ArrayTag);
 828         else if (obj-&gt;inherits&lt;JSFloat32Array&gt;(vm))
 829             write(Float32ArrayTag);
 830         else if (obj-&gt;inherits&lt;JSFloat64Array&gt;(vm))
</pre>
<hr />
<pre>
 837         write(static_cast&lt;uint32_t&gt;(arrayBufferView-&gt;byteLength()));
 838         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = arrayBufferView-&gt;possiblySharedBuffer();
 839         if (!arrayBuffer) {
 840             code = SerializationReturnCode::ValidationError;
 841             return true;
 842         }
 843 
 844         return dumpIfTerminal(toJSArrayBuffer(*arrayBuffer), code);
 845     }
 846 
 847     void dumpDOMPoint(const DOMPointReadOnly&amp; point)
 848     {
 849         write(point.x());
 850         write(point.y());
 851         write(point.z());
 852         write(point.w());
 853     }
 854 
 855     void dumpDOMPoint(JSObject* obj)
 856     {
<span class="line-modified"> 857         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
 858         if (obj-&gt;inherits&lt;JSDOMPoint&gt;(vm))
 859             write(DOMPointTag);
 860         else
 861             write(DOMPointReadOnlyTag);
 862 
 863         dumpDOMPoint(jsCast&lt;JSDOMPointReadOnly*&gt;(obj)-&gt;wrapped());
 864     }
 865 
 866     void dumpDOMRect(JSObject* obj)
 867     {
<span class="line-modified"> 868         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
 869         if (obj-&gt;inherits&lt;JSDOMRect&gt;(vm))
 870             write(DOMRectTag);
 871         else
 872             write(DOMRectReadOnlyTag);
 873 
 874         auto&amp; rect = jsCast&lt;JSDOMRectReadOnly*&gt;(obj)-&gt;wrapped();
 875         write(rect.x());
 876         write(rect.y());
 877         write(rect.width());
 878         write(rect.height());
 879     }
 880 
 881     void dumpDOMMatrix(JSObject* obj)
 882     {
<span class="line-modified"> 883         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
 884         if (obj-&gt;inherits&lt;JSDOMMatrix&gt;(vm))
 885             write(DOMMatrixTag);
 886         else
 887             write(DOMMatrixReadOnlyTag);
 888 
 889         auto&amp; matrix = jsCast&lt;JSDOMMatrixReadOnly*&gt;(obj)-&gt;wrapped();
 890         bool is2D = matrix.is2D();
 891         write(static_cast&lt;uint8_t&gt;(is2D));
 892         if (is2D) {
 893             write(matrix.m11());
 894             write(matrix.m12());
 895             write(matrix.m21());
 896             write(matrix.m22());
 897             write(matrix.m41());
 898             write(matrix.m42());
 899         } else {
 900             write(matrix.m11());
 901             write(matrix.m12());
 902             write(matrix.m13());
 903             write(matrix.m14());
</pre>
<hr />
<pre>
 919     void dumpDOMQuad(JSObject* obj)
 920     {
 921         write(DOMQuadTag);
 922 
 923         auto&amp; quad = jsCast&lt;JSDOMQuad*&gt;(obj)-&gt;wrapped();
 924         dumpDOMPoint(quad.p1());
 925         dumpDOMPoint(quad.p2());
 926         dumpDOMPoint(quad.p3());
 927         dumpDOMPoint(quad.p4());
 928     }
 929 
 930     void dumpImageBitmap(JSObject* obj, SerializationReturnCode&amp; code)
 931     {
 932         auto index = m_transferredImageBitmaps.find(obj);
 933         if (index != m_transferredImageBitmaps.end()) {
 934             write(ImageBitmapTransferTag);
 935             write(index-&gt;value);
 936             return;
 937         }
 938 
<span class="line-modified"> 939         auto&amp; imageBitmap = jsCast&lt;JSImageBitmap*&gt;(obj)-&gt;wrapped();</span>
<span class="line-modified"> 940         auto* buffer = imageBitmap.buffer();</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942         if (!buffer) {</span>
<span class="line-added"> 943             code = SerializationReturnCode::ValidationError;</span>
<span class="line-added"> 944             return;</span>
<span class="line-added"> 945         }</span>
<span class="line-added"> 946 </span>
<span class="line-added"> 947         const IntSize&amp; logicalSize = buffer-&gt;logicalSize();</span>
<span class="line-added"> 948         auto imageData = buffer-&gt;getPremultipliedImageData(IntRect(0, 0, logicalSize.width(), logicalSize.height()));</span>
<span class="line-added"> 949         if (!imageData) {</span>
<span class="line-added"> 950             code = SerializationReturnCode::ValidationError;</span>
<span class="line-added"> 951             return;</span>
<span class="line-added"> 952         }</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = imageData-&gt;possiblySharedBuffer();</span>
<span class="line-added"> 955         if (!arrayBuffer) {</span>
<span class="line-added"> 956             code = SerializationReturnCode::ValidationError;</span>
<span class="line-added"> 957             return;</span>
<span class="line-added"> 958         }</span>
<span class="line-added"> 959 </span>
<span class="line-added"> 960         write(ImageBitmapTag);</span>
<span class="line-added"> 961         write(static_cast&lt;uint8_t&gt;(imageBitmap.originClean()));</span>
<span class="line-added"> 962         write(static_cast&lt;int32_t&gt;(logicalSize.width()));</span>
<span class="line-added"> 963         write(static_cast&lt;int32_t&gt;(logicalSize.height()));</span>
<span class="line-added"> 964         write(static_cast&lt;double&gt;(buffer-&gt;resolutionScale()));</span>
<span class="line-added"> 965 </span>
<span class="line-added"> 966         write(static_cast&lt;uint32_t&gt;(arrayBuffer-&gt;byteLength()));</span>
<span class="line-added"> 967         write(static_cast&lt;const uint8_t*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());</span>
 968     }
 969 
<span class="line-added"> 970 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 971     void dumpOffscreenCanvas(JSObject* obj, SerializationReturnCode&amp; code)</span>
<span class="line-added"> 972     {</span>
<span class="line-added"> 973         auto index = m_transferredOffscreenCanvases.find(obj);</span>
<span class="line-added"> 974         if (index != m_transferredOffscreenCanvases.end()) {</span>
<span class="line-added"> 975             write(OffscreenCanvasTransferTag);</span>
<span class="line-added"> 976             write(index-&gt;value);</span>
<span class="line-added"> 977             return;</span>
<span class="line-added"> 978         }</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980         code = SerializationReturnCode::DataCloneError;</span>
<span class="line-added"> 981     }</span>
<span class="line-added"> 982 #endif</span>
<span class="line-added"> 983 </span>
 984     bool dumpIfTerminal(JSValue value, SerializationReturnCode&amp; code)
 985     {
 986         if (!value.isCell()) {
 987             dumpImmediate(value);
 988             return true;
 989         }
 990         ASSERT(value.isCell());
 991 
 992         if (value.isString()) {
<span class="line-modified"> 993             dumpString(asString(value)-&gt;value(m_lexicalGlobalObject));</span>
 994             return true;
 995         }
 996 
 997         if (value.isSymbol()) {
 998             code = SerializationReturnCode::DataCloneError;
 999             return true;
1000         }
1001 
<span class="line-modified">1002         VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
1003         if (isArray(vm, value))
1004             return false;
1005 
1006         if (value.isObject()) {
1007             auto* obj = asObject(value);
1008             if (auto* dateObject = jsDynamicCast&lt;DateInstance*&gt;(vm, obj)) {
1009                 write(DateTag);
1010                 write(dateObject-&gt;internalNumber());
1011                 return true;
1012             }
1013             if (auto* booleanObject = jsDynamicCast&lt;BooleanObject*&gt;(vm, obj)) {
1014                 if (!startObjectInternal(booleanObject)) // handle duplicates
1015                     return true;
<span class="line-modified">1016                 write(booleanObject-&gt;internalValue().toBoolean(m_lexicalGlobalObject) ? TrueObjectTag : FalseObjectTag);</span>
1017                 return true;
1018             }
1019             if (auto* stringObject = jsDynamicCast&lt;StringObject*&gt;(vm, obj)) {
1020                 if (!startObjectInternal(stringObject)) // handle duplicates
1021                     return true;
<span class="line-modified">1022                 String str = asString(stringObject-&gt;internalValue())-&gt;value(m_lexicalGlobalObject);</span>
1023                 dumpStringObject(str);
1024                 return true;
1025             }
1026             if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, obj)) {
1027                 if (!startObjectInternal(numberObject)) // handle duplicates
1028                     return true;
1029                 write(NumberObjectTag);
1030                 write(numberObject-&gt;internalValue().asNumber());
1031                 return true;
1032             }
1033             if (auto* file = JSFile::toWrapped(vm, obj)) {
1034                 write(FileTag);
1035                 write(*file);
1036                 return true;
1037             }
1038             if (auto* list = JSFileList::toWrapped(vm, obj)) {
1039                 write(FileListTag);
1040                 write(list-&gt;length());
1041                 for (auto&amp; file : list-&gt;files())
1042                     write(file.get());
</pre>
<hr />
<pre>
1114                 return true;
1115             }
1116             if (obj-&gt;inherits&lt;JSArrayBufferView&gt;(vm)) {
1117                 if (checkForDuplicate(obj))
1118                     return true;
1119                 bool success = dumpArrayBufferView(obj, code);
1120                 recordObject(obj);
1121                 return success;
1122             }
1123 #if ENABLE(WEB_CRYPTO)
1124             if (auto* key = JSCryptoKey::toWrapped(vm, obj)) {
1125                 write(CryptoKeyTag);
1126                 Vector&lt;uint8_t&gt; serializedKey;
1127                 Vector&lt;String&gt; dummyBlobURLs;
1128                 Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
1129                 Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
1130 #if ENABLE(WEBASSEMBLY)
1131                 WasmModuleArray dummyModules;
1132 #endif
1133                 ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">1134                 CloneSerializer rawKeySerializer(m_lexicalGlobalObject, dummyMessagePorts, dummyArrayBuffers, { },</span>
<span class="line-added">1135 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1136                     { },</span>
<span class="line-added">1137 #endif</span>
1138 #if ENABLE(WEBASSEMBLY)
1139                     dummyModules,
1140 #endif
1141                     dummyBlobURLs, serializedKey, SerializationContext::Default, dummySharedBuffers);
1142                 rawKeySerializer.write(key);
1143                 Vector&lt;uint8_t&gt; wrappedKey;
<span class="line-modified">1144                 if (!wrapCryptoKey(m_lexicalGlobalObject, serializedKey, wrappedKey))</span>
1145                     return false;
1146                 write(wrappedKey);
1147                 return true;
1148             }
1149 #endif
1150 #if ENABLE(WEB_RTC)
1151             if (auto* rtcCertificate = JSRTCCertificate::toWrapped(vm, obj)) {
1152                 write(RTCCertificateTag);
1153                 write(rtcCertificate-&gt;expires());
1154                 write(rtcCertificate-&gt;pemCertificate());
1155                 write(rtcCertificate-&gt;origin().toString());
1156                 write(rtcCertificate-&gt;pemPrivateKey());
1157                 write(static_cast&lt;unsigned&gt;(rtcCertificate-&gt;getFingerprints().size()));
1158                 for (const auto&amp; fingerprint : rtcCertificate-&gt;getFingerprints()) {
1159                     write(fingerprint.algorithm);
1160                     write(fingerprint.value);
1161                 }
1162                 return true;
1163             }
1164 #endif
</pre>
<hr />
<pre>
1177             if (obj-&gt;inherits&lt;JSDOMPointReadOnly&gt;(vm)) {
1178                 dumpDOMPoint(obj);
1179                 return true;
1180             }
1181             if (obj-&gt;inherits&lt;JSDOMRectReadOnly&gt;(vm)) {
1182                 dumpDOMRect(obj);
1183                 return true;
1184             }
1185             if (obj-&gt;inherits&lt;JSDOMMatrixReadOnly&gt;(vm)) {
1186                 dumpDOMMatrix(obj);
1187                 return true;
1188             }
1189             if (obj-&gt;inherits&lt;JSDOMQuad&gt;(vm)) {
1190                 dumpDOMQuad(obj);
1191                 return true;
1192             }
1193             if (obj-&gt;inherits(vm, JSImageBitmap::info())) {
1194                 dumpImageBitmap(obj, code);
1195                 return true;
1196             }
<span class="line-added">1197 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1198             if (obj-&gt;inherits(vm, JSOffscreenCanvas::info())) {</span>
<span class="line-added">1199                 dumpOffscreenCanvas(obj, code);</span>
<span class="line-added">1200                 return true;</span>
<span class="line-added">1201             }</span>
<span class="line-added">1202 #endif</span>
1203             return false;
1204         }
1205         // Any other types are expected to serialize as null.
1206         write(NullTag);
1207         return true;
1208     }
1209 
1210     void write(SerializationTag tag)
1211     {
1212         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1213     }
1214 
1215     void write(ArrayBufferViewSubtag tag)
1216     {
1217         writeLittleEndian&lt;uint8_t&gt;(m_buffer, static_cast&lt;uint8_t&gt;(tag));
1218     }
1219 
1220 #if ENABLE(WEB_CRYPTO)
1221     void write(CryptoKeyClassSubtag tag)
1222     {
</pre>
<hr />
<pre>
1317             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length | StringDataIs8BitFlag);
1318         else
1319             writeLittleEndian&lt;uint32_t&gt;(m_buffer, length);
1320 
1321         if (!length)
1322             return;
1323         if (str.is8Bit()) {
1324             if (!writeLittleEndian(m_buffer, str.characters8(), length))
1325                 fail();
1326             return;
1327         }
1328         if (!writeLittleEndian(m_buffer, str.characters16(), length))
1329             fail();
1330     }
1331 
1332     void write(const String&amp; str)
1333     {
1334         if (str.isNull())
1335             write(m_emptyIdentifier);
1336         else
<span class="line-modified">1337             write(Identifier::fromString(m_lexicalGlobalObject-&gt;vm(), str));</span>
1338     }
1339 
1340     void write(const Vector&lt;uint8_t&gt;&amp; vector)
1341     {
1342         uint32_t size = vector.size();
1343         write(size);
1344         writeLittleEndian(m_buffer, vector.data(), size);
1345     }
1346 
1347     void write(const File&amp; file)
1348     {
1349         m_blobURLs.append(file.url());
1350         write(file.path());
1351         write(file.url());
1352         write(file.type());
1353         write(file.name());
1354         write(static_cast&lt;double&gt;(file.lastModifiedOverride().valueOr(-1)));
1355     }
1356 
1357 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
1530             write(isRestrictedToHash);
1531             if (isRestrictedToHash)
1532                 write(hash);
1533             write(*downcast&lt;CryptoKeyRSA&gt;(*key).exportData());
1534             break;
1535         }
1536     }
1537 #endif
1538 
1539     void write(const uint8_t* data, unsigned length)
1540     {
1541         m_buffer.append(data, length);
1542     }
1543 
1544     Vector&lt;uint8_t&gt;&amp; m_buffer;
1545     Vector&lt;String&gt;&amp; m_blobURLs;
1546     ObjectPool m_objectPool;
1547     ObjectPool m_transferredMessagePorts;
1548     ObjectPool m_transferredArrayBuffers;
1549     ObjectPool m_transferredImageBitmaps;
<span class="line-added">1550 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1551     ObjectPool m_transferredOffscreenCanvases;</span>
<span class="line-added">1552 #endif</span>
1553     typedef HashMap&lt;RefPtr&lt;UniquedStringImpl&gt;, uint32_t, IdentifierRepHash&gt; StringConstantPool;
1554     StringConstantPool m_constantPool;
1555     Identifier m_emptyIdentifier;
1556     SerializationContext m_context;
1557     ArrayBufferContentsArray&amp; m_sharedBuffers;
1558 #if ENABLE(WEBASSEMBLY)
1559     WasmModuleArray&amp; m_wasmModules;
1560 #endif
1561 };
1562 
1563 SerializationReturnCode CloneSerializer::serialize(JSValue in)
1564 {
<span class="line-modified">1565     VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
1566     Vector&lt;uint32_t, 16&gt; indexStack;
1567     Vector&lt;uint32_t, 16&gt; lengthStack;
1568     Vector&lt;PropertyNameArray, 16&gt; propertyStack;
1569     Vector&lt;JSObject*, 32&gt; inputObjectStack;
1570     Vector&lt;JSMapIterator*, 4&gt; mapIteratorStack;
1571     Vector&lt;JSSetIterator*, 4&gt; setIteratorStack;
1572     Vector&lt;JSValue, 4&gt; mapIteratorValueStack;
1573     Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">1574     WalkerState lexicalGlobalObject = StateUnknown;</span>
1575     JSValue inValue = in;
1576     while (1) {
<span class="line-modified">1577         switch (lexicalGlobalObject) {</span>
1578             arrayStartState:
1579             case ArrayStartState: {
1580                 ASSERT(isArray(vm, inValue));
1581                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1582                     return SerializationReturnCode::StackOverflowError;
1583 
1584                 JSArray* inArray = asArray(inValue);
1585                 unsigned length = inArray-&gt;length();
1586                 if (!startArray(inArray))
1587                     break;
1588                 inputObjectStack.append(inArray);
1589                 indexStack.append(0);
1590                 lengthStack.append(length);
1591             }
1592             arrayStartVisitMember:
1593             FALLTHROUGH;
1594             case ArrayStartVisitMember: {
1595                 JSObject* array = inputObjectStack.last();
1596                 uint32_t index = indexStack.last();
1597                 if (index == lengthStack.last()) {
1598                     indexStack.removeLast();
1599                     lengthStack.removeLast();
1600 
1601                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1602                     array-&gt;methodTable(vm)-&gt;getOwnNonIndexPropertyNames(array, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
1603                     if (propertyStack.last().size()) {
1604                         write(NonIndexPropertiesTag);
1605                         indexStack.append(0);
1606                         goto objectStartVisitMember;
1607                     }
1608                     propertyStack.removeLast();
1609 
1610                     endObject();
1611                     inputObjectStack.removeLast();
1612                     break;
1613                 }
<span class="line-modified">1614                 inValue = array-&gt;getDirectIndex(m_lexicalGlobalObject, index);</span>
1615                 if (!inValue) {
1616                     indexStack.last()++;
1617                     goto arrayStartVisitMember;
1618                 }
1619 
1620                 write(index);
1621                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1622                 if (dumpIfTerminal(inValue, terminalCode)) {
1623                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1624                         return terminalCode;
1625                     indexStack.last()++;
1626                     goto arrayStartVisitMember;
1627                 }
1628                 stateStack.append(ArrayEndVisitMember);
1629                 goto stateUnknown;
1630             }
1631             case ArrayEndVisitMember: {
1632                 indexStack.last()++;
1633                 goto arrayStartVisitMember;
1634             }
1635             objectStartState:
1636             case ObjectStartState: {
1637                 ASSERT(inValue.isObject());
1638                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1639                     return SerializationReturnCode::StackOverflowError;
1640                 JSObject* inObject = asObject(inValue);
1641                 if (!startObject(inObject))
1642                     break;
1643                 // At this point, all supported objects other than Object
1644                 // objects have been handled. If we reach this point and
1645                 // the input is not an Object object then we should throw
1646                 // a DataCloneError.
1647                 if (inObject-&gt;classInfo(vm) != JSFinalObject::info())
1648                     return SerializationReturnCode::DataCloneError;
1649                 inputObjectStack.append(inObject);
1650                 indexStack.append(0);
1651                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1652                 inObject-&gt;methodTable(vm)-&gt;getOwnPropertyNames(inObject, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
1653             }
1654             objectStartVisitMember:
1655             FALLTHROUGH;
1656             case ObjectStartVisitMember: {
1657                 JSObject* object = inputObjectStack.last();
1658                 uint32_t index = indexStack.last();
1659                 PropertyNameArray&amp; properties = propertyStack.last();
1660                 if (index == properties.size()) {
1661                     endObject();
1662                     inputObjectStack.removeLast();
1663                     indexStack.removeLast();
1664                     propertyStack.removeLast();
1665                     break;
1666                 }
1667                 inValue = getProperty(vm, object, properties[index]);
1668                 if (shouldTerminate())
1669                     return SerializationReturnCode::ExistingExceptionError;
1670 
1671                 if (!inValue) {
1672                     // Property was removed during serialisation
</pre>
<hr />
<pre>
1684                     goto stateUnknown;
1685                 }
1686                 if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1687                     return terminalCode;
1688                 FALLTHROUGH;
1689             }
1690             case ObjectEndVisitMember: {
1691                 if (shouldTerminate())
1692                     return SerializationReturnCode::ExistingExceptionError;
1693 
1694                 indexStack.last()++;
1695                 goto objectStartVisitMember;
1696             }
1697             mapStartState: {
1698                 ASSERT(inValue.isObject());
1699                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1700                     return SerializationReturnCode::StackOverflowError;
1701                 JSMap* inMap = jsCast&lt;JSMap*&gt;(inValue);
1702                 if (!startMap(inMap))
1703                     break;
<span class="line-modified">1704                 JSMapIterator* iterator = JSMapIterator::create(vm, vm.mapIteratorStructure(), inMap, IterationKind::Entries);</span>
1705                 m_gcBuffer.appendWithCrashOnOverflow(inMap);
1706                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1707                 mapIteratorStack.append(iterator);
1708                 inputObjectStack.append(inMap);
1709                 goto mapDataStartVisitEntry;
1710             }
1711             mapDataStartVisitEntry:
1712             case MapDataStartVisitEntry: {
1713                 JSMapIterator* iterator = mapIteratorStack.last();
1714                 JSValue key, value;
<span class="line-modified">1715                 if (!iterator-&gt;nextKeyValue(m_lexicalGlobalObject, key, value)) {</span>
1716                     mapIteratorStack.removeLast();
1717                     JSObject* object = inputObjectStack.last();
1718                     ASSERT(jsDynamicCast&lt;JSMap*&gt;(vm, object));
1719                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1720                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
1721                     write(NonMapPropertiesTag);
1722                     indexStack.append(0);
1723                     goto objectStartVisitMember;
1724                 }
1725                 inValue = key;
1726                 m_gcBuffer.appendWithCrashOnOverflow(value);
1727                 mapIteratorValueStack.append(value);
1728                 stateStack.append(MapDataEndVisitKey);
1729                 goto stateUnknown;
1730             }
1731             case MapDataEndVisitKey: {
1732                 inValue = mapIteratorValueStack.last();
1733                 mapIteratorValueStack.removeLast();
1734                 stateStack.append(MapDataEndVisitValue);
1735                 goto stateUnknown;
1736             }
1737             case MapDataEndVisitValue: {
1738                 goto mapDataStartVisitEntry;
1739             }
1740 
1741             setStartState: {
1742                 ASSERT(inValue.isObject());
1743                 if (inputObjectStack.size() &gt; maximumFilterRecursion)
1744                     return SerializationReturnCode::StackOverflowError;
1745                 JSSet* inSet = jsCast&lt;JSSet*&gt;(inValue);
1746                 if (!startSet(inSet))
1747                     break;
<span class="line-modified">1748                 JSSetIterator* iterator = JSSetIterator::create(vm, vm.setIteratorStructure(), inSet, IterationKind::Keys);</span>
1749                 m_gcBuffer.appendWithCrashOnOverflow(inSet);
1750                 m_gcBuffer.appendWithCrashOnOverflow(iterator);
1751                 setIteratorStack.append(iterator);
1752                 inputObjectStack.append(inSet);
1753                 goto setDataStartVisitEntry;
1754             }
1755             setDataStartVisitEntry:
1756             case SetDataStartVisitEntry: {
1757                 JSSetIterator* iterator = setIteratorStack.last();
1758                 JSValue key;
<span class="line-modified">1759                 if (!iterator-&gt;next(m_lexicalGlobalObject, key)) {</span>
1760                     setIteratorStack.removeLast();
1761                     JSObject* object = inputObjectStack.last();
1762                     ASSERT(jsDynamicCast&lt;JSSet*&gt;(vm, object));
1763                     propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
<span class="line-modified">1764                     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_lexicalGlobalObject, propertyStack.last(), EnumerationMode());</span>
1765                     write(NonSetPropertiesTag);
1766                     indexStack.append(0);
1767                     goto objectStartVisitMember;
1768                 }
1769                 inValue = key;
1770                 stateStack.append(SetDataEndVisitKey);
1771                 goto stateUnknown;
1772             }
1773             case SetDataEndVisitKey: {
1774                 goto setDataStartVisitEntry;
1775             }
1776 
1777             stateUnknown:
1778             case StateUnknown: {
1779                 auto terminalCode = SerializationReturnCode::SuccessfullyCompleted;
1780                 if (dumpIfTerminal(inValue, terminalCode)) {
1781                     if (terminalCode != SerializationReturnCode::SuccessfullyCompleted)
1782                         return terminalCode;
1783                     break;
1784                 }
1785 
1786                 if (isArray(vm, inValue))
1787                     goto arrayStartState;
1788                 if (isMap(vm, inValue))
1789                     goto mapStartState;
1790                 if (isSet(vm, inValue))
1791                     goto setStartState;
1792                 goto objectStartState;
1793             }
1794         }
1795         if (stateStack.isEmpty())
1796             break;
1797 
<span class="line-modified">1798         lexicalGlobalObject = stateStack.last();</span>
1799         stateStack.removeLast();
1800     }
1801     if (m_failed)
1802         return SerializationReturnCode::UnspecifiedError;
1803 
1804     return SerializationReturnCode::SuccessfullyCompleted;
1805 }
1806 
1807 class CloneDeserializer : CloneBase {
1808 public:
1809     static String deserializeString(const Vector&lt;uint8_t&gt;&amp; buffer)
1810     {
1811         if (buffer.isEmpty())
1812             return String();
1813         const uint8_t* ptr = buffer.begin();
1814         const uint8_t* end = buffer.end();
1815         uint32_t version;
1816         if (!readLittleEndian(ptr, end, version) || version &gt; CurrentVersion)
1817             return String();
1818         uint8_t tag;
1819         if (!readLittleEndian(ptr, end, tag) || tag != StringTag)
1820             return String();
1821         uint32_t length;
1822         if (!readLittleEndian(ptr, end, length))
1823             return String();
1824         bool is8Bit = length &amp; StringDataIs8BitFlag;
1825         length &amp;= ~StringDataIs8BitFlag;
1826         String str;
1827         if (!readString(ptr, end, str, length, is8Bit))
1828             return String();
1829         return str;
1830     }
1831 
<span class="line-modified">1832     static DeserializationResult deserialize(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
<span class="line-added">1833 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1834         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases</span>
<span class="line-added">1835 #endif</span>
<span class="line-added">1836         , ArrayBufferContentsArray* arrayBufferContentsArray, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers</span>
1837 #if ENABLE(WEBASSEMBLY)
1838         , WasmModuleArray* wasmModules
1839 #endif
1840         )
1841     {
1842         if (!buffer.size())
1843             return std::make_pair(jsNull(), SerializationReturnCode::UnspecifiedError);
<span class="line-modified">1844         CloneDeserializer deserializer(lexicalGlobalObject, globalObject, messagePorts, arrayBufferContentsArray, buffer, blobURLs, blobFilePaths, sharedBuffers, WTFMove(imageBuffers)</span>
<span class="line-added">1845 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1846             , WTFMove(detachedOffscreenCanvases)</span>
<span class="line-added">1847 #endif</span>
1848 #if ENABLE(WEBASSEMBLY)
1849             , wasmModules
1850 #endif
1851             );
1852         if (!deserializer.isValid())
1853             return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
1854         return deserializer.deserialize();
1855     }
1856 
1857 private:
1858     struct CachedString {
1859         CachedString(const String&amp; string)
1860             : m_string(string)
1861         {
1862         }
1863 
<span class="line-modified">1864         JSValue jsString(JSGlobalObject* lexicalGlobalObject)</span>
1865         {
1866             if (!m_jsString)
<span class="line-modified">1867                 m_jsString = JSC::jsString(lexicalGlobalObject-&gt;vm(), m_string);</span>
1868             return m_jsString;
1869         }
1870         const String&amp; string() { return m_string; }
1871         String takeString() { return WTFMove(m_string); }
1872 
1873     private:
1874         String m_string;
1875         JSValue m_jsString;
1876     };
1877 
1878     struct CachedStringRef {
1879         CachedStringRef()
1880             : m_base(0)
1881             , m_index(0)
1882         {
1883         }
1884         CachedStringRef(Vector&lt;CachedString&gt;* base, size_t index)
1885             : m_base(base)
1886             , m_index(index)
1887         {
1888         }
1889 
1890         CachedString* operator-&gt;() { ASSERT(m_base); return &amp;m_base-&gt;at(m_index); }
1891 
1892     private:
1893         Vector&lt;CachedString&gt;* m_base;
1894         size_t m_index;
1895     };
1896 
<span class="line-modified">1897     CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers, const Vector&lt;uint8_t&gt;&amp; buffer</span>
<span class="line-added">1898 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1899         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases = { }</span>
<span class="line-added">1900 #endif</span>
1901 #if ENABLE(WEBASSEMBLY)
<span class="line-modified">1902         , WasmModuleArray* wasmModules = nullptr</span>
1903 #endif
<span class="line-modified">1904         )</span>
<span class="line-modified">1905         : CloneBase(lexicalGlobalObject)</span>
1906         , m_globalObject(globalObject)
1907         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1908         , m_ptr(buffer.data())
1909         , m_end(buffer.data() + buffer.size())
1910         , m_version(0xFFFFFFFF)
1911         , m_messagePorts(messagePorts)
1912         , m_arrayBufferContents(arrayBufferContents)
1913         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1914         , m_imageBuffers(WTFMove(imageBuffers))
1915         , m_imageBitmaps(m_imageBuffers.size())
<span class="line-added">1916 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1917         , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))</span>
<span class="line-added">1918         , m_offscreenCanvases(m_detachedOffscreenCanvases.size())</span>
<span class="line-added">1919 #endif</span>
1920 #if ENABLE(WEBASSEMBLY)
1921         , m_wasmModules(wasmModules)
1922 #endif
1923     {
1924         if (!read(m_version))
1925             m_version = 0xFFFFFFFF;
1926     }
1927 
<span class="line-modified">1928     CloneDeserializer(JSGlobalObject* lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, ArrayBufferContentsArray* arrayBufferContents, const Vector&lt;uint8_t&gt;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt; blobFilePaths, ArrayBufferContentsArray* sharedBuffers, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers</span>
<span class="line-added">1929 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1930         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases</span>
<span class="line-added">1931 #endif</span>
1932 #if ENABLE(WEBASSEMBLY)
1933         , WasmModuleArray* wasmModules
1934 #endif
1935         )
<span class="line-modified">1936         : CloneBase(lexicalGlobalObject)</span>
1937         , m_globalObject(globalObject)
1938         , m_isDOMGlobalObject(globalObject-&gt;inherits&lt;JSDOMGlobalObject&gt;(globalObject-&gt;vm()))
1939         , m_ptr(buffer.data())
1940         , m_end(buffer.data() + buffer.size())
1941         , m_version(0xFFFFFFFF)
1942         , m_messagePorts(messagePorts)
1943         , m_arrayBufferContents(arrayBufferContents)
1944         , m_arrayBuffers(arrayBufferContents ? arrayBufferContents-&gt;size() : 0)
1945         , m_blobURLs(blobURLs)
1946         , m_blobFilePaths(blobFilePaths)
1947         , m_sharedBuffers(sharedBuffers)
1948         , m_imageBuffers(WTFMove(imageBuffers))
1949         , m_imageBitmaps(m_imageBuffers.size())
<span class="line-added">1950 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">1951         , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))</span>
<span class="line-added">1952         , m_offscreenCanvases(m_detachedOffscreenCanvases.size())</span>
<span class="line-added">1953 #endif</span>
1954 #if ENABLE(WEBASSEMBLY)
1955         , m_wasmModules(wasmModules)
1956 #endif
1957     {
1958         if (!read(m_version))
1959             m_version = 0xFFFFFFFF;
1960     }
1961 
1962     DeserializationResult deserialize();
1963 
1964     bool isValid() const { return m_version &lt;= CurrentVersion; }
1965 
1966     template &lt;typename T&gt; bool readLittleEndian(T&amp; value)
1967     {
1968         if (m_failed || !readLittleEndian(m_ptr, m_end, value)) {
1969             fail();
1970             return false;
1971         }
1972         return true;
1973     }
</pre>
<hr />
<pre>
2138         return true;
2139     }
2140 
2141     SerializationTag readTag()
2142     {
2143         if (m_ptr &gt;= m_end)
2144             return ErrorTag;
2145         return static_cast&lt;SerializationTag&gt;(*m_ptr++);
2146     }
2147 
2148     bool readArrayBufferViewSubtag(ArrayBufferViewSubtag&amp; tag)
2149     {
2150         if (m_ptr &gt;= m_end)
2151             return false;
2152         tag = static_cast&lt;ArrayBufferViewSubtag&gt;(*m_ptr++);
2153         return true;
2154     }
2155 
2156     void putProperty(JSObject* object, unsigned index, JSValue value)
2157     {
<span class="line-modified">2158         object-&gt;putDirectIndex(m_lexicalGlobalObject, index, value);</span>
2159     }
2160 
2161     void putProperty(JSObject* object, const Identifier&amp; property, JSValue value)
2162     {
<span class="line-modified">2163         object-&gt;putDirectMayBeIndex(m_lexicalGlobalObject, property, value);</span>
2164     }
2165 
2166     bool readFile(RefPtr&lt;File&gt;&amp; file)
2167     {
2168         CachedStringRef path;
2169         if (!readStringData(path))
2170             return false;
2171         CachedStringRef url;
2172         if (!readStringData(url))
2173             return false;
2174         CachedStringRef type;
2175         if (!readStringData(type))
2176             return false;
2177         CachedStringRef name;
2178         if (!readStringData(name))
2179             return false;
2180         Optional&lt;int64_t&gt; optionalLastModified;
2181         if (m_version &gt; 6) {
2182             double lastModified;
2183             if (!read(lastModified))
2184                 return false;
2185             if (lastModified &gt;= 0)
2186                 optionalLastModified = lastModified;
2187         }
2188 
2189         // If the blob URL for this file has an associated blob file path, prefer that one over the &quot;built-in&quot; path.
2190         String filePath = blobFilePathForBlobURL(url-&gt;string());
2191         if (filePath.isEmpty())
2192             filePath = path-&gt;string();
2193 
2194         if (m_isDOMGlobalObject)
<span class="line-modified">2195             file = File::deserialize(filePath, URL(URL(), url-&gt;string()), type-&gt;string(), name-&gt;string(), optionalLastModified);</span>
2196         return true;
2197     }
2198 
2199     bool readArrayBuffer(RefPtr&lt;ArrayBuffer&gt;&amp; arrayBuffer)
2200     {
2201         uint32_t length;
2202         if (!read(length))
2203             return false;
2204         if (m_ptr + length &gt; m_end)
2205             return false;
2206         arrayBuffer = ArrayBuffer::create(m_ptr, length);
2207         m_ptr += length;
2208         return true;
2209     }
2210 
2211     bool readArrayBufferView(VM&amp; vm, JSValue&amp; arrayBufferView)
2212     {
2213         ArrayBufferViewSubtag arrayBufferViewSubtag;
2214         if (!readArrayBufferViewSubtag(arrayBufferViewSubtag))
2215             return false;
2216         uint32_t byteOffset;
2217         if (!read(byteOffset))
2218             return false;
2219         uint32_t byteLength;
2220         if (!read(byteLength))
2221             return false;
2222         JSObject* arrayBufferObj = asObject(readTerminal());
2223         if (!arrayBufferObj || !arrayBufferObj-&gt;inherits&lt;JSArrayBuffer&gt;(vm))
2224             return false;
2225 
2226         unsigned elementSize = typedArrayElementSize(arrayBufferViewSubtag);
2227         if (!elementSize)
2228             return false;
2229         unsigned length = byteLength / elementSize;
2230         if (length * elementSize != byteLength)
2231             return false;
2232 
2233         RefPtr&lt;ArrayBuffer&gt; arrayBuffer = toPossiblySharedArrayBuffer(vm, arrayBufferObj);
2234         switch (arrayBufferViewSubtag) {
2235         case DataViewTag:
<span class="line-modified">2236             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, DataView::create(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2237             return true;
2238         case Int8ArrayTag:
<span class="line-modified">2239             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2240             return true;
2241         case Uint8ArrayTag:
<span class="line-modified">2242             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2243             return true;
2244         case Uint8ClampedArrayTag:
<span class="line-modified">2245             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2246             return true;
2247         case Int16ArrayTag:
<span class="line-modified">2248             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2249             return true;
2250         case Uint16ArrayTag:
<span class="line-modified">2251             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint16Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2252             return true;
2253         case Int32ArrayTag:
<span class="line-modified">2254             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Int32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2255             return true;
2256         case Uint32ArrayTag:
<span class="line-modified">2257             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Uint32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2258             return true;
2259         case Float32ArrayTag:
<span class="line-modified">2260             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float32Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2261             return true;
2262         case Float64ArrayTag:
<span class="line-modified">2263             arrayBufferView = toJS(m_lexicalGlobalObject, m_globalObject, Float64Array::tryCreate(WTFMove(arrayBuffer), byteOffset, length).get());</span>
2264             return true;
2265         default:
2266             return false;
2267         }
2268     }
2269 
2270     bool read(Vector&lt;uint8_t&gt;&amp; result)
2271     {
2272         ASSERT(result.isEmpty());
2273         uint32_t size;
2274         if (!read(size))
2275             return false;
2276         if (m_ptr + size &gt; m_end)
2277             return false;
2278         result.append(m_ptr, size);
2279         m_ptr += size;
2280         return true;
2281     }
2282 
2283 #if ENABLE(WEB_CRYPTO)
</pre>
<hr />
<pre>
2399     {
2400         CryptoAlgorithmIdentifier algorithm;
2401         if (!read(algorithm))
2402             return false;
2403         if (!CryptoKeyAES::isValidAESAlgorithm(algorithm))
2404             return false;
2405         Vector&lt;uint8_t&gt; keyData;
2406         if (!read(keyData))
2407             return false;
2408         result = CryptoKeyAES::importRaw(algorithm, WTFMove(keyData), extractable, usages);
2409         return true;
2410     }
2411 
2412     bool readRSAKey(bool extractable, CryptoKeyUsageBitmap usages, RefPtr&lt;CryptoKey&gt;&amp; result)
2413     {
2414         CryptoAlgorithmIdentifier algorithm;
2415         if (!read(algorithm))
2416             return false;
2417 
2418         int32_t isRestrictedToHash;
<span class="line-modified">2419         CryptoAlgorithmIdentifier hash = CryptoAlgorithmIdentifier::SHA_1;</span>
2420         if (!read(isRestrictedToHash))
2421             return false;
2422         if (isRestrictedToHash &amp;&amp; !read(hash))
2423             return false;
2424 
2425         CryptoKeyAsymmetricTypeSubtag type;
2426         if (!read(type))
2427             return false;
2428 
2429         Vector&lt;uint8_t&gt; modulus;
2430         if (!read(modulus))
2431             return false;
2432         Vector&lt;uint8_t&gt; exponent;
2433         if (!read(exponent))
2434             return false;
2435 
2436         if (type == CryptoKeyAsymmetricTypeSubtag::Public) {
2437             auto keyData = CryptoKeyRSAComponents::createPublic(modulus, exponent);
2438             auto key = CryptoKeyRSA::create(algorithm, hash, isRestrictedToHash, *keyData, extractable, usages);
2439             result = WTFMove(key);
</pre>
<hr />
<pre>
2592             if (!readRSAKey(extractable, usages, result))
2593                 return false;
2594             break;
2595         case CryptoKeyClassSubtag::EC:
2596             if (!readECKey(extractable, usages, result))
2597                 return false;
2598             break;
2599         case CryptoKeyClassSubtag::Raw:
2600             if (!readRawKey(usages, result))
2601                 return false;
2602             break;
2603         }
2604         cryptoKey = getJSValue(result.get());
2605         return true;
2606     }
2607 #endif
2608 
2609     template&lt;class T&gt;
2610     JSValue getJSValue(T* nativeObj)
2611     {
<span class="line-modified">2612         return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
2613     }
2614 
2615     template&lt;class T&gt;
2616     JSValue getJSValue(T&amp; nativeObj)
2617     {
<span class="line-modified">2618         return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), nativeObj);</span>
2619     }
2620 
2621     template&lt;class T&gt;
2622     JSValue readDOMPoint()
2623     {
2624         double x;
2625         if (!read(x))
2626             return { };
2627         double y;
2628         if (!read(y))
2629             return { };
2630         double z;
2631         if (!read(z))
2632             return { };
2633         double w;
2634         if (!read(w))
2635             return { };
2636 
<span class="line-modified">2637         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, z, w));</span>
2638     }
2639 
2640     template&lt;class T&gt;
2641     JSValue readDOMMatrix()
2642     {
2643         uint8_t is2D;
2644         if (!read(is2D))
2645             return { };
2646 
2647         if (is2D) {
2648             double m11;
2649             if (!read(m11))
2650                 return { };
2651             double m12;
2652             if (!read(m12))
2653                 return { };
2654             double m21;
2655             if (!read(m21))
2656                 return { };
2657             double m22;
2658             if (!read(m22))
2659                 return { };
2660             double m41;
2661             if (!read(m41))
2662                 return { };
2663             double m42;
2664             if (!read(m42))
2665                 return { };
2666 
2667             TransformationMatrix matrix(m11, m12, m21, m22, m41, m42);
<span class="line-modified">2668             return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::Yes));</span>
2669         } else {
2670             double m11;
2671             if (!read(m11))
2672                 return { };
2673             double m12;
2674             if (!read(m12))
2675                 return { };
2676             double m13;
2677             if (!read(m13))
2678                 return { };
2679             double m14;
2680             if (!read(m14))
2681                 return { };
2682             double m21;
2683             if (!read(m21))
2684                 return { };
2685             double m22;
2686             if (!read(m22))
2687                 return { };
2688             double m23;
</pre>
<hr />
<pre>
2700             double m33;
2701             if (!read(m33))
2702                 return { };
2703             double m34;
2704             if (!read(m34))
2705                 return { };
2706             double m41;
2707             if (!read(m41))
2708                 return { };
2709             double m42;
2710             if (!read(m42))
2711                 return { };
2712             double m43;
2713             if (!read(m43))
2714                 return { };
2715             double m44;
2716             if (!read(m44))
2717                 return { };
2718 
2719             TransformationMatrix matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
<span class="line-modified">2720             return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(WTFMove(matrix), DOMMatrixReadOnly::Is2D::No));</span>
2721         }
2722     }
2723 
2724     template&lt;class T&gt;
2725     JSValue readDOMRect()
2726     {
2727         double x;
2728         if (!read(x))
2729             return { };
2730         double y;
2731         if (!read(y))
2732             return { };
2733         double width;
2734         if (!read(width))
2735             return { };
2736         double height;
2737         if (!read(height))
2738             return { };
2739 
<span class="line-modified">2740         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), T::create(x, y, width, height));</span>
2741     }
2742 
2743     Optional&lt;DOMPointInit&gt; readDOMPointInit()
2744     {
2745         DOMPointInit point;
2746         if (!read(point.x))
2747             return WTF::nullopt;
2748         if (!read(point.y))
2749             return WTF::nullopt;
2750         if (!read(point.z))
2751             return WTF::nullopt;
2752         if (!read(point.w))
2753             return WTF::nullopt;
2754 
2755         return point;
2756     }
2757 
2758     JSValue readDOMQuad()
2759     {
2760         auto p1 = readDOMPointInit();
2761         if (!p1)
2762             return JSValue();
2763         auto p2 = readDOMPointInit();
2764         if (!p2)
2765             return JSValue();
2766         auto p3 = readDOMPointInit();
2767         if (!p3)
2768             return JSValue();
2769         auto p4 = readDOMPointInit();
2770         if (!p4)
2771             return JSValue();
2772 
<span class="line-modified">2773         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), DOMQuad::create(p1.value(), p2.value(), p3.value(), p4.value()));</span>
2774     }
2775 
<span class="line-modified">2776     JSValue readTransferredImageBitmap()</span>
2777     {
2778         uint32_t index;
2779         bool indexSuccessfullyRead = read(index);
2780         if (!indexSuccessfullyRead || index &gt;= m_imageBuffers.size()) {
2781             fail();
2782             return JSValue();
2783         }
2784 
2785         if (!m_imageBitmaps[index])
2786             m_imageBitmaps[index] = ImageBitmap::create(WTFMove(m_imageBuffers.at(index)));
2787 
2788         auto bitmap = m_imageBitmaps[index].get();
2789         return getJSValue(bitmap);
2790     }
2791 
<span class="line-added">2792 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">2793     JSValue readOffscreenCanvas()</span>
<span class="line-added">2794     {</span>
<span class="line-added">2795         uint32_t index;</span>
<span class="line-added">2796         bool indexSuccessfullyRead = read(index);</span>
<span class="line-added">2797         if (!indexSuccessfullyRead || index &gt;= m_detachedOffscreenCanvases.size()) {</span>
<span class="line-added">2798             fail();</span>
<span class="line-added">2799             return JSValue();</span>
<span class="line-added">2800         }</span>
<span class="line-added">2801 </span>
<span class="line-added">2802         if (!m_offscreenCanvases[index])</span>
<span class="line-added">2803             m_offscreenCanvases[index] = OffscreenCanvas::create(*scriptExecutionContextFromExecState(m_lexicalGlobalObject), WTFMove(m_detachedOffscreenCanvases.at(index)));</span>
<span class="line-added">2804 </span>
<span class="line-added">2805         auto offscreenCanvas = m_offscreenCanvases[index].get();</span>
<span class="line-added">2806         return getJSValue(offscreenCanvas);</span>
<span class="line-added">2807     }</span>
<span class="line-added">2808 #endif</span>
<span class="line-added">2809 </span>
2810 #if ENABLE(WEB_RTC)
2811     JSValue readRTCCertificate()
2812     {
2813         double expires;
2814         if (!read(expires)) {
2815             fail();
2816             return JSValue();
2817         }
2818         CachedStringRef certificate;
2819         if (!readStringData(certificate)) {
2820             fail();
2821             return JSValue();
2822         }
2823         CachedStringRef origin;
2824         if (!readStringData(origin)) {
2825             fail();
2826             return JSValue();
2827         }
2828         CachedStringRef keyedMaterial;
2829         if (!readStringData(keyedMaterial)) {
2830             fail();
2831             return JSValue();
2832         }
2833         unsigned size = 0;
2834         if (!read(size))
2835             return JSValue();
2836 
2837         Vector&lt;RTCCertificate::DtlsFingerprint&gt; fingerprints;
2838         fingerprints.reserveInitialCapacity(size);
2839         for (unsigned i = 0; i &lt; size; i++) {
2840             CachedStringRef algorithm;
2841             if (!readStringData(algorithm))
2842                 return JSValue();
2843             CachedStringRef value;
2844             if (!readStringData(value))
2845                 return JSValue();
2846             fingerprints.uncheckedAppend(RTCCertificate::DtlsFingerprint { algorithm-&gt;string(), value-&gt;string() });
2847         }
2848 
2849         if (!m_isDOMGlobalObject)
<span class="line-modified">2850             return constructEmptyObject(m_lexicalGlobalObject, m_globalObject-&gt;objectPrototype());</span>
2851 
2852         auto rtcCertificate = RTCCertificate::create(SecurityOrigin::createFromString(origin-&gt;string()), expires, WTFMove(fingerprints), certificate-&gt;takeString(), keyedMaterial-&gt;takeString());
<span class="line-modified">2853         return toJSNewlyCreated(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), WTFMove(rtcCertificate));</span>
2854     }
2855 #endif
2856 
<span class="line-added">2857     JSValue readImageBitmap()</span>
<span class="line-added">2858     {</span>
<span class="line-added">2859         uint8_t originClean;</span>
<span class="line-added">2860         int32_t logicalWidth;</span>
<span class="line-added">2861         int32_t logicalHeight;</span>
<span class="line-added">2862         double resolutionScale;</span>
<span class="line-added">2863         RefPtr&lt;ArrayBuffer&gt; arrayBuffer;</span>
<span class="line-added">2864 </span>
<span class="line-added">2865         if (!read(originClean) || !read(logicalWidth) || !read(logicalHeight) || !read(resolutionScale) || !readArrayBuffer(arrayBuffer)) {</span>
<span class="line-added">2866             fail();</span>
<span class="line-added">2867             return JSValue();</span>
<span class="line-added">2868         }</span>
<span class="line-added">2869 </span>
<span class="line-added">2870         auto imageData = Uint8ClampedArray::tryCreate(WTFMove(arrayBuffer), 0, arrayBuffer-&gt;byteLength());</span>
<span class="line-added">2871         if (!imageData) {</span>
<span class="line-added">2872             fail();</span>
<span class="line-added">2873             return JSValue();</span>
<span class="line-added">2874         }</span>
<span class="line-added">2875 </span>
<span class="line-added">2876         auto buffer = ImageBuffer::create(FloatSize(logicalWidth, logicalHeight), RenderingMode::Unaccelerated, resolutionScale);</span>
<span class="line-added">2877         if (!buffer) {</span>
<span class="line-added">2878             fail();</span>
<span class="line-added">2879             return JSValue();</span>
<span class="line-added">2880         }</span>
<span class="line-added">2881 </span>
<span class="line-added">2882         buffer-&gt;putByteArray(*imageData, AlphaPremultiplication::Premultiplied, IntSize(logicalWidth, logicalHeight), IntRect(0, 0, logicalWidth, logicalHeight), IntPoint());</span>
<span class="line-added">2883 </span>
<span class="line-added">2884         auto bitmap = ImageBitmap::create({ WTFMove(buffer), static_cast&lt;bool&gt;(originClean) });</span>
<span class="line-added">2885         return getJSValue(bitmap);</span>
<span class="line-added">2886     }</span>
<span class="line-added">2887 </span>
2888     JSValue readTerminal()
2889     {
2890         SerializationTag tag = readTag();
2891         switch (tag) {
2892         case UndefinedTag:
2893             return jsUndefined();
2894         case NullTag:
2895             return jsNull();
2896         case IntTag: {
2897             int32_t i;
2898             if (!read(i))
2899                 return JSValue();
2900             return jsNumber(i);
2901         }
2902         case ZeroTag:
2903             return jsNumber(0);
2904         case OneTag:
2905             return jsNumber(1);
2906         case FalseTag:
2907             return jsBoolean(false);
2908         case TrueTag:
2909             return jsBoolean(true);
2910         case FalseObjectTag: {
<span class="line-modified">2911             BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">2912             obj-&gt;setInternalValue(m_lexicalGlobalObject-&gt;vm(), jsBoolean(false));</span>
2913             m_gcBuffer.appendWithCrashOnOverflow(obj);
2914             return obj;
2915         }
2916         case TrueObjectTag: {
<span class="line-modified">2917             BooleanObject* obj = BooleanObject::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;booleanObjectStructure());</span>
<span class="line-modified">2918             obj-&gt;setInternalValue(m_lexicalGlobalObject-&gt;vm(), jsBoolean(true));</span>
2919             m_gcBuffer.appendWithCrashOnOverflow(obj);
2920             return obj;
2921         }
2922         case DoubleTag: {
2923             double d;
2924             if (!read(d))
2925                 return JSValue();
2926             return jsNumber(d);
2927         }
2928         case NumberObjectTag: {
2929             double d;
2930             if (!read(d))
2931                 return JSValue();
<span class="line-modified">2932             NumberObject* obj = constructNumber(m_globalObject, jsNumber(d));</span>
2933             m_gcBuffer.appendWithCrashOnOverflow(obj);
2934             return obj;
2935         }
2936         case DateTag: {
2937             double d;
2938             if (!read(d))
2939                 return JSValue();
<span class="line-modified">2940             return DateInstance::create(m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;dateStructure(), d);</span>
2941         }
2942         case FileTag: {
2943             RefPtr&lt;File&gt; file;
2944             if (!readFile(file))
2945                 return JSValue();
2946             if (!m_isDOMGlobalObject)
2947                 return jsNull();
<span class="line-modified">2948             return toJS(m_lexicalGlobalObject, jsCast&lt;JSDOMGlobalObject*&gt;(m_globalObject), file.get());</span>
2949         }
2950         case FileListTag: {
2951             unsigned length = 0;
2952             if (!read(length))
2953                 return JSValue();
2954             Vector&lt;Ref&lt;File&gt;&gt; files;
2955             for (unsigned i = 0; i &lt; length; i++) {
2956                 RefPtr&lt;File&gt; file;
2957                 if (!readFile(file))
2958                     return JSValue();
2959                 if (m_isDOMGlobalObject)
2960                     files.append(file.releaseNonNull());
2961             }
2962             if (!m_isDOMGlobalObject)
2963                 return jsNull();
2964             return getJSValue(FileList::create(WTFMove(files)).get());
2965         }
2966         case ImageDataTag: {
2967             uint32_t width;
2968             if (!read(width))
</pre>
<hr />
<pre>
2990             }
2991             if (length)
2992                 memcpy(result-&gt;data()-&gt;data(), m_ptr, length);
2993             else
2994                 result-&gt;data()-&gt;zeroFill();
2995             m_ptr += length;
2996             return getJSValue(result.get());
2997         }
2998         case BlobTag: {
2999             CachedStringRef url;
3000             if (!readStringData(url))
3001                 return JSValue();
3002             CachedStringRef type;
3003             if (!readStringData(type))
3004                 return JSValue();
3005             unsigned long long size = 0;
3006             if (!read(size))
3007                 return JSValue();
3008             if (!m_isDOMGlobalObject)
3009                 return jsNull();
<span class="line-modified">3010             return getJSValue(Blob::deserialize(URL(URL(), url-&gt;string()), type-&gt;string(), size, blobFilePathForBlobURL(url-&gt;string())).get());</span>
3011         }
3012         case StringTag: {
3013             CachedStringRef cachedString;
3014             if (!readStringData(cachedString))
3015                 return JSValue();
<span class="line-modified">3016             return cachedString-&gt;jsString(m_lexicalGlobalObject);</span>
3017         }
3018         case EmptyStringTag:
<span class="line-modified">3019             return jsEmptyString(m_lexicalGlobalObject-&gt;vm());</span>
3020         case StringObjectTag: {
3021             CachedStringRef cachedString;
3022             if (!readStringData(cachedString))
3023                 return JSValue();
<span class="line-modified">3024             StringObject* obj = constructString(m_lexicalGlobalObject-&gt;vm(), m_globalObject, cachedString-&gt;jsString(m_lexicalGlobalObject));</span>
3025             m_gcBuffer.appendWithCrashOnOverflow(obj);
3026             return obj;
3027         }
3028         case EmptyStringObjectTag: {
<span class="line-modified">3029             VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
3030             StringObject* obj = constructString(vm, m_globalObject, jsEmptyString(vm));
3031             m_gcBuffer.appendWithCrashOnOverflow(obj);
3032             return obj;
3033         }
3034         case RegExpTag: {
3035             CachedStringRef pattern;
3036             if (!readStringData(pattern))
3037                 return JSValue();
3038             CachedStringRef flags;
3039             if (!readStringData(flags))
3040                 return JSValue();
3041             auto reFlags = Yarr::parseFlags(flags-&gt;string());
3042             ASSERT(reFlags.hasValue());
<span class="line-modified">3043             VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
3044             RegExp* regExp = RegExp::create(vm, pattern-&gt;string(), reFlags.value());
3045             return RegExpObject::create(vm, m_globalObject-&gt;regExpStructure(), regExp);
3046         }
3047         case ObjectReferenceTag: {
3048             unsigned index = 0;
3049             if (!readConstantPoolIndex(m_gcBuffer, index)) {
3050                 fail();
3051                 return JSValue();
3052             }
3053             return m_gcBuffer.at(index);
3054         }
3055         case MessagePortReferenceTag: {
3056             uint32_t index;
3057             bool indexSuccessfullyRead = read(index);
3058             if (!indexSuccessfullyRead || index &gt;= m_messagePorts.size()) {
3059                 fail();
3060                 return JSValue();
3061             }
3062             return getJSValue(m_messagePorts[index].get());
3063         }
3064 #if ENABLE(WEBASSEMBLY)
3065         case WasmModuleTag: {
3066             uint32_t index;
3067             bool indexSuccessfullyRead = read(index);
3068             if (!indexSuccessfullyRead || !m_wasmModules || index &gt;= m_wasmModules-&gt;size()) {
3069                 fail();
3070                 return JSValue();
3071             }
<span class="line-modified">3072             auto scope = DECLARE_THROW_SCOPE(m_lexicalGlobalObject-&gt;vm());</span>
<span class="line-modified">3073             JSValue result = JSC::JSWebAssemblyModule::createStub(m_lexicalGlobalObject-&gt;vm(), m_lexicalGlobalObject, m_globalObject-&gt;webAssemblyModuleStructure(), m_wasmModules-&gt;at(index));</span>
3074             // Since we are cloning a JSWebAssemblyModule, it&#39;s impossible for that
3075             // module to not have been a valid module. Therefore, createStub should
3076             // not trow.
3077             scope.releaseAssertNoException();
3078             m_gcBuffer.appendWithCrashOnOverflow(result);
3079             return result;
3080         }
3081 #endif
3082         case ArrayBufferTag: {
3083             RefPtr&lt;ArrayBuffer&gt; arrayBuffer;
3084             if (!readArrayBuffer(arrayBuffer)) {
3085                 fail();
3086                 return JSValue();
3087             }
3088             Structure* structure = m_globalObject-&gt;arrayBufferStructure(arrayBuffer-&gt;sharingMode());
3089             // A crazy RuntimeFlags mismatch could mean that we are not equipped to handle shared
3090             // array buffers while the sender is. In that case, we would see a null structure here.
3091             if (!structure) {
3092                 fail();
3093                 return JSValue();
3094             }
<span class="line-modified">3095             JSValue result = JSArrayBuffer::create(m_lexicalGlobalObject-&gt;vm(), structure, WTFMove(arrayBuffer));</span>
3096             m_gcBuffer.appendWithCrashOnOverflow(result);
3097             return result;
3098         }
3099         case ArrayBufferTransferTag: {
3100             uint32_t index;
3101             bool indexSuccessfullyRead = read(index);
3102             if (!indexSuccessfullyRead || index &gt;= m_arrayBuffers.size()) {
3103                 fail();
3104                 return JSValue();
3105             }
3106 
3107             if (!m_arrayBuffers[index])
3108                 m_arrayBuffers[index] = ArrayBuffer::create(WTFMove(m_arrayBufferContents-&gt;at(index)));
3109 
3110             return getJSValue(m_arrayBuffers[index].get());
3111         }
3112         case SharedArrayBufferTag: {
3113             uint32_t index = UINT_MAX;
3114             bool indexSuccessfullyRead = read(index);
3115             if (!indexSuccessfullyRead || !m_sharedBuffers || index &gt;= m_sharedBuffers-&gt;size()) {
3116                 fail();
3117                 return JSValue();
3118             }
3119 
3120             RELEASE_ASSERT(m_sharedBuffers-&gt;at(index));
3121             auto buffer = ArrayBuffer::create(WTFMove(m_sharedBuffers-&gt;at(index)));
3122             JSValue result = getJSValue(buffer.get());
3123             m_gcBuffer.appendWithCrashOnOverflow(result);
3124             return result;
3125         }
3126         case ArrayBufferViewTag: {
3127             JSValue arrayBufferView;
<span class="line-modified">3128             if (!readArrayBufferView(m_lexicalGlobalObject-&gt;vm(), arrayBufferView)) {</span>
3129                 fail();
3130                 return JSValue();
3131             }
3132             m_gcBuffer.appendWithCrashOnOverflow(arrayBufferView);
3133             return arrayBufferView;
3134         }
3135 #if ENABLE(WEB_CRYPTO)
3136         case CryptoKeyTag: {
3137             Vector&lt;uint8_t&gt; wrappedKey;
3138             if (!read(wrappedKey)) {
3139                 fail();
3140                 return JSValue();
3141             }
3142             Vector&lt;uint8_t&gt; serializedKey;
<span class="line-modified">3143             if (!unwrapCryptoKey(m_lexicalGlobalObject, wrappedKey, serializedKey)) {</span>
3144                 fail();
3145                 return JSValue();
3146             }
3147             JSValue cryptoKey;
3148             Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
<span class="line-modified">3149             CloneDeserializer rawKeyDeserializer(m_lexicalGlobalObject, m_globalObject, dummyMessagePorts, nullptr, { }, serializedKey);</span>




3150             if (!rawKeyDeserializer.readCryptoKey(cryptoKey)) {
3151                 fail();
3152                 return JSValue();
3153             }
3154             m_gcBuffer.appendWithCrashOnOverflow(cryptoKey);
3155             return cryptoKey;
3156         }
3157 #endif
3158         case DOMPointReadOnlyTag:
3159             return readDOMPoint&lt;DOMPointReadOnly&gt;();
3160         case DOMPointTag:
3161             return readDOMPoint&lt;DOMPoint&gt;();
3162         case DOMRectReadOnlyTag:
3163             return readDOMRect&lt;DOMRectReadOnly&gt;();
3164         case DOMRectTag:
3165             return readDOMRect&lt;DOMRect&gt;();
3166         case DOMMatrixReadOnlyTag:
3167             return readDOMMatrix&lt;DOMMatrixReadOnly&gt;();
3168         case DOMMatrixTag:
3169             return readDOMMatrix&lt;DOMMatrix&gt;();
3170         case DOMQuadTag:
3171             return readDOMQuad();
3172         case ImageBitmapTransferTag:
<span class="line-modified">3173             return readTransferredImageBitmap();</span>
3174 #if ENABLE(WEB_RTC)
3175         case RTCCertificateTag:
3176             return readRTCCertificate();
3177 
<span class="line-added">3178 #endif</span>
<span class="line-added">3179         case ImageBitmapTag:</span>
<span class="line-added">3180             return readImageBitmap();</span>
<span class="line-added">3181 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3182         case OffscreenCanvasTransferTag:</span>
<span class="line-added">3183             return readOffscreenCanvas();</span>
3184 #endif
3185         default:
3186             m_ptr--; // Push the tag back
3187             return JSValue();
3188         }
3189     }
3190 
3191     template&lt;SerializationTag Tag&gt;
3192     bool consumeCollectionDataTerminationIfPossible()
3193     {
3194         if (readTag() == Tag)
3195             return true;
3196         m_ptr--;
3197         return false;
3198     }
3199 
3200     JSGlobalObject* m_globalObject;
3201     bool m_isDOMGlobalObject;
3202     const uint8_t* m_ptr;
3203     const uint8_t* m_end;
3204     unsigned m_version;
3205     Vector&lt;CachedString&gt; m_constantPool;
3206     const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; m_messagePorts;
3207     ArrayBufferContentsArray* m_arrayBufferContents;
3208     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; m_arrayBuffers;
3209     Vector&lt;String&gt; m_blobURLs;
3210     Vector&lt;String&gt; m_blobFilePaths;
3211     ArrayBufferContentsArray* m_sharedBuffers;
3212     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; m_imageBuffers;
3213     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; m_imageBitmaps;
<span class="line-added">3214 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3215     Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt; m_detachedOffscreenCanvases;</span>
<span class="line-added">3216     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; m_offscreenCanvases;</span>
<span class="line-added">3217 #endif</span>
3218 #if ENABLE(WEBASSEMBLY)
3219     WasmModuleArray* m_wasmModules;
3220 #endif
3221 
3222     String blobFilePathForBlobURL(const String&amp; blobURL)
3223     {
3224         size_t i = 0;
3225         for (; i &lt; m_blobURLs.size(); ++i) {
3226             if (m_blobURLs[i] == blobURL)
3227                 break;
3228         }
3229 
3230         return i &lt; m_blobURLs.size() ? m_blobFilePaths[i] : String();
3231     }
3232 };
3233 
3234 DeserializationResult CloneDeserializer::deserialize()
3235 {
<span class="line-modified">3236     VM&amp; vm = m_lexicalGlobalObject-&gt;vm();</span>
3237     auto scope = DECLARE_THROW_SCOPE(vm);
3238 
3239     Vector&lt;uint32_t, 16&gt; indexStack;
3240     Vector&lt;Identifier, 16&gt; propertyNameStack;
3241     Vector&lt;JSObject*, 32&gt; outputObjectStack;
3242     Vector&lt;JSValue, 4&gt; mapKeyStack;
3243     Vector&lt;JSMap*, 4&gt; mapStack;
3244     Vector&lt;JSSet*, 4&gt; setStack;
3245     Vector&lt;WalkerState, 16&gt; stateStack;
<span class="line-modified">3246     WalkerState lexicalGlobalObject = StateUnknown;</span>
3247     JSValue outValue;
3248 
3249     while (1) {
<span class="line-modified">3250         switch (lexicalGlobalObject) {</span>
3251         arrayStartState:
3252         case ArrayStartState: {
3253             uint32_t length;
3254             if (!read(length)) {
3255                 fail();
3256                 goto error;
3257             }
<span class="line-modified">3258             JSArray* outArray = constructEmptyArray(m_globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), length);</span>
3259             if (UNLIKELY(scope.exception()))
3260                 goto error;
3261             m_gcBuffer.appendWithCrashOnOverflow(outArray);
3262             outputObjectStack.append(outArray);
3263         }
3264         arrayStartVisitMember:
3265         FALLTHROUGH;
3266         case ArrayStartVisitMember: {
3267             uint32_t index;
3268             if (!read(index)) {
3269                 fail();
3270                 goto error;
3271             }
3272             if (index == TerminatorTag) {
3273                 JSObject* outArray = outputObjectStack.last();
3274                 outValue = outArray;
3275                 outputObjectStack.removeLast();
3276                 break;
3277             } else if (index == NonIndexPropertiesTag) {
3278                 goto objectStartVisitMember;
</pre>
<hr />
<pre>
3281             if (JSValue terminal = readTerminal()) {
3282                 putProperty(outputObjectStack.last(), index, terminal);
3283                 goto arrayStartVisitMember;
3284             }
3285             if (m_failed)
3286                 goto error;
3287             indexStack.append(index);
3288             stateStack.append(ArrayEndVisitMember);
3289             goto stateUnknown;
3290         }
3291         case ArrayEndVisitMember: {
3292             JSObject* outArray = outputObjectStack.last();
3293             putProperty(outArray, indexStack.last(), outValue);
3294             indexStack.removeLast();
3295             goto arrayStartVisitMember;
3296         }
3297         objectStartState:
3298         case ObjectStartState: {
3299             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3300                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">3301             JSObject* outObject = constructEmptyObject(m_lexicalGlobalObject, m_globalObject-&gt;objectPrototype());</span>
3302             m_gcBuffer.appendWithCrashOnOverflow(outObject);
3303             outputObjectStack.append(outObject);
3304         }
3305         objectStartVisitMember:
3306         FALLTHROUGH;
3307         case ObjectStartVisitMember: {
3308             CachedStringRef cachedString;
3309             bool wasTerminator = false;
3310             if (!readStringData(cachedString, wasTerminator)) {
3311                 if (!wasTerminator)
3312                     goto error;
3313 
3314                 JSObject* outObject = outputObjectStack.last();
3315                 outValue = outObject;
3316                 outputObjectStack.removeLast();
3317                 break;
3318             }
3319 
3320             if (JSValue terminal = readTerminal()) {
3321                 putProperty(outputObjectStack.last(), Identifier::fromString(vm, cachedString-&gt;string()), terminal);
3322                 goto objectStartVisitMember;
3323             }
3324             stateStack.append(ObjectEndVisitMember);
3325             propertyNameStack.append(Identifier::fromString(vm, cachedString-&gt;string()));
3326             goto stateUnknown;
3327         }
3328         case ObjectEndVisitMember: {
3329             putProperty(outputObjectStack.last(), propertyNameStack.last(), outValue);
3330             propertyNameStack.removeLast();
3331             goto objectStartVisitMember;
3332         }
3333         mapObjectStartState: {
3334             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3335                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">3336             JSMap* map = JSMap::create(m_lexicalGlobalObject, m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;mapStructure());</span>
3337             if (UNLIKELY(scope.exception()))
3338                 goto error;
3339             m_gcBuffer.appendWithCrashOnOverflow(map);
3340             outputObjectStack.append(map);
3341             mapStack.append(map);
3342             goto mapDataStartVisitEntry;
3343         }
3344         mapDataStartVisitEntry:
3345         case MapDataStartVisitEntry: {
3346             if (consumeCollectionDataTerminationIfPossible&lt;NonMapPropertiesTag&gt;()) {
3347                 mapStack.removeLast();
3348                 goto objectStartVisitMember;
3349             }
3350             stateStack.append(MapDataEndVisitKey);
3351             goto stateUnknown;
3352         }
3353         case MapDataEndVisitKey: {
3354             mapKeyStack.append(outValue);
3355             stateStack.append(MapDataEndVisitValue);
3356             goto stateUnknown;
3357         }
3358         case MapDataEndVisitValue: {
<span class="line-modified">3359             mapStack.last()-&gt;set(m_lexicalGlobalObject, mapKeyStack.last(), outValue);</span>
3360             mapKeyStack.removeLast();
3361             goto mapDataStartVisitEntry;
3362         }
3363 
3364         setObjectStartState: {
3365             if (outputObjectStack.size() &gt; maximumFilterRecursion)
3366                 return std::make_pair(JSValue(), SerializationReturnCode::StackOverflowError);
<span class="line-modified">3367             JSSet* set = JSSet::create(m_lexicalGlobalObject, m_lexicalGlobalObject-&gt;vm(), m_globalObject-&gt;setStructure());</span>
3368             if (UNLIKELY(scope.exception()))
3369                 goto error;
3370             m_gcBuffer.appendWithCrashOnOverflow(set);
3371             outputObjectStack.append(set);
3372             setStack.append(set);
3373             goto setDataStartVisitEntry;
3374         }
3375         setDataStartVisitEntry:
3376         case SetDataStartVisitEntry: {
3377             if (consumeCollectionDataTerminationIfPossible&lt;NonSetPropertiesTag&gt;()) {
3378                 setStack.removeLast();
3379                 goto objectStartVisitMember;
3380             }
3381             stateStack.append(SetDataEndVisitKey);
3382             goto stateUnknown;
3383         }
3384         case SetDataEndVisitKey: {
3385             JSSet* set = setStack.last();
<span class="line-modified">3386             set-&gt;add(m_lexicalGlobalObject, outValue);</span>
3387             goto setDataStartVisitEntry;
3388         }
3389 
3390         stateUnknown:
3391         case StateUnknown:
3392             if (JSValue terminal = readTerminal()) {
3393                 outValue = terminal;
3394                 break;
3395             }
3396             SerializationTag tag = readTag();
3397             if (tag == ArrayTag)
3398                 goto arrayStartState;
3399             if (tag == ObjectTag)
3400                 goto objectStartState;
3401             if (tag == MapObjectTag)
3402                 goto mapObjectStartState;
3403             if (tag == SetObjectTag)
3404                 goto setObjectStartState;
3405             goto error;
3406         }
3407         if (stateStack.isEmpty())
3408             break;
3409 
<span class="line-modified">3410         lexicalGlobalObject = stateStack.last();</span>
3411         stateStack.removeLast();
3412     }
3413     ASSERT(outValue);
3414     ASSERT(!m_failed);
3415     return std::make_pair(outValue, SerializationReturnCode::SuccessfullyCompleted);
3416 error:
3417     fail();
3418     return std::make_pair(JSValue(), SerializationReturnCode::ValidationError);
3419 }
3420 
3421 SerializedScriptValue::~SerializedScriptValue() = default;
3422 
3423 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer)
3424     : m_data(WTFMove(buffer))
3425 {
3426 }
3427 
3428 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray)
3429     : m_data(WTFMove(buffer))
3430     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3431 {
3432 }
3433 
3434 SerializedScriptValue::SerializedScriptValue(Vector&lt;uint8_t&gt;&amp;&amp; buffer, const Vector&lt;String&gt;&amp; blobURLs, std::unique_ptr&lt;ArrayBufferContentsArray&gt; arrayBufferContentsArray, std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBufferContentsArray, Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt;&amp;&amp; imageBuffers
<span class="line-added">3435 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3436         , Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt;&amp;&amp; detachedOffscreenCanvases</span>
<span class="line-added">3437 #endif</span>
3438 #if ENABLE(WEBASSEMBLY)
3439         , std::unique_ptr&lt;WasmModuleArray&gt; wasmModulesArray
3440 #endif
3441         )
3442     : m_data(WTFMove(buffer))
3443     , m_arrayBufferContentsArray(WTFMove(arrayBufferContentsArray))
3444     , m_sharedBufferContentsArray(WTFMove(sharedBufferContentsArray))
3445     , m_imageBuffers(WTFMove(imageBuffers))
<span class="line-added">3446 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3447     , m_detachedOffscreenCanvases(WTFMove(detachedOffscreenCanvases))</span>
<span class="line-added">3448 #endif</span>
3449 #if ENABLE(WEBASSEMBLY)
3450     , m_wasmModulesArray(WTFMove(wasmModulesArray))
3451 #endif
3452 {
3453     // Since this SerializedScriptValue is meant to be passed between threads, its String data members
3454     // need to be isolatedCopies so we don&#39;t run into thread safety issues for the StringImpls.
3455     m_blobURLs.reserveInitialCapacity(blobURLs.size());
3456     for (auto&amp; url : blobURLs)
3457         m_blobURLs.uncheckedAppend(url.isolatedCopy());
3458 }
3459 
3460 static ExceptionOr&lt;std::unique_ptr&lt;ArrayBufferContentsArray&gt;&gt; transferArrayBuffers(VM&amp; vm, const Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&amp; arrayBuffers)
3461 {
3462     if (arrayBuffers.isEmpty())
3463         return nullptr;
3464 
3465     auto contents = makeUnique&lt;ArrayBufferContentsArray&gt;(arrayBuffers.size());
3466 
3467     HashSet&lt;JSC::ArrayBuffer*&gt; visited;
3468     for (size_t arrayBufferIndex = 0; arrayBufferIndex &lt; arrayBuffers.size(); arrayBufferIndex++) {
3469         if (visited.contains(arrayBuffers[arrayBufferIndex].get()))
3470             continue;
3471         visited.add(arrayBuffers[arrayBufferIndex].get());
3472 
3473         bool result = arrayBuffers[arrayBufferIndex]-&gt;transferTo(vm, contents-&gt;at(arrayBufferIndex));
3474         if (!result)
3475             return Exception { TypeError };
3476     }
3477 
3478     return contents;
3479 }
3480 
<span class="line-modified">3481 static void maybeThrowExceptionIfSerializationFailed(JSGlobalObject&amp; lexicalGlobalObject, SerializationReturnCode code)</span>
3482 {
<span class="line-modified">3483     auto&amp; vm = lexicalGlobalObject.vm();</span>
3484     auto scope = DECLARE_THROW_SCOPE(vm);
3485 
3486     switch (code) {
3487     case SerializationReturnCode::SuccessfullyCompleted:
3488         break;
3489     case SerializationReturnCode::StackOverflowError:
<span class="line-modified">3490         throwException(&amp;lexicalGlobalObject, scope, createStackOverflowError(&amp;lexicalGlobalObject));</span>
3491         break;
3492     case SerializationReturnCode::ValidationError:
<span class="line-modified">3493         throwTypeError(&amp;lexicalGlobalObject, scope, &quot;Unable to deserialize data.&quot;_s);</span>
3494         break;
3495     case SerializationReturnCode::DataCloneError:
<span class="line-modified">3496         throwDataCloneError(lexicalGlobalObject, scope);</span>
3497         break;
3498     case SerializationReturnCode::ExistingExceptionError:
3499     case SerializationReturnCode::UnspecifiedError:
3500         break;
3501     case SerializationReturnCode::InterruptedExecutionError:
3502         ASSERT_NOT_REACHED();
3503     }
3504 }
3505 
3506 static Exception exceptionForSerializationFailure(SerializationReturnCode code)
3507 {
3508     ASSERT(code != SerializationReturnCode::SuccessfullyCompleted);
3509 
3510     switch (code) {
3511     case SerializationReturnCode::StackOverflowError:
3512         return Exception { StackOverflowError };
3513     case SerializationReturnCode::ValidationError:
3514         return Exception { TypeError };
3515     case SerializationReturnCode::DataCloneError:
3516         return Exception { DataCloneError };
3517     case SerializationReturnCode::ExistingExceptionError:
3518         return Exception { ExistingExceptionError };
3519     case SerializationReturnCode::UnspecifiedError:
3520         return Exception { TypeError };
3521     case SerializationReturnCode::SuccessfullyCompleted:
3522     case SerializationReturnCode::InterruptedExecutionError:
3523         ASSERT_NOT_REACHED();
3524         return Exception { TypeError };
3525     }
3526     ASSERT_NOT_REACHED();
3527     return Exception { TypeError };
3528 }
3529 
<span class="line-modified">3530 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, SerializationErrorMode throwExceptions)</span>
3531 {
3532     Vector&lt;uint8_t&gt; buffer;
3533     Vector&lt;String&gt; blobURLs;
3534     Vector&lt;RefPtr&lt;MessagePort&gt;&gt; dummyMessagePorts;
3535     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; dummyImageBitmaps;
<span class="line-added">3536 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3537     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; dummyOffscreenCanvases;</span>
<span class="line-added">3538 #endif</span>
3539     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; dummyArrayBuffers;
3540 #if ENABLE(WEBASSEMBLY)
3541     WasmModuleArray dummyModules;
3542 #endif
3543     ArrayBufferContentsArray dummySharedBuffers;
<span class="line-modified">3544     auto code = CloneSerializer::serialize(&amp;lexicalGlobalObject, value, dummyMessagePorts, dummyArrayBuffers, dummyImageBitmaps,</span>
<span class="line-added">3545 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3546         dummyOffscreenCanvases,</span>
<span class="line-added">3547 #endif</span>
3548 #if ENABLE(WEBASSEMBLY)
3549         dummyModules,
3550 #endif
3551         blobURLs, buffer, SerializationContext::Default, dummySharedBuffers);
3552 
3553 #if ENABLE(WEBASSEMBLY)
3554     ASSERT_WITH_MESSAGE(dummyModules.isEmpty(), &quot;Wasm::Module serialization is only allowed in the postMessage context&quot;);
3555 #endif
3556 
3557     if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">3558         maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, code);</span>
3559 
3560     if (code != SerializationReturnCode::SuccessfullyCompleted)
3561         return nullptr;
3562 
<span class="line-modified">3563     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, nullptr, nullptr, { }));</span>




3564 }
3565 
3566 static bool containsDuplicates(const Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp; imageBitmaps)
3567 {
3568     HashSet&lt;ImageBitmap*&gt; visited;
3569     for (auto&amp; imageBitmap : imageBitmaps) {
3570         if (!visited.add(imageBitmap.get()))
3571             return true;
3572     }
3573     return false;
3574 }
3575 
<span class="line-modified">3576 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3577 static bool canOffscreenCanvasesDetach(const Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt;&amp; offscreenCanvases)</span>
<span class="line-added">3578 {</span>
<span class="line-added">3579     HashSet&lt;OffscreenCanvas*&gt; visited;</span>
<span class="line-added">3580     for (auto&amp; offscreenCanvas : offscreenCanvases) {</span>
<span class="line-added">3581         if (!offscreenCanvas-&gt;canDetach())</span>
<span class="line-added">3582             return false;</span>
<span class="line-added">3583         // Check the return value of add, we should not encounter duplicates.</span>
<span class="line-added">3584         if (!visited.add(offscreenCanvas.get()))</span>
<span class="line-added">3585             return false;</span>
<span class="line-added">3586     }</span>
<span class="line-added">3587     return true;</span>
<span class="line-added">3588 }</span>
<span class="line-added">3589 #endif</span>
<span class="line-added">3590 </span>
<span class="line-added">3591 ExceptionOr&lt;Ref&lt;SerializedScriptValue&gt;&gt; SerializedScriptValue::create(JSGlobalObject&amp; lexicalGlobalObject, JSValue value, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transferList, Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationContext context)</span>
3592 {
<span class="line-modified">3593     VM&amp; vm = lexicalGlobalObject.vm();</span>
3594     Vector&lt;RefPtr&lt;JSC::ArrayBuffer&gt;&gt; arrayBuffers;
3595     Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt; imageBitmaps;
<span class="line-added">3596 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3597     Vector&lt;RefPtr&lt;OffscreenCanvas&gt;&gt; offscreenCanvases;</span>
<span class="line-added">3598 #endif</span>
3599     for (auto&amp; transferable : transferList) {
3600         if (auto arrayBuffer = toPossiblySharedArrayBuffer(vm, transferable.get())) {
3601             if (arrayBuffer-&gt;isNeutered())
3602                 return Exception { DataCloneError };
3603             if (arrayBuffer-&gt;isLocked()) {
3604                 auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">3605                 throwVMTypeError(&amp;lexicalGlobalObject, scope, errorMesasgeForTransfer(arrayBuffer));</span>
3606                 return Exception { ExistingExceptionError };
3607             }
3608             arrayBuffers.append(WTFMove(arrayBuffer));
3609             continue;
3610         }
3611         if (auto port = JSMessagePort::toWrapped(vm, transferable.get())) {
3612             // FIXME: This should check if the port is detached as per https://html.spec.whatwg.org/multipage/infrastructure.html#istransferable.
3613             messagePorts.append(WTFMove(port));
3614             continue;
3615         }
3616 
3617         if (auto imageBitmap = JSImageBitmap::toWrapped(vm, transferable.get())) {
3618             if (imageBitmap-&gt;isDetached())
3619                 return Exception { DataCloneError };
3620 
3621             imageBitmaps.append(WTFMove(imageBitmap));
3622             continue;
3623         }
3624 
<span class="line-added">3625 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3626         if (auto offscreenCanvas = JSOffscreenCanvas::toWrapped(vm, transferable.get())) {</span>
<span class="line-added">3627             offscreenCanvases.append(WTFMove(offscreenCanvas));</span>
<span class="line-added">3628             continue;</span>
<span class="line-added">3629         }</span>
<span class="line-added">3630 #endif</span>
<span class="line-added">3631 </span>
3632         return Exception { DataCloneError };
3633     }
3634 
3635     if (containsDuplicates(imageBitmaps))
3636         return Exception { DataCloneError };
<span class="line-added">3637 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3638     if (!canOffscreenCanvasesDetach(offscreenCanvases))</span>
<span class="line-added">3639         return Exception { InvalidStateError };</span>
<span class="line-added">3640 #endif</span>
3641 
3642     Vector&lt;uint8_t&gt; buffer;
3643     Vector&lt;String&gt; blobURLs;
3644 #if ENABLE(WEBASSEMBLY)
3645     WasmModuleArray wasmModules;
3646 #endif
3647     std::unique_ptr&lt;ArrayBufferContentsArray&gt; sharedBuffers = makeUnique&lt;ArrayBufferContentsArray&gt;();
<span class="line-modified">3648     auto code = CloneSerializer::serialize(&amp;lexicalGlobalObject, value, messagePorts, arrayBuffers, imageBitmaps,</span>
<span class="line-added">3649 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3650         offscreenCanvases,</span>
<span class="line-added">3651 #endif</span>
3652 #if ENABLE(WEBASSEMBLY)
3653         wasmModules,
3654 #endif
3655         blobURLs, buffer, context, *sharedBuffers);
3656 
3657     if (code != SerializationReturnCode::SuccessfullyCompleted)
3658         return exceptionForSerializationFailure(code);
3659 
3660     auto arrayBufferContentsArray = transferArrayBuffers(vm, arrayBuffers);
3661     if (arrayBufferContentsArray.hasException())
3662         return arrayBufferContentsArray.releaseException();
3663 
3664     auto imageBuffers = ImageBitmap::detachBitmaps(WTFMove(imageBitmaps));
3665 
<span class="line-added">3666 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3667     Vector&lt;std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&gt; detachedCanvases;</span>
<span class="line-added">3668     for (auto offscreenCanvas : offscreenCanvases)</span>
<span class="line-added">3669         detachedCanvases.append(offscreenCanvas-&gt;detach());</span>
<span class="line-added">3670 #endif</span>
<span class="line-added">3671 </span>
3672     return adoptRef(*new SerializedScriptValue(WTFMove(buffer), blobURLs, arrayBufferContentsArray.releaseReturnValue(), context == SerializationContext::WorkerPostMessage ? WTFMove(sharedBuffers) : nullptr, WTFMove(imageBuffers)
<span class="line-added">3673 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3674                 , WTFMove(detachedCanvases)</span>
<span class="line-added">3675 #endif</span>
3676 #if ENABLE(WEBASSEMBLY)
3677                 , makeUnique&lt;WasmModuleArray&gt;(wasmModules)
3678 #endif
3679                 ));
3680 }
3681 
3682 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(StringView string)
3683 {
3684     Vector&lt;uint8_t&gt; buffer;
3685     if (!CloneSerializer::serialize(string, buffer))
3686         return nullptr;
3687     return adoptRef(*new SerializedScriptValue(WTFMove(buffer)));
3688 }
3689 
3690 RefPtr&lt;SerializedScriptValue&gt; SerializedScriptValue::create(JSContextRef originContext, JSValueRef apiValue, JSValueRef* exception)
3691 {
<span class="line-modified">3692     JSGlobalObject* lexicalGlobalObject = toJS(originContext);</span>
<span class="line-modified">3693     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
3694     JSLockHolder locker(vm);
3695     auto scope = DECLARE_CATCH_SCOPE(vm);
3696 
<span class="line-modified">3697     JSValue value = toJS(lexicalGlobalObject, apiValue);</span>
<span class="line-modified">3698     auto serializedValue = SerializedScriptValue::create(*lexicalGlobalObject, value);</span>
3699     if (UNLIKELY(scope.exception())) {
3700         if (exception)
<span class="line-modified">3701             *exception = toRef(lexicalGlobalObject, scope.exception()-&gt;value());</span>
3702         scope.clearException();
3703         return nullptr;
3704     }
3705     ASSERT(serializedValue);
3706     return serializedValue;
3707 }
3708 
3709 String SerializedScriptValue::toString()
3710 {
3711     return CloneDeserializer::deserializeString(m_data);
3712 }
3713 
<span class="line-modified">3714 JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, SerializationErrorMode throwExceptions)</span>
3715 {
<span class="line-modified">3716     return deserialize(lexicalGlobalObject, globalObject, { }, throwExceptions);</span>
3717 }
3718 
<span class="line-modified">3719 JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, SerializationErrorMode throwExceptions)</span>
3720 {
3721     Vector&lt;String&gt; dummyBlobs;
3722     Vector&lt;String&gt; dummyPaths;
<span class="line-modified">3723     return deserialize(lexicalGlobalObject, globalObject, messagePorts, dummyBlobs, dummyPaths, throwExceptions);</span>
3724 }
3725 
<span class="line-modified">3726 JSValue SerializedScriptValue::deserialize(JSGlobalObject&amp; lexicalGlobalObject, JSGlobalObject* globalObject, const Vector&lt;RefPtr&lt;MessagePort&gt;&gt;&amp; messagePorts, const Vector&lt;String&gt;&amp; blobURLs, const Vector&lt;String&gt;&amp; blobFilePaths, SerializationErrorMode throwExceptions)</span>
3727 {
<span class="line-modified">3728     DeserializationResult result = CloneDeserializer::deserialize(&amp;lexicalGlobalObject, globalObject, messagePorts, WTFMove(m_imageBuffers)</span>
<span class="line-added">3729 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added">3730         , WTFMove(m_detachedOffscreenCanvases)</span>
<span class="line-added">3731 #endif</span>
<span class="line-added">3732         , m_arrayBufferContentsArray.get(), m_data, blobURLs, blobFilePaths, m_sharedBufferContentsArray.get()</span>
3733 #if ENABLE(WEBASSEMBLY)
3734         , m_wasmModulesArray.get()
3735 #endif
3736         );
3737     if (throwExceptions == SerializationErrorMode::Throwing)
<span class="line-modified">3738         maybeThrowExceptionIfSerializationFailed(lexicalGlobalObject, result.second);</span>
3739     return result.first ? result.first : jsNull();
3740 }
3741 
3742 JSValueRef SerializedScriptValue::deserialize(JSContextRef destinationContext, JSValueRef* exception)
3743 {
<span class="line-modified">3744     JSGlobalObject* lexicalGlobalObject = toJS(destinationContext);</span>
<span class="line-modified">3745     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
3746     JSLockHolder locker(vm);
3747     auto scope = DECLARE_CATCH_SCOPE(vm);
3748 
<span class="line-modified">3749     JSValue value = deserialize(*lexicalGlobalObject, lexicalGlobalObject);</span>
3750     if (UNLIKELY(scope.exception())) {
3751         if (exception)
<span class="line-modified">3752             *exception = toRef(lexicalGlobalObject, scope.exception()-&gt;value());</span>
3753         scope.clearException();
3754         return nullptr;
3755     }
3756     ASSERT(value);
<span class="line-modified">3757     return toRef(lexicalGlobalObject, value);</span>
3758 }
3759 
3760 Ref&lt;SerializedScriptValue&gt; SerializedScriptValue::nullValue()
3761 {
3762     return adoptRef(*new SerializedScriptValue(Vector&lt;uint8_t&gt;()));
3763 }
3764 
3765 uint32_t SerializedScriptValue::wireFormatVersion()
3766 {
3767     return CurrentVersion;
3768 }
3769 
3770 #if ENABLE(INDEXED_DATABASE)
3771 Vector&lt;String&gt; SerializedScriptValue::blobURLsIsolatedCopy() const
3772 {
3773     Vector&lt;String&gt; result;
3774     result.reserveInitialCapacity(m_blobURLs.size());
3775     for (auto&amp; url : m_blobURLs)
3776         result.uncheckedAppend(url.isolatedCopy());
3777 
3778     return result;
3779 }
3780 
<span class="line-modified">3781 void SerializedScriptValue::writeBlobsToDiskForIndexedDB(CompletionHandler&lt;void(IDBValue&amp;&amp;)&gt;&amp;&amp; completionHandler)</span>
3782 {
3783     ASSERT(isMainThread());
3784     ASSERT(hasBlobURLs());
3785 
<span class="line-modified">3786     blobRegistry().writeBlobsToTemporaryFiles(m_blobURLs, [completionHandler = WTFMove(completionHandler), this, protectedThis = makeRef(*this)] (auto&amp;&amp; blobFilePaths) mutable {</span>
3787         ASSERT(isMainThread());
3788 
3789         if (blobFilePaths.isEmpty()) {
3790             // We should have successfully written blobs to temporary files.
3791             // If we failed, then we can&#39;t successfully store this record.
3792             completionHandler({ });
3793             return;
3794         }
3795 
3796         ASSERT(m_blobURLs.size() == blobFilePaths.size());
3797 
3798         completionHandler({ *this, m_blobURLs, blobFilePaths });
3799     });
3800 }
3801 
<span class="line-modified">3802 IDBValue SerializedScriptValue::writeBlobsToDiskForIndexedDBSynchronously()</span>
3803 {
3804     ASSERT(!isMainThread());
3805 
3806     IDBValue value;
3807     Lock lock;
3808     Condition condition;
3809     lock.lock();
3810 
<span class="line-modified">3811     RunLoop::main().dispatch([this, conditionPtr = &amp;condition, valuePtr = &amp;value] {</span>
<span class="line-modified">3812         writeBlobsToDiskForIndexedDB([conditionPtr, valuePtr](IDBValue&amp;&amp; result) {</span>
3813             ASSERT(isMainThread());
3814             valuePtr-&gt;setAsIsolatedCopy(result);
3815 
3816             conditionPtr-&gt;notifyAll();
3817         });
3818     });
3819 
3820     condition.wait(lock);
3821 
3822     return value;
3823 }
3824 
3825 #endif // ENABLE(INDEXED_DATABASE)
3826 
3827 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ScriptWrappable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedScriptValue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
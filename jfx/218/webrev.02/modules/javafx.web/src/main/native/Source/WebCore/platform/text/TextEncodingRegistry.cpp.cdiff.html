<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TextEncoding.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextEncodingRegistry.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 42,10 ***</span>
<span class="line-new-header">--- 42,14 ---</span>
  #include &lt;wtf/Lock.h&gt;
  #include &lt;wtf/MainThread.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  
<span class="line-added">+ #if USE(JAVA_UNICODE)</span>
<span class="line-added">+ #include &quot;java/TextCodecJava.h&quot;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
  namespace WebCore {
  
  const size_t maxEncodingNameLength = 63;
  
  // Hash for all-ASCII strings that does case folding.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,44 ***</span>
  static void addToTextEncodingNameMap(const char* alias, const char* name)
  {
      ASSERT(strlen(alias) &lt;= maxEncodingNameLength);
      if (isUndesiredAlias(alias))
          return;
<span class="line-modified">!     const char* atomicName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">!     ASSERT(strcmp(alias, name) == 0 || atomicName);</span>
<span class="line-modified">!     if (!atomicName)</span>
<span class="line-modified">!         atomicName = name;</span>
  
<span class="line-modified">!     ASSERT_WITH_MESSAGE(!textEncodingNameMap-&gt;get(alias), &quot;Duplicate text encoding name %s for %s (previously registered as %s)&quot;, alias, atomicName, textEncodingNameMap-&gt;get(alias));</span>
  
<span class="line-modified">!     textEncodingNameMap-&gt;add(alias, atomicName);</span>
  }
  
  static void addToTextCodecMap(const char* name, NewTextCodecFunction&amp;&amp; function)
  {
<span class="line-modified">!     const char* atomicName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">!     ASSERT(atomicName);</span>
<span class="line-modified">!     textCodecMap-&gt;add(atomicName, WTFMove(function));</span>
  }
  
  static void pruneBlacklistedCodecs()
  {
      for (auto&amp; nameFromBlacklist : textEncodingNameBlacklist) {
<span class="line-modified">!         auto* atomicName = textEncodingNameMap-&gt;get(nameFromBlacklist);</span>
<span class="line-modified">!         if (!atomicName)</span>
              continue;
  
          Vector&lt;const char*&gt; names;
          for (auto&amp; entry : *textEncodingNameMap) {
<span class="line-modified">!             if (entry.value == atomicName)</span>
                  names.append(entry.key);
          }
  
          for (auto* name : names)
              textEncodingNameMap-&gt;remove(name);
  
<span class="line-modified">!         textCodecMap-&gt;remove(atomicName);</span>
      }
  }
  
  static void buildBaseTextCodecMaps(const std::lock_guard&lt;Lock&gt;&amp;)
  {
<span class="line-new-header">--- 120,44 ---</span>
  static void addToTextEncodingNameMap(const char* alias, const char* name)
  {
      ASSERT(strlen(alias) &lt;= maxEncodingNameLength);
      if (isUndesiredAlias(alias))
          return;
<span class="line-modified">!     const char* atomName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">!     ASSERT(!strcmp(alias, name) || atomName);</span>
<span class="line-modified">!     if (!atomName)</span>
<span class="line-modified">!         atomName = name;</span>
  
<span class="line-modified">!     ASSERT_WITH_MESSAGE(!textEncodingNameMap-&gt;get(alias), &quot;Duplicate text encoding name %s for %s (previously registered as %s)&quot;, alias, atomName, textEncodingNameMap-&gt;get(alias));</span>
  
<span class="line-modified">!     textEncodingNameMap-&gt;add(alias, atomName);</span>
  }
  
  static void addToTextCodecMap(const char* name, NewTextCodecFunction&amp;&amp; function)
  {
<span class="line-modified">!     const char* atomName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">!     ASSERT(atomName);</span>
<span class="line-modified">!     textCodecMap-&gt;add(atomName, WTFMove(function));</span>
  }
  
  static void pruneBlacklistedCodecs()
  {
      for (auto&amp; nameFromBlacklist : textEncodingNameBlacklist) {
<span class="line-modified">!         auto* atomName = textEncodingNameMap-&gt;get(nameFromBlacklist);</span>
<span class="line-modified">!         if (!atomName)</span>
              continue;
  
          Vector&lt;const char*&gt; names;
          for (auto&amp; entry : *textEncodingNameMap) {
<span class="line-modified">!             if (entry.value == atomName)</span>
                  names.append(entry.key);
          }
  
          for (auto* name : names)
              textEncodingNameMap-&gt;remove(name);
  
<span class="line-modified">!         textCodecMap-&gt;remove(atomName);</span>
      }
  }
  
  static void buildBaseTextCodecMaps(const std::lock_guard&lt;Lock&gt;&amp;)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,14 ***</span>
      TextCodecUserDefined::registerCodecs(addToTextCodecMap);
  }
  
  static void addEncodingName(HashSet&lt;const char*&gt;* set, const char* name)
  {
<span class="line-modified">!     // We must not use atomicCanonicalTextEncodingName() because this function is called in it.</span>
<span class="line-modified">!     const char* atomicName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">!     if (atomicName)</span>
<span class="line-modified">!         set-&gt;add(atomicName);</span>
  }
  
  static void buildQuirksSets()
  {
      // FIXME: Having isJapaneseEncoding() and shouldShowBackslashAsCurrencySymbolIn()
<span class="line-new-header">--- 180,14 ---</span>
      TextCodecUserDefined::registerCodecs(addToTextCodecMap);
  }
  
  static void addEncodingName(HashSet&lt;const char*&gt;* set, const char* name)
  {
<span class="line-modified">!     // We must not use atomCanonicalTextEncodingName() because this function is called in it.</span>
<span class="line-modified">!     const char* atomName = textEncodingNameMap-&gt;get(name);</span>
<span class="line-modified">!     if (atomName)</span>
<span class="line-modified">!         set-&gt;add(atomName);</span>
  }
  
  static void buildQuirksSets()
  {
      // FIXME: Having isJapaneseEncoding() and shouldShowBackslashAsCurrencySymbolIn()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,10 ***</span>
<span class="line-new-header">--- 239,15 ---</span>
      TextCodecReplacement::registerCodecs(addToTextCodecMap);
  
      TextCodecICU::registerEncodingNames(addToTextEncodingNameMap);
      TextCodecICU::registerCodecs(addToTextCodecMap);
  
<span class="line-added">+ #if USE(JAVA_UNICODE)</span>
<span class="line-added">+     TextCodecJava::registerEncodingNames(addToTextEncodingNameMap);</span>
<span class="line-added">+     TextCodecJava::registerCodecs(addToTextCodecMap);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      pruneBlacklistedCodecs();
      buildQuirksSets();
  }
  
  std::unique_ptr&lt;TextCodec&gt; newTextCodec(const TextEncoding&amp; encoding)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,52 ***</span>
      auto result = textCodecMap-&gt;find(encoding.name());
      ASSERT(result != textCodecMap-&gt;end());
      return result-&gt;value();
  }
  
<span class="line-modified">! const char* atomicCanonicalTextEncodingName(const char* name)</span>
  {
      if (!name || !name[0])
          return nullptr;
  
      std::lock_guard&lt;Lock&gt; lock(encodingRegistryMutex);
  
      if (!textEncodingNameMap)
          buildBaseTextCodecMaps(lock);
  
<span class="line-modified">!     if (const char* atomicName = textEncodingNameMap-&gt;get(name))</span>
<span class="line-modified">!         return atomicName;</span>
      if (didExtendTextCodecMaps)
          return nullptr;
  
      extendTextCodecMaps();
      didExtendTextCodecMaps = true;
      return textEncodingNameMap-&gt;get(name);
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt; static const char* atomicCanonicalTextEncodingName(const CharacterType* characters, size_t length)</span>
  {
      char buffer[maxEncodingNameLength + 1];
      size_t j = 0;
      for (size_t i = 0; i &lt; length; ++i) {
          if (j == maxEncodingNameLength)
              return nullptr;
          buffer[j++] = characters[i];
      }
      buffer[j] = 0;
<span class="line-modified">!     return atomicCanonicalTextEncodingName(buffer);</span>
  }
  
<span class="line-modified">! const char* atomicCanonicalTextEncodingName(const String&amp; alias)</span>
  {
      if (alias.isEmpty() || !alias.isAllASCII())
          return nullptr;
  
      if (alias.is8Bit())
<span class="line-modified">!         return atomicCanonicalTextEncodingName(alias.characters8(), alias.length());</span>
  
<span class="line-modified">!     return atomicCanonicalTextEncodingName(alias.characters16(), alias.length());</span>
  }
  
  bool noExtendedTextEncodingNameUsed()
  {
      // If the calling thread did not use extended encoding names, it is fine for it to use a stale false value.
<span class="line-new-header">--- 258,52 ---</span>
      auto result = textCodecMap-&gt;find(encoding.name());
      ASSERT(result != textCodecMap-&gt;end());
      return result-&gt;value();
  }
  
<span class="line-modified">! const char* atomCanonicalTextEncodingName(const char* name)</span>
  {
      if (!name || !name[0])
          return nullptr;
  
      std::lock_guard&lt;Lock&gt; lock(encodingRegistryMutex);
  
      if (!textEncodingNameMap)
          buildBaseTextCodecMaps(lock);
  
<span class="line-modified">!     if (const char* atomName = textEncodingNameMap-&gt;get(name))</span>
<span class="line-modified">!         return atomName;</span>
      if (didExtendTextCodecMaps)
          return nullptr;
  
      extendTextCodecMaps();
      didExtendTextCodecMaps = true;
      return textEncodingNameMap-&gt;get(name);
  }
  
<span class="line-modified">! template&lt;typename CharacterType&gt; static const char* atomCanonicalTextEncodingName(const CharacterType* characters, size_t length)</span>
  {
      char buffer[maxEncodingNameLength + 1];
      size_t j = 0;
      for (size_t i = 0; i &lt; length; ++i) {
          if (j == maxEncodingNameLength)
              return nullptr;
          buffer[j++] = characters[i];
      }
      buffer[j] = 0;
<span class="line-modified">!     return atomCanonicalTextEncodingName(buffer);</span>
  }
  
<span class="line-modified">! const char* atomCanonicalTextEncodingName(const String&amp; alias)</span>
  {
      if (alias.isEmpty() || !alias.isAllASCII())
          return nullptr;
  
      if (alias.is8Bit())
<span class="line-modified">!         return atomCanonicalTextEncodingName(alias.characters8(), alias.length());</span>
  
<span class="line-modified">!     return atomCanonicalTextEncodingName(alias.characters16(), alias.length());</span>
  }
  
  bool noExtendedTextEncodingNameUsed()
  {
      // If the calling thread did not use extended encoding names, it is fine for it to use a stale false value.
</pre>
<center><a href="TextEncoding.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TextEncodingRegistry.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
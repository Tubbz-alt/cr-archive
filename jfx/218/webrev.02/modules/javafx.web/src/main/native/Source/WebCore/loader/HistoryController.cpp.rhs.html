<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/HistoryController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1.  Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  * 2.  Redistributions in binary form must reproduce the above copyright
 13  *     notice, this list of conditions and the following disclaimer in the
 14  *     documentation and/or other materials provided with the distribution.
 15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 16  *     its contributors may be used to endorse or promote products derived
 17  *     from this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;HistoryController.h&quot;
 33 
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &quot;BackForwardCache.h&quot;</span>
 35 #include &quot;BackForwardController.h&quot;
 36 #include &quot;CachedPage.h&quot;
 37 #include &quot;Document.h&quot;
 38 #include &quot;DocumentLoader.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;FrameLoader.h&quot;
 41 #include &quot;FrameLoaderClient.h&quot;
 42 #include &quot;FrameLoaderStateMachine.h&quot;
 43 #include &quot;FrameTree.h&quot;
 44 #include &quot;FrameView.h&quot;
 45 #include &quot;HistoryItem.h&quot;
 46 #include &quot;Logging.h&quot;
 47 #include &quot;Page.h&quot;
<a name="2" id="anc2"></a>
 48 #include &quot;ScrollingCoordinator.h&quot;
 49 #include &quot;SerializedScriptValue.h&quot;
 50 #include &quot;SharedStringHash.h&quot;
 51 #include &quot;ShouldTreatAsContinuingLoad.h&quot;
 52 #include &quot;VisitedLinkStore.h&quot;
 53 #include &lt;wtf/text/CString.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 static inline void addVisitedLink(Page&amp; page, const URL&amp; url)
 58 {
 59     page.visitedLinkStore().addVisitedLink(page, computeSharedStringHash(url.string()));
 60 }
 61 
 62 HistoryController::HistoryController(Frame&amp; frame)
 63     : m_frame(frame)
 64     , m_frameLoadComplete(true)
 65     , m_defersLoading(false)
 66 {
 67 }
 68 
 69 HistoryController::~HistoryController() = default;
 70 
 71 void HistoryController::saveScrollPositionAndViewStateToItem(HistoryItem* item)
 72 {
 73     FrameView* frameView = m_frame.view();
 74     if (!item || !frameView)
 75         return;
 76 
<a name="3" id="anc3"></a><span class="line-modified"> 77     if (m_frame.document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache)</span>
 78         item-&gt;setScrollPosition(frameView-&gt;cachedScrollPosition());
 79     else
 80         item-&gt;setScrollPosition(frameView-&gt;scrollPosition());
 81 
 82 #if PLATFORM(IOS_FAMILY)
 83     item-&gt;setExposedContentRect(frameView-&gt;exposedContentRect());
 84     item-&gt;setUnobscuredContentRect(frameView-&gt;unobscuredContentRect());
 85 #endif
 86 
 87     Page* page = m_frame.page();
 88     if (page &amp;&amp; m_frame.isMainFrame()) {
 89         item-&gt;setPageScaleFactor(page-&gt;pageScaleFactor() / page-&gt;viewScaleFactor());
 90 #if PLATFORM(IOS_FAMILY)
 91         item-&gt;setObscuredInsets(page-&gt;obscuredInsets());
 92 #endif
 93     }
 94 
 95     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling through to the client.
 96     m_frame.loader().client().saveViewStateToItem(*item);
 97 
 98     // Notify clients that the HistoryItem has changed.
 99     item-&gt;notifyChanged();
100 }
101 
102 void HistoryController::clearScrollPositionAndViewState()
103 {
104     if (!m_currentItem)
105         return;
106 
107     m_currentItem-&gt;clearScrollPosition();
108     m_currentItem-&gt;setPageScaleFactor(0);
109 }
110 
111 /*
112  There is a race condition between the layout and load completion that affects restoring the scroll position.
113  We try to restore the scroll position at both the first layout and upon load completion.
114 
115  1) If first layout happens before the load completes, we want to restore the scroll position then so that the
116  first time we draw the page is already scrolled to the right place, instead of starting at the top and later
117  jumping down.  It is possible that the old scroll position is past the part of the doc laid out so far, in
118  which case the restore silent fails and we will fix it in when we try to restore on doc completion.
119  2) If the layout happens after the load completes, the attempt to restore at load completion time silently
120  fails.  We then successfully restore it when the layout happens.
121 */
122 void HistoryController::restoreScrollPositionAndViewState()
123 {
124     if (!m_frame.loader().stateMachine().committedFirstRealDocumentLoad())
125         return;
126 
127     ASSERT(m_currentItem);
128 
129     // FIXME: As the ASSERT attests, it seems we should always have a currentItem here.
130     // One counterexample is &lt;rdar://problem/4917290&gt;
131     // For now, to cover this issue in release builds, there is no technical harm to returning
132     // early and from a user standpoint - as in the above radar - the previous page load failed
133     // so there *is* no scroll or view state to restore!
134     if (!m_currentItem)
135         return;
136 
137     auto view = makeRefPtr(m_frame.view());
138 
139     // FIXME: There is some scrolling related work that needs to happen whenever a page goes into the
<a name="4" id="anc4"></a><span class="line-modified">140     // back/forward cache and similar work that needs to occur when it comes out. This is where we do the work</span>
141     // that needs to happen when we exit, and the work that needs to happen when we enter is in
<a name="5" id="anc5"></a><span class="line-modified">142     // Document::setIsInBackForwardCache(bool). It would be nice if there was more symmetry in these spots.</span>
143     // https://bugs.webkit.org/show_bug.cgi?id=98698
144     if (view) {
145         Page* page = m_frame.page();
146         if (page &amp;&amp; m_frame.isMainFrame()) {
147             if (ScrollingCoordinator* scrollingCoordinator = page-&gt;scrollingCoordinator())
148                 scrollingCoordinator-&gt;frameViewRootLayerDidChange(*view);
149         }
150     }
151 
152     // FIXME: It would be great to work out a way to put this code in WebCore instead of calling
153     // through to the client.
154     m_frame.loader().client().restoreViewState();
155 
156 #if !PLATFORM(IOS_FAMILY)
157     // Don&#39;t restore scroll point on iOS as FrameLoaderClient::restoreViewState() does that.
158     if (view &amp;&amp; !view-&gt;wasScrolledByUser()) {
159         view-&gt;scrollToFocusedElementImmediatelyIfNeeded();
160 
161         Page* page = m_frame.page();
162         auto desiredScrollPosition = m_currentItem-&gt;shouldRestoreScrollPosition() ? m_currentItem-&gt;scrollPosition() : view-&gt;scrollPosition();
163         LOG(Scrolling, &quot;HistoryController::restoreScrollPositionAndViewState scrolling to %d,%d&quot;, desiredScrollPosition.x(), desiredScrollPosition.y());
164         if (page &amp;&amp; m_frame.isMainFrame() &amp;&amp; m_currentItem-&gt;pageScaleFactor())
165             page-&gt;setPageScaleFactor(m_currentItem-&gt;pageScaleFactor() * page-&gt;viewScaleFactor(), desiredScrollPosition);
166         else
167             view-&gt;setScrollPosition(desiredScrollPosition);
168 
169         // If the scroll position doesn&#39;t have to be clamped, consider it successfully restored.
170         if (m_frame.isMainFrame()) {
171             auto adjustedDesiredScrollPosition = view-&gt;adjustScrollPositionWithinRange(desiredScrollPosition);
172             if (desiredScrollPosition == adjustedDesiredScrollPosition)
173                 m_frame.loader().client().didRestoreScrollPosition();
174         }
175 
176     }
177 #endif
178 }
179 
180 void HistoryController::updateBackForwardListForFragmentScroll()
181 {
182     updateBackForwardListClippedAtTarget(false);
183 }
184 
185 void HistoryController::saveDocumentState()
186 {
187     // FIXME: Reading this bit of FrameLoader state here is unfortunate.  I need to study
188     // this more to see if we can remove this dependency.
189     if (m_frame.loader().stateMachine().creatingInitialEmptyDocument())
190         return;
191 
192     // For a standard page load, we will have a previous item set, which will be used to
193     // store the form state.  However, in some cases we will have no previous item, and
194     // the current item is the right place to save the state.  One example is when we
195     // detach a bunch of frames because we are navigating from a site with frames to
196     // another site.  Another is when saving the frame state of a frame that is not the
197     // target of the current navigation (if we even decide to save with that granularity).
198 
199     // Because of previousItem&#39;s &quot;masking&quot; of currentItem for this purpose, it&#39;s important
200     // that we keep track of the end of a page transition with m_frameLoadComplete.  We
201     // leverage the checkLoadComplete recursion to achieve this goal.
202 
203     HistoryItem* item = m_frameLoadComplete ? m_currentItem.get() : m_previousItem.get();
204     if (!item)
205         return;
206 
207     ASSERT(m_frame.document());
208     Document&amp; document = *m_frame.document();
209     if (item-&gt;isCurrentDocument(document) &amp;&amp; document.hasLivingRenderTree()) {
210         if (DocumentLoader* documentLoader = document.loader())
211             item-&gt;setShouldOpenExternalURLsPolicy(documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
212 
213         LOG(Loading, &quot;WebCoreLoading %s: saving form state to %p&quot;, m_frame.tree().uniqueName().string().utf8().data(), item);
214         item-&gt;setDocumentState(document.formElementsState());
215     }
216 }
217 
218 // Walk the frame tree, telling all frames to save their form state into their current
219 // history item.
220 void HistoryController::saveDocumentAndScrollState()
221 {
222     for (Frame* frame = &amp;m_frame; frame; frame = frame-&gt;tree().traverseNext(&amp;m_frame)) {
223         frame-&gt;loader().history().saveDocumentState();
224         frame-&gt;loader().history().saveScrollPositionAndViewStateToItem(frame-&gt;loader().history().currentItem());
225     }
226 }
227 
228 void HistoryController::restoreDocumentState()
229 {
230     switch (m_frame.loader().loadType()) {
231     case FrameLoadType::Reload:
232     case FrameLoadType::ReloadFromOrigin:
233     case FrameLoadType::ReloadExpiredOnly:
234     case FrameLoadType::Same:
235     case FrameLoadType::Replace:
236         // Not restoring the document state.
237         return;
238     case FrameLoadType::Back:
239     case FrameLoadType::Forward:
240     case FrameLoadType::IndexedBackForward:
241     case FrameLoadType::RedirectWithLockedBackForwardList:
242     case FrameLoadType::Standard:
243         break;
244     }
245 
246     if (!m_currentItem)
247         return;
248     if (m_frame.loader().requestedHistoryItem() != m_currentItem.get())
249         return;
250     if (m_frame.loader().documentLoader()-&gt;isClientRedirect())
251         return;
252 
253     m_frame.loader().documentLoader()-&gt;setShouldOpenExternalURLsPolicy(m_currentItem-&gt;shouldOpenExternalURLsPolicy());
254 
255     LOG(Loading, &quot;WebCoreLoading %s: restoring form state from %p&quot;, m_frame.tree().uniqueName().string().utf8().data(), m_currentItem.get());
256     m_frame.document()-&gt;setStateForNewFormElements(m_currentItem-&gt;documentState());
257 }
258 
259 void HistoryController::invalidateCurrentItemCachedPage()
260 {
261     if (!currentItem())
262         return;
263 
<a name="6" id="anc6"></a><span class="line-modified">264     // When we are pre-commit, the currentItem is where any back/forward cache data resides.</span>
<span class="line-modified">265     std::unique_ptr&lt;CachedPage&gt; cachedPage = BackForwardCache::singleton().take(*currentItem(), m_frame.page());</span>
266     if (!cachedPage)
267         return;
268 
269     // FIXME: This is a grotesque hack to fix &lt;rdar://problem/4059059&gt; Crash in RenderFlow::detach
270     // Somehow the PageState object is not properly updated, and is holding onto a stale document.
271     // Both Xcode and FileMaker see this crash, Safari does not.
272 
273     ASSERT(cachedPage-&gt;document() == m_frame.document());
274     if (cachedPage-&gt;document() == m_frame.document()) {
<a name="7" id="anc7"></a><span class="line-modified">275         cachedPage-&gt;document()-&gt;setBackForwardCacheState(Document::NotInBackForwardCache);</span>
276         cachedPage-&gt;clear();
277     }
278 }
279 
280 bool HistoryController::shouldStopLoadingForHistoryItem(HistoryItem&amp; targetItem) const
281 {
282     if (!m_currentItem)
283         return false;
284 
285     // Don&#39;t abort the current load if we&#39;re navigating within the current document.
286     if (m_currentItem-&gt;shouldDoSameDocumentNavigationTo(targetItem))
287         return false;
288 
289     return true;
290 }
291 
292 // Main funnel for navigating to a previous location (back/forward, non-search snap-back)
293 // This includes recursion to handle loading into framesets properly
294 void HistoryController::goToItem(HistoryItem&amp; targetItem, FrameLoadType type, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
295 {
296     LOG(History, &quot;HistoryController %p goToItem %p type=%d&quot;, this, &amp;targetItem, static_cast&lt;int&gt;(type));
297 
298     ASSERT(!m_frame.tree().parent());
299 
300     // shouldGoToHistoryItem is a private delegate method. This is needed to fix:
301     // &lt;rdar://problem/3951283&gt; can view pages from the back/forward cache that should be disallowed by Parental Controls
302     // Ultimately, history item navigations should go through the policy delegate. That&#39;s covered in:
303     // &lt;rdar://problem/3979539&gt; back/forward cache navigations should consult policy delegate
304     Page* page = m_frame.page();
305     if (!page)
306         return;
307     if (!m_frame.loader().client().shouldGoToHistoryItem(targetItem))
308         return;
309     if (m_defersLoading) {
310         m_deferredItem = &amp;targetItem;
311         m_deferredFrameLoadType = type;
312         return;
313     }
314 
315     // Set the BF cursor before commit, which lets the user quickly click back/forward again.
316     // - plus, it only makes sense for the top level of the operation through the frame tree,
317     // as opposed to happening for some/one of the page commits that might happen soon
318     RefPtr&lt;HistoryItem&gt; currentItem = page-&gt;backForward().currentItem();
319     page-&gt;backForward().setCurrentItem(targetItem);
320 
321     // First set the provisional item of any frames that are not actually navigating.
322     // This must be done before trying to navigate the desired frame, because some
323     // navigations can commit immediately (such as about:blank).  We must be sure that
324     // all frames have provisional items set before the commit.
325     recursiveSetProvisionalItem(targetItem, currentItem.get());
326 
327     // Now that all other frames have provisional items, do the actual navigation.
328     recursiveGoToItem(targetItem, currentItem.get(), type, shouldTreatAsContinuingLoad);
329 }
330 
331 void HistoryController::setDefersLoading(bool defer)
332 {
333     m_defersLoading = defer;
334     if (!defer &amp;&amp; m_deferredItem) {
335         goToItem(*m_deferredItem, m_deferredFrameLoadType, ShouldTreatAsContinuingLoad::No);
336         m_deferredItem = nullptr;
337     }
338 }
339 
340 void HistoryController::updateForBackForwardNavigation()
341 {
342     LOG(History, &quot;HistoryController %p updateForBackForwardNavigation: Updating History for back/forward navigation in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
343 
344     // Must grab the current scroll position before disturbing it
345     if (!m_frameLoadComplete)
346         saveScrollPositionAndViewStateToItem(m_previousItem.get());
347 
348     // When traversing history, we may end up redirecting to a different URL
349     // this time (e.g., due to cookies).  See http://webkit.org/b/49654.
350     updateCurrentItem();
351 }
352 
353 void HistoryController::updateForReload()
354 {
355     LOG(History, &quot;HistoryController %p updateForReload: Updating History for reload in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
356 
357     if (m_currentItem) {
<a name="8" id="anc8"></a><span class="line-modified">358         BackForwardCache::singleton().remove(*m_currentItem);</span>
359 
360         if (m_frame.loader().loadType() == FrameLoadType::Reload || m_frame.loader().loadType() == FrameLoadType::ReloadFromOrigin)
361             saveScrollPositionAndViewStateToItem(m_currentItem.get());
362 
363         // Rebuild the history item tree when reloading as trying to re-associate everything is too error-prone.
364         m_currentItem-&gt;clearChildren();
365     }
366 
367     // When reloading the page, we may end up redirecting to a different URL
368     // this time (e.g., due to cookies).  See http://webkit.org/b/4072.
369     updateCurrentItem();
370 }
371 
372 // There are 3 things you might think of as &quot;history&quot;, all of which are handled by these functions.
373 //
374 //     1) Back/forward: The m_currentItem is part of this mechanism.
375 //     2) Global history: Handled by the client.
376 //     3) Visited links: Handled by the PageGroup.
377 
378 void HistoryController::updateForStandardLoad(HistoryUpdateType updateType)
379 {
380     LOG(History, &quot;HistoryController %p updateForStandardLoad: Updating History for standard load in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader()-&gt;url().string().ascii().data());
381 
382     FrameLoader&amp; frameLoader = m_frame.loader();
383 
<a name="9" id="anc9"></a><span class="line-modified">384     bool usesEphemeralSession = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
385     const URL&amp; historyURL = frameLoader.documentLoader()-&gt;urlForHistory();
386 
387     if (!frameLoader.documentLoader()-&gt;isClientRedirect()) {
388         if (!historyURL.isEmpty()) {
389             if (updateType != UpdateAllExceptBackForwardList)
390                 updateBackForwardListClippedAtTarget(true);
<a name="10" id="anc10"></a><span class="line-modified">391             if (!usesEphemeralSession) {</span>
392                 frameLoader.client().updateGlobalHistory();
393                 frameLoader.documentLoader()-&gt;setDidCreateGlobalHistoryEntry(true);
394                 if (frameLoader.documentLoader()-&gt;unreachableURL().isEmpty())
395                     frameLoader.client().updateGlobalHistoryRedirectLinks();
396             }
397         }
398     } else {
399         // The client redirect replaces the current history item.
400         updateCurrentItem();
401     }
402 
<a name="11" id="anc11"></a><span class="line-modified">403     if (!historyURL.isEmpty() &amp;&amp; !usesEphemeralSession) {</span>
404         if (Page* page = m_frame.page())
405             addVisitedLink(*page, historyURL);
406 
407         if (!frameLoader.documentLoader()-&gt;didCreateGlobalHistoryEntry() &amp;&amp; frameLoader.documentLoader()-&gt;unreachableURL().isEmpty() &amp;&amp; !m_frame.document()-&gt;url().isEmpty())
408             frameLoader.client().updateGlobalHistoryRedirectLinks();
409     }
410 }
411 
412 void HistoryController::updateForRedirectWithLockedBackForwardList()
413 {
414     LOG(History, &quot;HistoryController %p updateForRedirectWithLockedBackForwardList: Updating History for redirect load in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
415 
<a name="12" id="anc12"></a><span class="line-modified">416     bool usesEphemeralSession = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
417     const URL&amp; historyURL = m_frame.loader().documentLoader()-&gt;urlForHistory();
418 
419     if (m_frame.loader().documentLoader()-&gt;isClientRedirect()) {
420         if (!m_currentItem &amp;&amp; !m_frame.tree().parent()) {
421             if (!historyURL.isEmpty()) {
422                 updateBackForwardListClippedAtTarget(true);
<a name="13" id="anc13"></a><span class="line-modified">423                 if (!usesEphemeralSession) {</span>
424                     m_frame.loader().client().updateGlobalHistory();
425                     m_frame.loader().documentLoader()-&gt;setDidCreateGlobalHistoryEntry(true);
426                     if (m_frame.loader().documentLoader()-&gt;unreachableURL().isEmpty())
427                         m_frame.loader().client().updateGlobalHistoryRedirectLinks();
428                 }
429             }
430         }
431         // The client redirect replaces the current history item.
432         updateCurrentItem();
433     } else {
434         Frame* parentFrame = m_frame.tree().parent();
435         if (parentFrame &amp;&amp; parentFrame-&gt;loader().history().currentItem())
436             parentFrame-&gt;loader().history().currentItem()-&gt;setChildItem(createItem());
437     }
438 
<a name="14" id="anc14"></a><span class="line-modified">439     if (!historyURL.isEmpty() &amp;&amp; !usesEphemeralSession) {</span>
440         if (Page* page = m_frame.page())
441             addVisitedLink(*page, historyURL);
442 
443         if (!m_frame.loader().documentLoader()-&gt;didCreateGlobalHistoryEntry() &amp;&amp; m_frame.loader().documentLoader()-&gt;unreachableURL().isEmpty())
444             m_frame.loader().client().updateGlobalHistoryRedirectLinks();
445     }
446 }
447 
448 void HistoryController::updateForClientRedirect()
449 {
450     LOG(History, &quot;HistoryController %p updateForClientRedirect: Updating History for client redirect in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
451 
452     // Clear out form data so we don&#39;t try to restore it into the incoming page.  Must happen after
453     // webcore has closed the URL and saved away the form state.
454     if (m_currentItem) {
455         m_currentItem-&gt;clearDocumentState();
456         m_currentItem-&gt;clearScrollPosition();
457     }
458 
<a name="15" id="anc15"></a><span class="line-modified">459     bool usesEphemeralSession = m_frame.page() ? m_frame.page()-&gt;usesEphemeralSession() : true;</span>
460     const URL&amp; historyURL = m_frame.loader().documentLoader()-&gt;urlForHistory();
461 
<a name="16" id="anc16"></a><span class="line-modified">462     if (!historyURL.isEmpty() &amp;&amp; !usesEphemeralSession) {</span>
463         if (Page* page = m_frame.page())
464             addVisitedLink(*page, historyURL);
465     }
466 }
467 
468 void HistoryController::updateForCommit()
469 {
470     FrameLoader&amp; frameLoader = m_frame.loader();
471     LOG(History, &quot;HistoryController %p updateForCommit: Updating History for commit in frame %p (main frame %d) %s&quot;, this, &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader() ? m_frame.loader().documentLoader()-&gt;url().string().utf8().data() : &quot;&quot;);
472 
473     FrameLoadType type = frameLoader.loadType();
474     if (isBackForwardLoadType(type)
475         || isReplaceLoadTypeWithProvisionalItem(type)
476         || (isReloadTypeWithProvisionalItem(type) &amp;&amp; !frameLoader.provisionalDocumentLoader()-&gt;unreachableURL().isEmpty())) {
477         // Once committed, we want to use current item for saving DocState, and
478         // the provisional item for restoring state.
479         // Note previousItem must be set before we close the URL, which will
480         // happen when the data source is made non-provisional below
481 
482         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=146842
483         // We should always have a provisional item when committing, but we sometimes don&#39;t.
484         // Not having one leads to us not having a m_currentItem later, which is also a terrible known issue.
485         // We should get to the bottom of this.
486         ASSERT(m_provisionalItem);
487         if (m_provisionalItem)
488             setCurrentItem(*m_provisionalItem.get());
489         m_provisionalItem = nullptr;
490 
491         // Tell all other frames in the tree to commit their provisional items and
492         // restore their scroll position.  We&#39;ll avoid this frame (which has already
493         // committed) and its children (which will be replaced).
494         m_frame.mainFrame().loader().history().recursiveUpdateForCommit();
495     }
496 }
497 
498 bool HistoryController::isReplaceLoadTypeWithProvisionalItem(FrameLoadType type)
499 {
500     // Going back to an error page in a subframe can trigger a FrameLoadType::Replace
501     // while m_provisionalItem is set, so we need to commit it.
502     return type == FrameLoadType::Replace &amp;&amp; m_provisionalItem;
503 }
504 
505 bool HistoryController::isReloadTypeWithProvisionalItem(FrameLoadType type)
506 {
507     return (type == FrameLoadType::Reload || type == FrameLoadType::ReloadFromOrigin) &amp;&amp; m_provisionalItem;
508 }
509 
510 void HistoryController::recursiveUpdateForCommit()
511 {
512     // The frame that navigated will now have a null provisional item.
513     // Ignore it and its children.
514     if (!m_provisionalItem)
515         return;
516 
517     // For each frame that already had the content the item requested (based on
518     // (a matching URL and frame tree snapshot), just restore the scroll position.
519     // Save form state (works from currentItem, since m_frameLoadComplete is true)
520     if (m_currentItem &amp;&amp; itemsAreClones(*m_currentItem, m_provisionalItem.get())) {
521         ASSERT(m_frameLoadComplete);
522         saveDocumentState();
523         saveScrollPositionAndViewStateToItem(m_currentItem.get());
524 
525         if (FrameView* view = m_frame.view())
526             view-&gt;setWasScrolledByUser(false);
527 
528         // Now commit the provisional item
529         if (m_provisionalItem)
530             setCurrentItem(*m_provisionalItem.get());
531         m_provisionalItem = nullptr;
532 
533         // Restore form state (works from currentItem)
534         restoreDocumentState();
535 
536         // Restore the scroll position (we choose to do this rather than going back to the anchor point)
537         restoreScrollPositionAndViewState();
538     }
539 
540     // Iterate over the rest of the tree
541     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
542         child-&gt;loader().history().recursiveUpdateForCommit();
543 }
544 
545 void HistoryController::updateForSameDocumentNavigation()
546 {
547     if (m_frame.document()-&gt;url().isEmpty())
548         return;
549 
550     Page* page = m_frame.page();
551     if (!page)
552         return;
553 
<a name="17" id="anc17"></a><span class="line-modified">554     bool usesEphemeralSession = page-&gt;usesEphemeralSession();</span>
<span class="line-modified">555     if (!usesEphemeralSession)</span>
<span class="line-added">556         addVisitedLink(*page, m_frame.document()-&gt;url());</span>
557 
<a name="18" id="anc18"></a>
558     m_frame.mainFrame().loader().history().recursiveUpdateForSameDocumentNavigation();
559 
560     if (m_currentItem) {
561         m_currentItem-&gt;setURL(m_frame.document()-&gt;url());
<a name="19" id="anc19"></a><span class="line-modified">562         if (!usesEphemeralSession)</span>
<span class="line-added">563             m_frame.loader().client().updateGlobalHistory();</span>
564     }
565 }
566 
567 void HistoryController::recursiveUpdateForSameDocumentNavigation()
568 {
569     // The frame that navigated will now have a null provisional item.
570     // Ignore it and its children.
571     if (!m_provisionalItem)
572         return;
573 
574     // The provisional item may represent a different pending navigation.
575     // Don&#39;t commit it if it isn&#39;t a same document navigation.
576     if (m_currentItem &amp;&amp; !m_currentItem-&gt;shouldDoSameDocumentNavigationTo(*m_provisionalItem))
577         return;
578 
579     // Commit the provisional item.
580     if (m_provisionalItem)
581         setCurrentItem(*m_provisionalItem.get());
582     m_provisionalItem = nullptr;
583 
584     // Iterate over the rest of the tree.
585     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
586         child-&gt;loader().history().recursiveUpdateForSameDocumentNavigation();
587 }
588 
589 void HistoryController::updateForFrameLoadCompleted()
590 {
591     // Even if already complete, we might have set a previous item on a frame that
592     // didn&#39;t do any data loading on the past transaction. Make sure to track that
593     // the load is complete so that we use the current item instead.
594     m_frameLoadComplete = true;
595 }
596 
597 void HistoryController::setCurrentItem(HistoryItem&amp; item)
598 {
599     m_frameLoadComplete = false;
600     m_previousItem = m_currentItem;
601     m_currentItem = &amp;item;
602 }
603 
604 void HistoryController::setCurrentItemTitle(const StringWithDirection&amp; title)
605 {
606     // FIXME: This ignores the title&#39;s direction.
607     if (m_currentItem)
608         m_currentItem-&gt;setTitle(title.string);
609 }
610 
611 bool HistoryController::currentItemShouldBeReplaced() const
612 {
613     // From the HTML5 spec for location.assign():
614     //  &quot;If the browsing context&#39;s session history contains only one Document,
615     //   and that was the about:blank Document created when the browsing context
616     //   was created, then the navigation must be done with replacement enabled.&quot;
617     return m_currentItem &amp;&amp; !m_previousItem &amp;&amp; equalIgnoringASCIICase(m_currentItem-&gt;urlString(), WTF::blankURL());
618 }
619 
620 void HistoryController::clearPreviousItem()
621 {
622     m_previousItem = nullptr;
623     for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling())
624         child-&gt;loader().history().clearPreviousItem();
625 }
626 
627 void HistoryController::setProvisionalItem(HistoryItem* item)
628 {
629     m_provisionalItem = item;
630 }
631 
632 void HistoryController::initializeItem(HistoryItem&amp; item)
633 {
634     DocumentLoader* documentLoader = m_frame.loader().documentLoader();
635     ASSERT(documentLoader);
636 
637     URL unreachableURL = documentLoader-&gt;unreachableURL();
638 
639     URL url;
640     URL originalURL;
641 
642     if (!unreachableURL.isEmpty()) {
643         url = unreachableURL;
644         originalURL = unreachableURL;
645     } else {
646         url = documentLoader-&gt;url();
647         originalURL = documentLoader-&gt;originalURL();
648     }
649 
650     // Frames that have never successfully loaded any content
651     // may have no URL at all. Currently our history code can&#39;t
652     // deal with such things, so we nip that in the bud here.
653     // Later we may want to learn to live with nil for URL.
654     // See bug 3368236 and related bugs for more information.
655     if (url.isEmpty())
656         url = WTF::blankURL();
657     if (originalURL.isEmpty())
658         originalURL = WTF::blankURL();
659 
660     StringWithDirection title = documentLoader-&gt;title();
661 
662     item.setURL(url);
663     item.setTarget(m_frame.tree().uniqueName());
664     // FIXME: Should store the title direction as well.
665     item.setTitle(title.string);
666     item.setOriginalURLString(originalURL.string());
667 
668     if (!unreachableURL.isEmpty() || documentLoader-&gt;response().httpStatusCode() &gt;= 400)
669         item.setLastVisitWasFailure(true);
670 
671     item.setShouldOpenExternalURLsPolicy(documentLoader-&gt;shouldOpenExternalURLsPolicyToPropagate());
672 
673     // Save form state if this is a POST
674     item.setFormInfoFromRequest(documentLoader-&gt;request());
675 }
676 
677 Ref&lt;HistoryItem&gt; HistoryController::createItem()
678 {
679     Ref&lt;HistoryItem&gt; item = HistoryItem::create();
680     initializeItem(item);
681 
682     // Set the item for which we will save document state
683     setCurrentItem(item);
684 
685     return item;
686 }
687 
688 Ref&lt;HistoryItem&gt; HistoryController::createItemTree(Frame&amp; targetFrame, bool clipAtTarget)
689 {
690     Ref&lt;HistoryItem&gt; bfItem = createItem();
691     if (!m_frameLoadComplete)
692         saveScrollPositionAndViewStateToItem(m_previousItem.get());
693 
694     if (!clipAtTarget || &amp;m_frame != &amp;targetFrame) {
695         // save frame state for items that aren&#39;t loading (khtml doesn&#39;t save those)
696         saveDocumentState();
697 
698         // clipAtTarget is false for navigations within the same document, so
699         // we should copy the documentSequenceNumber over to the newly create
700         // item.  Non-target items are just clones, and they should therefore
701         // preserve the same itemSequenceNumber.
702         if (m_previousItem) {
703             if (&amp;m_frame != &amp;targetFrame)
704                 bfItem-&gt;setItemSequenceNumber(m_previousItem-&gt;itemSequenceNumber());
705             bfItem-&gt;setDocumentSequenceNumber(m_previousItem-&gt;documentSequenceNumber());
706         }
707 
708         for (Frame* child = m_frame.tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
709             FrameLoader&amp; childLoader = child-&gt;loader();
710             bool hasChildLoaded = childLoader.frameHasLoaded();
711 
712             // If the child is a frame corresponding to an &lt;object&gt; element that never loaded,
713             // we don&#39;t want to create a history item, because that causes fallback content
714             // to be ignored on reload.
715 
716             if (!(!hasChildLoaded &amp;&amp; childLoader.isHostedByObjectElement()))
717                 bfItem-&gt;addChildItem(childLoader.history().createItemTree(targetFrame, clipAtTarget));
718         }
719     }
720     // FIXME: Eliminate the isTargetItem flag in favor of itemSequenceNumber.
721     if (&amp;m_frame == &amp;targetFrame)
722         bfItem-&gt;setIsTargetItem(true);
723     return bfItem;
724 }
725 
726 // The general idea here is to traverse the frame tree and the item tree in parallel,
727 // tracking whether each frame already has the content the item requests.  If there is
728 // a match, we set the provisional item and recurse.  Otherwise we will reload that
729 // frame and all its kids in recursiveGoToItem.
730 void HistoryController::recursiveSetProvisionalItem(HistoryItem&amp; item, HistoryItem* fromItem)
731 {
732     if (!itemsAreClones(item, fromItem))
733         return;
734 
735     // Set provisional item, which will be committed in recursiveUpdateForCommit.
736     m_provisionalItem = &amp;item;
737 
738     for (auto&amp; childItem : item.children()) {
739         const String&amp; childFrameName = childItem-&gt;target();
740 
741         HistoryItem* fromChildItem = fromItem-&gt;childItemWithTarget(childFrameName);
742         ASSERT(fromChildItem);
743         Frame* childFrame = m_frame.tree().child(childFrameName);
744         ASSERT(childFrame);
745 
746         childFrame-&gt;loader().history().recursiveSetProvisionalItem(childItem, fromChildItem);
747     }
748 }
749 
750 // We now traverse the frame tree and item tree a second time, loading frames that
751 // do have the content the item requests.
752 void HistoryController::recursiveGoToItem(HistoryItem&amp; item, HistoryItem* fromItem, FrameLoadType type, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
753 {
754     if (!itemsAreClones(item, fromItem)) {
755         m_frame.loader().loadItem(item, fromItem, type, shouldTreatAsContinuingLoad);
756         return;
757     }
758 
759     // Just iterate over the rest, looking for frames to navigate.
760     for (auto&amp; childItem : item.children()) {
761         const String&amp; childFrameName = childItem-&gt;target();
762 
763         HistoryItem* fromChildItem = fromItem-&gt;childItemWithTarget(childFrameName);
764         ASSERT(fromChildItem);
765         if (Frame* childFrame = m_frame.tree().child(childFrameName))
766             childFrame-&gt;loader().history().recursiveGoToItem(childItem, fromChildItem, type, shouldTreatAsContinuingLoad);
767     }
768 }
769 
770 // The following logic must be kept in sync with WebKit::WebBackForwardListItem::itemIsClone().
771 bool HistoryController::itemsAreClones(HistoryItem&amp; item1, HistoryItem* item2) const
772 {
773     // If the item we&#39;re going to is a clone of the item we&#39;re at, then we do
774     // not need to load it again.  The current frame tree and the frame tree
775     // snapshot in the item have to match.
776     // Note: Some clients treat a navigation to the current history item as
777     // a reload.  Thus, if item1 and item2 are the same, we need to create a
778     // new document and should not consider them clones.
779     // (See http://webkit.org/b/35532 for details.)
780     return item2
781         &amp;&amp; &amp;item1 != item2
782         &amp;&amp; item1.itemSequenceNumber() == item2-&gt;itemSequenceNumber()
783         &amp;&amp; currentFramesMatchItem(item1)
784         &amp;&amp; item2-&gt;hasSameFrames(item1);
785 }
786 
787 // Helper method that determines whether the current frame tree matches given history item&#39;s.
788 bool HistoryController::currentFramesMatchItem(HistoryItem&amp; item) const
789 {
790     if ((!m_frame.tree().uniqueName().isEmpty() || !item.target().isEmpty()) &amp;&amp; m_frame.tree().uniqueName() != item.target())
791         return false;
792 
793     const auto&amp; childItems = item.children();
794     if (childItems.size() != m_frame.tree().childCount())
795         return false;
796 
797     for (auto&amp; item : childItems) {
798         if (!m_frame.tree().child(item-&gt;target()))
799             return false;
800     }
801 
802     return true;
803 }
804 
805 void HistoryController::updateBackForwardListClippedAtTarget(bool doClip)
806 {
807     // In the case of saving state about a page with frames, we store a tree of items that mirrors the frame tree.
808     // The item that was the target of the user&#39;s navigation is designated as the &quot;targetItem&quot;.
809     // When this function is called with doClip=true we&#39;re able to create the whole tree except for the target&#39;s children,
810     // which will be loaded in the future. That part of the tree will be filled out as the child loads are committed.
811 
812     Page* page = m_frame.page();
813     if (!page)
814         return;
815 
816     if (m_frame.loader().documentLoader()-&gt;urlForHistory().isEmpty())
817         return;
818 
819     FrameLoader&amp; frameLoader = m_frame.mainFrame().loader();
820 
821     Ref&lt;HistoryItem&gt; topItem = frameLoader.history().createItemTree(m_frame, doClip);
822     LOG(History, &quot;HistoryController %p updateBackForwardListClippedAtTarget: Adding backforward item %p in frame %p (main frame %d) %s&quot;, this, topItem.ptr(), &amp;m_frame, m_frame.isMainFrame(), m_frame.loader().documentLoader()-&gt;url().string().utf8().data());
823 
824     page-&gt;backForward().addItem(WTFMove(topItem));
825 }
826 
827 void HistoryController::updateCurrentItem()
828 {
829     if (!m_currentItem)
830         return;
831 
832     DocumentLoader* documentLoader = m_frame.loader().documentLoader();
833 
834     if (!documentLoader-&gt;unreachableURL().isEmpty())
835         return;
836 
837     if (m_currentItem-&gt;url() != documentLoader-&gt;url()) {
838         // We ended up on a completely different URL this time, so the HistoryItem
839         // needs to be re-initialized.  Preserve the isTargetItem flag as it is a
840         // property of how this HistoryItem was originally created and is not
841         // dependent on the document.
842         bool isTargetItem = m_currentItem-&gt;isTargetItem();
843         m_currentItem-&gt;reset();
844         initializeItem(*m_currentItem);
845         m_currentItem-&gt;setIsTargetItem(isTargetItem);
846     } else {
847         // Even if the final URL didn&#39;t change, the form data may have changed.
848         m_currentItem-&gt;setFormInfoFromRequest(documentLoader-&gt;request());
849     }
850 }
851 
852 void HistoryController::pushState(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject, const String&amp; title, const String&amp; urlString)
853 {
854     if (!m_currentItem)
855         return;
856 
857     Page* page = m_frame.page();
858     ASSERT(page);
859 
860     bool shouldRestoreScrollPosition = m_currentItem-&gt;shouldRestoreScrollPosition();
861 
862     // Get a HistoryItem tree for the current frame tree.
863     Ref&lt;HistoryItem&gt; topItem = m_frame.mainFrame().loader().history().createItemTree(m_frame, false);
864 
865     // Override data in the current item (created by createItemTree) to reflect
866     // the pushState() arguments.
867     m_currentItem-&gt;setTitle(title);
868     m_currentItem-&gt;setStateObject(WTFMove(stateObject));
869     m_currentItem-&gt;setURLString(urlString);
870     m_currentItem-&gt;setShouldRestoreScrollPosition(shouldRestoreScrollPosition);
871 
872     LOG(History, &quot;HistoryController %p pushState: Adding top item %p, setting url of current item %p to %s, scrollRestoration is %s&quot;, this, topItem.ptr(), m_currentItem.get(), urlString.ascii().data(), topItem-&gt;shouldRestoreScrollPosition() ? &quot;auto&quot; : &quot;manual&quot;);
873 
874     page-&gt;backForward().addItem(WTFMove(topItem));
875 
876     if (m_frame.page()-&gt;usesEphemeralSession())
877         return;
878 
879     addVisitedLink(*page, URL({ }, urlString));
880     m_frame.loader().client().updateGlobalHistory();
881 }
882 
883 void HistoryController::replaceState(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject, const String&amp; title, const String&amp; urlString)
884 {
885     if (!m_currentItem)
886         return;
887 
888     LOG(History, &quot;HistoryController %p replaceState: Setting url of current item %p to %s scrollRestoration %s&quot;, this, m_currentItem.get(), urlString.ascii().data(), m_currentItem-&gt;shouldRestoreScrollPosition() ? &quot;auto&quot; : &quot;manual&quot;);
889 
890     if (!urlString.isEmpty())
891         m_currentItem-&gt;setURLString(urlString);
892     m_currentItem-&gt;setTitle(title);
893     m_currentItem-&gt;setStateObject(WTFMove(stateObject));
894     m_currentItem-&gt;setFormData(nullptr);
895     m_currentItem-&gt;setFormContentType(String());
896 
897     ASSERT(m_frame.page());
898     if (m_frame.page()-&gt;usesEphemeralSession())
899         return;
900 
901     addVisitedLink(*m_frame.page(), URL({ }, urlString));
902     m_frame.loader().client().updateGlobalHistory();
903 }
904 
905 void HistoryController::replaceCurrentItem(HistoryItem* item)
906 {
907     if (!item)
908         return;
909 
910     m_previousItem = nullptr;
911     if (m_provisionalItem)
912         m_provisionalItem = item;
913     else
914         m_currentItem = item;
915 }
916 
917 } // namespace WebCore
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
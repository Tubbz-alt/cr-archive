<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GlyphBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006, 2009, 2011, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2007-2008 Torch Mobile Inc.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;FloatSize.h&quot;
 33 #include &quot;Glyph.h&quot;
 34 #include &lt;climits&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 #if USE(CG)
 38 #include &lt;CoreGraphics/CGGeometry.h&gt;
 39 #endif
 40 
 41 namespace WebCore {
 42 
 43 class Font;
 44 
 45 #if USE(WINGDI)
 46 typedef wchar_t GlyphBufferGlyph;
 47 #elif PLATFORM(JAVA)
 48 typedef jint GlyphBufferGlyph;
 49 #else
 50 typedef Glyph GlyphBufferGlyph;
 51 #endif
 52 
 53 // CG uses CGSize instead of FloatSize so that the result of advances()
 54 // can be passed directly to CGContextShowGlyphsWithAdvances in FontMac.mm
 55 #if USE(CG)
 56 struct GlyphBufferAdvance : CGSize {
 57 public:
 58     GlyphBufferAdvance() : CGSize(CGSizeZero) { }
 59     GlyphBufferAdvance(CGSize size)
 60         : CGSize(size)
 61     {
 62     }
 63     GlyphBufferAdvance(float width, float height)
 64         : CGSize(CGSizeMake(width, height))
 65     {
 66     }
 67 
<a name="1" id="anc1"></a><span class="line-added"> 68     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;</span>
<span class="line-added"> 69     template&lt;class Decoder&gt; static Optional&lt;GlyphBufferAdvance&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 70 </span>
 71     void setWidth(CGFloat width) { this-&gt;CGSize::width = width; }
 72     void setHeight(CGFloat height) { this-&gt;CGSize::height = height; }
 73     CGFloat width() const { return this-&gt;CGSize::width; }
 74     CGFloat height() const { return this-&gt;CGSize::height; }
 75 };
<a name="2" id="anc2"></a><span class="line-added"> 76 </span>
<span class="line-added"> 77 template&lt;class Encoder&gt;</span>
<span class="line-added"> 78 void GlyphBufferAdvance::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 79 {</span>
<span class="line-added"> 80     encoder &lt;&lt; width();</span>
<span class="line-added"> 81     encoder &lt;&lt; height();</span>
<span class="line-added"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 template&lt;class Decoder&gt;</span>
<span class="line-added"> 85 Optional&lt;GlyphBufferAdvance&gt; GlyphBufferAdvance::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 86 {</span>
<span class="line-added"> 87     Optional&lt;CGFloat&gt; width;</span>
<span class="line-added"> 88     decoder &gt;&gt; width;</span>
<span class="line-added"> 89     if (!width)</span>
<span class="line-added"> 90         return WTF::nullopt;</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     Optional&lt;CGFloat&gt; height;</span>
<span class="line-added"> 93     decoder &gt;&gt; height;</span>
<span class="line-added"> 94     if (!height)</span>
<span class="line-added"> 95         return WTF::nullopt;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     return GlyphBufferAdvance(CGSizeMake(*width, *height));</span>
<span class="line-added"> 98 }</span>
 99 #else
100 typedef FloatSize GlyphBufferAdvance;
101 #endif
102 
<a name="3" id="anc3"></a><span class="line-added">103 inline FloatSize toFloatSize(const GlyphBufferAdvance&amp; a)</span>
<span class="line-added">104 {</span>
<span class="line-added">105     return FloatSize(a.width(), a.height());</span>
<span class="line-added">106 }</span>
<span class="line-added">107 </span>
108 class GlyphBuffer {
109 public:
<a name="4" id="anc4"></a><span class="line-modified">110     bool isEmpty() const { return m_fonts.isEmpty(); }</span>
<span class="line-modified">111     unsigned size() const { return m_fonts.size(); }</span>
112 
113     void clear()
114     {
<a name="5" id="anc5"></a><span class="line-modified">115         m_fonts.clear();</span>
116         m_glyphs.clear();
117         m_advances.clear();
118         if (m_offsetsInString)
119             m_offsetsInString-&gt;clear();
120     }
121 
122     GlyphBufferGlyph* glyphs(unsigned from) { return m_glyphs.data() + from; }
123     GlyphBufferAdvance* advances(unsigned from) { return m_advances.data() + from; }
124     const GlyphBufferGlyph* glyphs(unsigned from) const { return m_glyphs.data() + from; }
125     const GlyphBufferAdvance* advances(unsigned from) const { return m_advances.data() + from; }
<a name="6" id="anc6"></a>
126 
<a name="7" id="anc7"></a><span class="line-modified">127     const Font* fontAt(unsigned index) const { return m_fonts[index]; }</span>
128 
129     void setInitialAdvance(GlyphBufferAdvance initialAdvance) { m_initialAdvance = initialAdvance; }
130     const GlyphBufferAdvance&amp; initialAdvance() const { return m_initialAdvance; }
131 
132     Glyph glyphAt(unsigned index) const
133     {
134         return m_glyphs[index];
135     }
136 
137     GlyphBufferAdvance advanceAt(unsigned index) const
138     {
139         return m_advances[index];
140     }
141 
142     static const unsigned noOffset = UINT_MAX;
143     void add(Glyph glyph, const Font* font, float width, unsigned offsetInString = noOffset)
144     {
145         GlyphBufferAdvance advance;
146         advance.setWidth(width);
147         advance.setHeight(0);
148 
149         add(glyph, font, advance, offsetInString);
150     }
151 
152     void add(Glyph glyph, const Font* font, GlyphBufferAdvance advance, unsigned offsetInString)
153     {
<a name="8" id="anc8"></a><span class="line-modified">154         m_fonts.append(font);</span>
155         m_glyphs.append(glyph);
156 
157         m_advances.append(advance);
158 
159         if (offsetInString != noOffset &amp;&amp; m_offsetsInString)
160             m_offsetsInString-&gt;append(offsetInString);
161     }
162 
<a name="9" id="anc9"></a><span class="line-added">163     void remove(unsigned location, unsigned length)</span>
<span class="line-added">164     {</span>
<span class="line-added">165         m_fonts.remove(location, length);</span>
<span class="line-added">166         m_glyphs.remove(location, length);</span>
<span class="line-added">167         m_advances.remove(location, length);</span>
<span class="line-added">168         if (m_offsetsInString)</span>
<span class="line-added">169             m_offsetsInString-&gt;remove(location, length);</span>
<span class="line-added">170     }</span>
<span class="line-added">171 </span>
<span class="line-added">172     void makeHole(unsigned location, unsigned length, const Font* font)</span>
<span class="line-added">173     {</span>
<span class="line-added">174         ASSERT(location &lt;= size());</span>
<span class="line-added">175 </span>
<span class="line-added">176         m_fonts.insertVector(location, Vector&lt;const Font*&gt;(length, font));</span>
<span class="line-added">177         m_glyphs.insertVector(location, Vector&lt;GlyphBufferGlyph&gt;(length, 0xFFFF));</span>
<span class="line-added">178         m_advances.insertVector(location, Vector&lt;GlyphBufferAdvance&gt;(length, GlyphBufferAdvance(0, 0)));</span>
<span class="line-added">179         if (m_offsetsInString)</span>
<span class="line-added">180             m_offsetsInString-&gt;insertVector(location, Vector&lt;unsigned&gt;(length, 0));</span>
<span class="line-added">181     }</span>
<span class="line-added">182 </span>
183     void reverse(unsigned from, unsigned length)
184     {
185         for (unsigned i = from, end = from + length - 1; i &lt; end; ++i, --end)
186             swap(i, end);
187     }
188 
189     void expandLastAdvance(float width)
190     {
191         ASSERT(!isEmpty());
192         GlyphBufferAdvance&amp; lastAdvance = m_advances.last();
193         lastAdvance.setWidth(lastAdvance.width() + width);
194     }
195 
196     void expandLastAdvance(GlyphBufferAdvance expansion)
197     {
198         ASSERT(!isEmpty());
199         GlyphBufferAdvance&amp; lastAdvance = m_advances.last();
200         lastAdvance.setWidth(lastAdvance.width() + expansion.width());
201         lastAdvance.setHeight(lastAdvance.height() + expansion.height());
202     }
203 
204     void saveOffsetsInString()
205     {
206         m_offsetsInString.reset(new Vector&lt;unsigned, 2048&gt;());
207     }
208 
209     int offsetInString(unsigned index) const
210     {
211         ASSERT(m_offsetsInString);
212         return (*m_offsetsInString)[index];
213     }
214 
215     void shrink(unsigned truncationPoint)
216     {
<a name="10" id="anc10"></a><span class="line-modified">217         m_fonts.shrink(truncationPoint);</span>
218         m_glyphs.shrink(truncationPoint);
219         m_advances.shrink(truncationPoint);
220         if (m_offsetsInString)
221             m_offsetsInString-&gt;shrink(truncationPoint);
222     }
223 
224 private:
225     void swap(unsigned index1, unsigned index2)
226     {
<a name="11" id="anc11"></a><span class="line-modified">227         const Font* f = m_fonts[index1];</span>
<span class="line-modified">228         m_fonts[index1] = m_fonts[index2];</span>
<span class="line-modified">229         m_fonts[index2] = f;</span>
230 
231         GlyphBufferGlyph g = m_glyphs[index1];
232         m_glyphs[index1] = m_glyphs[index2];
233         m_glyphs[index2] = g;
234 
235         GlyphBufferAdvance s = m_advances[index1];
236         m_advances[index1] = m_advances[index2];
237         m_advances[index2] = s;
238     }
239 
<a name="12" id="anc12"></a><span class="line-modified">240     Vector&lt;const Font*, 2048&gt; m_fonts;</span>
241     Vector&lt;GlyphBufferGlyph, 2048&gt; m_glyphs;
242     Vector&lt;GlyphBufferAdvance, 2048&gt; m_advances;
243     GlyphBufferAdvance m_initialAdvance;
244     std::unique_ptr&lt;Vector&lt;unsigned, 2048&gt;&gt; m_offsetsInString;
245 };
246 
247 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>